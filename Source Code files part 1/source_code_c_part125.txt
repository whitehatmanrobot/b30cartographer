       FILE_OPEN_IF, // Create Disposition
                                0, // No Share Access 
                                FILE_READ_DATA|FILE_WRITE_DATA|SYNCHRONIZE, // DesiredAccess
                                NULL, // Continuation
                                NULL, // Continuation Context
                                FALSE
                            );

            Status = GetLastErrorLocal();
            CscBmpKdPrint(
                READWRITE,
                ("CscBmpWrite status of (create if not existing) CreateFile %u\n",
                Status));

        if (miniFileObj != NULL) {
            CscBmpKdPrint(
                READWRITE,
                ("CscBmpWrite create new invalid bitmap %s\n",
                strmFname));
            }
        }

        if (miniFileObj == NULL) {
            CscBmpKdPrint(
                BADERRORS,
                ("CscBmpWrite: Can't read/create bitmap %s\n",
                strmFname));
            goto DONE;
        }

        if (lpbitmap && !(lpbitmap->valid)) {
            corruptBmpFile = TRUE;
            goto WRITEHDR;
        }

        if (!corruptBmpFile) {
            // Read the header
            Nt5CscReadWriteFileEx(
                R0_READFILE,
                (CSCHFILE)miniFileObj,
                0, // pos
                &hdr,
                sizeof(CscBmpFileHdr),
                0, // Flags
                &ioStatusBlock);

            if (ioStatusBlock.Status != STATUS_SUCCESS) {
                CscBmpKdPrint(
                    READWRITE,
                    ("CscBmpWrite: Can't read header from bitmap file %s, Status\n",
                    strmFname, ioStatusBlock.Status));
                corruptBmpFile = TRUE;
            } else if (ioStatusBlock.Information < sizeof(CscBmpFileHdr)) {
                CscBmpKdPrint(
                    READWRITE,
                    ("CscBmpWrite: Can't read the whole header from %s,\n",
                    strmFname));
                CscBmpKdPrint(READWRITE,
                    ("\tAssume corrupt bitmap file\n"));
                corruptBmpFile = TRUE;
            } else if (hdr.magicnum != MAGICNUM) {
                CscBmpKdPrint(
                    READWRITE,
                    ("CscBmpWrite: Magic Number don't match\n"));
                corruptBmpFile = TRUE;
            } else if (!hdr.valid) {
                CscBmpKdPrint(
                    READWRITE,
                    ("CscBmpWrite: Bitmap %s marked invalid\n",
                    strmFname));
                corruptBmpFile = TRUE;
            }
        } // if (!corruptBmpFile)

WRITEHDR:
        // Write Header back to file, indicating
        // new sizes, not in use, and if corruptBmpFile, invalid.
        CscBmpKdPrint(
            READWRITE,
            ("CscBmpWrite: Writing back hdr to %s\n",strmFname));
        hdr.magicnum = MAGICNUM;
        hdr.inuse = (BYTE)FALSE;
        if (!corruptBmpFile && lpbitmap) {
            CscBmpAcquireFastMutex(lpbitmap);
            hdr.sizeinbits = lpbitmap->bitmapsize;
            hdr.numDWORDs = lpbitmap->numDWORD;
            bmpByteSize = lpbitmap->numDWORD * sizeof(DWORD);
            if (bmpByteSize > 0) {
                bmpBuf = RxAllocatePool(NonPagedPool,
                bmpByteSize);
                if (!bmpBuf) {
                    CscBmpKdPrint(
                        BADERRORS,
                        ("CscBmpWrite: Error allocating buffer for writing bitmap to disk\n"));
                    corruptBmpFile = TRUE;
                } else {
                    RtlCopyMemory(bmpBuf, lpbitmap->bitmap, bmpByteSize);
                }
            }
            CscBmpReleaseFastMutex(lpbitmap);
        } else {
            hdr.sizeinbits = 0;
            hdr.numDWORDs = 0;
            corruptBmpFile = TRUE;
        }

        // Write bitmap body first, if needed
        if (!corruptBmpFile && lpbitmap && bmpBuf) {
            Nt5CscReadWriteFileEx(
                R0_WRITEFILE,
                (CSCHFILE)miniFileObj,
                sizeof(hdr), // pos
                bmpBuf,
                bmpByteSize,
                0, // Flags
                &ioStatusBlock);
            if (ioStatusBlock.Status != STATUS_SUCCESS) {
                CscBmpKdPrint(
                    BADERRORS,
                    ("CscBmpWrite: Error writing back bitmap to %s\n",
                    strmFname));
                corruptBmpFile = TRUE;
            } else if (ioStatusBlock.Information < bmpByteSize) {
                CscBmpKdPrint(
                    BADERRORS,
                    ("CscBmpWrite: bitmap size %u written to %s is incorrect\n",
                    bmpByteSize, strmFname));
                corruptBmpFile = TRUE;
            }
        }

        // Then write header, indicating if anything invalid
        hdr.valid = (BYTE)!corruptBmpFile;
        IF_DEBUG {
            if (corruptBmpFile)
                CscBmpKdPrint(
                    READWRITE,
                    ("CscBmpWrite: On disk bitmap %s invalid\n",
                    strmFname));
        }
        Nt5CscReadWriteFileEx(
            R0_WRITEFILE,
            (CSCHFILE)miniFileObj,
            0, // pos
            &hdr,
            sizeof(hdr),
            0, // Flags
            &ioStatusBlock);
        if (ioStatusBlock.Status != STATUS_SUCCESS) {
            CscBmpKdPrint(
                BADERRORS,
                ("CscBmpWrite: Error writing back hdr file to %s\n",
                strmFname));
            corruptBmpFile = TRUE;
        } else if (ioStatusBlock.Information < sizeof(hdr)) {
            CscBmpKdPrint(
                BADERRORS,
            ("CscBmpWrite: hdr size written to %s is incorrect\n",
            strmFname));
        corruptBmpFile = TRUE;
        }

        // Close miniFileObj
        CloseFileLocal((CSCHFILE)miniFileObj);

    DONE:
        NOTHING;
    } finally {
        if (bmpBuf != NULL) {
            RxFreePool(bmpBuf);
        }
    }

    CscBmpKdPrint(
        READWRITE,
        ("--------------CscBmpWrite exit 0x%x\n", iRet));

    return iRet; // to be implemented for kernel mode
}

#endif // BITCOPY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\hook.h ===
#define  MAX_SHADOW_DIR_NAME  16 // maximum string size of shadow directory

// Stolen from IFSMgr code
#define  MAX_SERVER_SHARE  (31+63+2)


/********************** Type definitions for subclassed network objects ****/

typedef struct      tagRESOURCE     *PRESOURCE;
typedef struct      tagFINDINFO     *PFINDINFO;
typedef struct      tagFILEINFO     *PFILEINFO;
typedef struct      tagFDB *PFDB,   **PPFDB;
typedef struct      tagELEM         *PELEM;
typedef PELEM       *PPELEM;
typedef PRESOURCE   *PPRESOURCE;
typedef struct      tagFINDSHADOW   FINDSHADOW;
typedef FINDSHADOW  *LPFINDSHADOW;


/******** Netowrk provider *********/

typedef struct tagNETPRO
{
    PRESOURCE   pheadResource;
    pIFSFunc    pOurConnectNet;
    pIFSFunc    pConnectNet;      // Providers connection function
} NETPRO, DISKPRO, *PNETPRO, *PDISKPRO;


/************ Resource AKA Volume AKA share *****/

typedef struct tagRESOURCE
{
    PRESOURCE   pnextResource;
    PFILEINFO   pheadFileInfo;     // list of file I/O calls on this resource
    PFINDINFO   pheadFindInfo;     // list of finds on this resource
    PFDB        pheadFdb;            // List of files being shadowed
    HSHARE     hShare;             // Handle to the server shadow
    HSHADOW     hRoot;                // Handle to the root
    USHORT      usFlags;
    USHORT      usLocalFlags;
    PNETPRO     pOurNetPro;
    rh_t        rhPro;              // Providers resource handle;
    fh_t        fhSys;              // System resource handle
    vfunc_t     pVolTab;            // Pointer to volume functions structure
    int         cntLocks;      // Count of locks on this resource
    ULONG uDriveMap;         // Drive map for this resource
    PathElement pp_elements[1];
} RESOURCE, *PRESOURCE;


/********* per open file handle ****/

typedef struct tagFILEINFO
{
    PFILEINFO    pnextFileInfo; // Next FileInfo
    PRESOURCE    pResource;      // Resource off which it is hanging
    CSCHFILE     hfShadow;        // Shadow file handle
    PFDB         pFdb;             // Info of Shadow File
    fh_t         fhProFile;      // providers file handle
    hndlfunc     hfFileHandle;  // providers file function table
    UCHAR  uchAccess;  // Acess-share flags for this open
    UCHAR  uchDummy;
    USHORT usFlags;
    USHORT usLocalFlags;
    ULONG  cbTotalRead;
    sfn_t         sfnFile;
    pid_t         pidFile;
    uid_t         userFile;
} FILEINFO, *PFILEINFO;


/////////////////////////////////////////////////////////


/**** FileDescriptionBlock. Common info for all open instances of a file**/
typedef struct tagFDB
{
    // I M P O R T A N T :  the NT code for PFindFdbFromHshadow returns a PFDB
    //         but this pointer must not be used to get/put any field except usFlags!

    PFDB              pnextFdb;  // Link to the next
    PRESOURCE        pResource;          // Back pointer to our resource
    USHORT 	usFlags;     //
    USHORT 	usCount;        // Open Count
    ULONG  	hShadow;             // Shadow handle if any
    ULONG  	hDir;
    ULONG  	dwFileSize;         // file size when first opened
    dos_time         dosFileTime;
    ULONG  	dwAttr;
    USHORT 	cntLocks;        // Total outstanding locks
    USHORT 	usLocalFlags;
	ULONG	dwRemoteFileSize;	// size of the file when first created, used in the heuristic
    ParsedPath      sppathRemoteFile;     // Parsed Path of the file
} FDB, *PFDB;



typedef struct tagOTHERINFO
{
    ULONG       ulRefPri;
    union
    {
        ULONG   ulIHPri;
        ULONG   ulRootStatus;
    };
    ULONG       ulHintFlags;
    ULONG       ulHintPri;
    HSHADOW     hShadowOrg;
    FILETIME    ftOrgTime;
    FILETIME    ftLastRefreshTime;

} OTHERINFO, *LPOTHERINFO;

typedef  int (PUBLIC *METAMATCHPROC)(LPFIND32, HSHADOW, HSHADOW, ULONG, LPOTHERINFO, LPVOID);

#define  MM_RET_FOUND_CONTINUE    2
#define  MM_RET_CONTINUE            1
#define  MM_RET_FOUND_BREAK        0
#define  MM_RET_BREAK                -1

typedef  struct    tagFINDSHADOW
{
    LPFINDSHADOW    lpFSHNext;
    ULONG           ulFlags;
    HSHADOW         hDir;
    ULONG           ulCookie;
    ULONG           uAttrib;
    ULONG           uSrchFlags;
    USHORT          *lpPattern;
    METAMATCHPROC   lpfnMMProc;
} FINDSHADOW, *LPFINDSHADOW;

typedef struct tagSHADOWCHECK
{
    USHORT  uFlagsIn;
    USHORT  uFlagsOut;
    ULONG   ulCookie;
    USHORT  *lpuName;
    USHORT  *lpuType;
    HSHADOW hShadow;
    ULONG   uStatus;
    ULONG   ulHintFlags;
    ULONG   ulHintPri;
#ifdef MAYBE
    OTHERINFO    sOI;
#endif //MAYBE
} SHADOWCHECK, *LPSHADOWCHECK;

#define  FLAG_OUT_SHADOWCHECK_FOUND      0x1


#define  FLAG_IN_SHADOWCHECK_EXCLUDE        0x0001
#define  FLAG_IN_SHADOWCHECK_NAME            0x0002
#define  FLAG_IN_SHADOWCHECK_SUBTREE        0x0004
#define  FLAG_IN_SHADOWCHECK_IGNOREHINTS  0x0008
/*************** Our version of the find handle (VfnFindOpen)******/

typedef struct tagFINDINFO
{
    PFINDINFO    pnextFindInfo; // Next FindInfo
    PRESOURCE    pResource;      // Resource off which it is hanging
    fh_t          fhProFind;      // providers find handle
    hndlfunc     hfFindHandle;  // providers find function table
    USHORT usFlags;
    USHORT usLocalFlags;
    HSHADOW      hDir;             // Directory in which the search is going on
    FINDSHADOW  sFS;
    PathElement pe_pattern[1];  // Search pattern in case of wildcard search
} FINDINFO, *PFINDINFO;

/************ Generic linked list element ****************/
typedef struct tagELEM
{
    PELEM pnextElem;
} ELEM;



/********************* Flag definitions ************************************/

/** Flags set in usLocalFlags field of FDB (FileDescriptionBlock) **/

#define FLAG_FDB_SERIALIZE                  0x0001
#define FLAG_FDB_INUSE_BY_AGENT             0x0002
#define FLAG_FDB_SHADOW_MODIFIED            0x0008
#define FLAG_FDB_DONT_SHADOW                0x0010
#define FLAG_FDB_FINAL_CLOSE_DONE           0x0020
#define FLAG_FDB_DISABLE_AGENT			    0x0040
#define FLAG_FDB_ON_CACHEABLE_SHARE         0x0080
#define FLAG_FDB_SHADOW_SNAPSHOTTED         0x0100
#define FLAG_FDB_DELETE_ON_CLOSE            0x0200  // on NT we mark this file for delete after close

/** Flags set in usLocalFlags field of FILEINFO **/

#define FLAG_FILEINFO_INUSE_BY_AGENT      0x0002
#define FLAG_FILEINFO_DUP_HANDLE            0x2000    // Duplicate handle
#define FLAG_FILEINFO_INVALID_HANDLE      0x4000
#define FLAG_FILEINFO_INTERNAL_HANDLE     0x8000    // Handle created for internal find


/** Flags set in usLocalFlags field of FINDINFO **/

#define FLAG_FINDINFO_SHADOWFIND            0x0001    // Shadow find is in progress
#define FLAG_FINDINFO_INVALID_HANDLE      0x4000
#define FLAG_FINDINFO_INTERNAL_HANDLE     0x8000    // Handle created for internal find


/** Flags set on RESOURCE ***/

#define FLAG_RESOURCE_DISCONNECTED              SHARE_DISCONNECTED_OP //0x8000
#define FLAG_RESOURCE_SHADOW_ERRORS             SHARE_ERRORS             // 0x4000
#define FLAG_RESOURCE_SHADOW_CONNECT_PENDING    0x2000
#define FLAG_RESOURCE_SHADOWNP                  SHARE_SHADOWNP            // 0x1000
#define FLAG_RESOURCE_SLOWLINK                  0x0800
#define FLAG_RESOURCE_OFFLINE_CONNECTION        0x0400
#define FLAG_RESOURCE_CSC_MASK                  0x00C0

// the following defines deal with the CSC bits as obtained from the server and
// as stored in the RESOURCE data structure

#define ResourceCscBitsToSmbCscBits(uResBits)       (((uResBits) & FLAG_RESOURCE_CSC_MASK) >> 4)
#define SmbCscBitsToResourceCscBits(uResBits)       (((uResBits) & SMB_NEW_CSC_MASK) << 4)
#define ResourceCscBitsToShareCscBits(uResBits)    ((uResBits) & FLAG_RESOURCE_CSC_MASK)

#define FLAG_RESOURCE_CSC_MANUAL_REINT      0x0000      // No automatic file by file reint
#define FLAG_RESOURCE_CSC_AUTO_REINT        0x0040      // File by file reint is OK
#define FLAG_RESOURCE_CSC_VDO               0x0080      // no need to flow opens
#define FLAG_RESOURCE_CSC_NO_CACHING        0x00C0      // client should not cache this share

/** Find types *****/

#define  FLAG_FINDSHADOW_META               0x0001  // wild card matching
#define  FLAG_FINDSHADOW_NEWSTYLE           0x0002  // NT stle matching
#define  FLAG_FINDSHADOW_ALLOW_NORMAL       0x0004  // include non-sparse, undeleted shadows
#define  FLAG_FINDSHADOW_ALLOW_SPARSE       0x0008  // include sparse shadows
#define  FLAG_FINDSHADOW_ALLOW_DELETED      0x0010  // include shadows marked deleted
#define  FLAG_FINDSHADOW_DONT_ALLOW_INSYNC  0x0020  // ??
#define  FLAG_FINDSHADOW_ALL                0x8000


/******* Findshadow flags ***********/

#define FLAG_FINDSHADOW_INVALID_DIRECTORY   0x0001  //

/************** Convenience macros ****************************/

#define mShadowErrors(pRes)                 (((PRESOURCE)(pRes))->usLocalFlags & FLAG_RESOURCE_SHADOW_ERRORS)
#define mShadowFindON(pFI)                  (((PFINDINFO)(pFI))->usLocalFlags & FLAG_FINDINFO_SHADOWFIND)
#define mSetShadowFindON(pFI)               (((PFINDINFO)(pFI))->usLocalFlags |= FLAG_FINDINFO_SHADOWFIND)
#define mResetShadowFindON(pFI)             (((PFINDINFO)(pFI))->usLocalFlags &= ~FLAG_FINDINFO_SHADOWFIND)
#define mSerialize(pFdb)                    ((pFdb)->usLocalFlags & (FLAG_FDB_SERIALIZE))
#define mSetSerialize(pFdb)                 ((pFdb)->usLocalFlags |= FLAG_FDB_SERIALIZE)
#define mClearSerialize(pFdb)               ((pFdb)->usLocalFlags &= ~FLAG_FDB_SERIALIZE)
#define mInvalidFileHandle(pFileInfo)       (((PFILEINFO)(pFileInfo))->usLocalFlags & FLAG_FILEINFO_INVALID_HANDLE)
#define mInvalidFindHandle(pFileInfo)       (((PFILEINFO)(pFileInfo))->usLocalFlags & FLAG_FINDINFO_INVALID_HANDLE)

#define mIsDisconnected(pResource)          (((PRESOURCE)(pResource))->usLocalFlags & FLAG_RESOURCE_DISCONNECTED)
#define mMarkDisconnected(pResource)        (((PRESOURCE)(pResource))->usLocalFlags |= FLAG_RESOURCE_DISCONNECTED)
#define mClearDisconnected(pResource)       (((PRESOURCE)(pResource))->usLocalFlags &= ~FLAG_RESOURCE_DISCONNECTED)
#define mIsOfflineConnection(pResource)     (((PRESOURCE)(pResource))->usLocalFlags & FLAG_RESOURCE_OFFLINE_CONNECTION)
#define mShadowConnectPending(pResource)    (((PRESOURCE)(pResource))->usLocalFlags & FLAG_RESOURCE_SHADOW_CONNECT_PENDING)
#define mClearDriveUse(pResource, drvno)    (((PRESOURCE)(pResource))->uDriveMap &= ~((1 << drvno)))
#define mSetDriveUse(pResource, drvno)      (((PRESOURCE)(pResource))->uDriveMap |= (1 << drvno))
#define mGetDriveUse(pResource, drvno)      (((PRESOURCE)(pResource))->uDriveMap & (1 << drvno))
#define mGetCSCBits(pRes)                   (((PRESOURCE)(pRes))->usLocalFlags & FLAG_RESOURCE_CSC_MASK)
#define mSetCSCBits(pRes, uBits)            ((((PRESOURCE)(pRes))->usLocalFlags &= ~FLAG_RESOURCE_CSC_MASK), (((PRESOURCE)(pRes))->usLocalFlags |= ((uBits) & FLAG_RESOURCE_CSC_MASK)))

#define mAutoReint(pRes)                    ((((PRESOURCE)(pRes))->usLocalFlags & FLAG_RESOURCE_CSC_MASK)==FLAG_RESOURCE_CSC_AUTO_REINT)
#define mNotCacheable(pRes)                 ((((PRESOURCE)(pRes))->usLocalFlags & FLAG_RESOURCE_CSC_MASK)==FLAG_RESOURCE_CSC_NO_CACHING)


#define ANY_RESOURCE        (void *)(0xFFFFFFFF)
#define ANY_FHID             (void *)(0xFFFFFFFF)
#define RH_DISCONNECTED    (void *)0
#define UseGlobalFind32()     {AssertInShadowCrit();memset(&vsFind32, 0, sizeof(vsFind32));}
#define EnterHookCrit()        Wait_Semaphore(semHook, BLOCK_SVC_INTS)
#define LeaveHookCrit()        Signal_Semaphore(semHook)
/*************************** Globals     ************************************/
/************************** Templates for exported functions ***************/

int GetDriveIndex(LPSTR lpDrive);
PFDB PFindFdbFromHShadow (HSHADOW hShadow);
int CopyChunk (HSHADOW, HSHADOW, PFILEINFO, COPYCHUNKCONTEXT *);
PRESOURCE  PFindShadowResourceFromDriveMap(int    indx);
PRESOURCE  PFindResource (LPPE lppeIn, rh_t rhPro, fh_t fhPro, ULONG uFlags, PNETPRO pNetPro);
PRESOURCE  PFindResourceFromHShare (HSHARE, USHORT, USHORT);
PRESOURCE  PFindResourceFromRoot (HSHADOW, USHORT, USHORT);
void LinkResource (PRESOURCE pResource, PNETPRO pNetPro);
PRESOURCE PUnlinkResource (PRESOURCE pResource, PNETPRO pNetPro);
PRESOURCE PCreateResource (LPPE lppeIn);
void DestroyResource (PRESOURCE pResource);
int PUBLIC FindOpenHSHADOW(LPFINDSHADOW, LPHSHADOW, LPFIND32, ULONG far *, LPOTHERINFO);
int PUBLIC FindNextHSHADOW(LPFINDSHADOW, LPHSHADOW, LPFIND32, ULONG far *, LPOTHERINFO);
int PUBLIC FindCloseHSHADOW(LPFINDSHADOW);

HSHARE
HShareFromPath(
    PRESOURCE   pResource,
    LPPE        lppeShare,
    ULONG       uFlags,
    LPFIND32    lpFind32,
    HSHADOW     *lphRoot,
    ULONG       *lpuShareStatus
    );

PFILEINFO    PFileInfoAgent(VOID);

BOOL IsDupHandle(PFILEINFO pFileInfo);
PFDB PFindFdbFromHShadow (HSHADOW);
PFINDINFO    PFindFindInfoFromHShadow(HSHADOW);

int FsobjMMProc(LPFIND32, HSHADOW, HSHADOW, ULONG, LPOTHERINFO, LPFINDSHADOW);
int GetShadowWithChecksProc (LPFIND32, HSHADOW, HSHADOW, ULONG, LPOTHERINFO, LPSHADOWCHECK);

/*  the fcb structures work very differently on NT/rdr2 from the shadow VxD.
     accordingly, we have to do things a bit differently. there are the following
     important considerations:

     1. after you find a PFDBfromHShadow, it will continue to be valid until you
         leavveshadowcrit. what we'll do is to return a pointer to the status as
         part of the lookup routine and we'll use the pointer to fetch/update the status.
         IMPORTANT>>>> what i do is to actually return a pointer so that the status is
         act the correct offset from the pointer. the pointer must not be used for anything
         else.

     2. i cannot continue to be in the shadow crit while looking up a netroot. accordingly,
         i'll have to drop the lock and reacquire it. so i get the status and the drive map at
         the same time and remember them for later.

*/


#ifndef CSC_RECORDMANAGER_WINNT
int ReportCreateDelete( HSHADOW  hShadow, BOOL fCreate);

#define SMB_NEW_CSC_MASK                        0x000C      // see below

#define SMB_NEW_CSC_CACHE_MANUAL_REINT          0x0000      // No automatic file by file reint
#define SMB_NEW_CSC_CACHE_AUTO_REINT            0x0004      // File by file reint is OK
#define SMB_NEW_CSC_CACHE_VDO                   0x0008      // no need to flow opens
#define SMB_NEW_CSC_NO_CACHING                  0x000C      // client should not cache this share

#define IFNOT_CSC_RECORDMANAGER_WINNT if(TRUE)
#define MRxSmbCscGetSavedResourceStatus() (0)
#define MRxSmbCscGetSavedResourceDriveMap() (0)
#define DeclareFindFromShadowOnNtVars()
#define PLocalFlagsFromPFdb(pFdb)  (&((pFdb)->usLocalFlags))
#else
//BUGBUG
//this comes from hook.c on win95
#define ReportCreateDelete(a,b) {NOTHING;}

#define IFNOT_CSC_RECORDMANAGER_WINNT if(FALSE)

#define DeclareFindFromShadowOnNtVars() \
          ULONG mrxsmbShareStatus,mrxsmbDriveMap;

#define PFindFindInfoFromHShadow(a) ((NULL))

PFDB MRxSmbCscFindFdbFromHShadow (
     IN HSHADOW hShadow
     );
#define PFindFdbFromHShadow(a)  MRxSmbCscFindFdbFromHShadow(a)

PRESOURCE  MRxSmbCscFindResourceFromHandlesWithModify (
     IN  HSHARE  hShare,
     IN  HSHADOW  hRoot,
     IN  USHORT usLocalFlagsIncl,
     IN  USHORT usLocalFlagsExcl,
     OUT PULONG ShareStatus,
     OUT PULONG DriveMap,
     IN  ULONG uStatus,
     IN  ULONG uOp
    );

USHORT  *
MRxSmbCscFindLocalFlagsFromFdb(
    PFDB    pFdb
    );


#define PFindResourceFromRoot(a,b,c) \
     MRxSmbCscFindResourceFromHandlesWithModify(0xffffffff,a,b,c,\
                                              &mrxsmbShareStatus, \
                                              &mrxsmbDriveMap,0,0xffffffff)
#define MRxSmbCscGetSavedResourceStatus() (mrxsmbShareStatus)
#define MRxSmbCscGetSavedResourceDriveMap() (mrxsmbDriveMap)

#define PFindResourceFromHShare(a,b,c) \
     MRxSmbCscFindResourceFromHandlesWithModify(a,0xffffffff,b,c,\
                                              &mrxsmbShareStatus, \
                                              &mrxsmbDriveMap,0,0xffffffff)
#define PSetResourceStatusFromHShare(a,b,c,d,e) \
     MRxSmbCscFindResourceFromHandlesWithModify(a,0xffffffff,b,c,\
                                              &mrxsmbShareStatus, \
                                              &mrxsmbDriveMap,d,e)
#define ClearAllResourcesOfShadowingState() \
     MRxSmbCscFindResourceFromHandlesWithModify(0xffffffff,0xffffffff,0,0,\
                                              NULL, \
                                              NULL,0,SHADOW_FLAGS_AND)

#define PLocalFlagsFromPFdb(a)  MRxSmbCscFindLocalFlagsFromFdb(a)

NTSTATUS
MRxSmbCscCachingBitsFromCompleteUNCPath(
    PWSTR   lpShareShare,
    ULONG   *lpulBits
    );

NTSTATUS
MRxSmbCscServerStateFromCompleteUNCPath(
    PWSTR   lpShareShare,
    BOOL    *lpfOnline,
    BOOL    *lpfPinnedOffline
    );

NTSTATUS
MRxSmbCscIsLoopbackServer(
    PWSTR   lpServerShare,
    BOOL    *lpfIsLoopBack);


#define SIGNALAGENTFLAG_CONTINUE_FOR_NO_AGENT 0x00000001
#define SIGNALAGENTFLAG_DONT_LEAVE_CRIT_SECT  0x00000002

extern NTSTATUS
MRxSmbCscSignalAgent (
    PRX_CONTEXT RxContext OPTIONAL,
    ULONG  Controls
    );

extern NTSTATUS
MRxSmbCscSignalFillAgent (
    PRX_CONTEXT RxContext OPTIONAL,
    ULONG  Controls
    );

extern BOOL
IsCSCBusy(
    VOID
    );
    
VOID
ClearCSCStateOnRedirStructures(
    VOID
    );
    

#endif //ifndef CSC_RECORDMANAGER_WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\cshadow.h ===
#ifndef _CSHADOW_H_
#define _CSHADOW_H_
#if defined(BITCOPY)
#include <csc_bmpk.h>
#endif // defined(BITCOPY)

#define MAX_SERVER_STRING  32
#define MAX_DOS_NAME       255
#define MAX_SHADOW_NAME_SIZE  32
#define SRET_OK           0
#define SRET_ERROR        -1


#define  SRET_WILDCARD_HINT      1
#define  SRET_OBJECT_HINT        2


#define  RNMFLGS_MARK_SOURCE_DELETED         0x00000001
#define  RNMFLGS_USE_FIND32_TIMESTAMPS       0x00000002
#define  RNMFLGS_USE_FIND32_83NAME           0x00000004
#define  RNMFLGS_SAVE_ALIAS                  0x00000008
#define  RNMFLGS_RETAIN_ALIAS                0x00000010
#define  RNMFLGS_MARK_SOURCE_ORPHAN          0x00000020

#define  AssertInShadowCrit()    Assert(vfInShadowCrit)

typedef int (*LPDELETECALLBACK)(HSHADOW, HSHADOW);
extern LPDELETECALLBACK lpDeleteCBForIoctl;

#define CSHADOW_LIST_TYPE_EXCLUDE       0
#define CSHADOW_LIST_TYPE_CONSERVE_BW   1

#ifdef DEBUG
extern int vfInShadowCrit;
#endif


extern LPVOID lpdbShadow;

BOOL FExistsRecDB(
    LPSTR    lpszLocation
    );

BOOL FExistsShadowDB(
    LPSTR    lpszLocation
    );

int OpenShadowDB(
    LPSTR   lpszLocation,
    LPSTR   lpszUserName,
    DWORD   dwDefDataSizeHigh,
    DWORD   dwDefDataSizeLow,
    DWORD   dwClusterSize,
    BOOL    fReinit,
    BOOL    *lpfReinited
    );

int PUBLIC CloseShadowDB(VOID);

HSHADOW  HAllocShadowID(HSHADOW, BOOL);
int FreeShadowID(HSHADOW);
int GetShadowSpaceInfo(LPSHADOWSTORE);
int SetMaxShadowSpace(long nFileSizeHigh, long nFileSizeLow);
int AdjustShadowSpace(long, long, long, long, BOOL);
int AllocShadowSpace(long, long, BOOL);
int FreeShadowSpace(long, long, BOOL);
int PUBLIC GetLocalNameHSHADOW(HSHADOW, LPBYTE, int, BOOL);
int GetWideCharLocalNameHSHADOW(
    HSHADOW  hShadow,
    USHORT      *lpBuffer,
    LPDWORD     lpdwSize,
    BOOL        fExternal
    );
int PUBLIC CreateFileHSHADOW(HSHADOW);

#if defined(BITCOPY)
int OpenFileHSHADOWAndCscBmp(HSHADOW, USHORT, UCHAR, CSCHFILE far *, BOOL, DWORD, LPCSC_BITMAP *);
int OpenCscBmp(HSHADOW, LPCSC_BITMAP *);
#define OpenFileHSHADOW(a, b , c, d) OpenFileHSHADOWAndCscBmp(a, b, c, d, FALSE, 0, NULL)
#endif // defined(BITCOPY)

int GetSizeHSHADOW(HSHADOW, ULONG *, ULONG *);
int GetDosTypeSizeHSHADOW(HSHADOW, ULONG *);
int PUBLIC CreateShadow(HSHADOW hDir, LPFIND32 lpFind32, ULONG uFlags, LPHSHADOW, BOOL *lpfCreated);
BOOL PUBLIC ExcludeFromCreateShadow(USHORT  *lpuName, ULONG len, BOOL fCheckExclusionList);
BOOL PUBLIC CheckForBandwidthConservation(USHORT  *lpuName, ULONG len);
int PUBLIC CreateShadowInternal( HSHADOW  hDir, LPFIND32 lpFind32, ULONG uFlags, LPOTHERINFO lpOI, LPHSHADOW  lphNew);
int PUBLIC DeleteShadow(HSHADOW hDir, HSHADOW hShadow);
int PUBLIC TruncateDataHSHADOW (HSHADOW, HSHADOW);
int PUBLIC RenameDataHSHADOW(HSHADOW, HSHADOW);
int PUBLIC GetShadow(HSHADOW hDir, USHORT *lpName, LPHSHADOW lphShadow, LPFIND32 lpFind32, ULONG *lpuShadowStatus, LPOTHERINFO lpOI);
int PUBLIC                              // ret
GetShadowEx(                              //
    HSHADOW  hDir,
    USHORT *lpName,
    LPHSHADOW lphShadow,
    LPFIND32 lpFind32,
    ULONG far *lpuShadowStatus,
    LPOTHERINFO lpOI,
    LPVOID      lpSecurityBlob,
    LPDWORD     lpdwBlobSize
    );
int PUBLIC ChkStatusHSHADOW(HSHADOW hDir, HSHADOW hNew, LPFIND32 lpFind32, ULONG far *lpuFlags);
int PUBLIC ChkUpdtStatusHSHADOW(HSHADOW hDir, HSHADOW hNew, LPFIND32 lpFind32, ULONG far *lpuFlags);
int PUBLIC GetShadowInfo(HSHADOW hDir, HSHADOW hNew, LPFIND32 lpFind32, ULONG far *lpuFlags, LPOTHERINFO lpOI);
int PUBLIC SetShadowInfo(HSHADOW hDir, HSHADOW hNew, LPFIND32 lpFind32, ULONG uFlags, ULONG uOp);
int PUBLIC RenameShadow(HSHADOW, HSHADOW, HSHADOW, LPFIND32, ULONG, LPOTHERINFO, ULONG, LPHSHADOW);
int PUBLIC
    RenameShadowEx(
    HSHADOW     hDirFrom,
    HSHADOW     hShadowFrom,
    HSHARE     hShareTo,
    HSHADOW     hDirTo,
    LPFIND32    lpFind32To,
    ULONG       uShadowStatusTo,
    LPOTHERINFO lpOI,
    ULONG       uRenameFlags,
    LPVOID      lpSecurityBlobTo,
    LPDWORD     lpdwBlobSizeTo,
    LPHSHADOW   lphShadowTo
    );

int PUBLIC GetShadowInfoEx
    (
    HSHADOW     hDir,
    HSHADOW     hShadow,
    LPFIND32    lpFind32,
    ULONG       far *lpuStatus,
    LPOTHERINFO lpOI,
    LPVOID      lpSecurityBlob,
    LPDWORD     lpdwBlobSize
    );

int PUBLIC                              // ret
SetShadowInfoEx(                          //
    HSHADOW     hDir,
    HSHADOW     hShadow,
    LPFIND32    lpFind32,
    ULONG       uFlags,
    ULONG       uOp,
    LPOTHERINFO lpOI,
    LPVOID      lpSecurityBlob,
    LPDWORD     lpdwBlobSize
    );


int MetaMatch(HSHADOW, LPFIND32, ULONG *, LPHSHADOW, ULONG *, LPOTHERINFO, METAMATCHPROC, LPVOID);

HSHARE PUBLIC HCreateShareObj(USHORT *, LPSHADOWINFO lpSI);
int PUBLIC DestroyHSHARE(HSHARE);
int PUBLIC GetShareFromPath(USHORT *, LPSHADOWINFO);
int PUBLIC GetShareInfo(HSHARE, LPSHAREINFOW, LPSHADOWINFO);
int PUBLIC SetShareStatus(HSHARE, ULONG, ULONG);
int PUBLIC GetShareInfoEx(HSHARE, LPSHAREINFOW, LPSHADOWINFO, LPVOID, LPDWORD);
int PUBLIC SetShareStatusEx(HSHARE, ULONG, ULONG, LPVOID, LPDWORD);
int GetRenameAliasHSHADOW(HSHADOW, HSHADOW, LPHSHADOW, LPHSHADOW);
BOOL IsBusy(HSHADOW hShadow);
int PUBLIC GetAncestorsHSHADOW(HSHADOW, LPHSHADOW, LPHSHARE);
CSC_ENUMCOOKIE  PUBLIC BeginPQEnum(VOID);
int PUBLIC SetPriorityHSHADOW(HSHADOW, HSHADOW, ULONG, ULONG);
int PUBLIC GetPriorityHSHADOW(HSHADOW, HSHADOW, ULONG *, ULONG *);
int PUBLIC ChangePriEntryStatusHSHADOW(HSHADOW, HSHADOW, ULONG, ULONG, BOOL, LPOTHERINFO);
int PUBLIC EndPQEnum(CSC_ENUMCOOKIE);
int PUBLIC PrevPriSHADOW(LPVOID);
int PUBLIC NextPriSHADOW(LPVOID);


BOOL
InitializeShadowCritStructures (
    void
    );
VOID
CleanupShadowCritStructures(
    VOID
    );

#ifndef CSC_RECORDMANAGER_WINNT
int EnterShadowCrit(void);
int LeaveShadowCrit(void);
#else
#if !DBG
#define ENTERLEAVESHADOWCRIT_SIGNATURE void
#define EnterShadowCrit() {__EnterShadowCrit();}
#define LeaveShadowCrit() {__LeaveShadowCrit();}
#else
#define ENTERLEAVESHADOWCRIT_SIGNATURE PSZ FileName, ULONG LineNumber
#define EnterShadowCrit() {__EnterShadowCrit(__FILE__,__LINE__);}
#define LeaveShadowCrit() {__LeaveShadowCrit(__FILE__,__LINE__);}
#endif
int __EnterShadowCrit(ENTERLEAVESHADOWCRIT_SIGNATURE);
int __LeaveShadowCrit(ENTERLEAVESHADOWCRIT_SIGNATURE);
#endif //#ifdef CSC_RECORDMANAGER_WINNT

int LeaveShadowCritIfThisThreadOwnsIt(void);
#ifdef CSC_RECORDMANAGER_WINNT
extern BOOLEAN    MRxSmbIsCscEnabled;
#endif

int GetRootWithChecks(HSHARE, USHORT *, BOOL, LPHSHADOW, LPFIND32, ULONG *, LPOTHERINFO);
int GetShadowWithChecks(HSHADOW, USHORT *, USHORT *, BOOL, LPHSHADOW, LPFIND32, ULONG *, LPOTHERINFO);



int CreateHint(HSHADOW hShadow, LPFIND32 lpFind32, ULONG uHintFlags, ULONG uHintPri, LPHSHADOW lphHint);
int DeleteHint(HSHADOW hShadow, USHORT *lpuHintName, BOOL fClearAll);
int CreateGlobalHint(USHORT *lpuName, ULONG uHintFlags, ULONG uHintPri);
int DeleteGlobalHint(USHORT *lpuName, BOOL fClearAll);
int
FindCreateShare(
    USHORT            *lpShareName,
    BOOL            fCreate,
    LPSHADOWINFO    lpShadowInfo,
    BOOL            *lpfCreated
    );

#ifdef CSC_RECORDMANAGER_WINNT
int FindCreateShareForNt(
    PUNICODE_STRING         pShareName,
    BOOL                    fCreate,
    LPSHADOWINFO            lpSI,
    BOOL                    *lpfCreated
    );
#endif

int PUBLIC  GetSecurityBlobHSHADOW(HSHADOW  hDir, HSHADOW hShadow, LPVOID lpBuffer, LPDWORD lpdwBufferSize);
int PUBLIC  SetSecurityBlobHSHADOW(HSHADOW  hDir, HSHADOW hShadow, LPVOID lpBuffer, LPDWORD lpdwBufferSize);

#ifdef LATER
int PUBLIC GetPathSVROBJ(HSHARE, LPSTR, ULONG);
int PUBLIC GetLinkPropSVROBJ(HSHARE, LPLINKPROP);
int PUBLIC UpdateShadowHSHADOW(HSHADOW);
int PUBLIC ChangeShadowInfo(HSHADOW, LPSHADOWINFO);
#endif //LATER

//prototypes added to remove NT compile errors
CSC_ENUMCOOKIE  PUBLIC HBeginPQEnum(VOID);
int PUBLIC EndPQEnum(CSC_ENUMCOOKIE hPQEnum);
int InitOtherInfo(LPOTHERINFO lpOI);

int PathFromHShadow(
    HSHADOW  hDir,
    HSHADOW  hShadow,
    USHORT   *lpBuff,
    int      cBuff      // count of max characters that the buffer can hold
);

int CopyHSHADOW(
    HSHADOW hDir,
    HSHADOW hShadow,
    LPSTR   lpszDestinationFile,
    ULONG   ulATtrib
    );

int BeginInodeTransactionHSHADOW(
    VOID
    );

int EndInodeTransactionHSHADOW(
    VOID
    );

int
GetSecurityInfosFromBlob(
    LPVOID          lpvBlob,
    DWORD           dwBlobSize,
    LPSECURITYINFO  lpSecInfo,
    DWORD           *lpdwItemCount
    );

int SetList(
    USHORT  *lpList,
    DWORD   cbBufferSize,
    int     typeList
    );

int
GetHShareFromUNCString(
    USHORT  *lpShare,
    int     cbShare,
    int     lenSkip,
    BOOL    fIsShareName,
    HSHARE *lphShare,
    ULONG   *lpulHintFlags
    );

int
GetDatabaseLocation(
    LPSTR   lpszLocation
    );

BOOL
EnableHandleCaching(
    BOOL    fEnable
    );

int
RecreateHSHADOW(
    HSHADOW hDir,
    HSHADOW hShadow,
    ULONG   ulAttribIn
    );

VOID
QuerySparseStaleDetectionCount(
    LPDWORD lpcnt
    );

VOID
QueryManualFileDetectionCount(
    LPDWORD lpcnt
    );

ULONG
QueryDatabaseErrorFlags(
    VOID
    );

DWORD
QueryNameSpaceVersion(
    VOID
    );
    
int
HasDescendentsHShadow(
    HSHADOW hDir,
    HSHADOW hShadow,
    BOOLEAN *lpfDescendents
    );
    
int
SetDatabaseStatus(
    ULONG   ulStatus,
    ULONG   uMask
    );

int CopyOtherInfoToShadowInfo(
    LPOTHERINFO     lpOI,
    LPSHADOWINFO    lpShadowInfo
    );

#endif // #ifndef _CSHADOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\hookcmmn.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    HookCmmn.h

Abstract:

    This module defines the routines that are in common between the win9x and nt hooks.

Author:

    JoeLinn [JoeLinn]    8-Apr-1997

Revision History:


--*/

#ifndef __INCLUDED__CSC__HOOKCMMN__
#define __INCLUDED__CSC__HOOKCMMN__

extern ULONG hthreadReint; //BUGBUG why should a thread be a ULONG????
extern ULONG hwndReint;
extern PFILEINFO pFileInfoAgent;
extern HSERVER  hShareReint;    // Share that is currently being reintegrated
extern int fShadow, fLog, fNoShadow, /*fShadowFind,*/ fSpeadOpt;
extern WIN32_FIND_DATA    vsFind32;
extern int cMacPro;
extern NETPRO rgNetPro[];
extern VMM_SEMAPHORE  semHook;
extern GLOBALSTATUS sGS;
extern ULONG proidShadow;
extern ULONG heventReint;


#define FLAG_FDB_SERIALIZE              0x0001
#define FLAG_FDB_INUSE_BY_AGENT         0x0002
#define FLAG_FDB_SHADOW_MODIFIED        0x0008
#define FLAG_FDB_DONT_SHADOW            0x0010
#define FLAG_FDB_FINAL_CLOSE_DONE       0x0020


int ReinitializeDatabase(
    LPSTR   lpszLocation,
    LPSTR   lpszUserName,
    DWORD   nFileSizeHigh,
    DWORD   nFileSizeLow,
    DWORD   dwClusterSize
    );

int
InitDatabase(
    LPSTR   lpszLocation,
    LPSTR   lpszUserName,
    DWORD   nFileSizeHigh,
    DWORD   nFileSizeLow,
    DWORD   dwClusterSize,
    BOOL    fReformat,
    BOOL    *lpfNew
);

BOOL IsShadowVisible(
#ifndef MRXSMB_BUILD_FOR_CSC_DCON
    PVOID pResource, //PRESOURCE    pResource,
#else
    BOOLEAN Disconnected,
#endif
    DWORD         dwAttr,
    ULONG     uShadowStatus
    );

int MarkShareDirty(
    PUSHORT ShareStatus,
    ULONG  hShare
    );
////////////////////////////////////////////////////////////////////////////////
/////////  T U N N E L

// Timeout in seconds for tunnelled entries
// after this many seconds a tunnelled entry is thrown away
#define  STALE_TUNNEL_INFO     45

typedef struct tagSH_TUNNEL {
    HSHADOW hDir;
    ULONG     uTime;
    UCHAR      ubHintFlags;
    UCHAR      ubRefPri;
    UCHAR      ubHintPri;
    UCHAR      ubIHPri;
    USHORT    cAlternateFileName[14];
    USHORT    *      lpcFileName;
} SH_TUNNEL, *LPSH_TUNNEL;

BOOL InsertTunnelInfo(
    HSHADOW  hDir,
    USHORT    *lpcFileName,
    USHORT    *lpcAlternateFileName,
    LPOTHERINFO lpOI
    );

#ifndef MRXSMB_BUILD_FOR_CSC_DCON
BOOL RetrieveTunnelInfo(
#else
typedef enum _RETRIEVE_TUNNEL_INFO_RETURNS {
    TUNNEL_RET_NOTFOUND = 0,
    TUNNEL_RET_SHORTNAME_TUNNEL = 'S',
    TUNNEL_RET_LONGNAME_TUNNEL = 'L'
} RETRIEVE_TUNNEL_INFO_RETURNS;

RETRIEVE_TUNNEL_INFO_RETURNS RetrieveTunnelInfo(
#endif
    HSHADOW  hDir,
    USHORT    *lpcFileName,
    WIN32_FIND_DATA    *lpFind32,
    LPOTHERINFO lpOI
    );
VOID FreeStaleEntries();
void FreeEntry(LPSH_TUNNEL lpshTunnel);
BOOL
FailModificationsToShare(
    LPSHADOWINFO   lpSI
    );
void
IncrementActivityCountForShare(
    HSERVER hShare
    );

BOOL
CSCFailUserOperation(
    HSERVER hShare
    );

// Macro used to check whether shadowing operations should be done or not
// in any given filesystem API call. The global swicth fShadow can be set/reset
// by ring3 agent through an ioctl

#define  ShadowingON()          ((fShadow != 0) && !IsSpecialApp())

#endif //ifndef __INCLUDED__CSC__HOOKCMMN__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\log.h ===
#define  MIN_VERBOSE 1
#define  MID_VERBOSE 2
#define  MAX_VERBOSE 3

#define  STAGE_BEGIN       0
#define  STAGE_CONTINUE    1
#define  STAGE_END         2


#define  MAX_LOGFILE_SIZE      0x10000  // Default max size of a log file
#define  MIN_LOGFILE_SIZE      0x8000  // min size of a log file

void  EnterLogCrit(void);
void  LeaveLogCrit(void);
VOID _cdecl DbgPrintLog(LPSTR lpFmt, ...);
void LogVfnDelete(PIOREQ);
void LogVfnDir(PIOREQ);
void LogVfnFileAttrib(PIOREQ);
void LogVfnFlush(PIOREQ);
void LogVfnGetDiskInfo(PIOREQ);
void LogVfnOpen(PIOREQ);
void LogVfnRename(PIOREQ);
void LogVfnSearch(PIOREQ);
void LogVfnQuery(PIOREQ, USHORT);
void LogVfnDisconnect(PIOREQ);
void LogVfnUncPipereq(PIOREQ);
void LogVfnIoctl16Drive (PIOREQ);
void LogVfnGetDiskParms(PIOREQ);
void LogVfnFindOpen(PIOREQ);
void LogHfnFindNext(PIOREQ);
void LogVfnDasdIO(PIOREQ);
void LogHfnFindClose(PIOREQ);
void LogHfnRead (PIOREQ);
void LogHfnWrite (PIOREQ);
void LogHfnClose (PIOREQ, int);
void LogHfnSeek (PIOREQ);
void LogHfnCommit (PIOREQ);
void LogHfnFileLocks (PIOREQ);
void LogHfnFileTimes (PIOREQ);
void LogHfnPipeRequest(PIOREQ);
void LogHfnHandleInfo(PIOREQ);
void LogHfnEnumHandle(PIOREQ);
void LogTiming(int verbosity, int stage);


#ifdef DEBUG
extern ULONG cntVfnDelete, cntVfnCreateDir, cntVfnDeleteDir, cntVfnCheckDir, cntVfnGetAttrib;
extern ULONG cntVfnSetAttrib, cntVfnFlush, cntVfnGetDiskInfo, cntVfnOpen;
extern ULONG cntVfnRename, cntVfnSearchFirst, cntVfnSearchNext;
extern ULONG cntVfnQuery, cntVfnDisconnect, cntVfnUncPipereq, cntVfnIoctl16Drive;
extern ULONG cntVfnGetDisParms, cntVfnFindOpen, cntVfnDasdIo;

extern ULONG cntHfnFindNext, cntHfnFindClose;
extern ULONG cntHfnRead, cntHfnWrite, cntHfnSeek, cntHfnClose, cntHfnCommit;
extern ULONG cntHfnSetFileLocks, cntHfnRelFileLocks, cntHfnGetFileTimes, cntHfnSetFileTimes;
extern ULONG cntHfnPipeRequest, cntHfnHandleInfo, cntHfnEnumHandle;

extern ULONG cntReadHits, cbReadLow, cbReadHigh, cbWriteLow, cbWriteHigh;
#endif //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\ioctl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

     Ioctl.c

Abstract:

    This file implements the ioctl interface to Client Side Caching facility. The interface
    is used by a) the agent b) the CSC apis and c) remote boot. The interface allows the
    callers to initialize/reinitialize the csc database, enumerate the hierarchy at any level,
    get the status of any file/directory in the hierarchy, pin/unpin files directories etc.

    There are a few ioctls which are used only by the agent. These include, enumerating the
    priority q, doing space scavenging, initiating and terminating reintegration on a share etc.


Author:

     Shishir Pardikar      [Shishirp]        01-jan-1995

Revision History:

     Joe Linn                 [JoeLinn]         23-jan-97     Ported for use on NT

--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

#ifndef CSC_RECORDMANAGER_WINNT
#define WIN32_APIS
#include "cshadow.h"
#include "record.h"
#endif //ifndef CSC_RECORDMANAGER_WINNT

#include <stdlib.h>
#include <ctype.h>
#include <string.h>
// #include "error.h"
#include "shell.h"
#include "vxdwraps.h"
#include "clregs.h"
#define  LM_3
#include "netcons.h"
#include "use.h"
#include "neterr.h"

#pragma intrinsic (memcmp, memcpy, memset, strcat, strcmp, strcpy, strlen)

#ifdef CSC_RECORDMANAGER_WINNT
#define CSC_ENABLED      (fShadow && MRxSmbIsCscEnabled)
#define OK_TO_ENABLE_CSC    (MRxSmbIsCscEnabled)
#else
#define CSC_ENABLED (fShadow)
#define OK_TO_ENABLE_CSC    (TRUE)
#endif

//
// From cscapi.h
//
#define FLAG_CSC_SHARE_STATUS_MANUAL_REINT              0x0000
#define FLAG_CSC_SHARE_STATUS_AUTO_REINT                0x0040
#define FLAG_CSC_SHARE_STATUS_VDO                       0x0080
#define FLAG_CSC_SHARE_STATUS_NO_CACHING                0x00c0
#define FLAG_CSC_SHARE_STATUS_CACHING_MASK              0x00c0

#define COPY_STRUCTFILETIME_TO_LARGEINTEGER(dest,src) {\
     (dest).LowPart = (src).dwLowDateTime;             \
     (dest).HighPart = (src).dwHighDateTime;           \
    }

//
// prototypes
//

int
HintobjMMProc(
    LPFIND32,
    HSHADOW,
    HSHADOW,
    ULONG,
    LPOTHERINFO,
    LPFINDSHADOW);

LPFINDSHADOW
LpCreateFindShadow(
    HSHADOW,
    ULONG,
    ULONG,
    USHORT *,
    METAMATCHPROC);

int
DeleteCallbackForFind(
    HSHADOW hDir,
    HSHADOW hShadow
);

int
IoctlRenameShadow(
    LPSHADOWINFO    lpSI
    );


int IoctlEnableCSCForUser(
    LPSHADOWINFO    lpSI
    );

int
IoctlDisableCSCForUser(
    LPSHADOWINFO    lpSI
    );

VOID
MRxSmbCscGenerate83NameAsNeeded(
      IN HSHADOW hDir,
      PWCHAR FileName,
      PWCHAR SFN
      );
VOID
MRxSmbCscFlushFdb(
    IN PFDB Fdb
    );

#ifdef MAYBE
int RecalcIHPri(HSHADOW, HSHADOW, LPFIND32, LPOTHERINFO);
#endif //MAYBE

BOOL RegisterTempAgent(VOID);
BOOL UnregisterTempAgent(VOID);
int PUBLIC MakeSpace(long, long, BOOL);
int PUBLIC ReduceRefPri(VOID);

int
IoctlAddDeleteHintFromInode(
    LPSHADOWINFO    lpSI,
    BOOL            fAdd
    );

LONG
PurgeUnpinnedFiles(
    ULONG     Timeout,
    PULONG    pnFiles,
    PULONG    pnYoungFiles);

BOOL HaveSpace(
    long  nFileSizeHigh,
    long  nFileSizeLow
    );

int SetResourceFlags(
    HSHARE  hShare,
    ULONG uStatus,
    ULONG uOp
    );
int DestroyFindShadow(
    LPFINDSHADOW    lpFSH
    );

int
CloseDatabase(
    VOID
    );

int
IoctlCopyShadow(
    LPSHADOWINFO    lpSI
    );

int IoctlGetSecurityInfo(
    LPSHADOWINFO    lpShadowInfo
    );
int
IoctlTransitionShareToOffline(
    LPSHADOWINFO    lpSI
    );

IoctlChangeHandleCachingState(
    LPSHADOWINFO    lpSI
    );

BOOLEAN
CscCheckForNullA(
    PUCHAR pBuf,
    ULONG Count);

BOOLEAN
CscCheckForNullW(
    PWCHAR pBuf,
    ULONG Count);

int
PUBLIC TraversePQToCheckDirtyBits(
    HSHARE hShare,
    DWORD   *lpcntDirty
    );


#ifndef CSC_RECORDMANAGER_WINNT
int ReportCreateDelete( HSHADOW  hShadow, BOOL fCreate);
#else
//BUGBUG.win9xonly this comes from hook.c on win95
#define ReportCreateDelete(a,b) {NOTHING;}
#endif //ifndef CSC_RECORDMANAGER_WINNT
BOOL
FailModificationsToShare(
    LPSHADOWINFO   lpSI
    );

extern  ULONG hthreadReint;
extern  ULONG hwndReint;
extern  PFILEINFO pFileInfoAgent;
extern  HSHARE  hShareReint;    // Share that is currently being reintegrated
extern  BOOL vfBlockingReint;
extern  DWORD vdwActivityCount;
extern  int fShadow, fLog, fNoShadow, /*fShadowFind,*/ fSpeadOpt;
extern  WIN32_FIND_DATA    vsFind32;
extern  int cMacPro;
extern  NETPRO rgNetPro[];
extern  VMM_SEMAPHORE  semHook;
extern  GLOBALSTATUS sGS;
extern  ULONG proidShadow;
extern  ULONG heventReint;
#if defined(REMOTE_BOOT)
BOOLEAN    fIsRemoteBootSystem=FALSE;
#endif // defined(REMOTE_BOOT)

// List of ongoing IOCTL finds
LPFINDSHADOW    vlpFindShadowList = NULL;
// Count of # entries on vlpFindShadowList
LONG vuFindShadowListCount = 0;
int iPQEnumCount = 0;
CSC_ENUMCOOKIE  hPQEnumCookieForIoctls = NULL;


AssertData;
AssertError;

#ifdef CSC_RECORDMANAGER_WINNT
//BUGBUG.win9xonly this stuff comes from shadow.asm on win95......
//this is a synchronization primitive used to unblock guys waiting on a server
//not yet implemented
#define _SignalID(a) {ASSERT(FALSE);}
#define IFSMgr_UseAdd(a, b, c) (-1)
#define IFSMgr_UseDel(a, b, c) (-1)

#endif //ifdef CSC_RECORDMANAGER_WINNT


int IoctlRegisterAgent(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

WIN9x specific    This is the way, we tell the shadwo VxD that this thread is the
                  agent thread and to bypass CSC whenever this thread comes down to make
                  calls.

Parameters:

Return Value:

Notes:


--*/
{
    if (hthreadReint)
    {
        KdPrint(("Agent Already registered Unregistering!!!!!\r\n"));

#ifndef CSC_RECORDMANAGER_WINNT

        // should never happen on win9x
        Assert(FALSE);
        // cleanup the
        if (heventReint)
        {
            // close the event handle
            CloseVxDHandle(heventReint);
        }

#endif
    }

    hthreadReint = GetCurThreadHandle();
    hwndReint = lpSI->hShare & 0xffff;    // windows handle for messages
    heventReint = lpSI->hDir;            // event handle for reporting interesting events

#if defined(REMOTE_BOOT)
    // if CSC is ON even before the agent was registered, we must be on an RB machine.
    fIsRemoteBootSystem = fShadow;
#endif // defined(REMOTE_BOOT)

    return 1;
}

int IoctlUnRegisterAgent(
    ULONG uHwnd
    )
/*++

Routine Description:

WIN9x specific

Parameters:

Return Value:

Notes:


--*/
{
    ULONG hthread;
    hthread =  GetCurThreadHandle();

    if (hthreadReint != hthread)
    {
        KdPrint(("Shadow:Someother thread Unregitsering!!!!\r\n"));
    }

    hthreadReint = 0;
    hwndReint = 0;
    if (heventReint)
    {
#ifndef CSC_RECORDMANAGER_WINNT
        // close the event handle
        CloseVxDHandle(heventReint);
        heventReint = 0;
#endif
    }
    return 1;
}

int IoctlGetUNCPath(
    LPCOPYPARAMSW lpCopyParams
    )
/*++

Routine Description:

    Given an hDir and an hShadow, this routine returns the complete UNC path for it.
    It returns it in the COPYPARAMS structure which has three embedded pointers for
    a) \\server\share b) Remote path relative to the root of the share and c) Path in
    the local database.

Parameters:

Return Value:

Notes:


--*/
{
    PFDB pFdb;
    HSHADOW hDir;
    HSHARE hShare;
    SHAREINFOW sSRI;
    int iRet = -1;
    DWORD   dwSize;

    if (!CSC_ENABLED)
    {
        lpCopyParams->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();

    hDir = 0; hShare = 0;

    if (lpCopyParams->lpRemotePath || lpCopyParams->lpSharePath)
    {
        if (GetAncestorsHSHADOW(lpCopyParams->hShadow, &hDir, &hShare) < SRET_OK)
        {
            goto bailout;
        }
        if (lpCopyParams->lpRemotePath)
        {
            if(PathFromHShadow(hDir, lpCopyParams->hShadow, lpCopyParams->lpRemotePath, MAX_PATH)<SRET_OK)
            {
                goto bailout;
            }
        }
        if (lpCopyParams->lpSharePath)
        {
            if (GetShareInfo(hShare, &sSRI, NULL) < SRET_OK)
            {
                goto bailout;
            }

            memcpy(lpCopyParams->lpSharePath, sSRI.rgSharePath, sizeof(sSRI.rgSharePath));
        }
    }


    dwSize = MAX_PATH * sizeof(USHORT);

    GetWideCharLocalNameHSHADOW(lpCopyParams->hShadow, lpCopyParams->lpLocalPath, &dwSize, (lpCopyParams->uOp==0));

    iRet = 1;
bailout:
    IF_CSC_RECORDMANAGER_WINNT {
        if (iRet!=1) {
#if 0
            DbgPrint("Failure on nonfailable routine.....\n");
            DbgPrint("----> hShadow    %08lx\n",lpCopyParams->hShadow);
            DbgPrint("----> hDir hSrv  %08lx %08lx\n",hDir,hShare);
            DbgPrint("----> SrvPath    %08lx\n",lpCopyParams->lpSharePath);
            DbgPrint("----> RemotePath %08lx\n",lpCopyParams->lpRemotePath);
            DbgBreakPoint();
#endif
        }
    }

    if (iRet < SRET_OK)
    {
        lpCopyParams->dwError = GetLastErrorLocal();
    }

    LeaveShadowCrit();
    return(iRet);
}

int IoctlBeginPQEnum(
    LPPQPARAMS lpPQPar
    )
/*++

Routine Description:

    Priority queue enumeration begins. Typically used by agent thread to do background
    filling

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = -1;

    if (!CSC_ENABLED)
    {
        lpPQPar->dwError =  ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();

#ifdef CSC_RECORDMANAGER_WINNT
    EventLogForOpenFailure = 1;
#endif //ifdef CSC_RECORDMANAGER_WINNT

    if (hPQEnumCookieForIoctls==NULL)
    {
        hPQEnumCookieForIoctls = HBeginPQEnum();
    }

    if (hPQEnumCookieForIoctls != NULL)
    {
        iRet = 1;
    }
    else
    {
        lpPQPar->dwError = GetLastErrorLocal();
    }
#ifdef CSC_RECORDMANAGER_WINNT
    EventLogForOpenFailure = 0;
#endif //ifdef CSC_RECORDMANAGER_WINNT

    LeaveShadowCrit();


    return iRet;
}

int IoctlEndPQEnum(
    LPPQPARAMS lpPQPar
    )
/*++

Routine Description:

    End priority queue enumeration

Parameters:

Return Value:

Notes:


--*/
{
    return 1;
}

int IoctlNextPriShadow(
    LPPQPARAMS lpPQPar
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    PQPARAMS sPQP;
    int iRet=-1;

    EnterShadowCrit();

    if (hPQEnumCookieForIoctls==NULL) {
        lpPQPar->dwError =  ERROR_INVALID_PARAMETER;
        goto bailout;
    }

    sPQP = *lpPQPar;

    sPQP.uEnumCookie = hPQEnumCookieForIoctls;

    iRet = NextPriSHADOW(&sPQP);
    if (iRet >= SRET_OK)
    {
        *lpPQPar = sPQP;

        if (!iRet)
            lpPQPar->hShadow = 0;
        iRet = 1;
    }
    else
    {
        lpPQPar->dwError = GetLastErrorLocal();
        iRet = -1;
        EndPQEnum(hPQEnumCookieForIoctls);
        hPQEnumCookieForIoctls = NULL;
    }

    lpPQPar->uEnumCookie = NULL;

bailout:
    LeaveShadowCrit();

    return (iRet);
}

int IoctlPrevPriShadow(
    LPPQPARAMS lpPQPar
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    PQPARAMS sPQP;
    int iRet=-1;

    EnterShadowCrit();

    if (hPQEnumCookieForIoctls==NULL) {
        lpPQPar->dwError =  ERROR_INVALID_PARAMETER;
        goto bailout;
    }

    sPQP = *lpPQPar;
    sPQP.uEnumCookie = hPQEnumCookieForIoctls;

    iRet = PrevPriSHADOW(&sPQP);
    if (iRet >= SRET_OK)
    {
        *lpPQPar = sPQP;
        if (!iRet)
            lpPQPar->hShadow = 0;
        iRet =  1;
    }
    else
    {
        lpPQPar->dwError = GetLastErrorLocal();
        iRet = -1;
        EndPQEnum(hPQEnumCookieForIoctls);
        hPQEnumCookieForIoctls = NULL;
    }

    lpPQPar->uEnumCookie = NULL;

bailout:
    LeaveShadowCrit();

    return (iRet);
}

int
IoctlGetShadowInfoInternal(
    LPSHADOWINFO    lpShadowInfo,
    LPFIND32        lpFind32,
    LPSECURITYINFO  lpSecurityInfos,
    LPDWORD         lpcbBufferSize
    )
/*++

Routine Description:

    Given an hDir and an hShadow, return all the possible info for the Inode

Parameters:

Return Value:

Notes:


--*/
{
    ULONG uStatus;
    HSHADOW hDir, hShare;
    PFDB pFdb=NULL;
    PRESOURCE  pResource=NULL;
    int iRet = -1;
    OTHERINFO    sOI;
    DWORD           dwSecurityBlobSize;
    ACCESS_RIGHTS   rgsAccessRights[CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES];

    DeclareFindFromShadowOnNtVars()

    if (!CSC_ENABLED)
    {
        lpShadowInfo->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();

    if (!(hDir = lpShadowInfo->hDir))
    {
        if (GetAncestorsHSHADOW(lpShadowInfo->hShadow, &hDir, &hShare) < 0)
            goto bailout;

        lpShadowInfo->hDir = hDir;
        lpShadowInfo->hShare = hShare;
    }

    dwSecurityBlobSize = sizeof(rgsAccessRights);

    if(GetShadowInfoEx( hDir,
                        lpShadowInfo->hShadow,
                        &vsFind32,
                        &uStatus,
                        &sOI,
                        rgsAccessRights,
                        &dwSecurityBlobSize) < SRET_OK)
        goto bailout;


    // not a root
    if (hDir)
    {
        if (!(vsFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            // is a file
            uStatus |= SHADOW_IS_FILE;

            if(pFdb = PFindFdbFromHShadow(lpShadowInfo->hShadow))
            {
                uStatus |= (pFdb->usFlags | SHADOW_FILE_IS_OPEN);
            }
        }
    }
    else
    {
        pResource = PFindResourceFromRoot(lpShadowInfo->hShadow, 0xffff, 0);

        if (pResource)
        {
            IFNOT_CSC_RECORDMANAGER_WINNT
            {
                uStatus |= (
                                (pResource->usLocalFlags|SHARE_CONNECTED)|
                                ((pResource->pheadFdb)?SHARE_FILES_OPEN:0) |
                                ((pResource->pheadFindInfo) ?SHARE_FINDS_IN_PROGRESS:0));

                lpShadowInfo->uOp = pResource->uDriveMap;
            }
            else
            {
                uStatus |= MRxSmbCscGetSavedResourceStatus();
                lpShadowInfo->uOp = MRxSmbCscGetSavedResourceDriveMap();
            }
        }
        // UI expects to know whether a server is offline
        // even when a share may not be offline. So we do the following drill anyways
        {
#ifdef CSC_RECORDMANAGER_WINNT
            BOOL    fShareOnline = FALSE;
            BOOL    fPinnedOffline = FALSE;

            //  Leave Crit sec coz MRxSmbCscServerStateFromCompleteUNCPath may acquire SmbCeResource 
            LeaveShadowCrit();
            if (MRxSmbCscServerStateFromCompleteUNCPath(
                    vsFind32.cFileName,
                    &fShareOnline,
                    &fPinnedOffline)==STATUS_SUCCESS) {
                if (!fShareOnline)
                    uStatus |= SHARE_DISCONNECTED_OP;
                if (fPinnedOffline)
                    uStatus |= SHARE_PINNED_OFFLINE;
            }
            EnterShadowCrit();
#endif
        }

    }

    lpShadowInfo->uStatus = uStatus;
    CopyOtherInfoToShadowInfo(&sOI, lpShadowInfo);
    if (hShareReint && (lpShadowInfo->hShare == hShareReint))
    {
        lpShadowInfo->uStatus |= SHARE_MERGING;
    }

    if (lpFind32)
    {
        *(lpFind32) = vsFind32;

    }

    if (lpSecurityInfos)
    {
        Assert(lpcbBufferSize);

        iRet = GetSecurityInfosFromBlob(
            rgsAccessRights,
            dwSecurityBlobSize,
            lpSecurityInfos,
            lpcbBufferSize);

        Assert(iRet >= 0);

    }

    iRet = 1;

bailout:
    if (iRet < 0)
    {
        lpShadowInfo->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();
    return (iRet);
}

int IoctlGetSecurityInfo(
    LPSHADOWINFO    lpShadowInfo
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return IoctlGetShadowInfoInternal(lpShadowInfo, NULL, (LPSECURITYINFO)(lpShadowInfo->lpBuffer), &(lpShadowInfo->cbBufferSize));
}

int IoctlGetShadowInfo(
    LPSHADOWINFO    lpShadowInfo
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return IoctlGetShadowInfoInternal(lpShadowInfo, lpShadowInfo->lpFind32, NULL, NULL);
}


int IoctlSetShadowInfo(
    LPSHADOWINFO    lpShadowInfo
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    HSHADOW hDir;
    PFDB pFdb;
    ULONG uOp = lpShadowInfo->uOp, uStatus;
    int iRet = -1;
    LPFIND32 lpFind32=NULL;

    if (!CSC_ENABLED)
    {
        lpShadowInfo->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();

    if (FailModificationsToShare(lpShadowInfo))
    {
        goto bailout;
    }

    hDir = lpShadowInfo->hDir;
    pFdb = PFindFdbFromHShadow(lpShadowInfo->hShadow);

    if (!hDir)
    {
        if (GetAncestorsHSHADOW(lpShadowInfo->hShadow, &hDir, NULL) < 0)
            goto bailout;
        lpShadowInfo->hDir = hDir;
    }

    if (mTruncateDataCommand(uOp))
    {
        if (pFdb)
        {
            goto bailout;
        }
        if (GetShadowInfo(hDir, lpShadowInfo->hShadow, &vsFind32, &uStatus, NULL) < 0)
        {
            goto bailout;
        }
        if (uStatus & SHADOW_LOCALLY_CREATED)
        {
            goto bailout;
        }
        if (IsFile(vsFind32.dwFileAttributes))
        {
            if (TruncateDataHSHADOW(hDir, lpShadowInfo->hShadow) < SRET_OK)
            {
                goto bailout;
            }
        }

        // if we are truncating data, then the only thing possible
        // is to set all the flags to 0 and mark it as sparse
        lpShadowInfo->uStatus = SHADOW_SPARSE;
        uOp = lpShadowInfo->uOp = (SHADOW_FLAGS_ASSIGN | SHADOW_FLAGS_TRUNCATE_DATA);
    }

    if (lpShadowInfo->lpFind32)
    {
        lpFind32 = &vsFind32;

        *lpFind32 = *(lpShadowInfo->lpFind32);

//        Find32FromFind32A(lpFind32 = &vsFind32, (LPFIND32A)(lpShadowInfo->lpFind32), BCS_WANSI);

#ifndef CSC_RECORDMANAGER_WINNT

        // ensure that on win9x we set only the FAT like attributes
        lpFind32->dwFileAttributes &= FILE_ATTRIBUTE_EVERYTHING;

#endif

    }

    // strip out the ored flags
    lpShadowInfo->uStatus &= ~(SHARE_MERGING);

    if(SetShadowInfo(hDir, lpShadowInfo->hShadow
                            , lpFind32
                            , lpShadowInfo->uStatus
                            , lpShadowInfo->uOp) < SRET_OK)
    {
        goto bailout;
    }

    // if this is a file and it is open, then
    // update the in memory structures

    if (pFdb)
    {
        USHORT usFlags = (USHORT)(lpShadowInfo->uStatus);
        USHORT  usOldFlags, *pusLocalFlags = NULL;

        // we can't be truncating when a file is open
        Assert(!mTruncateDataCommand(uOp));

        usOldFlags = usFlags;

        pusLocalFlags = PLocalFlagsFromPFdb(pFdb);

        Assert(pusLocalFlags);

        if (mAndShadowFlags(uOp))
        {
            pFdb->usFlags = pFdb->usFlags & usFlags;
        }
        else if (mOrShadowFlags(uOp))
        {
            pFdb->usFlags = pFdb->usFlags | usFlags;
        }
        else
        {
            pFdb->usFlags = pFdb->usFlags | usFlags;
        }

        // if we are about to clear the reint bits
        // then also clear the snapshot bit
        // If the file has been modified after the snapshot was taken,
        // then the modified bit will have been set again

        if ((usOldFlags & SHADOW_DIRTY) && !(usFlags & SHADOW_DIRTY))
        {
            *pusLocalFlags &= ~FLAG_FDB_SHADOW_SNAPSHOTTED;
        }

    }

    iRet = 1;
bailout:
    if (iRet < 0)
    {
        lpShadowInfo->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();
    return (iRet);
}


int IoctlChkUpdtStatus(
    LPSHADOWINFO    lpShadowInfo
    )
/*++

Routine Description:

    Check if the File represneted by the inode is out of date by and mark it as stale
    if so

Parameters:

Return Value:

Notes:


--*/
{
    HSHADOW hDir;
    PFDB pFdb;
    int iRet = -1;

    if (!CSC_ENABLED)
    {
        lpShadowInfo->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    if (!(hDir = lpShadowInfo->hDir))
    {
        if (GetAncestorsHSHADOW(lpShadowInfo->hShadow, &hDir, NULL) < 0)
            goto bailout;
        lpShadowInfo->hDir = hDir;
    }
    if(ChkUpdtStatusHSHADOW(hDir, lpShadowInfo->hShadow
                            , lpShadowInfo->lpFind32
                            , &(lpShadowInfo->uStatus)
                            ) < SRET_OK)
        goto bailout;
    if(pFdb = PFindFdbFromHShadow(lpShadowInfo->hShadow))
    {
        // Update the staleness indicator in pFdb (why?)
        pFdb->usFlags ^= (lpShadowInfo->uStatus & SHADOW_STALE);

        // OR any flags such as DIRTY and SUSPECT that might
        // have occurred
        lpShadowInfo->uStatus |= pFdb->usFlags;
    }

    if (!(lpShadowInfo->lpFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        // is a file
        lpShadowInfo->uStatus |= SHADOW_IS_FILE;
    }

    iRet = 1;
bailout:
    if (iRet < 0)
    {
        lpShadowInfo->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();
    return (iRet);
}

int IoctlDoShadowMaintenance(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

    Catchall routine which takes a minor_number to do interesting things.
    It used to be used for maitenance purposes, but has become a funnelling
    point for many helper ioctls

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = 1;
    OTHERINFO sOI;
    ULONG nFiles = 0;
    ULONG nYoungFiles = 0;

    if (lpSI->uOp == SHADOW_REINIT_DATABASE)
    {
        if (fShadow)
        {
            lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
            return -1;
        }
        //
        // Check that cFileName and cAlternateFileName contain a NULL
        //
        if (CscCheckForNullA(((LPFIND32A)(lpSI->lpFind32))->cFileName, MAX_PATH) == FALSE) {
            lpSI->dwError = ERROR_INVALID_PARAMETER;
            return -1;
        }
        if (CscCheckForNullA(((LPFIND32A)(lpSI->lpFind32))->cAlternateFileName, 14) == FALSE) {
            lpSI->dwError = ERROR_INVALID_PARAMETER;
            return -1;
        }
        EnterShadowCrit();
        iRet = ReinitializeDatabase(
                        ((LPFIND32A)(lpSI->lpFind32))->cFileName,
                        ((LPFIND32A)(lpSI->lpFind32))->cAlternateFileName,
                        ((LPFIND32A)(lpSI->lpFind32))->nFileSizeHigh,
                        ((LPFIND32A)(lpSI->lpFind32))->nFileSizeLow,
                        ((LPFIND32A)(lpSI->lpFind32))->dwReserved1
                        );
        LeaveShadowCrit();
        if (iRet < 0) {
            lpSI->dwError = GetLastErrorLocal();
        }
        return (iRet);
    }
    else if (lpSI->uOp == SHADOW_ENABLE_CSC_FOR_USER)
    {
        
        CscInitializeSecurityDescriptor();
        
        
        if (CscAmIAdmin()) {
            if(IoctlEnableCSCForUser(lpSI) < 0) {
                lpSI->dwError = GetLastErrorLocal();
                return -1;
            } else {
                return 1;
            }
        } else {
            lpSI->dwError = ERROR_ACCESS_DENIED;
            return -1;
        }
        
    }

    if (!CSC_ENABLED) {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();
    switch(lpSI->uOp)
    {
        case SHADOW_MAKE_SPACE:
            // Assert(lpSI->lpFind32);
            if (lpSI->lpFind32 == NULL) {
                lpSI->dwError = ERROR_INVALID_PARAMETER;
                LeaveShadowCrit();
                return -1;
            }
            MakeSpace(    lpSI->lpFind32->nFileSizeHigh,
                        lpSI->lpFind32->nFileSizeLow,
                        (lpSI->ulHintPri == 0xffffffff));
            break;
        case SHADOW_REDUCE_REFPRI:
            ReduceRefPri();
            break;
        case SHADOW_ADD_SPACE:
            // Assert(lpSI->lpFind32);
            if (lpSI->lpFind32 == NULL) {
                lpSI->dwError = ERROR_INVALID_PARAMETER;
                LeaveShadowCrit();
                return -1;
            }
            AllocShadowSpace(lpSI->lpFind32->nFileSizeHigh, lpSI->lpFind32->nFileSizeLow, TRUE);
            break;
        case SHADOW_FREE_SPACE:
            // Assert(lpSI->lpFind32);
            if (lpSI->lpFind32 == NULL) {
                lpSI->dwError = ERROR_INVALID_PARAMETER;
                LeaveShadowCrit();
                return -1;
            }
            FreeShadowSpace(lpSI->lpFind32->nFileSizeHigh, lpSI->lpFind32->nFileSizeLow, TRUE);
            break;
        case SHADOW_GET_SPACE_STATS:
            // Assert(lpSI->lpBuffer);
            // Assert(lpSI->cbBufferSize >= sizeof(SHADOWSTORE));
            if (lpSI->lpBuffer == NULL || lpSI->cbBufferSize < sizeof(SHADOWSTORE)) {
                lpSI->dwError = ERROR_INVALID_PARAMETER;
                LeaveShadowCrit();
                return -1;
            }
            if(GetShadowSpaceInfo((SHADOWSTORE *)(lpSI->lpBuffer)) >= SRET_OK) {
                iRet = 1;
            } else {
                iRet = -1;
            }
            break;
        case SHADOW_SET_MAX_SPACE:
            // Assert(lpSI->lpFind32);
            if (lpSI->lpFind32 == NULL) {
                lpSI->dwError = ERROR_INVALID_PARAMETER;
                LeaveShadowCrit();
                return -1;
            }
            SetMaxShadowSpace(lpSI->lpFind32->nFileSizeHigh, lpSI->lpFind32->nFileSizeLow);
            break;
        case SHADOW_PER_THREAD_DISABLE:
            if(!RegisterTempAgent()) {
                iRet = -1;
            }
            break;
        case SHADOW_PER_THREAD_ENABLE:
            if(!UnregisterTempAgent()) {
                iRet = -1;
            }
            break;
        case SHADOW_ADDHINT_FROM_INODE:
            iRet = IoctlAddDeleteHintFromInode(lpSI, TRUE);
            break;
        case SHADOW_DELETEHINT_FROM_INODE:
            iRet = IoctlAddDeleteHintFromInode(lpSI, FALSE);
            break;
        case SHADOW_COPY_INODE_FILE:
            iRet = IoctlCopyShadow(lpSI);

            break;
        case SHADOW_BEGIN_INODE_TRANSACTION:
            iRet = BeginInodeTransactionHSHADOW();
            break;
        case SHADOW_END_INODE_TRANSACTION:
            iRet = EndInodeTransactionHSHADOW();
            break;
        case SHADOW_FIND_CREATE_PRINCIPAL_ID:
            {
                DWORD dwError = ERROR_SUCCESS;
                CSC_SID_INDEX indx;

                if (CscCheckForNullA(lpSI->lpBuffer, lpSI->cbBufferSize) == FALSE) {
                    lpSI->dwError = ERROR_INVALID_PARAMETER;
                    LeaveShadowCrit();
                    return -1;
                }
                if (lpSI->uStatus) {
                    dwError = CscAddSidToDatabase(lpSI->lpBuffer, lpSI->cbBufferSize, &indx);
                } else {
                    indx = CscMapSidToIndex(lpSI->lpBuffer, lpSI->cbBufferSize);

                    if (indx == CSC_INVALID_PRINCIPAL_ID) {
                        dwError = ERROR_NO_SUCH_USER;
                    }
                }
                if (dwError != ERROR_SUCCESS) {
                    iRet = -1;
                    lpSI->dwError = dwError;
                } else {
                    lpSI->ulPrincipalID = (ULONG)indx;
                }
            }
            break;
        case SHADOW_GET_SECURITY_INFO:
            LeaveShadowCrit();
            iRet = IoctlGetSecurityInfo(lpSI);
            return iRet;
        case SHADOW_SET_EXCLUSION_LIST:
            if (CscCheckForNullW(lpSI->lpBuffer, lpSI->cbBufferSize/sizeof(WCHAR)) == FALSE) {
                lpSI->dwError = ERROR_INVALID_PARAMETER;
                LeaveShadowCrit();
                return -1;
            }
            iRet = SetList(lpSI->lpBuffer, lpSI->cbBufferSize, CSHADOW_LIST_TYPE_EXCLUDE);
            break;
        case SHADOW_SET_BW_CONSERVE_LIST:
            if (CscCheckForNullW(lpSI->lpBuffer, lpSI->cbBufferSize/sizeof(WCHAR)) == FALSE) {
                lpSI->dwError = ERROR_INVALID_PARAMETER;
                LeaveShadowCrit();
                return -1;
            }
            iRet = SetList(lpSI->lpBuffer, lpSI->cbBufferSize, CSHADOW_LIST_TYPE_CONSERVE_BW);
            break;
#ifdef CSC_RECORDMANAGER_WINNT
        case IOCTL_TRANSITION_SERVER_TO_OFFLINE:
            iRet = IoctlTransitionShareToOffline(lpSI);
            break;
#endif
        case SHADOW_CHANGE_HANDLE_CACHING_STATE:
            iRet = IoctlChangeHandleCachingState(lpSI);
            break;
        case SHADOW_RECREATE:
            if (!PFindFdbFromHShadow(lpSI->hShadow)) {
                if(RecreateHSHADOW(lpSI->hDir, lpSI->hShadow, lpSI->uStatus) < 0) {
                    iRet = -1;
                }
            } else {
                iRet = -1;
                SetLastErrorLocal(ERROR_SHARING_VIOLATION);
            }
            break;
        case SHADOW_SET_DATABASE_STATUS:
            if (CscAmIAdmin()) {
                if(SetDatabaseStatus(lpSI->uStatus, lpSI->ulHintFlags) < 0) {
                    iRet = -1;
                }
            } else {
                iRet = -1;
                SetLastErrorLocal(ERROR_ACCESS_DENIED);
            }
            break;
        case SHADOW_RENAME:
            iRet = IoctlRenameShadow(lpSI);
            break;
        case SHADOW_SPARSE_STALE_DETECTION_COUNTER:
            QuerySparseStaleDetectionCount(&(lpSI->dwError));
            iRet = 1;
            break;
        case SHADOW_MANUAL_FILE_DETECTION_COUNTER:
            QueryManualFileDetectionCount(&(lpSI->dwError));
            iRet = 1;
            break;
        case SHADOW_DISABLE_CSC_FOR_USER:
            if (CscAmIAdmin()) {
                iRet = IoctlDisableCSCForUser(lpSI);
            } else {
                iRet = -1;
                SetLastErrorLocal(ERROR_ACCESS_DENIED);
            }
            
            break;        
        case SHADOW_PURGE_UNPINNED_FILES:
            // Assert(lpSI->lpFind32);
            if (lpSI->lpFind32 == NULL) {
                lpSI->dwError = ERROR_INVALID_PARAMETER;
                LeaveShadowCrit();
                return -1;
            }
            iRet = PurgeUnpinnedFiles(
                        lpSI->lpFind32->nFileSizeHigh,
                        &nFiles,
                        &nYoungFiles);
            if (iRet >= SRET_OK) {
                iRet = 1;  // Copy output params
                lpSI->lpFind32->nFileSizeHigh = nFiles;
                lpSI->lpFind32->nFileSizeLow = nYoungFiles;
                // DbgPrint("IoctlDoShadowMaintenance: iRet=%d, nFiles=%d, nYoungFiles=%d\n",
                //             iRet,
                //             nFiles,
                //             nYoungFiles);
            } else {
                iRet = -1;
            }
            break;

    }
    if (iRet < 0) {
        lpSI->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();
    return (iRet);
}

#ifndef CSC_RECORDMANAGER_WINNT
//the implementation on NT is completely different
int IoctlCopyChunk(
    LPSHADOWINFO        lpSI,
    COPYCHUNKCONTEXT    *lpCCC
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    PFILEINFO pFileInfo;
    int iRet = -1;

    if (!CSC_ENABLED)
    {
        return -1;
    }

    EnterHookCrit();
    if (pFileInfo = PFileInfoAgent())
    {
        EnterShadowCrit();
         iRet = CopyChunk(lpSI->hDir, lpSI->hShadow, pFileInfo, lpCCC);
        LeaveShadowCrit();
    }

    LeaveHookCrit();
    return (iRet);
}
#endif //ifndef CSC_RECORDMANAGER_WINNT

int IoctlBeginReint(
    LPSHADOWINFO    lpShadowInfo
    )
/*++

Routine Description:

    Puts a share in reintegration mode. The effect of this is that, all filesystem
    open calls to the share fail with ACCESS_DENIED if they come to CSC.

Parameters:

    lpShadowInfo    The significant entry is hShare, which represents the share being
                    put in disconnected state

Return Value:


Notes:

    CODE.IMPROVEMENT.ASHAMED This scheme assumes that only one share is reintegrated
    at one time. So if the multiple guys call IoctlBeginReint, then they will tromp on
    each other. We have taken care of it in the agent code which does merging. We allow
    only one guy to merge at any time by taking a global critical section.

--*/
{
    PPRESOURCE ppResource;
    int i;

    if (!CSC_ENABLED)
    {
        lpShadowInfo->dwError = ERROR_INVALID_FUNCTION;
        return -1;
    }

    if (hShareReint)
    {
        lpShadowInfo->dwError = ERROR_BUSY;
        return -1;
    }

    if (lpShadowInfo->hShare == 0)
    {
        lpShadowInfo->dwError = ERROR_INVALID_PARAMETER;
        return -1;
    }

// BUGBUG-win9xonly needs checking
#ifndef CSC_RECORDMANAGER_WINNT
    EnterHookCrit();
#endif


#ifdef CSC_RECORDMANAGER_WINNT

    EnterShadowCrit();

    hShareReint = lpShadowInfo->hShare;
    vdwActivityCount = 0;

    // if uOp is non-zero then this is a reint that should abort if the activytcount
    // is non-zero
    vfBlockingReint  = (lpShadowInfo->uOp == 0);

    LeaveShadowCrit();
    return(1);

#else
    for (i=0;i<cMacPro;++i)
    {
        for(ppResource = &(rgNetPro[i].pheadResource); *ppResource; ppResource = &((*ppResource)->pnextResource))
        {
            if ((*ppResource)->hShare == lpShadowInfo->hShare)
            {
                if ((*ppResource)->pheadFileInfo || (*ppResource)->pheadFindInfo)
                {
                    LeaveHookCrit();
                    return(-1);
                }
            }
        }
    }
#endif //ifdef CSC_RECORDMANAGER_WINNT

    hShareReint = lpShadowInfo->hShare;
    LeaveHookCrit();
    return (1);
}

int IoctlEndReint(
    LPSHADOWINFO    lpShadowInfo
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = -1;

    EnterShadowCrit();

    if (lpShadowInfo->hShare == hShareReint)
    {
        hShareReint = 0;
#ifndef CSC_RECORDMANAGER_WINNT
        _SignalID(lpShadowInfo->hShare);
#endif
        iRet = 1;
    }
    else
    {
        lpShadowInfo->dwError = ERROR_INVALID_PARAMETER;
    }
    LeaveShadowCrit();

    return iRet;
}

int IoctlCreateShadow(
    LPSHADOWINFO lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet= SRET_ERROR;
    SHAREINFO sSRI;
    LPFIND32 lpFind32 = lpSI->lpFind32;
    BOOL fCreated = FALSE;
    BOOL fIsLoopBack = FALSE;
    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();



    vsFind32 = *(lpSI->lpFind32);

    if (MRxSmbCscIsLoopbackServer(lpSI->lpFind32->cFileName, &fIsLoopBack)==STATUS_SUCCESS) {
        if (fIsLoopBack){
            iRet = -1;
            SetLastErrorLocal(ERROR_INVALID_NAME);
            goto bailout;
        }

    }

//    Find32FromFind32A(&vsFind32, (LPFIND32A)(lpSI->lpFind32), BCS_WANSI);

    if (!lpSI->hDir)
    {
        iRet = FindCreateShare(vsFind32.cFileName, TRUE, lpSI, &fCreated);

    }
    else
    {
        iRet = 0;
        if (IsFile(vsFind32.dwFileAttributes))
        {
            if (ExcludeFromCreateShadow(vsFind32.cFileName, wstrlen(vsFind32.cFileName), TRUE))
            {
                iRet = -1;
                SetLastErrorLocal(ERROR_INVALID_NAME);
            }
        }

        if (iRet == 0)
        {
            iRet = CreateShadow(lpSI->hDir, &vsFind32, lpSI->uStatus, &(lpSI->hShadow), &fCreated);
        }
    }

bailout:

    if (iRet < SRET_OK)
    {
        lpSI->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();

    iRet = (iRet>=SRET_OK)?1:-1;

    if ((iRet==1) && fCreated)
    {
        ReportCreateDelete(lpSI->hShadow, TRUE);
    }

    lpSI->lpFind32 = lpFind32;
    return (iRet);
}

int IoctlDeleteShadow(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=SRET_ERROR;
    BOOL fDoit = TRUE;
    PFDB pFdb;

    DeclareFindFromShadowOnNtVars()

    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();

    if (FailModificationsToShare(lpSI))
    {
        goto bailout;
    }

    if (!lpSI->hDir)
    {
        if (PFindResourceFromRoot(lpSI->hShadow, 0xffff, 0))
        {
            fDoit = FALSE;
        }
    }
    else if (pFdb = PFindFdbFromHShadow(lpSI->hShadow))
    {
        // Issue a flush to see if the file is in delayclose list
        MRxSmbCscFlushFdb(pFdb);

        if (PFindFdbFromHShadow(lpSI->hShadow))
        {
            fDoit = FALSE;
        }
    }
    else if (PFindFindInfoFromHShadow(lpSI->hShadow))
    {
        fDoit = FALSE;
    }
    else
    {
//        DbgPrint("%x has an FCB\n", lpSI->hShadow);
//        Assert(FALSE);
    }

    // if the shadow is not busy in some transaction, delete it
    if (fDoit)
    {
        iRet = DeleteShadow(lpSI->hDir, lpSI->hShadow);
        if (iRet>=SRET_OK)
        {
            ReportCreateDelete(lpSI->hShadow, FALSE);
        }
        else
        {
//            DbgPrint("%x is open on the disk\n", lpSI->hShadow);
//            Assert(FALSE);
        }
    }
bailout:
    if (iRet < SRET_OK)
    {
        lpSI->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();
    return ((iRet >=SRET_OK)?1:-1);
}

int IoctlGetShareStatus(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;
    PRESOURCE pResource;
    SHAREINFOW *lpShareInfo = (SHAREINFOW *)(lpSI->lpFind32); // save it because, getserverinfo destory's it

    DeclareFindFromShadowOnNtVars()

    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();

    Assert(sizeof(SHAREINFOW) <= sizeof(WIN32_FIND_DATA));

    iRet = GetShareInfo(lpSI->hShare, (LPSHAREINFOW)(&vsFind32), lpSI);

    if (iRet >= SRET_OK)
    {
        if (lpShareInfo)
        {
            *lpShareInfo = *(LPSHAREINFOW)(&vsFind32);
        }

        if (pResource = PFindResourceFromHShare(lpSI->hShare, 0xffff, 0))
        {
            IFNOT_CSC_RECORDMANAGER_WINNT
            {
                lpSI->uStatus |= ((pResource->usLocalFlags|SHARE_CONNECTED)|
                              ((pResource->pheadFdb)?SHARE_FILES_OPEN:0) |
                              ((pResource->pheadFindInfo) ?SHARE_FINDS_IN_PROGRESS:0));
            }
            else
            {
                lpSI->uStatus |= MRxSmbCscGetSavedResourceStatus();
            }
        }
        // UI expects to know whether a server is offline
        // even when a share may not be offline. So we do the following drill anyways
        {
#ifdef CSC_RECORDMANAGER_WINNT
            BOOL    fShareOnline = FALSE;
            BOOL    fPinnedOffline = FALSE;
            
            //  Leave Crit sec coz MRxSmbCscServerStateFromCompleteUNCPath may acquire SmbCeResource 
            LeaveShadowCrit();
            if (MRxSmbCscServerStateFromCompleteUNCPath(
                ((LPSHAREINFOW)(&vsFind32))->rgSharePath,
                &fShareOnline,
                &fPinnedOffline)==STATUS_SUCCESS) {
                if (!fShareOnline)
                    lpSI->uStatus |= SHARE_DISCONNECTED_OP;
                if (fPinnedOffline)
                    lpSI->uStatus |= SHARE_PINNED_OFFLINE;
            }
            EnterShadowCrit();
#endif
        }
    }

    if (iRet < SRET_OK)
    {
        lpSI->dwError = GetLastErrorLocal();
    }

    LeaveShadowCrit();

    return ((iRet >=SRET_OK)?1:-1);
}

int IoctlSetShareStatus(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=SRET_ERROR;
    HSHARE hShare = lpSI->hShare;
    ULONG   uStatus = lpSI->uStatus, uOp = lpSI->uOp;
    DWORD   cntDirty = 0;

    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();

    if (!FailModificationsToShare(lpSI))
    {
        iRet = SRET_OK;

        if (((uOp == SHADOW_FLAGS_ASSIGN)||(uOp == SHADOW_FLAGS_AND))&&!(uStatus & SHARE_REINT))
        {
            iRet = GetShareInfo(hShare, NULL, lpSI);

            if (iRet >= SRET_OK)
            {
                if (lpSI->uStatus & SHARE_REINT)
                {
                    iRet = TraversePQToCheckDirtyBits(hShare, &cntDirty);

                    // if the traversal failed, or there are some dirty entries
                    // then putback the dirty bit

                    if ((iRet==SRET_ERROR) || cntDirty)
                    {
                        uStatus |= SHARE_REINT;
                    }
                }
            }

        }

        if (iRet >= SRET_OK)
        {
            SetResourceFlags(hShare, uStatus, uOp);
            iRet = SetShareStatus(hShare, uStatus, uOp);
        }
    }

    if (iRet < SRET_OK)
    {
        lpSI->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();

    return ((iRet >=SRET_OK)?1:-1);
}

#ifndef CSC_RECORDMANAGER_WINNT
int IoctlAddUse(
    LPCOPYPARAMSA lpCPA
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    struct netuse_info nu;
    struct use_info_2 ui;
    int iRet=-1;
    PRESOURCE    pResource=NULL;
    HSHADOW hRoot;
    ULONG uShareStatus;
    BOOL fAlloced = FALSE, fOfflinePath=FALSE;
    path_t ppath;
    HSHARE  hShare;

#ifdef DEBUG
    int indx = 0;
#endif //DEBUG

#ifdef MAYBE
    if (!CSC_ENABLED)
    {
        return -1;
    }

    // Don't add shadow use for the agent
    if (IsSpecialApp())
    {
        lpCPA->hDir = lpCPA->dwError = ERROR_BAD_NETPATH;
        return (-1);
    }
#endif

    memset(&ui, 0, sizeof(ui));
    if (lpCPA->lpLocalPath)
    {
        strcpy(ui.ui2_local, lpCPA->lpLocalPath);
#ifdef DEBUG
        indx = GetDriveIndex(lpCPA->lpLocalPath);
#endif //DEBUG
    }

    if (ppath = (path_t)AllocMem((strlen(lpCPA->lpRemotePath)+4)*sizeof(USHORT)))
    {
        MakePPath(ppath, lpCPA->lpRemotePath);

        if (fOfflinePath = IsOfflinePE(ppath->pp_elements))
        {
            OfflineToOnlinePath(ppath);
        }

        EnterShadowCrit();
        UseGlobalFind32();
        hShare = HShareFromPath(NULL, ppath->pp_elements, 0, &vsFind32, &hRoot, &uShareStatus);
        LeaveShadowCrit();

        if (fOfflinePath)
        {
            OnlineToOfflinePath(ppath);
        }

        // Has connect succeeded with this server in the past?
        if (hShare)
        {
            // Any resource allocated by shadow NP?
            pResource = PFindResource(ppath->pp_elements
                                                , RH_DISCONNECTED
                                                , ANY_FHID
                                                , FLAG_RESOURCE_SHADOWNP
                                                , NULL);

            if (!pResource)
            {
                pResource = PCreateResource(ppath->pp_elements);
                if (pResource)
                {
                    fAlloced = TRUE;
                    DisconnectAllByName(pResource->pp_elements);
                    pResource->usLocalFlags |=
                            (FLAG_RESOURCE_SHADOW_CONNECT_PENDING
                            | ((fOfflinePath)?FLAG_RESOURCE_OFFLINE_CONNECTION:0));
                    LinkResource(pResource, &rgNetPro[0]);
                    KdPrint(("shadow:Created pending resource %x \r\n", pResource));
                }
            }
        }
        FreeMem(ppath);
    }


    if (pResource)
    {
        // need to tell IFS about the use

        ui.ui2_remote = lpCPA->lpRemotePath;
        ui.ui2_password="";
        ui.ui2_asg_type = USE_DISKDEV;
        ui.ui2_res_type = USE_RES_UNC;
        nu.nu_data = &ui;
        nu.nu_flags = FSD_NETAPI_USEOEM;
        nu.nu_info = (int)(pResource);

        iRet = IFSMgr_UseAdd(NULL, proidShadow, &nu);

        if (iRet)
        {
            lpCPA->hDir = (ULONG)iRet;
            KdPrint(("SHADOW::IoctlAddUse: error %x \r\n", iRet));
            if (fAlloced)
            {
                PUnlinkResource(pResource, &rgNetPro[0]);
                DestroyResource(pResource);
            }
            iRet = -1;
        }
        else
        {
            // AddUse succeeded
            lpCPA->hDir = 0;
            iRet = 1;
        }
    }

bailout:
    return (iRet);
}

int IoctlDelUse(
    LPCOPYPARAMSA lpCPA
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int indx, iRet=-1;
    PRESOURCE pResource;
    struct netuse_info nu;
    struct use_info_2    ui;
    BOOL fDoit = FALSE;

    if (!CSC_ENABLED)
    {
        return -1;
    }

    if (*(lpCPA->lpRemotePath+1)==':')
    {
        indx = GetDriveIndex(lpCPA->lpRemotePath);
        if (indx  && PFindShadowResourceFromDriveMap(indx))
        {
            fDoit = TRUE;
        }
    }
    else
    {
        EnterShadowCrit();
        UseGlobalFind32();
        if (strlen(lpCPA->lpRemotePath) < (sizeof(vsFind32.cFileName)/2-2))
        {
            MakePPath((path_t)(vsFind32.cFileName), lpCPA->lpRemotePath);

            if (PFindResource(((path_t)(vsFind32.cFileName))->pp_elements, 0, ANY_FHID, FLAG_RESOURCE_DISCONNECTED, NULL))
            {
                fDoit = TRUE;
            }
        }
        LeaveShadowCrit();
    }

    if (fDoit)
    {
        memset (&ui, 0, sizeof(ui));
        strcpy (ui.ui2_local, lpCPA->lpRemotePath);
        nu.nu_data  = &ui.ui2_local;
        nu.nu_flags = FSD_NETAPI_USEOEM;
        nu.nu_info = (lpCPA->hShadow)?3:0;
        if(!(lpCPA->hDir = IFSMgr_UseDel(0, proidShadow, &nu)))
        {
            iRet = 1;
        }
    }
    else
    {
        lpCPA->hDir = ERROR_BAD_NETPATH;
    }

    return (iRet);
}

int IoctlGetUse(
    LPCOPYPARAMSA lpCPA
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int indx;
    PRESOURCE pResource;

    if (!CSC_ENABLED)
    {
        return -1;
    }

    indx = GetDriveIndex(lpCPA->lpLocalPath);
    if (!indx)
        return (-1);

    if (pResource = PFindShadowResourceFromDriveMap(indx))
    {
        if (PpeToSvr(pResource->pp_elements, lpCPA->lpRemotePath, lpCPA->hShadow, 0))
        {
            return (1);
        }
    }
    return (-1);
}
#endif //ifndef CSC_RECORDMANAGER_WINNT

int IoctlSwitches(
    LPSHADOWINFO lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    BOOL fRet = 1;


    switch (lpSI->uOp)
    {
        case SHADOW_SWITCH_GET_STATE:
        {
            lpSI->uStatus = ((fShadow)?SHADOW_SWITCH_SHADOWING:0)
                                    |((fLog)?SHADOW_SWITCH_LOGGING:0)
                                    /*|((fShadowFind)?SHADOW_SWITCH_SHADOWFIND:0)*/
                                    |((fSpeadOpt)?SHADOW_SWITCH_SPEAD_OPTIMIZE:0)
#if defined(REMOTE_BOOT)
                                    | ((fIsRemoteBootSystem)?SHADOW_SWITCH_REMOTE_BOOT:0)
#endif // defined(REMOTE_BOOT)
                                    ;
            if (lpSI->lpFind32)
            {
                if (fShadow)
                {
                    EnterShadowCrit();
                    UseGlobalFind32();

                    fRet = GetDatabaseLocation((LPSTR)(vsFind32.cFileName));

                    Assert(fRet >= 0);

                    fRet = BCSToUni( lpSI->lpFind32->cFileName,
                                (LPSTR)(vsFind32.cFileName),
                                MAX_PATH,
                                BCS_WANSI);
                    Assert(fRet > 0);
                    fRet = 1;
                    LeaveShadowCrit();
                }
                else
                {
                    fRet = -1;
                    lpSI->dwError = ERROR_INVALID_ACCESS;
                }
            }
            break;
        }
        case SHADOW_SWITCH_OFF:
        {
            if (mQueryBits(lpSI->uStatus, SHADOW_SWITCH_LOGGING))
            {
                fLog = 0;
                mClearBits(lpSI->uStatus, SHADOW_SWITCH_LOGGING);
            }
            if (mQueryBits(lpSI->uStatus, SHADOW_SWITCH_SHADOWING))
            {
                // DbgPrint("Agent closing database fShadow=%x\r\n", fShadow);

                if (fShadow)
                {
                    EnterShadowCrit();


                    if (hPQEnumCookieForIoctls != NULL)
                    {
                        EndPQEnum(hPQEnumCookieForIoctls);
                        hPQEnumCookieForIoctls = NULL;
                    }

                    CloseDatabase();

                    fShadow = 0;

                    mClearBits(lpSI->uStatus, SHADOW_SWITCH_SHADOWING);

                    LeaveShadowCrit();
                }
            }
#ifdef HISTORY
            if (mQueryBits(lpSI->uStatus, SHADOW_SWITCH_SHADOWFIND))
            {
                fShadowFind = 0;
                mClearBits(lpSI->uStatus, SHADOW_SWITCH_SHADOWFIND);
            }
#endif //HISTORY
            if (mQueryBits(lpSI->uStatus, SHADOW_SWITCH_SPEAD_OPTIMIZE))
            {
                fSpeadOpt = 0;
                mClearBits(lpSI->uStatus, SHADOW_SWITCH_SPEAD_OPTIMIZE);
            }
            break;
        }
        case SHADOW_SWITCH_ON:
        {
            if (mQueryBits(lpSI->uStatus, SHADOW_SWITCH_LOGGING))
            {
#ifdef CSC_RECORDMANAGER_WINNT
#if defined(_X86_)
                fLog = 1;
                mClearBits(lpSI->uStatus, SHADOW_SWITCH_LOGGING);
#endif
#else
                fLog = 1;
                mClearBits(lpSI->uStatus, SHADOW_SWITCH_LOGGING);
#endif

            }
            if (mQueryBits(lpSI->uStatus, SHADOW_SWITCH_SHADOWING))
            {
                if (!fShadow)
                {
                    if (OK_TO_ENABLE_CSC)
                    {
                        Assert(lpSI->lpFind32);
                        //
                        // Check that cFileName and cAlternateFileName contain a NULL
                        //
                        if (CscCheckForNullA(((LPFIND32A)(lpSI->lpFind32))->cFileName, MAX_PATH) == FALSE) {
                            lpSI->dwError = ERROR_INVALID_PARAMETER;
                            return -1;
                        }
                        if (CscCheckForNullA(((LPFIND32A)(lpSI->lpFind32))->cAlternateFileName, 14) == FALSE) {
                            lpSI->dwError = ERROR_INVALID_PARAMETER;
                            return -1;
                        }
                        // check if we can initialize the database
//                        KdPrint(("Trying to shadow....%s\n",
//                                       ((LPFIND32A)(lpSI->lpFind32))->cFileName));
                        EnterShadowCrit();
                        if(InitDatabase(
                                ((LPFIND32A)(lpSI->lpFind32))->cFileName,            // location
                                ((LPFIND32A)(lpSI->lpFind32))->cAlternateFileName,    // user
                                ((LPFIND32A)(lpSI->lpFind32))->nFileSizeHigh,        // default cache size if creating
                                ((LPFIND32A)(lpSI->lpFind32))->nFileSizeLow,
                                ((LPFIND32A)(lpSI->lpFind32))->dwReserved1, // cluster size
                                lpSI->ulRefPri,
                                &(lpSI->uOp))    // whether newly created
                                ==-1)
                        {
                            //we can't, let us quit
                            lpSI->dwError = GetLastErrorLocal();
                            fRet = -1;
                            LeaveShadowCrit();
                            break;
                        }
                        LeaveShadowCrit();

//                        KdPrint(("Starting to shadow....\n"));
                        fShadow = 1;
                    }
                    else
                    {
                        //we are not supposed to turn on csc. This happens only on NT
                        lpSI->dwError = ERROR_ACCESS_DENIED;
                        fRet = -1;
                        break;
                    }
                }

                mClearBits(lpSI->uStatus, SHADOW_SWITCH_SHADOWING);
            }
#ifdef HISTORY
            if (mQueryBits(lpSI->uStatus, SHADOW_SWITCH_SHADOWFIND))
            {
                fShadowFind = 1;
                mClearBits(lpSI->uStatus, SHADOW_SWITCH_SHADOWFIND);
            }
#endif //HISTORY
            if (mQueryBits(lpSI->uStatus, SHADOW_SWITCH_SPEAD_OPTIMIZE))
            {
                fSpeadOpt = 1;
                mClearBits(lpSI->uStatus, SHADOW_SWITCH_SPEAD_OPTIMIZE);
            }
            break;
        }
    }
    return (fRet);
}

int IoctlGetShadow(
    LPSHADOWINFO lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=-1, iRet1;
    OTHERINFO sOI;
    PFDB pFdb=NULL;
    PRESOURCE    pResource=NULL;


    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();
    iRet1 = GetShadow(lpSI->hDir, lpSI->lpFind32->cFileName, &(lpSI->hShadow), &vsFind32, &(lpSI->uStatus), &sOI);

    // If it worked and we have a shadow ID which is a filesystem object
    if ((iRet1 >= SRET_OK)&& !mNotFsobj(lpSI->uStatus))
    {
        if (lpSI->hShadow)
        {
            if (lpSI->hDir)
            {
                if (!(vsFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                {

                    lpSI->uStatus |= SHADOW_IS_FILE;

                    if(pFdb = PFindFdbFromHShadow(lpSI->hShadow))
                    {
                        lpSI->uStatus |= (SHADOW_FILE_IS_OPEN | pFdb->usFlags);
                    }
                }
            }
            else
            {
                // this is a share

                DeclareFindFromShadowOnNtVars()
                if(pResource = PFindResourceFromRoot(lpSI->hShadow, 0xffff, 0))
                {
                    IFNOT_CSC_RECORDMANAGER_WINNT
                    {
                        lpSI->uStatus |= ((pResource->usLocalFlags|SHARE_CONNECTED)|
                                      ((pResource->pheadFdb)?SHARE_FILES_OPEN:0) |
                                      ((pResource->pheadFindInfo) ?SHARE_FINDS_IN_PROGRESS:0));
                    }
                    else
                    {
                        lpSI->uStatus |= MRxSmbCscGetSavedResourceStatus();
                    }
                }
                // UI expects to know whether a server is offline
                // even when a share may not be offline. So we do the following drill anyways
                {
#ifdef CSC_RECORDMANAGER_WINNT
                    BOOL    fShareOnline = FALSE;
                    BOOL    fPinnedOffline = FALSE;

                    //  Leave Crit sec coz MRxSmbCscServerStateFromCompleteUNCPath may acquire SmbCeResource 
                    LeaveShadowCrit();
                    if (MRxSmbCscServerStateFromCompleteUNCPath(
                            lpSI->lpFind32->cFileName,
                            &fShareOnline,
                            &fPinnedOffline)==STATUS_SUCCESS) {
                        if (!fShareOnline)
                            lpSI->uStatus |= SHARE_DISCONNECTED_OP;
                        if (fPinnedOffline)
                            lpSI->uStatus |= SHARE_PINNED_OFFLINE;
                    }
                    EnterShadowCrit();
#endif
                }
            }


            CopyOtherInfoToShadowInfo(&sOI, lpSI);

            if(GetAncestorsHSHADOW(lpSI->hShadow, NULL, &(lpSI->hShare)) < SRET_OK)
            {
                goto bailout;
            }

            *(lpSI->lpFind32) = vsFind32;

        }

        iRet = 1;

        // if we couldn't find it in the database, and we are doing lookups for shares
        // then let us lookup the in-memory data strucutres
        if (!lpSI->hShadow && !lpSI->hDir)
        {
#ifndef CSC_RECORDMANAGER_WINNT
            {
                path_t ppath;

                memset((LPSTR)(vsFind32.cFileName), 0, sizeof(vsFind32.cFileName));

                UniToBCS((LPSTR)(vsFind32.cFileName),
                         lpSI->lpFind32->cFileName,
                         wstrlen(lpSI->lpFind32->cFileName)*sizeof(USHORT),
                         sizeof(vsFind32.cFileName),
                         BCS_WANSI);

                if (ppath = (path_t)AllocMem((strlen((LPSTR)(vsFind32.cFileName))+4)*sizeof(USHORT)))
                {
                    MakePPath(ppath, (LPSTR)(vsFind32.cFileName));
                    pResource = PFindResource(ppath->pp_elements
                                                        , ANY_RESOURCE
                                                        , ANY_FHID
                                                        , 0xffff
                                                        , NULL);
                    if (pResource)
                    {
                        lpSI->uStatus = ResourceCscBitsToShareCscBits(mGetCSCBits(pResource));
                        lpSI->uStatus |= SHARE_CONNECTED;
                    }

                    FreeMem(ppath);

                }
            }
#else
            {
                if(MRxSmbCscCachingBitsFromCompleteUNCPath(lpSI->lpFind32->cFileName,
                                &(lpSI->uStatus)) == STATUS_SUCCESS)
                {
                    lpSI->uStatus |= SHARE_CONNECTED;
                }
            }
#endif

        }
    }


bailout:
    if (iRet < SRET_OK)
    {
        lpSI->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();


    return (iRet);
}


int IoctlAddHint(        // Add a new hint or change an existing hint
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;
    OTHERINFO    sOI;

    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();
    vsFind32 = *(lpSI->lpFind32);

//    BCSToUni(vsFind32.cFileName, (LPSTR)(lpSI->lpFind32->cFileName), MAX_PATH, BCS_WANSI);
    if (lpSI->hDir)
    {
        iRet = CreateHint(lpSI->hDir, &vsFind32, lpSI->ulHintFlags, lpSI->ulHintPri, &(lpSI->hShadow));
#ifdef MAYBE
        if (iRet == SRET_OBJECT_HINT)
        {
            if(RecalcIHPri(lpSI->hDir, lpSI->hShadow, &vsFind32, &sOI)>=SRET_OK)
            {
                SetPriorityHSHADOW(lpSI->hDir, lpSI->hShadow, RETAIN_VALUE, sOI.ulIHPri);
            }
        }
#endif //MAYBE
    }
    else
    {
        iRet = CreateGlobalHint(vsFind32.cFileName, lpSI->ulHintFlags, lpSI->ulHintPri);
    }

    if (iRet < SRET_OK)
    {
        lpSI->dwError = GetLastErrorLocal();
    }

    LeaveShadowCrit();
    return ((iRet >= SRET_OK)?1:-1);
}

int IoctlDeleteHint(    // Delete an existing hint
    LPSHADOWINFO lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;
    BOOL fClearAll = (lpSI->ulHintPri == 0xffffffff);

    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();
    vsFind32 = *(lpSI->lpFind32);

//    BCSToUni(vsFind32.cFileName, (LPSTR)(lpSI->lpFind32->cFileName), MAX_PATH, BCS_WANSI);
    if (lpSI->hDir)
    {
        iRet = DeleteHint(lpSI->hDir, vsFind32.cFileName, fClearAll);
    }
    else
    {
        iRet = DeleteGlobalHint(vsFind32.cFileName,  fClearAll);
    }
    if (iRet < SRET_OK)
    {
        lpSI->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();
    return ((iRet >= SRET_OK)?1:-1);
}

int IoctlGetHint(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;
    OTHERINFO sOI;

    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();

    iRet = GetShadow(lpSI->hDir, lpSI->lpFind32->cFileName, &(lpSI->hShadow), &vsFind32, &(lpSI->uStatus), &sOI);

    if ((iRet>=SRET_OK) && (lpSI->hShadow) && mIsHint(sOI.ulHintFlags))
    {
        CopyOtherInfoToShadowInfo(&sOI, lpSI);
        iRet = 1;
    }
    else
    {
        SetLastErrorLocal(ERROR_INVALID_ACCESS);

        iRet = -1;
    }
    if (iRet < SRET_OK)
    {
        lpSI->dwError = GetLastErrorLocal();
    }

    LeaveShadowCrit();
    return (iRet);
}

int IoctlFindOpenHSHADOW(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=-1;
    LPFINDSHADOW lpFSH;
    HSHADOW hTmp;
    ULONG uSrchFlags;
    PRESOURCE    pResource=NULL;
    OTHERINFO sOI;
    DeclareFindFromShadowOnNtVars()
    PFDB    pFdb = NULL;

    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();
    if (!lpDeleteCBForIoctl)
    {
        lpDeleteCBForIoctl = DeleteCallbackForFind;
    }
    uSrchFlags = FLAG_FINDSHADOW_META|FLAG_FINDSHADOW_NEWSTYLE
                     |((lpSI->uOp & FINDOPEN_SHADOWINFO_NORMAL)?FLAG_FINDSHADOW_ALLOW_NORMAL:0)
                     |((lpSI->uOp & FINDOPEN_SHADOWINFO_SPARSE)?FLAG_FINDSHADOW_ALLOW_SPARSE:0)
                     |((lpSI->uOp & FINDOPEN_SHADOWINFO_DELETED)?FLAG_FINDSHADOW_ALLOW_DELETED:0);

    lpFSH = LpCreateFindShadow(lpSI->hDir, lpSI->lpFind32->dwFileAttributes
                                        ,uSrchFlags
                                        ,lpSI->lpFind32->cFileName, FsobjMMProc);
    if (lpFSH)
    {
        if (FindOpenHSHADOW(lpFSH, &hTmp, &vsFind32, &(lpSI->uStatus), &sOI) >= SRET_OK)
        {
            CopyOtherInfoToShadowInfo(&sOI, lpSI);

            if(GetAncestorsHSHADOW(hTmp, &(lpSI->hDir), &(lpSI->hShare)) < SRET_OK)
            {
                goto bailout;
            }

            *(lpSI->lpFind32) = vsFind32;

            lpSI->hShadow = hTmp;
            lpSI->uEnumCookie = (CSC_ENUMCOOKIE)lpFSH;
            iRet = 1;

            // check if this is a root
            if(!lpFSH->hDir)
            {
                // the status bits we got are for the root
                lpSI->uRootStatus = sOI.ulRootStatus;

                // the server status is part of the otherinfo.
                lpSI->uStatus = lpSI->uStatus;

                if(pResource = PFindResourceFromRoot(lpSI->hShadow, 0xffff, 0))
                {
                    IFNOT_CSC_RECORDMANAGER_WINNT
                    {
                        lpSI->uStatus |= ((pResource->usLocalFlags|SHARE_CONNECTED)|
                                     ((pResource->pheadFdb)?SHARE_FILES_OPEN:0) |
                                     ((pResource->pheadFindInfo) ?SHARE_FINDS_IN_PROGRESS:0));
                        lpSI->uOp = pResource->uDriveMap;
                    }
                    else
                    {
                        lpSI->uStatus |= MRxSmbCscGetSavedResourceStatus();
                        lpSI->uOp = MRxSmbCscGetSavedResourceDriveMap();
                    }
                }
                // UI expects to know whether a server is offline
                // even when a share may not be offline. So we do the following drill anyways
                {
#ifdef CSC_RECORDMANAGER_WINNT
                    BOOL    fShareOnline = FALSE;
                    BOOL    fPinnedOffline = FALSE;

                    //  Leave Crit sec coz MRxSmbCscServerStateFromCompleteUNCPath may acquire SmbCeResource 
                    LeaveShadowCrit();
                    if (MRxSmbCscServerStateFromCompleteUNCPath(
                            lpSI->lpFind32->cFileName,
                            &fShareOnline,
                            &fPinnedOffline)==STATUS_SUCCESS) {
                        if (!fShareOnline)
                            lpSI->uStatus |= SHARE_DISCONNECTED_OP;
                        if (fPinnedOffline)
                            lpSI->uStatus |= SHARE_PINNED_OFFLINE;
                    }
                    EnterShadowCrit();
#endif
                }

            }
            else
            {
                // not a root, if this is a file and it is open
                // let the caller know that
                if (!(vsFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                {
                    lpSI->uStatus |= SHADOW_IS_FILE;

                    if (pFdb = PFindFdbFromHShadow(lpSI->hShadow))
                    {
                        lpSI->uStatus |= (SHADOW_FILE_IS_OPEN | pFdb->usFlags);
                    }
                }

            }
        }
        else
        {
            DestroyFindShadow(lpFSH);
        }
    }

    if (hShareReint && (lpSI->hShare == hShareReint))
    {
        lpSI->uStatus |= SHARE_MERGING;
    }
bailout:
    if (iRet < 0)
    {
        lpSI->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();
    return(iRet);
}

int IoctlFindNextHSHADOW(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int             iRet=-1;
    LPFINDSHADOW    lpFSH = (LPFINDSHADOW)(lpSI->uEnumCookie);
    LPFINDSHADOW    lpFSHtmp = NULL;
    HSHADOW         hTmp;
    PRESOURCE       pResource=NULL;
    OTHERINFO       sOI;
    PFDB    pFdb = NULL;
    DeclareFindFromShadowOnNtVars()

    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();
    if (lpFSH)
    {
        //
        // Verify that the lpFSH is in fact one we gave out; ie it is on the
        // vlpFindShadowList.
        //
        for (lpFSHtmp = vlpFindShadowList; lpFSHtmp; lpFSHtmp = lpFSHtmp->lpFSHNext) {
            if (lpFSHtmp == lpFSH) {
                break;
            }
        }
        if (lpFSHtmp != lpFSH) {
            SetLastErrorLocal(ERROR_INVALID_PARAMETER);
            iRet = -1;
            goto bailout;
        }
        // check if the directory has been deleted in the meanwhile
        if (!(lpFSH->ulFlags & FLAG_FINDSHADOW_INVALID_DIRECTORY))
        {
            if (FindNextHSHADOW(lpFSH, &hTmp, &vsFind32, &(lpSI->uStatus), &sOI) >= SRET_OK)
            {
                CopyOtherInfoToShadowInfo(&sOI, lpSI);
                if(GetAncestorsHSHADOW(hTmp, &(lpSI->hDir), &(lpSI->hShare)) < SRET_OK)
                {
                    goto bailout;
                }

                *(lpSI->lpFind32) = vsFind32;

                lpSI->hShadow = hTmp;
                iRet = 1;

                // check if this is a root
                if(!lpFSH->hDir)
                {
                    // the status bits we got are for the root
                    lpSI->uRootStatus = sOI.ulRootStatus;

                    // the server status is part of the otherinfo.
                    lpSI->uStatus = lpSI->uStatus;

                    if(pResource = PFindResourceFromRoot(lpSI->hShadow, 0xffff, 0))
                    {
                        IFNOT_CSC_RECORDMANAGER_WINNT
                        {
                            lpSI->uStatus |= ((pResource->usLocalFlags|SHARE_CONNECTED)|
                                         ((pResource->pheadFdb)?SHARE_FILES_OPEN:0) |
                                         ((pResource->pheadFindInfo) ?SHARE_FINDS_IN_PROGRESS:0));
                            lpSI->uOp = pResource->uDriveMap;
                        }
                        else
                        {
                            lpSI->uStatus |= MRxSmbCscGetSavedResourceStatus();
                            lpSI->uOp = MRxSmbCscGetSavedResourceDriveMap();
                        }
                    }
                    {
#ifdef CSC_RECORDMANAGER_WINNT
                        BOOL    fShareOnline = FALSE;
                        BOOL    fPinnedOffline = FALSE;

                        //  Leave Crit sec coz MRxSmbCscServerStateFromCompleteUNCPath may acquire SmbCeResource 
                        LeaveShadowCrit();
                        if (MRxSmbCscServerStateFromCompleteUNCPath(
                                lpSI->lpFind32->cFileName,
                                &fShareOnline,
                                &fPinnedOffline)==STATUS_SUCCESS) {
                            if (!fShareOnline)
                                lpSI->uStatus |= SHARE_DISCONNECTED_OP;
                            if (fPinnedOffline)
                                lpSI->uStatus |= SHARE_PINNED_OFFLINE;
                        }
                        EnterShadowCrit();
#endif
                    }
                }
                else
                {
                    // not a root, if this is a file and it is open
                    // let the caller know that
                    if (!(vsFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                    {
                        lpSI->uStatus |= SHADOW_IS_FILE;

                        if (pFdb = PFindFdbFromHShadow(lpSI->hShadow))
                        {
                            // or in the latest known bits
                            lpSI->uStatus |= (SHADOW_FILE_IS_OPEN | pFdb->usFlags);
                        }
                    }

                }
            }
        }
    }

    if (hShareReint && (lpSI->hShare == hShareReint))
    {
        lpSI->uStatus |= SHARE_MERGING;
    }

bailout:
    if (iRet < 0)
    {
        lpSI->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();
    return(iRet);
}


int IoctlFindCloseHSHADOW(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = -1;
    LPFINDSHADOW lpFSH = (LPFINDSHADOW)(lpSI->uEnumCookie);

    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    if (lpFSH)
    {
        DestroyFindShadow(lpFSH);
        iRet = 1;
    }
    LeaveShadowCrit();
    return(iRet);
}

int IoctlFindOpenHint(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=-1;
    LPFINDSHADOW lpFSH;
    OTHERINFO    sOI;
    HSHADOW  hTmp;

    if (!CSC_ENABLED)
    {
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();
    lpFSH = LpCreateFindShadow(lpSI->hDir, 0,
                                        FLAG_FINDSHADOW_META|FLAG_FINDSHADOW_NEWSTYLE,
                                        (lpSI->lpFind32->cFileName), HintobjMMProc);
    if (lpFSH)
    {
        if (FindOpenHSHADOW(lpFSH, &hTmp, &vsFind32, &(lpSI->uStatus), &sOI) >= SRET_OK)
        {
            *(lpSI->lpFind32) = vsFind32;
//            Find32AFromFind32((LPFIND32A)(lpSI->lpFind32), &vsFind32, BCS_WANSI);

            CopyOtherInfoToShadowInfo(&sOI, lpSI);
            lpSI->hShare = vsFind32.dwReserved0;
            lpSI->hShadow = hTmp;
            lpSI->uEnumCookie = (CSC_ENUMCOOKIE)lpFSH;
            iRet = 1;
        }
        else
        {
            DestroyFindShadow(lpFSH);
        }
    }
    LeaveShadowCrit();
    return(iRet);
}

int IoctlFindNextHint(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=-1;
    LPFINDSHADOW lpFSH = (LPFINDSHADOW)(lpSI->uEnumCookie);
    LPFINDSHADOW lpFSHtmp = NULL;
    OTHERINFO    sOI;
    HSHADOW  hTmp;

    if (!CSC_ENABLED)
    {
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();
    if (lpFSH)
    {
        //
        // Verify that the lpFSH is in fact one we gave out; ie it is on the
        // vlpFindShadowList.
        //
        for (lpFSHtmp = vlpFindShadowList; lpFSHtmp; lpFSHtmp = lpFSHtmp->lpFSHNext) {
            if (lpFSHtmp == lpFSH) {
                break;
            }
        }
        if (lpFSHtmp != lpFSH) {
            iRet = -1;
            goto AllDone;
        }
        if (FindNextHSHADOW(lpFSH, &hTmp, &vsFind32, &(lpSI->uStatus), &sOI) >= SRET_OK)
        {
            *(lpSI->lpFind32) = vsFind32;
//            Find32AFromFind32((LPFIND32A)(lpSI->lpFind32), &vsFind32, BCS_WANSI);

            lpSI->hShare = 0;
            lpSI->hShadow = hTmp;
            CopyOtherInfoToShadowInfo(&sOI, lpSI);
            iRet = 1;
        }
    }
AllDone:
    LeaveShadowCrit();
    return(iRet);
}


int IoctlFindCloseHint(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = -1;
    LPFINDSHADOW lpFSH = (LPFINDSHADOW)(lpSI->uEnumCookie);

    if (!CSC_ENABLED)
    {
        return -1;
    }

    EnterShadowCrit();
    if (lpFSH)
    {
        DestroyFindShadow(lpFSH);
        iRet = 1;
    }
    LeaveShadowCrit();
    return(iRet);
}


int IoctlSetPriorityHSHADOW(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=SRET_ERROR;

    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    if (!FailModificationsToShare(lpSI))
    {
        iRet = SetPriorityHSHADOW(lpSI->hDir, lpSI->hShadow, lpSI->ulRefPri, lpSI->ulHintPri);
    }
    if (iRet < 0)
    {
        lpSI->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();
    return ((iRet >= SRET_OK)?1:-1);
}

int IoctlGetPriorityHSHADOW(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;

    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    iRet = GetPriorityHSHADOW(lpSI->hDir, lpSI->hShadow, &(lpSI->ulRefPri), &(lpSI->ulHintPri));
    if (iRet < 0)
    {
        lpSI->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();
    return ((iRet >= SRET_OK)?1:-1);
}


int IoctlGetAliasHSHADOW(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;
    HSHADOW hShadow, hDir;

    if (!CSC_ENABLED)
    {
        return -1;
    }


    EnterShadowCrit();
    iRet = GetRenameAliasHSHADOW(lpSI->hDir, lpSI->hShadow
                , &hDir, &hShadow);
    lpSI->hDir = hDir;
    lpSI->hShadow = hShadow;
    LeaveShadowCrit();
    return ((iRet >= SRET_OK)?1:-1);
}



LPFINDSHADOW    LpCreateFindShadow(
    HSHADOW          hDir,
    ULONG           uAttrib,
    ULONG           uSrchFlags,
    USHORT          *lpPattern,
    METAMATCHPROC   lpfnMMProc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int len;
    LPFINDSHADOW    lpFSH;

    //
    // Limit # outstanding FindOpens/HintOpens
    //
    if (vuFindShadowListCount >= 128) {
        return NULL;
    }

    len = wstrlen(lpPattern);
    lpFSH = (LPFINDSHADOW)AllocMem(sizeof(FINDSHADOW)+(len+1)*sizeof(USHORT));
    if (lpFSH)
    {
        lpFSH->lpPattern = (USHORT *)((UCHAR *)lpFSH + sizeof(FINDSHADOW));
        memcpy(lpFSH->lpPattern, lpPattern, (len+1)*sizeof(USHORT));

//        BCSToUni(lpFSH->lpPattern, lpPattern, len, BCS_WANSI);
        // Convert the patterns to uppercase, as demanded by metamatch
        UniToUpper(lpFSH->lpPattern, lpFSH->lpPattern, len*sizeof(USHORT));
        lpFSH->hDir = hDir;
        lpFSH->uAttrib = uAttrib;
        lpFSH->uSrchFlags = uSrchFlags;
        lpFSH->lpfnMMProc = lpfnMMProc;

        // link this in the list of outstanding ioctl finds
        lpFSH->lpFSHNext = vlpFindShadowList;
        vlpFindShadowList = lpFSH;
        vuFindShadowListCount++;
        ASSERT(vuFindShadowListCount <= 128);
    }
    return (lpFSH);
}


int DestroyFindShadow(
    LPFINDSHADOW    lpFSH
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = -1;
    LPFINDSHADOW    *lplpFSHT;

    if (lpFSH)
    {
        for (lplpFSHT = &vlpFindShadowList; *lplpFSHT; lplpFSHT = &((*lplpFSHT)->lpFSHNext))
        {
            if (*lplpFSHT == lpFSH)
            {
                *lplpFSHT = lpFSH->lpFSHNext;
                FreeMem(lpFSH);
                vuFindShadowListCount--;
                ASSERT(vuFindShadowListCount >= 0);
                iRet = 1;
                break;
            }
        }
    }
    return (iRet);
}


int
DeleteCallbackForFind(
    HSHADOW hDir,
    HSHADOW hShadow
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPFINDSHADOW    lpFSH;
    int iRet = 0;
    for (lpFSH = vlpFindShadowList; lpFSH ; lpFSH = lpFSH->lpFSHNext)
    {
        if (lpFSH->hDir == hShadow)
        {
            lpFSH->ulFlags |= FLAG_FINDSHADOW_INVALID_DIRECTORY;
            ++iRet;
        }
    }
    return iRet;
}

int HintobjMMProc( LPFIND32 lpFind32,
    HSHADOW  hDir,
    HSHADOW  hShadow,
    ULONG uStatus,
    LPOTHERINFO lpOI,
    LPFINDSHADOW    lpFSH
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;
    iRet = MM_RET_CONTINUE;    // Continue


    hDir;
    if (mIsHint(lpOI->ulHintFlags)&&
        IFSMgr_MetaMatch(lpFSH->lpPattern, lpFind32->cFileName,UFLG_NT|UFLG_META))
        iRet = MM_RET_FOUND_BREAK;

    return (iRet);
}


#ifdef MAYBE
int RecalcIHPri( HSHADOW  hDir,
    HSHADOW  hShadow,
    LPFIND32 lpFind32,
    LPOTHERINFO lpOI
    )
{
    USHORT *lpuType=NULL;
    int len, iRet=SRET_ERROR;
    SHADOWCHECK sSC;
    HSHADOW  hChild, hParent;
    ULONG ulFlagsIn, uStatus;

    if (GetShadowInfo(hParent = hDir, hChild = hShadow, lpFind32, &uStatus, NULL) != SRET_OK)
        goto bailout;

    len = wstrlen(lpFind32->cFileName)*2;

    if (!(lpuType = (USHORT *)AllocMem(len+2)))
        goto bailout;

    memcpy(lpuType, lpFind32->cFileName, len);
    memset(lpOI, 0, sizeof(OTHERINFO));
    do
    {
        memset(&sSC, 0, sizeof(SHADOWCHECK));
        sSC.lpuName = (USHORT *)hChild;
        sSC.lpuType = lpuType;
        sSC.uFlagsIn = ulFlagsIn;
        MetaMatchInit(&(sSC.ulCookie));
        if (MetaMatch(hParent, lpFind32, &(sSC.ulCookie), &hChild
                        , &uStatus, NULL
                        , GetShadowWithChecksProc
                        , &sSC)!=SRET_OK)
            goto bailout;

        if (mIsHint(sSC.ulHintFlags))
        {
            if (mHintExclude(sSC.ulHintFlags) || (lpOI->ulIHPri < sSC.ulHintPri))
            {
                lpOI->ulHintFlags = sSC.ulHintFlags;
                lpOI->ulIHPri = sSC.ulHintPri;
            }
            // If we find an exclusion hint here, we need to quit
            // because this is the closest exclusion hint we got
            if (mHintExclude(sSC.ulHintFlags))
                break;
        }
        if (!hParent)
            break;
        hChild = hParent;
        GetAncestorsHSHADOW(hChild, &hParent, NULL);
        // Start checking the subtree hints
        ulFlagsIn = FLAG_IN_SHADOWCHECK_SUBTREE;
    }
    while (TRUE);

    iRet = SRET_OK;
bailout:
    if (lpuType)
    {
        FreeMem(lpuType);
    }
    return (iRet);
}
#endif //MAYBE

int SetResourceFlags(
    HSHARE  hShare,
    ULONG uStatus,
    ULONG uOp
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
#ifndef CSC_RECORDMANAGER_WINNT
    PRESOURCE    pResource;

    if(pResource = PFindResourceFromHShare(hShare, 0xffff, 0))
    {
        switch (mBitOpShadowFlags(uOp))
        {
            case SHADOW_FLAGS_ASSIGN:
                pResource->usFlags = (USHORT)uStatus;
                break;
            case SHADOW_FLAGS_OR:
                pResource->usFlags |= (USHORT)uStatus;
                break;
            case SHADOW_FLAGS_AND:
                pResource->usFlags &= (USHORT)uStatus;
                break;
        }
    }
#else
    //on NT, we just make the one call, if it can't find it, then
    //it just does nothing......
    DeclareFindFromShadowOnNtVars()

    PSetResourceStatusFromHShare(hShare, 0xffff, 0, uStatus, uOp);

#endif //ifndef CSC_RECORDMANAGER_WINNT
    return(0);  //stop complaining about no return value
}


int PUBLIC MakeSpace(
    long    nFileSizeHigh,
    long    nFileSizeLow,
    BOOL    fClearPinned
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSC_ENUMCOOKIE  hPQ;
    PQPARAMS sPQP;
    int iRet = SRET_ERROR;
    SHADOWSTORE sShdStr;
    ULONG uSize = 0;
    ULONG uSizeIn;
    ULONG ulStartSeconds;

    DEBUG_LOG(RECORD, ("Begin MakeSpace\r\n"));

    ulStartSeconds = GetTimeInSecondsSince1970();
    Win32ToDosFileSize(nFileSizeHigh, nFileSizeLow, &uSizeIn);

    // DbgPrint("Begin Makespace(%d)\n", uSizeIn);

    if (GetShadowSpaceInfo(&sShdStr) < SRET_OK) {
        DbgPrint("MakeSpace: GetShadowSpaceInfo error\n");
        return SRET_ERROR;
    }
    // DbgPrint("  Before cleanup, max=%d cur=%d\n",
    //                 sShdStr.sMax.ulSize,
    //                 sShdStr.sCur.ulSize);
    if (
        (sShdStr.sMax.ulSize > sShdStr.sCur.ulSize)
            &&
        ((sShdStr.sMax.ulSize - sShdStr.sCur.ulSize) > uSizeIn)
    ) {
        // DbgPrint("Makespace exit (nothing to do)\n");
        return SRET_OK;
    }

    // Open the priority q
    if (!(hPQ = HBeginPQEnum())) {
        DbgPrint("MakeSpace: Error opening Priority Q database\n");
        return SRET_ERROR;
    }
    memset(&sPQP, 0, sizeof(PQPARAMS));
    sPQP.uEnumCookie = hPQ;
    //
    // go down the Q once
    //
    do {
        if (PrevPriSHADOW(&sPQP) < SRET_OK) {
            // DbgPrint("  PQ record read error\n");
            break;
        }
        if (sPQP.hShadow == 0)
            break;
        // Nuke only the files and only those which are not open
        // and are not pinned
        if (
            !mNotFsobj(sPQP.ulStatus) // It is a file system object
                &&
            (sPQP.ulStatus & SHADOW_IS_FILE) // It is a file
                &&
            // told to clear pinned or it is not pinned
            (fClearPinned || !(sPQP.ulHintPri || mPinFlags(sPQP.ulHintFlags)))
                &&
            !mShadowNeedReint(sPQP.ulStatus)  // It is not in use or is not dirty
        ) {
            if (PFindFdbFromHShadow(sPQP.hShadow)) {
                // DbgPrint("  Skipping busy shadow (0x%x)\n", sPQP.hShadow);
                continue;
            }
            if(DeleteShadowHelper(FALSE, sPQP.hDir, sPQP.hShadow) < SRET_OK) {
                // DbgPrint("  error Deleting shadow %x\n", sPQP.hShadow);
                break;
            }
            // get the latest data on how much space there is.
            // this takes care of rounding up the size to the cluster
            if (GetShadowSpaceInfo(&sShdStr) < SRET_OK) {
                // DbgPrint("  error reading space status\n");
                break;
            }
            // DbgPrint("  Deleted shadow 0x%x Cur=%d\n",
            //             sPQP.hShadow,
            //             sShdStr.sCur.ulSize);
            if (
                (sShdStr.sMax.ulSize > sShdStr.sCur.ulSize)
                    &&
                ((sShdStr.sMax.ulSize - sShdStr.sCur.ulSize)>uSizeIn)
            ) {
                // DbgPrint("  Makespace exit (done enough)\n");
                iRet = SRET_OK;
                break;
            }
        } else {
            // DbgPrint("  Skip 0x%x\n", sPQP.hShadow);
        }

        #if 0
        if ((int)( GetTimeInSecondsSince1970() - ulStartSeconds) > 30) {
            DbgPrint("  Aborting, have been in for more than 30 seconds\r\n");
            break;
        }
        #endif

    } while (sPQP.uPos);

    if (hPQ)
        EndPQEnum(hPQ);

    DEBUG_LOG(RECORD, ("End MakeSpace\r\n"));

    // DbgPrint("Makespace alldone exit %d (Max=%d Cur=%d)\n",
    //                 iRet,
    //                 sShdStr.sMax.ulSize,
    //                 sShdStr.sCur.ulSize);
    return (iRet);
}

LONG
PurgeUnpinnedFiles(
    ULONG     Timeout,
    PULONG    pnFiles,
    PULONG    pnYoungFiles)
{
    CSC_ENUMCOOKIE hPQ;
    PQPARAMS sPQP;
    ULONG nFiles = 0;
    ULONG nYoungFiles = 0;
    int iRet = SRET_ERROR;

    // DbgPrint("Begin PurgeUnpinnedFiles(%d)\n", Timeout);

    // Open the priority q
    hPQ = HBeginPQEnum();
    if (!hPQ) {
        // DbgPrint("PurgeUnpinnedFiles: Error opening Priority Q database\n");
        return iRet;
    }
    memset(&sPQP, 0, sizeof(PQPARAMS));
    sPQP.uEnumCookie = hPQ;
    iRet = SRET_OK;
    do {
        SHAREINFO ShareInfo;
        SHADOWINFO ShadowInfo;
        OTHERINFO OtherInfo;
        WIN32_FIND_DATA Find32;
        ULONG Status;
        ULONG cStatus;
        ULONG NowSec;
        ULONG FileSec;
        LARGE_INTEGER TimeNow;
        LARGE_INTEGER FileTime;

        iRet = PrevPriSHADOW(&sPQP);
        if (iRet < SRET_OK) {
            // DbgPrint("  PQ record read error\n");
            break;
        }
        if (sPQP.hShadow == 0)
            break;
        // Nuke only the files and only those which are not open
        // and are not pinned
        if (
            mNotFsobj(sPQP.ulStatus) != 0
                ||
            mShadowIsFile(sPQP.hShadow) != SHADOW_IS_FILE
                ||
            mPinFlags(sPQP.ulHintFlags) != 0
                ||
            mShadowNeedReint(sPQP.ulStatus) != 0
        ) {
            // DbgPrint("  Skip(1) (0x%x)\n", sPQP.hShadow);
            continue;
        }
        //
        // See if on manually cached share
        //
        iRet = GetShareInfo(sPQP.hShare, &ShareInfo, &ShadowInfo);
        if (iRet != SRET_OK) {
            // DbgPrint("  GetShareInfo(0x%x) returned %d\n", sPQP.hShare, GetLastErrorLocal());
            continue;
        }
        cStatus = ShadowInfo.uStatus & FLAG_CSC_SHARE_STATUS_CACHING_MASK;
        if (cStatus != FLAG_CSC_SHARE_STATUS_MANUAL_REINT) {
            // DbgPrint("  Skip(2) (0x%x)\n", sPQP.hShadow);
            continue;
        }
        iRet = GetShadowInfo(sPQP.hDir, sPQP.hShadow, &Find32, &Status, &OtherInfo);
        if (iRet != SRET_OK) {
            // DbgPrint("  GetShadowInfo(0x%x/0x%x) returned %d\n",
            //                     sPQP.hDir,
            //                     sPQP.hShadow,
            //                     GetLastErrorLocal());
            continue;
        }
        // DbgPrint("  Name:%ws Size:0x%x Attr:0x%x  ",
        //     Find32.cFileName,
        //     Find32.nFileSizeLow,
        //     Find32.dwFileAttributes);
        KeQuerySystemTime(&TimeNow);
        COPY_STRUCTFILETIME_TO_LARGEINTEGER(FileTime, Find32.ftLastAccessTime);
        RtlTimeToSecondsSince1970(&TimeNow, &NowSec);
        RtlTimeToSecondsSince1970(&FileTime, &FileSec);
        if (
            PFindFdbFromHShadow(sPQP.hShadow) == NULL
                &&
            (Timeout == 0 || (NowSec > FileSec && (NowSec - FileSec) > Timeout))
        ) {
            // DbgPrint("  YES!!!  ");
            if (DeleteShadowHelper(FALSE, sPQP.hDir, sPQP.hShadow) >= SRET_OK) {
                // DbgPrint("-Delete succeeded\n");
                nFiles++;
            } else {
                // DbgPrint("-Error (%d) deleting shadow 0x%x/0x%x\n",
                //                 GetLastErrorLocal(),
                //                 sPQP.hDir,
                //                 sPQP.hShadow);
            }
        } else {
            // DbgPrint("  NO!!!\n");
            nYoungFiles++;
        }
    } while (sPQP.uPos);
    EndPQEnum(hPQ);
    if (iRet >= SRET_OK) {
        *pnFiles = nFiles;
        *pnYoungFiles = nYoungFiles;
    }
    // DbgPrint("PurgeUnpinnedFiles exit %d (nFiles=%d nYoungFiles=%d)\n",
    //                 iRet,
    //                 *pnFiles,
    //                 *pnYoungFiles);
    return (iRet);
}

int
PUBLIC TraversePQToCheckDirtyBits(
    HSHARE hShare,
    DWORD   *lpcntDirty
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSC_ENUMCOOKIE  hPQ;
    PQPARAMS sPQP;
    int iRet = SRET_ERROR;
    ULONG   ulStartSeconds;

    *lpcntDirty = 0;
    ulStartSeconds = GetTimeInSecondsSince1970();

    // Open the priority q
    if (!(hPQ = HBeginPQEnum()))
    {
        AssertSz(FALSE, "CSC.TraversePQToCheckDirty:: Error opening Priority Q database\r\n");
        return SRET_ERROR;
    }

    memset(&sPQP, 0, sizeof(PQPARAMS));
    sPQP.uEnumCookie = hPQ;

    // go down the Q once
    do
    {
        if(NextPriSHADOW(&sPQP) < SRET_OK)
        {
            AssertSz(FALSE, "CSC.TraversePQToCheckDirty:: PQ record read error\r\n");
            goto bailout;
        }

        if (!sPQP.hShadow)
        {
            continue;
        }

        if ((sPQP.hShare == hShare)   // this share
            && !mNotFsobj(sPQP.ulStatus) // It is a file system object
            )
        {
            if(sPQP.ulStatus & SHADOW_MODFLAGS)
            {
                ++*lpcntDirty;
            }
        }

        if ((int)( GetTimeInSecondsSince1970() - ulStartSeconds) > 30)
        {
            KdPrint(("CSC.TraversePQToCheckDirty: Aborting, have been in for more than 30 seconds\r\n"));
            goto bailout;
        }

    }
    while (sPQP.uPos);

    iRet = SRET_OK;

bailout:
    if (hPQ)
        EndPQEnum(hPQ);
    return (iRet);
}

int PUBLIC ReduceRefPri(
    VOID
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSC_ENUMCOOKIE  hPQ;
    PQPARAMS sPQP;
    int iRet = SRET_ERROR;
    OTHERINFO    sOI;

    // Open the priority q
    if (!(hPQ = HBeginPQEnum()))
    {
        // AssertSz(FALSE, "ReduceRefPri: Error opening Priority Q database\r\n");
        return SRET_ERROR;
    }

    memset(&sPQP, 0, sizeof(PQPARAMS));
    sPQP.uEnumCookie = hPQ;
    do
    {
        if(PrevPriSHADOW(&sPQP) < SRET_OK)
        {
            goto bailout;
        }

        if (!sPQP.hShadow)
            break;

        if (!mNotFsobj(sPQP.ulStatus))
        {
            if (!(sPQP.ulStatus & SHADOW_IS_FILE))
                continue;
            InitOtherInfo(&sOI);
            if (sPQP.ulRefPri > 1)
            {
                sOI.ulRefPri = sPQP.ulRefPri-1;
                ChangePriEntryStatusHSHADOW(sPQP.hDir, sPQP.hShadow, 0, SHADOW_FLAGS_OR, TRUE, &sOI);
            }
        }
    }
    while (sPQP.uPos);
    iRet = SRET_OK;

bailout:
    if (hPQ)
        EndPQEnum(hPQ);
    return (iRet);
}

BOOL HaveSpace(
    long  nFileSizeHigh,
    long  nFileSizeLow
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    SHADOWSTORE sShdStr;
    ULONG uSizeIn;

    Win32ToDosFileSize(nFileSizeHigh, nFileSizeLow, &uSizeIn);

    if (!uSizeIn)
    {
        return TRUE;
    }

    if (GetShadowSpaceInfo(&sShdStr) < SRET_OK)
    {
        return SRET_ERROR;
    }

    if (((sShdStr.sMax.ulSize - sShdStr.sCur.ulSize) >= uSizeIn))
    {
        return TRUE;
    }

    return FALSE;
}

int
IoctlAddDeleteHintFromInode(
    LPSHADOWINFO    lpSI,
    BOOL            fAdd
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    OTHERINFO sOI;
    unsigned uStatus;
    int iRet = -1;

    if(GetShadowInfo(lpSI->hDir, lpSI->hShadow, NULL, &uStatus, &sOI) >= SRET_OK)
    {
        if (fAdd)
        {
            // increment the pin count if no flags to be altered or we are supposed to alter pin count
            if (!(lpSI->ulHintFlags) || mPinAlterCount(lpSI->ulHintFlags))
            {
                sOI.ulHintPri++;
            }

            sOI.ulHintFlags |= lpSI->ulHintFlags;

            if (sOI.ulHintPri > MAX_PRI)
            {
                lpSI->dwError = ERROR_INVALID_PARAMETER;
                goto bailout;
            }
        }
        else
        {
            sOI.ulHintFlags &= (~lpSI->ulHintFlags);

            // decrement the pin count if no flags to be altered or we are supposed to alter pin count
            if (!(lpSI->ulHintFlags) || mPinAlterCount(lpSI->ulHintFlags))
            {
                if (sOI.ulHintPri == MIN_PRI)
                {
                    lpSI->dwError = ERROR_INVALID_PARAMETER;
                    goto bailout;
                }

                --sOI.ulHintPri;
            }
        }

        if (SetShadowInfoEx(lpSI->hDir, lpSI->hShadow, NULL, 0, SHADOW_FLAGS_OR, &sOI, NULL, NULL) >= SRET_OK)
        {
            lpSI->ulHintFlags = sOI.ulHintFlags;
            lpSI->ulHintPri = sOI.ulHintPri;
            iRet = 1;
        }
        else
        {
            lpSI->dwError = ERROR_WRITE_FAULT;
        }
    }

bailout:
    return (iRet);
}


int
IoctlCopyShadow(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    PFDB pFdb=NULL;
    USHORT  *pusLocal;
    int iRet=-1;

    // the shadowcritical section is already taken

    iRet = CopyHSHADOW(lpSI->hDir, lpSI->hShadow, ((LPFIND32A)(lpSI->lpFind32))->cFileName, lpSI->lpFind32->dwFileAttributes);

    if (iRet >= SRET_ERROR)
    {
        pFdb = PFindFdbFromHShadow(lpSI->hShadow);

        if (pFdb)
        {
            pusLocal = PLocalFlagsFromPFdb(pFdb);

            Assert(pusLocal);

            if (pFdb->usFlags & SHADOW_DIRTY)
            {
                // set the snapshotted bit.
                // If by the time the file is closed, the snapshotted bit is still set
                // it is transferred back to SHADOW_DIRTY in disconnected state.

                // it is the job of the SetShadowInfo ioctl to clear the
                // snapshotted bit when the agent is coming down to
                // clear the modified bits on the shadow after
                // reintegration

                pFdb->usFlags &= ~SHADOW_DIRTY;

                *pusLocal |= FLAG_FDB_SHADOW_SNAPSHOTTED;


            }
        }
    }
    else
    {
        lpSI->dwError = GetLastErrorLocal();
    }

    return iRet;
}

int
IoctlChangeHandleCachingState(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

    lpSI    SHADOWINFO structure pointer.

            If lpSI->uStatus is FALSE, then handle caching is disabled, else it is enabled

Return Value:

Notes:

--*/
{
    lpSI->uStatus = EnableHandleCaching(lpSI->uStatus != FALSE);
    return 1;
}

int
IoctlRenameShadow(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

    Given a source Inode, rename it into a destination directory. The source and the
    destination can be across shares

Parameters:

    lpSI    SHADOWINFO structure pointer.


Return Value:

Notes:

    Shadow ciritcal section is already taken

--*/
{
    int iRet=-1;
    ULONG   uStatus, uStatusDest;
    HSHARE hShare;
    HSHADOW hShadowTo;
    BOOL    fReplaceFile = (lpSI->uStatus != 0); // yuk

    UseGlobalFind32();

    lpSI->dwError = ERROR_SUCCESS;

    // get the name of the shadow
    if (GetShadowInfo(lpSI->hDir, lpSI->hShadow, &vsFind32, &uStatus, NULL) >= 0)
    {
        // if it is open, bail
        if (PFindFdbFromHShadow(lpSI->hShadow))
        {
            SetLastErrorLocal(ERROR_ACCESS_DENIED);
        }
        else
        {
            if (lpSI->lpFind32)
            {
                vsFind32 = *lpSI->lpFind32;
                vsFind32.cAlternateFileName[0] = 0;
                MRxSmbCscGenerate83NameAsNeeded(lpSI->hDirTo,vsFind32.cFileName,vsFind32.cAlternateFileName);
            }

            // check if it already exists in the destination directory
            if ((GetShadow( lpSI->hDirTo,
                            vsFind32.cFileName,
                            &hShadowTo, NULL,
                            &uStatusDest, NULL) >= 0) && hShadowTo)
            {
                // try deleting if we are supposed to replace it
                if (fReplaceFile)
                {
                    if (DeleteShadow(lpSI->hDirTo, hShadowTo)< SRET_OK)
                    {
                        lpSI->dwError = GetLastErrorLocal();
                        Assert(lpSI->dwError != ERROR_SUCCESS);
                    }
                }
                else
                {
                    SetLastErrorLocal(ERROR_FILE_EXISTS);
                }
            }

            if (lpSI->dwError == ERROR_SUCCESS)
            {
                // just in case this is a rename across shares, get the handle to the share
                if (GetAncestorsHSHADOW(lpSI->hDirTo, NULL, &hShare) >= 0)
                {
                    // do the rename
                    iRet = RenameShadowEx(
                        lpSI->hDir,
                        lpSI->hShadow,
                        hShare,
                        lpSI->hDirTo,
                        &vsFind32,
                        uStatus,
                        NULL,
                        0,
                        NULL,
                        NULL,
                        &lpSI->hShadow
                        );

                    if (iRet < 0)
                    {
                        lpSI->dwError = GetLastErrorLocal();
                    }
                }
                else
                {
                    lpSI->dwError = GetLastErrorLocal();
                }
            }
        }
    }
    else
    {
        SetLastErrorLocal(ERROR_FILE_NOT_FOUND);
    }

    return ((iRet >= SRET_OK)?1:-1);
}



int IoctlEnableCSCForUser(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

    lpSI    SHADOWINFO structure pointer. 

Return Value:

    -1

Notes:


--*/
{
    int iRet = SRET_ERROR;

    EnterShadowCrit();

    if (fShadow)
    {
        lpSI->dwError = 0;
        iRet = SRET_OK;
    }
    else
    {
        if (OK_TO_ENABLE_CSC)
        {
            Assert(lpSI->lpFind32);
            //
            // Check that cFileName and cAlternateFileName contain a NULL
            //
            if (CscCheckForNullA(((LPFIND32A)(lpSI->lpFind32))->cFileName, MAX_PATH) == FALSE) {
                lpSI->dwError = ERROR_INVALID_PARAMETER;
                LeaveShadowCrit();
                return -1;
            }
            if (CscCheckForNullA(((LPFIND32A)(lpSI->lpFind32))->cAlternateFileName, 14) == FALSE) {
                lpSI->dwError = ERROR_INVALID_PARAMETER;
                LeaveShadowCrit();
                return -1;
            }
            // check if we can initialize the database
//            KdPrint(("Trying to shadow....%s\n",
//                           ((LPFIND32A)(lpSI->lpFind32))->cFileName));
            if(InitDatabase(
                    ((LPFIND32A)(lpSI->lpFind32))->cFileName,            // location
                    ((LPFIND32A)(lpSI->lpFind32))->cAlternateFileName,    // user
                    ((LPFIND32A)(lpSI->lpFind32))->nFileSizeHigh,        // default cache size if creating
                    ((LPFIND32A)(lpSI->lpFind32))->nFileSizeLow,
                    ((LPFIND32A)(lpSI->lpFind32))->dwReserved1, // cluster size
                    lpSI->ulRefPri,
                    &(lpSI->uOp))    // whether newly created
                    ==-1)
            {
                //we can't, let us quit
                lpSI->dwError = GetLastErrorLocal();
            }
            else
            {
//                KdPrint(("Starting to shadow....\n"));
                fShadow = 1;
                iRet = SRET_OK;
                sGS.uFlagsEvents |= FLAG_GLOBALSTATUS_START;
                MRxSmbCscSignalAgent(NULL, SIGNALAGENTFLAG_DONT_LEAVE_CRIT_SECT|SIGNALAGENTFLAG_CONTINUE_FOR_NO_AGENT);
            }
        }
        else
        {
            //we are not supposed to turn on csc. This happens only on NT
            lpSI->dwError = ERROR_ACCESS_DENIED;
        }

    }
    LeaveShadowCrit();
    return iRet;
}

int
IoctlDisableCSCForUser(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

    lpSI    SHADOWINFO structure pointer. 

Return Value:

    -1

Notes:


--*/
{
    int iRet = SRET_ERROR;

    if (!fShadow)
    {
        iRet = 1;        
    }
    else
    {
        if (!IsCSCBusy() && (hShareReint == 0))
        {
            ClearCSCStateOnRedirStructures();
            CloseDatabase();
            fShadow = 0;
            iRet = 1;
                sGS.uFlagsEvents |= FLAG_GLOBALSTATUS_STOP;
                MRxSmbCscSignalAgent(NULL, SIGNALAGENTFLAG_DONT_LEAVE_CRIT_SECT|SIGNALAGENTFLAG_CONTINUE_FOR_NO_AGENT);
        }
        else
        {
            SetLastErrorLocal(ERROR_BUSY);
        }
    }
    return iRet;
}



#ifndef CSC_RECORDMANAGER_WINNT
int
IoctlTransitionShareToOffline(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

    lpSI    SHADOWINFO structure pointer. lpSI->hShare identifies the share to take offline.
            if lpSI->uStatus is 0, the online to offline transition should fail.

Return Value:

    -1

Notes:

    fails on win9x

--*/
{
    return -1;
}

BOOL
FailModificationsToShare(
    LPSHADOWINFO   lpSI
    )
{
    return FALSE;
}
#else

BOOL
FailModificationsToShare(
    LPSHADOWINFO   lpSI
    )
{
    HSHARE hShare=0;
    HSHADOW hShadow = 0;

    // if no reintegration is in progress or if there is, it is blocking kind
    // then we don't fail share modifications

    if (!hShareReint || vfBlockingReint)
    {
        return FALSE;
    }

    if (!lpSI->hShare)
    {
        hShadow = (lpSI->hDir)?lpSI->hDir:lpSI->hShadow;

        if ((GetAncestorsHSHADOW(hShadow, NULL, &hShare) < SRET_OK)||
           (hShare == hShareReint))
        {
            SetLastErrorLocal(ERROR_OPERATION_ABORTED);
            return TRUE;
        }

    }

    return FALSE;
}


void
IncrementActivityCountForShare(
    HSHARE hShare
    )
{
    if (!hShareReint || vfBlockingReint)
    {
        return;
    }

    if (hShare == hShareReint)
    {
        vdwActivityCount++;
    }
}

BOOL
CSCFailUserOperation(
    HSHARE hShare
    )
/*++

Routine Description:

Parameters:

Return Value:


Notes:

--*/
{

    if (!hShareReint || !vfBlockingReint)
    {
        return FALSE;
    }

    return(hShare == hShareReint);
}

int
IoctlTransitionShareToOffline(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

    lpSI    SHADOWINFO structure pointer. lpSI->hShare identifies the share to take offline.
            if lpSI->uStatus is 0, the online to offline transition should fail.

Return Value:

Notes:


--*/
{
    return -1;

}

#endif


BOOLEAN
CscCheckForNullA(
    PUCHAR pBuf,
    ULONG Count)
{
    ULONG i;

    for (i = 0; i < Count; i++) {
        if (pBuf[i] == '\0') {
            return TRUE;
        }
    }
    return FALSE;
}

BOOLEAN
CscCheckForNullW(
    PWCHAR pBuf,
    ULONG Count)
{
    ULONG i;

    for (i = 0; i < Count; i++) {
        if (pBuf[i] == L'\0') {
            return TRUE;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\oslayer.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

     OsLayer.c

Abstract: (win95)

     none.

Abstract: (NT)

     We go thru these wrapper functions but the main implementation
     is in ntcsclow.c

Author:

     Shishir Pardikar      [Shishirp]        01-jan-1995

Revision History:

     Joe Linn              [joelinn]         01-jan-1997  ported to NT
     Joe Linn              [joelinn]         22-aug-1997  moved NT stuff to ntcsclow.c


--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

#ifndef CSC_RECORDMANAGER_WINNT
#define WIN32_APIS
#include "cshadow.h"
#endif //ifndef CSC_RECORDMANAGER_WINNT

//already included by shdcom.h #include "ifs.h"


#ifdef CSC_RECORDMANAGER_WINNT
#define Dbg (DEBUG_TRACE_MRXSMBCSC_OSLAYER)
RXDT_DefineCategory(MRXSMBCSC_OSLAYER);
#endif //ifdef CSC_RECORDMANAGER_WINNT

//#define RXJOECSC_WHACKTRACE_FOR_OSLAYER
#ifdef RXJOECSC_WHACKTRACE_FOR_OSLAYER
#undef RxDbgTrace
#define RxDbgTrace(a,b,__d__) {DbgPrint __d__;}
#endif

#ifdef  CSC_BUILD_W_PROGRESS_CATCHERS
VOID
CscProgressInit (
    PCSC_PROGRESS_BLOCK ProgressBlock,
    ULONG Counter,
    PVOID NearArgs
    )
{
    ProgressBlock->Counter = Counter;
    ProgressBlock->NearTop = &NearArgs;
    ProgressBlock->NearArgs = NearArgs;
    ProgressBlock->Progress = 0x80000000;
    ProgressBlock->LastBit = 0;
    ProgressBlock->Loops = 0;
    ProgressBlock->StackRemaining = IoGetRemainingStackSize();
    ProgressBlock->RetAddrP = ((PULONG)NearArgs)-1;  //that's one ulong, boys....
    ProgressBlock->RetAddr = *(ProgressBlock->RetAddrP);
    ProgressBlock->SignatureOfEnd = '!dne';
}
VOID
CscProgress (
    PCSC_PROGRESS_BLOCK ProgressBlock,
    ULONG Bit
    )
{
    if( (*(ProgressBlock->RetAddrP)) != ProgressBlock->RetAddr ) {
        DbgPrint("Returnaddr has been trashed %08lx %08lx %08lx %08lx\n",
                    ProgressBlock,Bit,
                    (*(ProgressBlock->RetAddrP)),
                    ProgressBlock->RetAddr);
        DbgBreakPoint();
    }
    ProgressBlock->Progress |= (1<<Bit);
    if (Bit <= ProgressBlock->LastBit) {
        ProgressBlock->Loops++;
    }
    ProgressBlock->LastBit = Bit;
}
#endif //ifdef CSC_RECORDMANAGER_WINNT


/*
*/
/********************** typedefs and defines ********************************/
#ifdef HISTORY
#define R0_OPENCREATE    0xD500
#define R0_READ            0xD600
#define R0_WRITE          0xD601
#define R0_CLOSE          0xD700
#define R0_GETFILESIZE  0xD800
#define R0_RENAMEFILE    0x5600
#define R0_FILELOCK      0x5C00
#define R0_GETATTRIBUTE 0x4300
#define R0_SETATTRIBUTE 0x4301
#define R0_DELETEFILE    0x4100
#endif //HISTORY
#define R0_UNLOCKFILE    0x5C01
#define R0_SETATTRIBUTE 0x4301
#pragma intrinsic (memcmp, memcpy, memset, strcat, strcmp, strcpy, strlen)

/********************** static data *****************************************/
/********************** global data *****************************************/

AssertData;
AssertError;
/********************** function prototypes *********************************/

int Ring0Api();


/****************************************************************************/

/************************ File I/O ******************************************/

#ifndef CSC_RECORDMANAGER_WINNT
#pragma VxD_LOCKED_CODE_SEG
#endif //ifndef CSC_RECORDMANAGER_WINNT

long R0ReadWriteFile (ULONG uOper, CSCHFILE handle, ULONG pos, PVOID, long lCount);
#ifndef R0ReadWriteFileEx
long R0ReadWriteFileEx (ULONG uOper, CSCHFILE handle, ULONG pos, PVOID, long lCount, BOOL fInstrument);
#endif  //ifndef R0ReadWriteFile
#ifndef R0ReadWriteFileEx2
long R0ReadWriteFileEx2 (ULONG uOper, CSCHFILE handle, ULONG pos, PVOID, long lCount, ULONG uFlags);
#endif  //ifndef R0ReadWriteFileEx2

CSCHFILE CreateFileLocal(LPSTR lpPath)
{
    return (R0OpenFile(ACCESS_READWRITE, ACTION_OPENALWAYS, lpPath));
}

CSCHFILE OpenFileLocal(LPSTR lpPath)
{
    return (OpenFileLocalEx(lpPath, FALSE));
}
CSCHFILE OpenFileLocalEx(LPSTR lpPath, BOOL fInstrument)
{
    CSCHFILE hf;
//    unsigned uSize;

    hf = R0OpenFileEx(ACCESS_READWRITE, ACTION_OPENEXISTING, 0, lpPath, fInstrument);

#ifdef DEBUG
    if (!hf)
        KdPrint(("OpenFileLocal: error opening %s \r\n", lpPath));
#endif //DEBUG

#ifdef OBSOLETE
    // BUGBUG-win9xonly temporary kludge till fixed in IFS
    hf = R0OpenFile(ACCESS_READWRITE, ACTION_OPENALWAYS, lpPath);
    if (hf)
    {
        if ((GetFileSizeLocal(hf, &uSize) < 0 ) || !uSize)
        {
            CloseFileLocal(hf);
            hf = CSCHFILE_NULL;
        }
    }
#endif //OBSOLETE
    return (hf);
}


int FileExists
    (
    LPSTR lpPath
    )
{
    CSCHFILE hf;
    if (hf = R0OpenFile(ACCESS_READWRITE, ACTION_OPENEXISTING, lpPath))
    {
        CloseFileLocal(hf);
    }
    return (hf != CSCHFILE_NULL);
}

long ReadFileLocal
    (
    CSCHFILE handle,
    ULONG pos,
    LPVOID pBuff,
    long  lCount
    )
{
    return(R0ReadWriteFile(R0_READFILE, handle, pos, pBuff,lCount));
}

long ReadFileLocalEx
    (
    CSCHFILE handle,
    ULONG pos,
    LPVOID pBuff,
    long  lCount,
    BOOL  fInstrument
    )
{
    return(R0ReadWriteFileEx(R0_READFILE, handle, pos, pBuff,lCount, fInstrument));
}

long ReadFileLocalEx2
    (
    CSCHFILE handle,
    ULONG pos,
    LPVOID pBuff,
    long  lCount,
    ULONG   flags
    )
{
    return(R0ReadWriteFileEx2(R0_READFILE, handle, pos, pBuff, lCount, flags));
}

long WriteFileLocal
    (
    CSCHFILE handle,
    ULONG pos,
    LPVOID pBuff,
    long  lCount
    )
{
    return(R0ReadWriteFile(R0_WRITEFILE, handle, pos, pBuff, lCount));
}

long WriteFileLocalEx
    (
    CSCHFILE handle,
    ULONG pos,
    LPVOID pBuff,
    long  lCount,
    BOOL    fInstrument
    )
{
    return(R0ReadWriteFileEx(R0_WRITEFILE, handle, pos, pBuff, lCount, FALSE));
}

long WriteFileLocalEx2(
    CSCHFILE      hf,
    unsigned    long lSeek,
    LPVOID      lpBuff,
    long         cLength,
    ULONG       flags
    )
{
    return (R0ReadWriteFileEx2(R0_WRITEFILE, hf, lSeek, lpBuff, cLength, flags));
}

long ReadFileInContextLocal
    (
    CSCHFILE handle,
    ULONG pos,
    LPVOID pBuff,
    long  lCount
    )
{
    return(R0ReadWriteFile(R0_READFILE_IN_CONTEXT, handle, pos, pBuff,lCount));
}

long WriteFileInContextLocal
    (
    CSCHFILE handle,
    ULONG pos,
    LPVOID pBuff,
    long  lCount
    )
{
    return(R0ReadWriteFile(R0_WRITEFILE_IN_CONTEXT, handle, pos, pBuff, lCount));
}


#ifndef CSC_RECORDMANAGER_WINNT
ULONG CloseFileLocal
    (
    CSCHFILE handle
    )
{
    ULONG uOp = R0_CLOSEFILE;
    _asm
    {
        mov    eax,  uOp
        mov    ebx,  handle
        call  Ring0Api
        jc     error
        xor    eax,eax
error:
    }
}
#endif //ifndef CSC_RECORDMANAGER_WINNT

CSCHFILE R0OpenFile
    (
    USHORT usOpenFlags,
    UCHAR  bAction,
    LPSTR lpPath
    )
    {
        return (R0OpenFileEx(usOpenFlags, bAction, FILE_ATTRIBUTE_NORMAL, lpPath, FALSE));
    }

#ifndef CSC_RECORDMANAGER_WINNT
CSCHFILE R0OpenFileEx
    (
    USHORT  usOpenFlags,
    UCHAR   bAction,
    ULONG   ulAttr,
    LPSTR   lpPath,
    BOOL    fInstrument
    )
{
    ULONG uOper = R0_OPENCREATFILE;
    UCHAR bR0Opt = R0_SWAPPER_CALL;
    ulAttr; // ignore ulAttr on win9x
    _asm
    {
        mov    eax,  uOper
        mov    bx,    usOpenFlags
        mov    cx,    0
        mov    dl,    bAction
        mov    dh,    bR0Opt
        mov    esi,  lpPath
        call  Ring0Api
        jnc    ok
        xor    eax,eax
ok:
    }
}
#endif //ifndef CSC_RECORDMANAGER_WINNT


long R0ReadWriteFile
    (
    ULONG       uOper,
    CSCHFILE    handle,
    ULONG       pos,
    PVOID       pBuff,
    long        lCount
    )
    {
    return (R0ReadWriteFileEx(uOper, handle, pos, pBuff, lCount, FALSE));
    }

#ifndef CSC_RECORDMANAGER_WINNT
long R0ReadWriteFileEx (// YUK
    ULONG   uOper,
    CSCHFILE handle,
    ULONG   pos,
    PVOID   pBuff,
    long    lCount,
    BOOL    fInstrument // don't care
    )
{
    return (R0ReadWriteFileEx2(uOper, handle, pos, pBuff, lCount, 0));

}

long R0ReadWriteFileEx2
    (
    ULONG   uOper,
    CSCHFILE handle,
    ULONG   pos,
    PVOID   pBuff,
    long    lCount,
    ULONG   ulFlags
    )
{
    int retValue;
    if (lCount < 0 )
        return -1;
    _asm
    {
        mov    eax,  uOper
        mov    ebx,  handle
        mov    ecx,  lCount
        mov    edx,  pos
        mov    esi,  pBuff
        call  Ring0Api
        jnc     done
        mov    eax,0xffffffff

;        neg    eax        ; return negative error codes
done:
    }
}
#endif //ifndef CSC_RECORDMANAGER_WINNT

#ifndef CSC_RECORDMANAGER_WINNT
int GetFileSizeLocal
    (
    CSCHFILE handle,
    PULONG lpuSize
    )
{
    ULONG uSize;
    int iRes=0;
    _asm
    {
        mov    eax,  R0_GETFILESIZE
        mov    ebx,  handle
        call  Ring0Api
        jnc    ok
        mov    iRes,0xffffffff
ok:
        mov    uSize, eax
    }
    *lpuSize = uSize;
    return (iRes);
}
#endif //ifndef CSC_RECORDMANAGER_WINNT

#ifndef CSC_RECORDMANAGER_WINNT
int GetAttributesLocal
    (
    LPSTR lpPath,
    ULONG *lpuAttributes
    )
{
    int iRes=0;
    USHORT usAttrib=0;

    _asm
    {
        mov    eax,  R0_FILEATTRIBUTES
        mov    esi,  lpPath
        call  Ring0Api
        jnc    ok
        mov    iRes,0xffffffff
ok:
        mov    usAttrib, cx
    }
    *lpuAttributes = (ULONG)usAttrib;
    return (iRes);
}
#endif //ifndef CSC_RECORDMANAGER_WINNT

#ifndef CSC_RECORDMANAGER_WINNT
int SetAttributesLocal
    (
    LPSTR lpPath,
    ULONG uAttributes
    )
{
    int iRes=0;
    USHORT usAttrib=(USHORT)uAttributes;
    _asm
    {
        mov    eax,  R0_SETATTRIBUTE
        mov    esi,  lpPath
        mov    cx,    usAttrib
        call  Ring0Api
        jnc    ok
        mov    iRes,0xffffffff
ok:
    }
    return (iRes);
}
#endif //ifndef CSC_RECORDMANAGER_WINNT

#ifndef CSC_RECORDMANAGER_WINNT
int RenameFileLocal
    (
    LPSTR lpFrom,
    LPSTR lpTo
    )
{
    int iRes=0;
#ifdef DEBUG
    int iErr;
#endif //DEBUG

    _asm
    {
        mov    eax,  R0_RENAMEFILE
        mov    esi,  lpFrom
        mov    edx,  lpTo
        call  Ring0Api
        jnc    ok
        mov    iRes,0xffffffff
#ifdef    DEBUG
        mov    iErr,eax
#endif
ok:
    }
#ifdef DEBUG
    if (iRes == 0xffffffff)
    {
        KdPrint(("RenameFileLocal: error %d renaming %s to %s\r\n", iErr, lpFrom, lpTo));
    }
#endif //DEBUG
    return (iRes);
}
#endif //ifndef CSC_RECORDMANAGER_WINNT

#ifndef CSC_RECORDMANAGER_WINNT
int DeleteFileLocal
    (
    LPSTR lpName,
    USHORT usAttrib
    )
{
    int iRes=0;
#ifdef DEBUG
    int iErr;
#endif //DEBUG

    _asm
    {
        mov    eax,  R0_DELETEFILE
        mov    esi,  lpName
        mov    cx,    usAttrib
        call  Ring0Api
        jnc    ok
        mov    iRes,0xffffffff
#ifdef    DEBUG
        mov    iErr,eax
#endif
ok:
    }
#ifdef DEBUG
    if (iRes == 0xffffffff)
    {
        KdPrint(("DeleteFileLocal: error %d deleting %s \r\n", iErr, lpName));
    }
#endif //DEBUG
    return (iRes);
}
#endif //ifndef CSC_RECORDMANAGER_WINNT

int GetDiskFreeSpaceLocal(
    int indx,
    ULONG *lpuSectorsPerCluster,
    ULONG *lpuBytesPerSector,
    ULONG *lpuFreeClusters,
    ULONG *lpuTotalClusters
    )
{
#ifndef CSC_RECORDMANAGER_WINNT
    int iRes = 0;
    BYTE bIndx = (BYTE)indx;
    USHORT  usSPC, usBPS, usFC, usTC;
    _asm
    {
        mov    eax, R0_GETDISKFREESPACE
        mov    dl, bIndx
        call  Ring0Api
        jnc    ok
        mov    iRes, 0xffffffff
        jmp    done
ok:
        mov    usSPC, ax
        mov    usBPS, cx
        mov    usFC,  bx
        mov    usTC,  dx
done:
    }
    if (!iRes)
    {
        *lpuSectorsPerCluster = (ULONG)usSPC;
        *lpuBytesPerSector = (ULONG)usBPS;
        *lpuFreeClusters = (ULONG)usFC;
        *lpuTotalClusters = (ULONG)usTC;
    }
    return (iRes);
#else
    ASSERT(FALSE);
    return(-1);
#endif //ifndef CSC_RECORDMANAGER_WINNT
}

int FileLockLocal( CSCHFILE hf,
    ULONG offsetLock,
    ULONG lengthLock,
    ULONG idProcess,
    BOOL  fLock
    )
{
#ifndef CSC_RECORDMANAGER_WINNT
    int iRes = 0;
    ULONG uOp = (fLock)?R0_LOCKFILE:R0_UNLOCKFILE;
    _asm
    {
        mov    eax, uOp
        mov    ebx, hf
        mov    edx, offsetLock
        mov    esi, lengthLock
        mov    ecx, idProcess
        call  Ring0Api
        jnc    ok
        mov    iRes,0xffffffff
ok:
    }
    return (iRes);
#else
    ASSERT(FALSE);
    return(-1);
#endif //ifndef CSC_RECORDMANAGER_WINNT
}

int FindOpenRemote
    (
    PIOREQ pir,
    LPHFREMOTE  lphFind
    )
{
    int iRet;
    PRESOURCE pResource = pir->ir_rh;
    PFINDINFO pFindInfo;
    hndlfunc hfnSav;
    hfunc_t pSav;

    if(!(pFindInfo = (PFINDINFO)PAllocElem(SizeofFindRemote)))
    {
#if VERBOSE > 1
        KdPrint(("FindOpenRemote: Error creating FindOpen structure \r\n"));
#endif //VERBOSE > 1
        return -1;  // BUGBUG-win9xonly return proper error code
    }

    mSetBits(pFindInfo->usLocalFlags, FLAG_FINDINFO_INTERNAL_HANDLE);
    // HACK save the ioreq structure
    pFindInfo->pnextFindInfo = (PFINDINFO)pir;
    // Save it
    memcpy(LpIoreqFromFindInfo(pFindInfo), pir, sizeof(ioreq));

    pir->ir_data = LpFind32FromFindInfo(pFindInfo);
    pir->ir_attr = FILE_ATTRIBUTE_ALL;
    pir->ir_error = 0;
    pir->ir_flags = RESTYPE_DISK;
    pSav = pir->ir_hfunc;
    pir->ir_hfunc = (hfunc_t)&hfnSav;
    pir->ir_rh = pResource->rhPro;

    (*(pResource->pVolTab->vfn_func[VFN_FINDOPEN]))(pir);
    iRet = pir->ir_error;
    pir->ir_hfunc = pSav;
    pir->ir_rh = (rh_t)pResource;
    pir->ir_error = 0;

    if (!iRet)
    {
        // succeeded

        // Save his file handle
        pFindInfo->fhProFind = pir->ir_fh;

        // Save his function table
        pFindInfo->hfFindHandle = hfnSav;

        // point back to our parent
        pFindInfo->pResource = pResource;

#if VERBOSE > 1
    {

        KdPrint(("FindOpenRemote: lpFind32=%x Lowdate=%x Highdate=%x \r\n"
                    , LpFind32FromFindInfo(pFindInfo)
                    , LpFind32FromFindInfo(pFindInfo)->ftLastWriteTime.dwLowDateTime
                    , LpFind32FromFindInfo(pFindInfo)->ftLastWriteTime.dwHighDateTime));
    }
#endif //VERBOSE > 1
    }
    else
    {
        memcpy(pir, LpIoreqFromFindInfo(pFindInfo), sizeof(ioreq));
        FreeMem(pFindInfo);
#if VERBOSE < 2
        if (iRet != ERROR_NO_MORE_FILES)
#endif //VERBOSE < 2
#if    VERBOSE > 1
            KdPrint(("FindOpenRemote: Error %x \r\n", iRet));
#endif //VERBOSE > 1
        pFindInfo = NULL;
    }

    *lphFind = (HFREMOTE)pFindInfo;
    return (iRet);
}

int FindNextRemote
    (
    PFINDINFO pFindInfo,
    PIOREQ    pir
    )
{
    PRESOURCE pResource = pir->ir_rh;
    int iRet;

    if (mQueryBits(pFindInfo->usLocalFlags, FLAG_FINDINFO_INTERNAL_HANDLE))
    {
        pir = (PIOREQ)(pFindInfo->pnextFindInfo);
    }
    else
    {
        Assert(pir);
    }
    pir->ir_data = LpFind32FromFindInfo(pFindInfo);
    pir->ir_error = 0;

    pir->ir_rh = pFindInfo->pResource->rhPro;
    pir->ir_fh = pFindInfo->fhProFind;
    (*(pFindInfo->hfFindHandle.hf_read))(pir);
    iRet = pir->ir_error;
    pir->ir_rh = (rh_t)(pFindInfo->pResource);
    pir->ir_error = 0;
    return (iRet);
}

int FindCloseRemote
    (
    PFINDINFO pFindInfo,
    PIOREQ    pir
    )
{
    PRESOURCE pResource = pir->ir_rh;
    int iRet;

    if (mQueryBits(pFindInfo->usLocalFlags, FLAG_FINDINFO_INTERNAL_HANDLE))
    {
        pir = (PIOREQ)(pFindInfo->pnextFindInfo);
    }

#if VERBOSE > 1
    KdPrint(("FindCloseRemote: hfind= %x fh=%x\r\n", pFindInfo, pFindInfo->fhProFind));
#endif //VERBOSE > 1
    pir->ir_error = 0;
    pir->ir_rh = pFindInfo->pResource->rhPro;
    pir->ir_fh = pFindInfo->fhProFind;
    (*(pFindInfo->hfFindHandle.hf_misc->hm_func[HM_CLOSE]))(pir);
    iRet = pir->ir_error;
    pir->ir_rh = (rh_t)(pFindInfo->pResource);
    pir->ir_error = 0;
    if (iRet)
    {
#if VERBOSE > 1
        KdPrint(("FindCloseRemote: error hf= %x #=%x \r\n", pFindInfo, iRet));
#endif //VERBOSE > 1
    }
    if (mQueryBits(pFindInfo->usLocalFlags, FLAG_FINDINFO_INTERNAL_HANDLE))
    {
        Assert(pir == (PIOREQ)(pFindInfo->pnextFindInfo));
        memcpy(pir, LpIoreqFromFindInfo(pFindInfo), sizeof(ioreq));
        FreeMem(pFindInfo);
    }
    return (iRet);
}


int OpenFileRemote
    (
    PIOREQ    pir,
    LPHFREMOTE  lphFile
    )
{
    return (OpenFileRemoteEx(pir, ACCESS_READWRITE, ACTION_OPENEXISTING, 0, lphFile));
}

int OpenFileRemoteEx
    (
    PIOREQ    pir,
    UCHAR uchAccess,
    USHORT usOptions,
    ULONG  ulAttr,
    LPHFREMOTE  lphFile
    )
{
    PRESOURCE pResource = (PRESOURCE)(pir->ir_rh);
    PFILEINFO pFileInfo;
    hndlfunc hfnSav;
    hfunc_t pSav;

    int iRet;

    if(!(pFileInfo = (PFILEINFO)PAllocElem(SizeofFileRemote)))
    {
        KdPrint(("OpenFileRemoteEx: Error creating File structure \r\n"));
        return -1;  // BUGBUG-win9xonly return proper error code
    }

    mSetBits(pFileInfo->usLocalFlags, FLAG_FILEINFO_INTERNAL_HANDLE);

    // HACK save the ioreq structure pointer
    pFileInfo->pnextFileInfo = (PFILEINFO)pir;

    // Save it
    memcpy(LpIoreqFromFileInfo(pFileInfo), pir, sizeof(ioreq));


    pir->ir_flags = uchAccess;
    pir->ir_options = usOptions;
    pir->ir_attr = ulAttr;

     // Plug his resource handle back
    pir->ir_rh = pResource->rhPro;

    // Plug this in so servers understanding case can use it
    pir->ir_uFName = IFSLastElement(pir->ir_ppath)->pe_unichars;
    pSav = pir->ir_hfunc;
    memset((LPVOID)&hfnSav, 0, sizeof(hndlfunc));
    pir->ir_hfunc = (hfunc_t)&hfnSav;

    // and call his function
    (*(pResource->pVolTab->vfn_func[VFN_OPEN]))(pir);
    iRet = pir->ir_error;

    pir->ir_hfunc = pSav;
     // Plug our resource handle
    pir->ir_rh = (rh_t)pResource;
    pir->ir_error = 0;
    if (!iRet)
    {
        // succeeded

        // Save his file handle
        pFileInfo->fhProFile = pir->ir_fh;

        // Save his function table
        pFileInfo->hfFileHandle = hfnSav;

        // point back to our parent
        pFileInfo->pResource = pResource;

#if VERBOSE > 1
        KdPrint(("OpenFileRemote:  pFileInfo= %x fhPro=%x, read=%x write=%x\r\n"
            , pFileInfo, pFileInfo->fhProFile,
            hfnSav.hf_read, hfnSav.hf_write));
#endif //VERBOSE > 1
    }
    else
    {
        memcpy(pir, LpIoreqFromFileInfo(pFileInfo), sizeof(ioreq));
        FreeMem(pFileInfo);
#if VERBOSE > 1
        KdPrint(("OpenFileRemote: Error %x \r\n", iRet));
#endif //VERBOSE > 1
        pFileInfo = NULL;
    }

    *lphFile = (HFREMOTE)pFileInfo;
    return (iRet);
}


int ReadFileRemote(
    PFILEINFO    pFileInfo,
    PIOREQ    pir,
    ULONG pos,
    LPVOID    lpBuff,
    ULONG count
    )
{
    int iRet;

    if(mQueryBits(pFileInfo->usLocalFlags, FLAG_FILEINFO_INTERNAL_HANDLE))
    {
        pir = (PIOREQ)(pFileInfo->pnextFileInfo);
    }
    pir->ir_data = lpBuff;
    pir->ir_length = count;
    pir->ir_pos = pos;
    pir->ir_options = 0;
    pir->ir_sfn = pFileInfo->sfnFile;
    pir->ir_pid = pFileInfo->pidFile;
    pir->ir_user = pFileInfo->userFile;
    pir->ir_rh = pFileInfo->pResource->rhPro;
    pir->ir_fh = pFileInfo->fhProFile;

    (*(pFileInfo->hfFileHandle.hf_read))(pir);
    iRet = pir->ir_error;
    pir->ir_rh = (rh_t)(pFileInfo->pResource);
    return ((!iRet)?pir->ir_length:-1);
}

int WriteFileRemote(
    PFILEINFO    pFileInfo,
    PIOREQ    pir,
    ULONG pos,
    LPVOID    lpBuff,
    ULONG count
    )
{
    int iRet;

    if(mQueryBits(pFileInfo->usLocalFlags, FLAG_FILEINFO_INTERNAL_HANDLE))
    {
        pir = (PIOREQ)(pFileInfo->pnextFileInfo);
    }

    pir->ir_data = lpBuff;
    pir->ir_length = count;
    pir->ir_pos = pos;
    pir->ir_options = 0;
    pir->ir_sfn = pFileInfo->sfnFile;
    pir->ir_pid = pFileInfo->pidFile;
    pir->ir_user = pFileInfo->userFile;
    pir->ir_rh = pFileInfo->pResource->rhPro;
    pir->ir_fh = pFileInfo->fhProFile;
    (*(pFileInfo->hfFileHandle.hf_write))(pir);
    iRet = pir->ir_error;
    pir->ir_rh = (rh_t)(pFileInfo->pResource);
    return ((!iRet)?pir->ir_length:-1);
}

int TimeStampRemote(
    PFILEINFO    pFileInfo,
    LPFILETIME  lpFt,
    int            type
    )
{
    BOOL fGetType;
    ioreq ir;
    PIOREQ pir = &ir;
    int iRet;

    fGetType = ((type==GET_MODIFY_DATETIME)||
                    (type==GET_LAST_ACCESS_DATETIME)||
                    (type==GET_CREATION_DATETIME));

    pir->ir_flags = (UCHAR)type;
    pir->ir_sfn = pFileInfo->sfnFile;
    pir->ir_pid = pFileInfo->pidFile;
    pir->ir_user = pFileInfo->userFile;
    pir->ir_rh = pFileInfo->pResource->rhPro;
    pir->ir_fh = pFileInfo->fhProFile;
    pir->ir_options = 0;
    if (!fGetType)
    {
        pir->ir_dostime = IFSMgr_Win32ToDosTime(*lpFt);
    }
    (*(pFileInfo->hfFileHandle.hf_write))(pir);
    iRet = pir->ir_error;
    if (!iRet && fGetType)
    {
        *lpFt = IFSMgr_DosToWin32Time(pir->ir_dostime);
    }
    return (iRet);
}

int CloseFileRemote(
    PFILEINFO    pFileInfo,
    PIOREQ        pir
    )
{
    int iRet;

    if(mQueryBits(pFileInfo->usLocalFlags, FLAG_FILEINFO_INTERNAL_HANDLE))
    {
        pir = (PIOREQ)(pFileInfo->pnextFileInfo);
    }

    pir->ir_rh = pFileInfo->pResource->rhPro;
    pir->ir_fh = pFileInfo->fhProFile;
    pir->ir_options = 0;
    pir->ir_flags = CLOSE_FINAL;
    (*(pFileInfo->hfFileHandle.hf_misc->hm_func[HM_CLOSE]))(pir);
    iRet = pir->ir_error;
    if (iRet)
    {
        KdPrint(("CloseFileRemote: error hf= %x #=%x \r\n", pFileInfo, iRet));
    }
    else
    {
    }
    pir->ir_rh = (rh_t)(pFileInfo->pResource);

    if (mQueryBits(pFileInfo->usLocalFlags, FLAG_FILEINFO_INTERNAL_HANDLE))
    {
        memcpy((PIOREQ)(pFileInfo->pnextFileInfo), LpIoreqFromFileInfo(pFileInfo), sizeof(ioreq));
        FreeMem(pFileInfo);
    }

    return (iRet);
}


int CloseAllRemoteFiles( PRESOURCE    pResource
    )
{
    PFILEINFO pFileInfo = NULL;
    PFDB pFdb = NULL;
    ioreq sIoreq;

    for (pFileInfo = pResource->pheadFileInfo; pFileInfo; pFileInfo=pFileInfo->pnextFileInfo)
    {
        if (IsDupHandle(pFileInfo))
            continue;
        pFdb = pFileInfo->pFdb;
        if (pFileInfo->fhProFile)
        {
            // Do final close only once
            if (!(pFdb->usLocalFlags & FLAG_FDB_FINAL_CLOSE_DONE))
            {
                memset(&sIoreq, 0, sizeof(ioreq));
                CloseFileRemote(pFileInfo, &sIoreq);
                pFdb->usLocalFlags |= FLAG_FDB_FINAL_CLOSE_DONE;
            }

            pFileInfo->fhProFile = 0;
            if (pFileInfo->hfShadow)
            {
                if (mShadowSparse(pFdb->usFlags))
                {
                    CloseFileLocal(pFileInfo->hfShadow);
                    pFileInfo->hfShadow = 0;
                    mSetBits(pFileInfo->usLocalFlags, FLAG_FILEINFO_INVALID_HANDLE);
                }
            }
            else
            {
                mSetBits(pFileInfo->usLocalFlags, FLAG_FILEINFO_INVALID_HANDLE);
            }
        }
    }
    for (pFdb = pResource->pheadFdb; pFdb; pFdb = pFdb->pnextFdb)
    {
        pFdb->usLocalFlags &= ~FLAG_FDB_FINAL_CLOSE_DONE;
    }
    return SRET_OK;
}

int CloseAllRemoteFinds( PRESOURCE    pResource
    )
{
    PFINDINFO pFindInfo = NULL;
    ioreq sIoreq;

    for (pFindInfo = pResource->pheadFindInfo; pFindInfo; pFindInfo=pFindInfo->pnextFindInfo)
    {
        if (pFindInfo->fhProFind)
        {
            memset(&sIoreq, 0, sizeof(ioreq));
            FindCloseRemote(pFindInfo, &sIoreq);
            pFindInfo->fhProFind = 0;
            pFindInfo->usLocalFlags |= FLAG_FINDINFO_INVALID_HANDLE;
        }
    }
    return SRET_OK;
}


int DisconnectResource(
    PRESOURCE pResource
    )
{
#ifdef RESOURCE
    ioreq sIoreq;

    CloseAllRemoteFiles(pResource);
    CloseAllRemoteFinds(pResource);

    memset(&sIoreq, 0, sizeof(ioreq));

    Assert(pResource->rhPro);
    Assert(pResource->pVolTab);

    // Let us restore his rh
    sIoreq.ir_rh = pResource->rhPro;

    // and call his function
    (*(pResource->pVolTab->vfn_func[VFN_DISCONNECT]))(&sIoreq);

    pResource->rhPro = 0;
    pResource->pVolTab = 0;
    return(sIoreq.ir_error);
#endif //RESOURCE
    return (0);
}


#ifdef LATER

int PUBLIC CommitFile(
    CSCHFILE hf
    )
{
    return (-1);
}

#endif
/*************************** Utility Functions ******************************/
#ifndef CSC_RECORDMANAGER_WINNT

//for NT, these have been macro-ed to the appropriate Rx Functions
LPVOID AllocMem
    (
    ULONG uSize
    )
{
    LPVOID lpBuff;

    if (lpBuff = (LPVOID)FGHS(uSize))
    {
        memset(lpBuff, 0, uSize);
    }
    return (lpBuff);
}

VOID FreeMem
    (
    LPVOID lp
    )
{
//    CheckHeap(lp);

    if (lp)
    {
        RetHeap(lp);
    }
}

//for NT, these have been macro-ed to the appropriate Rx Functions
LPVOID AllocMemPaged(
    ULONG   uSize
    )
{
    return NULL;
}

//for NT, these have been macro-ed to the appropriate Rx Functions
VOID FreeMemPaged(
    LPVOID lp
    )
{
    lp;
}

int GetAttributesLocalEx
    (
    LPSTR   lpPath,
    BOOL    fFile,
    ULONG   *lpuAttributes
    )
{
    return(GetAttributesLocal(lpPath, lpuAttributes));
}

int
CreateDirectoryLocal(
    LPSTR   lpPath
    )
{
    return -1;
}
#endif //ifndef CSC_RECORDMANAGER_WINNT
#ifdef CSC_RECORDMANAGER_WINNT
PELEM PAllocElem
    (
    int cbSize
    )
{
    return ((PELEM)AllocMem(cbSize));
}

void FreeElem
    (
    PELEM p
    )
{
    FreeMem(p);
}

void LinkElem
    (
    PELEM pElem,
    PPELEM    ppHead
    )
{
    pElem->pnextElem = *ppHead;
    *ppHead = pElem;
}

PELEM PUnlinkElem
    (
    PELEM pElem,
    PPELEM    ppHead
    )
{
    PELEM p;
    for(;p = *ppHead; ppHead = &(p->pnextElem))
    {
        if (p == pElem)
        {
            // Found the guy
            *ppHead = p->pnextElem;
            return (p);
        }
    }
    return (NULL);
}

#endif //ifdef CSC_RECORDMANAGER_WINNT


#ifndef CSC_RECORDMANAGER_WINNT
VOID
GetSystemTime(
    _FILETIME *lpft
)
{
    LONG ltime = IFSMgr_Get_NetTime();

    *lpft = IFSMgr_NetToWin32Time(ltime);

}
#endif

ULONG
GetTimeInSecondsSince1970(
    VOID
    )
{
    return ((ULONG)IFSMgr_Get_NetTime());
}

BOOL
IterateOnUNCPathElements(
    USHORT  *lpuPath,
    PATHPROC lpfn,
    LPVOID  lpCookie
    )
/*++

Routine Description:

    This routine takes a unicode UNC path and iterates over each path element, calling the
    callback function. Thus for a path \\server\share\dir1\dir2\file1.txt, the function makes
    the following calls to the lpfn callback function

    (lpfn)(\\server\share, \\server\share, lpCookie)
    (lpfn)(\\server\share\dir1, dir1, lpCookie)
    (lpfn)(\\server\share\dir1\dir2, dir2, lpCookie)
    (lpfn)(\\server\share\dir1\dir2\file1, file1, lpCookie)

Arguments:

    lpuPath     NULL terminated unicode string (NOT NT style, just a plain unicode string)

    lpfn        callback function. If the function returns TRUE on a callback, the iteration
                proceeds, else it terminates

    lpCookie    context passed back on each callback

Returns:

    return TRUE if the entire iteration went through, FALSE if some error occurred or the callback
    function terminated the iteration

Notes:


--*/
{
    int cnt, cntSlashes=0, cbSize;
    USHORT  *lpuT, *lpuLastElement = NULL, *lpuCopy = NULL;
    BOOL    fRet = FALSE;

//    DEBUG_PRINT(("InterateOnUNCPathElements:Path on entry =%ws\r\n", lpuPath));

    if (!lpuPath || ((cnt = wstrlen(lpuPath)) <= 3))
    {
        return FALSE;
    }

    // check for the first two backslashes
    if (!(*lpuPath == (USHORT)'\\') && (*(lpuPath+1) == (USHORT)'\\'))
    {
        return FALSE;
    }

    // ensure that the server field is not NULL
    if (*(lpuPath+2) == (USHORT)'\\')
    {
        return FALSE;
    }

    cbSize = (wstrlen(lpuPath)+1) * sizeof(USHORT);

    lpuCopy = (USHORT *)AllocMem(cbSize);

    if (!lpuCopy)
    {
        return FALSE;
    }

    memcpy(lpuCopy, lpuPath, cbSize);

    cntSlashes = 2;

    lpuLastElement = lpuCopy;

    for (lpuT= lpuCopy+2;; ++lpuT)
    {
        if (*lpuT == (USHORT)'\\')
        {
            BOOL fContinue;

            ++cntSlashes;

            if (cntSlashes == 3)
            {
                if (lpuT == (lpuCopy+2))
                {
                    goto bailout;
                }

                continue;
            }

            *lpuT = 0;

            fContinue = (lpfn)(lpuCopy, lpuLastElement, lpCookie);

            *lpuT = (USHORT)'\\';

            if (!fContinue)
            {
                goto bailout;
            }

            lpuLastElement = (lpuT+1);
        }
        else if (!*lpuT)
        {
            (lpfn)(lpuCopy, lpuLastElement, lpCookie);
            break;
        }
    }

    fRet = TRUE;
bailout:

    if (lpuCopy)
    {
        FreeMem(lpuCopy);
    }
    return (fRet);
}

BOOL
IsPathUNC(
    USHORT      *lpuPath,
    int         cntMaxChars
    )
{
    USHORT *lpuT;
    int i, cntSlash=0;
    BOOL    fRet = FALSE;

    for(lpuT = lpuPath, i=0; (i < cntMaxChars) && *lpuT; lpuT++, ++i)
    {
        if (cntSlash <= 1)
        {
            // look for the first two backslashes
            if (*lpuT != (USHORT)'\\')
            {
                break;
            }

            ++cntSlash;
        }
        else if (cntSlash == 2)
        {
            // look for the 3rd one
            if (*lpuT == (USHORT)'\\')
            {
                if (((DWORD_PTR)lpuT - (DWORD_PTR)lpuPath) < 3)
                {
                    // NULL server field
                    break;
                }
                else
                {
                    ++cntSlash;
                }
            }
        }
        else    // all three slashes accounted for
        {
            Assert(cntSlash == 3);

            // if a non-slash character, then this path is OK
            fRet = (*lpuT != (USHORT)'\\');
            break;
        }
    }
    return (fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\ntcsclow.h ===
typedef struct _NT5CSC_MINIFILEOBJECT {
   NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT;
   ULONG Flags;
   HANDLE NtHandle;
   PFILE_OBJECT UnderlyingFileObject;
   union {
       struct {
           //cant do this PDEVICE_OBJECT UnderlyingDeviceObject;
           FAST_MUTEX MutexForSynchronousIo; //only synchronous Io is allowed
           union {
               FILE_STANDARD_INFORMATION StandardInfo;
               FILE_BASIC_INFORMATION BasicInfo;
               FILE_FS_SIZE_INFORMATION FsSizeInfo;
               FILE_FS_FULL_SIZE_INFORMATION FsFullSizeInfo;
           };
           ULONG ReturnedLength;
       };
       struct {
           KEVENT PostEvent;
           union {
               RX_WORK_QUEUE_ITEM  WorkQueueItem;
               NTSTATUS PostReturnStatus;
           };
           //this must match the signatureof Nt5CscCreateFile
           LPSTR lpPath;
           BOOL  fInstrument;
           ULONG FileAttributes;
           ULONG CreateOptions;
           ULONG Disposition;
           ULONG ShareAccess;
           ACCESS_MASK DesiredAccess;
           PVOID Continuation; //PNT5CSC_CREATEFILE_CONTINUATION Continuation;
           PVOID ContinuationContext;
       } PostXX;
   };
} NT5CSC_MINIFILEOBJECT, *PNT5CSC_MINIFILEOBJECT;
#define NT5CSC_MINIFOBJ_FLAG_ALLOCATED_FROM_POOL 0x00000001
#define NT5CSC_MINIFOBJ_FLAG_LOUDDOWNCALLS       0x00000080

#define NT5CSC_NTC_MINIFILEOBJECT    ((USHORT)0xed34)
#define ASSERT_MINIRDRFILEOBJECT(___m) ASSERT(NodeType(___m)==NT5CSC_NTC_MINIFILEOBJECT)

//LOUD DOWNCALLS

#ifdef RX_PRIVATE_BUILD
//#define MRXSMBCSC_LOUDDOWNCALLS
#else
#undef MRXSMBCSC_LOUDDOWNCALLS
#endif

#ifdef MRXSMBCSC_LOUDDOWNCALLS

VOID
LoudCallsDbgPrint(
    PSZ Tag,
    PNT5CSC_MINIFILEOBJECT MiniFileObject,
    ULONG MajorFunction,
    ULONG lCount,
    ULONG LowPart,
    ULONG HighPart,
    ULONG Status,
    ULONG Information
    );

#define IF_LOUD_DOWNCALLS(__minifileobj) \
     if(FlagOn((__minifileobj)->Flags,NT5CSC_MINIFOBJ_FLAG_LOUDDOWNCALLS))



#define LOUD_DOWNCALLS_DECL(__x) __x
#define LOUD_DOWNCALLS_CODE(__x) __x
#define IF_BUILT_FOR_LOUD_DOWNCALLS() if(TRUE)

#else

#define LoudCallsDbgPrint(a1,a2,a3,a4,a5,a6,a7,a8) {NOTHING;}

#define IF_LOUD_DOWNCALLS(__minifileobj) if(FALSE)

#define LOUD_DOWNCALLS_DECL(__x)
#define LOUD_DOWNCALLS_CODE(__x)
#define IF_BUILT_FOR_LOUD_DOWNCALLS() if(FALSE)

#endif //#ifdef MRXSMBCSC_LOUDDOWNCALLS

//long R0ReadWriteFileEx
//    (
//    ULONG   uOper,
//    ULONG   handle,
//    ULONG   pos,
//    PVOID   pBuff,
//    long    lCount,
//    BOOL    fInstrument
//    )

#define NT5CSC_RW_FLAG_INSTRUMENTED  0x00000001
#define NT5CSC_RW_FLAG_IRP_NOCACHE   0x00000002
#define NT5CSC_RW_FLAG_PAGED_BUFFER  0x00000004
LONG
Nt5CscReadWriteFileEx (
    ULONG       uOper,
    CSCHFILE    handle,
    ULONGLONG   pos,
    PVOID       pBuff,
    long        lCount,
    ULONG       Flags,
    PIO_STATUS_BLOCK OutIoStatusBlock OPTIONAL
    );
#define R0ReadWriteFileEx(__oper,__handle,__pos,__pbuff,__lcount,__instrument) \
     (Nt5CscReadWriteFileEx(__oper, \
                            __handle, \
                            __pos, \
                            __pbuff, \
                            __lcount, \
                            (__instrument)?NT5CSC_RW_FLAG_INSTRUMENTED:0, \
                            NULL \
                            ))

#define R0ReadWriteFileEx2(__oper,__handle,__pos,__pbuff,__lcount,__flags) \
     (Nt5CscReadWriteFileEx(__oper, \
                            __handle, \
                            __pos, \
                            __pbuff, \
                            __lcount, \
                            ((__flags & FLAG_RW_OSLAYER_INSTRUMENT)?NT5CSC_RW_FLAG_INSTRUMENTED:0) \
                            | ((__flags & FLAG_RW_OSLAYER_PAGED_BUFFER)?NT5CSC_RW_FLAG_PAGED_BUFFER:0), \
                            NULL \
                            ))
extern IO_STATUS_BLOCK Nt5CscGlobalIoStatusBlock;  //used by Nt5CscReadWriteFileEx


NTSTATUS
Nt5CscXxxInformation(
    IN PCHAR xMajorFunction,
    IN PNT5CSC_MINIFILEOBJECT MiniFileObject,
    IN ULONG InformationClass,
    IN ULONG Length,
    OUT PVOID Information,
    OUT PULONG ReturnedLength
    );

BOOL
CscAmIAdmin(
    VOID
    );

typedef
NTSTATUS
(*PNT5CSC_CREATEFILE_CONTINUATION) (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject,
    IN OUT PVOID ContinuationContext,
    IN     NTSTATUS CreateStatus
    );


PNT5CSC_MINIFILEOBJECT
__Nt5CscCreateFile (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject OPTIONAL,
    IN     LPSTR    lpPath,
    IN     ULONG    CSCFlags,
    IN     ULONG    FileAttributes,
    IN     ULONG    CreateOptions,
    IN     ULONG    Disposition,
    IN     ULONG    ShareAccess,
    IN     ACCESS_MASK DesiredAccess,
    IN     PNT5CSC_CREATEFILE_CONTINUATION Continuation,
    IN OUT PVOID    ContinuationContext,
    IN     BOOL     PostedCall
    );

int
DeleteStream(
    LPTSTR      lpdbID,
    ULONG       ulidFile,
    LPTSTR      str2Append
    );
    
BOOL
GetFileSystemAttributes(
    CSCHFILE handle,
    ULONG *lpFileSystemAttributes
    );
    
BOOL
HasStreamSupport(
    CSCHFILE handle,
    BOOL    *lpfResult
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\log.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

     Log.c

Abstract:

     none.

Author:

     Shishir Pardikar      [Shishirp]        01-jan-1995

Revision History:

     Joe Linn                 [JoeLinn]         23-jan-97     Ported for use on NT

--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

/********************************************************************/
/**                    Copyright(c) Microsoft Corp., 1990-1991             **/
/********************************************************************/

//      Hook Processing

/******************************* Include Files ******************************/

#ifndef CSC_RECORDMANAGER_WINNT
#define WIN32_APIS
#include "cshadow.h"
#endif //ifndef CSC_RECORDMANAGER_WINNT

#include <stdlib.h>
#include <ctype.h>
#include <string.h>
// #include "error.h"
#include "vxdwraps.h"
#include "logdat.h"

/******************************* defines/typedefs ***************************/
#define MAX_SHADOW_LOG_ENTRY  512
#define  MAX_LOG_SIZE    100000

#ifdef DEBUG
#define  SHADOW_TIMER_INTERVAL    30000
#define  STATS_FLUSH_COUNT         10
#endif //DEBUG

#define  ENTERCRIT_LOG  { if (!fLogInit) InitShadowLog();\
                    if (fLogInit==-1) return;  \
                    Wait_Semaphore(semLog, BLOCK_SVC_INTS);}
#define  LEAVECRIT_LOG    Signal_Semaphore(semLog);

#ifdef CSC_RECORDMANAGER_WINNT

//ntdef has already define TIME differently....fortuntely by macros....
//so we undo this for the remainder of this file. the RIGHT solution is
//to use a name like CSC_LOG_TIME.

#undef _TIME
#undef TIME
#undef PTIME

#endif //ifdef CSC_RECORDMANAGER_WINNT

typedef struct tagTIME
{
    WORD seconds;
    WORD minutes;
    WORD hours;
    WORD day;
    WORD month;
    WORD year;
}
TIME, FAR *LPTIME;
#pragma intrinsic (memcmp, memcpy, memset, strcat, strcmp, strcpy, strlen)

/******************************* Function Prototypes ************************/
int vxd_vsprintf(char * lpOut, char * lpFmt, CONST VOID * lpParms);
int PrintLog( LPSTR lpFmt,  ...);
void PrintNetTime(LONG ltime);
void PrintNetShortTime(LONG ltime);
void ExplodeTime( ULONG time, LPTIME lpTime );
void LogPreamble(int, LPSTR, int, LPSTR);
int WriteStats(BOOL);

//need this for NT
int WriteLog(void);
/******************************** Static/Global data ************************/

#ifdef CSC_RECORDMANAGER_WINNT
#define UniToBCSPath(a,b,c,d)
#define IFSMgr_DosToNetTime(a) ((0))
#endif //ifdef CSC_RECORDMANAGER_WINNT

AssertData;
AssertError;


char logpathbuff[MAX_PATH+1], rgchLogFileName[MAX_PATH];
char chLogginBuffer[COPY_BUFF_SIZE];

extern int fLog;
extern LPSTR vlpszShadowDir;
int fLogInit = FALSE;
LPSTR  lpLogBuff = chLogginBuffer;
int cBuffSize = COPY_BUFF_SIZE;
int indxCur = 0;
VMM_SEMAPHORE semLog = 0L;
#define FOURYEARS       (3*365+366)

ULONG   ulMaxLogSize=0x00020000;  // 128K log filesize by default

#ifndef CSC_RECORDMANAGER_WINNT
BOOL    fPersistLog = TRUE;
#else
BOOL    fPersistLog = FALSE;
#endif

#define DAYSECONDS      (60L*60L*24L)           // number of seconds in a day

#define BIAS_70_TO_80   0x12CEA600L

//      days in a month

int MonTab[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

/* structure stores intl settings for datetime format */
char szCSCLog[] = "\\csc.log"; // keep this size below 8
char szCRLF[] = "\r\n";
char szBegin[] = "Begin";
char szEnd[] = "End";
char szContinue[] = "Continue";
char szEndMarker[] = "END\n";

ULONG ulMaxLogfileSize;
DWORD   dwDebugLogVector = DEBUG_LOG_BIT_RECORD|DEBUG_LOG_BIT_CSHADOW;  // by default record manager logging is on
#ifdef DEBUG
ULONG cntVfnDelete=0, cntVfnCreateDir=0, cntVfnDeleteDir=0, cntVfnCheckDir=0, cntVfnGetAttrib=0;
ULONG cntVfnSetAttrib=0, cntVfnFlush=0, cntVfnGetDiskInfo=0, cntVfnOpen=0;
ULONG cntVfnRename=0, cntVfnSearchFirst=0, cntVfnSearchNext=0;
ULONG cntVfnQuery=0, cntVfnDisconnect=0, cntVfnUncPipereq=0, cntVfnIoctl16Drive=0;
ULONG cntVfnGetDiskParms=0, cntVfnFindOpen=0, cntVfnDasdIO=0;

ULONG cntHfnFindNext=0, cntHfnFindClose=0;
ULONG cntHfnRead=0, cntHfnWrite=0, cntHfnSeek=0, cntHfnClose=0, cntHfnCommit=0;
ULONG cntHfnSetFileLocks=0, cntHfnRelFileLocks=0, cntHfnGetFileTimes=0, cntHfnSetFileTimes=0;
ULONG cntHfnPipeRequest=0, cntHfnHandleInfo=0, cntHfnEnumHandle=0;
ULONG cbReadLow=0, cbReadHigh=0, cbWriteLow=0, cbWriteHigh=0;
ULONG cntVfnConnect=0;
ULONG cntLastTotal=0;
#endif //DEBUG

/****************************************************************************/
#ifndef CSC_RECORDMANAGER_WINNT
#pragma VxD_LOCKED_CODE_SEG
#endif //ifndef CSC_RECORDMANAGER_WINNT

int InitShadowLog(
    )
{
    int iRet = -1, lenT;

    if (fLog && !fLogInit && vlpszShadowDir)
    {
        if (!(semLog = Create_Semaphore(1)))
            goto bailout;

        strcpy(rgchLogFileName, (LPSTR)vlpszShadowDir);
        strcat(rgchLogFileName, szCSCLog);

        PrintLog(szCRLF);
        PrintNetTime(IFSMgr_Get_NetTime());
        PrintLog(szCRLF);
        fLogInit = 1;
        iRet = 0;
    }
    else
    {
        iRet = 0;
    }

bailout:
    if (iRet)
    {
        if (semLog)
            Destroy_Semaphore(semLog);
        semLog = 0L;
    }
    return iRet;
}

int ShadowLog(
    LPSTR lpFmt,
    ...
    )
{
    int pos, iRet = -1;
    if (!fLogInit)
    {
        InitShadowLog();
    }

    if (fLogInit)
    {
        if ((cBuffSize-indxCur+sizeof(szEndMarker)) < MAX_SHADOW_LOG_ENTRY)
        {
            iRet = WriteLog();
#if 0
            PrintLog(szCRLF);
            PrintNetTime(IFSMgr_Get_NetTime());
            PrintLog(szCRLF);
#endif
        }
        else
        {
            indxCur += vxd_vsprintf(lpLogBuff+indxCur, lpFmt, (LPSTR)&lpFmt+sizeof(lpFmt));

            // deliberately don't move the index pointer after writing the end marker
            // so when the next real log entry is written, the endmarker will be overwritten
            memcpy(lpLogBuff+indxCur, szEndMarker, sizeof(szEndMarker)-1);
            iRet = 0;
        }
    }
    else
    {
        iRet = 0;
    }
    return (iRet);
}


int TerminateShadowLog(
    )
{
    int iRet = -1;
    if (fLogInit)
    {
        iRet = WriteLog();
        Destroy_Semaphore(semLog);
        semLog = 0L;
        fLogInit = 0;
    }
    else
    {
        iRet = 0;
    }
    return (iRet);
}

int FlushLog(
    )
{
    int iRet = 0;
    if (!fLogInit)
    {
        InitShadowLog();
    }
    if (fLogInit==1)
    {
        Wait_Semaphore(semLog, BLOCK_SVC_INTS);
        iRet = WriteLog();
        Signal_Semaphore(semLog);
    }
    else
    {
        iRet = -1;
    }
    return (iRet);
}

#ifdef DEBUG
int WriteLog(
    )
{
    int iRet = -1;
    CSCHFILE hfShadowLog = CSCHFILE_NULL;
    ULONG pos;

    if (fLogInit && vlpszShadowDir)
    {
        if (fPersistLog)
        {
            if (!(hfShadowLog = CreateFileLocal(rgchLogFileName)))
            {
                KdPrint(("WriteLog: Couldn't open log file\r\n"));
                goto bailout;
            }
            if(GetFileSizeLocal(hfShadowLog, &pos))
            {
                KdPrint(("ShadowLog: log file error\r\n"));
                goto bailout;
            }
            if ((pos+indxCur) > ulMaxLogSize)
            {
#if 0
                CloseFileLocal(hfShadowLog);
                DeleteFileLocal(lpszLogAlt, ATTRIB_DEL_ANY);
                RenameFileLocal(szLog, szLogAlt);
                if (!(hfShadowLog = CreateFileLocal(szLog)))
                {
                    KdPrint(("WriteLog: Couldn't open shadow file\r\n"));
                    goto bailout;
                }
#endif
                pos=0;  // wraparound the logfile
            }
            if (WriteFileLocal(hfShadowLog, pos, lpLogBuff, indxCur) != indxCur)
            {
                KdPrint(("ShadowLog: error writing the log at position %x \r\n", pos));
                goto bailout;
            }
        }

        iRet = 0;
    }
bailout:
    if (hfShadowLog)
    {
        CloseFileLocal(hfShadowLog);
    }

    // no matter what happens, reset the index to 0
    indxCur = 0;
    return iRet;
}
#else
int
WriteLog(
    VOID
    )
{
    // no matter what happens, reset the index to 0
    indxCur = 0;
    return 1;
}
#endif  //DEBUG

void EnterLogCrit(void)
{
    ENTERCRIT_LOG;
}

void LeaveLogCrit(void)
{
    LEAVECRIT_LOG;
}

/*
 *      PrintNetTime
 *
 *      Adds a time and a date to the end of a string.
 *      Time is seconds since 1/1/70.
 *
 */
void PrintNetTime(LONG ltime)
{
    TIME tm;
    int d1, d2, d3;

    ExplodeTime( ltime, &tm );
    d1 = tm.month; d2 = tm.day; d3 = tm.year%100;

    PrintLog(szTimeDateFormat, tm.hours, tm.minutes, tm.seconds, d1, d2, d3);
}

/*
 *      PrintNetTime
 *
 *      Adds a time and a date to the end of a string.
 *      Time is seconds since 1/1/70.
 *
 */
void PrintNetShortTime( LONG ltime
    )
{
    TIME tm;

    ExplodeTime( ltime, &tm );

    PrintLog(szTimeFormat, tm.hours, tm.minutes, tm.seconds);
}

int PrintLog(
    LPSTR lpFmt,
    ...
    )
{
    indxCur += vxd_vsprintf(lpLogBuff+indxCur, lpFmt, (LPSTR)&lpFmt+sizeof(lpFmt));
    return(0);
}

VOID
_cdecl
DbgPrintLog(
    LPSTR lpFmt,
    ...
)
{
    ENTERCRIT_LOG;
    indxCur += vxd_vsprintf(lpLogBuff+indxCur, lpFmt, (LPSTR)&lpFmt+sizeof(lpFmt));
    LEAVECRIT_LOG;
}

void ExplodeTime( ULONG time, LPTIME lpTime )
{
    ULONG date;
    WORD cLeaps;
    LONG days;
    WORD dpy;
    int i;

    time -= BIAS_70_TO_80;

    date = time / DAYSECONDS;
    time %= DAYSECONDS;

    lpTime->seconds = (WORD)(time % 60L);
    time /= 60L;
    lpTime->minutes = (WORD)(time % 60L);
    lpTime->hours = (WORD)(time / 60L);

    cLeaps = (WORD)(date / FOURYEARS);              // # of full leap years
    days = date % FOURYEARS;                // remaining days

    lpTime->year = cLeaps * 4 + 1980;       // correct year
    MonTab[1] = 29;                                 // set # days in Feb for leap years
    dpy = 366;
    days -= dpy;
    if (days >= 0) {                                // this is not a leap year
        dpy--;
        while (days >= 0) {
            lpTime->year++;
            days -= dpy;
        }
        MonTab[1] = 28;                 // set # days in Feb for non-leap years
    }

    days += dpy;                            // days = # days left in this year

    for (i=0; days >= MonTab[i]; i++)
        days -= MonTab[i];

    lpTime->month = (WORD)i + 1;                    // calculate 1-based month
    lpTime->day = (WORD)days + 1;   // calculate 1-based day
}


void LogVfnDelete( PIOREQ    pir
    )
{
    TIME tm;
#ifdef DEBUG
    ++cntVfnDelete;
#endif //DEBUG
    if (fLog)
    {
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
        UniToBCSPath(logpathbuff, &pir->ir_ppath->pp_elements[0], MAX_PATH, BCS_OEM);
    logpathbuff[MAX_PATH]=0;
    LogPreamble(VFNLOG_DELETE, logpathbuff, pir->ir_error, szCR);
    LEAVECRIT_LOG;
    }
}

void LogVfnDir( PIOREQ    pir
    )
{
#ifdef DEBUG
    if (pir->ir_flags == CREATE_DIR)
    ++cntVfnCreateDir;
    else if (pir->ir_flags == DELETE_DIR)
    ++cntVfnDeleteDir;
    else
    ++cntVfnCheckDir;
#endif //DEBUG

    if (fLog)
    {
    ENTERCRIT_LOG;
    UniToBCSPath(logpathbuff, &pir->ir_ppath->pp_elements[0], MAX_PATH, BCS_OEM);
    logpathbuff[MAX_PATH]=0;
    if (pir->ir_flags==CREATE_DIR)
        LogPreamble(VFNLOG_CREATE_DIR, logpathbuff, pir->ir_error, szCR);
    else if (pir->ir_flags==DELETE_DIR)
        LogPreamble(VFNLOG_DELETE_DIR, logpathbuff, pir->ir_error, szCR);
    else if (pir->ir_flags==CHECK_DIR)
        LogPreamble(VFNLOG_CHECK_DIR, logpathbuff, pir->ir_error, szCR);
    else if (pir->ir_flags==QUERY83_DIR)
    {
        LogPreamble(VFNLOG_QUERY83_DIR, logpathbuff, pir->ir_error, NULL);
        UniToBCSPath(logpathbuff, &pir->ir_ppath2->pp_elements[0], MAX_PATH, BCS_OEM);
        ShadowLog(" %s\r\n", logpathbuff);
    }
    else
    {
        LogPreamble(VFNLOG_QUERYLONG_DIR, logpathbuff, pir->ir_error, NULL);
        UniToBCSPath(logpathbuff, &pir->ir_ppath2->pp_elements[0], MAX_PATH, BCS_OEM);
        ShadowLog(" %s\r\n", logpathbuff);
    }

    LEAVECRIT_LOG;
    }
}


void LogVfnFileAttrib( PIOREQ    pir
    )
{
#ifdef DEBUG
    if (pir->ir_flags == GET_ATTRIBUTES)
    ++cntVfnGetAttrib;
    else
    ++cntVfnSetAttrib;

#endif //DEBUG
    if (fLog)
    {
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
        UniToBCSPath(logpathbuff, &pir->ir_ppath->pp_elements[0], MAX_PATH, BCS_OEM);

    if (pir->ir_flags == GET_ATTRIBUTES)
    {
        LogPreamble(VFNLOG_GET_ATTRB, logpathbuff, pir->ir_error, NULL);
        ShadowLog(rgsLogCmd[VFNLOG_GET_ATTRB].lpFmt, pir->ir_attr);
    }
    else
    {
        LogPreamble(VFNLOG_SET_ATTRB, logpathbuff, pir->ir_error, NULL);
        ShadowLog(rgsLogCmd[VFNLOG_SET_ATTRB].lpFmt, pir->ir_attr);
    }
    LEAVECRIT_LOG;
    }
}


void LogVfnFlush( PIOREQ    pir
    )
{

#ifdef DEBUG
    ++cntVfnFlush;
#endif //DEBUG

    if (fLog)
    {
    ENTERCRIT_LOG;
    PpeToSvr(((PRESOURCE)(pir->ir_rh))->pp_elements, logpathbuff, sizeof(logpathbuff), BCS_OEM);
    LogPreamble(VFNLOG_FLUSH, logpathbuff, pir->ir_error, szCR);
    LEAVECRIT_LOG;
    }
}


void LogVfnGetDiskInfo( PIOREQ    pir
    )
{
    if (fLog)
    {
    ENTERCRIT_LOG;
    PpeToSvr(((PRESOURCE)(pir->ir_rh))->pp_elements, logpathbuff, sizeof(logpathbuff), BCS_OEM);
    LogPreamble(VFNLOG_GETDISKINFO, logpathbuff, pir->ir_error, szCR);
    LEAVECRIT_LOG;
    }
}


void LogVfnGetDiskParms( PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntVfnGetDiskParms;
#endif //DEBUG
    if (fLog)
    {
    ENTERCRIT_LOG;
    PpeToSvr(((PRESOURCE)(pir->ir_rh))->pp_elements, logpathbuff, sizeof(logpathbuff), BCS_OEM);
    LogPreamble(VFNLOG_GETDISKPARAMS, logpathbuff, pir->ir_error, szCR);
    LEAVECRIT_LOG;
    }
}

void LogVfnOpen( PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntVfnOpen;
#endif //DEBUG
    if (fLog)
    {
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
        UniToBCSPath(logpathbuff, &pir->ir_ppath->pp_elements[0], MAX_PATH, BCS_OEM);
    logpathbuff[MAX_PATH]=0;
    LogPreamble(VFNLOG_OPEN, logpathbuff, pir->ir_error, NULL);
    ShadowLog(rgsLogCmd[VFNLOG_OPEN].lpFmt,(ULONG)(pir->ir_flags), (ULONG)(pir->ir_options)
        , (ULONG)(pir->ir_attr), (ULONG)(pir->ir_size));
    PrintNetTime(IFSMgr_DosToNetTime(pir->ir_dostime));
    ShadowLog(szCR);
    LEAVECRIT_LOG;
    }
}

void LogVfnRename( PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntVfnRename;
#endif //DEBUG
    if (fLog)
    {
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
        UniToBCSPath(logpathbuff, &pir->ir_ppath->pp_elements[0], MAX_PATH, BCS_OEM);
    logpathbuff[MAX_PATH]=0;
    LogPreamble(VFNLOG_RENAME, logpathbuff, pir->ir_error, NULL);
    UniToBCSPath(logpathbuff, &pir->ir_ppath2->pp_elements[0], MAX_PATH, BCS_OEM);
    logpathbuff[MAX_PATH]=0;
    ShadowLog(rgsLogCmd[VFNLOG_RENAME].lpFmt, logpathbuff);
    LEAVECRIT_LOG;
    }
}

void LogVfnSearch( PIOREQ    pir
    )
{
    srch_entry *pse = (srch_entry *)(pir->ir_data);
    char szName[sizeof(pse->se_name)+1];
#ifdef DEBUG
    if (pir->ir_flags == SEARCH_FIRST)
    ++cntVfnSearchFirst;
    else
    ++cntVfnSearchNext;

#endif //DEBUG

    if (fLog)
    {
    ENTERCRIT_LOG;
    // BUGBUG expand this
    memset(szName, 0, sizeof(szName));
    memcpy(logpathbuff, pse->se_name, sizeof(pse->se_name));
    if (pir->ir_flags == SEARCH_FIRST)
    {
        memset(logpathbuff, 0, sizeof(logpathbuff));
        UniToBCSPath(logpathbuff, &pir->ir_ppath->pp_elements[0], MAX_PATH, BCS_OEM);
        LogPreamble(VFNLOG_SRCHFRST, logpathbuff, pir->ir_error, NULL);
        ShadowLog(rgsLogCmd[VFNLOG_SRCHFRST].lpFmt, pir->ir_attr, szName);
    }
    else
    {
        LogPreamble(VFNLOG_SRCHNEXT, szDummy, pir->ir_error, NULL);
        ShadowLog(rgsLogCmd[VFNLOG_SRCHNEXT].lpFmt, szName);
    }
    LEAVECRIT_LOG;
    }
}

void LogVfnQuery( PIOREQ    pir,
    USHORT    options
    )
{
#ifdef DEBUG
    ++cntVfnQuery;
#endif //DEBUG
    if (fLog)
    {
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
    PpeToSvr(((PRESOURCE)(pir->ir_rh))->pp_elements, logpathbuff, sizeof(logpathbuff), BCS_OEM);
    if (options==0)
    {
        LogPreamble(VFNLOG_QUERY0, logpathbuff, pir->ir_error, szCR);
    }
    if (options==1)
    {
        LogPreamble(VFNLOG_QUERY0, logpathbuff, pir->ir_error, NULL);
        ShadowLog(rgsLogCmd[VFNLOG_QUERY1].lpFmt, (ULONG)(pir->ir_options));
    }
    else if (options==2)
    {
        LogPreamble(VFNLOG_QUERY0, logpathbuff, pir->ir_error, NULL);
        ShadowLog(rgsLogCmd[VFNLOG_QUERY2].lpFmt, (ULONG)(pir->ir_options), (ULONG)(pir->ir_length >> 16), (ULONG)(pir->ir_length & 0xffff));
    }

    LEAVECRIT_LOG;
    }
}

void LogVfnConnect( PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntVfnConnect;
#endif //DEBUG
    if (fLog)
    {
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
    UniToBCSPath(logpathbuff, &pir->ir_ppath->pp_elements[0], MAX_PATH, BCS_OEM);
    LogPreamble(VFNLOG_CONNECT, logpathbuff, pir->ir_error, NULL);
    ShadowLog(rgsLogCmd[VFNLOG_CONNECT].lpFmt, pir->ir_flags);
    LEAVECRIT_LOG;
    }
}

void LogVfnDisconnect( PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntVfnDisconnect;
#endif //DEBUG
    if (fLog)
    {
    ENTERCRIT_LOG;
    PpeToSvr(((PRESOURCE)(pir->ir_rh))->pp_elements, logpathbuff, sizeof(logpathbuff), BCS_OEM);
    LogPreamble(VFNLOG_DISCONNECT, logpathbuff, pir->ir_error, szCR);
    WriteLog();
//        TerminateShadowLog();
    LEAVECRIT_LOG;
    }
}

void LogVfnUncPipereq(
    PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntVfnUncPipereq;
#endif //DEBUG
}

void LogVfnIoctl16Drive (
    PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntVfnIoctl16Drive ;
#endif //DEBUG
}

void LogVfnDasdIO(
    PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntVfnDasdIO;
#endif //DEBUG
}


void LogVfnFindOpen( PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntVfnFindOpen;
#endif //DEBUG
    if (fLog)
    {
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
        UniToBCSPath(logpathbuff, &pir->ir_ppath->pp_elements[0], MAX_PATH, BCS_OEM);
    logpathbuff[MAX_PATH]=0;
    LogPreamble(VFNLOG_FINDOPEN, logpathbuff, pir->ir_error, NULL);
    if (!pir->ir_error)
    {
        memset(logpathbuff, 0, sizeof(logpathbuff));
        UniToBCS(logpathbuff, ((LPFIND32)(pir->ir_data))->cFileName, sizeof(((LPFIND32)(pir->ir_data))->cFileName)
            , sizeof(logpathbuff)-1, BCS_OEM);
        ShadowLog(rgsLogCmd[VFNLOG_FINDOPEN].lpFmt, pir->ir_attr, logpathbuff);
    }
    else
    {
        ShadowLog(szCR);
    }
    LEAVECRIT_LOG;
    }
}

void LogHfnFindNext( PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntHfnFindNext;
#endif //DEBUG
    if (fLog)
    {
    ENTERCRIT_LOG;
    LogPreamble(HFNLOG_FINDNEXT, szDummy, pir->ir_error, NULL);

    if (!pir->ir_error)
    {
        memset(logpathbuff, 0, sizeof(logpathbuff));
        UniToBCS(logpathbuff, ((LPFIND32)(pir->ir_data))->cFileName, sizeof(((LPFIND32)(pir->ir_data))->cFileName)
            , sizeof(logpathbuff)-1, BCS_OEM);
        ShadowLog(rgsLogCmd[HFNLOG_FINDNEXT].lpFmt, logpathbuff);
    }
    else
    {
        ShadowLog(szCR);
    }
    LEAVECRIT_LOG;
    }
}

void LogHfnFindClose( PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntHfnFindClose;
#endif //DEBUG
    if (fLog)
    {
    ENTERCRIT_LOG;
    LogPreamble(HFNLOG_FINDCLOSE, szDummy, pir->ir_error, szCR);
    LEAVECRIT_LOG;
    }
}

void LogHfnRead
    (
    PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntHfnRead;
#endif //DEBUG
#ifdef MAYBE
    Incr64Bit(cbReadHigh, cbReadLow, (ULONG)(pir->ir_length));
#endif //MAYBE
    if (fLog)
    {
    PFILEINFO pFileInfo = (PFILEINFO)(pir->ir_fh);
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
    UniToBCSPath(logpathbuff, &(pFileInfo->pFdb->sppathRemoteFile.pp_elements[0]), MAX_PATH, BCS_OEM);
    LogPreamble(HFNLOG_READ, logpathbuff, pir->ir_error, NULL);
    ShadowLog(rgsLogCmd[HFNLOG_READ].lpFmt,
                (ULONG)(pir->ir_pos)-(ULONG)(pir->ir_length),
                (ULONG)(pir->ir_length));
    LEAVECRIT_LOG;
    }
}

void LogHfnWrite
    (
    PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntHfnWrite;
#endif //DEBUG
#ifdef MAYBE
    Incr64Bit(cbWriteHigh, cbWriteLow, (ULONG)(pir->ir_length));
#endif //MAYBE
    if (fLog)
    {
    PFILEINFO pFileInfo = (PFILEINFO)(pir->ir_fh);
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
    UniToBCSPath(logpathbuff, &(pFileInfo->pFdb->sppathRemoteFile.pp_elements[0]), MAX_PATH, BCS_OEM);
    LogPreamble(HFNLOG_WRITE, logpathbuff, pir->ir_error, NULL);
    ShadowLog(rgsLogCmd[HFNLOG_WRITE].lpFmt,
                (ULONG)(pir->ir_pos)-(ULONG)(pir->ir_length),
                (ULONG)(pir->ir_length));
    LEAVECRIT_LOG;
    }
}

void LogHfnClose
    (
    PIOREQ    pir,
    int closetype
    )
{
#ifdef DEBUG
    ++cntHfnClose;
#endif //DEBUG
    if (fLog)
    {
    PFILEINFO pFileInfo = (PFILEINFO)(pir->ir_fh);
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
    UniToBCSPath(logpathbuff, &(pFileInfo->pFdb->sppathRemoteFile.pp_elements[0]), MAX_PATH, BCS_OEM);
    LogPreamble(HFNLOG_CLOSE, logpathbuff, pir->ir_error, NULL);
    ShadowLog(rgsLogCmd[HFNLOG_CLOSE].lpFmt, closetype);
    LEAVECRIT_LOG;
    }
}

void LogHfnSeek
    (
    PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntHfnSeek;
#endif //DEBUG
    if (fLog)
    {
    PFILEINFO pFileInfo = (PFILEINFO)(pir->ir_fh);
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
    UniToBCSPath(logpathbuff, &(pFileInfo->pFdb->sppathRemoteFile.pp_elements[0]), MAX_PATH, BCS_OEM);
    LogPreamble(HFNLOG_SEEK, logpathbuff, pir->ir_error, NULL);
    ShadowLog(rgsLogCmd[HFNLOG_SEEK].lpFmt, (ULONG)(pir->ir_pos), pir->ir_flags);
    LEAVECRIT_LOG;
    }
}

void LogHfnCommit
    (
    PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntHfnCommit;
#endif //DEBUG
    if (fLog)
    {
    PFILEINFO pFileInfo = (PFILEINFO)(pir->ir_fh);
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
    UniToBCSPath(logpathbuff, &(pFileInfo->pFdb->sppathRemoteFile.pp_elements[0]), MAX_PATH, BCS_OEM);
    LogPreamble(HFNLOG_COMMIT, logpathbuff, pir->ir_error, szCR);
    LEAVECRIT_LOG;
    }
}


void LogHfnFileLocks
    (
    PIOREQ    pir
    )
{
#ifdef DEBUG
    if (pir->ir_flags == LOCK_REGION)
    ++cntHfnSetFileLocks;
    else
    ++cntHfnRelFileLocks;
#endif //DEBUG
    if (fLog)
    {
    PFILEINFO pFileInfo = (PFILEINFO)(pir->ir_fh);
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
    UniToBCSPath(logpathbuff, &(pFileInfo->pFdb->sppathRemoteFile.pp_elements[0]), MAX_PATH, BCS_OEM);
    LogPreamble((pir->ir_flags==LOCK_REGION)?HFNLOG_FLOCK:HFNLOG_FUNLOCK, logpathbuff, pir->ir_error, NULL);
    if (!pir->ir_error)
    {
        ShadowLog(rgsLogCmd[HFNLOG_FLOCK].lpFmt
            , pir->ir_pos
            , pir->ir_locklen);
    }
    else
    {
        ShadowLog(szCR);
    }
    LEAVECRIT_LOG;
    }
}

void LogHfnFileTimes
    (
    PIOREQ    pir
    )
{
#ifdef DEBUG
    if ((pir->ir_flags == GET_MODIFY_DATETIME)||(pir->ir_flags == GET_LAST_ACCESS_DATETIME))
    ++cntHfnGetFileTimes;
    else
    ++cntHfnSetFileTimes;
#endif //DEBUG
    if (fLog)
    {
    PFILEINFO pFileInfo = (PFILEINFO)(pir->ir_fh);
    int indxFn = pir->ir_flags;

    if (indxFn==GET_MODIFY_DATETIME)
    {
        indxFn = HFNLOG_GET_TIME;
    }
    else if (indxFn==SET_MODIFY_DATETIME)
    {
        indxFn = HFNLOG_SET_TIME;
    }
    else if (indxFn==GET_LAST_ACCESS_DATETIME)
    {
        indxFn = HFNLOG_GET_LATIME;
    }
    else
    {
        indxFn = HFNLOG_SET_LATIME;
    }

    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
    UniToBCSPath(logpathbuff, &(pFileInfo->pFdb->sppathRemoteFile.pp_elements[0]), MAX_PATH, BCS_OEM);
    LogPreamble(indxFn, logpathbuff, pir->ir_error, NULL);
    if (!pir->ir_error)
    {
        PrintNetTime(IFSMgr_DosToNetTime(pir->ir_dostime));
    }
    ShadowLog(szCR);

    LEAVECRIT_LOG;
    }
}

void LogHfnPipeRequest
    (
    PIOREQ pir
    )
{
}

void LogHfnHandleInfo(
    PIOREQ    pir
    )
{
    if (fLog)
    {
    PFILEINFO pFileInfo = (PFILEINFO)(pir->ir_fh);

    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
    UniToBCSPath(logpathbuff, &(pFileInfo->pFdb->sppathRemoteFile.pp_elements[0]), MAX_PATH, BCS_OEM);
    LogPreamble(HFNLOG_ENUMHANDLE, logpathbuff, pir->ir_error, NULL);
    ShadowLog(szCR);
    LEAVECRIT_LOG;
    }
}

void LogHfnEnumHandle(
    PIOREQ    pir
    )
{
    if (fLog)
    {
    PFILEINFO pFileInfo = (PFILEINFO)(pir->ir_fh);
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
    UniToBCSPath(logpathbuff, &(pFileInfo->pFdb->sppathRemoteFile.pp_elements[0]), MAX_PATH, BCS_OEM);
    LogPreamble(HFNLOG_ENUMHANDLE, logpathbuff, pir->ir_error, NULL);
    ShadowLog(rgsLogCmd[HFNLOG_ENUMHANDLE].lpFmt, pir->ir_flags);
    LEAVECRIT_LOG;
    }
}

void LogTiming(
    int verbosity,
    int stage
    )
{
    if (fLog >= verbosity)
    {
    ShadowLog("%s: ", (stage==STAGE_BEGIN)
                ?szBegin:((stage==STAGE_END)?szEnd:szContinue));
    PrintNetShortTime(IFSMgr_Get_NetTime());
    ShadowLog(szCR);
    }
}


void LogPreamble( int    indxFn,
    LPSTR lpSubject,
    int    errCode,
    LPSTR lpPreTerm
    )
{
    TIME tm;

    ExplodeTime(IFSMgr_Get_NetTime(), &tm);
    ShadowLog(szPreFmt
            , rgsLogCmd[indxFn].lpCmd
            , tm.hours, tm.minutes, tm.seconds
            , errCode
            , lpSubject);
    if (lpPreTerm)
    {
    ShadowLog(lpPreTerm);
    }
}


#ifdef MAYBE
int Incr64Bit(
    ULONG uHigh,
    ULONG uLow,
    ULONG uIncr
    )
{
    ULONG uTemp = uLow;

    uLow += uIncr;
    if (uLow < uTemp)
    ++uHigh;
    return 1;
}
#endif //MAYBE

#ifdef DEBUG
int WriteStats( BOOL fForce)
{
    ULONG cntTotal;
    SHADOWSTORE sSS;

    cntTotal =  cntVfnDelete+ cntVfnCreateDir+ cntVfnDeleteDir+ cntVfnCheckDir+ cntVfnGetAttrib+
            cntVfnSetAttrib+ cntVfnFlush+ cntVfnGetDiskInfo+ cntVfnOpen+
            cntVfnRename+ cntVfnSearchFirst+ cntVfnSearchNext+
            cntVfnQuery+ cntVfnDisconnect+ cntVfnUncPipereq+ cntVfnIoctl16Drive+
            cntVfnGetDiskParms+ cntVfnFindOpen+ cntVfnDasdIO+
            cntHfnFindNext+ cntHfnFindClose+
            cntHfnRead+ cntHfnWrite+ cntHfnSeek+ cntHfnClose+ cntHfnCommit+
            cntHfnSetFileLocks+ cntHfnRelFileLocks+ cntHfnGetFileTimes+ cntHfnSetFileTimes+
            cntHfnPipeRequest+ cntHfnHandleInfo+ cntHfnEnumHandle;

    ShadowLog("\r!***** Stats Begin *******\r");

    PrintNetTime(IFSMgr_Get_NetTime());
    ShadowLog("\r");
    if (!fForce && (cntTotal == cntLastTotal))
    {
    KdPrint(("No new network activity \r"));
    goto bailout;
    }
    cntLastTotal = cntTotal;
    if (!cntTotal)
    {
    cntTotal = 1;
    }
    ShadowLog("Total remote operations=%d \r", cntTotal);

    GetShadowSpaceInfo(&sSS);
    ShadowLog("Space used=%d, Files=%d, Dirs=%d\r",
        sSS.sCur.ulSize, sSS.sCur.ucntFiles, sSS.sCur.ucntDirs);

    ShadowLog("\rFile Operations:\r");
    ShadowLog("Open=%d%%, Close=%d%% \r",
            (cntVfnOpen * 100/cntTotal),
            (cntHfnClose * 100/cntTotal));

    ShadowLog("Read=%d%%, Write=%d%%, Seek=%d%%\r",
            (cntHfnRead * 100/cntTotal),
            (cntHfnWrite * 100/cntTotal),
            (cntHfnSeek * 100/cntTotal));
    if (!cntHfnRead)
    {
    cntHfnRead = 1;
    }
    ShadowLog("ReadHits=%d%% of total reads\r", (cntReadHits*100)/cntHfnRead);

    ShadowLog("GetFileTime=%d%% SetFileTime=%d%%\r",
            (cntHfnGetFileTimes * 100/cntTotal),
            (cntHfnSetFileTimes * 100/cntTotal));


    ShadowLog("SetLock=%d%%, ReleaseLock=%d%% \r",
            (cntHfnSetFileLocks * 100/cntTotal),
            (cntHfnRelFileLocks * 100/cntTotal));

    ShadowLog("Directory Operations: ");
    ShadowLog("CreateDir=%d%%, DeleteDir=%d%%, CheckDir=%d%% \r",
            (cntVfnCreateDir*100/cntTotal),
            (cntVfnDeleteDir*100/cntTotal),
            (cntVfnCheckDir*100/cntTotal));

    ShadowLog("Find/Search Operations:\r");
    ShadowLog("FindOpen=%d%%, FindNext=%d%%, FindClose=%d%% \r",
            (cntVfnFindOpen * 100/cntTotal),
            (cntHfnFindNext * 100/cntTotal),
            (cntHfnFindClose * 100/cntTotal));
    ShadowLog("SearchFirst=%d%%, SearchNext=%d%%\r",
            (cntVfnSearchFirst * 100/cntTotal),
            (cntVfnSearchNext * 100/cntTotal));

    ShadowLog("Attributes: ");
    ShadowLog("SetAttributes=%d%%, GetAttributes=%d%%\r",
            (cntVfnSetAttrib * 100/cntTotal),
            (cntVfnGetAttrib * 100/cntTotal));

    ShadowLog("Name Mutations: ");
    ShadowLog("Rename=%d%%, Delete=%d%% \r",
            (cntVfnRename * 100/cntTotal),
            (cntVfnDelete * 100/cntTotal));

bailout:
    ShadowLog("\r***** Stats End ******* \r");
    return 1;
}

void ShadowRestrictedEventCallback
    (
    )
{
    FlushLog();
    ENTERCRIT_LOG;
    WriteStats(0); // Don't force him to write
    LEAVECRIT_LOG;
    FlushLog();
}
#endif //DEBUG

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\ntcsc.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ntcsc.h

Abstract:

    The global include file including the csc record manager

Author:


Revision History:

--*/

#ifndef __NTCSC_H__
#define __NTCSC_H__

//#include "ntifs.h"
#include "rx.h"
//if this is included from smbmini, we'll need this
#include "rxpooltg.h"   // RX pool tag macros


#define WIN32_NO_STATUS
#define _WINNT_
#include "windef.h"
#include "winerror.h"

//both ntifs.h and ifs.h want to define these....sigh.......

#undef STATUS_PENDING
#undef FILE_ATTRIBUTE_READONLY
#undef FILE_ATTRIBUTE_HIDDEN
#undef FILE_ATTRIBUTE_SYSTEM
#undef FILE_ATTRIBUTE_DIRECTORY
#undef FILE_ATTRIBUTE_ARCHIVE

#include "ifs.h"


#define VxD
#define CSC_RECORDMANAGER_WINNT
#define CSC_ON_NT

// get rid of far references
#define far

//handle types
typedef ULONG DWORD;


// the VxD code likes to declare long pointers.....
typedef PVOID LPVOID;
typedef BYTE *LPBYTE;


//semaphore stuff....should be in a separate .h file
typedef PFAST_MUTEX VMM_SEMAPHORE;

INLINE
PFAST_MUTEX
Create_Semaphore (
    ULONG count
    )
{
    PFAST_MUTEX fmutex;
    ASSERT(count==1);

    fmutex =  (PFAST_MUTEX)RxAllocatePoolWithTag(
                NonPagedPool,
                sizeof(FAST_MUTEX),
                RX_MISC_POOLTAG);

    if (fmutex){
        ExInitializeFastMutex(fmutex);
    }

    //DbgPrint("fmtux=%08lx\n",fmutex);
    //ASSERT(!"here in init semaphore");

    return fmutex;
}

#define Destroy_Semaphore(__sem) { RxFreePool(__sem);}

//Bug 498169 - changing to unsafe version of acquire and release mutex - navjotv
#define Wait_Semaphore(__sem, DUMMY___) {\
							KeEnterCriticalRegion();\
							ExAcquireFastMutexUnsafe(__sem);}
#define Signal_Semaphore(__sem) {\
							ExReleaseFastMutexUnsafe(__sem);\
							KeLeaveCriticalRegion();}
//#define Wait_Semaphore(__sem, DUMMY___) { ExAcquireFastMutex(__sem);}
//#define Signal_Semaphore(__sem) { ExReleaseFastMutex(__sem);}

//registry stuff.........again, will be a separate .h file
typedef DWORD   VMMHKEY;
typedef VMMHKEY *PVMMHKEY;
typedef DWORD   VMMREGRET;                      // return type for the REG Functions

#define MAX_VMM_REG_KEY_LEN     256     // includes the \0 terminator

#ifndef REG_SZ          // define only if not there already
#define REG_SZ          0x0001
#endif
#ifndef REG_BINARY      // define only if not there already
#define REG_BINARY      0x0003
#endif
#ifndef REG_DWORD       // define only if not there already
#define REG_DWORD       0x0004
#endif


#ifndef HKEY_LOCAL_MACHINE      // define only if not there already

#define HKEY_CLASSES_ROOT               0x80000000
#define HKEY_CURRENT_USER               0x80000001
#define HKEY_LOCAL_MACHINE              0x80000002
#define HKEY_USERS                      0x80000003
#define HKEY_PERFORMANCE_DATA           0x80000004
#define HKEY_CURRENT_CONFIG             0x80000005
#define HKEY_DYN_DATA                   0x80000006

#endif

//initially, we won't go to the registry!
#define _RegOpenKey(a,b,c) (ERROR_SUCCESS+1)
#define _RegQueryValueEx(a,b,c,d,e,f) (ERROR_SUCCESS+1)
#define _RegCloseKey(a) {NOTHING; }

// fix up the fact that stuff is conditioned on DEBUG and various...
#if DBG
#define DEBLEVEL 2
#define DEBUG
#else
#define DEBLEVEL 2
#endif
#define VERBOSE 3


// now the real includes

#define WIN32_APIS
#define UNICODE 2
#include "shdcom.h"
#include "oslayer.h"
#include "record.h"
#include "cshadow.h"
#include "utils.h"
#include "hookcmmn.h"
#include "cscsec.h"
#include "log.h"

#include "ntcsclow.h"

//we have to redefine status_pending since the win95 stuff redefines it.......
#undef STATUS_PENDING
#define STATUS_PENDING                   ((NTSTATUS)0x00000103L)    // winnt

ULONG
IFSMgr_Get_NetTime();

#ifndef MRXSMB_BUILD_FOR_CSC_DCON

//define these to passivate so that i can share some code......
#undef   mIsDisconnected
#define  mIsDisconnected(pResource)  (FALSE)
//#define  mShadowOutofSync(uShadowStatus)  (mQueryBits(uShadowStatus, SHADOW_MODFLAGS|SHADOW_ORPHAN))
#undef   mShadowOutofSync
#define  mShadowOutofSync(uShadowStatus)  (FALSE)

#else

//dont allow mIsDisconnected anymore in common code
#undef   mIsDisconnected
#define  mIsDisconnected(pResource)  (LALA)
#define  mShadowOutofSync(uShadowStatus)  (mQueryBits(uShadowStatus, SHADOW_MODFLAGS|SHADOW_ORPHAN))

#endif

#endif //ifdef __NTCSC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\record.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Record.c

Abstract:

    This is the set of definitions that describes the actual contents of the
    record manager files. Records are actually of two types: "headers" that
    describe the structural content of a file and "records" that contain the
    actual mappings.

Author:

    Shishir Pardikar     [Shishirp]      01-jan-1995

Revision History:

    Joe Linn             [JoeLinn]       20-mar-97    Ported for use on NT

--*/

#ifndef RECORD_INCLUDED
#define RECORD_INCLUDED

#define  REC_EMPTY    'E'    // Record is empty
#define  REC_DATA     'D'    // Record has valid data
#define  REC_OVERFLOW 'O'    // This is an overflow record
#define  REC_SKIP     'S'    // This is record that should be skipped

#define Q_GETFIRST      1
#define Q_GETNEXT       2
#define Q_GETLAST       3
#define Q_GETPREV       4


#define  DB_SHADOW      1
#define  DB_HINT        2

#define  IsLeaf(ulidShadow)   (((ulidShadow) & 0x80000000) != 0)
#define  OVF_MASK       0xff
#define  MODFLAG_MASK   (~OVF_MASK)

#define  ULID_SHARE            1L
#define  ULID_PQ                (ULID_SHARE+1)
#define  ULID_SID_MAPPINGS      (ULID_PQ + 1)
#define  ULID_TEMPORARY_SID_MAPPINGS (ULID_SID_MAPPINGS + 1)
#define  ULID_TEMP1             (ULID_TEMPORARY_SID_MAPPINGS + 1)
#define  ULID_TEMP2             (ULID_TEMP1 + 1)

#ifdef OLD_INODE_SCHEME
#define  ULID_INODE             (ULID_SHARE+2) // we need to phase this out
#endif // OLD_INODE_SCHEME

#define  ULID_FIRST_USER_DIR    (ULID_PQ+15)    // 14 more special inodes available

#define  INODE_STRING_LENGTH        8
#define  SUBDIR_STRING_LENGTH       2

#define  CSCDB_SUBDIR_COUNT         8
#define  CSCDbSubdirFirstChar()     'd'
#define  CSCDbSubdirSecondChar(ULID_INODE) ((char)(((ULID_INODE)>=ULID_FIRST_USER_DIR)?('1'+((ULID_INODE)&0x7)):0))

#define  MAX_HINT_PRI            0xfe
#define  MAX_PRI                ((ULONG)254)
#define  MIN_PRI                ((ULONG)0)
#define  INVALID_REC            0
#define  INVALID_SHADOW         0

#define CSC_DATABASE_ERROR_INVALID_HEADER       0x00000001
#define CSC_DATABASE_ERROR_INVALID_OVF_COUNT    0x00000002
#define CSC_DATABASE_ERROR_TRUNCATED_INODE      0x00000004
#define CSC_DATABASE_ERROR_MISSING_INODE        0x00000008


#define  OvfCount(lpGR)             (((LPGENERICREC)(lpGR))->uchFlags & OVF_MASK)
#define  ClearOvfCount(lpGR)        (((LPGENERICREC)(lpGR))->uchFlags &= ~OVF_MASK)
#define  SetOvfCount(lpGR, cOvf)    {ClearOvfCount(lpGR);\
                                     ((LPGENERICREC)(lpGR))->uchFlags |= (cOvf) & OVF_MASK;}

#define  ModFlag(lpGR)              (((LPGENERICREC)(lpGR))->uchFlags & MODFLAG_MASK)
#define  ClearModFlag(lpGR)        (((LPGENERICREC)(lpGR))->uchFlags &= ~MODFLAG_MASK)
#define  SetModFlag(lpGR, uchFlag)    {ClearModFlag(lpGR);\
                                     ((LPGENERICREC)(lpGR))->uchFlags |= (uchFlag) & MODFLAG_MASK;}

#define  HeaderModFlag(lpGH)              (((LPGENERICHEADER)(lpGH))->uchFlags & MODFLAG_MASK)
#define  ClearHeaderModFlag(lpGH)        (((LPGENERICHEADER)(lpGH))->uchFlags &= ~MODFLAG_MASK)
#define  SetHeaderModFlag(lpGH, uchFlag)    {ClearHeaderModFlag(lpGH);\
                                     ((LPGENERICHEADER)(lpGH))->uchFlags |= (uchFlag) & MODFLAG_MASK;}

#define  RealFileSize(dwFileSize)   (((dwFileSize)+vdwClusterSizeMinusOne) & vdwClusterSizeMask)

#define  STATUS_WRITING MODFLAG_MASK

// HEADER types have three things in common:
//   1) they all have the same common part (RECORDMANAGER_COMMON_HEADER)
//   2) they are all 64bytes long (GENERICHEADER)
//   3) they MAY have optional addition information in the space after the common part
// we use anonymous union and struct components to achieve this in a maintainable way

typedef struct _RECORDMANAGER_COMMON_HEADER {
   UCHAR    uchType; //
   UCHAR    uchFlags;  //
   USHORT   uRecSize;   //  Size in bytes of one record
   ULONG    ulRecords;  //  # of records in the file
   LONG     lFirstRec;  //  Position of the first record
   ULONG    ulVersion;  //  Version # of the persistent database
} RECORDMANAGER_COMMON_HEADER, *PRECORDMANAGER_COMMON_HEADER;

typedef struct tagGENERICHEADER
   {
       union {
           RECORDMANAGER_COMMON_HEADER;
           UCHAR Ensure64byteSize[64];
       };
   }
GENERICHEADER, FAR *LPGENERICHEADER;


//no additional info on a INODEHEADER

typedef struct tagINODEHEADER
   {
       GENERICHEADER;
   }
INODEHEADER, FAR *LPINODEHEADER;



// servers have a bit of extra info in the padding

typedef struct tagSHAREHEADER
   {
       union {
           GENERICHEADER;
           struct {
               RECORDMANAGER_COMMON_HEADER spacer; //move past the common part
               ULONG        uFlags;   // General flags which define the state of the database
               STOREDATA    sMax;     // Maximum allowed storage
               STOREDATA    sCur;     // Current stats
           };
       };
   }
   SHAREHEADER, FAR *LPSHAREHEADER;

#define FLAG_SHAREHEADER_DATABASE_OPEN 0x00000001  // set when the database is opened
                                                    // and cleared when closed.
#define FLAG_SHAREHEADER_DATABASE_ENCRYPTED    0x00000002


typedef struct tagFILEHEADER
   {
       union {
           GENERICHEADER;
           struct {
               RECORDMANAGER_COMMON_HEADER spacer; //move past the common part
               ULONG  ulidNextShadow;  // #  of next inode to be used
               ULONG  ulsizeShadow;    // # Bytes shadowed
               ULONG  ulidShare;      // server index,
               ULONG  ulidDir;         // directory file inode #
               USHORT ucShadows;       // # shadowed entries
           };
       };
   }
   FILEHEADER, FAR *LPFILEHEADER;

typedef struct tagQHEADER
   {
       union {
           GENERICHEADER;
           struct {
               RECORDMANAGER_COMMON_HEADER spacer; //move past the common part
               ULONG          ulrecHead;  // Head of the queue
               ULONG          ulrecTail;  // Tail of the queue
           };
       };
   }
   QHEADER, PRIQHEADER, FAR *LPQHEADER, FAR *LPPRIQHEADER;

// RECORD types are not quite as similar:
//   1) they all have the same common part (RECORDMANAGER_COMMON_RECORD)
//   2) BUT, they are not arbitrarily padded.
//   3) addition information ordinarily follows the common part
// we use anonymous union and struct components to achieve this in a maintainable way


typedef struct _RECORDMANAGER_COMMON_RECORD {
   UCHAR  uchType; //
   UCHAR  uchFlags;  //
   //one of the records calls it usStatus....others call it uStatus...sigh.....
   union {
       USHORT uStatus;          // Shadow Status
       USHORT usStatus;          // Shadow Status
   };
} RECORDMANAGER_COMMON_RECORD, *PRECORDMANAGER_COMMON_RECORD;

typedef struct _RECORDMANAGER_BOOKKEEPING_FIELDS {
   UCHAR  uchRefPri;     // Reference Priority
   UCHAR  uchIHPri;      // Inherited Hint Pri
   UCHAR  uchHintFlags;  // Flags specific to hints
   UCHAR  uchHintPri;    // Hint Priority if a hint
} RECORDMANAGER_BOOKKEEPING_FIELDS, *LPRECORDMANAGER_BOOKKEEPING_FIELDS;

typedef struct _RECORDMANAGER_SECURITY_CONTEXT {
    ULONG Context;
    ULONG Context2;
    ULONG Context3;
    ULONG Context4;
} RECORDMANAGER_SECURITY_CONTEXT, *LPRECORDMANAGER_SECURITY_CONTEXT;

typedef struct tagGENERICREC
{
    RECORDMANAGER_COMMON_RECORD;
}
GENERICREC, FAR *LPGENERICREC;


typedef struct tagINODEREC
{
    RECORDMANAGER_COMMON_RECORD;    //uStatus is not used....
    ULONG  ulidShadow; // Shadow File INODE
}
INODEREC, FAR *LPINODEREC;


// Share record format

// ACHTUNG in someplaces in cshadow.c, it is assumed that tagSHAREREC is smaller than
// tagFILERECEXT structure. This will always be true, but it is important to note
// the assumption

typedef struct tagSHAREREC
{
    RECORDMANAGER_COMMON_RECORD;            //                          4

    ULONG           ulidShadow;             // Root INODE #             8
    DWORD           dwFileAttrib;           // root inode attributes    12
    FILETIME        ftLastWriteTime;        // Last Write Time          20
    FILETIME        ftOrgTime;              // server time              28

    USHORT          usRootStatus;           //                          30
    UCHAR           uchHintFlags;           // Hint flags on the root   31
    UCHAR           uchHintPri;             // pin count for the root   32
    RECORDMANAGER_SECURITY_CONTEXT sShareSecurity;//                    48
    RECORDMANAGER_SECURITY_CONTEXT sRootSecurity;//                     64
    ULONG   Reserved;                       //                          68
    ULONG   Reserved2;                      //                          72

    ULONG  ulShare;                        //                          80
    USHORT rgPath[64];                      //                          208 MAX_SHARE_SHARE_NAME_FOR_CSC defined in shdcom.h. Both must
                   // be kept in sync.
}
SHAREREC, FAR *LPSHAREREC;
//#pragma pack()      //packing off

#define  FILEREC_LOCALLY_CREATED 0x0001
#define  FILEREC_DIRTY           0x0002   // FILEREC_XXX
#define  FILEREC_BUSY            0x0004
#define  FILEREC_SPARSE          0x0008
#define  FILEREC_SUSPECT         0x0010
#define  FILEREC_DELETED         0x0020
#define  FILEREC_STALE           0x0040


// File record format
typedef struct tagFILEREC
{
    RECORDMANAGER_COMMON_RECORD;                                        // 4

    union
    {
        struct
        {
            // INODEREC part
            ULONG           ulidShadow;       // Shadow File INODE #    // 8
            ULONG           ulFileSize;       // FileSize               // 12
            ULONG           ulidShadowOrg;    // Original Inode         // 16
            DWORD           dwFileAttrib;     // File attributes        // 20
            FILETIME        ftLastWriteTime;  // File Write Time        // 28

            RECORDMANAGER_BOOKKEEPING_FIELDS;                           // 32
            RECORDMANAGER_SECURITY_CONTEXT Security;                    // 48

            ULONG           Reserved;           // for future use       // 52
            ULONG           Reserved2;          // for future use       // 56
            ULONG           Reserved3;          // for future use       // 60
            ULONG           ulLastRefreshTime;  // time                 // 64
                                                // when this entry was
                                                // refreshed (in seconds since 1970)

            FILETIME        ftOrgTime;        // Original Time          // 72


            USHORT          rgw83Name[14];     // 83 Name               // 100
            USHORT          rgwName[14];      // LFN part               // 128
        };

        USHORT  rgwOvf[1];   // used for copying overflow records
    };
}
FILEREC, FAR *LPFILEREC;


typedef struct tagQREC
{
    RECORDMANAGER_COMMON_RECORD;
    ULONG          ulidShare;          // Share ID
    ULONG          ulidDir;             // Dir ID
    ULONG          ulidShadow;          // Shadow ID
    ULONG          ulrecDirEntry;       // rec # of the entry in directory ulidDir
    ULONG          ulrecPrev;           // Predecessor record #
    ULONG          ulrecNext;           // Successor   record #
    RECORDMANAGER_BOOKKEEPING_FIELDS;
}
QREC, PRIQREC, FAR *LPQREC, FAR *LPPRIQREC;

// ACHTUNG in someplaces in cshadow.c, it is assumed that tagSHAREREC is smaller than
// tagFILERECEXT structure. This will always be true, but it is important to note
// the assumption
typedef struct tagFILERECEXT
{
    FILEREC sFR;
    FILEREC rgsSR[4];   // fits a record with LFN of MAX_PATH unicode characters
}
FILERECEXT, FAR *LPFILERECEXT;

// # of overflow records for LFN
#define MAX_OVERFLOW_FILEREC_RECORDS    ((sizeof(FILERECEXT)/sizeof(FILEREC)) - 1)

#define MAX_OVERFLOW_RECORDS    MAX_OVERFLOW_FILEREC_RECORDS

// amount of data an overflow file record will hold
#define SIZEOF_OVERFLOW_FILEREC     (sizeof(FILEREC) - sizeof(RECORDMANAGER_COMMON_RECORD))

#define  CPFR_NONE                  0x0000
#define  CPFR_INITREC               0x0001
#define  CPFR_COPYNAME              0x0002

#define  mCheckBit(uFlags, uBit)  ((uFlags) & (uBit))
#define  mSetBits(uFlags, uBits)    ((uFlags) |= (uBits))
#define  mClearBits(uFlags, uBits)    ((uFlags) &= ~(uBits))


#define  mHintFlags(lpFind32) ((lpFind32)->dwReserved0)
#define  mHintPri(lpFind32)   ((lpFind32)->dwReserved1)

// how inodes are created
#define InodeFromRec(ulRec, fFile)  ((ulRec+ULID_FIRST_USER_DIR-1) | ((fFile)?0x80000000:0))
#define RecFromInode(hShadow)       ((hShadow & 0x7fffffff) - (ULID_FIRST_USER_DIR-1))
#define IsDirInode(hShadow)         ((!(hShadow & 0x80000000)) && ((hShadow & 0x7fffffff)>=ULID_FIRST_USER_DIR))

#define NT_DB_PREFIX "\\DosDevices\\"


typedef int (PUBLIC *EDITCMPPROC)(LPVOID, LPVOID);

extern DWORD vdwClusterSizeMinusOne, vdwClusterSizeMask;

BOOL
PUBLIC
FExistsRecDB(
    LPSTR    lpszLocation
    );

LPVOID
PUBLIC                                   // ret
OpenRecDB(                                              //
    LPSTR  lpszLocation,        // database directory
    LPSTR  lpszUserName,        // name (not valid any more)
    DWORD   dwDefDataSizeHigh,  //high dword of max size of unpinned data
    DWORD   dwDefDataSizeLow,   //low dword of max size of pinned data
    DWORD   dwClusterSize,      // clustersize of the disk, used to calculate
                                // the actual amount of disk consumed
    BOOL    fReinit,            // reinitialize, even if it exists
    BOOL    *lpfNew,            // returns whether the database was newly recreated
    ULONG   *pulGlobalStatus    // returns the current globalstatus of the database
);

int
PUBLIC
CloseRecDB(
    LPVOID    lpdbID
);

int
QueryRecDB(
    LPTSTR  lpszLocation,       // database directory, must be MAX_PATH
    LPTSTR  lpszUserName,       // name (not valid any more)
    DWORD   *lpdwDefDataSizeHigh,  //high dword of max size of unpinned data
    DWORD   *lpdwDefDataSizeLow,   //low dword of max size of pinned data
    DWORD   *lpdwClusterSize      // clustersize of the disk, used to calculate
    );

ULONG PUBLIC FindFileRecord(LPVOID, ULONG, USHORT *, LPFILERECEXT);
int PUBLIC FindFileRecFromInode(LPVOID, ULONG, ULONG, ULONG, LPFILERECEXT);
ULONG PUBLIC FindShareRecord(LPVOID, USHORT *, LPSHAREREC);
ULONG PUBLIC FindSharerecFromInode(LPVOID, ULONG, LPSHAREREC);
ULONG PUBLIC FindSharerecFromShare(LPVOID, ULONG, LPSHAREREC);
ULONG PUBLIC AddShareRecord(LPVOID, LPSHAREREC);
int PUBLIC DeleteShareRecord(LPVOID, ULONG);
int   PUBLIC GetShareRecord(LPVOID, ULONG, LPSHAREREC);
int PUBLIC SetShareRecord(LPVOID, ULONG, LPSHAREREC);
ULONG PUBLIC AddFileRecordFR(LPVOID, ULONG, LPFILERECEXT);
int PUBLIC DeleteFileRecord(LPVOID, ULONG, USHORT *, LPFILERECEXT);

int PUBLIC DeleteFileRecFromInode(LPVOID, ULONG, ULONG, ULONG, LPFILERECEXT);
int PUBLIC UpdateFileRecFromInode(
    LPVOID  lpdbID,
    ULONG   ulidDir,
    ULONG   hShadow,
    ULONG   ulrecDirEntry,
    LPFILERECEXT    lpFR
    );
int PUBLIC UpdateFileRecFromInodeEx(
    LPVOID  lpdbID,
    ULONG   ulidDir,
    ULONG   hShadow,
    ULONG   ulrecDirEntry,
    LPFILERECEXT    lpFR,
    BOOL    fCompareInodes
    );
int PUBLIC ReadFileRecord(LPVOID, ULONG, LPGENERICHEADER, ULONG, LPFILERECEXT);
int DeleteInodeFile(LPVOID, ULONG);
int TruncateInodeFile(LPVOID, ULONG);
int PUBLIC CreateDirInode(LPVOID, ULONG, ULONG, ULONG);
int SetInodeAttributes(LPVOID, ULONG, ULONG);
int GetInodeAttributes(LPVOID, ULONG, ULONG *);

CSCHFILE PUBLIC BeginSeqReadPQ(LPVOID);
int PUBLIC SeqReadQ(CSCHFILE, LPQREC, LPQREC, USHORT);
int PUBLIC EndSeqReadPQ(CSCHFILE);
int PUBLIC AddPriQRecord(LPVOID, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG);
int PUBLIC DeletePriQRecord(LPVOID, ULONG, ULONG, LPPRIQREC);
int PUBLIC FindPriQRecord(LPVOID, ULONG, ULONG, LPPRIQREC);
int FindPriQRecordInternal(
    LPTSTR      lpdbID,
    ULONG       ulidShadow,
    LPPRIQREC   lpSrc
    );
int PUBLIC UpdatePriQRecord(LPVOID, ULONG, ULONG, LPPRIQREC);
int PUBLIC UpdatePriQRecordAndRelink(
    LPVOID      lpdbID,
    ULONG       ulidDir,
    ULONG       ulidShadow,
    LPPRIQREC   lpPQ
    );
int PUBLIC GetInodeFileSize(LPVOID, ULONG, ULONG far *);
int PUBLIC AddStoreData(LPVOID, LPSTOREDATA);
int PUBLIC SubtractStoreData(LPVOID, LPSTOREDATA);
int PUBLIC GetStoreData(LPVOID, LPSTOREDATA);
ULONG PUBLIC UlAllocInode(LPVOID, ULONG, BOOL);
int PUBLIC FreeInode(LPVOID, ULONG);
BOOL PUBLIC FInodeIsFile(LPVOID, ULONG, ULONG);
int FindAncestorsFromInode(LPVOID, ULONG, ULONG *, ULONG *);
void  PUBLIC CopyFindInfoToFilerec(LPFIND32 lpFind32, LPFILERECEXT lpFR, ULONG uFlags);
void PUBLIC CopyNamesToFilerec(LPFIND32, LPFILERECEXT);
ULONG PUBLIC AllocFileRecord(LPVOID, ULONG, USHORT *, LPFILERECEXT);
ULONG PUBLIC AllocPQRecord(LPVOID);
ULONG AllocShareRecord(LPVOID, USHORT *);
int ReadDirHeader(LPVOID, ULONG, LPFILEHEADER);
int WriteDirHeader(LPVOID, ULONG, LPFILEHEADER);
int HasDescendents(LPVOID, ULONG, ULONG);

//prototypes added to remove NT compile errors
int PUBLIC  ReadShareHeader(
   LPVOID           lpdbID,
   LPSHAREHEADER   lpSH
   );

int PUBLIC  WriteShareHeader(
   LPVOID           lpdbID,
   LPSHAREHEADER   lpSH
   );

#if defined(BITCOPY)
LPVOID PUBLIC FormAppendNameString(LPVOID, ULONG, LPVOID);
int
DeleteStream(
    LPTSTR      lpdbID,
    ULONG       ulidFile,
    LPTSTR      str2Append
    );
#endif // defined(BITCOPY)

LPVOID PUBLIC FormNameString(LPVOID, ULONG);
VOID PUBLIC FreeNameString(LPVOID);

void PUBLIC CopyFilerecToFindInfo(
   LPFILERECEXT   lpFR,
   LPFIND32    lpFind
   );

BOOL    PUBLIC InitShareRec(LPSHAREREC, USHORT *, ULONG);

int PUBLIC EndSeqReadQ(
   CSCHFILE hf
   );

int PUBLIC ReadHeader(CSCHFILE, LPVOID, USHORT);
int PUBLIC WriteHeader(CSCHFILE, LPVOID, USHORT);
int PUBLIC CopyRecord(LPGENERICREC, LPGENERICREC, USHORT, BOOL);
int PUBLIC ReadRecord(CSCHFILE, LPGENERICHEADER, ULONG, LPGENERICREC);
int PUBLIC WriteRecord(CSCHFILE, LPGENERICHEADER, ULONG, LPGENERICREC);
int
DeleteRecord(
    CSCHFILE   hf,
    LPGENERICHEADER lpGH,
    ULONG           ulRec,
    LPGENERICREC    lpGR,   // source
    LPGENERICREC    lpDst  // optional destination record, at which a copy should be
                            // made before deleting
);
ULONG PUBLIC EditRecordEx(
    ULONG    ulidInode,
    LPGENERICREC lpSrc,
    EDITCMPPROC lpCompareFunc,
    ULONG       ulInputRec,
    ULONG uOp
    );

int PUBLIC  LinkQRecord(
    CSCHFILE     hf,           // This file
    LPQREC    lpNew,        // Insert This record
    ULONG     ulrecNew,     // This is it's location in the file
    ULONG     ulrecPrev,     // This is our Prev's location
    ULONG     ulrecNext      // This is our Next's location
    );
int PUBLIC UnlinkQRecord(CSCHFILE, ULONG, LPQREC);
void PRIVATE InitPriQRec(ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, LPPRIQREC);
int PUBLIC IComparePri(LPPRIQREC, LPPRIQREC);
int PUBLIC IComparePriEx(LPPRIQREC, LPPRIQREC);
int PUBLIC ICompareQInode(LPPRIQREC, LPPRIQREC);

void
InitQHeader(
    LPQHEADER lpQH
    );

int PUBLIC AddQRecord(
    LPSTR   lpQFile,
    ULONG   ulidPQ,
    LPQREC  lpSrc,
    ULONG   ulrecNew,
    EDITCMPPROC fnCmp
    );

int PUBLIC DeleteQRecord(
    LPSTR           lpQFile,
    LPQREC          lpSrc,
    ULONG           ulRec,
    EDITCMPPROC     fnCmp
    );

int PUBLIC ReadHeaderEx(
    CSCHFILE hf,
    LPGENERICHEADER lpGH,
    USHORT sizeBuff,
    BOOL    fInstrument
    );
int PUBLIC WriteHeaderEx(
    CSCHFILE hf,
    LPGENERICHEADER    lpGH,
    USHORT sizeBuff,
    BOOL    fInstrument
    );

int PUBLIC ReadRecordEx(
    CSCHFILE hf,
    LPGENERICHEADER lpGH,
    ULONG  ulRec,
    LPGENERICREC    lpSrc,
    BOOL    fInstrument
    );

int PUBLIC WriteRecordEx(
    CSCHFILE hf,
    LPGENERICHEADER lpGH,
    ULONG  ulRec,
    LPGENERICREC    lpSrc,
    BOOL    fInstrument
    );

BOOL
ReorderQ(
    LPVOID  lpdbID
    );

CSCHFILE
OpenInodeFileAndCacheHandle(
    LPVOID  lpdbID,
    ULONG   ulidInode,
    ULONG   ulOpenMode,
    BOOL    *lpfCached
);

BOOL
EnableHandleCachingInodeFile(
    BOOL    fEnable
    );

int
PUBLIC CopyFileLocal(
    LPVOID  lpdbShadow,
    ULONG   ulidFrom,
    LPSTR   lpszNameTo,
    ULONG   ulAttrib
);

void
BeginInodeTransaction(
    VOID
    );
void
EndInodeTransaction(
    VOID
    );

BOOL
TraversePQ(
    LPVOID      lpdbID
    );

BOOL
RebuildPQ(
    LPVOID      lpdbID
    );

BOOL
TraverseHierarchy(
    LPVOID      lpdbID,
    BOOL        fFix
    );

// this actually defined in recordse.c
BOOL
EnableHandleCachingSidFile(
    BOOL    fEnable
    );

int RenameInode(
    LPTSTR  lpdbID,
    ULONG   ulidFrom,
    ULONG   ulidTo
    );
int
RecreateInode(
    LPTSTR  lpdbID,
    HSHADOW hShadow,
    ULONG   ulAttribIn
    );

ULONG
GetCSCDatabaseErrorFlags(
    VOID
    );


BOOL
DeleteFromHandleCache(
    ULONG   ulidShadow
);

VOID
SetCSCDatabaseErrorFlags(
    ULONG ulFlags
);

BOOL
EncryptDecryptDB(
    LPVOID      lpdbID,
    BOOL        fEncrypt
);


#include "timelog.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\record.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

     Record.c

Abstract:

This file contains the implementation of CSC database record manager.
The database consists of files which are numbered starting from 1. The idea is similar to
an inode on unix. Inode files 1 to 0xF are special inode files.
Directories are cached in files which have inode numbers in the range 0x10 to 0x7FFFFFFFF.
Files are given Inode #s in the range 0x80000010 to 0x8FFFFFFF.


File #1 is the root inode which contains all the cached shares. It contains inode #s for
the roots of the corresponding share etc. The format SHAREREC in record.h tells the story.

Inode file #2 (Priority Q) is like a master file table for all the entries in the
database. Inode #2 also contains an MRU list for all the entries. This helps us in filling,
nuking the appropriate entries.

The PriorityQ has an entry for every FSOBJ in the hierarchy. Hence the index of the FSOBJ is
used to obtain an inode. This has the advantage of random accessing the PQ. This allows the PQ
to grow large without causing scalability problems.

Inodes 1, 2 and the directory indoes (0x10 - 0x7fffffff) have the following general format:
- each has a header, the prefix of which is of the type GENEIRCHEADER.
- each has a set of records, each record having a prefix of the type GENERICRECORD
EditRecord is a worker routine which works on all the above files based on this format.


Except for inode files 1 and 2 all others are sprinkled into 8 different directories. The formula
for sprinkling is in the routine FormNameString.


Author:

     Shishir Pardikar      [Shishirp]        01-jan-1995

Revision History:

     Joe Linn                 [JoeLinn]         23-jan-97     Ported for use on NT

--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

#if defined(BITCOPY)
#include <csc_bmpc.h>
static LPSTR CscBmpAltStrmName = STRMNAME;
#endif // defined(BITCOPY)


#ifndef CSC_RECORDMANAGER_WINNT
#include "record.h"
#endif //ifndef CSC_RECORDMANAGER_WINNT

#include <stdlib.h>
#include <direct.h>
#include <dos.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
//#include <io.h>
#include <share.h>
#include <ctype.h>
#include <string.h>


#undef RxDbgTrace
#define RxDbgTrace(a,b,__d__) {qweee __d__;}

#ifdef DEBUG
//cshadow dbgprint interface
#define RecordKdPrint(__bit,__x) {\
    if (((RECORD_KDP_##__bit)==0) || FlagOn(RecordKdPrintVector,(RECORD_KDP_##__bit))) {\
    KdPrint (__x);\
    }\
}
#define RECORD_KDP_ALWAYS                 0x00000000
#define RECORD_KDP_BADERRORS              0x00000001
#define RECORD_KDP_INIT                   0x00000002
#define RECORD_KDP_STOREDATA              0x00000004
#define RECORD_KDP_FINDFILERECORD         0x00000008
#define RECORD_KDP_LFN2FILEREC            0x00000010
#define RECORD_KDP_EDITRECORDUPDDATEINFO  0x00000020
#define RECORD_KDP_PQ                     0x00000040
#define RECORD_KDP_COPYLOCAL              0x00000080

#define RECORD_KDP_GOOD_DEFAULT (RECORD_KDP_BADERRORS   \
                    | 0)

ULONG RecordKdPrintVector = RECORD_KDP_GOOD_DEFAULT;
//ULONG RecordKdPrintVector = 0xffff &~(RECORD_KDP_LFN2FILEREC);
ULONG RecordKdPrintVectorDef = RECORD_KDP_GOOD_DEFAULT;
#else
#define RecordKdPrint(__bit,__x)  {NOTHING;}
#endif



/********************** typedefs and defines ********************************/
#define SHARE_FILE_NO          1   // Inode # of the super root

#define INODE_NULL              0L

// operations performed by edit record
#define UPDATE_REC              1
#define FIND_REC                2
#define DELETE_REC              3
#define ALLOC_REC               4
#define CREATE_REC              5

#define DEFAULT_SHADOW_SPACE    0x1000000

#define COMMON_BUFF_SIZE          4096

#define ValidRec(ulRec)        (((ulRec) != INVALID_REC))
#define BYTES_PER_SECTOR        512

typedef struct tagHANDLE_CACHE_ENTRY{
    ULONG       ulidShadow;
    CSCHFILE       hf;
    ULONG       ulOpenMode;
    FILETIME    ft;
}
HANDLE_CACHE_ENTRY;
#define HANDLE_CACHE_SIZE   11
#define MAX_INODE_TRANSACTION_DURATION_IN_SECS  300 // 5 minutes


#define MAX_PATH	260	/* Maximum path length - including nul */

#define UseCommonBuff()     {Assert(!vfCommonBuffInUse); vfCommonBuffInUse = TRUE;}
#define UnUseCommonBuff()   {vfCommonBuffInUse = FALSE;}

#define  STRUCT_OFFSET(type, element)  ((ULONG)&(((type)0)->element))

#define EditRecord(ulidInode, lpSrc, lpCompareFunc, uOp) \
        EditRecordEx((ulidInode), (lpSrc), (lpCompareFunc), INVALID_REC, (uOp))


#pragma intrinsic (memcmp, memcpy, memset, strcat, strcmp, strcpy, strlen)

/********************** static data *****************************************/
/********************** global data *****************************************/

HANDLE_CACHE_ENTRY  rgHandleCache[HANDLE_CACHE_SIZE];

LPSTR   vlpszShadowDir = NULL;
int     vlenShadowDir = 0;

#ifdef CSC_RECORDMANAGER_WINNT
char vszShadowDir[MAX_SHADOW_DIR_NAME+1];
#endif

static char szBackslash[] = "\\";
#ifdef LATER
static char szStar[] = "\\*.*";
#endif //LATER
ULONG ulMaxStoreSize = 0;

#define CONDITIONALLY_NOP() ;

#ifdef DEBUG
#ifdef CSC_RECORDMANAGER_WINNT
LONGLONG    rgllTimeArray[TIMELOG_MAX];
#endif
#endif
char rgchReadBuff[COMMON_BUFF_SIZE];
LPBYTE  lpReadBuff = (LPBYTE)rgchReadBuff;
BOOL    vfCommonBuffInUse = FALSE;

DWORD vdwClusterSizeMinusOne=0, vdwClusterSizeMask=0xffffffff;
_FILETIME ftHandleCacheCurTime = {0, 0};
unsigned    cntReorderQ = 0;
unsigned    cntInodeTransactions = 0;
ULONG       ulLastInodeTransaction = 0;
BOOL        vfStopHandleCaching = FALSE;
ULONG       ulErrorFlags=0;
BOOL     fSupportsStreams = FALSE;

/********************** function prototypes *********************************/

void PRIVATE CopyNameToFilerec(LPTSTR lpName, LPFILERECEXT lpFre);
void  PRIVATE InitFileRec(LPFILERECEXT lpFre);
void  PRIVATE InitFileHeader(ULONG, ULONG, LPFILEHEADER);
ULONG PRIVATE GetNextFileInode(LPVOID, ULONG);
ULONG PRIVATE GetNextDirInode(LPVOID);
int PRIVATE InitShareDatabase(
    LPTSTR      lpdbID,
    LPTSTR  lpszUserName,
    DWORD   dwDefDataSizeHigh,
    DWORD   dwDefDataSizeLow,
    BOOL    fReinit,
    BOOL    *lpfReinited,
    BOOL    *lpfWasDirty,
    ULONG   *pulGlobalStatus
);

int PRIVATE InitPriQDatabase(LPVOID, BOOL fReinit, BOOL *lpfReinited);

int PUBLIC ICmpSameDirFileInode(LPINODEREC, LPINODEREC);
int PUBLIC ICompareDirInode(LPINODEREC, LPINODEREC);
int PUBLIC ICompareInodeRec(LPINODEREC, LPINODEREC);
int PRIVATE CreateRecordFile(LPVOID lpdbID, ULONG ulidShare, ULONG ulidDir, ULONG ulidNew);

int PUBLIC ICompareShareRec(LPSHAREREC, LPSHAREREC);
int PUBLIC ICompareShareRecId(LPSHAREREC, LPSHAREREC);
int PUBLIC ICompareShareRoot(LPSHAREREC, LPSHAREREC);
int PUBLIC ICompareFileRec(LPFILERECEXT, LPFILERECEXT);
int PUBLIC ICompareFileRecInode(LPFILERECEXT, LPFILERECEXT);


int ReadInodeHeader(
    LPTSTR  lpdbID,
    ULONG   ulidDir,
    LPGENERICHEADER lpGH,
    ULONG   ulSize
    );

ULONG PRIVATE UlFormFileInode(ULONG, ULONG);
void PRIVATE DecomposeNameString(LPTSTR, ULONG far *, ULONG far *);


#ifdef LATER
LPPATH PRIVATE LpAppendStartDotStar(LPPATH);
#endif //LATER
ULONG PRIVATE GetNormalizedPri(ULONG);
int PRIVATE ICompareFail(LPGENERICREC, LPGENERICREC);


int PRIVATE    LFNToFilerec(
    USHORT          *lpLFN,
    LPFILERECEXT    lpFR
    );

int PRIVATE    FilerecToLFN(
    LPFILERECEXT    lpFR,
    USHORT          *lpLFN
    );

int PRIVATE WriteRecordEx(CSCHFILE, LPGENERICHEADER, ULONG, LPGENERICREC, BOOL);
BOOL
InsertInHandleCache(
    ULONG   ulidShadow,
    CSCHFILE   hf
);

BOOL
InsertInHandleCacheEx(
    ULONG   ulidShadow,
    CSCHFILE   hf,
    ULONG   ulOpenMode
);

BOOL
DeleteFromHandleCache(
    ULONG   ulidShadow
);

BOOL
DeleteFromHandleCacheEx(
    ULONG   ulidShadow,
    ULONG   ulOpenMode
);

BOOL FindHandleFromHandleCache(
    ULONG   ulidShadow,
    CSCHFILE   *lphf);

BOOL FindHandleFromHandleCacheEx(
    ULONG   ulidShadow,
    ULONG   ulOpenMode,
    CSCHFILE   *lphf);

BOOL
FindHandleFromHandleCacheInternal(
    ULONG   ulidShadow,
    ULONG   ulOpenMode,
    CSCHFILE   *lphf,
    int     *lpIndx);

VOID
AgeOutHandlesFromHandleCache(
    VOID
    );

BOOL
WithinSector(
    ULONG   ulRec,
    LPGENERICHEADER lpGH
    );

BOOL
ExtendFileSectorAligned(
    CSCHFILE           hf,
    LPGENERICREC    lpDst,
    LPGENERICHEADER lpGH
    );

BOOL
ValidateGenericHeader(
    LPGENERICHEADER    lpGH
    );

int PUBLIC RelinkQRecord(
    LPTSTR  lpdbID,
    ULONG   ulidPQ,
    ULONG   ulRec,
    LPQREC  lpSrc,
    EDITCMPPROC fnCmp
    );
int PUBLIC FindQRecordInsertionPoint(
    CSCHFILE   hf,
    LPQREC  lpSrc,
    ULONG   ulrecStart,
    EDITCMPPROC fnCmp,
    ULONG   *lpulrecPrev,
    ULONG   *lpulrecNext
    );

int RealOverflowCount(
    LPGENERICREC    lpGR,
    LPGENERICHEADER lpGH,
    int             cntMaxRec
    );

#ifdef CSC_RECORDMANAGER_WINNT
BOOL
FindCreateDBDir(
    LPSTR   lpszShadowDir,
    BOOL    fCleanup,
    BOOL    *lpfCreated
    );
BOOL
TraverseHierarchy(
    LPVOID lpszLocation,
    BOOL fFix);

BOOL
CheckCSCDatabaseVersion(
    LPTSTR  lpszLocation,       // database directory
    BOOL    *lpfWasDirty
);

extern ULONG
CloseFileLocalFromHandleCache(
    CSCHFILE handle
    );

#endif

BOOL
HasStreamSupport(
    CSCHFILE handle,
    BOOL    *lpfResult
    );
    

extern int TerminateShadowLog(VOID);


BOOLEAN
IsLongFileName(
    USHORT     cFileName[MAX_PATH]
    );

/****************************************************************************/
AssertData
AssertError
/***************************************************************************/

BOOLEAN
IsLongFileName(
    USHORT     cFileName[MAX_PATH]
    )
/*++

Routine Description:

   This routine checks if it is a long file name.

Arguments:

    FileName - the file name needs to be parsed
    

Return Value:

    BOOLEAN - 

--*/
{
        USHORT          i;
        USHORT          Left = 0;
        USHORT          Right = 0;
        BOOLEAN         RightPart = FALSE;
        WCHAR           LastChar = 0;
        WCHAR           CurrentChar = 0;
        
		BOOLEAN       IsLongName = FALSE;

        

        for (i=0;i<wstrlen(cFileName);i++) {
            LastChar = CurrentChar;
            CurrentChar = cFileName[i];

            if (CurrentChar == L'\\') {
                RightPart = FALSE;
                Left = 0;
                Right = 0;
                continue;
            }

            if (CurrentChar == L'.') {
                if (RightPart) {
                    IsLongName = TRUE;
                    break;
                } else {
                    RightPart = TRUE;
                    Right = 0;
                    continue;
                }
            }

            if (CurrentChar >= L'0' && CurrentChar <= L'9' ||
                CurrentChar >= L'a' && CurrentChar <= L'z' ||
                CurrentChar >= L'A' && CurrentChar <= L'Z' ||
                CurrentChar == L'~' ||
                CurrentChar == L'_' ||
                CurrentChar == L'$' ||
                CurrentChar == L'@') {
                if (RightPart) {
                    if (++Right > 3) {
                        IsLongName = TRUE;
                        break;
                    }
                } else {
                    if (++Left > 8) {
                        IsLongName = TRUE;
                        break;
                    }
                }

                
            } else {
                // if not, an alternate name may be created by the server which will
                // be different from this name.
                IsLongName = TRUE;
                break;
            }
        }
    
    return IsLongName;
}



/***************** Database initialization operations ***********************/
BOOL PUBLIC FExistsRecDB(
    LPSTR   lpszLocation
    )
/*++

Routine Description:

    Checks whether the databas exists.

Parameters:

Return Value:

Notes:

    Mostly irrelevant now.

--*/
{
    ULONG uAttrib;
    LPTSTR  lpszName;
    BOOL fRet;

    lpszName = FormNameString(lpszLocation, ULID_SHARE);

//      CheckHeap(lpszName);

    if (!lpszName)
    {
        return FALSE;
    }

    fRet = (GetAttributesLocal(lpszName, &uAttrib)!=-1);

    FreeNameString(lpszName);

    return (fRet);
}


LPVOID
PUBLIC                                   // ret
OpenRecDBInternal(                                              //
    LPTSTR  lpszLocation,       // database directory
    LPTSTR  lpszUserName,       // name (not valid any more)
    DWORD   dwDefDataSizeHigh,  //high dword of max size of unpinned data
    DWORD   dwDefDataSizeLow,   //low dword of max size of pinned data
    DWORD   dwClusterSize,      // clustersize of the disk, used to calculate
                                // the actual amount of disk consumed
    BOOL    fReinit,            // reinitialize, even if it exists, create if it doesn't
    BOOL    fDoCheckCSC,        // whether to do CSC check
    BOOL    *lpfNew,            // returns whether the database was newly recreated
    ULONG   *pulGlobalStatus
    )
/*++

Routine Description:

    This routine initializes the database. On NT, if fReinit flag is set
    it also creates the directory strcuture that CSC expects and if the version number
    is not correct, it nukes the old database and creates the new one.



Parameters:

Return Value:

Notes:


--*/
{
    LPTSTR lpdbID = NULL;
    BOOL    fDirCreated = FALSE, fPQCreated = FALSE, fShareCreated = FALSE, fOK = FALSE;
    BOOL    fWasDirty = FALSE;

    RecordKdPrint(INIT,("OpenRecDB at %s for %s with size %d \r\n", lpszLocation, lpszUserName, dwDefDataSizeLow));

    if (fReinit)
    {
        RecordKdPrint(ALWAYS,("Reformat requested\r\n"));
    }

#ifdef CSC_RECORDMANAGER_WINNT
    if (!FindCreateDBDir(lpszLocation, fReinit, &fDirCreated))
    {
        RecordKdPrint(BADERRORS, ("CSC(OpenRecDB): couldn't create the CSC database directories \r\n"));
        return NULL;
    }

    if (!fDirCreated && !CheckCSCDatabaseVersion(lpszLocation, &fWasDirty))
    {
        if (!FindCreateDBDir(lpszLocation, TRUE, &fDirCreated))
        {
            return FALSE;
        }
        
    }
#endif

    vlpszShadowDir = AllocMem(strlen(lpszLocation)+1);

    if (!vlpszShadowDir)
    {
        return NULL;
    }

    strcpy(vlpszShadowDir, lpszLocation);
    vlenShadowDir = strlen(vlpszShadowDir);

    if (!vlpszShadowDir)
    {
#ifndef CSC_RECORDMANAGER_WINNT
        Assert(FALSE);
        return NULL;
#else
        vlpszShadowDir = vszShadowDir;
#endif
    }

    // lpdbID scheme had some genesis in multiple databases
    lpdbID = vlpszShadowDir;
    vlenShadowDir = strlen(vlpszShadowDir);

    if (InitPriQDatabase(vlpszShadowDir, fReinit, &fPQCreated) < 0)
    {
        RecordKdPrint(BADERRORS,("OpenRecDB  %s at %s for %s with size %d \r\n",
               "couldn't InitPriQDatabase",
               lpszLocation, lpszUserName, dwDefDataSizeLow));
        goto bailout;
    }

    if (fPQCreated)
    {
        fReinit = TRUE;
    }

    if (InitShareDatabase(vlpszShadowDir, lpszUserName, dwDefDataSizeHigh, dwDefDataSizeLow, fReinit, &fShareCreated, &fWasDirty, pulGlobalStatus) < 0)
    {
        RecordKdPrint(BADERRORS,("OpenRecDB  %s at %s for %s with size %d \r\n",
           "couldn't InitShareDatabase",
           lpszLocation, lpszUserName, dwDefDataSizeLow));
        return NULL;
    }


#ifdef CSC_RECORDMANAGER_WINNT
    if (!fReinit && fDoCheckCSC && fWasDirty)
    {
        RecordKdPrint(ALWAYS, ("CSC(OpenRecDB): CSC database wasn't cleanly shutdown, fixing...\r\n"));

        if (!TraverseHierarchy(lpszLocation, TRUE))
        {
            RecordKdPrint(BADERRORS, ("CSC(OpenRecDB): CSC database couldn't be fixed \r\n"));
            return NULL;
        }

        Assert(TraverseHierarchy(lpszLocation, FALSE));
    }
#endif

    if (!fPQCreated && fShareCreated)
    {
        if (InitPriQDatabase(vlpszShadowDir, TRUE, &fPQCreated) < 0)
        {
            RecordKdPrint(BADERRORS,("OpenRecDB  %s at %s for %s with size %d \r\n",
                   "couldn't recreate PriQDatabase",
                lpszLocation, lpszUserName, dwDefDataSizeLow));
            goto bailout;
        }

        Assert(fPQCreated);
    }

    Assert((fPQCreated && fShareCreated) || (!fPQCreated && !fShareCreated));

    Assert(lpReadBuff == rgchReadBuff);

    vdwClusterSizeMinusOne = dwClusterSize-1;
    vdwClusterSizeMask = ~vdwClusterSizeMinusOne;

    RecordKdPrint(INIT, ("OpenRecDB at %s for %s with size %d recreated=%d\r\n", lpszLocation, lpszUserName, dwDefDataSizeLow, fShareCreated));

    if (lpfNew)
    {
        *lpfNew = fShareCreated;
    }

    fOK = TRUE;

bailout:
    if (!fOK)
    {
        CloseRecDB(lpdbID);
    }

    return lpdbID;
}

LPVOID
PUBLIC                                   // ret
OpenRecDB(                                              //
    LPTSTR  lpszLocation,       // database directory
    LPTSTR  lpszUserName,       // name (not valid any more)
    DWORD   dwDefDataSizeHigh,  //high dword of max size of unpinned data
    DWORD   dwDefDataSizeLow,   //low dword of max size of pinned data
    DWORD   dwClusterSize,      // clustersize of the disk, used to calculate
                                // the actual amount of disk consumed
    BOOL    fReinit,            // reinitialize, even if it exists, create if it doesn't
    BOOL    *lpfNew,            // returns whether the database was newly recreated
    ULONG   *pulGlobalStatus
    )
/*++

Routine Description:

    This routine initializes the database. On NT, it also creates the directory strcuture
    that CSC expects. If the version number is not correct, it nukes the old database
    and creates the new one.

Parameters:

Return Value:

Notes:


--*/
{
    return OpenRecDBInternal(   lpszLocation,
                        lpszUserName,
                        dwDefDataSizeHigh,
                        dwDefDataSizeLow,
                        dwClusterSize,
                        fReinit,
                        TRUE,   // do csc check if necessary
                        lpfNew,
                        pulGlobalStatus
                        );
}

int
PUBLIC
CloseRecDB(
    LPTSTR  lpdbID
)
/*++

Routine Description:

    Closes the database

Parameters:

Return Value:

Notes:


--*/
{
    SHAREHEADER    sSH;

    if (vlpszShadowDir)
    {
        DEBUG_LOG(RECORD, ("CloseRecDB \r\n"));

        if (!strcmp(lpdbID, vlpszShadowDir))
        {
            DWORD Status;
#ifndef READONLY_OPS
            // if there have been no erros on the database, clear the
            // unclean shutdown bit. Otherwise, let it be set so that the next
            // time around when we enable CSC, we would run a database check 

            if (!ulErrorFlags)
            {
                if (ReadShareHeader(vlpszShadowDir, &sSH) >= 0)
                {
                    sSH.uFlags &= ~FLAG_SHAREHEADER_DATABASE_OPEN;
                
                    if(WriteShareHeader(vlpszShadowDir, &sSH) < 0)
                    {
                        RecordKdPrint(BADERRORS,("CloseRecDB  Failed to clear dirty bit"));
                    }
                }
            }
#endif // READONLY_OPS

            DeleteFromHandleCache(INVALID_SHADOW);
            TerminateShadowLog();

            FreeMem(vlpszShadowDir);
            Status = CscTearDownSecurity(vlpszShadowDir);
            vlpszShadowDir = NULL;

            if (Status == ERROR_SUCCESS) {
                return 1;
            } else {
                return -1;
            }
        }
    }
#ifdef DEBUG
#ifdef CSC_RECORDMANAGER_WINNT
    memset(rgllTimeArray, 0, sizeof(rgllTimeArray));
#endif
#endif
    SetLastErrorLocal(ERROR_INVALID_ACCESS);
    return (-1);
}

int
QueryRecDB(
    LPTSTR  lpszLocation,       // database directory, must be MAX_PATH
    LPTSTR  lpszUserName,       // name (not valid any more)
    DWORD   *lpdwDefDataSizeHigh,  //high dword of max size of unpinned data
    DWORD   *lpdwDefDataSizeLow,   //low dword of max size of pinned data
    DWORD   *lpdwClusterSize      // clustersize of the disk, used to calculate
    )
/*++

Routine Description:

    Returns the database information if it is open

Parameters:

Return Value:

    returns 1 if open else returns -1

Notes:


--*/
{
    if (!vlpszShadowDir)
    {
        SetLastErrorLocal(ERROR_INVALID_ACCESS);
        return -1;
    }

    Assert(vlenShadowDir < MAX_PATH);

    if (lpszLocation)
    {
#ifdef CSC_RECORDMANAGER_WINNT

        strcpy(lpszLocation, vlpszShadowDir+sizeof(NT_DB_PREFIX)-1);

        // check if this NT style location
        if (lpszLocation[1] != ':')
        {
            strcpy(lpszLocation, vlpszShadowDir);
        }
#else
        strcpy(lpszLocation, vlpszShadowDir);
#endif
    }

    return 1;
}

int PRIVATE InitShareDatabase(
    LPTSTR  lpdbID,
    LPTSTR  lpszUserName,
    DWORD   dwDefDataSizeHigh,
    DWORD   dwDefDataSizeLow,
    BOOL    fReinit,
    BOOL    *lpfReinited,
    BOOL    *lpfWasDirty,
    ULONG   *pulGlobalStatus
    )
/*++

Routine Description:

    Initialize the list of shares. This mostly means make sure nothing is wrong with
    the file and the header.

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=-1;
    CSCHFILE hf = CSCHFILE_NULL;
    SHAREHEADER sSH;
    ULONG uSize;
    LPSTR   lpszName;
    
    lpszUserName;   // we will se what to do about this later.

    lpszName = FormNameString(lpdbID, ULID_SHARE);

    if (!lpszName)
    {
        goto bailout;
    }

    *lpfReinited = FALSE;

    // if we are not supposed to reinitialize, only then we try to open the file

    if (!fReinit && (hf = OpenFileLocal(lpszName)))
    {
        
        if(ReadFileLocal(hf, 0, (LPVOID)&sSH, sizeof(SHAREHEADER))!=sizeof(SHAREHEADER))
        {
            Assert(FALSE);
            goto bailout;
        }

        if (!HasStreamSupport(hf, &fSupportsStreams))
        {
            goto bailout;
        }
        
        *lpfWasDirty = ((sSH.uFlags & FLAG_SHAREHEADER_DATABASE_OPEN) != 0);

        if (sSH.ulVersion == CSC_DATABASE_VERSION)
        {
#ifndef READONLY_OPS
            sSH.uFlags |= FLAG_SHAREHEADER_DATABASE_OPEN;

            if(WriteHeader(hf, (LPVOID)&sSH, sizeof(SHAREHEADER))
                    != sizeof(SHAREHEADER))
            {
                Assert(FALSE);
                goto bailout;
            }
#endif // READONLY_OPS

            iRet = 1;
            *pulGlobalStatus = sSH.uFlags;
            goto bailout;
        }
        else
        {
            RecordKdPrint(BADERRORS,("different version on the superroot, recreating\n"));
        }

        CloseFileLocal(hf);
        hf = CSCHFILE_NULL;  // general paranoia
    }

    // reinitialize the database

#ifndef READONLY_OPS
    hf = R0OpenFileEx(ACCESS_READWRITE, ACTION_CREATEALWAYS, FILE_ATTRIBUTE_SYSTEM, lpszName, FALSE);

    if (!hf)
    {
        RecordKdPrint(BADERRORS,("Can't create server list file\n"));
        goto bailout;
    }
    if (GetFileSizeLocal(hf, &uSize) || uSize)
    {
        iRet = 1;
        goto bailout;
    }

    // Init the server header
    memset((LPVOID)&sSH, 0, sizeof(SHAREHEADER));
    sSH.uRecSize = sizeof(SHAREREC);
    sSH.lFirstRec = (LONG) sizeof(SHAREHEADER);
    sSH.ulVersion = CSC_DATABASE_VERSION;
    // Max size of the cache
    sSH.sMax.ulSize    = dwDefDataSizeLow; // This size is good enough right now
    sSH.uFlags |= FLAG_SHAREHEADER_DATABASE_OPEN;

    if(WriteHeader(hf, (LPVOID)&sSH, sizeof(SHAREHEADER))
            != sizeof(SHAREHEADER))
    {
        Assert(FALSE);
        goto bailout;
    }

    RecordKdPrint(STOREDATA,("InitShareDatabase: Current space used %ld \r\n", sSH.sCur.ulSize));
    iRet = 1;

    *lpfReinited = TRUE;
    *pulGlobalStatus = sSH.uFlags;
    
#endif // READONLY_OPS

bailout:
    if (hf)
    {
        CloseFileLocal(hf);
    }

    FreeNameString(lpszName);

    return (iRet);
}


int PRIVATE InitPriQDatabase(
    LPTSTR  lpdbID,
    BOOL    fReinit,
    BOOL    *lpfReinited
    )
/*++

Routine Description:
    Initialize the PQ/MFT. This mostly means make sure nothing is wrong with
    the file and the header.


Parameters:

Return Value:

Notes:


--*/
{
    int iRet=-1;
    CSCHFILE hf= CSCHFILE_NULL;
    PRIQHEADER sQH;
    ULONG uSize;
    LPSTR   lpszName;

    lpszName = FormNameString(lpdbID, ULID_PQ);
    if (!lpszName)
    {
        goto bailout;
    }

    *lpfReinited = FALSE;

    if (!fReinit && (hf = OpenFileLocal(lpszName)))
    {
        if(ReadFileLocal(hf, 0, (LPVOID)&sQH, sizeof(PRIQHEADER))!=sizeof(PRIQHEADER))
        {
            Assert(FALSE);
            goto bailout;
        }

        if (sQH.ulVersion != CSC_DATABASE_VERSION)
        {
            RecordKdPrint(BADERRORS,("different version on the PQ, recreating \n"));
            CloseFileLocal(hf);
            hf = CSCHFILE_NULL;
        }
        else
        {
            iRet = 1;
            goto bailout;
        }
    }

#ifndef READONLY_OPS
    hf = R0OpenFileEx(ACCESS_READWRITE, ACTION_CREATEALWAYS, FILE_ATTRIBUTE_SYSTEM, lpszName, FALSE);

    if (!hf)
    {
        RecordKdPrint(BADERRORS,("Can't create Priority Q databse \r\n"));
        goto bailout;
    }

    if (GetFileSizeLocal(hf, &uSize) || uSize)
    {
        iRet = 1;
        goto bailout;
    }

    InitQHeader(&sQH);
    if(WriteHeader(hf, (LPVOID)&sQH, sizeof(PRIQHEADER))
            != sizeof(PRIQHEADER))
    {
        Assert(FALSE);
        goto bailout;
    }
    *lpfReinited = TRUE;
    iRet = 1;
#endif // READONLY_OPS

bailout:
    if (hf)
    {
        CloseFileLocal(hf);
    }

    FreeNameString(lpszName);
    return (iRet);
}

/******************* Local data size operations *****************************/

int ReadInodeHeader(
    LPTSTR    lpdbID,
    ULONG   ulidDir,
    LPGENERICHEADER lpGH,
    ULONG   ulSize
    )
/*++

Routine Description:

    Read the header of an inode file, which could be servers, PQ or any of the directories

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf;
    int iRet = -1;
    LPSTR   lpszName = NULL;

    lpszName =  FormNameString(lpdbID, ulidDir);

    if (!lpszName)
    {
        return -1;
    }

    hf = OpenFileLocal(lpszName);

    FreeNameString(lpszName);

    if (!hf)
    {
        // error gets set by openfilelocal
        return -1;
    }

    iRet = ReadHeader(hf, (LPVOID)lpGH, (USHORT)ulSize);

    CloseFileLocal(hf);

    return iRet;

}

int PUBLIC GetStoreData(
    LPTSTR    lpdbID,
    LPSTOREDATA lpSD
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf;
    SHAREHEADER sSH;
    int iRet = -1;
    BOOL    fCached;

    hf = OpenInodeFileAndCacheHandle(lpdbID, ULID_SHARE, ACCESS_READWRITE, &fCached);

    if (!hf)
    {
        return -1;
    }

    if ((iRet = ReadHeader(hf, (LPVOID)&sSH, sizeof(SHAREHEADER)))> 0)
    {
        *lpSD = sSH.sCur;
    }

    if (hf && !fCached)
    {
        Assert(vfStopHandleCaching);
        CloseFileLocal(hf);
    }
    else
    {
        Assert(!hf || !vfStopHandleCaching);
    }

    return iRet;
}

int PUBLIC GetInodeFileSize(
    LPTSTR    lpdbID,
    ULONG ulidShadow,
    ULONG far *lpuSize
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR   lpszName = NULL;
    CSCHFILE hf;
    int iRet = -1;

    *lpuSize = 0;
    lpszName = FormNameString(lpdbID, ulidShadow);

    if (!lpszName)
    {
        return -1;
    }


    if (hf = OpenFileLocal(lpszName))
    {
        if(GetFileSizeLocal(hf, lpuSize))
        {
            iRet = -1;
        }
        else
        {
            iRet = 0;
        }
        CloseFileLocal(hf);
    }
    else
    {
        iRet = 0;    // BUGBUG-win9xonly for now while IFS fixes the problem

    }

    FreeNameString(lpszName);

    return iRet;
}

int DeleteInodeFile(
    LPTSTR    lpdbID,
    ULONG ulidShadow
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR   lpszName = NULL;
    int iRet = -1;

    lpszName = FormNameString(lpdbID, ulidShadow);

    if (!lpszName)
    {
        return -1;
    }

    iRet = DeleteFileLocal(lpszName, ATTRIB_DEL_ANY);

    FreeNameString(lpszName);

    return iRet;
}

int TruncateInodeFile(
    LPTSTR    lpdbID,
    ULONG ulidShadow
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR   lpszName = NULL;
    CSCHFILE hf;
    int iRet = -1;

    lpszName = FormNameString(lpdbID, ulidShadow);

    if (!lpszName)
    {
        return -1;
    }

    hf = R0OpenFile(ACCESS_READWRITE, ACTION_CREATEALWAYS, lpszName);

    if (hf)
    {
        CloseFileLocal(hf);
        iRet = 0;
    }


    FreeNameString(lpszName);

    return iRet;
}

int SetInodeAttributes(
    LPTSTR    lpdbID,
    ULONG ulid,
    ULONG ulAttr
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR lpszName;
    int iRet=-1;

    lpszName = FormNameString(lpdbID, ulid);

    if (lpszName)
    {
        iRet = SetAttributesLocal(lpszName, ulAttr);
    }

    FreeNameString(lpszName);

    return (iRet);
}

int GetInodeAttributes(
    LPTSTR    lpdbID,
    ULONG ulid,
    ULONG *lpulAttr
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR lpszName;
    int iRet=-1;

    lpszName = FormNameString(lpdbID, ulid);

    if (lpszName)
    {
        iRet = GetAttributesLocal(lpszName, lpulAttr);
    }

    FreeNameString(lpszName);
    return (iRet);
}

int PUBLIC CreateDirInode(
    LPTSTR    lpdbID,
    ULONG     ulidShare,
    ULONG     ulidDir,
    ULONG     ulidNew
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR lpszName=NULL;
    FILEHEADER sFH;
    CSCHFILE hf= CSCHFILE_NULL;
    int iRet = -1;

    if (ulidDir)
    {
        lpszName = FormNameString(lpdbID, ulidDir);

        if (!lpszName)
        {
            goto bailout;
        }
        if (!(hf = OpenFileLocal(lpszName)))
        {
            RecordKdPrint(BADERRORS,("Couldn't access directory %s", lpszName));
            goto bailout;
        }

        if (ReadHeader(hf, (LPVOID)&sFH, sizeof(FILEHEADER)) != sizeof(FILEHEADER))
        {
            RecordKdPrint(BADERRORS,("Couldn't access directory %s", lpszName));
            goto bailout;
        }

        CloseFileLocal(hf);

        hf = CSCHFILE_NULL;

        ulidShare = sFH.ulidShare;
    }

    iRet = CreateRecordFile(lpdbID, ulidShare, ulidDir, ulidNew);

bailout:
    if (hf)
    {
        CloseFileLocal(hf);

    }

    FreeNameString(lpszName);

    return iRet;
}

/******************* Share database operations *****************************/


BOOL PUBLIC InitShareRec(
    LPSHAREREC lpSR,
    USHORT *lpName,
    ULONG ulidShare
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    unsigned i;

    memset((LPVOID)lpSR, 0, sizeof(SHAREREC));
    lpSR->uchType = REC_DATA;
    if (lpName)
    {
        i = wstrlen(lpName) * sizeof(USHORT);
        if(i >= sizeof(lpSR->rgPath))
        {
            SetLastErrorLocal(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        memcpy(lpSR->rgPath, lpName, i);
    }

    lpSR->ulShare = ulidShare;

    return TRUE;
}

int PUBLIC  ReadShareHeader(
    LPTSTR    lpdbID,
    LPSHAREHEADER lpSH
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf;
    int iRet = -1;
    LPSTR   lpszName = NULL;

    lpszName = FormNameString(lpdbID, ULID_SHARE);

    if (!lpszName)
    {
        return -1;
    }

    hf = OpenFileLocal(lpszName);

    FreeNameString(lpszName);

    if (hf)
    {
        iRet = ReadHeader(hf, (LPVOID)lpSH, sizeof(SHAREHEADER));
        CloseFileLocal(hf);
    }

    return iRet;
}

int PUBLIC  WriteShareHeader(
    LPTSTR    lpdbID,
    LPSHAREHEADER lpSH
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf;
    int iRet = -1;
    LPSTR   lpszName = NULL;

    lpszName = FormNameString(lpdbID, ULID_SHARE);


    if (!lpszName)
    {
        return -1;
    }

    hf = OpenFileLocal(lpszName);

    FreeNameString(lpszName);

    if (hf)
    {
        iRet = WriteHeader(hf, (LPVOID)lpSH, sizeof(SHAREHEADER));
        CloseFileLocal(hf);
    }

    return iRet;
}

ULONG PUBLIC FindShareRecord(
    LPTSTR    lpdbID,
    USHORT *lpName,
    LPSHAREREC lpSR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG ulShare;

    if (!InitShareRec(lpSR, lpName, 0))
    {
        return 0;
    }

    ulShare = EditRecordEx(ULID_SHARE, (LPGENERICREC)lpSR, ICompareShareRec, INVALID_REC, FIND_REC);


    return (ulShare);
}

ULONG PUBLIC FindSharerecFromInode(
    LPTSTR    lpdbID,
    ULONG ulidRoot,
    LPSHAREREC lpSR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG   ulShare;
    memset(lpSR, 0, sizeof(SHAREREC));

    lpSR->ulidShadow = ulidRoot;

    ulShare = EditRecordEx(ULID_SHARE, (LPGENERICREC)lpSR, ICompareShareRoot, INVALID_REC, FIND_REC);

    return (ulShare);
}

ULONG PUBLIC FindSharerecFromShare(
    LPTSTR    lpdbID,
    ULONG ulidShare,
    LPSHAREREC lpSR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG   ulShare;

    if (!InitShareRec(lpSR, NULL, ulidShare))
    {
        return 0;
    }

    ulShare = EditRecordEx(ULID_SHARE, (LPGENERICREC)lpSR, ICompareShareRoot, INVALID_REC, FIND_REC);

    return ulShare;

}

ULONG PUBLIC AddShareRecord(
    LPTSTR    lpdbID,
    LPSHAREREC lpSR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG   ulShare;

    ulShare = EditRecordEx(ULID_SHARE, (LPGENERICREC)lpSR, ICompareShareRec, INVALID_REC, CREATE_REC);


    return (ulShare);

}


int PUBLIC DeleteShareRecord(
    LPTSTR    lpdbID,
    ULONG ulidShare
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    SHAREREC sSR;
    int iRet = -1;


    if (!InitShareRec(&sSR, NULL, ulidShare))
    {
        return -1;
    }

    if(EditRecordEx(ULID_SHARE, (LPGENERICREC)&sSR, ICompareShareRecId, INVALID_REC, DELETE_REC))
    {
        iRet = 1;
    }

    return(iRet);
}

int PUBLIC GetShareRecord(
    LPTSTR    lpdbID,
    ULONG ulidShare,
    LPSHAREREC lpSR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf = CSCHFILE_NULL;
    SHAREHEADER sSH;
    int iRet = -1;
    LPSTR   lpszName = NULL;

    lpszName = FormNameString(lpdbID, ULID_SHARE);

    if (!lpszName)
    {
        return (-1);
    }

    hf = OpenFileLocal(lpszName);

    FreeNameString(lpszName);
    lpszName = NULL;

    if (!hf)
    goto bailout;

    if(ReadHeader(hf, (LPVOID)&sSH, sizeof(SHAREHEADER)) != sizeof(SHAREHEADER))
    goto bailout;
    if (ReadRecord(hf, (LPGENERICHEADER)&sSH, ulidShare, (LPGENERICREC)lpSR) < 0)
    goto bailout;
    iRet = 1;
bailout:
    if (hf)
    CloseFileLocal(hf);
    return (iRet);
}

int PUBLIC SetShareRecord(
    LPTSTR    lpdbID,
    ULONG ulidShare,
    LPSHAREREC lpSR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf = CSCHFILE_NULL;
    SHAREHEADER sSH;
    int iRet = -1;
    LPSTR lpszName;

    lpszName = FormNameString(lpdbID, ULID_SHARE);

    if (!lpszName)
    {
        goto bailout;
    }

    hf = OpenFileLocal(lpszName);

    FreeNameString(lpszName);

    if (!hf)
    goto bailout;

    if(ReadHeader(hf, (LPVOID)&sSH, sizeof(SHAREHEADER)) != sizeof(SHAREHEADER))
    goto bailout;
    if (WriteRecord(hf, (LPGENERICHEADER)&sSH, ulidShare, (LPGENERICREC)lpSR) < 0)
    goto bailout;
    iRet = 1;
bailout:
    if (hf)
    CloseFileLocal(hf);
    return (iRet);
}

int PUBLIC ICompareShareRec(
    LPSHAREREC lpDst,
    LPSHAREREC lpSrc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return ( wstrnicmp(lpDst->rgPath, lpSrc->rgPath, sizeof(lpDst->rgPath)));
}

int PUBLIC ICompareShareRoot(
    LPSHAREREC lpDst,
    LPSHAREREC lpSrc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (!(lpDst->ulidShadow==lpSrc->ulidShadow));
}

int PUBLIC ICompareShareRecId(
    LPSHAREREC lpDst,
    LPSHAREREC lpSrc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (!(lpDst->ulShare==lpSrc->ulShare));
}
/********************** File database operations ****************************/

void PRIVATE InitFileHeader(
    ULONG ulidShare,
    ULONG ulidDir,
    LPFILEHEADER lpFH
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    memset((LPVOID)lpFH, 0, sizeof(FILEHEADER));
    lpFH->uRecSize = sizeof(FILEREC);
    lpFH->lFirstRec = (LONG)sizeof(FILEHEADER);
    lpFH->ulidShare = ulidShare;
    lpFH->ulidDir = ulidDir;
    lpFH->ulidNextShadow = 1L;    // Leaf Inode at this level
    lpFH->ulVersion = CSC_DATABASE_VERSION;
}

void PRIVATE InitFileRec(
    LPFILERECEXT lpFR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int cCount;
    memset((LPVOID)lpFR, 0, sizeof(FILERECEXT));
    lpFR->sFR.uchType = REC_DATA;
    // Note!! we are initializing the count of overflow records to 0
    // the routine that actually fills the structure
    // will init it to approrpiate sizes
    for (cCount = sizeof(lpFR->rgsSR)/sizeof(FILEREC) - 1; cCount >= 0; --cCount)
    lpFR->rgsSR[cCount].uchType = REC_OVERFLOW;
}

int PRIVATE CreateRecordFile(
    LPTSTR    lpdbID,
    ULONG     ulidShare,
    ULONG ulidDir,
    ULONG ulidNew
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR lpszName;
    CSCHFILE hfDst=CSCHFILE_NULL;
    int iRet = -1;
    FILEHEADER sFH;
    ULONG uSize;

    lpszName = FormNameString(lpdbID, ulidNew);

    if (!lpszName)
    {
        return -1;

    }

    hfDst = R0OpenFileEx(ACCESS_READWRITE, ACTION_CREATEALWAYS, FILE_ATTRIBUTE_SYSTEM, lpszName, FALSE);


    if (!hfDst)
    {
        RecordKdPrint(BADERRORS,("Couldn't Create %s\n", lpszName));
        goto bailout;
    }


    if (GetFileSizeLocal(hfDst, &uSize))
        goto bailout;
    // If it is already filled up do nothing
    // BUGBUG-win9xonly this a kludge to get around Ring0 API bug in IFS
    if (uSize)
    {
        iRet = 1;
        goto bailout;
    }

    InitFileHeader(ulidShare, ulidDir, &sFH);

    if (WriteHeader(hfDst, (LPVOID)&sFH, sizeof(FILEHEADER))!=sizeof(FILEHEADER))
    {
        RecordKdPrint(BADERRORS,("Header write error in %s", lpszName));
        goto bailout;
    }
    iRet = 1;

bailout:
    if (hfDst)
        CloseFileLocal(hfDst);
    FreeNameString(lpszName);
    return iRet;
}


ULONG PUBLIC AddFileRecordFR(
    LPTSTR          lpdbID,
    ULONG           ulidDir,
    LPFILERECEXT    lpFR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG       ulrec=INVALID_REC;


    BEGIN_TIMING(AddFileRecordFR);


    ulrec = EditRecordEx(ulidDir, (LPGENERICREC)lpFR, ICompareFileRec, INVALID_REC, CREATE_REC);

    DEBUG_LOG(RECORD,("AddFileRecordFR:Error=%d ulidDir=%xh hShadow=%xh FileName=%w\r\n",
                        (ulrec==0), ulidDir, lpFR->sFR.ulidShadow, lpFR->sFR.rgw83Name));

    END_TIMING(AddFileRecordFR);

    return (ulrec);
}


int PUBLIC DeleteFileRecord(
    LPTSTR    lpdbID,
    ULONG ulidDir,
    USHORT *lpName,
    LPFILERECEXT lpFR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{

    ULONG       ulrec=INVALID_REC;
    BOOL        fFound = FALSE;

    InitFileRec(lpFR);

    LFNToFilerec(lpName, lpFR);

    ulrec = EditRecordEx(ulidDir, (LPGENERICREC)lpFR, ICompareFileRec, INVALID_REC, DELETE_REC);

    DEBUG_LOG(RECORD,("DeleteFileRecordFR:Error=%d ulidDir=%xh hShadow=%xh FileName=%w\r\n",
                        (ulrec==0), ulidDir, lpFR->sFR.ulidShadow, lpFR->sFR.rgw83Name));
    return (ulrec);
}

ULONG PUBLIC FindFileRecord(
    LPTSTR    lpdbID,
    ULONG ulidDir,      // which directory to look up
    USHORT *lpName,                  // string to lookup
    LPFILERECEXT lpFR                 // return the record
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG       ulrec=INVALID_REC;
    BOOL        fFound = FALSE;

    BEGIN_TIMING(FindFileRecord);

    InitFileRec(lpFR);

    LFNToFilerec(lpName, lpFR);

    ulrec = EditRecordEx(ulidDir, (LPGENERICREC)lpFR, ICompareFileRec, INVALID_REC, FIND_REC);

    RecordKdPrint(FINDFILERECORD,("FindFileRecord returns %08lx for %ws\n",ulrec,lpName));


    END_TIMING(FindFileRecord);

    return(ulrec);
}


int FindAncestorsFromInode(
    LPTSTR    lpdbID,
    ULONG ulidShadow,
    ULONG *lpulidDir,
    ULONG *lpulidShare
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    PRIQREC sPQ;
    int iRet;

    if ((iRet = FindPriQRecordInternal(lpdbID, ulidShadow, &sPQ)) >=0)
    {
        if (lpulidDir)
        {
            *lpulidDir = sPQ.ulidDir;
        }
        if (lpulidShare)
        {
            *lpulidShare = sPQ.ulidShare;
        }
    }
    return (iRet);
}

BOOL PUBLIC FInodeIsFile(
    LPTSTR    lpdbID,
    ULONG ulidDir,
    ULONG ulidShadow
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ulidDir;
    return IsLeaf(ulidShadow);
}

int PUBLIC ICompareFileRec(
    LPFILERECEXT lpDst,
    LPFILERECEXT lpSrc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=1, i, cntOvf;

    // Compare the 8.3 name
    if (lpSrc->sFR.rgw83Name[0])
    {
        if (!(iRet = wstrnicmp( (CONST USHORT *)(lpDst->sFR.rgw83Name),
                                (CONST USHORT *)(lpSrc->sFR.rgw83Name),
                                sizeof(lpDst->sFR.rgw83Name)))){
            return iRet;
        }
    }

    if (lpSrc->sFR.rgwName[0] && ((cntOvf = OvfCount(lpSrc))==OvfCount(lpDst)))
    {
        // or compare the LFN name
        iRet = wstrnicmp(   (CONST USHORT *)(lpDst->sFR.rgwName),
                            (CONST USHORT *)(lpSrc->sFR.rgwName),
                            sizeof(lpDst->sFR.rgwName));

        for (i=0; (i<cntOvf) && !iRet; ++i)
        {
            iRet = wstrnicmp(   (CONST USHORT *)(lpDst->rgsSR[i].rgwOvf),
                                (CONST USHORT *)(lpSrc->rgsSR[i].rgwOvf),
                                (SIZEOF_OVERFLOW_FILEREC));
        }
    }
    return (iRet);
}

void PUBLIC CopyFindInfoToFilerec(
    LPFIND32         lpFind,
    LPFILERECEXT    lpFR,
    ULONG         uFlags
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{

    if (mCheckBit(uFlags, CPFR_INITREC))
    {
        InitFileRec(lpFR);
    }

    lpFR->sFR.dwFileAttrib = (DWORD)lpFind->dwFileAttributes;
    lpFR->sFR.ftLastWriteTime = lpFind->ftLastWriteTime;

    Win32ToDosFileSize(lpFind->nFileSizeHigh, lpFind->nFileSizeLow, &(lpFR->sFR.ulFileSize));

    if (mCheckBit(uFlags, CPFR_COPYNAME))
    {
        CopyNamesToFilerec(lpFind, lpFR);
    }
}

void PUBLIC CopyNamesToFilerec(
    LPFIND32      lpFind,
    LPFILERECEXT lpFR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    unsigned i;

    LFNToFilerec(lpFind->cFileName, lpFR);

    // if there is an altername name, convert that too
    if (lpFind->cAlternateFileName[0])
    {
        memset(lpFR->sFR.rgw83Name, 0, sizeof(lpFR->sFR.rgw83Name));
        memcpy(lpFR->sFR.rgw83Name, lpFind->cAlternateFileName, sizeof(lpFR->sFR.rgw83Name)-sizeof(USHORT));
    }
    else
    {
        // If filename is smaller than 8.3 name stuff it in too.
        //if ((i = wstrlen(lpFind->cFileName))<
        //    (sizeof(lpFind->cAlternateFileName)/sizeof(lpFind->cAlternateFileName[0])))
		i = wstrlen(lpFind->cFileName);
		if (!IsLongFileName(lpFind->cFileName)) 
		
        {
            memset(lpFR->sFR.rgw83Name, 0, sizeof(lpFR->sFR.rgw83Name));
            memcpy(lpFR->sFR.rgw83Name, lpFind->cFileName, i*sizeof(USHORT));
        }

    }

}

void PUBLIC CopyFilerecToFindInfo(
    LPFILERECEXT    lpFR,
    LPFIND32     lpFind
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    memset(lpFind, 0, sizeof(_WIN32_FIND_DATA));
    // copy the attributes and the last write time
    lpFind->dwFileAttributes = lpFR->sFR.dwFileAttrib & ~FILE_ATTRIBUTE_ENCRYPTED;
    lpFind->ftLastWriteTime = lpFR->sFR.ftLastWriteTime;

    // Use the LastAccessTime field for ORG time
    lpFind->ftLastAccessTime = lpFR->sFR.ftOrgTime;

    DosToWin32FileSize(lpFR->sFR.ulFileSize, &(lpFind->nFileSizeHigh), &(lpFind->nFileSizeLow));

    // Convert the main name
    FilerecToLFN(lpFR, lpFind->cFileName);

    // if there is an altername name, convert that too
    if (lpFR->sFR.rgw83Name[0])
    {
        memcpy(lpFind->cAlternateFileName, lpFR->sFR.rgw83Name, sizeof(lpFR->sFR.rgw83Name)-sizeof(USHORT));
    }
}

int PRIVATE    LFNToFilerec(
    USHORT          *lpLFN,
    LPFILERECEXT    lpFR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    size_t csCount, csSize, i=0, j, k;

    // make sure we didn't goof in structure definition
    Assert((sizeof(lpFR->sFR.rgwName)+SIZEOF_OVERFLOW_FILEREC*MAX_OVERFLOW_FILEREC_RECORDS)>=(MAX_PATH*sizeof(USHORT)));

    memset(lpFR->sFR.rgwName, 0, sizeof(lpFR->sFR.rgwName));

    for (j=0; j<MAX_OVERFLOW_FILEREC_RECORDS; ++j)
    {
        memset((lpFR->rgsSR[j].rgwOvf), 0, SIZEOF_OVERFLOW_FILEREC);
    }

    {
        // count of elements in the Unicode LFN string (without NULL)
        csCount = wstrlen(lpLFN);
        csSize = csCount*sizeof(USHORT);

        memcpy(lpFR->sFR.rgwName, lpLFN, (i = min(sizeof(lpFR->sFR.rgwName), csSize)));

        RecordKdPrint(LFN2FILEREC,("LFNToFilerec1 %ws,%x/%x>\n", lpFR->sFR.rgwName,i,csCount));

        // Keep converting till the total count of bytes exceeds the
        // # of Unicode elements
        for (j=0;(j<MAX_OVERFLOW_FILEREC_RECORDS) && (csSize > i);++j)
        {
            k = min(csSize-i, SIZEOF_OVERFLOW_FILEREC);

            memcpy(lpFR->rgsSR[j].rgwOvf, ((LPBYTE)lpLFN+i),  k);

            i += k;

            RecordKdPrint(LFN2FILEREC,("LFNToFilerec1 %ws,%x/%x>\n", lpFR->sFR.rgwName,i,csCount));
        }

        // Store the overfow record info. in the proper place
        SetOvfCount(lpFR, j);

        RecordKdPrint(LFN2FILEREC,("LFNToFilerec: %d overflow records \r\n", j));
    }
    // If it is small enough to fit as 8.3 name, copy it too
    if (i < sizeof(lpFR->sFR.rgw83Name))
    {
        memset(lpFR->sFR.rgw83Name, 0, sizeof(lpFR->sFR.rgw83Name));
        memcpy(lpFR->sFR.rgw83Name, lpFR->sFR.rgwName, i);
    }

    // return the total count of bytes in lpFR (without the NULLS)
    RecordKdPrint(LFN2FILEREC,("LFNToFilerec2 %ws %ws\n", lpFR->sFR.rgwName, lpFR->sFR.rgw83Name));
    return (i);
}

int PRIVATE    FilerecToLFN(
    LPFILERECEXT    lpFR,
    USHORT          *lpLFN
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    size_t csInSize, i=0, j;
    int count = OvfCount(lpFR);


    Assert(count <= MAX_OVERFLOW_FILEREC_RECORDS);

    {


        // Get the count of elements in the main record

        // check if the last element is NULL
        if (!lpFR->sFR.rgwName[(sizeof(lpFR->sFR.rgwName)/sizeof(USHORT))-1])
        {
            // it is NULL, so we need to find the real size
            csInSize = wstrlen(lpFR->sFR.rgwName) * sizeof(USHORT);
        }
        else
        {
            // it is not NULL, so this section is completely filled
            csInSize = sizeof(lpFR->sFR.rgwName);
        }


        // copy the bytes from filerec to LFN
        memcpy((LPBYTE)lpLFN, lpFR->sFR.rgwName, csInSize);

        i = csInSize;

        for (j=0; j<(ULONG)count;++j)
        {

            // Check if the Overflow records last wide character is NULL
            if (!lpFR->rgsSR[j].rgwOvf[(sizeof(lpFR->rgsSR[j])- sizeof(RECORDMANAGER_COMMON_RECORD))/sizeof(USHORT)-1])
            {
                // it is
                // Get the size in bytes of elements in the overflow record
                csInSize = wstrlen(lpFR->rgsSR[j].rgwOvf) * sizeof(USHORT);
            }
            else
            {
                // the record is completely full
                csInSize = sizeof(lpFR->rgsSR[0]) - sizeof(RECORDMANAGER_COMMON_RECORD);
            }

            if (!csInSize)
            {
                break;
            }

            memcpy(((LPBYTE)lpLFN+i), lpFR->rgsSR[j].rgwOvf, csInSize);

            i += csInSize;

        }

        // NULL terminate the unicode string
        *(USHORT *)((LPBYTE)lpLFN+i) = 0;
    }

    // The total count of bytes in the unicode string
    return (i);
}


int PUBLIC UpdateFileRecFromInode(
    LPTSTR    lpdbID,
    ULONG ulidDir,
    ULONG hShadow,
    ULONG ulrecDirEntry,
    LPFILERECEXT    lpFR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (UpdateFileRecFromInodeEx(lpdbID, ulidDir, hShadow, ulrecDirEntry, lpFR, TRUE));
}

int PUBLIC UpdateFileRecFromInodeEx(
    LPTSTR    lpdbID,
    ULONG ulidDir,
    ULONG hShadow,
    ULONG ulrecDirEntry,
    LPFILERECEXT    lpFR,
    BOOL    fCompareInodes
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;

    Assert(ulrecDirEntry > INVALID_REC);

    iRet = EditRecordEx(ulidDir, (LPGENERICREC)lpFR, (fCompareInodes)?ICompareFileRecInode:NULL, ulrecDirEntry, UPDATE_REC);

    return (iRet);
}

int PUBLIC FindFileRecFromInode(
    LPTSTR    lpdbID,
    ULONG ulidDir,
    ULONG ulidInode,
    ULONG ulrecDirEntry,
    LPFILERECEXT    lpFR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;

    InitFileRec(lpFR);
    lpFR->sFR.ulidShadow = ulidInode;

    iRet = (int)EditRecordEx(ulidDir, (LPGENERICREC)lpFR, ICompareFileRecInode, ulrecDirEntry, FIND_REC);

    return (iRet);
}

int PUBLIC DeleteFileRecFromInode(
    LPTSTR  lpdbID,
    ULONG   ulidDir,
    ULONG   ulidInode,
    ULONG   ulrecDirEntry,
    LPFILERECEXT lpFR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;

    InitFileRec(lpFR);
    lpFR->sFR.ulidShadow = ulidInode;

    iRet = (int)EditRecordEx(ulidDir, (LPGENERICREC)lpFR, ICompareFileRecInode, ulrecDirEntry, DELETE_REC);

    DEBUG_LOG(RECORD,("DeleteFileRecord:iRet=%d ulidDir=%xh hShadow=%xh FileName=%w\r\n",
                        (iRet), ulidDir, lpFR->sFR.ulidShadow, lpFR->sFR.rgw83Name));

    return (iRet);
}



int PUBLIC ICompareFileRecInode(
    LPFILERECEXT lpDst,
    LPFILERECEXT lpSrc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return ((lpDst->sFR.ulidShadow == lpSrc->sFR.ulidShadow)?0:-1);
}


int ReadDirHeader( LPTSTR    lpdbID,
    ULONG ulidDir,
    LPFILEHEADER lpFH
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = -1;
    CSCHFILE hf;
    LPSTR   lpszName = NULL;

    lpszName = FormNameString(lpdbID, ulidDir);

    if (lpszName)
    {
        if (hf = OpenFileLocal(lpszName))
        {
            if (ReadHeader(hf, (LPGENERICHEADER)lpFH, sizeof(GENERICHEADER)) > 0)
            {
                iRet = 1;
            }
            CloseFileLocal(hf);
        }
    }

    FreeNameString(lpszName);

    return (iRet);
}

int WriteDirHeader( LPTSTR    lpdbID,
    ULONG ulidDir,
    LPFILEHEADER lpFH
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = -1;
    CSCHFILE hf;
    LPSTR lpszName;

    lpszName = FormNameString(lpdbID, ulidDir);

    if (!lpszName)
    {
        return -1;
    }

    if (hf = OpenFileLocal(lpszName))
    {
    if (WriteHeader(hf, (LPGENERICHEADER)lpFH, sizeof(GENERICHEADER)) > 0)
        {
            iRet = 1;
        }

    CloseFileLocal(hf);
    }

    FreeNameString(lpszName);

    return (iRet);
}


#define JOE_DECL_CURRENT_PROGRESS CscProgressHasDesc
JOE_DECL_PROGRESS();

int
HasDescendents( LPTSTR    lpdbShadow,
    ULONG   ulidDir,
    ULONG   ulidShadow
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = -1;
    ULONG count = 1;
    GENERICHEADER  sGH;
    FILERECEXT *lpFRExt;
    CSCHFILE hf = CSCHFILE_NULL;
    LPSTR   lpszName=NULL;

    JOE_INIT_PROGRESS(DelShadowInternalEntries,&lpdbShadow);

    if (FInodeIsFile(lpdbShadow, ulidDir, ulidShadow))
    {
        return 0;
    }
    else
    {
        JOE_PROGRESS(2);
        UseCommonBuff();

        lpFRExt = (FILERECEXT *)lpReadBuff;

        lpszName = FormNameString(lpdbShadow, ulidShadow);

        JOE_PROGRESS(3);
        if (!lpszName)
        {
            JOE_PROGRESS(4);
            goto bailout;
        }

        JOE_PROGRESS(5);
        if (!(hf = OpenFileLocal(lpszName)))
        {
            JOE_PROGRESS(6);
            goto bailout;
        }

        JOE_PROGRESS(7);
        if(ReadHeader(hf, &sGH, sizeof(GENERICHEADER)) < 0)
        {
            JOE_PROGRESS(8);
            goto bailout;
        }

        for (;count <=sGH.ulRecords;)
        {
            JOE_PROGRESS(9);
            iRet = ReadRecord(hf, &sGH, count, (LPGENERICREC)lpFRExt);

            JOE_PROGRESS(10);
            if (iRet < 0)
            {
                JOE_PROGRESS(11);
                goto bailout;
            }

            JOE_PROGRESS(12);
            // bump the record pointer
            count += iRet;

            if (lpFRExt->sFR.uchType == REC_DATA)
            {
                iRet = 1;
                JOE_PROGRESS(13);
                goto bailout;
            }
        }

        iRet = 0;
        JOE_PROGRESS(14);

    }
bailout:

    JOE_PROGRESS(20);

    FreeNameString(lpszName);
    JOE_PROGRESS(21);

    if (hf)
    {
        JOE_PROGRESS(22);
        CloseFileLocal(hf);
    }

    JOE_PROGRESS(23);

    UnUseCommonBuff();

    return (iRet);

}

/************************ Low level Header/Record Operations ****************/

int PUBLIC ReadHeader(
    CSCHFILE hf,
    LPGENERICHEADER lpGH,
    USHORT sizeBuff
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (ReadHeaderEx(hf, lpGH, sizeBuff, FALSE));

}
int PUBLIC ReadHeaderEx(
    CSCHFILE hf,
    LPGENERICHEADER lpGH,
    USHORT sizeBuff,
    BOOL    fInstrument
    )
{
    long cLength = sizeBuff;

    Assert(cLength >= sizeof(GENERICHEADER));

    if(ReadFileLocalEx(hf, 0, lpGH, cLength, fInstrument)==cLength)
    {
        if (ValidateGenericHeader(lpGH))
        {
            return cLength;
        }
        else
        {
            SetCSCDatabaseErrorFlags(CSC_DATABASE_ERROR_INVALID_HEADER);
            SetLastErrorLocal(ERROR_BAD_FORMAT);
            return -1;
        }
    }
    else
    {
        SetCSCDatabaseErrorFlags(CSC_DATABASE_ERROR_INVALID_HEADER);
        SetLastErrorLocal(ERROR_BAD_FORMAT);
        return -1;
    }
}

int PUBLIC WriteHeader(
    CSCHFILE hf,
    LPGENERICHEADER    lpGH,
    USHORT sizeBuff
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (WriteHeaderEx(hf, lpGH, sizeBuff, FALSE));
}

int PUBLIC WriteHeaderEx(
    CSCHFILE hf,
    LPGENERICHEADER    lpGH,
    USHORT sizeBuff,
    BOOL    fInstrument
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    long cLength = sizeBuff;

#ifdef WRITE_ERROR
    SetHeaderModFlag(lpGH, STATUS_WRITING);

    if (WriteFileLocalEx(hf, STRUCT_OFFSET(LPGENERICHEADER, uchFlags), &(lpGH->uchFlags, fInstrument),
        sizeof(lpGH->uchFlags))!=sizeof(lpGH->uchFlags))
        return -1;

#endif //WRITE_ERROR


    if(WriteFileLocalEx(hf, 0, lpGH, cLength, fInstrument)==cLength)
    {


#ifdef WRITE_ERROR
        ClearHeaderModFlag(lpGH);
        if (WriteFileLocal(hf, STRUCT_OFFSET(LPGENERICHEADER, uchFlags)
            , &(lpGH->uchFlags), sizeof(lpGH->uchFlags))!=sizeof(lpGH->uchFlags))
            return -1;
#endif //WRITE_ERROR


        return cLength;
    }
    else
        return -1;
}

int PUBLIC CopyRecord(
    LPGENERICREC    lpgrDst,
    LPGENERICREC    lpgrSrc,
    USHORT size,
    BOOL  fMarkEmpty
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int cCount, iTmp;

    cCount = OvfCount(lpgrSrc);

    for (iTmp=0;cCount>=0; --cCount)
    {
    memcpy(((LPBYTE)lpgrDst)+iTmp, ((LPBYTE)lpgrSrc)+iTmp, size);
    if (fMarkEmpty)
    {
        ((LPGENERICREC)((LPBYTE)lpgrDst+iTmp))->uchType = REC_EMPTY;
    }
    iTmp += size;
    }
    return(0);
}


int PUBLIC ReadRecord(
    CSCHFILE hf,
    LPGENERICHEADER lpGH,
    ULONG  ulRec,
    LPGENERICREC    lpSrc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (ReadRecordEx(hf, lpGH, ulRec, lpSrc, FALSE));
}

int PUBLIC ReadRecordEx(
    CSCHFILE hf,
    LPGENERICHEADER lpGH,
    ULONG  ulRec,
    LPGENERICREC    lpSrc,
    BOOL    fInstrument
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    long lSeek, cRead;
    int iRet=0, cCount;

    if (ulRec > lpGH->ulRecords)
    return -1;

    lSeek = lpGH->lFirstRec + (long)(ulRec-1) * lpGH->uRecSize;

    cRead = lpGH->uRecSize;

    if ((cRead = ReadFileLocalEx(hf, lSeek, lpSrc, cRead, fInstrument)) < 0)
    return -1;

    // If some error happened in an earlier write, return
    if (ModFlag(lpSrc))
    return -1;

    lSeek += cRead;
    cCount = 1;

    if (OvfCount(lpSrc) > MAX_OVERFLOW_RECORDS)
    {
        RecordKdPrint(BADERRORS,("ReadRecordEx: Bad record; Overflow count is %d, max allowed is %d\r\n",OvfCount(lpSrc),MAX_OVERFLOW_RECORDS));
        SetCSCDatabaseErrorFlags(CSC_DATABASE_ERROR_INVALID_OVF_COUNT);
        SetLastErrorLocal(ERROR_BAD_FORMAT);
        return -1;
    }

    // Read overflow records if any
    if(OvfCount(lpSrc))
    {
        cCount += OvfCount(lpSrc);
        cRead = lpGH->uRecSize * (cCount-1);
        Assert(cRead);
        cRead = ReadFileLocalEx(hf, lSeek, (LPTSTR)lpSrc+lpGH->uRecSize, cRead, fInstrument);
        iRet = (cRead < 0);
    }
    return ((!iRet)?cCount:-1);
}


int PUBLIC WriteRecord(
    CSCHFILE hf,
    LPGENERICHEADER lpGH,
    ULONG  ulRec,
    LPGENERICREC    lpSrc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (WriteRecordEx(hf, lpGH, ulRec, lpSrc, FALSE));

}
int PUBLIC WriteRecordEx(
    CSCHFILE hf,
    LPGENERICHEADER lpGH,
    ULONG  ulRec,
    LPGENERICREC    lpSrc,
    BOOL    fInstrument
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    long lSeek, cWrite;
    int cCount;

    if (ulRec > lpGH->ulRecords)
    {
        ulRec = lpGH->ulRecords+1;
    }
    lSeek = lpGH->lFirstRec + (long)(ulRec-1) * lpGH->uRecSize;
    cCount = 1 + OvfCount(lpSrc);
    cWrite = lpGH->uRecSize*cCount;


#ifdef WRITE_ERROR
    SetModFlag(lpSrc, STATUS_WRITING);
    if (WriteFileLocal(hf, lSeek+STRUCT_OFFSET(LPGENERICREC, uchFlags)
                , &(lpSrc->uchFlags)
                , sizeof(lpSrc->uchFlags))!=sizeof(lpSrc->uchFlags))
        return -1;

#endif //WRITE_ERROR

    // make sure that we are writing no-zero records
    Assert((lpSrc->uchType == REC_EMPTY)||(lpSrc->uchType == REC_DATA)||(lpSrc->uchType == REC_OVERFLOW));

    if(WriteFileLocalEx(hf, lSeek, lpSrc, cWrite, fInstrument)==cWrite)
    {


#ifdef WRITE_ERROR
    ClearModFlag(lpSrc);
    if (WriteFileLocal(hf, lSeek+STRUCT_OFFSET(LPGENERICREC, uchFlags)
                , &(lpSrc->uchFlags)
                , sizeof(lpSrc->uchFlags))!=sizeof(lpSrc->uchFlags))
        return -1;
#endif //WRITE_ERROR


        return cCount;
    }
    else
    return -1;
}

#if 0
ULONG PUBLIC EditRecord(
    ULONG   ulidInode,
    LPGENERICREC lpSrc,
    EDITCMPPROC lpCompareFunc,
    ULONG uOp
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return(EditRecordEx(ulidInode, lpSrc, lpCompareFunc, INVALID_REC, uOp));
}
#endif

/*************************** Utility Functions ******************************/

LPVOID
PUBLIC
FormNameString(
    LPTSTR      lpdbID,
    ULONG       ulidFile
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPTSTR lp, lpT;
    int lendbID;
    char chSubdir;

    if (!lpdbID)
    {
        SetLastErrorLocal(ERROR_INVALID_PARAMETER);
        return (NULL);
    }

    if (lpdbID == vlpszShadowDir)
    {
        lendbID = vlenShadowDir;
    }
    else
    {
        lendbID = strlen(lpdbID);
    }

    lp = AllocMem(lendbID+1+INODE_STRING_LENGTH+1+SUBDIR_STRING_LENGTH+1);

    if (!lp)
    {
        return NULL;
    }

//      RecordKdPrint(ALWAYS,("FormNameString: Checking before memcpy\r\n"));
//      CheckHeap(lp);

    memcpy(lp, lpdbID, lendbID);


    // Bump the pointer appropriately
    lpT = lp+lendbID;

    if (*(lpT-1)!= '\\')
    {
        *lpT++ = '\\';
    }

    chSubdir = CSCDbSubdirSecondChar(ulidFile);

    // sprinkle the user files in one of the subdirectories
    if (chSubdir)
    {
        // now append the subdirectory

        *lpT++ = CSCDbSubdirFirstChar();
        *lpT++ = chSubdir;
        *lpT++ = '\\';
    }

    HexToA(ulidFile, lpT, 8);

    lpT += 8;

    *lpT = 0;

//      RecordKdPrint(ALWAYS,("FormNameString:Checking at the end\r\n"));
//      CheckHeap(lp);

    return(lp);
}


VOID
PUBLIC
FreeNameString(
    LPTSTR  lpszName
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    if (lpszName)
    {
#ifdef DEBUG
                CheckHeap(lpszName);
#endif
        FreeMem(lpszName);
    }
}

void PRIVATE DecomposeNameString(
    LPTSTR lpName,
    ULONG far *lpulidDir,
    ULONG far *lpulidFile
    )
{
    LPTSTR lp = lpName;
    *lpulidFile = AtoHex(lp, 4);
    *lpulidDir = AtoHex(lp+4, 4);
}

/******************************* Higher level queue operations **************/

BOOL
ResetInodeTransactionIfNeeded(
    void
    )
{
    BOOL    fDoneReset = FALSE;
    // if an inode transaction has gone on for too long let us nuke it
    if (cntInodeTransactions)
    {
        if ((GetTimeInSecondsSince1970() - ulLastInodeTransaction) >= MAX_INODE_TRANSACTION_DURATION_IN_SECS)
        {
            cntInodeTransactions = 0;
            RecordKdPrint(ALWAYS, ("UlAllocInode: resetting Inode transaction \r\n"));
            fDoneReset = TRUE;
        }

    }
    return fDoneReset;
}

void
BeginInodeTransaction(
    VOID
    )
{

    ResetInodeTransactionIfNeeded();

    ++cntInodeTransactions;
    ulLastInodeTransaction = GetTimeInSecondsSince1970();

    RecordKdPrint(PQ, ("BeginInodetransaction \r\n"));

}

void
EndInodeTransaction(
    VOID
    )
{
    if (cntInodeTransactions)
    {
        --cntInodeTransactions;
    }

    RecordKdPrint(PQ, ("EndInodetransaction \r\n"));
}

int PUBLIC AddPriQRecord(
    LPTSTR    lpdbID,
    ULONG     ulidShare,
    ULONG     ulidDir,
    ULONG     ulidShadow,
    ULONG     uStatus,
    ULONG     ulRefPri,
    ULONG     ulIHPri,
    ULONG     ulHintPri,
    ULONG     ulHintFlags,
    ULONG     ulrecDirEntry
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    PRIQREC sPQ;
    LPSTR   lpszName;
    int iRet=-1;
    ULONG ulRec;

    BEGIN_TIMING(AddPriQRecord);

    lpszName = FormNameString(lpdbID, ULID_PQ);

    if (!lpszName)
    {
        return -1;
    }

    InitPriQRec(ulidShare, ulidDir, ulidShadow, uStatus, ulRefPri, ulIHPri, ulHintPri, ulHintFlags, ulrecDirEntry, &sPQ);

    ulRec = RecFromInode(ulidShadow);

    ulRec = EditRecordEx(ULID_PQ, (LPGENERICREC)&sPQ, NULL, ulRec, CREATE_REC);

    if (ulRec)
    {
        Assert(ulRec == RecFromInode(ulidShadow));

        // don't worry too much about the error on PQ
        // we will try to heal it on the fly
        if (AddQRecord(lpszName, ULID_PQ, &sPQ, ulRec, IComparePri) < 0)
        {
            RecordKdPrint(BADERRORS,("Bad PQ trying to reorder!!!\r\n"));
            ReorderQ(lpdbID);
        }

        iRet = 1;
    }
    else
    {
        Assert(FALSE);
    }

    FreeNameString(lpszName);

    END_TIMING(AddPriQRecord);
    return (iRet);
}

int PUBLIC DeletePriQRecord(
    LPTSTR      lpdbID,
    ULONG       ulidDir,
    ULONG       ulidShadow,
    LPPRIQREC   lpSrc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{

    LPSTR   lpszName;
    CSCHFILE hf;
    QREC sQR;
    ULONG ulRec;
    int iRet = -1;

    BEGIN_TIMING(DeletePriQRecord);

    CONDITIONALLY_NOP();
    lpszName = FormNameString(lpdbID, ULID_PQ);

    if (!lpszName)
    {
        return -1;
    }


    hf = OpenFileLocal(lpszName);

    if (!hf)
    {
    Assert(FALSE);
    goto bailout;
    }

    ulRec = RecFromInode(ulidShadow);

    Assert(ValidRec(ulRec));

    if (UnlinkQRecord(hf, ulRec, (LPQREC)lpSrc)>0)
    {
        Assert(lpSrc->ulidDir == ulidDir);
        Assert(lpSrc->ulidShadow == ulidShadow);

        // we set the ulidShadow of the record to 0s so that as far as priq is concerned
        // it is non-existent but it is still not de-allocated.

        //FreeInode will deallocate the record
        InitPriQRec(lpSrc->ulidShare, ulidDir, 0, 0, 0, 0, 0, 0, INVALID_REC, &sQR);

        if (EditRecordEx(ULID_PQ, (LPGENERICREC)&sQR, NULL, ulRec, UPDATE_REC))
        {
            iRet = 1;
        }
    }

bailout:
    if (hf)
    {
        CloseFileLocal(hf);
    }

    FreeNameString(lpszName);

    END_TIMING(DeletePriQRecord);
    DEBUG_LOG(RECORD,("DeletePriQRecord:iRet=%d, ulidDir=%xh, ulidSHadow=%xh\r\n", iRet, ulidDir, ulidShadow));
    return (iRet);
}

int PUBLIC FindPriQRecord(
    LPTSTR      lpdbID,
    ULONG       ulidDir,
    ULONG       ulidShadow,
    LPPRIQREC   lpSrc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CONDITIONALLY_NOP();

    if(FindPriQRecordInternal(lpdbID, ulidShadow, lpSrc) >= 0)
    {
        if (lpSrc->ulidDir == ulidDir)
        {
            return 1;
        }
    }

    return -1;
}

int FindPriQRecordInternal(
    LPTSTR      lpdbID,
    ULONG       ulidShadow,
    LPPRIQREC   lpSrc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=-1;
    ULONG ulRec;

    BEGIN_TIMING(FindPriQRecordInternal);


    ulRec = RecFromInode(ulidShadow);

    if(EditRecordEx(ULID_PQ, (LPGENERICREC)lpSrc, NULL, ulRec, FIND_REC))
    {
        // don't check whether the returned inode is of the same type or not
        if (lpSrc->ulidShadow)
        {
            iRet = 1;
        }
    }

    END_TIMING(FindPriQRecordInternal);
    return (iRet);
}



int PUBLIC UpdatePriQRecord(
    LPTSTR      lpdbID,
    ULONG       ulidDir,
    ULONG       ulidShadow,
    LPPRIQREC   lpPQ
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = -1;
    ULONG ulrecSrc;

    CONDITIONALLY_NOP();

//    Assert(ValidInode(lpPQ->ulidShadow));

    Assert(lpPQ->ulidShadow == ulidShadow);

    Assert(lpPQ->uchType == REC_DATA);

    ulrecSrc = RecFromInode(lpPQ->ulidShadow);

    Assert(ValidRec(ulrecSrc));

    if(EditRecordEx(ULID_PQ, (LPGENERICREC)lpPQ, NULL, ulrecSrc, UPDATE_REC))
    {
        iRet = 1;
    }

    return (iRet);
}

int PUBLIC UpdatePriQRecordAndRelink(
    LPTSTR      lpdbID,
    ULONG       ulidDir,
    ULONG       ulidShadow,
    LPPRIQREC   lpPQ
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;
    ULONG ulrecSrc;

    Assert(lpPQ->ulidShadow == ulidShadow);

    Assert(lpPQ->uchType == REC_DATA);

    ulrecSrc = RecFromInode(lpPQ->ulidShadow);

    Assert(ValidRec(ulrecSrc));

    iRet = RelinkQRecord(lpdbID, ULID_PQ, ulrecSrc, lpPQ, IComparePri);

    if (iRet < 0)
    {
        RecordKdPrint(BADERRORS,("Bad PQ, trying to reorder!!!\r\n"));
        ReorderQ(lpdbID);
        iRet = 1;
    }
    else
    {
        // iRet == 0 => record is OK where it is now
        // iRet == 1 => it has been relinked, this also means other values have been
        // updated

        if (iRet == 0)
        {
            // the record is OK where it is, we need to write the rest of the info

            if(EditRecordEx(ULID_PQ, (LPGENERICREC)lpPQ, NULL, ulrecSrc, UPDATE_REC))
            {
                iRet = 1;
            }

        }
    }

    return (iRet);
}

void PRIVATE InitPriQRec(
    ULONG ulidShare,
    ULONG ulidDir,
    ULONG ulidShadow,
    ULONG uStatus,
    ULONG ulRefPriority,
    ULONG ulIHPriority,
    ULONG ulHintPri,
    ULONG ulHintFlags,
    ULONG ulrecDirEntry,
    LPPRIQREC    lpDst
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    memset((LPVOID)lpDst, 0, sizeof(PRIQREC));
    lpDst->uchType = REC_DATA;
    lpDst->ulidShare = ulidShare;
    lpDst->ulidDir = ulidDir;
    lpDst->ulidShadow = ulidShadow;
    lpDst->usStatus = (USHORT)uStatus;
    lpDst->uchRefPri = (UCHAR)ulRefPriority;
    lpDst->uchIHPri = (UCHAR)ulIHPriority;
    lpDst->uchHintFlags = (UCHAR)ulHintFlags;
    lpDst->uchHintPri = (UCHAR)ulHintPri;
    lpDst->ulrecDirEntry = ulrecDirEntry;
}

int PUBLIC IComparePri(
    LPPRIQREC    lpDst,
    LPPRIQREC    lpSrc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    USHORT usSrc, usDst;

    usSrc = lpSrc->uchRefPri;
    usDst = lpDst->uchRefPri;

    return ((usDst > usSrc)?1:((usDst == usSrc)?0:-1));
}

int PUBLIC ICompareQInode(
    LPPRIQREC    lpDst,
    LPPRIQREC    lpSrc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return ((lpDst->ulidShadow == lpSrc->ulidShadow)?0:-1);
}

ULONG PUBLIC UlAllocInode(
    LPTSTR    lpdbID,
    ULONG ulidDir,
    BOOL fFile
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    PRIQREC sPQ;
    ULONG ulRec;
    HSHADOW hShadow = INVALID_SHADOW;

    ResetInodeTransactionIfNeeded();

    InitPriQRec(0, ulidDir, 0, 0, 1, 0, 0, 0, INVALID_REC, &sPQ);

    if(ulRec = EditRecordEx(ULID_PQ, (LPGENERICREC)&sPQ, ICompareFail, INVALID_REC, ALLOC_REC))
    {
        hShadow = InodeFromRec(ulRec, fFile);
    }

    RecordKdPrint(PQ,("UlAllocInode: rec=%x, inode=%x", ulRec, hShadow));
    return (hShadow);
}

int PUBLIC FreeInode(
    LPTSTR    lpdbID,
    ULONG ulidFree
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    PRIQREC sPQ;
    ULONG ulRec;
    HSHADOW hShadow = INVALID_SHADOW;

    ulRec = RecFromInode(ulidFree);
    RecordKdPrint(PQ,("FreeInode: rec=%x, inode=%x", ulRec, ulidFree));

    Assert(ValidRec(ulRec));

    memset(&sPQ, 0, sizeof(sPQ));

    ulRec = EditRecordEx(ULID_PQ, (LPGENERICREC)&sPQ, NULL, ulRec, DELETE_REC);

    return ((ulRec != 0)?1:-1);
}

/******************************* Queue operations ***************************/
void
InitQHeader(
    LPQHEADER lpQH
    )
{
    memset((LPVOID)lpQH, 0, sizeof(PRIQHEADER));
    lpQH->uRecSize = sizeof(PRIQREC);
    lpQH->lFirstRec = (LONG) sizeof(PRIQHEADER);
    lpQH->ulVersion = CSC_DATABASE_VERSION;
}

CSCHFILE
PUBLIC
BeginSeqReadPQ(
    LPTSTR    lpdbID
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR   lpszName;
    CSCHFILE hf;

    lpszName = FormNameString(lpdbID, ULID_PQ);
    if (!lpszName)
    {
        return (CSCHFILE_NULL);
    }
    hf = OpenFileLocal(lpszName);
    FreeNameString(lpszName);
    return (hf);
}

int PUBLIC SeqReadQ(
    CSCHFILE hf,
    LPQREC    lpSrc,
    LPQREC    lpDst,
    USHORT    uOp
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    QHEADER sQH;
    ULONG ulrecSeek = 0L, cLength;
    int iRet = -1;

    cLength = sizeof(QHEADER);
    if (ReadFileLocal(hf, 0L, (LPVOID)&sQH, cLength) < 0)
        goto bailout;

    switch (uOp)
    {
    case Q_GETFIRST:
        ulrecSeek = sQH.ulrecHead;
        break;
    case Q_GETNEXT:
        ulrecSeek = lpSrc->ulrecNext;
        break;
    case Q_GETLAST:
        ulrecSeek = sQH.ulrecTail;
        break;
    case Q_GETPREV:
        ulrecSeek = lpSrc->ulrecPrev;
        break;
    }
    if (ulrecSeek)
    {
        iRet = ReadRecord(hf, (LPGENERICHEADER)&sQH, ulrecSeek, (LPGENERICREC)lpDst);
    }
    else
    {
        lpDst->ulrecNext = lpDst->ulrecPrev = 0L;
        iRet = 0;
    }
bailout:
    return (iRet);
}

int PUBLIC
EndSeqReadQ(
    CSCHFILE hf
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return(CloseFileLocal(hf));
}


int PUBLIC AddQRecord(
    LPTSTR  lpQFile,
    ULONG   ulidPQ,
    LPQREC  lpSrc,
    ULONG   ulrecNew,
    EDITCMPPROC fnCmp
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf=CSCHFILE_NULL;
    ULONG ulrecPrev, ulrecNext;
    int iRet = -1, cntRetry;
    BOOL   fCached;

    // We are writing somewhere else
    lpSrc->ulrecNext = lpSrc->ulrecPrev = 0L;

    for(cntRetry=0; cntRetry<=1; cntRetry++)
    {
        hf = OpenInodeFileAndCacheHandle(vlpszShadowDir, ulidPQ, ACCESS_READWRITE, &fCached);

        if (!hf)
        {
            Assert(FALSE);
            return -1;
        }

        if (IsLeaf(lpSrc->ulidShadow))
        {
            BEGIN_TIMING(FindQRecordInsertionPoint_Addq);
        }
        else
        {
            BEGIN_TIMING(FindQRecordInsertionPoint_Addq_dir);
        }

        // Let us find a position to add it,
        iRet = FindQRecordInsertionPoint(   hf,
                    lpSrc,      // record to insert
                    INVALID_REC,// start from the head of the queue
                    fnCmp,      // comparison function
                    &ulrecPrev,
                    &ulrecNext);

        DEBUG_LOG(RECORD,("AddQRecord:Insertion points: Inode=%xh, ulrecPrev=%d, ulrecNext=%d \r\n", lpSrc->ulidShadow, ulrecPrev, ulrecNext));

        if (IsLeaf(lpSrc->ulidShadow))
        {
            END_TIMING(FindQRecordInsertionPoint_Addq);
        }
        else
        {
            END_TIMING(FindQRecordInsertionPoint_Addq_dir);
        }

        if (iRet<0)
        {
            if (cntRetry < 1)
            {

                RecordKdPrint(BADERRORS,("FindQRecordInsertionPoint: failed\r\n"));
                RecordKdPrint(BADERRORS,("FindQRecordInsertionPoint: purging handle cache and retrying \r\n"));

                DeleteFromHandleCache(INVALID_SHADOW);

                continue;
            }
            else
            {
                RecordKdPrint(BADERRORS,("FindQRecordInsertionPoint: failed, bailing out\r\n"));
                goto bailout;
            }
        }
        else
        {
            break;
        }
    }

    BEGIN_TIMING(LinkQRecord_Addq);

    Assert((ulrecNew != ulrecPrev) && (ulrecNew != ulrecNext));

    iRet = LinkQRecord(hf, lpSrc, ulrecNew, ulrecPrev, ulrecNext);

    END_TIMING(LinkQRecord_Addq);

    RecordKdPrint(PQ, ("AddQRecord: linking %x between prev=%x and Next=%x \r\n", ulrecNew, ulrecPrev, ulrecNext));

bailout:
    if (hf && !fCached)
    {
        Assert(vfStopHandleCaching);
        CloseFileLocal(hf);
    }
    else
    {
        Assert(!hf || !vfStopHandleCaching);
    }
    return (iRet);
}

int PUBLIC FindQRecordInsertionPoint(
    CSCHFILE   hf,
    LPQREC  lpSrc,
    ULONG   ulrecStart,
    EDITCMPPROC fnCmp,
    ULONG   *lpulrecPrev,
    ULONG   *lpulrecNext
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    QHEADER sQH;
    QREC sQR;
    ULONG ulrecFound, ulCnt;
    int iCmp;
    ULONG   fDownward;

    // Let us grab the header first
    if (ReadHeader(hf, (LPGENERICHEADER)&sQH, sizeof(QHEADER))<= 0)
        return -1;

//    Assert(!((ulrecStart == INVALID_REC) && !fDownward));

    // we do trivial checks for MAX and MIN
    if (lpSrc->uchRefPri >= MAX_PRI)
    {
        // if the passed in record is already at the head
        // then the current insertion point is just fine
        if ((ulrecStart != INVALID_REC) && (ulrecStart == sQH.ulrecHead))
        {
            return 0;
        }
        // make it the head

        *lpulrecPrev = 0;   // no prev

        *lpulrecNext = sQH.ulrecHead; // current head is the next

        RecordKdPrint(PQ,("FindQInsertionPoint: Insertion point for %x with ref=%d between prev=%x and Next=%x \r\n",
            lpSrc->ulidShadow, lpSrc->uchRefPri, *lpulrecPrev, *lpulrecNext));
        return 1;
    }
    // min priority?
    if (lpSrc->uchRefPri <= MIN_PRI)
    {
        // if the passed in record is already at the tail
        // then the current insertion point is just fine
        if ((ulrecStart != INVALID_REC) && (ulrecStart == sQH.ulrecTail))
        {
            return 0;
        }
        // make it the tail
        *lpulrecNext = 0;   // no next

        *lpulrecPrev = sQH.ulrecTail; // current  tail is the prev

        RecordKdPrint(PQ,("FindQInsertionPoint: Insertion point for %x with ref=%d between prev=%x and Next=%x \r\n",
            lpSrc->ulidShadow, lpSrc->uchRefPri, *lpulrecPrev, *lpulrecNext));
        return 1;
    }

    if (ulrecStart == INVALID_REC)
    {

        fDownward = (IsLeaf(lpSrc->ulidShadow)?TRUE:FALSE);

    }
    else
    {
        if(ReadRecord(hf, (LPGENERICHEADER)&sQH, ulrecStart, (LPGENERICREC)&sQR) <=0)
        {
            Assert(FALSE);
            return -1;
        }
        // is exiting record greater than the passed in record?
        // 1 => yes, 0 => equal, -1 => less
        iCmp = (*fnCmp)(&sQR, lpSrc);

        if (iCmp == 0)
        {
            *lpulrecPrev = sQR.ulrecPrev;
            *lpulrecNext = sQR.ulrecNext;

            return 0;
        }
        else {
            if (iCmp > 0)
            {
                // the existing record is greater than the new record
                // go down
                fDownward = TRUE;
                ulrecStart = sQR.ulrecNext;
            }
            else
            {
                // the existing record is less than the new record
                // go up
                fDownward = FALSE;
                ulrecStart = sQR.ulrecPrev;

            }
        }
    }

    // Start reading from the head and downward if starting rec is not provided
    // ensure that we don't traverse more than the total number of records in the PQ.
    // Thus if because of some problem there are loops in the PQ, we won't be stuck here.

    for (   ulrecFound = ((ulrecStart == INVALID_REC)?
                            ((fDownward)?sQH.ulrecHead:sQH.ulrecTail):ulrecStart),
                            ulCnt = sQH.ulRecords;
                        ulrecFound && ulCnt;
                        (ulrecFound = ((fDownward)?sQR.ulrecNext:sQR.ulrecPrev), --ulCnt)
        )
    {
        if(ReadRecord(hf, (LPGENERICHEADER)&sQH, ulrecFound, (LPGENERICREC)&sQR) <=0)
            return -1;


        if (fDownward)
        {
            // if we are going towards the tail (fDownward==TRUE ie: lower priority nodes) and
             // if the comparison function said that our priority is better than that of the one
            // pointed to by ulrecFound, then we must get inserted such that
            // ulrecFound is our next and it's prev is our prev

            *lpulrecNext = ulrecFound;
            *lpulrecPrev = sQR.ulrecPrev;
        }
        else
        {
            // if we are going towards the head (fDownward==FALSE ie: higher priority nodes)
            // and if the comparison function said that our priority is <= that of the one
            // pointed to by ulrecFound, then we must get inserted such that
            // ulrecFound is our prev and it's next is our Next

            *lpulrecPrev = ulrecFound;
            *lpulrecNext = sQR.ulrecNext;
        }


        // compare current record against passed in record
        // -1 => sQR<lpSrc
        // 0 => sQR==lpSrc
        // 1 => sQR>lpSrc

        iCmp = (*fnCmp)(&sQR, lpSrc);

        if (fDownward)
        {
            if (iCmp <= 0)
            {
                // found an entry which is equal to or less than the input priority
                break;
            }
        }
        else
        {
            if (iCmp >= 0)
            {
                // found an entry which is equal to or greater than the input priority
                break;
            }
        }
    }

    if (!ulrecFound)
    {
        // we are supposed to get inserted at the head or the tail

        // if going down, the current tail becomes our prev and we become the new tail
        // if going up, the current head becomes our next and we become the new head

        *lpulrecPrev = (fDownward)?sQH.ulrecTail:0;
        *lpulrecNext = (fDownward)?0:sQH.ulrecHead;
    }

    RecordKdPrint(PQ,("FindQInsertionPoint: Insertion point for %x with ref=%d between prev=%x and Next=%x \r\n", lpSrc->ulidShadow, lpSrc->uchRefPri, *lpulrecPrev, *lpulrecNext));
    return (1);
}

int PUBLIC DeleteQRecord(
    LPTSTR          lpQFile,
    LPQREC          lpSrc,
    ULONG           ulRec,
    EDITCMPPROC     fnCmp
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf;
    int iRet = -1;

    hf = OpenFileLocal(lpQFile);

    if (!hf)
    {
    Assert(FALSE);
    return -1;
    }

    Assert(ValidRec(ulRec));

    iRet = UnlinkQRecord(hf, ulRec, lpSrc);

    CloseFileLocal(hf);

    return (iRet);
}

int PUBLIC RelinkQRecord(
    LPTSTR  lpdbID,
    ULONG   ulidPQ,
    ULONG   ulRec,
    LPQREC  lpSrc,
    EDITCMPPROC fnCmp
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf;
    QREC    sQR1;
#ifdef DEBUG
    QREC sQRNext, sQRPrev;
#endif
    ULONG ulrecPrev, ulrecNext;
    int iRet = -1;
    LPSTR   lpszName;
    BOOL    fCached;

    hf = OpenInodeFileAndCacheHandle(lpdbID, ULID_PQ, ACCESS_READWRITE, &fCached);

    if (!hf)
    {
        return -1;
    }

    Assert(ValidRec(ulRec));

    // Let us find a position to add it,
    // iRet == 1 means it needs relinking
    // iRet ==0 means it is OK where it is
    // iRet < 0 means there has been some error

    iRet = FindQRecordInsertionPoint(  hf,
                lpSrc,
                ulRec,      // start looking from the current copy of the record
                fnCmp,
                &ulrecPrev, //returns rec # of the prev guy
                &ulrecNext); //returns rec # of the next guy

    if (iRet < 0)
        goto bailout;

#ifdef DEBUG

    // verify the reinsertion logic
    if (iRet == 1)
    {
        if (ulrecNext)
        {

            if (!EditRecordEx(ULID_PQ, (LPGENERICREC)&sQRNext, NULL, ulrecNext, FIND_REC))
            {
                Assert(FALSE);

            }
            else
            {

                if(sQRNext.uchRefPri > lpSrc->uchRefPri)
                {
                    LPQREC lpQT = &sQRNext;

                    RecordKdPrint(BADERRORS,("RelinkQRecord: Out of order insertion in PQ\r\n"));
                    RecordKdPrint(BADERRORS,("sQRNext.uchRefPri=%d lpSrc->uchRefPri=%d\r\n",(unsigned)(sQRNext.uchRefPri), (unsigned)(lpSrc->uchRefPri)));
                    RecordKdPrint(BADERRORS,("lpSrc=%x sQRNext=%x ulrecPrev=%d ulrecNext=%d\r\n", lpSrc, lpQT, ulrecPrev, ulrecNext));
//                    Assert(FALSE);
                }
            }
        }
        if (ulrecPrev)
        {

            if (!EditRecordEx(ULID_PQ, (LPGENERICREC)&sQRPrev, NULL, ulrecPrev, FIND_REC))
            {
                Assert(FALSE);

            }
            else
            {
                if(sQRPrev.uchRefPri < lpSrc->uchRefPri)
                {
                    LPQREC lpQT = &sQRPrev;
                    RecordKdPrint(BADERRORS,("RelinkQRecord: Out of order insertion in PQ\r\n"));
                    RecordKdPrint(BADERRORS,("sQRPrev.uchRefPri=%d lpSrc->uchRefPri=%d\r\n",(unsigned)(sQRPrev.uchRefPri), (unsigned)(lpSrc->uchRefPri)));
                    RecordKdPrint(BADERRORS,("lpSrc=%x sQRPrev=%x ulrecPrev=%d ulrecNext=%d\r\n", lpSrc, lpQT, ulrecPrev, ulrecNext));
//                    Assert(FALSE);
                }
            }
        }
    }
#endif //DEBUG

    Assert((iRet == 0) || ulrecPrev || ulrecNext);

    RecordKdPrint(PQ, ("RelinkQRecord: old location for %x with ref=%d at prev=%x and Next=%x \r\n", ulRec, lpSrc->uchRefPri, lpSrc->ulrecPrev, lpSrc->ulrecNext));
    RecordKdPrint(PQ, ("RelinkQRecord: new location at prev=%x and Next=%x \r\n", ulrecPrev, ulrecNext));

    if ((iRet == 0)||(ulrecPrev == ulRec)||(ulrecNext == ulRec))
    {
        RecordKdPrint(PQ, ("RelinkQRecord: %x is OK at its place for pri=%d\r\n", ulRec, lpSrc->uchRefPri));
        iRet = 0;
        goto bailout;
    }

    if ((iRet = UnlinkQRecord(hf, ulRec, &sQR1))>=0)
    {
        iRet = LinkQRecord(hf, lpSrc, ulRec, ulrecPrev, ulrecNext);
        if (iRet >= 0)
        {
            // return the fact that we relinked
            iRet = 1;
        }
    }

bailout:
    if (hf && !fCached)
    {
        Assert(vfStopHandleCaching);
        CloseFileLocal(hf);
    }
    else
    {
        Assert(!hf || !vfStopHandleCaching);
    }
    return (iRet);
}


int PRIVATE UnlinkQRecord(
    CSCHFILE hf,
    ULONG ulRec,
    LPQREC lpQR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    QHEADER sQH;
    QREC sQRPrev, sQRNext;
    BOOL fPrev=FALSE, fNext=FALSE;

    // Let us grab the header first
    if (ReadHeader(hf, (LPGENERICHEADER)&sQH, sizeof(QHEADER))<= 0)
        return -1;

    if (ReadRecord(hf, (LPGENERICHEADER)&sQH, ulRec, (LPGENERICREC)lpQR) < 0)
    {
        return -1;
    }

    // Did we have a prev?
    if (lpQR->ulrecPrev)
    {
        // yes, let us read it
        fPrev = (ReadRecord(hf, (LPGENERICHEADER)&sQH, lpQR->ulrecPrev, (LPGENERICREC)&sQRPrev)>0);
        if (!fPrev)
            return -1;
    }
    // Did we have a Next
    if (lpQR->ulrecNext)
    {
        // yes, let us read it
        fNext = (ReadRecord(hf, (LPGENERICHEADER)&sQH, lpQR->ulrecNext, (LPGENERICREC)&sQRNext)>0);
        if (!fNext)
            return -1;
    }

    // Plug these values assuming no special cases
    sQRNext.ulrecPrev =  lpQR->ulrecPrev;
    sQRPrev.ulrecNext =  lpQR->ulrecNext;

    // Were we at the head
    if (!fPrev)
    {
        // modify the head in the header to point to our next
        sQH.ulrecHead = lpQR->ulrecNext;
    }
    // Were we at the tail
    if (!fNext)
    {
        // modify the tail in the header to point to our prev
        sQH.ulrecTail = lpQR->ulrecPrev;
    }

    // Write our next if it exists
    if (fNext)
    {
        Assert(lpQR->ulrecNext != sQRNext.ulrecNext);
        Assert(lpQR->ulrecNext != sQRNext.ulrecPrev);
        if (WriteRecord(hf, (LPGENERICHEADER)&sQH, lpQR->ulrecNext, (LPGENERICREC)&sQRNext)<=0)
            return -1;
    }

    // Write our prev if it exists
    if (fPrev)
    {
        Assert(lpQR->ulrecPrev != sQRPrev.ulrecNext);
        Assert(lpQR->ulrecPrev != sQRPrev.ulrecPrev);
        if (WriteRecord(hf, (LPGENERICHEADER)&sQH, lpQR->ulrecPrev, (LPGENERICREC)&sQRPrev) <=0)
            return -1;
    }
    // Did we get removed from head or tail?
    if (!fPrev || !fNext)
    {
        if(WriteHeader(hf, (LPVOID)&sQH, sizeof(QHEADER))<=0)
            return -1;
    }
    return 1;
}



int PRIVATE LinkQRecord(
    CSCHFILE     hf,           // This file
    LPQREC    lpNew,        // Insert This record
    ULONG     ulrecNew,     // This is it's location in the file
    ULONG     ulrecPrev,     // This is our Prev's location
    ULONG     ulrecNext      // This is our Next's location
    )
{
    QHEADER sQH;
    QREC  sQRNext, sQRPrev;
    BOOL fPrev, fNext;
#ifdef DEBUG
    QHEADER sQHOrg;
    QREC    sQRNextOrg, sQRPrevOrg, sQRNewOrg;
#endif

    // Let us grab the header first
    if (ReadHeader(hf, (LPGENERICHEADER)&sQH, sizeof(QHEADER))<= 0)
        return -1;
#ifdef DEBUG
    sQHOrg = sQH;
    sQRNewOrg=*lpNew;
#endif


    fPrev = fNext = FALSE;

    // Let us now modify the Next related pointers
    if (ulrecNext)
    {
        // normal case
        // Read the record at ulrecNext

        if (ReadRecord(hf, (LPGENERICHEADER)&sQH, ulrecNext, (LPGENERICREC)&sQRNext) <=0)
            return -1;

#ifdef DEBUG
        sQRNextOrg = sQRNext;
#endif
        // Change it's Prev to point to new
        sQRNext.ulrecPrev = ulrecNew;

        // And new's Next to point to ulrecNext
        lpNew->ulrecNext = ulrecNext;

        // note that ulrecNext has been modified and hence must be written
        fNext=TRUE;
    }
    else
    {
        // no next, that means the new record is being added at the tail of the list
        // this must mean that if there is a ulrecPrev, then it is the current tail

        Assert(!ulrecPrev || (ulrecPrev == sQH.ulrecTail));

        // Mark nobody as our Next
        lpNew->ulrecNext = 0L;
        lpNew->ulrecPrev = sQH.ulrecTail;
        sQH.ulrecTail = ulrecNew;
    }

    // Now let us modify  Prev related pointers

    // Are supposed to have a Prev?
    if (ulrecPrev)
    {
        // normal case
        // Read the (tobe) Prev record

        if (ReadRecord(hf, (LPGENERICHEADER)&sQH, ulrecPrev, (LPGENERICREC)&sQRPrev) <=0)
            return -1;

#ifdef DEBUG
        sQRPrevOrg = sQRPrev;
#endif
        // make the new one his next
        sQRPrev.ulrecNext = ulrecNew;

        // make the prev the prev of new one
        lpNew->ulrecPrev = ulrecPrev;

        // Note the fact that the record at ulrecPrev was modified and must be written out
        fPrev = TRUE;
    }
    else
    {
        // no previous, that means the new record is being added at the head of the list
        // this must mean that if there is a ulrecNext, then it is the current head

        Assert(!ulrecNext || (ulrecNext == sQH.ulrecHead));

        // Make the head guy our Next, nobody as our Prev
        lpNew->ulrecNext = sQH.ulrecHead;
        lpNew->ulrecPrev = 0L;

        // Change the head pointer in the header to point to us
        sQH.ulrecHead = ulrecNew;
    }


    // let us first link the new record in. The order is important.
    // If subsequent operations fail, the linked list is not broken
    // It may be that traverseing from top to bottom might include
    // this new element but may not include it from bottom to top

#ifdef DEBUG
    if ((ulrecNew == lpNew->ulrecPrev)||(ulrecNew == lpNew->ulrecNext))
    {
        LPQHEADER lpQHOrg = &sQHOrg, lpQHT=&sQH;

        RecordKdPrint(BADERRORS,("LinkQRecord: Circular linking sQHOrg.ulrecHead=%d sQHOrg.ulrecTail=%d\r\n",
                        sQHOrg.ulrecHead, sQHOrg.ulrecTail));

        RecordKdPrint(BADERRORS,("sQRNewOrg.ulrecPrev=%d, sQRNewOrg.ulrecNext=%d", sQRNewOrg.ulrecPrev, sQRNewOrg.ulrecNext));

        RecordKdPrint(BADERRORS,("sQRPrevOrg.ulrecPrev=%d, sQRPrevOrg.ulrecNext=%d", sQRPrevOrg.ulrecPrev, sQRPrevOrg.ulrecNext));

        RecordKdPrint(BADERRORS,("sQHOrg=%x sQH=%x\r\n", lpQHOrg,lpQHT));

        Assert(FALSE);
    }
#endif

    if(WriteRecord(hf, (LPGENERICHEADER)&sQH, ulrecNew, (LPGENERICREC)lpNew) < 0)
        return -1;

    if (fPrev)
    {
        Assert(ulrecPrev != sQRPrev.ulrecPrev);
        Assert(ulrecPrev != sQRPrev.ulrecNext);

        Assert(lpNew->uchRefPri <= sQRPrev.uchRefPri);

        if(WriteRecord(hf, (LPGENERICHEADER)&sQH, ulrecPrev, (LPGENERICREC)&sQRPrev) < 0)
            return -1;
    }
    if (fNext)
    {
        Assert(ulrecNext != sQRNext.ulrecPrev);
        Assert(ulrecNext != sQRNext.ulrecNext);

        Assert(lpNew->uchRefPri >= sQRNext.uchRefPri);

    if (WriteRecord(hf, (LPGENERICHEADER)&sQH, ulrecNext, (LPGENERICREC)&sQRNext) < 0)
        return -1;
    }

    if (!fNext || !fPrev)
        if (WriteHeader(hf, (LPGENERICHEADER)&sQH, sizeof(QHEADER))<0)
            return -1;

    return (1);
}


#ifdef LATER
LPPATH PRIVATE LpAppendStartDotStar
    (
    LPPATH lpSrc
    )
{
    count = strlen(lpSrc)+strlen(szStar)+1;
    if (!(lpNewSrc = (LPTSTR)AllocMem(count)))
    {
        RecordKdPrint(BADERRORS,("CopyDir: Memalloc failed\r\n"));
        return -1;
    }
    strcpy(lpNewSrc, lpSrc);
    strcat(lpNewSrc, szStar);
}

#endif //LATER

ULONG PRIVATE GetNormalizedPri(
    ULONG ulPri
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ulPri = min(ulPri, MAX_PRI);
    ulPri = max(ulPri, MIN_PRI);
    return (ulPri);
}

ULONG PUBLIC AllocFileRecord(
    LPTSTR    lpdbID,
    ULONG ulidDir,
    USHORT    *lpcFileName,
    LPFILERECEXT    lpFR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG ulRec;


    InitFileRec(lpFR);
    LFNToFilerec(lpcFileName, lpFR);
    ulRec = EditRecordEx(ulidDir, (LPGENERICREC)lpFR, ICompareFail, INVALID_REC, ALLOC_REC);

    return (ulRec);
}

ULONG PUBLIC AllocPQRecord(
    LPTSTR    lpdbID)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    PRIQREC sPQ;
    ULONG ulRec;

    InitPriQRec(0, 0, 0, 0, 0, 0, 0, 0, 0, &sPQ);
    ulRec = EditRecordEx(ULID_PQ, (LPGENERICREC)&sPQ, ICompareFail, INVALID_REC, ALLOC_REC);

    return (ulRec);
}


ULONG AllocShareRecord( LPTSTR    lpdbID,
    USHORT *lpShare
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    SHAREREC sSR;
    ULONG ulRec=0;

    // we deal with \\server\share names of limited size.
    if (wstrlen(lpShare) < sizeof(sSR.rgPath))
    {

        if(!InitShareRec(&sSR, lpShare, 0))
        {
            return 0;
        }

        // Let us get the location of the soon to be server record
        ulRec = EditRecordEx(ULID_SHARE, (LPGENERICREC)&sSR, ICompareFail, INVALID_REC, ALLOC_REC);
    }

    return (ulRec);
}

int PRIVATE ICompareFail(
    LPGENERICREC    lpSrc,
    LPGENERICREC    lpDst
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    lpSrc;
    lpDst;
    return(1);
}

#ifdef MAYBE
BOOL
InsertInNameCache(
    HSHADOW hDir,
    HSHADOW hShadow,
    USHORT  *lpName,
    ULONG   ulrec,
    FILERECEXT  *lpFR
    )
{
    int     indx, len;
    DWORD   dwHash;
    BOOL fRet = FALSE;


    if(FindNameCacheEntryEx(hDir, hShadow, lpName, &dwHash, &indx))
    {
    Assert(indx >= 0 && indx < NAME_CACHE_TAB_SIZE);

    return TRUE;
    }
    else
    {

        Assert(indx >= 0 && indx < NAME_CACHE_TAB_SIZE);

        if(rgNameCache[indx] != NULL)
        {
            FreeMem(rgNameCache[indx]);
            rgNameCache[indx] = NULL;
        }

        len = wstrlen(lpName);

        if(rgNameCache[indx] = AllocMem(sizeof(NAME_CACHE_ENTRY)+sizeof(FILERECEXT)+(len+1)*sizeof(USHORT)))
        {
            rgNameCache[indx]->dwHash = dwHash;
            rgNameCache[indx]->hDir = hDir;
            rgNameCache[indx]->hShadow = hDir;
            rgNameCache[indx]->ulrec = ulrec;

            memcpy(&(rgNameCache[indx]->sFR), lpFR, sizeof(FILERECEXT));

            memcpy(rgNameCache[indx]->rgName, lpName, (len+1)*sizeof(USHORT));
            fRet = TRUE;
        }
    }

    return (fRet);
}

BOOL
DeleteFromNameCache(
    HSHADOW hDir,
    HSHADOW hShadow,
    USHORT  *lpName,
    ULONG   *lpulrec,
    FILERECEXT  *lpFR

)
{

    int     indx = -1;
    DWORD   dwHash;
    BOOL fFound;

    if(fFound = FindNameCacheEntryEx(hDir, hShadow, lpName, &dwHash, &indx))
    {
    Assert(indx >= 0 && indx < NAME_CACHE_TAB_SIZE);

    if(rgNameCache[indx] != NULL)
    {
        *lpulrec = rgNameCache[indx]->ulrec;
        memcpy(lpFR, &(rgNameCache[indx]->sFR), sizeof(FILERECEXT));
        FreeMem(rgNameCache[indx]);
        rgNameCache[indx] = NULL;
    }
    }

    return (fFound);
}

BOOL
FindNameCacheEntry(
    HSHADOW hDir,
    HSHADOW hShadow,
    USHORT  *lpName,
    ULONG   *lpulrec
    FILERECEXT  *lpFR
    )
{

    int     indx;
    DWORD   dwHash;
    BOOL fFound;

    dwNCETotalLookups++;

    if (fFound = FindNameCacheEntryEx(hDir, hShadow, lpName, &dwHash, &indx))
    {
    Assert(indx >=0 && indx < NAME_CACHE_TAB_SIZE);
    *lpulrec = rgNameCache[indx]->ulrec;
    memcpy(lpFR, &(rgNameCache[indx]->sFR), sizeof(FILERECEXT));
    dwNCEHits++;
    }

    return (fFound);
}

BOOL
FindNameCacheEntryEx(
    HSHADOW hDir,
    HSHADOW hShadow,
    USHORT  *lpName,
    DWORD   *lpdwHash,
    int     *lpindx
    )
{
    DWORD dwHash;
    int indx, indxT;
    BOOL fRet = FALSE, fHoleFound = FALSE;

    if (lpName)
    {
    dwHash = HashStr(hDir, lpName);
    }
    else
    {
    dwHash = 0; // 
    }
    if (lpdwHash)
    {
    *lpdwHash = dwHash;
    }

    indxT = indx = dwHash % NAME_CACHE_TAB_SIZE;

    for (;indx < NAME_CACHE_TAB_SIZE; ++indx)
    {
    if (rgNameCache[indx])
    {
        if ((rgNameCache[indx]->dwHash == dwHash)
        &&(rgNameCache[indx]->hDir == hDir)
        && (!hShadow || (hShadow == rgNameCache[indx]->hShadow))
        &&(!lpName || !wstrnicmp(rgNameCache[indx]->rgName, lpName, 256)))
        {
        indxT = indx;
        fRet = TRUE;
        break;
        }
    }
    else
    {
        if (!fHoleFound)
        {
        indxT = indx;   // a hole somewhere after the place where this name hashes
        fHoleFound = TRUE;
        }
    }
    }

    if (lpindx)
    {
    *lpindx = indxT;
    }

    return fRet;
}

DWORD
HashStr(
    HSHADOW hDir,
    USHORT  *lpName
    )
{
    DWORD dwHash = 0;

    while (*lpName)
    {
    dwHash += *lpName;
    dwHash <<= 1;
    lpName++;
    }
    return (dwHash);
}

ULONG PUBLIC UpdateFileRecordFR(
    LPTSTR          lpdbID,
    ULONG           ulidDir,
    LPFILERECEXT    lpFR
    )
{
    LPSTR lpszName;
    ULONG       ulrec=INVALID_REC;
    BOOL        fFound = FALSE;

    BEGIN_TIMING(AddFileRecordFR);

    if (fFound = DeleteFromNameCache(ulidDir, lpFR->sFR.ulidShadow, NULL, &ulrec, &sFR))
    {
    Assert(ulrec != INVALID_REC);
    }

    InitFileRec(&sFR);

    lpszName = FormNameString(lpdbID, ulidDir);

    if (!lpszName)
    {
        return 0;
    }


    ulrec = EditRecordEx(lpszName, (LPGENERICREC)lpFR, ICompareFileRec, ulrec, UPDATE_REC);

    if (ulrec)
    {
        InsertInNameCache(ulidDir, , lpFR->sFR.ulidShadow, lpName, NULL, ulrec);
    }

    FreeNameString(lpszName);

bailout:
    END_TIMING(AddFileRecordFR);

    return (ulrec);
}

#endif


ULONG PUBLIC EditRecordEx(
    ULONG           ulidInode,
    LPGENERICREC    lpSrc,
    EDITCMPPROC     lpCompareFunc,
    ULONG           ulInputRec,
    ULONG           uOp
    )
/*++

Routine Description:

    Workhorse routine called for all operations on the record manager.

Arguments:

    ulidInode       Inode # on which the operation needs to be performed

    lpSrc           record tobe created, lookedup, deleted etc.

    lpCompareFunc   Function to compare the input with the entries in the indoe file

    ulInputRec      If INVALID_REC, then we directly access the sadi record.
                    Otherwise we go linearly and apply the comparison routine.

    uOp             create,delete,find,alloc,update

Returns:

    If successful, returns a non-zero value which is the record number of the record operated on
    else returns 0.

Notes:

    Assumes we are in the shadow critical section.
    Tries to do a lot of paranoid checking + perf.

    Perf is improved by doing two things a) file handles are cached and b) reads are done in
    chunks of ~4K.

    Tries to fix problems on the fly, or bypass them if it may not be safe to fix them.

    Has become kind of messy but I am loathe to change stuff around in this particular routine
    because it is so central to CSC.


--*/
{
    CSCHFILE hf;
    ULONG ulRec;
    GENERICHEADER sGH;
    ULONG ulrecFound = 0L, ulrecHole=0L, ulrecTmp=0L, cntRecs=0;
    int cMaxHoles=0, iRet = -1;
    int iTmp, cOvf,  cntRead=-1, cntRetry;
    LPBYTE  lpGenT;
    LPSTR   lpFile=NULL;
    BOOL    fCached;

    BEGIN_TIMING(EditRecordEx);

    UseCommonBuff();

    for (cntRetry=0; cntRetry<= 1; cntRetry++)
    {
        BEGIN_TIMING(EditRecordEx_OpenFileLocal);

        ulRec = (((ulidInode == ULID_PQ)||(ulidInode == ULID_SHARE))&& (uOp == CREATE_REC))?
                (ACCESS_READWRITE|OPEN_FLAGS_COMMIT):ACCESS_READWRITE;


        hf = OpenInodeFileAndCacheHandle(vlpszShadowDir, ulidInode, ulRec, &fCached);

        if (!hf)
        {
            // spew only when database is enabled
            if(vlpszShadowDir)
            {
                RecordKdPrint(BADERRORS,("EditRecord: FileOpen Error: %xh op=%d \r\n", ulidInode, uOp));
            }
            END_TIMING(EditRecordEx_OpenFileLocal);
            UnUseCommonBuff();
            return 0L;
        }

        END_TIMING(EditRecordEx_OpenFileLocal);

        BEGIN_TIMING(EditRecordEx_Lookup);

        cntRead = ReadFileLocalEx(hf, 0, lpReadBuff, COMMON_BUFF_SIZE, TRUE);

        if (cntRead < (long)sizeof(GENERICHEADER))
        {
            if (cntRead == -1)
            {
                // the handle is invalid

                if (cntRetry < 1)
                {
                    RecordKdPrint(BADERRORS,("EditRecord: Invalid file handle %x\r\n", ulidInode));
                    RecordKdPrint(BADERRORS,("EditRecord: purging handle cache and retrying \r\n"));

                    DeleteFromHandleCache(INVALID_SHADOW);
                    continue;
                }
                else
                {
                    RecordKdPrint(BADERRORS,("EditRecord: Invalid file handle bailing out %x\r\n", ulidInode));
                    goto bailout;
                }
            }
            else
            {
                // an invalid record file !!!
                SetCSCDatabaseErrorFlags(CSC_DATABASE_ERROR_INVALID_HEADER);
                RecordKdPrint(BADERRORS,("EditRecord: Invalid record header for %x\r\n", ulidInode));
                END_TIMING(EditRecordEx_Lookup);
                goto bailout;
            }
        }

        // succeeded in reading the header
        break;

    }

    Assert (cntRead >= (long)sizeof(GENERICHEADER));

    sGH = *(LPGENERICHEADER)lpReadBuff;


    // validate header

    if (!ValidateGenericHeader(&sGH))
    {
        // an invalid record file !!!
        SetCSCDatabaseErrorFlags(CSC_DATABASE_ERROR_INVALID_HEADER);
        RecordKdPrint(BADERRORS,("EditRecord: Invalid record header %x\r\n", ulidInode));
        goto bailout;
    }


    lpGenT = lpReadBuff + sGH.lFirstRec;

    // truncated division gives the count of complete records read
    cntRecs = (cntRead - sGH.lFirstRec)/sGH.uRecSize;

    // if we read all the file
    if (cntRead < COMMON_BUFF_SIZE)
    {
        if (sGH.ulRecords > cntRecs)
        {
            // an invalid record file !!!
            RecordKdPrint(BADERRORS,("EditRecord: Invalid record header, fixable %x\r\n", ulidInode));
            sGH.ulRecords = cntRecs;
            WriteHeaderEx(hf, (LPVOID)&sGH, sizeof(sGH), TRUE);
        }

    }

    cntRecs = (cntRecs <= sGH.ulRecords)?cntRecs:sGH.ulRecords;


    if (ulInputRec == INVALID_REC)
    {
        // there are some records to iterate on and iteration is allowed.

        // in case of PQ, if someone has started an inode transation ans hence is
        // holding inodes, then we shouldn't be reusing them, even if they
        // are deleted by someone else

        if (cntRecs && !((ulidInode==ULID_PQ) && (uOp == ALLOC_REC) && cntInodeTransactions))
        {
            for (ulRec=1;ulRec <=sGH.ulRecords;)
            {

                // The count of complete record sequences, ie main + ovf
                iRet = 1 + ((cntRecs)?OvfCount(lpGenT):0);

                if (ulidInode >= ULID_FIRST_USER_DIR)
                {   // directory inode, we know what the max overflow can be
                    if (iRet > (MAX_OVERFLOW_RECORDS+1))
                    {
                        // file looks bad, bailout;
                        SetCSCDatabaseErrorFlags(CSC_DATABASE_ERROR_INVALID_OVF_COUNT);
                        RecordKdPrint(BADERRORS, ("Invalid overflow count = %d for Inode %x\r\n", iRet, ulidInode));
                        goto bailout;
                    }
                }
                else
                {   // PQ or server, these don't have any overflow records
                    if (iRet != 1)
                    {
                        // file looks bad, bailout;
                        SetCSCDatabaseErrorFlags(CSC_DATABASE_ERROR_INVALID_OVF_COUNT);
                        RecordKdPrint(BADERRORS, ("Invalid overflow count = %d for Inode %x\r\n", iRet, ulidInode));
                        goto bailout;
                    }
                }

                //RecordKdPrint(BADERRORS, ("iRet = %d, cntRecs = %d, ulRec = %d \r\n", iRet, cntRecs, ulRec));

                // time to read if we don't have a full complement of records
                //
                if (iRet > (LONG)cntRecs)
                {
                    cntRead = ReadFileLocalEx(  hf,
                                    sGH.lFirstRec + (long)(ulRec-1) * sGH.uRecSize,
                                    lpReadBuff,
                                    COMMON_BUFF_SIZE, TRUE);
                    if (cntRead <= 0)
                    {
                        // a truncated record file !!!!
//                        Assert(FALSE);
                        SetCSCDatabaseErrorFlags(CSC_DATABASE_ERROR_TRUNCATED_INODE);
                        goto bailout;
                    }

                    cntRecs = cntRead/sGH.uRecSize;

                    if ((LONG)cntRecs < iRet)
                    {
                        // a truncated record file !!!!
//                        Assert(FALSE);
                        SetCSCDatabaseErrorFlags(CSC_DATABASE_ERROR_TRUNCATED_INODE);
                        goto bailout;
                    }

                    // if we are at the end of the file, make sure that the # of records
                    // we read so far (ulRec-1) and the # we read in the latest read
                    // add up to sGH.ulRecords

                    if (cntRead < COMMON_BUFF_SIZE)
                    {
                        if(sGH.ulRecords > (ulRec + cntRecs - 1))
                        {
                            // an invalid record file !!!
                            RecordKdPrint(BADERRORS,("EditRecord: Invalid record header, fixable %x\r\n", ulidInode));
                            sGH.ulRecords = ulRec + cntRecs - 1;
                            WriteHeaderEx(hf, (LPVOID)&sGH, sizeof(sGH), TRUE);
                        }

                    }

                    // all is well
                    lpGenT = lpReadBuff;

                    // recalculate the count of complete records
                    iRet = 1 + ((cntRecs)?OvfCount(lpGenT):0);
                }

                // Make sure we are in ssync
                if ((((LPGENERICREC)lpGenT)->uchType == REC_EMPTY)||
                    (((LPGENERICREC)lpGenT)->uchType == REC_DATA))
                {
                    // make sure the overflow count is really correct

                    if (OvfCount(lpGenT))
                    {
                        Assert((ULONG)OvfCount(lpGenT) < cntRecs);
                        cOvf = RealOverflowCount((LPGENERICREC)lpGenT, &sGH, cntRecs);

                        if (cOvf != OvfCount(lpGenT))
                        {
                            RecordKdPrint(BADERRORS,("EditRecord: ovf count mismatch %xh ulRec=%d cntRecs=%d lpGenT=%x\r\n", ulidInode, ulRec, cntRecs, lpGenT));
//                            Assert(FALSE);
                            SetCSCDatabaseErrorFlags(CSC_DATABASE_ERROR_INVALID_OVF_COUNT);
                            SetOvfCount((LPBYTE)lpGenT, cOvf);
                            if (uOp != FIND_REC)
                            {
                                // do fixups only if we are doing some write operation
                                // this is done so for remoteboot, when we are doing lookups
                                // we won't try to fixup things, in an environment where writes
                                // are not allowed.
                                // at anyrate, we should do writes only when the operation demands writes

                                if (WriteRecord(hf, &sGH, ulRec, (LPGENERICREC)lpGenT) < 0)
                                {
                                    RecordKdPrint(BADERRORS,("EditRecord:Fixup failed \r\n"));
                                    goto bailout;
                                }
                            }
                        }
                    }
                }

                if (((LPGENERICREC)lpGenT)->uchType == REC_EMPTY)
                {
                    // If this is a hole let use keep track if this is the biggest
                    if ((OvfCount(lpGenT)+1) > cMaxHoles)
                    {
                        cMaxHoles = (OvfCount(lpGenT)+1);
                        ulrecHole = ulRec;
                    }
                }
                else if (((LPGENERICREC)lpGenT)->uchType == REC_DATA)
                {
                    // This is a data record, let us do comparing
                    if (lpCompareFunc && !(*lpCompareFunc)((LPGENERICREC)lpGenT, lpSrc))
                    {
                        ulrecFound = ulRec;
                        break;
                    }
                }

                ulRec += iRet;
                lpGenT += iRet * sGH.uRecSize;
                cntRecs -= iRet;

            }   // for loop

        }
    }
    else    // if (ulInputRec == INVALID_REC)
    {
        // random access
        ulrecFound = ulInputRec;
        lpGenT += (long)(ulInputRec-1) * sGH.uRecSize;

        // if the input record exists in the COMMON_BUFF_SIZE read in earlier
        // then just use it

        if ((ulInputRec <= cntRecs)&&
            ((cntRecs - ulInputRec)>=(ULONG)OvfCount(lpGenT)))
        {
        }
        else
        {
            if (ulrecFound <= sGH.ulRecords)
            {

                // NB the assumption here is that the lpReadBuff is big enough
                // to hold the biggest header and the biggest record

                iRet = ReadRecordEx(hf, &sGH, ulrecFound, (LPGENERICREC)lpReadBuff, TRUE);

                if (iRet < 0)
                {
                    goto bailout;
                }

                lpGenT = lpReadBuff;

            }
            else
            {
                iRet = -1;
                RecordKdPrint(ALWAYS,("EditRecordEx: invalid input rec# %d, max record=%d \r\n", ulInputRec, sGH.ulRecords));
                goto bailout;
            }
        }
        // paranoid check
        // even with random access, make sure that if there is a comparison function
        // then the entry matches with what we got, as per the function
        if (lpCompareFunc)
        {
            if((*lpCompareFunc)((LPGENERICREC)lpGenT, lpSrc))
            {
                iRet = -1;
                RecordKdPrint(ALWAYS,("EditRecordEx: invalid input rec# %d as per the comparison routine, \r\n", ulInputRec ));
                goto bailout;
            }
        }
    }

    END_TIMING(EditRecordEx_Lookup);


    BEGIN_TIMING(EditRecordEx_Data);

    switch (uOp)
    {
    case FIND_REC:
    {
        if (ulrecFound && (((LPGENERICREC)lpGenT)->uchType == REC_DATA))
        {
            Assert((LPGENERICREC)lpGenT);
            CopyRecord(lpSrc, (LPGENERICREC)lpGenT, sGH.uRecSize, FALSE);  // From Dst to Src
            iRet = 1;
        }
        else
        {
            iRet = 0;
        }
    }
    break;
    case DELETE_REC:
    {
        if (ulrecFound)
        {
            Assert(lpGenT);
            // Maybe we should truncate files and decrement ulRecords
            // in the header
            for (iTmp=0, cOvf = OvfCount((LPGENERICREC)lpGenT); cOvf >= 0 ; --cOvf)
            {
                // Copy it before we mark it empty so that it can be reused
                // as is
                memcpy(((LPBYTE)lpSrc)+iTmp, ((LPBYTE)lpGenT)+iTmp, sGH.uRecSize);
                ((LPGENERICREC)((LPBYTE)lpGenT+iTmp))->uchType = REC_EMPTY;

                //mark decreasing ovf counts so if next time a record with leass than cOvf
                // count uses this space, the remaining tail still indicates the max size of the hole

                SetOvfCount(((LPBYTE)lpGenT+iTmp), cOvf);

                iTmp += sGH.uRecSize;
            }
            // NB we are deliberately not resetting the overflow count
            // becaues WriteRecord uses it to write those many records
            if((iRet = WriteRecordEx(hf, &sGH, ulrecFound, (LPGENERICREC)lpGenT, TRUE))<=0)
            {
                RecordKdPrint(BADERRORS,("EditRecord:Delete failed \r\n"));
                goto bailout;
            }

            // make sure it went away from the handle cache
            if (IsDirInode(ulidInode))
            {
                DeleteFromHandleCacheEx(((LPFILEREC)lpSrc)->ulidShadow, ACCESS_READWRITE);
                DeleteFromHandleCacheEx(((LPFILEREC)lpSrc)->ulidShadow, ACCESS_READWRITE|OPEN_FLAGS_COMMIT);
            }
        }
    }
    break;
    case CREATE_REC:
    case UPDATE_REC:
    {
        RecordKdPrint(EDITRECORDUPDDATEINFO,("ulrecFound=%d ulrecHole=%d cMaxHoles=%d ovf record=%d \r\n",
            ulrecFound, ulrecHole, cMaxHoles, (ULONG)OvfCount(lpSrc)));
        // Let us try writing in the same place
        if (!ulrecFound)
        {
            // there is a hole and it is big enough and is sector aligned
            if (ulrecHole && (cMaxHoles > OvfCount(lpSrc)) && WithinSector(ulrecHole, &sGH))
            {
                ulrecFound = ulrecHole;
            }
            else
            {
                BEGIN_TIMING(EditRecordEx_ValidateHeader);
                // if necessary extend the file so the next record is sector aligned
                if(!ExtendFileSectorAligned(hf, (LPGENERICREC)lpReadBuff, &sGH))
                {
                    RecordKdPrint(BADERRORS,("EditRecord:filextend failed \r\n"));
                    goto bailout;
                }

                END_TIMING(EditRecordEx_ValidateHeader);
                ulrecFound = sGH.ulRecords+1; //Increase count on append

            }
        }

        Assert(WithinSector(ulrecFound, &sGH));

        if (ulidInode >= ULID_FIRST_USER_DIR)
        {
            Assert(((LPFILERECEXT)lpSrc)->sFR.ulidShadow);
//            Assert(((LPFILERECEXT)lpSrc)->sFR.rgw83Name[0]);
            Assert(((LPFILERECEXT)lpSrc)->sFR.rgwName[0]);
        }

        // ISSUE-1/31/2000 what about existing records that expand or contract
        if((iRet = WriteRecordEx(hf, &sGH, ulrecFound, lpSrc, TRUE))<=0)
        {
            RecordKdPrint(BADERRORS,("EditRecord:Update failed \r\n"));
            goto bailout;
        }

        // Increase record count only if appending
        if (ulrecFound == sGH.ulRecords+1)
        {
            sGH.ulRecords += iRet;
            iRet = WriteHeaderEx(hf, (LPVOID)&sGH, sizeof(sGH), TRUE);
        }

#ifdef DEBUG
        if ((ulidInode == ULID_PQ)&&(uOp == CREATE_REC))
        {
            // while createing an inode
            Assert(!((LPQREC)lpSrc)->ulrecPrev);
            Assert(!((LPQREC)lpSrc)->ulrecNext);
            Assert((((LPQHEADER)&sGH))->ulrecTail != ulrecFound);
        }
#endif
    }
    break;
    case ALLOC_REC:
    {
        Assert(!ulrecFound);

        Assert(!((ulidInode == ULID_PQ) && ulrecHole && cntInodeTransactions));

        // there is a hole and it is big enough and sector aligned
        if (ulrecHole && (cMaxHoles > OvfCount(lpSrc)) && WithinSector(ulrecHole, &sGH))
        {
            ulrecFound = ulrecHole;
            iRet = 1;
        }
        else
        {
            if(!ExtendFileSectorAligned(hf, (LPGENERICREC)lpReadBuff, &sGH))
            {
                RecordKdPrint(BADERRORS,("EditRecord:filextend failed \r\n"));
                goto bailout;
            }

            ulrecFound = sGH.ulRecords+1; //Increase count on append


            if((iRet = WriteRecordEx(hf, &sGH, ulrecFound, lpSrc, TRUE))<=0)
                goto bailout;
            sGH.ulRecords += iRet;
            iRet = WriteHeaderEx(hf, (LPVOID)&sGH, sizeof(sGH), TRUE);
            // Now we have a hole for this record
        }

#ifdef DEBUG
        if (ulidInode == ULID_PQ)
        {
            Assert(((LPQHEADER)&sGH)->ulrecTail != ulrecFound);
        }
#endif
        Assert(ulrecFound && WithinSector(ulrecFound, &sGH));
    }
    break;
    default:
        RecordKdPrint(ALWAYS,("EditRecord: Invalid Opcode \r\n"));
    }

    END_TIMING(EditRecordEx_Data);

bailout:
    if (hf && !fCached)
    {
        CloseFileLocal(hf);
    }
    else
    {
        Assert(!hf || !vfStopHandleCaching);
    }
    END_TIMING(EditRecordEx);

    UnUseCommonBuff();

    return ((iRet > 0)? ulrecFound : 0L);
}


BOOL
InsertInHandleCache(
    ULONG   ulidShadow,
    CSCHFILE   hf
)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (InsertInHandleCacheEx(ulidShadow,  hf, ACCESS_READWRITE));
}

BOOL
InsertInHandleCacheEx(
    ULONG   ulidShadow,
    CSCHFILE   hf,
    ULONG   ulOpenMode
)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int i, indx = -1;
    _FILETIME ft;

    Assert(ulidShadow && hf);

    IncrementFileTime(&ftHandleCacheCurTime);

    ft.dwHighDateTime = ft.dwLowDateTime = 0xffffffff;

    for (i=0; i<HANDLE_CACHE_SIZE; ++i)
    {
        if (rgHandleCache[i].ulidShadow == ULID_SHARE)
        {
            // ACHTUNG very sensitive fix. avoids us from getting into a deadlock
            // on FAT by keeping the handle for list of shares cached at all times
            // So we don't have to open the file ever, so we don't have to take the VCB

            continue;
        }
        if (!rgHandleCache[i].ulidShadow)
        {
            indx = i;
            break;
        }
        else if (CompareTimes(rgHandleCache[i].ft, ft) <= 0)
        {
            indx = i;   // LRU so far
            ft = rgHandleCache[i].ft;   // the time corresponding to LRU
        }
    }


    Assert( (indx>=0)&&(indx <HANDLE_CACHE_SIZE)  );

    if (rgHandleCache[indx].ulidShadow)
    {
        RecordKdPrint(PQ,("InsertInHandleCache: Evicting %x for %x\r\n", rgHandleCache[indx].ulidShadow, ulidShadow));
        Assert(rgHandleCache[indx].hf);
        CloseFileLocalFromHandleCache(rgHandleCache[indx].hf);
    }
    else
    {
        RecordKdPrint(PQ,("InsertInHandleCache: Inserted new entry for %x\r\n", ulidShadow));

    }

    rgHandleCache[indx].ulidShadow = ulidShadow;
    rgHandleCache[indx].hf = hf;
    rgHandleCache[indx].ulOpenMode = ulOpenMode;

    rgHandleCache[indx].ft = ftHandleCacheCurTime;

    return TRUE;

}

BOOL
DeleteFromHandleCache(
    ULONG   ulidShadow
)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (DeleteFromHandleCacheEx(ulidShadow, ACCESS_READWRITE));
}

BOOL
DeleteFromHandleCacheEx(
    ULONG   ulidShadow,
    ULONG   ulOpenMode
)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int i;
    CSCHFILE hf;

    if (ulidShadow != INVALID_SHADOW)
    {
        if (FindHandleFromHandleCacheInternal(ulidShadow, ulOpenMode, &hf, &i))
        {
            CloseFileLocalFromHandleCache(rgHandleCache[i].hf);
            memset(&rgHandleCache[i], 0, sizeof(HANDLE_CACHE_ENTRY));
            return TRUE;
        }
    }
    else
    {
        for (i=0; i<HANDLE_CACHE_SIZE; ++i)
        {
            if (rgHandleCache[i].ulidShadow)
            {
                Assert(rgHandleCache[i].hf);
                CloseFileLocalFromHandleCache(rgHandleCache[i].hf);
                memset(&rgHandleCache[i], 0, sizeof(HANDLE_CACHE_ENTRY));
            }
        }
    }
    return FALSE;

}

BOOLEAN
IsHandleCachedForRecordmanager(
   CSCHFILE hFile
   )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int i;

    for (i=0; i<HANDLE_CACHE_SIZE; ++i)
    {
        if (rgHandleCache[i].ulidShadow &&
            rgHandleCache[i].hf &&
            (rgHandleCache[i].hf == hFile))
        {
            return TRUE;
        }
    }

    return FALSE;

}

BOOL FindHandleFromHandleCache(
    ULONG   ulidShadow,
    CSCHFILE   *lphf)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int i;

    if (FindHandleFromHandleCacheInternal(ulidShadow, ACCESS_READWRITE, lphf, &i))
    {
        IncrementFileTime(&ftHandleCacheCurTime);
        rgHandleCache[i].ft = ftHandleCacheCurTime;
        return TRUE;
    }
    return FALSE;
}

BOOL FindHandleFromHandleCacheEx(
    ULONG   ulidShadow,
    ULONG   ulOpenMode,
    CSCHFILE   *lphf
    )
{
    int i;

    if (FindHandleFromHandleCacheInternal(ulidShadow, ulOpenMode, lphf, &i))
    {
        IncrementFileTime(&ftHandleCacheCurTime);

        rgHandleCache[i].ft = ftHandleCacheCurTime;

        Assert(rgHandleCache[i].ulOpenMode == ulOpenMode);
        return TRUE;
    }

    return FALSE;
}

BOOL
FindHandleFromHandleCacheInternal(
    ULONG   ulidShadow,
    ULONG   ulOpenMode,
    CSCHFILE   *lphf,
    int     *lpIndx)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int i;

    for (i=0; i<HANDLE_CACHE_SIZE; ++i)
    {
        if (    rgHandleCache[i].ulidShadow &&
                (rgHandleCache[i].ulidShadow == ulidShadow) &&
                (rgHandleCache[i].ulOpenMode == ulOpenMode)
                )
        {
            Assert(rgHandleCache[i].hf);
            *lphf = rgHandleCache[i].hf;
            *lpIndx = i;
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
WithinSector(
    ULONG   ulRec,
    LPGENERICHEADER lpGH
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG ulStart, ulEnd;

    ulStart = lpGH->lFirstRec + (long)(ulRec-1) * lpGH->uRecSize;

    ulEnd = ulStart + lpGH->uRecSize -1;

    return ((ulStart/BYTES_PER_SECTOR) == (ulEnd/BYTES_PER_SECTOR));
    return TRUE;
}

BOOL
ExtendFileSectorAligned(
    CSCHFILE           hf,
    LPGENERICREC    lpDst,
    LPGENERICHEADER lpGH
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;
    // if the record to be appended is not aligned on a sector
    // we need to write a hole there and make corresponding adjustments
    // in the header

    if (!WithinSector(lpGH->ulRecords+1, lpGH))
    {
        ((LPGENERICREC)((LPBYTE)lpDst))->uchType = REC_EMPTY;

        ClearOvfCount(lpDst);

        if((iRet = WriteRecordEx(hf, lpGH, lpGH->ulRecords+1, lpDst, TRUE))<=0)
        {
            return (FALSE);
        }

        Assert(iRet == 1);

        lpGH->ulRecords++;
    }
    return (TRUE);
}


BOOL
ValidateGenericHeader(
    LPGENERICHEADER    lpGH
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    BOOL fRet = FALSE;

    if (lpGH->ulVersion != CSC_DATABASE_VERSION)
    {
        RecordKdPrint(BADERRORS,("EditRecord: %x, incorrect version #%x\r\n", lpGH->ulVersion));
        goto bailout;

    }
    if (!lpGH->uRecSize)
    {
        goto bailout;
    }

    fRet = TRUE;

bailout:
    return fRet;
}

BOOL
ReorderQ(
    LPVOID  lpdbID
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    BOOL fRet = FALSE;
    LPTSTR  lpszName;
    QHEADER     sQH;
    QREC        sQR;
    unsigned    ulrecCur;
    CSCHFILE   hf = CSCHFILE_NULL;

    // keep count of how many times we tried reordering
    ++cntReorderQ;

    lpszName = FormNameString(lpdbID, ULID_PQ);

    if (!lpszName)
    {
        return FALSE;
    }

    hf = OpenFileLocal(lpszName);

    if (!hf)
    {
        RecordKdPrint(BADERRORS,("ReorderQ: %s FileOpen Error\r\n", lpszName));
        goto bailout;
    }

    if (ReadHeader(hf, (LPGENERICHEADER)&sQH, sizeof(QHEADER)) < 0)
    {
        RecordKdPrint(BADERRORS,("ReorderQ: %s  couldn't read the header\r\n", lpszName));
        goto bailout;
    }

    sQH.ulrecHead = sQH.ulrecTail = 0;


    // just read till you get an error
    // NB we know that there are no overflow records
    // hence we can do ulrecCur++ in the for loop below

    for (ulrecCur=1; TRUE; ulrecCur++)
    {
        if(ReadRecord(hf, (LPGENERICHEADER)&sQH, ulrecCur, (LPGENERICREC)&sQR) < 0)
        {
            break;
        }

        if (sQR.uchType == REC_DATA)
        {

            // in aid of performance, let us just put them together quickly,
            // files at the top of the queue while directories at the bottom

            if (IsLeaf(sQR.ulidShadow))
            {
                sQR.ulrecPrev = 0;              // no predecessor
                sQR.ulrecNext = sQH.ulrecHead;  // the current head as the successor
                sQH.ulrecHead = ulrecCur;       // we at the head
                sQR.uchRefPri = MAX_PRI;
            }
            else
            {
                sQR.ulrecNext = 0;              // no successor
                sQR.ulrecPrev = sQH.ulrecTail;  // current tail as the predecessor
                sQH.ulrecTail = ulrecCur;        // we at the tail
                sQR.uchRefPri = MIN_PRI;
            }

            if(WriteRecord(hf, (LPGENERICHEADER)&sQH, ulrecCur, (LPGENERICREC)&sQR) < 0)
            {
                RecordKdPrint(BADERRORS,("ReorderQ: WriteQRecord Failed\r\n"));
                goto bailout;
            }

            // NB!!! we will write the header out only at the end
        }

    }

    sQH.ulRecords = ulrecCur - 1;

    if (WriteHeader(hf, (LPGENERICHEADER)&sQH, sizeof(QHEADER)) < 0)
    {
        RecordKdPrint(BADERRORS,("ReorderQ: %s  couldn't write the header\r\n", lpszName));
        goto bailout;
    }

    fRet = TRUE;

bailout:

    if (hf)
    {
        CloseFileLocal(hf);
    }

    FreeNameString(lpszName);

    return (fRet);

}

CSCHFILE
OpenInodeFileAndCacheHandle(
    LPVOID  lpdbID,
    ULONG   ulidInode,
    ULONG   ulOpenMode,
    BOOL    *lpfCached
)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR lpFile = NULL;
    CSCHFILE hf = CSCHFILE_NULL;
    
    *lpfCached = FALSE;

    if (!FindHandleFromHandleCacheEx(ulidInode, ulOpenMode, &hf))
    {

        lpFile = FormNameString(lpdbID,  ulidInode);

        if (!lpFile)
        {
            if (!lpdbID)
            {
                RecordKdPrint(INIT,("OpenInodeFileAndCacheHandle: database uninitialized \r\n"));
            }
            else
            {
                RecordKdPrint(BADERRORS,("OpenInodeFileAndCacheHandle: memory allocation failed\r\n"));
            }
            return 0L;
        }

        hf = R0OpenFileEx((USHORT)ulOpenMode, ACTION_OPENEXISTING, FILE_ATTRIBUTE_NORMAL, lpFile, TRUE);

        FreeNameString(lpFile);


        if (!hf)
        {
            RecordKdPrint(BADERRORS,("OpenInodeFileAndCacheHandle: Failed to open file for %x \r\n", ulidInode));
            return 0L;
        }

        if (!vfStopHandleCaching)
        {
            InsertInHandleCacheEx(ulidInode, hf, ulOpenMode);
            *lpfCached = TRUE;
        }

    }
    else
    {
        *lpfCached = TRUE;
    }

    return hf;

}

BOOL
EnableHandleCachingInodeFile(
    BOOL    fEnable
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    BOOL    fOldState = vfStopHandleCaching;

    if (!fEnable)
    {
        if (vfStopHandleCaching == FALSE)
        {
            DeleteFromHandleCache(INVALID_SHADOW);
            vfStopHandleCaching = TRUE;
        }
    }
    else
    {
        vfStopHandleCaching = FALSE;
    }

    return fOldState;
}

int RealOverflowCount(
    LPGENERICREC    lpGR,
    LPGENERICHEADER lpGH,
    int             cntMaxRec
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int i = OvfCount(lpGR)+1;
    LPGENERICREC lpGRT = lpGR;
    char chType;

    cntMaxRec = min(cntMaxRec, i);

    Assert((lpGR->uchType == REC_DATA) || (lpGR->uchType == REC_EMPTY));

    chType = (lpGR->uchType == REC_DATA)?REC_OVERFLOW:REC_EMPTY;

    for (i=1; i<cntMaxRec; ++i)
    {
        lpGRT = (LPGENERICREC)((LPBYTE)lpGRT + lpGH->uRecSize);

        if (lpGRT->uchType != chType)
        {
            break;
        }

    }

    return (i-1);
}

#if defined(BITCOPY)
int
PUBLIC CopyFileLocalDefaultStream(
#else
int
PUBLIC CopyFileLocal(
#endif // defined(BITCOPY)
    LPVOID  lpdbShadow,
    ULONG   ulidFrom,
    LPSTR   lpszNameTo,
    ULONG   ulAttrib
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR   lpszNameFrom=NULL;
    int iRet=-1;
    LPBYTE  lpBuff = (LPBYTE)lpReadBuff;

    CSCHFILE hfSrc= CSCHFILE_NULL;
    CSCHFILE hfDst= CSCHFILE_NULL;
    ULONG pos;

    UseCommonBuff();

    lpszNameFrom = FormNameString(lpdbShadow, ulidFrom);

    if (!lpszNameFrom)
    {
        goto bailout;
    }

    if (!(hfSrc = OpenFileLocal(lpszNameFrom)))
    {
        RecordKdPrint(BADERRORS,("CopyFileLocal: Can't open %s\r\n", lpszNameFrom));
        goto bailout;
    }
#ifdef CSC_RECORDMANAGER_WINNT

    memcpy(lpReadBuff, NT_DB_PREFIX, sizeof(NT_DB_PREFIX)-1);
    strcpy(lpReadBuff+sizeof(NT_DB_PREFIX)-1, lpszNameTo);

    // if the file exists it will get truncated
    if ( !(hfDst = R0OpenFileEx(ACCESS_READWRITE,
                                ACTION_CREATEALWAYS,
                                ulAttrib,
                                lpReadBuff,
                                FLAG_CREATE_OSLAYER_ALL_ACCESS
                                )))
    {
        RecordKdPrint(BADERRORS,("CopyFile: Can't create %s\r\n", lpReadBuff));
        goto bailout;
    }
#else
    // If the original file existed it would be truncated
    strcpy(lpReadBuff, lpszNameTo);
    if ( !(hfDst = R0OpenFile(ACCESS_READWRITE, ACTION_CREATEALWAYS, lpReadBuff)))
    {
        RecordKdPrint(BADERRORS,("CopyFile: Can't create %s\r\n", lpszNameTo));
        goto bailout;
    }
#endif

    RecordKdPrint(COPYLOCAL,("Copying...\r\n"));

    pos = 0;
    // Both the files are correctly positioned
    while ((iRet = ReadFileLocal(hfSrc, pos, lpBuff, COMMON_BUFF_SIZE))>0)
    {
        if (WriteFileLocal(hfDst, pos, lpBuff, iRet) < 0)
        {
            RecordKdPrint(BADERRORS,("CopyFile: Write Error\r\n"));
            goto bailout;
        }
        pos += iRet;
    }

    RecordKdPrint(COPYLOCAL,("Copy Complete\r\n"));

    iRet = 1;
bailout:
    if (hfSrc)
    {
        CloseFileLocal(hfSrc);
    }
    if (hfDst)
    {
        CloseFileLocal(hfDst);
    }
    if ((iRet==-1) && hfDst)
    {
#ifdef CSC_RECORDMANAGER_WINNT
        memcpy(lpReadBuff, NT_DB_PREFIX, sizeof(NT_DB_PREFIX)-1);
        strcpy(lpReadBuff+sizeof(NT_DB_PREFIX)-1, lpszNameTo);
        DeleteFileLocal(lpReadBuff, ATTRIB_DEL_ANY);
#else
        DeleteFileLocal(lpszNameTo, ATTRIB_DEL_ANY);
#endif
    }
    FreeNameString(lpszNameFrom);
    UnUseCommonBuff();

    return iRet;
}


#if defined(BITCOPY)
int
PUBLIC CopyFileLocalCscBmp(
    LPVOID  lpdbShadow,
    ULONG   ulidFrom,
    LPSTR   lpszNameTo,
    ULONG   ulAttrib
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR   lpszNameCscBmpFrom = NULL;
    int iRet=-1;
    LPBYTE  lpBuff = (LPBYTE)lpReadBuff;

    CSCHFILE hfSrc= CSCHFILE_NULL;
    CSCHFILE hfDst= CSCHFILE_NULL;
    ULONG pos;

    UseCommonBuff();

    lpszNameCscBmpFrom = FormAppendNameString(lpdbShadow,
                          ulidFrom,
                          CscBmpAltStrmName);
    RecordKdPrint(COPYLOCAL, ("Trying to copy bitmap %s\n"));

    if (!lpszNameCscBmpFrom)
    {
        goto bailout;
    }

    if (!(hfSrc = OpenFileLocal(lpszNameCscBmpFrom)))
    {
        RecordKdPrint(COPYLOCAL,
  ("CopyFileLocalCscBmp: bitmap file %s does not exist or error opening.\r\n",
       lpszNameCscBmpFrom));
        goto bailout;
    }
#ifdef CSC_RECORDMANAGER_WINNT

    memcpy(lpReadBuff, NT_DB_PREFIX, sizeof(NT_DB_PREFIX)-1);
    strcpy(lpReadBuff+sizeof(NT_DB_PREFIX)-1, lpszNameTo);
    strcat(lpReadBuff, CscBmpAltStrmName);

    // if the file exists it will get truncated
    if ( !(hfDst = R0OpenFileEx(ACCESS_READWRITE,
                                ACTION_CREATEALWAYS,
                                ulAttrib,
                                lpReadBuff,
                                FLAG_CREATE_OSLAYER_ALL_ACCESS
                                )))
    {
        RecordKdPrint(BADERRORS,
         ("CopyFileLocalCscBmp: Can't create %s\r\n", lpReadBuff));
        goto bailout;
    }
#else
    // If the original file existed it would be truncated
    strcpy(lpReadBuff, lpszNameTo);
    strcat(lpReadBuff, CscBmpAltStrmName);
    if ( !(hfDst = R0OpenFile(ACCESS_READWRITE, ACTION_CREATEALWAYS, lpReadBuff)))
    {
        RecordKdPrint(BADERRORS,
      ("CopyFileLocalCscBmp: Can't create %s\r\n", lpszNameTo));
        goto bailout;
    }
#endif

    RecordKdPrint(COPYLOCAL,("Copying bitmap...\r\n"));

    pos = 0;
    // Both the files are correctly positioned
    while ((iRet = ReadFileLocal(hfSrc, pos, lpBuff, COMMON_BUFF_SIZE))>0)
    {
        if (WriteFileLocal(hfDst, pos, lpBuff, iRet) < 0)
        {
            RecordKdPrint(BADERRORS,
          ("CopyFileLocalCscBmp: Write Error\r\n"));
            goto bailout;
        }
        pos += iRet;
    }

    RecordKdPrint(COPYLOCAL,("CopyFileLocalCscBmp Complete\r\n"));

    iRet = 1;
bailout:
    if (hfSrc)
    {
        CloseFileLocal(hfSrc);
    }
    if (hfDst)
    {
        CloseFileLocal(hfDst);
    }
    if ((iRet==-1) && hfDst)
    {
#ifdef CSC_RECORDMANAGER_WINNT
        memcpy(lpReadBuff, NT_DB_PREFIX, sizeof(NT_DB_PREFIX)-1);
        strcpy(lpReadBuff+sizeof(NT_DB_PREFIX)-1, lpszNameTo);
        strcat(lpReadBuff, CscBmpAltStrmName);
        DeleteFileLocal(lpReadBuff, ATTRIB_DEL_ANY);
#else
    strcpy(lpReadBuff, lpszNameTo);
    strcat(lpReadBuff, CscBmpAltStrmName);
        DeleteFileLocal(lpReadBuff, ATTRIB_DEL_ANY);
#endif
    }
    FreeNameString(lpszNameCscBmpFrom);
    UnUseCommonBuff();

    return iRet;
}

int
PUBLIC CopyFileLocal(
    LPVOID  lpdbShadow,
    ULONG   ulidFrom,
    LPSTR   lpszNameTo,
    ULONG   ulAttrib
    )
/*++

Routine Description:

  The original CopyFileLocal is renamed CopyFileLocalDefaultStream.
  The new CopyFileLocal calls CopyFileLocalDefaultStream and
      dir
CopyFileLocalCscBmp.

Parameters:

Return Value:

Notes:


--*/
{
  int ret;

  ret = CopyFileLocalDefaultStream(lpdbShadow, ulidFrom, lpszNameTo, ulAttrib);

  // Don't care if be able to copy bitmap or not. Reint will copy whole file
  // back to share if bitmap does not exist.
  CopyFileLocalCscBmp(lpdbShadow, ulidFrom, lpszNameTo, ulAttrib);
  
  return ret;
}
#endif // defined(BITCOPY)


int
RecreateInode(
    LPTSTR  lpdbID,
    HSHADOW hShadow,
    ULONG   ulAttribIn
    )
/*++

Routine Description:

    This routine recreates an inode data file. This is so that when the CSC directory is
    marked for encryption, the newly created inode file will get encrypted.

Arguments:

    hDir        Inode directory

    hShadow     Inode whosw file needs to be recreated

    ulAttribIn  Recreate with the given attributes

Return Value:


--*/
{
    LPSTR   lpszTempFileName=NULL;
    int     iRet = -1;
    ULONG   ulAttributes;

    // do this only for files
    if (IsLeaf(hShadow))
    {
        if(lpszTempFileName = FormNameString(lpdbID, hShadow))
        {
            if(GetAttributesLocal(lpszTempFileName, &ulAttributes)>=0)
            {
                // For now special case it for encryption SPP
                
                if (!((!ulAttribIn && (ulAttributes & FILE_ATTRIBUTE_ENCRYPTED))||
                    (ulAttribIn && !(ulAttributes & FILE_ATTRIBUTE_ENCRYPTED))))
                {
                    iRet = 0;
                    goto FINALLY;
                }
            }

            FreeNameString(lpszTempFileName);
            lpszTempFileName = NULL;
        }
        

        // makeup a temporary name
        if(lpszTempFileName = FormNameString(lpdbID, ULID_TEMP1))
        {
            // we delete the original so that if we are doing
            // encrypting/decrypting, a new file will get created which will
            // get encrypted or decrypted
            if(DeleteFileLocal(lpszTempFileName, ATTRIB_DEL_ANY) < 0)
            {
                if (GetLastErrorLocal() != ERROR_FILE_NOT_FOUND)
                {
                    iRet = -1;
                    goto FINALLY;
                }
            }
        
            // make a new copy the file represented by the hShadow with the temp name
            if (CopyFileLocal(lpdbID, hShadow, lpszTempFileName+sizeof(NT_DB_PREFIX)-1, ulAttribIn) >= 0)
            {
                // rename the original to another temp name
                if (RenameInode(lpdbID, hShadow, ULID_TEMP2)>=0)
                {
                    // rename the copy to the origianl name
                    if (RenameInode(lpdbID, ULID_TEMP1, hShadow)>=0)
                    {
                        iRet = 0;
                    }
                    else
                    {
                        // if failed, try to restore it back.
                        RenameInode(lpdbID, ULID_TEMP2, hShadow);
                    }
                }

                if (iRet == -1)
                {
                    DeleteFileLocal(lpszTempFileName, ATTRIB_DEL_ANY);
                }
            }

        }
    }
FINALLY:
    if (lpszTempFileName)
    {
        FreeNameString(lpszTempFileName);
    }
    return iRet;
}

int RenameInode(
    LPTSTR  lpdbID,
    ULONG   ulidFrom,
    ULONG   ulidTo
    )
/*++

Routine Description:

    This routine renames an inode file to another inode file

Arguments:

    lpdbID  which database

    ulidFrom

    ulidTo

Return Value:


--*/
{
    LPSTR   lpszNameFrom=NULL, lpszNameTo=NULL;
    int iRet=-1;

    lpszNameFrom = FormNameString(lpdbID, ulidFrom);
    lpszNameTo = FormNameString(lpdbID, ulidTo);

    if (lpszNameFrom && lpszNameTo)
    {
        iRet = RenameFileLocal(lpszNameFrom, lpszNameTo);
    }

    FreeNameString(lpszNameFrom);
    FreeNameString(lpszNameTo);

    return (iRet);
}


ULONG
GetCSCDatabaseErrorFlags(
    VOID
    )
/*++

Routine Description:

    returns in memory error flags if any detected so far
    
Arguments:

    None

Return Value:

    error flags

--*/
{
    return ulErrorFlags;
}

#ifdef CSC_RECORDMANAGER_WINNT

BOOL
FindCreateDBDirEx(
    LPSTR   lpszShadowDir,
    BOOL    fCleanup,
    BOOL    *lpfCreated,
    BOOL    *lpfIncorrectSubdirs
    )
/*++

Routine Description:


Parameters:

Return Value:

Notes:

--*/
{
    DWORD   dwAttr;
    BOOL    fRet = FALSE;
    int i;
    UINT lenDir;


    UseCommonBuff();

    *lpfIncorrectSubdirs = *lpfCreated = FALSE;

    RecordKdPrint(INIT, ("InbCreateDir: looking for %s \r\n", lpszShadowDir));

    if ((GetAttributesLocalEx(lpszShadowDir, FALSE, &dwAttr)) == 0xffffffff)
    {
        RecordKdPrint(BADERRORS, ("InbCreateDir: didnt' find the CSC directory trying to create one \r\n"));
        if(CreateDirectoryLocal(lpszShadowDir)>=0)
        {
            *lpfCreated = TRUE;
        }
        else
        {
            goto bailout;
        }
    }
    else
    {
        if (dwAttr & FILE_ATTRIBUTE_DIRECTORY)
        {
            if (fCleanup && !DeleteDirectoryFiles(lpszShadowDir))
            {
                goto bailout;
            }
        }
        else
        {
            goto bailout;
        }
    }

    strcpy(lpReadBuff, lpszShadowDir);

    lenDir = strlen(lpReadBuff);
    lpReadBuff[lenDir++] = '\\';
    lpReadBuff[lenDir++] = CSCDbSubdirFirstChar();
    lpReadBuff[lenDir++] = '1';
    lpReadBuff[lenDir] = 0;

    for (i=0; i<CSCDB_SUBDIR_COUNT; ++i)
    {
        if ((GetAttributesLocalEx(lpReadBuff, FALSE, &dwAttr)) == 0xffffffff)
        {
            *lpfIncorrectSubdirs = TRUE;
            RecordKdPrint(BADERRORS, ("InbCreateDir: didnt' find the CSC directory trying to create one \r\n"));
            if(CreateDirectoryLocal(lpReadBuff) < 0)
            {
                goto bailout;
            }
        }
        else
        {
            if (!(dwAttr & FILE_ATTRIBUTE_DIRECTORY))
            {
                break;
            }
            if (fCleanup && !DeleteDirectoryFiles(lpReadBuff))
            {
                goto bailout;
            }
        }

        lpReadBuff[lenDir-1]++;
    }

    fRet = TRUE;

bailout:

    UnUseCommonBuff();

    return (fRet);
}

BOOL
FindCreateDBDir(
    LPSTR   lpszShadowDir,
    BOOL    fCleanup,    // empty the directory if found
    BOOL    *lpfCreated
    )
/*++

Routine Description:


Parameters:

Return Value:

Notes:

--*/
{
    BOOL    fIncorrectSubdirs = FALSE, fRet;

    if (fRet = FindCreateDBDirEx(lpszShadowDir, fCleanup, lpfCreated, &fIncorrectSubdirs))
    {
        // if the root directory wasn't created and there are incorrect subdirs
        // then we need to recreate the database.

        if (!*lpfCreated && fIncorrectSubdirs)
        {
            fRet = FindCreateDBDirEx(lpszShadowDir, TRUE, lpfCreated, &fIncorrectSubdirs);
        }
    }
    return fRet;
}
#endif

#if defined(REMOTE_BOOT)
int
GetCSCFileNameFromUNCPathCallback(
    USHORT  *lpuPath,
    USHORT  *lpuLastElement,
    LPVOID  lpCookie
    )
/*++

Routine Description:

    This is the callback function for GetCSCFileNameFromUNCPath (see below)

Parameters:

Return Value:

Notes:

--*/
{
    SHADOWINFO *lpSI = (SHADOWINFO *)lpCookie;

    if (!lpSI->hDir)
    {
        RecordKdPrint(ALWAYS, ("getting inode for %ls path is %ls\r\n", lpuLastElement, lpuPath));
        if (!FindShareRecord(vlpszShadowDir, lpuLastElement, (LPSHAREREC)(lpSI->lpFind32)))
        {
            return FALSE;
        }

        lpSI->hDir =((LPSHAREREC)(lpSI->lpFind32))->ulidShadow;
    }
    else
    {
        RecordKdPrint(ALWAYS, ("getting inode for %ls path is %ls\r\n", lpuLastElement, lpuPath));

        if (!FindFileRecord(vlpszShadowDir, lpSI->hDir, lpuLastElement, (LPFILERECEXT)(lpSI->lpFind32)))
        {
            return FALSE;
        }

        // return only complete files so RB knows that it has a good local copy
        if (!(((LPFILERECEXT)(lpSI->lpFind32))->sFR.dwFileAttrib & FILE_ATTRIBUTE_DIRECTORY)) {
            if ((((LPFILERECEXT)(lpSI->lpFind32))->sFR.usStatus & SHADOW_SPARSE)) {
                // RecordKdPrint(ALWAYS, ("inode for %ls path is %ls and is marked sparse\r\n", lpuLastElement, lpuPath));
                return FALSE;
            }
        }
        lpSI->hDir = ((LPFILERECEXT)(lpSI->lpFind32))->sFR.ulidShadow;
    }

    return TRUE;
}

BOOL
GetCSCFileNameFromUNCPath(
    LPSTR   lpszDatabaseLocation,
    USHORT  *lpuPath,
    LPBYTE  lpBuff  // must be MAX_PATH
    )
/*++

Routine Description:

    This function is used by remote boot, to get the filenames for csc database files, when
    the database is not initialized, and even the drive link is also not set. The location will
    come down in the form of \\harddisk\disk0\....

Parameters:

    lpszDatabaseLocation    CSC database location in ANSI (NB!!!)

    lpuPath                 UNC path for the file whose local copy name needs to be found.
                            This is in unicode ((NB!!!)

    lpBuff                  return buffer. Must be MAX_PATH or more bytes. The returned
                            string is ANSI. (NB!!!)

Return Value:

    if TRUE, the buffer contains a null terminated string for the internal name of the given
    file/directory on the server.

Notes:

    Assumes that this is called before the database is initialized. Opens the record database,
    does the job and closes it.

--*/
{
    BOOL fRet, fNew;
    SHADOWINFO sSI;
    LPFILERECEXT lpFRExt = NULL;
    LPVOID  lpdbID = NULL;
    LPSTR   lpszName = NULL;

    if (!vlpszShadowDir)
    {
        lpdbID = OpenRecDBInternal(lpszDatabaseLocation, NULL, 0, 0, 0, FALSE, FALSE, &fNew);
    }
    else
    {
        lpdbID = vlpszShadowDir;
    }

    if (!lpdbID)
    {
        return FALSE;
    }

    lpFRExt = AllocMem(sizeof(*lpFRExt));

    if (!lpFRExt)
    {
        goto bailout;
    }

    memset(&sSI, 0, sizeof(sSI));

    sSI.lpFind32 = (LPFIND32)lpFRExt;

    RecordKdPrint(ALWAYS, ("getting inode file for %ls\r\n", lpuPath));

    fRet = IterateOnUNCPathElements(lpuPath, GetCSCFileNameFromUNCPathCallback, (LPVOID)&sSI);

    if (fRet)
    {
        RecordKdPrint(ALWAYS, ("getting file name for %xh\r\n", sSI.hDir));

        lpszName = FormNameString(lpdbID, sSI.hDir);

        if (lpszName)
        {
            strcpy(lpBuff, lpszName);

            FreeNameString(lpszName);
        }

        RecordKdPrint(ALWAYS, ("file name is %s\r\n", lpBuff));

    }
bailout:
    if (lpFRExt)
    {
        FreeMem(lpFRExt);
    }

    // CloseRecDB(lpdbID);
    return fRet;
}
#endif // defined(REMOTE_BOOT)

#if 0

BOOL
ValidateQ(
    VOID
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    QREC      sQR, sPrev, sNext;
    unsigned ulRec;
    BOOL    fRet = FALSE, fValidHead=FALSE, fValidTail=FALSE;
    LPTSTR  lpszName;
    QHEADER     sQH;
    unsigned    ulRec;
    CSCHFILE   hf = CSCHFILE_NULL;

    lpszName = FormNameString(lpdbID, ULID_PQ);

    if (!lpszName)
    {
        return FALSE;
    }

    hf = R0OpenFileEx((USHORT)ulRec, ACTION_OPENEXISTING, lpszName, TRUE);

    if (!hf)
    {
        RecordKdPrint(BADERRORS,("ReorderQ: %s FileOpen Error\r\n", lpszName));
        goto bailout;
    }

    if (ReadHeader(hf, &sQH, sizeof(QHEADER)) < 0)
    {
        RecordKdPrint(BADERRORS, ("ReorderQ: %s  couldn't read the header\r\n", lpszName));
        goto bailout;
    }


    if ((sQH.ulrecTail > sQH.ulRecods) || (sQH.ulrecHead > sQH.ulRecords))
    {
        RecordKdPrint(BADERRORS, ("Invalid head-tail pointers\r\n"));
        goto bailout;
    }

    if (!sQH.ulRecords)
    {
        fRet = TRUE;
        goto bailout;
    }

    for (ulRec = 1; ulRec <= sQH.ulRecords; ulRec++)
    {
        if (!ReadRecord(hf, (LPGENERICHEADER)&sQH, ulRec, (LPGENERICREC)&sQR))
        {
            Assert(FALSE);
            goto bailout;
        }

        if (sQR.uchType == REC_DATA)
        {

            if (sQR.ulrecNext)
            {
                if (sQR.ulrecNext > sQH.ulRecords)
                {
                    RecordKdPrint(BADERRORS, ("Invalid next pointer to %d\r\n", ulRec));
                    goto bailout;
                }

                if (!ReadRecord(hf, (LPGENERICHEADER)&sQH, sQR.ulrecNext, (LPGENERICREC)&sNext))
                {
                    goto bailout;
                }


                if (sNext.ulrecPrev != ulRec)
                {
                    RecordKdPrint(BADERRORS, ("Prev pointer of %d doesn't equal %d\r\n", sNext.ulrecPrev, ulRec));
                    goto bailout;
                }
            }
            else
            {
                if (((LPQHEADER)&(sQH))->ulrecTail != ulRec)
                {

                    RecordKdPrint(BADERRORS, ("Invalid tail pointer to %d\r\n", ulRec));
                    goto bailout;
                }

                fValidTail = TRUE;
            }

            if (sQR.ulrecPrev)
            {
                if (sQR.ulrecPrev > sQH.ulRecords)
                {
                    RecordKdPrint(BADERRORS, ("Invalid prev pointer to %d\r\n", ulRec));
                    goto bailout;
                }

                if (!ReadRecord(hf, (LPGENERICHEADER)&sQH, sQR.ulrecPrev, (LPGENERICREC)&sPrev))
                {
                    Assert(FALSE);
                    goto bailout;
                }

                if (sPrev.ulrecNext != ulRec)
                {

                    RecordKdPrint(BADERRORS, ("Next pointer of %d doesn't equal %d\r\n", sPrev.ulrecNext, ulRec));
                    goto bailout;
                }
            }
            else
            {
                if (((LPQHEADER)&(sQH))->ulrecHead != ulRec)
                {

                    RecordKdPrint(BADERRORS, ("Invalid Head pointer to %d\r\n", ulRec));
                    goto bailout;
                }

                fValidHead = TRUE;
            }
        }
    }

    if (!fValidHead || !fValidTail)
    {
        RecordKdPrint(BADERRORS, ("Head or Tail invalid \r\n"));
        goto bailout;
    }

    fRet = TRUE;

bailout:
    if (hf)
    {
        CloseFileLocal(hf);
    }

    return (fRet);
}

#endif


BOOL
CheckCSCDatabaseVersion(
    LPTSTR  lpszLocation,       // database directory
    BOOL    *lpfWasDirty
)
{

    char *lpszName = NULL;
    SHAREHEADER sSH;
    PRIQHEADER    sPQ;

    CSCHFILE hfShare = 0, hfPQ=0;
    BOOL    fOK = FALSE;
    DWORD   dwErrorShare=NO_ERROR, dwErrorPQ=NO_ERROR;

//    OutputDebugStringA("Checking version...\r\n");
    lpszName = FormNameString(lpszLocation, ULID_SHARE);

    if (!lpszName)
    {
        return FALSE;
    }

    if(!(hfShare = OpenFileLocal(lpszName)))
    {
        dwErrorShare = GetLastErrorLocal();
    }


    FreeNameString(lpszName);

    lpszName = FormNameString(lpszLocation, ULID_PQ);

    if (!lpszName)
    {
        goto bailout;
    }


    if(!(hfPQ = OpenFileLocal(lpszName)))
    {
        dwErrorPQ = GetLastErrorLocal();
    }

    FreeNameString(lpszName);
    lpszName = NULL;

    if ((dwErrorShare == NO_ERROR)&&(dwErrorPQ==NO_ERROR))
    {
        if(ReadFileLocal(hfShare, 0, &sSH, sizeof(SHAREHEADER))!=sizeof(SHAREHEADER))
        {
            //error message
            goto bailout;
        }

        if (sSH.ulVersion != CSC_DATABASE_VERSION)
        {
            goto bailout;
        }

        if(ReadFileLocal(hfPQ, 0, &sPQ, sizeof(PRIQHEADER))!=sizeof(PRIQHEADER))
        {
            //error message
            goto bailout;
        }

        if (sPQ.ulVersion != CSC_DATABASE_VERSION)
        {
            goto bailout;
        }

        fOK = TRUE;
    }
    else
    {
        if (((dwErrorShare == ERROR_FILE_NOT_FOUND)&&(dwErrorPQ==ERROR_FILE_NOT_FOUND))||
            ((dwErrorShare == ERROR_PATH_NOT_FOUND)&&(dwErrorPQ==ERROR_PATH_NOT_FOUND)))
        {
            fOK = TRUE;
        }
    }

bailout:

    if (lpszName)
    {
        FreeNameString(lpszName);
    }

    if (hfShare)
    {
        CloseFileLocal(hfShare);
    }

    if (hfPQ)
    {
        CloseFileLocal(hfPQ);
    }

    return (fOK);
}

VOID
SetCSCDatabaseErrorFlags(
    ULONG ulFlags
)
{
    ulErrorFlags |= ulFlags;
}


BOOL
EncryptDecryptDB(
    LPVOID      lpdbID,
    BOOL        fEncrypt
)
/*++

Routine Description:

    This routine traverses the priority Q and encrypts/decrypts the database

Parameters:

    lpdbID      CSC database directory
    
    fEncrypt    TRUE if we are encrypting, else decrypting

Return Value:

    TRUE if Suceeded

Notes:

    This is called if the cache was paritally encrypted/decrypted. When the database is being initialized
    we try to encrypt/decrypt the files that couldn't be processed because either they were open or some other
    error occurred.

--*/
{
    QREC      sQR, sPrev, sNext;
    BOOL    fRet = FALSE;
    LPTSTR  lpszName;
    QHEADER     sQH;
    unsigned    ulRec;
    CSCHFILE   hf = CSCHFILE_NULL;
    ULONG   cntFailed = 0;
    
    lpszName = FormNameString(lpdbID, ULID_PQ);

    if (!lpszName)
    {
        return FALSE;
    }

    hf = R0OpenFile(ACCESS_READWRITE, ACTION_OPENEXISTING, lpszName);

    if (!hf)
    {
        RecordKdPrint(BADERRORS,("ReorderQ: %s FileOpen Error\r\n", lpszName));
        goto bailout;
    }

    if (ReadHeader(hf, (LPGENERICHEADER)&sQH, sizeof(QHEADER)) < 0)
    {
        RecordKdPrint(BADERRORS, ("ReorderQ: %s  couldn't read the header\r\n", lpszName));
        goto bailout;
    }


    if (!sQH.ulRecords)
    {
        fRet = TRUE;
        goto bailout;
    }

    for (ulRec = 1; ulRec <= sQH.ulRecords; ulRec++)
    {
        if (!ReadRecord(hf, (LPGENERICHEADER)&sQH, ulRec, (LPGENERICREC)&sQR))
        {
            Assert(FALSE);
            goto bailout;
        }

        if (sQR.uchType == REC_DATA)
        {
            if (IsLeaf(sQR.ulidShadow))
            {
                if (RecreateInode(lpdbID, sQR.ulidShadow, (fEncrypt)?FILE_ATTRIBUTE_ENCRYPTED:0) < 0)
                {
                    ++cntFailed;
                }
            }
        }
    }


    if (!cntFailed)
    {
        fRet = TRUE;
    }

bailout:
    if (hf)
    {
        CloseFileLocal(hf);
    }

    return (fRet);
}

#if defined(BITCOPY)
LPVOID
PUBLIC
FormAppendNameString(
    LPTSTR      lpdbID,
    ULONG       ulidFile,
    LPTSTR      str2Append
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPTSTR lp, lpT;
    int lendbID;
    char chSubdir;
    int lenStr2Append = 0;

    if (!lpdbID)
    {
        SetLastErrorLocal(ERROR_INVALID_PARAMETER);
        return (NULL);
    }

    if (lpdbID == vlpszShadowDir)
    {
        lendbID = vlenShadowDir;
    }
    else
    {
        lendbID = strlen(lpdbID);
    }

    if (str2Append) {
      lenStr2Append = strlen(str2Append);
      lp = AllocMem(lendbID+1+INODE_STRING_LENGTH+1
            +SUBDIR_STRING_LENGTH
            +lenStr2Append+1);
    }
    else {
      lp = AllocMem(lendbID+1+INODE_STRING_LENGTH+1 +SUBDIR_STRING_LENGTH+1);
    }

    if (!lp)
    {
        return NULL;
    }

    memcpy(lp, lpdbID, lendbID);


    // Bump the pointer appropriately
    lpT = lp+lendbID;

    if (*(lpT-1)!= '\\')
    {
        *lpT++ = '\\';
    }

    chSubdir = CSCDbSubdirSecondChar(ulidFile);

    // sprinkle the user files in one of the subdirectories
    if (chSubdir)
    {
        // now append the subdirectory

        *lpT++ = CSCDbSubdirFirstChar();
        *lpT++ = chSubdir;
        *lpT++ = '\\';
    }

    HexToA(ulidFile, lpT, 8);

    lpT += 8;

    if (str2Append) {
      memcpy(lpT, str2Append, lenStr2Append);
      lpT += lenStr2Append;
    }
    *lpT = 0;

    return(lp);
}


int
DeleteStream(
    LPTSTR      lpdbID,
    ULONG       ulidFile,
    LPTSTR      str2Append
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPVOID  lpStrmName;
    int iRet = SRET_OK;
    CSCHFILE    hf;
        
    if (!fSupportsStreams)
    {
        return SRET_OK;
    }
    
    lpStrmName = FormAppendNameString(lpdbID, ulidFile, str2Append);
    
    if (lpStrmName)
    {
        if(DeleteFileLocal(lpStrmName, 0) < 0)
        {
            if (GetLastErrorLocal() != ERROR_FILE_NOT_FOUND)
            {
                iRet = SRET_ERROR;
            }
        }
        FreeNameString(lpStrmName);
    }
    else
    {
        SetLastErrorLocal(ERROR_NO_SYSTEM_RESOURCES);
        iRet = SRET_ERROR;
    }
    
    return (iRet);    
}

#endif // defined(BITCOPY)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\recchk.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    recchk.c

Abstract:

    This file implements the record database checking code. There are two types of
    persistent data structures, the priority Q (or our version of Master FIle Table)
    and the hierarchy of files and directories that starts with the superroot which
    contains all the shares connected to. The truth is considered to be in the
    hierarchy. The Priority Q is supposed to mirror some critical data from the
    hierarchy. When fixing the database, we traverse the hierarchy
    recursively and build an in memory PQ.  We then write that out as the new PQ.

    This file gets linked in the usermode and in the kernlemode so that for NT this
    can execute in kernel mode while for win9x it can execute in usermode

Author:

     Shishir Pardikar      [Shishirp]        10-30-1997

Revision History:

    split up from usermode.

--*/
#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

#include "record.h"
#include "string.h"
#include "stdlib.h"

// Record Buffer Array (RBA). This holds an entire inode file in memory
// It is made up of pointers to 1 or more Record Buffer Entries (RBE).
// Each RBE is a chunk of memory that holds an integral number of records from
// the file represented by ulidShadow entry in the structure


typedef struct tagRBA
{
    unsigned        ulErrorFlags;
    unsigned        ulidShadow;                 // Inode which is represented by this structure
    GENERICHEADER   sGH;                        // it's header
    CSCHFILE           hf;                         // open handle to the file
    DWORD           cntRBE;                     // count of buffer entries in the array
    DWORD           cntRecsPerRBE;              // #of records per buffer entry
    DWORD           cbRBE;                      // size in bytes of each buffer entry
    LPBYTE          rgRBE[];                    // Record Buffer Entry (RBE) array
}
RBA, *LPRBA;    // stands for RecordBuffArray

#define RBA_ERROR_INVALID_HEADER            0x00000001
#define RAB_ERROR_INVALID_RECORD_COUNT      0x00000002
#define RBA_ERROR_INVALID_OVF               0x00000004
#define RBA_ERROR_INVALID_ENTRY             0x00000008
#define RBA_ERROR_MISMATCHED_SIZE           0x00000010
#define RBA_ERROR_MISALIGNED_RECORD         0x00000020
#define RBA_ERROR_INVALID_INODE             0x00000040
#define RBA_ERROR_LIMIT_EXCEEDED            0x00000080


#define MAX_RECBUFF_ENTRY_SIZE  (0x10000-0x100) // max size of an RBE
#define MAX_RBES_EXPECTED       0x30    // Max number of RBEs of the above size in an RBA

// we make provision for max possible # of RBEs, even beyond what the PQ currently
// needs. The max set here is (MAX_RBES_EXPETCED * MAX_RECBUFF_ENTRY_SIZE)
// which amounts to 48 * 65280 which is around 3M which at the current size of
// QREC will hold ~100K entries in the hierarchy. This is far more than
// the # of entries we ever expect to have in our database

// As we allocate memory only as it is needed, it would'nt be a problem to
// increase MAX_RBES_EXPECTED so it handles more inodes



typedef struct tagCSE   *LPCSE;

typedef struct tagCSE   // CSC Stack Entry
{
    LPCSE       lpcseNext;
    unsigned    ulidShare; // server
    unsigned    ulidParent; // parent of the directory
    unsigned    ulidDir;    // the directory itself
    unsigned    ulRec;
    LPRBA       lpRBA;      // the contents of ulidDir
}
CSE;

#pragma intrinsic (memcmp, memcpy, memset, strcat, strcmp, strcpy, strlen)

#ifdef DEBUG
//cshadow dbgprint interface
#define RecchkKdPrint(__bit,__x) {\
    if (((RECCHK_KDP_##__bit)==0) || FlagOn(RecchkKdPrintVector,(RECCHK_KDP_##__bit))) {\
    KdPrint (__x);\
    }\
}

#define RECCHK_KDP_ALWAYS               0x00000000
#define RECCHK_KDP_BADERRORS            0x00000001
#define RECCHK_KDP_TRAVERSE             0x00000002
#define RECCHK_KDP_PQ                   0x00000004
#define RECCHK_KDP_RBA                  0x00000008


ULONG RecchkKdPrintVector = RECCHK_KDP_BADERRORS;
#else
#define RecchkKdPrint(__bit,__x) ;
#endif

#define ValidShadowID(ulidShadow)   ((ulidShadow & ~0x80000000) >=ULID_FIRST_USER_DIR)


char vszTemp[] = "csc0.tmp";
char vszTemp1[] = "csc1.tmp";

AssertData;
AssertError;


RebuildPQInRBA(
    LPRBA   lpRBA
    );

BOOL
TraverseDirectory(
    LPVOID  lpdbID,
    unsigned    ulidShare,
    unsigned    ulidParent,
    unsigned    ulidDir,
    LPRBA       lpRBAPQ,
    BOOL        fFix
    );

BOOL
AllocateRBA(
    DWORD           cntRBE,     // count of record buffer entries
    DWORD           cbRBE,      // size of each record buffer entry
    LPRBA           *lplpRBA   // result to be returned
    );

VOID
FreeRBA(
    LPRBA  lpRBA
    );

BOOL
ReadShadowInRBA(
    LPVOID          lpdbID,
    unsigned        ulidShadow,
    DWORD           cbMaxRBE,       // max size of an RBE
    DWORD           cntRBE,         // # of RBEs to be allocated, calculated if 0
    LPRBA           *lplpRBA
    );

BOOL
WriteRBA(
    LPVOID  lpdbID,
    LPRBA   lpRBA,
    LPSTR   lpszFileName
    );

LPVOID
GetRecordPointerFromRBA(
    LPRBA           lpRBA,
    unsigned        ulRec
    );

BOOL
ReadRecordFromRBA(
    LPRBA           lpRBA,
    unsigned        ulRec,
    LPGENERICREC    lpGH
    );

BOOL
WriteRecordToRBA(
    LPRBA           lpRBA,
    unsigned        ulRec,
    LPGENERICREC    lpGH,
    BOOL            fOverwrite,
    LPDWORD         lpdwError
    );


BOOL
FillupRBAUptoThisRBE(
    LPRBA   lpRBA,
    DWORD   indxRBE
    );

VOID
InitializeRBE(
    LPRBA   lpRBA,
    DWORD   indxRBE
    );

BOOL
InsertRBAPQEntryFile(
    LPRBA       lpRBAPQ,
    LPQREC      lpPQDst,
    unsigned    ulrecDst
    );

BOOL
InsertRBAPQEntryDir(
    LPRBA       lpRBAPQ,
    LPQREC      lpPQDst,
    unsigned    ulrecDst
    );

BOOL
ValidateQrecFromFilerec(
    unsigned        ulidShare,
    unsigned        ulidDir,
    LPFILERECEXT    lpFR,
    LPQREC          lpQR,
    unsigned        ulrecDirEntry
    );

BOOL
TraversePQ(
    LPVOID      lpdbID
    )
/*++

Routine Description:

    This routine traverses the priority Q and verifies the consistency of the Q by verifying
    that the backward and the forward pointers are pointing correctly

Parameters:

    lpdbID  CSC database directory

Return Value:

Notes:


--*/
{
    QREC      sQR, sPrev, sNext;
    unsigned ulRec;
    BOOL    fRet = FALSE, fValidHead=FALSE, fValidTail=FALSE;
    LPRBA   lpRBA = NULL;

    if (!ReadShadowInRBA(lpdbID, ULID_PQ, MAX_RECBUFF_ENTRY_SIZE, 0, &lpRBA))
    {
        RecchkKdPrint(BADERRORS, ("TraversePQ: Failed to read PQ in memory\r\n"));
        goto bailout;
    }

    if ((((LPQHEADER)&(lpRBA->sGH))->ulrecTail > lpRBA->sGH.ulRecords) ||
        (((LPQHEADER)&(lpRBA->sGH))->ulrecHead > lpRBA->sGH.ulRecords))
    {
        RecchkKdPrint(BADERRORS, ("Invalid head-tail pointers\r\n"));
        goto bailout;
    }

    if (!lpRBA->sGH.ulRecords)
    {
        fRet = TRUE;
        goto bailout;
    }
    for (ulRec = 1; ulRec <= lpRBA->sGH.ulRecords; ulRec++)
    {
        if(!ReadRecordFromRBA(lpRBA, ulRec, (LPGENERICREC)&sQR))
        {
            goto bailout;
        }

        if (sQR.uchType == REC_DATA)
        {
            if (sQR.ulrecNext)
            {
                if (sQR.ulrecNext > lpRBA->sGH.ulRecords)
                {
                    RecchkKdPrint(BADERRORS, ("Invalid next pointer to %d\r\n", ulRec));
                    goto bailout;
                }

                if (!ReadRecordFromRBA(lpRBA, sQR.ulrecNext, (LPGENERICREC)&sNext))
                {
                    goto bailout;
                }

                if (sNext.ulrecPrev != ulRec)
                {

                    RecchkKdPrint(BADERRORS, ("Prev pointer of %d doesn't equal %d\r\n", sNext.ulrecPrev, ulRec));
                    goto bailout;
                }
            }
            else
            {
                if (((LPQHEADER)&(lpRBA->sGH))->ulrecTail != ulRec)
                {

                    RecchkKdPrint(BADERRORS, ("Invalid tail pointer to %d\r\n", ulRec));
                    goto bailout;
                }

                fValidTail = TRUE;
            }

            if (sQR.ulrecPrev)
            {
                if (sQR.ulrecPrev > lpRBA->sGH.ulRecords)
                {
                    RecchkKdPrint(BADERRORS, ("Invalid prev pointer to %d\r\n", ulRec));
                    goto bailout;
                }

                if (!ReadRecordFromRBA(lpRBA, sQR.ulrecPrev, (LPGENERICREC)&sPrev))
                {
                    goto bailout;
                }

                if (sPrev.ulrecNext != ulRec)
                {

                    RecchkKdPrint(BADERRORS, ("Next pointer of %d doesn't equal %d\r\n", sPrev.ulrecNext, ulRec));
                    goto bailout;
                }
            }
            else
            {
                if (((LPQHEADER)&(lpRBA->sGH))->ulrecHead != ulRec)
                {

                    RecchkKdPrint(BADERRORS, ("Invalid Head pointer to %d\r\n", ulRec));
                    goto bailout;
                }

                fValidHead = TRUE;
            }
        }
    }

    if (!fValidHead || !fValidTail)
    {
        RecchkKdPrint(BADERRORS, ("Head or Tail invalid \r\n"));
        goto bailout;
    }

    fRet = TRUE;

bailout:
    if (lpRBA)
    {
        FreeRBA(lpRBA);
    }

    return (fRet);
}

BOOL
RebuildPQ(
    LPVOID      lpdbID
)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPRBA   lpRBA = NULL;
    BOOL    fRet = FALSE;


    RecchkKdPrint(PQ, ("RebuildPQ: reading PQ \r\n"));

    if (!ReadShadowInRBA(lpdbID, ULID_PQ, MAX_RECBUFF_ENTRY_SIZE, 0, &lpRBA))
    {
        RecchkKdPrint(BADERRORS, ("TraversePQ: Failed to read PQ in memory\r\n"));
        goto bailout;
    }

    RecchkKdPrint(PQ, ("RebuildPQ: read PQ \r\n"));

    if (!RebuildPQInRBA(lpRBA))
    {
        RecchkKdPrint(BADERRORS, ("RebuildPQ: failed to rebuild PQ in RBA \r\n"));
        goto bailout;
    }

    RecchkKdPrint(PQ, ("RebuildPQ: writing PQ \r\n"));

    if (!WriteRBA(lpdbID, lpRBA, NULL))
    {
        RecchkKdPrint(BADERRORS, ("RebuildPQ:Failed to writeout the PQ\r\n"));
        goto bailout;
    }

    RecchkKdPrint(PQ, ("RebuildPQ: wrote PQ \r\n"));

    fRet = TRUE;

bailout:
    if (lpRBA)
    {
        FreeRBA(lpRBA);
    }

    return (fRet);
}

BOOL
RebuildPQInRBA(
    LPRBA   lpRBA
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    unsigned ulRec;
    LPQHEADER   lpQH;
    LPQREC  lpPQ;
    BOOL fRet = FALSE;

    lpQH = (LPQHEADER)&(lpRBA->sGH);

    // nuke the PQ
    lpQH->ulrecHead = lpQH->ulrecTail = 0;

    for (ulRec = 1; ulRec <= lpRBA->sGH.ulRecords; ulRec++)
    {
        if (!(lpPQ = GetRecordPointerFromRBA(lpRBA, ulRec)))
        {
            RecchkKdPrint(BADERRORS, ("InsertRBAPQEntry: failed reading q entry at %d\r\n", ulRec));
            goto bailout;
        }

        if (lpPQ->uchType != REC_DATA)
        {
            continue;
        }

        if (!(lpPQ->ulidShadow & 0x80000000))
        {
            if (!InsertRBAPQEntryDir(lpRBA, lpPQ, ulRec))
            {
                RecchkKdPrint(BADERRORS, ("RebuildPQ:Failed inserting %d \r\n", ulRec));
                goto bailout;
            }
        }
        else
        {
            if (!InsertRBAPQEntryFile(lpRBA, lpPQ, ulRec))
            {
                RecchkKdPrint(BADERRORS, ("RebuildPQ:Failed inserting %d \r\n", ulRec));
                goto bailout;
            }
        }
    }
    fRet = TRUE;

bailout:
    return fRet;
}

BOOL
TraverseHierarchy(
    LPVOID      lpdbID,
    BOOL        fFix
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    unsigned ulRec;
    BOOL fRet = FALSE;
    LPRBA   lpRBA = NULL, lpRBAPQ=NULL;
    SHAREREC   sSR;
    QREC    sQR;
    BOOL    fErrors = FALSE;
    DWORD   dwError;

    if (!ReadShadowInRBA(lpdbID, ULID_SHARE, MAX_RECBUFF_ENTRY_SIZE, 0, &lpRBA))
    {
        RecchkKdPrint(BADERRORS, ("TraverseHierarchy: Failed to read servers in memory\r\n"));
        goto bailout;
    }

    if (!fFix)
    {
        if (!ReadShadowInRBA(   lpdbID,
                                ULID_PQ,
                                MAX_RECBUFF_ENTRY_SIZE,
                                0,
                                &lpRBAPQ))
        {
            RecchkKdPrint(BADERRORS, ("TraverseHierarchy: Failed to read PQ in memory\r\n"));
            goto bailout;
        }
    }
    else
    {
        ULONG   cbCountOfTotal= ((LPSHAREHEADER)&(lpRBA->sGH))->sCur.ucntDirs+((LPSHAREHEADER)&(lpRBA->sGH))->sCur.ucntFiles;
        ULONG   cbMaxEntriesExpected,cbMaxRbesExpected;

        cbMaxEntriesExpected = (MAX_RECBUFF_ENTRY_SIZE * MAX_RBES_EXPECTED)/sizeof(QREC);
        RecchkKdPrint(BADERRORS, ("TraverseHierarchy: total count=%d\r\n",cbCountOfTotal));
        if (cbCountOfTotal >= cbMaxEntriesExpected)
        {
            fRet = TRUE;
            RecchkKdPrint(BADERRORS, ("TraverseHierarchy: Database too big skipping autocheck\r\n"));
            goto bailout;
//            cbMaxRbesExpected = (cbCountOfTotal*sizeof(QREC)/MAX_RECBUFF_ENTRY_SIZE)+1;
        }
        else
        {
            cbMaxRbesExpected = MAX_RBES_EXPECTED;
        }

        RecchkKdPrint(BADERRORS, ("TraverseHierarchy: MaxRBEs = %d\r\n",cbMaxRbesExpected));

        if (!AllocateRBA(cbMaxRbesExpected, MAX_RECBUFF_ENTRY_SIZE, &lpRBAPQ))
        {
            RecchkKdPrint(BADERRORS, ("TraverseHierarchy: Failed to Allocate PQ\r\n"));
            goto bailout;
        }

        InitQHeader((LPQHEADER)&(lpRBAPQ->sGH));

        lpRBAPQ->ulidShadow = ULID_PQ;
        lpRBAPQ->cntRecsPerRBE =  MAX_RECBUFF_ENTRY_SIZE/lpRBAPQ->sGH.uRecSize;

    }

    for (ulRec=1; ulRec<=lpRBA->sGH.ulRecords; ++ulRec)
    {
        ReadRecordFromRBA(lpRBA, ulRec, (LPGENERICREC)&sSR);

        if (sSR.uchType != REC_DATA)
        {
            continue;
        }

        if(!ValidShadowID(sSR.ulidShadow))
        {
            fErrors = TRUE;
            sSR.uchType = REC_EMPTY;
            RecchkKdPrint(BADERRORS, ("Invalid Shadow ID %xh found in %xh \r\n", sSR.ulidShadow, sSR.ulShare));
            if (fFix)
            {
                if (!WriteRecordToRBA(lpRBA, ulRec, (LPGENERICREC)&sSR, TRUE, NULL))
                {
                    RecchkKdPrint(BADERRORS, ("Couldn't write entry for Share Record %xh \r\n", sSR.ulShare));
                }
            }

            continue;

        }

        if (!fFix)
        {

            if (!ReadRecordFromRBA(lpRBAPQ, RecFromInode(sSR.ulidShadow), (LPGENERICREC)&sQR))
            {
                RecchkKdPrint(BADERRORS, ("No PQ entry for Inode %xh \r\n", sSR.ulidShadow));
            }
        }
        else
        {
            InitPriQRec(ulRec, 0, sSR.ulidShadow, SHADOW_SPARSE, 0, 0, 0, 0, ulRec, &sQR);

            if (!WriteRecordToRBA(lpRBAPQ, RecFromInode(sSR.ulidShadow), (LPGENERICREC)&sQR, FALSE, &dwError))
            {
                if (dwError == ERROR_NOT_ENOUGH_MEMORY)
                {
                    RecchkKdPrint(BADERRORS, ("Couldn't write PQ entry for Inode %xh \r\n", sSR.ulidShadow));
                }

                fErrors = TRUE;
                sSR.uchType = REC_EMPTY;
                WriteRecordToRBA(lpRBA, ulRec, (LPGENERICREC)&sSR, TRUE, NULL);
                continue;
            }
        }

        if(!TraverseDirectory(  lpdbID,
                            ulRec,  // ulidShare
                            0,  // parent inode
                            sSR.ulidShadow, // dir inode
                            lpRBAPQ,
                            fFix
                            ))
        {
            goto bailout;
        }

    }
    if (fFix)
    {
        if (fErrors)
        {
            if (!WriteRBA(lpdbID, lpRBA, NULL))
            {
                RecchkKdPrint(BADERRORS, ("TraverseHierarchy:Failed to write Shares\r\n"));
                goto bailout;
            }
        }
        RecchkKdPrint(TRAVERSE, ("Total records %d \r\n", lpRBAPQ->sGH.ulRecords));

        if (lpRBAPQ->ulErrorFlags & RBA_ERROR_LIMIT_EXCEEDED)
        {
            RecchkKdPrint(BADERRORS, ("TraverseHierarchy: skipping rewriting of new PQ\r\n"));
        }
        else
        {
            if (!RebuildPQInRBA(lpRBAPQ))
            {
                RecchkKdPrint(BADERRORS, ("TraverseHierarchy:Failed to rebuild PQ\r\n"));
                goto bailout;
            }
            if (!WriteRBA(lpdbID, lpRBAPQ, NULL))
            {
                RecchkKdPrint(BADERRORS, ("TraverseHierarchy:Failed to write PQ\r\n"));
                goto bailout;
            }
        }
    }
    fRet = TRUE;

bailout:

    if (lpRBA)
    {
        FreeRBA(lpRBA);
    }

    if (lpRBAPQ)
    {
        FreeRBA(lpRBAPQ);
    }

    return fRet;
}

BOOL
TraverseDirectory(
    LPVOID      lpdbID,
    unsigned    ulidShare,
    unsigned    ulidParent,
    unsigned    ulidDir,
    LPRBA       lpRBAPQ,
    BOOL        fFix
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    unsigned    ulDepthLevel = 0, ulidCurParent, ulidCurDir;
    BOOL        fRet = FALSE, fGoDeeper = TRUE;
    FILERECEXT  *lpFR = NULL;
    QREC        *lpQR = NULL;
    LPCSE       lpcseNextDir = NULL;
    LPCSE       lpcseHead = NULL, lpcseT;
    BOOL        fErrors = FALSE;
    DWORD       dwError;

    lpFR = AllocMemPaged(sizeof(FILERECEXT));
    lpQR = AllocMemPaged(sizeof(QREC));

    if (!lpFR || !lpQR)
    {
        RecchkKdPrint(BADERRORS, ("AllocMemPaged Failed \r\n"));
        goto bailout;
    }

    ulidCurParent = ulidParent;
    ulidCurDir = ulidDir;

    for (;;)
    {
        if (fGoDeeper)
        {
            // we are going deeper

            // allocate a stack entry for the directory which we want
            // to traverse

            lpcseT = AllocMemPaged(sizeof(CSE));

            if (!lpcseT)
            {
                RecchkKdPrint(BADERRORS, ("AllocMemPaged failed \r\n"));
                goto bailout;
            }

            // do appropriate inits

            lpcseT->ulidShare = ulidShare;
            lpcseT->ulidParent = ulidCurParent;
            lpcseT->ulidDir = ulidCurDir;
            lpcseT->ulRec = 1;  // start for record # 1
            lpcseT->lpcseNext = NULL;

            // read the entire directory in memory
            if (!ReadShadowInRBA(lpdbID, ulidCurDir, MAX_RECBUFF_ENTRY_SIZE, 0, &(lpcseT->lpRBA)))
            {
                RecchkKdPrint(BADERRORS, ("TraverseDirectory: Failed to read directory in memory\r\n"));

                if (!fFix)
                {
                    RecchkKdPrint(BADERRORS, ("TraverseDirectory: Aborting\r\n"));
                    FreeMemPaged(lpcseT);
                    goto bailout;
                }
                else
                {
                    RecchkKdPrint(TRAVERSE, ("TraverseDirectory: attempting to heal\r\n"));
                    if(CreateDirInode(lpdbID, ulidShare, ulidCurParent, ulidCurDir) < 0)
                    {
                        RecchkKdPrint(BADERRORS, ("TraverseDirectory: failed to heal\r\n"));
                    }

                    FreeMemPaged(lpcseT);
                    fGoDeeper = FALSE;

                    // continue if there are more things to do
                    // else stop
                    if (lpcseHead)
                    {
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
            }

            // put it at the head of the queue
            lpcseT->lpcseNext = lpcseHead;
            lpcseHead = lpcseT;

            ulDepthLevel++;

        }

        fGoDeeper = FALSE;

        // we always operate on the head of the list

        Assert(lpcseHead != NULL);

        RecchkKdPrint(TRAVERSE, ("Processing %x at depth %d\r\n", ulidCurDir, ulDepthLevel));

        RecchkKdPrint(TRAVERSE, ("lpcseHead = %x, lpcseHead->lpcseNext = %x \r\n", lpcseHead, lpcseHead->lpcseNext));

        for (; lpcseHead->ulRec<=lpcseHead->lpRBA->sGH.ulRecords;)
        {
            ReadRecordFromRBA(lpcseHead->lpRBA, lpcseHead->ulRec, (LPGENERICREC)lpFR);

            if (lpFR->sFR.uchType == REC_DATA)
            {
                if(!ValidShadowID(lpFR->sFR.ulidShadow))
                {
                    RecchkKdPrint(BADERRORS, ("Invalid Shadow ID %xh found in %xh \r\n", lpFR->sFR.ulidShadow, ulidCurDir));
                    lpcseHead->lpRBA->ulErrorFlags |= RBA_ERROR_INVALID_INODE;

                    if (fFix)
                    {
                        lpFR->sFR.uchType = REC_EMPTY;
                        if (!WriteRecordToRBA(lpcseHead->lpRBA, lpcseHead->ulRec, (LPGENERICREC)lpFR, TRUE, NULL))
                        {
                            RecchkKdPrint(BADERRORS, ("Couldn't write entry for dir Record #%dh in dir %xh\r\n", lpcseHead->ulRec, ulidCurDir));
                        }

                    }

                }
                else
                {
                    if (!fFix)
                    {
                        ReadRecordFromRBA(lpRBAPQ, RecFromInode(lpFR->sFR.ulidShadow), (LPGENERICREC)lpQR);

                        if (!ValidateQrecFromFilerec(lpcseHead->ulidShare, lpcseHead->ulidDir, lpFR, lpQR, lpcseHead->ulRec))
                        {
                            RecchkKdPrint(BADERRORS, ("PQ entry for Inode %xh in directory=%xh doesn't match with filerec\r\n", lpFR->sFR.ulidShadow, lpcseHead->lpRBA->ulidShadow));
                        }
                    }
                    else
                    {
                        InitPriQRec(lpcseHead->ulidShare,
                                    lpcseHead->ulidDir,
                                    lpFR->sFR.ulidShadow,
                                    lpFR->sFR.usStatus,
                                    lpFR->sFR.uchRefPri,
                                    lpFR->sFR.uchIHPri,
                                    lpFR->sFR.uchHintPri,
                                    lpFR->sFR.uchHintFlags,
                                    lpcseHead->ulRec,
                                    lpQR);

                        if (!WriteRecordToRBA(lpRBAPQ, RecFromInode(lpFR->sFR.ulidShadow), (LPGENERICREC)lpQR, FALSE, &dwError))
                        {
                            if (dwError == ERROR_NOT_ENOUGH_MEMORY)
                            {
                                RecchkKdPrint(BADERRORS, ("Couldn't write PQ entry for Inode %xh \r\n", lpFR->sFR.ulidShadow));
                            }

                            lpFR->sFR.uchType = REC_EMPTY;
                            lpcseHead->lpRBA->ulErrorFlags |= RBA_ERROR_INVALID_INODE;

                            WriteRecordToRBA(lpcseHead->lpRBA, lpcseHead->ulRec, (LPGENERICREC)lpFR, TRUE, NULL);

                            // go around one more time, when this entry will get skipped
                            continue;
                        }
                    }
                }
            }

            // point to the next record
            lpcseHead->ulRec += (OvfCount(lpFR)+1);

            if ((lpFR->sFR.uchType == REC_DATA) && !(lpFR->sFR.ulidShadow & 0x80000000))
            {
                ulidCurParent = ulidCurDir;
                ulidCurDir = lpFR->sFR.ulidShadow;
                fGoDeeper = TRUE;
                break;
            }
        }

        if (fGoDeeper)
        {
            continue;
        }
        else
        {
            // we completed processing a directory

            Assert(fGoDeeper == FALSE);
            Assert(lpcseHead);

            RecchkKdPrint(TRAVERSE, ("Unwinding \r\n"));

            if (fFix && lpcseHead->lpRBA->ulErrorFlags)
            {

                if (!WriteRBA(lpdbID, lpcseHead->lpRBA, NULL))
                {
                    RecchkKdPrint(BADERRORS, ("Cannot fix errors on %xh \n\r", lpcseHead->lpRBA->ulidShadow));

                }

            }
            // processing of a directory is complete, unwind the stack
            lpcseT = lpcseHead;
            lpcseHead = lpcseHead->lpcseNext;

            FreeRBA(lpcseT->lpRBA);
            FreeMemPaged(lpcseT);

            if (!lpcseHead)
            {
                break;
            }

            ulidCurDir = lpcseHead->ulidDir;
            ulidCurParent = lpcseHead->ulidParent;
        }
    }

    fRet = TRUE;

bailout:
    if (lpFR)
    {
        FreeMemPaged(lpFR);
    }
    if (lpQR)
    {
        FreeMemPaged(lpQR);
    }
    Assert(!(fRet && lpcseHead));

    for (;lpcseHead;)
    {
        lpcseT = lpcseHead;
        lpcseHead = lpcseHead->lpcseNext;
        FreeRBA(lpcseT->lpRBA);
        FreeMemPaged(lpcseT);
    }

    return (fRet);
}

BOOL
AllocateRBA(
    DWORD           cntRBE,     // count of record buffer entries
    DWORD           cbRBE,      // size of each record buffer entry
    LPRBA           *lplpRBA   // result to be returned
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPRBA   lpRBA = NULL;
    DWORD   i;


    lpRBA = (LPRBA)AllocMemPaged(sizeof(RBA)+sizeof(LPBYTE)*cntRBE);

    if (lpRBA != NULL)
    {
        // initialize the guy
        lpRBA->cntRBE = cntRBE;                 // count of record buffer entries in rgRBE
        lpRBA->cbRBE = cbRBE;                   // size in bytes of each RBE buffer
    }
    else
    {
        RecchkKdPrint(BADERRORS, ("Failed memory allocation while getting RBA\r\n"));
    }

    if (lpRBA)
    {
        *lplpRBA = lpRBA;
        return (TRUE);
    }

    return FALSE;
}

VOID
FreeRBA(
    LPRBA  lpRBA
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    DWORD   i;

    RecchkKdPrint(RBA, ("FreeRBA:cntRBE=%d cbRBE=%d lpRBA=%xh\r\n", lpRBA->cntRBE, lpRBA->cbRBE, lpRBA));

    for (i=0; i<lpRBA->cntRBE; ++i)
    {
        if (lpRBA->rgRBE[i])
        {
            FreeMemPaged(lpRBA->rgRBE[i]);
        }
    }

    if (lpRBA->hf)
    {
        CloseFileLocal(lpRBA->hf);
    }
    FreeMemPaged(lpRBA);
}

BOOL
ReadShadowInRBA(
    LPVOID          lpdbID,
    unsigned        ulidShadow,
    DWORD           cbMaxRBEIn,     // max size in bytes of an RBE
    DWORD           cntRBEIn,       // # of RBEs in this RBA, calculated if 0
    LPRBA           *lplpRBA
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR   lpszName = NULL;
    BOOL    fRet = FALSE;
    DWORD   dwFileSize, cntRBE, cntRecsPerRBE, cbRBE, i;
    unsigned    ulRecords, ulPos, ulErrorFlags = 0;
    CSCHFILE hf = CSCHFILE_NULL;
    GENERICHEADER sGH;
    LPRBA lpRBA=NULL;

    if (lpszName = FormNameString(lpdbID, ulidShadow))
    {
        hf = OpenFileLocal(lpszName);

        if (hf)
        {
            if ((GetFileSizeLocal(hf, &dwFileSize))==0xffffffff)
            {
                RecchkKdPrint(BADERRORS, ("Failed to get filesize for %s\r\n", lpszName));
                goto bailout;
            }

            if (ReadHeader(hf, &sGH, sizeof(sGH))< 0)
            {
                RecchkKdPrint(BADERRORS, ("Failed to read header for %s\r\n", lpszName));
                goto bailout;

            }

            ulRecords = (dwFileSize-sGH.lFirstRec)/sGH.uRecSize;

            if (sGH.ulRecords != ulRecords)
            {
                RecchkKdPrint(BADERRORS, ("Count of total records inconsistent with the file size header=%d expected=%d\r\n",
                                sGH.ulRecords,
                                ulRecords
                ));

                ulErrorFlags |= RAB_ERROR_INVALID_RECORD_COUNT;

            }

            if (sGH.ulRecords > ulRecords)
            {
                sGH.ulRecords = ulRecords;
            }

            // integral # of records per RBE
            cntRecsPerRBE = cbMaxRBEIn/sGH.uRecSize;

            // corresponding size of memory allocation per RBE
            cbRBE = cntRecsPerRBE * sGH.uRecSize;

            if (!cntRBEIn)
            {
                // total count of RBEs. Add 1 to take care of partial RBE at the end
                cntRBE = sGH.ulRecords/cntRecsPerRBE + 1;
            }
            else
            {
                cntRBE = cntRBEIn;
            }


            if (!AllocateRBA(cntRBE, cbRBE, &lpRBA))
            {
                RecchkKdPrint(BADERRORS, ("Failed allocation of recbuff array of %d entries for %s\r\n", cntRBE, lpszName));
                goto bailout;
            }

            ulPos = sGH.lFirstRec;
            for (i=0; i<cntRBE; ++i)
            {
                int iRet;

                Assert(!lpRBA->rgRBE[i]);

                lpRBA->rgRBE[i] = (LPBYTE)AllocMemPaged(cbRBE);

                if (!lpRBA->rgRBE[i])
                {
                    RecchkKdPrint(BADERRORS, ("Error  allocating RBE for Inode file %s \r\n", lpszName));
                    goto bailout;
                }

                iRet = ReadFileLocalEx2(hf, ulPos, lpRBA->rgRBE[i], cbRBE, FLAG_RW_OSLAYER_PAGED_BUFFER);

                if (iRet < 0)
                {

                    RecchkKdPrint(BADERRORS, ("Error reading Inode file %s \r\n", lpszName));
                    goto bailout;
                }
                if (iRet < (int)cbRBE)
                {
                    break;
                }
                ulPos += cbRBE;
            }

            // initialize the guy
            lpRBA->ulidShadow = ulidShadow;         // Inode
            lpRBA->sGH = sGH;                       // Inode file header
            lpRBA->hf = hf;                         // file handle
            lpRBA->cntRBE = cntRBE;                 // count of record buffer entries in rgRBE
            lpRBA->cntRecsPerRBE = cntRecsPerRBE;   // count of records in each RBE buffer
            lpRBA->cbRBE = cbRBE;                   // size in bytes of each RBE buffer
            lpRBA->ulErrorFlags = ulErrorFlags;     // errors found so far

            *lplpRBA = lpRBA;

            fRet = TRUE;
        }
        else
        {
            RecchkKdPrint(BADERRORS, ("Failed to open %s \r\n", lpszName));
        }

    }
    else
    {
        RecchkKdPrint(BADERRORS, ("Failed memory allocation\r\n"));
    }
bailout:

    if (lpszName)
    {
        FreeNameString(lpszName);
    }

    if (hf)
    {
        CloseFileLocal(hf);
        if (lpRBA)
        {
            lpRBA->hf = CSCHFILE_NULL;
        }
    }

    if (!fRet)
    {
        if (lpRBA)
        {
            FreeRBA(lpRBA);
        }

    }
    return (fRet);
}


BOOL
WriteRBA(
    LPVOID  lpdbID,
    LPRBA   lpRBA,
    LPSTR   lpszFileName
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf = CSCHFILE_NULL;
    BOOL fRet = FALSE;
    LPSTR   lpszName = NULL, lpszTempName = NULL, lpszTempName1 = NULL;
    DWORD   i, cntRecsInLastRBE, cbLastRBE, cntRBEReal;
    unsigned long   ulPos, ulT;

    if (!lpszFileName)
    {
        lpszName = FormNameString(lpdbID, lpRBA->ulidShadow);

        if (!lpszName)
        {
            RecchkKdPrint(BADERRORS, ("Failed to allocate memory\r\n"));
            goto bailout;
        }
    }
    else
    {
        lpszName = lpszFileName;
    }

    // create tempfilel names
    lpszTempName = AllocMemPaged(strlen((LPSTR)lpdbID) + strlen(vszTemp) + 4);

    if (!lpszTempName)
    {
        RecchkKdPrint(BADERRORS, ("Failed to allocate memory\r\n"));
        goto bailout;
    }

    strcpy(lpszTempName, (LPSTR)lpdbID);
    strcat(lpszTempName, "\\");
    strcat(lpszTempName, vszTemp);

    lpszTempName1 = AllocMemPaged(strlen((LPSTR)lpdbID) + strlen(vszTemp1) + 4);

    if (!lpszTempName1)
    {
        RecchkKdPrint(BADERRORS, ("Failed to allocate memory\r\n"));
        goto bailout;
    }

    strcpy(lpszTempName1, (LPSTR)lpdbID);
    strcat(lpszTempName1, "\\");
    strcat(lpszTempName1, vszTemp1);



    hf = R0OpenFileEx(ACCESS_READWRITE, ACTION_CREATEALWAYS, FILE_ATTRIBUTE_SYSTEM, lpszTempName, FALSE);

    if (!hf)
    {
        RecchkKdPrint(BADERRORS, ("Failed to open %s\r\n", lpszTempName));
        goto bailout;
    }

    // this is the real # of RBEs, there might be empty ones
    // after this

    cntRBEReal = lpRBA->sGH.ulRecords / lpRBA->cntRecsPerRBE;

    RecchkKdPrint(RBA, ("Writing %s\r\n", lpszTempName));

    // is there a partial RBE at the end?
    if (lpRBA->sGH.ulRecords % lpRBA->cntRecsPerRBE)
    {
        // yes, bump up the count of RBEs to write and caclulate the
        // # of bytes

        cntRBEReal++;
        cntRecsInLastRBE = lpRBA->sGH.ulRecords - (cntRBEReal - 1) * lpRBA->cntRecsPerRBE;
        cbLastRBE = cntRecsInLastRBE * lpRBA->sGH.uRecSize;

    }
    else
    {
        // records exactly fit in the last RBE.
        // so the stats for the last RBE are trivial

        cntRecsInLastRBE = lpRBA->cntRecsPerRBE;
        cbLastRBE = lpRBA->cbRBE;
    }


    RecchkKdPrint(RBA, ("%d RBEs, %d bytes in last RBE\r\n", cntRBEReal, cbLastRBE));

    Assert(cntRBEReal <= lpRBA->cntRBE);

    if(WriteFileLocalEx2(hf, 0, &(lpRBA->sGH), sizeof(lpRBA->sGH), FLAG_RW_OSLAYER_PAGED_BUFFER)!=((int)sizeof(lpRBA->sGH)))
    {
        RecchkKdPrint(BADERRORS, ("Failed writing header \r\n"));
        goto bailout;
    }

    ulPos = lpRBA->sGH.lFirstRec;

    for (i=0; i<cntRBEReal; ++i)
    {
        DWORD dwSize;

        // if last RBE, write the residual size calculated above
        dwSize = (((i+1)==cntRBEReal)?cbLastRBE:lpRBA->cbRBE);

        // there must be a corresponding RBE
        Assert(lpRBA->rgRBE[i]);

        if(WriteFileLocalEx2(hf, ulPos, lpRBA->rgRBE[i], dwSize, FLAG_RW_OSLAYER_PAGED_BUFFER)!=(int)dwSize)
        {
            RecchkKdPrint(BADERRORS, ("Error writing file\r\n"));
            goto bailout;
        }

        ulPos += dwSize;
    }

    CloseFileLocal(hf);
    hf = CSCHFILE_NULL;

    if((GetAttributesLocal(lpszTempName1, &ulT)>=0)
        && (DeleteFileLocal(lpszTempName1, ATTRIB_DEL_ANY) < 0))
    {
        RecchkKdPrint(BADERRORS, ("WriteRBA: failed to delete temp file %s\r\n", lpszTempName1));
        goto bailout;
    }

    if(RenameFileLocal(lpszName, lpszTempName1) < 0)
    {
        RecchkKdPrint(BADERRORS, ("WriteRBA: failed to rename original %s to temp file %s\r\n", lpszName, lpszTempName1));
        goto bailout;

    }

    if(RenameFileLocal(lpszTempName, lpszName) < 0)
    {
        RecchkKdPrint(BADERRORS, ("WriteRBA: failed to rename new file %s to the original %s\r\n", lpszTempName, lpszName));
        if(RenameFileLocal(lpszTempName1, lpszTempName) < 0)
        {
            RecchkKdPrint(BADERRORS, ("WriteRBA: failed to rename back %s to the original %s\r\n", lpszTempName1, lpszName));
            Assert(FALSE);
        }
        goto bailout;

    }

    fRet = TRUE;


bailout:

    if (hf)
    {
        CloseFileLocal(hf);
    }

    // if a name wasn't sent in, we must have allocated it
    if (!lpszFileName)
    {
        FreeNameString(lpszName);
    }

    if (lpszTempName)
    {
        FreeMemPaged(lpszTempName);
    }

    if (lpszTempName1)
    {
        FreeMemPaged(lpszTempName1);
    }

    return (fRet);
}

LPVOID
GetRecordPointerFromRBA(
    LPRBA           lpRBA,
    unsigned        ulRec
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    DWORD   indxRec, indxRBE;

    if (lpRBA->sGH.ulRecords < ulRec)
    {
        RecchkKdPrint(BADERRORS, ("GetRecordPointerFromRBA: invalid rec passed in lpRBA->ulidShadow=%xh lpRBA->sGH.ulRecords=%xh ulRec=%xh\r\n",
            lpRBA->ulidShadow, lpRBA->sGH.ulRecords, ulRec));

        return NULL;
    }

    indxRBE = (ulRec-1)/lpRBA->cntRecsPerRBE;
    indxRec = (ulRec-1)%lpRBA->cntRecsPerRBE;

    Assert(lpRBA->rgRBE[indxRBE]);

    return ((lpRBA->rgRBE[indxRBE])+indxRec*lpRBA->sGH.uRecSize);
}

BOOL
ReadRecordFromRBA(
    LPRBA           lpRBA,
    unsigned        ulRec,
    LPGENERICREC    lpGR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    DWORD   indxRec, indxRBE, cntOvf, i;
    char uchOvfType;
    LPGENERICREC    lpGRT;


    if(lpRBA->sGH.ulRecords < ulRec)
    {
        // this must have been fixed when we read the file in
        // only in case of priority Q, where the records point
        // to each other is it possible that this could happen

        Assert(lpRBA->ulidShadow == ULID_PQ);
    }

    indxRBE = (ulRec-1)/lpRBA->cntRecsPerRBE;
    indxRec = (ulRec-1)%lpRBA->cntRecsPerRBE;

    Assert(lpRBA->rgRBE[indxRBE]);

    lpGRT = (LPGENERICREC)((lpRBA->rgRBE[indxRBE])+indxRec*lpRBA->sGH.uRecSize);

    memcpy(lpGR, (lpRBA->rgRBE[indxRBE])+indxRec*lpRBA->sGH.uRecSize, lpRBA->sGH.uRecSize);


    if ((lpGR->uchType == REC_DATA)||(lpGR->uchType == REC_EMPTY))
    {
        cntOvf = (DWORD)OvfCount(lpGR);

        uchOvfType = (lpGR->uchType == REC_DATA)?REC_OVERFLOW:REC_EMPTY;

        if (cntOvf > MAX_OVERFLOW_RECORDS)
        {
            lpRBA->ulErrorFlags |= RBA_ERROR_INVALID_OVF;
            SetOvfCount(lpGR, MAX_OVERFLOW_RECORDS);
        }
        if (cntOvf)
        {
            for (i=1; i<=cntOvf; ++i)
            {
                indxRBE = (ulRec+i-1)/lpRBA->cntRecsPerRBE;
                indxRec = (ulRec+i-1)%lpRBA->cntRecsPerRBE;
                memcpy(((LPBYTE)lpGR)+i*lpRBA->sGH.uRecSize, (lpRBA->rgRBE[indxRBE])+indxRec*lpRBA->sGH.uRecSize, lpRBA->sGH.uRecSize);
                if (((LPGENERICREC)(((LPBYTE)lpGR)+i*lpRBA->sGH.uRecSize))->uchType != uchOvfType)
                {
                    lpRBA->ulErrorFlags |= RBA_ERROR_INVALID_OVF;
                    SetOvfCount(lpGR, (i-1));
                }
            }
        }
    }
    else
    {
        lpGR->uchType = REC_EMPTY;
        SetOvfCount(lpGR, 0);

        lpGRT->uchType = REC_EMPTY;
        SetOvfCount(lpGRT, 0);

        lpRBA->ulErrorFlags |= RBA_ERROR_MISALIGNED_RECORD;
        RecchkKdPrint(BADERRORS, ("ReadRecordFromRBA: misaligned record found \r\n"));
    }

    return (TRUE);
}

BOOL
WriteRecordToRBA(
    LPRBA           lpRBA,
    unsigned        ulRec,
    LPGENERICREC    lpGR,
    BOOL            fOverwrite,
    LPDWORD         lpdwError
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{

    DWORD   indxRec, indxRBE, cntOvf, i, ulRecords;
    LPGENERICREC    lpGRT;

    indxRBE = (ulRec-1)/lpRBA->cntRecsPerRBE;
    indxRec = (ulRec-1)%lpRBA->cntRecsPerRBE;

    if (indxRBE >= MAX_RBES_EXPECTED)
    {
        lpRBA->ulErrorFlags |= RBA_ERROR_LIMIT_EXCEEDED;

        RecchkKdPrint(BADERRORS, ("WriteRecordToRBA: Limit of reached, for Inode %x, skipping\r\n", lpRBA->ulidShadow));

        if (lpdwError)
        {
            *lpdwError = ERROR_BUFFER_OVERFLOW;
        }
        return FALSE;
        
    }
    if (!lpRBA->rgRBE[indxRBE])
    {
        if (!FillupRBAUptoThisRBE(lpRBA, indxRBE))
        {
            RecchkKdPrint(BADERRORS, ("WriteRecordToRBA: failed to fillup RBA\r\n"));
            if (lpdwError)
            {
                *lpdwError = ERROR_NOT_ENOUGH_MEMORY;
            }
            return FALSE;
        }
    }

    Assert(lpRBA->rgRBE[indxRBE]);

    lpGRT = (LPGENERICREC)((lpRBA->rgRBE[indxRBE])+indxRec*lpRBA->sGH.uRecSize);

    if (!fOverwrite && ((lpGRT->uchType == REC_DATA)||(lpGRT->uchType == REC_OVERFLOW)))
    {
        RecchkKdPrint(RBA, ("Not overwriting at ulrec=%d in RBA for Inode 0x%x", ulRec, lpRBA->ulidShadow));
        if (lpdwError)
        {
            *lpdwError = ERROR_INVALID_PARAMETER;
        }
        return FALSE;
    }

    memcpy((lpRBA->rgRBE[indxRBE])+indxRec*lpRBA->sGH.uRecSize, lpGR, lpRBA->sGH.uRecSize);


    cntOvf = (DWORD)OvfCount(lpGR);
    if (cntOvf)
    {
        for (i=1; i<=cntOvf; ++i)
        {
            indxRBE = (ulRec+i-1)/lpRBA->cntRecsPerRBE;
            indxRec = (ulRec+i-1)%lpRBA->cntRecsPerRBE;
            if (!lpRBA->rgRBE[indxRBE])
            {
                RecchkKdPrint(RBA, ("Extending RBEs upto indx=%d \r\n", indxRBE));
                if (!FillupRBAUptoThisRBE(lpRBA, indxRBE))
                {
                    RecchkKdPrint(BADERRORS, ("WriteRecordToRBA: failed to fillup RBA\r\n"));
                    return FALSE;
                }
            }
            memcpy( (lpRBA->rgRBE[indxRBE])+indxRec*lpRBA->sGH.uRecSize,
                    ((LPBYTE)lpGR)+i*lpRBA->sGH.uRecSize,
                    lpRBA->sGH.uRecSize);
        }
    }

    // reflect any addition in the count of records
    // add up total records in all RBEs except the last one
    // which might be partially filled, then add the index of the
    // one we just filled in , then add one because the index is
    // 0 based

     ulRecords =  lpRBA->cntRecsPerRBE * indxRBE
                                + indxRec
                                + 1;
    if (ulRecords > lpRBA->sGH.ulRecords)
    {
        RecchkKdPrint(RBA, ("# of records got increased from %d to %d\r\n", lpRBA->sGH.ulRecords, ulRecords));
        lpRBA->sGH.ulRecords = ulRecords;
    }

    return (TRUE);
}

BOOL
FillupRBAUptoThisRBE(
    LPRBA   lpRBA,
    DWORD   indxRBE
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    DWORD   i;
    for (i=0; i<= indxRBE; ++i)
    {
        if (!lpRBA->rgRBE[i])
        {
            lpRBA->rgRBE[i] = (LPBYTE)AllocMemPaged(lpRBA->cbRBE);
            if (!lpRBA->rgRBE[i])
            {
                RecchkKdPrint(BADERRORS, ("FillupRBAUptoThisPoint:Failed memory allocation \r\n"));
                return FALSE;
            }
            InitializeRBE(lpRBA, i);
        }
    }
    return (TRUE);
}

VOID
InitializeRBE(
    LPRBA   lpRBA,
    DWORD   indxRBE
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    DWORD i;
    LPBYTE  lpT = lpRBA->rgRBE[indxRBE];

    for (i=0; i< lpRBA->cntRecsPerRBE; ++i)
    {
        Assert(((LPGENERICREC)lpT)->uchType != REC_DATA);

        ((LPGENERICREC)lpT)->uchType = REC_EMPTY;
        lpT += lpRBA->sGH.uRecSize;
    }
}

BOOL
InsertRBAPQEntryFile(
    LPRBA       lpRBAPQ,
    LPQREC      lpPQDst,
    unsigned    ulrecDst
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPQREC      lpPQCur, lpPQPred=NULL;
    LPQHEADER   lpQH = NULL;
    unsigned ulrecCur, ulrecPred;

    lpQH = (LPQHEADER)&(lpRBAPQ->sGH);

    if (!lpQH->ulrecHead)
    {
        Assert(!lpQH->ulrecTail);

        lpQH->ulrecHead = lpQH->ulrecTail = ulrecDst;
        lpPQDst->ulrecNext = lpPQDst->ulrecPrev = 0;
    }
    else
    {
        for(ulrecCur = lpQH->ulrecHead, lpPQPred=NULL, ulrecPred=0;;)
        {
            if (!(lpPQCur = GetRecordPointerFromRBA(lpRBAPQ, ulrecCur)))
            {
                RecchkKdPrint(BADERRORS, ("InsertRBAPQEntry: failed getting q entry at %d\r\n", ulrecCur));
                return FALSE;
            }

            // are we greater than or equal to the current one?
            if (IComparePri(lpPQDst, lpPQCur) >= 0)
            {
                // yes, insert here

                if (!lpPQPred)
                {
                    // no predecessor, must be the head of the list
                    Assert(!lpPQCur->ulrecPrev);

                    // when we become the head, we got no prev
                    lpPQDst->ulrecPrev = 0;

                    // and the current head is our next
                    lpPQDst->ulrecNext = lpQH->ulrecHead;

                    // fix up the current heads prev to point to us
                    lpPQCur->ulrecPrev = ulrecDst;

                    // and fix the current head to point to us
                    lpQH->ulrecHead = ulrecDst;
                }
                else
                {
                    // normal case, we go between lpPQPred and lpPQCur

                    Assert(ulrecPred);

                    // fix up the passed in guy first

                    lpPQDst->ulrecPrev = ulrecPred;
                    lpPQDst->ulrecNext = ulrecCur;

                    // now fix the predecessor's next and current guys prev to point to us
                    lpPQPred->ulrecNext = lpPQCur->ulrecPrev = ulrecDst;

                }
                break;
            }

            ulrecPred = ulrecCur;
            ulrecCur = lpPQCur->ulrecNext;

            if (!ulrecCur)
            {

                // Insert at the tail
                lpPQDst->ulrecNext = 0;
                lpPQDst->ulrecPrev = lpQH->ulrecTail;

                lpPQCur->ulrecNext = ulrecDst;
                lpQH->ulrecTail = ulrecDst;

                break;
            }

            lpPQPred = lpPQCur;

        }
    }

    return (TRUE);
}


BOOL
InsertRBAPQEntryDir(
    LPRBA       lpRBAPQ,
    LPQREC      lpPQDst,
    unsigned    ulrecDst
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPQREC      lpPQCur, lpPQSucc=NULL;
    LPQHEADER   lpQH = NULL;
    unsigned ulrecCur, ulrecSucc;

    lpQH = (LPQHEADER)&(lpRBAPQ->sGH);

    if (!lpQH->ulrecHead)
    {
        Assert(!lpQH->ulrecTail);

        lpQH->ulrecHead = lpQH->ulrecTail = ulrecDst;
        lpPQDst->ulrecNext = lpPQDst->ulrecPrev = 0;
    }
    else
    {
        for(ulrecCur = lpQH->ulrecTail, lpPQSucc=NULL, ulrecSucc=0;;)
        {
            if (!(lpPQCur = GetRecordPointerFromRBA(lpRBAPQ, ulrecCur)))
            {
                RecchkKdPrint(BADERRORS, ("InsertRBAPQEntry: failed getting q entry at %d\r\n", ulrecCur));
                return FALSE;
            }

            // are we less than or equal to the current one?
            if (IComparePri(lpPQDst, lpPQCur) <= 0)
            {
                // yes, insert here

                if (!lpPQSucc)
                {
                    // no Succecessor, must be the tail of the list
                    Assert(!lpPQCur->ulrecNext);

                    // when we become the tail, we got no next
                    lpPQDst->ulrecNext = 0;

                    // and the current tail is our prev
                    lpPQDst->ulrecPrev = lpQH->ulrecTail;

                    Assert(lpQH->ulrecTail == ulrecCur);

                    Assert(!lpPQCur->ulrecNext);

                    // fix up the current tails next to point to us
                    lpPQCur->ulrecNext = ulrecDst;

                    // and fix the current tail to point to us
                    lpQH->ulrecTail = ulrecDst;
                }
                else
                {
                    // normal case, we go between lpPQCur and lpPQSucc

                    Assert(ulrecSucc);

                    // fix up the passed in guy first

                    lpPQDst->ulrecNext = ulrecSucc;
                    lpPQDst->ulrecPrev = ulrecCur;

                    // now fix the Succecessor's prev and current guys next to point to us
                    lpPQSucc->ulrecPrev = lpPQCur->ulrecNext = ulrecDst;

                }
                break;
            }

            ulrecSucc = ulrecCur;
            ulrecCur = lpPQCur->ulrecPrev;

            if (!ulrecCur)
            {

                // Insert at the head
                lpPQDst->ulrecPrev = 0;
                lpPQDst->ulrecNext = lpQH->ulrecHead;

                lpPQCur->ulrecPrev = ulrecDst;
                lpQH->ulrecHead = ulrecDst;

                break;
            }

            lpPQSucc = lpPQCur;

        }
    }

    return (TRUE);
}


BOOL
ValidateQrecFromFilerec(
    unsigned        ulidShare,
    unsigned        ulidDir,
    LPFILERECEXT    lpFR,
    LPQREC          lpQR,
    unsigned        ulrecDirEntry
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    if (lpQR->uchType != REC_DATA)
    {
        RecchkKdPrint(BADERRORS, ("Invalid Qrec type %c \r\n", lpQR->uchType));
        return FALSE;
    }

    if ((lpQR->ulidShare != ulidShare)||
        (lpQR->ulidDir != ulidDir)||
        (lpQR->ulidShadow != lpFR->sFR.ulidShadow))
    {
        RecchkKdPrint(BADERRORS, ("Mismatched server, dir or inode \r\n"));
        return FALSE;
    }

    if ((lpQR->usStatus != lpFR->sFR.usStatus)||
        (lpQR->uchRefPri != lpFR->sFR.uchRefPri)||
        (lpQR->uchIHPri != lpFR->sFR.uchIHPri)||
        (lpQR->uchHintFlags != lpFR->sFR.uchHintFlags)||
        (lpQR->uchHintPri != lpFR->sFR.uchHintPri))
    {
        RecchkKdPrint(BADERRORS, ("Mismatched status or pincount\r\n"));
        return FALSE;
    }
    if (ulidDir && (lpQR->ulrecDirEntry != ulrecDirEntry))
    {
        RecchkKdPrint(BADERRORS, ("Mismatched ulrecDirEntry\r\n"));
        return FALSE;
    }

    return TRUE;
}

#if 0

#ifdef DEBUG
VOID
PrintShareHeader(
    LPSHAREHEADER  lpSH,
    LPFNPRINTPROC   lpfnPrintProc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=0;

    if (lpfnPrintProc)
    {
        iRet += wsprintfA(vchPrintBuff,"****ShareHeader****\r\n" );

        iRet+=wsprintfA(vchPrintBuff+iRet,"Header: Flags=%xh Version=%lxh Records=%ld Size=%d \r\n",
                    lpSH->uchFlags, lpSH->ulVersion, lpSH->ulRecords, lpSH->uRecSize);

        iRet+=wsprintfA(vchPrintBuff+iRet,"Store: Max=%ld Current=%ld \r\n", lpSH->sMax.ulSize, lpSH->sCur.ulSize);

        iRet+=wsprintfA(vchPrintBuff+iRet,"\r\n");

        (lpfnPrintProc)(vchPrintBuff);
    }
}

VOID
PrintPQHeader(
    LPQHEADER   lpQH,
    PRINTPROC lpfnPrintProc
    )
{
    int iRet=0;

    if (lpfnPrintProc)
    {
        iRet += wsprintfA(vchPrintBuff+iRet,"****PQHeader****\r\n" );

        iRet += wsprintfA(vchPrintBuff+iRet,"Flags=%xh Version=%lxh Records=%ld Size=%d head=%ld tail=%ld\r\n",
                    lpQH->uchFlags, lpQH->ulVersion, lpQH->ulRecords, lpQH->uRecSize, lpQH->ulrecHead, lpQH->ulrecTail);
        iRet += wsprintfA(vchPrintBuff+iRet,"\r\n");

        (lpfnPrintProc)(vchPrintBuff);
    }
}

VOID
PrintFileHeader(
    LPFILEHEADER lpFH,
    unsigned    ulSpaces,
    PRINTPROC lpfnPrintProc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{

    int iRet=0;

    if (lpfnPrintProc)
    {
        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);
        iRet += wsprintfA(vchPrintBuff+iRet,"****FileHeader****\r\n" );

        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);
        iRet += wsprintfA(vchPrintBuff+iRet,"Flags=%xh Version=%lxh Records=%ld Size=%d\r\n",
                    lpFH->uchFlags, lpFH->ulVersion, lpFH->ulRecords, lpFH->uRecSize);

        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);
        iRet += wsprintfA(vchPrintBuff+iRet,"bytes=%ld entries=%d Share=%xh Dir=%xh\r\n",
                    lpFH->ulsizeShadow, lpFH->ucShadows, lpFH->ulidShare, lpFH->ulidDir);

        iRet += wsprintfA(vchPrintBuff+iRet,"\r\n");

        (lpfnPrintProc)(vchPrintBuff);
    }
}

VOID
PrintPQrec(
    unsigned    ulRec,
    LPQREC      lpQrec,
    PRINTPROC lpfnPrintProc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=0;

    if (lpfnPrintProc)
    {
        iRet += wsprintfA(vchPrintBuff+iRet,"rec=%xh: Srvr=%xh dir=%xh shd=%xh prev=%xh next=%xh Stts=%xh, RfPr=%d PnCnt=%x PnFlgs=%xh DrEntr=%d\r\n"
                    ,ulRec
                    , lpQrec->ulidShare
                    , lpQrec->ulidDir
                    , lpQrec->ulidShadow
                    , lpQrec->ulrecPrev
                    , lpQrec->ulrecNext
                    , (unsigned long)(lpQrec->usStatus)
                    , (unsigned long)(lpQrec->uchRefPri)
                    , (unsigned long)(lpQrec->uchHintPri)
                    , (unsigned long)(lpQrec->uchHintFlags)
                    , lpQrec->ulrecDirEntry

            );

        (lpfnPrintProc)(vchPrintBuff);
    }
}

VOID PrintShareRec(
    unsigned ulRec,
    LPSHAREREC lpSR,
    PRINTPROC lpfnPrintProc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=0;

    if (lpfnPrintProc)
    {
        iRet += wsprintfA(vchPrintBuff+iRet,"Type=%c Flags=%xh hShare=%lxh Root=%0lxh status=%xh Share=%s \r\n"
             , lpSR->uchType, (unsigned)lpSR->uchFlags, ulRec, lpSR->ulidShadow
             , lpSR->uStatus, lpSR->rgPath);
        iRet += wsprintfA(vchPrintBuff+iRet,"Hint: HintFlags=%xh, HintPri=%d, IHPri=%d\r\n",
                     (unsigned)(lpSR->uchHintFlags)
                     , (int)(lpSR->uchHintPri)
                     , (int)(lpSR->uchIHPri));

        iRet += wsprintfA(vchPrintBuff+iRet,"\r\n");

        (lpfnPrintProc)(vchPrintBuff+iRet);
    }
}

VOID PrintFilerec(
    unsigned ulRec,
    LPFILERECEXT    lpFR,
    unsigned    ulSpaces,
    PRINTPROC lpfnPrintProc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int i;
    int iRet=0;

    if (lpfnPrintProc)
    {
        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);

        iRet += wsprintfA(vchPrintBuff+iRet,"Type=%c Flags=%xh Inode=%0lxh status=%xh 83Name=%ls size=%ld attrib=%lxh \r\n",
            lpFR->sFR.uchType, (unsigned)lpFR->sFR.uchFlags, lpFR->sFR.ulidShadow,
            lpFR->sFR.uStatus, lpFR->sFR.rgw83Name, lpFR->sFR.ulFileSize, lpFR->sFR.dwFileAttrib);

        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);

        iRet += wsprintfA(vchPrintBuff+iRet,"time: hi=%lxh lo=%lxh orgtime: hi=%lxh lo=%lxh\r\n"
                     , lpFR->sFR.ftLastWriteTime.dwHighDateTime,lpFR->sFR.ftLastWriteTime.dwLowDateTime
                     , lpFR->sFR.ftOrgTime.dwHighDateTime,lpFR->sFR.ftOrgTime.dwLowDateTime);

        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);

        iRet += wsprintfA(vchPrintBuff+iRet,"Hint: HintFlags=%xh, RefPri=%d, HintPri=%d AliasInode=%0lxh \r\n",
                     (unsigned)(lpFR->sFR.uchHintFlags)
                     , (int)(lpFR->sFR.uchRefPri)
                     , (int)(lpFR->sFR.uchHintPri)
                     , lpFR->sFR.ulidShadowFrom);

        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);

        iRet += wsprintfA(vchPrintBuff+iRet,"LFN=%-14ls", lpFR->sFR.rgwName);

        for(i = 0; i < OvfCount(lpFR); ++i)
        {
            iRet += wsprintfA(vchPrintBuff+iRet,"%-74s", &(lpFR->sFR.ulidShadow));
        }

        iRet += wsprintfA(vchPrintBuff+iRet,"\r\n");

        (lpfnPrintProc)(vchPrintBuff);
    }
}

int
PrintSpaces(
    LPSTR   lpBuff,
    unsigned    ulSpaces
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    unsigned i;
    int iRet=0;

    for (i=0; i< ulSpaces; ++i)
    {
        iRet += wsprintfA(lpBuff+iRet," ");
    }
    return iRet;

}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\recordse.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    recordse.c

Abstract:

    This module implements all security related functions for disconnected
    operation of Client Side Caching at the record level. This facilitates the
    usage of a user mode integrity checker at the record level.

Revision History:

    Balan Sethu Raman     [SethuR]    6-October-1997

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

#ifndef CSC_RECORDMANAGER_WINNT
#include "record.h"
#endif //ifndef CSC_RECORDMANAGER_WINNT

#define CSC_INVALID_FILE_HANDLE (0)

CSC_SECURITY CscSecurity = { CSC_INVALID_FILE_HANDLE, NULL };
BOOL    vfStopCachingSidFileHandle = FALSE;

#define CSC_NUMBER_OF_SIDS_OFFSET (0x0)
#define CSC_SID_SIZES_OFFSET      (CSC_NUMBER_OF_SIDS_OFFSET + sizeof(ULONG))

// These macros define the associated Global variables for assert macros
AssertData
AssertError

DWORD
CscLoadSidMappings(
    CSCHFILE     hSidFile,
    PCSC_SIDS *pCscSidsPointer)
/*++

Routine Description:

    This routine loads the sid mappings from the CSC database to a memory
    data structure.

Arguments:

    hSidFile -- the file for loading the mappings from.

Return Value:

    STATUS_SUCCESS - if the mappings were successfully loaded

    Other Status codes correspond to error situations.

Notes:

    There are two important considerations that need to be satisfied in the
    implementation ..

    1) During remote boot the regular API for reading/writing files are not
    available. There will be an OS layer implementation for the same.
    Consequently this routine must implement the loading in terms of the OS
    layer APIs.

    2) The data structure is geared towards the fact that there are very few
    sid to index mappings. Consequently a simple array suffices.

    The format in which the mappings are stored is as follows

        1) number of sids
        2) sizes of the various sids
        3) the sids
--*/
{
    DWORD       Status = ERROR_SUCCESS;
    ULONG       NumberOfSids;
    ULONG        BytesRead;
    ULONG       i;
    PCSC_SIDS   pCscSids = NULL;

    BytesRead = ReadFileLocal(
                    hSidFile,
                    CSC_NUMBER_OF_SIDS_OFFSET,
                    &NumberOfSids,
                    sizeof(NumberOfSids));

    if (BytesRead == sizeof(NumberOfSids)) {

        // Allocate the Sids Array
        pCscSids = (PCSC_SIDS)AllocMem(
                                  sizeof(CSC_SIDS) + sizeof(CSC_SID) * NumberOfSids);

        if (pCscSids != NULL) {
            pCscSids->MaximumNumberOfSids = NumberOfSids;
            pCscSids->NumberOfSids = NumberOfSids;

            for (i = 0; i < NumberOfSids; i++) {
                pCscSids->Sids[i].pSid = NULL;
            }

            BytesRead = ReadFileLocal(
                            hSidFile,
                            CSC_SID_SIZES_OFFSET,
                            &pCscSids->Sids,
                            sizeof(CSC_SID) * NumberOfSids);

            if (BytesRead != (sizeof(CSC_SID) * NumberOfSids)) {
                Status = ERROR_INVALID_DATA;
            }
        } else {
            Status = ERROR_NO_SYSTEM_RESOURCES;
        }

        // The array structure has been initialized correctly. Each of the
        // individual sids needs to be initialized.
        if (Status == ERROR_SUCCESS) {
            ULONG SidOffset = CSC_SID_SIZES_OFFSET +
                              sizeof(CSC_SID) * NumberOfSids;

            for (i = 0; i < NumberOfSids; i++) {
                pCscSids->Sids[i].pSid = AllocMem(pCscSids->Sids[i].SidLength);

                if (pCscSids->Sids[i].pSid != NULL) {
                    BytesRead = ReadFileLocal(
                                    hSidFile,
                                    SidOffset,
                                    pCscSids->Sids[i].pSid,
                                    pCscSids->Sids[i].SidLength);

                    if (BytesRead == pCscSids->Sids[i].SidLength) {
                        // Validate the Sid
                    } else {
                        Status = ERROR_INVALID_DATA;
                        break;
                    }
                }

                SidOffset += pCscSids->Sids[i].SidLength;
            }
        }

        if (Status != ERROR_SUCCESS) {
            if (pCscSids != NULL) {
                // There was a problem loading the SID mappings. The mapping structure
                // needs to be torn down.

                for (i=0; i < NumberOfSids; i++) {
                    if (pCscSids->Sids[i].pSid != NULL) {
                        FreeMem(pCscSids->Sids[i].pSid);
                    }
                }

                FreeMem(pCscSids);
            }

            pCscSids = NULL;
        } else {
            // The loading was successful.
            *pCscSidsPointer = pCscSids;
        }
    } else {
        Status = ERROR_INVALID_DATA;
    }

    // On exit from this routine either pCscSids must be NULL or the status
    // must be ERROR_SUCCESS

    if (!((pCscSids == NULL) || (Status == ERROR_SUCCESS))) {
        Assert(FALSE);
    }

    return Status;
}

DWORD
CscSaveSidMappings(
    CSCHFILE     hSidFile,
    PCSC_SIDS pCscSids)
/*++

Routine Description:

    This routine saves the sid mappings to the CSC database from a memory
    data structure.

Arguments:

    hSidFile -- the file for loading the mappings from.

Return Value:

    ERROR_SUCCESS - if the mappings were successfully loaded

    Other Status codes correspond to error situations.

Notes:

    Refer to CscLoadSidMappings

--*/
{
    DWORD  Status = ERROR_SUCCESS;
    ULONG  NumberOfSids,i;
    ULONG  BytesWritten;

    if (pCscSids == NULL) {
        NumberOfSids = 0;
    } else {
        NumberOfSids = pCscSids->NumberOfSids;
    }

    BytesWritten = WriteFileLocal(
                       hSidFile,
                       CSC_NUMBER_OF_SIDS_OFFSET,
                       &NumberOfSids,
                       sizeof(DWORD));

    if (BytesWritten != sizeof(DWORD)) {
        Status = ERROR_INVALID_DATA;
    }

    if ((Status == ERROR_SUCCESS) &&
        (NumberOfSids > 0)) {
        // Write out the CSC_SID data structures corresponding to the various
        // Sids

        BytesWritten = WriteFileLocal(
                           hSidFile,
                           CSC_SID_SIZES_OFFSET,
                           pCscSids->Sids,
                           sizeof(CSC_SID) * NumberOfSids);

        if (BytesWritten == (sizeof(CSC_SID) * NumberOfSids)) {
            ULONG SidOffset = CSC_SID_SIZES_OFFSET + sizeof(CSC_SID) * NumberOfSids;

            for (i = 0; i < NumberOfSids; i++) {
                BytesWritten = WriteFileLocal(
                                   hSidFile,
                                   SidOffset,
                                   pCscSids->Sids[i].pSid,
                                   pCscSids->Sids[i].SidLength);

                if (BytesWritten != pCscSids->Sids[i].SidLength) {
                    Status = ERROR_INVALID_DATA;
                    break;
                }

                SidOffset += pCscSids->Sids[i].SidLength;
            }
        }
    }

    return Status;
}

DWORD
CscInitializeSecurity(
    LPVOID  ShadowDatabaseName)
/*++

Routine Description:

    This routine initializes the infra structure required for caching SIDs/
    access rights in the CSC database.

Arguments:

    ShadowDatabaseName - the root of the shadow database

Return Value:

    STATUS_SUCCESS - if the mappings were successfully loaded

    Other Status codes correspond to error situations.

--*/
{
    DWORD   Status;
    LPTSTR  MappingsFileName;

    Assert(CscSecurity.hSidMappingsFile == CSC_INVALID_FILE_HANDLE);

#if 0
    // Initialize the ACL used with all CSC files

    Status = CscInitializeSecurityDescriptor();

    if (Status != ERROR_SUCCESS) {
        return Status;
    }
#endif

    CscSecurity.hSidMappingsFile = CSC_INVALID_FILE_HANDLE;
    CscSecurity.pCscSids = NULL;

    // A copy of the shadow database name root is kept here.
    // Currently we do not make a copy of this name
    CscSecurity.ShadowDatabaseName = ShadowDatabaseName;

    MappingsFileName = FormNameString(
                           CscSecurity.ShadowDatabaseName,
                           ULID_SID_MAPPINGS);

    if (MappingsFileName != NULL) {
        CscSecurity.hSidMappingsFile = OpenFileLocal(MappingsFileName);

        if (CscSecurity.hSidMappingsFile != CSC_INVALID_FILE_HANDLE) {
            Status = CscLoadSidMappings(
                         CscSecurity.hSidMappingsFile,
                         &CscSecurity.pCscSids);

            // if we are not supposed to cache the file handle
            // then close it
            if (vfStopCachingSidFileHandle)
            {
                CloseFileLocal(CscSecurity.hSidMappingsFile);
                CscSecurity.hSidMappingsFile = CSC_INVALID_FILE_HANDLE;
            }
        } else {
            CscSecurity.pCscSids = NULL;
            Status = ERROR_SUCCESS;
        }
    } else {
        Status = ERROR_NO_SYSTEM_RESOURCES;
    }

    FreeNameString(MappingsFileName);

    if (Status != ERROR_SUCCESS) {
        CscTearDownSecurity(NULL);
    }

    return Status;
}

DWORD
CscTearDownSecurity(LPSTR s)
/*++

Routine Description:

    This routine tears down the infrastructure required for caching SIDs/
    access rights in the CSC database.

Return Value:

    STATUS_SUCCESS - if the mappings were successfully loaded

    Other Status codes correspond to error situations.

--*/
{
    if (CscSecurity.hSidMappingsFile != CSC_INVALID_FILE_HANDLE) {
        CloseFileLocal(CscSecurity.hSidMappingsFile);
        CscSecurity.hSidMappingsFile = CSC_INVALID_FILE_HANDLE;

    }

    if (CscSecurity.pCscSids != NULL) {
        ULONG i;

        for (i = 0;i < CscSecurity.pCscSids->NumberOfSids;i++) {
            if (CscSecurity.pCscSids->Sids[i].pSid != NULL) {
                FreeMem(CscSecurity.pCscSids->Sids[i].pSid);
            }
        }

        FreeMem(CscSecurity.pCscSids);
        CscSecurity.pCscSids = NULL;
        if (CscSecurity.ShadowDatabaseName == s)
            CscSecurity.ShadowDatabaseName = NULL;
    }

#if 0
    CscUninitializeSecurityDescriptor();
#endif
    return ERROR_SUCCESS;
}

DWORD
CscWriteOutSidMappings()
/*++

Routine Description:

    This routine writes out the SID mappings onto the persistent store for the
    CSC database

Return Value:

    ERROR_SUCCESS if successful, otherwise appropriate error

--*/
{
    DWORD   Status;
    LPTSTR  TemporaryMappingsFileName;
    LPTSTR  MappingsFileName;

    TemporaryMappingsFileName = FormNameString(
                                    CscSecurity.ShadowDatabaseName,
                                    ULID_TEMPORARY_SID_MAPPINGS);

    MappingsFileName = FormNameString(
                           CscSecurity.ShadowDatabaseName,
                           ULID_SID_MAPPINGS);

    if ((TemporaryMappingsFileName != NULL) &&
        (MappingsFileName != NULL)) {
        CSCHFILE hNewSidMappingsFile;

        hNewSidMappingsFile = OpenFileLocal(TemporaryMappingsFileName);

        if (hNewSidMappingsFile == CSC_INVALID_FILE_HANDLE) {
            hNewSidMappingsFile = R0OpenFileEx(ACCESS_READWRITE, ACTION_CREATEALWAYS, FILE_ATTRIBUTE_SYSTEM, TemporaryMappingsFileName, FALSE);
        }

        if (hNewSidMappingsFile != CSC_INVALID_FILE_HANDLE) {
            Status = CscSaveSidMappings(
                        hNewSidMappingsFile,
                        CscSecurity.pCscSids);

            if (Status == ERROR_SUCCESS) {
                CloseFileLocal(hNewSidMappingsFile);
                hNewSidMappingsFile = CSC_INVALID_FILE_HANDLE;

                if (CscSecurity.hSidMappingsFile != CSC_INVALID_FILE_HANDLE) {
                    CloseFileLocal(CscSecurity.hSidMappingsFile);
                    CscSecurity.hSidMappingsFile = CSC_INVALID_FILE_HANDLE;
                }

                Status = (DWORD)RenameFileLocal(
                                    TemporaryMappingsFileName,
                                    MappingsFileName);

                if (Status == ERROR_SUCCESS) {
                    if (!vfStopCachingSidFileHandle)
                    {
                        CscSecurity.hSidMappingsFile = OpenFileLocal(MappingsFileName);

                        if (CscSecurity.hSidMappingsFile == CSC_INVALID_FILE_HANDLE) {
                            Status = ERROR_INVALID_DATA;
                        }
                    }
                }
            }
        }
    } else {
        Status = ERROR_NO_SYSTEM_RESOURCES;
    }

    if (MappingsFileName != NULL) {
        FreeNameString(MappingsFileName);
    }

    if (TemporaryMappingsFileName != NULL) {
        FreeNameString(TemporaryMappingsFileName);
    }

    return Status;
}

CSC_SID_INDEX
CscMapSidToIndex(
    PVOID   pSid,
    ULONG   SidLength)
/*++

Routine Description:

    This routine maps a sid to the appropriate index in the CSC database (
    memory data structure)

Arguments:

    pSid -- the sid which is to be mapped.

    SidLength - the length of the Sid

Return Value:

    either valid index or CSC_INVALID_SID_INDEX if none was found.

Notes:

    This routine assumes that Sids are DWORD aligned.

--*/
{
    PCSC_SIDS pCscSids = CscSecurity.pCscSids;

    CSC_SID_INDEX SidIndex = CSC_INVALID_SID_INDEX;

    if ((pSid == CSC_GUEST_SID) &&
        (SidLength == CSC_GUEST_SID_LENGTH)) {
        return CSC_GUEST_SID_INDEX;
    }

    if (pCscSids != NULL) {
        CSC_SID_INDEX i;

        for (i=0; i < pCscSids->NumberOfSids; i++) {
            if (pCscSids->Sids[i].SidLength == SidLength) {
                PBYTE  pSid1,pSid2;

                ULONG  NumberOfBytes;

                pSid1 = (PBYTE)pSid;
                pSid2 = (PBYTE)pCscSids->Sids[i].pSid;

                NumberOfBytes = SidLength;

                for (;;) {
                    if (NumberOfBytes >= sizeof(ULONG)) {
                        if (*((PULONG)pSid1) != *((PULONG)pSid2)) {
                            break;
                        }

                        pSid1 += sizeof(ULONG);
                        pSid2 += sizeof(ULONG);
                        NumberOfBytes -= sizeof(ULONG);

                        continue;
                    }

                    if (NumberOfBytes >= sizeof(USHORT)) {
                        if (*((PUSHORT)pSid1) != *((PUSHORT)pSid2)) {
                            break;
                        }

                        pSid1 += sizeof(USHORT);
                        pSid2 += sizeof(USHORT);
                        NumberOfBytes -= sizeof(USHORT);
                    }

                    if (NumberOfBytes == sizeof(BYTE)) {
                        if (*((PUSHORT)pSid1) != *((PUSHORT)pSid2)) {
                            break;
                        }

                        NumberOfBytes -= sizeof(BYTE);
                    }

                    break;
                }

                if (NumberOfBytes == 0) {
                    // Since 0 is the invalid index ensure that the valid
                    // sid indices are never zero
                    SidIndex = i + 1;
                    break;
                }
            }
        }
    }

    return SidIndex;
}

DWORD
CscAddSidToDatabase(
    PVOID           pSid,
    ULONG           SidLength,
    PCSC_SID_INDEX  pSidIndex)
/*++

Routine Description:

    This routine maps a sid to the appropriate index in the CSC database (
    memory data structure). If a mapping does not exist a new one is created

Arguments:

    pSid - the sid which is to be mapped.

    SidLength - the length of the Sid

    pSidIndex - set to the newly assingned index on exit

Return Value:

    ERROR_SUCCESS if successful, otherwise appropriate error

Notes:

    This routine assumes that Sids are DWORD aligned.

--*/
{
    DWORD Status = ERROR_SUCCESS;

    ULONG i,NumberOfSids;

    *pSidIndex = CscMapSidToIndex(
                     pSid,
                     SidLength);

    if (*pSidIndex == CSC_INVALID_SID_INDEX) {
        PCSC_SIDS pOldCscSids = NULL;
        PCSC_SIDS pCscSids    = CscSecurity.pCscSids;

        // The Sid does not exist and it needs to be added to the table
        // of mappings

        pOldCscSids = pCscSids;

        if ((pCscSids == NULL) ||
            (pCscSids->MaximumNumberOfSids == pCscSids->NumberOfSids)) {

            NumberOfSids =  (pOldCscSids != NULL)
                            ? pOldCscSids->NumberOfSids
                            : 0;

            NumberOfSids += CSC_SID_QUANTUM;

            // Allocate a new chunk of memory for the sid mapping array and
            // copy over the existing mappings before adding the new ones

            pCscSids = (PCSC_SIDS)AllocMem(
                                      sizeof(CSC_SIDS) +
                                      sizeof(CSC_SID) * NumberOfSids);

            if (pCscSids != NULL) {
                pCscSids->MaximumNumberOfSids = NumberOfSids;
                pCscSids->NumberOfSids = NumberOfSids - CSC_SID_QUANTUM;

                if (pOldCscSids != NULL) {
                    for (i = 0; i < pOldCscSids->NumberOfSids; i++) {
                        pCscSids->Sids[i] = pOldCscSids->Sids[i];
                    }
                }
            } else {
                Status = ERROR_NO_SYSTEM_RESOURCES;
            }
        }

        if ((Status == ERROR_SUCCESS) &&
            (pCscSids->MaximumNumberOfSids > pCscSids->NumberOfSids)) {
            CSC_SID_INDEX SidIndex;

            SidIndex = (CSC_SID_INDEX)pCscSids->NumberOfSids;
            pCscSids->Sids[SidIndex].pSid = AllocMem(SidLength);

            if (pCscSids->Sids[SidIndex].pSid != NULL) {
                PBYTE pSid1, pSid2;
                ULONG NumberOfBytes = SidLength;

                pSid1 = pSid;
                pSid2 = pCscSids->Sids[SidIndex].pSid;

                while (NumberOfBytes > 0) {
                    *pSid2++ = *pSid1++;
                    NumberOfBytes--;
                }

                pCscSids->Sids[SidIndex].SidLength = SidLength;

                *pSidIndex = SidIndex + 1;
                pCscSids->NumberOfSids++;
            } else {
                Status = ERROR_NO_SYSTEM_RESOURCES;
            }
        }

        if (Status == ERROR_SUCCESS) {
            CscSecurity.pCscSids = pCscSids;

            // Save the mappings
            Status = CscWriteOutSidMappings();
        }

        if (Status == ERROR_SUCCESS) {
            if (pOldCscSids != pCscSids) {
                // Walk through and free the old mappings structure
                if (pOldCscSids != NULL) {
                    FreeMem(pOldCscSids);
                }
            }
        } else {
            if ((pCscSids != NULL)&&(pCscSids != pOldCscSids)) {
                FreeMem(pCscSids);
            }

            CscSecurity.pCscSids = pOldCscSids;
        }
    }

    return Status;
}

DWORD
CscRemoveSidFromDatabase(
    PVOID   pSid,
    ULONG   SidLength)
/*++

Routine Description:

    This routine removes a mapping for a sid to the appropriate index in the CSC
    database

Arguments:

    pSid - the sid which is to be mapped.

    SidLength - the length of the Sid

Return Value:

    ERROR_SUCCESS if successful, otherwise appropriate error

Notes:

    This routine assumes that Sids are DWORD aligned.

--*/
{
    DWORD Status = ERROR_SUCCESS;
    ULONG SidIndex,i;

    SidIndex = CscMapSidToIndex(
                   pSid,
                   SidLength);

    if (SidIndex != CSC_INVALID_SID_INDEX) {
        // Slide all the Sids following this index by 1 and decrement the
        // number of sids for which mappings exist.

        for (i = SidIndex + 1; i < CscSecurity.pCscSids->NumberOfSids; i++) {
            CscSecurity.pCscSids->Sids[i-1] = CscSecurity.pCscSids->Sids[i];
        }

        CscSecurity.pCscSids->NumberOfSids -= 1;

        // Save the new mappings onto the persistent store
        Status = CscWriteOutSidMappings();
    }

    return Status;
}

BOOL
EnableHandleCachingSidFile(
    BOOL    fEnable
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    BOOL    fOldState = vfStopCachingSidFileHandle;

    if (!fEnable)
    {
        if (vfStopCachingSidFileHandle == FALSE)
        {
            if (CscSecurity.hSidMappingsFile != CSC_INVALID_FILE_HANDLE)
            {
                CloseFileLocal(CscSecurity.hSidMappingsFile);
                CscSecurity.hSidMappingsFile = CSC_INVALID_FILE_HANDLE;
            }
            vfStopCachingSidFileHandle = TRUE;
        }
    }
    else
    {
        vfStopCachingSidFileHandle = FALSE;
    }

    return fOldState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\shadow.asm ===
PAGE 58,132
;******************************************************************************
TITLE SHADOW.ASM - Windows/386 NETBIOS SHADOW FOR REMOTE NETWORK ACCESS
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1987-1993
;
;   Title: SHADOW.ASM -
;
;
;
;   Version:
;
;   Date:
;
;   Author:
;
;------------------------------------------------------------------------------

        .386p

.XLIST

WIN40COMPAT     equ     1

        include vmm.inc
        include shell.inc
        include debug.inc
        include ifsmgr.inc
        include dosmgr.inc
        include vxdldr.inc
        include vwin32.inc
        include winnetwk.inc
	include netvxd.inc
	include vrdsvc.inc
.LIST

        extern  _ProcessRegisterNet:near
        extern  _ProcessNetFunction:near
IFDEF HOOKMOUNT
        extern  _ProcessRegisterMount:near
ENDIF
        extern  _FS_ConnectResourceShadow:near
        extern  _IoctlRegisterAgent:near
        extern  _IoctlUnRegisterAgent:near
        extern  _IoctlGetUNCPath:near
        extern  _IoctlBeginPQEnum:near
        extern  _IoctlEndPQEnum:near
        extern  _IoctlNextPriShadow:near
        extern  _IoctlPrevPriShadow:near
        extern  _IoctlGetShadowInfo:near
        extern  _IoctlSetShadowInfo:near
        extern  _IoctlCopyChunk:near
        extern  _IoctlChkUpdtStatus:near
        extern  _IoctlDoShadowMaintenance:near
        extern  _IoctlBeginReint:near
        extern  _IoctlEndReint:near
        extern  _IoctlCreateShadow:near
        extern  _IoctlDeleteShadow:near
        extern  _IoctlSetServerStatus:near
        extern  _IoctlGetServerStatus:near
        extern  _IoctlAddUse:near
        extern  _IoctlDelUse:near
        extern  _IoctlGetUse:near
        extern  _ActOnCreateVM:near
        extern  _ActOnResumeVM:near
        extern  _ActOnSetDeviceFocus:near
        extern  _TerminateHook:near
        extern  _IoctlSwitches:near
        extern  _IoctlGetShadow:near
        extern  _IoctlGetGlobalStatus:near
        extern  _IoctlFindOpenHSHADOW:near
        extern  _IoctlFindNextHSHADOW:near
        extern  _IoctlFindCloseHSHADOW:near
        extern  _IoctlGetPriorityHSHADOW:near
        extern  _IoctlSetPriorityHSHADOW:near
        extern  _IoctlAddHint:near
        extern  _IoctlDeleteHint:near
        extern  _IoctlFindOpenHint:near
        extern  _IoctlFindNextHint:near
        extern  _IoctlFindCloseHint:near
        extern  _IoctlGetAliasHSHADOW:near
        extern  _FS_FakeNetConnect:near
	extern	_ActOnTerminateThread:near

IFDEF DEBUG
        extern  _ShadowRestrictedEventCallback:near
	extern  _DebugQueryCmdStr:byte
	extern  _DebugQueryCmdStrLen:dword
        extern  _SHDDebug:near
ENDIF

Declare_Virtual_Device SHADOW, 3, 0Ah, Shadow_Control, CSC_Device_ID, IFSMgr_Init_Order+1,,Shadow_PM_Api_Handler

SHADOW_VERSION                  EQU 8287h
API_SUCCESS                     EQU 1
API_FAILURE                     EQU 0
Time_Out_Period                 EQU 1100
MAX_LANS                        EQU 16
Shadow_IOCTL_BASE               EQU 1001
Shadow_IOCTL_GENERROR           EQU 1
TRUE                            EQU 1
FALSE                           EQU 0

;SHADOW_OEM_ID                   EQU     00220000h



IFDEF   DEBUG
SHADOW_LOG_TIME_INTERVAL        EQU 60000
SHADOW_STATS_FLUSH_COUNT        EQU 10
ENDIF

VxD_DATA_SEG

IFDEF DEBUG
_NbDebug        dd 0
ENDIF
                public  OrigRegisterNetFunc
                public  _OrigNetFunction
                public  _fLog
                public  _fShadow
                public  _fShadowFind
                public  _fDiscon
                public  _fNoShadow
                public  _OrigSetupFailedConnection
                public  _proidShadow
                public  _FCBToShort
                public  _ShortToFCB
		public	_DebugMenu
		public	_GetConfigDir
                public  _Get_Sys_VM_Handle
                public  _Get_Cur_VM_Handle
		public	_Call_VM_Event
		public	_SetWin32Event
		public	_CloseVxDHandle
		public	_VRedirCSCInfoFunction
		public	_MyCheckAccessConflict


OrigRegisterNetFunc             dd      -1
_OrigNetFunction                dd      0
OrigHookDeviceService           dd      0
NextNetFunction                 dd      0
_OrigSetupFailedConnection      dd      0
_proidShadow                    dd      0
_VRedirCSCInfoFunction		dd	0

IFDEF HOOKMOUNT
                public  OrigRegisterMountFunc

OrigRegisterMountFunc     dd      -1
ENDIF

ALIGN 4
indos_ptr       dd 0

IFDEF DEBUG
Alloc_watch     dd 0
Alloc_table     dd 512 DUP (0)
Alloc_sizes     dd 512 DUP (0)
Alloc_cnt       dd 0
ENDIF

ALIGN 4
Shadow_PM_API_Table LABEL DWORD

        dd    offset32 Shadow_PM_API_Get_Version

Shadow_PM_API_Max          EQU ($-Shadow_PM_API_Table)/4

Shadow_IOCTL_Table LABEL DWORD

        dd    offset32 Shadow_PM_API_Register_Agent
        dd    offset32 Shadow_PM_API_UnRegister_Agent
        dd    offset32 Shadow_PM_API_GetUNCPath
        dd    offset32 Shadow_PM_API_BeginPQEnum
        dd    offset32 Shadow_PM_API_EndPQEnum
        dd    offset32 Shadow_PM_API_NextPriShadow
        dd    offset32 Shadow_PM_API_PrevPriShadow
        dd    offset32 Shadow_PM_API_GetShadowInfo
        dd    offset32 Shadow_PM_API_SetShadowInfo
        dd    offset32 Shadow_PM_API_ChkUpdtStatus
        dd    offset32 Shadow_PM_API_DoShadowMaintenance
        dd    offset32 Shadow_PM_API_CopyChunk
        dd    offset32 Shadow_PM_API_BeginReint
        dd    offset32 Shadow_PM_API_EndReint
        dd    offset32 Shadow_PM_API_CreateShadow
        dd    offset32 Shadow_PM_API_DeleteShadow
        dd    offset32 Shadow_PM_API_GetServerStatus
        dd    offset32 Shadow_PM_API_SetServerStatus
        dd    offset32 Shadow_PM_API_AddUse
        dd    offset32 Shadow_PM_API_DelUse
        dd    offset32 Shadow_PM_API_GetUse
        dd    offset32 Shadow_PM_API_Switches
        dd    offset32 Shadow_PM_API_GetShadow
        dd    offset32 Shadow_PM_API_GetGlobalStatus
        dd    offset32 Shadow_PM_API_FindOpenHSHADOW
        dd    offset32 Shadow_PM_API_FindNextHSHADOW
        dd    offset32 Shadow_PM_API_FindCloseHSHADOW
        dd    offset32 Shadow_PM_API_GetPriorityHSHADOW
        dd    offset32 Shadow_PM_API_SetPriorityHSHADOW
        dd    offset32 Shadow_PM_API_AddHint
        dd    offset32 Shadow_PM_API_DeleteHint
        dd    offset32 Shadow_PM_API_FindOpenHint
        dd    offset32 Shadow_PM_API_FindNextHint
        dd    offset32 Shadow_PM_API_FindCloseHint
        dd    offset32 Shadow_PM_API_GetAliasHSHADOW
Shadow_IOCTL_MAX          EQU ($-Shadow_IOCTL_Table)/4

IFDEF DEBUG

Debug_Menu LABEL DWORD
        dd  OFFSET32 MinDbg_Str,     OFFSET32 MinDbg_Debug
        dd  OFFSET32 DefaultDbg_Str, OFFSET32 DefaultDbg_Debug
        dd  OFFSET32 MaxDbg_Str,     OFFSET32 MaxDbg_Debug
        dd  OFFSET32 Alloc_Str,      OFFSET32 Alloc_Debug
        dd  OFFSET32 Heap_Str,       OFFSET32 AllocDisplay_Debug

Debug_Menu_Len equ ($ - Debug_Menu)/8
        dd  0

MinDbg_Str          db "Minimal debug output", 0
DefaultDbg_Str      db "Default debug output", 0
MaxDbg_Str          db "Maximum debug output", 0
Alloc_Str           db "Monitor memory allocations", 0
Heap_Str            db "Display current memory allocations", 0
Shadow_Str          db "Shadow",0
ENDIF ; DEBUG

_fLog               dd  0
_fShadow            dd  0
_fDiscon            dd  0
_fNoShadow          dd  0
_cntTicks           dd  0
_fShadowFind        dd  0

sz386Enh            db "386enh",0
_vszShadowOverride      db "NoShadow",0

extern _ulMaxStoreSize:DWORD

VxD_DATA_ENDS

VxD_LOCKED_DATA_SEG

VxD_LOCKED_DATA_ENDS

VxD_CODE_SEG

;******************************************************************************
;
; @doc      INTERNAL      SHADOW
;
; @api      LocalAlloc | Allocates page-locked memory.
;
; @parm     flags | ignored
;
; @parm     bytesneeded | number of bytes of memory required
;
; @rdesc    Returns address of memory if allocation succeeds
;           or zero if allocation failed.
;
;******************************************************************************

LocalAlloc proc near c public, flags:dword, bytesneeded:dword

        mov     eax, bytesneeded

        push    eax
        VxDcall IFSMgr_GetHeap
        pop     ecx                     ; Clear stack
        test    eax, eax
        jz short AH50

AH20:

IFDEF DEBUG
        jmp     AH_Debug
ENDIF
        cld
        ret

; Heap allocation failed.  Try to fill the spare if inDos not set.

AH50:

        mov     ecx, indos_ptr
        cmp     word ptr [ecx], 0
        jne     short AH20

        VxDcall IFSMgr_FillHeapSpare

        push    bytesneeded
        VxDcall IFSMgr_GetHeap
        pop     ecx                     ; Clear stack

IFDEF DEBUG
        jmp     AH_Debug
ENDIF
        cld
        ret


IFDEF DEBUG

AH_Debug:

        cld
        pushad
        test    eax, eax
        jnz     AH_GotMem
        Debug_Out "Shadow: LocalAlloc Failed"
        jmp     AH_Done

AH_GotMem:

        mov     edx, Alloc_watch
        or      edx, edx
        jz      AH_NoTrace
        mov     edx, bytesneeded
;        Trace_Out "Shadow: LocalAlloc #EDX bytes at #EAX"

AH_NoTrace:

        mov     edi, OFFSET32 Alloc_table
        mov     ecx, Alloc_cnt
        mov     [edi + ecx *4], eax
        mov     edi, OFFSET32 Alloc_sizes
        mov     edx, bytesneeded
        mov     [edi + ecx *4], edx
        inc     Alloc_cnt

AH_Done:
        popad
        ret

ENDIF


LocalAlloc endp

;******************************************************************************
;
; @doc      INTERNAL      SHADOW
;
; @api      LocalFree | Frees a previously allocated block of page-locked memory.
;
; @parm     memhandle | address of the block to be freed
;
; @rdesc    Returns zero.
;
;******************************************************************************

LocalFree proc near c public, memhandle:dword
        mov     eax, memhandle

IFDEF DEBUG

        pushad

IFDEF DEBUG
        mov     ecx, eax
        call    _ShadowCheckHeap
ENDIF

        mov     edi, OFFSET32 Alloc_table
        mov     ecx, Alloc_cnt
        cld
        repne   scasd
        jz      FH_Found
        Debug_Out "Shadow: LocalFree invalid handle"
        jmp     FH_Done

FH_Found:

        sub     edi, 4
        xor     ecx, ecx
        mov     [edi], ecx
        mov     esi, OFFSET32 Alloc_table
        mov     edx, Alloc_cnt
        dec     edx
        mov     ebx, [esi + edx * 4]
        mov     [edi], ebx
        mov     esi, OFFSET32 Alloc_sizes
        mov     ebx, [esi + edx * 4]
        sub     edi, OFFSET32 Alloc_table
        add     edi, OFFSET32 Alloc_sizes
        mov     [edi], ebx
        mov     Alloc_cnt, edx
        mov     edx, Alloc_watch
        or      edx, edx
        jz      FH_Done
;        Trace_Out "Shadow: LocalFree #EAX"

FH_Done:

        popad
ENDIF

        push    eax
        VxDcall IFSMgr_RetHeap
        pop     eax             ; Clear stack, smallest way
        cld
        xor     eax, eax
        ret
LocalFree endp


;******************************************************************************
;
; @doc      INTERNAL      SHADOW
;
; @asm      Shadow_Device_Init | This function is called when the
;           shadow is dynamically loaded.
;
; @reg      EBX | System VM Handle
;
; @reg      EBP | pointer to client regs structure
;
; @rdesc    Register values at return:
;
; @reg      FLAGS | Flags defined at return:
;
; @flag     NC | Succeeded in initializing VxD
;
; @flag     CY | Failed to initializing VxD
;
; @uses     FLAGS
;
; @xref     Shadow_Control
;
;******************************************************************************

BeginProc Shadow_Device_Init, PUBLIC
;        int     1
        xor     eax,eax
        mov     esi, OFFSET32 sz386Enh
        mov     edi, OFFSET32 _vszShadowOverride
        VMMCall Get_Profile_Decimal_Int
        jc      yes_shadow_enable
        jz      yes_shadow_enable
        Trace_Out       "Shadow: Override set"
        mov     _fNoShadow, 1
        stc
        ret

yes_shadow_enable:

	mov	esi, OFFSET32 ShadowNetFunction
	mov	eax, @@IFSMgr_NetFunction
	VMMcall	Hook_Device_Service
        jc      DevInitError
        Trace_Out       "Shadow: Hooked IFSMgr_NetFunction"
	mov	_OrigNetFunction, esi
        clc

	mov	esi, OFFSET32 ShadowHookDeviceService
	mov	eax, @@Hook_Device_Service
	VMMcall	Hook_Device_Service
        jc      DevInitError
        Trace_Out       "Shadow: Hooked Hook_Device_Service"
	mov	OrigHookDeviceService, esi
        clc

Register_Net_Func:
	mov	esi, OFFSET32 ShadowRegisterNetFunc
	mov	eax, @@IFSMgr_RegisterNet
	VMMcall	Hook_Device_Service
        jc      DevInitError
        Trace_Out       "Shadow: Hooked RegisterNet service"
	mov	OrigRegisterNetFunc, esi
        clc

        VxDCall IFSMgr_RegisterNet, <_FS_FakeNetConnect, IFSMGRVERSION, WNNC_NET_COGENT>
        cmp     eax, -1
        jz      DevInitError
        mov     _proidShadow, eax

IFDEF HOOKMOUNT
	mov	esi, OFFSET32 ShadowMountFunction
	mov	eax, @@IFSMgr_RegisterMount
	VMMcall	Hook_Device_Service
        jc      DevInitError
        Trace_Out       "Shadow: Hooked RegisterMount service"
	mov	OrigRegisterMountFunc, esi
        clc
ENDIF
IFDEF DEBUG
        mov     eax, SHADOW_LOG_TIME_INTERVAL
        mov     edx, 0
        mov     esi, OFFSET32 Shadow_Timer_Callback
        VMMCall Set_Global_Time_Out
        mov     eax,esi
        cmp     eax,0
        jne     TimerSet
        Trace_Out       "Shadow: Couldn't set the logging timer"
TimerSet:
ENDIF
	mov	esi, OFFSET32 _FS_ConnectResourceShadow
	mov	eax, @@IFSMgr_SetupFailedConnection
	VMMcall	Hook_Device_Service
        jc      SFC_Error
        Trace_Out       "Shadow: Hooked SetupFailedConnection"
	mov	_OrigSetupFailedConnection, esi
SFC_Error:
        clc
        ret
DevInitError:
        Trace_Out       "Shadow: Error Hooking services"
        mov     _fshadow, 0
        ret

EndProc Shadow_Device_Init


;******************************************************************************
;
; @doc      INTERNAL      SHADOW
;
; @asm      Shadow_Device_Exit | This function is called when the
;           VxD is dynamically unloaded.
;
; @reg      EBX | System VM Handle
;
; @reg      EBP | pointer to client regs structure
;
; @rdesc    Register values at return:
;
; @reg      FLAGS | Flags defined at return:
;
; @flag     NC | Success
;
; @flag     CY | Failure
;
; @uses     FLAGS
;
; @xref     Shadow_Control
;
;
;******************************************************************************

BeginProc Shadow_Device_Exit

        clc
        ret

EndProc Shadow_Device_Exit

;******************************************************************************
;
; @doc      INTERNAL      SHADOW
;
; @asm      Shadow_Sys_VM_Terminate | This function is called when the
;           VxD is dynamically unloaded.
;
; @reg      EBX | System VM Handle
;
; @reg      EBP | pointer to client regs structure
;
; @rdesc    Register values at return:
;
; @reg      FLAGS | Flags defined at return:
;
; @flag     NC | Success
;
; @flag     CY | Failure
;
; @uses     FLAGS
;
; @xref     Shadow_Control
;
;
;******************************************************************************

BeginProc Shadow_Sys_VM_Terminate

        call _TerminateHook
        clc
        ret

EndProc Shadow_Sys_VM_Terminate

;******************************************************************************
;
; @doc      INTERNAL      SHADOW
;
; @asm      Shadow_Control | This function dispatches VxD control messages
;
; @reg      EBX | System VM Handle
;
; @reg      EBP | pointer to client regs structure
;
; @rdesc    Register values at return:
;
; @reg      FLAGS | Flags defined at return:
;
; @flag     NC | Success
;
; @flag     CY | Failure
;
; @uses     FLAGS
;
;******************************************************************************

BeginProc Shadow_Control

        Control_Dispatch Device_Init,           Shadow_Device_Init
        Control_Dispatch System_Exit,           Shadow_Device_Exit
        Control_Dispatch Sys_VM_Terminate,      Shadow_Sys_VM_Terminate
        Control_Dispatch W32_DEVICEIOCONTROL,   Shadow_DeviceIOControl
        Control_Dispatch Create_VM,             Shadow_Create_VM
        Control_Dispatch VM_Resume,             Shadow_Resume_VM
        Control_Dispatch Set_Device_Focus,      Shadow_Set_Device_Focus
	Control_Dispatch terminate_thread,	Shadow_Terminate_Thread

IFDEF DEBUG

        Control_Dispatch Debug_Query, SHDDumpDebug

ENDIF


        clc
        ret

EndProc Shadow_Control


;******************************************************************************
;
; @doc      INTERNAL      SHADOW
;
; @asm      Shadow_DeviceIOControl | This is the single entry point for WIN32
;           Device IOCTL calls.
;
; @reg      EAX | W32_DEVICEIOCONTROL
;
; @reg      EBX | DDB
;
; @reg      ECX | dwIoControlCode
;
; @reg      ESI | Pointer to DIOCParams structure.
;
; @rdesc    Return code in EAX as follows
;
; @flag     0 | Success
;
; @flag     -1 | Asynchronous I/O in progress
;
; @falg     Other | Error code.
;
; @uses     ALL
;
;******************************************************************************

BeginProc Shadow_DeviceIOControl

        push    ebx
        push    esi
        push    edi
        cmp     ecx, DIOC_GETVERSION                    ; Q: Version IOCTL? (must be supported)
        jne     DIOC_10                                 ;   N: Continue
                                                        ;   Y: Information returned from GetVersion TBD
        xor     eax, eax                                ;      Return w/ EAX = 0 (success)
        jmp     DIOC_Done

DIOC_10:
;        cmp     ecx, DIOC_CLOSEHANDLE                   ; Q: Close IOCTL? (must be supported)
;        jne     DIOC_20                                 ;    N: Continue
;        xor     eax, eax                                ;    Y: Return w/ EAX = 0 (success)
;        jmp     DIOC_Done

DIOC_20:
        shr     ecx, 2                                	; as per winioctl.h
	and	ecx, 7ffh				; as per winioctl.h
        sub     ecx, Shadow_IOCTL_BASE
        cmp     ecx, Shadow_IOCTL_MAX                  	; Q: index in range?
        jae     SHORT DIOC_Error                        ;  N: Return error
        mov     edi, [esi.lpvInBuffer]                  ;  Y: Call appropriate API
        call    Shadow_IOCTL_Table[ecx*4]
        cmp     eax, 0
        jl      DIOC_Error
        xor     eax, eax                                ;      Return w/ EAX = 0 (success)


        ; fall-through

DIOC_Done:
        clc
        pop     edi
        pop     esi
        pop     ebx
        ret

DIOC_Error:
        mov     eax, Shadow_IOCTL_GENERROR
        jmp     DIOC_Done

EndProc Shadow_DeviceIOControl

;******************************************************************************
;
; @doc      INTERNAL      SHADOW
;
; @asm      Shadow_Create_VM | This function is called when a virtual
;            machine is created
;
; @reg      EBX | System VM Handle
;
; @reg      EBP | pointer to client regs structure
;
; @rdesc    Register values at return:
;
; @reg      FLAGS | Flags defined at return:
;
; @flag     NC | Succeeded in initializing VxD
;
; @flag     CY | Failed to initializing VxD
;
; @uses     FLAGS
;
; @xref     Shadow_Control
;
;******************************************************************************

BeginProc Shadow_Create_VM, PUBLIC
        call    _ActOnCreateVM
        clc
        ret

EndProc Shadow_Create_VM

;******************************************************************************
;
; @doc      INTERNAL      SHADOW
;
; @asm      Shadow_Resume_VM | This function is called when a virtual
;            machine is created
;
; @reg      EBX | System VM Handle
;
; @reg      EBP | pointer to client regs structure
;
; @rdesc    Register values at return:
;
; @reg      FLAGS | Flags defined at return:
;
; @flag     NC | Succeeded in initializing VxD
;
; @flag     CY | Failed to initializing VxD
;
; @uses     FLAGS
;
; @xref     Shadow_Control
;
;******************************************************************************

BeginProc Shadow_Resume_VM, PUBLIC
        call    _ActOnResumeVM
        clc
        ret

EndProc Shadow_Resume_VM

;******************************************************************************
;
; @doc      INTERNAL      SHADOW
;
; @asm      Shadow_Set_Device_Focus | This function is called when our VXD
;            gets Set_Device_Focus message
;
; @reg      EBX | System VM Handle
;
; @reg      EBP | pointer to client regs structure
;
; @rdesc    Register values at return:
;
; @reg      FLAGS | Flags defined at return:
;
; @flag     NC | Succeeded in initializing VxD
;
; @flag     CY | Failed to initializing VxD
;
; @uses     FLAGS
;
; @xref     Shadow_Control
;
;******************************************************************************

BeginProc Shadow_Set_Device_Focus, PUBLIC
        call    _ActOnSetDeviceFocus
        clc
        ret

EndProc Shadow_Set_Device_Focus

;******************************************************************************
;
; @doc      INTERNAL      SHADOW
;
; @asm      Shadow_Terminate_Thread | This function is called when our VXD
;            gets Terminate_Thread message
;
; @reg      EBX | System VM Handle
;
; @reg      EBP | pointer to client regs structure
;
; @rdesc    Register values at return:
;
; @reg      FLAGS | Flags defined at return:
;
; @flag     NC | Succeeded in initializing VxD
;
; @flag     CY | Failed to initializing VxD
;
; @uses     FLAGS
;
; @xref     Shadow_Control
;
;******************************************************************************

BeginProc Shadow_Terminate_Thread, PUBLIC
	push	edi
        call    _ActOnTerminateThread
	pop	edi
        clc
        ret

EndProc Shadow_Terminate_Thread

;******************************************************************************
;
; @doc      INTERNAL      SHADOW
;
; @asm      Shadow_PM_API_Handler | This is the single entry point for VMs
;           executing in protect-mode.
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      CLIENT_AX | Shadow PM API Index.
;
; @reg      CLIENT_ES:CLIENT_(E)BX | API specific parameters or NULL
;
; @rdesc    Refer to specific APIs for client register values at return.
;           A return value of 0 indicates that the API succeeded, otherwise
;           an error value is returned. The version call is an exception
;
; @uses     FLAGS
;
;******************************************************************************

BeginProc Shadow_PM_API_Handler

        movzx   eax, [ebp.Client_AX]                ; Get API index

        cmp     eax, Shadow_PM_API_MAX             ; Q: index in range?
        jae     SHORT Shadow_Handler_Error         ;  N: Fail call.

        mov     [ebp.Client_AX], 1
        mov     cx,[ebp.Client_ES]                  ; Q: Null Parameters?
        or      cx,[ebp.Client_ES]                  ;  Y: Don't call map_flat
        jz      SHORT Shadow_Handler_Null_Parms

        Client_Ptr_Flat edi, es, bx                 ;  N: EDI -> parameter struc.

Shadow_Handler_Null_Parms:

        call    Shadow_PM_API_Table[eax*4]         ; Call appropriate API
        mov     [ebp.Client_AX], ax
        ret

Shadow_Handler_Error:

        mov     [ebp.Client_AX], API_FAILURE
        ret

EndProc Shadow_PM_API_Handler

;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      Shadow_PM_API_Get_Version | This function returns the version
;           number of the device,
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      CLIENT_AX | VTD API Index.
;
; @rdesc    AX contains version number
;
; @uses     FLAGS
;
; @xref     Shadow_PM_API_Handler
;
;******************************************************************************

BeginProc Shadow_PM_API_Get_Version

        mov     eax, SHADOW_VERSION
        ret

EndProc Shadow_PM_API_Get_Version



;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_Register_Agent | This function allows the
;           reintegartion agent to register itself
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | Contains the window handle
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_Register_Agent
        push    edi
        call    _IoctlRegisterAgent
        pop     edi
        ret
EndProc Shadow_PM_API_Register_Agent

;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_UnRegister_Agent | This function allows the
;           reintegartion agent to unregister itself
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Dont' Care
;
; @reg      EDI | Contains the window handle
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_UnRegister_Agent
        push    edi
        call    _IoctlUnRegisterAgent
        pop     edi
        ret
EndProc Shadow_PM_API_UnRegister_Agent

;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_Get_Copyback_Params | This function is called
;           by the Reintegration Agent. It returns the
;           name of the shadow file that has been modified and
;           the remote file that needs to be updated
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to a PATHS structure :
;               typedef struct tagPATHS
;                  {
;                  unsigned uCookie;  // Indicates the reintegartion ID
;                  LPVOID lpSrc;      // Name of local file
;                  int    cbSrc;      // Buffer size
;                  LPVOD  lpDst;      // Name of remote file
;                  int    cbDst;      // Buffer size
;                  }
;               PATHS;
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_GetUNCPath
        push    edi
        call    _IoctlGetUNCPath
        pop     edi
        ret
EndProc Shadow_PM_API_GetUNCPath


;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_Begin_PQ_Enum | This function is called
;           by the Reintegration Agent. It returns the
;           name of the shadow file that has been modified and
;           the remote file that needs to be updated
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to a unsigned long
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_BeginPQEnum
        push    edi
        call    _IoctlBeginPQEnum
        pop     edi
        ret
EndProc Shadow_PM_API_BeginPQEnum

;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_End_PQ_Enum | This function is called
;           by the Reintegration Agent. It returns the
;           name of the shadow file that has been modified and
;           the remote file that needs to be updated
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to a unsigned long
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_EndPQEnum
        push    edi
        call    _IoctlEndPQEnum
        pop     edi
        ret
EndProc Shadow_PM_API_EndPQEnum

;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_Next_Pri_Shadow | This function is called
;           by the Reintegration Agent. It returns the
;           name of the shadow file that has been modified and
;           the remote file that needs to be updated
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to a unsigned long
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_NextPriShadow
        push    edi
        call    _IoctlNextPriShadow
        pop     edi
        ret
EndProc Shadow_PM_API_NextPriShadow

;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_Prev_Pri_Shadow | This function is called
;           by the Reintegration Agent. It returns the
;           name of the shadow file that has been modified and
;           the remote file that needs to be updated
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to a unsigned long
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_PrevPriShadow
        push    edi
        call    _IoctlPrevPriShadow
        pop     edi
        ret
EndProc Shadow_PM_API_PrevPriShadow

;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_Get_Shadow_Info | This function is called
;           by the Reintegration Agent. It returns the
;           name of the shadow file that has been modified and
;           the remote file that needs to be updated
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to SHADOWINFO structure
;                {
;                HSHADOW         hShadow;
;                HSHADOW         hDir;
;                HSERVER         hServer;
;                LPFIND32        lpFind32;
;                unsigned        short usStatus;
;                }
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_GetShadowInfo
        push    edi
        call    _IoctlGetShadowInfo
        pop     edi
        ret
EndProc Shadow_PM_API_GetShadowInfo

;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_Set_Shadow_Info | This function is called
;           by the Reintegration Agent. It returns the
;           name of the shadow file that has been modified and
;           the remote file that needs to be updated
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to SHADOWINFO structure
;                {
;                HSHADOW         hShadow;
;                HSHADOW         hDir;
;                HSERVER         hServer;
;                LPFIND32        lpFind32;
;                unsigned        short usStatus;
;                }
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_SetShadowInfo
        push    edi
        call    _IoctlSetShadowInfo
        pop     edi
        ret
EndProc Shadow_PM_API_SetShadowInfo



;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_ChkUpdtStatus | This function is called
;           by the Reintegration Agent.
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_ChkUpdtStatus
        push    edi
        call    _IoctlChkUpdtStatus
        pop     edi
        ret
EndProc Shadow_PM_API_ChkUpdtStatus

;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_DoShadowMaintenance | This function is called
;           by the Reintegration Agent.
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_DoShadowMaintenance
        push    edi
        call    _IoctlDoShadowMaintenance
        pop     edi
        ret
EndProc Shadow_PM_API_DoShadowMaintenance

;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_CopyChunk | This function is called
;           by the Reintegration Agent.
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_CopyChunk
        push    ebx
        mov     ebx,[esi.lpvOutBuffer]
        push    ebx
        push    edi
        call    _IoctlCopyChunk
        pop     edi
        pop     ebx
        pop     ebx
        ret
EndProc Shadow_PM_API_CopyChunk

;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_BeginReint | This function is called
;           by the Reintegration Agent to start reintegration on a
;           server whose handle is in the SHADOWINFO structure
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to SHADOWINFO structure
;                {
;                HSHADOW         hShadow;
;                HSHADOW         hDir;
;                HSERVER         hServer;
;                LPFIND32        lpFind32;
;                unsigned        short usStatus;
;                }
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_BeginReint
        push    edi
        call    _IoctlBeginReint
        pop     edi
        ret
EndProc Shadow_PM_API_BeginReint

;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_EndReint | This function is called
;           by the Reintegration Agent to end reintegration on a
;           server whose handle is in the SHADOWINFO structure.
;           uStatus contains the server status to be set.
;           uOp contains the operation to be applied on the status(AND,OR etc.)
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to SHADOWINFO structure
;                {
;                HSHADOW         hShadow;
;                HSHADOW         hDir;
;                HSERVER         hServer;
;                LPFIND32        lpFind32;
;                unsigned        uStatus;
;                unsigned        uOp;
;                }
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_EndReint
        push    edi
        call    _IoctlEndReint
        pop     edi
        ret
EndProc Shadow_PM_API_EndReint


;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_CreateShadow | This function is called
;           by the Reintegration Agent to create a shadow
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to SHADOWINFO structure
;                {
;                HSHADOW         hShadow;
;                HSHADOW         hDir;
;                HSERVER         hServer;
;                LPFIND32        lpFind32;
;                unsigned        uStatus;
;                unsigned        uOp;
;                }
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_CreateShadow
        push    edi
        call    _IoctlCreateShadow
        pop     edi
        ret
EndProc Shadow_PM_API_CreateShadow




;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_DeleteShadow | This function is called
;           by the Reintegration Agent to delete a shadow
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to SHADOWINFO structure
;                {
;                HSHADOW         hShadow;
;                HSHADOW         hDir;
;                HSERVER         hServer;
;                LPFIND32        lpFind32;
;                unsigned        uStatus;
;                unsigned        uOp;
;                }
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_DeleteShadow
        push    edi
        call    _IoctlDeleteShadow
        pop     edi
        ret
EndProc Shadow_PM_API_DeleteShadow



;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_GetServerStatus | This function is called
;           by the Reintegration Agent to create a shadow
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to SHADOWINFO structure
;                {
;                HSHADOW         hShadow;
;                HSHADOW         hDir;
;                HSERVER         hServer;
;                LPFIND32        lpFind32;
;                unsigned        uStatus;
;                unsigned        uOp;
;                }
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_GetServerStatus
        push    edi
        call    _IoctlGetServerStatus
        pop     edi
        ret
EndProc Shadow_PM_API_GetServerStatus


;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_SetServerStatus | This function is called
;           by the Reintegration Agent to create a shadow
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to SHADOWINFO structure
;                {
;                HSHADOW         hShadow;
;                HSHADOW         hDir;
;                HSERVER         hServer;
;                LPFIND32        lpFind32;
;                unsigned        uStatus;
;                unsigned        uOp;
;                }
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_SetServerStatus
        push    edi
        call    _IoctlSetServerStatus
        pop     edi
        ret
EndProc Shadow_PM_API_SetServerStatus




;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_AddUse | This function is by Shadow NP
;           on detecting disconnection
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to COPYPARAMS structure
;               typedef struct tagCOPYPARAMS
;                   {
;                   HSERVER  hServer;
;                   HSHADOW  hDir;
;                   HSHADOW  hShadow;
;                   LPSTR    lpLocalPath;
;                   LPSTR    lpRemotePath;
;                   LPSTR    lpServerPath;
;                   }
;                COPYPARAMS;
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_AddUse
        push    edi
        call    _IoctlAddUse
        pop     edi
        ret
EndProc Shadow_PM_API_AddUse



;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_DelUse | This function is by Shadow NP
;           on detecting disconnection
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to COPYPARAMS structure
;               typedef struct tagCOPYPARAMS
;                   {
;                   HSERVER  hServer;
;                   HSHADOW  hDir;
;                   HSHADOW  hShadow;
;                   LPSTR    lpLocalPath;
;                   LPSTR    lpRemotePath;
;                   LPSTR    lpServerPath;
;                   }
;                COPYPARAMS;
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_DelUse
        push    edi
        call    _IoctlDelUse
        pop     edi
        ret
EndProc Shadow_PM_API_DelUse



;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_GetUse | This function is by Shadow NP
;           on detecting disconnection
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to COPYPARAMS structure
;               typedef struct tagCOPYPARAMS
;                   {
;                   HSERVER  hServer;
;                   HSHADOW  hDir;
;                   HSHADOW  hShadow;
;                   LPSTR    lpLocalPath;
;                   LPSTR    lpRemotePath;
;                   LPSTR    lpServerPath;
;                   }
;                COPYPARAMS;
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_GetUse
        push    edi
        call    _IoctlGetUse
        pop     edi
        ret
EndProc Shadow_PM_API_GetUse


;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_Switches | This function is called
;           by the Reintegration Agent to switch on/off shadowing, loggin etc.
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to SHADOWINFO structure
;                {
;                HSHADOW         hShadow;
;                HSHADOW         hDir;
;                HSERVER         hServer;
;                LPFIND32        lpFind32;
;                unsigned        uStatus;
;                unsigned        uOp;
;                }
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_Switches
        push    edi
        call    _IoctlSwitches
        pop     edi
        ret
EndProc Shadow_PM_API_Switches


;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_Get_Shadow_Info |
;                IN: hDir, name of the shadow (OEM string) in lpFind2->cFileName
;                OUT: hShadow, uStatus, lpFind32 contains the find info
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to SHADOWINFO structure
;                {
;                HSERVER         hServer;
;                HSHADOW         hDir;
;                HSHADOW         hShadow;
;                LPFIND32        lpFind32;
;                unsigned        uStatus;
;                unsigned        uOp;
;                }
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_GetShadow
        push    edi
        call    _IoctlGetShadow
        pop     edi
        ret
EndProc Shadow_PM_API_GetShadow


;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_Get_Space_Info |
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to GLOABLSTATUS structure
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_GetGlobalStatus
        push    edi
        call    _IoctlGetGlobalStatus
        pop     edi
        ret
EndProc Shadow_PM_API_GetGlobalStatus


BeginProc Shadow_PM_API_FindOpenHSHADOW
        push    edi
        call    _IoctlFindOpenHSHADOW
        pop     edi
        ret
EndProc Shadow_PM_API_FindOpenHSHADOW

BeginProc Shadow_PM_API_FindNextHSHADOW
        push    edi
        call    _IoctlFindNextHSHADOW
        pop     edi
        ret
EndProc Shadow_PM_API_FindNextHSHADOW

BeginProc Shadow_PM_API_FindCloseHSHADOW
        push    edi
        call    _IoctlFindCloseHSHADOW
        pop     edi
        ret
EndProc Shadow_PM_API_FindCloseHSHADOW



BeginProc Shadow_PM_API_GetPriorityHSHADOW
        push    edi
        call    _IoctlGetPriorityHSHADOW
        pop     edi
        ret
EndProc Shadow_PM_API_GetPriorityHSHADOW

BeginProc Shadow_PM_API_SetPriorityHSHADOW
        push    edi
        call    _IoctlSetPriorityHSHADOW
        pop     edi
        ret
EndProc Shadow_PM_API_SetPriorityHSHADOW




BeginProc Shadow_PM_API_AddHint
        push    edi
        call    _IoctlAddHint
        pop     edi
        ret
EndProc Shadow_PM_API_AddHint

BeginProc Shadow_PM_API_DeleteHint
        push    edi
        call    _IoctlDeleteHint
        pop     edi
        ret
EndProc Shadow_PM_API_DeleteHint




BeginProc Shadow_PM_API_FindOpenHint
        push    edi
        call    _IoctlFindOpenHint
        pop     edi
        ret
EndProc Shadow_PM_API_FindOpenHint

BeginProc Shadow_PM_API_FindNextHint
        push    edi
        call    _IoctlFindNextHint
        pop     edi
        ret
EndProc Shadow_PM_API_FindNextHint

BeginProc Shadow_PM_API_FindCloseHint
        push    edi
        call    _IoctlFindCloseHint
        pop     edi
        ret
EndProc Shadow_PM_API_FindCloseHint

BeginProc Shadow_PM_API_GetAliasHSHADOW
        push    edi
        call    _IoctlGetAliasHSHADOW
        pop     edi
        ret
EndProc Shadow_PM_API_GetAliasHSHADOW


IFDEF DEBUG
;******************************************************************************
;            D E B U G G I N G   C O D E
;******************************************************************************

BeginProc Shadow_Timer_Callback, PUBLIC

        inc     _cntTicks
        mov     eax,    _cntTicks
        cmp     eax,    SHADOW_STATS_FLUSH_COUNT
        jl      STC_Done
        mov     eax,    0
        mov     ebx,    0
        mov     ecx,    PEF_WAIT_NOT_NESTED_EXEC
        mov     edx,    0
        lea     esi,    Shadow_Restricted_Event_Callback
        VMMCall Call_Restricted_Event
        mov     _cntTicks,0
STC_Done:
        ret
EndProc Shadow_Timer_Callback


BeginProc Shadow_Restricted_Event_Callback, PUBLIC
        call    _ShadowRestrictedEventCallback
        mov     eax, SHADOW_LOG_TIME_INTERVAL
        mov     edx, 0
        mov     esi, OFFSET32 Shadow_Timer_Callback
        VMMCall Set_Global_Time_Out
        mov     eax,esi
        cmp     eax,0
        jne     TimerSet1
        Trace_Out       "Shadow: Couldn't set the logging timer again"
TimerSet1:
        ret
EndProc   Shadow_Restricted_Event_Callback

BeginProc _DebugBreak, PUBLIC
        push    [esp+4]
        VMMCall _Debug_Out_Service
        pop     eax
        ret
EndProc _DebugBreak

BeginProc MinDbg_Debug

        mov     _NbDebug, 0
        ret

EndProc MinDbg_Debug

BeginProc DefaultDbg_Debug

;        mov     _NbDebug, DEFAULT_DEBUG
        ret

EndProc DefaultDbg_Debug

BeginProc MaxDbg_Debug

        mov     _NbDebug, 0FFFFFFFFh
        ret

EndProc MaxDbg_Debug

BeginProc Alloc_Debug

        mov     eax, Alloc_watch
        not     eax
        mov     Alloc_watch, eax
        ret

EndProc Alloc_Debug

BeginProc _ShadowCheckHeap

        pushad
        push    @Line
        push    OFFSET32 Shadow_str
        push    ecx
        VxDCall IFSMgr_CheckHeap
        add     esp, 12
        or      eax, eax
        jz      GCH_10
        trace_out "Heap is fried"

GCH_10:

        popad
        ret

EndProc _ShadowCheckHeap

BeginProc _CheckHeap
	mov ecx, [esp+4]
	call _shadowCheckHeap
	ret
EndProc _Checkheap

BeginProc AllocDisplay_Debug

        mov     ecx, Alloc_cnt
        or      ecx, ecx
        jz      AD_Exit
        mov     edi, OFFSET32 Alloc_table
        mov     esi, OFFSET32 Alloc_sizes

AD_Loop:

        mov     edx, [edi]
        mov     ebx, [esi]
        Trace_Out "Memory block: #edx Size: #ebx"
        add     esi, 4
        add     edi, 4
        loop    AD_Loop

AD_Exit:

        Trace_Out " "
        call    _ShadowCheckHeap
        ret

EndProc AllocDisplay_Debug

;**	SHDDumpDebug - Dump debug information to the debugger
;

	public	SHDDumpDebug
SHDDumpDebug proc near

	xor	ebx, ebx
	mov	ax, fs
	test	ax, ax
	jz	dq1

	push	esi
	push	ds

	lea	edi, _DebugQueryCmdStr
	mov	ecx, _DebugQueryCmdStrLen
	mov	ds, ax
	cld
	rep	movsb
	xor	eax, eax
	stosb

	pop	ds
	pop	esi

	lea	ebx, _DebugQueryCmdStr

dq1:
	push	ebx
	call	_SHDDebug
	add	esp, 4
	ret
SHDDumpDebug endp

ENDIF

;** ShadowHookDeviceService - external API handler
;
;	This routine receives HookDeviceService from the IFSMgr
;
;	Entry	(TOS+4) = ioreq & user register ptr
;	Exit	none
;	Uses	C registers

BeginProc ShadowHookDeviceService, PUBLIC
;        Trace_Out       "HookDeviceService Hook Called"
        pushf
        cmp            eax, @@IFSMgr_NetFunction
        jz             SHDS_Unhook
        popf
        jmp            OrigHookDeviceService

SHDS_Unhook:
;       Someone is indeed trying to hook IFSMgr_NetFunction
;       Let us first unhook ourselves
        popf
;        Trace_Out       "Someone hooking IFSMgr_NetFunction"

        push            eax
        push            esi
        mov             esi, OFFSET32 ShadowNetFunction
        VMMCall         Unhook_Device_Service
        pop             esi
        pop             eax
        jc              SHDS_error

;       We unhooked ourselves
;       let the caller  do it
        call            OrigHookDeviceService

;       Save his result on the stack
        pushf

;       Let us hook     ourselves back in
        push            esi
        push            eax
	mov	        esi, OFFSET32 ShadowNetFunction
	mov	        eax, @@IFSMgr_NetFunction
	call	        OrigHookDeviceService
	mov	        _OrigNetFunction, esi
        pop             eax
        pop             esi
        jc              SHDS_unhook_error
        popf
        jmp             SHDS_done
SHDS_unhook_error:
        popf
        jmp             SHDS_error
SHDS_error:
        Trace_Out       "HookDeviceService Hook Error, disabling shadowing"
        mov             _fShadow, 0
SHDS_done:
        ret
EndProc ShadowHookDeviceService

;** ShadowRegisterNetFunction - external API handler
;
;	This routine receives RegisterNet from the IFSMgr
;
;	Entry	(TOS+4) = ioreq & user register ptr
;	Exit	none
;	Uses	C registers

BeginProc ShadowRegisterNetFunc, PUBLIC
;        int     1
        Trace_Out       "Hook Called"
	mov		eax, [esp+8]
	cmp		eax, IFSMGRVERSION
	jne		connect_passthrough	; if wrong ifs version, don't hook

	mov		eax, [esp+0ch]
	cmp		eax, WNNC_NET_LANMAN
	je		hooklanman			; hookit if lanman or ourselves
	mov		eax, [esp+0ch]
	cmp		eax, WNNC_NET_COGENT	; BUGBUG get us a net ID
	je		hookus
        Trace_Out       "Hook Called by some other FSD"
	jmp		connect_passthrough
hooklanman:
        Trace_Out       "Hook Called by LANMAN"
	xor		ecx, ecx		;; important step!!!
	VxDCall 	VRedir_Get_Version
	mov		_VRedirCSCInfoFunction, ecx	;; if this is a new vredir, it will give us the function
	jmp		hookit
hookus:
        Trace_Out       "Hook Called by us"
hookit:
        mov             eax, [esp+4]    ; take the pFunc from FSD

        ; Put it in our table
        push            eax

        call            _ProcessRegisterNet
        add             esp,4
        or              eax,eax
        jz              connect_passthrough
        mov             [esp+4],eax     ; replace his function with ours

connect_passthrough:
	jmp	OrigRegisterNetFunc	; pass on to IFSMgr

EndProc ShadowRegisterNetFunc

;** ShadowNetFunction - external API handler
;
;	This routine receives NetFunction from the IFSMgr
;
;	Entry	(TOS+4) = ioreq & user register ptr
;	Exit	none
;	Uses	C registers

BeginProc ShadowNetFunction, PUBLIC, HOOK_PROC, NextNetFunction
;        Trace_Out       "NetFunction Hook Called"
        call            _ProcessNetFunction
        ret
EndProc ShadowNetFunction

IFDEF HOOKMOUNT
;** ShadowMountFunction - external API handler
;
;	This routine receives RegisterMount from the IFSMgr
;
;	Entry	(TOS+4) = ioreq & user register ptr
;	Exit	none
;	Uses	C registers

BeginProc ShadowMountFunction, PUBLIC
;        int     1
        Trace_Out       "Hook Called"
        mov             eax, [esp+4]    ; take the pFunc from FSD

        ; Put it in our table
        push            eax
        call            _ProcessRegisterMount
        add             esp,4
        or              eax,eax
        jz              mount_passthrough
        mov             [esp+4],eax     ; replace his function with ours

mount_passthrough:
	jmp	OrigRegisterMountFunc	; pass on to IFSMgr

EndProc ShadowMountFunction

ENDIF

BeginProc _UniToBCSPath , PUBLIC
	int	Dyna_Link_Int
	dd	@@UniToBCSPath OR DL_Jmp_Mask
EndProc _UniToBCSPath

BeginProc _UniToBCS , PUBLIC
	int	Dyna_Link_Int
	dd	@@UniToBCS OR DL_Jmp_Mask
EndProc _UniToBCS

BeginProc _BCSToUni , PUBLIC
	int	Dyna_Link_Int
	dd	@@BCSToUni OR DL_Jmp_Mask
EndProc _BCSToUni

BeginProc _IFSMgr_MetaMatch, PUBLIC
	int	Dyna_Link_Int
	dd	@@IFSMgr_MetaMatch OR DL_Jmp_Mask
EndProc _IFSMgr_MetaMatch

BeginProc _UniToUpper, PUBLIC
	int	Dyna_Link_Int
	dd	@@UniToUpper OR DL_Jmp_Mask
EndProc _UniToUpper

BeginProc _FGHS, PUBLIC
	int	Dyna_Link_Int
	dd	@@IFSMgr_GetHeap OR DL_Jmp_Mask
EndProc _FGHS

BeginProc _RetHeap, PUBLIC
	int	Dyna_Link_Int
	dd	@@IFSMgr_RetHeap OR DL_Jmp_Mask
EndProc _RetHeap

BeginProc _IFSMgr_Printf, PUBLIC
        int     Dyna_Link_Int
        dd      @@IFSMgr_printf OR DL_Jmp_Mask
EndProc _IFSMgr_Printf

BeginProc _IFSMgr_AssertFailed, PUBLIC
        int     Dyna_Link_Int
        dd      @@IFSMgr_AssertFailed OR DL_Jmp_Mask
EndProc _IFSMgr_AssertFailed

BeginProc _Ring0Api,  PUBLIC
        int     Dyna_Link_Int
        dd      @@IFSMgr_Ring0_FileIO OR DL_Jmp_Mask
EndProc _Ring0Api

BeginProc _ParsePath,  PUBLIC
        int     Dyna_Link_Int
        dd      @@IFSMgr_ParsePath OR DL_Jmp_Mask
EndProc _ParsePath

BeginProc _IFSMgr_Win32ToDosTime,  PUBLIC
        int     Dyna_Link_Int
        dd      @@IFSMgr_Win32ToDosTime OR DL_Jmp_Mask
EndProc _IFSMgr_Win32ToDosTime

BeginProc _IFSMgr_DosToWin32Time,  PUBLIC
        int     Dyna_Link_Int
        dd      @@IFSMgr_DosToWin32Time OR DL_Jmp_Mask
EndProc _IFSMgr_DosToWin32Time

BeginProc _IFSMgr_DosToNetTime,  PUBLIC
        int     Dyna_Link_Int
        dd      @@IFSMgr_DosToNetTime OR DL_Jmp_Mask
EndProc _IFSMgr_DosToNetTime

BeginProc _IFSMgr_Get_NetTime,  PUBLIC
        int     Dyna_Link_Int
        dd      @@IFSMgr_Get_NetTime OR DL_Jmp_Mask
EndProc _IFSMgr_Get_NetTime

BeginProc _IFSMgr_NetToWin32Time,  PUBLIC
        int     Dyna_Link_Int
        dd      @@IFSMgr_NetToWin32Time OR DL_Jmp_Mask
EndProc _IFSMgr_NetToWin32Time

BeginProc _GetCurThreadHandle
        VMMCall Get_Cur_Thread_Handle
        mov     eax,edi
        ret
EndProc _GetCurThreadHandle

BeginProc _Shell_PostMessage
        int     Dyna_Link_Int
        dd      @@_Shell_PostMessage OR DL_Jmp_Mask
EndProc _Shell_PostMessage

BeginProc __BlockOnID
        int     Dyna_Link_Int
        dd      @@_BlockOnID OR DL_Jmp_Mask
EndProc __BlockOnID

BeginProc __SignalID
        int     Dyna_Link_Int
        dd      @@_SignalID OR DL_Jmp_Mask
EndProc __SignalID

BeginProc _IFSMgr_UseAdd
        int     Dyna_Link_Int
        dd      @@IFSMgr_UseAdd OR DL_Jmp_Mask
EndProc _IFSMgr_UseAdd

BeginProc _IFSMgr_UseDel
        int     Dyna_Link_Int
        dd      @@IFSMgr_UseDel OR DL_Jmp_Mask
EndProc _IFSMgr_UseDel

BeginProc _CreateBasis
        int     Dyna_Link_Int
        dd      @@CreateBasis OR DL_Jmp_Mask
EndProc _CreateBasis

BeginProc _MatchBasisName
        int     Dyna_Link_Int
        dd      @@MatchBasisName OR DL_Jmp_Mask
EndProc _MatchBasisName

BeginProc _AppendBasisTail
        int     Dyna_Link_Int
        dd      @@AppendBasisTail OR DL_Jmp_Mask
EndProc _AppendBasisTail


BeginProc _FCBToShort
        int     Dyna_Link_Int
        dd      @@FcbToShort OR DL_Jmp_Mask
EndProc _FCBToShort

BeginProc _ShortToFCB
        int     Dyna_Link_Int
        dd      @@ShortToFcb OR DL_Jmp_Mask
EndProc _ShortToFCB

BeginProc  _DebugMenu
        int     Dyna_Link_Int
        dd      @@IFSMgr_DebugMenu OR DL_Jmp_Mask
EndProc _DebugMenu


_GetConfigDir:
	push	edx
	VMMCall	Get_Config_Directory
	mov	eax, edx
	pop	edx
	ret

_Get_Sys_VM_Handle:
        push    ebx
        VMMcall Get_Sys_VM_Handle
        mov     eax, ebx
        pop     ebx
        ret

_Get_Cur_VM_Handle:
        push    ebx
        VMMcall Get_Cur_VM_Handle
        mov     eax, ebx
        pop     ebx
        ret

_Call_VM_Event:
	push 	ebx
	push	esi
	push	edx
	mov	ebx, [esp+16]	;VM handle
	mov	esi, [esp+20]	;callback function
	mov	edx, [esp+24]	; refdata
	VMMCall	Call_VM_Event
	pop	edx
	pop	esi
	pop	ebx
	ret

;***	_SetWin32Event - This function sets an event to the signaled state.
;
;	_SetWin32Event is a thunk to VWIN32_SetWin32Event.  (We make
;	sure that Win32 is loaded prior to making the call.)
;
;	BOOL = SetWin32Event( pevt );
;
;	ENTRY	[esp+4] - pointer to an event object
;
;	EXIT	eax = 0 if event was invalid, <> 0 if OK
;		The event object is set to a signaled state. If it is a
;		manual reset event, it remains in the signaled state until it
;		is explicitly reset and all threads currently blocked on this
;		event are unblocked. If it is an auto reset event, one waiting
;		thread is unblocked.
;
;	USES	EAX, ECX, EDX
;

BeginProc   _SetWin32Event
	VxDCall VWIN32_Get_Version	; Verify Win32 installation
	jc	short swe90		; Win32 not installed! (EAX)=0

	; BUGBUG - the input parameter to _VWIN32_SetWin32Event is
	; documented as being in EAX right now, but if someone comes to
	; their senses and makes this C callable, this code will still work!

	mov	eax,DWORD PTR [esp+4]	; (EAX) = event object address
	push	eax
	VxDCall _VWIN32_SetWin32Event	; Call _VWIN32_SetWin32Event
	lea	esp,[esp+4]
swe90:	ret
EndProc     _SetWin32Event


;***	_ResetWin32Event - This function sets an event to not signaled state.
;
;	_ResetWin32Event is a thunk to VWIN32_ResetWin32Event.
;	(We make sure that Win32 is loaded prior to making the call.)
;
;	BOOL = ResetWin32Event( pevt );
;
;	ENTRY	[esp+4] - pointer to an event object
;
;	EXIT	eax = 0 if event was invalid, <> 0 if OK
;		The event object is set to a not signaled state.
;
;	USES	EAX, ECX, EDX
;

BeginProc   _ResetWin32Event
	VxDCall VWIN32_Get_Version	; Verify Win32 installation
	jc	short swe91		; Win32 not installed! (EAX)=0

	; BUGBUG - the input parameter to _VWIN32_ResetWin32Event is
	; documented as being in EAX right now, but if someone comes to
	; their senses and makes this C callable, this code will still work!

	mov	eax,DWORD PTR [esp+4]	; (EAX) = event object address
	push	eax
	VxDCall _VWIN32_ResetWin32Event ; Call _VWIN32_ResetWin32Event
	lea	esp,[esp+4]
swe91:	ret
EndProc _ResetWin32Event


;***	_InSysVM - Returns boolean (Current VM == System VM) in EAX
;

BeginProc   _InSysVM
	push	ebx
	VMMCall Get_Cur_VM_Handle	; (EBX) = Current VM
	VMMCall Test_Sys_VM_Handle	; (Zero) = (Current VM == System VM)
	pop	ebx
	sete	al			; (AL)= (Current VM == System VM)
	movzx	eax,al			; EAX = (Current VM == System VM)
	ret
EndProc _InSysVM

_CloseVxDHandle:
	mov	eax, [esp+4]
	VxDcall _VWIN32_CloseVxDHandle
	ret


BeginProc _MyCheckAccessConflict
        int     Dyna_Link_Int
        dd      @@IFSMgr_CheckAccessConflict OR DL_Jmp_Mask
EndProc _MyCheckAccessConflict

;
;   SP_PutNumber
;
;   Takes an unsigned long integer and places it into a buffer, respecting
;   a buffer limit, a radix, and a case select (upper or lower, for hex).
;

SP_PutNumber proc near c public,  lpb:DWORD, n:DWORD, limit:DWORD, radix:DWORD, case:DWORD

        push    esi
        push    edi
        mov     al,'a'-'0'-10                           ; figure out conversion offset
        cmp     case,0
        jz pn_lower
        mov     al,'A'-'0'-10
pn_lower:
        mov     byte ptr case,al

        mov     eax,n                                   ; ebx=number
        mov     ecx,radix                               ; cx=radix
        mov     edi,lpb                                 ; edi->string
        mov     esi,limit                               ; cchLimit

divdown:
        xor     edx,edx
        div     ecx                                     ; edx = rem, eax = div
        xchg    eax,edx                                 ; eax = rem, edx = div
        add     al,'0'
        cmp     al,'9'
        jbe     isadig                                  ; is a digit already
        add     al,byte ptr case                        ; convert to letter

isadig:
        dec     esi                                     ; decrement cchLimit
        jz      pn_exit                                 ; go away if end of string
        stosb                                           ; stick it in
        mov     eax,edx
        or      eax,eax
        jnz     divdown                                 ; crack out next digit

pn_exit:
        mov     eax,edi
        sub     eax,dword ptr lpb[0]                    ; find number of chars output
        pop     edi
        pop     esi
        ret

SP_PutNumber EndP

;
;   SP_Reverse
;
;   Reverses a string in place
;
SP_Reverse proc near c public,  lpFirst:DWORD, lpLast:DWORD
        push    esi
        push    edi
        mov     esi,lpFirst
        mov     edi,lpLast
        mov     ecx,edi                                 ; number of character difference
        sub     ecx,esi
        inc     ecx
        shr     ecx,1                                   ; number of swaps required
        jcxz    spr_boring                              ; nuthin' to do
spr100:
        mov     ah,[edi]
        mov     al,[esi]                                ; load the two characters
        mov     [esi],ah
        mov     [edi],al                                ; swap them
        inc     esi
        dec     edi                                     ; adjust the pointers
        loop    spr100                                  ; ...until we've done 'em all
spr_boring:
        pop     edi
        pop     esi
        ret

SP_Reverse EndP


VxD_CODE_ENDS

END



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\oslayer.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

oslayer.h

Abstract:

    OS layer API definition. These are the functions which the record manager uses
    to manage the CSC record database. This allows us to port the record manager
    to NT and win9x platforms without affecting the record manager code in any
    significant manner.

    Contents:

Author:
    Shishir Pardikar


Environment:

    kernel mode.

Revision History:

    1-1-94    original

--*/

//let's take this opportunity to null out the rdbss/minirdr style dbgtrace/log
//if we're not on NT

typedef void                *CSCHFILE;
#define CSCHFILE_NULL       NULL

#ifndef CSC_RECORDMANAGER_WINNT
#ifndef NOTHING
#define NOTHING
#endif
#define RxLog(Args)   {NOTHING;}
#define RxDbgTrace(INDENT,CONTROLPOINTNUM,Z)     {NOTHING;}
#define DbgBreakPoint() {NOTHING;}
#define FILE_ATTRIBUTE_NORMAL   0
#endif

#undef CSC_BUILD_W_PROGRESS_CATCHERS
#ifdef RX_PRIVATE_BUILD
#ifdef CSC_RECORDMANAGER_WINNT
#if defined(_X86_)
#define CSC_BUILD_W_PROGRESS_CATCHERS
#else
#endif
#endif
#endif

#if !DBG
#undef CSC_BUILD_W_PROGRESS_CATCHERS
#endif

#ifdef CSC_BUILD_W_PROGRESS_CATCHERS
typedef struct _CSC_PROGRESS_BLOCK {
    ULONG Counter;
    PVOID NearTop;
    PVOID NearArgs;
    ULONG Progress;
    ULONG LastBit;
    ULONG Loops;
    ULONG StackRemaining;
    PULONG RetAddrP;
    ULONG RetAddr;
    ULONG SignatureOfEnd;
} CSC_PROGRESS_BLOCK, *PCSC_PROGRESS_BLOCK;

VOID
CscProgressInit (
    PCSC_PROGRESS_BLOCK ProgressBlock,
    ULONG Counter,
    PVOID NearArgs
    );
VOID
CscProgress (
    PCSC_PROGRESS_BLOCK ProgressBlock,
    ULONG Bit
    );
extern ULONG DelShadowInternalEntries;

#define JOE_DECL_PROGRESS()  CSC_PROGRESS_BLOCK  JOE_DECL_CURRENT_PROGRESS
#define JOE_INIT_PROGRESS(counter,nearargs) \
     {CscProgressInit(&JOE_DECL_CURRENT_PROGRESS,counter,nearargs);}
#define JOE_PROGRESS(bit) \
     {CscProgress(&JOE_DECL_CURRENT_PROGRESS,bit);}
#else
#define JOE_DECL_PROGRESS()
#define JOE_INIT_PROGRESS(counter,nearargs)
#define JOE_PROGRESS(bit)
#endif

#define  PUBLIC
#define  PRIVATE
#define  COPY_BUFF_SIZE 4096
#ifndef UNICODE
#define  UNICODE  2
#endif


#define  ATTRIB_DEL_ANY     0x0007   // Attrib passed to ring0 delete

//typedef USHORT                USHORT;
//typedef ULONG         ULONG;

#ifndef CSC_RECORDMANAGER_WINNT
typedef void (PUBLIC       *FARPROC)(void);
#endif


typedef  pioreq   PIOREQ;
typedef struct ParsedPath  *PPP, far *LPPP;
typedef struct PathElement  *PPE, far *LPPE;
typedef LPVOID             HFREMOTE;
typedef  HFREMOTE far *    LPHFREMOTE;
typedef PIOREQ             LPPATH;
typedef LPSTR              LPTSTR;
typedef char               tchar;
typedef  _FILETIME         FILETIME, *LPFILETIME;

typedef struct _WIN32_FIND_DATAA _WIN32_FIND_DATAA, far *LPFIND32A;
struct _WIN32_FIND_DATAA {
        ULONG           dwFileAttributes;
        struct _FILETIME        ftCreationTime;
        struct _FILETIME        ftLastAccessTime;
        struct _FILETIME        ftLastWriteTime;
        ULONG           nFileSizeHigh;
        ULONG           nFileSizeLow;
        ULONG           dwReserved0;
        ULONG           dwReserved1;
        UCHAR           cFileName[MAX_PATH];    /* includes NUL */
        UCHAR           cAlternateFileName[14]; /* includes NUL */
};      /* _WIN32_FIND_DATAA */

#define FILE_ATTRIBUTE_ALL (FILE_ATTRIBUTE_READONLY| FILE_ATTRIBUTE_HIDDEN \
                           | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY \
                           | FILE_ATTRIBUTE_ARCHIVE)

#define  IsFile(dwAttr) (!((dwAttr) & (FILE_ATTRIBUTE_DIRECTORY)))
typedef int (*PATHPROC)(USHORT *, USHORT *, LPVOID);



#define FLAG_RW_OSLAYER_INSTRUMENT      0x00000001
#define FLAG_RW_OSLAYER_PAGED_BUFFER    0x00000002

#define FLAG_CREATE_OSLAYER_INSTRUMENT      0x00000001
#define FLAG_CREATE_OSLAYER_ALL_ACCESS      0x00000002

#if defined(BITCOPY)
#define FLAG_CREATE_OSLAYER_OPEN_STRM       0x00000004
#endif // defined(BITCOPY)

#include "hook.h"


#ifdef CSC_RECORDMANAGER_WINNT
//this comes from shadow.asm on win95......
#define GetCurThreadHandle() (PtrToUlong(KeGetCurrentThread()))
#define CheckHeap(a) {NOTHING;}
extern ULONG EventLogForOpenFailure;
#endif //ifdef CSC_RECORDMANAGER_WINNT

#define SizeofFindRemote  (sizeof(FINDINFO)+sizeof(ioreq)+sizeof(WIN32_FIND_DATA))
#define LpIoreqFromFindInfo(pFindInfo)  ((PIOREQ)((LPBYTE)(pFindInfo)+sizeof(FINDINFO)))
#define LpFind32FromFindInfo(pFindInfo) ((LPFIND32)((LPBYTE)(pFindInfo)+sizeof(FINDINFO)+sizeof(ioreq)))
#define LpFind32FromHfRemote(HfRemote) ((LPFIND32)((LPBYTE)(HfRemote)+sizeof(FINDINFO)+sizeof(ioreq)))

#define SizeofFileRemote  (sizeof(FILEINFO)+sizeof(ioreq))
#define LpIoreqFromFileInfo(pFileInfo)  ((PIOREQ)((LPBYTE)(pFileInfo)+sizeof(FILEINFO)))


CSCHFILE CreateFileLocal(LPSTR lpName);
/*++

Routine Description:

    This routine creates a file on the local drive, if it doesn't exist. If it exists, it truncates
    the file.

Arguments:

    lpName  Fully qualified path name. On NT it is prefixed by \DosDevice\

Returns:

    if successful, returns a file handle that can be used in read and write calls.
    If it fails, it retruns NULL.

Notes:

    Need a scheme to return the actual error code

--*/

CSCHFILE OpenFileLocal(LPSTR lpName);
/*++

Routine Description:

    This routine opens a file on the local drive if it exists. If it doesn't exist the call fails

Arguments:

    lpName  Fully qualified path name. On NT it is prefixed by \DosDevice\

Returns:

    if successful, returns a file handle that can be used in read and write calls.
    If it fails, it retruns NULL.

Notes:

    Need a scheme to return the actual error code

--*/
int DeleteFileLocal(LPSTR lpName, USHORT usAttrib);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int FileExists (LPSTR lpName);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
long ReadFileLocal (CSCHFILE handle, ULONG pos, LPVOID lpBuff,  long lCount);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
long WriteFileLocal (CSCHFILE handle, ULONG pos, LPVOID lpBuff, long lCount);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
long ReadFileInContextLocal (CSCHFILE, ULONG, LPVOID, long);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
long WriteFileInContextLocal (CSCHFILE, ULONG, LPVOID, long);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
ULONG CloseFileLocal (CSCHFILE handle);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int GetFileSizeLocal (CSCHFILE, PULONG);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int GetDiskFreeSpaceLocal(int indx
   , ULONG *lpuSectorsPerCluster
   , ULONG *lpuBytesPerSector
   , ULONG *lpuFreeClusters
   , ULONG *lpuTotalClusters
   );
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/

int CreateFileRemote(LPPATH lpPath, LPHFREMOTE);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int OpenFileRemote(LPPATH lpPath, LPHFREMOTE);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int OpenFileRemoteEx(LPPATH lpPath, UCHAR uchAccess, USHORT usAction,ULONG ulAttr, LPHFREMOTE);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int ReadFileRemote (HFREMOTE handle, PIOREQ pir, ULONG pos, LPVOID lpBuff,  ULONG count);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int WriteFileRemote (HFREMOTE handle, PIOREQ pir, ULONG pos, LPVOID lpBuff, ULONG count);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int CloseFileRemote (HFREMOTE handle, PIOREQ pir);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/

int GetAttributesLocal (LPSTR lpPath, ULONG *lpuAttr);
/*++

Routine Description:

    Return the attributes of the file

Arguments:

    lpPath  A fully qualified path

    lpuAttr contains the attributes on return

Returns:

    0 if successfull, < 0 otherwise

Notes:


--*/

int GetAttributesLocalEx (LPSTR lpPath, BOOL fFile, ULONG *lpuAttr);
/*++

Routine Description:

    Return the attributes of the file/directory

Arguments:

    lpPath  A fully qualified path

    fFile   if TURE, the object is a file, else it is a directory

    lpuAttr contains the attributes on return

Returns:

    0 if successfull, < 0 otherwise

Notes:


--*/


int SetAttributesLocal (LPSTR, ULONG);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int RenameFileLocal (LPSTR, LPSTR);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int FileLockLocal(CSCHFILE, ULONG, ULONG, ULONG, BOOL);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/

int FindOpenRemote (LPPATH lpPath, LPHFREMOTE);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int FindNextRemote (HFREMOTE handle, PIOREQ pir);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int FindCloseRemote (HFREMOTE handle, PIOREQ pir);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/

int CloseAllRemoteFiles(PRESOURCE);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int CloseAllRemoteFinds(PRESOURCE);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/

LPVOID AllocMem (ULONG uSize);
//BUGBUG.REVIEW AllocMem should distinguish between paged and nonpaged pool
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
#ifndef CSC_RECORDMANAGER_WINNT
VOID FreeMem (LPVOID lpBuff);
VOID CheckHeap(LPVOID lpBuff);
#else
INLINE
VOID
FreeMem (
    PVOID p___
    )
{RxFreePool(p___);}
#endif //ifndef CSC_RECORDMANAGER_WINNT
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/

//BUGBUG.REVIEW this was added here because it is called from record.c
CSCHFILE R0OpenFile (USHORT usOpenFlags, UCHAR bAction, LPSTR lpPath);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/

//for the NT build these are added here AND the code is also moved from
//hook.c to oslayer.c since these routines are called from oslayer.c

PELEM PAllocElem (int cbSize);
void FreeElem (PELEM pElem);
void LinkElem (PELEM pElem, PPELEM ppheadElem);
PELEM PUnlinkElem (PELEM pElem, PPELEM ppheadElem);
int ReinitializeDatabase();
BOOL IsSpecialApp(VOID);
int DisconnectAllByName(LPPE lppeRes);
int PRIVATE DeleteShadowHelper(BOOL fMarkDeleted, HSHADOW, HSHADOW);
int InitShadowDB(VOID);

CSCHFILE OpenFileLocalEx(LPSTR lpPath, BOOL fInstrument);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
long ReadFileLocalEx(CSCHFILE handle, ULONG pos, LPVOID pBuff, long  lCount, BOOL fInstrument);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
long WriteFileLocalEx(CSCHFILE handle, ULONG pos, LPVOID lpBuff, long lCount, BOOL fInstrument);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
long ReadFileLocalEx2(CSCHFILE handle, ULONG pos, LPVOID pBuff, long  lCount, ULONG flags);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
long WriteFileLocalEx2(CSCHFILE handle, ULONG pos, LPVOID lpBuff, long lCount, ULONG flags);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
CSCHFILE R0OpenFileEx(USHORT  usOpenFlags, UCHAR   bAction, ULONG uAttr, LPSTR   lpPath, BOOL fInstrument);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/

VOID GetSystemTime(_FILETIME *lpft);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/

int
CreateDirectoryLocal(
    LPSTR   lpPath
);
/*++

Routine Description:

    This routine creates a directory if it doesn't exist.

Arguments:

    lpPath  Fully qualified directory path. On NT, this is of the form \DosDevice\c:\winnt\csc\d0
            On win95 the \DosDevice\ part is missing
Returns:


Notes:


--*/


LPVOID
AllocMemPaged(
    unsigned long   ulSize
    );

/*++

Routine Description:

    This routine allows allocating paged memory

Arguments:

Returns:


Notes:


--*/

VOID
FreeMemPaged(
    LPVOID  lpMemPaqged
    );

/*++

Routine Description:

    This routine allows freeing paged memory

Arguments:

Returns:


Notes:

    On win95 paged and fixed memory come from totally different allocators, so the appropriate
    deallocator has to be called for freeing it.


--*/
ULONG
GetTimeInSecondsSince1970(
    VOID
    );


BOOL
IterateOnUNCPathElements(
    USHORT  *lpuPath,
    PATHPROC lpfn,
    LPVOID  lpCookie
    );

BOOL
IsPathUNC(
    USHORT      *lpuPath,
    int         cntMaxChars
    );


VOID
SetLastErrorLocal(
    DWORD   dwError
    );

DWORD
GetLastErrorLocal(
    VOID
    );
    
int
FindNextFileLocal(
    CSCHFILE handle,
    _WIN32_FIND_DATAA   *lpFind32A
    );

CSCHFILE
FindFirstFileLocal(
    LPSTR   lpPath,
    _WIN32_FIND_DATAA   *lpFind32A
    );
    
int
FindCloseLocal(
    CSCHFILE handle
    );

BOOL
HasStreamSupport(
    CSCHFILE handle,
    BOOL    *lpfResult
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\win97csc.h ===
#include "basedef.h"
#include "shdcom.h"
#include "oslayer.h"
#include "log.h"
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include "assert.h"
#include "ifs.h"
#include "utils.h"
#include "winerror.h"
#include "vxdwraps.h"
#include "cscsec.h"


//got this from wdm.h....modified to use DEBUG
#ifdef DEBUG

#define KdPrint(_x_) DbgPrint _x_
#define KdBreakPoint() DbgBreakPoint()
#ifndef ASSERT
#define ASSERT(__X) Assert(__X)
#define ASSERTMSG(__X,__MSG) AssertMsg(__X,__MSG)
#endif


#else

#define KdPrint(_x_)
#define KdBreakPoint()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\bmreclib\assert.h ===
/* Routines for debugging and error messages. */

#define AssertFn  AssertFn
#define PrintFn   DbgPrint

#ifdef DBG


#define AssertData static char szFileAssert[] = __FILE__;
#define AssertError static char szError[] = "Error";
#define Assert(f)  do {if (!(f)) AssertFn(szError, szFileAssert, __LINE__);} while(0)
#define AssertSz(f, sz)  do {if (!(f)) AssertFn(sz, szFileAssert, __LINE__);} while(0)

VOID AssertFn(PCHAR pMsg, PCHAR pFile, ULONG uLine);

VOID _cdecl DbgPrint(PCHAR pFmt, ...);

VOID
NTAPI
DbgBreakPoint(
    VOID
    );

#else

#define Assert(f)
#define AssertData
#define AssertError
#define AssertSz(f, sz)
#define DbgPrint
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\shddbg.c ===
/********************************************************************/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 	This file uses 4 space hard tabs */

// ***	vrddbg.c - VRedir debug routines
//

#ifdef DEBUG

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

#include <ifsdebug.h>

#pragma intrinsic (memcmp, memcpy, memset, strcat, strcmp, strcpy, strlen)

#define  MAXPRO            (2+2)
extern NETPRO rgNetPro[MAXPRO];
extern int cMacPro;
extern LPSTR    lpLogBuff;
extern int indxCur;
VOID
DispThisIOReq(
	pioreq pir
	);

VOID
DispThisResource(
	PRESOURCE pResource	
	);

VOID
DispThisFdb(
	PFDB pFdb
	);

VOID
DispThisFileInfo(
	PFILEINFO pFileInfo
	);

VOID
DispThisFindInfo(
	PFINDINFO pFindInfo
	);

extern pimh
DebugMenu(
	IFSMenu *pIFSMenu
	);

IFSMenuHand DispNetPro, DispResource, DispFdb, DispFileInfo, DispFindInfo, DispIOReq, DispLog;

IFSMenu	SHDMainMenu[] = {
	{"NetPro info"	, DispNetPro},
	{"Resource info", DispResource},
	{"Fdb info"		, DispFdb},
	{"OpenFile Info", DispFileInfo},
	{"Find Info"	, DispFindInfo},
	{"DisplayIOReq"	, DispIOReq},
    {"DisplayLog"   , DispLog},
	{0				, 0}
};

typedef struct {
    char  *pName;      // Command name (unique part uppercase, optional lowercase)
    int   (*pHandler)(char *pArgs);
} QD, *pQD;


int NetProCmd(char *pCmd);
int ResCmd(char *pCmd);
int FdbCmd(char *pCmd);
int FileInfoCmd(char *pCmd);
int FindInfoCmd(char *pCmd);
int IoReqCmd(char *pCmd);
int FindInfoCmd(char *pCmd);
int LogCmd(char *pCmd);

QD QueryDispatch[] = {
    { "NETPRO"    	, NetProCmd     },
    { "RES"         , ResCmd     	},
    { "FDB"     	, FdbCmd        },
    { "FILEINFO"    , FileInfoCmd   },
    { "FINDINFO"   	, FindInfoCmd   },
    { "IOREQ"   	, IoReqCmd      },
    { "LOG"         , LogCmd        },
	{ ""        	, 0             },
};


#define MAX_ARG_LEN 30
#define MAX_DEBUG_QUERY_COMMAND_LENGTH 100

unsigned char DebugQueryCmdStr[MAX_DEBUG_QUERY_COMMAND_LENGTH+1] = "";
ULONG DebugQueryCmdStrLen = MAX_DEBUG_QUERY_COMMAND_LENGTH;
unsigned char CmdArg[MAX_ARG_LEN+1] = {0};
unsigned char vrgchBuffDebug[MAX_PATH+1];

/*
    GetArg - Gets a command line argument from a string.

    IN          ppArg = pointer to pointer to argument string
    OUT        *ppArg = pointer to next argument, or NULL if this was the last.
    Returns     Pointer to uppercase ASCIZ argument with delimeters stripped, or NULL if
                no more arguments.

    Note        Not reentrant

*/

unsigned char *GetArg(unsigned char **ppArg)
{
    // Note - Always returns at least one blank argument if string is valid, even
    //        if the string is empty.

    unsigned char *pDest = CmdArg;
    unsigned char c;
    ULONG i;

    #define pArg (*ppArg)

    // If end of command already reached, fail

    if (!pArg)
        return NULL;

    // Skip leading whitespace

    while (*pArg == ' ' || *pArg == '\t')
        pArg++;

    // Copy the argument

    for (i = 0; i < MAX_ARG_LEN; i++) {
        if ((c = *pArg) == 0 || c == '\t' || c == ' ' || c == ';' ||
                          c == '\n' || c == ',')
            break;
        if (c >= 'a' && c <= 'z')
            c -= ('a' - 'A');
        *(pDest++) = c;
        pArg++;
    }

    // Null terminate the result

    *pDest = '\0';

    // Skip trailing whitespace

    while (*pArg == ' ' || *pArg == '\t')
        pArg++;

    // strip up to one comma

    if (*pArg == ',')
        pArg++;

    // If end of command reached, make next request fail

    else if (*pArg == 0 || *pArg == ';' || *pArg == '\n')
        pArg = NULL;

    // return copy

    return CmdArg;

    #undef pArg
}

/*
    AtoI - Convert a string to a signed or unsigned integer

    IN          pStr = ASCIZ representation of number with optional leading/trailing
                       whitespace and optional leading '-'.
                Radix = Radix to use for conversion (2, 8, 10, or 16)
    OUT        *pResult = Numeric result, or unchanged on failure
    Returns     1 on success, 0 if malformed string.

    Note        Not reentrant

*/
ULONG AtoI(unsigned char *pStr, ULONG Radix, ULONG *pResult)
{
    ULONG r = 0;
    ULONG Sign = 0;
    unsigned char c;
    ULONG d;

    while (*pStr == ' ' || *pStr == '\t')
        pStr++;

    if (*pStr == '-') {
        Sign = 1;
        pStr++;
    }

    if (*pStr == 0)
        return 0;                   // Empty string!

    while ((c = *pStr) != 0 && c != ' ' && c != '\t') {
        if (c >= '0' && c <= '9')
            d = c - '0';
        else if (c >= 'A' && c <= 'F')
            d = c - ('A' - 10);
        else if (c >= 'a' && c <= 'f')
            d = c - ('a' - 10);
        else
            return 0;               // Not a digit
        if (d >= Radix)
            return 0;               // Not in radix
        r = r*Radix+d;
        pStr++;
    }

    while (*pStr == ' ' || *pStr == '\t')
        pStr++;

    if (*pStr != 0)
        return 0;                   // Garbage at end of string

    if (Sign)
        r = (ULONG)(-(int)r);
    *pResult = r;

    return 1;                       // Success!

}

VOID
*GetPtr(char *pCmd)
{
	char *pch;
	int p;
	
	pch = GetArg(&pCmd);
	
	//dprintf("cmd = '%s'\n");
	if (*pch == 0 || !AtoI(pch, 16, &p))
 		return 0;

	return (VOID *) p;
}

int
CmdDispatch(char *pCmdName, char *pCmd)
{
	int ret = 0;
	int i=0;
	pQD	pq;

	pq = QueryDispatch;

	while (pq->pName[0]) {
		if (strcmp(pCmdName, pq->pName) == 0) {
		    ret = (*pq->pHandler)(pCmd);
			DbgPrint("\n");
			break;
		}
		pq++;
	}

	return ret;
}

//** Debug Command Handlers

int
NetProCmd(char *pCmd)
{
	
	DispNetPro("");

	return 1;
}

int
IoReqCmd(char *pCmd)
{
	pioreq pir;

	if (pir = GetPtr(pCmd))
		DispThisIOReq(pir);
	else
		return 0;

	return 1;
}


int
ResCmd(char *pCmd)
{
	DispResource(pCmd);
	return 1;
}

int
FdbCmd(char *pCmd)
{
	PFDB pFdb;


	if (pFdb = GetPtr(pCmd)){
		DispThisFdb(pFdb);
	}

	return 1;
}

int
FileInfoCmd(char *pCmd)
{
	PFILEINFO pF;

	if (pF = GetPtr(pCmd))
		DispThisFileInfo(pF);

	return 1;
}

int
FindInfoCmd(char *pCmd)
{

	return 1;
}

int
LogCmd(char *pCmd)
{
    DispLog(pCmd);
}

// **	SHDDebug - handle Debug_Query request from windows
//

VOID
SHDDebug(unsigned char *pCmd)
{
	pimh phand;
	char *pCmdName;

//	dprintf("pCmd = '%s'\n", pCmd);
	//see if we got an explicit command
	pCmdName = GetArg(&pCmd);	

//	dprintf("pCmdName = (%x) '%s'\n", pCmdName, pCmdName);	
	if (*pCmdName != 0) { //got a command, try to process it
		if (!CmdDispatch(pCmdName, pCmd))  {
			DbgPrint("%* Shadow Command Options:\n");
			DbgPrint("%* NETPRO             ----- dump network provider info\n");
			DbgPrint("%* RES [addr]         ---- dump resource info\n");
			DbgPrint("%* FDB [addr]         ---- dump File Descriptor Block\n");
			DbgPrint("%* FILEINFO [addr]    --- dump per open file structure\n");
			DbgPrint("%* FINDINFO [addr]    --- dump findinfo structure\n");
			DbgPrint("%* IOREQ [addr]       --- dump IOReq structure\n");
    		DbgPrint("%* LOG                --- show trace log\n");
    	}
	} else {
		//no args passed, do the menu thing
		while ((phand=DebugMenu(SHDMainMenu)) != 0) {
			if (phand(0) != 0)
				return;
		}
	}
	return;
}


/*+++

Actual display functions

+++*/


VOID
DispThisIOReq(
	pioreq pir
	)
{
    // Display the ioreq structure
	DbgPrint("%*IoReq = \t\t%8.8x \n", pir );
	DbgPrint("%*ir_length=\t\t%x\n", pir->ir_length);
    DbgPrint("%*ir_flags=\t\t%x\n", pir->ir_flags);
    DbgPrint("%*ir_user=\t\t%x\n", pir->ir_user);
	DbgPrint("%*ir_sfn=\t\t%x\n", pir->ir_sfn);
    DbgPrint("%*ir_pid=\t\t%x\n", pir->ir_pid);
    DbgPrint("%*ir_ppath=\t\t%x\n", pir->ir_ppath);
	DbgPrint("%*ir_aux1=\t\t%x\n", pir->ir_aux1);
    DbgPrint("%*ir_data=\t\t%x\n", pir->ir_data);
    DbgPrint("%*ir_options=\t\t%x\n", pir->ir_options);
	DbgPrint("%*ir_error=\t\t%x\n", pir->ir_error);
	DbgPrint("%*ir_rh=\t\t%x\n", pir->ir_rh);
	DbgPrint("%*ir_fh=\t\t%x\n", pir->ir_fh);
	DbgPrint("%*ir_pos=\t\t%x\n", pir->ir_pos);
    DbgPrint("%*ir_aux2=\t\t%x\n", pir->ir_aux2);
    DbgPrint("%*ir_pev=\t\t%x\n", pir->ir_pev);
}

int DispIOReq(
	char *pCmd
	)
{
	pioreq pir;

	if (pir = GetPtr(pCmd))
	{
		DispThisIOReq(pir);
		return (1);
	}
	return (0);
}
int
DispNetPro(
	char *pcl
	)
{
	int i;

	if (cMacPro > 1){
		DbgPrint("%d redirs hooked \n", cMacPro-1);

		for (i=1; i< cMacPro; ++i){
			DbgPrint("Info for Redir # %d \n", i);

			DbgPrint("Head of Resource Chain = \t%x\n", rgNetPro[i].pheadResource);
			DbgPrint("Shadow Connect Function = \t%x\n", rgNetPro[i].pOurConnectNet);
			DbgPrint("Redir Connect Function = \t%x\n", rgNetPro[i].pConnectNet);
		}
		return (1);
	}
	else {
		DbgPrint("No Redirs have been hooked \n");
		return (0);
	}
}


int
DispResource(
	char *pCmd
	)
{
	PRESOURCE pResource = GetPtr(pCmd);

	if (pResource)
	{
		DispThisResource(pResource);

	}
	else
	{
		if (cMacPro > 1)
		{
			pResource = rgNetPro[1].pheadResource;
			while (pResource)
			{
				DispThisResource(pResource);
				pResource = pResource->pnextResource;
			}
		}
	}
}

int
DispFdb(
	char *pCmd
	)
{
	PFDB pFdb = GetPtr(pCmd);

	if (pFdb)
	{
		DispThisFdb(pFdb);
		return (1);
	}
	return (0);
}

int
DispFileInfo(
	char *pCmd
	)
{
	PFILEINFO pFileInfo = GetPtr(pCmd);

	if (pFileInfo)
	{
		DispThisFileInfo(pFileInfo);
		return (1);
	}
	return (0);
}

int
DispFindInfo(
	char *pCmd
	)
{
	PFINDINFO pFindInfo = GetPtr(pCmd);

	if (pFindInfo)
	{
		DispThisFindInfo(pFindInfo);
		return (1);
	}
	return (0);
}

int
DispLog(
	char *pCmd
    )
{
    int indxT=0, len;
    LPSTR   lpszT;

    pCmd;

    lpszT = lpLogBuff;

    while (indxCur > indxT)
    {
        DbgPrint(("%s"), lpszT);

        for (len=1; (*(lpszT+len) != 0xa) && ((indxT+len) < indxCur); ++len);

        // step over the string
        lpszT += len;
        indxT += len;
    }

}

/*+++

Helper Functions

+++*/


VOID
DispThisResource(
	PRESOURCE pResource
	)
{
	DbgPrint("Resource \t%x \n", pResource);
	PpeToSvr(pResource->pp_elements, vrgchBuffDebug, MAX_PATH, BCS_OEM);
	DbgPrint("Share name: \t%s \n", vrgchBuffDebug);
	DbgPrint("Next Resource \t%x \n", pResource->pnextResource);
	DbgPrint("FileInfo structures list \t%x \n", pResource->pheadFileInfo);
	DbgPrint("FindInfo structures list \t%x \n", pResource->pheadFindInfo);
	DbgPrint("FDB structures list \t%x \n", pResource->pheadFdb);
	DbgPrint("hServer: \t%x\n", pResource->hServer);
	DbgPrint("Root shadow: \t%x\n", pResource->hRoot);
	DbgPrint("usFlags \t%x\n", (ULONG)(pResource->usFlags));
	DbgPrint("usLocalFlags \t%x\n", (ULONG)(pResource->usLocalFlags));
	DbgPrint("Our Network Provider \t%x\n", pResource->pOurNetPro);
	DbgPrint("Providers resource handle \t%x\n", pResource->rhPro);
	DbgPrint("fh_t \t%x\n", pResource->fhSys);
	DbgPrint("Providers Volume Function table \t%x\n", pResource->pVolTab);
	DbgPrint(" Count of locks on this resource \t%x\n", pResource->cntLocks);
	DbgPrint(" Bitmap of mapped drives \t%x\n", pResource->uDriveMap);

}

VOID
DispThisFdb(
	PFDB pFdb
	)
{

	DbgPrint("\n");
	memset(vrgchBuffDebug, 0, sizeof(vrgchBuffDebug));
	UniToBCSPath(vrgchBuffDebug, &(pFdb->sppathRemoteFile.pp_elements[0]), MAX_PATH, BCS_OEM);
	DbgPrint("****** Fdb for \t%s ", vrgchBuffDebug);
	memset(vrgchBuffDebug, 0, sizeof(vrgchBuffDebug));
	PpeToSvr(pFdb->pResource->pp_elements, vrgchBuffDebug, MAX_PATH, BCS_OEM);
	DbgPrint("on \t%s \n", vrgchBuffDebug);

	DbgPrint("Next Fdb: \t%x \n", pFdb->pnextFdb);
	DbgPrint("Resource: \t%x\n", pFdb->pResource);
	DbgPrint("usFlags: \t%x\n", (ULONG)(pFdb->usFlags));
	DbgPrint("Total # of opens: \t%x\n", (ULONG)(pFdb->usCount));
	DbgPrint("File Inode: \t%x\n", pFdb->hShadow);
	DbgPrint("Dir Inode: \t%x\n", pFdb->hDir);

}


VOID
DispThisFileInfo(
	PFILEINFO pFileInfo
	)
{

	DbgPrint("\n");
	memset(vrgchBuffDebug, 0, sizeof(vrgchBuffDebug));
	UniToBCSPath(vrgchBuffDebug, &(pFileInfo->pFdb->sppathRemoteFile.pp_elements[0]), MAX_PATH, BCS_OEM);
	DbgPrint("****** FileInfo for \t%s ", vrgchBuffDebug);
	memset(vrgchBuffDebug, 0, sizeof(vrgchBuffDebug));
	PpeToSvr(pFileInfo->pResource->pp_elements, vrgchBuffDebug, MAX_PATH, BCS_OEM);
	DbgPrint("on \t%s \n", vrgchBuffDebug);

	DbgPrint(" Next FileInfo \t%x\n", pFileInfo->pnextFileInfo);
	DbgPrint(" Resource off which it is hangin%x\n", pFileInfo->pResource);
	DbgPrint(" Shadow file handle \t%x\n", pFileInfo->hfShadow);
	DbgPrint(" pFdb: %x\n", pFileInfo->pFdb);
	DbgPrint(" providers file handle: \t%x\n", pFileInfo->fhProFile);
	DbgPrint(" providers file function table \t%x\n", pFileInfo->hfFileHandle);
	DbgPrint(" Acess-share flags for this open \t%x\n", (ULONG)(pFileInfo->uchAccess));
	DbgPrint(" usFlags: \t%x\n", (ULONG)(pFileInfo->usFlags));
	DbgPrint(" usLocalFlags: \t%x\n", (ULONG)(pFileInfo->usLocalFlags));
	DbgPrint(" sfnFile: \t%x\n", pFileInfo->sfnFile);
	DbgPrint(" pidFile: \t%x\n", pFileInfo->pidFile);
	DbgPrint(" userFile: \t%x\n", pFileInfo->userFile);

}

VOID
DispThisFindInfo(
	PFINDINFO pFindInfo
	)
{
}


#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\shadowse.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    shadowse.c

Abstract:

    This module implements all security related functions for disconnected
    operation of Client Side Caching

Revision History:

    Balan Sethu Raman     [SethuR]    6-October-1997

Notes:

    In NT ACL(Access Control lists) provide the necessary mechanism for
    denying/granting permissions to users. Each user is associated with a SID.
    The ACLs are specified in terms of SIDs associated with groups of users as
    well as individual users. Each user is associated with a token at runtime
    which details the various groups a user is a member of and this token is
    used to evaluate the ACLs. This is complicated by the fact that there are
    local groups associated with various machines. Therefore the token/context
    associated with an user varies from machine.

    In connected mode the credentials associated with a given user are shipped
    to the server where they are validated and the appropriate token created.
    This token is used subsequently in the evaluation of ACLs.

    This presents us with two options in implementing security for disconnected
    operation -- lazy evaluation and eager evaluation. In lazy evaluation the
    evaluation of ACLs is done on demand but the preparatory work for this
    evaluation is done in connected mode. On the other hand in eager evaluation
    the ACLs are evaluated and the maximal rights are stored as part of the CSC
    database. These rights are used to determine the appropriate access.

    The advantage of lazy evaluation is that the database is no longer constrained
    by previous access requirements while in eager evaluation we require that the
    user have accessed the file in connected mode in order to correctly determine
    the rights in disconnected mode. The flip side is that Lazy Evaluation is
    tougher to implement ( requires modifications in security/DS ) while the
    eager evaluation implementation is very easy.

    The current implementation corresponds to a simplified form of eager evaluation
    strategy. Appropriate encapsulation has been provided to allow us to
    swicth over to a lazy evaluation mode easily.

    There are three facets of the implementation

        1) Storing/Retreiving Access information

        2) Denying/Granting access based upon the stored access information.

        3) Persisting the SID/index mapping

    Currently associated with each file/directory in the CSC database there is a
    security blob. This blob is an in

--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

DWORD
CscUpdateCachedSecurityInformation(
    PCACHED_SECURITY_INFORMATION pCachedSecurityInformation,
    ULONG                        CachedSecurityInformationLength,
    ULONG                        NumberOfSids,
    PCSC_SID_ACCESS_RIGHTS       pSidAccessRights)
/*++

Routine Description:

    This routine updates the access rights for a given number of sids in the
    given cached security information structure. This routine centralizes the
    update process required for share level security as well as the object level
    security into a single routine since the on disk format for both these
    cases are the same. However, different APIs are required to update the
    in memory data structures.
    
    

Arguments:

    pCachedSecurityInformation - the cached security information instance

    CachedSecurityInformationLength - the length of the cached information

    NumberOfSids - the number of sids for which the access rights needs to be
                   updated

    pSidAccessRights - an array of the sids and the corresponding access rights.

Return Value:

    ERROR_SUCCESS if successful, otherwise appropriate error

Notes:

    The current implementation of this routine is based upon the assumption that
    the number of Sid mappings stored on a per file basis is very small ( 8 at most).
    If this assumption is changed this routine needs to be reworked.

--*/
{
    DWORD  Status = ERROR_SUCCESS;
    ULONG  i,j,cntNewRights=0;
    CACHED_SECURITY_INFORMATION NewSecurityInformation;

    ASSERT(CachedSecurityInformationLength == sizeof(CACHED_SECURITY_INFORMATION));

    if (NumberOfSids > CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES) {
        return ERROR_BUFFER_OVERFLOW;
    } else if (NumberOfSids == 0) {
        return ERROR_SUCCESS;
    }

    // NB assumption, CSC_INVALID_INDEX is 0
    memset(&NewSecurityInformation, 0, sizeof(NewSecurityInformation));


    // from the array of new rights
    for (i = 0; i < NumberOfSids; i++) {
        CSC_SID_INDEX SidIndex;

        // map the sid to a sid index
        SidIndex = CscMapSidToIndex(
                       pSidAccessRights[i].pSid,
                       pSidAccessRights[i].SidLength);

        if (SidIndex == CSC_INVALID_SID_INDEX) {
            // Map the new sid
            Status = CscAddSidToDatabase(
                         pSidAccessRights[i].pSid,
                         pSidAccessRights[i].SidLength,
                         &SidIndex);

            if (Status != STATUS_SUCCESS)
            {
                return Status;                
            }

        }
        
        NewSecurityInformation.AccessRights[i].SidIndex = SidIndex;
        NewSecurityInformation.AccessRights[i].MaximalRights =
            (USHORT)pSidAccessRights[i].MaximalAccessRights;

        cntNewRights++;
    }

    // now copy the cached rights from old array for those sids which are not already 
    // there in the new array, till all slots in the new array are full
    // this ensures a round robin scheme

    ASSERT(cntNewRights && (cntNewRights <= CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES));

    for (i=0; i<CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES; ++i)
    {
        // if all slots in the new array are filled up, break
        if (cntNewRights==CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES)
        {
            break;            
        }

        // if this is a valid sid index
        if (pCachedSecurityInformation->AccessRights[i].SidIndex != CSC_INVALID_SID_INDEX)
        {
            BOOLEAN fFound;
            
            fFound = FALSE;

            // check if it is already there in the new array.
            
            for (j=0; j< cntNewRights; ++j)
            {
                if (NewSecurityInformation.AccessRights[j].SidIndex == 
                    pCachedSecurityInformation->AccessRights[i].SidIndex)
                {
                    fFound = TRUE;
                    break;                                        
                }
            }
            
            // if it isn't in the new array, then we need to copy it
            if (!fFound)
            {
                NewSecurityInformation.AccessRights[cntNewRights] = 
                pCachedSecurityInformation->AccessRights[i];

                ++cntNewRights; // the new array has 
            }
        }
    }
    
    // update the cached security info and pass it back
    *pCachedSecurityInformation = NewSecurityInformation;

    return Status;
}

DWORD
CscAddMaximalAccessRightsForSids(
    HSHADOW                 hParent,
    HSHADOW                 hFile,
    ULONG                   NumberOfSids,
    PCSC_SID_ACCESS_RIGHTS  pSidAccessRights)
/*++

Routine Description:

    This routine updates the access rights for a given number of sids on the
    given file

Arguments:

    hParent - the parent directory shadow handle

    hFile   - the shadow handle

    NumberOfSids - the number of sids for which the access rights needs to be
                   updated

    pSidAccessRights - an array of the sids and the corresponding access rights.

Return Value:

    ERROR_SUCCESS if successful, otherwise appropriate error

Notes:

    The current implementation of this routine is based upon the assumption that
    the number of Sid mappings stored on a per file basis is very small ( 8 at most).
    If this assumption is changed this routine needs to be reworked.

--*/
{
    DWORD  Status = ERROR_SUCCESS;

    CACHED_SECURITY_INFORMATION CachedSecurityInformation;

    ULONG  BytesReturned, BytesWritten;

    BytesReturned = sizeof(CachedSecurityInformation);

    Status = GetShadowInfoEx(
                 hParent,
                 hFile,
                 NULL,
                 NULL,
                 NULL,
                 &CachedSecurityInformation,
                 &BytesReturned);

    if ((Status == ERROR_SUCCESS) &&
        ((BytesReturned == 0) ||
         (BytesReturned == sizeof(CachedSecurityInformation)))) {

        Status = CscUpdateCachedSecurityInformation(
                     &CachedSecurityInformation,
                     BytesReturned,
                     NumberOfSids,
                     pSidAccessRights);

        if (Status == ERROR_SUCCESS) {
            BytesWritten = sizeof(CachedSecurityInformation);

            Status = SetShadowInfoEx(
                         hParent,
                         hFile,
                         NULL,
                         0,
                         SHADOW_FLAGS_OR,
                         NULL,
                         &CachedSecurityInformation,
                         &BytesWritten);
        }
    }

    return Status;
}

DWORD
CscAddMaximalAccessRightsForShare(
    HSERVER                 hShare,
    ULONG                   NumberOfSids,
    PCSC_SID_ACCESS_RIGHTS  pSidAccessRights)
/*++

Routine Description:

    This routine updates the access rights for a given number of sids on the
    given share

Arguments:

    hShare - the parent directory shadow handle

    NumberOfSids - the number of sids for which the access rights needs to be
                   updated

    pSidAccessRights - an array of the sids and the corresponding access rights.

Return Value:

    ERROR_SUCCESS if successful, otherwise appropriate error

Notes:

    The current implementation of this routine is based upon the assumption that
    the number of Sid mappings stored on a per file basis is very small ( 8 at most).
    If this assumption is changed this routine needs to be reworked.

--*/
{
    DWORD  Status = ERROR_SUCCESS;

    CACHED_SECURITY_INFORMATION CachedSecurityInformation;

    ULONG  BytesReturned, BytesWritten;

    BytesReturned = sizeof(CachedSecurityInformation);

    Status = GetShareInfoEx(
                 hShare,
                 NULL,
                 NULL,
                 &CachedSecurityInformation,
                 &BytesReturned);

    if ((Status == ERROR_SUCCESS) &&
        ((BytesReturned == 0) ||
         (BytesReturned == sizeof(CachedSecurityInformation)))) {

        Status = CscUpdateCachedSecurityInformation(
                     &CachedSecurityInformation,
                     BytesReturned,
                     NumberOfSids,
                     pSidAccessRights);

        if (Status == ERROR_SUCCESS) {
            BytesWritten = sizeof(CachedSecurityInformation);

                if (SetShareStatusEx(
                         hShare,
                         0,
                         SHADOW_FLAGS_OR,
                         &CachedSecurityInformation,
                         &BytesWritten) >= 0)
                {
                    Status = STATUS_SUCCESS;
                }
                {
                    Status = STATUS_UNSUCCESSFUL;
                }
        }
    }

    return Status;
}

DWORD
CscRemoveMaximalAccessRightsForSid(
    HSHADOW     hParent,
    HSHADOW     hFile,
    PVOID       pSid,
    ULONG       SidLength)

/*++

Routine Description:

    This routine removes the cached access rights for a given number of sids on
    the given file

Arguments:

    hParent - the parent directory shadow handle

    hFile   - the shadow handle

    pSid    - the sid for which the cached access rights are revoked.

    SidLength - the length of the sid.

Return Value:

    ERROR_SUCCESS if successful, otherwise appropriate error

--*/
{
    DWORD   Status = ERROR_SUCCESS;
    USHORT  SidIndex;
    ULONG   BytesRead,BytesWritten,i;

    CACHED_SECURITY_INFORMATION CachedSecurityInformation;

    SidIndex = CscMapSidToIndex(
                   pSid,
                   SidLength);

    if (SidIndex != CSC_INVALID_SID_INDEX) {
        BytesRead = sizeof(CachedSecurityInformation);

        Status = GetShadowInfoEx(
                    hParent,
                    hFile,
                    NULL,
                    NULL,
                    NULL,
                    &CachedSecurityInformation,
                    &BytesRead);

        if ((Status == ERROR_SUCCESS) &&
            (BytesRead == sizeof(CachedSecurityInformation))) {
            for (i = 0; i < CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES; i++) {
                if (CachedSecurityInformation.AccessRights[i].SidIndex == SidIndex) {
                    CachedSecurityInformation.AccessRights[i].SidIndex =
                        CSC_INVALID_SID_INDEX;

                    BytesWritten = sizeof(CachedSecurityInformation);

                    Status = SetShadowInfoEx(
                                 hParent,
                                 hFile,
                                 NULL,
                                 0,
                                 SHADOW_FLAGS_OR,
                                 NULL,
                                 &CachedSecurityInformation,
                                 &BytesWritten);

                    break;
                }
            }
        }
    }

    return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\bmreclib\localdefs.h ===
#define  PUBLIC
typedef int                 BOOL;
typedef  unsigned             HFILE;
typedef void             *LPVOID;
typedef unsigned long       DWORD;
typedef struct  _FILETIME
    {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
    }   FILETIME;


typedef  ULONG  HSERVER;
typedef  ULONG  HSHADOW;
typedef  ULONG  HSHARE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\utils.h ===
#define  IF32_LOCAL        	0x0001
#define  IF32_DIRECTORY    	0x0002
#define  IF32_LAST_ELEMENT	0x0004

#ifndef CSC_RECORDMANAGER_WINNT
#define _wtoupper(x)     ( ( ((x)>='a')&&((x)<='z') ) ? ((x)-'a'+'A'):(x))
#define _mytoupper(x)     ( ( ((x)>='a')&&((x)<='z') ) ? ((x)-'a'+'A'):(x))
#else
#define _wtoupper(x)    RtlUpcaseUnicodeChar(x)
#define _mytoupper(x)   RtlUpperChar(x)
#endif
// not to be used obsolete

#define MakeNullPPath(p_ppath)	p_ppath->pp_totalLength = 4; 	\
					p_ppath->pp_prefixLength = 4;				\
					p_ppath->pp_elements[0].pe_length = 0	

int PUBLIC GetServerPart(LPPE lppeServer, USHORT *lpBuff, int cBuff);
ULONG PUBLIC GetNextPathElement(LPPP lppp, ULONG indx,USHORT *lpBuff, ULONG cBuff);
VOID PUBLIC GetLeafPtr(LPPATH lpPath, USHORT *lpBuff, ULONG cBuff);
VOID PUBLIC BreakPath(LPPP lppp, ULONG indx, USHORT *pusSav);
VOID PUBLIC MendPath(LPPP lppp, ULONG indx, USHORT *pusSav);
int PUBLIC HexToA(ULONG ulHex, LPSTR lpBuff, int count);
ULONG PUBLIC AtoHex(LPSTR lpBuff, int count);
int wstrnicmp(const USHORT *, const USHORT *, ULONG);
//int strnicmp(const char *, const char *, ULONG);
ULONG strmcpy(LPSTR, LPSTR, ULONG);
int PpeToSvr(LPPE, LPSTR, int, ULONG);
ULONG wstrlen(USHORT *lpuStr);
int DosToWin32FileSize(ULONG, int *, int *);
int Win32ToDosFileSize(int, int, ULONG *);
int CompareTimes(_FILETIME, _FILETIME);
int CompareSize(long nHighDst, long nLowDst, long nHighSrc, long nLowSrc);
void InitFind32FromIoreq (PIOREQ, LPFIND32, ULONG uFlags);
void InitFind32Names(LPFIND32, USHORT * , USHORT *);
void InitIoreqFromFind32 (LPFIND32, PIOREQ);
void Find32ToSearchEntry(LPFIND32 lpFind32, srch_entry *pse);
void PUBLIC Find32AFromFind32(LPFIND32A, LPFIND32, int);
void PUBLIC Find32FromFind32A(LPFIND32, LPFIND32A, int);
void  AddPathElement(path_t, string_t, int);
void MakePPath(path_t, LPBYTE);
void MakePPathW(path_t, USHORT *);
void DeleteLastElement(path_t);
int ResNameCmp(LPPE, LPPE);
int  Conv83ToFcb(LPSTR lp83Name, LPSTR lpFcbName);
int  Conv83UniToFcbUni(USHORT *, USHORT *);
void  FileRootInfo(LPFIND32);
BOOL FHasWildcard(USHORT *lpuName, int cMax);
LPSTR mystrpbrk(LPSTR, LPSTR);
LPWSTR
wstrpbrk(
    LPWSTR lpSrc,
    LPWSTR lpDelim
    );

int OfflineToOnlinePath(path_t ppath);
int OnlineToOfflinePath(path_t ppath);

BOOL IsOfflinePE(LPPE lppp);
int OnlineToOfflinePE(LPPE lppp);
int OfflineToOnlinePE(LPPE lppp);

BOOL IsOfflineUni(USHORT *lpuName);
int OnlineToOfflineUni(USHORT *lpuName, ULONG size);
int OfflineToOnlineUni(USHORT *lpuName, ULONG size);

LPVOID mymemmove(LPVOID lpDst, LPVOID lpSrc, ULONG size);
int GetDriveIndex(LPSTR lpDrive);

//prototypes added to remove NT compile warn/errors

void FillRootInfo(
   LPFIND32 lpFind32
   );

int CompareTimesAtDosTimePrecision( _FILETIME ftDst,
   _FILETIME ftSrc
   );


int ReadInitValues();

BOOL
HasHeuristicTypeExtensions(
	USHORT	*lpwzFileName
	);

VOID
IncrementFileTime(
    _FILETIME *lpft
    );

int
IncrementTime(
    LPFILETIME  lpFt,
    int    secs
    );


#ifndef CSC_RECORDMANAGER_WINNT
int mystrnicmp(
    const char *pStr1,
    const char *pStr2,
    unsigned count
    );
#else
_CRTIMP int __cdecl mystrnicmp(
    const char *pStr1,
    const char *pStr2,
    size_t count
    );
#endif //ifndef CSC_RECORDMANAGER_WINNT

BOOL
CreateStringArrayFromDelimitedList(
    IN  LPWSTR  lpwzDelimitedList,
    IN  LPWSTR  lpwzDelimiters,
    IN  LPWSTR  *lprgwzStringArray,
    OUT LPDWORD lpdwCount
    );
    
BOOL
DeleteDirectoryFiles(
    LPCSTR  lpszDir
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\sprintf.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sprintf.c

Abstract:

    Implements Windows friendly versions of sprintf and vsprintf

Author:



Revision History:

 	2/15/89     craigc	    Initial
 	4/6/93      ROBWI       For VxD

--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

#include <stdlib.h>
#include <ctype.h>
#include <string.h>

#ifndef CSC_RECORDMANAGER_WINNT
#include    "basedef.h"
#include    "vmm.h"
#pragma VxD_LOCKED_CODE_SEG
#endif //ifndef CSC_RECORDMANAGER_WINNT

#include "vxdwraps.h"

#define WSPRINTF_LIMIT 1024
#define DEBUG_BUFFER_SIZE 16376

extern int SP_PutNumber(char *, long, int, int, int);
extern void SP_Reverse(char * lp1, char * lp2);

DWORD DebugBufferLength = 0;
char * DebugBuffer;


#define out(c) if (--cchLimit) *lpOut++=(c); else goto errorout
#pragma intrinsic (memcmp, memcpy, memset, strcat, strcmp, strcpy, strlen)

/*
 *  GetFmtValue
 *
 *  reads a width or precision value from the format string
 */

char * SP_GetFmtValue(char * lpch, int * lpw)
{
    register int i=0;

    while (*lpch>='0' && *lpch<='9')
	{
	i *= 10;
	i += (int)(*lpch-'0');
	lpch++;
	}

    *lpw=i;

    /* return the address of the first non-digit character */
    return lpch;
}

/*
 *  vsprintf()
 *
 *  VxD version of vsprintf().  Does not support floating point or
 *  pointer types, and all strings are assumed to be NEAR.  Supports only
 *  the left alignment flag.
 *
 *  Takes pointers to an output buffer, where the string is built, a
 *  pointer to an input buffer, and a pointer to a list of parameters.
 *
 */

int vxd_vsprintf(char * lpOut, char * lpFmt, CONST VOID * lpParms)
{
    int left;
    char prefix;
    register int width;
    register int prec;
    char fillch;
    int size;
    int sign;
    int radix;
    int upper;
    int cchLimit=WSPRINTF_LIMIT;
    int cch;
    char * lpT;
    union {
	long l;
	ULONG ul;
	char sz[sizeof(long)];
	} val;
    int fWideChar;

    while (*lpFmt)
	{
	if (*lpFmt=='%')
	    {

	    /* read the flags.	These can be in any order */
	    left=0;
	    prefix=0;
        fWideChar = 0;
	    while (*++lpFmt)
		{
		if (*lpFmt=='-')
		    left++;
		else if (*lpFmt=='#')
		    prefix++;
		else
		    break;
		}

	    /* find fill character */
	    if (*lpFmt=='0')
		{
		fillch='0';
		lpFmt++;
		}
	    else
		fillch=' ';

	    /* read the width specification */
	    lpFmt=SP_GetFmtValue(lpFmt,&cch);
	    width=cch;

	    /* read the precision */
	    if (*lpFmt=='.')
		{
		lpFmt=SP_GetFmtValue(++lpFmt,&cch);
		prec=cch;
		}
	    else
		prec=-1;

	    /* get the operand size */
	    if (*lpFmt=='l')
		{
		size=1;
		lpFmt++;
		}
	    else
		{
		size=0;
		if (*lpFmt=='h')
		    lpFmt++;
		}

	    upper=0;
	    sign=0;
	    radix=10;
	    switch (*lpFmt)
		{
	    case 0:
		goto errorout;

	    case 'i':
	    case 'd':
		sign++;

	    case 'u':
		/* turn off prefix if decimal */
		prefix=0;
donumeric:
		/* special cases to act like MSC v5.10 */
		if (left || prec>=0)
		    fillch=' ';

		if (size)
		    val.l=*((long *)lpParms)++;
		else
		    if (sign)
		        val.l=*((long *)lpParms)++;
		    else
			val.ul=(ULONG)*((ULONG *)lpParms)++;

		if (sign && val.l<0L)
		    val.l=-val.l;
		else
		    sign=0;

		lpT=lpOut;

		/* blast the number backwards into the user buffer */
		cch=SP_PutNumber(lpOut,val.l,cchLimit,radix,upper);
		if (!(cchLimit-=cch))
		    goto errorout;

		lpOut+=cch;
		width-=cch;
		prec-=cch;
		if (prec>0)
		    width-=prec;

		/* fill to the field precision */
		while (prec-->0)
		    out('0');

		if (width>0 && !left)
		    {
		    /* if we're filling with spaces, put sign first */
		    if (fillch!='0')
			{
			if (sign)
			    {
			    sign=0;
			    out('-');
			    width--;
			    }

			if (prefix)
			    {
			    out(prefix);
			    out('0');
			    prefix=0;
			    }
			}

		    if (sign)
			width--;

		    /* fill to the field width */
		    while (width-->0)
			out(fillch);

		    /* still have a sign? */
		    if (sign)
			out('-');

		    if (prefix)
			{
			out(prefix);
			out('0');
			}

		    /* now reverse the string in place */
		    SP_Reverse(lpT,lpOut-1);
		    }
		else
		    {
		    /* add the sign character */
		    if (sign)
			{
			out('-');
			width--;
			}

		    if (prefix)
			{
			out(prefix);
			out('0');
			}

		    /* reverse the string in place */
		    SP_Reverse(lpT,lpOut-1);

		    /* pad to the right of the string in case left aligned */
		    while (width-->0)
			out(fillch);
		    }
		break;

	    case 'X':
		upper++;
	    case 'x':
		radix=16;
		if (prefix)
		    if (upper)
			prefix='X';
		    else
			prefix='x';
		goto donumeric;

	    case 'c':
		val.sz[0] = *((char *)lpParms);
		val.sz[1]=0;
		lpT=val.sz;
		cch = 1;  // Length is one character.
			  // Fix for Bug #1862 --01/10/91-- SANKAR --
		/* stack aligned to larger size */
		(BYTE *)lpParms += sizeof(DWORD);

		goto putstring;
        case 'w':
            fWideChar = 1;
	    case 's':
		lpT=*((char **)lpParms)++;
		cch=((!fWideChar)?strlen(lpT):wstrlen((USHORT *)lpT));
putstring:
		if (prec>=0 && cch>prec)
		    cch=prec;
		width -= cch;
		if (left)
		    {
		    while (cch--) {
			if (*lpT == 0x0A || *lpT == 0x0D) {
                                out(0x0D);
                                out(0x0A);
                        }
                        else
			    out(*lpT++);
                if (fWideChar)
                {
                    ++lpT;
                }
            }
		    while (width-->0)
			out(fillch);
		    }
		else
		    {
		    while (width-->0)
			out(fillch);
		    while (cch--) {
			if (*lpT == 0x0A || *lpT == 0x0D) {
                                out(0x0D);
                                out(0x0A);
                        }
                        else
		    	    out(*lpT++);
                    if (fWideChar)
                    {
                        ++lpT;
                    }
                }
		    }
		break;

	    default:
	    	/* This is an unsupported character that followed %; So,
		 * we must output that character as it is; This is the
		 * Documented behaviour; This is the Fix for Bug #15410.
		 * Please note that this could be due to a typo in the app as in the
		 * case of the sample app for Bug #13946 and in such cases,
		 * we might mis-interpret the parameters that follow and that
		 * could result in a GP Fault. But, this is clearly a bug in the app
		 * and we can't do anything about it. We will just RIP and let
		 * them know in such cases.
		 */
		if (*lpFmt == 0x0A || *lpFmt == 0x0D) {
                    out(0x0D);
                    out(0x0A);
                }
                else
	            out(*lpFmt);	/* Output the invalid char and continue */
		break;

		}			/* END OF SWITCH(*lpFmt) */
	    }		    /* END OF IF(%) */
	else
	  {
	    /* character not a '%', just do it */
	    if (*lpFmt == 0x0A || *lpFmt == 0x0D) {
                out(0x0D);
                out(0x0A);
            }
            else
	        out(*lpFmt);
	  }
		
	/* advance to next format string character */
	lpFmt++;
	}	    /* END OF OUTER WHILE LOOP */

errorout:
    *lpOut=0;

    return WSPRINTF_LIMIT-cchLimit;
}


int vxd_vprintf(char * Format, CONST VOID * lpParms)
{
    int length;

    if (DebugBufferLength+WSPRINTF_LIMIT < DEBUG_BUFFER_SIZE) {
        length =  vxd_vsprintf(DebugBuffer+DebugBufferLength, Format, lpParms);
        DebugBufferLength += length;
    }
    else
        length = 0;

    return length;

}

#ifdef CSC_RECORDMANAGER_WINNT
int
SP_PutNumber(
    LPSTR   lpb,
    long    n,
    int     limit,
    int     radix,
    int     strCase
    )
{
    unsigned long nT = (unsigned long)n, nRem=0;
    int i;

    for (i=0; i < limit; ++i)
    {

        nRem = nT%radix;

        nT = nT/radix;

        lpb[i] = (char)((nRem > 9)?((nRem-10) + ((strCase)?'A':'a')):(nRem+'0'));

        if (!nT)
        {
            ++i;    // bump up the count appropriately
            break;
        }
    }

    return (i);
}

void
SP_Reverse(
    LPSTR   lpFirst,
    LPSTR   lpLast
    )
{
    LPSTR   lpT = lpFirst;
    char ch;

    while (lpFirst < lpLast)
    {
        ch = *lpFirst;
        *lpFirst = *lpLast;
        *lpLast = ch;
        ++lpFirst; --lpLast;
    }
}
#endif //ifdef CSC_RECORDMANAGER_WINNT


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\utils.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

     Utils.c

Abstract:

     none.

Author:

     Shishir Pardikar      [Shishirp]        01-jan-1995

Revision History:

     Joe Linn                 [JoeLinn]         23-jan-97     Ported for use on NT

--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

#ifndef CSC_RECORDMANAGER_WINNT
#define WIN32_APIS
#include "cshadow.h"
#endif //ifndef CSC_RECORDMANAGER_WINNT

#include <stdlib.h>
#include <ctype.h>
#include <string.h>
// #include "error.h"
#include <vmmreg.h>  // Must be after error.h
#include "vxdwraps.h"

#define  SIGN_BIT 0x80000000
#define  UCHAR_OFFLINE  ((USHORT)'_')
#define  HIGH_ONE_SEC    0x98
#define  LOW_ONE_SEC     0x9680

#pragma intrinsic (memcmp, memcpy, memset, strcat, strcmp, strcpy, strlen)
#define cBackSlash    '\\'
#define cNull          0

#ifdef MAYBE
ULONG UlGetDefaultShadowStore(LPSTR lpDrive);
#endif //MAYBE

AssertData
AssertError
extern char pathbuff[MAX_PATH+1];
extern char vszShadowDir[MAX_SHADOW_DIR_NAME+1];
char vszEnableShadow[]="EnableShadow";
char vszEnableRemoteLog[]="EnableRemoteLog";
char vszEnableDisconnect[]="EnableDisconnect";
char vszMaxShadowStoreHex[]="MaxShadowStoreHex";
char vszMaxLogfileSize[]="MaxLogfileSize";
char vszExcludeList[] = "ExcludeExtensions";
char vszIncludeList[] = "IncludeExtensions";
char vszExclDelim[]=" ;,";
char vszRemoteAccess[]="System\\CurrentControlSet\\Services\\RemoteAccess";
char vszRemoteConnection[]="Remote Connection";
char vszEnableSpeadOpt[]="EnableSpeadOpt";
char vszDefShadowDir[] = "c:\\shadow";
char vszCSCDirName[] = "CSC\\";

USHORT *rgwzHeuristicExtensionTab[] =
{
	L".exe",
	L".dll"
};

#ifndef CSC_RECORDMANAGER_WINNT
#pragma VxD_LOCKED_CODE_SEG
#endif //ifndef CSC_RECORDMANAGER_WINNT

int PUBLIC GetServerPart(
    LPPE  lppeServer,
    USHORT *lpBuff,
    int cBuff
    )
 {
    return(PpeToSvr(lppeServer, (LPSTR)lpBuff, cBuff, UNICODE));
 }

ULONG PUBLIC GetNextPathElement(
    LPPP    lppp,
    ULONG   indx,
    USHORT  *lpBuff,
    ULONG   cBuff
    )
 {
    LPPE lppe;

#if VERBOSE > 3
    KdPrint(("GetNextPathElement: input index=%d \r\n", indx));
#endif //VERBOSE > 3
    lppe = (LPPE)&(((LPBYTE)(lppp->pp_elements))[indx]);
    if (lpBuff)
     {
        Assert(cBuff);
        memset(lpBuff, 0, cBuff);

        memcpy(lpBuff, lppe->pe_unichars, min(lppe->pe_length-2, (int)cBuff));
//        UniToBCS(lpBuff, lppe->pe_unichars, lppe->pe_length-2, cBuff-1, BCS_OEM);
     }
#if VERBOSE > 3
    KdPrint(("GetNextPathElement: output index=%d \r\n", indx));
#endif //VERBOSE > 3
    indx += lppe->pe_length;
    return ((indx < IFSPathLength(lppp))?indx:0xffff);
 }

VOID PUBLIC GetLeafPtr
    (
    PIOREQ   pir,
    USHORT  *lpBuff,
    ULONG   cBuff
    )
 {
    LPPE lpLast;
    Assert(cBuff);
    lpLast = IFSLastElement((LPPP)(pir->ir_ppath));
    memset(lpBuff, 0, cBuff);
    memcpy(lpBuff, lpLast->pe_unichars, min(lpLast->pe_length-2, (int)cBuff));
 }


VOID PUBLIC BreakPath(
    LPPP lppp,
    ULONG indx,
    USHORT *pusCookie
    )
 {
    USHORT u;
    LPPE lppe;

#if VERBOSE > 3
	UniToBCSPath(pathbuff, &lppp->pp_elements[0], MAX_PATH, BCS_OEM);
    KdPrint(("BreakPath In %s \r\n", pathbuff));
#endif //VERBOSE > 3
    *pusCookie = lppp->pp_totalLength;
    *(pusCookie+1) = lppp->pp_prefixLength;
    *(pusCookie+2) = 0;
    if (IFSPathLength(lppp) > indx)
     {
        if (!indx)
         {
            lppp->pp_totalLength = lppp->pp_prefixLength = 4;
         }
        else
         {
            for (lppe = lppp->pp_elements, u=0;;)
             {
                u += lppe->pe_length;
                // This condition must happen
                if (u >= indx)
                 {
                    lppp->pp_totalLength = u+4;
                    lppp->pp_prefixLength = u - lppe->pe_length+4;
                    break;
                 }
                lppe = IFSNextElement(lppe);
             }
         }
        *(pusCookie+2) = *(USHORT *)&(((LPBYTE)(lppp->pp_elements))[indx]);
        *(USHORT *)&(((LPBYTE)(lppp->pp_elements))[indx]) = 0;
     }
#if VERBOSE > 3
    KdPrint(("BreakPath saved=%x \r\n", uSav));
	UniToBCSPath(pathbuff, &lppp->pp_elements[0], MAX_PATH, BCS_OEM);
    KdPrint(("BreakPath out %s \r\n", pathbuff));
#endif //VERBOSE > 3
 }

VOID PUBLIC MendPath(
    LPPP  lppp,
    ULONG indx,
    USHORT *pusCookie
    )
 {
    lppp->pp_totalLength = *pusCookie ;
    lppp->pp_prefixLength = *(pusCookie+1);
    if (indx < IFSPathLength(lppp))
     {
        *(USHORT *)&(((LPBYTE)(lppp->pp_elements))[indx])
            = *(pusCookie+2);
     }
#if VERBOSE > 3
	UniToBCSPath(pathbuff, &lppp->pp_elements[0], MAX_PATH, BCS_OEM);
    KdPrint(("MendPath %s \r\n", pathbuff));
#endif //VERBOSE > 3
 }


int PUBLIC GetPathLevel(
    LPPP ppath
    )
 {
	PathElement	*ppe;
    int level = 1;

	ppe = ppath->pp_elements;

	while(ppe->pe_length)
     {
        ++level;
        ppe = IFSNextElement(ppe);
    	}
    return (level);
 }

int PUBLIC HexToA(
    ULONG ulHex,
    LPSTR lpName,
    int count)
 {
    int i;
    LPSTR lp = lpName+count-1;
    UCHAR uch;

    for (i=0; i<count; ++i)
     {
        uch = (UCHAR)(ulHex & 0xf) + '0';
        if (uch > '9')
            uch += 7;    // A becomes '0' + A + 7 which is 'A'
        *lp = uch;
        --lp;
        ulHex >>= 4;
     }
    *(lpName+count) = cNull;
    return 0;
 }


ULONG PUBLIC AtoHex(
    LPSTR lpStr,
    int count
    )
 {
    int i;
    LPSTR lp = lpStr;
    UCHAR uch;
    ULONG ulHex = 0L;

    for (i=0; i<count; ++i)
     {
        uch = *lp;
        if (uch>= '0' && uch <= '9')
            ulHex += (uch - '0');
        else if (uch >= 'A' && uch <= 'F')
            ulHex += (uch - '0' - 7);
        else
            break;
        ++lp;
        ulHex <<= 4;
     }
    return ulHex;
 }


int PpeToSvr( LPPE lppe,
    LPSTR lpBuff,
    int cBuff,
    ULONG type
    )
 {
    LPSTR lpTmp = lpBuff;
    memset(lpTmp, 0, cBuff);
    if (type != UNICODE)
     {
        if (cBuff <= (lppe->pe_length+IFSNextElement(lppe)->pe_length)/2)
            return 0;
        *lpTmp = '\\';
        UniToBCS(lpTmp+1, lppe->pe_unichars, lppe->pe_length-2, cBuff, BCS_OEM);
        lpTmp += (lppe->pe_length)/2;
        lppe = IFSNextElement(lppe);
        *lpTmp = '\\';
        UniToBCS(lpTmp+1, lppe->pe_unichars, lppe->pe_length-2, cBuff, BCS_OEM);
     }
    else
     {
        USHORT *lpUni;

        lpUni = (USHORT *)lpTmp;
        if (cBuff < (lppe->pe_length+IFSNextElement(lppe)->pe_length))
            return 0;
        *lpUni = '\\';
        memcpy(lpUni+1, lppe->pe_unichars, lppe->pe_length);
        lpUni = (USHORT *)((LPSTR)lpUni+lppe->pe_length);
        lppe = IFSNextElement(lppe);
        *lpUni = '\\';
        memcpy(lpUni+1, lppe->pe_unichars, lppe->pe_length);
     }
    return (1);
 }

int IPathCompare( LPPP lpppDst,
    LPPP lpppSrc
    )
 {
    LPPE lppeDst, lppeSrc;
    if (lpppDst->pp_totalLength != lpppSrc->pp_totalLength)
        return -1;
    if (lpppDst->pp_prefixLength != lpppSrc->pp_prefixLength)
        return -1;

    lppeDst = lpppDst->pp_elements;
    lppeSrc = lpppSrc->pp_elements;
    for (;;)
     {
        if (!lppeDst->pe_length || !lppeSrc->pe_length)
            break;
        if (lppeDst->pe_length != lppeSrc->pe_length)
            return -1;
        if (wstrnicmp(lppeDst->pe_unichars, lppeSrc->pe_unichars, lppeSrc->pe_length))
            return -1;
        lppeDst = IFSNextElement(lppeDst);
        lppeSrc = IFSNextElement(lppeSrc);
     }
    return 0;
 }


int wstrnicmp( const USHORT *pStr1,
    const USHORT *pStr2,
    ULONG count
    )
 {
    USHORT c1, c2;
    int iRet;
    ULONG i=0;

    for(;;)
     {
        c1 = *pStr1++;
        c2 = *pStr2++;
        c1 = _wtoupper(c1);
        c2 = _wtoupper(c2);
        if (c1!=c2)
            break;
        if (!c1)
            break;
        i+=2;
        if (i >= count)
            break;
     }
    iRet = ((c1 > c2)?1:((c1==c2)?0:-1));
    return iRet;
 }

#ifndef CSC_RECORDMANAGER_WINNT
int mystrnicmp(
    const char *pStr1,
    const char *pStr2,
    unsigned count
    )
#else
_CRTIMP int __cdecl mystrnicmp(
    const char *pStr1,
    const char *pStr2,
    size_t count
    )
#endif //ifndef CSC_RECORDMANAGER_WINNT
 {
    char c1, c2;
    int iRet;
    ULONG i=0;

    for(;;)
     {
        c1 = *pStr1++;
        c2 = *pStr2++;
        c1 = _mytoupper(c1);
        c2 = _mytoupper(c2);
        if (c1!=c2)
            break;
        if (!c1)
            break;
        if (++i >= count)
            break;
     }
    iRet = ((c1 > c2)?1:((c1==c2)?0:-1));
    return iRet;
 }

ULONG strmcpy( LPSTR lpDst,
	LPSTR lpSrc,
    ULONG cTchar
    )
 {
    ULONG i;

    if (!cTchar)
        return 0;
    for(i=cTchar;i;--i)
        if (!(*lpDst++ = *lpSrc++))
						    break;
    lpDst[cTchar-i] ='\0';

    return(cTchar-i);
 }

ULONG wstrlen(
    USHORT *lpuStr
    )
 {
    ULONG i;

    for (i=0; *lpuStr; ++lpuStr, ++i);
    return (i);
 }

int DosToWin32FileSize( ULONG uDosFileSize,
    int *lpnFileSizeHigh,
    int *lpnFileSizeLow
    )
 {
    int iRet;

    if (uDosFileSize & SIGN_BIT)
     {
        *lpnFileSizeHigh = 1;
        *lpnFileSizeLow = uDosFileSize & SIGN_BIT;
        iRet = 1;
     }
    else
     {
        *lpnFileSizeHigh = 0;
        *lpnFileSizeLow = uDosFileSize;
        iRet = 0;
     }
    return (iRet);
 }

int Win32ToDosFileSize( int nFileSizeHigh,
    int nFileSizeLow,
    ULONG *lpuDosFileSize
    )
 {
    int iRet;
    *lpuDosFileSize = nFileSizeLow;
    if (nFileSizeHigh == 1)
     {
        *lpuDosFileSize += SIGN_BIT;
        iRet = 1;
     }
    else
        iRet = 0;
    return (iRet);
 }

int CompareTimes( _FILETIME ftDst,
    _FILETIME ftSrc
    )
 {
    int iRet = 0;

    if (ftDst.dwHighDateTime
                    > ftSrc.dwHighDateTime)
        iRet = 1;
    else if (ftDst.dwHighDateTime == ftSrc.dwHighDateTime)
     {
        if (ftDst.dwLowDateTime > ftSrc.dwLowDateTime)
            iRet = 1;
        else if (ftDst.dwLowDateTime == ftSrc.dwLowDateTime)
            iRet = 0;
        else
            iRet = -1;
     }
    else
        iRet = -1;
    return (iRet);
 }

int CompareTimesAtDosTimePrecision( _FILETIME ftDst,
    _FILETIME ftSrc
    )
 {
    dos_time dostDst, dostSrc;
    int diff;

    dostDst = IFSMgr_Win32ToDosTime(ftDst);
    dostSrc = IFSMgr_Win32ToDosTime(ftSrc);

    diff = (int)(*(ULONG *)&dostDst - *(ULONG *)&dostSrc);

    if (diff > 1)
        return 1;
    else if (diff < -1)
        return -1;
    else
        return 0;
 }

int CompareSize(
    long nHighDst,
    long nLowDst,
    long nHighSrc,
    long nLowSrc
    )
 {
    int iRet = 0;

    if (nHighDst > nHighSrc)
        iRet = 1;
    else if (nHighDst == nHighSrc)
     {
        if (nLowDst > nLowSrc)
            iRet = 1;
        else if (nLowDst == nLowSrc)
            iRet = 0;
        else
            iRet = -1;
     }
    else
        iRet = -1;
    return (iRet);
 }

void InitFind32FromIoreq
    (
    PIOREQ    pir,
    LPFIND32 lpFind32,
    ULONG uFlags
    )
 {
    if (uFlags & IF32_LOCAL)
     {
		memset(lpFind32, 0, sizeof(WIN32_FIND_DATA));
		InitFind32Names(lpFind32,
					  ((pir->ir_attr & FILE_FLAG_KEEP_CASE)&&(uFlags&IF32_LAST_ELEMENT))?
						pir->ir_uFName:
						IFSLastElement(pir->ir_ppath)->pe_unichars,
						(pir->ir_attr & FILE_FLAG_IS_LFN)? NULL:IFSLastElement((LPPP)(pir->ir_ppath))->pe_unichars);
     }

    if (!(uFlags & IF32_DIRECTORY))
     {
        lpFind32->dwFileAttributes =
                ((((pir->ir_attr) & ~FILE_ATTRIBUTE_DIRECTORY) | FILE_ATTRIBUTE_ARCHIVE)
			& FILE_ATTRIBUTE_EVERYTHING);
     }
    else
     {
        lpFind32->dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
     }

    if (uFlags & IF32_LOCAL)
     {
//CODE.IMPROVEMENT very ugly.....define a platform specific macro....
#ifndef CSC_RECORDMANAGER_WINNT
        lpFind32->ftCreationTime = IFSMgr_NetToWin32Time(IFSMgr_Get_NetTime());
#else
        //lpFind32->ftCreationTime = IFSMgr_NetToWin32Time(IFSMgr_Get_NetTime());
        KeQuerySystemTime(((PLARGE_INTEGER)(&lpFind32->ftCreationTime)));
#endif //ifndef CSC_RECORDMANAGER_WINNT
        lpFind32->ftLastAccessTime = lpFind32->ftLastWriteTime = lpFind32->ftCreationTime;
     }

    lpFind32->nFileSizeHigh = lpFind32->nFileSizeLow = 0;
 }

void InitIoreqFromFind32
    (
    LPFIND32 lpFind32,
    PIOREQ    pir
    )
 {
    pir->ir_attr = lpFind32->dwFileAttributes;
    pir->ir_size = lpFind32->nFileSizeLow;
 }

void InitFind32Names( LPFIND32 lpFind32,
    USHORT *lpcFileName,
    USHORT *lpcAlternateFileName
    )
 {
    int len;

    memset(lpFind32->cFileName, 0, sizeof(lpFind32->cFileName));
    memset(lpFind32->cAlternateFileName, 0, sizeof(lpFind32->cAlternateFileName));

    len = wstrlen(lpcFileName)*2;
    len = min(len, (sizeof(lpFind32->cFileName)-2));
    memcpy(lpFind32->cFileName, lpcFileName, len);

    if (lpcAlternateFileName)
     {
        len = wstrlen(lpcAlternateFileName)*2;
        len = min(len, (sizeof(lpFind32->cAlternateFileName)-2));
		memset(lpFind32->cAlternateFileName, 0, sizeof(lpFind32->cAlternateFileName));
		UniToUpper(lpFind32->cAlternateFileName, lpcAlternateFileName, len);
     }
 }

void Find32ToSearchEntry(LPFIND32 lpFind32, srch_entry *pse)
 {
    dos_time sDosTime;
    pse->se_attrib = (UCHAR)(lpFind32->dwFileAttributes);
    sDosTime = IFSMgr_Win32ToDosTime(lpFind32->ftLastWriteTime);
    pse->se_time = sDosTime.dt_time;
    pse->se_date = sDosTime.dt_date;
    Win32ToDosFileSize(lpFind32->nFileSizeHigh
                                , lpFind32->nFileSizeLow
                                , &(pse->se_size));
    memset(pse->se_name, 0, sizeof(pse->se_name));
    UniToBCS(pse->se_name
                , lpFind32->cAlternateFileName
                , wstrlen(lpFind32->cAlternateFileName) * 2
                , sizeof(pse->se_name)-1, BCS_OEM);
 }

void PUBLIC Find32AFromFind32(
    LPFIND32A    lpFind32ADst,
    LPFIND32     lpFind32WSrc,
    int            type
    )
 {
    // Copy everything except the names, we know the size of that is the
    // same for both structures
    memcpy(lpFind32ADst, lpFind32WSrc, sizeof(_WIN32_FIND_DATAA)
                                            -sizeof(lpFind32ADst->cFileName)
                                            -sizeof(lpFind32ADst->cAlternateFileName));

    // Cleanup the destineation names so we don't get into NULL termination problems
    memset(lpFind32ADst->cFileName, 0, sizeof(lpFind32ADst->cFileName));
    memset(lpFind32ADst->cAlternateFileName, 0, sizeof(lpFind32ADst->cAlternateFileName));


    UniToBCS(lpFind32ADst->cFileName     // Destination ANSI string
                , lpFind32WSrc->cFileName  // Source unicode string
                , sizeof(lpFind32WSrc->cFileName)    // bytes in the source
                    - sizeof(lpFind32WSrc->cFileName[0])
                , sizeof(lpFind32ADst->cFileName)    // max size of dst string wo NULL
                    -sizeof(lpFind32ADst->cFileName[0])
                , type    // ANSI or OEM
                );

    UniToBCS(lpFind32ADst->cAlternateFileName
                , lpFind32WSrc->cAlternateFileName
                , sizeof(lpFind32WSrc->cAlternateFileName)
                    - sizeof(lpFind32WSrc->cAlternateFileName[0])
                , sizeof(lpFind32ADst->cAlternateFileName)
                    -sizeof(lpFind32ADst->cAlternateFileName[0])
                , BCS_OEM);
 }

void PUBLIC Find32FromFind32A(
    LPFIND32     lpFind32WDst,
    LPFIND32A    lpFind32ASrc,
    int            type
    )
 {
    memcpy(lpFind32WDst, lpFind32ASrc, sizeof(_WIN32_FIND_DATAA)
                                            -sizeof(lpFind32ASrc->cFileName)
                                            -sizeof(lpFind32ASrc->cAlternateFileName));

    memset(lpFind32WDst->cFileName, 0, sizeof(lpFind32WDst->cFileName));
    memset(lpFind32WDst->cAlternateFileName, 0, sizeof(lpFind32WDst->cAlternateFileName));
    BCSToUni(lpFind32WDst->cFileName
                , lpFind32ASrc->cFileName
                , sizeof(lpFind32ASrc->cFileName)
                    - sizeof(lpFind32ASrc->cFileName[0])
                        , type);

    BCSToUni(lpFind32WDst->cAlternateFileName
                , lpFind32ASrc->cAlternateFileName
                , sizeof(lpFind32ASrc->cAlternateFileName)
                    - sizeof(lpFind32ASrc->cAlternateFileName[0])
                , BCS_OEM);
 }

//**	AddPathElement
//
//	This routine adds a path element to an existing parsed path structure
//	
//	flag =  0 - no mapping
//			1 - map from OEM to unicode
//

void  AddPathElement( path_t		ppath,
    string_t	pstr,	
    int			flag) 	
 {
	PathElement *ppe;
	int 		len, unilen;
	
	ppe = IFSLastElement(ppath);
	ppath->pp_prefixLength+=ppe->pe_length;	//update the prefix marker
	ppe = IFSNextElement(ppe);

	//add the new element
	if (flag)
     {
		//map to unicode
		len = strlen((char *)pstr);
		unilen = BCSToUni(ppe->pe_unichars, (char *) pstr, len, BCS_OEM);
	 }
    else
    {
		//already in unicode
		unilen = wstrlen(pstr)*sizeof(USHORT);
		memcpy(ppe->pe_unichars, pstr, unilen);
    }
	ppe->pe_length = (USHORT)(unilen+sizeof(USHORT)); //include the length word		
	//update the header
	ppath->pp_totalLength+=ppe->pe_length;  //update total length

	//mark the end
	ppe = IFSNextElement(ppe);
	ppe->pe_length = 0;	
 }

//**  	MakePath
//		
//		Builds a parsed path from a ASCII string in the format "\\FOO\BAR.."
//
//		ppath - points to a path buffer at least PATH_BUFF_SIZE
//		ppath - OEM path string
//

void MakePPath( path_t	ppath,
    LPBYTE 	ps
    )
{
    LPBYTE pc = ps;

    MakeNullPPath(ppath);	//initialize the path

    while(*pc == '\\') //skip past leading '\'
    {
       	pc++;
    }

    if (ps[0] =='\\')	//ps points to first name
    {
   	    ps++;
    }

    for (;;)
    {
   	    if (*pc == '\\')
        {
   		    *pc = 0;
   		    AddPathElement(ppath, (string_t)ps, 1);
   		    *pc = '\\';
   		    ps = ++pc;
   	    }
        else if (*pc == 0)
        {
   		    AddPathElement(ppath, (string_t)ps, 1);
   		    break;
   		}
   	    pc++;
    }
}


//**  	MakePathW
//		
//		Builds a parsed path from a unicode string in the format "\\FOO\BAR.."
//
//		ppath - points to a path buffer at least PATH_BUFF_SIZE
//		ppath - OEM path string
//

void MakePPathW( path_t	ppath,
    USHORT  *puName
    )
{
    USHORT *pu = puName;

    MakeNullPPath(ppath);   //initialize the path

    while(*pu == L'\\') //skip past leading '\'
    {
   	    pu++;
    }

    if (pu[0] == L'\\') //ps points to first name
    {
   	    pu++;
    }

    for (;;)
    {
   	    if (*pu == L'\\')
        {
   		    *pu = 0;

   		    AddPathElement(ppath, (string_t)puName, 0);

   		    *pu = L'\\';

   		    puName = ++pu;
   	    }
        else if (*pu == 0)
        {
   		    AddPathElement(ppath, (string_t)puName, 0);

   		    break;
   		}

   	    pu++;
    }
}

//** DeleteLastElement
//
// removes the last element from a parsed path
//
void DeleteLastElement( path_t ppath
    )
 {
	PathElement	*ppe, *ppelast;
	
	ppe = IFSLastElement(ppath);
	ppath->pp_totalLength -= ppe->pe_length;
	ppe->pe_length = 0;

	//set the new prefix length
	ppe = ppath->pp_elements;
	ppath->pp_prefixLength = 4;

	while(ppe->pe_length)
     {
		ppelast = ppe;
		ppe = IFSNextElement(ppe);
		if (ppe)
			ppath->pp_prefixLength += ppelast->pe_length;
    	}
 }


int ResNameCmp(
    LPPE  lppeSrc,
    LPPE  lppeDst
    )
 {
    int i;

    for (i=0; i<2; ++i)
     {
        if (lppeSrc->pe_length != lppeDst->pe_length)
            break;
        if (wstrnicmp(lppeSrc->pe_unichars
            , lppeDst->pe_unichars
            , lppeSrc->pe_length-sizeof(lppeDst->pe_length)))
            break;
        lppeSrc = IFSNextElement(lppeSrc);
        lppeDst = IFSNextElement(lppeDst);
     }
    return (!(i==2));//return 0 if equal
 }

int  Conv83ToFcb(
    LPSTR lp83Name,
    LPSTR lpFcbName
    )
 {
    int i, j;
    char ch;
    memset(lpFcbName, ' ', 11);
    for(i=0; ((ch=lp83Name[i]) && (i<8)); ++i)
     {
        if (ch=='.')
            break;
        lpFcbName[i] = ch;
     }
    if (lp83Name[i]=='.')
     {
        // Step over the dot
        ++i;
        // point to the extension area in the FCB format
        j = 8;
        for(;((ch=lp83Name[i]) && (j<11)); ++i, ++j)
         {
            lpFcbName[j] = ch;
         }
        return (i);
     }
    else
     {
        return (i);
     }
 }

int  Conv83UniToFcbUni(
    USHORT *lp83Name,
    USHORT *lpFcbName
    )
 {
    int i, j;
    USHORT uch;

    for (i=0; i<11; ++i)
     {
        lpFcbName[i] = (USHORT)' ';
     }

    for(i=0; ((uch=lp83Name[i]) && (i<8)); ++i)
     {
        if (uch==(USHORT)'.')
            break;
        lpFcbName[i] = uch;
     }
    if (lp83Name[i]=='.')
     {
        // Step over the dot
        ++i;
        // point to the extension area in the FCB format
        j = 8;
        for(;((uch=lp83Name[i]) && (j<11)); ++i, ++j)
         {
            lpFcbName[j] = uch;
         }
        return (i);
     }
    else
     {
        return (i);
     }
 }

void FillRootInfo(
    LPFIND32 lpFind32
    )
 {
    memset(lpFind32, 0, sizeof(WIN32_FIND_DATA));
    lpFind32->dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
    lpFind32->cFileName[0] = lpFind32->cAlternateFileName[0] = '\\';
 }

int ReadInitValues()
 {
    VMMHKEY hKeyShadow;
	LPSTR	lpWindir = NULL;
    int iSize = sizeof(int), lenWindir=0;
    DWORD dwType;
    extern int fLog, fShadow, fDiscon, fSpeadOpt, vlenShadowDir;
    extern ULONG ulMaxStoreSize, ulMaxLogfileSize;
	extern LPSTR vlpszShadowDir;
	
    if (_RegOpenKey(HKEY_LOCAL_MACHINE, REG_KEY_SHADOW, &hKeyShadow) ==  ERROR_SUCCESS)
    {
#ifdef CSC_RECORDMANAGER_WINNT
        memset(vszShadowDir, 0, sizeof(vszShadowDir));
        iSize = MAX_SHADOW_DIR_NAME+1;
        if(_RegQueryValueEx(hKeyShadow, REG_STRING_DATABASE_LOCATION, NULL, &dwType, vszShadowDir, &iSize)!=ERROR_SUCCESS)
         {
            Assert(strlen(vszDefShadowDir) <= MAX_SHADOW_DIR_NAME);
            KdPrint(("ReadInitValues: No vszShadowDb value in registry\r\n"));
            memcpy(vszShadowDir, vszDefShadowDir, strlen(vszDefShadowDir));
         }
#else

#ifdef OLDCODE

		lpWindir = (LPSTR)GetConfigDir();

		if (!lpWindir)
		{
			// VMM promises this to be valid!!!
			Assert(FALSE);
			return (0);
		}

		lenWindir = strlen(lpWindir);
		vlpszShadowDir = AllocMem(lenWindir+strlen(vszCSCDirName)+3);

		if (!vlpszShadowDir)
		{
			KdPrint(("ReadInitValues: Failed memroy allocation while\r\n"));
			return (0);
		}

		memcpy(vlpszShadowDir, lpWindir, lenWindir);

		if ((*(lpWindir+lenWindir-1))!='\\')
		{
			*(vlpszShadowDir+lenWindir)='\\';
		}

		// NB vszCSCDirName has a trailing backslash
		strcat(vlpszShadowDir, vszCSCDirName);
		vlenShadowDir = strlen(vlpszShadowDir);

        KdPrint(("ReadInitValues: ShadowDbDir is %s\r\n", vlpszShadowDir));
#endif // OLDCODE

#endif // CSC_RECORDMANAGER_WINNT

#ifdef MAYBE
		// we should let the agent decide whether shadowing should be on or off
        _RegQueryValueEx(hKeyShadow, vszEnableShadow, NULL, &dwType, &fShadow, &iSize);
#endif // MAYBE

        iSize = sizeof(int);
        _RegQueryValueEx(hKeyShadow, vszEnableRemoteLog, NULL, &dwType, &fLog, &iSize);
        iSize = sizeof(int);
        _RegQueryValueEx(hKeyShadow, vszEnableDisconnect, NULL, &dwType, &fDiscon, &iSize);
        iSize = sizeof(int);
        _RegQueryValueEx(hKeyShadow, vszEnableSpeadOpt, NULL, &dwType, &fSpeadOpt, &iSize);
        iSize = sizeof(ULONG);
        _RegQueryValueEx(hKeyShadow, vszMaxShadowStoreHex, NULL, &dwType, &ulMaxStoreSize, &iSize);
        iSize = sizeof(ULONG);
        if(_RegQueryValueEx(hKeyShadow, vszMaxLogfileSize, NULL, &dwType, &ulMaxLogfileSize, &iSize)!=ERROR_SUCCESS)
         {
            ulMaxLogfileSize = MAX_LOGFILE_SIZE;
         }
        else if (ulMaxLogfileSize < MIN_LOGFILE_SIZE)
         {
            ulMaxLogfileSize = MIN_LOGFILE_SIZE;
         }
        _RegCloseKey(hKeyShadow);
        ulMaxStoreSize = 0xffffffff;
#ifdef MAYBE
        ulMaxStoreSize = UlGetDefaultShadowStore(vszShadowDir);
#endif //MAYBE
        return(1);
     }
    return (0);
 }

BOOL IsSlowLink()
 {
    VMMHKEY hKeyRemote;
    int iSize = sizeof(int), fRemote=0;
    DWORD dwType;
    if (_RegOpenKey(HKEY_LOCAL_MACHINE, vszRemoteAccess, &hKeyRemote) ==  ERROR_SUCCESS)
     {
        _RegQueryValueEx(hKeyRemote, vszRemoteConnection, NULL, &dwType, &fRemote, &iSize);
        _RegCloseKey(hKeyRemote);
     }
    return (fRemote);
 }

BOOL FHasWildcard(
    USHORT *lpuName,
    int cMax
    )
 {
    int i;
    BOOL fRet = FALSE;
    USHORT uT;

    for (i=0; i<cMax; ++i)
     {
        uT = *(lpuName+i);
        if (!uT)
            break;
        if (fRet = ((uT==(USHORT)'*')||(uT == (USHORT)'?')))
            break;
     }
    return (fRet);
 }

int IncrementTime(
    LPFILETIME  lpFt,
    int    secs
    )
 {
    lpFt->dwHighDateTime += secs*(HIGH_ONE_SEC+1);
    return(0);  //stop complaining about no return value
 }

int FParentMatch(
    LPPP  lpp1,
    LPPP  lpp2
    )
 {
	PathElement	*ppe1, *ppe2, *ppe1Last, *ppe2Last;
    int fMatch = FALSE;

    //If either of them is root then say they have invalid parents
    if (IFSIsRoot(lpp1) || IFSIsRoot(lpp2))
        return 0;

    ppe1Last = IFSLastElement(lpp1);
    ppe2Last = IFSLastElement(lpp2);

    ppe1 = lpp1->pp_elements;
    ppe2 = lpp2->pp_elements;

	while((ppe1!=ppe1Last) && (ppe2!= ppe2Last))
     {
        if (ppe1->pe_length!=ppe1->pe_length)
            return 0;
        if (wstrnicmp(ppe1->pe_unichars, ppe2->pe_unichars, ppe1->pe_length-2))
            return 0;
        ppe1 = IFSNextElement(ppe1);
        ppe2 = IFSNextElement(ppe2);
    	}

    return ((ppe1==ppe1Last) && (ppe2==ppe2Last));
 }


LPSTR mystrpbrk(
    LPSTR lpSrc,
    LPSTR lpDelim
    )
 {
    char c, c1;
    LPSTR lpSav;
    BOOL fBegin = FALSE;

  for(;c = *lpSrc; ++lpSrc)
     {
        // skip leading blanks
        if (!fBegin)
         {
            if (c==' ')
                continue;
            else
                fBegin = TRUE;
         }

        lpSav = lpDelim;
        while (c1 = *lpDelim++)
         {
            if (c==c1)
                return (lpSrc);
         }
        lpDelim = lpSav;
     }
    return (NULL);
 }

LPWSTR
wstrpbrk(
    LPWSTR lpSrc,
    LPWSTR lpDelim
    )
{
    USHORT c, c1;
    LPWSTR lpSav;
    BOOL fBegin = FALSE;

    for(;c = *lpSrc; ++lpSrc)
    {
        // skip leading blanks
        if (!fBegin)
        {
            if (c==L' ')
            {
                continue;
            }
            else
            {
                fBegin = TRUE;
            }
        }

        lpSav = lpDelim;

        while (c1 = *lpDelim++)
        {
            if (c==c1)
            {
                return (lpSrc);
            }
        }

        lpDelim = lpSav;
    }
    return (NULL);
}

int OfflineToOnlinePath
    (
    path_t ppath
    )
 {
    if (!IFSIsRoot(ppath) && IsOfflinePE(ppath->pp_elements))
     {
        OfflineToOnlinePE(ppath->pp_elements);
        ppath->pp_totalLength -= sizeof(USHORT);
        ppath->pp_prefixLength-= sizeof(USHORT);
     }
    return(0);  //stop complaining about no return value
 }

int OnlineToOfflinePath
    (
    path_t ppath
    )
 {
    // Must have space for one extra character

    OnlineToOfflinePE(ppath->pp_elements);
    ppath->pp_totalLength  += sizeof(USHORT);
    ppath->pp_prefixLength += sizeof(USHORT);
    return(0);  //stop complaining about no return value
 }

BOOL IsOfflinePE
    (
    LPPE lppe
    )
 {
    return(lppe->pe_unichars[1] == UCHAR_OFFLINE);
 }

int OfflineToOnlinePE
    (
    LPPE lppe
    )
 {
    ULONG size;

    size = wstrlen(lppe->pe_unichars)*2+2;
    mymemmove(&(lppe->pe_unichars[1])
                ,&(lppe->pe_unichars[2])
                ,size-2*sizeof(USHORT));
    lppe->pe_length-= sizeof(USHORT);
    return(0);  //stop complaining about no return value
 }

int OnlineToOfflinePE
    (
    LPPE lppe
    )
 {
    ULONG size;

    size = wstrlen(lppe->pe_unichars)*2+2;
    // Must have space for one extra character
    mymemmove(&(lppe->pe_unichars[2])
                ,&(lppe->pe_unichars[1])
                ,size-sizeof(USHORT));

    lppe->pe_unichars[1] = UCHAR_OFFLINE;
    lppe->pe_length += sizeof(USHORT);
    return(0);  //stop complaining about no return value
 }

BOOL IsOfflineUni(
    USHORT *lpuName
    )
 {
    return(lpuName[2] == UCHAR_OFFLINE);
 }

int OfflineToOnlineUni(
    USHORT *lpuName,
    ULONG size)
 {
    if (!size)
     {
        size = wstrlen(lpuName)*2+2;
     }
    mymemmove(&(lpuName[2])
                ,&(lpuName[3])
                ,size-3*sizeof(short));
    return(0);  //stop complaining about no return value
 }

int OnlineToOfflineUni(
    USHORT *lpuName,
    ULONG size)
 {
    if (!size)
     {
        size = wstrlen(lpuName)*2+2;
     }

    // Must have space for one extra character
    mymemmove(&(lpuName[3])
                ,&(lpuName[2])
                ,size-2*sizeof(USHORT));

    lpuName[2] = UCHAR_OFFLINE;
    return(0);  //stop complaining about no return value
 }

LPVOID mymemmove(
    LPVOID    lpDst,
    LPVOID    lpSrc,
    ULONG size
    )
 {
    int i;

    if (!size)
        return (lpDst);

    // if lpDst does not fall within the source array, just do memcpy
    if (!(
             ( lpDst > lpSrc )
                && ( ((LPBYTE)lpDst) < ((LPBYTE)lpSrc)+size )    ))
     {
        memcpy(lpDst, lpSrc, size);
     }
    else
     {
        // do reverse copy
        for (i=size-1;i>=0;--i)
         {
            *((LPBYTE)lpDst+i) = *((LPBYTE)lpSrc+i);
         }
     }
    return (lpDst);
 }


#ifdef MAYBE
ULONG UlGetDefaultShadowStore(LPSTR lpDrive)
 {
    int indx;
    ULONG ulSize=0;
    ULONG uSectorsPerCluster, uBytesPerSector, uFreeClusters, uTotalClusters;
    if (indx = GetDriveIndex(lpDrive))
     {
        if (GetDiskFreeSpace(indx  , &uSectorsPerCluster
                                            , &uBytesPerSector
                                            , &uFreeClusters
                                            , &uTotalClusters) >= 0)
         {
            ulSize =  (uTotalClusters * uSectorsPerCluster * uBytesPerSector * 10)/100;
         }
     }
    return ulSize;
 }
#endif //MAYBE

#ifndef CSC_RECORDMANAGER_WINNT
int GetDriveIndex(LPSTR lpDrive)
 {
    int c;
    if (*(lpDrive+1)==':')
     {
        c = *lpDrive;
        c = _mytoupper(c);
        return (c - 'A'+1);
     }
    return (0);
}
#endif

BOOL
HasHeuristicTypeExtensions(
	USHORT	*lpwzFileName
	)
{
	ULONG lenName = wstrlen(lpwzFileName);
	int i;

	if (lenName > 4)
	{
		for (i=0; i<(sizeof(rgwzHeuristicExtensionTab)/sizeof(USHORT *)); ++i)
		{
			if (!wstrnicmp(&lpwzFileName[lenName-4], rgwzHeuristicExtensionTab[i], 4*sizeof(USHORT)))
			{
				return (TRUE);
			}
		}
	}
	return (FALSE);
}

VOID
IncrementFileTime(
    _FILETIME *lpft
    )
{
    DWORD dwTemp = lpft->dwLowDateTime;

    ++lpft->dwLowDateTime;

    // if it rolled over, there was a carry
    if (lpft->dwLowDateTime < dwTemp)
        lpft->dwHighDateTime++;

}

BOOL
CreateStringArrayFromDelimitedList(
    IN  LPWSTR  lpwzDelimitedList,
    IN  LPWSTR  lpwzDelimiters,
    IN  LPWSTR  *lprgwzStringArray,
    OUT LPDWORD lpdwCount
    )
{

    LPWSTR   lpStart, lpEnd, lpTmp;
    USHORT  c;
    BOOL    fRet = FALSE;

    *lpdwCount = 0;

    lpStart = lpwzDelimitedList;
    lpEnd = lpStart + wstrlen(lpwzDelimitedList);    // points to null

    // strip out the trailing spaces
    for(;(lpStart<lpEnd);--lpEnd) {
        c = *(lpEnd-1);

        if (c != L' ') {
            *lpEnd = 0;
            break;
        }
    }

    // bailout if this is an empty string
    if (lpStart == lpEnd) {
        fRet = TRUE;
        goto done;
    }


    for (lpTmp = lpStart;(lpTmp && (lpEnd > lpStart)); lpStart = lpTmp+1) {

        lpTmp = lpStart;

        c = *lpStart;

        if (c == L' ') {
             continue;
        }

        Assert(*lpStart != L' ');

        lpTmp = wstrpbrk(lpStart, lpwzDelimiters);

        if (lprgwzStringArray) {

            if (lpTmp) {
                *lpTmp = 0; // create a string out of it
            }

            // plug the start pointer into the array
            lprgwzStringArray[*lpdwCount] = lpStart;
        }

        ++*lpdwCount;

    }
    fRet = TRUE;
done:
    return (fRet);
}

BOOL IsValidName(LPSTR lpName)
{
    int len = strlen(lpName), ch, i=0;

    if (len != INODE_STRING_LENGTH)
    {
        return FALSE;
    }

    while (len--)
    {
        ++i;

        ch = *lpName++;
        if (!(((ch>='0') && (ch <='9'))||
            ((ch>='A') && (ch <='F'))||
            ((ch>='a') && (ch <='f'))))
        {
            return FALSE;
        }
    }

    if (i != INODE_STRING_LENGTH)
    {
        return FALSE;
    }

    return (TRUE);
}


BOOL
DeleteDirectoryFiles(
    LPCSTR  lpszDir
)
{
    _WIN32_FIND_DATAA sFind32;
    char buff[MAX_PATH+32];
    CSCHFILE hFind;
    int lenDir;
    BOOL fOK = TRUE;


    strcpy(buff, lpszDir);
    lenDir = strlen(buff);

    if (!lenDir)
    {
        return (FALSE);
    }

    if ((hFind = FindFirstFileLocal(buff, &sFind32)))
    {
        if (buff[lenDir-1] != '\\')
        {
            buff[lenDir++] ='\\';
            buff[lenDir]=0;
        }
        do
        {
            buff[lenDir] = 0;

            if (!(sFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                && IsValidName(sFind32.cFileName))
            {
                strcat(buff, sFind32.cFileName);

                if(DeleteFileLocal(buff, ATTRIB_DEL_ANY) < 0)
                {
                    fOK = FALSE;
                    break;
                }
            }
        }
        while(FindNextFileLocal(hFind, &sFind32) >= 0);

        FindCloseLocal(hFind);
    }
    return (fOK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\daytona\precomp.h ===
#include "ntcsc.h"

//this cannot be placed in ntcsc.h because it redefines dbgprint
#include "assert.h"

//sigh..........
#if DBG
#undef DbgPrint
#undef Assert
#undef AssertSz
#define Assert(f)  ASSERT(f)
#define AssertSz(f, sz) ASSERTMSG(sz,f)
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\bmreclib\precomp.h ===
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include "shdsys.h"
#include "assert.h"
#include "shdcom.h"
#include "oslayeru.h"
#include "cscsec.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\daytona\ntcsclow.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

     NtCscLow.c

Abstract:

     Since this stuff is called from a low level, we must make use of the irp
     filesystems interface. An earlier experiment with ZwXXXFile failed due
     to the fact that the handles must be longlived and KeAttachProcess is
     unreliable. The strategy adopted has been to do the open in the rdbss
     process (i.e. in the system process) and then to use that handle as the
     basis for further Io. what we do is to get a pointer to the fileobject
     while we are in the system context. We do not take a reference on this
     because we already have the handle!

Author:


Revision History:

     Joe Linn              [joelinn]         01-jan-1997  ported to NT (as oslayer.c)
     Joe Linn              [joelinn]         22-aug-1997  moved into ntspecific file


--*/

#include "precomp.h"
#pragma hdrstop

#ifdef MRXSMBCSC_LOUDDOWNCALLS
#pragma alloc_text(PAGE, LoudCallsDbgPrint)
#endif //ifdef MRXSMBCSC_LOUDDOWNCALLS


#ifdef CSC_RECORDMANAGER_WINNT
#define Dbg (DEBUG_TRACE_MRXSMBCSC_OSLAYER)
RXDT_DeclareCategory(MRXSMBCSC_OSLAYER);
#endif //ifdef CSC_RECORDMANAGER_WINNT

//#define RXJOECSC_WHACKTRACE_FOR_OSLAYER
#ifdef RXJOECSC_WHACKTRACE_FOR_OSLAYER
#undef RxDbgTrace
#define RxDbgTrace(a,b,__d__) {DbgPrint __d__;}
#endif

#include "netevent.h"

typedef struct _NT5CSC_CLOSEFILE_POSTCONTEXT {
    KEVENT PostEvent;
    RX_WORK_QUEUE_ITEM  WorkQueueItem;
    PNT5CSC_MINIFILEOBJECT MiniFileObject;
    NTSTATUS PostedReturnStatus;
} NT5CSC_CLOSEFILE_POSTCONTEXT, *PNT5CSC_CLOSEFILE_POSTCONTEXT;


typedef struct _NT5CSC_ATTRIBS_CONTINUATION_CONTEXT {
    NTSTATUS Status;
    union {
        ULONG Attributes;
        struct {
            PFILE_RENAME_INFORMATION RenameInformation;
            ULONG RenameInfoBufferLength;
        };
    };
} NT5CSC_ATTRIBS_CONTINUATION_CONTEXT, *PNT5CSC_ATTRIBS_CONTINUATION_CONTEXT;


NTSTATUS
__Nt5CscCloseFile (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject OPTIONAL,
    IN     BOOL  PostedCall
    );

NTSTATUS
Nt5CscCloseFilePostWrapper(
    IN OUT PNT5CSC_CLOSEFILE_POSTCONTEXT CloseFilePostContext
    );

NTSTATUS
Nt5CscCreateFilePostWrapper(
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject
    );

//CODE.IMPROVEMENT these could be combined as one...........
NTSTATUS
Nt5CscGetAttributesContinuation (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject,
    IN OUT PVOID ContinuationContext,
    IN     NTSTATUS CreateStatus
    );

NTSTATUS
Nt5CscSetAttributesContinuation (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject,
    IN OUT PVOID ContinuationContext,
    IN     NTSTATUS CreateStatus
    );

NTSTATUS
Nt5CscRenameContinuation (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject,
    IN OUT PVOID ContinuationContext,
    IN     NTSTATUS CreateStatus
    );

NTSTATUS
Nt5CscDeleteContinuation (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject,
    IN OUT PVOID ContinuationContext,
    IN     NTSTATUS CreateStatus
    );

VOID
SetLastNtStatusLocal(
    NTSTATUS    Status
    );

ULONG
CloseFileLocalFromHandleCache(
    CSCHFILE handle
    );

extern BOOLEAN
IsHandleCachedForRecordmanager(
   CSCHFILE hFile
   );

#pragma alloc_text(PAGE, CscInitializeSecurityDescriptor)
#pragma alloc_text(PAGE, CscUninitializeSecurityDescriptor)
#pragma alloc_text(PAGE, GetSystemTime)
#pragma alloc_text(PAGE, Nt5CscCloseFilePostWrapper)
#pragma alloc_text(PAGE, __Nt5CscCloseFile)
#pragma alloc_text(PAGE, CloseFileLocal)
#pragma alloc_text(PAGE, CloseFileLocalFromHandleCache)
#pragma alloc_text(PAGE, __Nt5CscCreateFile)
#pragma alloc_text(PAGE, Nt5CscCreateFilePostWrapper)
#pragma alloc_text(PAGE, R0OpenFileEx)
#pragma alloc_text(PAGE, Nt5CscReadWriteFileEx)
#pragma alloc_text(PAGE, Nt5CscXxxInformation)
#pragma alloc_text(PAGE, GetFileSizeLocal)
#pragma alloc_text(PAGE, GetAttributesLocal)
#pragma alloc_text(PAGE, GetAttributesLocalEx)
#pragma alloc_text(PAGE, Nt5CscGetAttributesContinuation)
#pragma alloc_text(PAGE, SetAttributesLocal)
#pragma alloc_text(PAGE, Nt5CscSetAttributesContinuation)
#pragma alloc_text(PAGE, RenameFileLocal)
#pragma alloc_text(PAGE, Nt5CscRenameContinuation)
#pragma alloc_text(PAGE, DeleteFileLocal)
#pragma alloc_text(PAGE, Nt5CscDeleteContinuation)
#pragma alloc_text(PAGE, CreateDirectoryLocal)
#pragma alloc_text(PAGE, CreateDirectoryLocal)
#pragma alloc_text(PAGE, SetLastErrorLocal)
#pragma alloc_text(PAGE, GetLastErrorLocal)
#pragma alloc_text(PAGE, SetLastNtStatusLocal)

//CODE.IMPROVEMENT.NTIFS this should be in ntifs.h
NTSYSAPI
NTSTATUS
NTAPI
ZwFsControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG FsControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );

#ifdef RX_PRIVATE_BUILD
#undef IoGetTopLevelIrp
#undef IoSetTopLevelIrp
#endif //ifdef RX_PRIVATE_BUILD

PSECURITY_DESCRIPTOR CscSecurityDescriptor = NULL;

// This is a fake way by which we simulate the GetLastError and SetLastError calls
// vGloablWin32Error is set to the last error encountered if any.
// The reason why this works is because all csc database activities happen in
// the shadowcritsect, so effectively we are single threaded

DWORD   vGlobalWin32Error = 0;



extern NTSTATUS
RtlAbsoluteToSelfRelativeSD(
    PSECURITY_DESCRIPTOR AbsoluteSD,
    PSECURITY_DESCRIPTOR RelativeSD,
    PULONG               Length);


DWORD
CscInitializeSecurityDescriptor()
/*++

Routine Description:

    This routine initializes the security descriptor used for the creation of
    all the files in the database.

Notes:

    The current implementation provides for a ACL which grants the administrator
    group all access and read/execute access to everybody else.

    It is important to grant the local administrator group all access since the
    CSC utilities need to access these files

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PSID AdminsAliasSid;
    PACL TmpAcl = NULL;

    SECURITY_DESCRIPTOR AbsoluteSecurityDescriptor;

    SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;

    ULONG Length = 0;

    if (CscSecurityDescriptor != NULL) {
        return RtlNtStatusToDosError(Status);
    }

    AdminsAliasSid = (PSID)RxAllocatePoolWithTag(
                               NonPagedPool,
                               RtlLengthRequiredSid(2),
                               RX_MISC_POOLTAG);

    if (AdminsAliasSid != NULL) {

        RtlInitializeSid( AdminsAliasSid,   &BuiltinAuthority, 2 );

        *(RtlSubAuthoritySid( AdminsAliasSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
        *(RtlSubAuthoritySid( AdminsAliasSid,  1 )) = DOMAIN_ALIAS_RID_ADMINS;

        // The approach is to set up an absolute security descriptor that
        // looks like what we want and then copy it to make a self-relative
        // security descriptor.

        Status = RtlCreateSecurityDescriptor(
                     &AbsoluteSecurityDescriptor,
                     SECURITY_DESCRIPTOR_REVISION1);

        ASSERT( NT_SUCCESS(Status) );

        // Owner

        Status = RtlSetOwnerSecurityDescriptor (
                     &AbsoluteSecurityDescriptor,
                     AdminsAliasSid,
                     FALSE );

        ASSERT(NT_SUCCESS(Status));

        // Discretionary ACL
        //
        //      Calculate its length,
        //      Allocate it,
        //      Initialize it,
        //      Add each ACE
        //      Add it to the security descriptor

        Length = (ULONG)sizeof(ACL);

        Length += RtlLengthSid( AdminsAliasSid ) +
                  (ULONG)sizeof(ACCESS_ALLOWED_ACE) -
                  (ULONG)sizeof(ULONG);  //Subtract out SidStart field length

        TmpAcl = RxAllocatePoolWithTag(
                     NonPagedPool,
                     Length,
                     RX_MISC_POOLTAG);

        if (TmpAcl != NULL) {
            Status = RtlCreateAcl(
                         TmpAcl,
                         Length,
                         ACL_REVISION2);

            ASSERT( NT_SUCCESS(Status) );

            Status = RtlAddAccessAllowedAce (
                         TmpAcl,
                         ACL_REVISION2,
                         FILE_ALL_ACCESS,
                         AdminsAliasSid);

            ASSERT( NT_SUCCESS(Status) );

            Status = RtlSetDaclSecurityDescriptor (
                         &AbsoluteSecurityDescriptor,
                         TRUE,
                         TmpAcl,
                         FALSE );

            ASSERT(NT_SUCCESS(Status));


            // Convert the Security Descriptor to Self-Relative
            //
            //      Get the length needed
            //      Allocate that much memory
            //      Copy it
            //      Free the generated absolute ACLs

            Length = 0;
            Status = RtlAbsoluteToSelfRelativeSD(
                         &AbsoluteSecurityDescriptor,
                         NULL,
                         &Length );
            ASSERT(Status == STATUS_BUFFER_TOO_SMALL);

            CscSecurityDescriptor = (PSECURITY_DESCRIPTOR)
                                    RxAllocatePoolWithTag(
                                        NonPagedPool,
                                        Length,
                                        RX_MISC_POOLTAG);

            if (CscSecurityDescriptor != NULL) {
                Status = RtlAbsoluteToSelfRelativeSD(
                             &AbsoluteSecurityDescriptor,
                             CscSecurityDescriptor,
                             &Length );

                ASSERT(NT_SUCCESS(Status));
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (TmpAcl != NULL) {
        RxFreePool(TmpAcl);
    }

    if (AdminsAliasSid != NULL) {
        RxFreePool(AdminsAliasSid);
    }

    if (!NT_SUCCESS(Status)) {
        if (CscSecurityDescriptor != NULL) {
            RxFreePool(CscSecurityDescriptor);
        }
    }

    return RtlNtStatusToDosError(Status);
}

DWORD
CscUninitializeSecurityDescriptor()
/*++

Routine Description:

    This routine uninitializes the security descriptor used for the creation of
    all the files in the database.

--*/
{
    if (CscSecurityDescriptor != NULL) {
        RxFreePool(CscSecurityDescriptor);
        CscSecurityDescriptor = NULL;
    }
    return STATUS_SUCCESS;
}

VOID
GetSystemTime(
    _FILETIME *lpft
)
{
    LARGE_INTEGER l;

    KeQuerySystemTime(&l);
    lpft->dwLowDateTime = (DWORD)l.LowPart;
    lpft->dwHighDateTime = (DWORD)l.HighPart;
}


extern PRDBSS_DEVICE_OBJECT MRxSmbDeviceObject;

NTSTATUS
Nt5CscCloseFilePostWrapper(
    IN OUT PNT5CSC_CLOSEFILE_POSTCONTEXT CloseFilePostContext
    )
{
    NTSTATUS Status;

    ASSERT_MINIRDRFILEOBJECT(CloseFilePostContext->MiniFileObject);

    RxDbgTrace( 0, Dbg, ("Nt5CscCloseFilePostWrapper %08lx\n",
                 CloseFilePostContext->MiniFileObject));

    //KdPrint(("Nt5CscCloseFilePostWrapper %08lx\n",
    //             CloseFilePostContext->MiniFileObject));

    Status = __Nt5CscCloseFile (
                 CloseFilePostContext->MiniFileObject,
                 TRUE);

    CloseFilePostContext->PostedReturnStatus = Status;

    RxDbgTrace( 0, Dbg, ("Nt5CscCreateFilePostWrapper %08lx %08lx\n",
                 CloseFilePostContext->MiniFileObject,Status));
    //KdPrint(("Nt5CscCreateFilePostWrapper %08lx %08lx\n",
    //             CloseFilePostContext->MiniFileObject,Status));

    KeSetEvent( &CloseFilePostContext->PostEvent, 0, FALSE );
    return(Status);
}

NTSTATUS
__Nt5CscCloseFile (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject OPTIONAL,
    IN     BOOL  PostedCall
    )
{
    NTSTATUS Status;

    ASSERT_MINIRDRFILEOBJECT(MiniFileObject);

    if (PsGetCurrentProcess()!= RxGetRDBSSProcess()) {
        //CODE.IMPROVEMENT we should capture the rdbss process
        //  and avoid this call (RxGetRDBSSProcess)
        NTSTATUS PostStatus;
        NT5CSC_CLOSEFILE_POSTCONTEXT PostContext;

        ASSERT(!PostedCall);
        //gather up exverything and post the call

        KeInitializeEvent(&PostContext.PostEvent,
                          NotificationEvent,
                          FALSE );
        PostContext.MiniFileObject = MiniFileObject;

        IF_DEBUG {
            //fill the workqueue structure with deadbeef....all the better to diagnose
            //a failed post
            ULONG i;
            for (i=0;i+sizeof(ULONG)-1<sizeof(PostContext.WorkQueueItem);i+=sizeof(ULONG)) {
                PBYTE BytePtr = ((PBYTE)&PostContext.WorkQueueItem)+i;
                PULONG UlongPtr = (PULONG)BytePtr;
                *UlongPtr = 0xdeadbeef;
            }
        }

        PostStatus = RxPostToWorkerThread(
                         MRxSmbDeviceObject,
                         HyperCriticalWorkQueue,
                         &PostContext.WorkQueueItem,
                         Nt5CscCloseFilePostWrapper,
                         &PostContext);

        ASSERT(PostStatus == STATUS_SUCCESS);


        KeWaitForSingleObject( &PostContext.PostEvent,
                               Executive, KernelMode, FALSE, NULL );

        Status = PostContext.PostedReturnStatus;

    } else {

        LoudCallsDbgPrint("Ready to close",
                                MiniFileObject,0xcc,0,0,0,0,0);

        Status = ZwClose(MiniFileObject->NtHandle); //no one to return a status to!

        RxDbgTrace( 0, Dbg, ("Ring0 close: miniFO/status is %08lx/%08lx\n",MiniFileObject,Status));

    }

    if (PostedCall) {
        return(Status);
    }

    if (FlagOn(MiniFileObject->Flags,
              NT5CSC_MINIFOBJ_FLAG_ALLOCATED_FROM_POOL)) {
        RxFreePool(MiniFileObject);
    }

    return(Status);
}


ULONG
CloseFileLocal(
    CSCHFILE handle
    )
{
    NTSTATUS Status;

    if (IsHandleCachedForRecordmanager(handle))
    {
        DbgPrint("Doing a close on CSC handle %x while it is cached \n", handle);
        ASSERT(FALSE);
    }

    Status = __Nt5CscCloseFile(
                (PNT5CSC_MINIFILEOBJECT)handle,
                FALSE);
    return(RtlNtStatusToDosErrorNoTeb(Status));
}

ULONG
CloseFileLocalFromHandleCache(
    CSCHFILE handle
    )
{
    NTSTATUS Status;

    Status = __Nt5CscCloseFile(
                (PNT5CSC_MINIFILEOBJECT)handle,
                FALSE);
    return(RtlNtStatusToDosErrorNoTeb(Status));
}

#define Nt5CscCreateFile(a1,a2,a3,a4,a5,a6,a7,a8,a9, a10) \
          __Nt5CscCreateFile(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,FALSE)

#ifdef MRXSMBCSC_LOUDDOWNCALLS
PCHAR LoudDownCallsTrigger = "\0";// "0000001D\0xxxxxxxxxxxxxxxxxxx";
#else
#define LoudDownCallsTrigger ((PCHAR)NULL)
#endif //ifdef MRXSMBCSC_LOUDDOWNCALLS


NTSTATUS
Nt5CscCreateFilePostWrapper(
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject
    );

ULONG EventLogForOpenFailure = 0;
ULONG MaximumEventLogsOfThisType = 10;
PNT5CSC_MINIFILEOBJECT
__Nt5CscCreateFile (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject OPTIONAL,
    IN     LPSTR    lpPath,
    IN     ULONG    CSCFlags,
    IN     ULONG    FileAttributes,
    IN     ULONG    CreateOptions,
    IN     ULONG    Disposition,
    IN     ULONG    ShareAccess,
    IN     ACCESS_MASK DesiredAccess,
    IN     PNT5CSC_CREATEFILE_CONTINUATION Continuation,
    IN OUT PVOID    ContinuationContext,
    IN     BOOL     PostedCall
    )
/*++

Routine Description:

   This routine performs a IoCreateFile after gathering up
   all the params and getting into the right process. It also
   allocates (if needed) a MINIFILEOBJECT. All of the recordmanager
   opens are gathered up here....whether a regular open or a path-based
   operation.

   In addition, i discover that it is not enough to be in the system process;
   rather, i must be on a thread with APCs enabled. so, we will post all create
   calls even tho we do not post close calls if we are already in a system
   thread.

Arguments:

    these params are the same as for IoCreateFile.

Return Value:

    NULL is the operation failed......a MINIFILEOBJECT otherwise.

Notes:

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING FileName;
    ANSI_STRING FileNameAsAnsiString;
#if defined(BITCOPY)
    BOOLEAN Allocated = TRUE;
    ULONG fInstrument =   CSCFlags & FLAG_CREATE_OSLAYER_INSTRUMENT;
    ULONG fAllAccess  =   CSCFlags & FLAG_CREATE_OSLAYER_ALL_ACCESS;
    ULONG fOpenAltStream = CSCFlags & FLAG_CREATE_OSLAYER_OPEN_STRM;
#else
    BOOLEAN Allocated = TRUE;
    BOOLEAN fInstrument =   (BOOLEAN)(CSCFlags & FLAG_CREATE_OSLAYER_INSTRUMENT);
    BOOLEAN fAllAccess  =   (BOOLEAN)(CSCFlags & FLAG_CREATE_OSLAYER_ALL_ACCESS);
#endif // defined(BITCOPY)

    FileName.Buffer = NULL;

    if (MiniFileObject==NULL) {
        MiniFileObject = (PNT5CSC_MINIFILEOBJECT)RxAllocatePoolWithTag(
                            NonPagedPool, //this has events and mutexs in it
                            sizeof(*MiniFileObject),
                            RX_MISC_POOLTAG);
    } else {
        Allocated = FALSE;
    }
    if (MiniFileObject==NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY;
    }

    ZeroAndInitializeNodeType(
          MiniFileObject,
          NT5CSC_NTC_MINIFILEOBJECT,
          ((USHORT)FIELD_OFFSET(NT5CSC_MINIFILEOBJECT,PostXX.PostEvent))
          );
    MiniFileObject->Flags |= NT5CSC_MINIFOBJ_FLAG_ALLOCATED_FROM_POOL;

    // There used to be an optimization here, which would check whether this was RDBSS
    // process and if so the code would not post the call.
    // But that causes IoCreateFile to be issued at APC irql becuase
    // shadowcrit is implemented as fastmutex which causes the irql level to be
    // raised to APC level

    // The above optimization was done for remoteboot. If and when we resurrect
    // remoteboot, we will revisit the issue

    if (!PostedCall) {
        NTSTATUS PostStatus;
        //gather up exverything and post the call

        KeInitializeEvent(&MiniFileObject->PostXX.PostEvent,
                          NotificationEvent,
                          FALSE );
        MiniFileObject->PostXX.lpPath = lpPath;
#if defined(BITCOPY)
        MiniFileObject->PostXX.fInstrument = fInstrument|fOpenAltStream|fAllAccess;
#else
        MiniFileObject->PostXX.fInstrument = fInstrument;
#endif // defined(BITCOPY)
        MiniFileObject->PostXX.FileAttributes = FileAttributes;
        MiniFileObject->PostXX.CreateOptions = CreateOptions;
        MiniFileObject->PostXX.Disposition = Disposition;
        MiniFileObject->PostXX.ShareAccess = ShareAccess;
        MiniFileObject->PostXX.DesiredAccess = DesiredAccess;
        MiniFileObject->PostXX.Continuation = Continuation;
        MiniFileObject->PostXX.ContinuationContext = ContinuationContext;


        IF_DEBUG {
            //fill the workqueue structure with deadbeef....all the better to diagnose
            //a failed post
            ULONG i;
            for (i=0;i+sizeof(ULONG)-1<sizeof(MiniFileObject->PostXX.WorkQueueItem);i+=sizeof(ULONG)) {
                PBYTE BytePtr = ((PBYTE)&MiniFileObject->PostXX.WorkQueueItem)+i;
                PULONG UlongPtr = (PULONG)BytePtr;
                *UlongPtr = 0xdeadbeef;
            }
        }

        PostStatus = RxPostToWorkerThread(
                         MRxSmbDeviceObject,
                         HyperCriticalWorkQueue,
                         &MiniFileObject->PostXX.WorkQueueItem,
                         Nt5CscCreateFilePostWrapper,
                         MiniFileObject);

        ASSERT(PostStatus == STATUS_SUCCESS);


        KeWaitForSingleObject( &MiniFileObject->PostXX.PostEvent,
                                Executive, KernelMode, FALSE, NULL );

        Status = MiniFileObject->PostXX.PostReturnStatus;
    } else {
        BOOLEAN ThisIsALoudFile = FALSE;

        RtlInitAnsiString(&FileNameAsAnsiString, lpPath);

        IF_BUILT_FOR_LOUD_DOWNCALLS() {
            ANSI_STRING LoudDownCallsTriggerAsAnsiString = {0,0,NULL};
            USHORT CompareLength;

            RtlInitAnsiString(&LoudDownCallsTriggerAsAnsiString, LoudDownCallsTrigger);
            if ((CompareLength=LoudDownCallsTriggerAsAnsiString.Length) != 0) {
                ANSI_STRING TailStringOfName;
                TailStringOfName.Length = CompareLength;
                TailStringOfName.MaximumLength = CompareLength;
                TailStringOfName.Buffer
                    = &FileNameAsAnsiString.Buffer[FileNameAsAnsiString.Length - CompareLength];
                if (RtlEqualString(&TailStringOfName,
                                   &LoudDownCallsTriggerAsAnsiString,TRUE)) {
                    KdPrint(("found loudfilename: file %s\n",lpPath));
                    ThisIsALoudFile = TRUE;
                }
            }
        }

        Status = RtlAnsiStringToUnicodeString(
                        &FileName,
                        &FileNameAsAnsiString,
                        TRUE //this says to allocate the string
                        );
        if (Status!=STATUS_SUCCESS) {
            goto FINALLY;
        }

#if defined(REMOTE_BOOT)
        //
        // At this point in the old remote boot code, we impersonated
        // the user for the call to IoCreateFile. There was an
        // OsSpecificContext saved in the MiniFileObject->PostXX
        // structure that was saved before we posted to a thread,
        // having been passed down by adding a context parameter
        // to CreateFileLocal, OpenFileLocal[Ex], and R0OpenFile[Ex].
        // This context pointed to a structure containing a
        // PNT_CREATE_PARAMETERS cp from the IRP and a place to return
        // a status. We called
        //  PsImpersonateContext(
        //      PsGetCurrentThread(),
        //      SeQuerySubjectContextToken(
        //          &cp->SecurityContext->AccessState->SubjectSecurityContext),
        //      TRUE,
        //      TRUE,
        //      SecurityImpersonation)
        // then in InitializeObjectAttributes we set the security descriptor
        // to cp->SecurityContext->AccessState->SecurityDescriptor (in case
        // we were creating the file). We then called IoCreateFile with the
        // IO_FORCE_ACCESS_CHECK option, saving the status in the context
        // (since we have no way to directly return an NTSTATUS from here).
        // Finally we called PsRevertToSelf() before returning.
        //
#endif

        RxDbgTrace( 0, Dbg, ("Ring0 open: file %wZ\n",&FileName));

        InitializeObjectAttributes(
             &ObjectAttributes,
             &FileName,
             OBJ_CASE_INSENSITIVE,
             0,
             (fAllAccess)?NULL:CscSecurityDescriptor
             );

        if (fInstrument)
        {
            BEGIN_TIMING(IoCreateFile_R0Open);
        }
#if DBG
        if(KeGetCurrentIrql() != PASSIVE_LEVEL)
        {
            DbgPrint("Irql level = %d \n", KeGetCurrentIrql());
            ASSERT(FALSE);
        }
#endif

        Status = IoCreateFile(
                          &MiniFileObject->NtHandle,
                          DesiredAccess,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          NULL, //&CreateParameters->AllocationSize,
                          FileAttributes, //CreateParameters->FileAttributes,
                          ShareAccess, //CreateParameters->ShareAccess,
                          Disposition, //CreateParameters->Disposition,
                          CreateOptions,
                          NULL, //RxContext->Create.EaBuffer,
                          0, //RxContext->Create.EaLength,
                          CreateFileTypeNone,
                          NULL,                    // extra parameters
                          IO_NO_PARAMETER_CHECKING
                          );

        if (fInstrument)
        {
            END_TIMING(IoCreateFile_R0Open);
        }


        if (Status==STATUS_SUCCESS) {

            RxDbgTrace( 0, Dbg, ("Ring0 open: file %wZ, handle is %08lx\n",&FileName,MiniFileObject->NtHandle));
            //now get a pointer to the file object by referencing....since we
            //dont need the reference...drop it if successful

             Status = ObReferenceObjectByHandle(
                             MiniFileObject->NtHandle,
                             0L,
                             NULL,
                             KernelMode,
                             (PVOID *) &MiniFileObject->UnderlyingFileObject,
                             NULL );

            if (Status==STATUS_SUCCESS) {
                ObDereferenceObject( MiniFileObject->UnderlyingFileObject );
            }

#if defined(BITCOPY)
            if (TRUE && (Status==STATUS_SUCCESS) && !fOpenAltStream) {
#else
            if (TRUE && (Status==STATUS_SUCCESS)) {
#endif // defined(BITCOPY)
                IO_STATUS_BLOCK IoStatusBlock;
                USHORT CompressionFormat = COMPRESSION_FORMAT_NONE;
                Status = ZwFsControlFile(
                                MiniFileObject->NtHandle,  //IN HANDLE FileHandle,
                                NULL,                      //IN HANDLE Event OPTIONAL,
                                NULL,                      //IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
                                NULL,                      //IN PVOID ApcContext OPTIONAL,
                                &IoStatusBlock,            //OUT PIO_STATUS_BLOCK IoStatusBlock,
                                FSCTL_SET_COMPRESSION,     //IN ULONG FsControlCode,
                                &CompressionFormat,        //IN PVOID InputBuffer OPTIONAL,
                                sizeof(CompressionFormat), //IN ULONG InputBufferLength,
                                NULL,                      //OUT PVOID OutputBuffer OPTIONAL,
                                0                          //IN ULONG OutputBufferLength
                                );
                //DbgPrint("Ring0 setcompress : file %wZ, status is %08lx\n",&FileName,Status);
                if (Status!=STATUS_SUCCESS) {
                    if (Status==STATUS_INVALID_DEVICE_REQUEST) {
                        Status = STATUS_SUCCESS;
                    } else {
                        DbgPrint("Ring0 setcompress failed: file %wZ, status is %08lx\n",&FileName,Status);
                        RxDbgTrace( 0, Dbg,
                           ("Ring0 setcompress failed: file %wZ, status is %08lx\n",&FileName,Status));
                    }
                }
            }


            if (Status!=STATUS_SUCCESS) {
                NtClose(MiniFileObject->NtHandle);
                MiniFileObject->NtHandle = 0;
            }

        } else {
            RxDbgTrace( 0, Dbg, ("Ring0 open: file %wZ, status is %08lx\n",&FileName,Status));

            IF_BUILT_FOR_LOUD_DOWNCALLS() {
                if (ThisIsALoudFile) {
                    DbgPrint("Nt5Csc: openfailed %08lx %wZ\n",Status,&FileName);
                }
            }

            if (EventLogForOpenFailure && (MaximumEventLogsOfThisType > 0)) {
                PCHAR  LogBuffer = FileNameAsAnsiString.Buffer;
                USHORT LogBufferLength = FileNameAsAnsiString.Length;

                DbgPrint("Nt5Csc: openfailed %08lx %wZ\n",Status,&FileName);

                EventLogForOpenFailure = 0; //do this to be sure....
                MaximumEventLogsOfThisType--;

                if (LogBufferLength>12) {
                    LogBuffer += 12;
                    LogBufferLength -= 12;
                }
                RxLogFailureWithBuffer(
                     MRxSmbDeviceObject,
                     NULL,
                     EVENT_RDR_CANT_READ_REGISTRY,
                     Status,
                     LogBuffer,
                     LogBufferLength
                     );
            }
        }

        IF_BUILT_FOR_LOUD_DOWNCALLS() {
            if (ThisIsALoudFile) {
                DbgPrint("OpenedFile %08lx %08lx %02lx  %08lx@%08lx:%08lx\n",
                                MiniFileObject->NtHandle,
                                MiniFileObject->UnderlyingFileObject,
                                0xcc,
                                0,
                                0,
                                0
                                );
                SetFlag(MiniFileObject->Flags,NT5CSC_MINIFOBJ_FLAG_LOUDDOWNCALLS);
            }
        }

        if (Continuation!=NULL) {
            Status = Continuation(MiniFileObject,ContinuationContext,Status);
        }

    }

FINALLY:
    if (FileName.Buffer != NULL) {
        ExFreePool(FileName.Buffer);
    }

    if (PostedCall) {
        ASSERT(!Allocated);
        MiniFileObject->PostXX.PostReturnStatus = Status;
        return(NULL);
    }

    if (Status!=STATUS_SUCCESS) {
        //give back anything that we have
        if (Allocated && (MiniFileObject!=NULL)) {
            if (FlagOn(MiniFileObject->Flags,
                       NT5CSC_MINIFOBJ_FLAG_ALLOCATED_FROM_POOL)) {
                RxFreePool(MiniFileObject);
            }
        }
        SetLastNtStatusLocal(Status);
        return(NULL);
    }

    //initialize the deviceobjectpointer and the mutex........

    //cant do this MiniFileObject->UnderlyingDeviceObject
    //cant do this    = IoGetRelatedDeviceObject( MiniFileObject->UnderlyingFileObject );
    ExInitializeFastMutex(&MiniFileObject->MutexForSynchronousIo);
    return(MiniFileObject);
}


NTSTATUS
Nt5CscCreateFilePostWrapper(
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject
    )
/*++

Routine Description:

Arguments:

Return Value:

Notes:

--*/
{
    NTSTATUS Status;
    LPSTR Path = MiniFileObject->PostXX.lpPath;

    RxDbgTrace( 0, Dbg, ("Nt5CscCreateFilePostWrapper %08lx %s\n",
                 MiniFileObject,Path));

    __Nt5CscCreateFile (
                 MiniFileObject,
                 MiniFileObject->PostXX.lpPath,
                 MiniFileObject->PostXX.fInstrument,
                 MiniFileObject->PostXX.FileAttributes,
                 MiniFileObject->PostXX.CreateOptions,
                 MiniFileObject->PostXX.Disposition,
                 MiniFileObject->PostXX.ShareAccess,
                 MiniFileObject->PostXX.DesiredAccess,
                 MiniFileObject->PostXX.Continuation,
                 MiniFileObject->PostXX.ContinuationContext,
                 TRUE);

    Status = MiniFileObject->PostXX.PostReturnStatus;
    RxDbgTrace( 0, Dbg, ("Nt5CscCreateFilePostWrapper %08lx %s %08lx\n",
                 MiniFileObject,Path,Status));

    KeSetEvent( &MiniFileObject->PostXX.PostEvent, 0, FALSE );
    return(Status);
}



CSCHFILE
R0OpenFileEx(
    USHORT  usOpenFlags,
    UCHAR   bAction,
    ULONG   ulAttr,
    LPSTR   lpPath,
    BOOL    fInstrument
    )
/*++

Routine Description:

Arguments:

Return Value:

Notes:

--*/
{
     PNT5CSC_MINIFILEOBJECT MiniFileObject;
     ULONG Disposition,ShareAccess,CreateOptions;

     ASSERT( (usOpenFlags & 0xf) == ACCESS_READWRITE);
     ShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE;
     CreateOptions = FILE_SYNCHRONOUS_IO_NONALERT
                                    | FILE_NON_DIRECTORY_FILE;
     if (usOpenFlags & OPEN_FLAGS_COMMIT)
     {
        CreateOptions |= FILE_WRITE_THROUGH;
     }
     switch (bAction) {
     case ACTION_CREATEALWAYS:
          Disposition = FILE_OVERWRITE_IF;
          break;

     case ACTION_OPENALWAYS:
          Disposition = FILE_OPEN_IF;
          break;

     case ACTION_OPENEXISTING:
          Disposition = FILE_OPEN;
          break;

     default:
         return (CSCHFILE)(NULL);
     }

     MiniFileObject =  Nt5CscCreateFile (
                          NULL, //make him allocate
                          lpPath,
                          fInstrument,
                          ulAttr,
                          CreateOptions,
                          Disposition,
                          ShareAccess,
                          GENERIC_READ | GENERIC_WRITE,
                          NULL,NULL  //Continuation
                          );

    return (CSCHFILE)MiniFileObject;
}



typedef struct _NT5CSC_IRPCOMPLETION_CONTEXT {
    //IO_STATUS_BLOCK IoStatus;
    KEVENT Event;
} NT5CSC_IRPCOMPLETION_CONTEXT, *PNT5CSC_IRPCOMPLETION_CONTEXT;

NTSTATUS
Nt5CscIrpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the calldownirp is completed.

Arguments:

    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context

Return Value:

    RXSTATUS - STATUS_MORE_PROCESSING_REQUIRED

--*/
{
    PNT5CSC_IRPCOMPLETION_CONTEXT IrpCompletionContext
           = (PNT5CSC_IRPCOMPLETION_CONTEXT)Context;

    if (CalldownIrp->PendingReturned){
        //IrpCompletionContext->IoStatus = CalldownIrp->IoStatus;
        KeSetEvent( &IrpCompletionContext->Event, 0, FALSE );
    }
    return(STATUS_MORE_PROCESSING_REQUIRED);
}

//long R0ReadWriteFileEx
//    (
//    ULONG     uOper,
//    CSCHFILE  handle,
//    ULONG     pos,
//    PVOID     pBuff,
//    long      lCount,
//    BOOL      fInstrument
//    )


IO_STATUS_BLOCK Nt5CscGlobalIoStatusBlock;

LONG
Nt5CscReadWriteFileEx (
    ULONG       uOper,
    CSCHFILE    handle,
    ULONGLONG   pos,
    PVOID       pBuff,
    long        lCount,
    ULONG       Flags,
    PIO_STATUS_BLOCK OutIoStatusBlock OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

Notes:

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER ByteOffset;
    ULONG MajorFunction;
    PNT5CSC_MINIFILEOBJECT MiniFileObject = (PNT5CSC_MINIFILEOBJECT)handle;

    PIRP irp,TopIrp;
    PIO_STACK_LOCATION irpSp;

    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT FileObject;

    NT5CSC_IRPCOMPLETION_CONTEXT IrpCompletionContext;
    ULONG ReturnedLength, MdlLength;
    BOOLEAN    fInstrument = BooleanFlagOn(Flags,NT5CSC_RW_FLAG_INSTRUMENTED);
    BOOLEAN    fPagedBuffer = BooleanFlagOn(Flags,NT5CSC_RW_FLAG_PAGED_BUFFER);


    if (OutIoStatusBlock==NULL) {
        OutIoStatusBlock = &Nt5CscGlobalIoStatusBlock;
    }
    OutIoStatusBlock->Information = 0;

    ASSERT (MiniFileObject);
    ASSERT_MINIRDRFILEOBJECT(MiniFileObject);

    //DeviceObject =  MiniFileObject->UnderlyingDeviceObject;
    FileObject = MiniFileObject->UnderlyingFileObject;
    ASSERT (FileObject);
    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    ASSERT (DeviceObject);

    if (DeviceObject->Flags & DO_BUFFERED_IO) {
        //i cannot handled buffered_io devices....sigh
        OutIoStatusBlock->Status = STATUS_INVALID_DEVICE_REQUEST;
        SetLastNtStatusLocal(STATUS_INVALID_DEVICE_REQUEST);
        return -1;
    }

    ByteOffset.QuadPart = pos;

    if ((uOper == R0_READFILE) || (uOper == R0_READFILE_IN_CONTEXT)) {
        MajorFunction = IRP_MJ_READ;
    } else {
        MajorFunction = IRP_MJ_WRITE;
        //if (lCount ==0x44) {
        //     DbgBreakPoint();
        //}
    }

//    irp = IoBuildAsynchronousFsdRequest(
//              MajorFunction,
//              DeviceObject,
//              NULL, //Buffer...needs special treatment
//              lCount,
//              &ByteOffset,
//              NULL
//              );

    irp = IoAllocateIrp( DeviceObject->StackSize, FALSE ); //why not charge???
    if (!irp) {
        OutIoStatusBlock->Status = STATUS_INSUFFICIENT_RESOURCES;
        SetLastNtStatusLocal(STATUS_INSUFFICIENT_RESOURCES);
        return -1;
    }

    //
    // Set current thread for IoSetHardErrorOrVerifyDevice.
    //

    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and the parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation( irp );  //ok4ioget
    irpSp->MajorFunction = (UCHAR) MajorFunction;
    irpSp->FileObject = FileObject;            //ok4->FileObj
    IoSetCompletionRoutine(irp,
                           Nt5CscIrpCompletionRoutine,
                           &IrpCompletionContext,
                           TRUE,TRUE,TRUE); //call no matter what....

    ASSERT (&irpSp->Parameters.Write.Key == &irpSp->Parameters.Read.Key);
    ASSERT (&irpSp->Parameters.Write.Length == &irpSp->Parameters.Read.Length);
    ASSERT (&irpSp->Parameters.Write.ByteOffset == &irpSp->Parameters.Read.ByteOffset);
    irpSp->Parameters.Read.Length = MdlLength = lCount;
    irpSp->Parameters.Read.ByteOffset = ByteOffset;
    irpSp->Parameters.Read.Key = 0;          //not used
    irp->RequestorMode = KernelMode;
    irp->UserBuffer = pBuff;

    if (FlagOn(Flags,NT5CSC_RW_FLAG_IRP_NOCACHE)) {
        irp->Flags |= IRP_NOCACHE;
        MdlLength = (ULONG)ROUND_TO_PAGES(MdlLength);
    }


    irp->MdlAddress = IoAllocateMdl(
                         irp->UserBuffer,
                         MdlLength,
                         FALSE,FALSE,NULL);

    if (!irp->MdlAddress) {
        //whoops.......sorry..........
        IoFreeIrp(irp);
        OutIoStatusBlock->Status = STATUS_INSUFFICIENT_RESOURCES;
        SetLastNtStatusLocal(STATUS_INSUFFICIENT_RESOURCES);
        return(-1);
    }

    Status = STATUS_SUCCESS;

    if (fPagedBuffer)
    {
        try {
            MmProbeAndLockPages(
                irp->MdlAddress,
                KernelMode,
                IoWriteAccess
            );
        } except(EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();

            IoFreeMdl( irp->MdlAddress );
        }
    }
    else
    {
        MmBuildMdlForNonPagedPool(irp->MdlAddress);
    }

    if (Status != STATUS_SUCCESS)
    {
        IoFreeIrp(irp);
        OutIoStatusBlock->Status = Status;
        SetLastNtStatusLocal(Status);
        return(-1);
    }


    LoudCallsDbgPrint("Ready to ",
                            MiniFileObject,
                            MajorFunction,
                            lCount,
                            ByteOffset.LowPart,
                            ByteOffset.HighPart,0,0
                            );

    KeInitializeEvent(&IrpCompletionContext.Event,
                      NotificationEvent,
                      FALSE );

    try {
        TopIrp = IoGetTopLevelIrp();
        IoSetTopLevelIrp(NULL); //tell the underlying guy he's all clear
        Status = IoCallDriver(DeviceObject,irp);
    } finally {
        IoSetTopLevelIrp(TopIrp); //restore my context for unwind
    }

    //RxDbgTrace (0, Dbg, ("  -->Status after iocalldriver %08lx(%08lx)\n",RxContext,Status));

    if (Status == (STATUS_PENDING)) {
        KeWaitForSingleObject( &IrpCompletionContext.Event,
                               Executive, KernelMode, FALSE, NULL );
        Status = irp->IoStatus.Status;
    }

    ReturnedLength = (ULONG)irp->IoStatus.Information;
    RxDbgTrace( 0, Dbg, ("Ring0%sFile<%x> %x bytes@%x returns %08lx/%08lx\n",
                (MajorFunction == IRP_MJ_READ)?"Read":"Write",MiniFileObject,
                lCount,pos,Status,ReturnedLength));


    if (fPagedBuffer)
    {
        MmUnlockPages( irp->MdlAddress );
    }

    IoFreeMdl(irp->MdlAddress);
    IoFreeIrp(irp);

    LoudCallsDbgPrint("Back from",
                            MiniFileObject,
                            MajorFunction,
                            lCount,
                            ByteOffset.LowPart,
                            ByteOffset.HighPart,
                            Status,
                            ReturnedLength
                            );

    OutIoStatusBlock->Status = Status;
    if (Status==STATUS_SUCCESS) {

        OutIoStatusBlock->Information = ReturnedLength;

        return(ReturnedLength);

    } else if (Status == STATUS_END_OF_FILE){
        SetLastNtStatusLocal(STATUS_END_OF_FILE);
        return (0);
    }
    else {
        SetLastNtStatusLocal(Status);
        return(-1);
    }
}


NTSTATUS
Nt5CscXxxInformation(
    IN PCHAR xMajorFunction,
    IN PNT5CSC_MINIFILEOBJECT MiniFileObject,
    IN ULONG InformationClass,
    IN ULONG Length,
    OUT PVOID Information,
    OUT PULONG ReturnedLength
    )

/*++

Routine Description:

    This routine returns the requested information about a specified file
    or volume.  The information returned is determined by the class that
    is specified, and it is placed into the caller's output buffer.

Arguments:

    MiniFileObject - Supplies a pointer to the file object about which the requested
        information is returned.

    FsInformationClass - Specifies the type of information which should be
        returned about the file/volume.

    Length - Supplies the length of the buffer in bytes.

    FsInformation - Supplies a buffer to receive the requested information
        returned about the file.  This buffer must not be pageable and must
        reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
        information written to the buffer.

    FileInformation - Boolean that indicates whether the information requested
        is for a file or a volume.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    NTSTATUS Status;
    PIRP irp,TopIrp;
    PIO_STACK_LOCATION irpSp;

    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT FileObject;

    NT5CSC_IRPCOMPLETION_CONTEXT IrpCompletionContext;
    ULONG DummyReturnedLength;

    ULONG SetFileInfoInfo;

    PAGED_CODE();

    if (ReturnedLength==NULL) {
        ReturnedLength = &DummyReturnedLength;
    }


    //DeviceObject =  MiniFileObject->UnderlyingDeviceObject;
    FileObject = MiniFileObject->UnderlyingFileObject;
    ASSERT (FileObject);
    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    ASSERT (DeviceObject);

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IoAllocateIrp( DeviceObject->StackSize, TRUE );
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = KernelMode;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = (UCHAR)xMajorFunction;
    irpSp->FileObject = FileObject;
    IoSetCompletionRoutine(irp,
                           Nt5CscIrpCompletionRoutine,
                           &IrpCompletionContext,
                           TRUE,TRUE,TRUE); //call no matter what....


    irp->AssociatedIrp.SystemBuffer = Information;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    IF_DEBUG {
        ASSERT( (irpSp->MajorFunction == IRP_MJ_QUERY_INFORMATION)
                    || (irpSp->MajorFunction == IRP_MJ_SET_INFORMATION)
                    || (irpSp->MajorFunction == IRP_MJ_QUERY_VOLUME_INFORMATION) );

        if (irpSp->MajorFunction == IRP_MJ_SET_INFORMATION) {
            ASSERT( (InformationClass == FileAllocationInformation)
                        || (InformationClass == FileEndOfFileInformation) );

            IF_LOUD_DOWNCALLS(MiniFileObject) {
                SetFileInfoInfo =  ((PFILE_END_OF_FILE_INFORMATION)Information)->EndOfFile.LowPart;
            }
        }

        ASSERT(&irpSp->Parameters.QueryFile.Length == &irpSp->Parameters.SetFile.Length);
        ASSERT(&irpSp->Parameters.QueryFile.Length == &irpSp->Parameters.QueryVolume.Length);


        ASSERT(&irpSp->Parameters.QueryFile.FileInformationClass
                                          == &irpSp->Parameters.SetFile.FileInformationClass);
        ASSERT((PVOID)&irpSp->Parameters.QueryFile.FileInformationClass
                                          == (PVOID)&irpSp->Parameters.QueryVolume.FsInformationClass);

    }

    irpSp->Parameters.QueryFile.Length = Length;
    irpSp->Parameters.QueryFile.FileInformationClass = InformationClass;

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    KeInitializeEvent(&IrpCompletionContext.Event,
                      NotificationEvent,
                      FALSE );

    LoudCallsDbgPrint("Ready to",
                            MiniFileObject,
                            irpSp->MajorFunction,
                            irpSp->Parameters.QueryFile.FileInformationClass,
                            irpSp->Parameters.QueryFile.Length,
                            SetFileInfoInfo,0,0
                            );

    try {
        TopIrp = IoGetTopLevelIrp();
        IoSetTopLevelIrp(NULL); //tell the underlying guy he's all clear
        Status = IoCallDriver(DeviceObject,irp);
    } finally {
        IoSetTopLevelIrp(TopIrp); //restore my context for unwind
    }


    //RxDbgTrace (0, Dbg, ("  -->Status after iocalldriver %08lx(%08lx)\n",RxContext,Status));

    if (Status == (STATUS_PENDING)) {
        KeWaitForSingleObject( &IrpCompletionContext.Event,
                               Executive, KernelMode, FALSE, NULL );
        Status = irp->IoStatus.Status;
    }

    LoudCallsDbgPrint("Back from",
                            MiniFileObject,
                            irpSp->MajorFunction,
                            irpSp->Parameters.QueryFile.FileInformationClass,
                            irpSp->Parameters.QueryFile.Length,
                            SetFileInfoInfo,
                            Status,irp->IoStatus.Information
                            );

    if (Status==STATUS_SUCCESS) {
        *ReturnedLength = (ULONG)irp->IoStatus.Information;
        RxDbgTrace( 0, Dbg, ("Ring0QueryXXX(%x)Info<%x> %x bytes@%x returns %08lx/%08lx\n",
                    xMajorFunction,MiniFileObject,
                    Status,*ReturnedLength));
    }

    IoFreeIrp(irp);
    return(Status);

}

int
GetFileSizeLocal(
    CSCHFILE handle,
    PULONG lpuSize
    )
{
     NTSTATUS Status;
     IO_STATUS_BLOCK IoStatusBlock;
     FILE_STANDARD_INFORMATION Information;
     ULONG t,ReturnedLength;
     PNT5CSC_MINIFILEOBJECT MiniFileObject = (PNT5CSC_MINIFILEOBJECT)handle;


     RxDbgTrace( 0, Dbg, ("GetFileSizeLocal: handle %08lx\n",handle));
     ASSERT_MINIRDRFILEOBJECT(MiniFileObject);

     MiniFileObject->StandardInfo.EndOfFile.LowPart = 0xfffffeee;
     Status = Nt5CscXxxInformation((PCHAR)IRP_MJ_QUERY_INFORMATION,
                    MiniFileObject,
                    FileStandardInformation,//IN FILE_INFORMATION_CLASS FileInformationClass,
                    sizeof(MiniFileObject->StandardInfo),//IN ULONG Length,
                    &MiniFileObject->StandardInfo,   //OUT PVOID FileInformation,
                    &MiniFileObject->ReturnedLength //OUT PULONG ReturnedLength
                    );

     Information = MiniFileObject->StandardInfo;

     if (Status != STATUS_SUCCESS) {
          KdPrint(("GetFileSizeLocal: handle %08lx: bailing w %08lx\n",handle,Status));
          SetLastNtStatusLocal(Status);
          return(-1);
     }

     t = Information.EndOfFile.LowPart;
     RxDbgTrace( 0, Dbg, ("GetFileSizeLocal: handle %08lx: return w size%08lx\n",handle,t));
     //DbgPrint("GetFileSizeLocal: handle %08lx: return w size%08lx\n",handle,t);
     *lpuSize = t;
     return(STATUS_SUCCESS);
}

ULONG  Nt5CscGetAttributesLocalCalls = 0;
int
GetAttributesLocal(
    LPSTR   lpPath,
    ULONG   *lpuAttributes
    )
{
    return (GetAttributesLocalEx(lpPath, TRUE, lpuAttributes));
}

int GetAttributesLocalEx(
    LPSTR   lpPath,
    BOOL    fFile,
    ULONG   *lpuAttributes
    )
{
    PNT5CSC_MINIFILEOBJECT MiniFileObject;
    ULONG Disposition,ShareAccess,CreateOptions;
    NT5CSC_ATTRIBS_CONTINUATION_CONTEXT Context;

    Nt5CscGetAttributesLocalCalls++;
    ShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    CreateOptions = FILE_SYNCHRONOUS_IO_NONALERT
                                    | (fFile?FILE_NON_DIRECTORY_FILE:FILE_DIRECTORY_FILE);

    MiniFileObject =  Nt5CscCreateFile (
                          NULL, //make him allocate
                          lpPath,
                          FALSE,
                          FILE_ATTRIBUTE_NORMAL,
                          CreateOptions,
                          FILE_OPEN,  //disposition
                          ShareAccess,
                          FILE_READ_ATTRIBUTES,
                          Nt5CscGetAttributesContinuation,
                          &Context  //Continuation
                          );

     if (Context.Status != STATUS_SUCCESS) {
          SetLastNtStatusLocal(Context.Status);
          return(-1);
     }

     *lpuAttributes = Context.Attributes;
     return(STATUS_SUCCESS);
}

NTSTATUS
Nt5CscGetAttributesContinuation (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject,
    IN OUT PVOID ContinuationContext,
    IN     NTSTATUS CreateStatus
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInformation;
    PNT5CSC_ATTRIBS_CONTINUATION_CONTEXT Context
          = (PNT5CSC_ATTRIBS_CONTINUATION_CONTEXT)ContinuationContext;

    if (CreateStatus == STATUS_SUCCESS) {

        LoudCallsDbgPrint("GetAttrContinue",
                                MiniFileObject,
                                0xa1,0,0,0,0,0);


        Context->Status = ZwQueryInformationFile(
                         MiniFileObject->NtHandle,  //IN HANDLE FileHandle,
                         &IoStatusBlock,            //OUT PIO_STATUS_BLOCK IoStatusBlock,
                         &BasicInformation,         //OUT PVOID FileInformation,
                         sizeof(BasicInformation),//IN ULONG Length,
                         FileBasicInformation      //IN FILE_INFORMATION_CLASS FileInformationClass
                         );

        LoudCallsDbgPrint("GetAttrContinueRR",
                                MiniFileObject,
                                0xa1,0,0,0,
                                Context->Status,IoStatusBlock.Information);

        Context->Attributes = BasicInformation.FileAttributes;
        NtClose(MiniFileObject->NtHandle);
    } else {
        Context->Status = CreateStatus;
    }
    return(STATUS_MORE_PROCESSING_REQUIRED);
}

ULONG  Nt5CscSetAttributesLocalCalls = 0;
int
SetAttributesLocal(
    LPSTR lpPath,
    ULONG uAttributes
    )
{
    PNT5CSC_MINIFILEOBJECT MiniFileObject;
    ULONG ShareAccess,CreateOptions;
    NT5CSC_ATTRIBS_CONTINUATION_CONTEXT Context;

    Nt5CscSetAttributesLocalCalls++;
    ShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    CreateOptions = FILE_SYNCHRONOUS_IO_NONALERT
                                    | FILE_NON_DIRECTORY_FILE;

    Context.Attributes = uAttributes;
    MiniFileObject =  Nt5CscCreateFile (
                          NULL, //make him allocate
                          lpPath,
                          FALSE,
                          FILE_ATTRIBUTE_NORMAL,
                          CreateOptions,
                          FILE_OPEN,  //disposition
                          ShareAccess,
                          FILE_WRITE_ATTRIBUTES|SYNCHRONIZE,
                          Nt5CscSetAttributesContinuation,
                          &Context  //Continuation
                          );

     if (Context.Status != STATUS_SUCCESS) {
          SetLastNtStatusLocal(Context.Status);
          return(-1);
     }

     return(STATUS_SUCCESS);
}

NTSTATUS
Nt5CscSetAttributesContinuation (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject,
    IN OUT PVOID ContinuationContext,
    IN     NTSTATUS CreateStatus
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInformation;
    PNT5CSC_ATTRIBS_CONTINUATION_CONTEXT Context
          = (PNT5CSC_ATTRIBS_CONTINUATION_CONTEXT)ContinuationContext;

    if (CreateStatus == STATUS_SUCCESS) {
        RtlZeroMemory(&BasicInformation,sizeof(BasicInformation));
        BasicInformation.FileAttributes = Context->Attributes;

        LoudCallsDbgPrint("SetAttrContinue",
                                MiniFileObject,
                                0xa1,0,0,0,0,0);

        Context->Status = ZwSetInformationFile(
                         MiniFileObject->NtHandle,  //IN HANDLE FileHandle,
                         &IoStatusBlock,            //OUT PIO_STATUS_BLOCK IoStatusBlock,
                         &BasicInformation,         //OUT PVOID FileInformation,
                         sizeof(BasicInformation),//IN ULONG Length,
                         FileBasicInformation      //IN FILE_INFORMATION_CLASS FileInformationClass
                         );

        LoudCallsDbgPrint("SetAttrContinueRR",
                                MiniFileObject,
                                0xa1,0,0,0,
                                Context->Status,IoStatusBlock.Information);

        NtClose(MiniFileObject->NtHandle);
    } else {
        Context->Status = CreateStatus;
    }
    return(STATUS_MORE_PROCESSING_REQUIRED);
}

ULONG  Nt5CscRenameLocalCalls = 0;
int
RenameFileLocal(
    LPSTR lpFrom,
    LPSTR lpTo
    )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    UNICODE_STRING RenameName;
    ANSI_STRING FileNameAsAnsiString;
    ULONG UnicodeLength;
    PFILE_RENAME_INFORMATION RenameInformation=NULL;
    ULONG RenameInfoBufferLength;

    PNT5CSC_MINIFILEOBJECT MiniFileObject;
    ULONG ShareAccess,CreateOptions;
    NT5CSC_ATTRIBS_CONTINUATION_CONTEXT Context;

    Nt5CscRenameLocalCalls++;
    //DbgPrint("here in rename %s %s\n",lpFrom,lpTo);
    //ASSERT(!"here in rename");

    RtlInitAnsiString(&FileNameAsAnsiString, lpTo);
    UnicodeLength = RtlAnsiStringToUnicodeSize(&FileNameAsAnsiString);
    if ( UnicodeLength > MAXUSHORT ) {
        Status = STATUS_NAME_TOO_LONG;
        goto FINALLY;
    }
    RenameName.MaximumLength = (USHORT)(UnicodeLength);
    RenameName.Length = RenameName.MaximumLength - sizeof(UNICODE_NULL);

    RenameInfoBufferLength = FIELD_OFFSET(FILE_RENAME_INFORMATION,FileName[0])
                                       + UnicodeLength; //already contains the null
    RenameInformation = (PFILE_RENAME_INFORMATION)RxAllocatePoolWithTag(
                                PagedPool | POOL_COLD_ALLOCATION,
                                RenameInfoBufferLength,
                                RX_MISC_POOLTAG);
    if (RenameInformation==NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY;
    }
    RenameInformation->ReplaceIfExists = TRUE;
    RenameInformation->RootDirectory = 0;
    RenameInformation->FileNameLength = RenameName.Length;
    RenameName.Buffer = &RenameInformation->FileName[0];
    Status = RtlAnsiStringToUnicodeString(
                &RenameName,
                &FileNameAsAnsiString,
                FALSE //this says don't allocate the string
                );
    if (Status!=STATUS_SUCCESS) {
        goto FINALLY;
    }

    RxDbgTrace( 0, Dbg, ("rename: file %s %wZ\n",lpFrom,&RenameName));
    //DbgPrint("rename: file %s %wZ\n",lpFrom,&RenameName);

    ShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    CreateOptions = FILE_SYNCHRONOUS_IO_NONALERT
                                    | FILE_NON_DIRECTORY_FILE;

    Context.RenameInformation = RenameInformation;
    Context.RenameInfoBufferLength = RenameInfoBufferLength;
    MiniFileObject =  Nt5CscCreateFile (
                          NULL, //make him allocate
                          lpFrom,
                          FALSE,
                          FILE_ATTRIBUTE_NORMAL,
                          CreateOptions,
                          FILE_OPEN,  //disposition
                          ShareAccess,
                          DELETE | SYNCHRONIZE,  //DesiredAccess,
                          Nt5CscRenameContinuation,
                          &Context  //Continuation
                          );
    Status = Context.Status;
    if (Status!=STATUS_SUCCESS) {
        DbgPrint("rename didn't work....%08lx,%08lx,%08lx\n",
                      Status,RenameInformation,RenameInfoBufferLength);
    }

FINALLY:
     if (RenameInformation != NULL) {
          RxFreePool(RenameInformation);
     }

     if (Status != STATUS_SUCCESS) {
          return(-1);
     }

     return(STATUS_SUCCESS);
}

NTSTATUS
Nt5CscRenameContinuation (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject,
    IN OUT PVOID ContinuationContext,
    IN     NTSTATUS CreateStatus
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    PNT5CSC_ATTRIBS_CONTINUATION_CONTEXT Context
          = (PNT5CSC_ATTRIBS_CONTINUATION_CONTEXT)ContinuationContext;

    if (CreateStatus == STATUS_SUCCESS) {

        LoudCallsDbgPrint("Rename",
                                MiniFileObject,
                                0xa1,0,0,0,0,0);

        Context->Status = ZwSetInformationFile(
                         MiniFileObject->NtHandle,  //IN HANDLE FileHandle,
                         &IoStatusBlock,            //OUT PIO_STATUS_BLOCK IoStatusBlock,
                         Context->RenameInformation,         //OUT PVOID FileInformation,
                         Context->RenameInfoBufferLength,//IN ULONG Length,
                         FileRenameInformation      //IN FILE_INFORMATION_CLASS FileInformationClass
                         );

        LoudCallsDbgPrint("RenameRR",
                                MiniFileObject,
                                0xa1,0,0,0,
                                Context->Status,IoStatusBlock.Information);

        NtClose(MiniFileObject->NtHandle);
    } else {
        Context->Status = CreateStatus;
    }
    return(STATUS_MORE_PROCESSING_REQUIRED);
}

//=======================================================================================================
ULONG Nt5CscDeleteLocalCalls = 0;
int
DeleteFileLocal(
    LPSTR lpName,
    USHORT usAttrib
    )
{
    PNT5CSC_MINIFILEOBJECT MiniFileObject;
    ULONG ShareAccess,CreateOptions;
    NT5CSC_ATTRIBS_CONTINUATION_CONTEXT Context;

    Nt5CscDeleteLocalCalls++;
    ShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    CreateOptions = FILE_SYNCHRONOUS_IO_NONALERT;

    MiniFileObject =  Nt5CscCreateFile (
                          NULL, //make him allocate
                          lpName,
                          FALSE,
                          FILE_ATTRIBUTE_NORMAL,
                          CreateOptions,
                          FILE_OPEN,  //disposition
                          ShareAccess,
                          DELETE,  //DesiredAccess,
                          Nt5CscDeleteContinuation,
                          &Context  //Continuation
                          );

     if (Context.Status != STATUS_SUCCESS) {
          SetLastNtStatusLocal(Context.Status);
          return((Context.Status | 0x80000000)); // just so this becomes -ve
     }

     return(STATUS_SUCCESS);
}

NTSTATUS
Nt5CscDeleteContinuation (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject,
    IN OUT PVOID ContinuationContext,
    IN     NTSTATUS CreateStatus
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_DISPOSITION_INFORMATION DispositionInformation;
    PNT5CSC_ATTRIBS_CONTINUATION_CONTEXT Context
          = (PNT5CSC_ATTRIBS_CONTINUATION_CONTEXT)ContinuationContext;

    if (CreateStatus == STATUS_SUCCESS) {
        DispositionInformation.DeleteFile = TRUE;

        LoudCallsDbgPrint("Delete",
                                MiniFileObject,
                                0xa1,0,0,0,0,0);

        Context->Status = ZwSetInformationFile(
                         MiniFileObject->NtHandle,  //IN HANDLE FileHandle,
                         &IoStatusBlock,            //OUT PIO_STATUS_BLOCK IoStatusBlock,
                         &DispositionInformation,         //OUT PVOID FileInformation,
                         sizeof(DispositionInformation),//IN ULONG Length,
                         FileDispositionInformation      //IN FILE_INFORMATION_CLASS FileInformationClass
                         );

        if (Context->Status!=STATUS_SUCCESS) {
          DbgPrint("DeleteBad %08lx %08lx %08lx\n",
                                MiniFileObject,
                                Context->Status,IoStatusBlock.Information);
        }

        LoudCallsDbgPrint("DeleteRR",
                                MiniFileObject,
                                0xa1,0,0,0,
                                Context->Status,IoStatusBlock.Information);

        NtClose(MiniFileObject->NtHandle);
    } else {
        Context->Status = CreateStatus;
    }
    return(STATUS_MORE_PROCESSING_REQUIRED);
}

int
CreateDirectoryLocal(
    LPSTR   lpPath
    )
{

    PNT5CSC_MINIFILEOBJECT MiniFileObject;

    MiniFileObject =  Nt5CscCreateFile (
                         NULL, //make him allocate
                         lpPath,
                         FALSE,
                         FILE_ATTRIBUTE_NORMAL,
                         FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE,
                         FILE_OPEN_IF,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         GENERIC_READ | GENERIC_WRITE,
                         NULL,NULL  //Continuation
                         );


    if (MiniFileObject)
    {
        CloseFileLocal((CSCHFILE)MiniFileObject);
        return 0;
    }

    return -1;
}


CSCHFILE
FindFirstFileLocal(
    LPSTR   lpPath,
    _WIN32_FIND_DATAA   *lpFind32A
    )
{

    PNT5CSC_MINIFILEOBJECT MiniFileObject;

    MiniFileObject =  Nt5CscCreateFile (
                         NULL, //make him allocate
                         lpPath,
                         FALSE,
                         FILE_ATTRIBUTE_NORMAL,
                         FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE,
                         FILE_OPEN,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         GENERIC_READ | GENERIC_WRITE,
                         NULL,NULL  //Continuation
                         );


    if (MiniFileObject)
    {
        if (FindNextFileLocal(MiniFileObject, lpFind32A) < 0)
        {
            CloseFileLocal(MiniFileObject);
            MiniFileObject = NULL;
        }
    }
    return MiniFileObject;
}



int
FindNextFileLocal(
    CSCHFILE handle,
    _WIN32_FIND_DATAA   *lpFind32A
    )
{
    NTSTATUS Status;
    PNT5CSC_MINIFILEOBJECT MiniFileObject = (PNT5CSC_MINIFILEOBJECT)handle;
    PIRP irp,TopIrp;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT FileObject;
    NT5CSC_IRPCOMPLETION_CONTEXT IrpCompletionContext;
    ULONG ReturnedLength, MdlLength,Length;
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;
    IO_STATUS_BLOCK IoStatusBlock;

    IoStatusBlock.Information = 0;

    ASSERT (MiniFileObject);
    ASSERT_MINIRDRFILEOBJECT(MiniFileObject);

    FileObject = MiniFileObject->UnderlyingFileObject;
    ASSERT (FileObject);

    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    ASSERT (DeviceObject);

    if (DeviceObject->Flags & DO_BUFFERED_IO) {
        //i cannot handle buffered_io devices....sigh
        SetLastNtStatusLocal(STATUS_INVALID_DEVICE_REQUEST);
        return -1;
    }

    irp = IoAllocateIrp( DeviceObject->StackSize, FALSE ); //why not charge???

    if (!irp) {
        SetLastNtStatusLocal(STATUS_INSUFFICIENT_RESOURCES);
        return -1;
    }

    // get info for win32 find data

    MdlLength = Length = sizeof(FILE_BOTH_DIR_INFORMATION)+ sizeof(WCHAR) * (MAX_PATH+1);
    DirectoryInfo = (PFILE_BOTH_DIR_INFORMATION)RxAllocatePoolWithTag(NonPagedPool, Length, RX_MISC_POOLTAG);

    if (!DirectoryInfo)
    {
        IoFreeIrp(irp);
        SetLastNtStatusLocal(STATUS_INSUFFICIENT_RESOURCES);
        return -1;

    }

    // Set current thread for IoSetHardErrorOrVerifyDevice.
    //

    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and the parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation( irp );  //ok4ioget
    irpSp->MajorFunction = IRP_MJ_DIRECTORY_CONTROL;
    irpSp->MinorFunction = IRP_MN_QUERY_DIRECTORY;
    irpSp->FileObject = FileObject;            //ok4->FileObj
    IoSetCompletionRoutine(irp,
                           Nt5CscIrpCompletionRoutine,
                           &IrpCompletionContext,
                           TRUE,TRUE,TRUE); //call no matter what....

    irp->RequestorMode = KernelMode;
    irp->UserBuffer = DirectoryInfo;
    irpSp->Parameters.QueryDirectory.Length = Length;
    irpSp->Parameters.QueryDirectory.FileInformationClass = FileBothDirectoryInformation;
    irpSp->Parameters.QueryDirectory.FileIndex = 0;
    irpSp->Parameters.QueryDirectory.FileName = NULL;
    irpSp->Flags = SL_RETURN_SINGLE_ENTRY;

    irp->MdlAddress = IoAllocateMdl(
                         irp->UserBuffer,
                         MdlLength,
                         FALSE,FALSE,NULL);

    if (!irp->MdlAddress) {
        //whoops.......sorry..........
        IoFreeIrp(irp);
        RxFreePool(DirectoryInfo);
        SetLastNtStatusLocal(STATUS_INSUFFICIENT_RESOURCES);
        return(-1);
    }

    Status = STATUS_SUCCESS;

    MmBuildMdlForNonPagedPool(irp->MdlAddress);

    if (Status != STATUS_SUCCESS)
    {
        IoFreeIrp(irp);
        RxFreePool(DirectoryInfo);
        SetLastNtStatusLocal(Status);
        return(-1);
    }


    KeInitializeEvent(&IrpCompletionContext.Event,
                      NotificationEvent,
                      FALSE );

    //
    try {
        TopIrp = IoGetTopLevelIrp();
        IoSetTopLevelIrp(NULL); //tell the underlying guy he's all clear
        Status = IoCallDriver(DeviceObject,irp);
    } finally {
        IoSetTopLevelIrp(TopIrp); //restore my context for unwind
    }

    //RxDbgTrace (0, Dbg, ("  -->Status after iocalldriver %08lx(%08lx)\n",RxContext,Status));

    if (Status == (STATUS_PENDING)) {
        KeWaitForSingleObject( &IrpCompletionContext.Event,
                               Executive, KernelMode, FALSE, NULL );
        Status = irp->IoStatus.Status;
    }

    ReturnedLength = (ULONG)irp->IoStatus.Information;

    IoFreeMdl(irp->MdlAddress);
    IoFreeIrp(irp);
    if (Status==STATUS_SUCCESS) {

        // Attributes are composed of the attributes returned by NT.
        //

        lpFind32A->dwFileAttributes = DirectoryInfo->FileAttributes;
        lpFind32A->ftCreationTime = *(LPFILETIME)&DirectoryInfo->CreationTime;
        lpFind32A->ftLastAccessTime = *(LPFILETIME)&DirectoryInfo->LastAccessTime;
        lpFind32A->ftLastWriteTime = *(LPFILETIME)&DirectoryInfo->LastWriteTime;
        lpFind32A->nFileSizeHigh = DirectoryInfo->EndOfFile.HighPart;
        lpFind32A->nFileSizeLow = DirectoryInfo->EndOfFile.LowPart;
        lpFind32A->cAlternateFileName[0] = 0;
        lpFind32A->cFileName[0] = 0;



        Status = RtlUnicodeToOemN(
                        lpFind32A->cAlternateFileName,            //OUT PCH OemString,
                        sizeof(lpFind32A->cAlternateFileName),    //IN ULONG MaxBytesInOemString,
                        &ReturnedLength, //OUT PULONG BytesInOemString OPTIONAL,
                        DirectoryInfo->ShortName,            //IN PWCH UnicodeString,
                        DirectoryInfo->ShortNameLength    //IN ULONG BytesInUnicodeString
                        );
        if (Status == STATUS_SUCCESS)
        {
            lpFind32A->cAlternateFileName[ReturnedLength] = 0;
        }



        Status = RtlUnicodeToOemN(
                        lpFind32A->cFileName,            //OUT PCH OemString,
                        sizeof(lpFind32A->cFileName)-1,    //IN ULONG MaxBytesInOemString,
                        &ReturnedLength, //OUT PULONG BytesInOemString OPTIONAL,
                        DirectoryInfo->FileName,            //IN PWCH UnicodeString,
                        DirectoryInfo->FileNameLength    //IN ULONG BytesInUnicodeString
                        );

        if (Status == STATUS_SUCCESS)
        {
            lpFind32A->cFileName[ReturnedLength] = 0;
        }

        RxFreePool(DirectoryInfo);
        return(1);

    }
    else {
        RxFreePool(DirectoryInfo);
        SetLastNtStatusLocal(Status);
        return(-1);
    }
}


int
FindCloseLocal(
    CSCHFILE handle
    )
{
    CloseFileLocal(handle);
    return 1;
}

DWORD
GetLastErrorLocal(
    VOID
    )
{
    return(vGlobalWin32Error);
}

VOID
SetLastErrorLocal(
    DWORD   dwError
    )
{
    vGlobalWin32Error = dwError;
}

VOID
SetLastNtStatusLocal(
    NTSTATUS    Status
    )
{
    vGlobalWin32Error = RtlNtStatusToDosErrorNoTeb(Status);
}


#ifdef MRXSMBCSC_LOUDDOWNCALLS

VOID
LoudCallsDbgPrint(
    PSZ Tag,
    PNT5CSC_MINIFILEOBJECT MiniFileObject,
    ULONG MajorFunction,
    ULONG lCount,
    ULONG LowPart,
    ULONG HighPart,
    ULONG Status,
    ULONG Information
    )
{
    PCHAR op = "***";
    BOOLEAN Chase = TRUE;
    PFILE_OBJECT FileObject = MiniFileObject->UnderlyingFileObject;
    PSECTION_OBJECT_POINTERS SecObjPtrs;
    PULONG SharedCacheMap;

    if(!FlagOn(MiniFileObject->Flags,NT5CSC_MINIFOBJ_FLAG_LOUDDOWNCALLS)) {
        return;
    }

    switch (MajorFunction) {
    case IRP_MJ_READ:  op = "READ"; break;
    case IRP_MJ_WRITE:  op = "WRITE"; break;
    case IRP_MJ_QUERY_INFORMATION:  op = "QryInfo"; break;
    case IRP_MJ_SET_INFORMATION:  op = "SetInfo"; break;
    case 0xff:  op = "SPECIALWRITE"; break;
    default: Chase = FALSE;
    }

    DbgPrint("%s %s(%x) h=%lx[%lx]  %lx@%lx:%lx  st %x:%x\n",
                        Tag,op,MajorFunction,
                        MiniFileObject->NtHandle,
                        MiniFileObject->UnderlyingFileObject,
                        lCount,
                        LowPart,
                        HighPart,
                        Status,
                        Information
                        );
    if (!Chase) {
        return;
    }

    SecObjPtrs = FileObject->SectionObjectPointer;
    if (SecObjPtrs==NULL) {
        DbgPrint("       No SecObjPtrs\n");
        return;
    }

    SharedCacheMap = (PULONG)(SecObjPtrs->SharedCacheMap);
    if (SharedCacheMap==NULL) {
        DbgPrint("       No SharedCacheMap\n");
        return;
    }
    DbgPrint("       size per sharedcachemap %08lx %08lx\n",*(SharedCacheMap+2),*(SharedCacheMap+3));
}

#endif //ifdef MRXSMBCSC_LOUDDOWNCALLS

BOOL
CscAmIAdmin(
    VOID
    )
/*++

Routine Description:

    This routine checks to see whether the caller is in the admin group
    all the files in the database.

Notes:

    We check the access_rights of the caller against CscSecurityDescriptor, which gives WRITE access
    only to principals in the admin group.
    The caller must impersonate in order to make sure he is in the right context

--*/
{
    NTSTATUS                 status;
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    ACCESS_MASK              GrantedAccess;
    GENERIC_MAPPING          Mapping = {   FILE_GENERIC_READ,
                                           FILE_GENERIC_WRITE,
                                           FILE_GENERIC_EXECUTE,
                                           FILE_ALL_ACCESS
                                       };
    BOOLEAN                  retval  = FALSE;
    
    SeCaptureSubjectContext( &SubjectContext );

    retval = SeAccessCheck( CscSecurityDescriptor,
                            &SubjectContext,
                            FALSE,
                            FILE_GENERIC_WRITE,
                            0,
                            NULL,
                            &Mapping,
                            UserMode,
                            &GrantedAccess,
                            &status );

    SeReleaseSubjectContext( &SubjectContext );
    return retval;
    
}

BOOL
GetFileSystemAttributes(
    CSCHFILE handle,
    ULONG *lpFileSystemAttributes
    )
/*++

Routine Description:

    This API returns the attributes of the filesystem for the file handle. This is the way various
    features such as stream bitmaps, encryption etc. be checked

Notes:


--*/
{
    FILE_FS_ATTRIBUTE_INFORMATION fsAttribInfo;
    DWORD returnLen;
    NTSTATUS Status;
    BOOL    fRet = TRUE;
    
    // Check if volume is NTFS and hence support
    // multiple streams
    Status = Nt5CscXxxInformation(
                        (PCHAR)IRP_MJ_QUERY_VOLUME_INFORMATION,
                        (PNT5CSC_MINIFILEOBJECT)handle,
                        FileFsAttributeInformation,
                        sizeof(FILE_FS_ATTRIBUTE_INFORMATION),
                        &fsAttribInfo,
                        &returnLen);

    if (!NT_ERROR(Status)) {
        *lpFileSystemAttributes = fsAttribInfo.FileSystemAttributes;
    }
    else
    {
        SetLastNtStatusLocal(Status);
        fRet = FALSE;
    }
    
    return fRet;    
}

BOOL
HasStreamSupport(
    CSCHFILE handle,
    BOOL    *lpfResult
    )
/*++

Routine Description:


Notes:


--*/
{
    ULONG ulFsAttributes;

    if (GetFileSystemAttributes(handle, &ulFsAttributes))
    {
        *lpfResult =  ((ulFsAttributes & FILE_NAMED_STREAMS) != 0);
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\bmreclib\oslayeru.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

     OsLayerU.c

Abstract:

     Implementation of the OsLayer that interfaces to ARC so that setup loader and
     ntldr can retrieve files from the local CSC if available.

Author:

     Colin Watson      [ColinW]        11-05-1997

Revision History:


--*/

#pragma hdrstop
#include <ntos.h>
#include <arccodes.h>
#include <bldr.h>

#define  PUBLIC
typedef int             BOOL;
typedef void            *LPVOID;
typedef unsigned long   DWORD;
typedef struct  _FILETIME{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
}   FILETIME;


typedef  ULONG  HSERVER;
typedef  ULONG  HSHADOW;
typedef  ULONG  HSHARE;

#include <oslayeru.h>

/********************** global data *****************************************/


//
//  In an attempt to avoid opening the disk device all the time we share the handle
//  with netboot.c if there is one.
//

extern ULONG NetBootDiskId;

DWORD    dwDebugLogVector;
AssertData;
AssertError;
/********************** function prototypes *********************************/

/****************************************************************************/

/************************ File I/O ******************************************/


CSCHFILE
R0OpenFileEx(
    USHORT  usOpenFlags,
    UCHAR   bAction,
    ULONG   ulAttr,
    LPSTR   lpPath,
    BOOL    fInstrument
    )
{
    ULONG hf;
    DWORD status;

    ASSERT( (usOpenFlags & 0xf) == ACCESS_READWRITE);

    if (!NetBootDiskId) {
        return (CSCHFILE)NULL;
    }

    //
    // Don't ever create the database or allow it to be modified since this would mean
    // the OS would not know to repin all the files.
    //

    status = BlOpen(NetBootDiskId, lpPath, ArcOpenReadOnly, &hf);

    if (status != ESUCCESS) {
        return (CSCHFILE)NULL;
    }
    return (CSCHFILE)hf;
}

CSCHFILE
CreateFileLocal(
    LPSTR lpFile
    )
{
    return R0OpenFileEx( ACCESS_READWRITE, ACTION_CREATEALWAYS, FILE_ATTRIBUTE_NORMAL, lpFile, FALSE);
}

CSCHFILE
OpenFileLocal(
    LPSTR lpFile
    )
{
    return R0OpenFileEx( ACCESS_READWRITE, ACTION_OPENEXISTING, FILE_ATTRIBUTE_NORMAL, lpFile, FALSE);
}

ULONG
CloseFileLocal(
    CSCHFILE hf
    )
{
    BlClose((ULONG)((ULONG_PTR)hf));
    return (1);
}


long
ReadFileLocal(
    CSCHFILE hf,
    unsigned long lSeek,
    LPVOID    lpBuff,
    long    cLength
    )
{
    ULONG dwBytesRead;
    ARC_STATUS status;

    LARGE_INTEGER seekValue;

    seekValue.QuadPart = lSeek;

    status = ArcSeek((ULONG)((ULONG_PTR)hf), &seekValue, SeekAbsolute);
    if (status==ESUCCESS) {
        status = ArcRead((ULONG)((ULONG_PTR)hf),
                         (VOID * POINTER_32)lpBuff,
                         cLength,
                         (ULONG * POINTER_32)&dwBytesRead);
        if (status==ESUCCESS) {
            return dwBytesRead;
        }
    }
    return (-1);
}

long
ReadFileLocalEx(
    CSCHFILE      hf,
    unsigned    long lSeek,
    LPVOID      lpBuff,
    long         cLength,
    BOOL        fInstrument
    )
{
    return ReadFileLocal(hf,lSeek,lpBuff,cLength);
}

long
ReadFileLocalEx2(
    CSCHFILE      hf,
    unsigned    long lSeek,
    LPVOID      lpBuff,
    long         cLength,
    ULONG       flags
    )
{
    return ReadFileLocalEx(hf, lSeek, lpBuff, cLength, FALSE);
}

long
WriteFileLocal(
    CSCHFILE hf,
    unsigned long lSeek,
    LPVOID    lpBuff,
    long    cLength
    )
{
    return (-1);
}

long WriteFileLocalEx(
    CSCHFILE hf,
    unsigned long lSeek,
    LPVOID    lpBuff,
    long    cLength,
    BOOL    fInstrument
    )
{
    fInstrument;
    return(WriteFileLocal(hf, lSeek, lpBuff, cLength));
}

long
WriteFileLocalEx2(
    CSCHFILE      hf,
    unsigned    long lSeek,
    LPVOID      lpBuff,
    long         cLength,
    ULONG       flags
    )
{
    return WriteFileLocalEx(hf, lSeek, lpBuff, cLength, FALSE);
}

CSCHFILE
OpenFileLocalEx(
    LPSTR lpPath,
    BOOL fInstrument
    )
{
    return(R0OpenFileEx(ACCESS_READWRITE, ACTION_OPENEXISTING, FILE_ATTRIBUTE_NORMAL, lpPath, fInstrument));
}


int
FileExists(
    LPSTR lpPath
    )
{
    CSCHFILE hf;
    hf = R0OpenFileEx(ACCESS_READWRITE, ACTION_OPENEXISTING, FILE_ATTRIBUTE_NORMAL, lpPath, FALSE);
    if ((ULONG)((ULONG_PTR)hf) != -1) {
        BlClose((ULONG)((ULONG_PTR)hf));
        return TRUE;
    }
    return FALSE;
}


int
GetFileSizeLocal
    (
    CSCHFILE handle,
    PULONG lpuSize
    )
{
    return (-1);
}

int
RenameFileLocal(
    LPSTR lpFrom,
    LPSTR lpTo
    )
{
    return -1;
}

int
DeleteFileLocal
    (
    LPSTR lpName,
    USHORT usAttrib
    )
{
    return(-1);
}

int
GetDiskFreeSpaceLocal(
    int indx,
    ULONG *lpuSectorsPerCluster,
    ULONG *lpuBytesPerSector,
    ULONG *lpuFreeClusters,
    ULONG *lpuTotalClusters
    )
{
    return (-1);
}

int
FileLockLocal(
    CSCHFILE hf,
    ULONG offsetLock,
    ULONG lengthLock,
    ULONG idProcess,
    BOOL  fLock
    )
{
    return (-1);
}

/*************************** Utility Functions ******************************/

LPVOID
AllocMem(
    ULONG uSize
    )
{
    return BlAllocateHeap(uSize);

}

VOID
FreeMem(
    LPVOID lp
    )
{
}

LPVOID
AllocMemPaged(
    ULONG uSize
    )
{
    return BlAllocateHeap(uSize);
}

VOID FreeMemPaged(
    LPVOID lp
    )
{
}

int GetAttributesLocal(
    LPSTR lpName,
    ULONG *lpuAttr
    )
{
    return -1;
}

int GetAttributesLocalEx
    (
    LPSTR   lpPath,
    BOOL    fFile,
    ULONG   *lpuAttributes
    )
{
    return (GetAttributesLocal(lpPath, lpuAttributes));
}

int
SetAttributesLocal (
    LPSTR lpName,
    ULONG uAttr
    )
{
    return -1;
}

CSCHFILE R0OpenFile (
    USHORT usOpenFlags,
    UCHAR bAction,
    LPSTR lpPath)
{
    return (R0OpenFileEx(usOpenFlags, bAction, FILE_ATTRIBUTE_NORMAL, lpPath, FALSE));
}

int CreateDirectoryLocal(
    LPSTR   lpszPath
    )
{
    return -1;
}
int wstrnicmp(
    const USHORT *pStr1,
    const USHORT *pStr2,
    ULONG count
)
{
    USHORT c1, c2;
    int iRet;
    ULONG i=0;

    for(;;)
     {
        c1 = *pStr1++;
        c2 = *pStr2++;
        c1 = towupper(c1);
        c2 = towupper(c2);
        if (c1!=c2)
            break;
        if (!c1)
            break;
        i+=2;
        if (i >= count)
            break;
     }
    iRet = ((c1 > c2)?1:((c1==c2)?0:-1));
    return iRet;
}

ULONG
GetTimeInSecondsSince1970(
    VOID
    )
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\bmreclib\osutils.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

     Utils.c

Abstract:

     none.

Author:

     Shishir Pardikar      [Shishirp]        01-jan-1995

--*/

#include "precomp.h"
#pragma hdrstop

#define  SIGN_BIT 0x80000000
#define  UCHAR_OFFLINE  ((USHORT)'_')
#define  HIGH_ONE_SEC    0x98
#define  LOW_ONE_SEC     0x9680

#pragma intrinsic (memcmp, memcpy, memset, strcat, strcmp, strcpy, strlen)
#define cBackSlash    '\\'
#define cNull          0

AssertData
AssertError

int HexToA(
     ULONG ulHex,
     LPSTR lpName,
     int count
     )
{
    int i;
    LPSTR lp = lpName+count-1;
    UCHAR uch;

    for (i=0; i<count; ++i)
     {
         uch = (UCHAR)(ulHex & 0xf) + '0';
         if (uch > '9')
               uch += 7;     // A becomes '0' + A + 7 which is 'A'
         *lp = uch;
         --lp;
         ulHex >>= 4;
     }
    *(lpName+count) = cNull;
    return 0;
}


ULONG AtoHex(
     LPSTR lpStr,
     int count
)
{
     int i;
     LPSTR lp = lpStr;
     UCHAR uch;
     ULONG ulHex = 0L;

     for (i=0; i<count; ++i)
      {
          uch = *lp;
          if (uch>= '0' && uch <= '9')
                ulHex += (uch - '0');
          else if (uch >= 'A' && uch <= 'F')
                ulHex += (uch - '0' - 7);
          else
                break;
          ++lp;
          ulHex <<= 4;
      }
     return ulHex;
 }


ULONG strmcpy( LPSTR lpDst,
        LPSTR lpSrc,
     ULONG cTchar
     )
 {
     ULONG i;

     if (!cTchar)
          return 0;
     for(i=cTchar;i;--i)
          if (!(*lpDst++ = *lpSrc++))
                                                     break;
     lpDst[cTchar-i] ='\0';

     return(cTchar-i);
 }

ULONG wstrlen(
     USHORT *lpuStr
     )
 {
     ULONG i;

     for (i=0; *lpuStr; ++lpuStr, ++i);
     return (i);
 }

int CompareSize(
     long nHighDst,
     long nLowDst,
     long nHighSrc,
     long nLowSrc
     )
 {
     int iRet = 0;

     if (nHighDst > nHighSrc)
          iRet = 1;
     else if (nHighDst == nHighSrc)
      {
          if (nLowDst > nLowSrc)
                iRet = 1;
          else if (nLowDst == nLowSrc)
                iRet = 0;
          else
                iRet = -1;
      }
     else
          iRet = -1;
     return (iRet);
 }


LPSTR mystrpbrk(
     LPSTR lpSrc,
     LPSTR lpDelim
     )
{
    char c, c1;
    LPSTR lpSav;
    BOOL fBegin = FALSE;

 for(;c = *lpSrc; ++lpSrc)
     {
         // skip leading blanks
         if (!fBegin)
           {
               if (c==' ')
                    continue;
               else
                    fBegin = TRUE;
           }

         lpSav = lpDelim;
         while (c1 = *lpDelim++)
           {
               if (c==c1)
                    return (lpSrc);
           }
         lpDelim = lpSav;
     }
    return (NULL);
}

LPVOID mymemmove(
     LPVOID     lpDst,
     LPVOID     lpSrc,
     ULONG size
     )
{
    int i;

    if (!size)
         return (lpDst);

    // if lpDst does not fall within the source array, just do memcpy
    if (!(
                ( lpDst > lpSrc )
                    && ( ((LPBYTE)lpDst) < ((LPBYTE)lpSrc)+size )     ))
     {
         memcpy(lpDst, lpSrc, size);
     }
    else
     {
         // do reverse copy
         for (i=size-1;i>=0;--i)
           {
               *((LPBYTE)lpDst+i) = *((LPBYTE)lpSrc+i);
           }
     }
    return (lpDst);
}


VOID
IncrementFileTime(
     FILETIME *lpft
    )
{
    DWORD dwTemp = lpft->dwLowDateTime;

    ++lpft->dwLowDateTime;

    // if it rolled over, there was a carry
    if (lpft->dwLowDateTime < dwTemp)
         lpft->dwHighDateTime++;

}
#ifdef DBG
VOID AssertFn(PCHAR lpMsg, PCHAR lpFile, ULONG uLine)
{

    DbgPrint("Line %u file %s", uLine, lpFile);
    DbgBreakPoint();
}
#endif
int CompareTimes(
    FILETIME ftDst,
    FILETIME ftSrc
   )
{
    int iRet = 0;

    if (ftDst.dwHighDateTime > ftSrc.dwHighDateTime)
        iRet = 1;
    else if (ftDst.dwHighDateTime == ftSrc.dwHighDateTime)
    {
        if (ftDst.dwLowDateTime > ftSrc.dwLowDateTime)
            iRet = 1;
        else if (ftDst.dwLowDateTime == ftSrc.dwLowDateTime)
            iRet = 0;
        else
            iRet = -1;
    }
    else
        iRet = -1;
    return (iRet);
}


int DosToWin32FileSize( unsigned long uDosFileSize,
   int *lpnFileSizeHigh,
   int *lpnFileSizeLow
   )
   {
   int iRet;

   if (uDosFileSize & SIGN_BIT)
      {
      *lpnFileSizeHigh = 1;
      *lpnFileSizeLow = uDosFileSize & SIGN_BIT;
      iRet = 1;
      }
   else
      {
      *lpnFileSizeHigh = 0;
      *lpnFileSizeLow = uDosFileSize;
      iRet = 0;
      }
   return (iRet);
   }

int Win32ToDosFileSize( int nFileSizeHigh,
   int nFileSizeLow,
   unsigned long *lpuDosFileSize
   )
   {
   int iRet;
   Assert(nFileSizeHigh <= 1);
   *lpuDosFileSize = nFileSizeLow;
   if (nFileSizeHigh == 1)
      {
      *lpuDosFileSize += SIGN_BIT;
      iRet = 1;
      }
   else
      iRet = 0;
   return (iRet);
   }

int
PUBLIC
mystrnicmp(
    const char *pStr1,
    const char *pStr2,
    unsigned count
    )
{
    char c1, c2;
    int iRet;
    unsigned i=0;

    for(;;)
    {
        c1 = *pStr1++;
        c2 = *pStr2++;
        c1 = _toupper(c1);
        c2 = _toupper(c2);
        if (c1!=c2)
            break;
        if (!c1)
            break;
        if (++i >= count)
            break;
    }
    iRet = ((c1 > c2)?1:((c1==c2)?0:-1));
    return iRet;
}

int ShadowLog(
    LPSTR lpFmt,
    ...
    )
{
    return (0);
}

int TerminateShadowLog(VOID)
{
    return 0;
}

BOOL
IterateOnUNCPathElements(
    USHORT  *lpuPath,
    PATHPROC lpfn,
    LPVOID  lpCookie
    )
/*++

Routine Description:

    This routine takes a unicode UNC path and iterates over each path element, calling the
    callback function. Thus for a path \\server\share\dir1\dir2\file1.txt, the function makes
    the following calls to the lpfn callback function

    (lpfn)(\\server\share, \\server\share, lpCookie)
    (lpfn)(\\server\share\dir1, dir1, lpCookie)
    (lpfn)(\\server\share\dir1\dir2, dir2, lpCookie)
    (lpfn)(\\server\share\dir1\dir2\file1, file1, lpCookie)

Arguments:

    lpuPath     NULL terminated unicode string (NOT NT style, just a plain unicode string)

    lpfn        callback function. If the function returns TRUE on a callback, the iteration
                proceeds, else it terminates

    lpCookie    context passed back on each callback

Returns:

    return TRUE if the entire iteration went through, FALSE if some error occurred or the callback
    function terminated the iteration

Notes:


--*/
{
    int cnt, cntSlashes=0, cbSize;
    USHORT  *lpuT, *lpuLastElement = NULL, *lpuCopy = NULL;
    BOOL    fRet = FALSE;

//    DEBUG_PRINT(("InterateOnUNCPathElements:Path on entry =%ws\r\n", lpuPath));

    if (!lpuPath || ((cnt = wstrlen(lpuPath)) <= 3))
    {
        return FALSE;
    }

    // check for the first two backslashes
    if (!(*lpuPath == (USHORT)'\\') && (*(lpuPath+1) == (USHORT)'\\'))
    {
        return FALSE;
    }

    // ensure that the server field is not NULL
    if (*(lpuPath+2) == (USHORT)'\\')
    {
        return FALSE;
    }

    cbSize = (wstrlen(lpuPath)+1) * sizeof(USHORT);

    lpuCopy = (USHORT *)AllocMem(cbSize);

    if (!lpuCopy)
    {
        return FALSE;
    }

    memcpy(lpuCopy, lpuPath, cbSize);

    cntSlashes = 2;

    lpuLastElement = lpuCopy;

    for (lpuT= lpuCopy+2;; ++lpuT)
    {
        if (*lpuT == (USHORT)'\\')
        {
            BOOL fContinue;

            ++cntSlashes;

            if (cntSlashes == 3)
            {
                if (lpuT == (lpuCopy+2))
                {
                    goto bailout;
                }

                continue;
            }

            *lpuT = 0;

            fContinue = (lpfn)(lpuCopy, lpuLastElement, lpCookie);

            *lpuT = (USHORT)'\\';

            if (!fContinue)
            {
                goto bailout;
            }

            lpuLastElement = (lpuT+1);
        }
        else if (!*lpuT)
        {
            fRet = (lpfn)(lpuCopy, lpuLastElement, lpCookie);
            break;
        }
    }

bailout:

    if (lpuCopy)
    {
        FreeMem(lpuCopy);
    }
    return (fRet);
}

BOOL
IsPathUNC(
    USHORT      *lpuPath,
    int         cntMaxChars
    )
{
    USHORT *lpuT;
    int i, cntSlash=0;
    BOOL    fRet = FALSE;

    for(lpuT = lpuPath, i=0; (i < cntMaxChars) && *lpuT; lpuT++, ++i)
    {
        if (cntSlash <= 1)
        {
            // look for the first two backslashes
            if (*lpuT != (USHORT)'\\')
            {
                break;
            }

            ++cntSlash;
        }
        else if (cntSlash == 2)
        {
            // look for the 3rd one
            if (*lpuT == (USHORT)'\\')
            {
                if ((DWORD)(lpuT - lpuPath) < 3)
                {
                    // NULL server field
                    break;
                }
                else
                {
                    ++cntSlash;
                }
            }
        }
        else    // all three slashes accounted for
        {
            Assert(cntSlash == 3);

            // if a non-slash character, then this path is OK
            fRet = (*lpuT != (USHORT)'\\');
            break;
        }
    }
    return (fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\daytona\nullincs.tmp\error.h ===
//null .h file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\daytona\nullincs.tmp\shell.h ===
//null .h file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\daytona\ifsmgr.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ifsmgr.c

Abstract:

    this file contains routine to simulate the ifsmgr environment for the purposes
    of using the same record manager interface on nt and win95.

Author:

    Joe Linn             [JoeLinn]       31-jan-97

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

unsigned int  _cdecl UniToBCS(
                    unsigned char   *pStr,
                    string_t        pUni,
                    unsigned int    length,
                    unsigned int    maxLength,
                    unsigned int    charSet)
/*++

Routine Description:

    this routine converts from unicode to either ansi or oem depending on the
    charSet flag. the full description may be found in the ifsmanager sources
    or the ifsmanager docs.

    here's what it says in summary

        PROTO
            unsigned int UniToBCS (unsigned char  *pStr,
                                   unsigned short *pUni,
                                   unsigned int length,
                                   unsigned int maxLength,
                                   int charSet);

        ENTRY   pStr    Flat ptr to an Windows ANSI or OEM output string.

                pUni    Flat ptr to a UNICODE input string.

                length  Number of bytes in the UNICODE input string.

                maxLength - longest string that can be put into pStr
                             (not counting the nul terminator)

                charSet Ordinal specifying character set of input string.
                        0 == Windows ANSI
                        1 == OEM

    BUT!!!!!!!!!!!!!!!

    the trick is that the ifsmgr routine will do an early out if it encounters
    a null!!!! the bottom line is that i have to hunt up the null treating the
    length passed as the maxlength in the UNICODE_STRING sense. additionally,
    this is temporary....soon, we should stop translating back and forth.

--*/
{
    NTSTATUS Status;
    ULONG ReturnedLength;
    ULONG UnicodeLength;
    PWCHAR p;

    // look for a null for early out....sigh...
    for (p=pUni,UnicodeLength=0;;) {
        if (UnicodeLength==length) {
            break;
        }
        if (*p ==0) {
            break;
        }
        UnicodeLength+=sizeof(WCHAR);
        p++;
    }

    if (charSet == 0) {
        Status = RtlUnicodeToMultiByteN(
                        pStr,            //OUT PCH OemString,
                        maxLength,       //IN ULONG MaxBytesInOemString,
                        &ReturnedLength, //OUT PULONG BytesInOemString OPTIONAL,
                        pUni,            //IN PWCH UnicodeString,
                        UnicodeLength    //IN ULONG BytesInUnicodeString
                        );

    } else {
        Status = RtlUnicodeToOemN(
                        pStr,            //OUT PCH OemString,
                        maxLength,       //IN ULONG MaxBytesInOemString,
                        &ReturnedLength, //OUT PULONG BytesInOemString OPTIONAL,
                        pUni,            //IN PWCH UnicodeString,
                        UnicodeLength    //IN ULONG BytesInUnicodeString
                        );

    }

    return(ReturnedLength);

}

unsigned int UniToBCSPath(
                    unsigned char   *pStr,
                    PathElement     *pPth,
                    unsigned int    maxLength,
                    int             charSet);


_QWORD qwUniToBCS(
                    unsigned char   *pStr,
                    string_t        pUni,
                    unsigned int    length,
                    unsigned int    maxLength,
                    unsigned int    charSet);


_QWORD qwUniToBCSPath(
                    unsigned char   *pStr,
                    PathElement     *pPth,
                    unsigned int    maxLength,
                    int             charSet);






unsigned int  _cdecl BCSToUni(
                    string_t        pUni,
                    unsigned char   *pStr,
                    unsigned int    length,
                    int             charSet)
/*++

Routine Description:

    this routine converts to unicode from either ansi or oem depending on the
    charSet flag. the full description may be found in the ifsmanager sources
    or the ifsmanager docs

--*/
{
    ULONG ReturnedLength;

    if (charSet == 0) {
        RtlMultiByteToUnicodeN(
            pUni,            //OUT PWCH UnicodeString,
            0xffff,          //IN ULONG MaxBytesInUnicodeString,
            &ReturnedLength, //OUT PULONG BytesInUnicodeString OPTIONAL,
            pStr,            //IN PCH OemString,
            length           //IN ULONG BytesInOemString
            );
    } else {
        RtlOemToUnicodeN(
            pUni,            //OUT PWCH UnicodeString,
            0xffff,          //IN ULONG MaxBytesInUnicodeString,
            &ReturnedLength, //OUT PULONG BytesInUnicodeString OPTIONAL,
            pStr,            //IN PCH OemString,
            length           //IN ULONG BytesInOemString
            );
    }
    return(ReturnedLength);
}



unsigned int UniToUpper(
                    string_t        pUniUp,
                    string_t        pUni,
                    unsigned int    length)
/*++

Routine Description:

    this routine upcases from unicode to unicode. the full description
    may be found in the ifsmanager sources or the ifsmanager docs

--*/
{
    UNICODE_STRING u,uUp;
    u.Length = uUp.Length = (USHORT)length;
    u.MaximumLength = uUp.MaximumLength = (USHORT)length;
    u.Buffer = pUni;
    uUp.Buffer = pUniUp;

    RtlUpcaseUnicodeString(
        &uUp, //PUNICODE_STRING DestinationString,
        &u,   //PUNICODE_STRING SourceString,
        FALSE //BOOLEAN AllocateDestinationString
        );

    return(uUp.Length);
}




unsigned int BCSToBCS (unsigned char *pDst,
                       unsigned char *pSrc,
                       unsigned int  dstCharSet,
                       unsigned int  srcCharSet,
                       unsigned int  maxLen);


unsigned int BCSToBCSUpper (unsigned char *pDst,
                       unsigned char *pSrc,
                       unsigned int  dstCharSet,
                       unsigned int  srcCharSet,
                       unsigned int  maxLen);

//------------------------------------------------------------------------------
// T I M E
//
#include "smbtypes.h"
#include "smbgtpt.h"

/** Time format conversion routines
 *
 *  These routines will convert from time/date information between
 * the various formats used and required by IFSMgr and FSDs.
 */

_FILETIME  _cdecl IFSMgr_DosToWin32Time(dos_time dt)
/*++

Routine Description:

    This routine converts from the old dos packed time format to the
    normal win32 time. it was just lifted from the smbminirdr.

Arguments:



Return Value:



--*/


{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER OutputTime;
    _FILETIME ret;
    SMB_TIME Time;
    SMB_DATE Date;

    Time.Ushort = dt.dt_time;
    Date.Ushort = dt.dt_date;

    OutputTime.LowPart = OutputTime.HighPart = 0;
    if (SmbIsTimeZero(&Date) && SmbIsTimeZero(&Time)) {
        NOTHING;
    } else {
        TimeFields.Year = Date.Struct.Year + (USHORT )1980;
        TimeFields.Month = Date.Struct.Month;
        TimeFields.Day = Date.Struct.Day;

        TimeFields.Hour = Time.Struct.Hours;
        TimeFields.Minute = Time.Struct.Minutes;
        TimeFields.Second = Time.Struct.TwoSeconds*(USHORT )2;
        TimeFields.Milliseconds = 0;

        //
        //  Make sure that the times specified in the SMB are reasonable
        //  before converting them.
        //

        if (TimeFields.Year < 1601) {
            TimeFields.Year = 1601;
        }

        if (TimeFields.Month > 12) {
            TimeFields.Month = 12;
        }

        if (TimeFields.Hour >= 24) {
            TimeFields.Hour = 23;
        }
        if (TimeFields.Minute >= 60) {
            TimeFields.Minute = 59;
        }
        if (TimeFields.Second >= 60) {
            TimeFields.Second = 59;

        }

        if (!RtlTimeFieldsToTime(&TimeFields, &OutputTime)) {
            OutputTime.HighPart = 0;
            OutputTime.LowPart = 0;
        } else {
            ExLocalTimeToSystemTime(&OutputTime, &OutputTime);
        }

    }

    ret.dwHighDateTime = OutputTime.HighPart;
    ret.dwLowDateTime  = OutputTime.LowPart;
    return(ret); //CODE.IMPROVEMENT put in some asserts and don't do this copy

}



dos_time IFSMgr_Win32ToDosTime(_FILETIME ft)
/*++

Routine Description:

    This routine converts from the normal win32 time to the old dos packed
    time format. it was just lifted from the smbminirdr.

Arguments:



Return Value:



--*/

{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER InputTime;
    SMB_TIME Time;
    SMB_DATE Date;
    dos_time ret;

    PAGED_CODE();

    InputTime.HighPart = ft.dwHighDateTime;
    InputTime.LowPart  = ft.dwLowDateTime;

    if (InputTime.LowPart == 0 && InputTime.HighPart == 0) {
        Time.Ushort = Date.Ushort = 0;
    } else {
        LARGE_INTEGER LocalTime;

        ExSystemTimeToLocalTime(&InputTime, &LocalTime);

        RtlTimeToTimeFields(&LocalTime, &TimeFields);

        //if (TimeFields.Year < 1980) {
        //    return FALSE;
        //}

        Date.Struct.Year = (USHORT )(TimeFields.Year - 1980);
        Date.Struct.Month = TimeFields.Month;
        Date.Struct.Day = TimeFields.Day;

        Time.Struct.Hours = TimeFields.Hour;
        Time.Struct.Minutes = TimeFields.Minute;

        //
        //  When converting from a higher granularity time to a lesser
        //  granularity time (seconds to 2 seconds), always round up
        //  the time, don't round down.
        //

        Time.Struct.TwoSeconds = (TimeFields.Second + (USHORT)1) / (USHORT )2;

    }

    ret.dt_time = Time.Ushort;
    ret.dt_date = Date.Ushort;
    return ret;
}


dos_time IFSMgr_NetToDosTime(unsigned long time);

unsigned long IFSMgr_DosToNetTime(dos_time dt);

unsigned long IFSMgr_Win32ToNetTime(_FILETIME ft);

ULONG
IFSMgr_Get_NetTime()
{
    LARGE_INTEGER CurrentTime;
    ULONG SecondsSince1970;
    KeQuerySystemTime(&CurrentTime);
    RtlTimeToSecondsSince1970(&CurrentTime,&SecondsSince1970);
    return(SecondsSince1970);
}

_FILETIME
IFSMgr_NetToWin32Time(
    ULONG   time
    )
{
    LARGE_INTEGER sTime;

    RtlSecondsSince1970ToTime(time, &sTime);

    return (*(_FILETIME *)&sTime);
}

//----------------------------------------------------------
//----------------------------------------------------------
//----------------------------------------------------------
//----------------------------------------------------------
DEBUG_ONLY_DECL(ULONG IFSMgr_MetaMatch_DbgPFlag = 0);
unsigned int IFSMgr_MetaMatch(
                    string_t        pUniPat,
                    string_t        pUni,
                    int MatchSem)
/*++

Routine Description:

    this routine checks to see if the unicode pattern matches the
    passed unicode string. the MatchSem parameter is currently unused;
    it is supposed to represent doing a dos-fcb style match. please refer
    to the ifsmgr sources if necessary.

    the full description may be found in the ifsmanager sources
    or the ifsmanager docs

--*/
{
    UNICODE_STRING Pattern,Name;
    unsigned int Result;

    RtlInitUnicodeString(&Pattern,pUniPat);
    RtlInitUnicodeString(&Name,pUni);

    try
    {
        Result =  FsRtlIsNameInExpression (
                        &Pattern, //IN PUNICODE_STRING Expression,
                        &Name,    //IN PUNICODE_STRING Name,
                        TRUE,     //IN BOOLEAN IgnoreCase,
                        NULL      //IN PWCH UpcaseTable
                        );
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        Result = 0;
    }
    
#ifdef RX_PRIVATE_BUILD
    if (IFSMgr_MetaMatch_DbgPFlag) {
        DbgPrint("MMnt <%wZ> in <%wZ> returning %08lx\n", &Name, &Pattern, Result);
    }
#endif //ifdef RX_PRIVATE_BUILD

    return(Result);

}

// i moved these here from win95's hook.c
/*************************** Agent Related ********************************/
// Two globals vpFileInfoAgent and vpFileInfoDuped are used to deal with the agent
// The access to these globals is serialized by the hookcrit section
// Hookcrit section is entered, in VfnOpen, HfnClose, IoctlCopyChunk

// Info on file opened by agent
PFILEINFO vpFileInfoAgent = NULL;   // handle of file opened by agent
PFILEINFO vpFileInfoDuped = NULL;   // If duped, this is set

int SetInUseByAgent( PFILEINFO   pFileInfo, BOOL fDuped
   )
   {
   PFDB pFdb = pFileInfo->pFdb;

   Assert(vpFileInfoAgent==NULL);
   vpFileInfoAgent = pFileInfo;
   if (fDuped)
      {
      vpFileInfoDuped = pFileInfo;
      }
   else
      {
      vpFileInfoDuped = NULL;
      }
   return(0);  //stop complaining about no return value
   }

int ResetInUseByAgent( PFILEINFO   pFileInfo
   )
   {
   Assert(pFileInfo==vpFileInfoAgent);
   vpFileInfoAgent = NULL;
   vpFileInfoDuped = NULL;
   return(0);  //stop complaining about no return value
   }


PFILEINFO   PFileInfoAgent( VOID)
   {
   return (vpFileInfoAgent);
   }

BOOL IsAgentHandle(PFILEINFO pFileInfo)
   {
   return (pFileInfo == vpFileInfoAgent);
   }


BOOL IsDupHandle(PFILEINFO pFileInfo)
   {
   if (pFileInfo)
      return (pFileInfo == vpFileInfoDuped);
   return FALSE;
   }


LPVOID AllocMem (ULONG uSize)
{
    PVOID t;
    t = RxAllocatePoolWithTag(NonPagedPool,
                              uSize,
                              RX_MISC_POOLTAG);
    if (t) {
        RtlZeroMemory(t,uSize);
    }
    else
    {
        SetLastErrorLocal(ERROR_NOT_ENOUGH_MEMORY);
    }

    return(t);
}


LPVOID AllocMemPaged (ULONG uSize)
{
    PVOID t;
    t = RxAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION,
                              uSize,
                              RX_MISC_POOLTAG);
    if (t) {
        RtlZeroMemory(t,uSize);
    }
    else
    {
        SetLastErrorLocal(ERROR_NOT_ENOUGH_MEMORY);
    }

    return(t);
}

VOID
FreeMemPaged(
    LPVOID  lpBuff
    )
{
    FreeMem(lpBuff);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\daytona\nullincs.tmp\vmmreg.h ===
//null .h file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\daytona\nullincs.tmp\ifs.h ===
/*****************************************************************/
/**			Microsoft DOS IFS Manager		 					**/
/**		 Copyright(c) Microsoft Corp., 1990-1993				**/
/*****************************************************************/
/* :ts=4 */

/*NOINC*/
#ifndef IFS_INC
#define IFS_INC 1
/*INC*/

/***	ifs.h - Installable File System definitions
 *
 *	This file contains the C function prototypes, structure declarations,
 *	type names, and constants which define the DOS installable file system
 *	interface.
 *
 *	All of these routines take a pointer to an IO request structure that
 *	is filled in with the parameters relevant for the request. The routines
 *	return some result info in the IO request struct. The particulars
 *	for each routine are given below the function prototype. All of the
 *	requests use ir_pid as the ID of the requesting process and return
 *	success/failure info in ir_error.
 */

/*NOINC*/
#ifndef FAR
	#if defined(M_I386) || _M_IX86 >= 300
		#define FAR
	#else
		#define FAR _far
	#endif
#endif
/*INC*/

#ifndef IFSMgr_Device_ID

#define IFSMgr_Device_ID    0x00040	/* Installable File System Manager */

#define IFSMgr_Init_Order   0x10000 + V86MMGR_Init_Order
#define FSD_Init_Order      0x00100 + IFSMgr_Init_Order

#else
/* ASM

ifdef MASM
	.errnz IFSMgr_Device_ID - 0040h
endif
*/
#endif

/* ASM
ifdef MASM
;*	Equ's for types that h2inc script cannot convert.
;	BUGBUG: These are kept here only because there are other ifsmgr include
;	files that still use the SED script and they depend on these definitions.
;	Ifs.h itself doesn't use them any more. Once the other include files have
;	been converted to use h2inc, these definitions will be removed.

ubuffer_t	equ	<dd>
pos_t		equ	<dd>
uid_t		equ	<db>
sfn_t		equ	<dw>
$F			equ	<dd>

	path_t		equ	<dd>
	string_t	equ	<dd>
	pid_t		equ	<dd>
	rh_t		equ	<dd>
	fh_t		equ	<dd>
	vfunc_t		equ	<dd>
	$P			equ	<dd>
	$I			equ	<dd>
	fsdwork struc
		dd	16 dup (?)
	fsdwork ends

endif
*/

#define IFS_VERSION	0x030A
#define IFS_REVISION	0x10

/**	Maximum path length - excluding nul	*/

#define MAX_PATH	260	/* Maximum path length - including nul */

/* Maximum length for a LFN name element - excluding nul */
#define LFNMAXNAMELEN	255


#define MAXIMUM_USERID	2		/* max. # of users that can be logged */
								/* on at the same time.  Ir_user must */
								/* always be less than MAXIMUM_USERID. */
#define NULL_USER_ID	0		/* special user id for operations when */
								/* not logged on. */

/* Status indications returned as errors: */

#define STATUS_PENDING	-1		/* request is pending */
#define STATUS_RAWLOCK	-2		/* rawlock active on session			*/
								/* (only returned for async requests,	*/
								/*  sync requests will wait for the raw */
								/*  lock to be released)				*/
#define STATUS_BUSY	-3			/* request can't be started because of */
								/* serialization.	*/

/**	ANYPROID - Any Provider ID
 */
#define ANYPROID	-1


/**	Common function defintions for NetFunction */
#define	NF_PROCEXIT			0x111D	/* Process Exit sent (ID = ANYPROID)	*/
#define NF_DRIVEUSE			0x0001	/* Drive Use Created (ID = ID of owner FSD) */
#define NF_DRIVEUNUSE		0x0002	/* Drive Use Broken (ID = ID of owner FSD) */
#define	NF_GETPRINTJOBID	0x0003	/* Get Print Job ID					*/
									/* ir_fh - ptr to master file info	*/
									/* ir_data - ptr to data buffer		*/
									/* ir_length - IN: buffer size		*/
									/*			  OUT: amount transfered*/
									/* ir_SFN - SFN of file handle		*/
#define NF_PRINTERUSE		0x0004	/* Printer Use Created (ID = ID of owner FSD) */
#define NF_PRINTERUNUSE		0x0005	/* Printer Use Broken (ID = ID of owner FSD) */
#define NF_NetSetUserName	0x1181

/** Flags passed to NetFunction */
#define WIN32_CALLFLAG		0x04	/* call is Win32 api */

/** Values for the different types of FSDs that can be registered: */
#define FSTYPE_LOCAL_FSD		0		// a local FSD
#define FSTYPE_NET_FSD			1		// a network FSD
#define FSTYPE_MAILSLOT_FSD		2		// a mailslot provider
#define FSTYPE_CHARACTER_FSD	3		// a character FSD

/** Force levels that can be specified on IFSMgr_DeregisterFSD apis. A
 *	description of the actions performed at the various levels as well as
 *	which FSD types can use which levels is given below. Note that if the
 *	api is called with a force level that is not valid for its FSD type,
 *	the call will be failed.
 *	
 *	Level	FSD Type  	Action
 *	-----	--------	------
 *	  0		Only net 	Clean only UNC with no open handles.
 *
 *	  1		Only net	Clean up UNC & net drives with no open handles.
 *
 *	  2		Net, local	Close open files. For net FSD, get rid of UNC, and
 *						net drives that are not current drives in a VM. For
 *						local FSD, get rid of drive if no errors closing files.
 *						It is irrelevant if it is the current drive in a VM.
 *
 *	  3		Net, local	Does everything at level 2. In addition, for CFSD and
 *			and CFSD	local FSD, blast resources ignoring all	errors. For net
 *						FSD, ignore if drive is current drive in VM.
 *
 *	  4		Net only	Do everything at level 3. In addition, get rid of
 *						static connections also.
 */
#define FORCE_LEV_UNC			0	// clean up UNC connections only
#define FORCE_LEV_USE			1	// clean up any net uses to drives
									// provided there are no open files
#define FORCE_LEV_CLOSE_FILES	2	// close any open files and clean up
#define FORCE_LEV_CLEANUP		3	// ignore errors closing open files, or
									// for net drives, if it is current drive
#define FORCE_LEV_BLAST			4	// only for net, clean up static
									// connections also

/** Priority levels that can be specifed for FSDs while registering.
 *	Priority levels can only be passed in on the new service
 *	IFSMgr_RegisterFSDWithPriority. A priority level of zero cannot be
 *	passed in, the IFSMgr automatically converts this to a default
 *	priority level.
 *
 *	For reference, the filesystem components have the following
 *	priorities:
 *
 *	VDEF:	FS_PRIORITY_LOWEST
 *	VFAT:	FS_PRIORITY_DEFAULT
 *	CDFS:	FS_PRIORITY_LOW
 */
 #define FS_PRIORITY_LOWEST		0x00	// lowest value, only for default FSD
 #define FS_PRIORITY_LOW		0x20	// low priority FSD
 #define FS_PRIORITY_DEFAULT	0x40	// default value for priority
 #define FS_PRIORITY_MEDIUM		0x80	// medium value of priority
 #define FS_PRIORITY_HIGH		0xC0	// high priority FSD
 #define FS_PRIORITY_HIGHEST	0x100	// max value of priority

 /** Attributes that describe the level of support provided by the FSD.
  *	 The ifsmgr uses these attributes to determine what kinds of functions
  *	 are supported by the FSD. Currently, it is used to indicate that the
  *	 FSD supports large-disk access i.e. disks > 2Gb in size.
  */

 #define FS_ATTRIB_WIN95COMPAT	0x00000000	// Win95 level of support
 #define FS_ATTRIB_LARGE_MEDIA	0x00000001	// Supports media > 2Gb


/*NOINC*/

/** Macros for handling status indications when returned as errors
 *
 *	REAL_ERROR - returns TRUE if there is a real error
 *				 returns FALSE for NO_ERROR or STATUS_????
 *	STATUS_ERROR - returns TRUE if error is actually a status indication
 */

#define REAL_ERROR(err) ((err) > 0)
#define STATUS_ERROR(err) ((err) < 0)

/*INC*/

/**
 *	The types for resource handles (rh_t), file handles (fh_t),
 *	and the file system driver work space (fsdwork_t) can be defined
 *	by the FSD.  The FSD's version of the type must be exactly the
 *	same size as the types defined below.  To declare your own
 *	version of these types: define a macros of the same name as
 *	any of the three types before including ifs.h.
 */

#ifndef rh_t
	typedef void *rh_t;		/* resource handle */
#endif
#ifndef fh_t
	typedef void *fh_t;		/* file handle */
#endif
#ifndef fsdwork_t
	typedef int fsdwork_t[16];	/* provider work space */
#endif

typedef unsigned short *string_t;	/* character string */
typedef unsigned short sfn_t;		/* system file number */
typedef unsigned long pos_t;		/* file position */
typedef unsigned int pid_t;			/* process ID of requesting task */
typedef void FAR *ubuffer_t;		/* ptr to user data buffer */
typedef unsigned char uid_t;		/* user ID for this request */

/* Parsed path structures are defined later in this file. */
typedef struct PathElement PathElement;
typedef struct ParsedPath ParsedPath;
typedef ParsedPath *path_t;

typedef struct ioreq ioreq;
typedef struct ioreq *pioreq;

/** dos_time - DOS time & date format */

typedef struct dos_time dos_time;
struct dos_time {
	unsigned short	dt_time;
	unsigned short	dt_date;
};	/* dos_time */


/** dos_time_rounded - DOS date/time returned by ifsgmr_GetDosTimeRounded */

typedef struct dos_time_rounded dos_time_rounded;
struct dos_time_rounded {
	unsigned short	dtr_time_rounded;
	unsigned short	dtr_date_rounded;
	unsigned short	dtr_time;
	unsigned short	dtr_date;
	unsigned char	dtr_time_msec;
};	/* dos_time_rounded */

typedef struct volfunc volfunc;
typedef struct volfunc *vfunc_t;
typedef struct hndlfunc hndlfunc;
typedef struct hndlfunc *hfunc_t;


typedef union aux_t {
	ubuffer_t		aux_buf;
	unsigned long	aux_ul;
	dos_time		aux_dt;
	vfunc_t			aux_vf;
	hfunc_t			aux_hf;
	void			*aux_ptr;
	string_t		aux_str;
	path_t			aux_pp;
	unsigned int	aux_ui;
} aux_t;


/* ASM
ifdef MASM

aux_data struc
  aux_dword	dd	?
aux_data ends

if @Version ge 600
	aux_ul 	textequ	<aux_data.aux_dword>
	aux_ui 	textequ	<aux_data.aux_dword>
	aux_vf 	textequ	<aux_data.aux_dword>
	aux_hf 	textequ	<aux_data.aux_dword>
	aux_ptr textequ	<aux_data.aux_dword>
	aux_str textequ	<aux_data.aux_dword>
	aux_pp 	textequ	<aux_data.aux_dword>
	aux_buf textequ	<aux_data.aux_dword>
	aux_dt	textequ	<aux_data.aux_dword>
else
	aux_ul 	equ	aux_dword
	aux_ui 	equ	aux_dword
	aux_vf 	equ	aux_dword
	aux_hf 	equ	aux_dword
	aux_ptr equ	aux_dword
	aux_str equ	aux_dword
	aux_pp 	equ	aux_dword
	aux_buf equ	aux_dword
	aux_dt	equ	aux_dword
endif

endif
*/

typedef struct event event;
typedef struct event *pevent;

struct ioreq {
	unsigned int	ir_length;	/* length of user buffer (eCX) */
	unsigned char	ir_flags;	/* misc. status flags (AL) */
	uid_t			ir_user;	/* user ID for this request */
	sfn_t			ir_sfn;		/* System File Number of file handle */
	pid_t			ir_pid;		/* process ID of requesting task */
	path_t			ir_ppath;	/* unicode pathname */
	aux_t			ir_aux1;	/* secondary user data buffer (CurDTA) */
	ubuffer_t		ir_data;	/* ptr to user data buffer (DS:eDX) */
	unsigned short	ir_options;	/* request handling options */
	short			ir_error;	/* error code (0 if OK) */
	rh_t			ir_rh;		/* resource handle */
	fh_t			ir_fh;		/* file (or find) handle */
	pos_t			ir_pos;		/* file position for request */
	aux_t			ir_aux2;	/* misc. extra API parameters */
	aux_t			ir_aux3;	/* misc. extra API parameters */
	pevent			ir_pev;		/* ptr to IFSMgr event for async requests */
	fsdwork_t		ir_fsd;		/* Provider work space */
};	/* ioreq */


/* misc. fields overlayed with other ioreq members: */

#define ir_size		ir_pos
#define ir_conflags	ir_pos		/* flags for connect */
#define ir_attr2	ir_pos		/* destination attributes for Rename */
#define ir_attr		ir_length	/* DOS file attribute info */
#define ir_pathSkip	ir_length	/* # of path elements consumed by Connect */
#define ir_lananum	ir_sfn		/* LanA to Connect on (0xFF for any net) */
#define ir_tuna		ir_sfn		/* Mount: FSD authorises IFSMGR tunneling */
#define ir_ptuninfo ir_data		/* Rename/Create: advisory tunneling info ptr */


/* Fields overlayed with ir_options: */

#define ir_namelen	ir_options
#define ir_sectors	ir_options	/* sectors per cluster */
#define ir_status	ir_options	/* named pipe status */


/* Fields overlayed with ir_aux1: */

#define ir_data2	ir_aux1.aux_buf	/* secondary data buffer */
#define ir_vfunc	ir_aux1.aux_vf	/* volume function vector */
#define ir_hfunc	ir_aux1.aux_hf	/* file handle function vector */
#define ir_ppath2	ir_aux1.aux_pp	/* second pathname for Rename */
#define ir_volh		ir_aux1.aux_ul	/* VRP address for Mount */


/* Fields overlayed with ir_aux2: */

#define ir_numfree	ir_aux2.aux_ul	/* number of free clusters */
#define ir_locklen	ir_aux2.aux_ul	/* length of lock region */
#define ir_msglen	ir_aux2.aux_ui	/* length of current message (peek pipe) */
									/* next msg length for mailslots */
#define ir_dostime	ir_aux2.aux_dt	/* DOS file date & time stamp */
#define ir_timeout	ir_aux2.aux_ul	/* timeout value in milliseconds */
#define ir_password	ir_aux2.aux_ptr	/* password for Connect */
#define ir_drvh		ir_aux2.aux_ptr	/* drive handle for Mount */
#define ir_prtlen	ir_aux2.aux_dt.dt_time	/* length of printer setup string */
#define ir_prtflag	ir_aux2.aux_dt.dt_date	/* printer flags */
#define ir_firstclus ir_aux2.aux_ul	/* First cluster of file */
#define ir_mntdrv	ir_aux2.aux_ul	/* driveletter for Mount */
#define ir_cregptr	ir_aux2.aux_ptr	/* pointer to client registers */
#define ir_uFName	ir_aux2.aux_str	/* case preserved filename */

/* Fields overlayed with ir_aux3: */

#define ir_upath	ir_aux3.aux_str	/* pointer to unparsed pathname */
#define ir_scratch	ir_aux3.aux_ptr	/* scratch buffer for NetFunction calls */

/* Fields overlayed with ir_user: */

#define	ir_drivenum	ir_user		/* Logical drive # (when mounting) */


/**	IFSFunc - general IFS functions
 */
typedef	int	_cdecl IFSFunc(pioreq pir);
typedef IFSFunc *pIFSFunc;

/** hndlfunc - I/O functions for file handles
 */

#define NUM_HNDLMISC	8

/*NOINC*/
/** IFSFileHookFunc - IFS file hook function
 */
typedef	int	_cdecl IFSFileHookFunc( pIFSFunc pfn, int fn, int Drive, int ResType, int CodePage, pioreq pir );
typedef	IFSFileHookFunc	*pIFSFileHookFunc;
typedef	pIFSFileHookFunc	*ppIFSFileHookFunc;
/*INC*/

typedef struct hndlmisc hndlmisc;

struct hndlfunc {
	pIFSFunc	hf_read;	/* file read handler function */
	pIFSFunc	hf_write;	/* file write handler function */
	hndlmisc	*hf_misc;	/* ptr to misc. function vector */
};	/* hndlfunc */


struct hndlmisc {
	short		hm_version;			/* IFS version # */
	char		hm_revision;		/* IFS interface revision # */
	char		hm_size;			/* # of entries in table */
	pIFSFunc	hm_func[NUM_HNDLMISC];
};	/* hndlmisc */

#define HM_SEEK			0			/* Seek file handle */
#define HM_CLOSE		1			/* close handle */
#define HM_COMMIT		2			/* commit buffered data for handle*/
#define HM_FILELOCKS	3			/* lock/unlock byte range */
#define HM_FILETIMES	4			/* get/set file modification time */
#define HM_PIPEREQUEST	5			/* named pipe operations */
#define HM_HANDLEINFO	6			/* get/set file information */
#define HM_ENUMHANDLE	7			/* enum filename from handle, lock info */

/**	volfunc - volume based api fucntions
 */

#define NUM_VOLFUNC	15

struct volfunc {
	short		vfn_version;		/* IFS version # */
	char		vfn_revision;		/* IFS interface revision # */
	char		vfn_size;			/* # of entries in table */
	pIFSFunc	vfn_func[NUM_VOLFUNC];/* volume base function handlers */
};	/* volfunc */

#define VFN_DELETE			0		/* file delete */
#define VFN_DIR				1		/* directory manipulation */
#define VFN_FILEATTRIB		2		/* DOS file attribute manipulation */
#define VFN_FLUSH			3		/* flush volume */
#define VFN_GETDISKINFO		4		/* query volume free space */
#define VFN_OPEN			5		/* open file */
#define VFN_RENAME			6		/* rename path */
#define VFN_SEARCH			7		/* search for names */
#define VFN_QUERY			8		/* query resource info (network only) */
#define VFN_DISCONNECT		9		/* disconnect from resource (net only) */
#define VFN_UNCPIPEREQ		10		/* UNC path based named pipe operations */
#define VFN_IOCTL16DRIVE	11		/* drive based 16 bit IOCTL requests */
#define VFN_GETDISKPARMS	12		/* get DPB */
#define VFN_FINDOPEN		13		/* open	an LFN file search */
#define VFN_DASDIO			14		/* direct volume access */


/** IFS Function IDs passed to IFSMgr_CallProvider */

#define IFSFN_READ			0		/* read a file */
#define IFSFN_WRITE			1		/* write a file */
#define IFSFN_FINDNEXT		2		/* LFN handle based Find Next */
#define IFSFN_FCNNEXT		3		/* Find Next Change Notify */

#define IFSFN_SEEK			10		/* Seek file handle */
#define IFSFN_CLOSE			11		/* close handle */
#define IFSFN_COMMIT		12		/* commit buffered data for handle*/
#define IFSFN_FILELOCKS		13		/* lock/unlock byte range */
#define IFSFN_FILETIMES		14		/* get/set file modification time */
#define IFSFN_PIPEREQUEST	15		/* named pipe operations */
#define IFSFN_HANDLEINFO	16		/* get/set file information */
#define IFSFN_ENUMHANDLE	17		/* enum file handle information */
#define IFSFN_FINDCLOSE		18		/* LFN find close */
#define IFSFN_FCNCLOSE		19		/* Find Change Notify Close */

#define IFSFN_CONNECT		30		/* connect or mount a resource */
#define IFSFN_DELETE		31		/* file delete */
#define IFSFN_DIR			32		/* directory manipulation */
#define IFSFN_FILEATTRIB	33		/* DOS file attribute manipulation */
#define IFSFN_FLUSH			34		/* flush volume */
#define IFSFN_GETDISKINFO	35		/* query volume free space */
#define IFSFN_OPEN			36		/* open file */
#define IFSFN_RENAME		37		/* rename path */
#define IFSFN_SEARCH		38		/* search for names */
#define IFSFN_QUERY			39		/* query resource info (network only) */
#define IFSFN_DISCONNECT	40		/* disconnect from resource (net only) */
#define IFSFN_UNCPIPEREQ	41		/* UNC path based named pipe operations */
#define IFSFN_IOCTL16DRIVE	42		/* drive based 16 bit IOCTL requests */
#define IFSFN_GETDISKPARMS	43		/* get DPB */
#define IFSFN_FINDOPEN		44		/* open	an LFN file search */
#define IFSFN_DASDIO		45		/* direct volume access */

/**	Resource types passed in on the File Hook: */
#define IFSFH_RES_UNC		0x01	/* UNC resource */
#define IFSFH_RES_NETWORK	0x08	/* Network drive connection */
#define IFSFH_RES_LOCAL		0x10	/* Local drive */
#define IFSFH_RES_CFSD		0x80	/* Character FSD */

/** values for ir_options to Connect:
 * Note that only one of RESOPT_UNC_REQUEST, RESOPT_DEV_ATTACH, and
 * RESOPT_UNC_CONNECT may be set at once.
 */

#define RESOPT_UNC_REQUEST	0x01	/* UNC-style path based request */
#define RESOPT_DEV_ATTACH	0x02	/* explicit redirection of a device */
#define RESOPT_UNC_CONNECT	0x04	/* explicit UNC-style use */
#define RESOPT_DISCONNECTED	0x08	/* Set up connection disconnected */
									/* (Don't touch net) */
#define RESOPT_NO_CREATE	0x10	/* don't create a new resource */
#define RESOPT_STATIC		0x20	/* don't allow ui to remove */

/** values for ir_flags to Connect:	*/
#define RESTYPE_WILD	0			/* wild card service type */
#define RESTYPE_DISK	1			/* disk resource */
#define RESTYPE_SPOOL	2			/* spooled printer */
#define RESTYPE_CHARDEV 3			/* character device */
#define RESTYPE_IPC		4			/* interprocess communication */

#define FIRST_RESTYPE	RESTYPE_DISK
#define LAST_RESTYPE	RESTYPE_IPC

/** values for ir_options to Close **/

#define RESOPT_NO_IO 0x01     /* no I/O allowed during the operation */

/** values for ir_flags for FSD operations */

#define IR_FSD_MOUNT		0		/* mount volume */
//OBSOLETE: #define IR_FSD_DISMOUNT 1			/* dismount volume */
#define IR_FSD_VERIFY		2		/* verify volume */
#define IR_FSD_UNLOAD		3		/* unload volume */
#define	IR_FSD_MOUNT_CHILD	4		/* mount child volume */
#define	IR_FSD_MAP_DRIVE	5		/* change drive mapping */
#define	IR_FSD_UNMAP_DRIVE	6		/* reset drive mapping */


/** Value for ir_error from IR_FSD_MOUNT if volume exists **/
#define ERROR_IFSVOL_EXISTS		284 /* mounted volume already exists */

/** Values returned in ir_tuna from IR_FSD_MOUNT (default IR_TUNA_NOTUNNEL) */
#define IR_TUNA_NOTUNNEL	0		/* Disable IFSMGR tunneling on volume */
#define IR_TUNA_FSDTUNNEL	0		/* FSD implements tunneling itself */
#define IR_TUNA_IFSTUNNEL	1		/* FSD requests IFSMGR tunneling support */

/** Values for IFSMgr_PNPVolumeEvent */
#define	PNPE_SUCCESS		0x00
#define PNPE_QUERY_ACCEPTED	0x00
#define PNPE_QUERY_REFUSED	0x01
#define PNPE_BAD_ARGS		0x02
#define PNPE_UNDEFINED		0xFF

/** Type values for IFSMgr_PNPEvent */
#define PNPT_VOLUME			0x10000000
#define PNPT_NET			0x20000000
#define PNPT_MASK	        0xF0000000

/** Values for ir_options returned from QueryResource:	*/
#define RESSTAT_OK		0			/* connection to resource is valid */
#define RESSTAT_PAUSED	1			/* paused by workstation */
#define RESSTAT_DISCONN 2			/* disconnected */
#define RESSTAT_ERROR	3			/* cannot be reconnected */
#define RESSTAT_CONN	4			/* first connection in progress */
#define RESSTAT_RECONN	5			/* reconnection in progress */



/** Values for ir_flags to HM_CLOSE:	*/

#define CLOSE_HANDLE		0		/* only closing a handle */
#define CLOSE_FOR_PROCESS	1		/* last close of SFN for this process */
#define CLOSE_FINAL			2		/* final close of SFN for system */

/** Values for ir_options to HM_CLOSE, HM_COMMIT, hf_read, hf_write:	*/
#define FILE_NO_LAST_ACCESS_DATE	0x01	/* do not update last access date */
#define FILE_CLOSE_FOR_LEVEL4_LOCK	0x02	/* special close on a level 4 lock */
#define FILE_COMMIT_ASYNC			0x04	/* commit async instead of sync */

#define FILE_FIND_RESTART	0x40	/* set for findnext w/key */
#define IOOPT_PRT_SPEC		0x80	/* ir_options flag for int17 writes */

/**	Values for ir_flags to VFN_DIR: */

#define CREATE_DIR	0
#define DELETE_DIR	1
#define CHECK_DIR	2
#define QUERY83_DIR	3
#define QUERYLONG_DIR	4


/**	ir_flags values for HM_FILELOCKS:	*/

#define LOCK_REGION		0			/* lock specified file region */
#define UNLOCK_REGION	1			/* unlock region */

/* Note: these values are also used by the sharing services */
/** ir_options values for HM_FILELOCKS:	*/

#define LOCKF_MASK_RDWR	0x01	/* Read / write lock flag */
#define LOCKF_WR		0x00	/* bit 0 clear - write lock */
#define LOCKF_RD		0x01	/* bit 0 set - read lock(NW only) */

#define LOCKF_MASK_DOS_NW	0x02	/* DOS/Netware style lock flag */
#define LOCKF_DOS			0x00	/* bit 1 clear - DOS-style lock */
#define LOCKF_NW			0x02	/* bit 1 set - Netware-style lock */

/** These values are used internally by the IFS manager only: */
#define LOCKF_MASK_INACTIVE	0x80	/* lock active/inactive flag */
#define LOCKF_ACTIVE		0x00	/* bit 7 clear - lock active */
#define LOCKF_INACTIVE		0x80	/* bit 7 set - lock inactive */

/** Values for ir_flags to VFN_PIPEREQUEST and HM_PIPEREQUEST:
 *	(NOTE: these values have been chosen to agree with the opcodes used
 *	by the TRANSACTION SMB for the matching operation.)
 */

#define PIPE_QHandState		0x21
#define PIPE_SetHandState	0x01
#define PIPE_QInfo			0x22
#define PIPE_Peek			0x23
#define PIPE_RawRead		0x11
#define PIPE_RawWrite		0x31
#define PIPE_Wait			0x53
#define PIPE_Call			0x54
#define PIPE_Transact		0x26


/** Values for ir_flags for HM_HANDLEINFO call: */

#define HINFO_GET			0		/* retrieve current buffering info */
#define HINFO_SETALL		1		/* set info (all parms) */
#define HINFO_SETCHARTIME	2		/* set handle buffer timeout */
#define HINFO_SETCHARCOUNT	3		/* set handle max buffer count */

/** Values for ir_flags for HM_ENUMHANDLE call: */
#define ENUMH_GETFILEINFO	0		/* get fileinfo by handle */
#define ENUMH_GETFILENAME	1		/* get filename associated with handle */
#define ENUMH_GETFINDINFO	2		/* get info for resuming */
#define ENUMH_RESUMEFIND	3		/* resume find operation */
#define ENUMH_RESYNCFILEDIR	4		/* resync dir entry info for file */

/** Values for ir_options for the ENUMH_RESYNCFILEDIR call: */
#define RESYNC_INVALIDATEMETACACHE	0x01	/* invalidate meta cache on resync */

/** Values for ir_flags for VFN_FILEATTRIB:				   	*/
/**														   	*/
/**	Note: All functions that modify the volume MUST be odd.	*/
/**       Callers rely on this & test the low order bit.   	*/

#define GET_ATTRIBUTES					0	/* get attributes of file/dir         */
#define SET_ATTRIBUTES					1	/* set attributes of file/dir         */

#define GET_ATTRIB_COMP_FILESIZE		2	/* get compressed size of file        */

#define SET_ATTRIB_MODIFY_DATETIME		3	/* set date last written of file/dir  */
#define GET_ATTRIB_MODIFY_DATETIME		4 	/* get date last written of file/dir  */
#define SET_ATTRIB_LAST_ACCESS_DATETIME	5 	/* set date last accessed of file/dir */
#define GET_ATTRIB_LAST_ACCESS_DATETIME	6	/* get date last accessed of file/dir */
#define SET_ATTRIB_CREATION_DATETIME	7	/* set create date of file/dir        */
#define GET_ATTRIB_CREATION_DATETIME	8	/* get create date of file/dir        */

#define GET_ATTRIB_FIRST_CLUST			9	/* get first cluster of a file        */

/** Values for ir_flags for VFN_FLUSH: */
#define GDF_NORMAL			0x00	/* walk disk, if needed, to get free space */
#define GDF_NO_DISK_HIT		0x01	/* return current "hint", don't walk disk */
#define GDF_R0_EXT_FREESPACE	0x80	/* extended free space call for Fat32 */

/** Values for ir_flags for HM_FILETIMES: */

#define GET_MODIFY_DATETIME		0	/* get last modification date/time */
#define SET_MODIFY_DATETIME		1	/* set last modification date/time */
#define GET_LAST_ACCESS_DATETIME 4	/* get last access date/time */
#define SET_LAST_ACCESS_DATETIME 5	/* set last access date/time */
#define GET_CREATION_DATETIME	6	/* get creation date/time */
#define SET_CREATION_DATETIME	7	/* set creation date/time */

/** Values for ir_flags for HM_SEEK: */

#define FILE_BEGIN	0				/* absolute posn from file beginning */
#define FILE_END	2				/* signed posn from file end */

/** Values for ir_flags for VFN_OPEN: */

#define ACCESS_MODE_MASK	0x0007	/* Mask for access mode bits */
#define ACCESS_READONLY		0x0000	/* open for read-only access */
#define ACCESS_WRITEONLY	0x0001	/* open for write-only access */
#define ACCESS_READWRITE	0x0002	/* open for read and write access */
#define ACCESS_EXECUTE		0x0003	/* open for execute access */

#define SHARE_MODE_MASK		0x0070	/* Mask for share mode bits */
#define SHARE_COMPATIBILITY 0x0000	/* open in compatability mode */
#define SHARE_DENYREADWRITE 0x0010	/* open for exclusive access */
#define SHARE_DENYWRITE		0x0020	/* open allowing read-only access */
#define SHARE_DENYREAD		0x0030	/* open allowing write-only access */
#define SHARE_DENYNONE		0x0040	/* open allowing other processes access */
#define SHARE_FCB			0x0070	/* FCB mode open */

/** Values for ir_options for VFN_OPEN: */

#define ACTION_MASK				0xff	/* Open Actions Mask */
#define ACTION_OPENEXISTING		0x01	/* open an existing file */
#define ACTION_REPLACEEXISTING	0x02	/* open existing file and set length */
#define ACTION_CREATENEW		0x10	/* create a new file, fail if exists */
#define ACTION_OPENALWAYS		0x11	/* open file, create if does not exist */
#define ACTION_CREATEALWAYS		0x12	/* create a new file, even if it exists */

/** Alternate method: bit assignments for the above values: */

#define ACTION_EXISTS_OPEN	0x01	// BIT: If file exists, open file
#define ACTION_TRUNCATE		0x02	// BIT: Truncate file
#define ACTION_NEXISTS_CREATE	0x10	// BIT: If file does not exist, create

/* these mode flags are passed in via ifs_options to VFN_OPEN */
/* NOTE: These flags also directly correspond to DOS flags passed in BX, the */
/* only exception being OPEN_FLAGS_REOPEN */

#define OPEN_FLAGS_NOINHERIT	0x0080
#define OPEN_FLAGS_NO_CACHE	R0_NO_CACHE /* 0x0100 */
#define OPEN_FLAGS_NO_COMPRESS	0x0200
#define OPEN_FLAGS_ALIAS_HINT	0x0400
#define OPEN_FLAGS_NOCRITERR	0x2000
#define OPEN_FLAGS_COMMIT		0x4000
#define OPEN_FLAGS_REOPEN		0x0800	/* file is being reopened on vol lock */

/* These open flags are passed in via ir_attr to VFN_OPEN: */
/* NOTE: The third byte in the dword of ir_attr is unused on VFN_OPEN */
#define OPEN_FLAGS_EXTENDED_SIZE	0x10000	/* open in "extended size" mode */
#define OPEN_EXT_FLAGS_MASK			0x00FF0000 /* mask for extended flags */

/** Values returned by VFN_OPEN for action taken: */
#define ACTION_OPENED		1		/* existing file has been opened */
#define ACTION_CREATED		2		/* new file has been created */
#define ACTION_REPLACED		3		/* existing file has been replaced */

/** Values for ir_flags for VFN_SEARCH: */
#define SEARCH_FIRST		0		/* findfirst operation */
#define SEARCH_NEXT			1		/* findnext operation */

/** Values for ir_flags for VFN_DISCONNECT: */
#define	DISCONNECT_NORMAL	0	/* normal disconnect */
#define	DISCONNECT_NO_IO	1	/* no i/o can happen at this time */
#define	DISCONNECT_SINGLE	2	/* disconnect this drive only */

/** Values for ir_options for VFN_FLUSH: */
#define	VOL_DISCARD_CACHE	1
#define	VOL_REMOUNT			2

/** Values for ir_options for VFN_GETDISKINFO: */
#define GDF_EXTENDED_FREESPACE	0x01	/* Extended get free space for Fat32 */

/** Values for ir_options for VFN_IOCTL16DRIVE: */
#define IOCTL_PKT_V86_ADDRESS		0	/* V86 pkt address in user DS:DX */
#define IOCTL_PKT_LINEAR_ADDRESS	1	/* Linear address to packet in ir_data */

/** Values for ir_options for VFN_GETDISKPARMS: */
#define GDP_EXTENDED_PARMS		0x01	/* Extended disk parms for Fat32 */

/** Values for ir_flags for VFN_DASDIO:	*/
#define DIO_ABS_READ_SECTORS 		0	/* Absolute disk read */
#define DIO_ABS_WRITE_SECTORS		1	/* Absolute disk write */
#define DIO_SET_LOCK_CACHE_STATE	2	/* Set cache state during volume lock */
#define DIO_SET_DPB_FOR_FORMAT		3	/* Set DPB for format for Fat32 */

/** Values for ir_options for DIO_ABS_READ_SECTORS and DIO_ABS_WRITE_SECTORS: */
#define ABS_EXTENDED_DASDIO			0x01	/* Extended disk read/write */

/**	Values for ir_options for DIO_SET_LOCK_CACHE_STATE: */
#define DLC_LEVEL4LOCK_TAKEN	0x01	/* cache writethru, discard name cache */
#define DLC_LEVEL4LOCK_RELEASED	0x02	/* revert to normal cache state */
#define DLC_LEVEL1LOCK_TAKEN	0x04	/* cache writethru, discard name cache */
#define DLC_LEVEL1LOCK_RELEASED	0x08	/* revert to normal cache state */

/* These values for ir_options are used only on ring 0 apis */
#define R0_NO_CACHE				0x0100	/* must not cache reads/writes */
#define R0_SWAPPER_CALL			0x1000	/* called by the swapper */
#define R0_LOADER_CALL			0x2000	/* called by program loader */
#define R0_MM_READ_WRITE		0x8000	/* indicates this is a MMF R0 i/o */
#define R0_SPLOPT_MASK			0xFF00	/* mask for ring 0 special options */


/** Values for ir_attr for different file attributes: */

#define FILE_ATTRIBUTE_READONLY		0x01	/* read-only file */
#define FILE_ATTRIBUTE_HIDDEN		0x02	/* hidden file */
#define FILE_ATTRIBUTE_SYSTEM		0x04	/* system file */
#define FILE_ATTRIBUTE_LABEL		0x08	/* volume label */
#define FILE_ATTRIBUTE_DIRECTORY	0x10	/* subdirectory */
#define FILE_ATTRIBUTE_ARCHIVE		0x20	/* archived file/directory */

/* The second byte of ir_attr is a mask of attributes which "must match"
 * on a SEARCH or FINDOPEN call.  If an attribute bit is set in the
 * "must match" mask, then the file must also have that attribute set
 * to match the search/find.
 */
#define FILE_ATTRIBUTE_MUSTMATCH	0x00003F00	/* 00ADVSHR Must Match */
#define FILE_ATTRIBUTE_EVERYTHING	0x0000003F	/* 00ADVSHR Find Everything */
#define FILE_ATTRIBUTE_INTERESTING	0x0000001E	/* 000DVSH0 Search bits */

/*   Auto-generation flags returned from CreateBasis()
 */
#define	BASIS_TRUNC			0x01	/* original name was truncated     */
#define	BASIS_LOSS			0x02	/* char translation loss occurred  */
#define	BASIS_UPCASE		0x04	/* char in basis was upcased       */
#define	BASIS_EXT			0x20	/* char in basis is extended ASCII */

/*   Flags that SHOULD associated with detecting 'collisions' in the basis name
 *   and the numeric tail of a basis name.  They are defined here so that routines
 *   who need to flag these conditions use these values in a way that does not
 *   conflict with the previous three 'basis' flags.
 */
#define	BASIS_NAME_COLL		0x08	/* collision in the basis name component   */
#define	BASIS_NUM_TAIL_COLL	0x10	/* collision in the numeric-tail component */

/*	Flags returned by long-name FindOpen/Findnext calls.  The flags
 *	indicate whether a mapping from UNICODE to BCS of the primary and
 *	altername names in the find buffer have lost information.  This
 *	occurs whenever a UNICODE char cannot be mapped into an OEM/ANSI
 *	char in the codepage specified.
 */

#define	FIND_FLAG_PRI_NAME_LOSS			0x0001
#define	FIND_FLAG_ALT_NAME_LOSS			0x0002

/*	Flags returned by UNIToBCS, BCSToUni, UniToBCSPath, MapUniToBCS
 *  MapBCSToUni.  The flags indicate whether a mapping from UNICODE
 *  to BCS, or BCS to UNICODE have lost information.  This occurs
 *	whenever a char cannot be mapped.
 */

#define MAP_FLAG_LOSS					0x0001
#define MAP_FLAG_TRUNCATE				0x0002


/*NOINC*/
#define TestMustMatch(pir, attr)	(((((pir)->ir_attr & (attr)<<8)	\
											^ (pir)->ir_attr)		\
										& FILE_ATTRIBUTE_MUSTMATCH) == 0)
/*INC*/

/* These bits are also set in ir_attr for specific properties of the
 * pathname/filename.
 *
 * A filename is 8.3 compatible if it contains at most 8 characters before
 * a DOT or the end of the name, at most 3 chars after a DOT, at most one
 * DOT, and no new LFN only characters.  The new LFN characters are:
 * , + = [ ] ;
 *
 * If a name does not meet all of the 8.3 rules above then it is considered
 * to be a "long file name", LFN.
 */
#define FILE_FLAG_WILDCARDS	0x80000000	/* set if wildcards in name */
#define FILE_FLAG_HAS_STAR	0x40000000	/* set if *'s in name (PARSE_WILD also set) */
#define FILE_FLAG_LONG_PATH	0x20000000	/* set if any path element is not 8.3 */
#define FILE_FLAG_KEEP_CASE	0x10000000	/* set if FSD should use ir_uFName */
#define FILE_FLAG_HAS_DOT	0x08000000	/* set if last path element contains .'s */
#define FILE_FLAG_IS_LFN	0x04000000	/* set if last element is LFN */

/* Function definitions on the ring 0 apis function list:
 * NOTE: Most functions are context independent unless explicitly stated
 * i.e. they do not use the current thread context. R0_LOCKFILE is the only
 * exception - it always uses the current thread context.
 */
#define R0_OPENCREATFILE		0xD500	/* Open/Create a file */
#define R0_OPENCREAT_IN_CONTEXT	0xD501	/* Open/Create file in current context */
#define R0_READFILE				0xD600	/* Read a file, no context */
#define R0_WRITEFILE			0xD601	/* Write to a file, no context */
#define R0_READFILE_IN_CONTEXT	0xD602	/* Read a file, in thread context */
#define R0_WRITEFILE_IN_CONTEXT	0xD603	/* Write to a file, in thread context */
#define R0_CLOSEFILE			0xD700	/* Close a file */
#define R0_GETFILESIZE			0xD800	/* Get size of a file */
#define R0_FINDFIRSTFILE		0x4E00	/* Do a LFN FindFirst operation */
#define R0_FINDNEXTFILE			0x4F00	/* Do a LFN FindNext operation */
#define R0_FINDCLOSEFILE		0xDC00	/* Do a LFN FindClose operation */
#define R0_FILEATTRIBUTES		0x4300	/* Get/Set Attributes of a file */
#define R0_RENAMEFILE			0x5600	/* Rename a file */
#define R0_DELETEFILE			0x4100	/* Delete a file */
#define R0_LOCKFILE				0x5C00	/* Lock/Unlock a region in a file */
#define R0_GETDISKFREESPACE		0x3600	/* Get disk free space */
#define R0_READABSOLUTEDISK		0xDD00	/* Absolute disk read */
#define R0_WRITEABSOLUTEDISK	0xDE00	/* Absolute disk write */

/* Special definitions for ring 0 apis for drive information flags */

#define IFS_DRV_RMM		0x0001	/* drive is managed by RMM */
#define IFS_DRV_DOS_DISK_INFO		0x0002	/* drive needs DOS */


/*NOINC*/

/**	SetHandleFunc - set up routing info for a file handle.
 *
 *NOTE: the do {} while(0) construction below is necessary to obtain proper
 *		behavior when this macro is used in if statement body. Do not
 *		add a ; to the while (0) line!
 *
 *	Entry	(pir) = ptr to IOReq structure for request
 *			(read) = ptr to IO Function for reading from file
 *			(write) = ptr to IO Function for writting to file
 *			(table) = ptr to table of misc. IO Functions
 */

#define SetHandleFunc(pir, read, write, table)	\
	do {								\
		hfunc_t phf = (pir)->ir_hfunc;	\
		phf->hf_read = (read);			\
		phf->hf_write = (write);		\
		phf->hf_misc = (table);			\
	} while (0)


/**	SetVolumeFunc - set up routing info for a volume
 *
 *	Entry	(pir) = ptr to ioreq struct
 *			(table) = ptr to table of provider Functions
 */

#define SetVolumeFunc(pir, table) ((pir)->ir_vfunc = (table))

/*INC*/


/** search - Search record structure
 *
 * This strucure defines the result buffer format for search returns
 * for int21h based file searches: 11H/12H FCB Find First/Next
 *	and 4eH/4fH path based Find First/Next
 *
 * There are two areas in the search_record reserved for use by file system
 * drivers. One is to be used by local file systems such as FAT or CDROM
 * and the other is to be used by network file systems such as an SMB or
 * NCP client. The reason for the split is because many network file
 * systems send and receive the search key directly on the net.
 */

typedef struct srch_key srch_key;
struct srch_key {
	unsigned char	sk_drive;		/* Drive specifier (set by IFS MGR) */
	unsigned char	sk_pattern[11];	/* Reserved (pattern sought) */
	unsigned char	sk_attr;		/* Reserved (attribute sought) */
	unsigned char	sk_localFSD[4];	/* available for use local FSDs */
	unsigned char	sk_netFSD[2];	/* available for use by network FSDs */
	unsigned char	sk_ifsmgr[2];	/* reserved for use by IFS MGR */
}; /* srch_key */


typedef struct srch_entry srch_entry;
struct srch_entry {
	struct srch_key se_key;		/* resume key */
	unsigned char	se_attrib;	/* file attribute */
	unsigned short	se_time;	/* time of last modification to file */
	unsigned short	se_date;	/* date of last modification to file */
	unsigned long	se_size;	/* size of file */
	char		se_name[13];	/* ASCIIZ name with dot included */
}; /* srch_entry */


/** Win32 Date Time structure
 * This structure defines the new Win32 format structure for returning the
 * date and time
 */

typedef struct _FILETIME _FILETIME;
#ifndef _FILETIME_
struct _FILETIME {
	unsigned long	dwLowDateTime;
	unsigned long	dwHighDateTime;
}; /* _FILETIME */
#endif

/** Win32 Find Structure
 *  This structure defines the contents of the result buffer on a
 * Win32 FindFirst / FindNext. These calls are accessed by the new
 * LFN find apis
 */

typedef struct _WIN32_FIND_DATA _WIN32_FIND_DATA;
struct _WIN32_FIND_DATA {
	unsigned long		dwFileAttributes;
	struct _FILETIME	ftCreationTime;
	struct _FILETIME	ftLastAccessTime;
	struct _FILETIME	ftLastWriteTime;
	unsigned long		nFileSizeHigh;
	unsigned long		nFileSizeLow;
	unsigned long		dwReserved0;
	unsigned long		dwReserved1;
	unsigned short		cFileName[MAX_PATH];	/* includes NUL */
	unsigned short		cAlternateFileName[14];	/* includes NUL */
};	/* _WIN32_FIND_DATA */


/** Win32 File Info By Handle Structure
 *  This structure defines the contents of the result buffer on a
 *  Win32 FileInfoByHandle. These calls are accessed by the new
 *  LFN find apis
 */

typedef struct _BY_HANDLE_FILE_INFORMATION _BY_HANDLE_FILE_INFORMATION;
struct _BY_HANDLE_FILE_INFORMATION { /* bhfi */
	unsigned long		bhfi_dwFileAttributes;
	struct _FILETIME	bhfi_ftCreationTime;
    struct _FILETIME	bhfi_ftLastAccessTime;
	struct _FILETIME	bhfi_ftLastWriteTime;
	unsigned long		bhfi_dwVolumeSerialNumber;
	unsigned long		bhfi_nFileSizeHigh;
	unsigned long		bhfi_nFileSizeLow;
	unsigned long		bhfi_nNumberOfLinks;
	unsigned long		bhfi_nFileIndexHigh;
	unsigned long		bhfi_nFileIndexLow;
};	/* _BY_HANDLE_FILE_INFORMATION */


/* these are win32 defined flags for GetVolInfo */

#define	FS_CASE_IS_PRESERVED		0x00000002
#define	FS_UNICODE_STORED_ON_DISK	0x00000004

/* these flags for GetVolInfo are NOT defined */

#define	FS_VOL_IS_COMPRESSED		0x00008000
#define FS_VOL_SUPPORTS_LONG_NAMES	0x00004000


/* these flags are returned by IFSMgr_Get_Drive_Info	*/

#define	FDRV_INT13		0x01
#define	FDRV_FASTDISK	0x02
#define	FDRV_COMP		0x04
#define	FDRV_RMM		0x08
#define	FDRV_DOS		0x10
#define	FDRV_USE_RMM	0x20
#define	FDRV_COMPHOST	0x40
#define	FDRV_NO_LAZY	0x80


/** TUNINFO - Tunneling Information
 *	This structure defines the information passed into the FSD on
 *	a Create or Rename operation if tunneling was detected.  This
 *	gives a set of advisory information to create the new file with.
 *	if ir_ptuninfo is NULL on Create or Rename, none of this information
 *	is available.  All of this information is advisory.  tuni_bfContents
 *	defines what pieces of tunneling information are available.
 */

typedef struct	TUNINFO		TUNINFO;
struct TUNINFO {
	unsigned long		tuni_bfContents;
	short			   *tuni_pAltName;
	struct _FILETIME	tuni_ftCreationTime;
	struct _FILETIME	tuni_ftLastAccessTime;
	struct _FILETIME	tuni_ftLastWriteTime;
}; /* TUNINFO */

#define TUNI_CONTAINS_ALTNAME		0x00000001	/* pAltName available */
#define TUNI_CONTAINS_CREATIONT		0x00000002	/* ftCreationTime available */
#define TUNI_CONTAINS_LASTACCESST	0x00000004	/* ftLastAccessTime available */
#define TUNI_CONTAINS_LASTWRITET	0x00000008	/* ftLastWriteTime available */


/** _QWORD - 64-bit data type
 *  A struct used to return 64-bit data types to C callers
 *  from the qwUniToBCS & qwUniToBCS rotuines.  These
 *  'routines' are just alias' for UntoToBCS & UniToBCSPath
 *  routines and do not exist as separate entities.  Both
 *  routines always return a 64-bit result.  The lower
 *  32-bits are a length.  The upper 32-bits are flags.
 *  Typically, the flag returned indicates whether a mapping
 *  resulted in a loss on information in the UNICODE to BCS
 *  translation (i.e. a unicode char was converted to an '_').
 */

typedef struct _QWORD _QWORD;
struct _QWORD {
	unsigned long	ddLower;
	unsigned long	ddUpper;
}; /* _QWORD */


/** ParsedPath - structure of an IFSMgr parsed pathname */

struct PathElement {
	unsigned short	pe_length;
	unsigned short	pe_unichars[1];
}; /* PathElement */

struct ParsedPath {
	unsigned short	pp_totalLength;
	unsigned short	pp_prefixLength;
	struct PathElement pp_elements[1];
}; /* ParsedPath */


/** Macros to mainipulate parsed pathnames receieved from IFSMgr */

/*NOINC*/
#define IFSPathSize(ppath)	((ppath)->pp_totalLength + sizeof(short))
#define IFSPathLength(ppath) ((ppath)->pp_totalLength - sizeof(short)*2)
#define IFSLastElement(ppath)	((PathElement *)((char *)(ppath) + (ppath)->pp_prefixLength))
#define IFSNextElement(pel)	((PathElement *)((char *)(pel) + (pel)->pe_length))
#define IFSIsRoot(ppath)	((ppath)->pp_totalLength == 4)
/*INC*/

/** Function prototypes for IFSMgr services */

/* Values for charSet passed to character conversion routines */
#define BCS_WANSI	0	/* use Windows ANSI set */
#define BCS_OEM		1	/* use current OEM character set */
#define BCS_UNI		2	/* use UNICODE character set */


/*   Matching semantics flags passed to MetaMatchUni() */
#define UFLG_META	0x01
#define UFLG_NT		0x02
#define UFLG_NT_DOS	0x04
#define UFLG_DOS	0x00

/* define the utb and btu ptr table structures */

typedef struct CPPtrs CPPtrs;
struct CPPtrs {
	unsigned long	AnsiPtr;
	unsigned long	OEMPtr;
}; /* CPPtrs */


typedef struct	UnitoUpperTab UnitoUpperTab;
struct UnitoUpperTab {
	unsigned long	delta;
	unsigned	long	TabPtr;
}; /* UnitoUpperTab */
	
typedef struct	CPTablePtrs CPTablePtrs;
struct CPTablePtrs {
	unsigned long	CPT_Length;
	struct CPPtrs utbPtrTab;
	struct CPPtrs btuPtrTab;
	struct UnitoUpperTab UnitoUpperPtr;
}; /* CPTablePtrs */


/*NOINC*/
unsigned int  _cdecl UniToBCS(
					unsigned char	*pStr,
					string_t 		pUni,
					unsigned int	length,
					unsigned int	maxLength,
					unsigned int	charSet);


unsigned int UniToBCSPath(
					unsigned char	*pStr,
					PathElement		*pPth,
					unsigned int	maxLength,
					int				charSet);


_QWORD qwUniToBCS(
					unsigned char	*pStr,
					string_t 		pUni,
					unsigned int	length,
					unsigned int	maxLength,
					unsigned int	charSet);


_QWORD qwUniToBCSPath(
					unsigned char	*pStr,
					PathElement		*pPth,
					unsigned int	maxLength,
					int				charSet);


unsigned int  _cdecl BCSToUni(
					string_t		pUni,
					unsigned char	*pStr,
					unsigned int	length,
					int				charSet);


unsigned int UniToUpper(
					string_t		pUniUp,
					string_t		pUni,
					unsigned int	length);


unsigned int BCSToBCS (unsigned char *pDst,
                       unsigned char *pSrc,
                       unsigned int  dstCharSet,
                       unsigned int  srcCharSet,
                       unsigned int  maxLen);


unsigned int BCSToBCSUpper (unsigned char *pDst,
                       unsigned char *pSrc,
                       unsigned int  dstCharSet,
                       unsigned int  srcCharSet,
                       unsigned int  maxLen);


/* Map a single Unicode character to OEM
 *	Entry	(uniChar) - character to map
 *
 *	Returns	(oemChar) - character in OEM set
 *			  (if oemChar > 255, then DBCS character with
 *				lead byte in LSB and trail byte in next byte)
 */
unsigned int  _cdecl UniCharToOEM(unsigned short uniChar);


unsigned int IFSMgr_MetaMatch(
					string_t		pUniPat,
					string_t		pUni,
					int MatchSem);

/** IFSMgr_TransMatch - translate and match
 *
 *	The routine converts a DOS format 43 bytes search buffer into
 * _WIN32_FIND_DATA format and will optionally perform attribute and
 * pattern matching on the entry.
 *
 *	Entry	(pir) - ptr to ioreq structure
 *			  ir_attr - attribute value from FINDOPEN call.
 *			(pse) - ptr to DOS format search buffer
 *			(pattern) - ptr to Unicode pattern string (0 terminated)
 *			(pwf) - ptr to _WIN32_FIND_DATA structure to fill in
 *	Exit	!= 0 if match
 *			  ir_pos - value from sk_localFSD.
 *						(used for restarting finds)
 *			0 if no match
 */
int IFSMgr_TransMatch(
					pioreq		pir,
					srch_entry	*pse,
					string_t	pattern,
					_WIN32_FIND_DATA *pwf);


/** Time format conversion routines
 *
 *	These routines will convert from time/date information between
 * the various formats used and required by IFSMgr and FSDs.
 */

extern _FILETIME  _cdecl IFSMgr_DosToWin32Time(dos_time dt);

extern _FILETIME IFSMgr_NetToWin32Time(unsigned long time);

extern dos_time IFSMgr_Win32ToDosTime(_FILETIME ft);

extern dos_time IFSMgr_NetToDosTime(unsigned long time);

extern unsigned long IFSMgr_DosToNetTime(dos_time dt);

extern unsigned long IFSMgr_Win32ToNetTime(_FILETIME ft);


/** IFSMgr_CallProvider - call file system provider
 *
 *	The IFSMgr makes all calls to file system providers via this
 * service.  It is possible for a VxD to hook this service to monitor
 * file system operations.
 *
 *	Entry	(pir) - ptr to ioreq structure
 *			(fnID) - function ID (see IFSFN_* above)
 *			(ifn) - provider function being called
 *	Exit	return code from provider
 */
int IFSMgr_CallProvider(pioreq pir, int fnID, pIFSFunc ifn);

/* These definitions are used by MSNET32 for */
/* making DeviceIOControl calls to ifsmgr */

#define IFS_IOCTL_21				100
#define IFS_IOCTL_2F				101
#define	IFS_IOCTL_GET_RES			102
#define IFS_IOCTL_GET_NETPRO_NAME_A	103	

struct win32apireq {
	unsigned long 	ar_proid;
	unsigned long  	ar_eax;		
	unsigned long  	ar_ebx;	
	unsigned long  	ar_ecx;	
	unsigned long  	ar_edx;	
	unsigned long  	ar_esi;	
	unsigned long  	ar_edi;
	unsigned long  	ar_ebp;		
	unsigned short 	ar_error;
	unsigned short  ar_pad;
}; /* win32apireq */

/* This structure is passed to IFSMgr_UseAdd and */
/* IFSMgr_UseDel */

typedef struct netuse_info netuse_info;
struct netuse_info {
	void			*nu_data;
	int				nu_info;	/* del use only */
	unsigned long	nu_flags;
	unsigned long	nu_rsvd;	
};	/* netuse_info */

/* values for nu_flags */

#define FSD_NETAPI_USEOEM	0x00000001		/* strings are OEM */
#define FSD_NETAPI_STATIC	0x00000002		/* drive redirection can */
											/* only be removed at shutdown */
#define FSD_NETAPI_USELFN	0x00000004      /* treat remote name as lfn */
/*INC*/


struct fmode_t {			/* File mode information */
    unsigned long fm_uid;		/* User ID */
    void *fm_cookie0;			/* Caller-supplied cookie */
    void *fm_cookie1;			/* Caller-supplied cookie */
    unsigned short fm_mode;		/* File sharing mode and access */
    unsigned short fm_attr;		/* File attributes */
}; /* fmode_t */

typedef struct fmode_t fmode_t;		/* Type definition */

/*
 *	These flags are used on the Win32 service to duplicate an extended handle
 *
 */

#define DUP_NORMAL_HANDLE		0x00	// dup handle for normal file io
#define DUP_MEMORY_MAPPED		0x01	// dup handle for memory-mapping
#define DUP_MEM_MAPPED_WRITE	0x02 	// mem mapping is for write if set,
										// is for read if clear.
/*
 * These constants for the different subfunctions on NameTrans (7160h)
 *
 */

#define NAMTRN_NORMALQUERY		0x00	// normal LFN NameTrans operation
#define NAMTRN_DO83QUERY		0x01	// NameTrans to return full 8.3 name
#define NAMTRN_DOLFNQUERY		0x02	// NameTrans to return full LFN name

/*
 * These constants are used for the different subfunctions on Get List Of
 * Open Files (440dh, 086Dh)
 *
 */

#define ENUM_ALL_FILES			0x00	// enumerate all open files
#define ENUM_UNMOVEABLE_FILES	0x01	// enumerate only unmoveable files

/** Structure for the open file information from DOS to take over open files.
 */

typedef struct SFTOpenInfo SFTOpenInfo;
typedef struct SFTOpenInfo *pSFTOpenInfo;
struct SFTOpenInfo {
	unsigned long  soi_dirclus;		// cluster # for directory
	unsigned short soi_dirind;		// directory index of dir entry
	unsigned char  soi_dirname[11];	// directory entry name
	unsigned char  soi_pad[3];		// pad out for dword boundary
};	/* SFTOpenInfo */

/*NOINC*/

/** Win32DupHandle service and associated constants.
 */

extern int _cdecl Win32DupHandle( pid_t srcpid,
  								  pid_t duppid,
  								  unsigned long *phandle,
  								  unsigned char flag,
  								  unsigned long globNWHandle,
  								  unsigned long *fReturnFlags );

/** Values for fReturnFlags: */
#define WDUP_RMM_DRIVE		0x01			// file mapped on a RMM drive
#define WDUP_NETWARE_HANDLE	0x02			// handle belongs to Netware


#endif	/* IFS_INC */
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\daytona\nullincs.tmp\vxdwraps.h ===
//null .h file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\daytona\nullincs.tmp\io.h ===
//null .h file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\daytona\nullincs.tmp\net32def.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/********************************************************************/
/*                                                                  */
/* This file contains definition that are required to make a .h     */
/* file compatable with 32-bit compiler.                            */
/*                                                                  */
/* History:                                                         */
/*	Madana	 08/03/90	- Initial coding		    */
/*	DavidHov 12/14/90	- added #undef for C++		    */
/*								    */
/********************************************************************/

/*NOINC*/

#if !defined(WIN32)
#if !defined(NET32DEF_INCLUDED)
	#define NET32DEF_INCLUDED
	#if !defined(OS2DEF_INCLUDED)
		#if !defined(FLAT_DEF)
			#if !(defined(INCL_32) || defined(INCL_16))
				#if defined(M_I386) || _M_IX86 >= 300	/* compiler const. */
					#define	INCL_32
				#else
					#define	INCL_16
				#endif
			#endif /* INCL_32 || INCL_16 */
			#undef PASCAL
			#undef FAR
			#undef NEAR
			#undef APIENTRY
			#undef NEAR_APIENTRY
			#if defined(INCL_32)
				#define	PASCAL		/* null string */
				#define FAR		/* null string */
				#define NEAR		/* null string */
				#define	APIENTRY	_cdecl
				#define NEAR_APIENTRY	_cdecl
			#else
				#define PASCAL		_pascal
				#define FAR		_far
				#define NEAR		_near
				#define APIENTRY	FAR PASCAL
				#define NEAR_APIENTRY	_near PASCAL
			#endif /* INCL_32 */

			#define FLAT_DEF
		#endif /* ! FLAT_DEF */
	#else
		#if !defined(FLAT_DEF)
			#if defined(INCL_32)
				#define NEAR_APIENTRY	_cdecl
			#else
				#define NEAR_APIENTRY	_near PASCAL
			#endif

			#define FLAT_DEF
		#endif /* FLAT_DEF */
	#endif /* OS2DEF_INCLUDED */
#endif /* NET32DEF_INCLUDED */

#endif

/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\daytona\nullincs.tmp\neterr.h ===
//redirect this to the new name in sdkinc
//#include "lmerr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\daytona\nullincs.tmp\vmm.h ===
//null .h file so as not to confuse build
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\daytona\nullincs.tmp\netcons.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/********************************************************************
 *                                                                  *
 *  About this file ...  NETCONS.H                                  *
 *                                                                  *
 *  This file contains constants used throughout the LAN Manager    *
 *  API header files.  It should be included in any source file     *
 *  that is going to include other LAN Manager API header files or  *
 *  call a LAN Manager API.                                         *
 *                                                                  *
 ********************************************************************/

/*
 *      NOTE:  Lengths of ASCIIZ strings are given as the maximum
 *      strlen() value.  This does not include space for the
 *      terminating 0-byte.  When allocating space for such an item,
 *      use the form:
 *
 *              char username[UNLEN+1];
 *
 *      An exception to this is the PATHLEN manifest, which does
 *      include space for the terminating 0-byte.
 */

/*NOINC*/
#ifndef NETCONS_INCLUDED

#include <net32def.h>

#define NETCONS_INCLUDED

//#ifndef RC_INVOKED
//#pragma pack(1)         /* Assume byte packing throughout */
//#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*INC*/

#define CNLEN           15                  /* Computer name length     */
#define UNCLEN          (CNLEN+2)           /* UNC computer name length */
#define NNLEN           12                  /* 8.3 Net name length      */
#define RMLEN           (UNCLEN+1+NNLEN)    /* Maximum remote name length */

#define SNLEN           15                  /* Service name length      */
#define STXTLEN         63                  /* Service text length      */

/**INTERNAL_ONLY**/
#ifdef DOS3
#define PATHLEN         128
#else  /* DOS3 */

#define PATHLEN1_1      128
#define COMPLEN1_1      (8 + 1 + 3)     /* 8.3 */

/* Determine if the CCHMAXPATH manifest is defined (and use it).
 * If it isn't, then the source file in question isn't using OS2.H,
 * and we display a warning message.
 */
#ifdef CCHMAXPATH
#define PATHLEN         CCHMAXPATH
#else  /* CCHMAXPATH */
/**END_INTERNAL**/
#define PATHLEN         260
/**INTERNAL_ONLY**/
#endif /* CCHMAXPATH */
#endif /* DOS3 */

/* BUG20.7067 - We define MAXPATHLEN to be equivalent to PATHLEN.  This
 *          should be removed.
 */
#ifndef MAXPATHLEN
#define MAXPATHLEN      PATHLEN
#endif /* not MAXPATHLEN */
/**END_INTERNAL**/

#define DEVLEN           8                  /* Device name length       */

/**INTERNAL_ONLY**/
/* WARNING:  DNLEN must be the same as CNLEN.  We have a sanity check
 *           below which verifies this.
 */
/**END_INTERNAL**/
#define DNLEN           CNLEN               /* Maximum domain name length */
#define EVLEN           16                  /* event name length        */
#define JOBSTLEN        80                  /* status length in print job */
#define AFLEN           64                  /* Maximum length of alert  */
                                            /* names field              */
#define UNLEN           20                  /* Maximum user name length */
#define GNLEN           UNLEN               /* Group name               */
#define PWLEN           14                  /* Maximum password length  */
#define SHPWLEN          8                  /* Share password length    */
#define CLTYPE_LEN      12                  /* Length of client type string */


#define MAXCOMMENTSZ    48                  /* server & share comment length */

#define QNLEN           12                  /* Queue name maximum length     */
/**INTERNAL_ONLY**/
/*NOINC*/
#if (QNLEN != NNLEN)
# error QNLEN and NNLEN are not equal
#endif
/*INC*/
/**END_INTERNAL**/
#define PDLEN            8                  /* Print destination length      */
#define DTLEN            9                  /* Spool file data type          */
                                            /* e.g. IBMQSTD,IBMQESC,IBMQRAW  */
#define ALERTSZ         128                 /* size of alert string in server */
//#define MAXDEVENTRIES   (sizeof (int)*8)    /* Max number of device entries   */
#define MAXDEVENTRIES   32    				/* Max number of device entries   */
                                            /* We use int bitmap to represent */
#define MAXRDRSRVNAM    2               /* max names rdr/svr can use (not */
                                        /* including services) */

#define HOURS_IN_WEEK           24*7        /* for struct user_info_2 in UAS */
#define MAXWORKSTATIONS         8           /* for struct user_info_2 in UAS */

#define NETBIOS_NAME_LEN        16          /* NetBIOS net name */


/**INTERNAL_ONLY**/
#ifdef  USHRT_MAX
#define MAX_API_BUFFER_SIZE     USHRT_MAX
#else
#define MAX_API_BUFFER_SIZE     0xffff
#endif

#define WRKHEUR_COUNT           54

#define WORKBUFSIZE             4096

#define SMBANDXPAD              212         /* Added to each rdr & srv wrkbuf */
#define SMB_HDR_SZ              48          /* Added to each rdr & srv wrkbuf */

                                            /* WARNING: The following two    */
                                            /*  defines are dependent upon   */
                                            /*  rdr data structures!!!       */
#define RDR_SMB_LINK_SZ         8           /* Additional amount rdr adds to */
                                            /*  to each work buf             */
#define RDR_SMB_SEG_HD_SZ       20          /* Amount of rdr overhd per each */
                                            /*  workbuf segment              */

#define MAXSRVWRKSEGS           80          /* 64K segs for srv work bufs */
#define MAXRDRWRKSEGS           1           /* 64K segs for rdr work bufs */
#define MAXRDRBIGBUFSEGS        10          /* rdr 64K big buf segs */
/**END_INTERNAL**/

/*
 *      Constants used with encryption
 */

#define CRYPT_KEY_LEN   7
#define CRYPT_TXT_LEN   8
#define ENCRYPTED_PWLEN 16
#define SESSION_PWLEN   24
#define SESSION_CRYPT_KLEN 21

/*
 *  Value to be used with SetInfo calls to allow setting of all
 *  settable parameters (parmnum zero option)
*/
#ifndef  PARMNUM_ALL
#define         PARMNUM_ALL             0
#endif

/*
 *      Message File Names
 */

#define MESSAGE_FILE            "NETPROG\\NET.MSG"
#define MESSAGE_FILENAME        "NET.MSG"
#define OS2MSG_FILE             "NETPROG\\OSO001.MSG"
#define OS2MSG_FILENAME         "OSO001.MSG"
#define HELP_MSG_FILE           "NETPROG\\NETH.MSG"
#define HELP_MSG_FILENAME       "NETH.MSG"
#define OS2HELP_MSG_FILE        "NETPROG\\OSO001H.MSG"
#define OS2HELP_MSG_FILENAME    "OSO001H.MSG"
#define NMP_MSG_FILE            "NETPROG\\NMP.MSG"
#define NMP_MSG_FILENAME        "NMP.MSG"

#define MESSAGE_FILE_BASE       "NETPROG\\NET00000"
#define MESSAGE_FILE_EXT        ".MSG"

/**INTERNAL_ONLY**/

/* The backup message file named here is a duplicate of net.msg. It
 * is not shipped with the product, but is used at buildtime to
 * msgbind certain messages to netapi.dll and some of the services.
 * This allows for OEMs to modify the message text in net.msg and
 * have those changes show up.  Only in case there is an error in
 * retrieving the messages from net.msg do we then get the bound
 * messages out of bak.msg (really out of the message segment).
 */

#define BACKUP_MSG_FILENAME     "BAK.MSG"

/**END_INTERNAL**/


#define NMP_LOW_END             230
#define NMP_HIGH_END            240

#ifndef NULL
#define  NULL    0
#endif


/*NOINC*/
#define PUNAVAIL NULL
#define API_RET_TYPE unsigned

#ifndef DLLAPI

#ifdef IS_32

/* for 32-bit code, no extra stuff is needed for APIs (like __loadds). */
#define DLLAPI

#else // IS_32 not defined

#if defined(_WINDLL)

#define DLLAPI _loadds
#elif defined(BUILDDLL)
  #define DLLAPI _loadds
#else
#define DLLAPI

#endif // IS_32

#endif // _WINDLL

#endif // DLLAPI

#define API_FUNCTION API_RET_TYPE APIENTRY DLLAPI
/*INC*/


/**INTERNAL_ONLY**/
/*NOINC*/
/* Sanity check to verify that CNLEN == DNLEN */
#if (CNLEN != DNLEN)
#error CNLEN and DNLEN are not equal
#endif
/*INC*/
/**END_INTERNAL**/

typedef const unsigned char FAR * CPSZ ;

/* The following are stolen from OS2DEF.H and should be removed when
 * all references to the obsolete DOSCALLS.H are removed.
 */
#if ! defined(WIN32)
#define INT     int
typedef unsigned char BYTE;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef unsigned char FAR  *PSZ;
typedef USHORT FAR *PUSHORT;
typedef ULONG  FAR *PULONG;
typedef unsigned short SEL;
#endif

/**INTERNAL_ONLY**/

/********************************************************************
 *
 *      There are (at present) six (6) files which are processed
 *      by the mapmsg utility to create an input file for the os
 *      utility mkmsgf.  Each of these files has a non-overlapping
 *      range of MESSAGE numbers assigned to it.  In addtion, the
 *      file neterr.h has a range of ERROR numbers.  The error
 *      numbers do not overlap with the error numbers assigned to
 *      other os components.
 *
 *      The ERROR number range in neterr.h is 2100 to 2999.  The
 *      range 2750 - 2799 has been reserved for IBM.  The range
 *      2900 - 2999 has been reserved for other Microsoft OEMs.
 *
 *      The MESSAGE number range is as follow:
 *
 *      neterr.h:       the same as the error range, 2100-2999, with some
 *                      reserved for IBM, and some reserved for other
 *                      Microsoft OEMs.
 *      alertmsg.h:     3000 - 3049
 *      service.h:      3050 - 3099
 *      errlog.h:       3100 - 3299
 *      msgtext.h:      3300 - 3499
 *      apperr.h:       3500 - (where ever it chooses to stop)
 *
 *     WARNING *** WARNING *** WARNING
 *
 *   The redirector has hardcoded in its
 *   makefile some message numbers used
 *   at startup.  If you change MTXT_BASE
 *   or any of the redirs message numbers
 *   you must also fix the redir makefile
 *   where it generates netwksta.pro
 *
 ********************************************************************/

/**END_INTERNAL**/

/*NOINC*/
#ifdef __cplusplus
}
#endif	/* __cplusplus */

//#ifndef RC_INVOKED
//#pragma pack()          /* Revert to default packing */
//#endif

#endif /* NETCONS_INCLUDED */
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\inc.tmp\shdcom.h ===
#error shdcom.h is no longer in recm\inc.tmp.....it's in csc\inc

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\umreclib\precomp.h ===
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include "shdsys.h"
#include "assert.h"
#include <winbase.h>
#include "shdcom.h"
#include "oslayeru.h"
#include "cscsec.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\umreclib\osutils.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

     Utils.c

Abstract:

     none.

Author:

     Shishir Pardikar      [Shishirp]        01-jan-1995

--*/

#include "precomp.h"
#pragma hdrstop


#define  SIGN_BIT 0x80000000
#define  UCHAR_OFFLINE  ((USHORT)'_')
#define  HIGH_ONE_SEC    0x98
#define  LOW_ONE_SEC     0x9680

#pragma intrinsic (memcmp, memcpy, memset, strcat, strcmp, strcpy, strlen)
#define cBackSlash    '\\'
#define cNull          0

char vrgchLibBuff[1024];
char vrgchLibBuff2[1024+25];
DWORD    dwDebugLogVector;
extern DWORD vdwAgentSessionId;

AssertData
AssertError

int HexToA(
     ULONG ulHex,
     LPSTR lpName,
     int count
     )
{
    int i;
    LPSTR lp = lpName+count-1;
    UCHAR uch;

    for (i=0; i<count; ++i)
     {
         uch = (UCHAR)(ulHex & 0xf) + '0';
         if (uch > '9')
               uch += 7;     // A becomes '0' + A + 7 which is 'A'
         *lp = uch;
         --lp;
         ulHex >>= 4;
     }
    *(lpName+count) = cNull;
    return 0;
}


ULONG AtoHex(
     LPSTR lpStr,
     int count
)
{
     int i;
     LPSTR lp = lpStr;
     UCHAR uch;
     ULONG ulHex = 0L;

     for (i=0; i<count; ++i)
      {
          // a fake shift the very first time
          ulHex <<= 4;
          uch = *lp;
          if (uch>= '0' && uch <= '9')
                ulHex += (uch - '0');
          else if (uch >= 'A' && uch <= 'F')
                ulHex += (uch - '0' - 7);
          else
                break;
          ++lp;
      }
     return ulHex;
 }


ULONG strmcpy( LPSTR lpDst,
	LPSTR lpSrc,
     ULONG cTchar
     )
 {
     ULONG i;

     if (!cTchar)
          return 0;
     for(i=cTchar;i;--i)
          if (!(*lpDst++ = *lpSrc++))
						     break;
     lpDst[cTchar-i] ='\0';

     return(cTchar-i);
 }

ULONG wstrlen(
     USHORT *lpuStr
     )
 {
     ULONG i;

     for (i=0; *lpuStr; ++lpuStr, ++i);
     return (i);
 }

int CompareSize(
     long nHighDst,
     long nLowDst,
     long nHighSrc,
     long nLowSrc
     )
 {
     int iRet = 0;

     if (nHighDst > nHighSrc)
          iRet = 1;
     else if (nHighDst == nHighSrc)
      {
          if (nLowDst > nLowSrc)
                iRet = 1;
          else if (nLowDst == nLowSrc)
                iRet = 0;
          else
                iRet = -1;
      }
     else
          iRet = -1;
     return (iRet);
 }


LPSTR mystrpbrk(
     LPSTR lpSrc,
     LPSTR lpDelim
     )
{
    char c, c1;
    LPSTR lpSav;
    BOOL fBegin = FALSE;

 for(;c = *lpSrc; ++lpSrc)
     {
         // skip leading blanks
         if (!fBegin)
           {
               if (c==' ')
                    continue;
               else
                    fBegin = TRUE;
           }

         lpSav = lpDelim;
         while (c1 = *lpDelim++)
           {
               if (c==c1)
                    return (lpSrc);
           }
         lpDelim = lpSav;
     }
    return (NULL);
}

LPVOID mymemmove(
     LPVOID     lpDst,
     LPVOID     lpSrc,
     ULONG size
     )
{
    int i;

    if (!size)
         return (lpDst);

    // if lpDst does not fall within the source array, just do memcpy
    if (!(
                ( lpDst > lpSrc )
                    && ( ((LPBYTE)lpDst) < ((LPBYTE)lpSrc)+size )     ))
     {
         memcpy(lpDst, lpSrc, size);
     }
    else
     {
         // do reverse copy
         for (i=size-1;i>=0;--i)
           {
               *((LPBYTE)lpDst+i) = *((LPBYTE)lpSrc+i);
           }
     }
    return (lpDst);
}


VOID
IncrementFileTime(
     FILETIME *lpft
    )
{
    DWORD dwTemp = lpft->dwLowDateTime;

    ++lpft->dwLowDateTime;

    // if it rolled over, there was a carry
    if (lpft->dwLowDateTime < dwTemp)
         lpft->dwHighDateTime++;

}

unsigned int
UniToBCS (
     unsigned char  *pStr,
     unsigned short *pUni,
     unsigned int length,
     unsigned int maxLength,
     int charSet
)
{
     BOOL fDefSet;

     UINT uCodePage = (charSet == BCS_OEM)?CP_OEMCP:CP_ACP;
     return(WideCharToMultiByte(uCodePage, WC_DEFAULTCHAR, pUni, length/2, pStr, maxLength, NULL, &fDefSet));
}

unsigned int
BCSToUni (
     unsigned short *pUni,
     unsigned char  *pStr,
     unsigned int length,
     int charSet
)
{
     UINT uCodePage = (charSet == BCS_OEM)?CP_OEMCP:CP_ACP;

     return (MultiByteToWideChar(uCodePage, MB_PRECOMPOSED, pStr, length, pUni, length));
}

VOID __cdecl AssertFn(LPSTR lpMsg, LPSTR lpFile, ULONG uLine)
{
   wsprintf(vrgchLibBuff, "Line %u file %s", uLine, lpFile);
   MessageBox(NULL, vrgchLibBuff, NULL, MB_OK);
}

VOID
__cdecl PrintFn(
    LPSTR lpFmt,
    ...
    )
{
    va_list base;

    va_start(base,lpFmt);

    wvsprintf(vrgchLibBuff, lpFmt, base);
    if (vdwAgentSessionId != 0xffff)
        sprintf(vrgchLibBuff2, "%05d:%s", vdwAgentSessionId, vrgchLibBuff);
    else
        sprintf(vrgchLibBuff2, "%s", vrgchLibBuff);
    OutputDebugString(vrgchLibBuff2);
}

int CompareTimes(
    FILETIME ftDst,
    FILETIME ftSrc
   )
{
    int iRet = 0;

    if (ftDst.dwHighDateTime > ftSrc.dwHighDateTime)
        iRet = 1;
    else if (ftDst.dwHighDateTime == ftSrc.dwHighDateTime)
    {
        if (ftDst.dwLowDateTime > ftSrc.dwLowDateTime)
            iRet = 1;
        else if (ftDst.dwLowDateTime == ftSrc.dwLowDateTime)
            iRet = 0;
        else
            iRet = -1;
    }
    else
        iRet = -1;
    return (iRet);
}


int DosToWin32FileSize( unsigned long uDosFileSize,
   int *lpnFileSizeHigh,
   int *lpnFileSizeLow
   )
   {
   int iRet;

   if (uDosFileSize & SIGN_BIT)
      {
      *lpnFileSizeHigh = 1;
      *lpnFileSizeLow = uDosFileSize & SIGN_BIT;
      iRet = 1;
      }
   else
      {
      *lpnFileSizeHigh = 0;
      *lpnFileSizeLow = uDosFileSize;
      iRet = 0;
      }
   return (iRet);
   }

int Win32ToDosFileSize( int nFileSizeHigh,
   int nFileSizeLow,
   unsigned long *lpuDosFileSize
   )
   {
   int iRet;
   Assert(nFileSizeHigh <= 1);
   *lpuDosFileSize = nFileSizeLow;
   if (nFileSizeHigh == 1)
      {
      *lpuDosFileSize += SIGN_BIT;
      iRet = 1;
      }
   else
      iRet = 0;
   return (iRet);
   }

int CompareTimesAtDosTimePrecision(
	FILETIME ftDst,
	FILETIME ftSrc
    )
{
	WORD wdateDst, wtimeDst;
	WORD wdateSrc, wtimeSrc;

	if (FileTimeToDosDateTime((CONST FILETIME *)&ftSrc, &wdateSrc, &wtimeSrc) &&
		FileTimeToDosDateTime((CONST FILETIME *)&ftDst, &wdateDst, &wtimeDst)
		)
	{
		if (wdateDst > wdateSrc)
		{
			return 1;
		}
		else if (wdateDst < wdateSrc)
		{
			return -1;
		}
		else
		{	// same dates
			if (wtimeDst > wtimeSrc)
			{
				return 1;
			}
			else if(wtimeDst < wtimeSrc)
			{
					return -1;
			}
			else
			{
				return 0;
			}
		}
	}
	return -1;

}



int
PUBLIC
mystrnicmp(
    const char *pStr1,
    const char *pStr2,
    unsigned count
    )
{
    char c1, c2;
    int iRet;
    unsigned i=0;

    for(;;)
    {
        c1 = *pStr1++;
        c2 = *pStr2++;
        c1 = _toupper(c1);
        c2 = _toupper(c2);
        if (c1!=c2)
            break;
        if (!c1)
            break;
        if (++i >= count)
            break;
    }
    iRet = ((c1 > c2)?1:((c1==c2)?0:-1));
    return iRet;
}

int ShadowLog(
    LPSTR lpFmt,
    ...
    )
{
    return (0);
}

int TerminateShadowLog(VOID)
{
    return 0;
}

BOOL
IterateOnUNCPathElements(
    USHORT  *lpuPath,
    PATHPROC lpfn,
    LPVOID  lpCookie
    )
/*++

Routine Description:

    This routine takes a unicode UNC path and iterates over each path element, calling the
    callback function. Thus for a path \\server\share\dir1\dir2\file1.txt, the function makes
    the following calls to the lpfn callback function

    (lpfn)(\\server\share, \\server\share, lpCookie)
    (lpfn)(\\server\share\dir1, dir1, lpCookie)
    (lpfn)(\\server\share\dir1\dir2, dir2, lpCookie)
    (lpfn)(\\server\share\dir1\dir2\file1, file1, lpCookie)

Arguments:

    lpuPath     NULL terminated unicode string (NOT NT style, just a plain unicode string)

    lpfn        callback function. If the function returns TRUE on a callback, the iteration
                proceeds, else it terminates

    lpCookie    context passed back on each callback

Returns:

    return TRUE if the entire iteration went through, FALSE if some error occurred or the callback
    function terminated the iteration

Notes:


--*/
{
    int cnt, cntSlashes=0, cbSize;
    USHORT  *lpuT, *lpuLastElement = NULL, *lpuCopy = NULL;
    BOOL    fRet = FALSE;

//    DEBUG_PRINT(("InterateOnUNCPathElements:Path on entry =%ws\r\n", lpuPath));

    if (!lpuPath || ((cnt = wstrlen(lpuPath)) <= 3))
    {
        return FALSE;
    }

    // check for the first two backslashes
    if (!(*lpuPath == (USHORT)'\\') && (*(lpuPath+1) == (USHORT)'\\'))
    {
        return FALSE;
    }

    // ensure that the server field is not NULL
    if (*(lpuPath+2) == (USHORT)'\\')
    {
        return FALSE;
    }

    cbSize = (wstrlen(lpuPath)+1) * sizeof(USHORT);

    lpuCopy = (USHORT *)AllocMem(cbSize);

    if (!lpuCopy)
    {
        return FALSE;
    }

    memcpy(lpuCopy, lpuPath, cbSize);

    cntSlashes = 2;

    lpuLastElement = lpuCopy;

    for (lpuT= lpuCopy+2;; ++lpuT)
    {
        if (*lpuT == (USHORT)'\\')
        {
            BOOL fContinue;

            ++cntSlashes;

            if (cntSlashes == 3)
            {
                if (lpuT == (lpuCopy+2))
                {
                    goto bailout;
                }

                continue;
            }

            *lpuT = 0;

            fContinue = (lpfn)(lpuCopy, lpuLastElement, lpCookie);

            *lpuT = (USHORT)'\\';

            if (!fContinue)
            {
                goto bailout;
            }

            lpuLastElement = (lpuT+1);
        }
        else if (!*lpuT)
        {
            (lpfn)(lpuCopy, lpuLastElement, lpCookie);
            break;
        }
    }

    fRet = TRUE;
bailout:

    if (lpuCopy)
    {
        FreeMem(lpuCopy);
    }
    return (fRet);
}

BOOL
IsPathUNC(
    USHORT      *lpuPath,
    int         cntMaxChars
    )
{
    USHORT *lpuT;
    int i, cntSlash=0;
    BOOL    fRet = FALSE;

    for(lpuT = lpuPath, i=0; (i < cntMaxChars) && *lpuT; lpuT++, ++i)
    {
        if (cntSlash <= 1)
        {
            // look for the first two backslashes
            if (*lpuT != (USHORT)'\\')
            {
                break;
            }

            ++cntSlash;
        }
        else if (cntSlash == 2)
        {
            // look for the 3rd one
            if (*lpuT == (USHORT)'\\')
            {
                if (((DWORD_PTR)lpuT - (DWORD_PTR)lpuPath) < 3)
                {
                    // NULL server field
                    break;
                }
                else
                {
                    ++cntSlash;
                }
            }
        }
        else    // all three slashes accounted for
        {
            Assert(cntSlash == 3);

            // if a non-slash character, then this path is OK
            fRet = (*lpuT != (USHORT)'\\');
            break;
        }
    }
    return (fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\daytona\nullincs.tmp\use.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/********************************************************************
 *								    *
 *  About this file ...  USE.H					    *
 *								    *
 *  This file contains information about the NetUse APIs.	    *
 *								    *
 *	Function prototypes.					    *
 *								    *
 *	Data structure templates.				    *
 *								    *
 *	Definition of special values.				    *
 *								    *
 *								    *
 *  NOTE:  You must include NETCONS.H before this file, since this  *
 *	   file	depends on values defined in NETCONS.H.		    *
 *								    *
 ********************************************************************/

/*NOINC*/
#ifndef NETUSE_INCLUDED

#define NETUSE_INCLUDED

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*INC*/



/****************************************************************
 *                                                              *
 *              Function prototypes                             *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetUseAdd ( const char FAR * pszServer,
              short            sLevel,
	      const char FAR * pbBuffer,
              unsigned short   cbBuffer );

extern API_FUNCTION
  NetUseDel ( const char FAR * pszServer,
	      const char FAR * pszDeviceName,
              unsigned short   usForce );

extern API_FUNCTION
  NetUseEnum ( const char FAR *     pszServer,
               short                sLevel,
	       char FAR *	    pbBuffer,
               unsigned short       cbBuffer,
	       unsigned short FAR * pcEntriesRead,
	       unsigned short FAR * pcTotalAvail );

extern API_FUNCTION
  NetUseGetInfo ( const char FAR *     pszServer,
		  const char FAR *     pszUseName,
                  short                sLevel,
		  char FAR *	       pbBuffer,
                  unsigned short       cbBuffer,
		  unsigned short FAR * pcbTotalAvail );

/**INTERNAL_ONLY**/
/*NOINC*/

/*
 * Private GetConnectionPerformance API
 */
extern API_FUNCTION
  NetUseGetPerformance(
	const char FAR *        usename,
	char FAR *              buffer);

//
typedef struct tagCONNPERFINFO  
{
   	char FAR *	remotename;
   	unsigned long		ticks;
   	unsigned long		nsec_per_byte;  
   	unsigned long		nsec_delay;     
} CONNPERFINFO;
typedef CONNPERFINFO*	 LPCONNPERFINFO;

/*INC*/
/**END_INTERNAL**/

/****************************************************************
 *								*
 *	  	Data structure templates			*
 *								*
 ****************************************************************/

/**INTERNAL_ONLY**/
/*NOINC*/
/* NOTE: the field pad_1 in the use_info_x structures is now being
 * used to convey some status information about the use. This info
 * currently contains current drive status and if the use was made
 * as guest at the remote machine.
 * The pad byte should not be removed without defining an alternate
 * location in which to return the information.
 */
/*INC*/
/**END_INTERNAL**/

struct use_info_0 {
    char	   ui0_local[DEVLEN+1];
    char	   ui0_pad_1;
    char FAR *	   ui0_remote;
};	/* use_info_0 */

struct use_info_1 {
    char	   ui1_local[DEVLEN+1];
    char	   ui1_pad_1;
/**INTERNAL_ONLY**/
/*NOINC*/
#if (((DEVLEN+1)%2) == 0)
# error  "PAD BYTE NOT NEEDED"
#endif
/*INC*/
/**END_INTERNAL**/
    char FAR *	   ui1_remote;
    char FAR *	   ui1_password;
    unsigned short ui1_status;
    short 	   ui1_asg_type;
    unsigned short ui1_refcount;
    unsigned short ui1_usecount;
};	/* use_info_1 */

#ifdef LM_3
/*NOINC*/

/* BUGBUG -- GUID is multiply defined and there should only be
 *	     one definition somewhere. When definition is formalized
 *	     this struct definition must be deleted and all references
 *	     to LM_GUID replaced with GUID.
 */
typedef struct _LM_GUID
{
	unsigned short	guid_uid;	  /* LM10 style user id */
	unsigned long	guid_serial;	  /* user record serial number */
	unsigned char	guid_rsvd[10];	  /* pad out to 16 bytes for now */
} LM_GUID;

struct use_info_2 {
    char	   ui2_local[DEVLEN+1];
    char	   ui2_pad_1;
/**INTERNAL_ONLY**/
/* NOINC*/
#if (((DEVLEN+1)%2) == 0)
# error  "PAD BYTE NOT NEEDED"
#endif
/* INC*/
/**END_INTERNAL**/
    char FAR *	   ui2_remote;
    char FAR *	   ui2_password;
    unsigned short ui2_status;
    short	   ui2_asg_type;
    unsigned short ui2_refcount;
    unsigned short ui2_usecount;
    unsigned short ui2_res_type;
    unsigned short ui2_flags;
    unsigned short ui2_usrclass;
    void FAR *	   ui2_dirname;
    struct _LM_GUID ui2_dfs_id;
};	/* use_info_2 */
/*INC*/
#endif /* LM_3 */

/****************************************************************
 *								*
 *	  	Special values and constants			*
 *								*
 ****************************************************************/


/*
 *  	Definitions for NetUseDel's last parameter
 */

#define USE_NOFORCE         	0
#define USE_FORCE           	1
#define USE_LOTS_OF_FORCE   	2
#ifdef LM_3
/**INTERNAL_ONLY**/
#define USE_LOGOFF_FORCE	3
/**END_INTERNAL**/
#endif /* LM_3 */


/*
 *	Values appearing in the ui1_status field of use_info_1 structure.
 *	Note that USE_SESSLOST and USE_DISCONN are synonyms.
 */

#define USE_OK			0
#define USE_PAUSED		1
#define USE_SESSLOST		2
#define USE_DISCONN		2
#define USE_NETERR		3
#define	USE_CONN		4
#define USE_RECONN		5


/*
 *	Values of the ui1_asg_type field of use_info_1 structure
 */

#define USE_WILDCARD  		-1
#define USE_DISKDEV   		0
#define USE_SPOOLDEV  		1
#define USE_CHARDEV   		2
#define USE_IPC 			3

#define USE_ADD_DISCONN 	128  /* flag used to add connection in */
								 /* disconnected state */
#ifdef LM_3
#define USE_DFS 		4

/*
 *	Values of the ui2_res_type field of use_info_2 structure
 */
#define USE_RES_UNC		1
#define USE_RES_DFS		2
#define USE_RES_DS		3

/*
 *	Values of the ui2_flags field of use_info_2 structure
 */
#define USE_AS_GUEST		0x01
#define USE_CURR_DRIVE		0x02
#define USE_PERM_CONN		0x04
/**INTERNAL_ONLY**/
#define USE_ADD_PERM_CONN	0x0100
/**END_INTERNAL**/
#endif /* LM_3 */

/**INTERNAL_ONLY**/
/*
 *  Values for the pad_byte hidden return info in the use_info_x structures.
 *  NOTE: the redir returns a word of flags, we have only a byte to return
 *	  info in, thus these defines may not be the same bits as those in
 *	  the word returned by the redir.
 */

#define     REDIR_USE_AS_GUEST	0x1000

#define     USE_AS_GUEST	0x01
#define     USE_CURR_DRIVE	0x02



/**END_INTERNAL**/

/*NOINC*/
#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif /* NETUSE_INCLUDED */
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\umreclib\oslayeru.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

     OsLayer.c

Abstract:

     none.

Author:

     Shishir Pardikar      [Shishirp]        01-jan-1995

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

/********************** global data *****************************************/

AssertData;
AssertError;
/********************** function prototypes *********************************/

/****************************************************************************/

/************************ File I/O ******************************************/


CSCHFILE
R0OpenFileEx(
    USHORT  usOpenFlags,
    UCHAR   bAction,
    ULONG   ulAttr,
    LPSTR   lpPath,
    BOOL    fInstrument
    )
{
    HANDLE hf;
    DWORD   DesiredAccess=0, CreateOptions=0, FlagsAndAttributes=ulAttr;

    Assert( (usOpenFlags & 0xf) == ACCESS_READWRITE);

    DesiredAccess = GENERIC_READ | GENERIC_WRITE;

    if (usOpenFlags & OPEN_FLAGS_COMMIT)
    {
       FlagsAndAttributes |= FILE_FLAG_WRITE_THROUGH;
    }

    switch (bAction) {
    case ACTION_CREATEALWAYS:
          CreateOptions = CREATE_ALWAYS;
          break;

    case ACTION_OPENALWAYS:
         CreateOptions = OPEN_ALWAYS;
         break;

    case ACTION_OPENEXISTING:
         CreateOptions = OPEN_EXISTING;
         break;

   default:
       CreateOptions = OPEN_EXISTING;
       break;

    }
#if 0
    if (fInstrument)
    {
        BEGIN_TIMING(KeAttachProcess_R0Open);
    }
    if (fInstrument)
    {
        END_TIMING(KeAttachProcess_R0Open);
    }

    if (fInstrument)
    {
        BEGIN_TIMING(IoCreateFile_R0Open);
    }
#endif


    hf = CreateFileA(    lpPath,
                        DesiredAccess,
                        FILE_SHARE_READ|FILE_SHARE_WRITE,
                        NULL,
                        CreateOptions,
                        FlagsAndAttributes,
                        NULL
                   );
    if (hf == INVALID_HANDLE_VALUE)
    {
        hf = 0;
    }

#if 0
    if (fInstrument)
    {
        END_TIMING(IoCreateFile_R0Open);
    }
#endif

    if (hf == INVALID_HANDLE_VALUE)
    {
        hf = 0;
    }
#if 0
    if (fInstrument)
    {
        BEGIN_TIMING(KeDetachProcess_R0Open);
    }
    if (fInstrument)
    {
        END_TIMING(KeDetachProcess_R0Open);
    }
#endif
    return (CSCHFILE)hf;
}

CSCHFILE
CreateFileLocal(
    LPSTR lpFile
    )
{
    HANDLE hf;

    hf = CreateFileA(lpFile,
                                            GENERIC_READ|GENERIC_WRITE,
                                            FILE_SHARE_READ|FILE_SHARE_WRITE,
                                            NULL,
                                            CREATE_ALWAYS,
                                            0,
                                            NULL);
    if (hf == INVALID_HANDLE_VALUE)
    {
        hf = 0;
    }

    return ((CSCHFILE)hf);
}

CSCHFILE
OpenFileLocal(
    LPSTR lpFile
    )
{
    HANDLE hf;

    hf = CreateFileA(lpFile,
                                            GENERIC_READ|GENERIC_WRITE,
                                            FILE_SHARE_READ|FILE_SHARE_WRITE,
                                            NULL,
                                            OPEN_EXISTING,
                                            0,
                                            NULL);
    if (hf == INVALID_HANDLE_VALUE)
    {
        hf = 0;
    }

    return ((CSCHFILE)hf);
}

ULONG CloseFileLocal(
    CSCHFILE hf
    )
{
    CloseHandle((HANDLE)hf);
    return (1);
}

ULONG CloseFileLocalFromHandleCache(
    CSCHFILE hf
    )
{
    CloseHandle((HANDLE)hf);
    return (1);
}


long ReadFileLocal(
    CSCHFILE hf,
    unsigned long lSeek,
    LPVOID    lpBuff,
    long    cLength
    )
{
    DWORD dwBytesRead;

    if (SetFilePointer((HANDLE)hf, lSeek, NULL, FILE_BEGIN) != lSeek)
        return (-1);

    if(ReadFile((HANDLE)hf, lpBuff, (DWORD)cLength, &dwBytesRead, NULL))
    {
        return ((int)dwBytesRead);
    }
    return (-1);
}

long ReadFileLocalEx(
    CSCHFILE      hf,
    unsigned    long lSeek,
    LPVOID      lpBuff,
    long         cLength,
    BOOL        fInstrument
    )
{
    DWORD dwBytesRead;

    if (SetFilePointer((HANDLE)hf, lSeek, NULL, FILE_BEGIN) != lSeek)
        return (-1);

    if(ReadFile((HANDLE)hf, lpBuff, (DWORD)cLength, &dwBytesRead, NULL))
    {
        return ((int)dwBytesRead);
    }

    return (-1);
}

long ReadFileLocalEx2(
    CSCHFILE      hf,
    unsigned    long lSeek,
    LPVOID      lpBuff,
    long         cLength,
    ULONG       flags
    )
{
    return ReadFileLocalEx(hf, lSeek, lpBuff, cLength, FALSE);
}

long WriteFileLocal(
    CSCHFILE hf,
    unsigned long lSeek,
    LPVOID    lpBuff,
    long    cLength
    )
{
    unsigned long dwBytesRead;

    if (SetFilePointer((HANDLE)hf, lSeek, NULL, FILE_BEGIN) != lSeek)
        return (-1);

    if(WriteFile((HANDLE)hf, lpBuff, (DWORD)cLength, &dwBytesRead, NULL))
    {
        if ((DWORD)cLength == dwBytesRead)
        {
            return ((int)dwBytesRead);
        }
    }
    return (-1);
}

long WriteFileLocalEx(
    CSCHFILE hf,
    unsigned long lSeek,
    LPVOID    lpBuff,
    long    cLength,
    BOOL    fInstrument
    )
{
    fInstrument;
    return(WriteFileLocal(hf, lSeek, lpBuff, cLength));
}

long WriteFileLocalEx2(
    CSCHFILE      hf,
    unsigned    long lSeek,
    LPVOID      lpBuff,
    long         cLength,
    ULONG       flags
    )
{
    return WriteFileLocalEx(hf, lSeek, lpBuff, cLength, FALSE);
}

CSCHFILE OpenFileLocalEx(LPSTR lpPath, BOOL fInstrument)
{
    return(R0OpenFileEx(ACCESS_READWRITE, ACTION_OPENEXISTING, FILE_ATTRIBUTE_NORMAL, lpPath, fInstrument));
}


int FileExists
    (
    LPSTR lpPath
    )
{

    return(GetFileAttributesA(lpPath)!= 0xffffffff);
}


int GetFileSizeLocal
    (
    CSCHFILE handle,
    PULONG lpuSize
    )
{
    *lpuSize = GetFileSize((HANDLE)handle, NULL);

    if(*lpuSize == 0xffffffff)
    {
        return (-1);
    }
    else
    {
        return (0);
    }
}

#if 0

int GetAttributesLocal
    (
    LPSTR lpPath,
    ULONG *lpuAttributes
    )
{
}

int SetAttributesLocal
    (
    LPSTR lpPath,
    ULONG uAttributes
    )
{
}

#endif // if 0

int RenameFileLocal
    (
    LPSTR lpFrom,
    LPSTR lpTo
    )
{
    if(MoveFileA(lpFrom, lpTo))
    {
        return 1;
    }
    return -1;
}

int DeleteFileLocal
    (
    LPSTR lpName,
    USHORT usAttrib
    )
{
    return(DeleteFileA(lpName));
}

int GetDiskFreeSpaceLocal(
    int indx,
    ULONG *lpuSectorsPerCluster,
    ULONG *lpuBytesPerSector,
    ULONG *lpuFreeClusters,
    ULONG *lpuTotalClusters
    )
{
    return (-1);
}

int FileLockLocal( CSCHFILE hf,
    ULONG offsetLock,
    ULONG lengthLock,
    ULONG idProcess,
    BOOL  fLock
    )
{
    return (-1);
}

/*************************** Utility Functions ******************************/

LPVOID AllocMem
    (
    ULONG uSize
    )
{

    return (LocalAlloc(LPTR, uSize));

}
VOID FreeMem
    (
    LPVOID lp
    )
{
    LocalFree(lp);
}

LPVOID AllocMemPaged(
    ULONG uSize
    )
{

    return (LocalAlloc(LPTR, uSize));

}
VOID FreeMemPaged(
    LPVOID lp
    )
{
    LocalFree(lp);
}

int GetAttributesLocal(
    LPSTR lpName,
    ULONG *lpuAttr
    )
{
    if ( (*lpuAttr = (ULONG)GetFileAttributesA(lpName)) == 0xffffffff)
    {
        return -1;
    }
    return 1;
}

int GetAttributesLocalEx
    (
    LPSTR   lpPath,
    BOOL    fFile,
    ULONG   *lpuAttributes
    )
{
    return (GetAttributesLocal(lpPath, lpuAttributes));
}

int
SetAttributesLocal (
    LPSTR lpName,
    ULONG uAttr
    )
{
    if (!SetFileAttributesA(lpName, uAttr))
    {
        return -1;
    }
    return 1;
}

CSCHFILE R0OpenFile (
    USHORT usOpenFlags,
    UCHAR bAction,
    LPSTR lpPath)
{
    return (R0OpenFileEx(usOpenFlags, bAction, FILE_ATTRIBUTE_NORMAL, lpPath, FALSE));
}

int CreateDirectoryLocal(
    LPSTR   lpszPath
    )
{
    if (CreateDirectoryA(lpszPath, NULL))
    {
        return 0;
    }

    return -1;
}
int wstrnicmp(
    const USHORT *pStr1,
    const USHORT *pStr2,
    ULONG count
)
{
    USHORT c1, c2;
    int iRet;
    ULONG i=0;

    for(;;)
     {
        c1 = *pStr1++;
        c2 = *pStr2++;
        c1 = towupper(c1);
        c2 = towupper(c2);
        if (c1!=c2)
            break;
        if (!c1)
            break;
        i+=2;
        if (i >= count)
            break;
     }
    iRet = ((c1 > c2)?1:((c1==c2)?0:-1));
    return iRet;
}

ULONG
GetTimeInSecondsSince1970(
    VOID
    )
{
    return 0;
}

BOOL
HasStreamSupport(
    CSCHFILE hf,
    BOOL    *lpfStreams
    )
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\lib3\debug.c ===
#include "pch.h"
#pragma hdrstop

/*****************************************************************************
 *	Purpose: Cool debug function
 */
void DebugPrint(char *szFmt, ...)
{
	char szDebug[200];
	va_list base;

	va_start(base,szFmt);

	wvsprintfA(szDebug, szFmt, base);
	OutputDebugStringA(szDebug);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\db\db.c ===
#define PUBLIC
#define PRIVATE
#include <stdlib.h>
#include <stdio.h>
#include <memory.h>
#include <string.h>
#include <windows.h>
#include <conio.h>
#include <share.h>
#include <dos.h>
#include "cscapi.h"
#pragma pack (1)

#if defined(BITCOPY)
#include "csc_bmpd.h"
#endif // defined(BITCOPY)

#define  MAX_PQ_PER_PAGE   10
#define  MAX_SHARES_PER_PAGE  6
#define  MAX_FILE_PER_PAGE   4
#define  MAX_INODES_PER_PAGE   15


#define _wtoupper(x)     ( ( ((x)>='a')&&((x)<='z') ) ? ((x)-'a'+'A'):(x))
#define _mytoupper(x)     ( ( ((x)>='a')&&((x)<='z') ) ? ((x)-'a'+'A'):(x))

#ifndef CSC_ON_NT
typedef void *CSCHFILE;
typedef void *CSC_ENUMCOOKIE;

#define UCHAR   unsigned char
#define USHORT  unsigned short
#define ULONG   unsigned long
#define CHAR    char
#define wchar_t unsigned short
#define LPTSTR  LPSTR
#define CONST   const
#define LPWIN32_FIND_DATAW   LPVOID
typedef struct tagSTOREDATA
{
    ULONG   ulSize;           // Max shadow data size
    ULONG   ucntDirs;         // Current count of dirs
    ULONG   ucntFiles;        // Current count of files
}
STOREDATA, *LPSTOREDATA;
typedef LPVOID LPFIND32;
#else
typedef PVOID   CSCHFILE;
#include "shdcom.h"
#include "cscsec.h"
#endif //CSC_ON_NT

#define  ESC       0x1b

typedef unsigned long  ulong;
typedef unsigned short ushort;

typedef LPSTR LPPATH;

#include "record.h"

#define InodeFromRec(ulRec, fFile)  ((ulRec+ULID_FIRST_USER_DIR-1) | ((fFile)?0x80000000:0))
#define RecFromInode(hShadow)       ((hShadow & 0x7fffffff) - (ULID_FIRST_USER_DIR-1))

char rgch[256], rgPrint[1024], rgchPar[256];

char szShadow[] = "\\WINDOWS\\CSC";
char szBackslash[] = "\\";
char szDbDir[256];    // shadow database
char szName[MAX_PATH];     // working buffer

int DispFunc(char *);
void DisplayShares(char *);
void DisplayInodes(void);
void DisplayPriorityQ(void);
void DisplayFile(unsigned long ulid, char *);
int PUBLIC HexToA(ulong, LPSTR, int);
void PRIVATE FormNameStringDB(
   LPSTR lpdbID,
   ulong ulidFile,
   LPSTR lpName
    );

BOOL
FindAncestor(
    ulong ulid,
    ulong *lpulidDir
);
void
printwidestring(
    USHORT  *lpwString,
    unsigned long   cntChars
    );

int RoughCompareWideStringWithAnsiString(
    LPSTR   lpSrcString,
    USHORT  *lpwDstString,
    int     cntMax
    );

int _cdecl main(int argc, char *argv[], char *envp[])
{
   BOOL fRet;
   DWORD junk;
   unsigned uAttr;
   int iRet = -1;
   if (argc==1)
    {
       fRet = CSCGetSpaceUsage(
                    szDbDir,
                    sizeof(szDbDir),
                    &junk,
                    &junk,
                    &junk,
                    &junk,
                    &junk,
                    &junk);
       if (fRet == FALSE)
          strcpy(szDbDir, szShadow);
    }
   else
    {
       memset(szDbDir, 0, sizeof(szDbDir));
       strncpy(szDbDir, argv[1], sizeof(szDbDir)-1);
    }
#ifdef CSC_ON_NT
     if((uAttr = GetFileAttributes(szDbDir)) == 0xffffffff)
#else
   if(_dos_getfileattr(szDbDir, &uAttr))
#endif //CSC_ON_NT
    {
       printf("Error accessing directory %s \r\n", szDbDir);
    }
   else if (!(uAttr & _A_SUBDIR))
    {
       printf("%s is not a directory\r\n", szDbDir);
    }
   else
    {
       do
        {
           memset(rgch, 0, sizeof(rgch));
           printf("\r\n");
           printf("Shares [s [name]], ");
           printf("PriQ [q], ");
           printf("File [f inode# [name]], ");
           printf("Exit [x], ");
           printf("Enter:");
           if (!gets(rgch))
               break;
           printf("\r\n");
               if (!DispFunc(rgch))
               break;
        }
       while (1);
       iRet = 0;
    }
   return (iRet);
}

int DispFunc(
   char *lpBuff
    )
{
    char ch;
    unsigned long ulid;
    int cnt;

    cnt = sscanf(lpBuff, "%c", &ch);

    if (!cnt)
        return 0;

    switch (ch)
    {
    // Display shares database
        case 's':
        case 'S':
            cnt = sscanf(lpBuff, "%c%s", &ch, rgchPar);
            DisplayShares((cnt==2)?rgchPar:NULL);
        break;

        // display priority Q database
        case 'q':
        case 'Q':
            DisplayPriorityQ();
        break;

        case 'f':
        case 'F':
            cnt = sscanf(lpBuff, "%c%lx%s", &ch, &ulid, rgchPar);
            if (cnt==2)
            {
                // display Inode file
                DisplayFile(ulid, NULL);
            }
            else if (cnt==3)
            {
                printf("Looking for %s in %x \r\n", rgchPar, ulid);
                // display Inode file
                DisplayFile(ulid, rgchPar);
            }
        break;
        case 'x':
        case 'X':
            return 0;
    }
    return 1;
}

void
DisplaySecurityContext(
    char *pSecurityDescriptor,
    LPRECORDMANAGER_SECURITY_CONTEXT   pSecurityContext)
{
#ifdef CSC_ON_NT

    PCACHED_SECURITY_INFORMATION pCachedSecurityInformation;
    ULONG i;

    pCachedSecurityInformation = (PCACHED_SECURITY_INFORMATION)pSecurityContext;

    if (pSecurityDescriptor != NULL) {
        printf("\n%s ",pSecurityDescriptor);
    }

    printf("SECURITY CONTEXT:\n");

    for (i = 0; i < MAXIMUM_NUMBER_OF_USERS; i++) {
        CSC_SID_INDEX SidIndex;

        SidIndex = pCachedSecurityInformation->AccessRights[i].SidIndex;
        switch (SidIndex) {
        case CSC_INVALID_SID_INDEX:
            break;
        default:
            {
                if (SidIndex == CSC_GUEST_SID_INDEX) {
                    printf("\tGUEST: ");
                } else {
                    printf("\t%lx: ",SidIndex);
                }

                printf(
                    "Rights: %lx\t\n",
                    pCachedSecurityInformation->AccessRights[i].MaximalRights);
            }
        }
    }
#endif
}

void
DisplaySecurityContext2(
    char *pSecurityDescriptor,
    LPRECORDMANAGER_SECURITY_CONTEXT   pSecurityContext)
{
    PCACHED_SECURITY_INFORMATION pCachedSecurityInformation;
    BOOL fGotOne = FALSE;
    ULONG i;

    pCachedSecurityInformation = (PCACHED_SECURITY_INFORMATION)pSecurityContext;

    for (i = 0; i < MAXIMUM_NUMBER_OF_USERS; i++) {
        CSC_SID_INDEX SidIndex;

        SidIndex = pCachedSecurityInformation->AccessRights[i].SidIndex;
        if (SidIndex != CSC_INVALID_SID_INDEX) {
            fGotOne = TRUE;
            break;
        }
    }

    if (fGotOne == FALSE)
        return;

    printf("%s Security: ",pSecurityDescriptor);
    for (i = 0; i < MAXIMUM_NUMBER_OF_USERS; i++) {
        CSC_SID_INDEX SidIndex;

        SidIndex = pCachedSecurityInformation->AccessRights[i].SidIndex;
        if (SidIndex == CSC_INVALID_SID_INDEX) {
            continue;
        }else if (SidIndex == CSC_GUEST_SID_INDEX) {
            printf("(G:0x%x)",
                pCachedSecurityInformation->AccessRights[i].MaximalRights);
        } else {
            printf("(0x%x:0x%x)",
                SidIndex,
                pCachedSecurityInformation->AccessRights[i].MaximalRights);
        }
    }
    printf("\r\n");
}

void DisplayShares(
    char    *lpszShareName
    )
{
    FILE *fp= (FILE *)NULL;
    SHAREHEADER sSH;
    SHAREREC sSR;
    unsigned long ulrec=1L;
    int count=0;

    FormNameStringDB(szDbDir, ULID_SHARE, szName);
    if (fp = _fsopen(szName, "rb", _SH_DENYNO))
    {
        if (fread(&sSH, sizeof(SHAREHEADER), 1, fp) != 1)
        {
            printf("Error reading server header \r\n");
            goto bailout;
        }

        printf("Header: Flags=%x Version=%lx Records=%ld Size=%d \r\n",
                sSH.uFlags, sSH.ulVersion, sSH.ulRecords, sSH.uRecSize);

        printf("Store: Max=%ld Current=%ld \r\n", sSH.sMax.ulSize, sSH.sCur.ulSize);
        printf("store: files=%ld directories=%ld \r\n\r\n", sSH.sCur.ucntFiles, sSH.sCur.ucntDirs);

        while (fread(&sSR, sizeof(SHAREREC), 1, fp)==1)
        {
            if (count == MAX_SHARES_PER_PAGE) {
                printf("\r\n--- Press any key to continue; ESC to cancel ---\r\n");
                if(_getch()==ESC) {
                    break;
                }
                count = 0;
            }

            if (sSR.uchType == (unsigned char)REC_DATA) {
                if (lpszShareName) {
                    if (RoughCompareWideStringWithAnsiString(
                            lpszShareName,
                            sSR.rgPath,
                            sizeof(sSR.rgPath)/sizeof(USHORT)-1)
                    ) {
                        continue;
                    }
                }

                printwidestring(sSR.rgPath, sizeof(sSR.rgPath)/sizeof(USHORT));
                printf("\r\n");
                printf( "  Share=0x%x Root=0x%x Stat=0x%x RootStat=0x%x "
                        "HntFlgs=0x%x HntPri=0x%x Attr=0x%x\r\n",
                            ulrec++,
                            sSR.ulidShadow,
                            sSR.uStatus,
                            (unsigned)(sSR.usRootStatus),
                            (unsigned)(sSR.uchHintFlags),
                            (unsigned)(sSR.uchHintPri),
                            sSR.dwFileAttrib);

                DisplaySecurityContext2("  ShareLevel",&sSR.sShareSecurity);
                DisplaySecurityContext2("  Root ",&sSR.sRootSecurity);
                printf("\r\n");

                if (lpszShareName) {
                    printf("\r\n--- Press any key to continue search; ESC to cancel ---\r\n");
                    if(_getch()==ESC) {
                        break;
                    }
                } else {
                    ++count;
                }
            }
        }
    }
bailout:
    if (fp)
        fclose(fp);
}



void DisplayPriorityQ
    (
   void
    )
{
   FILE *fp= (FILE *)NULL;
   QHEADER sQH;
   QREC sQR;
   unsigned long ulRec=1;
   int count = 0;

   FormNameStringDB(szDbDir, ULID_PQ, szName);
   if (fp = _fsopen(szName, "rb", _SH_DENYNO)) {
       if (fread(&sQH, sizeof(QHEADER), 1, fp) != 1) {
           printf("Error reading PQ header \r\n");
           goto bailout;
        }
       printf("Header: Flags=%x Version=%lx Records=%ld Size=%d head=%ld tail=%ld\r\n",
                    sQH.uchFlags,
                    sQH.ulVersion,
                    sQH.ulRecords,
                    sQH.uRecSize,
                    sQH.ulrecHead,
                    sQH.ulrecTail);
       printf("\r\n");
       printf(
       "  REC SHARE      DIR   SHADOW   STATUS  PRI HINTFLGS HINTPRI  PREV  NEXT DIRENT\r\n");
       for (ulRec = sQH.ulrecHead; ulRec;) {
           if (count == MAX_PQ_PER_PAGE) {
               printf("\r\n--- Press any key to continue; ESC to cancel ---\r\n");
               if(_getch()==ESC) {
                   break;
                }
               count = 0;
               printf(
               "  REC SHARE      DIR   SHADOW   STATUS  PRI HINTFLGS HINTPRI  PREV  NEXT DIRENT\r\n");
           }
           fseek(fp, ((ulRec-1) * sizeof(QREC))+sizeof(QHEADER), SEEK_SET);
           if (fread(&sQR, sizeof(QREC), 1, fp)!=1)
               break;
           printf("%5d %5x %8x %8x %8x %4d %8x %7d %5d %5d %6d\r\n",
                        ulRec,
                        sQR.ulidShare,
                        sQR.ulidDir,
                        sQR.ulidShadow,
                        sQR.usStatus,
                        (unsigned)(sQR.uchRefPri),
                        (unsigned)(sQR.uchHintFlags),
                        (unsigned)(sQR.uchHintPri),
                        sQR.ulrecPrev,
                        sQR.ulrecNext,
                        sQR.ulrecDirEntry);
            ++count;
           ulRec = sQR.ulrecNext;
        }
    }
bailout:
   if (fp)
       fclose(fp);
}

void DisplayFile(
    unsigned long ulid,
    char *lpszName
    )
{
    FILE *fp= (FILE *)NULL;
    FILEHEADER sFH;
    FILEREC sFR;
    int fLfn=0;
    unsigned long ulidDir=ulid;
    int fPrintOvf = 0, count=0;
#if defined(BITCOPY)
    char strmPath[MAX_PATH];
    LPCSC_BITMAP_DB lpbitmap = NULL;
#endif // defined(BITCOPY)

    if (IsLeaf(ulid)) {
        if (!FindAncestor(ulid, &ulidDir))
            return;
    }

    FormNameStringDB(szDbDir, ulidDir, szName);

    if (fp = _fsopen(szName, "rb", _SH_DENYNO)) {
        if (fread(&sFH, sizeof(FILEHEADER), 1, fp) != 1) {
            printf("Error reading file header \r\n");
            goto bailout;
        }


        if (ulid == ulidDir) {
            printf("Header: Flags=%x Version=%lx Records=%ld Size=%d\r\n",
                        sFH.uchFlags, sFH.ulVersion, sFH.ulRecords, sFH.uRecSize);
            printf("Header: bytes=%ld entries=%d Share=%ld Dir=%lx\r\n",
                        sFH.ulsizeShadow, sFH.ucShadows, sFH.ulidShare, sFH.ulidDir);
            printf ("\r\n");
            fPrintOvf = 1;
        }

        while (fread(&sFR, sizeof(FILEREC), 1, fp)==1) {
            if (count == MAX_FILE_PER_PAGE) {
                printf("--- Press any key to continue; ESC to cancel ---\r\n");
                if(_getch()==ESC) {
                    break;
                }
                count = 0;
            }
            if (sFR.uchType != (unsigned char)REC_OVERFLOW) {
                if (fLfn) {
                    if (ulidDir != ulid)
                        break;
                }
                fLfn = 0;
            }

            if (sFR.uchType==(unsigned char)REC_DATA) {
                if (ulidDir != ulid) {
                    if (ulid != sFR.ulidShadow)
                        continue;
                }
                if (lpszName) {
                    if (RoughCompareWideStringWithAnsiString(
                            lpszName,
                            sFR.rgwName,
                            sizeof(sFR.rgw83Name)/sizeof(USHORT)-1)
                    ) {
                        continue;
                    }
                }

                fPrintOvf = 1;
                printwidestring(sFR.rgw83Name, sizeof(sFR.rgw83Name)/sizeof(USHORT));
                printf(" (0x%x)\r\n", sFR.ulidShadow);
                printf("  Type=%c Flags=0x%x status=0x%x size=%ld attrib=0x%lx\r\n",
                            sFR.uchType,
                            (unsigned)sFR.uchFlags,
                            sFR.uStatus,
                            sFR.ulFileSize,
                            sFR.dwFileAttrib);
                printf("  PinFlags=0x%x PinCount=%d RefPri=%d OriginalInode=0x%0x\r\n",
                             (unsigned)(sFR.uchHintFlags),
                             (int)(sFR.uchHintPri),
                             (int)(sFR.uchRefPri),
                             sFR.ulidShadowOrg);
                printf("  time: hi=%x lo=%x orgtime: hi=%x lo=%x\r\n",
                            sFR.ftLastWriteTime.dwHighDateTime,
                            sFR.ftLastWriteTime.dwLowDateTime,
                            sFR.ftOrgTime.dwHighDateTime,
                            sFR.ftOrgTime.dwLowDateTime);
                if (sFR.rgwName[0]) {
                    printf("  LFN:");
                    printwidestring(sFR.rgwName, sizeof(sFR.rgwName)/sizeof(USHORT));
                    fLfn = 1;
                }

                printf("\r\n");
                DisplaySecurityContext2(" ",&sFR.Security);

                if (ulidDir != ulid)
                {
                    printf("DirInode = %x\r\n", ulidDir);
#if defined(BITCOPY)
                    FormNameStringDB(szDbDir, sFR.ulidShadow, strmPath);
                    DBCSC_BitmapAppendStreamName(strmPath, MAX_PATH);
                    printf("Trying to read CSCBitmap file %s\n", strmPath);		
                    // read bitmap
                    switch(DBCSC_BitmapRead(&lpbitmap, strmPath)) {
                        case 1:
                            // Print the bitmap associated if any
                            printf("\n");
                            DBCSC_BitmapOutput(stdout, lpbitmap);
                            printf("\n");
                            // if bitmap opened delete bitmap
                            DBCSC_BitmapDelete(&lpbitmap);
                            break;
                        case -1:
                            printf("Error reading bitmap file %s or bitmap invalid\n",
                            strmPath);
                            break;
                        case -2:
                            printf("No CSCBitmap\n");
                            break;
                        case 0:
                        default:
                            printf("Something strange going on w/ bitmap printing...\n");
                            break;
                    }
#endif // defined(BITCOPY)
                    break;
                }

                if (lpszName) {
                    printf("--- Press any key to continue search; ESC to cancel ---\r\n");
                    if(_getch()==ESC) {
                        break;
                    }
                }
                printf("\r\n");
            } else if (fPrintOvf && (sFR.uchType == (unsigned char)REC_OVERFLOW)) {
                printf("(overflow) ");
                printwidestring(sFR.rgwOvf,
                    (sizeof(FILEREC)-sizeof(RECORDMANAGER_COMMON_RECORD))/sizeof(USHORT));
                printf("\r\n\r\n");
            }

            // do counting only when we are scanning the whole directory
            if (!lpszName &&  (ulid == ulidDir)) {
                ++count;
            }
        }
        printf("\r\n");
    }
bailout:
    if (fp)
        fclose(fp);
}

void PRIVATE FormNameStringDB(
   LPSTR lpdbID,
   ulong ulidFile,
   LPSTR lpName
    )
{
   LPSTR lp;
   char chSubdir;

#ifdef CSC_ON_NT
    // Prepend the local path
   strcpy(lpName, lpdbID);
   strcat(lpName, szBackslash);
#else
    // Prepend the local path
   _fstrcpy(lpName, lpdbID);
   _fstrcat(lpName, szBackslash);
#endif //CSC_ON_NT

    // Bump the pointer appropriately
#ifdef CSC_ON_NT
   lp = lpName + strlen(lpName);
#else
   lp = lpName + _fstrlen(lpName);
#endif //CSC_ON_NT

   chSubdir = CSCDbSubdirSecondChar(ulidFile);

   // sprinkle the user files in one of the subdirectories
   if (chSubdir)
   {
       // now append the subdirectory

       *lp++ = CSCDbSubdirFirstChar();
       *lp++ = chSubdir;
       *lp++ = '\\';
   }


   HexToA(ulidFile, lp, 8);

   lp += 8;
    *lp = 0;
}

int PUBLIC HexToA(
   ulong ulHex,
   LPSTR lpName,
   int count)
{
   int i;
   LPSTR lp = lpName+count-1;
   unsigned char uch;

   for (i=0; i<count; ++i)
    {
       uch = (unsigned char)(ulHex & 0xf) + '0';
       if (uch > '9')
           uch += 7;    // A becomes '0' + A + 7 which is 'A'
        *lp = uch;
        --lp;
       ulHex >>= 4;
    }
    *(lpName+count) = '\0';
   return 0;
}

BOOL
FindAncestor(
    ulong ulid,
    ulong *lpulidDir
)
{
    ulong ulRec = RecFromInode(ulid);
    FILE *fp= (FILE *)NULL;
    QHEADER sQH;
    QREC sQR;
    BOOL fRet = FALSE;

    *lpulidDir = 0;

    FormNameStringDB(szDbDir, ULID_PQ, szName);
    if (fp = _fsopen(szName, "rb", _SH_DENYNO))
     {
        if (fread(&sQH, sizeof(QHEADER), 1, fp) != 1)
         {
            printf("Error reading PQ header \r\n");
            goto bailout;
         }

         fseek(fp, ((ulRec-1) * sizeof(QREC))+sizeof(QHEADER), SEEK_SET);

         if (fread(&sQR, sizeof(QREC), 1, fp)!=1){
            goto bailout;
         }
         *lpulidDir = sQR.ulidDir;
         fRet = TRUE;
     }
 bailout:
    if (fp)
        fclose(fp);
    return fRet;
}

#ifndef CSC_ON_NT
void
printwidestring(
    USHORT  *lpwString,
    unsigned long   cntChars
    )
{
    unsigned long i;

    cntChars = min(cntChars, sizeof(rgPrint) -1);

    for(i=0; (i< cntChars) && lpwString[i]; ++i)
    {
        rgPrint[i] = (char)(lpwString[i]);
    }

    rgPrint[i] = 0;
    printf(rgPrint);
}
#else
void
printwidestring(
    USHORT  *lpwString,
    unsigned long   cntChars
    )
{
    printf("%ls", lpwString);
}
#endif

int RoughCompareWideStringWithAnsiString(
    LPSTR   lpSrcString,
    USHORT  *lpwDstString,
    int     cntMax
    )
{
    char ch;
    USHORT  uch;
    int i;

    for (i=0;i<cntMax;++i)
    {
        ch = *lpSrcString++;
        uch = *lpwDstString++;
        uch = _wtoupper(uch);
        ch = _mytoupper(ch);

        if (!ch)
        {
            return 0;
        }

        if (ch != (char)uch)
        {
            return ((char)uch - ch);
        }
    }
    if (i==cntMax)
    {
        return 0;
    }

    return 1;   // this should never occur
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\lib3\debug.h ===
void DebugPrint(char *szFmt, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\db\csc_bmpd.h ===
/*++

    Copyright (c) 2000 Microsoft Corporation

Module Name:

    csc_bmpd.h

Abstract:

    Interface to the user mode utility functions of bitmaps associated
    with CSC files written specifically for the db program. The 'd' in
    the file name means "db."

Author:

    Nigel Choi [t-nigelc]  Sept 3, 1999

--*/

#ifndef _CSC_BITMAP_H_
#define _CSC_BITMAP_H_

#include <windows.h>
#include <stdio.h>
#include "csc_bmpc.h"

// The _DB is used to distinguish this from the kernel mode CSC_BITMAP
// or the usermode _U

typedef struct _CSC_BITMAP_DB {
    DWORD bitmapsize;  // size in bits. How many bits effective in the bitmap
    DWORD numDWORD;    // how many DWORDs to accomodate the bitmap */
    LPDWORD bitmap;    // The bitmap itself
} CSC_BITMAP_DB, *LPCSC_BITMAP_DB, *PCSC_BITMAP_DB;

extern LPSTR CscBmpAltStrmName;

LPCSC_BITMAP_DB
DBCSC_BitmapCreate(
    DWORD filesize);

VOID
DBCSC_BitmapDelete(
    LPCSC_BITMAP_DB *lplpbitmap);

int
DBCSC_BitmapIsMarked(
    LPCSC_BITMAP_DB lpbitmap,
    DWORD bitoffset);

int
DBCSC_BitmapAppendStreamName(
    LPSTR fname,
    DWORD bufsize);

int
DBCSC_BitmapRead(
    LPCSC_BITMAP_DB *lplpbitmap,
    LPCTSTR filename);

VOID
DBCSC_BitmapOutput(
    FILE *outStrm,
    LPCSC_BITMAP_DB lpbitmap);

#endif //#define _CSC_BITMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\db\csc_bmpd.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    csc_bmpd.c

Abstract:

    This module implements the utility functions of bitmaps associated
    with CSC files specifically for the db application.  CSC_BMP_U is
    an opaque structure. Must use the functions here to
    create/modify/destroy a CSC_BMP_U to ensure data integrity.  The
    'd' in the filename means "db."

Author:

    Nigel Choi [t-nigelc]  Sept 3, 1999

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <assert.h>
#include <winbase.h>
#include "csc_bmpd.h"

// append this to inode file name to get the stream name
LPSTR CscBmpAltStrmName = STRMNAME;

/*++

    DBCSC_BitmapCreate()

Routine Description:

    Allocates an appropriate in-memory bitmap CSC_BITMAP_DB with size
    corresponding to filesize.

Arguments:


Returns:

    NULL if memory allocation error.
    pointer to the newly allocated bitmap if successful.

Notes:


--*/
LPCSC_BITMAP_DB
DBCSC_BitmapCreate(
    DWORD filesize)
{
    LPCSC_BITMAP_DB bm;
    DWORD i;

    bm = (LPCSC_BITMAP_DB)malloc(sizeof(CSC_BITMAP_DB));

    if (bm == NULL)
        return NULL;

    bm->bitmapsize = filesize/BLOCKSIZE;
    if (filesize % BLOCKSIZE)
        bm->bitmapsize++;
    bm->numDWORD = bm->bitmapsize/(8*sizeof(DWORD));
    if (bm->bitmapsize % (8*sizeof(DWORD)))
        bm->numDWORD++;

    if (bm->bitmapsize) {
        bm->bitmap = (LPDWORD)malloc(bm->numDWORD*sizeof(DWORD));
        if (bm->bitmap == NULL) {
            free(bm);
            return NULL;
        }
        for (i = 0; i < bm->numDWORD; i++) {
            bm->bitmap[i] = 0;
        }
    } else {
        bm->bitmap = NULL;
    }

    return bm;
}

/*++

    DBCSC_BitmapDelete()

Routine Description:

Arguments:

Returns:

Notes:

--*/
void
DBCSC_BitmapDelete(
    LPCSC_BITMAP_DB *lplpbitmap)
{
    if (lplpbitmap == NULL)
        return;
    if (*lplpbitmap == NULL)
        return;
    if ((*lplpbitmap)->bitmap)
        free((*lplpbitmap)->bitmap);
    free((*lplpbitmap));
    *lplpbitmap = NULL;
}

/*++

    DBCSC_BitmapIsMarked()

Routine Description:


Arguments:


Returns:

    -1 if lpbitmap is NULL or bitoffset is larger than the bitmap
    TRUE if the bit is marked
    FALSE if the bit is unmarked

Notes:

--*/
int
DBCSC_BitmapIsMarked(
    LPCSC_BITMAP_DB lpbitmap,
    DWORD bitoffset)
{
    DWORD DWORDnum;
    DWORD bitpos;

    if (lpbitmap == NULL)
        return -1;
    if (bitoffset >= lpbitmap->bitmapsize)
        return -1;

    DWORDnum = bitoffset/(8*sizeof(DWORD));
    bitpos = 1 << bitoffset%(8*sizeof(DWORD));

    if (lpbitmap->bitmap[DWORDnum] & bitpos)
        return TRUE;

    return FALSE;
}

/*++

    DBCSC_BitmapAppendStreamName()

Routine Description:

    Appends the CSC stream name to the existing path/file name fname.

Arguments:

    fname is the sting buffer containing the path/file.
    bufsize is the buffer size.

Returns:

    TRUE if append successful.
    FALSE if buffer is too small or other errors.

Notes:

    Single-byte strings only.

--*/
int
DBCSC_BitmapAppendStreamName(
    LPSTR fname,
    DWORD bufsize)
{
    int ret = TRUE;

    if ((strlen(fname) + strlen(CscBmpAltStrmName) + 1) > bufsize) {
        return FALSE;
    }

    __try {
        ret = TRUE;
        strcat(fname, CscBmpAltStrmName);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        ret = FALSE;
    }

    return ret;
}

/*++

    DBCSC_BitmapRead()

Routine Description:

    Reads the on-disk bitmap file, and if it exists, is not in use and valid,
    store it in *lplpbitmap. If *lplpbitmap is NULL allocate a new
    bitmap data structure. Otherwise, if *lplpbitmap is not NULL, the
    existing bitmap will be deleted and assigned the on-disk bitmap
    file.

Arguments:

    filename is the file that contains the bitmap. If read from a
    stream, append the stream name before passing the filename in. The
    filename is used as is and no checking of validity of the name is
    performed. For default stream name, append the global LPSTR
    CscBmpAltStrmName.

Returns:

    1 if read successful
    0 if lplpbitmap is NULL
    -1 if error in disk operation (open/read), memory allocating error,
          or invalid bitmap file format.
    -2 if bitmap not exist

Notes:

    CODE.IMPROVEMENT design a better error message propagation mechanism.
    Bitmap open for exclusive access.

--*/
int
DBCSC_BitmapRead(
    LPCSC_BITMAP_DB *lplpbitmap,
    LPCTSTR filename)
{
    CscBmpFileHdr hdr;
    HANDLE bitmapFile;
    DWORD bytesRead;
    DWORD bitmapByteSize;
    DWORD * bitmapBuf = NULL;
    DWORD errCode;
    int ret = 1;

    if (lplpbitmap == NULL)
        return 0;

    bitmapFile = CreateFile(
                    filename,
                    GENERIC_READ,
                    0, // No sharing; exclusive
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
    if (bitmapFile == INVALID_HANDLE_VALUE) {
        errCode = GetLastError();
        if (errCode == ERROR_FILE_NOT_FOUND) {
            // File does not exist
            return -2;
        }
        return -1;
    }

    if (!ReadFile(
            bitmapFile,
            &hdr, 
            sizeof(CscBmpFileHdr),
            &bytesRead,
            NULL)
    ) {
        ret = -1;
        goto CLOSEFILE;
    }

    if (
        bytesRead != sizeof(CscBmpFileHdr)
            ||
        hdr.magicnum != MAGICNUM
            ||
        !hdr.valid
            ||
        hdr.inuse
    ) {
        ret = -1;
        goto CLOSEFILE;
    }

    printf(
            "---Header---\n"
            "MagicNum: 0x%x\n"
            "inuse: 0x%x\n"
            "valid: 0x%x\n"
            "sizeinbits:0x%x\n"
            "numDWORDS:0x%x\n",
                hdr.magicnum,
                hdr.inuse,
                hdr.valid,
                hdr.sizeinbits,
                hdr.numDWORDs);

    if (hdr.sizeinbits > 0) {
        bitmapByteSize = hdr.numDWORDs*sizeof(DWORD);
        bitmapBuf = (DWORD *)malloc(bitmapByteSize);
        if (!bitmapBuf) {
            ret = -1;
            goto CLOSEFILE;
        }

        if (!ReadFile(
                bitmapFile,
                bitmapBuf,
                bitmapByteSize,
                &bytesRead,
                NULL)
        ) {
            ret = -1;
            goto CLOSEFILE;
        }

        if (bytesRead != bitmapByteSize) {
            ret = -1;
            goto CLOSEFILE;
        }
    }

    if (*lplpbitmap) {
        // bitmap exist, dump old and create new
        if ((*lplpbitmap)->bitmap)
            free((*lplpbitmap)->bitmap);
        (*lplpbitmap)->bitmap = bitmapBuf;
        (*lplpbitmap)->numDWORD = hdr.numDWORDs;
        (*lplpbitmap)->bitmapsize = hdr.sizeinbits;
    } else {
        // bitmap not exist, create brand new
        *lplpbitmap = (LPCSC_BITMAP_DB)malloc(sizeof(CSC_BITMAP_DB));
        if (!(*lplpbitmap)) {
            // Error in memory allocation
            ret = -1;
            goto CLOSEFILE;
        }
        (*lplpbitmap)->bitmap = bitmapBuf;
        (*lplpbitmap)->numDWORD = hdr.numDWORDs;
        (*lplpbitmap)->bitmapsize = hdr.sizeinbits;
    }

CLOSEFILE:
    CloseHandle(bitmapFile);

    return ret;
}

/*++

    DBCSC_BitmapOutput()

Routine Description:

    Outputs the passed in bitmap to the ouput file stream outStrm

Arguments:


Returns:


Notes:


--*/
void
DBCSC_BitmapOutput(
    FILE * outStrm,
    LPCSC_BITMAP_DB lpbitmap)
{
    DWORD i;

    if (lpbitmap == NULL) {
        fprintf(outStrm, "lpbitmap is NULL\n");
        return;
    }

    fprintf(outStrm, "lpbitmap 0x%08x, bitmapsize %u, numDWORD %u\n",
                (ULONG_PTR)lpbitmap, lpbitmap->bitmapsize, lpbitmap->numDWORD);
                fprintf(outStrm, "bitmap  |0/5        |1/6        |2/7        |3/8        |4/9\n");
    fprintf(outStrm, "number  |01234|56789|01234|56789|01234|56789|01234|56789|01234|56789");
    for (i = 0; i < lpbitmap->bitmapsize; i++) {
        if ((i % 50) == 0)
            fprintf(outStrm, "\n%08d", i);
        if ((i % 5) == 0)
            fprintf(outStrm, "|");
        fprintf(outStrm, "%1d", DBCSC_BitmapIsMarked(lpbitmap, i));
    }
    fprintf(outStrm, "\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\lib3\lib3.c ===
/*****************************************************************************
 *    This file is a ring 3 layer to call down to the VxD.
 */

#include "pch.h"
#pragma hdrstop

#include "assert.h"
#include "lib3.h"
#include "debug.h"

/*****************************************************************************
Globals declared within this file
*/
static char    vszShadowDevice[] = "\\\\.\\shadow";    // name of vxd

// must be declared in your OWN code...

/* assert/debug stuff */
AssertData;
AssertError;

//this variable is used as the receiver of the BytesReturned for DeviceIoControl Calls
//the value is never actually used
ULONG DummyBytesReturned, uShadowDeviceOpenCount=0;


//HACKHACKHACK the agent will wait up to 7 minutes for the rdr to show up
LONG NtWaitLoopMax = 7 * 60;
LONG NtWaitLoopSleep = 5;

/*****************************************************************************
Call once to get the file handle opened to talk to the VxD
*/

HANDLE
OpenShadowDatabaseIOex(ULONG WaitForDriver, DWORD dwFlags)
{
    HANDLE hShadowDB;
    LONG WaitLoopRemaining = NtWaitLoopMax;
    DWORD dwError;
    char buff[64];

#if 0
WAITLOOP_HACK:
#endif
    if ((hShadowDB = CreateFileA(vszShadowDevice,
                               FILE_EXECUTE, //GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               dwFlags,
                               NULL)) == INVALID_HANDLE_VALUE ) {

#if 0
        //HACKHACKHACK
        if (WaitForDriver && (WaitLoopRemaining > 0)) {
            Sleep(NtWaitLoopSleep * 1000);
            WaitLoopRemaining -= NtWaitLoopSleep;
            goto WAITLOOP_HACK;
        }
#endif
        dwError = GetLastError();

//        DEBUG_PRINT(("lib3:CreateFile on CSC device failed Error = %d\r\n", dwError));

        return INVALID_HANDLE_VALUE; /* failure */
    }

    InterlockedIncrement(&uShadowDeviceOpenCount);

    return hShadowDB; /* success */
}

HANDLE
__OpenShadowDatabaseIO(ULONG WaitForDriver)
{
    return OpenShadowDatabaseIOex(WaitForDriver, 0);
}


/*****************************************************************************
Call after we're all done to close down the IOCTL interface.
*/
void
CloseShadowDatabaseIO(HANDLE hShadowDB)
{
    CloseHandle(hShadowDB);
    InterlockedDecrement(&uShadowDeviceOpenCount);
}


int BeginInodeTransactionHSHADOW(
    VOID
    )
{
    int iRet;
    iRet = DoShadowMaintenance(INVALID_HANDLE_VALUE, SHADOW_BEGIN_INODE_TRANSACTION);
    if (!iRet)
    {
        SetLastError(ERROR_ACCESS_DENIED);
    }
    return (iRet);
}

int EndInodeTransactionHSHADOW(
    VOID
    )
{
    int iRet;

    iRet = DoShadowMaintenance(INVALID_HANDLE_VALUE, SHADOW_END_INODE_TRANSACTION);

    if (!iRet)
    {
        SetLastError(ERROR_ACCESS_DENIED);
    }
    return (iRet);
}

/*****************************************************************************
 *    Given an hDir and filename, find the hShadow, should it exist.
 */
int
GetShadowW(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    LPHSHADOW            lphShadow,
    LPWIN32_FIND_DATAW    lpFind32,
    unsigned long        *lpuStatus
    )
{
    int            iRet;
    SHADOWINFO    sSI;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }
    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hDir = hDir;
    sSI.lpFind32 = lpFind32;
    iRet = DeviceIoControl(hShadowDB
                           , IOCTL_GETSHADOW
                           ,(LPVOID)(&sSI), 0
                           , NULL, 0
                           , &DummyBytesReturned, NULL);
    if (iRet) {
        *lpuStatus = sSI.uStatus;
        *lphShadow = sSI.hShadow;
    }

    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }

    return (iRet);
}

/*****************************************************************************
 *    Given an hDir and filename, get SHADOWINFO if it exists
 */
int
GetShadowExW(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    LPWIN32_FIND_DATAW    lpFind32,
    LPSHADOWINFO          lpSI
    )
{
    int            iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(lpSI, 0, sizeof(SHADOWINFO));
    lpSI->hDir = hDir;
    lpSI->lpFind32 = lpFind32;
    iRet = DeviceIoControl(hShadowDB
                           , IOCTL_GETSHADOW
                           ,(LPVOID)(lpSI), 0
                           , NULL, 0
                           , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(lpSI->dwError);
    }
    return (iRet);
}

/*****************************************************************************
 *    Call down to the VxD to add a file to the shadow.
 *    lphShadow is filled in with the new HSHADOW.
 *    Set uStatus as necessary (ie: SPARSE or whatever...)
 */
int
CreateShadowW(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    LPWIN32_FIND_DATAW    lpFind32,
    unsigned long        uStatus,
    LPHSHADOW            lphShadow
    )
{
    int            iRet;
    SHADOWINFO    sSI;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hDir = hDir;
    sSI.uStatus = uStatus;
    sSI.lpFind32 = lpFind32;
    iRet = DeviceIoControl(hShadowDB
                           , IOCTL_SHADOW_CREATE
                           ,(LPVOID)(&sSI), 0
                           , NULL, 0
                           , &DummyBytesReturned, NULL);
    if (iRet) {
        *lphShadow = sSI.hShadow;
    }

    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }

    return (iRet);
}

/*****************************************************************************
 *    given an hDir and hShadow, nuke the shadow
 */
int
DeleteShadow(
    HANDLE     hShadowDB,
    HSHADOW  hDir,
    HSHADOW  hShadow
    )
{
    SHADOWINFO sSI;
    BOOL        fDBOpened = FALSE;
    int iRet;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hDir = hDir;
    sSI.hShadow = hShadow;
    iRet = DeviceIoControl(hShadowDB  , IOCTL_SHADOW_DELETE
                           ,(LPVOID)(&sSI), 0
                           , NULL, 0
                           , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }

    return (iRet);
}

/*****************************************************************************
 *    given an hDir and hShadow, get WIN32_FIND_DATAW about the file.
 */
int
GetShadowInfoW(
    HANDLE                hShadowDB,
    HSHADOW            hDir,
    HSHADOW            hShadow,
    LPWIN32_FIND_DATAW    lpFind32,
    unsigned long        *lpuStatus
    )
{
    int iRet;
    SHADOWINFO    sSI;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hDir = hDir;
    sSI.hShadow = hShadow;
    sSI.lpFind32 = lpFind32;
    iRet = DeviceIoControl(hShadowDB    , IOCTL_SHADOW_GET_SHADOW_INFO
                                    ,(LPVOID)(&sSI), 0
                                    , NULL, 0
                                    , &DummyBytesReturned, NULL);
    *lpuStatus = sSI.uStatus;
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }

    return (iRet);
}

/*****************************************************************************
 *    given an hDir and hShadow, get WIN32_FIND_DATAW about the file and the SHADOWINFO
 */
int
GetShadowInfoExW(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    HSHADOW                hShadow,
    LPWIN32_FIND_DATAW    lpFind32,
    LPSHADOWINFO          lpSI
    )
{
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(lpSI, 0, sizeof(SHADOWINFO));
    lpSI->hDir = hDir;
    lpSI->hShadow = hShadow;
    lpSI->lpFind32 = lpFind32;
    iRet = DeviceIoControl(hShadowDB    , IOCTL_SHADOW_GET_SHADOW_INFO
                                    ,(LPVOID)(lpSI), 0
                                    , NULL, 0
                                    , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(lpSI->dwError);
    }

    return (iRet);
}

/*****************************************************************************
 *    given an hDir and hShadow, set WIN32_FIND_DATAW or uStatus about the file.
 *    Operation depends on uOp given.
 */
int
SetShadowInfoW(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    HSHADOW                hShadow,
    LPWIN32_FIND_DATAW    lpFind32,
    unsigned long        uStatus,
    unsigned long        uOp
    )
{
    SHADOWINFO    sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hDir = hDir;
    sSI.hShadow = hShadow;
    sSI.lpFind32 = lpFind32;
    sSI.uStatus = uStatus;
    sSI.uOp = uOp;
    iRet = DeviceIoControl(hShadowDB    , IOCTL_SHADOW_SET_SHADOW_INFO
                                    ,(LPVOID)(&sSI), 0
                                    , NULL, 0
                                    , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }

    return (iRet);
}

/*****************************************************************************
 *    Fills out a GLOBALSTATUS passed in.
 */
int
GetGlobalStatus(
    HANDLE            hShadowDB,
    LPGLOBALSTATUS    lpGS
    )
{
    BOOL        fDBOpened = FALSE;
    int iRet;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }
    iRet = DeviceIoControl(hShadowDB    , IOCTL_GETGLOBALSTATUS
                                    ,(LPVOID)(lpGS), 0
                                    , NULL, 0
                                    , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    return (iRet);
}

/*****************************************************************************
 *    given an hDir, enumerate the directory.     A SHADOWINFO will be filled in.
 *    You must pass in a LPWIN32_FIND_DATAW that has cFileName and fileAttributes
 *    set properly.  The cookie returned must be used in findNext calls.
 */
int
FindOpenShadowW(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    unsigned              uOp,
    LPWIN32_FIND_DATAW    lpFind32,
    LPSHADOWINFO        lpSI
)
{
    BOOL retVal;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(lpSI, 0, sizeof(SHADOWINFO));
    lpSI->uOp = uOp;
    lpSI->hDir = hDir;
    lpSI->lpFind32 = lpFind32;

    retVal = DeviceIoControl(hShadowDB    , IOCTL_FINDOPEN_SHADOW
                                    ,(LPVOID)(lpSI), 0
                                    , NULL, 0
                                    , &DummyBytesReturned, NULL);
    lpSI->lpFind32 = NULL;

    if(!retVal) {

        memset(lpSI, 0, sizeof(SHADOWINFO));
    }

    if (!retVal)
    {
        SetLastError(lpSI->dwError);
    }

    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    return retVal;
}

/*****************************************************************************
 *    Continue enumeration based on handle returned above.
 */
int
FindNextShadowW(
    HANDLE                hShadowDB,
    CSC_ENUMCOOKIE        uEnumCookie,
    LPWIN32_FIND_DATAW    lpFind32,
    LPSHADOWINFO        lpSI
    )
{
    BOOL retVal;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(lpSI, 0, sizeof(SHADOWINFO));
    lpSI->uEnumCookie = uEnumCookie;
    lpSI->lpFind32 = lpFind32;
    retVal = DeviceIoControl(hShadowDB    , IOCTL_FINDNEXT_SHADOW
                                    ,(LPVOID)(lpSI), 0
                                    , NULL, 0
                                    , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    return retVal;
}

/*****************************************************************************
 *    Finished enumeration, return the handle.
 */
int
FindCloseShadow(
    HANDLE                hShadowDB,
    CSC_ENUMCOOKIE        uEnumCookie
    )
{
    SHADOWINFO    sSI;
    int iRet;

    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }
    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uEnumCookie = uEnumCookie;
    iRet = DeviceIoControl(hShadowDB    , IOCTL_FINDCLOSE_SHADOW
                                    ,(LPVOID)(&sSI), 0
                                    , NULL, 0
                                    , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    return (iRet);
}

/*****************************************************************************
 *    Call down to the VxD to add a hint of some sort to the database.
 *    cFileName is the string to match against.
 *    lphShadow is filled in with the new HSHADOW.
 *    hDir = 0 means global hint.     Otherwise, this is the root to take it from.
 */
int
AddHintW(
    HANDLE            hShadowDB,
    HSHADOW            hDir,
    TCHAR            *cFileName,
    LPHSHADOW        lphShadow,
    unsigned long    ulHintFlags,
    unsigned long    ulHintPri
    )
{
    int                iRet;
    SHADOWINFO        sSI;
    WIN32_FIND_DATAW    sFind32;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    wcsncpy(sFind32.cFileName, cFileName, MAX_PATH-1);
    sSI.hDir = hDir;
    sSI.lpFind32 = (LPFIND32)&sFind32;
    sSI.ulHintFlags = ulHintFlags;
    sSI.ulHintPri = ulHintPri;

    iRet = DeviceIoControl(hShadowDB
                           , IOCTL_ADD_HINT
                           ,(LPVOID)(&sSI), 0
                           , NULL, 0
                           , &DummyBytesReturned, NULL);
    if (iRet) {
        *lphShadow = sSI.hShadow;
    }
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }
    return (iRet);
}

/*****************************************************************************
 *    Call down to the VxD to delete a hint of some sort from the database.
 *    cFileName is the string to match against.
 *    hDir = 0 means global hint.     Otherwise, this is the root to take it from.
 */
int
DeleteHintW(
    HANDLE    hShadowDB,
    HSHADOW    hDir,
    TCHAR   *cFileName,
    BOOL    fClearAll
    )
{
    int                iRet;
    SHADOWINFO        sSI;
    WIN32_FIND_DATAW    sFind32;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    wcsncpy(sFind32.cFileName, cFileName, MAX_PATH-1);

    sSI.hDir = hDir;
    sSI.lpFind32 = (LPFIND32)&sFind32;

    // nuke or just decrement?
    if (fClearAll)
    {
        sSI.ulHintPri = 0xffffffff;
    }
    iRet = DeviceIoControl(hShadowDB
                           , IOCTL_DELETE_HINT
                           ,(LPVOID)(&sSI), 0
                           , NULL, 0
                           , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }
    return iRet;
}

/*****************************************************************************
 *    given an hDir, enumerate the directory.     A SHADOWINFO will be filled in.
 *    You must pass in a LPWIN32_FIND_DATAW that has cFileName and fileAttributes
 *    set properly.  The cookie returned must be used in findNext calls.
 */
int
FindOpenHintW(
    HANDLE              hShadowDB,
    HSHADOW             hDir,
    LPWIN32_FIND_DATAW  lpFind32,
    CSC_ENUMCOOKIE      *lpuEnumCookie,
    HSHADOW             *hShadow,
    unsigned long       *lpulHintFlags,
    unsigned long       *lpulHintPri
    )
{
    SHADOWINFO    sSI;
    BOOL retVal;

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uOp = FINDOPEN_SHADOWINFO_ALL;
    sSI.hDir = hDir;
//    sSI.ulHintFlags = 0xF;
    sSI.ulHintFlags = HINT_TYPE_FOLDER;
    sSI.lpFind32 = lpFind32;

    retVal = DeviceIoControl(hShadowDB    , IOCTL_FINDOPEN_HINT
                                    ,(LPVOID)(&sSI), 0
                                    , NULL, 0
                                    , &DummyBytesReturned, NULL);
    if(retVal) {
        *lpuEnumCookie = sSI.uEnumCookie;
        *hShadow = sSI.hShadow;
        *lpulHintFlags = sSI.ulHintFlags;
        *lpulHintPri = sSI.ulHintPri;
    } else {
        *lpuEnumCookie = 0;
        *hShadow = 0;
    }
    return retVal;
}

/*****************************************************************************
 *    Continue enumeration based on handle returned above.
 */
int
FindNextHintW(
    HANDLE                hShadowDB,
    CSC_ENUMCOOKIE      uEnumCookie,
    LPWIN32_FIND_DATAW    lpFind32,
    HSHADOW            *hShadow,
    unsigned long        *lpuHintFlags,
    unsigned long        *lpuHintPri
    )
{
    SHADOWINFO    sSI;
    BOOL retVal;
    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uEnumCookie = uEnumCookie;
    sSI.lpFind32 = lpFind32;
    retVal = DeviceIoControl(hShadowDB    , IOCTL_FINDNEXT_HINT
                                    ,(LPVOID)(&sSI), 0
                                    , NULL, 0
                                    , &DummyBytesReturned, NULL);
    *hShadow = sSI.hShadow;
    *lpuHintFlags = sSI.ulHintFlags;
    *lpuHintPri = sSI.ulHintPri;

    return retVal;
}

/*****************************************************************************
 *    Finished enumeration, return the handle.
 */
int
FindCloseHint(
    HANDLE                hShadowDB,
    CSC_ENUMCOOKIE      uEnumCookie
    )
{
    SHADOWINFO    sSI;
    int iRet;
    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uEnumCookie = uEnumCookie;
    return(DeviceIoControl(hShadowDB    , IOCTL_FINDCLOSE_HINT
                                    ,(LPVOID)(&sSI), 0
                                    , NULL, 0
                                    , &DummyBytesReturned, NULL));
}



/*****************************************************************************
 *    Call down to the VxD to add a hint on the inode.
 *  This ioctl does the right thing for user and system hints
 *  If successful, there is an additional pincount on the inode entry
 *  and the flags that are passed in are ORed with the original entry
 */
int
AddHintFromInode(
    HANDLE            hShadowDB,
    HSHADOW            hDir,
    HSHADOW         hShadow,
    unsigned        long    *lpulPinCount,
    unsigned        long    *lpulHintFlags
    )
{
    int                iRet;
    SHADOWINFO        sSI;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hDir = hDir;
    sSI.hShadow = hShadow;
    sSI.ulHintFlags = *lpulHintFlags;
    sSI.uOp = SHADOW_ADDHINT_FROM_INODE;

    iRet = DeviceIoControl(hShadowDB
                           , IOCTL_DO_SHADOW_MAINTENANCE
                           ,(LPVOID)(&sSI), 0
                           , NULL, 0
                           , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }
    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }
    else
    {
        *lpulHintFlags = sSI.ulHintFlags;
        *lpulPinCount = sSI.ulHintPri;
    }
    return (iRet);
}

/*****************************************************************************
 *    Call down to the VxD to add a hint on the inode.
 *  This ioctl does the right thing for user and system hints
 *  If successful, there is an one pincount less than the original
 *  and the ~ of flags that are passed in are ANDed with the original entry
 */
int
DeleteHintFromInode(
    HANDLE    hShadowDB,
    HSHADOW    hDir,
    HSHADOW hShadow,
    unsigned        long    *lpulPinCount,
    unsigned        long    *lpulHintFlags
    )
{
    int                iRet;
    SHADOWINFO        sSI;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hDir = hDir;
    sSI.hShadow = hShadow;
    sSI.ulHintFlags = *lpulHintFlags;
    sSI.uOp = SHADOW_DELETEHINT_FROM_INODE;

    iRet = DeviceIoControl(hShadowDB
                           , IOCTL_DO_SHADOW_MAINTENANCE
                           ,(LPVOID)(&sSI), 0
                           , NULL, 0
                           , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }
    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }
    else
    {
        *lpulHintFlags = sSI.ulHintFlags;
        *lpulPinCount = sSI.ulHintPri;
    }
    return (iRet);
}





/******************************************************/


/*****************************************************************************
 *    Given an hDir and filename, find the hShadow, should it exist.
 */
int
GetShadowA(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    LPHSHADOW            lphShadow,
    LPWIN32_FIND_DATAA    lpFind32,
    unsigned long        *lpuStatus
    )
{
    int iRet;
    WIN32_FIND_DATAW sFind32, *lpFind32W = NULL;

    if (lpFind32)
    {
        lpFind32W = &sFind32;
        Find32AToFind32W(lpFind32, lpFind32W);
    }
    iRet = GetShadowW(hShadowDB, hDir, lphShadow, lpFind32W, lpuStatus);
    if (lpFind32)
    {
        Assert(lpFind32W);
        Find32WToFind32A(lpFind32W, lpFind32);
    }

    return (iRet);
}

/*****************************************************************************
 *    Given an hDir and filename, get SHADOWINFO if it exists
 */
int
GetShadowExA(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    LPWIN32_FIND_DATAA    lpFind32,
    LPSHADOWINFO          lpSI
    )
{
    int iRet;

    WIN32_FIND_DATAW sFind32, *lpFind32W = NULL;

    if (lpFind32)
    {
        lpFind32W = &sFind32;
        Find32AToFind32W(lpFind32, lpFind32W);
    }
    iRet = GetShadowExW(hShadowDB, hDir, lpFind32W, lpSI);

    if (lpFind32)
    {
        Assert(lpFind32W);
        Find32WToFind32A(lpFind32W, lpFind32);
    }

    return (iRet);
}

/*****************************************************************************
 *    Call down to the VxD to add a file to the shadow.
 *    lphShadow is filled in with the new HSHADOW.
 *    Set uStatus as necessary (ie: SPARSE or whatever...)
 */
int
CreateShadowA(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    LPWIN32_FIND_DATAA    lpFind32,
    unsigned long        uStatus,
    LPHSHADOW            lphShadow
    )
{
    int iRet;
    WIN32_FIND_DATAW sFind32, *lpFind32W = NULL;

    if (lpFind32)
    {
        lpFind32W = &sFind32;
        Find32AToFind32W(lpFind32, lpFind32W);
    }
    iRet = CreateShadowW(hShadowDB, hDir, lpFind32W, uStatus, lphShadow);

    if (lpFind32)
    {
        Assert(lpFind32W);
        Find32WToFind32A(lpFind32W, lpFind32);
    }

    return (iRet);
}

/*****************************************************************************
 *    given an hDir and hShadow, get WIN32_FIND_DATAA about the file.
 */
int
GetShadowInfoA(
    HANDLE                hShadowDB,
    HSHADOW            hDir,
    HSHADOW            hShadow,
    LPWIN32_FIND_DATAA    lpFind32,
    unsigned long        *lpuStatus
    )
{
    int iRet;
    WIN32_FIND_DATAW sFind32, *lpFind32W = NULL;

    if (lpFind32)
    {
        lpFind32W = &sFind32;
    }

    iRet = GetShadowInfoW(hShadowDB, hDir, hShadow, lpFind32W, lpuStatus);

    if (lpFind32)
    {
        Assert(lpFind32W);
        Find32WToFind32A(lpFind32W, lpFind32);
    }

    return (iRet);
}

/*****************************************************************************
 *    given an hDir and hShadow, get WIN32_FIND_DATAA about the file and the SHADOWINFO
 */
int
GetShadowInfoExA(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    HSHADOW                hShadow,
    LPWIN32_FIND_DATAA    lpFind32,
    LPSHADOWINFO          lpSI
    )
{
    int iRet;
    WIN32_FIND_DATAW sFind32, *lpFind32W = NULL;

    if (lpFind32)
    {
        lpFind32W = &sFind32;
    }

    iRet = GetShadowInfoExW(hShadowDB, hDir, hShadow, lpFind32W, lpSI);

    if (lpFind32)
    {
        Assert(lpFind32W);
        Find32WToFind32A(lpFind32W, lpFind32);
    }

    return (iRet);
}

/*****************************************************************************
 *    given an hDir and hShadow, set WIN32_FIND_DATAA or uStatus about the file.
 *    Operation depends on uOp given.
 */
int
SetShadowInfoA(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    HSHADOW                hShadow,
    LPWIN32_FIND_DATAA    lpFind32,
    unsigned long        uStatus,
    unsigned long        uOp
    )
{
    int iRet;
    WIN32_FIND_DATAW sFind32, *lpFind32W = NULL;

    if (lpFind32)
    {
        lpFind32W = &sFind32;
        Find32AToFind32W(lpFind32, lpFind32W);
    }

    iRet = SetShadowInfoW(hShadowDB, hDir, hShadow, lpFind32W, uStatus, uOp);

    if (lpFind32)
    {
        Assert(lpFind32W);
        Find32WToFind32A(lpFind32W, lpFind32);
    }

    return (iRet);
}

/*****************************************************************************
 *    given an hDir, enumerate the directory.     A SHADOWINFO will be filled in.
 *    You must pass in a LPWIN32_FIND_DATAA that has cFileName and fileAttributes
 *    set properly.  The cookie returned must be used in findNext calls.
 */
int
FindOpenShadowA(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    unsigned              uOp,
    LPWIN32_FIND_DATAA    lpFind32,
    LPSHADOWINFO        lpSI
)
{
    int iRet;
    WIN32_FIND_DATAW sFind32, *lpFind32W = NULL;

    if (lpFind32)
    {
        lpFind32W = &sFind32;
        Find32AToFind32W(lpFind32, lpFind32W);
    }

    iRet = FindOpenShadowW(hShadowDB, hDir, uOp, lpFind32W, lpSI);

    if (lpFind32)
    {
        Assert(lpFind32W);
        Find32WToFind32A(lpFind32W, lpFind32);
    }

    return (iRet);
}

/*****************************************************************************
 *    Continue enumeration based on handle returned above.
 */
int
FindNextShadowA(
    HANDLE                hShadowDB,
    CSC_ENUMCOOKIE        uEnumCookie,
    LPWIN32_FIND_DATAA    lpFind32,
    LPSHADOWINFO        lpSI
    )
{
    int iRet;
    WIN32_FIND_DATAW sFind32, *lpFind32W = NULL;

    if (lpFind32)
    {
        lpFind32W = &sFind32;
    }

    iRet = FindNextShadowW(hShadowDB, uEnumCookie, lpFind32W, lpSI);

    if (lpFind32)
    {
        Assert(lpFind32W);
        Find32WToFind32A(lpFind32W, lpFind32);
    }

    return (iRet);
}

/*****************************************************************************
 *    Call down to the VxD to add a hint of some sort to the database.
 *    cFileName is the string to match against.
 *    lphShadow is filled in with the new HSHADOW.
 *    hDir = 0 means global hint.     Otherwise, this is the root to take it from.
 */
int
AddHintA(
    HANDLE            hShadowDB,
    HSHADOW            hDir,
    char            *cFileName,
    LPHSHADOW        lphShadow,
    unsigned long    ulHintFlags,
    unsigned long    ulHintPri
    )
{
    int                iRet = 0;
    unsigned short wBuff[MAX_PATH];

    if (MultiByteToWideChar(CP_ACP, 0, cFileName, strlen(cFileName), wBuff, sizeof(wBuff)/sizeof(WCHAR)))
    {
        iRet = AddHintW(hShadowDB, hDir, wBuff, lphShadow, ulHintFlags, ulHintPri);
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return (iRet);
}

/*****************************************************************************
 *    Call down to the VxD to delete a hint of some sort from the database.
 *    cFileName is the string to match against.
 *    hDir = 0 means global hint.     Otherwise, this is the root to take it from.
 */
int
DeleteHintA(
    HANDLE    hShadowDB,
    HSHADOW    hDir,
    char    *cFileName,
    BOOL    fClearAll
    )
{
    int                iRet = 0;
    unsigned short wBuff[MAX_PATH];

    if (MultiByteToWideChar(CP_ACP, 0, cFileName, strlen(cFileName), wBuff, sizeof(wBuff)/sizeof(WCHAR)))
    {
        iRet = DeleteHintW(hShadowDB, hDir, wBuff, fClearAll);
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return (iRet);
}

/*****************************************************************************
 *    given an hDir, enumerate the directory.     A SHADOWINFO will be filled in.
 *    You must pass in a LPWIN32_FIND_DATAA that has cFileName and fileAttributes
 *    set properly.  The cookie returned must be used in findNext calls.
 */
int
FindOpenHintA(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    LPWIN32_FIND_DATAA    lpFind32,
    CSC_ENUMCOOKIE        *lpuEnumCookie,
    HSHADOW                *lphShadow,
    unsigned long        *lpulHintFlags,
    unsigned long        *lpulHintPri
    )
{
    int iRet;
    WIN32_FIND_DATAW sFind32, *lpFind32W = NULL;

    if (lpFind32)
    {
        lpFind32W = &sFind32;
        Find32AToFind32W(lpFind32, lpFind32W);
    }

    iRet = FindOpenHintW(hShadowDB, hDir, lpFind32W, lpuEnumCookie, lphShadow, lpulHintFlags, lpulHintPri);

    if (lpFind32)
    {
        Assert(lpFind32W);
        Find32WToFind32A(lpFind32W, lpFind32);
    }

    return (iRet);
}

/*****************************************************************************
 *    Continue enumeration based on handle returned above.
 */
int
FindNextHintA(
    HANDLE                hShadowDB,
    CSC_ENUMCOOKIE        uEnumCookie,
    LPWIN32_FIND_DATAA    lpFind32,
    HSHADOW                *hShadow,
    unsigned long        *lpuHintFlags,
    unsigned long        *lpuHintPri
    )
{
    int iRet;
    WIN32_FIND_DATAW sFind32, *lpFind32W = NULL;

    if (lpFind32)
    {
        lpFind32W = &sFind32;
    }

    iRet = FindNextHintW(hShadowDB, uEnumCookie, lpFind32W, hShadow, lpuHintFlags, lpuHintPri);

    if (lpFind32)
    {
        Assert(lpFind32W);
        Find32WToFind32A(lpFind32W, lpFind32);
    }

    return (iRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\lib3\pch.h ===
#define STRICT

#ifdef CSC_ON_NT

#define UNICODE // use all widecharacter APIs

#endif

#include <windows.h>
#include <windowsx.h>

// Dont link - just do it.
#pragma intrinsic(memcpy,memcmp,memset,strcpy,strlen,strcmp,strcat)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>			// implementation dependent values
#include <memory.h>
#include <winioctl.h>

#include "shdcom.h"

BOOL
Find32WToFind32A(
    WIN32_FIND_DATAW    *lpFind32W,
    WIN32_FIND_DATAA    *lpFind32A
);

BOOL
Find32AToFind32W(
    WIN32_FIND_DATAA    *lpFind32A,
    WIN32_FIND_DATAW    *lpFind32W
);

BOOL
ConvertCopyParamsFromUnicodeToAnsi(
    LPCOPYPARAMSW    lpCPUni,
    LPCOPYPARAMSA    lpCP
);

BOOL
ShareInfoWToShareInfoA(
    LPSHAREINFOW   lpShareInfoW,
    LPSHAREINFOA   lpShareInfoA
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\lib3\misc.c ===
#include "pch.h"
#pragma hdrstop

#include "lib3.h"
#include "assert.h"

//this variable is used as the receiver of the BytesReturned for DeviceIoControl Calls
//the value is never actually used...it is declared in lib3.c
extern ULONG DummyBytesReturned;

/* assert/debug stuff */
AssertData;
AssertError;

#define MAX_USERNAME    8   // this is not used any more


// error codes on which we decide that we are in disconnected state
static const DWORD rgdwErrorTab[] = {
     ERROR_BAD_NETPATH
    ,ERROR_NETWORK_BUSY
    ,ERROR_REM_NOT_LIST
    ,ERROR_DEV_NOT_EXIST
    ,ERROR_ADAP_HDW_ERR
    ,ERROR_BAD_NET_RESP
    ,ERROR_UNEXP_NET_ERR
    ,ERROR_BAD_REM_ADAP
    ,ERROR_BAD_NET_NAME
    ,ERROR_TOO_MANY_NAMES
    ,ERROR_TOO_MANY_SESS
    ,ERROR_NO_NET_OR_BAD_PATH
    ,ERROR_NETNAME_DELETED
    ,ERROR_NETWORK_UNREACHABLE
};

typedef struct tagREINT_IO
{
    HANDLE  hShadowDBAsync;
    OVERLAPPED  sOverlapped;
}
REINT_IO, *LPREINT_IO;

/*--------------------------- Widecharacter APIs ----------------------------------------*/

/*****************************************************************************
 *    GetUNCPath().  Pass in hShare, hDir, hShadow and get a LPCOPYPARAMS
 *    filled out fully.
 */
int
GetUNCPathW(
    HANDLE          hShadowDB,
    HSHARE         hShare,
    HSHADOW         hDir,
    HSHADOW         hShadow,
    LPCOPYPARAMSW   lpCP
    )
{
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    lpCP->uOp = 0;  // this means we are looking for a local path of the driveletter kind
                    // ie. c:\winnt\csc\80000002. That is the only kind that any
                    // usermode code should want
                    // on nt it can be \dosdevice\harddisk0\winnt\csc\80000002

    lpCP->hShare = hShare;

    lpCP->hDir = hDir;

    lpCP->hShadow = hShadow;

    iRet = DeviceIoControl( hShadowDB,
                            IOCTL_SHADOW_GET_UNC_PATH,
                            (LPVOID)(lpCP),
                            0,
                            NULL,
                            0,
                            &DummyBytesReturned,
                            NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(lpCP->dwError);
    }

    return (iRet);

}

/*****************************************************************************
 */
int
ChkUpdtStatusW(
    HANDLE                hShadowDB,
    unsigned long        hDir,
    unsigned long        hShadow,
    LPWIN32_FIND_DATAW   lpFind32,
    unsigned long        *lpulShadowStatus
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hShadow = hShadow;
    sSI.lpFind32 = lpFind32;
    if(DeviceIoControl(hShadowDB  , IOCTL_SHADOW_CHK_UPDT_STATUS
                             ,(LPVOID)(&sSI), 0
                             , NULL, 0
                             , &DummyBytesReturned, NULL))
    {
        *lpulShadowStatus = sSI.uStatus;
        iRet = 1;
    } else {
        *lpulShadowStatus = 0;
        iRet = 0;
    }
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }


    return (iRet);
}

int
GetShareInfoW(
    HANDLE              hShadowDB,
    HSHARE             hShare,
    LPSHAREINFOW       lpSVRI,
    unsigned long       *lpulStatus
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hShare = hShare;
    sSI.lpFind32 = (WIN32_FIND_DATAW *)lpSVRI;
    iRet = DeviceIoControl(hShadowDB  , IOCTL_GET_SHARE_STATUS
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if(iRet)
        *lpulStatus = sSI.uStatus;
    else
        *lpulStatus = 0;

    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }

    return iRet;
}



BOOL
CopyShadowA(
    HANDLE  hShadowDB,
    HSHADOW hDir,
    HSHADOW hShadow,
    LPSTR   lpszFileName
    )
{

    SHADOWINFO sSI;
    int iRet, len;
    BOOL        fDBOpened = FALSE;
    WIN32_FIND_DATAA    sFind32;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }
    memset(sFind32.cFileName, 0, sizeof(sFind32.cFileName));
    
	len = min(sizeof(sFind32.cFileName)-1,strlen(lpszFileName));
	
	strncpy(sFind32.cFileName, lpszFileName, len);

    sFind32.dwFileAttributes = FILE_ATTRIBUTE_SYSTEM;   // to make it explicit

    sSI.hDir = hDir;
    sSI.hShadow = hShadow;
    sSI.uOp = SHADOW_COPY_INODE_FILE;
    sSI.lpFind32 = (WIN32_FIND_DATAW *)&sFind32;
    iRet = DeviceIoControl(hShadowDB, IOCTL_DO_SHADOW_MAINTENANCE, (LPVOID)&(sSI), 0, NULL, 0, &DummyBytesReturned, NULL);

    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (iRet)
    {
        iRet = SetFileAttributesA(lpszFileName, 0);
    }
    
    if (!iRet)
    {
        DeleteFileA(lpszFileName);
        SetLastError(sSI.dwError);
        
    }


    return (iRet);

}

/*****************************************************************************
 *    GetUNCPath().  Pass in hShare, hDir, hShadow and get a LPCOPYPARAMS
 *    filled out fully.
 */
int
GetUNCPathA(
    HANDLE          hShadowDB,
    HSHARE         hShare,
    HSHADOW         hDir,
    HSHADOW         hShadow,
    LPCOPYPARAMSA   lpCP
    )
{
    int iRet = 0;
    LPCOPYPARAMSW lpCPW;

    if (lpCPW = LpAllocCopyParamsW())
    {
        iRet = GetUNCPathW(hShadowDB, hShare, hDir, hShadow, lpCPW);

        if (iRet == 1)
        {
            ConvertCopyParamsFromUnicodeToAnsi(lpCPW, lpCP);
        }

        FreeCopyParamsW(lpCPW);
    }

    return (iRet);

}

/*****************************************************************************
 */
int
ChkUpdtStatusA(
    HANDLE                hShadowDB,
    unsigned long        hDir,
    unsigned long        hShadow,
    LPWIN32_FIND_DATAA   lpFind32,
    unsigned long        *lpulShadowStatus
    )
{
    WIN32_FIND_DATAW    sFind32W;
    int iRet;

    iRet = ChkUpdtStatusW(hShadowDB, hDir, hShadow, (lpFind32)?&sFind32W:NULL, lpulShadowStatus);

    if ((iRet == 1) && lpFind32)
    {
        Find32WToFind32A(&sFind32W, lpFind32);
    }
    return (iRet);
}


int
GetShareInfoA(
    HANDLE              hShadowDB,
    HSHARE             hShare,
    LPSHAREINFOA       lpSVRI,
    unsigned long       *lpulStatus
    )
{
    int iRet;
    SHAREINFOW sShareInfoW;

    iRet = GetShareInfoW(hShadowDB, hShare, (lpSVRI)?&sShareInfoW:NULL, lpulStatus);

    if ((iRet==1) && lpSVRI)
    {
        ShareInfoWToShareInfoA(&sShareInfoW, lpSVRI);
    }
    return iRet;
}

BOOL
CopyShadowW(
    HANDLE  hShadowDB,
    HSHADOW hDir,
    HSHADOW hShadow,
    LPWSTR   lpwFileName
    )
{

    char chBuff[MAX_PATH];

    memset(chBuff, 0, sizeof(chBuff));
    WideCharToMultiByte(CP_ACP, 0, lpwFileName, wcslen(lpwFileName), chBuff, MAX_PATH, NULL, NULL);
    return (CopyShadowA(INVALID_HANDLE_VALUE, hDir, hShadow, chBuff));
}
/*****************************************************************************
 *    Cache maintenance ioctl
 */
int
DoShadowMaintenance(
    HANDLE            hShadowDB,
    unsigned long     uOp
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    sSI.uOp = uOp;
    iRet = DeviceIoControl(hShadowDB, IOCTL_DO_SHADOW_MAINTENANCE, (LPVOID)&(sSI), 0, NULL, 0, &DummyBytesReturned, NULL);

    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }


    return (iRet);

}


int
SetMaxShadowSpace(
    HANDLE    hShadowDB,
    long     nFileSizeHigh,
    long     nFileSizeLow
    )
{
    SHADOWINFO sSI;
    WIN32_FIND_DATAW   sFind32;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sFind32, 0, sizeof(WIN32_FIND_DATAW));
    memset(&sSI, 0, sizeof(SHADOWINFO));
    sFind32.nFileSizeHigh = nFileSizeHigh;
    sFind32.nFileSizeLow = nFileSizeLow;
    sSI.lpFind32 = &sFind32;
    sSI.uOp = SHADOW_SET_MAX_SPACE;
    iRet = DeviceIoControl(hShadowDB  , IOCTL_DO_SHADOW_MAINTENANCE
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);


    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }

    return (iRet);
}

BOOL
PurgeUnpinnedFiles(
    HANDLE hShadowDB,
    LONG   Timeout,
    PULONG  pnFiles,
    PULONG  pnYoungFiles)
{
    SHADOWINFO sSI;
    WIN32_FIND_DATAW sFind32;
    BOOL fDBOpened = FALSE;
    BOOL bRet;

    if (hShadowDB == INVALID_HANDLE_VALUE) {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE) {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sFind32, 0, sizeof(WIN32_FIND_DATAW));
    memset(&sSI, 0, sizeof(SHADOWINFO));
    sFind32.nFileSizeHigh = Timeout;
    sSI.lpFind32 = &sFind32;
    sSI.uOp = SHADOW_PURGE_UNPINNED_FILES;
    bRet = DeviceIoControl(
                hShadowDB,
                IOCTL_DO_SHADOW_MAINTENANCE,
                (LPVOID)(&sSI),
                0,
                NULL,
                0,
                &DummyBytesReturned,
                NULL);

    if (fDBOpened)
        CloseShadowDatabaseIO(hShadowDB);

    if (bRet == TRUE) {
        *pnFiles = sFind32.nFileSizeHigh;
        *pnYoungFiles = sFind32.nFileSizeLow;
    }

    return (bRet);
}

BOOL
ShareIdToShareName(
    HANDLE hShadowDB,
    ULONG ShareId,
    PBYTE Buffer,
    LPDWORD  pBufSize)
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE) {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
            return 0;
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hShare = ShareId;
    sSI.lpBuffer = (LPVOID)(Buffer);
    sSI.cbBufferSize = *pBufSize;

    iRet = DeviceIoControl(
                    hShadowDB,
                    IOCTL_SHAREID_TO_SHARENAME,
                    (LPVOID)(&sSI), 0,
                    NULL, 0,
                    &DummyBytesReturned, NULL);
    if (fDBOpened)
        CloseShadowDatabaseIO(hShadowDB);
    if (!iRet) {
        *pBufSize = sSI.cbBufferSize;
        SetLastError(sSI.dwError);
    }
    return (iRet);


}


/*****************************************************************************
 *    Priority queue enumerators
 */
int
BeginPQEnum(
    HANDLE        hShadowDB,
    LPPQPARAMS     lpPQP
    )
{
    return DeviceIoControl(hShadowDB, IOCTL_SHADOW_BEGIN_PQ_ENUM
                                  ,(LPVOID)(lpPQP), 0, NULL, 0, &DummyBytesReturned, NULL);
}

int
NextPriShadow(
    HANDLE        hShadowDB,
    LPPQPARAMS     lpPQP
    )
{
    return DeviceIoControl(hShadowDB, IOCTL_SHADOW_NEXT_PRI_SHADOW
                                  ,(LPVOID)(lpPQP), 0, NULL, 0, &DummyBytesReturned, NULL);
}

int
PrevPriShadow(
    HANDLE        hShadowDB,
    LPPQPARAMS     lpPQP
    )
{
    return DeviceIoControl(hShadowDB, IOCTL_SHADOW_PREV_PRI_SHADOW
                                  ,(LPVOID)(lpPQP), 0, NULL, 0, &DummyBytesReturned, NULL);
}

int
EndPQEnum(
    HANDLE        hShadowDB,
    LPPQPARAMS    lpPQP
    )
{
    return DeviceIoControl(hShadowDB, IOCTL_SHADOW_END_PQ_ENUM
                                  ,(LPVOID)(lpPQP), 0, NULL, 0, &DummyBytesReturned, NULL);
}


/*****************************************************************************
 *    FreeShadowSpace().  Pass in lpFind32 with filesize stuff filled out?.
 *    tHACK: not a very elegant interface.
 */
int
FreeShadowSpace(
    HANDLE  hShadowDB,
    long    nFileSizeHigh,
    long    nFileSizeLow,
    BOOL    fClearAll
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;
    WIN32_FIND_DATAW sFind32;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    memset(&sFind32, 0, sizeof(sFind32));
    sFind32.nFileSizeHigh = nFileSizeHigh;
    sFind32.nFileSizeLow = nFileSizeLow;
    sSI.lpFind32 = (LPWIN32_FIND_DATAW)&sFind32;
    sSI.uOp = SHADOW_MAKE_SPACE;

    if (fClearAll)
    {
        sSI.ulHintPri = 0xffffffff;
    }

    iRet = DeviceIoControl(hShadowDB  , IOCTL_DO_SHADOW_MAINTENANCE
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);


    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }


    return (iRet);
}

int
GetSpaceStats(
    HANDLE  hShadowDB,
    SHADOWSTORE *lpsST
)
{
    SHADOWINFO  sSI;
    int         iRet;
    BOOL        fDBOpened = FALSE;
    SHADOWSTORE sST;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    memset(&sST, 0, sizeof(sST));

    sSI.lpBuffer = (LPVOID)&sST;
    sSI.cbBufferSize = sizeof(sST);

    sSI.uOp = SHADOW_GET_SPACE_STATS;

    iRet = DeviceIoControl(hShadowDB  , IOCTL_DO_SHADOW_MAINTENANCE
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);


    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    *lpsST = sST;

    return (iRet);

}


/*****************************************************************************
 */
#ifndef NT
int CopyChunk(
                HANDLE    hShadowDB,
                LPSHADOWINFO    lpSI,
                struct tagCOPYCHUNKCONTEXT FAR *CopyChunkContext
             )
{
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    iRet = DeviceIoControl(hShadowDB  , IOCTL_SHADOW_COPYCHUNK
                                  ,(LPVOID)(lpSI), 0
                                  , (LPVOID)CopyChunkContext, 0
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    return (iRet);
}
#else
int CopyChunk(
                HANDLE                          hShadowDB,
                LPSHADOWINFO                    lpSI,
                struct tagCOPYCHUNKCONTEXT FAR  *CopyChunkContext
             )
{
    BOOL Success;
    BOOL fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    CopyChunkContext->LastAmountRead = 0;

    Success = DeviceIoControl(hShadowDB  , IOCTL_SHADOW_COPYCHUNK
                                  , (LPVOID)(lpSI), 0
                                  , (LPVOID)CopyChunkContext, sizeof(*CopyChunkContext)
                                  , &DummyBytesReturned, NULL);

    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    return(Success);
}

int CloseFileWithCopyChunkIntent(
    HANDLE    hShadowDB,
    struct tagCOPYCHUNKCONTEXT FAR *CopyChunkContext
    )
{
    BOOL Success;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }


    Success = DeviceIoControl(hShadowDB  , IOCTL_CLOSEFORCOPYCHUNK
                                  , NULL, 0
                                  , (LPVOID)CopyChunkContext, sizeof(*CopyChunkContext)
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    return(Success);
}
int OpenFileWithCopyChunkIntent(
    HANDLE      hShadowDB,
    LPCWSTR     lpFileName,
    struct      tagCOPYCHUNKCONTEXT FAR *CopyChunkContext,
    int         ChunkSize
    )
{
    BOOL Success;
    int FileNameLength;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }



    FileNameLength = wcslen(lpFileName) * sizeof(USHORT);

    CopyChunkContext->ChunkSize = ChunkSize;

    Success = DeviceIoControl(hShadowDB  , IOCTL_OPENFORCOPYCHUNK
                                  , (LPVOID)lpFileName, FileNameLength
                                  , (LPVOID)CopyChunkContext, sizeof(*CopyChunkContext)
                                  , &DummyBytesReturned, NULL);

    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    return(Success);
}
#endif

int
BeginReint(
    HSHARE      hShare,
    BOOL        fBlockingReint,
    LPREINT_IO  *lplpReintIO
    )
{
    SHADOWINFO sSI;
    LPREINT_IO lpReintIO = NULL;
    BOOL fSuccess = FALSE;
    
    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hShare = hShare;

    lpReintIO = LocalAlloc(LPTR, sizeof(REINT_IO));
    if (!lpReintIO)
    {
        return 0;        
    }
    
    // don't create hevent in the overlapped structure because we are not going to do any read write
    // on this

    if (!fBlockingReint)
    {
        sSI.uOp = 1;
    }
    
    // create an async handle
    lpReintIO->hShadowDBAsync = OpenShadowDatabaseIOex(1, FILE_FLAG_OVERLAPPED);

    if (lpReintIO->hShadowDBAsync == INVALID_HANDLE_VALUE)
    {
        goto bailout;
    }

    *lplpReintIO = lpReintIO;

    // issue an overlapped I/O request
    // This creates an IRP which is cancelled when the thread that is merging
    // dies in the middle of a merge
    fSuccess = DeviceIoControl(lpReintIO->hShadowDBAsync  , IOCTL_SHADOW_BEGIN_REINT
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, &(lpReintIO->sOverlapped));
bailout:
    if (!fSuccess)
    {
        DWORD   dwError;

        dwError = GetLastError();
        if (dwError != ERROR_IO_PENDING)
        {
            if (lpReintIO->hShadowDBAsync != INVALID_HANDLE_VALUE)
            {
                CloseHandle(lpReintIO->hShadowDBAsync);
            }
            LocalFree(lpReintIO);
            SetLastError(dwError);
            *lplpReintIO = NULL;
        }
        else
        {
            fSuccess = TRUE;
        }
    }

    return fSuccess;
}

int
EndReint(
    HSHARE      hShare,
    LPREINT_IO  lpReintIO
    )
{
    SHADOWINFO sSI;
    BOOL fSuccess;
    DWORD   dwError = NO_ERROR;   

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hShare = hShare;
    fSuccess = DeviceIoControl(lpReintIO->hShadowDBAsync  , IOCTL_SHADOW_END_REINT
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    
    if (!fSuccess)
    {
        dwError = GetLastError();        
    }

    CloseHandle(lpReintIO->hShadowDBAsync);
    LocalFree(lpReintIO);

    if (!fSuccess)
    {
        SetLastError(dwError);        
    }
    return fSuccess;
}

int
SetShareStatus(
    HANDLE          hShadowDB,
    HSHARE         hShare,
    unsigned long   uStatus,
    unsigned long   uOp
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hShare = hShare;
    sSI.uStatus = uStatus;
    sSI.uOp = uOp;
    iRet = DeviceIoControl(hShadowDB  , IOCTL_SET_SHARE_STATUS
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }

    return (iRet);
}

int
GetShareStatus(
    HANDLE          hShadowDB,
    HSHARE         hShare,
    unsigned long   *lpulStatus
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hShare = hShare;
    iRet = DeviceIoControl(hShadowDB  , IOCTL_GET_SHARE_STATUS
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if(iRet)
    {
        *lpulStatus = sSI.uStatus;
    }
    else
    {
        *lpulStatus = 0;
    }

    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }


    return iRet;
}


int ShadowSwitches(
    HANDLE          hShadowDB,
    unsigned long   *lpuSwitches,
    unsigned long   uOp
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uStatus = *lpuSwitches;
    sSI.uOp = uOp;
    iRet = DeviceIoControl(hShadowDB  , IOCTL_SWITCHES
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    *lpuSwitches = sSI.uStatus;
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }


    return (iRet);
}


int GetShadowDatabaseLocationW(
    HANDLE              hShadowDB,
    WIN32_FIND_DATAW    *lpFind32W
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uStatus = SHADOW_SWITCH_SHADOWING;
    sSI.uOp = SHADOW_SWITCH_GET_STATE;
    sSI.lpFind32 = lpFind32W;

    iRet = DeviceIoControl(hShadowDB  , IOCTL_SWITCHES
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }
    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }
    return (iRet);
}

int EnableShadowing(
    HANDLE    hShadowDB,
    LPCSTR    lpszDatabaseLocation,    // location of the shadowing directory
    LPCSTR    lpszUserName,            // name of the user
    DWORD    dwDefDataSizeHigh,        // cache size if being created for the first time
    DWORD    dwDefDataSizeLow,
    DWORD   dwClusterSize,
    BOOL    fReformat
)
{
    SHADOWINFO sSI;
    WIN32_FIND_DATAA   sFind32;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    memset(&sFind32, 0, sizeof(WIN32_FIND_DATAA));
    sFind32.nFileSizeHigh = dwDefDataSizeHigh;
    sFind32.nFileSizeLow = dwDefDataSizeLow;
    sFind32.dwReserved1 = dwClusterSize;
    if (lpszDatabaseLocation)
    {
        if (strlen(lpszDatabaseLocation) > sizeof(sFind32.cFileName))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return 0;
        }

        strcpy(sFind32.cFileName, lpszDatabaseLocation);
    }
    if (lpszUserName)
    {
        strncpy(sFind32.cAlternateFileName, lpszUserName, MAX_USERNAME);
    }
    sSI.uStatus = SHADOW_SWITCH_SHADOWING;
    sSI.uOp = SHADOW_SWITCH_ON;
    sSI.ulRefPri = fReformat;
    sSI.lpFind32 = (WIN32_FIND_DATAW *)&sFind32;
    iRet = DeviceIoControl(hShadowDB  , IOCTL_SWITCHES
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }


    return (iRet);
}

int
RegisterAgent(
    HANDLE  hShadowDB,
    HWND    hwndAgent,
    HANDLE  hEvent
    )
{

    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = __OpenShadowDatabaseIO(1);
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(sSI));
    sSI.hShare = HandleToUlong(hwndAgent);
    sSI.hDir = HandleToUlong(hEvent);

    //
    // Ensure that we're dealing with truncatable handles here
    //

    Assert( (HANDLE)sSI.hShare == hwndAgent );
    Assert( (HANDLE)sSI.hDir == hEvent );

    iRet = DeviceIoControl(hShadowDB, IOCTL_SHADOW_REGISTER_AGENT,
                                  (LPVOID)&sSI, 0,
                                  NULL, 0,
                                  &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }

    return (iRet);
}

int
UnregisterAgent(
    HANDLE  hShadowDB,
    HWND    hwndAgent
    )
{
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    iRet = DeviceIoControl(hShadowDB, IOCTL_SHADOW_UNREGISTER_AGENT,
                                  (LPVOID)hwndAgent, 0,
                                  NULL, 0,
                                  &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    return (iRet);
}


int
DisableShadowingForThisThread(
    HANDLE  hShadowDB
    )
{
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }
    iRet = DoShadowMaintenance(hShadowDB, SHADOW_PER_THREAD_DISABLE);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }
    return (iRet);
}

int
EnableShadowingForThisThread(
    HANDLE  hShadowDB
    )
{
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }
    iRet = DoShadowMaintenance(hShadowDB, SHADOW_PER_THREAD_ENABLE);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }
    return (iRet);

}

int
ReinitShadowDatabase(
    HANDLE  hShadowDB,
    LPCSTR  lpszDatabaseLocation,    // location of the shadowing directory
    LPCSTR  lpszUserName,            // name of the user
    DWORD   dwDefDataSizeHigh,        // cache size if being created for the first time
    DWORD   dwDefDataSizeLow,
    DWORD   dwClusterSize
    )
{
    SHADOWINFO sSI;
    WIN32_FIND_DATAA   sFind32;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    memset(&sFind32, 0, sizeof(WIN32_FIND_DATAA));
    sFind32.nFileSizeHigh = dwDefDataSizeHigh;
    sFind32.nFileSizeLow = dwDefDataSizeLow;
    sFind32.dwReserved1 = dwClusterSize;
    if (lpszDatabaseLocation)
    {
        if (strlen(lpszDatabaseLocation) > sizeof(sFind32.cFileName))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return 0;
        }
        strcpy(sFind32.cFileName, lpszDatabaseLocation);
    }
    if (lpszUserName)
    {
        strncpy(sFind32.cAlternateFileName, lpszUserName, MAX_USERNAME);
    }
    sSI.uOp = SHADOW_REINIT_DATABASE;
    sSI.lpFind32 = (WIN32_FIND_DATAW *)&sFind32;
    iRet = DeviceIoControl(hShadowDB  , IOCTL_DO_SHADOW_MAINTENANCE
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }

    return (iRet);
}



BOOL
IsNetDisconnected(
    DWORD dwErrorCode
)
{
    int i;

    if (dwErrorCode != NO_ERROR)
    {

        for (i=0; i< (sizeof(rgdwErrorTab)/sizeof(DWORD)); ++i)
        {
            if (rgdwErrorTab[i] == dwErrorCode)
            {
//                DEBUG_PRINT(("lib3: IsNetDisconnected on %d\r\n",  dwErrorCode));
                return TRUE;
            }
        }
    }

    return FALSE;
}

int
FindCreatePrincipalIDFromSID(
    HANDLE  hShadowDB,
    LPVOID  lpSidBuffer,
    ULONG   cbSidLength,
    ULONG   *lpuPrincipalID,
    BOOL    fCreate
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uSubOperation = SHADOW_FIND_CREATE_PRINCIPAL_ID;
    sSI.lpBuffer = lpSidBuffer;
    sSI.cbBufferSize = cbSidLength;
    sSI.uStatus = fCreate;
    iRet = DeviceIoControl(hShadowDB  , IOCTL_DO_SHADOW_MAINTENANCE
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (iRet)
    {
        *lpuPrincipalID = sSI.ulPrincipalID;
    }
    else
    {
        SetLastError(sSI.dwError);
    }


    return (iRet);
}

int
GetSecurityInfoForCSC(
    HANDLE          hShadowDB,
    HSHADOW         hDir,
    HSHADOW         hShadow,
    LPSECURITYINFO  lpSecurityInfo,
    DWORD           *lpdwBufferSize
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uSubOperation = SHADOW_GET_SECURITY_INFO;
    sSI.lpBuffer = lpSecurityInfo;
    sSI.cbBufferSize = *lpdwBufferSize;
    sSI.hDir = hDir;
    sSI.hShadow = hShadow;
    iRet = DeviceIoControl(hShadowDB  , IOCTL_DO_SHADOW_MAINTENANCE
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (iRet)
    {
        *lpdwBufferSize = sSI.cbBufferSize;
    }
    else
    {
        SetLastError(sSI.dwError);
    }


    return (iRet);

}

BOOL
SetExclusionList(
    HANDLE  hShadowDB,
    LPWSTR  lpwList,
    DWORD   cbSize
    )
{

    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uSubOperation = SHADOW_SET_EXCLUSION_LIST;
    sSI.lpBuffer = lpwList;
    sSI.cbBufferSize = cbSize;

    iRet = DeviceIoControl(hShadowDB  , IOCTL_DO_SHADOW_MAINTENANCE
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }


    return (iRet);

}

BOOL
SetBandwidthConservationList(
    HANDLE  hShadowDB,
    LPWSTR  lpwList,
    DWORD   cbSize
    )
{

    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uSubOperation = SHADOW_SET_BW_CONSERVE_LIST;
    sSI.lpBuffer = lpwList;
    sSI.cbBufferSize = cbSize;

    iRet = DeviceIoControl(hShadowDB  , IOCTL_DO_SHADOW_MAINTENANCE
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }


    return (iRet);

}


BOOL
TransitionShareInternal(
    HANDLE  hShadowDB,
    HSHARE hShare,
    BOOL    fTrue,
    BOOL    fOnlineToOffline
    )
{

    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hShare = hShare;
    sSI.uStatus = fTrue;

    iRet = DeviceIoControl(
                    hShadowDB,
                    (fOnlineToOffline)?IOCTL_TRANSITION_SERVER_TO_OFFLINE:IOCTL_TRANSITION_SERVER_TO_ONLINE
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    return (iRet);

}

BOOL
TransitionShareToOffline(
    HANDLE  hShadowDB,
    HSHARE hShare,
    BOOL    fTrue
    )
{
    return TransitionShareInternal(
                hShadowDB,
                hShare,    // which share
                fTrue,      // transtion or not
                TRUE);      // online to offline
}

BOOL
TransitionShareToOnline(
    HANDLE  hShadowDB,
    HSHARE hShare
    )
{
    return TransitionShareInternal(
            hShadowDB,
            hShare,    // which share
            TRUE,       // really a don't care
            FALSE);     // offlinetoonline
}


BOOL
IsServerOfflineW(
    HANDLE  hShadowDB,
    LPCWSTR  lptzShare,
    BOOL    *lpfIsOffline
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    if (lptzShare)
    {
        sSI.lpBuffer = (LPVOID)(lptzShare);
        sSI.cbBufferSize = sizeof(WORD) * (lstrlenW(lptzShare)+1);
    }


    iRet = DeviceIoControl(
                    hShadowDB,
                    IOCTL_IS_SERVER_OFFLINE
                    ,(LPVOID)(&sSI), 0
                    , NULL, 0
                    , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (iRet)
    {
        *lpfIsOffline = sSI.uStatus;
    }
    return (iRet);

}

BOOL
IsServerOfflineA(
    HANDLE  hShadowDB,
    LPCSTR  lptzShare,
    BOOL    *lpfIsOffline
    )
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

int GetShadowDatabaseLocationA(
    HANDLE              hShadowDB,
    WIN32_FIND_DATAA    *lpFind32A
    )
{
    int iRet = 0;
    WIN32_FIND_DATAW    sFind32W;

    if (GetShadowDatabaseLocationW(hShadowDB, &sFind32W))
    {
        memset(lpFind32A, 0, sizeof(*lpFind32A));
        iRet = WideCharToMultiByte(CP_ACP, 0, sFind32W.cFileName, wcslen(sFind32W.cFileName), lpFind32A->cFileName, sizeof(lpFind32A->cFileName), NULL, NULL);
    }

    return (iRet);
}

BOOL
GetNameOfServerGoingOfflineW(
    HANDLE      hShadowDB,
    LPBYTE      lpBuffer,
    LPDWORD     lpdwSize
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.lpBuffer = (LPVOID)(lpBuffer);
    sSI.cbBufferSize = *lpdwSize;


    iRet = DeviceIoControl(
                    hShadowDB,
                    IOCTL_NAME_OF_SERVER_GOING_OFFLINE
                    ,(LPVOID)(&sSI), 0
                    , NULL, 0
                    , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        *lpdwSize = sSI.cbBufferSize;
    }

    return (iRet);

}

BOOL
RenameShadow(
    HANDLE  hShadowDB,
    HSHADOW hDirFrom,
    HSHADOW hShadowFrom,
    HSHADOW hDirTo,
    LPWIN32_FIND_DATAW   lpFind32,
    BOOL    fReplaceFile,
    HSHADOW *lphShadowTo
    )
{

    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));

    sSI.hDir = hDirFrom;
    sSI.hShadow = hShadowFrom;
    sSI.hDirTo = hDirTo;
    sSI.uSubOperation = SHADOW_RENAME;
    sSI.uStatus = fReplaceFile;
    sSI.lpFind32 = lpFind32;
    iRet = DeviceIoControl(
                    hShadowDB
                    ,IOCTL_DO_SHADOW_MAINTENANCE
                    ,(LPVOID)(&sSI), 0
                    , NULL, 0
                    , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }
    else
    {
        if (lphShadowTo)
        {
            *lphShadowTo = sSI.hShadow;
        }
    }
    return (iRet);

}

BOOL
GetSparseStaleDetectionCounter(
    HANDLE  hShadowDB,
    LPDWORD lpdwCounter
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uSubOperation = SHADOW_SPARSE_STALE_DETECTION_COUNTER;

    iRet = DeviceIoControl(
                    hShadowDB
                    ,IOCTL_DO_SHADOW_MAINTENANCE
                    ,(LPVOID)(&sSI), 0
                    , NULL, 0
                    , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }
    else
    {
        *lpdwCounter = sSI.dwError;
    }

    return (iRet);


}

BOOL
GetManualFileDetectionCounter(
    HANDLE  hShadowDB,
    LPDWORD lpdwCounter
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uSubOperation = SHADOW_MANUAL_FILE_DETECTION_COUNTER;

    iRet = DeviceIoControl(
                    hShadowDB
                    ,IOCTL_DO_SHADOW_MAINTENANCE
                    ,(LPVOID)(&sSI), 0
                    , NULL, 0
                    , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }
    else
    {
        *lpdwCounter = sSI.dwError;
    }

    return (iRet);


}


int EnableShadowingForUser(
    HANDLE    hShadowDB,
    LPCSTR    lpszDatabaseLocation,    // location of the shadowing directory
    LPCSTR    lpszUserName,            // name of the user
    DWORD    dwDefDataSizeHigh,        // cache size if being created for the first time
    DWORD    dwDefDataSizeLow,
    DWORD   dwClusterSize,
    BOOL    fFormat
)
{
    SHADOWINFO sSI;
    WIN32_FIND_DATAA   sFind32;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    memset(&sFind32, 0, sizeof(WIN32_FIND_DATAA));
    sFind32.nFileSizeHigh = dwDefDataSizeHigh;
    sFind32.nFileSizeLow = dwDefDataSizeLow;
    sFind32.dwReserved1 = dwClusterSize;
    if (lpszDatabaseLocation)
    {
        if (strlen(lpszDatabaseLocation) > sizeof(sFind32.cFileName))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return 0;
        }

        strcpy(sFind32.cFileName, lpszDatabaseLocation);
    }
    if (lpszUserName)
    {
        strncpy(sFind32.cAlternateFileName, lpszUserName, MAX_USERNAME);
    }

    sSI.lpFind32 = (WIN32_FIND_DATAW *)&sFind32;
    sSI.uSubOperation = SHADOW_ENABLE_CSC_FOR_USER;
    sSI.ulRefPri = fFormat;

    iRet = DeviceIoControl(hShadowDB
                           ,IOCTL_DO_SHADOW_MAINTENANCE,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }


    return (iRet);
}

int DisableShadowingForUser(
    HANDLE    hShadowDB
)
{
    SHADOWINFO sSI;
    WIN32_FIND_DATAA   sFind32;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uSubOperation = SHADOW_DISABLE_CSC_FOR_USER;

    iRet = DeviceIoControl(hShadowDB
                           ,IOCTL_DO_SHADOW_MAINTENANCE,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }


    return (iRet);
}


LPCOPYPARAMSW LpAllocCopyParamsW(
    VOID
    )
{
    LPCOPYPARAMSW   lpCPW = NULL;

    DWORD   dwMinSize = (sizeof(COPYPARAMSW) + MAX_PATH+MAX_PATH+MAX_SERVER_SHARE_NAME_FOR_CSC)*sizeof(unsigned short);

    lpCPW = (LPCOPYPARAMSW)LocalAlloc(LPTR, dwMinSize);

    if (lpCPW)
    {
        lpCPW->lpLocalPath  = (LPWSTR)((LPBYTE)lpCPW+sizeof(COPYPARAMSW));
        lpCPW->lpRemotePath = (lpCPW->lpLocalPath + MAX_PATH);
        lpCPW->lpSharePath = (lpCPW->lpRemotePath + MAX_PATH);

    }

    return (lpCPW);
}

VOID
FreeCopyParamsW(
    IN LPCOPYPARAMSW lpCPW
    )
{
    LocalFree(lpCPW);
}

LPCOPYPARAMSA LpAllocCopyParamsA(
    VOID
    )
{
    LPCOPYPARAMSA   lpCPA = NULL;
    DWORD   dwMinSize = (sizeof(COPYPARAMSA) + MAX_PATH+MAX_PATH+MAX_SERVER_SHARE_NAME_FOR_CSC);

    lpCPA = (LPCOPYPARAMSA)LocalAlloc(LPTR, dwMinSize);

    if (lpCPA)
    {
        lpCPA->lpLocalPath  = (LPSTR)((LPBYTE)lpCPA+sizeof(COPYPARAMSA));
        lpCPA->lpRemotePath = (lpCPA->lpLocalPath + MAX_PATH);
        lpCPA->lpSharePath = (lpCPA->lpRemotePath + MAX_PATH);

    }
    return (lpCPA);
}

VOID
FreeCopyParamsA(
    IN LPCOPYPARAMSA lpCPA
    )
{
    LocalFree(lpCPA);
}

BOOL
ConvertCopyParamsFromUnicodeToAnsi(
    LPCOPYPARAMSW   lpCPUni,
    LPCOPYPARAMSA   lpCP
)
{
    memset(lpCP->lpLocalPath, 0, MAX_PATH);
    memset(lpCP->lpRemotePath, 0, MAX_PATH);
    memset(lpCP->lpSharePath, 0, MAX_SERVER_SHARE_NAME_FOR_CSC);

    WideCharToMultiByte(CP_ACP, 0, lpCPUni->lpLocalPath, wcslen(lpCPUni->lpLocalPath), lpCP->lpLocalPath, MAX_PATH, NULL, NULL);
    WideCharToMultiByte(CP_ACP, 0, lpCPUni->lpRemotePath, wcslen(lpCPUni->lpRemotePath), lpCP->lpRemotePath, MAX_PATH, NULL, NULL);
    WideCharToMultiByte(CP_ACP, 0, lpCPUni->lpSharePath, wcslen(lpCPUni->lpSharePath), lpCP->lpSharePath, MAX_SERVER_SHARE_NAME_FOR_CSC, NULL, NULL);
    return TRUE;
}

BOOL
Find32WToFind32A(
    WIN32_FIND_DATAW    *lpFind32W,
    WIN32_FIND_DATAA    *lpFind32A
    )
{
    memset(lpFind32A, 0, sizeof(WIN32_FIND_DATAA));
    memcpy(lpFind32A, lpFind32W, sizeof(WIN32_FIND_DATAA)-sizeof(lpFind32A->cFileName)-sizeof(lpFind32A->cAlternateFileName));

    if (    WideCharToMultiByte(CP_ACP, 0, lpFind32W->cFileName, wcslen(lpFind32W->cFileName), lpFind32A->cFileName, sizeof(lpFind32A->cFileName), NULL, NULL)
        &&  WideCharToMultiByte(CP_OEMCP, 0, lpFind32W->cAlternateFileName, wcslen(lpFind32W->cAlternateFileName), lpFind32A->cAlternateFileName, sizeof(lpFind32A->cAlternateFileName), NULL, NULL))
    {
        return TRUE;
    }
    return FALSE;
}

BOOL
Find32AToFind32W(
    WIN32_FIND_DATAA    *lpFind32A,
    WIN32_FIND_DATAW    *lpFind32W
    )
{
    memset(lpFind32W, 0, sizeof(WIN32_FIND_DATAW));
    memcpy(lpFind32W, lpFind32A, sizeof(WIN32_FIND_DATAW)-sizeof(lpFind32W->cFileName)-sizeof(lpFind32W->cAlternateFileName));

    if (    MultiByteToWideChar(CP_ACP, 0, lpFind32A->cFileName, strlen(lpFind32A->cFileName), lpFind32W->cFileName, sizeof(lpFind32W->cFileName)/sizeof(WCHAR))
        &&  MultiByteToWideChar(CP_OEMCP, 0, lpFind32A->cAlternateFileName, strlen(lpFind32A->cAlternateFileName), lpFind32W->cAlternateFileName, sizeof(lpFind32W->cAlternateFileName)/sizeof(WCHAR)))
    {
        return TRUE;
    }
    return FALSE;
}

BOOL
ShareInfoWToShareInfoA(
    LPSHAREINFOW   lpShareInfoW,
    LPSHAREINFOA   lpShareInfoA
    )
{
    memset(lpShareInfoA, 0, sizeof(*lpShareInfoA));

    lpShareInfoA->hShare = lpShareInfoW->hShare;
    lpShareInfoA->usCaps = lpShareInfoW->usCaps;
    lpShareInfoA->usState = lpShareInfoW->usState;

    WideCharToMultiByte( CP_ACP, 0,
                         lpShareInfoW->rgSharePath,
                         wcslen(lpShareInfoW->rgSharePath),
                         lpShareInfoA->rgSharePath,
                         sizeof(lpShareInfoA->rgSharePath), NULL, NULL);

    WideCharToMultiByte(    CP_ACP, 0,
                            lpShareInfoW->rgFileSystem,
                            wcslen(lpShareInfoW->rgFileSystem),
                            lpShareInfoA->rgFileSystem,
                            sizeof(lpShareInfoA->rgFileSystem), NULL, NULL);
    return TRUE;
}

BOOL
RecreateShadow(
    HANDLE  hShadowDB,
    HSHADOW hDir,
    HSHADOW hShadow,
    ULONG   ulAttrib
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hDir = hDir;
    sSI.hShadow = hShadow;
    sSI.uStatus = ulAttrib;
    sSI.uSubOperation = SHADOW_RECREATE;

    iRet = DeviceIoControl(
                    hShadowDB
                    ,IOCTL_DO_SHADOW_MAINTENANCE
                    ,(LPVOID)(&sSI), 0
                    , NULL, 0
                    , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }

    return (iRet);



}

BOOL
SetDatabaseStatus(
    HANDLE  hShadowDB,
    ULONG   ulStatus,
    ULONG   uMask
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uStatus = ulStatus;
    sSI.uSubOperation = SHADOW_SET_DATABASE_STATUS;
    sSI.ulHintFlags = uMask;

    iRet = DeviceIoControl(
                    hShadowDB
                    ,IOCTL_DO_SHADOW_MAINTENANCE
                    ,(LPVOID)(&sSI), 0
                    , NULL, 0
                    , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }
    return (iRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\api.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    api.c

Abstract:

    reintegration functions

    Contents:

Author:
    Shishir Pardikar


Environment:

    Win32 (user-mode) DLL

Revision History:

    4/24/97 Created  shishirp

--*/

#include "pch.h"


#ifdef CSC_ON_NT
#include <winioctl.h>
#define UNICODE
#endif //CSC_ON_NT

#include "shdcom.h"
#include "shdsys.h"
#include "reint.h"
#include "utils.h"
#include "resource.h"
#include "strings.h"
// this sets flags in a couple of headers to not include some defs.
#define REINT
#include "lib3.h"
#include "cscapi.h"

//
// Defines/structures
//

#define SHADOW_FIND_SIGNATURE           0x61626162  // abab
#define FLAG_SHADOW_FIND_TERMINATED     0x00000001


typedef struct tagSHADOW_FIND
{
    DWORD   dwSignature;    // for validation
    DWORD   dwFlags;
    HANDLE  hShadowDB;
    ULONG   ulPrincipalID;
    CSC_ENUMCOOKIE  uEnumCookie;
}
SHADOW_FIND, *LPSHADOW_FIND;

typedef struct tagMST_LIST
{
    struct tagMST_LIST *lpNext;
    HSHADOW             hDir;
} MST_LIST, *LPMST_LIST;

typedef struct tagMOVE_SUBTREE
{
    DWORD       dwFlags;
    DWORD       cntFail;
    HSHARE     hShareTo;
    LPCTSTR     lptzSource;
    LPCTSTR     lptzDestination;
    LPMST_LIST  lpTos;
    MST_LIST    sTos;
    SHADOWINFO  sSI;
    WIN32_FIND_DATA sFind32;
} MOVE_SUBTREE, *LPMOVE_SUBTREE;

#define MST_REPLACE_IF_EXISTS   0x00000001
#define MST_SHARE_MARKED_DIRTY  0x00000002
#define MST_MARK_AS_LOCAL       0x00000004

typedef struct tagSET_SUBTREE_STATUS
{
    DWORD       dwFlags;
    ULONG       uStatus;
    ULONG       uOp;

} SET_SUBTREE_STATUS, *LPSET_SUBTREE_STATUS;



#define EDS_FLAG_ERROR_ENCOUNTERED   0x00000001

typedef struct tagENCRYPT_DECRYPT_SUBTREE
{
    DWORD       dwFlags;
    BOOL        fEncrypt;
    LPCSCPROCW  lpfnEnumProgress;
    DWORD_PTR   dwContext;
    DWORD       dwEndingNameSpaceVersion;
}ENCRYPT_DECRYPT_SUBTREE, *LPENCRYPT_DECRYPT_SUBTREE;

BOOL
CheckCSCAccessForThread(
    HSHADOW hDir,
    HSHADOW hShadow,
    BOOL    fWrite
    );

int
MoveSubtree(
    HANDLE          hShadowDB,
    LPSECURITYINFO  pShareSecurityInfo,
    LPTSTR          lptzFullPath,
    DWORD           dwCallbackReason,
    WIN32_FIND_DATA *lpFind32,
    SHADOWINFO      *lpSI,
    LPMOVE_SUBTREE  lpMst
    );

int
SetSubtreeStatus(
    HANDLE          hShadowDB,
    LPSECURITYINFO  pShareSecurityInfo,
    LPTSTR          lptzFullPath,
    DWORD           dwCallbackReason,
    WIN32_FIND_DATA *lpFind32,
    SHADOWINFO      *lpSI,
    LPSET_SUBTREE_STATUS  lpSss
    );

int
EncryptDecryptSubtree(
    HANDLE          hShadowDB,
    LPSECURITYINFO  pShareSecurityInfo,
    LPTSTR          lptzFullPath,
    DWORD           dwCallbackReason,
    WIN32_FIND_DATA *lpFind32,
    SHADOWINFO      *lpSI,
    LPENCRYPT_DECRYPT_SUBTREE  lpEds
    );

BOOL
UncPathToDfsPath(
    PWCHAR UncPath,
    PWCHAR DfsPath,
    ULONG cbLen);

BOOL
IsPersonal(VOID);

//
// local data
//
static TCHAR vszStarDotStar[] = _TEXT("*.*");
static TCHAR vszStar[] = _TEXT("*");

static TCHAR vszPrefix[] = _TEXT("CSC");
AssertData;
AssertError;


//
// functions
//

BOOL
WINAPI
CSCIsCSCEnabled(
    VOID
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    unsigned ulSwitch = SHADOW_SWITCH_SHADOWING;

    if(ShadowSwitches(INVALID_HANDLE_VALUE, &ulSwitch, SHADOW_SWITCH_GET_STATE))
    {
        return((ulSwitch & SHADOW_SWITCH_SHADOWING)!=0);
    }

    return FALSE;
}

BOOL
WINAPI
CSCGetSpaceUsageA(
    LPSTR  lptzLocation,
    DWORD   dwSize,
    LPDWORD lpdwMaxSpaceHigh,
    LPDWORD lpdwMaxSpaceLow,
    LPDWORD lpdwCurrentSpaceHigh,
    LPDWORD lpdwCurrentSpaceLow,
    LPDWORD lpcntTotalFiles,
    LPDWORD lpcntTotalDirs
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    SHADOWSTORE sST;
    WIN32_FIND_DATA sFind32;
    BOOL    fRet = FALSE;
    DWORD   dwLen;

    // NTRAID#455247-1/31/2000-shishirp parameter validation
    if (GetShadowDatabaseLocation(INVALID_HANDLE_VALUE, &sFind32))
    {
        memset(lptzLocation, 0, sizeof(dwSize));
        WideCharToMultiByte(CP_ACP, 0, sFind32.cFileName, wcslen(sFind32.cFileName), lptzLocation, dwSize, NULL, NULL);

        if (GetSpaceStats(INVALID_HANDLE_VALUE, &sST))
        {
            *lpdwMaxSpaceHigh = 0;
            *lpdwMaxSpaceLow = sST.sMax.ulSize;
            *lpdwCurrentSpaceHigh = 0;
            *lpdwCurrentSpaceLow = sST.sCur.ulSize;
            *lpcntTotalFiles = sST.sCur.ucntFiles;
            *lpcntTotalFiles = sST.sCur.ucntDirs;
            fRet = TRUE;
        }

    }
    return fRet;
#endif
}

BOOL
WINAPI
CSCGetSpaceUsageW(
    LPTSTR  lptzLocation,
    DWORD   dwSize,
    LPDWORD lpdwMaxSpaceHigh,
    LPDWORD lpdwMaxSpaceLow,
    LPDWORD lpdwCurrentSpaceHigh,
    LPDWORD lpdwCurrentSpaceLow,
    LPDWORD lpcntTotalFiles,
    LPDWORD lpcntTotalDirs
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    SHADOWSTORE sST;
    WIN32_FIND_DATA sFind32;
    BOOL    fRet = FALSE;

    // NTRAID#455247-1/31/2000-shishirp parameter validation
    if (GetShadowDatabaseLocation(INVALID_HANDLE_VALUE, &sFind32))
    {
        memset(lptzLocation, 0, dwSize);
        wcsncpy(lptzLocation, sFind32.cFileName, dwSize/sizeof(USHORT)-1);

        if (GetSpaceStats(INVALID_HANDLE_VALUE, &sST))
        {
            *lpdwMaxSpaceHigh = 0;
            *lpdwMaxSpaceLow = sST.sMax.ulSize;
            *lpdwCurrentSpaceHigh = 0;
            *lpdwCurrentSpaceLow = sST.sCur.ulSize;
            *lpcntTotalFiles = sST.sCur.ucntFiles;
            *lpcntTotalDirs = sST.sCur.ucntDirs;
            fRet = TRUE;
        }

    }
    return fRet;
#endif
}

BOOL
WINAPI
CSCSetMaxSpace(
    DWORD   nFileSizeHigh,
    DWORD   nFileSizeLow
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    int iRet;

    // 2GB is our limit
    if ((nFileSizeHigh)||(nFileSizeLow > 0x7fffffff))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    iRet = SetMaxShadowSpace(INVALID_HANDLE_VALUE, (long)nFileSizeHigh, (long)nFileSizeLow);

    if (iRet<0)
    {
        SetLastError(ERROR_INTERNAL_ERROR);
    }

    return (iRet >= 1);
}

BOOL
CSCPinFileInternal(
    LPCTSTR     lpszFileName,
    DWORD       dwHintFlags,
    LPDWORD     lpdwStatus,
    LPDWORD     lpdwPinCount,
    LPDWORD     lpdwHintFlags
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    WIN32_FIND_DATA sFind32;
    SHADOWINFO sSI;
    BOOL fCreated, fRet = FALSE;
    DWORD   dwError = ERROR_GEN_FAILURE;

    // NTRAID#455247-1/31/2000-shishirp parameter validation !!!!


    if (BeginInodeTransactionHSHADOW())
    {
        if(FindCreateShadowFromPath(lpszFileName, TRUE, &sFind32, &sSI, &fCreated))
        {
            sSI.ulHintFlags = dwHintFlags;

            fRet = (AddHintFromInode(    INVALID_HANDLE_VALUE,
                                        sSI.hDir,
                                        sSI.hShadow,
                                        &(sSI.ulHintPri),
                                        &(sSI.ulHintFlags)
                                        ) != 0);

            if (fRet)
            {
                if (lpdwStatus)
                {
                    *lpdwStatus = sSI.uStatus;
                }
                if (lpdwPinCount)
                {
                    *lpdwPinCount = sSI.ulHintPri;
                }
                if (lpdwHintFlags)
                {
                    *lpdwHintFlags = sSI.ulHintFlags;
                }

            }
            else
            {
                dwError = ERROR_INVALID_FUNCTION;
            }
        }
        else
        {
            dwError = GetLastError();
        }

        EndInodeTransactionHSHADOW();
    }
    if (!fRet)
    {
        Assert(dwError != ERROR_SUCCESS);
        SetLastError(dwError);
    }
    return fRet;
}


BOOL
CSCUnpinFileInternal(
    LPCTSTR lpszFileName,
    IN      DWORD   dwHintFlags,
    LPDWORD lpdwStatus,
    LPDWORD lpdwPinCount,
    LPDWORD lpdwHintFlags
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    WIN32_FIND_DATA sFind32;
    SHADOWINFO sSI;
    BOOL fRet = FALSE;
    DWORD   dwError = ERROR_GEN_FAILURE;

    // NTRAID#455247-1/31/2000-shishirp parameter validation !!!!


    if (BeginInodeTransactionHSHADOW())
    {
        if(FindCreateShadowFromPath(lpszFileName, FALSE, &sFind32, &sSI, NULL))
        {
            sSI.ulHintFlags = dwHintFlags;

            fRet = (DeleteHintFromInode(    INVALID_HANDLE_VALUE,
                                            sSI.hDir,
                                            sSI.hShadow,
                                            &(sSI.ulHintPri),
                                            &(sSI.ulHintFlags)
                                            ) != 0);

            if (fRet)
            {
                if (lpdwStatus)
                {
                    *lpdwStatus = sSI.uStatus;
                }
                if (lpdwPinCount)
                {
                    *lpdwPinCount = sSI.ulHintPri;
                }
                if (lpdwHintFlags)
                {
                    *lpdwHintFlags = sSI.ulHintFlags;
                }
            }
            else
            {
                dwError = ERROR_INVALID_FUNCTION;
            }
            
        }
        else
        {
            dwError = GetLastError();
        }

        EndInodeTransactionHSHADOW();

    }

    if (!fRet)
    {
        SetLastError(dwError);
    }

    return fRet;
}

BOOL
CSCQueryFileStatusInternal(
    LPCTSTR  lpszFileName,
    LPDWORD lpdwStatus,
    LPDWORD lpdwPinCount,
    LPDWORD lpdwHintFlags,
    LPDWORD lpdwUserPerms,
    LPDWORD lpdwOtherPerms
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{

    WIN32_FIND_DATA sFind32;
    SHADOWINFO sSI;

    // NTRAID#455247-1/31/2000-shishirp parameter validation !!!!


    if (FindCreateShadowFromPath(lpszFileName, FALSE, &sFind32, &sSI, NULL) != TRUE)
        return FALSE;

    if (lpdwStatus != NULL) {
        *lpdwStatus = sSI.uStatus;
        // return accessmask for files or the root
        if ((sSI.uStatus & SHADOW_IS_FILE)||(!sSI.hDir)) {
            if (sSI.hShadow) {
                ULONG ulPrincipalID;

                if (!GetCSCPrincipalID(&ulPrincipalID))
                    ulPrincipalID = CSC_GUEST_PRINCIPAL_ID;                            

                GetCSCAccessMaskForPrincipalEx(
                    ulPrincipalID,
                    sSI.hDir,
                    sSI.hShadow,
                    lpdwStatus,
                    lpdwUserPerms,
                    lpdwOtherPerms);

                Assert((*lpdwStatus & ~FLAG_CSC_ACCESS_MASK) == sSI.uStatus);

                if (lpdwUserPerms != NULL && lpdwOtherPerms != NULL) {

                    ULONG i;
                    ULONG GuestIdx = CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS;
                    ULONG UserIdx = CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS;
                    SECURITYINFO rgsSecurityInfo[CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS];
                    _TCHAR  tchBuff[MAX_SERVER_SHARE_NAME_FOR_CSC];
                    ULONG nRet = 0;
                    DWORD dwDummy;
                    WIN32_FIND_DATA sFind32;
                    SHADOWINFO sSI2;
                    BOOL fDone = FALSE;

                    // DbgPrint("CSCQueryFileStatusInternal(%ws)\n", lpszFileName);

                    if (lstrlen(lpszFileName) >= MAX_SERVER_SHARE_NAME_FOR_CSC)
                        goto AllDone;

                    lstrcpy(tchBuff, lpszFileName);

                    if (!LpBreakPath(tchBuff, TRUE, &fDone))
                        goto AllDone;

                    // DbgPrint("   tchBuff=%ws\n", tchBuff);

                    if (!FindCreateShadowFromPath(tchBuff, FALSE, &sFind32, &sSI2, NULL))
                        goto AllDone;

                    // DbgPrint("CSCQueryFileStatusInternal: hShare=0x%x,hShadow=0x%x,hDir=0x%x\n",
                    //                         sSI2.hShare,
                    //                         sSI2.hShadow,
                    //                         sSI2.hDir);

                    dwDummy = sizeof(rgsSecurityInfo);
                    nRet = GetSecurityInfoForCSC(
                               INVALID_HANDLE_VALUE,
                               0,
                               sSI2.hShadow,
                               rgsSecurityInfo,
                               &dwDummy);

                    // DbgPrint("     GetSecurityInfoForCSC returned %d\n", nRet);

                    if (nRet == 0)
                        goto AllDone;

                    //
                    // Find the user's and guest's entries
                    //
                    for (i = 0; i < CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS; i++) {
                        if (rgsSecurityInfo[i].ulPrincipalID == ulPrincipalID)
                            UserIdx = i;
                        if (rgsSecurityInfo[i].ulPrincipalID == CSC_GUEST_PRINCIPAL_ID)
                            GuestIdx = i;
                    }
                    if (GuestIdx < CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS) {
                        if (UserIdx >= CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS)
                            UserIdx = GuestIdx;

                        *lpdwUserPerms &= rgsSecurityInfo[UserIdx].ulPermissions;
                        *lpdwOtherPerms &= rgsSecurityInfo[GuestIdx].ulPermissions;

                        // DbgPrint("UserPerms=0x%x,OtherPerms=0x%x\n",
                        //                 *lpdwUserPerms,
                        //                 *lpdwOtherPerms);
                    }
                }
            }
        }
    }

AllDone:

    if (lpdwPinCount) {
        *lpdwPinCount = sSI.ulHintPri;
    }
    if (lpdwHintFlags) {
        *lpdwHintFlags = sSI.ulHintFlags;
    }
    return TRUE;
}


HANDLE
CSCFindFirstFileInternal(
    LPCTSTR             lpszFileName,
    ULONG               ulPrincipalID,
    WIN32_FIND_DATA     *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    SHADOWINFO sSI;
    BOOL fRet = FALSE;
    LPSHADOW_FIND   lpShadowFind = NULL;

    // NTRAID#455247-1/31/2000-shishirp parameter validation !!!!


    if (lpszFileName && *lpszFileName)
    {
        fRet = FindCreateShadowFromPath(
                        lpszFileName,   // UNC path
                        FALSE,          // don't create
                        lpFind32,
                        &sSI,
                        NULL);

        if (fRet && !sSI.hShadow)
        {
            // a situation where, the share is connected but it's entry is
            // not in the database
            fRet = FALSE;
        }

    }
    else
    {
        memset(&sSI, 0, sizeof(sSI));   // sSI.hShadow is 0 => we are enumerating all shares
        lpFind32->dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
        fRet = TRUE;
    }

    if (fRet)
    {
        fRet = FALSE;

        // Found the shadow
        if (lpShadowFind = AllocMem(sizeof(SHADOW_FIND)))
        {
            lpShadowFind->dwSignature = SHADOW_FIND_SIGNATURE;
            lpShadowFind->hShadowDB = INVALID_HANDLE_VALUE;

            if (ulPrincipalID != CSC_INVALID_PRINCIPAL_ID)
            {
                lpShadowFind->ulPrincipalID = ulPrincipalID;
            }
            else
            {
                if (!GetCSCPrincipalID(&lpShadowFind->ulPrincipalID))
                {
                    lpShadowFind->ulPrincipalID = CSC_GUEST_PRINCIPAL_ID;                            
                }
            }

            if (!(lpFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                lpShadowFind->dwFlags |= FLAG_SHADOW_FIND_TERMINATED;
                fRet = TRUE;
            }
            else
            {
//              lpShadowFind->hShadowDB = OpenShadowDatabaseIO();

//              if (lpShadowFind->hShadowDB != INVALID_HANDLE_VALUE)
                {
#ifndef CSC_ON_NT
                    lstrcpy(lpFind32->cFileName, vszStarDotStar);
#else
                    lstrcpy(lpFind32->cFileName, vszStar);
#endif

                    if(FindOpenShadow(
                                    lpShadowFind->hShadowDB,
                                    sSI.hShadow,
                                    FINDOPEN_SHADOWINFO_ALL,
                                    lpFind32,
                                    &sSI
                                    ))
                    {
                        lpShadowFind->uEnumCookie = sSI.uEnumCookie;

                        fRet = TRUE;
                    }
                }
            }
        }
    }

    if (!fRet)
    {
        if (lpShadowFind)
        {
            if (lpShadowFind->hShadowDB != INVALID_HANDLE_VALUE)
            {
                CloseShadowDatabaseIO(lpShadowFind->hShadowDB);
            }

            FreeMem(lpShadowFind);
    
        }

        EndInodeTransactionHSHADOW();

        return (INVALID_HANDLE_VALUE);
    }
    else
    {

        if (lpdwStatus)
        {
            *lpdwStatus = (DWORD)(sSI.uStatus);

            // return accessmask for files or the root
            if ((sSI.uStatus & SHADOW_IS_FILE)||(!sSI.hDir))
            {
                GetCSCAccessMaskForPrincipal(lpShadowFind->ulPrincipalID, sSI.hDir, sSI.hShadow, lpdwStatus);
                Assert((*lpdwStatus & ~FLAG_CSC_ACCESS_MASK) == sSI.uStatus);
            }

        }
        if (lpdwPinCount)
        {
            *lpdwPinCount = (DWORD)(sSI.ulHintPri);
        }
        if (lpdwHintFlags)
        {
            *lpdwHintFlags = sSI.ulHintFlags;
        }
        if (lpOrgFileTime)
        {
            *lpOrgFileTime = lpFind32->ftLastAccessTime;
        }

        return ((HANDLE)lpShadowFind);
    }
}


BOOL
CSCFindNextFileInternal(
    HANDLE  hFind,
    WIN32_FIND_DATA     *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    LPSHADOW_FIND lpShadowFind = (LPSHADOW_FIND)hFind;
    BOOL fRet = FALSE;
    SHADOWINFO sSI;

    // validate parameters !!!!

    if (lpShadowFind->dwFlags & FLAG_SHADOW_FIND_TERMINATED)
    {
        SetLastError(ERROR_NO_MORE_FILES);
        return FALSE;
    }
    else
    {
        if (!FindNextShadow(    lpShadowFind->hShadowDB,
                            lpShadowFind->uEnumCookie,
                            lpFind32,
                            &sSI
                            ))
        {
            lpShadowFind->dwFlags |= FLAG_SHADOW_FIND_TERMINATED;
            SetLastError(ERROR_NO_MORE_FILES);          
        }
        else
        {
            if (lpdwStatus)
            {
                *lpdwStatus = (DWORD)(sSI.uStatus);

                // return accessmask for files or the root
                if ((sSI.uStatus & SHADOW_IS_FILE)||(!sSI.hDir))
                {
                    GetCSCAccessMaskForPrincipal(lpShadowFind->ulPrincipalID, sSI.hDir, sSI.hShadow, lpdwStatus);                            
                    Assert((*lpdwStatus & ~FLAG_CSC_ACCESS_MASK) == sSI.uStatus);
                }
            }
            if (lpdwPinCount)
            {
                *lpdwPinCount = (DWORD)(sSI.ulHintPri);
            }
            if (lpdwHintFlags)
            {
                *lpdwHintFlags = sSI.ulHintFlags;
            }

            if (lpOrgFileTime)
            {
                *lpOrgFileTime = lpFind32->ftLastAccessTime;
            }
            fRet = TRUE;
        }
    }
    return (fRet);
}

BOOL
WINAPI
CSCFindClose(
    HANDLE  hFind
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    LPSHADOW_FIND lpShadowFind = (LPSHADOW_FIND)hFind;

    if (lpShadowFind->uEnumCookie)
    {
        // don't check any errors
        FindCloseShadow(lpShadowFind->hShadowDB, lpShadowFind->uEnumCookie);
    }

    if (lpShadowFind->hShadowDB != INVALID_HANDLE_VALUE)
    {
        CloseShadowDatabaseIO(lpShadowFind->hShadowDB);
    }

    FreeMem(lpShadowFind);

    return (TRUE);
}


BOOL
CSCDeleteInternal(
    LPCTSTR lpszName
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    WIN32_FIND_DATA sFind32;
    SHADOWINFO sSI;
    BOOL fRet = FALSE;
    DWORD   dwError = ERROR_GEN_FAILURE;
    DWORD dwStatus = 0;
    BOOL DoDelete = FALSE;

    // NTRAID#455247 -1/31/2000-shishirp parameter validation !!!!

    ReintKdPrint(API, ("Delete %ls\r\n", lpszName));

    if(CSCQueryFileStatus(lpszName, &dwStatus, NULL, NULL))
    {
        // Shouls check if the user has the permission to delete this file - Bug 524237
        if(!(FLAG_CSC_COPY_STATUS_IS_FILE & dwStatus) || //is directory or
           (((dwStatus & FLAG_CSC_GUEST_ACCESS_MASK) & // the guest has write permission
                        FLAG_CSC_WRITE_ACCESS << FLAG_CSC_GUEST_ACCESS_SHIFT_COUNT) ||
           ((dwStatus & FLAG_CSC_USER_ACCESS_MASK) & // or the user has write permission
                        FLAG_CSC_WRITE_ACCESS << FLAG_CSC_USER_ACCESS_SHIFT_COUNT)))
        {
            if (BeginInodeTransactionHSHADOW())
            {
        
                if(FindCreateShadowFromPath(lpszName, FALSE, &sFind32, &sSI, NULL))
                {
        
                    ReintKdPrint(API, ("Delete Inode %x %x\r\n", sSI.hDir, sSI.hShadow));
        
                    if (DeleteShadow(INVALID_HANDLE_VALUE, sSI.hDir, sSI.hShadow))
                    {
                         fRet = TRUE;
                    }
                    else
                    {
                         dwError = ERROR_ACCESS_DENIED;
                    }
                    
                }
                else
                {
                    dwError = GetLastError();
                }
        
                EndInodeTransactionHSHADOW();
            }

        }
        else
        {
            dwError = ERROR_ACCESS_DENIED;
        }

    }

    

    if (!fRet)
    {
        SetLastError(dwError);
    }

    return fRet;
}


BOOL
CSCFillSparseFilesInternal(
    IN  LPCTSTR     lpszShareOrFileName,
    IN  BOOL        fFullSync,
    IN  LPCSCPROC   lpfnFillProgress,
    IN  DWORD_PTR   dwContext
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    WIN32_FIND_DATA sFind32;
    SHADOWINFO sSI;
    DWORD   dwError = ERROR_INVALID_PARAMETER, dwRet;
    LPCOPYPARAMS lpCP = NULL;
    ULONG   ulPrincipalID;

    if (!GetCSCPrincipalID(&ulPrincipalID))
    {
        ulPrincipalID = CSC_GUEST_PRINCIPAL_ID;                            
    }
    if(FindCreateShadowFromPath(lpszShareOrFileName, FALSE, &sFind32, &sSI, NULL))
    {
        if (!sSI.hDir)
        {
            dwError = NO_ERROR;

            // if this is a share
            dwRet = (*lpfnFillProgress)(
                                    lpszShareOrFileName,
                                    sSI.uStatus,
                                    sSI.ulHintFlags,
                                    sSI.ulHintPri,
                                    &sFind32,
                                    CSCPROC_REASON_BEGIN,
                                    0,
                                    0,
                                    dwContext
                                    );
            if (dwRet == CSCPROC_RETURN_CONTINUE)
            {
                AttemptCacheFill(sSI.hShare, DO_ALL, fFullSync, ulPrincipalID, lpfnFillProgress, dwContext);
            }
            else
            {
                if (dwRet == CSCPROC_RETURN_ABORT)
                {
                    dwError = ERROR_OPERATION_ABORTED;
                }
            }

            (*lpfnFillProgress)(
                                lpszShareOrFileName,
                                sSI.uStatus,
                                sSI.ulHintFlags,
                                sSI.ulHintPri,
                                &sFind32,
                                CSCPROC_REASON_END,
                                0,
                                0,
                                dwContext
                                );
        }
        else if (!(sFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            BOOL    fStalenessCheck;
            dwError = NO_ERROR;

            fStalenessCheck = (fFullSync || (sSI.uStatus & SHADOW_STALE));

            if (fStalenessCheck)
            {
                if (!(lpCP = LpAllocCopyParams()))
                {
                    dwError = GetLastError();
                    Assert(dwError != NO_ERROR);

                }
                else if(!GetUNCPath(INVALID_HANDLE_VALUE, sSI.hShare, sSI.hDir, sSI.hShadow, lpCP))
                {
                    Assert(lpCP);
                    FreeCopyParams(lpCP);
                    dwError = GetLastError();
                    Assert(dwError != NO_ERROR);
                }
            }

            if ((dwError == NO_ERROR) &&
                (fStalenessCheck || (sSI.uStatus & SHADOW_SPARSE))) {

                dwError = DoSparseFill( INVALID_HANDLE_VALUE,
                                        (LPTSTR)lpszShareOrFileName,
                                        NULL,
                                        &sSI,
                                        &sFind32,
                                        lpCP,
                                        fStalenessCheck,
                                        ulPrincipalID,
                                        lpfnFillProgress,
                                        dwContext);
            }

            if (lpCP)
            {
                FreeCopyParams(lpCP);
                lpCP = NULL;
            }
        }
    }
    else
    {
        dwError = GetLastError();
    }

    if (dwError != NO_ERROR)
    {
        SetLastError(dwError);
        return FALSE;
    }

    return TRUE;

}



BOOL
CSCMergeShareInternal(
    IN  LPCTSTR     lpszShareName,
    IN  LPCSCPROC   lpfnMergeProgress,
    IN  DWORD_PTR   dwContext
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{

    WIN32_FIND_DATA sFind32;
    SHADOWINFO sSI;
    int cntDriveMapped = 0;
    BOOL    fTransitionedToOnline = FALSE, fDone=FALSE;
    _TCHAR  tchBuff[MAX_SERVER_SHARE_NAME_FOR_CSC];
    DWORD   dwError = ERROR_SUCCESS;
    ULONG   ulPrincipalID;

    if (!GetCSCPrincipalID(&ulPrincipalID))
    {
        ulPrincipalID = CSC_GUEST_PRINCIPAL_ID;                            
    }

    if (lstrlen(lpszShareName) >= MAX_SERVER_SHARE_NAME_FOR_CSC)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    lstrcpy(tchBuff, lpszShareName);

    if (!LpBreakPath(tchBuff, TRUE, &fDone) && !fDone)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if(FindCreateShadowFromPath(tchBuff, FALSE, &sFind32, &sSI, NULL))
    {

        fDone = ReintOneShare(sSI.hShare, sSI.hShadow, NULL, NULL, NULL, ulPrincipalID, lpfnMergeProgress, dwContext);

        if (!fDone)
        {
            dwError = GetLastError();
        }

//        TransitionShareToOnline(INVALID_HANDLE_VALUE, sSI.hShare);

        if (!fDone)
        {
            SetLastError(dwError);
        }

        return fDone;
    }

    return FALSE;

}


BOOL
CSCCopyReplicaInternal(
    IN  LPCTSTR lpszFullPath,
    OUT LPTSTR  *lplpszLocalName
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{

    WIN32_FIND_DATA sFind32;
    SHADOWINFO sSI;
    BOOL fRet = FALSE;
    DWORD   dwError = ERROR_GEN_FAILURE;

    if (BeginInodeTransactionHSHADOW())
    {
        if(FindCreateShadowFromPath(lpszFullPath, FALSE, &sFind32, &sSI, NULL))
        {
            if (sFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                dwError = ERROR_INVALID_PARAMETER;
                goto bailout;
            }

            if (!CheckCSCAccessForThread(sSI.hDir, sSI.hShadow, FALSE))
            {
                dwError = GetLastError();
                goto bailout;
            }

            if (!(*lplpszLocalName = GetTempFileForCSC(NULL)))
            {
                goto bailout;
            }

            if(!CopyShadow(INVALID_HANDLE_VALUE, sSI.hDir, sSI.hShadow, *lplpszLocalName))
            {
                LocalFree(*lplpszLocalName);
                *lplpszLocalName = NULL;
                goto bailout;
            }

            fRet = TRUE;
        }
        else
        {
            dwError = GetLastError();
        }

        EndInodeTransactionHSHADOW();
    }
bailout:
    if (!fRet)
    {
        SetLastError(dwError);
    }
    return fRet;
}

BOOL
CSCEnumForStatsInternal(
    IN  LPCTSTR     lpszShareName,
    IN  LPCSCPROC   lpfnEnumProgress,
    IN  BOOL        fPeruserInfo,
    IN  BOOL        fUpdateShareReintBit,
    IN  DWORD_PTR   dwContext
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    WIN32_FIND_DATA sFind32;
    SHADOWINFO sSI;
    BOOL    fRet = TRUE;
    PQPARAMS sPQP;
    HANDLE hShadowDB = INVALID_HANDLE_VALUE;
    DWORD   dwRet;
    ULONG ulPrincipalID = CSC_INVALID_PRINCIPAL_ID;

    if (lpszShareName)
    {

        if(!FindCreateShadowFromPath(lpszShareName, FALSE, &sFind32, &sSI, NULL))
        {
            fRet = FALSE;
        }
    }
    else
    {
        sSI.hShare = 0;
    }
    if (fRet)
    {
        fRet = FALSE;

        if ((hShadowDB = OpenShadowDatabaseIO())==INVALID_HANDLE_VALUE)
        {
            goto bailout;
        }

        if (lpfnEnumProgress)
        {
            dwRet = (*lpfnEnumProgress)(NULL, 0, 0, 0, NULL, CSCPROC_REASON_BEGIN, 0, 0, dwContext);

            if (dwRet != CSCPROC_RETURN_CONTINUE )
            {
                goto bailout;
            }
        }

        if (fPeruserInfo)
        {

            if (!GetCSCPrincipalID(&ulPrincipalID))
            {
                ulPrincipalID = CSC_GUEST_PRINCIPAL_ID;                            
            }
        }

        memset(&sPQP, 0, sizeof(sPQP));

        if(BeginPQEnum(hShadowDB, &sPQP) == 0) {
            goto bailout;
        }

        do {

            if(NextPriShadow(hShadowDB, &sPQP) == 0) {
                break;
            }

            if (!sPQP.hShadow) {
                break;
            }

            if (!sSI.hShare || (sSI.hShare == sPQP.hShare))
            {
                if (fPeruserInfo)
                {

                    // return accessmask for files or the root
                    if ((sPQP.ulStatus & SHADOW_IS_FILE)||(!sPQP.hDir))
                    {
                        GetCSCAccessMaskForPrincipal(ulPrincipalID, sPQP.hDir, sPQP.hShadow, &sPQP.ulStatus);
                    }
                }
                
                if (lpfnEnumProgress)
                {
                    // if we are enumerating for a particular share
                    // besides status, report whether file or directory and whether a root or a non-root
                    dwRet = (*lpfnEnumProgress)(NULL, sPQP.ulStatus & ~SHADOW_IS_FILE, sPQP.ulHintFlags, sPQP.ulHintPri, NULL, CSCPROC_REASON_MORE_DATA, (mShadowIsFile(sPQP.ulStatus) != 0), (sPQP.hDir==0), dwContext);
                
                    if (dwRet != CSCPROC_RETURN_CONTINUE )
                    {
                        break;
                    }
                }

                // if we are enumerating for a particular share
                // then make sure that the share dirty bit matches with what we got on the
                // actual files
                if (fUpdateShareReintBit && sSI.hShare && (sSI.hShare == sPQP.hShare))
                {
                    if (mShadowNeedReint(sPQP.ulStatus) && !(sSI.uStatus & SHARE_REINT))
                    {
                        if(SetShareStatus(hShadowDB, sSI.hShare, SHARE_REINT, SHADOW_FLAGS_OR))
                        {
                            sSI.uStatus |= SHARE_REINT;
                        }
                    }
                }
            }


        } while (sPQP.uPos);

        // Close the enumeration
        EndPQEnum(hShadowDB, &sPQP);

        if (lpfnEnumProgress)
        {
            dwRet = (*lpfnEnumProgress)(NULL, 0, 0, 0, NULL, CSCPROC_REASON_END, 0, 0, dwContext);
        }

        fRet = TRUE;
    }

bailout:

    if (hShadowDB != INVALID_HANDLE_VALUE)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    return fRet;
}


BOOL
WINAPI
CSCPinFileA(
    IN  LPCSTR  lpszFileName,
    IN  DWORD   dwHintFlags,
    IN  LPDWORD lpdwStatus,
    IN  LPDWORD lpdwPinCount,
    IN  LPDWORD lpdwHintFlags
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return (CSCPinFileInternal(lpszFileName, dwHintFlags, lpdwStatus, lpdwPinCount, lpdwHintFlags));
#endif
}

BOOL
WINAPI
CSCUnpinFileA(
    IN  LPCSTR  lpszFileName,
    IN  DWORD   dwHintFlags,
    IN  LPDWORD lpdwStatus,
    IN  LPDWORD lpdwPinCount,
    IN  LPDWORD lpdwHintFlags
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return (CSCUnpinFileInternal(lpszFileName, dwHintFlags, lpdwStatus, lpdwPinCount, lpdwHintFlags));
#endif
}

BOOL
WINAPI
CSCQueryFileStatusA(
    LPCSTR              lpszFileName,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return (CSCQueryFileStatusInternal(
                        lpszFileName,
                        lpdwStatus,
                        lpdwPinCount,
                        lpdwHintFlags,
                        NULL,
                        NULL));
#endif
}

BOOL
WINAPI
CSCQueryFileStatusExA(
    LPCSTR              lpszFileName,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    LPDWORD             lpdwUserPerms,
    LPDWORD             lpdwOtherPerms
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return (CSCQueryFileStatusInternal(
                        lpszFileName,
                        lpdwStatus,
                        lpdwPinCount,
                        lpdwHintFlags,
                        lpdwUserPerms,
                        llpdwOtherPerms));
#endif
}

BOOL
WINAPI
CSCQueryShareStatusA(
    LPCSTR              lpszFileName,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    LPDWORD             lpdwUserPerms,
    LPDWORD             lpdwOtherPerms)
{
#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return (CSCQueryFileStatusInternal(
                        lpszFileName,
                        lpdwStatus,
                        lpdwPinCount,
                        lpdwHintFlags,
                        lpdwUserPerms,
                        llpdwOtherPerms));
#endif
}

HANDLE
WINAPI
CSCFindFirstFileA(
    LPCSTR              lpszFileName,
    WIN32_FIND_DATA     *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return (CSCFindFirstFileInternal(
                        lpszFileName,
                        CSC_INVALID_PRINCIPAL_ID,
                        lpFind32,
                        lpdwStatus,
                        lpdwPinCount,
                        lpdwHintFlags,
                        lpOrgFileTime
                        ));
#endif

}

HANDLE
WINAPI
CSCFindFirstFileForSidA(
    LPCSTR              lpszFileName,
    PSID                pSid,
    WIN32_FIND_DATA     *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

BOOL
WINAPI
CSCFindNextFileA(
    HANDLE  hFind,
    WIN32_FIND_DATA     *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return(CSCFindNextFileInternal(
            hFind,
            lpFind32,
            lpdwStatus,
            lpdwPinCount,
            lpdwHintFlags,
            lpOrgFileTime
            ));
#endif
}


BOOL
WINAPI
CSCDeleteA(
    LPCSTR  lpszFileName
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else

    return (CSCDeleteInternal(lpszFileName));

#endif

}

BOOL
WINAPI
CSCFillSparseFilesA(
    IN  LPCSTR      lpszShareName,
    IN  BOOL        fFullSync,
    IN  LPCSCPROCA  lpfnFillProgress,
    IN  DWORD_PTR   dwContext
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return (CSCFillSparseFilesInternal(
                    lpszShareName,
                    fFullSync,
                    lpfnFillProgress,
                    dwContext));

#endif
}



BOOL
WINAPI
CSCMergeShareA(
    IN  LPCSTR      lpszShareName,
    IN  LPCSCPROCA  lpfnMergeProgress,
    IN  DWORD_PTR   dwContext
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return(CSCMergeShareInternal(
                lpszShareName,
                lpfnMergeProgress,
                dwContext));
#endif
}


BOOL
WINAPI
CSCCopyReplicaA(
    IN  LPCSTR  lpszFullPath,
    OUT LPSTR   *lplpszLocalName
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return(CSCCopyReplicaInternal(
                lpszFullPath,
                lplpszLocalName));
#endif
}


BOOL
WINAPI
CSCEnumForStatsA(
    IN  LPCSTR      lpszShareName,
    IN  LPCSCPROCA  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{

#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return(CSCEnumForStatsInternal(
                lpszShareName,
                lpfnEnumProgress,
                FALSE,
                FALSE,
                dwContext));
#endif
}
BOOL
WINAPI
CSCPinFileW(
    IN  LPCWSTR lpszFileName,
    IN  DWORD   dwHintFlags,
    IN  LPDWORD lpdwStatus,
    IN  LPDWORD lpdwPinCount,
    IN  LPDWORD lpdwHintFlags
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return (CSCPinFileInternal(lpszFileName, dwHintFlags, lpdwStatus, lpdwPinCount, lpdwHintFlags));
#endif
}

BOOL
WINAPI
CSCUnpinFileW(
    IN  LPCWSTR lpszFileName,
    IN  DWORD   dwHintFlags,
    IN  LPDWORD lpdwStatus,
    IN  LPDWORD lpdwPinCount,
    IN  LPDWORD lpdwHintFlags
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return (CSCUnpinFileInternal(lpszFileName, dwHintFlags, lpdwStatus, lpdwPinCount, lpdwHintFlags));
#endif
}

BOOL
WINAPI
CSCQueryFileStatusW(
    LPCWSTR             lpszFileName,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return (CSCQueryFileStatusInternal(
                        lpszFileName,
                        lpdwStatus,
                        lpdwPinCount,
                        lpdwHintFlags,
                        NULL,
                        NULL));
#endif
}

BOOL
WINAPI
CSCQueryFileStatusExW(
    LPCWSTR             lpszFileName,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    LPDWORD             lpdwUserPerms,
    LPDWORD             lpdwOtherPerms
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return (CSCQueryFileStatusInternal(
                        lpszFileName,
                        lpdwStatus,
                        lpdwPinCount,
                        lpdwHintFlags,
                        lpdwUserPerms,
                        lpdwOtherPerms));
#endif
}

BOOL
WINAPI
CSCQueryShareStatusW(
    LPCWSTR             lpszFileName,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    LPDWORD             lpdwUserPerms,
    LPDWORD             lpdwOtherPerms)
{
    BOOL fStatus = FALSE;
    BOOL fDfsStatus = FALSE;
    DWORD dwDfsStatus;
    WCHAR lpszOrgPath[MAX_PATH];
    WCHAR lpszDfsPath[MAX_PATH];
    PWCHAR wCp;
    ULONG sCount;

#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else

    // DbgPrint("CSCQueryShareStatusW(%ws)\n", lpszFileName);

    //
    // Save a copy of the original path passed in
    // 
    wcscpy(lpszOrgPath, lpszFileName);

    // Now truncate to just \\server\share
    for (sCount = 0, wCp = lpszOrgPath; *wCp !=L'\0'; wCp++) {
        if (*wCp == L'\\') {
            if (++sCount == 4) {
                *wCp = L'\0';
                break;
            }
        }
    }

    // DbgPrint("   OrgPath=%ws\n", lpszOrgPath);
    fStatus = CSCQueryFileStatusInternal(
                    lpszOrgPath,
                    lpdwStatus,
                    lpdwPinCount,
                    lpdwHintFlags,
                    lpdwUserPerms,
                    lpdwOtherPerms);

    //
    // If we found info, check if DFS, and (if so)
    // adjust Status
    //
    if (fStatus == TRUE) {
        DWORD Junk;

        lpszDfsPath[0] = L'\0';
        fDfsStatus = UncPathToDfsPath(
                        (PWCHAR)lpszFileName,
                        lpszDfsPath,
                        sizeof(lpszDfsPath));

        if (fDfsStatus != TRUE)
            goto AllDone;

        // DbgPrint("DfsPath(1)=%ws\n", lpszDfsPath);

        // turn into just \\server\share
        for (sCount = 0, wCp = lpszDfsPath; *wCp !=L'\0'; wCp++) {
            if (*wCp == L'\\') {
                if (++sCount == 4) {
                    *wCp = L'\0';
                    break;
                }
            }
        }
        // DbgPrint("DfsPath(2)=%ws\n", lpszDfsPath);
        fDfsStatus = CSCQueryFileStatusInternal(
                        lpszDfsPath,
                        &dwDfsStatus,
                        &Junk,
                        &Junk,
                        &Junk,
                        &Junk);
        if (
            fDfsStatus == TRUE
                &&
            (dwDfsStatus & FLAG_CSC_SHARE_STATUS_CACHING_MASK) == FLAG_CSC_SHARE_STATUS_NO_CACHING
        ) {
            *lpdwStatus &= ~FLAG_CSC_SHARE_STATUS_CACHING_MASK;
            *lpdwStatus |= FLAG_CSC_SHARE_STATUS_NO_CACHING;
            // DbgPrint("New Status=0x%x\n", dwDfsStatus);
        }
    }
AllDone:
    return fStatus;
#endif
}

HANDLE
WINAPI
CSCFindFirstFileW(
    LPCWSTR             lpszFileName,
    WIN32_FIND_DATAW    *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (INVALID_HANDLE_VALUE);
#else
    return (CSCFindFirstFileInternal(
                        lpszFileName,
                        CSC_INVALID_PRINCIPAL_ID,
                        lpFind32,
                        lpdwStatus,
                        lpdwPinCount,
                        lpdwHintFlags,
                        lpOrgFileTime
                        ));
#endif

}

HANDLE
WINAPI
CSCFindFirstFileForSidW(
    LPCWSTR             lpszFileName,
    PSID                pSid,
    WIN32_FIND_DATAW    *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    ULONG   ulPrincipalID;

#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (INVALID_HANDLE_VALUE);
#else
    if (pSid)
    {
        if(!FindCreatePrincipalIDFromSID(INVALID_HANDLE_VALUE, pSid, GetLengthSid(pSid), &ulPrincipalID, FALSE))
        {
            return INVALID_HANDLE_VALUE;
        }
    }
    else
    {
        ulPrincipalID = CSC_INVALID_PRINCIPAL_ID;
    }

    return (CSCFindFirstFileInternal(
                        lpszFileName,
                        ulPrincipalID,
                        lpFind32,
                        lpdwStatus,
                        lpdwPinCount,
                        lpdwHintFlags,
                        lpOrgFileTime
                        ));
#endif

}

BOOL
WINAPI
CSCFindNextFileW(
    HANDLE  hFind,
    WIN32_FIND_DATAW    *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return(CSCFindNextFileInternal(
            hFind,
            lpFind32,
            lpdwStatus,
            lpdwPinCount,
            lpdwHintFlags,
            lpOrgFileTime
            ));
#endif
}


BOOL
WINAPI
CSCDeleteW(
    LPCWSTR lpszFileName
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else

    return (CSCDeleteInternal(lpszFileName));

#endif

}

BOOL
WINAPI
CSCFillSparseFilesW(
    IN  LPCWSTR     lpszShareName,
    IN  BOOL        fFullSync,
    IN  LPCSCPROCW  lpfnFillProgress,
    IN  DWORD_PTR   dwContext
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return (CSCFillSparseFilesInternal(
                    lpszShareName,
                    fFullSync,
                    lpfnFillProgress,
                    dwContext));

#endif
}



BOOL
WINAPI
CSCMergeShareW(
    IN  LPCWSTR     lpszShareName,
    IN  LPCSCPROCW  lpfnMergeProgress,
    IN  DWORD_PTR   dwContext
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return(CSCMergeShareInternal(
                lpszShareName,
                lpfnMergeProgress,
                dwContext));
#endif
}


BOOL
WINAPI
CSCCopyReplicaW(
    IN  LPCWSTR lpszFullPath,
    OUT LPWSTR  *lplpszLocalName
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return(CSCCopyReplicaInternal(
                lpszFullPath,
                lplpszLocalName));
#endif
}

BOOL
WINAPI
CSCEnumForStatsW(
    IN  LPCWSTR     lpszShareName,
    IN  LPCSCPROCW  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return(CSCEnumForStatsInternal(
                lpszShareName,
                lpfnEnumProgress,
                FALSE,
                FALSE,
                dwContext));
#endif
}

BOOL
WINAPI
CSCEnumForStatsExA(
    IN  LPCSTR     lpszShareName,
    IN  LPCSCPROCA  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

BOOL
WINAPI
CSCEnumForStatsExW(
    IN  LPCWSTR     lpszShareName,
    IN  LPCSCPROCW  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return(CSCEnumForStatsInternal(
                lpszShareName,
                lpfnEnumProgress,
                TRUE,
                FALSE,
                dwContext));
#endif
}

BOOL
WINAPI
CSCFreeSpace(
    DWORD   nFileSizeHigh,
    DWORD   nFileSizeLow
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    SHADOWSTORE sSTLast, sST;
    BOOL fRet = FALSE;

    if(!GetSpaceStats(INVALID_HANDLE_VALUE, &sSTLast))
    {
        return FALSE;
    }

    do
    {
        if (!FreeShadowSpace(INVALID_HANDLE_VALUE, nFileSizeHigh, nFileSizeLow, FALSE))
        {
            break;
        }

        if(!GetSpaceStats(INVALID_HANDLE_VALUE, &sST))
        {
            break;
        }

        // check if we are making any progress over successive
        // free space calls. If the current space used is greater than
        // after we last called, just quit.

        if (sST.sCur.ulSize >= sSTLast.sCur.ulSize)
        {
            fRet = TRUE;
            break;
        }

        sSTLast = sST;

    }
    while (TRUE);

    return fRet;
}


BOOL
WINAPI
CSCIsServerOfflineW(
    LPCWSTR  lptzServerName,
    BOOL    *lpfOffline
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return(IsServerOfflineW(INVALID_HANDLE_VALUE, lptzServerName, lpfOffline));
}

BOOL
WINAPI
CSCIsServerOfflineA(
    LPCSTR  lptzServerName,
    BOOL    *lpfOffline
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return(IsServerOfflineA(INVALID_HANDLE_VALUE, lptzServerName, lpfOffline));
}

BOOL
WINAPI
CSCTransitionServerOnlineW(
    IN  LPCWSTR     lpszShareName
    )
/*++

Routine Description:

    This routine transitions the server for the given share to online.

Arguments:

    lpszShareName

Returns:


Notes:

--*/
{

    WIN32_FIND_DATA sFind32;
    SHADOWINFO sSI;
    BOOL    fTransitionedToOnline = FALSE, fDone=FALSE;
    _TCHAR  tchBuff[MAX_SERVER_SHARE_NAME_FOR_CSC], tzDrive[4];
    DWORD   i;

    if (lstrlen(lpszShareName) >= MAX_SERVER_SHARE_NAME_FOR_CSC)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    lstrcpy(tchBuff, lpszShareName);

    if (!LpBreakPath(tchBuff, TRUE, &fDone) && !fDone)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    tzDrive[0] = 0;

    if(FindCreateShadowFromPath(tchBuff, FALSE, &sFind32, &sSI, NULL))
    {
        LPCONNECTINFO   lpHead = NULL;
        BOOL    fServerIsOffline = FALSE;

        fServerIsOffline = ((sSI.uStatus & SHARE_DISCONNECTED_OP) != 0);


        if(FGetConnectionListEx(&lpHead, tchBuff, TRUE, fServerIsOffline, NULL))
        {
            // take an extra reference, just in case there are some credentials on the server entry
            // with the redir
            // if it fails, don't stop going online
            // the worst that could happen is that the user might get an extra popup 
            // for the explicit credential case
            DWORD dwError;

            dwError = DWConnectNet(tchBuff, tzDrive, NULL, NULL, NULL, 0, NULL);
            if ((dwError != WN_SUCCESS) && (dwError != WN_CONNECTED_OTHER_PASSWORD_DEFAULT))
            {
                tzDrive[0] = 0;
            }

            DisconnectList(&lpHead, NULL, 0);
        }

        fTransitionedToOnline = TransitionShareToOnline(INVALID_HANDLE_VALUE, sSI.hShare);

        for (i=2;i<MAX_SERVER_SHARE_NAME_FOR_CSC;++i)
        {
            if (tchBuff[i] == '\\')
            {
                break;                
            }
        }

        Assert(i< MAX_SERVER_SHARE_NAME_FOR_CSC);

        // going online
        ReportTransitionToDfs(tchBuff, FALSE, i*sizeof(_TCHAR));

        if (lpHead)
        {
            ReconnectList(&lpHead, NULL);
            ClearConnectionList(&lpHead);

        }

        // if there was an extra reference,
        // remove it
        if (tzDrive[0])
        {
            DWDisconnectDriveMappedNet(tzDrive, TRUE);
        }
    }

    return(fTransitionedToOnline);
}

BOOL
WINAPI
CSCTransitionServerOnlineA(
    IN  LPCSTR     lpszShareName
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

BOOL
WINAPI
CSCCheckShareOnlineExW(
    IN  LPCWSTR     lpszShareName,
    LPDWORD         lpdwSpeed
    )
/*++

Routine Description:

    This routine checks whether a given share is available online.

Arguments:

    lpszShareName

Returns:


Notes:

--*/
{

    _TCHAR  tchBuff[MAX_SERVER_SHARE_NAME_FOR_CSC], tzDrive[4];
    BOOL    fIsOnline = FALSE, fDone;
    DWORD   dwError;

    if (lstrlen(lpszShareName) >= MAX_SERVER_SHARE_NAME_FOR_CSC)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    lstrcpy(tchBuff, lpszShareName);

    if (!LpBreakPath(tchBuff, TRUE, &fDone) && !fDone)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    dwError = DWConnectNet(tchBuff, tzDrive, NULL, NULL, NULL, 0, NULL);
    if ((dwError == WN_SUCCESS) || (dwError == WN_CONNECTED_OTHER_PASSWORD_DEFAULT))
    {
        fIsOnline = TRUE;

        if (lpdwSpeed)
        {
            GetConnectionInfoForDriveBasedName(tzDrive, lpdwSpeed);
        }                                       
        DWDisconnectDriveMappedNet(tzDrive, TRUE);
    }
    else
    {
        SetLastError(dwError);
    }

    return(fIsOnline);
}

BOOL
WINAPI
CSCCheckShareOnlineW(
    IN  LPCWSTR     lpszShareName
    )
/*++

Routine Description:

    This routine checks whether a given share is available online.

Arguments:

    lpszShareName

Returns:


Notes:

--*/
{
    return (CSCCheckShareOnlineExW(lpszShareName, NULL));
}

BOOL
WINAPI
CSCCheckShareOnlineA(
    IN  LPCSTR     lpszShareName
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

BOOL
WINAPI
CSCDoLocalRenameW(
    IN  LPCWSTR     lpszSource,
    IN  LPCWSTR     lpszDestination,
    IN  BOOL        fReplaceFileIfExists
    )
{
    return CSCDoLocalRenameExW(lpszSource, lpszDestination, NULL, FALSE, fReplaceFileIfExists);
}

BOOL
WINAPI
CSCDoLocalRenameExW(
    IN  LPCWSTR     lpszSource,
    IN  LPCWSTR     lpszDestination,
    IN  WIN32_FIND_DATAW    *lpFind32,
    IN  BOOL        fMarkAsLocal,
    IN  BOOL        fReplaceFileIfExists
    )
/*++

Routine Description:

    This routine does a rename in the datbase. The rename operation can be across shares

Arguments:

    lpszSource              Fully qualified source name (must be UNC)

    lpszDestination         Fully qualified destination directory name (must be UNC)
    
    lpFind32                New name in the destination directory, given the long name
                            the shortnmae is locally generated. For this reason, when
                            a new name is given, fMarkAsLocal is forced TRUE.
    
    fMarkAsLocal            Mark the newly created entry as locally created (except see lpFind32)
    
    fReplaceFileIfExists    replace destination file with the source if it exists

Returns:

    TRUE if successfull, FALSE otherwise. If the API fails, GetLastError returns the specific
    errorcode.

Notes:

--*/
{

    DWORD   dwError = NO_ERROR;
    WIN32_FIND_DATA sFind32;
    BOOL    fDone=FALSE, fRet = FALSE, fBeginInodeTransaction = FALSE, fSourceIsFile=FALSE;
    SHADOWINFO  sSI;
    HSHADOW hDirFrom, hShadowFrom, hDirTo, hShadowTo=0;
    HSHARE hShareFrom, hShareTo;
    HANDLE      hShadowDB;
    DWORD   lenSrc=0, lenDst=0;

    ReintKdPrint(API, ("DoLocalRenameEx %ls %ls %x %x %x\r\n", lpszSource, lpszDestination, lpFind32, fMarkAsLocal, fReplaceFileIfExists));

    try
    {
        if ((lenSrc = lstrlen(lpszSource)) >= MAX_PATH)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        lstrcpy(sFind32.cFileName, lpszSource);

        if (!LpBreakPath(sFind32.cFileName, TRUE, &fDone) && fDone)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
    }

    try
    {
        if ((lenDst = lstrlen(lpszDestination)) >= MAX_PATH)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
    }

    // if source is not greater than the destination
    // verify that we are not renaming the parent under it's own child

    if (lenSrc <= lenDst)
    {
        lstrcpy(sFind32.cFileName, lpszDestination);
        sFind32.cFileName[lenSrc] = 0;

        // make a case insensitive comparison
        if(!lstrcmpi(lpszSource, sFind32.cFileName))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }

    if ((hShadowDB = OpenShadowDatabaseIO()) ==INVALID_HANDLE_VALUE)
    {
        ReintKdPrint(BADERRORS, ("failed to open database\r\n"));
        return FALSE;
    }

    if(BeginInodeTransactionHSHADOW())
    {
        fBeginInodeTransaction = TRUE;

        if(!FindCreateShadowFromPath(lpszSource, FALSE, &sFind32, &sSI, NULL))
        {
            goto bailout;
        }

        ReintKdPrint(API, ("Source Share = %x Inode %x %x\r\n", sSI.hShare, sSI.hDir, sSI.hShadow));

        hDirFrom = sSI.hDir;
        hShadowFrom = sSI.hShadow;
        hShareFrom = sSI.hShare;
        fSourceIsFile = ((sFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)==0);

        if(!FindCreateShadowFromPath(lpszDestination, TRUE, &sFind32, &sSI, NULL))
        {
            goto bailout;
        }

        ReintKdPrint(API, ("Destination Share = %x Inode %x %x\r\n", sSI.hShare, sSI.hDir, sSI.hShadow));
        hShareTo = sSI.hShare;
        hDirTo = sSI.hShadow;

        // if we are creating a new entry in the database, we say it was created
        // offline
        if (lpFind32)
        {
            fMarkAsLocal = TRUE;                        
            fReplaceFileIfExists = FALSE;
        }

        if (((hShareFrom == hShareTo) && !fReplaceFileIfExists) ||fSourceIsFile)
        {
            // do the rename only if the source directory is not the same as the destination directory.
            // or the destination name is different, otherwise there is nothing to do
            if ((hDirFrom != sSI.hShadow)||(lpFind32))
            {

                if (RenameShadow(hShadowDB, hDirFrom, hShadowFrom, hDirTo, lpFind32, fReplaceFileIfExists, &hShadowTo))
                {
                    //
                    fRet = SetShareStatus(hShadowDB, hShareTo, SHARE_REINT, SHADOW_FLAGS_OR);

                    if (fMarkAsLocal)
                    {
                        Assert(hShadowTo);
                        if (fSourceIsFile)
                        {
                            fRet = SetShadowInfo(hShadowDB, hDirTo, hShadowTo, NULL, SHADOW_LOCALLY_CREATED, SHADOW_FLAGS_ASSIGN);
                        }
                        else
                        {
                            SET_SUBTREE_STATUS sSSS;
                            memset(&sSSS, 0, sizeof(sSSS));
                            sSSS.uStatus = SHADOW_LOCALLY_CREATED;
                            sSSS.uOp = SHADOW_FLAGS_ASSIGN;
                            fRet = (TraverseOneDirectory(hShadowDB, NULL, hDirTo, hShadowTo, (LPTSTR)lpszSource, SetSubtreeStatus, &sSSS)!=TOD_ABORT);
                        }
                    }
                    if (!fRet)
                    {
                       dwError = GetLastError();                        
                    }
                }
                else
                {
                    dwError = GetLastError();
                }
            }
            else
            {
                fRet = TRUE;
            }
        }
        else
        {
            MOVE_SUBTREE    sMST;
            
            memset(&sMST, 0, sizeof(sMST));

            sMST.lptzSource = lpszSource;
            sMST.lptzDestination = lpszDestination;
            sMST.lpTos = &sMST.sTos;
            sMST.sTos.hDir = hDirTo;
            sMST.hShareTo = hShareTo;

            if (fReplaceFileIfExists)
            {
                sMST.dwFlags |= MST_REPLACE_IF_EXISTS;                
            }

            TraverseOneDirectory(hShadowDB,  NULL, hDirFrom, hShadowFrom, (LPTSTR)lpszSource, MoveSubtree, &sMST);

            fRet = (sMST.cntFail == 0);

            Assert(sMST.lpTos == &sMST.sTos);
            Assert(sMST.sTos.lpNext == NULL);
        }
    }

bailout:
    if (fBeginInodeTransaction)
    {
        EndInodeTransactionHSHADOW();
    }
    if (!fRet)
    {
        SetLastError(dwError);
    }

    CloseShadowDatabaseIO(hShadowDB);

    return fRet;
}

BOOL
CreateDirectoryAndSetHints(
    HANDLE          hShadowDB,
    LPTSTR          lptzFullPath,
    DWORD           dwCallbackReason,
    WIN32_FIND_DATA *lpFind32,
    SHADOWINFO      *lpSI,
    LPMOVE_SUBTREE  lpMst
    )
/*++

Routine Description:

    This routine creates a copy of a source directory under a destination directory

Arguments:

    hShadowDB           Handle to issue ioctls to the redir

    lptzFullPath        fully qualified path to the item

    dwCallbackReason    TOD_CALLBACK_REASON_XXX (BEGIN, NEXT_ITEM or END)

    lpFind32            local win32info

    lpSI                other info such as priority, pincount etc.

    lpMst               MOVE_SUBTREE structure which contains the rlevant info about this move


Returns:

    TRUE if successfull, FALSE otherwise. If the API fails, GetLastError returns the specific
    errorcode.

Notes:

--*/
{
    BOOL fRet = FALSE;

    lpMst->sFind32 =  *lpFind32;
    if(GetShadowEx(hShadowDB, lpMst->lpTos->hDir, &lpMst->sFind32, &lpMst->sSI))
    {
        // if it doesn't exist, create it and set it's hints to those found on the source
        if (!lpMst->sSI.hShadow)
        {
            if (CreateShadow(hShadowDB, lpMst->lpTos->hDir, &lpMst->sFind32, lpSI->uStatus, &lpMst->sSI.hShadow))
            {
                lpMst->sSI.ulHintPri = lpSI->ulHintPri;
                lpMst->sSI.ulHintFlags =  lpSI->ulHintFlags;

                if(AddHintFromInode(hShadowDB, lpMst->lpTos->hDir, lpMst->sSI.hShadow, &(lpMst->sSI.ulHintPri), &(lpMst->sSI.ulHintFlags)) != 0)
                {
                    fRet = TRUE;
                }

            }

        }
        else
        {
            fRet = TRUE;
        }

    }
    return fRet;
}

BOOL
WINAPI
CSCDoLocalRenameA(
    IN  LPCSTR      lpszSource,
    IN  LPCSTR      lpszDestination,
    IN  BOOL        fReplcaeFileIfExists
    )
/*++

Routine Description:

    This routine does a rename in the datbase. The rename operation can be across shares

Arguments:

    lpszSource          Fully qualified source name (must be UNC)

    lpszDestination     Fully qualified destination name (must be UNC)

Returns:

    TRUE if successfull, FALSE otherwise. If the API fails, GetLastError returns the specific
    errorcode.

Notes:

--*/
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

BOOL
WINAPI
CSCDoEnableDisable(
    BOOL    fEnable
    )
/*++

Routine Description:

    This routine enables/disables CSC

Arguments:

    fEnable enable CSC if TRUE, else disable CSC
    
Returns:

    TRUE if successfull, FALSE otherwise. If the API fails, GetLastError returns the specific
    errorcode.

Notes:

--*/
{
    BOOL fRet = FALSE, fReformat = FALSE;
    char    szDBDir[MAX_PATH+1];
    DWORD   dwDBCapacity, dwClusterSize;

    if (IsPersonal() == TRUE) {
        SetLastError(ERROR_INVALID_OPERATION);
        return FALSE;
    }

    if (fEnable)
    {
        if (InitValues(szDBDir, sizeof(szDBDir), &dwDBCapacity, &dwClusterSize))
        {
            fReformat = QueryFormatDatabase();

            fRet = EnableShadowingForUser(INVALID_HANDLE_VALUE, szDBDir, NULL, 0, dwDBCapacity, dwClusterSize, fReformat);
        }
    }
    else
    {
        fRet = DisableShadowingForUser(INVALID_HANDLE_VALUE);

    }
    return fRet;
}


int
MoveSubtree(
    HANDLE          hShadowDB,
    LPSECURITYINFO  pShareSecurityInfo,
    LPTSTR          lptzFullPath,
    DWORD           dwCallbackReason,
    WIN32_FIND_DATA *lpFind32,
    SHADOWINFO      *lpSI,
    LPMOVE_SUBTREE  lpMst
    )
/*++

Routine Description:

    This is a callback routine to TraverseOneDirectory. It moves the subtree from one place
    in the hierarchy to another. It would be necessary to call this routine only when
    the subtree is being moved from one share to another.

Arguments:

    hShadowDB           Handle to issue ioctls to the redir

    lptzFullPath        fully qualified path to the item

    dwCallbackReason    TOD_CALLBACK_REASON_XXX (BEGIN, NEXT_ITEM or END)

    lpFind32            local win32info

    lpSI                other info such as priority, pincount etc.

    lpMst               MOVE_SUBTREE structure which contains the rlevant info about this move


Returns:

    return code, whether continue, cancel etc.

Notes:

    As TravesreOneDirectory descends the source subtree, this routine creates directories in the
    corresponding location in the destination subtree. It then moves the files from one subtree
    to another. At the end of the enumeration of any directory, it tries to delete the source
    directory. The delete succeeds only if there are no more descedents left to the source
    directory

--*/
{
    BOOL    fRet = FALSE;
    LPMST_LIST lpT;

    ReintKdPrint(API, ("MoveSubTree %ls\r\n", lptzFullPath));

    switch (dwCallbackReason)
    {
    case TOD_CALLBACK_REASON_BEGIN:
        {
            ReintKdPrint(API, ("MST Begin source Inode %x %x\r\n", lpSI->hDir, lpSI->hShadow));

            // Get the source directory info
            if (GetShadowInfoEx(hShadowDB, lpSI->hDir, lpSI->hShadow, lpFind32, lpSI))
            {
                fRet = CreateDirectoryAndSetHints(hShadowDB, lptzFullPath, dwCallbackReason, lpFind32, lpSI, lpMst);
            }
            // if all is well, then make this directory the parent directory for
            // all subsequent creates and renames

            if (fRet)
            {

                lpT = (LPMST_LIST)LocalAlloc(LPTR, sizeof(MST_LIST));

                if (!lpT)
                {
                    return TOD_ABORT;
                }

                lpT->hDir = lpMst->sSI.hShadow;
                lpT->lpNext = lpMst->lpTos;
                lpMst->lpTos = lpT;

                // mark the destination share dirty, if necessary
                if (lpSI->uStatus & SHADOW_MODFLAGS)
                {
                    if (!(lpMst->dwFlags & MST_SHARE_MARKED_DIRTY))
                    {
                        ReintKdPrint(API, ("Setting Share %x dirty \n", lpMst->hShareTo));

                        if(SetShareStatus(hShadowDB, lpMst->hShareTo, SHARE_REINT, SHADOW_FLAGS_OR))
                        {
                            lpMst->dwFlags |= MST_SHARE_MARKED_DIRTY;
                        }
                    }
                }
            }
            else
            {
                lpMst->cntFail++;
            }
        }
    break;
    case TOD_CALLBACK_REASON_NEXT_ITEM:
        // if the source is a file, then move it
        ReintKdPrint(API, ("MST next source Inode %x %x\r\n", lpSI->hDir, lpSI->hShadow));
        if(!(lpFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            ReintKdPrint(API, ("MST rename file SrcInode %x %x to destdir %x\r\n", lpSI->hDir, lpSI->hShadow, lpMst->lpTos->hDir));
            if (RenameShadow(hShadowDB, lpSI->hDir, lpSI->hShadow, lpMst->lpTos->hDir, NULL, 
                ((lpMst->dwFlags & MST_REPLACE_IF_EXISTS)!=0), NULL))
            {
                fRet = TRUE;

            }
        }
        else
        {
            if(CreateDirectoryAndSetHints(hShadowDB, lptzFullPath, dwCallbackReason, lpFind32, lpSI, lpMst))
            {
                fRet = TRUE;
            }
        }

        if (!fRet)
        {
            lpMst->cntFail++;
        }
        // mark the destination share dirty, if necessary
        if (lpSI->uStatus & SHADOW_MODFLAGS)
        {
            if (!(lpMst->dwFlags & MST_SHARE_MARKED_DIRTY))
            {
                if(SetShareStatus(hShadowDB, lpMst->hShareTo, SHARE_REINT, SHADOW_FLAGS_OR))
                {
                    lpMst->dwFlags |= MST_SHARE_MARKED_DIRTY;
                }
            }
        }
    break;
    case TOD_CALLBACK_REASON_END:
        Assert(lpMst->lpTos);
        lpT = lpMst->lpTos;
        lpMst->lpTos = lpMst->lpTos->lpNext;
        LocalFree(lpT);
        fRet = TRUE;

        ReintKdPrint(API, ("MST End Delete Inode %x %x \r\n", lpSI->hDir, lpSI->hShadow));
        DeleteShadow(hShadowDB, lpSI->hDir, lpSI->hShadow);

    break;

    }

    return (fRet?TOD_CONTINUE:TOD_ABORT);
}

int
SetSubtreeStatus(
    HANDLE          hShadowDB,
    LPSECURITYINFO  pShareSecurityInfo,
    LPTSTR          lptzFullPath,
    DWORD           dwCallbackReason,
    WIN32_FIND_DATA *lpFind32,
    SHADOWINFO      *lpSI,
    LPSET_SUBTREE_STATUS  lpSss
    )
/*++

Routine Description:

    This is a callback routine to TraverseOneDirectory. It moves the subtree from one place
    in the hierarchy to another. It would be necessary to call this routine only when
    the subtree is being moved from one share to another.

Arguments:

    hShadowDB           Handle to issue ioctls to the redir

    lptzFullPath        fully qualified path to the item

    dwCallbackReason    TOD_CALLBACK_REASON_XXX (BEGIN, NEXT_ITEM or END)

    lpFind32            local win32info

    lpSI                other info such as priority, pincount etc.

    lpSss               SET_SUBTREE_STATE structure which contains the relevant info about this state setting


Returns:

    return code, whether continue, cancel etc.

Notes:

    As TravesreOneDirectory descends the source subtree, this routine sets the required bits

--*/
{

    ReintKdPrint(API, ("SetSubTreeState %ls\r\n", lptzFullPath));

    if(SetShadowInfo(hShadowDB, lpSI->hDir, lpSI->hShadow, NULL, lpSss->uStatus, lpSss->uOp) == TRUE)
    {
        return TOD_CONTINUE;
    }
    else
    {
        return TOD_ABORT;
    }

}

BOOL
WINAPI
CSCBeginSynchronizationW(
    IN  LPCTSTR     lpszShareName,
    LPDWORD         lpdwSpeed,
    LPDWORD         lpdwContext
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
{
    _TCHAR  tchBuff[MAX_SERVER_SHARE_NAME_FOR_CSC], tzDrive[4];
    BOOL    fIsOnline = FALSE, fDone, fExplicitCredentials=FALSE, fIsDfs;
    DWORD   dwError;
    
    if (lstrlen(lpszShareName) >= MAX_SERVER_SHARE_NAME_FOR_CSC)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    lstrcpy(tchBuff, lpszShareName);

    if (!LpBreakPath(tchBuff, TRUE, &fDone) && !fDone)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    ReintKdPrint(API, (" CSCBeginSynchronization %ls\r\n", tchBuff));

    dwError = DWConnectNet(tchBuff, tzDrive, NULL, NULL, NULL, CONNECT_INTERACTIVE, NULL);
    if ((dwError == WN_SUCCESS)||(dwError==WN_CONNECTED_OTHER_PASSWORD)||(dwError==WN_CONNECTED_OTHER_PASSWORD_DEFAULT))
    {
        fIsOnline = TRUE;

        if (lpdwSpeed)
        {
            GetConnectionInfoForDriveBasedName(tzDrive, lpdwSpeed);
        }

        if (dwError==WN_CONNECTED_OTHER_PASSWORD || dwError==WN_CONNECTED_OTHER_PASSWORD_DEFAULT)
        {
            ReintKdPrint(API, (" CSCBeginSynchronization: Explicit Credentials\r\n"));
            fExplicitCredentials = TRUE;

            dwError = DoNetUseAddForAgent(tchBuff, NULL, NULL, NULL, NULL, 0, &fIsDfs);
            if (dwError != WN_SUCCESS && dwError!=WN_CONNECTED_OTHER_PASSWORD_DEFAULT)
            {
                fIsOnline = FALSE;
                ReintKdPrint(API, (" CSCBeginSynchronization: Failed extra reference %d\r\n", dwError));
            }
        }

        DWDisconnectDriveMappedNet(tzDrive, TRUE);
    }

    if (!fIsOnline)
    {
        ReintKdPrint(ALWAYS, (" CSCBeginSynchronization: Failed %d\r\n", dwError));
        SetLastError(dwError);
    }
    else
    {
        *lpdwContext = fExplicitCredentials;
    }

    return(fIsOnline);
}

BOOL
WINAPI
CSCEndSynchronizationW(
    IN  LPCTSTR     lpszShareName,
    DWORD           dwContext
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
{
    _TCHAR  tchBuff[MAX_SERVER_SHARE_NAME_FOR_CSC], tzDrive[4];
    BOOL    fIsOnline = FALSE, fDone, fExplicitCredentials=FALSE;
    DWORD   dwError;
    
    if (lstrlen(lpszShareName) >= MAX_SERVER_SHARE_NAME_FOR_CSC)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    lstrcpy(tchBuff, lpszShareName);

    if (!LpBreakPath(tchBuff, TRUE, &fDone) && !fDone)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (dwContext != 0)
    {
        WNetCancelConnection2(tchBuff, 0, TRUE);
    }

    return TRUE;
}

#if 0
BOOL
WINAPI
CSCEncryptDecryptFileW(
    IN  LPCTSTR     lpszFileName,
    IN  BOOL        fEncrypt
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
{
    WIN32_FIND_DATA sFind32;
    SHADOWINFO sSI;
    BOOL fRet = FALSE;
    DWORD   dwError = ERROR_GEN_FAILURE;

    //    
    if(FindCreateShadowFromPath(lpszFileName, FALSE, &sFind32, &sSI, NULL))
    {
        fRet = RecreateShadow(INVALID_HANDLE_VALUE, sSI.hDir, sSI.hShadow, (fEncrypt)?FILE_ATTRIBUTE_ENCRYPTED:0);
    }
    
    return fRet;    
}
#endif

BOOL
WINAPI
CSCQueryDatabaseStatus(
    ULONG   *pulStatus,
    ULONG   *pulErrors
    )
/*++

Routine Description:

    Allows caller to query the database status.

Arguments:

    pulStatus   Current status. Encryption status is the most interesting

    pulErrors   If the database has any errors, one or more bits will be set

Returns:

    TRUE if the API succeeded

Notes:


--*/
{
    GLOBALSTATUS sGS;
    
    if(!GetGlobalStatus(INVALID_HANDLE_VALUE, &sGS))
    {
        return FALSE;
    }
    *pulStatus = sGS.sST.uFlags;
    *pulErrors = sGS.uDatabaseErrorFlags;
    return TRUE;
    
}


BOOL
WINAPI
CSCEncryptDecryptDatabase(
    IN  BOOL        fEncrypt,
    IN  LPCSCPROCW  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
    )
    
/*++

Routine Description:

    This routine is used to encrypt/decrypt the entire database in system context. The routine checks that
    the CSC database is hosted on a filesystem that allows encryption. Only admins can do the conversion
    

Arguments:

    fEncrypt    if TRUE, we encrypt the database else we decrypt.
    
    LPCSCPROCW  callback proc. The usual set of CSCPROC_REASON_BEGIN, CSCPROC_REASON_MORE_DATA, CSC_PROC_END
                are sent when the conversion actually begins. Conversion can fail if a file is open or for
                some other reason, in which case the second to last parameter in the callback with 
                CSCPROC_REASON_MORE_DATA has the error code. The third to last parameter indicates whether
                the conversion was complete or not. Incomplete conversion is not an error condition.
    
    dwContext   callback context

Returns:

    TRUE if no errors encountered.

Notes:


    Theory of operations:
    
        The CSC database encryption code encrypts all the inodes represented by remote files.
        Who: Only user in admingroup can do encryption/decryption. This is checked in kernel
        Which context: Files are encrypted in system context. This allows files to be shared
                       while still being encrypted. This solution protects from a stolen laptop case.
                       
        The database can have the following status set on it based on the four encryption states:
        
        a) FLAG_DATABASESTATUS_UNENCRYPTED b) FLAG_DATABASESTATUS_PARTIALLY_UNENCRYPTED
        c) FLAG_DATABASESTATUS_ENCRYPTED d) FLAG_DATABASESTATUS_PARTIALLY_ENCRYPTED
        
        In states a) and b) new files are created unencrypted. In states c) and d) new files are created encrypted.
        
        At the beginning of the conversion, the database stats is marked to the appropriate XX_PARTIAL_XX
        state. At the end, if all goes well, it is transitioned to the final state.
        At the time of enabling CSC, if the database state is XX_PARTIAL_XX, the kernel code tries to
        complete the conversion to the appropriate final state.
                               
                               
            

--*/
{
    BOOL fRet = FALSE, fComplete = FALSE;
    HANDLE hShadowDB = INVALID_HANDLE_VALUE;
    SHADOWSTORE sST;
    DWORD   dwRet, dwError=0, dwStartigNameSpaceVersion;
    ULONG   uT;
    WIN32_FIND_DATA sFind32;
    ENCRYPT_DECRYPT_SUBTREE sEDS;
    SHADOWINFO  sSI;
    HANDLE  ulEnumCookie;
            
    // we have begun    
    if (lpfnEnumProgress)
    {
        dwRet = (*lpfnEnumProgress)(NULL, 0, 0, 0, NULL, CSCPROC_REASON_BEGIN, fEncrypt, 0, dwContext);

        if (dwRet != CSCPROC_RETURN_CONTINUE )
        {
            goto bailout;
        }
    }
    
    if (GetShadowDatabaseLocation(INVALID_HANDLE_VALUE, &sFind32))
    {

        // Set NULL after the root backslash so that this API works correctly
        sFind32.cFileName[3] = 0;
                            
        if(!GetVolumeInformation(sFind32.cFileName, NULL, 0, NULL, &dwRet, &dwError, NULL, 0))
        {
            ReintKdPrint(BADERRORS, ("failed to get volume info for %ls Error=%d\r\n", sFind32.cFileName, GetLastError()));
            goto bailout;

        }
        if (!(dwError & FILE_SUPPORTS_ENCRYPTION))
        {
            ReintKdPrint(BADERRORS, ("volume doesn't support replication \r\n"));
            SetLastError(ERROR_NOT_SUPPORTED);
            goto bailout;
        }
        
    }
    else
    {
        ReintKdPrint(BADERRORS, ("failed to get database location Error=%d\r\n", GetLastError()));
        goto bailout;
    }
    
    if ((hShadowDB = OpenShadowDatabaseIO())==INVALID_HANDLE_VALUE)
    {
        goto bailout;
    }

    // let us see whether we need to do anything
    if(!GetSpaceStats(hShadowDB, &sST))
    {
        goto bailout;    
    }

    sST.uFlags &= FLAG_DATABASESTATUS_ENCRYPTION_MASK;

    // the database is already in the state desired, succeed and quit
    if ((fEncrypt && (sST.uFlags == FLAG_DATABASESTATUS_ENCRYPTED))||
        (!fEncrypt && (sST.uFlags == FLAG_DATABASESTATUS_UNENCRYPTED)))
    {
        fRet = TRUE;
        goto bailout;
    }


    sST.uFlags = (fEncrypt)? FLAG_DATABASESTATUS_PARTIALLY_ENCRYPTED : FLAG_DATABASESTATUS_PARTIALLY_UNENCRYPTED;

    // mark the database in appropriate transient state
    // once this is marked, any new file that is created is in correct encryption state    
    if (!SetDatabaseStatus(hShadowDB, sST.uFlags, FLAG_DATABASESTATUS_ENCRYPTION_MASK))
    {
        goto bailout;
    }

    
    memset(&sEDS, 0, sizeof(sEDS));
    memset(&sFind32, 0, sizeof(sFind32));
    lstrcpy(sFind32.cFileName, _TEXT("*"));

    if(!FindOpenShadow(  hShadowDB, 0, FINDOPEN_SHADOWINFO_ALL,
                        &sFind32, &sSI))
    {
        // The database is empty, so set the state to fully encrypted (or decrypted)
        sST.uFlags = (fEncrypt)? FLAG_DATABASESTATUS_ENCRYPTED : FLAG_DATABASESTATUS_UNENCRYPTED;
        SetDatabaseStatus(hShadowDB, sST.uFlags, FLAG_DATABASESTATUS_ENCRYPTION_MASK);
        goto bailout;
    }
    
    dwStartigNameSpaceVersion = sSI.dwNameSpaceVersion;
    ulEnumCookie = sSI.uEnumCookie;
    
    sEDS.dwContext = dwContext;
    sEDS.lpfnEnumProgress = lpfnEnumProgress;
    sEDS.fEncrypt = fEncrypt;
        
    ReintKdPrint(ALWAYS, ("Starting NameSpaceVersion %x \n", dwStartigNameSpaceVersion));
    do {

        if(TraverseOneDirectory(hShadowDB, NULL, sSI.hDir, sSI.hShadow, sFind32.cFileName, EncryptDecryptSubtree, &sEDS)==TOD_ABORT)
        {
            break;
        }

    }while(FindNextShadow(hShadowDB, ulEnumCookie, &sFind32, &sSI));

    FindCloseShadow(hShadowDB, ulEnumCookie);
    
    ReintKdPrint(ALWAYS, ("Ending NameSpaceVersion %x \n", sEDS.dwEndingNameSpaceVersion));

    if (!(sEDS.dwFlags & EDS_FLAG_ERROR_ENCOUNTERED) &&
        (dwStartigNameSpaceVersion == sEDS.dwEndingNameSpaceVersion))
    {
        sST.uFlags = (fEncrypt)? FLAG_DATABASESTATUS_ENCRYPTED : FLAG_DATABASESTATUS_UNENCRYPTED;
    
        if (!SetDatabaseStatus(hShadowDB, sST.uFlags, FLAG_DATABASESTATUS_ENCRYPTION_MASK))
        {
            goto bailout;
        }
        
        fComplete = TRUE;
        
    }

    dwError = NO_ERROR;
    fRet = TRUE;
    

bailout:

    if (!fRet)
    {
        dwError = GetLastError();
    }
    
    if (hShadowDB != INVALID_HANDLE_VALUE)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (lpfnEnumProgress)
    {
        dwRet = (*lpfnEnumProgress)(NULL, 0, 0, 0, NULL, CSCPROC_REASON_END, fComplete, dwError, dwContext);
    }

    return fRet;
}

int
EncryptDecryptSubtree(
    HANDLE          hShadowDB,
    LPSECURITYINFO  pShareSecurityInfo,
    LPTSTR          lptzFullPath,
    DWORD           dwCallbackReason,
    WIN32_FIND_DATA *lpFind32,
    SHADOWINFO      *lpSI,
    LPENCRYPT_DECRYPT_SUBTREE  lpEds
    )
/*++

Routine Description:

    This is a callback routine to TraverseOneDirectory. It encrypts or decrypts files in the subtree

Arguments:

    hShadowDB           Handle to issue ioctls to the redir

    lptzFullPath        fully qualified path to the item

    dwCallbackReason    TOD_CALLBACK_REASON_XXX (BEGIN, NEXT_ITEM or END)

    lpFind32            local win32info

    lpSI                other info such as priority, pincount etc.

    lpEds               ENCRYPT_DECRYPT_SUBTREE structure which contains the relevant info such
                        as encrypt-or-decrypt, callback function, context, error flag


Returns:

    return code, whether continue, cancel etc.

Notes:


--*/
{
    BOOL    fRet;
    DWORD   dwError, dwRet;
    int iRet = TOD_CONTINUE;


    //Bug: 581224
    // Should return TOD_CONTINUE for TOD_CALLBACK_REASON_BEGIN
    if (dwCallbackReason == TOD_CALLBACK_REASON_BEGIN) {
        return iRet;
    }


    // save the last known version number, the calling routine will
    // compare it against the first one    
    if(dwCallbackReason == TOD_CALLBACK_REASON_NEXT_ITEM)
    {
        lpEds->dwEndingNameSpaceVersion = lpSI->dwNameSpaceVersion;
    }

    // operate only on files        
    if (lpSI->uStatus & SHADOW_IS_FILE)
    {

        ReintKdPrint(ALWAYS, ("Processing file %ls \n", lptzFullPath));

        do
        {
            dwError = 0;

            // try conversion. If we fail, not in the EDS structure so 
            // the caller knows        
            if(!RecreateShadow(hShadowDB, lpSI->hDir, lpSI->hShadow, (lpEds->fEncrypt)?FILE_ATTRIBUTE_ENCRYPTED:0))
            {
                dwError = GetLastError();
            }
        
            if (lpEds->lpfnEnumProgress)
            {
                dwRet = (*(lpEds->lpfnEnumProgress))(lptzFullPath, 0, 0, 0, lpFind32, CSCPROC_REASON_MORE_DATA, 0, dwError, lpEds->dwContext);

                if (dwRet == CSCPROC_RETURN_RETRY)
                {
                    continue;                    
                }
                // abort if the callback wants to
                if (dwRet != CSCPROC_RETURN_CONTINUE )
                {
                    iRet = TOD_ABORT;
                }
            }                
            
            break;
        }
        while (TRUE);
        if (dwError != ERROR_SUCCESS)
        {
            lpEds->dwFlags |= EDS_FLAG_ERROR_ENCOUNTERED;
        }
    }
        
    return iRet;
}

BOOL
CSCPurgeUnpinnedFiles(
    ULONG Timeout,
    PULONG pnFiles,
    PULONG pnYoungFiles)
{
    BOOL iRet;

    iRet = PurgeUnpinnedFiles(
            INVALID_HANDLE_VALUE,
            Timeout,
            pnFiles,
            pnYoungFiles);

    // DbgPrint("CSCPurgeUnpinnedFiles(Timeout=%d nFiles=%d nYoungFiles=%d)\n",
    //                     Timeout,
    //                     *pnFiles,
    //                     *pnYoungFiles);

    return iRet;
}

BOOL
WINAPI
CSCShareIdToShareName(
    ULONG ShareId,
    PBYTE Buffer,
    PDWORD pBufSize)
{

    BOOL iRet;

    iRet = ShareIdToShareName(
                INVALID_HANDLE_VALUE,
                ShareId,
                Buffer,
                pBufSize);

    return iRet;
}

BOOL
IsPersonal(VOID)
{
    OSVERSIONINFOEX Osvi;
    DWORD TypeMask;
    DWORDLONG ConditionMask;

    memset(&Osvi, 0, sizeof(OSVERSIONINFOEX));
    Osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    Osvi.wSuiteMask = VER_SUITE_PERSONAL;
    TypeMask = VER_SUITENAME;
    ConditionMask = 0;
    VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_OR);
    return(VerifyVersionInfo(&Osvi, TypeMask, ConditionMask)); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\dobj.h ===
//
// dobj.h: Declares data, defines and struct types for RecAct
//          module.
//
//

#ifndef __DOBJ_H__
#define __DOBJ_H__

// DOBJ is the draw object structure for drawing listbox entries
//
// DOBJ kinds
//
#define DOK_ICON        1   // lpvObject is the HICON
#define DOK_STRING      2   // lpvObject is the LPCSTR
#define DOK_BITMAP      3   // lpvObject is the HBITMAP
#define DOK_SIDEITEM    4   // lpvObject points to LPSIDEITEM
#define DOK_IMAGE       5   // 
#define DOK_IDS         6   // lpvObject is the resource ID

// DOBJ item styles
//
#define DOF_LEFT        0x0000
#define DOF_CENTER      0x0001
#define DOF_RIGHT       0x0002
#define DOF_DIFFER      0x0004  // This item's appearance is affected by uState
#define DOF_MENU        0x0008  // Use menu colors
#define DOF_DISABLED    0x0010
#define DOF_IGNORESEL   0x0020  // Ignore selection state
#define DOF_USEIDS      0x0040  // lpvObject is a resource string ID
#define DOF_NODRAW      0x1000  // Don't draw 

typedef struct tagDOBJ
    {
    UINT    uKind;          // One of DOK_* ordinals
    UINT    uFlags;         // One of DOF_* styles
    LPVOID  lpvObject;      // ptr or handle
    HIMAGELIST himl;        // 
    int     iImage;         // 
    int     x;
    int     y;
    RECT    rcBounding;     // Bounding rect of entire object
    union 
        {
        RECT rcSrc;         // DOK_BITMAP: source rect to blt from
        RECT rcClip;        // Clipping rect
        RECT rcLabel;       // Clipping rect for label
        };

    } DOBJ, FAR * LPDOBJ;


void PUBLIC Dobj_Draw(HDC hdc, LPDOBJ pdobj, int cItems, UINT uState, int cxEllipses, int cyText, COLORREF clrBkgnd);

void PUBLIC ComputeImageRects(LPCSTR psz, HDC hdc, LPPOINT ppt, LPRECT prcIcon, LPRECT prcLabel, int cxIcon, int cyIcon, int cxIconSpacing, int cyText);

#endif // __DOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\dobj.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: dobj.c
//
//  This file contains support routines for the reconciliation-action 
//   control class code
//
//
// History:
//  09-13-93 ScottH     Extracted from recact.c
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "pch.h"

#include "extra.h"
#include "resource.h"
#include "recact.h"
#include "dobj.h"

/////////////////////////////////////////////////////  CONTROLLING DEFINES


/////////////////////////////////////////////////////  DEFINES

#define DT_CALCWRAP     (DT_CALCRECT | DT_CENTER | DT_WORDBREAK | DT_NOPREFIX)
#define DT_CALC         (DT_CALCRECT | DT_CENTER | DT_SINGLELINE | DT_NOPREFIX)

/*----------------------------------------------------------
Purpose: Formats the given path to the correct location format
Returns: --
Cond:    --
*/
void PRIVATE FormatLocationPath(
    LPCSTR pszPath,
    LPSTR pszBuffer)        // Must be MAX_PATH
    {
    UINT ids;
// tHACK    char szBrfDir[MAX_PATH];
    LPCSTR psz;
    LPSTR pszMsg;

    //  The format for the directory location is:
    //
    //      Inside briefcase:       "In Briefcase"
    //      Below briefcase:        "In Briefcase\FolderName"
    //      Outside briefcase:      "In FullPath"
    //
    // We assume that paths outside the current briefcase
    //  never consist of a briefcase name of another.
    //
#if 0
	 // tHACK
	 if (PathGetLocality(pszPath, szBrfDir) != PL_FALSE)
        {
        // Inside the briefcase
        psz = &pszPath[lstrlen(szBrfDir)];
        ids = IDS_InBriefcase;
        }
    else
#endif
        {
        // Outside the briefcase
        psz = pszPath;
        ids = IDS_InLocation;
        }

    if (ConstructMessage(&pszMsg, vhinstCur, MAKEINTRESOURCE(ids), psz))
        {
        lstrcpy(pszBuffer, pszMsg);
        GFree(pszMsg);
        }
    else
        *pszBuffer = 0;
    }


/*----------------------------------------------------------
Purpose: Return the string describing the status of this sideitem
Returns: ptr to status string
Cond:    --
*/
LPSTR PRIVATE SideItem_GetStatus(
    LPSIDEITEM this,
    LPSTR pszBuf,
    UINT cchBuf)
    {
    switch (this->uState)
        {
    case SI_CHANGED:
        return SzFromIDS(IDS_STATE_Changed, pszBuf, cchBuf);
    case SI_UNCHANGED:
        return SzFromIDS(IDS_STATE_Unchanged, pszBuf, cchBuf);
    case SI_NEW:
        return SzFromIDS(IDS_STATE_NewFile, pszBuf, cchBuf);
    case SI_UNAVAILABLE:
        return SzFromIDS(IDS_STATE_Unavailable, pszBuf, cchBuf);
    default:
        return NULL;
        }
    }


/*----------------------------------------------------------
Purpose: Displays the 3-liner: location, status, and timestamp
Returns: --
Cond:    --
*/
void PRIVATE SideItem_Display(
    LPSIDEITEM this,
    HDC hdc,
    LPRECT prc,
    int cxEllipses,
    int cyText)
    {
    char sz[MAX_PATH];
    char szBuf[MAXBUFLEN];
    LPSTR psz;
    RECT rc = *prc;

    // Directory location.  

	 FormatLocationPath(this->pszDir, sz);
//    strcpy(sz, "a long path tHACKed");
    MyDrawText(hdc, sz, &rc, MDT_LEFT | MDT_TRANSPARENT | MDT_ELLIPSES, 
        cyText, cxEllipses, CLR_DEFAULT, CLR_DEFAULT);

    // Status string
    psz = SideItem_GetStatus(this, szBuf, sizeof(szBuf));
    if (psz)
        {
        // Only bother with these two lines if the file actually
        // exists.

        rc.top += cyText;
        MyDrawText(hdc, psz, &rc, MDT_LEFT | MDT_TRANSPARENT, 
            cyText, cxEllipses, CLR_DEFAULT, CLR_DEFAULT);

        // Date stamp.  Skip this if this is a folder or unavailable.
        //
        if (this->fs.fscond != FS_COND_UNAVAILABLE)
            {
            FileTimeToDateTimeString(&this->fs.ftMod, sz, sizeof(sz));

            rc.top += cyText;
            MyDrawText(hdc, sz, &rc, MDT_LEFT | MDT_TRANSPARENT, 
                cyText, cxEllipses, CLR_DEFAULT, CLR_DEFAULT);
            }
        }
    }


/*----------------------------------------------------------
Purpose: Return the bounding rect for a labelled image.

Returns: --
Cond:    --
*/
void PUBLIC ComputeImageRects(
    LPCSTR psz,
    HDC hdc,
    LPPOINT pptInOut,       
    LPRECT prcWhole,        // May be NULL
    LPRECT prcLabel,        // May be NULL
    int cxIcon,
    int cyIcon,
    int cxIconSpacing,
    int cyText)
    {
    RECT rc;
    int yLabel;
    int cxLabel;
    int cyLabel;
    int cchLabel;
    POINT pt;

    ASSERT(psz);

    // Set our minimum rect size for icon spacing
    if (cxIconSpacing < cxIcon)
        cxIconSpacing = cxIcon + g_cxIconMargin * 2;

    // Upon entry, *pptInOut is expected to be the upper left corner of the 
    // icon-spacing rect.  This function will set it to the upper left
    // corner of the icon itself.

    pt.x = pptInOut->x + (cxIconSpacing - cxIcon) / 2;
    pt.y = pptInOut->y + g_cyIconMargin;

    // Determine rectangle of label with wrap

    rc.left = rc.top = rc.bottom = 0;
    rc.right = cxIconSpacing - g_cxLabelMargin * 2;

    cchLabel = lstrlen(psz);
    if (0 < cchLabel)
        {
        DrawText(hdc, psz, cchLabel, &rc, DT_CALCWRAP);
        }
    else
        {
        rc.bottom = rc.top + cyText;
        }

    yLabel = pptInOut->y + g_cyIconMargin + cyIcon + g_cyLabelSpace;
    cxLabel = (rc.right - rc.left) + 2 * g_cxLabelMargin;
    cyLabel = rc.bottom - rc.top;

    if (prcWhole)
        {
        prcWhole->left   = pptInOut->x;
        prcWhole->right  = prcWhole->left + cxIconSpacing;
        prcWhole->top    = pptInOut->y;
        prcWhole->bottom = max(prcWhole->top + g_cyIconSpacing,
                            yLabel + cyLabel + g_cyLabelSpace);
        }

    if (prcLabel)
        {
        prcLabel->left = pptInOut->x + ((cxIconSpacing - cxLabel) / 2);
        prcLabel->right = prcLabel->left + cxLabel;
        prcLabel->top = yLabel;
        prcLabel->bottom = prcLabel->top + cyLabel;
        }

    *pptInOut = pt;
    }


/*----------------------------------------------------------
Purpose: Set the colors for the given HDC.  The previous colors
          are stored in pcrText and pcrBk.

Returns: uStyle to pass to ImageList_Draw (specific to images only)
Cond:    --
*/
UINT PRIVATE Dobj_SetColors(
    LPDOBJ this,
    HDC hdc,
    UINT uState,
    COLORREF clrBkgnd)
    {
    COLORREF clrText;
    COLORREF clrBk;
    UINT uStyleILD = ILD_NORMAL;
    BOOL bSetColors = FALSE;
    BOOL bDiffer;
    BOOL bMenu;
    BOOL bDisabled;

    // Determine selection colors
    //
    bDiffer = IsFlagSet(this->uFlags, DOF_DIFFER);
    bMenu = IsFlagSet(this->uFlags, DOF_MENU);
    bDisabled = IsFlagSet(this->uFlags, DOF_DISABLED);

    switch (this->uKind)
        {
    case DOK_STRING:
    case DOK_IDS:
    case DOK_SIDEITEM:
        bSetColors = TRUE;
        break;
        }
    
    // Set the text and background colors
    //
    if (bSetColors)
        {
        if (bDiffer)
            {
            // Make the colors differ based on selection state
            //
            if (bMenu)
                {
                if (bDisabled)
                    clrText = GetSysColor(COLOR_GRAYTEXT);
                else
                    clrText = GetSysColor(ColorMenuText(uState));

                clrBk = GetSysColor(ColorMenuBk(uState));
                }
            else
                {
                if (bDisabled)
                    clrText = GetSysColor(COLOR_GRAYTEXT);
                else
                    clrText = GetSysColor(ColorText(uState));

                clrBk = GetSysColor(ColorBk(uState));
                }
            }
        else
            {
            // Transparent colors
            //
            if (bMenu)
                {
                if (bDisabled)
                    clrText = GetSysColor(COLOR_GRAYTEXT);
                else
                    clrText = GetSysColor(COLOR_MENUTEXT);

                clrBk = GetSysColor(COLOR_MENU);
                }
            else
                {
                if (bDisabled)
                    clrText = GetSysColor(COLOR_GRAYTEXT);
                else
                    clrText = GetSysColor(COLOR_WINDOWTEXT);

                clrBk = clrBkgnd;
                }
            }
        SetTextColor(hdc, clrText);
        SetBkColor(hdc, clrBk);
        }

    return uStyleILD;
    }


/*----------------------------------------------------------
Purpose: Draw the menu image and text
Returns: --
Cond:    --
*/
void PRIVATE Dobj_DrawMenuImage(
    LPDOBJ this,
    HDC hdc,
    UINT uState,
    int cyText,
    COLORREF clrBkgnd)
    {
    UINT uStyleILD;
    UINT uFlagsETO;
    LPCSTR psz;
    char szIDS[MAXBUFLEN];
    int cch;
    HIMAGELIST himl = this->himl;
    COLORREF clrText;
    COLORREF clrBk;
    int x;
    int y;
    int cxIcon;
    RECT rc;

    if (IsFlagSet(this->uFlags, DOF_USEIDS))
        psz = SzFromIDS((UINT)this->lpvObject, szIDS, sizeof(szIDS));
    else
        psz = (LPCSTR)this->lpvObject;

    ASSERT(psz);

    cch = lstrlen(psz);
    ImageList_GetImageRect(himl, this->iImage, &rc);
    cxIcon = rc.right-rc.left;

    // Draw the text first

    uFlagsETO = ETO_OPAQUE | ETO_CLIPPED;
    x = this->rcLabel.left + g_cxMargin + cxIcon + g_cxMargin;
    y = this->rcLabel.top + ((this->rcLabel.bottom - this->rcLabel.top - cyText) / 2);

    if (IsFlagSet(this->uFlags, DOF_DISABLED) && 
        IsFlagClear(uState, ODS_SELECTED))
        {
        int imodeOld;
        COLORREF crOld;

        // For disabled menu strings (not selected), we draw the string 
        // twice.  The first is offset down and to the right and drawn 
        // in the 3D hilight color.  The second time is the disabled text
        // color in the normal offset.
        //
        crOld = SetTextColor(hdc, GetSysColor(COLOR_3DHILIGHT));
        imodeOld = SetBkMode(hdc, TRANSPARENT);
        ExtTextOut(hdc, x+1, y+1, uFlagsETO, &this->rcLabel, psz, cch, NULL);

        // Reset back to original color.  Also, turn off the opaqueness.
        //
        SetTextColor(hdc, crOld);
        uFlagsETO ^= ETO_OPAQUE;
        }

    if (IsFlagSet(this->uFlags, DOF_DISABLED))
        clrText = GetSysColor(COLOR_GRAYTEXT);
    else
        clrText = GetSysColor(ColorMenuText(uState));

    clrBk = GetSysColor(ColorMenuBk(uState));
    SetTextColor(hdc, clrText);
    SetBkColor(hdc, clrBk);

    ExtTextOut(hdc, x, y, uFlagsETO, &this->rcLabel, psz, cch, NULL);

    // Draw the image

    if (GetBkColor(hdc) == ImageList_GetBkColor(himl))
        uStyleILD = ILD_NORMAL;     // Paint quicker
    else
        uStyleILD = ILD_TRANSPARENT;

    ImageList_Draw(himl, this->iImage, hdc, this->x, this->y, uStyleILD);
    }


/*----------------------------------------------------------
Purpose: Draw the icon image and label
Returns: --
Cond:    --
*/
void PRIVATE Dobj_DrawIconImage(
    LPDOBJ this,
    HDC hdc,
    UINT uState,
    int cxEllipses,
    int cyText,
    COLORREF clrBkgnd)
    {
    UINT uStyleILD;
    UINT uFlagsMDT;
    LPCSTR psz;
    char szIDS[MAXBUFLEN];

    if (IsFlagSet(this->uFlags, DOF_USEIDS))
        psz = SzFromIDS((UINT)this->lpvObject, szIDS, sizeof(szIDS));
    else
        psz = (LPCSTR)this->lpvObject;

    ASSERT(psz);

    // Draw the image
    //
    if (IsFlagClear(this->uFlags, DOF_IGNORESEL))
        {
        uStyleILD = GetImageDrawStyle(uState);
        uFlagsMDT = IsFlagSet(uState, ODS_SELECTED) ? MDT_SELECTED : MDT_DESELECTED;
        }
    else
        {
        uStyleILD = ILD_NORMAL;
        uFlagsMDT = MDT_DESELECTED;
        ClearFlag(uState, ODS_FOCUS);
        }

    ImageList_Draw(this->himl, this->iImage, hdc, this->x, this->y, uStyleILD);

    // Draw the file label.  Wrap if it is long.

    if (this->rcLabel.bottom - this->rcLabel.top > cyText)
        uFlagsMDT |= MDT_DRAWTEXT;
    
    MyDrawText(hdc, psz, &this->rcLabel, MDT_CENTER | uFlagsMDT, cyText, 
        cxEllipses, CLR_DEFAULT, clrBkgnd);

    // (uState may have been changed above)
    if (IsFlagSet(uState, ODS_FOCUS))
        DrawFocusRect(hdc, &this->rcLabel);
    }


#ifdef UNUSED
/*----------------------------------------------------------
Purpose: Draw a picture
Returns: --
Cond:    --
*/
void PRIVATE Dobj_DrawPicture(
    LPDOBJ this,
    HDC hdc,
    UINT uState,
    UINT uDrawStyle)
    {
    HIMAGELIST himl;
    HDC hdcMem;
    HBITMAP hbmp;
    BITMAP bm;
    RECT rc;
    int iImage;
    int cx;
    int x;
    int y;

    switch (this->uKind)
        {
    case DOK_BITMAP:
        hbmp = (HBITMAP)(DWORD)this->lpvObject;
        GetObject(hbmp, sizeof(BITMAP), &bm);
        cx = this->rcSrc.right - this->rcSrc.left;
        break;

    case DOK_ICON:
        cx = 32;
        break;
        }

    // We only align horizontally
    //
    y = this->y;
    if (IsFlagSet(this->uFlags, DOF_CENTER))
        x = this->x - (cx / 2);
    else if (IsFlagSet(this->uFlags, DOF_RIGHT))
        x = this->x - cx;
    else
        x = this->x;

    // Draw the object
    //
    switch (this->uKind)
        {
    case DOK_ICON:
        // BUGBUG: we don't handle DOF_DIFFER for icons
        DrawIcon(hdc, x, y, (HICON)(DWORD)this->lpvObject);
        break;

    case DOK_BITMAP:
        hdcMem = CreateCompatibleDC(hdc);
        if (hdcMem)
            {
            SIZE size;

            SelectBitmap(hdcMem, hbmp);
    
            size.cx = this->rcSrc.right - this->rcSrc.left;
            size.cy = this->rcSrc.bottom - this->rcSrc.top;

            if (IsFlagSet(this->uFlags, DOF_MENU) && 
                IsFlagSet(this->uFlags, DOF_DISABLED) && 
                IsFlagClear(uState, ODS_SELECTED))
                {
                COLORREF crOld;
    
                // For disabled menu strings (not selected), we draw the bitmap 
                //  twice.  The first is offset down and to the right and drawn 
                //  in the 3D hilight color.  The second time is the disabled 
                //  color in the normal offset.
                //
                crOld = SetTextColor(hdc, GetSysColor(COLOR_3DHILIGHT));
                BitBlt(hdc, x+1, y+1, size.cx, size.cy, hdcMem, this->rcSrc.left, 
                    this->rcSrc.top,  SRCCOPY);
    
                // Reset back to original color.  Also, turn off the opaqueness.
                //
                SetTextColor(hdc, crOld);
                }

            BitBlt(hdc, x, y, size.cx, size.cy, hdcMem, this->rcSrc.left, this->rcSrc.top,  SRCCOPY);
            DeleteDC(hdcMem);
            }
        break;
        }
    }
#endif

/*----------------------------------------------------------
Purpose: Draw a string
Returns: --
Cond:    --
*/
void PRIVATE Dobj_DrawString(
    LPDOBJ this,
    HDC hdc,
    UINT uState,
    int cxEllipses,
    int cyText)
    {
    UINT ufAlignSav;
                                               
    ASSERT(this);

    // Prep the alignment
    //
    if (this->uFlags & (DOF_LEFT | DOF_CENTER | DOF_RIGHT))
        {
        UINT ufMode;

        ufMode = IsFlagSet(this->uFlags, DOF_CENTER) ? TA_CENTER :
                 (IsFlagSet(this->uFlags, DOF_RIGHT) ? TA_RIGHT : TA_LEFT);
        ufAlignSav = SetTextAlign(hdc, ufMode);
        }

    // Draw the string
    //
    switch (this->uKind)
        {
    case DOK_IDS:
    case DOK_STRING:
        {
        char szBuf[MAXBUFLEN];
        LPSTR lpsz;
        UINT uflag = ETO_OPAQUE;

        if (this->uKind == DOK_IDS)
            lpsz = SzFromIDS((UINT)(DWORD)this->lpvObject, szBuf, sizeof(szBuf));
        else
            lpsz = (LPSTR)this->lpvObject;

        if (!IsRectEmpty(&this->rcClip))
            uflag |= ETO_CLIPPED;
        
        if (IsFlagSet(this->uFlags, DOF_MENU) && 
            IsFlagSet(this->uFlags, DOF_DISABLED) && 
            IsFlagClear(uState, ODS_SELECTED))
            {
            int imodeOld;
            COLORREF crOld;

            // For disabled menu strings (not selected), we draw the string 
            //  twice.  The first is offset down and to the right and drawn 
            //  in the 3D hilight color.  The second time is the disabled text
            //  color in the normal offset.
            //
            crOld = SetTextColor(hdc, GetSysColor(COLOR_3DHILIGHT));
            imodeOld = SetBkMode(hdc, TRANSPARENT);
            ExtTextOut(hdc, this->x+1, this->y+1, uflag, &this->rcClip, lpsz,
                lstrlen(lpsz), NULL);

            // Reset back to original color.  Also, turn off the opaqueness.
            //
            SetTextColor(hdc, crOld);
            uflag ^= ETO_OPAQUE;
            }

        ExtTextOut(hdc, this->x, this->y, uflag, &this->rcClip, lpsz,
            lstrlen(lpsz), NULL);
        }
        break;

    case DOK_SIDEITEM:
        SideItem_Display((LPSIDEITEM)this->lpvObject, hdc, &this->rcClip, 
            cxEllipses, cyText);
        break;
        }

    // Clean up
    //
    if (this->uFlags & (DOF_LEFT | DOF_CENTER | DOF_RIGHT))
        {
        SetTextAlign(hdc, ufAlignSav);
        }
    }


/*----------------------------------------------------------
Purpose: Draw an object
Returns: --
Cond:    --
*/
void PUBLIC Dobj_Draw(
    HDC hdc,
    LPDOBJ rgdobj,
    int cItems,
    UINT uState,            // ODS_*
    int cxEllipses,
    int cyText,
    COLORREF clrBkgnd)
    {
    UINT uDrawStyle;
    LPDOBJ pdobj;
    int i;

    ASSERT(rgdobj);

    for (i = 0, pdobj = rgdobj; i < cItems; i++, pdobj++)
        {
        if (IsFlagSet(pdobj->uFlags, DOF_NODRAW))
            continue ;
    
        uDrawStyle = Dobj_SetColors(pdobj, hdc, uState, clrBkgnd);

        // Draw the object
        //
        switch (pdobj->uKind)
            {
        case DOK_IMAGE:
            if (IsFlagSet(pdobj->uFlags, DOF_MENU))
                Dobj_DrawMenuImage(pdobj, hdc, uState, cyText, clrBkgnd);
            else
                Dobj_DrawIconImage(pdobj, hdc, uState, cxEllipses, cyText, clrBkgnd);
            break;

#ifdef UNUSED
        case DOK_BITMAP:
        case DOK_ICON:
            Dobj_DrawPicture(pdobj, hdc, uState, uDrawStyle);
            break;
#endif
    
        case DOK_IDS:
        case DOK_STRING:
        case DOK_SIDEITEM:
            Dobj_DrawString(pdobj, hdc, uState, cxEllipses, cyText);
            break;
            }
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\csc_bmpu.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    csc_bmpu.c

Abstract:

    This module implements the user mode utility functions of bitmaps
    associated with CSC files. CSC_BMP_U is an opaque structure. Must
    use the functions here to create/modify/destroy a CSC_BMP_U to
    ensure data integrity.  The 'u' in the filename means "usermode."

Author:

    Nigel Choi [t-nigelc]  Sept 3, 1999

--*/

#include "pch.h"

#ifdef CSC_ON_NT
#pragma hdrstop

#define UNICODE

#endif //CSC_ON_NT

#include "csc_bmpu.h"

 // append this to inode file name to get the stream name
LPTSTR CscBmpAltStrmName = TEXT(STRMNAME);

#ifdef DEBUG

#define CSC_BitmapKdPrint(__bit,__x) {\
    if (((CSC_BITMAP_KDP_##__bit)==0) || (CSC_BitmapKdPrintVector & (CSC_BITMAP_KDP_##__bit))) {\
    DEBUG_PRINT(__x);\
    }\
}
#define CSC_BITMAP_KDP_ALWAYS                0x00000000
#define CSC_BITMAP_KDP_REINT                 0x00000001
#define CSC_BITMAP_KDP_PRINTBITMAP           0x00000002

// static ULONG CSC_BitmapKdPrintVector = 0XFFFFFFFF;
static ULONG CSC_BitmapKdPrintVector = 0;

#else

#define CSC_BitmapKdPrint(__bit,__x) ;

#endif

/*++

    CSC_BitmapCreate()

Routine Description:

    Allocates an appropriate in-memory bitmap CSC_BITMAP_U with size
    corresponding to filesize.

Arguments:


Returns:

    NULL if memory allocation error.
    pointer to the newly allocated bitmap if successful.

Notes:


--*/
LPCSC_BITMAP_U
CSC_BitmapCreate(
    DWORD filesize)
{
    LPCSC_BITMAP_U bm;
    DWORD i;

    bm = (LPCSC_BITMAP_U)malloc(sizeof(CSC_BITMAP_U));

    if (bm == NULL)
        return NULL;

    bm->bitmapsize = filesize/BLOCKSIZE;
    if (filesize % BLOCKSIZE)
        bm->bitmapsize++;
    bm->numDWORD = bm->bitmapsize/(8*sizeof(DWORD));
    if (bm->bitmapsize % (8*sizeof(DWORD)))
        bm->numDWORD++;

    bm->reintProgress = 0; /* not reint yet */

    if (bm->bitmapsize) {
        bm->bitmap = (LPDWORD)malloc(bm->numDWORD*sizeof(DWORD));
        if (bm->bitmap == NULL) {
            free(bm);
            return NULL;
        }
        for (i = 0; i < bm->numDWORD; i++) {
          bm->bitmap[i] = 0;
        }
    } else {
        bm->bitmap = NULL;
    }

    return bm;
}

/*++

    CSC_BitmapDelete()

Routine Description:


Arguments:


Returns:


Notes:

--*/
void
CSC_BitmapDelete(
    LPCSC_BITMAP_U *lplpbitmap)
{
    if (lplpbitmap == NULL)
        return;
    if (*lplpbitmap == NULL)
        return;
    if ((*lplpbitmap)->bitmap)
        free((*lplpbitmap)->bitmap);
    free((*lplpbitmap));
    *lplpbitmap = NULL;
}

/*++

    CSC_BitmapIsMarked()

Routine Description:


Arguments:


Returns:

    -1 if lpbitmap is NULL or bitoffset is larger than the bitmap
    TRUE if the bit is marked
    FALSE if the bit is unmarked

Notes:

--*/
int
CSC_BitmapIsMarked(
    LPCSC_BITMAP_U lpbitmap,
    DWORD bitoffset)
{
    DWORD DWORDnum;
    DWORD bitpos;

    if (lpbitmap == NULL)
        return -1;
    if (bitoffset >= lpbitmap->bitmapsize)
        return -1;

    DWORDnum = bitoffset/(8*sizeof(DWORD));
    bitpos = 1 << bitoffset%(8*sizeof(DWORD));

    if (lpbitmap->bitmap[DWORDnum] & bitpos) {
        return TRUE;
    }

    return FALSE;
}

/*++

    CSC_BitmapGetBlockSize()

Routine Description:


Arguments:


Returns:

    The pre-defined block size represented by one bit of the bitmap.

Notes:

--*/
DWORD
CSC_BitmapGetBlockSize()
{
  return BLOCKSIZE;
}

/*++

    CSC_BitmapGetSize()

Routine Description:

Arguments:

Returns:

    -1 if lpbitmap is NULL.
    The size of the bitmap passed in.

Notes:

--*/
int
CSC_BitmapGetSize(
    LPCSC_BITMAP_U lpbitmap)
{
    if (lpbitmap == NULL)
        return -1;
    return lpbitmap->bitmapsize;
}

/*++

    CSC_BitmapStreamNameLen()

Routine Description:

    returns the length of the CSC stream name including the colon, in bytes.

Arguments:


Returns:


Notes:

    size is in bytes. 

--*/
int
CSC_BitmapStreamNameLen()
{
  return lstrlen(CscBmpAltStrmName);
}

/*++

    CSC_BitmapAppendStreamName()

Routine Description:

    Appends the CSC stream name to the existing path/file name fname.

Arguments:

    fname is the sting buffer containing the path/file.
    bufsize is the buffer size.

Returns:

    TRUE if append successful.
    FALSE if buffer is too small or other errors.

Notes:

    Single-byte strings only.

--*/
int
CSC_BitmapAppendStreamName(
    LPTSTR fname,
    DWORD bufsize)
{
    int ret = TRUE;

    if ((lstrlen(fname) + lstrlen(CscBmpAltStrmName) + 1) > (int)bufsize) {
        return FALSE;
    }

    __try {
        ret = TRUE;
        lstrcat(fname, CscBmpAltStrmName);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        ret = FALSE;
    }

    return ret;
}

/*++

    CSC_BitmapRead()

Routine Description:

    Reads the on-disk bitmap file, and if it exists, is not in use and valid,
    store it in *lplpbitmap. If *lplpbitmap is NULL allocate a new
    bitmap data structure. Otherwise, if *lplpbitmap is not NULL, the
    existing bitmap will be deleted and assigned the on-disk bitmap
    file.

Arguments:

    filename is the file that contains the bitmap. If read from a
    stream, append the stream name before passing the filename in. The
    filename is used as is and no checking of validity of the name is
    performed. For default stream name, append the global LPSTR
    CscBmpAltStrmName.

Returns:

    1 if read successful
    0 if lplpbitmap is NULL
    -1 if error in disk operation (open/read), memory allocating error,
          or invalid bitmap file format.
    -2 if bitmap not exist

Notes:

    CODE.IMPROVEMENT design a better error message propagation mechanism.
    Bitmap open for exclusive access.

--*/
int
CSC_BitmapRead(
    LPCSC_BITMAP_U *lplpbitmap,
    LPCTSTR filename)
{
    CscBmpFileHdr hdr;
    HANDLE bitmapFile;
    DWORD bytesRead;
    DWORD bitmapByteSize;
    DWORD * bitmapBuf = NULL;
    DWORD errCode;
    int ret = 1;

    if (lplpbitmap == NULL)
        return 0;

    bitmapFile = CreateFile(
                    filename,
                    GENERIC_READ,
                    0, // No sharing; exclusive
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
    if (bitmapFile == INVALID_HANDLE_VALUE) {
        errCode = GetLastError();
        if (errCode == ERROR_FILE_NOT_FOUND) {
            // File does not exist
            return -2;
        }
        return -1;
    }

    if (!ReadFile(
            bitmapFile,
            &hdr, 
            sizeof(CscBmpFileHdr),
            &bytesRead, NULL)
    ) {
        ret = -1;
        goto CLOSEFILE;
    }

    if (
        bytesRead != sizeof(CscBmpFileHdr)
            ||
        hdr.magicnum != MAGICNUM
            ||
        !hdr.valid
            ||
        hdr.inuse
    ) {
        ret = -1;
        goto CLOSEFILE;
    }

    if (hdr.sizeinbits > 0) {
        bitmapByteSize = hdr.numDWORDs*sizeof(DWORD);
        bitmapBuf = (DWORD *)malloc(bitmapByteSize);
        if (!bitmapBuf) {
            ret = -1;
            goto CLOSEFILE;
        }

        if (!ReadFile(
                bitmapFile,
                bitmapBuf,
                bitmapByteSize,
                &bytesRead,
                NULL)
        ) {
            ret = -1;
            goto CLOSEFILE;
        }

        if (bytesRead != bitmapByteSize) {
            ret = -1;
            goto CLOSEFILE;
        }
    }

    if (*lplpbitmap) {
        // bitmap exist, dump old and create new
        if ((*lplpbitmap)->bitmap)
            free((*lplpbitmap)->bitmap);
            (*lplpbitmap)->bitmap = bitmapBuf;
            (*lplpbitmap)->numDWORD = hdr.numDWORDs;
            (*lplpbitmap)->bitmapsize = hdr.sizeinbits;
    } else {
        // bitmap not exist, create brand new
        *lplpbitmap = (LPCSC_BITMAP_U)malloc(sizeof(CSC_BITMAP_U));
        if (!(*lplpbitmap)) {
            // Error in memory allocation
            ret = -1;
            goto CLOSEFILE;
        }
        (*lplpbitmap)->bitmap = bitmapBuf;
        (*lplpbitmap)->numDWORD = hdr.numDWORDs;
        (*lplpbitmap)->bitmapsize = hdr.sizeinbits;
    }
    (*lplpbitmap)->reintProgress = 0; /* not reint yet */

CLOSEFILE:
    CloseHandle(bitmapFile);

    return ret;
}

/*++

    CSC_BitmapReint()

Routine Description:

    Copy a chunk of srcH to dstH. Offset depends on lpbitmap. Size of
    chunk depends on buffSize. May have to call several times to get
    srcH and dstH fully synchronized. lpbitmap remembers where the last
    CSC_BitmapReint call got to. See description of Return value below
    about how to know when to call again or stop calling.

Arguments:

    lpbitmap  the bitmap must not be zero, otherwise can't keep track of reint 
                progress
    srcH      the handle of the source file. See notes below
    dstH      the handle of the destination file. See notes below
    buff      user-supplied buffer
    buffSize  size of the user-supplied buffer. See notes below
    lpbytesXfered Returns how many bytes are transferred, optional.

Returns:

    CSC_BITMAPReintInvalid lpbitmap or buff is NULL, or srcH or dstH is invalid
    CSC_BITMAPReintError Error in transferring data
    CSC_BITMAPReintCont  made some progress, call CSC_BITMAPReint again
                       to continue Reint
    CSC_BITMAPReintDone  Done Reint, don't need to call again

Notes:

    srcH and dstH MUST NOT be opened with FILE_FLAG_OVERLAPPED 
                                   or FILE_FLAG_NO_BUFFERING
    buffSize must be at least 2 times greater than BLOCKSIZE

--*/
int
CSC_BitmapReint(
    LPCSC_BITMAP_U lpbitmap,
    HANDLE srcH,
    HANDLE dstH,
    LPVOID buff,
    DWORD buffSize,
    DWORD * lpbytesXfered)
{
    DWORD bitoffset;
    DWORD DWORDoffset;
    DWORD bitmask;
    DWORD bytes2cpy = 0;
    DWORD bytesActuallyRead, bytesActuallyCopied;
    DWORD startFileOffset = 0;
    DWORD fileSize;
    BOOL seen1b4 = FALSE;
    int ret = CSC_BITMAPReintCont;

    if (lpbitmap == NULL || buff == NULL) {
        return CSC_BITMAPReintInvalid;
    }
    if (srcH == INVALID_HANDLE_VALUE || dstH == INVALID_HANDLE_VALUE) {
        return CSC_BITMAPReintInvalid;
    }

    CSC_BitmapKdPrint(
            REINT,
            ("***CSC_BitmapReint reintProgress: %u\n",
            lpbitmap->reintProgress));

    startFileOffset = lpbitmap->reintProgress;
    bitoffset = startFileOffset/BLOCKSIZE;
    startFileOffset = bitoffset * BLOCKSIZE; // make sure startFileOffset is 
    // aligned with BLOCKSIZE
    DWORDoffset = bitoffset/(sizeof(DWORD)*8);
    bitmask = 1 << bitoffset%(sizeof(DWORD)*8);

    while (bytes2cpy < buffSize && bitoffset < lpbitmap->bitmapsize) {
        // the loop
        if ((bitmask & lpbitmap->bitmap[DWORDoffset]) != 0) {
            // the bit is marked
            if (!seen1b4) {
                // seeing first bit of a consecutive chunk of 1's
                startFileOffset = bitoffset * BLOCKSIZE;
                bytes2cpy += BLOCKSIZE;
                seen1b4 = TRUE;
            } else {
                // seeing the rest of the bits of a consecutive chunk of 1's
                // other than the first one
                bytes2cpy += BLOCKSIZE;
            }
        } else {
            // this bit is not marked
            if (seen1b4) {
                // first 0 after a chunk of consecutive 1's
                break;
            }
        }
        // Advance bitmap index
        bitoffset++;
        bitmask = bitmask << 1;
        if (bitmask == 0) {
            bitmask = 1;
            DWORDoffset++;
        }
    } // while

    if (bytes2cpy > buffSize) {
        bytes2cpy = buffSize;
    }

    // if never seen 1's then must have reached end of bitmap
    // Can't get Assert to compile!?
    // Assert(seen1b4 || (!seen1b4 && (bitoffset >= lpbitmap->bitmapsize)));
    /*
    CSC_BitmapKdPrint(
        REINT,
        ("Must be true, csc_bmpu.c, CSC_BitmapReint: %s\n",
        (seen1b4 || (!seen1b4 && (bitoffset >= lpbitmap->bitmapsize)))?
        "TRUE":"FALSE"));
    */

    CSC_BitmapKdPrint(
        REINT,
        ("startFileOffset: %u bytes2cpy: %u\n",
        startFileOffset,
        bytes2cpy));

    fileSize = GetFileSize(srcH, NULL);
    if (fileSize == 0xFFFFFFFF) {
        // if cannot get filesize, just be conservative on
        // what needs to be copied, ie, copy as much as possible
        if (seen1b4) {
            // Seen 1's before
            if (bitoffset >= lpbitmap->bitmapsize) {
                // copying until end of bitmap, copy as much as possible
                bytes2cpy = buffSize;
            }
        } else {
            // not seen 1's before, copy from the last block represented
            // by bitmap for as many bytes as possible
            startFileOffset = (lpbitmap->bitmapsize)?  ((lpbitmap->bitmapsize-1)*BLOCKSIZE):0;
            bytes2cpy = buffSize;
        }
    } else { // filesize == 0xFFFFFFFF
        if (startFileOffset >= fileSize) {
            // Obviously done
            return CSC_BITMAPReintDone;
        }
        if (!seen1b4) {
            // never seen 1's
            if ((bitoffset * BLOCKSIZE) >= fileSize) {
                // bitmap is accurate representation of the file, or bitmap is larger
                // bitoffset should be pointing to last bit of the bitmap + 1
                // see ASSERT above
                return CSC_BITMAPReintDone;
            } else {
                // bitmap is shorter than the file, copy the rest of the file
                if (startFileOffset < lpbitmap->bitmapsize*BLOCKSIZE) {
                    startFileOffset = (lpbitmap->bitmapsize)?
                    ((lpbitmap->bitmapsize-1)*BLOCKSIZE):0;
                }
                bytes2cpy = fileSize - startFileOffset;
                if (bytes2cpy > buffSize) {
                    bytes2cpy = buffSize;
                }
            }
        } else { // if !seen1b4
            // seen 1's
            if (bitoffset >= lpbitmap->bitmapsize) {
                // end of bitmap
                if (bitoffset * BLOCKSIZE < fileSize) {
                    // bitmap is too small compared to real file
                    bytes2cpy = fileSize - startFileOffset;
                    if (bytes2cpy > buffSize) {
                        bytes2cpy = buffSize;
                    }
                } else {
                    ret = CSC_BITMAPReintDone;
                }
            }
        }
    } // fileSize != 0xffffffff

    CSC_BitmapKdPrint(REINT, ("new startFileOffset: %u new bytes2cpy: %u\n",
    startFileOffset, bytes2cpy));

    //Assert(bytes2cpy <= buffSize);

    // Copy Contents

    //****** SET FILE POINTERS!!
    if (SetFilePointer(
            srcH, 
            startFileOffset,
            NULL,
            FILE_BEGIN) == INVALID_SET_FILE_POINTER
    ) {
        return CSC_BITMAPReintError;
    }
    if (!ReadFile(srcH, buff, bytes2cpy, &bytesActuallyRead, NULL)) {
        return CSC_BITMAPReintError;
    }
    if (bytesActuallyRead > 0) {
        if (SetFilePointer(
                dstH, 
                startFileOffset,
                NULL,
                FILE_BEGIN) == INVALID_SET_FILE_POINTER
        ) {
            return CSC_BITMAPReintError;
        }
        if (!WriteFile(
                dstH,
                buff,
                bytesActuallyRead,
            &bytesActuallyCopied, NULL)
        ) {
            return CSC_BITMAPReintError;
        }
    }

    // If copied all data or none read, done.
    if (
        (fileSize != 0xFFFFFFFF && (startFileOffset + bytesActuallyCopied) == fileSize)
            ||
        bytesActuallyRead == 0
    ) {
        ret = CSC_BITMAPReintDone;
    }

    CSC_BitmapKdPrint(
        REINT,
        ("bytesActuallyRead: %u bytesActuallyCopied: %u\n",
        bytesActuallyRead,
        bytesActuallyCopied));

    lpbitmap->reintProgress = startFileOffset + bytesActuallyCopied;

    CSC_BitmapKdPrint(
        REINT,
        ("***CSC_BitmapReint New reintProgress: %u\n",
        lpbitmap->reintProgress));

    if (lpbytesXfered) {
        *lpbytesXfered = bytesActuallyCopied;
    }

    return ret;
}

#ifdef DEBUG
/*++

    CSC_BitmapOutput()

Routine Description:

    Outputs the passed in bitmap to kd

Arguments:


Returns:


Notes:


--*/
VOID
CSC_BitmapOutput(
    LPCSC_BITMAP_U lpbitmap)
{
    DWORD i;

    if (lpbitmap == NULL) {
        CSC_BitmapKdPrint( PRINTBITMAP, ("lpbitmap is NULL\n"));
        return;
    }

    CSC_BitmapKdPrint(
        PRINTBITMAP,
        ( "lpbitmap 0x%08x, bitmapsize 0x%x (%u) bits, numDWORD 0x%x (%u)\n",
            lpbitmap, 
            lpbitmap->bitmapsize, 
            lpbitmap->bitmapsize, 
            lpbitmap->numDWORD,
            lpbitmap->numDWORD));
    CSC_BitmapKdPrint(
        PRINTBITMAP,
            ( "bitmap  |0/5        |1/6        |2/7        |3/8        |4/9\n"));
    CSC_BitmapKdPrint(
        PRINTBITMAP,
            ("number  |01234|56789|01234|56789|01234|56789|01234|56789|01234|56789"));
    for (i = 0; i < lpbitmap->bitmapsize; i++) {
        if ((i % 50) == 0)
            CSC_BitmapKdPrint(PRINTBITMAP, ( "\n%08d", i));
        if ((i % 5) == 0)
            CSC_BitmapKdPrint(PRINTBITMAP, ( "|"));
        CSC_BitmapKdPrint(
            PRINTBITMAP,
            ( "%1d", CSC_BitmapIsMarked(lpbitmap, i)));
    }
    CSC_BitmapKdPrint(PRINTBITMAP, ( "\n"));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\csc_bmpu.h ===
/*++

    Copyright (c) 2000 Microsoft Corporation

Module Name:

    csc_bmpu.h

Abstract:

    Interface to the user mode utility functions of bitmaps
    associated with CSC files. The 'u' in the file name means "usermode"

Author:

    Nigel Choi [t-nigelc]  Sept 3, 1999

--*/

#ifndef _CSC_BITMAP_H_
#define _CSC_BITMAP_H_

#include "csc_bmpc.h"

// The _U is used to distinguish this from the kernel mode CSC_BITMAP

typedef struct _CSC_BITMAP_U {
    DWORD bitmapsize;    // size in bits. How many bits effective in the bitmap
    DWORD numDWORD;      // how many DWORDs to accomodate the bitmap
    DWORD reintProgress; // last fileoffset Reint copies + 1, initially 0 
    LPDWORD bitmap;      // The bitmap itself
} CSC_BITMAP_U, *LPCSC_BITMAP_U, *PCSC_BITMAP_U;

extern LPTSTR CscBmpAltStrmName;

LPCSC_BITMAP_U
CSC_BitmapCreate(
    DWORD filesize);

VOID
CSC_BitmapDelete(
    LPCSC_BITMAP_U *lplpbitmap);

int
CSC_BitmapIsMarked(
    LPCSC_BITMAP_U lpbitmap,
    DWORD bitoffset);

DWORD
CSC_BitmapGetBlockSize();

int
CSC_BitmapGetSize(
    LPCSC_BITMAP_U lpbitmap);

int
CSC_BitmapStreamNameLen();

int
CSC_BitmapAppendStreamName(
    LPTSTR fname,
    DWORD bufsize);

int
CSC_BitmapRead(
    LPCSC_BITMAP_U *lplpbitmap,
    LPCTSTR filename);

#define CSC_BITMAPReintInvalid  0
#define CSC_BITMAPReintError    1
#define CSC_BITMAPReintCont     2
#define CSC_BITMAPReintDone     3

int
CSC_BitmapReint(
    LPCSC_BITMAP_U lpbitmap,
    HANDLE srcH,
    HANDLE dstH,
    LPVOID buff,
    DWORD buffSize,
    DWORD * bytesRead);

#ifdef DEBUG
VOID
CSC_BitmapOutput(
    LPCSC_BITMAP_U lpbitmap);
#else
#define CSC_BitmapOutput(x) NOTHING;
#endif

#endif //#define _CSC_BITMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\err.c ===
#include "pch.h"

#include "extra.h"

// Debugging variables
UINT g_uBreakFlags = 0;         // Controls when to int 3
UINT g_uTraceFlags = 0;         // Controls what trace messages are spewed
UINT g_uDumpFlags = 0;          // Controls what structs get dumped

char const FAR c_szAssertFailed[] = "BRIEFCASE  Assertion failed in %s on line %d\r\n";

/*----------------------------------------------------------
Purpose: Returns a string safe enough to print...and I don't
mean swear words.

Returns: String ptr
Cond:    --
*/
LPCSTR PUBLIC Dbg_SafeStr(LPCSTR psz)
{
	if (psz)
		return psz;
	else
		return "NULL";
}

void PUBLIC BrfAssertFailed(
    LPCSTR pszFile, 
    int line)
    {
    LPCSTR psz;
    char ach[256];
    UINT uBreakFlags;

// tHACK    ENTEREXCLUSIVE()
        {
        uBreakFlags = g_uBreakFlags;
        }
//    LEAVEEXCLUSIVE()

    // Strip off path info from filename string, if present.
    //
    for (psz = pszFile + lstrlen(pszFile); psz != pszFile; psz=AnsiPrev(pszFile, psz))
        {
#ifdef  DBCS
        if ((AnsiPrev(pszFile, psz) != (psz-2)) && *(psz - 1) == '\\')
#else
        if (*(psz - 1) == '\\')
#endif
            break;
        }
    wsprintf(ach, c_szAssertFailed, psz, line);
    OutputDebugString(ach);
    
    if (IsFlagSet(uBreakFlags, BF_ONVALIDATE))
        DebugBreak();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\list.c ===
/*****************************************************************************
 *	This is a poor list.  Insert only of a (node *).data with no ordering.
 *	To create the list (and insert 1 item), call insertList(NULL, blah, blah...)
 */

#include "pch.h"
#include "lib3.h"
#include "list.h"

AssertData;
AssertError;

void killList(node *thisList)
{
	node *currRoot=thisList,*last;

	while(currRoot) {
		last = currRoot;
		currRoot = currRoot->next;
		FreeCopyParams(last->lpCP);
		GlobalFree(last);
	}
}

/*
	insert a node.  Small bug: if mem alloc fails for CopyParams, the list will
	have 1 extra fluff node at the end.
*/
node *
insertList(
	node 				**thisList,
	LPCOPYPARAMS 		aNode,
	LPSHADOWINFO 		lpSI,
	LPWIN32_FIND_DATA	lpFind32Local,
	LPWIN32_FIND_DATA	lpFind32Remote,
	int 				iShadowStatus,
	int 				iFileStatus,
	unsigned int 		uAction)
{
	node *startItem = *thisList;
	node *currItem = startItem;

	if(startItem) {
		while(currItem->next)
			currItem = currItem->next;
		if(!(currItem->next = (node *) GlobalAlloc(GPTR,sizeof(node))))
			return NULL;
		currItem = currItem->next;
	} else {
		if(!(startItem = (node *) GlobalAlloc(GPTR,sizeof(node))))
			return NULL;
		currItem = startItem;
		*thisList = currItem;
	}

	if(!(currItem->lpCP = LpAllocCopyParams())) {
		GlobalFree(currItem);
		return 0;
	}
	currItem->lpCP->hShare = aNode->hShare;
	currItem->lpCP->hDir = aNode->hDir;
	currItem->lpCP->hShadow = aNode->hShadow;
	lstrcpy(currItem->lpCP->lpLocalPath, aNode->lpLocalPath);
	lstrcpy(currItem->lpCP->lpSharePath, aNode->lpSharePath);
	lstrcpy(currItem->lpCP->lpRemotePath, aNode->lpRemotePath);
	currItem->iShadowStatus = iShadowStatus;
	currItem->iFileStatus = iFileStatus;
	currItem->uAction = uAction;
	memcpy(&(currItem->sSI), lpSI, sizeof(SHADOWINFO));
	currItem->sSI.lpFind32 = NULL;

	memcpy(&(currItem->sFind32Local), lpFind32Local, sizeof(WIN32_FIND_DATA));

	if (lpFind32Remote)
	{
        Assert(sizeof(currItem->sFind32Remote) == sizeof(*lpFind32Remote));

        currItem->sFind32Remote = *lpFind32Remote;

	}
	else
	{
		memset(&(currItem->sFind32Remote), 0, sizeof(currItem->sFind32Remote));
	}

	currItem->next = (node *) NULL;
	return startItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\err.h ===
// Debugging macros
//

#define DEBUG_CASE_STRING(x)    case x: return #x

// Dump flags used in g_uDumpFlags
//
#define DF_RECLIST      0x0001
#define DF_RECITEM      0x0002
#define DF_RECNODE      0x0004
#define DF_CREATETWIN   0x0008
#define DF_ATOMS        0x0010
#define DF_CRL          0x0020
#define DF_CBS          0x0040
#define DF_CPATH        0x0080
#define DF_PATHS        0x0100
#define DF_UPDATECOUNT  0x0200
#define DF_TWINPAIR     0x0400
#define DF_FOLDERTWIN   0x0800
#define DF_CHOOSESIDE   0x1000

// Break flags used in g_uBreakFlags
//
#define BF_ONOPEN       0x0001
#define BF_ONCLOSE      0x0002
#define BF_ONRUNONCE    0x0004
#define BF_ONVALIDATE   0x0010
#define BF_ONTHREADATT  0x0100
#define BF_ONTHREADDET  0x0200
#define BF_ONPROCESSATT 0x0400
#define BF_ONPROCESSDET 0x0800

// Trace flags used in g_uTraceFlags (defined in retail on purpose)
//
#define TF_ALWAYS       0x0000
#define TF_WARNING      0x0001
#define TF_ERROR        0x0002
#define TF_GENERAL      0x0004      // Standard briefcase trace messages
#define TF_FUNC         0x0008      // Trace function calls
#define TF_CACHE        0x0010      // Cache-specific trace messages
#define TF_ATOM         0x0020      // Atom-specific trace messages

LPCSTR PUBLIC Dbg_SafeStr(LPCSTR psz);

#ifdef DEBUG

#define DEBUG_CASE_STRING(x)    case x: return #x

#define ASSERTSEG

// Use this macro to declare message text that will be placed
// in the CODE segment (useful if DS is getting full)
//
// Ex: DEBUGTEXT(szMsg, "Invalid whatever: %d");
//
#define DEBUGTEXT(sz, msg)	/* ;Internal */ \
    static const char ASSERTSEG sz[] = msg;

void PUBLIC BrfAssertFailed(LPCSTR szFile, int line);
void CPUBLIC BrfAssertMsg(BOOL f, LPCSTR pszMsg, ...);
void CPUBLIC BrfDebugMsg(UINT mask, LPCSTR pszMsg, ...);

// ASSERT(f)  -- Generate "assertion failed in line x of file.c"
//               message if f is NOT true.
//
#define ASSERT(f)                                                       \
    {                                                                   \
        DEBUGTEXT(szFile, __FILE__);                                    \
        if (!(f))                                                       \
            BrfAssertFailed(szFile, __LINE__);                          \
    }
#define ASSERT_E(f)  ASSERT(f)

// ASSERT_MSG(f, msg, args...)  -- Generate wsprintf-formatted msg w/params
//                          if f is NOT true.
//
#define ASSERT_MSG   BrfAssertMsg

// DEBUG_MSG(mask, msg, args...) - Generate wsprintf-formatted msg using
//                          specified debug mask.  System debug mask
//                          governs whether message is output.
//
#define DEBUG_MSG    BrfDebugMsg
#define TRACE_MSG    DEBUG_MSG

// VERIFYSZ(f, msg, arg)  -- Generate wsprintf-formatted msg w/ 1 param
//                          if f is NOT true 
//
#define VERIFYSZ(f, szFmt, x)   ASSERT_MSG(f, szFmt, x)


// VERIFYSZ2(f, msg, arg1, arg2)  -- Generate wsprintf-formatted msg w/ 2
//                          param if f is NOT true 
//
#define VERIFYSZ2(f, szFmt, x1, x2)   ASSERT_MSG(f, szFmt, x1, x2)



// DBG_ENTER(szFn)  -- Generates a function entry debug spew for
//                          a function 
//
#define DBG_ENTER(szFn)                  \
    TRACE_MSG(TF_FUNC, " > " szFn "()")


// DBG_ENTER_SZ(szFn, sz)  -- Generates a function entry debug spew for
//                          a function that accepts a string as one of its
//                          parameters.
//
#define DBG_ENTER_SZ(szFn, sz)                  \
    TRACE_MSG(TF_FUNC, " > " szFn "(..., \"%s\",...)", Dbg_SafeStr(sz))


// DBG_ENTER_DTOBJ(szFn, pdtobj, szBuf)  -- Generates a function entry 
//                          debug spew for a function that accepts a 
//                          string as one of its parameters.
//
#define DBG_ENTER_DTOBJ(szFn, pdtobj, szBuf) \
    TRACE_MSG(TF_FUNC, " > " szFn "(..., %s,...)", Dbg_DataObjStr(pdtobj, szBuf))


// DBG_ENTER_RIID(szFn, riid)  -- Generates a function entry debug spew for
//                          a function that accepts an riid as one of its
//                          parameters.
//
#define DBG_ENTER_RIID(szFn, riid)                  \
    TRACE_MSG(TF_FUNC, " > " szFn "(..., %s,...)", Dbg_GetRiidName(riid))


// DBG_EXIT(szFn)  -- Generates a function exit debug spew 
//
#define DBG_EXIT(szFn)                              \
        TRACE_MSG(TF_FUNC, " < " szFn "()")

// DBG_EXIT_US(szFn, us)  -- Generates a function exit debug spew for
//                          functions that return a USHORT.
//
#define DBG_EXIT_US(szFn, us)                       \
        TRACE_MSG(TF_FUNC, " < " szFn "() with %#x", (USHORT)us)

// DBG_EXIT_UL(szFn, ul)  -- Generates a function exit debug spew for
//                          functions that return a ULONG.
//
#define DBG_EXIT_UL(szFn, ul)                   \
        TRACE_MSG(TF_FUNC, " < " szFn "() with %#lx", (ULONG)ul)

// DBG_EXIT_PTR(szFn, pv)  -- Generates a function exit debug spew for
//                          functions that return a pointer.
//
#define DBG_EXIT_PTR(szFn, pv)                   \
        TRACE_MSG(TF_FUNC, " < " szFn "() with %#lx", (LPVOID)pv)

// DBG_EXIT_HRES(szFn, hres)  -- Generates a function exit debug spew for
//                          functions that return an HRESULT.
//
#define DBG_EXIT_HRES(szFn, hres)                   \
        TRACE_MSG(TF_FUNC, " < " szFn "() with %s", Dbg_GetScode(hres))


#else

#define ASSERT(f)
#define ASSERT_E(f)      (f)
#define ASSERT_MSG   1 ? (void)0 : (void)
#define DEBUG_MSG    1 ? (void)0 : (void)
#define TRACE_MSG    1 ? (void)0 : (void)

#define VERIFYSZ(f, szFmt, x)     (f)

#define DBG_ENTER(szFn)
#define DBG_ENTER_SZ(szFn, sz)
#define DBG_ENTER_DTOBJ(szFn, pdtobj, sz)
#define DBG_ENTER_RIID(szFn, riid)   

#define DBG_EXIT(szFn)                            
#define DBG_EXIT_US(szFn, us)
#define DBG_EXIT_UL(szFn, ul)
#define DBG_EXIT_PTR(szFn, ptr)                            
#define DBG_EXIT_HRES(szFn, hres)   

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\extra.h ===
#ifndef __EXTRA_H__
#define __EXTRA_H__
/* hacked headers from filesync... */

#define PUBLIC          FAR PASCAL
#define CPUBLIC         FAR _cdecl
#define PRIVATE         NEAR PASCAL

#define MAXBUFLEN       260
#define MAXMSGLEN       520
#define MAXMEDLEN       64
#define MAXSHORTLEN     32

#define NULL_CHAR       '\0'

#define DPA_ERR         (-1)
#define DPA_APPEND      0x7fff

#define CRL_FLAGS       CRL_FL_DELETE_DELETED_TWINS

/* err.h */
#include "err.h"

/* port32.h */

#ifndef CSC_ON_NT
/* void Cls_OnContextMenu(HWND hwnd, HWND hwndClick, int x, int y) */
#define HANDLE_WM_CONTEXTMENU(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam)), 0L)
#endif

void InitializeAll(WPARAM wParam);

/* globals...*/
extern UINT g_uDumpFlags;          // Controls what structs get dumped

extern int g_cxIconSpacing;
extern int g_cyIconSpacing;
extern int g_cxBorder;
extern int g_cyBorder;

extern int g_cxMargin;
extern int g_cxIcon;
extern int g_cyIcon;
extern int g_cxIconMargin;
extern int g_cyIconMargin;

extern int g_cxLabelMargin;
extern int g_cyLabelSpace;

extern char const FAR c_szWinHelpFile[];

// Debugging variables
extern UINT g_uBreakFlags;         // Controls when to int 3
extern UINT g_uTraceFlags;         // Controls what trace messages are spewed
extern UINT g_uDumpFlags;          // Controls what structs get dumped


/* brfprv.h */
void    PUBLIC PathMakePresentable(LPSTR pszPath);
UINT    PUBLIC PathGetLocality(LPCSTR pszPath, LPSTR pszBuf);
LPSTR   PUBLIC PathFindNextComponentI(LPCSTR lpszPath);

// Path locality values, relative to a briefcase
//
#define PL_FALSE   0       // path is not related at all to a briefcase
#define PL_ROOT    1       // path directly references the root of a briefcase
#define PL_INSIDE  2       // path is somewhere inside a briefcase


/* comm.h */

LPSTR PUBLIC _ConstructMessageString(HINSTANCE hinst, LPCSTR pszMsg, va_list *ArgList);

BOOL PUBLIC ConstructMessage(LPSTR * ppsz, HINSTANCE hinst, LPCSTR pszMsg, ...);


// Flags for MyDrawText()
#define MDT_DRAWTEXT        0x00000001                                  
#define MDT_ELLIPSES        0x00000002                                  
#define MDT_LINK            0x00000004                                  
#define MDT_SELECTED        0x00000008                                  
#define MDT_DESELECTED      0x00000010                                  
#define MDT_DEPRESSED       0x00000020                                  
#define MDT_EXTRAMARGIN     0x00000040                                  
#define MDT_TRANSPARENT     0x00000080
#define MDT_LEFT            0x00000100
#define MDT_RIGHT           0x00000200
#define MDT_CENTER          0x00000400
#define MDT_VCENTER         0x00000800
#define MDT_CLIPPED         0x00001000

void PUBLIC MyDrawText(HDC hdc, LPCSTR pszText, RECT FAR* prc, UINT flags, int cyChar, int cxEllipses, COLORREF clrText, COLORREF clrTextBk);

void PUBLIC FileTimeToDateTimeString(LPFILETIME pft, LPSTR pszBuf, int cchBuf);

// Copies psz into *ppszBuf and (re)allocates *ppszBuf accordingly
BOOL PUBLIC GSetString(LPSTR * ppszBuf, LPCSTR psz);

// FileInfo struct that contains file time/size info
//
typedef struct _FileInfo
{
	HICON   hicon;
	FILETIME ftMod;
	DWORD   dwSize;         // size of the file
	DWORD   dwAttributes;   // attributes
	LPARAM  lParam;
	LPSTR   pszDisplayName; // points to the display name
	char    szPath[1];      
} FileInfo;

#define FIGetSize(pfi)          ((pfi)->dwSize)
#define FIGetPath(pfi)          ((pfi)->szPath)
#define FIGetDisplayName(pfi)   ((pfi)->pszDisplayName)
#define FIGetAttributes(pfi)    ((pfi)->dwAttributes)
#define FIIsFolder(pfi)         (IsFlagSet((pfi)->dwAttributes, SFGAO_FOLDER))

#ifndef REINT
// tHACK to not cause warnings in reint.c because of this def later in shdsys.h
#define SetFlag(obj, f)             do {obj |= (f);} while (0)
#define ToggleFlag(obj, f)          do {obj ^= (f);} while (0)
#define ClearFlag(obj, f)           do {obj &= ~(f);} while (0)
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))  
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))  
#endif

// Flags for FICreate
#define FIF_DEFAULT     0x0000
#define FIF_ICON        0x0001
#define FIF_DONTTOUCH   0x0002

HRESULT PUBLIC FICreate(LPCSTR pszPath, FileInfo ** ppfi, UINT uFlags);
BOOL    PUBLIC FISetPath(FileInfo ** ppfi, LPCSTR pszPathNew, UINT uFlags);
BOOL    PUBLIC FIGetInfoString(FileInfo * pfi, LPSTR pszBuf, int cchBuf);
void    PUBLIC FIFree(FileInfo * pfi);


//
// Non-shared memory allocation
//

//      void * GAlloc(DWORD cbBytes)
//          Alloc a chunk of memory, quickly, with no 64k limit on size of
//          individual objects or total object size.  Initialize to zero.
//
#define GAlloc(cbBytes)         GlobalAlloc(GPTR, cbBytes)

//      void * GReAlloc(void * pv, DWORD cbNewSize)
//          Realloc one of above.  If pv is NULL, then this function will do
//          an alloc for you.  Initializes new portion to zero.
//
#define GReAlloc(pv, cbNewSize) GlobalReAlloc(pv, cbNewSize, GMEM_MOVEABLE | GMEM_ZEROINIT)

//      void GFree(void *pv)
//          Free pv if it is nonzero.  Set pv to zero.  
//
#define GFree(pv)        do { (pv) ? GlobalFree(pv) : (void)0;  pv = NULL; } while (0)

//      DWORD GGetSize(void *pv)
//          Get the size of a block allocated by Alloc()
//
#define GGetSize(pv)            GlobalSize(pv)

//      type * GAllocType(type);                    (macro)
//          Alloc some memory the size of <type> and return pointer to <type>.
//
#define GAllocType(type)                (type *)GAlloc(sizeof(type))

//      type * GAllocArray(type, int cNum);         (macro)
//          Alloc an array of data the size of <type>.
//
#define GAllocArray(type, cNum)          (type *)GAlloc(sizeof(type) * (cNum))

//      type * GReAllocArray(type, void * pb, int cNum);
//
#define GReAllocArray(type, pb, cNum)    (type *)GReAlloc(pb, sizeof(type) * (cNum))

// Color macros
//
#define ColorText(nState)   (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT)
#define ColorBk(nState)     (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHT : COLOR_WINDOW)
#define ColorMenuText(nState)   (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHTTEXT : COLOR_MENUTEXT)
#define ColorMenuBk(nState)     (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHT : COLOR_MENU)
#define GetImageDrawStyle(nState)   (((nState) & ODS_SELECTED) ? ILD_SELECTED : ILD_NORMAL)

#define CCH_NUL                     (sizeof(TCHAR))
#define CbFromCch(cch)              ((cch)*sizeof(TCHAR))

/* strings.h */
LPSTR PUBLIC SzFromIDS (UINT ids, LPSTR pszBuf, UINT cchBuf);
#define IsSzEqual(sz1, sz2)         (BOOL)(lstrcmpi(sz1, sz2) == 0)

/* comm.h */
VOID PUBLIC SetRectFromExtent(HDC hdc, LPRECT lprc, LPCSTR lpcsz);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\extra.c ===
#include "pch.h"

#ifndef CSC_ON_NT
#define MyStrChr            StrChr
#define MyPathIsUNC(lpT)    PathIsUNC(lpT)
#endif

#include "extra.h"

// System colors
COLORREF g_clrHighlightText = 0;
COLORREF g_clrHighlight = 0;
COLORREF g_clrWindowText = 0;
COLORREF g_clrWindow = 0;

HBRUSH g_hbrHighlight = 0;
HBRUSH g_hbrWindow = 0;

char const FAR c_szEllipses[] = "...";
BOOL PUBLIC PathExists(
    LPCSTR pszPath);

/*----------------------------------------------------------
Purpose: Get the system metrics we need
Returns: --
Cond:    --
*/
void PRIVATE GetMetrics(
    WPARAM wParam)      // wParam from WM_WININICHANGE
    {
    if ((wParam == 0) || (wParam == SPI_SETNONCLIENTMETRICS))
        {
        g_cxIconSpacing = GetSystemMetrics( SM_CXICONSPACING );
        g_cyIconSpacing = GetSystemMetrics( SM_CYICONSPACING );

        g_cxBorder = GetSystemMetrics(SM_CXBORDER);
        g_cyBorder = GetSystemMetrics(SM_CYBORDER);

        g_cxIcon = GetSystemMetrics(SM_CXICON);
        g_cyIcon = GetSystemMetrics(SM_CYICON);

        g_cxIconMargin = g_cxBorder * 8;
        g_cyIconMargin = g_cyBorder * 2;
        g_cyLabelSpace = g_cyIconMargin + (g_cyBorder * 2);
        g_cxLabelMargin = (g_cxBorder * 2);
        g_cxMargin = g_cxBorder * 5;
        }
    }


/*----------------------------------------------------------
Purpose: Initializes colors
Returns: --
Cond:    --
*/
void PRIVATE InitGlobalColors()
    {
    g_clrWindowText = GetSysColor(COLOR_WINDOWTEXT);
    g_clrWindow = GetSysColor(COLOR_WINDOW);
    g_clrHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);
    g_clrHighlight = GetSysColor(COLOR_HIGHLIGHT);

    g_hbrWindow = GetSysColorBrush(COLOR_WINDOW);
    g_hbrHighlight = GetSysColorBrush(COLOR_HIGHLIGHT);
    }



/*----------------------------------------------------------
Purpose: Sets up a bunch of necessary globals

Returns: nothing.

Cond:    --
*/
void InitializeAll(WPARAM wParam)
{
	GetMetrics(wParam);      // wParam from WM_WININICHANGE
	InitGlobalColors();
}

/*----------------------------------------------------------
Purpose: Load the string (if necessary) and format the string
         properly.

Returns: A pointer to the allocated string containing the formatted
         message or
         NULL if out of memory

Cond:    --
*/
LPSTR PUBLIC _ConstructMessageString(
    HINSTANCE hinst,
    LPCSTR pszMsg,
    va_list *ArgList)
    {
    char szTemp[MAXBUFLEN];
    LPSTR pszRet;
    LPSTR pszRes;

    if (HIWORD(pszMsg))
        pszRes = (LPSTR)pszMsg;
    else if (LOWORD(pszMsg) && LoadString(hinst, LOWORD(pszMsg), szTemp, sizeof(szTemp)))
        pszRes = szTemp;
    else
        pszRes = NULL;

    if (pszRes)
        {
        if (!FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                           pszRes, 0, 0, (LPTSTR)&pszRet, 0, ArgList))
            {
            pszRet = NULL;
            }
        }
    else
        {
        // Bad parameter
        pszRet = NULL;
        }

    return pszRet;      // free with LocalFree()
    }


/*----------------------------------------------------------
Purpose: Constructs a formatted string.  The returned string
         must be freed using GFree().

Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC ConstructMessage(
    LPSTR * ppsz,
    HINSTANCE hinst,
    LPCSTR pszMsg, ...)
    {
    BOOL bRet;
    LPSTR pszRet;
    va_list ArgList;

    va_start(ArgList, pszMsg);

    pszRet = _ConstructMessageString(hinst, pszMsg, &ArgList);

    va_end(ArgList);

    *ppsz = NULL;

    if (pszRet)
        {
        bRet = GSetString(ppsz, pszRet);
        LocalFree(pszRet);
        }
    else
        bRet = FALSE;

    return bRet;
    }

#if 0
/*----------------------------------------------------------
Purpose: Gets the locality of the path, relative to any
         briefcase.  If PL_ROOT or PL_INSIDE is returned,
         pszBuf will contain the path to the root of the
         briefcase.

         This function may hit the file-system to achieve
         its goal.

         Worst case: performs 2*n GetFileAttributes, where
         n is the number of components in pszPath.

Returns: Path locality (PL_FALSE, PL_ROOT, PL_INSIDE)

Cond:    --
*/
UINT PUBLIC PathGetLocality(
    LPCSTR pszPath,
    LPSTR pszBuf)       // Buffer for root path
    {
    UINT uRet;

    ASSERT(pszPath);
    ASSERT(pszBuf);

    *pszBuf = NULL_CHAR;

    // pszPath may be:
    //  1) a path to the briefcase folder itself
    //  2) a path to a file or folder beneath the briefcase
    //  3) a path to something unrelated to a briefcase

    // We perform our search by first looking in our cache
    // of known briefcase paths (CPATH).  If we don't find
    // anything, then we proceed to iterate thru each
    // component of the path, checking for these two things:
    //
    //   1) A directory with the system attribute
    //   2) The existence of a brfcase.dat file in the directory.
    //
    uRet = CPATH_GetLocality(pszPath, pszBuf);
    if (PL_FALSE == uRet)
        {
        int cnt = 0;

        lstrcpy(pszBuf, pszPath);
        do
            {
            if (PathCheckForBriefcase(pszBuf, (DWORD)-1))
                {
                int atom;

                uRet = cnt > 0 ? PL_INSIDE : PL_ROOT;

                // Add this briefcase path to our cache
                //
                atom = Atom_Add(pszBuf);
                if (ATOM_ERR != atom)
                    CPATH_Replace(atom);

                break;      // Done
                }

            cnt++;

            } while (PathRemoveFileSpec(pszBuf));

        if (PL_FALSE == uRet)
            *pszBuf = NULL_CHAR;
        }

    return uRet;
    }
#endif

/*----------------------------------------------------------
Purpose: Convert FILETIME struct to a readable string

Returns: String
Cond:    --
*/
void PUBLIC FileTimeToDateTimeString(
    LPFILETIME pft,
    LPSTR pszBuf,
    int cchBuf)
    {
    SYSTEMTIME st;
    FILETIME ftLocal;

    FileTimeToLocalFileTime(pft, &ftLocal);
    FileTimeToSystemTime(&ftLocal, &st);
    GetDateFormatA(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &st, NULL, pszBuf, cchBuf/2);
    pszBuf += lstrlen(pszBuf);
    *pszBuf++ = ' ';
    GetTimeFormatA(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &st, NULL, pszBuf, cchBuf/2);
    }


/*----------------------------------------------------------
Purpose: Sees whether the entire string will fit in *prc.
         If not, compute the numbder of chars that will fit
         (including ellipses).  Returns length of string in
         *pcchDraw.

         Taken from COMMCTRL.

Returns: TRUE if the string needed ellipses
Cond:    --
*/
BOOL PRIVATE NeedsEllipses(
    HDC hdc,
    LPCSTR pszText,
    RECT * prc,
    int * pcchDraw,
    int cxEllipses)
    {
    int cchText;
    int cxRect;
    int ichMin, ichMax, ichMid;
    SIZE siz;

    cxRect = prc->right - prc->left;

    cchText = lstrlen(pszText);

    if (cchText == 0)
        {
        *pcchDraw = cchText;
        return FALSE;
        }

    GetTextExtentPoint(hdc, pszText, cchText, &siz);

    if (siz.cx <= cxRect)
        {
        *pcchDraw = cchText;
        return FALSE;
        }

    cxRect -= cxEllipses;

    // If no room for ellipses, always show first character.
    //
    ichMax = 1;
    if (cxRect > 0)
        {
        // Binary search to find character that will fit
        ichMin = 0;
        ichMax = cchText;
        while (ichMin < ichMax)
            {
            // Be sure to round up, to make sure we make progress in
            // the loop if ichMax == ichMin + 1.
            //
            ichMid = (ichMin + ichMax + 1) / 2;

            GetTextExtentPoint(hdc, &pszText[ichMin], ichMid - ichMin, &siz);

            if (siz.cx < cxRect)
                {
                ichMin = ichMid;
                cxRect -= siz.cx;
                }
            else if (siz.cx > cxRect)
                {
                ichMax = ichMid - 1;
                }
            else
                {
                // Exact match up up to ichMid: just exit.
                //
                ichMax = ichMid;
                break;
                }
            }

        // Make sure we always show at least the first character...
        //
        if (ichMax < 1)
            ichMax = 1;
        }

    *pcchDraw = ichMax;
    return TRUE;
    }


#define CCHELLIPSES     3
#define DT_LVWRAP       (DT_CENTER | DT_WORDBREAK | DT_NOPREFIX | DT_EDITCONTROL)

/*----------------------------------------------------------
Purpose: Draws text the shell's way.

         Taken from COMMCTRL.

Returns: --

Cond:    This function requires TRANSPARENT background mode
         and a properly selected font.
*/
void PUBLIC MyDrawText(
    HDC hdc,
    LPCSTR pszText,
    RECT FAR* prc,
    UINT flags,
    int cyChar,
    int cxEllipses,
    COLORREF clrText,
    COLORREF clrTextBk)
    {
    int cchText;
    COLORREF clrSave;
    COLORREF clrSaveBk;
    UINT uETOFlags = 0;
    RECT rc;
    char ach[MAX_PATH + CCHELLIPSES];

    // REVIEW: Performance idea:
    // We could cache the currently selected text color
    // so we don't have to set and restore it each time
    // when the color is the same.
    //
    if (!pszText)
        return;

    rc = *prc;

    // If needed, add in a little extra margin...
    //
    if (IsFlagSet(flags, MDT_EXTRAMARGIN))
        {
        rc.left  += g_cxLabelMargin * 3;
        rc.right -= g_cxLabelMargin * 3;
        }
    else
        {
        rc.left  += g_cxLabelMargin;
        rc.right -= g_cxLabelMargin;
        }

    if (IsFlagSet(flags, MDT_ELLIPSES) &&
        NeedsEllipses(hdc, pszText, &rc, &cchText, cxEllipses))
        {
        hmemcpy(ach, pszText, cchText);
        lstrcpy(ach + cchText, c_szEllipses);

        pszText = ach;

        // Left-justify, in case there's no room for all of ellipses
        //
        ClearFlag(flags, (MDT_RIGHT | MDT_CENTER));
        SetFlag(flags, MDT_LEFT);

        cchText += CCHELLIPSES;
        }
    else
        {
        cchText = lstrlen(pszText);
        }

    if (IsFlagSet(flags, MDT_TRANSPARENT))
        {
        clrSave = SetTextColor(hdc, 0x000000);
        }
    else
        {
        uETOFlags |= ETO_OPAQUE;

        if (IsFlagSet(flags, MDT_SELECTED))
            {
            clrSave = SetTextColor(hdc, g_clrHighlightText);
            clrSaveBk = SetBkColor(hdc, g_clrHighlight);

            if (IsFlagSet(flags, MDT_DRAWTEXT))
                {
                FillRect(hdc, prc, g_hbrHighlight);
                }
            }
        else
            {
            if (clrText == CLR_DEFAULT && clrTextBk == CLR_DEFAULT)
                {
                clrSave = SetTextColor(hdc, g_clrWindowText);
                clrSaveBk = SetBkColor(hdc, g_clrWindow);

                if (IsFlagSet(flags, MDT_DRAWTEXT | MDT_DESELECTED))
                    {
                    FillRect(hdc, prc, g_hbrWindow);
                    }
                }
            else
                {
                HBRUSH hbr;

                if (clrText == CLR_DEFAULT)
                    clrText = g_clrWindowText;

                if (clrTextBk == CLR_DEFAULT)
                    clrTextBk = g_clrWindow;

                clrSave = SetTextColor(hdc, clrText);
                clrSaveBk = SetBkColor(hdc, clrTextBk);

                if (IsFlagSet(flags, MDT_DRAWTEXT | MDT_DESELECTED))
                    {
                    hbr = CreateSolidBrush(GetNearestColor(hdc, clrTextBk));
                    if (hbr)
                        {
                        FillRect(hdc, prc, hbr);
                        DeleteObject(hbr);
                        }
                    else
                        FillRect(hdc, prc, GetStockObject(WHITE_BRUSH));
                    }
                }
            }
        }

    // If we want the item to display as if it was depressed, we will
    // offset the text rectangle down and to the left
    if (IsFlagSet(flags, MDT_DEPRESSED))
        OffsetRect(&rc, g_cxBorder, g_cyBorder);

    if (IsFlagSet(flags, MDT_DRAWTEXT))
        {
        UINT uDTFlags = DT_LVWRAP;

        if (IsFlagClear(flags, MDT_CLIPPED))
            uDTFlags |= DT_NOCLIP;

        DrawText(hdc, pszText, cchText, &rc, uDTFlags);
        }
    else
        {
        if (IsFlagClear(flags, MDT_LEFT))
            {
            SIZE siz;

            GetTextExtentPoint(hdc, pszText, cchText, &siz);

            if (IsFlagSet(flags, MDT_CENTER))
                rc.left = (rc.left + rc.right - siz.cx) / 2;
            else
                {
                ASSERT(IsFlagSet(flags, MDT_RIGHT));
                rc.left = rc.right - siz.cx;
                }
            }

        if (IsFlagSet(flags, MDT_VCENTER))
            {
            // Center vertically
            rc.top += (rc.bottom - rc.top - cyChar) / 2;
            }

        if (IsFlagSet(flags, MDT_CLIPPED))
            uETOFlags |= ETO_CLIPPED;

        ExtTextOut(hdc, rc.left, rc.top, uETOFlags, prc, pszText, cchText, NULL);
        }

    if (flags & (MDT_SELECTED | MDT_DESELECTED | MDT_TRANSPARENT))
        {
        SetTextColor(hdc, clrSave);
        if (IsFlagClear(flags, MDT_TRANSPARENT))
            SetBkColor(hdc, clrSaveBk);
        }
    }


//---------------------------------------------------------------------------
// Given a pointer to a point in a path - return a ptr the start of the
// next path component. Path components are delimted by slashes or the
// null at the end.
// There's special handling for UNC names.
// This returns NULL if you pass in a pointer to a NULL ie if you're about
// to go off the end of the  path.
LPSTR PUBLIC PathFindNextComponentI(LPCSTR lpszPath)
{
    LPSTR lpszLastSlash;

    // Are we at the end of a path.
    if (!*lpszPath)
    {
        // Yep, quit.
        return NULL;
    }
    // Find the next slash.
    // REVIEW UNDONE - can slashes be quoted?
    lpszLastSlash = MyStrChr(lpszPath, '\\');
    // Is there a slash?
    if (!lpszLastSlash)
    {
        // No - Return a ptr to the NULL.
        return (LPSTR) (lpszPath+lstrlen(lpszPath));
    }
    else
    {
        // Is it a UNC style name?
        if ('\\' == *(lpszLastSlash+1))
        {
            // Yep, skip over the second slash.
            return lpszLastSlash+2;
        }
        else
        {
            // Nope. just skip over one slash.
            return lpszLastSlash+1;
        }
    }
}

/*----------------------------------------------------------
Purpose: Convert a file spec to make it look a bit better
         if it is all upper case chars.

Returns: --
Cond:    --
*/
BOOL PRIVATE PathMakeComponentPretty(LPSTR lpPath)
{
    LPSTR lp;

    // REVIEW: INTL need to deal with lower case chars in (>127) range?

    // check for all uppercase
    for (lp = lpPath; *lp; lp = AnsiNext(lp)) {
        if ((*lp >= 'a') && (*lp <= 'z'))
            return FALSE;       // this is a LFN, dont mess with it
    }

    AnsiLower(lpPath);
    AnsiUpperBuff(lpPath, 1);
    return TRUE;        // did the conversion
}

/*----------------------------------------------------------
Purpose: Takes the path and makes it presentable.

The rules are:
If the LFN name is simply the short name (all caps),
then convert to lowercase with first letter capitalized

Returns: --
Cond:    --
*/
void PUBLIC PathMakePresentable(
										  LPSTR pszPath)
{
	LPSTR pszComp;          // pointers to begining and
	LPSTR pszEnd;           //  end of path component
	LPSTR pch;
	int cComponent = 0;
	BOOL bUNCPath;
	char ch;

	bUNCPath = MyPathIsUNC(pszPath);

	pszComp = pszPath;
	while (pszEnd = PathFindNextComponentI(pszComp))
	{
		// pszEnd may be pointing to the right of the backslash
		//  beyond the path component, so back up one
		//
		ch = *pszEnd;
		*pszEnd = 0;        // temporary null

		// pszComp points to the path component
		//
		pch = AnsiNext(pszComp);
		if (':' == *pch)
		{
			// Simply capitalize the drive-portion of the path
			//
			AnsiUpper(pszComp);
		}
		else if (bUNCPath && cComponent++ < 3)
		{
			// Network server or share name
			//      BUGBUG: handle LFN network names
			//
			AnsiUpper(pszComp);
			PathMakeComponentPretty(pszComp);
		}
		else
		{
			// Normal path component
			//
			PathMakeComponentPretty(pszComp);
		}

		*pszEnd = ch;
		pszComp = pszEnd;
	}
}

/*----------------------------------------------------------
Purpose: Get a string from the resource string table.  Returned
ptr is a ptr to static memory.  The next call to this
function will wipe out the prior contents.
Returns: Ptr to string
Cond:    --
*/
LPSTR PUBLIC SzFromIDS(
							  UINT ids,               // resource ID
							  LPSTR pszBuf,
							  UINT cchBuf)
{
	ASSERT(pszBuf);

	*pszBuf = NULL_CHAR;
	LoadString(vhinstCur, ids, pszBuf, cchBuf);
	return pszBuf;
}


/*----------------------------------------------------------
Purpose: Sets the rectangle with the bounding extent of the given string.
Returns: Rectangle
Cond:    --
*/
void PUBLIC SetRectFromExtent(
										HDC hdc,
										LPRECT lprect,
										LPCSTR lpcsz)
{
	SIZE size;

	GetTextExtentPoint(hdc, lpcsz, lstrlen(lpcsz), &size);
	SetRect(lprect, 0, 0, size.cx, size.cy);
}

/*----------------------------------------------------------
Purpose: Copies psz into *ppszBuf.  Will alloc or realloc *ppszBuf
         accordingly.

Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC GSetString(
    LPSTR * ppszBuf,
    LPCSTR psz)
    {
    BOOL bRet = FALSE;
    DWORD cb;

    ASSERT(ppszBuf);
    ASSERT(psz);

    cb = CbFromCch(lstrlen(psz)+CCH_NUL);

    if (*ppszBuf)
        {
        // Need to reallocate?
        if (cb > GGetSize(*ppszBuf))
            {
            // Yes
            LPSTR pszT = GReAlloc(*ppszBuf, cb);
            if (pszT)
                {
                *ppszBuf = pszT;
                bRet = TRUE;
                }
            }
        else
            {
            // No
            bRet = TRUE;
            }
        }
    else
        {
        *ppszBuf = (LPSTR)GAlloc(cb);
        if (*ppszBuf)
            {
            bRet = TRUE;
            }
        }

    if (bRet)
        {
        ASSERT(*ppszBuf);
        lstrcpy(*ppszBuf, psz);
        }
    return bRet;
    }

/*----------------------------------------------------------
Purpose: Gets the file info given a path.  If the path refers
         to a directory, then simply the path field is filled.

         If himl != NULL, then the function will add the file's
         image to the provided image list and set the image index
         field in the *ppfi.

Returns: standard hresult
Cond:    --
*/
HRESULT PUBLIC FICreate(
    LPCSTR pszPath,
    FileInfo ** ppfi,
    UINT uFlags)
    {
    HRESULT hres = ResultFromScode(E_OUTOFMEMORY);
    int cchPath;
    SHFILEINFO sfi;
    UINT uInfoFlags = SHGFI_DISPLAYNAME | SHGFI_ATTRIBUTES;
    DWORD dwAttr;

    ASSERT(pszPath);
    ASSERT(ppfi);

    // Get shell file info
    if (IsFlagSet(uFlags, FIF_ICON))
        uInfoFlags |= SHGFI_ICON;
    if (IsFlagSet(uFlags, FIF_DONTTOUCH))
        {
        uInfoFlags |= SHGFI_USEFILEATTRIBUTES;

        // Today, FICreate is not called for folders, so this is ifdef'd out
#ifdef SUPPORT_FOLDERS
        dwAttr = IsFlagSet(uFlags, FIF_FOLDER) ? FILE_ATTRIBUTE_DIRECTORY : 0;
#else
        dwAttr = 0;
#endif
        }
    else
        dwAttr = 0;

    if (SHGetFileInfo(pszPath, dwAttr, &sfi, sizeof(sfi), uInfoFlags))
        {
        // Allocate enough for the structure, plus buffer for the fully qualified
        // path and buffer for the display name (and extra null terminator).
        cchPath = lstrlen(pszPath);

        *ppfi = GAlloc(sizeof(FileInfo)+cchPath+1-sizeof((*ppfi)->szPath)+lstrlen(sfi.szDisplayName)+1);
        if (*ppfi)
            {
            FileInfo * pfi = *ppfi;

            pfi->pszDisplayName = pfi->szPath+cchPath+1;
            lstrcpy(pfi->pszDisplayName, sfi.szDisplayName);

            if (IsFlagSet(uFlags, FIF_ICON))
                pfi->hicon = sfi.hIcon;

            pfi->dwAttributes = sfi.dwAttributes;

            // Does the path refer to a directory?
            if (FIIsFolder(pfi))
                {
                // Yes; just fill in the path field
                lstrcpy(pfi->szPath, pszPath);
                hres = NOERROR;
                }
            else
                {
                // No; assume the file exists?
                if (IsFlagClear(uFlags, FIF_DONTTOUCH))
                    {
                    // Yes; get the time, date and size of the file
                    HANDLE hfile = CreateFile(pszPath, GENERIC_READ,
                                FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                                NULL);

                    if (hfile == INVALID_HANDLE_VALUE)
                        {
                        GFree(*ppfi);
                        hres = ResultFromScode(E_HANDLE);
                        }
                    else
                        {
                        hres = NOERROR;

                        lstrcpy(pfi->szPath, pszPath);
                        pfi->dwSize = GetFileSize(hfile, NULL);
                        GetFileTime(hfile, NULL, NULL, &pfi->ftMod);
                        CloseHandle(hfile);
                        }
                    }
                else
                    {
                    // No; use what we have
                    hres = NOERROR;
                    lstrcpy(pfi->szPath, pszPath);
                    }
                }
            }
        }
    else if (!PathExists(pszPath))
        {
        // Differentiate between out of memory and file not found
        hres = E_FAIL;
        }

    return hres;
    }

/*----------------------------------------------------------
Purpose: Set the path entry.  This can move the pfi.

Returns: FALSE on out of memory
Cond:    --
*/
BOOL PUBLIC FISetPath(
    FileInfo ** ppfi,
    LPCSTR pszPathNew,
    UINT uFlags)
    {
    ASSERT(ppfi);
    ASSERT(pszPathNew);

    FIFree(*ppfi);

    return SUCCEEDED(FICreate(pszPathNew, ppfi, uFlags));
    }

/*----------------------------------------------------------
Purpose: Free our file info struct
Returns: --
Cond:    --
*/
void PUBLIC FIFree(
    FileInfo * pfi)
    {
    if (pfi)
        {
        if (pfi->hicon)
            DestroyIcon(pfi->hicon);

        GFree(pfi);     // This macro already checks for NULL pfi condition
        }
    }

/*----------------------------------------------------------
Purpose: Returns TRUE if the file/directory exists.

Returns: see above
Cond:    --
*/
BOOL PUBLIC PathExists(
    LPCSTR pszPath)
    {
    return GetFileAttributes(pszPath) != 0xFFFFFFFF;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\list.h ===
#ifndef __LIST_H__
#define __LIST_H__

#include "shdcom.h"

typedef struct node {
	struct node *next;
	LPCOPYPARAMS lpCP;
	int iShadowStatus;
	int iFileStatus;
	unsigned int uAction;
	SHADOWINFO sSI;						// tHACK:  too BIG!!!
	WIN32_FIND_DATA sFind32Local;
	WIN32_FIND_DATA sFind32Remote;
} node;

void killList(node *);
node *
insertList(
	node 				**thisList,
	LPCOPYPARAMS 		aNode,
	LPSHADOWINFO 		lpSI,
	LPWIN32_FIND_DATA	lpFind32Local,
	LPWIN32_FIND_DATA	lpFind32Remote,
	int 				iShadowStatus,
	int 				iFileStatus,
	unsigned int 		uAction);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\merge.c ===
#include "pch.h"

#include "extra.h"
#include "resource.h"
#include "recact.h"
#include "list.h"
#include "merge.h"
#include "lib3.h"
#include "utils.h"

//
AssertData;
AssertError;
//

//
extern HANDLE vhinstCur;				// current instance (from reint.c)

typedef struct tagINFO
{
	HWND	hwnd;						// dialog handle.
	node	*mergeList;				// list of files to query
} INFO, FAR * PINFO;

BOOL APIENTRY NewDlg_DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

/* externs needed */
BOOL GetWin32Info(LPSTR lpFile, LPWIN32_FIND_DATA lpFW32);


char vszLocalCopy[] = "Local Database";
/****************************************************************************
 *	Caller entrypoint for merge conflicts dialog.
 */
int doMergeDialog(HWND hWnd, node *aList)
{
	int nRet=-1;
	INFO sInfo;
	static inited=FALSE;
	node *currItem=aList;

    // There is a chance that the view window may be closed before we put up UI
    // in this case, we abort any merging that we thought may have gone on.
    if( !IsWindow(hWnd) )
    {
        DEBUG_PRINT(("Merge: hwnd is no longer active\n"));
        return -1;
    }

	sInfo.mergeList = aList;

	DEBUG_PRINT(("attempt to open dialog\n"));
	if(!inited)
	{
		RecAct_Init(vhinstCur);
		InitCommonControls();
		InitializeAll(0);		// bogus param, but same as in FileSync...
		inited = TRUE;
	}
	nRet = DialogBoxParam(vhinstCur, MAKEINTRESOURCE(IDD_MERGE_LIST), hWnd, NewDlg_DlgProc, (LPARAM) &sInfo);
	DEBUG_PRINT(("return = %d (0x%08x)\n", nRet, nRet));

	while(currItem)
	{
		char szBigBuf[2*MAX_PATH];

		if(currItem->iFileStatus == SI_NOEXIST)
		{
			strcpy(szBigBuf, currItem->lpCP->lpServerPath);
			strcat(szBigBuf, currItem->lpCP->lpRemotePath);
			DeleteFile(szBigBuf);
			DEBUG_PRINT(("temp file <%s> deleted\n", szBigBuf));
		}
		currItem= currItem->next;
	}

	//	RecAct_Term(vhinstCur);
    return(nRet);
}

/****************************************************************************
 *	dialog stuff
 */

BOOL NEAR PASCAL NewDlg_OnInitDialog(
    PINFO this,
    HWND hwndFocus,
    LPARAM lParam)
{
	int currCount=0;
	RA_ITEM item;
	node *currItem=this->mergeList;
	char szBigBuf[2*MAX_PATH];
	char *szTemp;

	DEBUG_PRINT(("Merge:OnInitDialog\n"));

	while(currItem)
	{
		// insert each item into the list...
		item.mask = RAIF_ALL;					// One of RAIF_
		item.iItem = currCount++;
		item.uStyle=RAIS_CANMERGE;				// One of RAIS_
		item.uAction=currItem->uAction;		// One of RAIA_

		item.pszName = currItem->sFind32Local.cFileName;

        if (currItem->sFind32Local.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            item.uStyle = RAIS_FOLDER;
		memcpy(&item.siInside.fs.ftMod,&currItem->sFind32Local.ftLastWriteTime, sizeof(FILETIME));
		item.siInside.fs.dwcbHighLength = currItem->sFind32Local.nFileSizeHigh;
		item.siInside.fs.dwcbLowLength = currItem->sFind32Local.nFileSizeLow;
		item.siInside.pszDir=vszLocalCopy;
		item.siInside.fs.fscond = FS_COND_EXISTS;
		item.siInside.uState=currItem->iShadowStatus;

		lstrcpy(szBigBuf, currItem->lpCP->lpServerPath);
		lstrcat(szBigBuf, currItem->lpCP->lpRemotePath);
		if(currItem->iFileStatus != SI_NOEXIST)
		{
			Assert(currItem->sFind32Remote.cFileName[0]);
			memcpy(&item.siOutside.fs.ftMod, &currItem->sFind32Remote.ftLastWriteTime, sizeof(FILETIME));
			item.siOutside.fs.dwcbHighLength = currItem->sFind32Remote.nFileSizeHigh;
			item.siOutside.fs.dwcbLowLength = currItem->sFind32Remote.nFileSizeLow;
		}
		else
		{
			HANDLE fh;
			// fake up a file for a little while.
			fh = CreateFile(szBigBuf, GENERIC_READ|GENERIC_WRITE,
								 FILE_SHARE_READ|FILE_SHARE_WRITE,
								 NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
			if(fh==INVALID_HANDLE_VALUE) {
				DEBUG_PRINT(("file not created\n"));
			} else {
				DEBUG_PRINT(("temp file <%s> created\n", szBigBuf));
				CloseHandle( fh );
			}
		}
		szTemp = StrRChr(szBigBuf, szBigBuf+lstrlen(szBigBuf)-1, '\\');
		Assert(szTemp);
		*szTemp = (char) 0;
		item.siOutside.pszDir=szBigBuf;
		item.siOutside.fs.fscond = FS_COND_EXISTS;
		item.siOutside.uState=currItem->iFileStatus;

		item.lParam=(LPARAM) currItem;

		DEBUG_PRINT(("inserting <%s> <%s %s> at %d\n", item.siInside.pszDir, item.siOutside.pszDir, item.pszName, item.iItem));

		if(-1 == RecAct_InsertItem(GetDlgItem(this->hwnd, IDC_RECACTION), &item))
         {
#ifdef DEBUG
			DEBUG_PRINT(("RecAct_InsertItem failed\n"));
#endif //DEBUG
         }
		else
         {
#ifdef DEBUG
			DEBUG_PRINT(("RecAct_InsertItem done right!\n"));
#endif //DEBUG
         }
		
		currItem = currItem->next;
	}
	DEBUG_PRINT(("done list\n"));
	return TRUE;
}

/*****************************************************************************
 *	Purpose: NewDlg handle WM_COMMAND
 *	Returns: --
 *	Cond:    --
 */
VOID NEAR PASCAL NewDlg_OnCommand(
    PINFO this,
    int id,
    HWND hwndCtl,
    UINT uNotifyCode)
{
	HWND hwnd = this->hwnd;

	switch (id)
	{
		case IDOK:
			EndDialog(hwnd,TRUE);
			break;

		case IDCANCEL:
			EndDialog(hwnd,FALSE);
            break;

		default:
		    DEBUG_PRINT(("Merge:OnCommand - Unknown id %d\n",id));
			return;
	}
}

/*****************************************************************************
 *	Purpose: NewDlg handle WM_NOTIFY
 *	Returns: --
 *	Cond:    --
 */
BOOL NEAR PASCAL NewDlg_OnNotify(
    PINFO this,
    int idFrom,
    NMHDR FAR * lpnmhdr)
{
	node *currItem;
	HWND hwnd = this->hwnd;
	NM_RECACT *pnmrecact = (NM_RECACT *) lpnmhdr;

	Assert(lpnmhdr);  Assert(this);

	switch (lpnmhdr->code)
	{
		case RN_SELCHANGED:
			DEBUG_PRINT(("RN_SELCHANGED received\n"));
			return FALSE;

		case RN_ITEMCHANGED:
			if(pnmrecact->mask & RAIF_ACTION)
			{
				currItem = (node *) pnmrecact->lParam;
				Assert(currItem);
				currItem->uAction = pnmrecact->uAction;
				DEBUG_PRINT(("RN_ITEMCHANGED on %08x received and delt with\n", currItem->lpCP->hShadow));
			}
			else
				DEBUG_PRINT(("RN_ITEMCHANGED: no RAIF_ACTION\n"));
			break;

		default:
			break;
	}
	return FALSE;
}

/*****************************************************************************
 *	Purpose: Handle WM_DESTROY
 *	Returns: --
 *	Cond:    --
 */
void NEAR PASCAL NewDlg_OnDestroy(PINFO this)
{
}

/*****************************************************************************
 *	Purpose: random
 *	Returns: mush
 *	Cond:    --
 */
BOOL APIENTRY NewDlg_DlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
	PINFO this;

	this = (PINFO)GetWindowLong(hDlg, DWL_USER);
	if(!this)
		if(message == WM_INITDIALOG)
		{
			// lparam = the pinfo we need.  Allocated from above.
			this = (PINFO) lParam;
			this->hwnd = hDlg;
			SetWindowLong(hDlg, DWL_USER, (LONG) lParam);
		}
		else
			return FALSE;  // ignore everthing until we get an initdialog

	switch (message)
	{
		HANDLE_MSG(this, WM_INITDIALOG, NewDlg_OnInitDialog);
		HANDLE_MSG(this, WM_COMMAND, NewDlg_OnCommand);
		HANDLE_MSG(this, WM_NOTIFY, NewDlg_OnNotify);
		HANDLE_MSG(this, WM_DESTROY, NewDlg_OnDestroy);
		default:
			return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\exports.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    exports.c

Abstract:

    entry point and functions exported by cscdll.dll

    Contents:

Author:

    Shishir Pardikar


Environment:

    Win32 (user-mode) DLL

Revision History:

    4-4-97  created by putting all the exported functions here.

--*/

#include "pch.h"


#ifdef CSC_ON_NT
#include <winioctl.h>
#endif //CSC_ON_NT

#include "shdcom.h"
#include "shdsys.h"
#include "reint.h"
#include "utils.h"
#include "resource.h"
#include "strings.h"
// this sets flags in a couple of headers to not include some defs.
#define REINT
#include "lib3.h"


//
// Globals/Locals
//

HANDLE  vhinstCur=NULL;             // current instance
AssertData;
AssertError;

#ifndef CSC_ON_NT
extern HWND vhwndShared;
#endif

//
// Local prototypes
//



int
PASCAL
ReInt_WinMain(
    HANDLE,
    HANDLE,
    LPSTR,
    int
    );

//
// functions
//



BOOL
APIENTRY
LibMain(
    IN HANDLE hDll,
    IN DWORD dwReason,
    IN LPVOID lpReserved
    )
/*++

Routine Description:

    Entry point for the agent library.

Arguments:

    hDll - Library handle

    dwReason - PROCESS_ATTACH etc.

    lpReserved - reserved

Returns:

    TRUE if successful.

Notes:

--*/
{
    switch(dwReason){
        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:
            if (!vhinstCur){
               vhinstCur = hDll;
            }
            if (!vhMutex){
               vhMutex = CreateMutex(NULL, FALSE, NULL);
               if (!vhMutex){
                   OutputDebugString(_TEXT("CreateMutex Failed \r\n"));
               }
           }
        break;

        case DLL_THREAD_DETACH:
            break;
        case DLL_PROCESS_DETACH:
            CleanupReintState();
           if (vhMutex)
           {
               CloseHandle(vhMutex);
           }
        break;

        default:
        break;

    } // end switch()

    return TRUE;

}


DWORD
WINAPI
MprServiceProc(
    IN LPVOID lpvParam
    )
/*++

Routine Description:


Parameters:

    lpvParam - NULL indicates start, non-NULL indicates terminate

Return Value:


Notes:



--*/
{
    if (!lpvParam){
        Assert (vhinstCur != NULL);
//        DEBUG_PRINT(("MprServiceProc: Calling ReInt_WinMain!\n"));
        ReInt_WinMain(vhinstCur, NULL, NULL, SW_SHOW);
    }
    else
    {
        if (vhwndMain)
        {
            DestroyWindow(vhwndMain);
        }
    }
   return (0L);
}


#ifndef CSC_ON_NT

VOID
WINAPI
LogonHappened(
    IN BOOL fDone
    )
/*++

Routine Description:
    Win95 specific routine. No significance for NT

Parameters:

Return Value:

Notes:

When the network comes back on, this is called by shdnp.dll
we nuke our shadowed connections, and replace them with 'true' connections
NB!!!!: this function could be called in the context of a thread other than the
reint thread.

--*/
{

    if (vhwndShared)
    {
        SendMessage(vhwndShared, WM_COMMAND, IDM_LOGON, fDone);
    
    }
}


VOID
WINAPI
LogoffHappened(
    BOOL fDone
    )
/*++

Routine Description:

    this is called by shdnp.dll during logoff sequence by shdnp
    NB!!!!: this function could be called in the context of a thread other than the
    reint thread.

Arguments:


Returns:


Notes:

--*/
{
    if (vhwndShared)
    {
        SendMessage(vhwndShared, WM_COMMAND, IDM_LOGOFF, fDone);
    
    }
}

//
// Called from Shhndl.dll to update the servers
// Pass the server ID and a parent window to own the UI.
//
int
WINAPI
Update(
    HSERVER hServer,
    HWND hwndParent
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    int iRes;
    if(hServer==(HSERVER)NULL){
        iRes=(int)SendMessage(vhwndShared, RWM_UPDATEALL, (WPARAM)hServer, (LPARAM)hwndParent);
    }
    else{
        iRes=(int)SendMessage(vhwndShared, RWM_UPDATE, (WPARAM)hServer, (LPARAM)hwndParent);
    }
    return iRes;
}


int
WINAPI
RefreshConnections(
    int  force,
    BOOL verbose
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return (SendMessage(vhwndShared, WM_COMMAND, IDM_REFRESH_CONNECTIONS, MAKELPARAM(force, verbose)));
}


int
WINAPI
BreakConnections(
    int  force,
    BOOL verbose
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return (SendMessage(vhwndShared, WM_COMMAND, IDM_BREAK_CONNECTIONS, MAKELPARAM(force, verbose)));
}
#else

VOID
WINAPI
LogonHappened(
    IN BOOL fDone
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
}


VOID
WINAPI
LogoffHappened(
    BOOL fDone
    )
/*++

Routine Description:

Arguments:


Returns:


Notes:

--*/
{
}

int
WINAPI
Update(
    HSERVER hServer,
    HWND hwndParent
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return -1;
}


int
WINAPI
RefreshConnections(
    int  force,
    BOOL verbose
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return (-1);
}


int
WINAPI
BreakConnections(
    int  force,
    BOOL verbose
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return (-1);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\merge.h ===
int doMergeDialog(HWND hWnd, node *aList);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\recon.h ===
// Reconnect Dialog and friends

#ifndef __RECONH
#define __RECONH

extern HANDLE vhinstCur;			// current instance from reint.c
BOOL CALLBACK Recon_DlgProc(
    HWND  hwndDlg,
    UINT  uMsg,
    WPARAM  wParam,
    LPARAM  lParam);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\pch.c ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\reintinc.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\recact.h ===
//
// recact.h: Declares data, defines and struct types for RecAct
//				  module.
//
//

#ifndef __RECACT_H__
#define __RECACT_H__


/////////////////////////////////////////////////////  INCLUDES

/////////////////////////////////////////////////////  DEFINES

// RecAct message ranges
//
#define RAM_FIRST       (WM_USER+1)
#define RAM_LAST        (WM_USER+20)
#define RN_FIRST        (0U-700U)
#define RN_LAST         (0U-799U)

// Window class name
//
#define WC_RECACT       "RecAction"



// BOOL RecAct_Enable(HWND hwnd, BOOL fEnable);
//
#define RecAct_Enable(hwnd, fEnable) \
	EnableWindow((hwnd), (fEnable))

// int RecAct_GetItemCount(HWND hwnd);
//
#define RAM_GETITEMCOUNT		(RAM_FIRST + 0)
#define RecAct_GetItemCount(hwnd) \
		(int)SendMessage(hwnd, RAM_GETITEMCOUNT, 0, 0L)

// Side item structure
//
#define SI_UNCHANGED    0
#define SI_CHANGED      1
#define SI_NEW          2
#define SI_NOEXIST      3
#define SI_UNAVAILABLE  4
#define SI_DELETED      5

typedef struct tagSIDE_ITEM
    {
    LPSTR pszDir;
    UINT uState;        // One of SI_* flags
    FILESTAMP fs;
    } SIDEITEM, FAR * LPSIDEITEM;

// RecAction Item structure
//
#define RAIF_ACTION      0x0001     // Mask codes
#define RAIF_NAME        0x0002
#define RAIF_STYLE       0x0004
#define RAIF_INSIDE      0x0008
#define RAIF_OUTSIDE     0x0010
#define RAIF_LPARAM      0x0020

#define RAIF_ALL         0x001f


typedef struct tagRA_ITEM
    {
    UINT mask;          // One of RAIF_
    int iItem;
    UINT uStyle;        // One of RAIS_
    UINT uAction;       // One of RAIA_

    LPCSTR pszName;

    SIDEITEM siInside;
    SIDEITEM siOutside;

    LPARAM lParam;

    } RA_ITEM, FAR * LPRA_ITEM;


// RecAct item styles
//
#define RAIS_CANMERGE   0x0001
#define RAIS_FOLDER     0x0002
#define RAIS_CANSKIP		0x0004

// RecAct actions
//
#define RAIA_TOOUT      0       // Don't change these values without changing
#define RAIA_TOIN       1       //  the order of the bitmaps in s_rgidAction
#define RAIA_SKIP       2
#define RAIA_CONFLICT   3
#define RAIA_MERGE      4
#define RAIA_SOMETHING  5       // These two require RAIS_FOLDER
#define RAIA_NOTHING    6
#define RAIA_ORPHAN     7

// Insert item at specified index.  Item is inserted at end if
// i is greater than or equal to the number of items in the twinview.
// Returns the index of the inserted item, or -1 on error.
//
// int RecAct_InsertItem(HWND hwnd, const LPRA_ITEM pitem);
//
#define RAM_INSERTITEM		    (RAM_FIRST + 1)
#define RecAct_InsertItem(hwnd, pitem) \
		(int)SendMessage((hwnd), RAM_INSERTITEM, 0, (LPARAM)(const LPRA_ITEM)(pitem))

// Delete an item at the specified index.
//
// int RecAct_DeleteItem(HWND hwnd, int i);
//
#define RAM_DELETEITEM			(RAM_FIRST + 2)
#define RecAct_DeleteItem(hwnd, i) \
		(int)SendMessage((hwnd), RAM_DELETEITEM, (WPARAM)(int)(i), 0L)

// Deletes all items in the control
//
// BOOL RecAct_DeleteAllItems(HWND hwnd);
//
#define RAM_DELETEALLITEMS		(RAM_FIRST + 3)
#define RecAct_DeleteAllItems(hwnd) \
		(BOOL)SendMessage((hwnd), RAM_DELETEALLITEMS, 0, 0L)

// BOOL RecAct_GetItem(HWND hwnd, LPRA_ITEM pitem);
//
#define RAM_GETITEM				(RAM_FIRST + 4)
#define RecAct_GetItem(hwnd, pitem) \
		(BOOL)SendMessage((hwnd), RAM_GETITEM, 0, (LPARAM)(LPRA_ITEM)(pitem))

// BOOL RecAct_SetItem(HWND hwnd, const LPRA_ITEM pitem);
//
#define RAM_SETITEM				(RAM_FIRST + 5)
#define RecAct_SetItem(hwnd, pitem) \
		(BOOL)SendMessage((hwnd), RAM_SETITEM, 0, (LPARAM)(const LPRA_ITEM)(pitem))

// Get the current selection by index.  -1 if nothing is selected.
//
// int RecAct_GetCurSel(HWND hwnd);
//
#define RAM_GETCURSEL			(RAM_FIRST + 6)
#define RecAct_GetCurSel(hwnd) \
		(int)SendMessage((hwnd), RAM_GETCURSEL, (WPARAM)0, 0L)

// Set the current selection by index.  -1 to deselect.
//
// int RecAct_SetCurSel(HWND hwnd, int i);
//
#define RAM_SETCURSEL			(RAM_FIRST + 7)
#define RecAct_SetCurSel(hwnd, i) \
		(int)SendMessage((hwnd), RAM_SETCURSEL, (WPARAM)(i), 0L)

// RecAct_FindItem flags
//
#define RAFI_NAME       0x0001
#define RAFI_LPARAM     0x0002
#define RAFI_ACTION     0x0004

typedef struct tagRA_FINDITEM
    {
    UINT    flags;      // One of RAFI_* flags
    UINT    uAction;    // One of RAIA_* flags
    LPCSTR  psz;
    LPARAM  lParam;
    
    } RA_FINDITEM;

// Find an item according to RA_FINDITEM struct.  iStart = -1 to
//  start at beginning.
//
// int RecAct_FindItem(HWND hwnd, int iStart, const RA_FINDITEM FAR* prafi);
#define RAM_FINDITEM				(RAM_FIRST + 8)
#define RecAct_FindItem(hwnd, iStart, prafi) \
		(int)SendMessage((hwnd), RAM_FINDITEM, (WPARAM)(int)(iStart), (LPARAM)(const RA_FINDINFO FAR*)(prafi))

// Refresh the control.
//
// void RecAct_Refresh(HWND hwnd);
#define RAM_REFRESH				(RAM_FIRST + 9)
#define RecAct_Refresh(hwnd) \
		SendMessage((hwnd), RAM_REFRESH, 0, 0L)


// Notification codes
//
#define RN_SELCHANGED	(RN_FIRST-0)
#define RN_ITEMCHANGED  (RN_FIRST-1)

typedef struct tagNM_RECACT
    {
    NMHDR   hdr;
    int     iItem;
    UINT    mask;           // One of RAIF_* 
    UINT    uAction;        // One of RAIA_*
    UINT    uActionOld;     // One of RAIA_*
    LPARAM  lParam;
    
    } NM_RECACT;

// Window styles
#define RAS_SINGLEITEM  0x0001L


/////////////////////////////////////////////////////  EXPORTED DATA


/////////////////////////////////////////////////////  PUBLIC PROTOTYPES

BOOL PUBLIC RecAct_Init (HINSTANCE hinst);
void PUBLIC RecAct_Term(HINSTANCE hinst);

void PUBLIC RAI_FillFromObject(LPRA_ITEM pitem, int atomBrf, LPCSTR pszInsideDir, PRECITEM lpri, HTWIN FAR * lphtwin);
BOOL PUBLIC RAI_FillFromFolder(LPRA_ITEM pitem, PFOLDERTWINLIST lpftl, PRECLIST lprl, LPCSTR lpcszPath, HTWIN FAR * lphtwin);

#endif // __RECACT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\recact.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: recact.c
//
//  This file contains the reconciliation-action control class code
//
//
// History:
//  08-12-93 ScottH     Created.
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "pch.h"

#include "reintinc.h"
#include "extra.h"
#include "resource.h"

#include "recact.h"
#include "dobj.h"


/////////////////////////////////////////////////////	 Globals

int g_cxIconSpacing = 0;
int g_cyIconSpacing = 0;
int g_cxBorder = 0;
int g_cyBorder = 0;

int g_cxMargin = 0;
int g_cxIcon = 0;
int g_cyIcon = 0;
int g_cxIconMargin = 0;
int g_cyIconMargin = 0;

int g_cxLabelMargin = 0;
int g_cyLabelSpace = 0;

//char const FAR c_szWinHelpFile[] = "windows.hlp";

/////////////////////////////////////////////////////  CONTROLLING DEFINES


/////////////////////////////////////////////////////  DEFINES

// Manifest constants 
#define SIDE_INSIDE     0
#define SIDE_OUTSIDE    1

// These should be changed if the bitmap sizes change!!
#define CX_ACTIONBMP    26
#define CY_ACTIONBMP    26

#define RECOMPUTE       (-1)

#define X_INCOLUMN      (g_cxIcon*2)

// Image indexes 
#define II_RIGHT        0
#define II_LEFT         1
#define II_CONFLICT     2
#define II_SKIP         3
#define II_MERGE        4
#define II_SOMETHING    5
#define II_UPTODATE     6

// Menu items
//
#define IDM_ACTIONFIRST     100
#define IDM_TOOUT           100
#define IDM_TOIN            101
#define IDM_SKIP            102
#define IDM_MERGE           103
#define IDM_ACTIONLAST      103

#define IDM_WHATSTHIS       104


/////////////////////////////////////////////////////  TYPEDEFS

typedef struct tagRECACT
    {
    HWND        hwnd;
    
    HWND        hwndLB;
    HDC         hdcOwn;             // Own DC
    HMENU       hmenu;              // Action and help context menu
    HFONT       hfont;
    WNDPROC     lpfnLBProc;         // Default LB proc
    HIMAGELIST  himlAction;         // imagelist for actions
    HIMAGELIST  himlCache;          // control imagelist cache
    HBITMAP     hbmpBullet;

    HBRUSH      hbrBkgnd;
    COLORREF    clrBkgnd;

    LONG        lStyle;             // Window style flags

    // Metrics
    int         xAction;
    int         cxAction;
    int         cxItem;             // Generic width of an item
    int         cxMenuCheck;
    int         cyMenuCheck;
    int         cyText;
    int         cxSideItem;
    int         cxEllipses;

    } RECACT, FAR * LPRECACT;

#define RecAct_IsNoIcon(this)   IsFlagSet((this)->lStyle, RAS_SINGLEITEM)

// Internal item data struct
//
typedef struct tagRA_PRIV
    {
    UINT uStyle;        // One of RAIS_
    UINT uAction;       // One of RAIA_

    FileInfo * pfi;

    SIDEITEM siInside;
    SIDEITEM siOutside;

    LPARAM  lParam;

    DOBJ    rgdobj[4];      // Array of Draw object info
    int     cx;             // Bounding width and height
    int     cy;

    } RA_PRIV, FAR * LPRA_PRIV;

#define IDOBJ_ACTION    3

// RecAction menu item definition structure.  Used to define the
//  context menu brought up in this control.
//
typedef struct tagRAMID
    {
    UINT    idm;               // Menu ID (for MENUITEMINFO struct)
    UINT    uAction;           // One of RAIA_* flags
    UINT    ids;               // Resource string ID
    int     iImage;            // Index into himlAction 
    RECT    rcExtent;          // Extent rect of string
    } RAMID, FAR * LPRAMID;   // RecAction Menu Item Definition

// Help menu item definition structure.  Used to define the help
//  items in the context menu.
//
typedef struct tagHMID
    {
    UINT idm;
    UINT ids;
    } HMID;

/////////////////////////////////////////////////////  MACROS

#define RecAct_DefProc      DefWindowProc
#define RecActLB_DefProc    CallWindowProc


// Instance data pointer macros
//
#define RecAct_GetPtr(hwnd)     (LPRECACT)GetWindowLong(hwnd, 0)
#define RecAct_SetPtr(hwnd, lp) (LPRECACT)SetWindowLong(hwnd, 0, (LONG)(lp))

#define RecAct_GetCount(this)   ListBox_GetCount((this)->hwndLB)

/////////////////////////////////////////////////////  MODULE DATA

static char const c_szEllipses[] = "...";
static char const c_szDateDummy[] = "99/99/99 99:99PM";

// Map RAIA_* values to image indexes 
//
static UINT const c_mpraiaiImage[] = 
    { II_RIGHT, II_LEFT, II_SKIP, II_CONFLICT, II_MERGE, II_SOMETHING, II_UPTODATE };

// Map RAIA_* values to menu command positions
//
static UINT const c_mpraiaidmMenu[] = 
    {IDM_TOOUT, IDM_TOIN, IDM_SKIP, IDM_SKIP, IDM_MERGE, 0, 0 };

// Define the context menu layout
//
static RAMID const c_rgramid[] = {
    { IDM_TOOUT,    RAIA_TOOUT, IDS_MENU_REPLACE,   II_RIGHT,   0 },
    { IDM_TOIN,     RAIA_TOIN,  IDS_MENU_REPLACE,   II_LEFT,    0 },
    { IDM_SKIP,     RAIA_SKIP,  IDS_MENU_SKIP,      II_SKIP,    0 },
    // Merge must be the last item!
    { IDM_MERGE,    RAIA_MERGE, IDS_MENU_MERGE,     II_MERGE,   0 },
    };

static RAMID const c_rgramidCreates[] = {
    { IDM_TOOUT,    RAIA_TOOUT, IDS_MENU_CREATE,    II_RIGHT,   0 },
    { IDM_TOIN,     RAIA_TOIN,  IDS_MENU_CREATE,    II_LEFT,    0 },
    };

// Indexes into c_rgramidCreates
//
#define IRAMID_CREATEOUT    0
#define IRAMID_CREATEIN     1

static HMID const c_rghmid[] = {
    { IDM_WHATSTHIS, IDS_MENU_WHATSTHIS },
    };

/////////////////////////////////////////////////////  LOCAL PROCEDURES

LRESULT _export CALLBACK RecActLB_LBProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam);

/////////////////////////////////////////////////////  PRIVATE FUNCTIONS



#ifdef DEBUG
LPCSTR PRIVATE DumpRecAction(
    UINT uAction)        // RAIA_
    {
    switch (uAction)
        {
    DEBUG_CASE_STRING( RAIA_TOOUT );
    DEBUG_CASE_STRING( RAIA_TOIN );     
    DEBUG_CASE_STRING( RAIA_SKIP );     
    DEBUG_CASE_STRING( RAIA_CONFLICT ); 
    DEBUG_CASE_STRING( RAIA_MERGE );    
    DEBUG_CASE_STRING( RAIA_SOMETHING );
    DEBUG_CASE_STRING( RAIA_NOTHING );  
    DEBUG_CASE_STRING( RAIA_ORPHAN );   

    default:        return "Unknown";
        }
    }


LPCSTR PRIVATE DumpSideItemState(
    UINT uState)        // SI_
    {
    switch (uState)
        {
    DEBUG_CASE_STRING( SI_UNCHANGED );
    DEBUG_CASE_STRING( SI_CHANGED );     
    DEBUG_CASE_STRING( SI_NEW );     
    DEBUG_CASE_STRING( SI_NOEXIST ); 
    DEBUG_CASE_STRING( SI_UNAVAILABLE );    
    DEBUG_CASE_STRING( SI_DELETED );

    default:        return "Unknown";
        }
    }


/*----------------------------------------------------------
Purpose: 
Returns: 
Cond:    --
*/
void PUBLIC DumpTwinPair(
    LPRA_ITEM pitem)
    {
    if (pitem)
        {
        char szBuf[MAXMSGLEN];

        #define szDump   "Dump TWINPAIR: "
        #define szBlank  "               "

        if (IsFlagClear(g_uDumpFlags, DF_TWINPAIR))
            {
            return;
            }

        wsprintf(szBuf, "%s.pszName = %s\r\n", (LPSTR)szDump, Dbg_SafeStr(pitem->pszName));
        OutputDebugString(szBuf);
        wsprintf(szBuf, "%s.uStyle = %lx\r\n", (LPSTR)szBlank, pitem->uStyle);
        OutputDebugString(szBuf);
        wsprintf(szBuf, "%s.uAction = %s\r\n", (LPSTR)szBlank, DumpRecAction(pitem->uAction));
        OutputDebugString(szBuf);

        #undef szDump
        #define szDump   "       Inside: "
        wsprintf(szBuf, "%s.pszDir = %s\r\n", (LPSTR)szDump, Dbg_SafeStr(pitem->siInside.pszDir));
        OutputDebugString(szBuf);
        wsprintf(szBuf, "%s.uState = %s\r\n", (LPSTR)szBlank, DumpSideItemState(pitem->siInside.uState));
        OutputDebugString(szBuf);

        #undef szDump
        #define szDump   "      Outside: "
        wsprintf(szBuf, "%s.pszDir = %s\r\n", (LPSTR)szDump, Dbg_SafeStr(pitem->siOutside.pszDir));
        OutputDebugString(szBuf);
        wsprintf(szBuf, "%s.uState = %s\r\n", (LPSTR)szBlank, DumpSideItemState(pitem->siOutside.uState));
        OutputDebugString(szBuf);

        #undef szDump
        #undef szBlank
        }
    }


#endif


/*----------------------------------------------------------
Purpose: Create a monochrome bitmap of the bullet, so we can
         play with the colors later.
Returns: handle to bitmap
Cond:    Caller must delete bitmap
*/
HBITMAP PRIVATE CreateBulletBitmap(
    LPSIZE psize)
    {
    HDC hdcMem;
    HBITMAP hbmp = NULL;

    hdcMem = CreateCompatibleDC(NULL);
    if (hdcMem)
        {
        hbmp = CreateCompatibleBitmap(hdcMem, psize->cx, psize->cy);
        if (hbmp)
            {
            HBITMAP hbmpOld;
            RECT rc;

            // hbmp is monochrome

            hbmpOld = SelectBitmap(hdcMem, hbmp);
            rc.left = 0;
            rc.top = 0;
            rc.right = psize->cx;
            rc.bottom = psize->cy;
            DrawFrameControl(hdcMem, &rc, DFC_MENU, DFCS_MENUBULLET);

            SelectBitmap(hdcMem, hbmpOld);
            }
        DeleteDC(hdcMem);
        }
    return hbmp;
    }


/*----------------------------------------------------------
Purpose: Returns the resource ID string given the action
         flag.
Returns: IDS_ value
Cond:    --
*/
UINT PRIVATE GetActionText(
    LPRA_PRIV ppriv)
    {
    UINT ids;

    ASSERT(ppriv);

    switch (ppriv->uAction)
        {
    case RAIA_TOOUT:
        if (SI_NEW == ppriv->siInside.uState)
            {
            ids = IDS_STATE_Creates;
            }
        else
            {
            ids = IDS_STATE_Replaces;
            }
        break;

    case RAIA_TOIN:
        if (SI_NEW == ppriv->siOutside.uState)
            {
            ids = IDS_STATE_Creates;
            }
        else
            {
            ids = IDS_STATE_Replaces;
            }
        break;

    case RAIA_SKIP:         
        // Can occur if the user explicitly wants to skip, or if
        // one side is unavailable.
        ids = IDS_STATE_Skip;           
        break;

    case RAIA_CONFLICT:     ids = IDS_STATE_Conflict;       break;
    case RAIA_MERGE:        ids = IDS_STATE_Merge;          break;
    case RAIA_NOTHING:      ids = IDS_STATE_Uptodate;       break;
    case RAIA_SOMETHING:    ids = IDS_STATE_NeedToUpdate;   break;
    default:                ids = 0;                        break;
        }

    return ids;
    }


/*----------------------------------------------------------
Purpose: Repaint an item in the listbox
Returns: --
Cond:    --
*/
void PRIVATE ListBox_RepaintItemNow(
    HWND hwnd,
    int iItem,
    LPRECT prc,         // Relative to individual entry rect.  May be NULL
    BOOL bEraseBk)
    {
    RECT rc;
    RECT rcItem;

    ListBox_GetItemRect(hwnd, iItem, &rcItem);
    if (prc)
        {
        OffsetRect(prc, rcItem.left, rcItem.top);
        IntersectRect(&rc, &rcItem, prc);
        }
    else
        rc = rcItem;

    InvalidateRect(hwnd, &rc, bEraseBk);
    UpdateWindow(hwnd);
    }


/*----------------------------------------------------------
Purpose: Send selection change notification
Returns: 
Cond:    --
*/
BOOL PRIVATE RecAct_SendSelChange(
    LPRECACT this,
    int isel)
    {
    NM_RECACT nm;
    
    nm.iItem = isel;
    nm.mask = 0;
    
    if (isel != -1)
        {
        LPRA_ITEM pitem;
        
        ListBox_GetText(this->hwndLB, isel, &pitem);
        if (!pitem)
            return FALSE;
        
        nm.lParam = pitem->lParam;
        nm.mask |= RAIF_LPARAM;
        }
    
    return !(BOOL)SendNotify(GetParent(this->hwnd), this->hwnd, RN_SELCHANGED, &nm.hdr);
    }


/*----------------------------------------------------------
Purpose: Send an action change notification
Returns: 
Cond:    --
*/
BOOL PRIVATE RecAct_SendItemChange(
    LPRECACT this,
    int iEntry,
    UINT uActionOld)
    {
    NM_RECACT nm;
    
    nm.iItem = iEntry;
    nm.mask = 0;
    
    if (iEntry != -1)
        {
        LPRA_PRIV ppriv;
        
        ListBox_GetText(this->hwndLB, iEntry, &ppriv);
        if (!ppriv)
            return FALSE;
        
        nm.mask |= RAIF_LPARAM | RAIF_ACTION;
        nm.lParam = ppriv->lParam;
        nm.uAction = ppriv->uAction;
        nm.uActionOld = uActionOld;
        }
    
    return !(BOOL)SendNotify(GetParent(this->hwnd), this->hwnd, RN_ITEMCHANGED, &nm.hdr);
    }


/*----------------------------------------------------------
Purpose: Calculate the important coordinates that we want to save.
Returns: --
Cond:    --
*/
void PRIVATE RecAct_CalcCoords(
    LPRECACT this)
    {
    int xOutColumn;
      
    ASSERT(this->cxSideItem != 0);
      
    xOutColumn = this->cxItem - this->cxSideItem - g_cxMargin;

    this->xAction = (RecAct_IsNoIcon(this) ? 0 : X_INCOLUMN) + this->cxSideItem;
    this->cxAction = xOutColumn - this->xAction;
    }


/*----------------------------------------------------------
Purpose: Create the action context menu
Returns: TRUE on success
Cond:    --
*/
BOOL PRIVATE RecAct_CreateMenu(
    LPRECACT this)
    {
    HMENU hmenu;

    hmenu = CreatePopupMenu();
    if (hmenu)
        {
        char sz[MAXSHORTLEN];
        MENUITEMINFO mii;
        int i;

        // Add the help menu items now, since these will be standard
        //
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
        mii.fType = MFT_STRING;
        mii.fState = MFS_ENABLED;

        for (i = 0; i < ARRAYSIZE(c_rghmid); i++)
            {
            mii.wID = c_rghmid[i].idm;
            mii.dwTypeData = SzFromIDS(c_rghmid[i].ids, sz, sizeof(sz));
            InsertMenuItem(hmenu, i, TRUE, &mii);
            }

        this->hmenu = hmenu;
        }

    return hmenu != NULL;
    }


/*----------------------------------------------------------
Purpose: Add the action menu items to the context menu
Returns: --
Cond:    --
*/
void PRIVATE AddActionsToContextMenu(
    HMENU hmenu,
    UINT idmCheck,      // menu item to checkmark
    LPRA_PRIV ppriv)
    {
    MENUITEMINFO mii;
    int i;
    int cItems = ARRAYSIZE(c_rgramid);

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID | MIIM_DATA;
    mii.fType = MFT_OWNERDRAW;
    mii.fState = MFS_ENABLED;

    // Is merge supported?
    if (IsFlagClear(ppriv->uStyle, RAIS_CANMERGE))
        {
        // No
        --cItems;
        }

    for (i = 0; i < cItems; i++)
        {
        mii.wID = c_rgramid[i].idm;
        mii.dwItemData = (DWORD)&c_rgramid[i];

        InsertMenuItem(hmenu, i, TRUE, &mii);
        }

    // Add the separator
    mii.fMask = MIIM_TYPE;
    mii.fType = MFT_SEPARATOR;
    InsertMenuItem(hmenu, i, TRUE, &mii);

    // Set the initial checkmark.  
    CheckMenuRadioItem(hmenu, IDM_ACTIONFIRST, IDM_ACTIONLAST, idmCheck, 
        MF_BYCOMMAND | MF_CHECKED);

#if 0
    // Is merge supported?
    if (IsFlagClear(ppriv->uStyle, RAIS_CANMERGE))
        {
        // No
        mii.fMask = MIIM_STATE;
        mii.fState = MFS_GRAYED | MFS_DISABLED;
        SetMenuItemInfo(hmenu, IDM_MERGE, FALSE, &mii);
        }
#endif
	 //tHACK
	 mii.fMask = MIIM_STATE;
	 mii.fState = MFS_GRAYED | MFS_DISABLED;
	 SetMenuItemInfo(hmenu, IDM_SKIP, FALSE, &mii);

    // Is the file or its sync copy unavailable?
    if (SI_UNAVAILABLE == ppriv->siInside.uState ||
        SI_UNAVAILABLE == ppriv->siOutside.uState)
        {
        // Yes
        mii.fMask = MIIM_STATE;
        mii.fState = MFS_GRAYED | MFS_DISABLED;
        SetMenuItemInfo(hmenu, IDM_TOIN, FALSE, &mii);
        SetMenuItemInfo(hmenu, IDM_TOOUT, FALSE, &mii);
        SetMenuItemInfo(hmenu, IDM_MERGE, FALSE, &mii);
        }

    // Is the file being created?
    else if (ppriv->siInside.uState == SI_NEW ||
        ppriv->siOutside.uState == SI_NEW)
        {
        // Yes; disable the replace-in-opposite direction 
        UINT idmDisable;
        UINT idmChangeVerb;

        if (ppriv->siInside.uState == SI_NEW)
            {
            idmDisable = IDM_TOIN;
            idmChangeVerb = IDM_TOOUT;
            i = IRAMID_CREATEOUT;
            }
        else
            {
            idmDisable = IDM_TOOUT;
            idmChangeVerb = IDM_TOIN;
            i = IRAMID_CREATEIN;
            }
            
        // Disable one of the directions
        mii.fMask = MIIM_STATE;
        mii.fState = MFS_GRAYED | MFS_DISABLED;
        SetMenuItemInfo(hmenu, idmDisable, FALSE, &mii);

        // Change the verb of the other direction
        mii.fMask = MIIM_DATA;
        mii.dwItemData = (DWORD)&c_rgramidCreates[i];

        SetMenuItemInfo(hmenu, idmChangeVerb, FALSE, &mii);
        }
    }


/*----------------------------------------------------------
Purpose: Clear out the context menu
Returns: --
Cond:    --
*/
void PRIVATE ResetContextMenu(
    HMENU hmenu)
    {
    int cnt;

    // If there is more than just the help items, remove them
    //  (but leave the help items)
    //
    cnt = GetMenuItemCount(hmenu);
    if (cnt > ARRAYSIZE(c_rghmid))
        {
        int i;

        cnt -= ARRAYSIZE(c_rghmid);
        for (i = 0; i < cnt; i++)
            {
            DeleteMenu(hmenu, 0, MF_BYPOSITION);
            }
        }
    }


/*----------------------------------------------------------
Purpose: Do the context menu
Returns: --
Cond:    --
*/
void PRIVATE RecAct_DoContextMenu(
    LPRECACT this,
    int x,              // in screen coords
    int y,
    int iEntry,
    BOOL bHelpOnly)     // TRUE: only show the help items
    {
    UINT idCmd;

    if (this->hmenu)
        {
        LPRA_PRIV ppriv;
        RECT rc;
        int idmCheck;
        UINT uActionOld;

        // Only show help-portion of context menu?
        if (bHelpOnly)
            {
            // Yes
            ppriv = NULL;
            }
        else
            {
            // No
            ListBox_GetText(this->hwndLB, iEntry, &ppriv);

            // Determine if this is a help-context menu only.
            //  It is if this is a folder-item or if there is no action
            //  to take.
            //
            ASSERT(ppriv->uAction < ARRAYSIZE(c_mpraiaidmMenu));
            idmCheck = c_mpraiaidmMenu[ppriv->uAction];

            // Build the context menu
            //
            if (IsFlagClear(ppriv->uStyle, RAIS_FOLDER) && idmCheck != 0)
                {
                AddActionsToContextMenu(this->hmenu, idmCheck, ppriv);
                }
            }

        // Show context menu
        //
        idCmd = TrackPopupMenu(this->hmenu, 
                    TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                    x, y, 0, this->hwnd, NULL);

        // Clear menu
        //
        ResetContextMenu(this->hmenu);

        if (ppriv)
            {
            // Save the old action
            uActionOld = ppriv->uAction;
            }

        // Act on whatever the user chose
        switch (idCmd)
            {
        case IDM_TOOUT:
            ppriv->uAction = RAIA_TOOUT;
            break;

        case IDM_TOIN:
            ppriv->uAction = RAIA_TOIN;
            break;

        case IDM_SKIP:
            ppriv->uAction = RAIA_SKIP;
            break;

        case IDM_MERGE:
            ppriv->uAction = RAIA_MERGE;
            break;

// tHACK        case IDM_WHATSTHIS:
//            WinHelp(this->hwnd, c_szWinHelpFile, HELP_CONTEXTPOPUP, IDH_BFC_UPDATE_SCREEN);
//            return;         // Return now

        default:
            return;         // Return now
            }

        // Repaint action portion of entry
        ppriv->cx = RECOMPUTE;
        rc = ppriv->rgdobj[IDOBJ_ACTION].rcBounding;
        ListBox_RepaintItemNow(this->hwndLB, iEntry, &rc, TRUE);

        // Send a notify message
        ASSERT(NULL != ppriv);      // uActionOld should be valid
        RecAct_SendItemChange(this, iEntry, uActionOld);
        }
    }


/*----------------------------------------------------------
Purpose: Create the windows for this control
Returns: TRUE on success
Cond:    --
*/
BOOL PRIVATE RecAct_CreateWindows(
    LPRECACT this,
    CREATESTRUCT FAR * lpcs)
    {
    HWND hwnd = this->hwnd;
    HWND hwndLB = NULL;
    RECT rc;
    int cxEdge = GetSystemMetrics(SM_CXEDGE);
    int cyEdge = GetSystemMetrics(SM_CYEDGE);

    // Create listbox
    hwndLB = CreateWindowEx(
                0, 
                "listbox",
                "",
                WS_CHILD | WS_CLIPSIBLINGS | LBS_SORT | LBS_OWNERDRAWVARIABLE |
                WS_VSCROLL | WS_TABSTOP | WS_VISIBLE | LBS_NOINTEGRALHEIGHT |
                LBS_NOTIFY,
                0, 0, lpcs->cx, lpcs->cy,
                hwnd,
                NULL,
                lpcs->hInstance,
                0L);
    if (!hwndLB)
        return FALSE;

    SetWindowFont(hwndLB, this->hfont, FALSE);

    this->hwndLB = hwndLB;

    // Determine layout of window
    GetClientRect(hwnd, &rc);
    InflateRect(&rc, -cxEdge, -cyEdge);
    SetWindowPos(hwndLB, NULL, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top,
        SWP_NOACTIVATE | SWP_SHOWWINDOW | SWP_NOZORDER);

    GetClientRect(hwndLB, &rc);
    this->cxItem = rc.right - rc.left;

    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Set the colors of the control
Returns: --
Cond:    --
*/
void PRIVATE RecAct_SetColors(
    LPRECACT this)
    {
    int cr;

    if (IsFlagClear(this->lStyle, RAS_SINGLEITEM))
        {
        cr = COLOR_WINDOW;
        }
    else
        {
        cr = COLOR_3DFACE;
        }

    this->clrBkgnd = GetSysColor(cr);

    if (this->hbrBkgnd)
        DeleteBrush(this->hbrBkgnd);

    this->hbrBkgnd = CreateSolidBrush(this->clrBkgnd);
    }


/*----------------------------------------------------------
Purpose: Creates an imagelist of the action images

Returns: TRUE on success

Cond:    --
*/
BOOL PRIVATE CreateImageList(
    HIMAGELIST * phiml,
    HDC hdc,
    UINT idb,
    int cxBmp,
    int cyBmp,
    int cImage)
    {
    BOOL bRet;
    HIMAGELIST himl;

    himl = ImageList_Create(cxBmp, cyBmp, TRUE, cImage, 1);

    if (himl)
        {
        COLORREF clrMask;
        HBITMAP hbm;

        hbm = LoadBitmap(vhinstCur, MAKEINTRESOURCE(idb));
        ASSERT(hbm);

        if (hbm)
            {
            HDC hdcMem = CreateCompatibleDC(hdc);
            if (hdcMem)
                {
                HBITMAP hbmSav = SelectBitmap(hdcMem, hbm);

                clrMask = GetPixel(hdcMem, 0, 0);
                SelectBitmap(hdcMem, hbmSav);

                bRet = (0 == ImageList_AddMasked(himl, hbm, clrMask));

                DeleteDC(hdcMem);
                }
            else
                bRet = FALSE;

            DeleteBitmap(hbm);
            }
        else
            bRet = FALSE;
        }
    else
        bRet = FALSE;

    *phiml = himl;
    return bRet;
    }


/*----------------------------------------------------------
Purpose: WM_CREATE handler
Returns: TRUE on success
Cond:    --
*/
BOOL PRIVATE RecAct_OnCreate(
    LPRECACT this,
    CREATESTRUCT FAR * lpcs)
    {
    BOOL bRet = FALSE;
    HWND hwnd = this->hwnd;
    HDC hdc;
    TEXTMETRIC tm;
    RECT rcT;
    LOGFONT lf;

    this->lStyle = GetWindowLong(hwnd, GWL_STYLE);
    RecAct_SetColors(this);

    // Determine some font things

    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
    this->hfont = CreateFontIndirect(&lf);

    // This window is registered with the CS_OWNDC flag
    this->hdcOwn = GetDC(hwnd);
    ASSERT(this->hdcOwn);

    hdc = this->hdcOwn;

    SelectFont(hdc, this->hfont);
    GetTextMetrics(hdc, &tm);
    this->cyText = tm.tmHeight;

    // Calculate text extent for sideitems (use the listbox font)
    //
    SetRectFromExtent(hdc, &rcT, c_szEllipses);
    this->cxEllipses = rcT.right - rcT.left;

    SetRectFromExtent(hdc, &rcT, c_szDateDummy);
    this->cxSideItem = (rcT.right - rcT.left) + 2*g_cxMargin;

    // Create windows used by control
    if (RecAct_CreateWindows(this, lpcs))
        {
        RecAct_CalcCoords(this);

        this->lpfnLBProc = SubclassWindow(this->hwndLB, RecActLB_LBProc);

        // Get the system imagelist cache
        //
        this->himlCache = ImageList_Create(g_cxIcon, g_cyIcon, TRUE, 8, 8);
        if (this->himlCache)
            {
            if (CreateImageList(&this->himlAction, hdc, IDB_ACTIONS,
                CX_ACTIONBMP, CY_ACTIONBMP, 8))
                {
                SIZE size;

                // Get some metrics
                this->cxMenuCheck = GetSystemMetrics(SM_CXMENUCHECK);
                this->cyMenuCheck = GetSystemMetrics(SM_CYMENUCHECK);

                size.cx = this->cxMenuCheck;
                size.cy = this->cyMenuCheck;
                this->hbmpBullet = CreateBulletBitmap(&size);
                if (this->hbmpBullet)
                    {
                    bRet = RecAct_CreateMenu(this);
                    }
                }
            }
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: WM_DESTROY Handler
Returns: --
Cond:    --
*/
void PRIVATE RecAct_OnDestroy(
    LPRECACT this)
    {
    if (this->himlCache)
        {
        ImageList_Destroy(this->himlCache);
        this->himlCache = NULL;
        }

    if (this->himlAction)
        {
        ImageList_Destroy(this->himlAction);
        this->himlAction = NULL;
        }
    
    if (this->hbmpBullet)
        {
        DeleteBitmap(this->hbmpBullet);
        this->hbmpBullet = NULL;
        }

    if (this->hmenu)
        {
        DestroyMenu(this->hmenu);
        this->hmenu = NULL;
        }

    if (this->hbrBkgnd)
        DeleteBrush(this->hbrBkgnd);

    if (this->hfont)
        DeleteFont(this->hfont);
    }


/*----------------------------------------------------------
Purpose: WM_COMMAND Handler
Returns: --
Cond:    --
*/
VOID PRIVATE RecAct_OnCommand(
    LPRECACT this,
    int id,
    HWND hwndCtl,
    UINT uNotifyCode)
    {
    if (hwndCtl == this->hwndLB)
        {
        switch (uNotifyCode)
            {
        case LBN_SELCHANGE:
            break;
            }
        }
    }


/*----------------------------------------------------------
Purpose: WM_NOTIFY handler
Returns: varies
Cond:    --
*/
LRESULT PRIVATE RecAct_OnNotify(
    LPRECACT this,
    int idFrom,
    NMHDR FAR * lpnmhdr)
    {
    LRESULT lRet = 0;

    switch (lpnmhdr->code)
        {
    case HDN_BEGINTRACK:
        lRet = TRUE;       // prevent tracking
        break;

    default:
        break;
        }

    return lRet;
    }


/*----------------------------------------------------------
Purpose: WM_CONTEXTMENU handler
Returns: --
Cond:    --
*/
void PRIVATE RecAct_OnContextMenu(
    LPRECACT this,
    HWND hwnd,
    int x,
    int y)
    {
    if (hwnd == this->hwndLB)
        {
        POINT pt;
        int iHitEntry;
        BOOL bHelpOnly = TRUE;
    
        pt.x = x;
        pt.y = y;
        ScreenToClient(hwnd, &pt);
        iHitEntry = (pt.y / ListBox_GetItemHeight(hwnd, 0)) + ListBox_GetTopIndex(hwnd);

        ASSERT(iHitEntry >= 0);
    
        if (iHitEntry < ListBox_GetCount(hwnd))
            {
            ListBox_SetCurSel(hwnd, iHitEntry);
            ListBox_RepaintItemNow(hwnd, iHitEntry, NULL, FALSE);

            bHelpOnly = FALSE;
            }

        // Bring up the context menu for the listbox
        RecAct_DoContextMenu(this, x, y, iHitEntry, bHelpOnly);
        }
    }


/*----------------------------------------------------------
Purpose: Calculate the rectangle boundary of a sideitem

Returns: calculated rect
Cond:    --
*/
void PRIVATE RecAct_CalcSideItemRect(
    LPRECACT this,
    int nSide,          // SIDE_INSIDE or SIDE_OUTSIDE
    LPRECT prcOut)
    {
    int x;
    int y = g_cyIconMargin*2;

    if (SIDE_INSIDE == nSide)
        {
        x = g_cxMargin;
        if ( !RecAct_IsNoIcon(this) )
            x += X_INCOLUMN;
        }
    else
        {
        ASSERT(SIDE_OUTSIDE == nSide);
        x = this->cxItem - this->cxSideItem - g_cxMargin;
        }

    prcOut->left   = x;
    prcOut->top    = y;
    prcOut->right  = x + this->cxSideItem;
    prcOut->bottom = y + (this->cyText * 3);
    }


/*----------------------------------------------------------
Purpose: Draw a reconciliation listbox entry
Returns: --
Cond:    --
*/
void PRIVATE RecAct_RecomputeItemMetrics(
    LPRECACT this,
    LPRA_PRIV ppriv)
    {
    HDC hdc = this->hdcOwn;
    LPDOBJ pdobj = ppriv->rgdobj;
    RECT rcT;
    RECT rcUnion;
    char szIDS[MAXBUFLEN];
    UINT ids;
    int cyText = this->cyText;
    POINT pt;

    // Compute the metrics and dimensions of each of the draw objects
    // and store back into the item.

    // File icon and label

    pt.x = 0;
    pt.y = 0;
    ComputeImageRects(FIGetDisplayName(ppriv->pfi), hdc, &pt, 
        &pdobj->rcBounding, &pdobj->rcLabel, g_cxIcon, g_cyIcon, 
        g_cxIconSpacing, cyText);

    pdobj->uKind = DOK_IMAGE;
    pdobj->lpvObject = FIGetDisplayName(ppriv->pfi);
    pdobj->uFlags = DOF_DIFFER | DOF_CENTER;
    if (RecAct_IsNoIcon(this))
        SetFlag(pdobj->uFlags, DOF_NODRAW);
    pdobj->x = pt.x;
    pdobj->y = pt.y;
    pdobj->himl = this->himlCache;
    pdobj->iImage = (UINT)ppriv->pfi->lParam;

    rcUnion = pdobj->rcBounding;

    // Sideitem Info (Inside Briefcase)

    RecAct_CalcSideItemRect(this, SIDE_INSIDE, &rcT);

    pdobj++;
    pdobj->uKind = DOK_SIDEITEM;
    pdobj->lpvObject = &ppriv->siInside;
    pdobj->uFlags = DOF_LEFT;
    pdobj->x = rcT.left;
    pdobj->y = rcT.top;
    pdobj->rcClip = rcT;
    pdobj->rcBounding = rcT;

    // Sideitem Info (Outside Briefcase)

    RecAct_CalcSideItemRect(this, SIDE_OUTSIDE, &rcT);

    pdobj++;
    pdobj->uKind = DOK_SIDEITEM;
    pdobj->lpvObject = &ppriv->siOutside;
    pdobj->uFlags = DOF_LEFT;
    pdobj->x = rcT.left;
    pdobj->y = rcT.top;
    pdobj->rcClip = rcT;
    pdobj->rcBounding = rcT;

    UnionRect(&rcUnion, &rcUnion, &rcT);

    // Action image

    ASSERT(ppriv->uAction <= ARRAYSIZE(c_mpraiaiImage));

    pdobj++;

    ids = GetActionText(ppriv);
    pt.x = this->xAction;
    pt.y = 0;
    ComputeImageRects(SzFromIDS(ids, szIDS, sizeof(szIDS)), hdc, &pt,
        &pdobj->rcBounding, &pdobj->rcLabel, CX_ACTIONBMP, CY_ACTIONBMP, 
        this->cxAction, cyText);

    pdobj->uKind = DOK_IMAGE;
    pdobj->lpvObject = (LPVOID)ids;
    pdobj->uFlags = DOF_CENTER | DOF_USEIDS;
    if (!RecAct_IsNoIcon(this))
        SetFlag(pdobj->uFlags, DOF_IGNORESEL);
    pdobj->x = pt.x;
    pdobj->y = pt.y;
    pdobj->himl = this->himlAction;
    pdobj->iImage = c_mpraiaiImage[ppriv->uAction];

    UnionRect(&rcUnion, &rcUnion, &pdobj->rcBounding);

    // Set the bounding rect of this item.
    ppriv->cx = rcUnion.right - rcUnion.left;
    ppriv->cy = max((rcUnion.bottom - rcUnion.top), g_cyIconSpacing);
    }


/*----------------------------------------------------------
Purpose: WM_MEASUREITEM handler
Returns: --
Cond:    --
*/
void PRIVATE RecAct_OnMeasureItem(
    LPRECACT this,
    LPMEASUREITEMSTRUCT lpmis)
    {
    HDC hdc = this->hdcOwn;

    switch (lpmis->CtlType)
        {
    case ODT_LISTBOX: {
        LPRA_PRIV ppriv = (LPRA_PRIV)lpmis->itemData;
        
        // Recompute item metrics?
        if (RECOMPUTE == ppriv->cx)
            {
            RecAct_RecomputeItemMetrics(this, ppriv);   // Yes
            }

        lpmis->itemHeight = ppriv->cy;
        }
        break;

    case ODT_MENU:
        {
        int i;
        int cxMac = 0;
        RECT rc;
        char sz[MAXBUFLEN];

        // Calculate based on font and image dimensions.
        //
        SelectFont(hdc, this->hfont);

        cxMac = 0;
        for (i = 0; i < ARRAYSIZE(c_rgramid); i++)
            {
            SzFromIDS(c_rgramid[i].ids, sz, sizeof(sz));
            SetRectFromExtent(hdc, &rc, sz);
            cxMac = max(cxMac, 
                        g_cxMargin + CX_ACTIONBMP + g_cxMargin + 
                        (rc.right-rc.left) + g_cxMargin);
            }

        lpmis->itemHeight = max(this->cyText, CY_ACTIONBMP);
        lpmis->itemWidth = cxMac;
        }
        break;
        }
    }


/*----------------------------------------------------------
Purpose: Draw a reconciliation listbox entry
Returns: --
Cond:    --
*/
void PRIVATE RecAct_DrawLBItem(
    LPRECACT this,
    const DRAWITEMSTRUCT FAR * lpcdis)
    {
    LPRA_PRIV ppriv = (LPRA_PRIV)lpcdis->itemData;
    HDC hdc = lpcdis->hDC;
    RECT rc = lpcdis->rcItem;
    POINT ptSav;
    LPDOBJ pdobj;
    UINT cdobjs;

    if (!ppriv)
        {
        // Empty listbox and we're getting the focus
        return;
        }

    SetBkMode(hdc, TRANSPARENT);        // required for Shell_DrawText
    SetViewportOrgEx(hdc, rc.left, rc.top, &ptSav);

    // The Chicago-look mandates that icon and filename are selected, 
    //  the rest of the entry is normal.  Yuk.

    // Recompute item metrics?
    if (RECOMPUTE == ppriv->cx)
        {
        RecAct_RecomputeItemMetrics(this, ppriv);   // Yes
        }

    // Do we need to redraw everything?
    if (IsFlagSet(lpcdis->itemAction, ODA_DRAWENTIRE))
        {
        // Yes
        cdobjs = ARRAYSIZE(ppriv->rgdobj);
        pdobj = ppriv->rgdobj;
        }
    else
        {
        // No; should we even draw the file icon or action icon?
        if (lpcdis->itemAction & (ODA_FOCUS | ODA_SELECT))
            {
            cdobjs = 1;     // Yes

            // Focus rect on file icon?
            if (!RecAct_IsNoIcon(this))
                pdobj = ppriv->rgdobj;
            else
                pdobj = &ppriv->rgdobj[IDOBJ_ACTION];
            }
        else
            {
            cdobjs = 0;     // No
            pdobj = ppriv->rgdobj;
            }
        }

    Dobj_Draw(hdc, pdobj, cdobjs, lpcdis->itemState, this->cxEllipses, this->cyText,
        this->clrBkgnd);
    
    // Clean up
    //
    SetViewportOrgEx(hdc, ptSav.x, ptSav.y, NULL);
    }


/*----------------------------------------------------------
Purpose: Draw an action menu item
Returns: --
Cond:    --
*/
void PRIVATE RecAct_DrawMenuItem(
    LPRECACT this,
    const DRAWITEMSTRUCT FAR * lpcdis)
    {
    LPRAMID pramid = (LPRAMID)lpcdis->itemData;
    HDC hdc = lpcdis->hDC;
    RECT rc = lpcdis->rcItem;
    DOBJ dobj;
    LPDOBJ pdobj;
    POINT ptSav;
    MENUITEMINFO mii;
    int cx;
    int cy;
    UINT uFlags;
    UINT uFlagsChecked;

    ASSERT(pramid);
    
    if (lpcdis->itemID == -1)
        return;

    SetViewportOrgEx(hdc, rc.left, rc.top, &ptSav);
    OffsetRect(&rc, -rc.left, -rc.top);

    cx = rc.right - rc.left;
    cy = rc.bottom - rc.top;

    // Get the menu state 
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_STATE | MIIM_CHECKMARKS;
    GetMenuItemInfo(this->hmenu, lpcdis->itemID, FALSE, &mii);
    uFlagsChecked = IsFlagClear(mii.fState, MFS_CHECKED) ? DOF_NODRAW : 0;

    uFlags = DOF_DIFFER | DOF_MENU | DOF_USEIDS;
    if (IsFlagSet(mii.fState, MFS_GRAYED))
        SetFlag(uFlags, DOF_DISABLED);

    // Build the array of DObjs that we want to draw.

    // Action image

    pdobj = &dobj;

    pdobj->uKind = DOK_IMAGE;
    pdobj->lpvObject = (LPVOID)pramid->ids;
    pdobj->himl = this->himlAction;
    pdobj->iImage = pramid->iImage;
    pdobj->uFlags = uFlags;
    pdobj->x = g_cxMargin;
    pdobj->y = (cy - CY_ACTIONBMP) / 2;
    pdobj->rcLabel.left = 0;
    pdobj->rcLabel.right = cx;
    pdobj->rcLabel.top = 0;
    pdobj->rcLabel.bottom = cy;

    // Draw the entry...
    //
    Dobj_Draw(hdc, &dobj, 1, lpcdis->itemState, 0, this->cyText, this->clrBkgnd);
    
    // Clean up
    //
    SetViewportOrgEx(hdc, ptSav.x, ptSav.y, NULL);
    }


/*----------------------------------------------------------
Purpose: WM_DRAWITEM handler
Returns: --
Cond:    --
*/
void PRIVATE RecAct_OnDrawItem(
    LPRECACT this,
    const DRAWITEMSTRUCT FAR * lpcdis)
    {
    switch (lpcdis->CtlType)
        {
    case ODT_LISTBOX:
        RecAct_DrawLBItem(this, lpcdis);
        break;

    case ODT_MENU:
        RecAct_DrawMenuItem(this, lpcdis);
        break;
        }
    }


/*----------------------------------------------------------
Purpose: WM_COMPAREITEM handler
Returns: -1 (item 1 precedes item 2), 0 (equal), 1 (item 2 precedes item 1)
Cond:    --
*/
int PRIVATE RecAct_OnCompareItem(
    LPRECACT this,
    const COMPAREITEMSTRUCT FAR * lpcis)
    {
    LPRA_PRIV ppriv1 = (LPRA_PRIV)lpcis->itemData1;
    LPRA_PRIV ppriv2 = (LPRA_PRIV)lpcis->itemData2;

    // We sort based on name of file
    //
    return lstrcmpi(FIGetPath(ppriv1->pfi), FIGetPath(ppriv2->pfi));
    }


/*----------------------------------------------------------
Purpose: WM_DELETEITEM handler
Returns: --
Cond:    --
*/
void RecAct_OnDeleteLBItem(
    LPRECACT this,
    const DELETEITEMSTRUCT FAR * lpcdis)
    {
    switch (lpcdis->CtlType)
        {
    case ODT_LISTBOX:
        {
        LPRA_PRIV ppriv = (LPRA_PRIV)lpcdis->itemData;
        
        ASSERT(ppriv);
    
        if (ppriv)
            {
            FIFree(ppriv->pfi);

            GFree(ppriv->siInside.pszDir);
            GFree(ppriv->siOutside.pszDir);
            GFree(ppriv);
            }
        }
        break;
        }
    }


/*----------------------------------------------------------
Purpose: WM_CTLCOLORLISTBOX handler
Returns: --
Cond:    --
*/
HBRUSH PRIVATE RecAct_OnCtlColorListBox(
    LPRECACT this,
    HDC hdc,
    HWND hwndLB,
    int nType)
    {
    return this->hbrBkgnd;
    }


/*----------------------------------------------------------
Purpose: WM_PAINT handler
Returns: --
Cond:    --
*/
void RecAct_OnPaint(
    LPRECACT this)
    {
    HWND hwnd = this->hwnd;
    PAINTSTRUCT ps;
    RECT rc;
    HDC hdc;

    hdc = BeginPaint(hwnd, &ps);
    GetClientRect(hwnd, &rc);
    if (IsFlagSet(this->lStyle, RAS_SINGLEITEM))
        {
        DrawEdge(hdc, &rc, BDR_SUNKENINNER, BF_TOPLEFT);
        DrawEdge(hdc, &rc, BDR_SUNKENOUTER, BF_BOTTOMRIGHT);
        }
    else
        {
        DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT);
        }

    EndPaint(hwnd, &ps);
    }


/*----------------------------------------------------------
Purpose: WM_SETFONT handler
Returns: --
Cond:    --
*/
void RecAct_OnSetFont(
    LPRECACT this,
    HFONT hfont,
    BOOL bRedraw)
    {
    this->hfont = hfont;
    FORWARD_WM_SETFONT(this->hwnd, hfont, bRedraw, RecAct_DefProc);
    }


/*----------------------------------------------------------
Purpose: WM_SETFOCUS handler
Returns: --
Cond:    --
*/
void RecAct_OnSetFocus(
    LPRECACT this,
    HWND hwndOldFocus)
    {
    SetFocus(this->hwndLB);
    }


/*----------------------------------------------------------
Purpose: WM_SYSCOLORCHANGE handler
Returns: --
Cond:    --
*/
void RecAct_OnSysColorChange(
    LPRECACT this)
    {
    RecAct_SetColors(this);
    InvalidateRect(this->hwnd, NULL, TRUE);
    }


/*----------------------------------------------------------
Purpose: Insert item
Returns: index
Cond:    --
*/
int PRIVATE RecAct_OnInsertItem(
    LPRECACT this,
    const LPRA_ITEM pitem)
    {
    HWND hwndLB = this->hwndLB;
    LPRA_PRIV pprivNew;
    char szPath[MAXPATHLEN];
    int iRet = -1;
    int iItem = LB_ERR;

    ASSERT(pitem);
    ASSERT(pitem->siInside.pszDir);
    ASSERT(pitem->siOutside.pszDir);
    ASSERT(pitem->pszName);

    pprivNew = GAlloc(sizeof(*pprivNew));
    if (pprivNew)
        {
        SetWindowRedraw(hwndLB, FALSE);

        // Fill the prerequisite fields first
        //
        pprivNew->uStyle = pitem->uStyle;
        pprivNew->uAction = pitem->uAction;

        // Set the fileinfo stuff and large icon system-cache index.
        //  If we can't get the fileinfo of the inside file, get the outside
        //  file.  If neither can be found, then we fail
        //
        lstrcpy(szPath, pitem->siInside.pszDir);
        if (IsFlagClear(pitem->uStyle, RAIS_FOLDER))
            PathAppend(szPath, pitem->pszName);
        PathMakePresentable(szPath);

        if (FAILED(FICreate(szPath, &pprivNew->pfi, FIF_ICON)))
            {
            // Try the outside file
            //
            lstrcpy(szPath, pitem->siOutside.pszDir);
            if (IsFlagClear(pitem->uStyle, RAIS_FOLDER))
                PathAppend(szPath, pitem->pszName);
            PathMakePresentable(szPath);

            if (FAILED(FICreate(szPath, &pprivNew->pfi, FIF_ICON)))
                {
                // Don't try to touch the file
                if (FAILED(FICreate(szPath, &pprivNew->pfi, FIF_ICON | FIF_DONTTOUCH)))
                    goto Insert_Cleanup;
                }
            }
        ASSERT(pprivNew->pfi);

        pprivNew->pfi->lParam = (LPARAM)ImageList_AddIcon(this->himlCache, pprivNew->pfi->hicon);

        // Fill in the rest of the fields
        //
        lstrcpy(szPath, pitem->siInside.pszDir);
        if (IsFlagSet(pitem->uStyle, RAIS_FOLDER))
            PathRemoveFileSpec(szPath);
        PathMakePresentable(szPath);
        if (!GSetString(&pprivNew->siInside.pszDir, szPath))
            goto Insert_Cleanup;

        pprivNew->siInside.uState = pitem->siInside.uState;
        pprivNew->siInside.fs = pitem->siInside.fs;

        lstrcpy(szPath, pitem->siOutside.pszDir);
        if (IsFlagSet(pitem->uStyle, RAIS_FOLDER))
            PathRemoveFileSpec(szPath);
        PathMakePresentable(szPath);
        if (!GSetString(&pprivNew->siOutside.pszDir, szPath))
            goto Insert_Cleanup;

        pprivNew->siOutside.uState = pitem->siOutside.uState;
        pprivNew->siOutside.fs = pitem->siOutside.fs;

        pprivNew->lParam = pitem->lParam;

        pprivNew->cx = RECOMPUTE;

        // We know we're doing a redundant sorted add if the element
        //  needs to be inserted at the end of the list, but who cares.
        //
        if (pitem->iItem >= RecAct_GetCount(this))
            iItem = ListBox_AddString(hwndLB, pprivNew);
        else
            iItem = ListBox_InsertString(hwndLB, pitem->iItem, pprivNew);
        
        if (iItem == LB_ERR)
            goto Insert_Cleanup;

        SetWindowRedraw(hwndLB, TRUE);

        iRet = iItem;
        }
    goto Insert_End;

Insert_Cleanup:
    // Have DeleteString handler clean up field allocations
    //  of pitem.
    //
    if (iItem != LB_ERR)
        ListBox_DeleteString(hwndLB, iItem);
    else
        {
        FIFree(pprivNew->pfi);
        GFree(pprivNew);
        }
    SetWindowRedraw(hwndLB, TRUE);
    
Insert_End:

    return iRet;
    }


/*----------------------------------------------------------
Purpose: Delete item
Returns: count of items left
Cond:    --
*/
int PRIVATE RecAct_OnDeleteItem(
    LPRECACT this,
    int i)
    {
    HWND hwndLB = this->hwndLB;
    
    return ListBox_DeleteString(hwndLB, i);
    }


/*----------------------------------------------------------
Purpose: Delete all items
Returns: TRUE 
Cond:    --
*/
BOOL PRIVATE RecAct_OnDeleteAllItems(
    LPRECACT this)
    {
    ListBox_ResetContent(this->hwndLB);
    
    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Get item
Returns: TRUE on success
Cond:    --
*/
BOOL PRIVATE RecAct_OnGetItem(
    LPRECACT this,
    LPRA_ITEM pitem)
    {
    LPRA_PRIV ppriv;
    HWND hwndLB = this->hwndLB;
    UINT uMask;
    int iItem;
    
    if (!pitem)
        return FALSE;
    
    iItem = pitem->iItem;
    uMask = pitem->mask;
    
    ListBox_GetText(hwndLB, iItem, &ppriv);
    
    if (uMask & RAIF_ACTION)
        pitem->uAction = ppriv->uAction;
    
    if (uMask & RAIF_NAME)
        pitem->pszName = FIGetPath(ppriv->pfi);
    
    if (uMask & RAIF_STYLE)
        pitem->uStyle = ppriv->uStyle;
    
    if (uMask & RAIF_INSIDE)
        pitem->siInside = ppriv->siInside;
    
    if (uMask & RAIF_OUTSIDE)
        pitem->siOutside = ppriv->siOutside;
    
    if (uMask & RAIF_LPARAM)
        pitem->lParam = ppriv->lParam;
    
    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Set item
Returns: TRUE on success
Cond:    --
*/
BOOL PRIVATE RecAct_OnSetItem(
    LPRECACT this,
    LPRA_ITEM pitem)
    {
    LPRA_PRIV ppriv;
    HWND hwndLB = this->hwndLB;
    UINT uMask;
    int iItem;

    if (!pitem)
        return FALSE;
    
    uMask = pitem->mask;
    iItem = pitem->iItem;
    
    ListBox_GetText(hwndLB, iItem, &ppriv);
    
    if (uMask & RAIF_ACTION)
        ppriv->uAction = pitem->uAction;
    
    if (uMask & RAIF_STYLE)
        ppriv->uStyle = pitem->uStyle;
    
    if (uMask & RAIF_NAME)
        {
        if (!FISetPath(&ppriv->pfi, pitem->pszName, FIF_ICON))
            return FALSE;

        ppriv->pfi->lParam = (LPARAM)ImageList_AddIcon(this->himlCache, ppriv->pfi->hicon);
        }
    
    if (uMask & RAIF_INSIDE)
        {
        if (!GSetString(&ppriv->siInside.pszDir, pitem->siInside.pszDir))
            return FALSE;
        ppriv->siInside.uState = pitem->siInside.uState;
        ppriv->siInside.fs = pitem->siInside.fs;
        }
    
    if (uMask & RAIF_OUTSIDE)
        {
        if (!GSetString(&ppriv->siOutside.pszDir, pitem->siOutside.pszDir))
            return FALSE;
        ppriv->siOutside.uState = pitem->siOutside.uState;
        ppriv->siOutside.fs = pitem->siOutside.fs;
        }
    
    if (uMask & RAIF_LPARAM)
        ppriv->lParam = pitem->lParam;
    
    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Get the current selection
Returns: index
Cond:    --
*/
int PRIVATE RecAct_OnGetCurSel(
    LPRECACT this)
    {
    return ListBox_GetCurSel(this->hwndLB);
    }


/*----------------------------------------------------------
Purpose: Set the current selection
Returns: --
Cond:    --
*/
int PRIVATE RecAct_OnSetCurSel(
    LPRECACT this,
    int i)
    {
    int iRet = ListBox_SetCurSel(this->hwndLB, i);

    if (iRet != LB_ERR)
        RecAct_SendSelChange(this, i);

    return iRet;
    }


/*----------------------------------------------------------
Purpose: Find an item
Returns: TRUE on success
Cond:    --
*/
int PRIVATE RecAct_OnFindItem(
    LPRECACT this,
    int iStart,
    const RA_FINDITEM FAR * prafi)
    {
    HWND hwndLB = this->hwndLB;
    UINT uMask = prafi->flags;
    LPRA_PRIV ppriv;
    BOOL bPass;
    int i;
    int cItems = ListBox_GetCount(hwndLB);

    for (i = iStart+1; i < cItems; i++)
        {
        bPass = TRUE;       // assume we pass

        ListBox_GetText(hwndLB, i, &ppriv);

        if (uMask & RAFI_NAME &&
            !IsSzEqual(FIGetPath(ppriv->pfi), prafi->psz))
            bPass = FALSE;

        if (uMask & RAFI_ACTION && ppriv->uAction != prafi->uAction)
            bPass = FALSE;

        if (uMask & RAFI_LPARAM && ppriv->lParam != prafi->lParam)
            bPass = FALSE;

        if (bPass)
            break;          // found it
        }

    return i == cItems ? -1 : i;
    }


/////////////////////////////////////////////////////  EXPORTED FUNCTIONS


/*----------------------------------------------------------
Purpose: RecAct window proc
Returns: varies
Cond:    --
*/
LRESULT CALLBACK RecAct_WndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
    {
    LPRECACT this = RecAct_GetPtr(hwnd);
    
    if (this == NULL)
        {
        if (msg == WM_NCCREATE)
            {
            this = GAlloc(sizeof(*this));
            ASSERT(this);
            if (!this)
                return 0L;      // OOM failure
            
            this->hwnd = hwnd;
            RecAct_SetPtr(hwnd, this);
            }
        else
            {
            return RecAct_DefProc(hwnd, msg, wParam, lParam);
            }
        }

    if (msg == WM_NCDESTROY)
        {
        GFree(this);
        RecAct_SetPtr(hwnd, NULL);
        }

    switch (msg)
        {
        HANDLE_MSG(this, WM_CREATE, RecAct_OnCreate);
        HANDLE_MSG(this, WM_DESTROY, RecAct_OnDestroy);
        
        HANDLE_MSG(this, WM_SETFONT, RecAct_OnSetFont);
        HANDLE_MSG(this, WM_COMMAND, RecAct_OnCommand);
        HANDLE_MSG(this, WM_NOTIFY, RecAct_OnNotify);
        HANDLE_MSG(this, WM_MEASUREITEM, RecAct_OnMeasureItem);
        HANDLE_MSG(this, WM_DRAWITEM, RecAct_OnDrawItem);
        HANDLE_MSG(this, WM_COMPAREITEM, RecAct_OnCompareItem);
        HANDLE_MSG(this, WM_DELETEITEM, RecAct_OnDeleteLBItem);
        HANDLE_MSG(this, WM_CONTEXTMENU, RecAct_OnContextMenu);
        HANDLE_MSG(this, WM_SETFOCUS, RecAct_OnSetFocus);
        HANDLE_MSG(this, WM_CTLCOLORLISTBOX, RecAct_OnCtlColorListBox);
        HANDLE_MSG(this, WM_PAINT, RecAct_OnPaint);
        HANDLE_MSG(this, WM_SYSCOLORCHANGE, RecAct_OnSysColorChange);

	case RAM_GETITEMCOUNT:
		return (LRESULT)RecAct_GetCount(this);

	case RAM_GETITEM:
		return (LRESULT)RecAct_OnGetItem(this, (LPRA_ITEM)lParam);

	case RAM_SETITEM:
		return (LRESULT)RecAct_OnSetItem(this, (const LPRA_ITEM)lParam);

	case RAM_INSERTITEM:
		return (LRESULT)RecAct_OnInsertItem(this, (const LPRA_ITEM)lParam);

	case RAM_DELETEITEM:
		return (LRESULT)RecAct_OnDeleteItem(this, (int)wParam);

	case RAM_DELETEALLITEMS:
		return (LRESULT)RecAct_OnDeleteAllItems(this);

	case RAM_GETCURSEL:
		return (LRESULT)RecAct_OnGetCurSel(this);

	case RAM_SETCURSEL:
		return (LRESULT)RecAct_OnSetCurSel(this, (int)wParam);

	case RAM_FINDITEM:
		return (LRESULT)RecAct_OnFindItem(this, (int)wParam, (const RA_FINDITEM FAR *)lParam);

	case RAM_REFRESH:
		RedrawWindow(this->hwndLB, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);

	default:
		return RecAct_DefProc(hwnd, msg, wParam, lParam);
		}
	}


/////////////////////////////////////////////////////  PUBLIC FUNCTIONS


/*----------------------------------------------------------
Purpose: Initialize the reconciliation-action window class
Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC RecAct_Init(HINSTANCE hinst)
{
	WNDCLASSEX wc;

	wc.cbSize       = sizeof(WNDCLASSEX);
	wc.style        = CS_DBLCLKS | CS_OWNDC;
	wc.lpfnWndProc  = RecAct_WndProc;
	wc.cbClsExtra   = 0;
	wc.cbWndExtra   = sizeof(LPRECACT);
	wc.hInstance    = hinst;
	wc.hIcon        = NULL;
	wc.hCursor      = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground= NULL;
	wc.lpszMenuName = NULL;
	wc.lpszClassName= WC_RECACT;
	wc.hIconSm      = NULL;

	return (RegisterClassEx(&wc) != 0);
}


/*----------------------------------------------------------
Purpose: Clean up RecAct window class
Returns: --
Cond:    --
*/
void PUBLIC RecAct_Term(
								HINSTANCE hinst)
{
	UnregisterClass(WC_RECACT, hinst);
}


/*----------------------------------------------------------
Purpose: Special sub-class listbox proc 
Returns: varies
Cond:    --
*/
LRESULT _export CALLBACK RecActLB_LBProc(
													  HWND hwnd,          // window handle
													  UINT msg,           // window message
													  WPARAM wparam,      // varies
													  LPARAM lparam)      // varies
{
	LRESULT lRet;
	LPRECACT lpra = NULL;

	// Get the instance data for the control
	lpra = RecAct_GetPtr(GetParent(hwnd));
	ASSERT(lpra);

	switch (msg)
	{
		default:
			lRet = RecActLB_DefProc(lpra->lpfnLBProc, hwnd, msg, wparam, lparam);
			break;
	}

	return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\recon.c ===
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#include "pch.h"

#include "recon.h"
#include "resource.h"

BOOL CALLBACK Recon_DlgProc(
    HWND  hwndDlg,
    UINT  uMsg,
    WPARAM  wParam,
    LPARAM  lParam)
{
    switch (uMsg )
    {
		case WM_INITDIALOG:
			SetWindowLong(hwndDlg, DWL_USER, lParam);
            DEBUG_PRINT(("Reconnect: Init dialog\n"));
			break;

		case WM_DESTROY:
            DEBUG_PRINT(("Reconnect: DestroyDialog\n"));
			break;

		case WM_COMMAND:
        	switch (LOWORD(wParam))
        	{
            }
            return FALSE;
			break;

		default:
			return FALSE;
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\pch.h ===
//--------------------------------------------------------------
// common user interface routines
//
//
//--------------------------------------------------------------


#ifdef CSC_ON_NT

#ifndef DEFINED_UNICODE
#define _UNICODE
#define UNICODE
#define DEFINED_UNICODE
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef ASSERT
#else
#define STRICT
#endif

#define NOWINDOWSX
#define NOSHELLDEBUG
#define DONT_WANT_SHELLDEBUG
#define USE_MONIKER

#define _INC_OLE				// WIN32

#include <tchar.h>
#include <windows.h>
#include <windowsx.h>

#include <shellapi.h>		// for registration functions
#include "port32.h"

#define NO_COMMCTRL_DA
#define NO_COMMCTRL_ALLOCFCNS
#define NO_COMMCTRL_STRFCNS
// the DebugMsg is here because we want OUR Assert, not their stub.
#define DebugMsg    1 ? (void)0 : (void)                                        /* ;Internal */
#include <commctrl.h>

#ifdef CSC_ON_NT
#include <comctrlp.h>
#endif

#include <ole2.h>				// object binding
#include <shlobj.h>			// IContextMenu
#include <shlwapi.h>

#include <stdlib.h>
#include <string.h>			// for string macros
#include <limits.h>			// implementation dependent values
#include <memory.h>

#include <synceng.h>			// Twin Engine include file
#include <cscapi.h>

#ifdef CSC_ON_NT
#ifndef DBG
#define DBG 0
#endif
#if DBG
#define DEBUG
#else
//if we don't do this DEBUG is defined in shdsys.h....sigh
#define NONDEBUG
#endif
#endif //ifdef CSC_ON_NT

/* globals */
extern HANDLE vhinstCur;				// current instance

#include "assert.h"
// Dont link - just do it.
#pragma intrinsic(memcpy,memcmp,memset,strcpy,strlen,strcmp,strcat)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\reint.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    reint.c

Abstract:

    This file contains the fill and merge functions necessary for bot inward and outward
    synchronization of files and directories. It also contains generic database tree-traversal
    code. This is used by merge as well as DoLocalRename API.


    Tree Traversal:
    
        TraverseOneDirectory    // traverses a subtree in the database
        
    Fill Functions:
    
        AttemptCacheFill    Fills the entire cache or a particular share
        DoSparseFill        Fills a particular file
    
    Merge Functions:
    
        ReintOneShare       // reintegrate one share
        ReintAllShares      // reintegrate all shares



Author:
    Trent-Gray-Donald/Shishir Pardikar


Environment:

    Win32 (user-mode) DLL

Revision History:

    1-1-94    original
    4-4-97  removed all the entry points to exports.c
    reint.c

--*/

#include "pch.h"

#pragma hdrstop
#define UNICODE

#ifndef DEBUG
#undef VERBOSE
#else
#undef VERBOSE
#define VERBOSE 1
#endif

#include <winioctl.h>

#include "lib3.h"
#include "shdsys.h"
#include "reint.h"
#include "utils.h"
#include "resource.h"
#include "traynoti.h"
#include <dbt.h>
#include "strings.h"

#include "csc_bmpu.h"

// this sets flags in a couple of headers to not include some defs.
#define REINT
#include "list.h"
#include "merge.h"
#include "recact.h"
#include "recon.h"  // reconnect shares dialog
#include "reint.h"
#include "aclapi.h"

//
// Defines
//

#define chNull '\0'    // terminator

#define BUFF_SIZE 64


#define MAX_WAIT_PERIODS       1
#define MAX_ATTEMPTS           1

#define MAX_ATTEMPTS_SHARE    1
#define MAX_ATTEMPTS_SHADOW    5
#define MAX_SPARSE_FILL_RETRIES 4



#define  STATE_REINT_BEGIN    0

#define  STATE_REINT_CREATE_DIRS    STATE_REINT_BEGIN
#define  STATE_REINT_FILES          (STATE_REINT_CREATE_DIRS+1)
#define  STATE_REINT_END            (STATE_REINT_FILES+1)

#define  MAX_EXCLUSION_STRING 1024


// for some Registry queries, this is the max len buffer that I want back
#define MAX_NAME_LEN    100

#define MY_SZ_TRUE _TEXT("true")
#define MY_SZ_FALSE _TEXT("false")
#define  SLOWLINK_SPEED 400   // in 100 bitspersec units
// NB!!! these defines cannot be changed they are in the order in which
// reintegration must proceed

#define REINT_DELETE_FILES  0
#define REINT_DELETE_DIRS   1
#define REINT_CREATE_UPDATE_DIRS   2
#define REINT_CREATE_UPDATE_FILES  3


typedef struct tagREINT_INFO {

    int nCurrentState;  // 0->deleting files, 1->deleting directories, 2->creating directoires
                        // 3 ->creating files
    node *lpnodeInsertList; // reint errors

    LPCSCPROC   lpfnMergeProgress;

    DWORD_PTR   dwContext;
    DWORD       dwFileSystemFlags;  // From GetVolumeInformation, used to set ACCLs etc. if the
                                    // share is hosted on NTFS
    HSHARE      hShare;            // handle to the share being reintegrated
    ULONG       ulPrincipalID;
    _TCHAR      tzDrive[4];         // mapped drive to the remote path

} REINT_INFO, *LPREINT_INFO;


#define SPARSEFILL_SLEEP_TIME_FOR_WIN95         2000    // two seconds
#define MAX_SPARSEFILL_SLEEP_TIME_FOR_WIN95     2 * 60 * 100    // two minutes


#define DFS_ROOT_FILE_SYSTEM_FLAGS 0xffffffff

//
// Variables Global/Local
//

_TCHAR  *vlpExclusionList = NULL;
REINT_INFO  vsRei;  // global reint structure. NTRAID-455269-shishirp-1/31/2000 we should make this into a list
                    // in order to allow multiple reintegrations on various shares


unsigned long   ulMinSparseFillPri = MIN_SPARSEFILL_PRI;
int     cntDelay=0;
HANDLE  vhShadow=NULL;
BOOL    vfTimerON = FALSE, vfAutoDeleteOrphans=TRUE;
char    vrgchBuff[1024], vrwBuff[4096], vrgchSrcName[350], vrgchDstName[300];
unsigned    vcntDirty=0, vcntStale=0, vcntSparse=0, vcntWaitDirty=0;
LPFAILINFO  lpheadFI = NULL;
HCURSOR     vhcursor=NULL;

BOOL    vfLogCopying=TRUE;

LPCONNECTINFO   vlpLogonConnectList = NULL;

BOOL    vfNeedPQTraversal = TRUE;
DWORD   vdwSparseStaleDetectionCounter = 0;


_TCHAR vrgchCRLF[] = _TEXT("\r\n");
_TCHAR tzStarDotStar[] = _TEXT("*");
#pragma data_seg(DATASEG_READONLY)

ERRMSG rgErrorTab[] =
{
    ERROR_CREATE_CONFLICT, IDS_CREATE_CONFLICT

   ,ERROR_DELETE_CONFLICT, IDS_DELETE_CONFLICT

   ,ERROR_UPDATE_CONFLICT, IDS_UPDATE_CONFLICT

   ,ERROR_ATTRIBUTE_CONFLICT, IDS_ATTRIBUTE_CONFLICT

};


static const _TCHAR vszMachineName[]= _TEXT("System\\CurrentControlSet\\Control\\ComputerName\\ComputerName");
static const _TCHAR vszComputerName[]=_TEXT("ComputerName");
static const _TCHAR vszLogUNCPath[]=_TEXT("\\\\scratch\\scratch\\t-trentg\\logs\\");
static const _TCHAR vszLogShare[]=_TEXT("\\\\scratch\\scratch");
static const _TCHAR vszLocalLogPath[]=_TEXT("c:\\shadow.log");
static const _TCHAR vszConflictDir[]=_TEXT("C:\\ConflictsWhileMerging");

#pragma data_seg()

AssertData;
AssertError;




//
// Local prototypes
//



BOOL
CheckForStalenessAndRefresh(
    HANDLE          hShadowDB,
    _TCHAR          *lptzDrive,
    LPCOPYPARAMS    lpCP,
    _TCHAR *        lpszFullPath,
    LPSHADOWINFO    lpSI
    );

BOOL
StalenessCheck(
    BOOL hasBeenInited
    );

VOID
GetLogCopyStatus(
    VOID
    );

VOID
CopyLogToShare(
    VOID
    );

VOID
AppendToShareLog(
    HANDLE hLog
    );


int
PRIVATE
AttemptReint(
    int forceLevel
    );

VOID
PRIVATE
AddToReintList(
    LPCOPYPARAMS lpCP,
    LPSHADOWINFO lpSI,
    _TCHAR *szFileName
    );

DWORD
PRIVATE
DoObjectEdit(
    HANDLE                hShadowDB,
    _TCHAR *               lpDrive,
    _TCHAR *            lptzFullPath,
    LPCOPYPARAMS        lpCP,
    LPSHADOWINFO        lpSI,
    LPWIN32_FIND_DATA    lpFind32Local,
    LPWIN32_FIND_DATA    lpFind32Remote,
    int         iShadowStatus,
    int         iFileStatus,
    int         uAction,
    DWORD       dwFileSystemFlags,
    LPCSCPROC   lpfnMergeProc,
    DWORD_PTR   dwContext
    );

DWORD
PRIVATE
DoCreateDir(
    HANDLE                hShadowDB,
    _TCHAR *               lpDrive,
    _TCHAR *            lptzFullPath,
    LPCOPYPARAMS        lpCP,
    LPSHADOWINFO        lpSI,
    LPWIN32_FIND_DATA    lpFind32Local,
    LPWIN32_FIND_DATA    lpFind32Remote,
    int         iShadowStatus,
    int         iFileStatus,
    int         uAction,
    DWORD       dwFileSystemFlags,
    LPCSCPROC   lpfnMergeProc,
    DWORD_PTR   dwContext
    );

DWORD
PRIVATE
CheckFileConflict(
    LPSHADOWINFO,
    LPWIN32_FIND_DATA
    );

BOOL
FCheckAncestor(
    node *lpnodeList,
    LPCOPYPARAMS lpCP
    );

int
PRIVATE
StampReintLog(
    VOID
    );

int
PRIVATE
LogReintError(
    DWORD,
    _TCHAR *,
    _TCHAR *);

int
PRIVATE
WriteLog(
    _TCHAR *
    );

DWORD
PRIVATE
MoveConflictingFile(
    LPCOPYPARAMS
    );

DWORD
PRIVATE
GetUniqueName(
    _TCHAR *,
    _TCHAR *
    );

VOID
PRIVATE
FormLocalNameFromRemoteName(
    _TCHAR *,
    _TCHAR *
    );

DWORD
PRIVATE
InbCreateDir(
    _TCHAR *     lpDir,
    DWORD    dwAttr
    );

int
PRIVATE
GetShadowByName(
    HSHADOW,
    _TCHAR *,
    LPWIN32_FIND_DATA,
    unsigned long *
    );

_TCHAR *
PRIVATE
LpGetExclusionList(
    VOID
    );

VOID
PRIVATE
ReleaseExclusionList(
    LPVOID
    );


BOOL
PRIVATE
FSkipObject(
    HSHARE,
    HSHADOW,
    HSHADOW
    );

int
PRIVATE
PurgeSkipQueue(
    BOOL,
    HSHARE,
    HSHADOW,
    HSHADOW
    );

LPFAILINFO FAR *
LplpFindFailInfo(
    HSHARE,
    HSHADOW,
    HSHADOW
    );

VOID
PRIVATE
ReportStats(
    VOID
    );

VOID
PRIVATE
CopyPQInfoToShadowInfo(
    LPPQPARAMS,
    LPSHADOWINFO
    );

BOOL
PRIVATE
IsSlowLink(
    _TCHAR *
    );

VOID
PRIVATE
InferReplicaReintStatus(
    LPSHADOWINFO         lpSI,
    LPWIN32_FIND_DATA    lpFind32Local,    // shadow info
    LPWIN32_FIND_DATA     lpFind32Remote,    // if NULL, the remote doesn't exist
    int                 *lpiShadowStatus,
    int                 *lpiFileStatus,
    unsigned             *lpuAction
    );

BOOL
GetRemoteWin32Info(
    _TCHAR  *lptzDrive,
    LPCOPYPARAMS lpCP,
    LPWIN32_FIND_DATA    lpFind32,
    BOOL *lpfExists
    );

BOOL
PRIVATE
PerformOneReint(
    HANDLE              hShadowDB,
    LPSECURITYINFO      pShareSecurityInfo,
    _TCHAR *            lpszDrive,          // drive mapped to the UNC name of lpSI->hShare
    _TCHAR *            lptzFullPath,       // full UNC path
    LPCOPYPARAMS        lpCP,               // copy parameters
    LPSHADOWINFO        lpSI,               // shadowinfo structure
    LPWIN32_FIND_DATA   lpFind32Local,      // local win32 data
    LPWIN32_FIND_DATA   lpFind32Remote,     // remote win32 data, could be NULL
    DWORD               dwErrorRemoteFind32,// error code while getting remote win32 data
    int                 iShadowStatus,      // local copy status
    int                 iFileStatus,        // remote file status
    unsigned            uAction,            // action to be taken
    DWORD               dwFileSystemFlags,  // CODE.IMPROVEMENT, why not just pass down REINT_INFO
    ULONG               ulPrincipalID,
    LPCSCPROC           lpfnMergeProgress,  // instead of the three parameters?
    DWORD_PTR           dwContext
    );

ImpersonateALoggedOnUser(
    VOID
    );

HANDLE
CreateTmpFileWithSourceAcls(
    _TCHAR  *lptzSrc,
    _TCHAR  *lptzDst
    );

BOOL
HasMultipleStreams(
    _TCHAR  *lpExistingFileName,
    BOOL    *lpfTrueFalse
    );

int
PRIVATE
CALLBACK
RefreshProc(
    LPCONNECTINFO  lpCI,
    DWORD          dwCookie // LOWORD 0==Silently, 1== Give messages
                           // HIWORD 0==Nuke UNC, 1==Nuke all if no ongoing open/finds
                           // 2==Maximum force for shadow 3==Nuke ALL
    );



BOOL
CALLBACK
ShdLogonProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:

    Legacy code, used to be used in win9x implementation

Arguments:


Returns:


Notes:

--*/
{
    switch(msg)
    {
        case WM_INITDIALOG:
            return TRUE;
    }
    return 0;
}

/**************************** Fill routines *********************************/

int
AttemptCacheFill (
    HSHARE      hShareToSync,
    int         type,
    BOOL        fFullSync,
    ULONG       ulPrincipalID,
    LPCSCPROC   lpfnFillProgress,
    DWORD_PTR   dwContext
    )
/*++

Routine Description:

    Routine called by the agent and the fill API to do filling on a share.

Arguments:

    hShareToSync        Represnts the share to fill. If 0, fill all shares

    type                DO_ONE or DO_ALL. No one sets it to DO_ONE anymore

    fFullSync           if TRUE, we do a staleness check as well
    
    ulPrincipalID       ID of the principal as maintained in the shadow database
                        used to avoid ssyncing files for which the currently logged
                        on user doesn't have access

    lpfnFillProgress    Callback function to report progress, can be NULL

    dwContext           Callback context


Returns:

    count of items done

Notes:

    

--*/
{
    PQPARAMS sPQP;
    BOOL fFound = FALSE, fFoundBusy = FALSE, fAmAgent=FALSE, fNeedImpersonation=FALSE, fInodeTransaction=FALSE;
    BOOL    fSparseStaleDetected = FALSE;
    SHADOWINFO  sSI;
    SHAREINFO  sSR;
    LPCOPYPARAMS lpCP = NULL;
    DWORD dwError = NO_ERROR, dwFillStartTick=0, dwCount=0, dwSleepCount=0, dwSparseStaleDetectionCounter=0xffff;
    HANDLE hShadowDB;
    int cntDone = 0;
    WIN32_FIND_DATA sFind32Local;
    _TCHAR szNameBuff[MAX_PATH+MAX_SERVER_SHARE_NAME_FOR_CSC+10], tzDrive[4];

    tzDrive[0] = 0;

    fAmAgent = (GetCurrentThreadId() == vdwCopyChunkThreadId);
    Assert(GetCurrentThreadId() != vdwAgentThreadId);

    // when the agent comes here to fill, if the vfNeedPQTraversal flag is set
    // we go ahead and traverse the priority Q.

    // Otherwise, we check with the record manager whether since the last time we looked
    // there has been any sparse or stale files encountered.

    // If what the agent gets from the record manager
    // is not the same as what the agent stored last time around
    // then we let him traverse the Q.

    // the whole idea here is to converse CPU cycles when
    // there is nothing to fill

    if (fAmAgent && !vfNeedPQTraversal)
    {
        GetSparseStaleDetectionCounter(INVALID_HANDLE_VALUE, &dwSparseStaleDetectionCounter);

        if (dwSparseStaleDetectionCounter == vdwSparseStaleDetectionCounter)
        {
            ReintKdPrint(FILL, ("Agent.fill: SparseStaleDetectionCounter =%d is unchanged, not filling\n", vdwSparseStaleDetectionCounter));
            return 0;
        }
        else
        {
            vfNeedPQTraversal = TRUE;
            vdwSparseStaleDetectionCounter = dwSparseStaleDetectionCounter;
            ReintKdPrint(FILL, ("**Agent.fill: SparseStaleDetectionCounter =%d is changed**\n", vdwSparseStaleDetectionCounter));
        }
    }

    if ((hShadowDB = OpenShadowDatabaseIO())==INVALID_HANDLE_VALUE)
    {
        goto bailout;
    }

    Assert(!(fFullSync && fAmAgent));


    lpCP = LpAllocCopyParams();

    if (!lpCP){
        ReintKdPrint(BADERRORS, ("Agent:Allocation of copyparam buffer failed\n"));
        goto bailout;
    }

    if (fFullSync && hShareToSync)
    {
        ULONG   ulStatus;
        BOOL    fIsDfsConnect;
        
        if(GetShareInfo(hShadowDB, hShareToSync, &sSR, &ulStatus)<= 0)
        {
            ReintKdPrint(BADERRORS, ("AttemptCacheFill: couldn't get status for server 0x%x\r\n", hShareToSync));
            goto bailout;
        }

        dwError = DWConnectNet(sSR.rgSharePath, tzDrive, NULL, NULL, NULL, CONNECT_INTERACTIVE, &fIsDfsConnect);

        if ((dwError != WN_SUCCESS) && (dwError != WN_CONNECTED_OTHER_PASSWORD) && (dwError != WN_CONNECTED_OTHER_PASSWORD_DEFAULT))
        {
            ReintKdPrint(BADERRORS, ("AttemptCacheFill: connect to %ls failed error=%d\r\n", sSR.rgSharePath, dwError));
            goto bailout;
        }
                
    }

    memset(&sPQP, 0, sizeof(PQPARAMS));
    memset(&sSI, 0, sizeof(SHADOWINFO));

    if (type == DO_ALL)
    {
        PurgeSkipQueue(TRUE, hShareToSync, 0, 0);
    }

    if(BeginPQEnum(hShadowDB, &sPQP) == 0) {
        goto bailout;
    }

    ReintKdPrint(FILL, ("Agent.fill:Started enumeration\n"));

    do {

        if (FAbortOperation())
        {
            cntDone = 0;
            goto bailout;
        }
        if (fInodeTransaction)
        {
            DoShadowMaintenance(hShadowDB, SHADOW_END_INODE_TRANSACTION);
            fInodeTransaction = FALSE;
        }
        if (fAmAgent)
        {
            Sleep(1);   // Yield on NT because we are winlogon
        }
        if(!DoShadowMaintenance(hShadowDB, SHADOW_BEGIN_INODE_TRANSACTION))
        {
            ReintKdPrint(BADERRORS, ("AttemptCacheFill: failed to begin inode transaction, aborting\n"));
            break;
        }

        fInodeTransaction = TRUE;
        if(NextPriShadow(hShadowDB, &sPQP) == 0) {
            break;
        }

        if (++dwCount > 100000)
        {
            ReintKdPrint(BADERRORS, ("AttemptCacheFill: Aborting, more than 100000 entries!!!\n"));
            break;
        }

        if (!sPQP.hShadow) {
            break;
        }

        if (fAmAgent && !fSparseStaleDetected &&
            ((mShadowIsFile(sPQP.ulStatus) && (sPQP.ulStatus & SHADOW_SPARSE)) || // sparse file
             (sPQP.ulStatus & SHADOW_STALE)))   // or stale file or dir
        {
            fSparseStaleDetected = TRUE;
        }

        if (!fFullSync && !(mShadowIsFile(sPQP.ulStatus) || (sPQP.ulStatus & SHADOW_STALE)))
        {
            continue;
        }

        if (hShareToSync && (hShareToSync != sPQP.hShare))
        {
            continue;
        }

        if (fAmAgent && FSkipObject(sPQP.hShare, 0, 0)){
            continue;
        }

        else if  (mShadowNeedReint(sPQP.ulStatus)||
                    mShadowOrphan(sPQP.ulStatus)||
                    mShadowSuspect(sPQP.ulStatus)){
            continue;
        }

        if (fAmAgent && FSkipObject(sPQP.hShare, sPQP.hDir, sPQP.hShadow)) {
            continue;
        }

        // If we are not doing full sync then do only sparse filling
        // or filling stale directories
        // otherwise we also want to update the attributes and timestamps on
        // the directories

        if (fFullSync || (sPQP.ulStatus & (SHADOW_STALE|SHADOW_SPARSE))){

            if (fAmAgent)
            {
                if (!hdesktopUser)
                {
                    if (!(sPQP.ulHintFlags & FLAG_CSC_HINT_PIN_SYSTEM))
                    {
                        ReintKdPrint(FILL, ("AttemptCacheFill: skipping fill till logon happens\n"));
                        continue;
                    }
                }
            }
            if (FAbortOperation())
            {
                cntDone = 0;
                goto bailout;
            }

            if (!GetShadowInfoEx(hShadowDB, sPQP.hDir, sPQP.hShadow,
                &sFind32Local, &sSI)){

                ReintKdPrint(BADERRORS, ("AttemptCacheFill: GetShadowInfoEx failed\n"));
                continue;
            }

            if (FAbortOperation())
            {
                cntDone = 0;
                goto bailout;
            }

            if(GetUNCPath(hShadowDB, sPQP.hShare, sPQP.hDir, sPQP.hShadow, lpCP)){

                // impersonate only if we are the agent and the file we are trying to 
                // bring down is not pinned for system. This was for remoteboot feature
                // which doesn't exist any more.

                fNeedImpersonation = (fAmAgent && !(sPQP.ulHintFlags & FLAG_CSC_HINT_PIN_SYSTEM));

                if (!fNeedImpersonation || 
                    (mShadowIsFile(sPQP.ulStatus) && SetAgentThreadImpersonation(sPQP.hDir, sPQP.hShadow, FALSE))||
                    (!mShadowIsFile(sPQP.ulStatus) && ImpersonateALoggedOnUser()))
                {
                    BOOL    fStalenessCheck;

                    // !!NB Stale must be dealt with first
                    // because a sparse shadow can become stale

                    // NB!!! we assume the limits because we know that
                    // the database handles only that much size

                    lstrcpy(szNameBuff, lpCP->lpSharePath);
                    lstrcat(szNameBuff, lpCP->lpRemotePath);

                    fStalenessCheck = (fFullSync || (sSI.uStatus & SHADOW_STALE));

                    if (fStalenessCheck || (sSI.uStatus & SHADOW_SPARSE)) {

                        dwError = DoSparseFill(hShadowDB, szNameBuff, tzDrive, &sSI, &sFind32Local, lpCP, fStalenessCheck, ulPrincipalID, lpfnFillProgress, dwContext);

                    }

                    if (fNeedImpersonation)
                    {
                        ResetAgentThreadImpersonation();
                    }

                    if (fAmAgent)
                    {
                        if (dwFillStartTick == 0)
                        {
                            dwFillStartTick = GetTickCount();
                            ReintKdPrint(FILL, ("AttemptCacheFill: start tick count is %d ms\r\n", dwFillStartTick));
                        }
                        else
                        {
                            Assert(type != DO_ALL);

                            // if we have been filling too long
                            // comeback later
                            if (((int)(GetTickCount() - (dwFillStartTick+dwSleepCount)) > WAIT_INTERVAL_ATTEMPT_MS/3))
                            {
                                ReintKdPrint(FILL, ("AttemptCacheFill: aborting, been filling for more than %d ms\r\n", WAIT_INTERVAL_ATTEMPT_MS/3));
                                break;
                            }

                        }
                        Sleep(200);
                        dwSleepCount+=200;
                    }
                }
                else
                {
                    Assert(fAmAgent);
                    Sleep(200);
                    dwSleepCount+=200;

                    // no one is allowed to read the entry
                    // go on to fill other things
                    continue;

                }

            }
            else
            {
                ReintKdPrint(BADERRORS, ("Agent: Shadow %08lx doesn't have an entry in the hierarchy \r\n", sPQP.hShadow));
                continue;
            }

            if (dwError == NO_ERROR) {

                cntDone += 1;
            }
#if 0
            if (type == DO_ONE_OBJECT) {
                break;
            }
#endif
            if (dwError == ERROR_OPERATION_ABORTED)
            {
                cntDone = 0;
                break;
            }

        }

    } while (sPQP.uPos);

    // if the agent traversed the entire PQ and didn't come across any item
    // that needed to be filled or refreshed, then we turnoff the global flag indicating
    // that we need priority Q traversal.
    // From here on, the agent will be driven by the SparseStaleDetectionCount
    if (fAmAgent)
    {
        // if even one sparse or stale was detected, traverse the queue again
        if (fSparseStaleDetected)
        {
            vfNeedPQTraversal = TRUE;
        }
        else if (!sPQP.uPos)
        {
            vfNeedPQTraversal = FALSE;
            ReintKdPrint(FILL, ("Agent.fill: No sparse stale entries found, going in querycount mode\r\n"));
        }
    }

    // Close the enumeration
    EndPQEnum(hShadowDB, &sPQP);

bailout:
    if (fInodeTransaction)
    {
        DoShadowMaintenance(hShadowDB, SHADOW_END_INODE_TRANSACTION);
        fInodeTransaction = FALSE;
    }
    if (hShadowDB != INVALID_HANDLE_VALUE)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (lpCP) {
        FreeCopyParams(lpCP);
    }

    if (tzDrive[0])
    {
        if(DWDisconnectDriveMappedNet(tzDrive, TRUE))
        {
            ReintKdPrint(BADERRORS, ("Failed disconnection of merge drive \r\n"));
        }
        else
        {
            ReintKdPrint(MERGE, ("Disconnected merge drive \r\n"));
        }
                
    }

    ReintKdPrint(FILL, ("Agent.fill:done cachefill\n"));
    return (cntDone);
}


DWORD
DoRefresh(
    HANDLE          hShadowDB,
    LPCOPYPARAMS    lpCP,
    _TCHAR *        lpszFullPath,
    LPSHADOWINFO    lpSI,
    _TCHAR *        lptzDrive
    )
/*++

Routine Description:

    Checks whether an item in the database has gone stale and if so, it refreshes it. If it is
    a file, it is truncated and marked SPARSE

Arguments:


Returns:


Notes:

--*/
{
    DWORD dwError = 0xffffffff;

    if (!CheckForStalenessAndRefresh(hShadowDB, lptzDrive, lpCP, lpszFullPath, lpSI)) {
            dwError = GetLastError();
    }
    else
    {
        dwError = NO_ERROR;
    }

    if ((dwError != NOERROR) && IsNetDisconnected(dwError))
    {

#ifdef DEBUG
        EnterSkipQueue(lpSI->hShare, lpSI->hDir, lpSI->hShadow, lpszFullPath);
#else
        EnterSkipQueue(lpSI->hShare, lpSI->hDir, lpSI->hShadow);
#endif //DEBUG
    }

    return (dwError);
}

/*********************** Merging related routines **************************/

int
TraverseOneDirectory(
    HANDLE          hShadowDB,
    LPSECURITYINFO  pShareSecurityInfo,
    HSHADOW         hParentDir,
    HSHADOW         hDir,
    LPTSTR          lptzInputPath,
    TRAVERSEFUNC    lpfnTraverseDir,
    LPVOID          lpContext
    )
/*++

Routine Description:

    Generic routine that traverses a directory in the database recursively and issues a
    callback function to let callers do interesting things, such as merge or rename.

Arguments:

    hShadowDB       Handle to the redir for issuing ioctls

    hParentDir      handle to the parent directory

    hDir            handle to the directory to be traversed

    lptzInputPath   full qualified path of the directory

    lpfnTraverseDir callback function to call at each step in the traversal

    lpContext       callback context

Returns:

    return code, whether continue, cancel etc.

Notes:

--*/
{
    WIN32_FIND_DATA sFind32;
    SHADOWINFO sSI;
    int retCode = TOD_CONTINUE, lenInputPath = 0, retCodeSav;
    CSC_ENUMCOOKIE  ulEnumCookie = NULL;

    Assert(lptzInputPath);

    lenInputPath = lstrlen(lptzInputPath);

    Assert(lenInputPath && (lenInputPath < MAX_PATH));

    ReintKdPrint(MERGE, ("Begin_Traverse directory %ls\r\n", lptzInputPath));

    sSI.hDir = hParentDir;
    sSI.hShadow = hDir;
    retCode = (lpfnTraverseDir)(hShadowDB, pShareSecurityInfo, lptzInputPath, TOD_CALLBACK_REASON_BEGIN, &sFind32, &sSI, lpContext);

    memset(&sFind32, 0, sizeof(sFind32));
    lstrcpy(sFind32.cFileName, tzStarDotStar);

    if(FindOpenShadow(  hShadowDB, hDir, FINDOPEN_SHADOWINFO_ALL,
                        &sFind32, &sSI))
    {
        if (FAbortOperation())
        {
            ReintKdPrint(MERGE, ("TraverseOneDirectory:Abort received\r\n"));
            SetLastError(ERROR_CANCELLED);
            goto bailout;
        }


        ulEnumCookie = sSI.uEnumCookie;

        do
        {
            int lenChildName;

            lenChildName = lstrlen(sFind32.cFileName);

            if (!lenChildName || ((lenInputPath+lenChildName+1) >= MAX_PATH))
            {
                ReintKdPrint(MERGE, ("TraverseOneDirectory: path exceeds max path or is invalid\r\n"));
                SetLastError(ERROR_INVALID_PARAMETER);
                retCode = TOD_ABORT;
                goto bailout;
            }

            lptzInputPath[lenInputPath] = _T('\\');
            lstrcpy(&lptzInputPath[lenInputPath+1], sFind32.cFileName);

            if (sFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                retCode = (lpfnTraverseDir)(hShadowDB, pShareSecurityInfo, lptzInputPath, TOD_CALLBACK_REASON_NEXT_ITEM, &sFind32, &sSI, lpContext);

                if (retCode == TOD_ABORT)
                {
                    ReintKdPrint(MERGE, ("TraverseOneDirectory:Abort\r\n"));
                    goto bailout;
                }
                retCode = TraverseOneDirectory(hShadowDB, pShareSecurityInfo, sSI.hDir, sSI.hShadow, lptzInputPath, lpfnTraverseDir, lpContext);
            }
            else
            {
                retCode = (lpfnTraverseDir)(hShadowDB, pShareSecurityInfo, lptzInputPath, TOD_CALLBACK_REASON_NEXT_ITEM, &sFind32, &sSI, lpContext);

            }

            lptzInputPath[lenInputPath] = 0;

            if (retCode == TOD_ABORT)
            {
                ReintKdPrint(MERGE, ("TraverseOneDirectory:Abort\r\n"));
                goto bailout;
            }

        } while(FindNextShadow(hShadowDB, ulEnumCookie, &sFind32, &sSI));
    }

bailout:

    sSI.hDir = hParentDir;
    sSI.hShadow = hDir;
    retCodeSav = (lpfnTraverseDir)(hShadowDB, pShareSecurityInfo, lptzInputPath, TOD_CALLBACK_REASON_END, &sFind32, &sSI, lpContext);
    if (retCode != TOD_ABORT)
    {
        retCode = retCodeSav;
    }
    ReintKdPrint(MERGE, ("End_Traverse directory %ls\r\n", lptzInputPath));

    if (ulEnumCookie)
    {
        FindCloseShadow(hShadowDB, ulEnumCookie);
    }

    return retCode;
}

int
ReintDirCallback(
    HANDLE          hShadowDB,
    LPSECURITYINFO  pShareSecurityInfo,
    LPTSTR          lptzFullPath,
    DWORD           dwCallbackReason,
    WIN32_FIND_DATA *lpFind32,
    SHADOWINFO      *lpSI,
    LPREINT_INFO     lpRei
    )
/*++

Routine Description:

    callback function used by ReintOneShare while calling TraverseOneDirectory. It is called
    on each step in the traversal. This routine issues call to do the merging

Arguments:

    hShadowDB           Handle to issue ioctls to the redir

    lptzFullPath        fully qualified path to the item

    dwCallbackReason    TOD_CALLBACK_REASON_XXX (BEGIN, NEXT_ITEM or END)

    lpFind32            local win32info

    lpSI                other info such as priority, pincount etc.

    lpRei               reintegration information context

Returns:

    return code, whether continue, cancel etc.

Notes:

--*/
{
    int retCode = TOD_CONTINUE;
    int iFileStatus, iShadowStatus;
    LPCOPYPARAMS lpCP = NULL;
    BOOL    fInsertInList = FALSE, fIsFile;
    WIN32_FIND_DATA sFind32Remote, *lpFind32Remote = NULL;
    unsigned    uAction;
    DWORD   dwErrorRemote = ERROR_SUCCESS;

    if (dwCallbackReason != TOD_CALLBACK_REASON_NEXT_ITEM)
    {
        return TOD_CONTINUE;
    }

    if ( mShadowOrphan(lpSI->uStatus)||
                 mShadowSuspect(lpSI->uStatus))
    {
        return TOD_CONTINUE;
    }

    if (!mShadowNeedReint(lpSI->uStatus))
    {
        return TOD_CONTINUE;
    }

    fIsFile = ((lpFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0);

    switch (lpRei->nCurrentState)
    {
        case REINT_DELETE_FILES:
            if (!fIsFile || !mShadowDeleted(lpSI->uStatus))
            {
                return TOD_CONTINUE;
            }
        break;
        case REINT_DELETE_DIRS:
            if (fIsFile || !mShadowDeleted(lpSI->uStatus))
            {
                return TOD_CONTINUE;
            }
        break;
        case REINT_CREATE_UPDATE_FILES:
            if (!fIsFile)
            {
                return TOD_CONTINUE;
            }
        break;
        case REINT_CREATE_UPDATE_DIRS:
            if (fIsFile)
            {
                return TOD_CONTINUE;
            }
        break;
        default:
        Assert(FALSE);
        break;
    }

#if 0
    if (!fStamped){
        StampReintLog();
        fStamped = TRUE;
    }
#endif
    lpCP = LpAllocCopyParams();

    if (!lpCP){
        ReintKdPrint(BADERRORS, ("ReintDirCallback: Allocation of copyparam buffer failed\n"));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        retCode = TOD_ABORT;
        goto bailout;
    }
    if(!GetUNCPath(hShadowDB, lpSI->hShare, lpSI->hDir, lpSI->hShadow, lpCP)){

        ReintKdPrint(BADERRORS, ("ReintDirCallback: GetUNCPath failed\n"));
        Assert(FALSE);
        retCode =  TOD_CONTINUE;
        goto bailout;
    }

    ReintKdPrint(MERGE, ("Merging local changes to <%ls%ls>\n", lpCP->lpSharePath, lpCP->lpRemotePath));

    fInsertInList = FALSE;

    lpFind32Remote = NULL;

    // if there is an insertion list, then check whether his ancestor
    // didn't fail in reintegration
    if (lpRei->lpnodeInsertList)
    {
        // if there is an acestor then we should put this guy in the list
        fInsertInList = FCheckAncestor(lpRei->lpnodeInsertList, lpCP);
    }

    // if we are not supposed to put him in the list then try getting
    // his win32 strucuture
    if (!fInsertInList)
    {

        BOOL fExists;

        ReintKdPrint(MERGE, ("getting Remote win32 Info \n"));

        if (!GetRemoteWin32Info(lpRei->tzDrive, lpCP, &sFind32Remote, &fExists) && (fExists == -1))
        {
            // NB: dwErrorRemote is set only when fExists is -1, ie there some error
            // besides the file not being there

            // some error happened while getting remote find32
            if (IsNetDisconnected(dwErrorRemote = GetLastError()))
            {
#ifdef DEBUG
                EnterSkipQueue(lpSI->hShare, 0, 0, lpCP->lpSharePath);
#else
                EnterSkipQueue(lpSI->hShare, 0, 0);
#endif //DEBUG
                retCode = TOD_ABORT;
                ReintKdPrint(BADERRORS, ("ReintDirCallback: Error = %d NetDisconnected aborting\r\n", GetLastError()));
                goto bailout;
            }

        }

        // passing remote find32 only if it succeeded
        if (fExists == TRUE)
        {
            lpFind32Remote = &sFind32Remote;
        }
        Assert(!((fExists != -1) && (dwErrorRemote != NO_ERROR)));
    }
    else
    {
        ReintKdPrint(BADERRORS, ("ReintDirCallback: Inserting in failed list\r\n"));
    }


    // find out what needs to be done
    // this is one central place to infer all the stuff
    InferReplicaReintStatus(
                            lpSI,    // shadowinfo
                            lpFind32,    // win32 info for the shadow
                            lpFind32Remote,    // remote win32 info
                            &iShadowStatus,
                            &iFileStatus,
                            &uAction
                            );


    if (!fInsertInList)
    {
        ReintKdPrint(MERGE, ("Silently doing <%ls%ls>\n", lpCP->lpSharePath, lpCP->lpRemotePath));


        fInsertInList = (PerformOneReint(
                                    hShadowDB,
                                    pShareSecurityInfo,
                                    lpRei->tzDrive,
                                    lptzFullPath,
                                    lpCP,
                                    lpSI,
                                    lpFind32,
                                    lpFind32Remote,
                                    dwErrorRemote,
                                    iShadowStatus,
                                    iFileStatus,
                                    uAction,
                                    lpRei->dwFileSystemFlags,
                                    lpRei->ulPrincipalID,
                                    lpRei->lpfnMergeProgress,
                                    lpRei->dwContext
                                    ) == FALSE);
        if (fInsertInList)
        {
            if (IsNetDisconnected(GetLastError()))
            {
#ifdef DEBUG
                EnterSkipQueue(lpSI->hShare, 0, 0, lpCP->lpSharePath);
#else
                EnterSkipQueue(lpSI->hShare, 0, 0);
#endif //DEBUG
                retCode = TOD_ABORT;
                ReintKdPrint(BADERRORS, ("ReintDirCallback: Error = %d NetDisconnected aborting\r\n", GetLastError()));
                goto bailout;
            }
            else if (GetLastError() == ERROR_OPERATION_ABORTED)
            {
                retCode = TOD_ABORT;
                ReintKdPrint(BADERRORS, ("ReintDirCallback: operation aborted becuase of ERROR_OPERATION_ABORT\r\n"));
                goto bailout;
            }

        }
        else
        {
            retCode = TOD_CONTINUE;
        }
    }
    else
    {
        ReintKdPrint(BADERRORS, ("ReintDirCallback: Was Inserted in failed list\r\n"));
    }


bailout:
    if (lpCP) {
        FreeCopyParams(lpCP);
    }

    return retCode;
}

BOOL
PUBLIC
ReintOneShare(
    HSHARE         hShare,
    HSHADOW         hRoot,    // root inode
    _TCHAR          *lpDomainName,
    _TCHAR          *lpUserName,
    _TCHAR          *lpPassword,
    ULONG           ulPrincipalID,
    LPCSCPROC       lpfnMergeProgress,
    DWORD_PTR       dwContext
    )
/*++

Routine Description:

    This is the workhorse routine that does the merging of a share which may have modifications
    made while offline.

    The routine, first checks whether any modifications have been done at all on this share.
    Is so, then it gets a list of all the drive-mapped and explicit UNC connections made to
    this share.

    The routine then creates a special drive mapping to the share, done by passing in an
    extended attribute flag CSC_BYPASS (defined in lmuse.h). This tells the redir
    to bypass all CSC functionality.

    It then deletes all the connections in the list gathered before making the EA based
    connections.

    The merge then proceeds by enumerating the share from the database. It uses, TraverseOneDirectory
    routine and gives it ReintDirCallback routine as a callback with REINT_INFO as the context.
    The directory travesal proceeds from the root of the share

    At the end of the merge, the EA connection is deleted and the connections in the list are
    reconnected.


Arguments:

    hShare         // Represents the share to merged

    hRoot           // the root inode for the share

    lpDomainName    // domain name for EA drivemapping (can be NULL)

    lpUserName      // username for EA drivemapping (can be NULL)

    lpPassword      // password for EA drivemapping (can be NULL)
    
    ulPrinciaplID   // the ID of the guy calling reint

    lpfnMergeProgress   // callback function for reporting progress

    dwContext           // callback context

Returns:

    TRUE if successful. If FALSE, GetLastError returns the actual errorcode.

Notes:

    The EA drivemap is passed back to the callback routine during the CSCPROC_REASON_BEGIN callback
    so that the callback routine can use the same driveletter to bypass CSC for doing whatever
    it needs to do on the server without having CSC get in it's way.
    
--*/

{
    BOOL fConnected=FALSE, fDone = FALSE;
    BOOL fStamped = FALSE, fInsertInList = FALSE, fBeginReint = FALSE, fDisabledShadowing = FALSE;
    unsigned long ulStatus;
    HANDLE                hShadowDB;
    SHAREINFO  sSR;
    SHADOWINFO  sSI;
    int iRet, i;
    ULONG nRet = 0;
    DWORD   dwError, dwRet, dwMaxComponentLength=0;
    TCHAR   tzFullPath[MAX_PATH+1], tzDrive[4];
    LPCONNECTINFO lpHead = NULL;
    BOOL    fIsDfsConnect = FALSE;
    LPVOID  lpContext = NULL;
    DWORD   dwDummy;
    SECURITYINFO rgsSecurityInfo[CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS];
    LPSECURITYINFO pShareSecurityInfo = NULL;

    // if reintegration is going on on a share, then ask him to stop
    // NTRAID-455269-shishirp-1/31/2000 we should allow reintegration on multiple shares
    if (vsRei.hShare)
    {
        ReintKdPrint(BADERRORS, ("ReintOneShare: reintegration is in progress\r\n"));
        SetLastError(ERROR_SHARING_VIOLATION);
        return FALSE;
    }

    // we enter a critical section because eventually we should allocate a reint_info strucuture
    // and thread it in a list

    EnterAgentCrit();
    memset(&vsRei, 0, sizeof(vsRei));
   
    vsRei.lpfnMergeProgress = lpfnMergeProgress;

    vsRei.dwContext = dwContext;
    vsRei.hShare = hShare;
    vsRei.ulPrincipalID = ulPrincipalID;

    LeaveAgentCrit();

    memset(tzDrive, 0, sizeof(tzDrive));

    if ((hShadowDB = OpenShadowDatabaseIO()) ==INVALID_HANDLE_VALUE)
    {
        ReintKdPrint(BADERRORS, ("ReintOneShare: failed to open database\r\n"));
        return FALSE;
    }
    if(GetShareInfo(hShadowDB, hShare, &sSR, &ulStatus)<= 0)
    {
        ReintKdPrint(BADERRORS, ("ReintOneShare: couldn't get status for server 0x%x\r\n", hShare));
        goto bailout;
    }

    dwDummy = sizeof(rgsSecurityInfo);
    nRet = GetSecurityInfoForCSC(
                hShadowDB,
                0,
                hRoot,
                rgsSecurityInfo,
                &dwDummy);

    if (nRet > 0)
        pShareSecurityInfo = rgsSecurityInfo;

    lstrcpy(tzFullPath, sSR.rgSharePath);

    // this will modify the reint bit on the share if necessary
    if(!CSCEnumForStatsInternal(sSR.rgSharePath, NULL, FALSE, TRUE, 0))
    {
        ReintKdPrint(MERGE, ("ReintOneShare: Couldn't get stats for %ls \r\n", sSR.rgSharePath));
        goto bailout;

    }

    if (!(ulStatus & SHARE_REINT))
    {
        ReintKdPrint(MERGE, ("ReintOneShare: server %ls doesn't need reintegration\r\n", sSR.rgSharePath));
        fDone = TRUE;
        goto bailout;
    }

    if (!GetShadowInfoEx(INVALID_HANDLE_VALUE, 0, hRoot, NULL, &sSI)){

        ReintKdPrint(BADERRORS, ("ReintOneShare: GetShadowInfoEx failed\n"));
        goto bailout;
    }



    // put the share in reintegration mode
    // if this is not marked system pinned, then it would be a blocking reint
    // Putting the share in reintegration mode makes all open calls fail, except those
    // done on the special EA drive mapping

    // NB, beginreint is an async ioctl. This is the basis for cleanup
    // when the thread does the merge dies


    // All reint's are blocking reints.
    if (!BeginReint(hShare, TRUE /*!(sSI.ulHintFlags & FLAG_CSC_HINT_PIN_SYSTEM)*/, &lpContext))
    {
        if (GetLastError() != ERROR_IO_PENDING)
        {
            ReintKdPrint(BADERRORS, ("ReintOneShare: Couldn't put server 0x%x in reintegration state\r\n", hShare));
            goto bailout;
        }
    }

    fBeginReint = TRUE;

    // After putting the share in reintegration mode, we get the list of all
    // connection to the share and delete them with maximum force.
    // this ensures that no files are open after the share is put in reintegration mode
    // Moreover any files that are open are only thorugh the EA drive mapping

    // obtain the list of connections to this share.
    // do this before making a the special CSC_BYPASS connection
    // so that the list won't have it
    FGetConnectionListEx(&lpHead, sSR.rgSharePath, FALSE, FALSE, NULL);

    // now make the connection
    ReintKdPrint(MERGE, ("CSC.ReintOneShare: Attempting to map drive letter to %ls \r\n", sSR.rgSharePath));
    dwError = DWConnectNet(sSR.rgSharePath, tzDrive, lpDomainName, lpUserName, lpPassword, CONNECT_INTERACTIVE, &fIsDfsConnect);
    if ((dwError != WN_SUCCESS) &&
         (dwError != WN_CONNECTED_OTHER_PASSWORD_DEFAULT) &&
             (dwError != WN_CONNECTED_OTHER_PASSWORD))
    {
#ifdef DEBUG
        EnterSkipQueue(hShare, 0, 0, sSR.rgSharePath);
#else
        EnterSkipQueue(hShare, 0, 0);
#endif
        SetLastError(dwError);

        ReintKdPrint(BADERRORS, ("ReintOneShare: Error %d, couldn't connect to %ls\r\n", dwError, sSR.rgSharePath));

        // clear the connection list and bailout
        if (lpHead)
        {
            ClearConnectionList(&lpHead);
            lpHead = NULL;
        }

        goto bailout;

    }

    fConnected = TRUE;

    // if we have a connectionlist, disconnect all connections before attempting merge
    // NB, this is done after the drivemapped connection is made, so that
    // if there are special credentials on the server, they are maintained
    // as there is always atelast one outstanding connection

    if (lpHead)
    {
        DisconnectList(&lpHead, NULL, 0);
    }

    lstrcpy(vsRei.tzDrive, tzDrive);

    tzDrive[2]='\\';tzDrive[3]=0;
    ReintKdPrint(MERGE, ("CSC.ReintOneShare: mapped drive letter %ls IsDfs=%d\r\n", tzDrive, fIsDfsConnect));

    vsRei.dwFileSystemFlags = 0;

    // NTRAID#455273-shishirp-1/31/2000  we do getvolumeinfo only for non-dfs shares. This is because of a problem in
    // the DFS code that doesn't bypass volume operations for CSC agent. GetVolumeInfo is not implemented
    // by DFS

    if (!fIsDfsConnect)
    {
        if(!GetVolumeInformation(tzDrive, NULL, 0, NULL, &dwMaxComponentLength, &vsRei.dwFileSystemFlags, NULL, 0))
        {
            ReintKdPrint(BADERRORS, ("CSC.ReintOneShare: failed to get volume info for %ls Error=%d\r\n", tzDrive, GetLastError()));
            goto bailout;

        }
    }
    else
    {
        vsRei.dwFileSystemFlags = DFS_ROOT_FILE_SYSTEM_FLAGS;
    }

    tzDrive[2]=0;

    ReintKdPrint(MERGE, ("CSC.ReintOneShare: FileSystemFlags=%x \r\n", vsRei.dwFileSystemFlags));

    if (lpfnMergeProgress)
    {
        WIN32_FIND_DATA *lpFT;

        lpFT = (WIN32_FIND_DATA *)LocalAlloc(LPTR, sizeof(WIN32_FIND_DATA));

        if (!lpFT)
        {
            ReintKdPrint(BADERRORS, ("ReintOneShare: Couldn't allocate find32 strucutre for callback \r\n"));
            goto bailout;
        }

        lstrcpy(lpFT->cFileName, vsRei.tzDrive);

        try
        {
            dwRet = (*lpfnMergeProgress)(sSR.rgSharePath, ulStatus, 0, 0, lpFT, CSCPROC_REASON_BEGIN, 0, 0, dwContext);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            dwRet = CSCPROC_RETURN_ABORT;
        }


        LocalFree(lpFT);

        if (dwRet != CSCPROC_RETURN_CONTINUE)
        {
            if (dwRet == CSCPROC_RETURN_ABORT)
            {
                SetLastError(ERROR_OPERATION_ABORTED);
            }
            else
            {
                SetLastError(ERROR_SUCCESS);
            }
        }
    }

    for (i=0; i<4; ++i)
    {
        // for now we don't do directory deletions
        // we will fix this later

        if (i==REINT_DELETE_DIRS)
        {
            continue;
        }

        vsRei.nCurrentState = i;

        try
        {
            iRet = TraverseOneDirectory(
                        hShadowDB,
                        pShareSecurityInfo,
                        0,
                        hRoot,
                        tzFullPath,
                        ReintDirCallback,
                        (LPVOID)&vsRei);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            iRet = TOD_ABORT;
        }

        if (iRet == TOD_ABORT)
        {
            break;
        }
    }


    if (iRet != TOD_ABORT)
    {
        if(!vsRei.lpnodeInsertList)
        {
            fDone = TRUE;
        }
    }

    if (fDone) {

        SetShareStatus(hShadowDB, hShare, (unsigned long)(~SHARE_REINT), SHADOW_FLAGS_AND);
    }

bailout:


    if (!fDone)
    {
        dwError = GetLastError();
    }

#if 0
    if (fIsDfsConnect)
    {
        DbgPrint("Nuking DFS connects On Close %ls \n", sSR.rgSharePath);
        do
        {
            if(WNetCancelConnection2(sSR.rgSharePath, 0, TRUE) != NO_ERROR)
            {
                DbgPrint("Nuked On Close %ls Error=%d\n", sSR.rgSharePath, GetLastError());
                break;
            }
            else
            {
                DbgPrint("Nuked On Close %ls \n", sSR.rgSharePath);
            }

        } while (TRUE);
    }
#endif

    EnterAgentCrit();

    if (fBeginReint){

        Assert(hShare == vsRei.hShare);

        EndReint(hShare, lpContext);

        vsRei.hShare = 0;


        fBeginReint = FALSE;
        if (lpfnMergeProgress)
        {
            try
            {
                dwRet = (*lpfnMergeProgress)(sSR.rgSharePath, ulStatus, 0, 0, NULL, CSCPROC_REASON_END, 0, 0, dwContext);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                dwRet = CSCPROC_RETURN_ABORT;
            }
        }
    }

    if (fDisabledShadowing)
    {
        EnableShadowingForThisThread(hShadowDB);
    }

    CloseShadowDatabaseIO(hShadowDB);

    if(vsRei.lpnodeInsertList) {
        killList(vsRei.lpnodeInsertList);
    }

    // reestablish the connection list
    // NB we do this before we disconnect the drive mapping
    // so that if any special credentials stay because
    // there is always one connection outstanding to the server
    
    if (lpHead)
    {
        ReconnectList(&lpHead, NULL);
        ClearConnectionList(&lpHead);
    }

    if (fConnected) {

        if(DWDisconnectDriveMappedNet(vsRei.tzDrive, TRUE))
        {
            ReintKdPrint(BADERRORS, ("Failed disconnection of merge drive \r\n"));
        }
        else
        {
            ReintKdPrint(MERGE, ("Disconnected merge drive \r\n"));
        }
    }

    memset(&vsRei, 0, sizeof(vsRei));

    LeaveAgentCrit();

    if (!fDone)
    {

        ReintKdPrint(BADERRORS, ("Failed merge dwError=%d\r\n", dwError));
        SetLastError(dwError);
    }


    return (fDone);
}


/***************************************************************************
 * enumerate all the shares, checking to see if the share needs to be
 *    merged before starting.
 * Returns: # of shares that needed to be merged and were successfully done.
 */
// HWND for parent for UI.
int
PUBLIC
ReintAllShares(
    HWND hwndParent
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/

{
    unsigned long ulStatus;
    WIN32_FIND_DATA sFind32;
    int iDone=0, iDoneOne;
    SHADOWINFO sSI;
    HANDLE                hShadowDB;
    CSC_ENUMCOOKIE  ulEnumCookie=NULL;

    if ((hShadowDB = OpenShadowDatabaseIO()) ==INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

#if 0
    if (!EnterAgentCrit()) {
        ReintKdPrint(BADERRORS, ("ReintAllShares:Failed to enter critsect \r\n"));
        return 0;
    }
#endif


    vhcursor = LoadCursor(NULL, IDC_WAIT);

    memset(&sFind32, 0, sizeof(sFind32));
    lstrcpy(sFind32.cFileName, tzStarDotStar);


    if(FindOpenShadow( hShadowDB, 0, FINDOPEN_SHADOWINFO_ALL, &sFind32, &sSI)){

        ulEnumCookie = sSI.uEnumCookie;

        do {
            if (FAbortOperation())
            {
                break;
            }

            if(GetShareStatus(hShadowDB, sSI.hShare, &ulStatus)) {
                if(TRUE/*ulStatus & SHARE_REINT*/){ // OLDCODE
                    iDoneOne = ReintOneShare(sSI.hShare, sSI.hShadow, NULL, NULL, NULL, CSC_INVALID_PRINCIPAL_ID, NULL, 0);
                    if (iDoneOne > 0){
                        if (iDone >= 0)
                            ++iDone;
                        }
                    else if (iDoneOne < 0){
                        iDone = -1;
                    }
                }
                else {
                    ReintKdPrint(MERGE, ("server %d doesn't need reint.\n", sSI.hShare));
                }
            }
        } while(FindNextShadow( hShadowDB, ulEnumCookie, &sFind32, &sSI));

        FindCloseShadow(hShadowDB, ulEnumCookie);
    }

#if 0
    LeaveAgentCrit();
#endif
    vhcursor = NULL;

    CloseShadowDatabaseIO(hShadowDB);
    return (iDone);
}

int
CheckDirtyShares(
    VOID
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/

{
    unsigned long ulStatus;
    WIN32_FIND_DATA sFind32;
    int cntDirty=0;
    SHADOWINFO sSI;
    HANDLE                hShadowDB;
    CSC_ENUMCOOKIE  ulEnumCookie=NULL;

    if ((hShadowDB = OpenShadowDatabaseIO()) ==INVALID_HANDLE_VALUE)
    {
        return 0;
    }

    memset(&sFind32, 0, sizeof(sFind32));
    lstrcpy(sFind32.cFileName, tzStarDotStar);

    if(FindOpenShadow(  hShadowDB, 0, FINDOPEN_SHADOWINFO_ALL,
                        &sFind32, &sSI))
    {
        ulEnumCookie = sSI.uEnumCookie;

        do {
            if(GetShareStatus(hShadowDB, sSI.hShare, &ulStatus)) {

                if(ulStatus & SHARE_REINT){
                    ++cntDirty;
                }

            }
        } while(FindNextShadow(hShadowDB, ulEnumCookie, &sFind32, &sSI));

        FindCloseShadow(hShadowDB, ulEnumCookie);
    }

    CloseShadowDatabaseIO(hShadowDB);

    return cntDirty;
}

BOOL
GetRemoteWin32Info(
    _TCHAR              *lptzDrive,
    LPCOPYPARAMS        lpCP,
    LPWIN32_FIND_DATA   lpFind32,
    BOOL                *lpfExists
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/

{
    _TCHAR *    lpT = NULL;
    BOOL fRet = FALSE;
    _TCHAR  tzDrive[4];
    DWORD   dwError = ERROR_SUCCESS;

    *lpfExists = -1;
    tzDrive[0] = 0;

    lpT = AllocMem((lstrlen(lpCP->lpSharePath) + lstrlen(lpCP->lpRemotePath) + 2) * sizeof(_TCHAR));

    if (lpT)
    {

        if (lptzDrive && lptzDrive[0])
        {
            lstrcpy(lpT, lptzDrive);
        }
        else
        {
            dwError = DWConnectNet(lpCP->lpSharePath, tzDrive, NULL, NULL, NULL, 0, NULL);
            if ((dwError != WN_SUCCESS) && (dwError != WN_CONNECTED_OTHER_PASSWORD_DEFAULT))
            {
                tzDrive[0] = 0;
                goto bailout;
            }

            lstrcpy(lpT, tzDrive);
        }

        lstrcat(lpT, lpCP->lpRemotePath);

        fRet = GetWin32Info(lpT, lpFind32);    // if this fails, GetLastError is properly set

        if (fRet)
        {
            *lpfExists = TRUE;
        }
        else
        {
            dwError = GetLastError();
            if ((dwError == ERROR_FILE_NOT_FOUND)||
                 (dwError == ERROR_PATH_NOT_FOUND)||
                 (dwError == ERROR_INVALID_PARAMETER)
                )
            {
                *lpfExists = FALSE;
            }
        }
    }
    else
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
    }
bailout:
    if (tzDrive[0])
    {
        if(DWDisconnectDriveMappedNet(tzDrive, TRUE))
        {
            ReintKdPrint(BADERRORS, ("Failed disconnection of remote drive \r\n"));
        }
    }
    if (lpT)
    {
        FreeMem(lpT);
    }
    if (!fRet)
    {
        SetLastError(dwError);
    }
    return (fRet);
}


VOID
PRIVATE
InferReplicaReintStatus(
    LPSHADOWINFO         lpSI,              // shadow info
    LPWIN32_FIND_DATA    lpFind32Local,     // win32 info in the database
    LPWIN32_FIND_DATA     lpFind32Remote,   // if NULL, the remote doesn't exist
    int                 *lpiShadowStatus,
    int                 *lpiFileStatus,
    unsigned             *lpuAction
    )
/*++

Routine Description:

    As the name sugggests, the routine find out what changes have occurred on the local replica
    and whether there is a conflict with the original on the remote.

Arguments:

    lpSI                shadow info

    lpFind32Local       win32 info in the database

    lpFind32Remote      win32 info for the original if NULL, the original doesn't exist

    lpiShadowStatus     status of local replica returned

    lpiFileStatus       status of remote replica returned

    lpuAction           Action to be performed to do the merge returned


Returns:

    -

Notes:

--*/

{
    int iShadowStatus=SI_UNCHANGED, iFileStatus=SI_UNCHANGED;
    unsigned int uAction=RAIA_TOOUT;


    if(mShadowDeleted(lpSI->uStatus)){
        iShadowStatus=SI_DELETED;
    }

    if(lpSI->uStatus & (SHADOW_DIRTY|SHADOW_TIME_CHANGE|SHADOW_ATTRIB_CHANGE)){
        iShadowStatus=SI_CHANGED;
    }

    if(mShadowLocallyCreated(lpSI->uStatus)){
        iShadowStatus=SI_NEW;
    }

    // no one should be calling this if there have been no offline changes
    Assert(iShadowStatus != SI_UNCHANGED);

    if(!lpFind32Remote){    // does the remote exist?
        // No
        // if the shadow was not locally created then it must have vanished from the share
        if(iShadowStatus != SI_NEW) {
            iFileStatus=SI_DELETED;
            uAction = RAIA_MERGE;
            ReintKdPrint(MERGE, ("<%ls> deleted at some stage\n", lpFind32Local->cFileName));
        }
        else {
            // we mark the outside as not existing.  We also have to
            // create a file locally to get the insert to work right...
            // don't forget to kill it later. 
            iFileStatus=SI_NOEXIST;
            ReintKdPrint(MERGE, ("<%ls> will be created\n", lpFind32Local->cFileName));
        }
    }
    else {
        // check to see if server version has been touched
        // NB the last accesstime field of the lpFind32Local contains the replica time

        if ((lpFind32Local->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            != (lpFind32Remote->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            // dir became file or vice versa
            iFileStatus=SI_CHANGED;
            uAction = RAIA_MERGE;
        }
        else
        {
            if(CompareTimesAtDosTimePrecision(lpFind32Remote->ftLastWriteTime, //dst
                lpFind32Local->ftLastAccessTime))    //src , does (dst-src)
            {
                // the timestamps don't match

                // mark the remote as changed only if it is a file
                // will do the directories quitely
                if (!(lpFind32Remote->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                {
                    iFileStatus=SI_CHANGED;
                    uAction = RAIA_MERGE;
                    ReintKdPrint(MERGE, ("<%ls> will be merged\n", lpFind32Local->cFileName));
                }
            }
        }
    }

    *lpiShadowStatus = iShadowStatus;
    *lpiFileStatus = iFileStatus;
    *lpuAction = uAction;

}


BOOL
PRIVATE
PerformOneReint(
    HANDLE              hShadowDB,
    LPSECURITYINFO      pShareSecurityInfo,
    _TCHAR *            lpszDrive,          // drive mapped to the UNC name of lpSI->hShare
    _TCHAR *            lptzFullPath,       // full UNC path
    LPCOPYPARAMS        lpCP,               // copy parameters
    LPSHADOWINFO        lpSI,               // shadowinfo structure
    LPWIN32_FIND_DATA   lpFind32Local,      // local win32 data
    LPWIN32_FIND_DATA   lpFind32Remote,     // remote win32 data, could be NULL
    DWORD               dwErrorRemoteFind32,// error code while getting remote win32 data
    int                 iShadowStatus,      // local copy status
    int                 iFileStatus,        // remote file status
    unsigned            uAction,            // action to be taken
    DWORD               dwFileSystemFlags,  // CODE.IMPROVEMENT, why not just pass down REINT_INFO
    ULONG               ulPrincipalID,
    LPCSCPROC           lpfnMergeProgress,  // instead of the three parameters?
    DWORD_PTR           dwContext
    )
/*++

Routine Description:

    Merges a filesystem object by calling the routine for the appropriate type of FS object.
    We implement only files and directories for NT5. Also does callbacks for the UI.

Arguments:

    hShadowDB           Shadow Database handle
    
    lpszDrive           drive mapped to the UNC name of lpSI->hShare
    
    lptzFullPath        full UNC path
    
    lpCP                copy parameters containing various paths for the object being merged
    
    lpSI                shadowinfo structure for the object being merged
    
    lpFind32Local       local win32 data for the object being merged
    
    lpFind32Remote      remote win32 data for the object being merged, could be NULL
    
    iShadowStatus       local copy status
    
    iFileStatus         remote file status
    
    uAction             action to be taken
    
    dwFileSystemFlags   remote filesystem 
    
    ulPrincipalID       principal ID in order to skip selectively
    
    lpfnMergeProgress   callback function
    
    dwContext           callback context

Returns:


Notes:

--*/
{
    DWORD dwError, dwRet;

    dwError = NO_ERROR;

    ReintKdPrint(
        MERGE,
        ("++++++++PerformOneReint: %s (%08x) %d %d perform:\n",
        lptzFullPath,
        lpSI->hShadow,
        iShadowStatus,
        iFileStatus));

    if (lpfnMergeProgress)
    {
        ULONG   uStatus = lpSI->uStatus;
        DWORD   dwsav0, dwsav1;

        // if there is an error in getting remote find32, then 
        // don't tell any conflicts to the callback, because we don't want to show any UI
        if (dwErrorRemoteFind32 != NO_ERROR)
        {
            iFileStatus = SI_CHANGED;
            uAction = RAIA_TOOUT;
        }

        // if this is a file, check whether access is allowed for this user
        if (!(lpFind32Local->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            BOOL fRet;

            Assert(dwError == NO_ERROR);
            Assert(ulPrincipalID != CSC_INVALID_PRINCIPAL_ID);

            dwsav0 = lpFind32Local->dwReserved0;
            dwsav1 = lpFind32Local->dwReserved1;

            fRet = GetCSCAccessMaskForPrincipalEx(
                        ulPrincipalID,
                        lpSI->hDir,
                        lpSI->hShadow,
                        &uStatus,
                        &lpFind32Local->dwReserved0,
                        &lpFind32Local->dwReserved1);

            //
            // Adjust user and guest permissions based on share security, if
            // we have such info.
            //
            if (pShareSecurityInfo != NULL) {
                ULONG i;
                ULONG GuestIdx = CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS;
                ULONG UserIdx = CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS;

                //
                // Find the user's and guest's entries
                //
                for (i = 0; i < CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS; i++) {
                    if (pShareSecurityInfo[i].ulPrincipalID == ulPrincipalID)
                        UserIdx = i;
                    if (pShareSecurityInfo[i].ulPrincipalID == CSC_GUEST_PRINCIPAL_ID)
                        GuestIdx = i;
                }
                //
                // Only work with share perms if we found a guest perm in the list
                //
                if (GuestIdx < CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS) {
                    if (UserIdx >= CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS)
                        UserIdx = GuestIdx;
                    //
                    // Logical AND the share perms with the file perms - to prevent
                    // ACCESS_DENIED errors on files which a user has access to via
                    // file perms, but share perms deny such access.
                    //
                    lpFind32Local->dwReserved0 &= pShareSecurityInfo[UserIdx].ulPermissions;
                    lpFind32Local->dwReserved1 &= pShareSecurityInfo[GuestIdx].ulPermissions;
                }
            }

            if (!fRet)
            {
                dwError = GetLastError();
                ReintKdPrint(MERGE, ("Failed to get accessmask Error=%d \n", dwError));
                lpFind32Local->dwReserved0 = dwsav0;
                lpFind32Local->dwReserved1 = dwsav1;
                goto bailout;            
            }
            else
            {
                Assert((uStatus & ~FLAG_CSC_ACCESS_MASK) == lpSI->uStatus);
                ReintKdPrint(MERGE, ("PerformOneReint: Status with mask 0x%x\n",uStatus));
            }
        }

        try{
            dwRet = (*lpfnMergeProgress)(
                        lptzFullPath,
                        uStatus,
                        lpSI->ulHintFlags,
                        lpSI->ulHintPri,
                        lpFind32Local,
                        CSCPROC_REASON_BEGIN,
                        (uAction == RAIA_MERGE),
                        (iFileStatus == SI_DELETED),
                        dwContext
                        );
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            dwRet = CSCPROC_RETURN_ABORT;
        }

        lpFind32Local->dwReserved0 = dwsav0;
        lpFind32Local->dwReserved1 = dwsav1;

        if (dwRet != CSCPROC_RETURN_CONTINUE)
        {
            // if the guy said abort, we want to quit with the correct error code
            if (dwRet == CSCPROC_RETURN_ABORT)
            {
                dwError = ERROR_OPERATION_ABORTED;
                goto bailout;
            }


            if (dwRet == CSCPROC_RETURN_FORCE_INWARD)
            {
                // the remote copy wins
                uAction = RAIA_TOIN;
            }
            else if (dwRet == CSCPROC_RETURN_FORCE_OUTWARD)
            {
                // local copy wins
#if defined(BITCOPY)
                ReintKdPrint(MERGE, ("CSCPROC_RETURN_FORCE_OUTWARD\n"));
                uAction = RAIA_MERGE;
#else
                uAction = RAIA_TOOUT;
#endif // defined(BITCOPY)
            }
            else
            {
                goto bailout;
            }
        }
        else
        {
            // if we are asked to continue, we press on irrespective of whether there is
            // a conflict or not

#if defined(BITCOPY)
            ReintKdPrint(MERGE, ("CSCPROC_RETURN_CONTINUE\n"));
#endif // defined(BITCOPY)
            uAction = RAIA_TOOUT;
        }

        // if there is an error in getting remote find32, then 
        // tell the real error code to the callback
        if (dwErrorRemoteFind32 != NO_ERROR)
        {
            dwError = dwErrorRemoteFind32;
            goto bailout;
        }
    }

    switch(uAction){

        case RAIA_MERGE:
        case RAIA_TOOUT:
            ReintKdPrint(MERGE, ((uAction==RAIA_TOOUT)?"RAIA_TOOUT\n":"RAIA_MERGE\n"));

            if (lpFind32Local->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY){
                dwError = DoCreateDir(
                            hShadowDB,
                            lpszDrive,
                            lptzFullPath,
                            lpCP,
                            lpSI,
                            lpFind32Local,
                            lpFind32Remote,
                            iShadowStatus,
                            iFileStatus,
                            uAction,
                            dwFileSystemFlags,
                            lpfnMergeProgress,
                            dwContext
                            );
            }
            else {
                dwError = DoObjectEdit(
                            hShadowDB,
                            lpszDrive,
                            lptzFullPath,
                            lpCP,
                            lpSI,
                            lpFind32Local,
                            lpFind32Remote,
                            iShadowStatus,
                            iFileStatus,
                            uAction,
                            dwFileSystemFlags,
                            lpfnMergeProgress,
                            dwContext
                            );
                ReintKdPrint(MERGE, ("DoObjectEdit returned 0x%x\n", dwError));
            }
        break;

        case RAIA_TOIN:
            ReintKdPrint(MERGE, ("RAIA_TOIN\n"));

            if((!SetShadowInfo(hShadowDB, lpSI->hDir, lpSI->hShadow, NULL, (unsigned long)~(SHADOW_MODFLAGS), SHADOW_FLAGS_AND))
               ||!CheckForStalenessAndRefresh(hShadowDB, lpszDrive, lpCP, lptzFullPath, lpSI))
            {
                dwError = GetLastError();
            }
        break;

        case RAIA_SKIP:
            ReintKdPrint(MERGE, ("RAIA_SKIP\n"));
        break;

        case RAIA_CONFLICT:
            ReintKdPrint(MERGE, ("RAIA_CONFLICT\n"));
        break;

        case RAIA_SOMETHING:
            ReintKdPrint(MERGE, ("RAIA_SOMETHING\n"));
        break;

        case RAIA_NOTHING:
            ReintKdPrint(MERGE, ("RAIA_NOTHING\n"));
        break;

        case RAIA_ORPHAN:
            ReintKdPrint(MERGE, ("RAIA_ORPHAN\n"));
        break;

        default:
            ReintKdPrint(MERGE, ("BOGUS!!!!!!!!!!!! %d\n",uAction));
    }
bailout:

    if (lpfnMergeProgress)
    {
        try
        {
            dwRet = (*lpfnMergeProgress)(
                                lptzFullPath,
                                lpSI->uStatus,
                                lpSI->ulHintFlags,
                                lpSI->ulHintPri,
                                lpFind32Local,
                                CSCPROC_REASON_END,
                                (uAction == RAIA_MERGE),
                                dwError,
                                dwContext
                                );
            ReintKdPrint(MERGE, ("Got %d from callback at CSCPROC_REASON_END\n", dwRet));
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            dwRet = CSCPROC_RETURN_ABORT;
        }
        if (dwRet == CSCPROC_RETURN_ABORT)
        {
            dwError = ERROR_OPERATION_ABORTED;
        }
    }

    if (dwError == NO_ERROR) {
        ReintKdPrint(MERGE, ("--------PerformOneReint exit TRUE\n"));
        return TRUE;
    }

    ReintKdPrint(MERGE, ("--------PerformOneReint exit FALSE (0x%x)\n", dwError));
    SetLastError(dwError);
    return (FALSE);
}


/******************************* Conflict related operations ****************/

DWORD
PRIVATE
CheckFileConflict(
   LPSHADOWINFO   lpSI,
   LPWIN32_FIND_DATA lpFind32Remote
   )
{
    unsigned long ulStatus = lpSI->uStatus;

    if (!lpFind32Remote){
        if (!(mShadowLocallyCreated(ulStatus)||mShadowDeleted(ulStatus))){
            return (ERROR_DELETE_CONFLICT);
        }
        else{
            return (NO_ERROR);
        }
    }
    else {
        // Create/Create conflict
        if (mShadowLocallyCreated(ulStatus)){
            return (ERROR_CREATE_CONFLICT);
        }

        if (lpFind32Remote->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY){
            if (mShadowDeleted(ulStatus)){
                return (NO_ERROR);
            }
            else{
                return(ERROR_ATTRIBUTE_CONFLICT);
            }
        }

        if(ChkUpdtStatus(INVALID_HANDLE_VALUE, lpSI->hDir, lpSI->hShadow, lpFind32Remote, &ulStatus) == 0){
            return (GetLastError());
        }

        if (mShadowConflict(ulStatus)){
            return (ERROR_UPDATE_CONFLICT);
        }
    }

   return (NO_ERROR);
}


DWORD
PRIVATE
InbCreateDir(
    _TCHAR *     lpDir,
    DWORD    dwAttr
    )
{
    SECURITY_ATTRIBUTES sSA;
    DWORD dwError = NO_ERROR, dwT;

    sSA.nLength = sizeof(SECURITY_ATTRIBUTES);
    sSA.lpSecurityDescriptor = NULL;
    sSA.bInheritHandle = TRUE;

    if ((dwT = GetFileAttributes(lpDir))==0xffffffff){
        if (!CreateDirectory(lpDir, &sSA)){
            dwError = GetLastError();
        }
    }
    else
    {
        if (!(dwT & FILE_ATTRIBUTE_DIRECTORY))
        {
            dwError = ERROR_FILE_EXISTS;    // there is a file by the same name
        }
    }
    if (dwError == NO_ERROR)
    {
        if (dwAttr != 0xffffffff)
        {
            if(!SetFileAttributes(lpDir, dwAttr))
            {
                ReintKdPrint(MERGE, ("Benign error %x \n", GetLastError()));
            }
        }
    }
    return (dwError);
}


/*********************************** Misc routines **************************/

#if defined(BITCOPY)
int
PRIVATE
GetShadowByName(
    HSHADOW              hDir,
    _TCHAR *                lpName,
    LPWIN32_FIND_DATA    lpFind32,
    unsigned long        *lpuStatus
    )
/*++

Routine Description:


Arguments:


Returns:

Notes:

--*/
{
    HSHADOW hShadow;
    memset(lpFind32, 0, sizeof(WIN32_FIND_DATA));
    lstrcpyn(lpFind32->cFileName, lpName, sizeof(lpFind32->cFileName)-1);
    return(GetShadow(INVALID_HANDLE_VALUE, hDir, &hShadow, lpFind32, lpuStatus));
}
#endif // defined(BITCOPY)

DWORD
DoSparseFill(
    HANDLE          hShadowDB,
    _TCHAR *          lpszFullPath,
    _TCHAR *          lptzDrive,
    LPSHADOWINFO    lpSI,
    WIN32_FIND_DATA *lpFind32,
    LPCOPYPARAMS    lpCP,
    BOOL            fStalenessCheck,
    ULONG           ulPrincipalID,
    LPCSCPROC       lpfnProgress,
    DWORD_PTR       dwContext
   )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    DWORD dwError = 0xffffffff, dwRet, dwTotal=0, dwTotalSleepTime = 0, cntRetries=0, cntMaxRetries=1;
    BOOL fConnected = FALSE, fIsSlowLink, fDisabledShadowing = FALSE, fAmAgent;
    int cbRead;
    COPYCHUNKCONTEXT CopyChunkContext;
    HANDLE hAnchor = INVALID_HANDLE_VALUE;
    ULONG   uStatus;

    fAmAgent = (GetCurrentThreadId() == vdwCopyChunkThreadId);
    Assert(GetCurrentThreadId() != vdwAgentThreadId);

    memset(&CopyChunkContext, 0, sizeof(CopyChunkContext));
    CopyChunkContext.handle = INVALID_HANDLE_VALUE;

    if (!fAmAgent)
    {
        cntMaxRetries = MAX_SPARSE_FILL_RETRIES;
    }

    ReintKdPrint(FILL, ("cntMaxRetries = %d \r\n", cntMaxRetries));

    if(!DoShadowMaintenance(hShadowDB, SHADOW_BEGIN_INODE_TRANSACTION))
    {
        return GetLastError();
    }

    // report the progress
    if (lpfnProgress)
    {
        DWORD   dwsav0, dwsav1;
        BOOL    fRet;

        uStatus = lpSI->uStatus;


        Assert(ulPrincipalID != CSC_INVALID_PRINCIPAL_ID);

        dwError = ERROR_SUCCESS;

        dwsav0 = lpFind32->dwReserved0;
        dwsav1 = lpFind32->dwReserved1;

        fRet = GetCSCAccessMaskForPrincipalEx(ulPrincipalID, lpSI->hDir, lpSI->hShadow, &uStatus, &lpFind32->dwReserved0, &lpFind32->dwReserved1);


        if (!fRet)
        {
            dwError = GetLastError();
            ReintKdPrint(BADERRORS, ("DoSparseFill Failed to get accessmask Error=%d\r\n", dwError));
            lpFind32->dwReserved0 = dwsav0;
            lpFind32->dwReserved1 = dwsav1;
            goto done;            
        }
        else
        {
            Assert((uStatus & ~FLAG_CSC_ACCESS_MASK) == lpSI->uStatus);
        }

        try{
            dwRet = (*lpfnProgress)(
                                    lpszFullPath,
                                    uStatus,
                                    lpSI->ulHintFlags,
                                    lpSI->ulHintPri,
                                    lpFind32,
                                    CSCPROC_REASON_BEGIN,
                                    0,
                                    0,
                                    dwContext
                                    );
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            dwRet = CSCPROC_RETURN_ABORT;
        }

        lpFind32->dwReserved0 = dwsav0;
        lpFind32->dwReserved1 = dwsav1;

        if (dwRet != CSCPROC_RETURN_CONTINUE)
        {
            if (dwRet == CSCPROC_RETURN_ABORT)
            {
                dwError = ERROR_OPERATION_ABORTED;
            }
            else
            {
                dwError = ERROR_SUCCESS;
            }

            goto done;
        }
    }

    if (fStalenessCheck)
    {
        ReintKdPrint(FILL, ("Doing staleness check %ls \r\n", lpszFullPath));
        dwError = DoRefresh(hShadowDB, lpCP, lpszFullPath, lpSI, lptzDrive);

        if (dwError != NO_ERROR)
        {
            ReintKdPrint(ALWAYS, ("Error = %x on refresh for %ls \r\n", dwError, lpszFullPath));
            goto bailout;
        }

        if (!(lpSI->uStatus & SHADOW_SPARSE) && !(lpFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            HANDLE hFile;


            if (    !lpfnProgress ||    // if this is not UI
                    (uStatus & FLAG_CSC_USER_ACCESS_MASK) || // or the user already has a mask
                    ((uStatus & FLAG_CSC_GUEST_ACCESS_MASK)== // or the guest has full permission
                        ((FLAG_CSC_READ_ACCESS|FLAG_CSC_WRITE_ACCESS)
                            <<FLAG_CSC_GUEST_ACCESS_SHIFT_COUNT)))
            {
                goto done;
            }

            // open the file to get the access rights for the user

            hFile = CreateFile(lpszFullPath,
                                     GENERIC_READ,
                                     FILE_SHARE_READ,
                                     NULL,
                                     OPEN_EXISTING,
                                     0,
                                     NULL);

            if (hFile != INVALID_HANDLE_VALUE)
            {
                CloseHandle(hFile);
            }
            else
            {
                dwError = GetLastError();
                goto bailout;
            }

            goto done;
        }

        if (!lpSI->hDir || !mShadowIsFile(lpSI->uStatus))
        {
            ReintKdPrint(FILL, ("Done staleness check for directory %ls, quitting \r\n", lpszFullPath));
            goto done;
        }
    }

    Assert(mShadowIsFile(lpSI->uStatus));
    Assert((lpSI->uStatus & SHADOW_SPARSE));

    fIsSlowLink = FALSE;    // on NT we are always going aggressively
    cbRead = (fIsSlowLink)?FILL_BUF_SIZE_SLOWLINK:FILL_BUF_SIZE_LAN;

    for (cntRetries=0; cntRetries<cntMaxRetries; ++cntRetries)
    {

        memset(&CopyChunkContext, 0, sizeof(CopyChunkContext));
        CopyChunkContext.handle = INVALID_HANDLE_VALUE;
        if (fAmAgent)
        {
            CopyChunkContext.dwFlags |= COPYCHUNKCONTEXT_FLAG_IS_AGENT_OPEN;
        }

        if (!OpenFileWithCopyChunkIntent(hShadowDB, lpszFullPath,
                                         &CopyChunkContext,
                                         (fIsSlowLink)?FILL_BUF_SIZE_SLOWLINK
                                                      :FILL_BUF_SIZE_LAN
                                         )) {
            dwError = GetLastError();
            if(dwError == ERROR_LOCK_VIOLATION)
            {
                if (cntMaxRetries > 1)
                {
                    ReintKdPrint(FILL, ("LockViolation, Retrying Sparse filling %ls \r\n", lpszFullPath));
                    Sleep(1000);
                    continue;
                }
            }
            ReintKdPrint(FILL, ("error %x, OpenCopyChunk failed %ls \r\n", dwError, lpszFullPath));
            goto bailout;
        }

        do {
            CopyChunkContext.ChunkSize = cbRead;

            if (FAbortOperation())
            {
                dwError = ERROR_OPERATION_ABORTED;
                goto done;
            }


            if((CopyChunk(hShadowDB, lpSI, &CopyChunkContext)) == 0){

                // NB we break here deliberately in order to get into the outer loop
                // where we will retry the operation
                dwError = GetLastError();
                ReintKdPrint(FILL, ("error %x, CopyChunk failed %ls \r\n", dwError, lpszFullPath));
                break;
            }

            if (lpfnProgress)
            {
                dwRet = (*lpfnProgress)(  lpszFullPath,
                                    lpSI->uStatus,
                                    lpSI->ulHintFlags,
                                    lpSI->ulHintPri,
                                    lpFind32,
                                    CSCPROC_REASON_MORE_DATA,
                                    (DWORD)(CopyChunkContext.LastAmountRead+
                                            CopyChunkContext.TotalSizeBeforeThisRead),    // low dword of bytes transferred
                                    0,
                                    dwContext
                                    );

                if (dwRet != CSCPROC_RETURN_CONTINUE)
                {
                    // once we start copying, any return code
                    // other than continue is abort
                    dwError = ERROR_OPERATION_ABORTED;
                    goto done;
                }
            }

// NB there seems to be a timing window here. The file could get out of ssync
// by the time we came here and it could have been marked sparse by then
            if (!CopyChunkContext.LastAmountRead) {
                SetShadowInfo(hShadowDB, lpSI->hDir, lpSI->hShadow, NULL, (unsigned long)~SHADOW_SPARSE, SHADOW_FLAGS_AND);
                ReintKdPrint(FILL, ("Done Sparse filling %ls \r\n", lpszFullPath));
                goto success;
            }


        }while (TRUE);

        if (dwError == ERROR_GEN_FAILURE)
        {
            // this might be due to the fact that
            // the guy we were piggybacking on went away
            // Just try a few times

            ReintKdPrint(FILL, ("Retrying Sparse filling %ls \r\n", lpszFullPath));
            CloseFileWithCopyChunkIntent(hShadowDB, &CopyChunkContext);
            CopyChunkContext.handle = INVALID_HANDLE_VALUE;
            dwError = 0xffffffff;
            continue;
        }
        else if (dwError != NO_ERROR)
        {
            ReintKdPrint(BADERRORS, ("Error %x while Sparse filling %ls \r\n", dwError, lpszFullPath));
            goto bailout;
        }

    }

success:

   dwError = NO_ERROR;
   goto done;

bailout:


    // if the net is disconnected then put the whole share in the skip queue
    // else put the file in the queue
    if (IsNetDisconnected(dwError))
    {
#ifdef DEBUG
         EnterSkipQueue(lpSI->hShare, 0, 0, lpszFullPath);
#else
         EnterSkipQueue(lpSI->hShare, 0, 0);
#endif //DEBUG
    }
    else
    {
#ifdef DEBUG
         EnterSkipQueue(lpSI->hShare, lpSI->hDir, lpSI->hShadow, lpszFullPath);
#else
         EnterSkipQueue(lpSI->hShare, lpSI->hDir, lpSI->hShadow);
#endif //DEBUG

    }

    ReportLastError();

done:

    if (lpfnProgress)
    {
        dwRet = (*lpfnProgress)( lpszFullPath,
                         lpSI->uStatus,
                         lpSI->ulHintFlags,
                         lpSI->ulHintPri,
                         lpFind32,
                         CSCPROC_REASON_END,
                         (DWORD)(CopyChunkContext.LastAmountRead+
                                 CopyChunkContext.TotalSizeBeforeThisRead),    // low dword of bytes transferred
                         dwError,    // errorcode
                         dwContext
                         );

        if (dwRet == CSCPROC_RETURN_ABORT)
        {
            dwError = ERROR_OPERATION_ABORTED;
        }

    }

    if (CopyChunkContext.handle != INVALID_HANDLE_VALUE){
        CloseFileWithCopyChunkIntent(hShadowDB, &CopyChunkContext);
    }

    if (hAnchor != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hAnchor);
    }

    DoShadowMaintenance(hShadowDB, SHADOW_END_INODE_TRANSACTION);

    return (dwError);
}

BOOL
CheckForStalenessAndRefresh(
    HANDLE          hShadowDB,
    _TCHAR          *lptzDrive,
    LPCOPYPARAMS    lpCP,
    _TCHAR          *lpRemoteName,
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    BOOL fDone = FALSE, fDisabledShadowing=FALSE;
    WIN32_FIND_DATA sFind32;
    BOOL fExists = FALSE;

    // Let us get the latest info
    if (GetRemoteWin32Info(lptzDrive, lpCP, &sFind32, &fExists))
    {
        // If this is a file, update the file status
        if (lpSI->hDir && mShadowIsFile(lpSI->uStatus))
        {
            if (!(lpSI->uStatus & SHADOW_STALE))
            {
                ReintKdPrint(FILL, ("Checking update status for a file %ls\r\n", lpRemoteName));
                // compare the timestamp as obtained from the
                // server with that on the database. If the two are the same
                // the file in our database is still consistent with the one on the server
                // Otherwise the call below will mark it as stale
                if(ChkUpdtStatus(   hShadowDB,
                                    lpSI->hDir,
                                    lpSI->hShadow,
                                    &sFind32, &(lpSI->uStatus)) == 0){
                    ReintKdPrint(BADERRORS, ("ChkUpdt failed %X \r\n", lpSI->hShadow));
                    goto bailout;
                }

            }

            if (lpSI->uStatus & SHADOW_STALE)
            {
                // if it changed from being a file, then mark it a orphan
                // else truncate it's data and mark it sparse
                if (IsFile(sFind32.dwFileAttributes))
                {
                    ReintKdPrint(FILL, ("File %ls is stale, truncating\r\n", lpRemoteName));

                    if(SetShadowInfo(hShadowDB, lpSI->hDir, lpSI->hShadow, &sFind32, 0, SHADOW_FLAGS_OR|SHADOW_FLAGS_TRUNCATE_DATA))
                    {
                        lpSI->uStatus &= ~SHADOW_STALE;
                        lpSI->uStatus |= SHADOW_SPARSE;

                        fDone = TRUE;
                    }
                }
                else
                {
                    ReintKdPrint(FILL, ("File %ls become directory, marking orphan\r\n", lpRemoteName));
                    if(SetShadowInfo(hShadowDB, lpSI->hDir, lpSI->hShadow, NULL, SHADOW_ORPHAN, SHADOW_FLAGS_OR))
                    {
                        lpSI->uStatus |= SHADOW_ORPHAN;

                        fDone = TRUE;
                    }
                }
            }
            else
            {
                fDone = TRUE;
            }
        }
        else
        {
            // NB, we do nothing if a directory changed to file
            // we are letting the scavenging code remove the entries in due course.
            // If one of the descendents of this directory are pinned, then they stay on
            // in the database till the user actually cleans then up.
            // Need a good startegy to warn the user about it.

            if (!IsFile(sFind32.dwFileAttributes))
            {
                // this is a directory
                // update it's win32 data so that things like attributes get updated
                // We get here only during fullsync operations
                if(SetShadowInfo(hShadowDB, lpSI->hDir, lpSI->hShadow, &sFind32, ~(SHADOW_STALE), SHADOW_FLAGS_AND|SHADOW_FLAGS_CHANGE_83NAME))
                {
                    fDone = TRUE;
                }
            }

        }
    }

bailout:

    if (fDisabledShadowing)
    {
        int iEnable;

        iEnable = EnableShadowingForThisThread(hShadowDB);

        Assert(iEnable);

    }

    if (!fDone)
    {
        ReportLastError();

    }

    return (fDone);
}

DWORD
DWConnectNetEx(
    _TCHAR * lpSharePath,
    _TCHAR * lpOutDrive,
    BOOL fInteractive
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    NETRESOURCE sNR;
    DWORD dwError;
    _TCHAR szErr[16], szNP[16];

    if (lpOutDrive){
        lpOutDrive[0]='E';   // Let use start searching from e:
        lpOutDrive[1]=':';
        lpOutDrive[2]=0;
    }
    do{
        memset(&sNR, 0, sizeof(NETRESOURCE));
        sNR.lpRemoteName = lpSharePath;
        if (lpOutDrive){
            if(lpOutDrive[0]=='Z') {
                break;
            }
            sNR.lpLocalName = lpOutDrive;
        }
        sNR.dwType = RESOURCETYPE_DISK;
        dwError = WNetAddConnection3(vhwndMain, &sNR, NULL, NULL, 0);
        if (dwError==WN_SUCCESS){
            break;
        }
        else if (lpOutDrive &&
                    ((dwError == WN_BAD_LOCALNAME)||
                    (dwError == WN_ALREADY_CONNECTED))){
            ++lpOutDrive[0];
            continue;
        }
        else{
            if (dwError==WN_EXTENDED_ERROR){
                WNetGetLastError(&dwError, szErr, sizeof(szErr), szNP, sizeof(szNP));
            }
            break;
        }
    }
    while (TRUE);

    if ((dwError == ERROR_SUCCESS) && !IsShareReallyConnected((LPCTSTR)lpSharePath))
    {
        WNetCancelConnection2((lpOutDrive)?lpOutDrive:lpSharePath, 0, FALSE);
        SetLastError(dwError = ERROR_REM_NOT_LIST);
    }

    return (dwError);
}

/************************** Skip queue related operations *******************/

#ifdef DEBUG
VOID
EnterSkipQueue(
    HSHARE hShare,
    HSHADOW hDir,
    HSHADOW hShadow,
    _TCHAR * lpPath
    )
#else
VOID
EnterSkipQueue(
    HSHARE hShare,
    HSHADOW hDir,
    HSHADOW hShadow
    )
#endif //DEBUG
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    LPFAILINFO lpFI = NULL;
    LPFAILINFO FAR * lplpFI;

    if (!EnterAgentCrit()){
        return;
    }

    if(lplpFI = LplpFindFailInfo(hShare, hDir, hShadow)){
        lpFI = *lplpFI;
    }

    if (!lpFI){
        if (lpFI = (LPFAILINFO)AllocMem(sizeof(FAILINFO))){
            lpFI->hShare = hShare;
            lpFI->hDir = hDir;
            lpFI->hShadow = hShadow;
#ifdef DEBUG
            lstrcpyn(lpFI->rgchPath, lpPath, MAX_SERVER_SHARE_NAME_FOR_CSC);
#endif //DEBUG
            lpFI->cntFail = 1;
            lpFI->cntMaxFail = (hShadow)?MAX_ATTEMPTS_SHADOW:MAX_ATTEMPTS_SHARE;
            lpFI->lpnextFI = lpheadFI;
            lpheadFI = lpFI;
        }
    }

    if (lpFI){
        if (lpFI->cntFail >= lpFI->cntMaxFail){
            lpFI->dwFailTime = GetTickCount();
            ReintKdPrint(SKIPQUEUE, ("EnterSkipQueue: Marking %ls for Skipping \r\n", lpPath));
        } else{
            // Increment the fail count
            lpFI->cntFail++;
            ReintKdPrint(SKIPQUEUE, ("EnterSkipQueue: Incementing failcount for %ls \r\n", lpPath));
        }
    }
   LeaveAgentCrit();
}


BOOL
PRIVATE
FSkipObject(
    HSHARE hShare,
    HSHADOW hDir,
    HSHADOW hShadow
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    LPFAILINFO FAR *lplpFI;

    if (!EnterAgentCrit()){
        return 0;
    }

    if (lplpFI = LplpFindFailInfo(hShare, hDir, hShadow)){
        if ((*lplpFI)->cntFail >= (*lplpFI)->cntMaxFail) {
            LeaveAgentCrit();
            return TRUE;
        }
    }

    LeaveAgentCrit();
    return FALSE;
}

int
PRIVATE
PurgeSkipQueue(
    BOOL fAll,
    HSHARE  hShare,
    HSHADOW  hDir,
    HSHADOW  hShadow
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    LPFAILINFO FAR *lplpFI = NULL, lpfiTemp;
    DWORD dwCurTime = GetTickCount();
    int cntUnmark=0;

    if (!EnterAgentCrit()){
        return 0;
    }

    for (lplpFI = &lpheadFI; *lplpFI; lplpFI = &((*lplpFI)->lpnextFI)){

        if (fAll ||
            ((dwCurTime - (*lplpFI)->dwFailTime) > WAIT_INTERVAL_SKIP_MS)){
            if ((!hShare || (hShare==(*lplpFI)->hShare))
                && (!hDir || (hDir==(*lplpFI)->hDir))
                && (!hShadow || (hShadow==(*lplpFI)->hShadow)))
                {
                    ReintKdPrint(SKIPQUEUE, ("PurgeSkipQueue: Purging Skip Queue Entry for %s \r\n"
                                    ,(*lplpFI)->rgchPath));
                    lpfiTemp = *lplpFI;
                    *lplpFI = lpfiTemp->lpnextFI;
                    FreeMem(lpfiTemp);
                    ++cntUnmark;
                    if (!*lplpFI){
                        break;
                    }
                }
            }
        }
    LeaveAgentCrit();
    return (cntUnmark);
}

LPFAILINFO FAR *
LplpFindFailInfo(
    HSHARE hShare,
    HSHADOW hDir,
    HSHADOW hShadow
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    LPFAILINFO FAR *lplpFI = NULL;

    // look for the inode or the server entry

    for (lplpFI = &lpheadFI; *lplpFI; lplpFI = &((*lplpFI)->lpnextFI)) {
            if ((hShadow && (hShadow ==  (*lplpFI)->hShadow)) ||
                (hShare && ((*lplpFI)->hShare == hShare))){
            return (lplpFI);
        }
    }
    return (NULL);
}



VOID
ReportLastError(
    VOID
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    DWORD dwError;

    dwError = GetLastError();

    ReintKdPrint(FILL, ("Error # %ld \r\n", dwError));
}

VOID
PRIVATE
ReportStats(
    VOID
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    ReintKdPrint(BADERRORS, ("dirty=%d stale=%d sparse=%d \r\n"
            , vcntDirty
            , vcntStale
            , vcntSparse));
}


VOID
PRIVATE
CopyPQInfoToShadowInfo(
    LPPQPARAMS     lpPQ,
    LPSHADOWINFO   lpShadowInfo
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    lpShadowInfo->hShare = lpPQ->hShare;
    lpShadowInfo->hDir = lpPQ->hDir;
    lpShadowInfo->hShadow = lpPQ->hShadow;
    lpShadowInfo->uStatus = lpPQ->ulStatus;   //Sic
}

int
PUBLIC
EnterAgentCrit(
    VOID
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    if (!vhMutex){
        return 0;
    }
    WaitForSingleObject(vhMutex, INFINITE);
    return 1;
}

VOID
PUBLIC
LeaveAgentCrit(
    VOID
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    ReleaseMutex(vhMutex);
}



BOOL
FGetConnectionList(
    LPCONNECTINFO *lplpHead,
    int *lpcntDiscon
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return (FGetConnectionListEx(lplpHead, NULL, FALSE, FALSE, lpcntDiscon));
}

BOOL
FGetConnectionListEx(
    LPCONNECTINFO   *lplpHead,
    LPCTSTR         lptzShareName,
    BOOL            fAllSharesOnServer,
    BOOL            fServerIsOffline,
    int             *lpcntDiscon
    )
/*++

Routine Description:

    This routine makes a list of shares that are connected and are in disconnected state.
    If lptzShareName is not NULL it returns all the mapping of that share that are
    in disconnected state.

    This is the first of a trilogy of routines used while doing a merge. The other two are
    DisconnectList and ReconnectList.

Arguments:

    lplpHead        head of the list is created here.

    lptzShareName   list of connections for this share, if NULL, list of all connected shares

    lpcntDiscon     # of shares in the list. Can be NULL.

Returns:

    TRUE if there are some entries in the connection list

Notes:

    List is allocated using LocalAlloc. It is upto the caller to free it.

--*/
{
    HANDLE hEnum;
    DWORD cbNum, cbSize, dwError, dwDummy, len=0;
    LPCONNECTINFO lpCI;
    WIN32_FIND_DATA sFind32;


    ReintKdPrint(MERGE, ("Getting conection list\r\n"));

    try
    {
        if (lpcntDiscon){
            *lpcntDiscon = 0;
        }

        *lplpHead = NULL;

        if (lptzShareName)
        {
            len = lstrlen(lptzShareName);
            if (fAllSharesOnServer)
            {
                _TCHAR *lpT, chT;
            
                len = 2;
                for (lpT = (LPTSTR)lptzShareName+2;;)
                {
                    chT = *lpT++;
                
                    Assert(chT);
                    if (chT == (_TCHAR)'\\')
                    {
                        break;
                    }

                    ++len;
                }
                ReintKdPrint(MERGE, ("Nuking shares %ls len %d \n", (LPTSTR)lptzShareName, len));
            }
        }

        // enumerate all connected shares
        if (WNetOpenEnum(   RESOURCE_CONNECTED,
                            RESOURCETYPE_DISK, RESOURCEUSAGE_CONNECTABLE,
                            NULL, &hEnum) == NO_ERROR ){
            do{
                cbNum = 1;
                cbSize = sizeof(dwDummy);
                dwError = WNetEnumResource(hEnum, &cbNum, &dwDummy, &cbSize);

                if (dwError==ERROR_MORE_DATA){

                    if (lpCI =
                        (LPCONNECTINFO)AllocMem(sizeof(CONNECTINFO)+cbSize)){
                        cbNum = 1;
                        dwError = WNetEnumResource(hEnum, &cbNum
                                    , &(lpCI->rgFill[0])
                                    , &cbSize);

                        if (!cbNum || (dwError!=NO_ERROR)){
                            FreeMem(lpCI);
                            break;
                        }
                        if(lptzShareName)
                        {

                            // do case insensitive prefix matching and ensure that
                            // the next character after the match is a path delimiter

                            if (!((CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, 
                                            lptzShareName, len,
                                            ((NETRESOURCE *)&(lpCI->rgFill[0]))->lpRemoteName,len)
                                            == CSTR_EQUAL)&&
                                ((((NETRESOURCE *)&(lpCI->rgFill[0]))->lpRemoteName[len] == (_TCHAR)'\\')||
                                 (((NETRESOURCE *)&(lpCI->rgFill[0]))->lpRemoteName[len] == (_TCHAR)0))))
                            {
                                FreeMem(lpCI);
                                continue;
                            }

                            ReintKdPrint(MERGE, ("Got %ls on %ls\r\n"
                                , (((NETRESOURCE *)&(lpCI->rgFill[0]))->lpLocalName)?((NETRESOURCE *)&(lpCI->rgFill[0]))->lpLocalName:L"Empty"
                                , ((NETRESOURCE *)&(lpCI->rgFill[0]))->lpRemoteName));

                        }
                        lpCI->lpnextCI = *lplpHead;
                        *lplpHead = lpCI;

                        if (!fServerIsOffline)
                        {
                            BOOL fRet;
                            SHADOWINFO sSI;
                            fRet = FindCreateShadowFromPath(((NETRESOURCE *)&(lpCI->rgFill[0]))->lpRemoteName,
                                                            FALSE, // Don't create, just look
                                                            &sFind32,
                                                            &sSI,
                                                            NULL
                                                            );
                            lpCI->uStatus = 0;                                                            
                            if (fRet && sSI.hShadow)
                            {
                                lpCI->uStatus = sSI.uStatus;
                            }
                        }
                        else
                        {
                            lpCI->uStatus |= SHARE_DISCONNECTED_OP;
                        }
                        if (lpcntDiscon && (lpCI->uStatus & SHARE_DISCONNECTED_OP)){
                            ++*lpcntDiscon;
                        }
                    }
                    else{
                        //PANIC
                        break;
                    }
                }
                else{
                    break;
                }
            }while (TRUE);
            WNetCloseEnum(hEnum);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        ReintKdPrint(BADERRORS, ("Took exception in FGetConnectionListEx list \n"));
    }

    return (*lplpHead != NULL);
}

int
DisconnectList(
    LPCONNECTINFO       *lplpHead,
    LPFNREFRESHPROC     lpfn,
    DWORD               dwCookie
)
/*++

Routine Description:

    disconnects all drive mapped shares in a list accumulated using FGetConnectionList

Arguments:


Returns:


Notes:

--*/
{
    BOOL fOk = TRUE;
    DWORD dwError;
    int icntDriveMapped=0;
    LPCONNECTINFO lpTmp = *lplpHead;

    ReintKdPrint(MERGE, ("In DisconnectList \n"));
    
    try
    {
        for (;lpTmp;lpTmp = lpTmp->lpnextCI){
        
            if (!(lpTmp->uStatus & SHARE_DISCONNECTED_OP))
            {
                continue;
            }
            if (((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpLocalName){
        
                ++icntDriveMapped;

                ReintKdPrint(MERGE, ("Nuking %ls on %ls\r\n"
                    , ((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpLocalName
                    , ((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpRemoteName));
                dwError = WNetCancelConnection2( ((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpLocalName, 0, TRUE);

            }
            else{
                ReintKdPrint(MERGE, ("Nuking %ls \r\n" , ((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpRemoteName));
                dwError = WNetCancelConnection2(
                    ((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpRemoteName
                    , 0
                    , TRUE);
            }

            if (dwError != NO_ERROR){
                ReintKdPrint(BADERRORS, ("Error=%ld \r\n", dwError));
                fOk = FALSE;
            }
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        ReintKdPrint(BADERRORS, ("Took exception in Disconnecte list \n"));
        fOk = FALSE;
    }

    ReintKdPrint(MERGE, ("Out DisconnectList %x\n", (fOk?icntDriveMapped:-1)));
    return (fOk?icntDriveMapped:-1);
}

int
CALLBACK
RefreshProc(
    LPCONNECTINFO  lpCI,
    DWORD          dwCookie // LOWORD 0==Silently, 1== Give messages
                           // HIWORD 0==Nuke UNC, 1==Nuke all if no ongoing open/finds
                           // 2==Maximum force for shadow 3==Nuke ALL
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    WORD  wVerbose = LOWORD(dwCookie), wForce = HIWORD(dwCookie);
    int iRet = 0;
    BOOL fDisconnectedOp=FALSE, fOpensFinds = FALSE;


    fDisconnectedOp = (lpCI->uStatus & SHARE_DISCONNECTED_OP);
    fOpensFinds = (lpCI->uStatus & (SHARE_FILES_OPEN|SHARE_FINDS_IN_PROGRESS));

    switch (wForce){
        case 0://shadow UNC connections with no opens/finds in progress
            iRet = (fDisconnectedOp && !fOpensFinds && !((NETRESOURCE *)&(lpCI->rgFill[0]))->lpLocalName)?1:0;
            break;
        case 1://shadow connections (UNC+drivemapped) with no opens/finds in progress
            iRet = (fDisconnectedOp && !fOpensFinds)?1:0;
            break;
        case 2://shadow connections with or without opens/finds
            iRet = (fDisconnectedOp)?1:0;
            break;
        case 3://all connections
            iRet = 1;
            break;
    }
    if ((iRet==1) && wVerbose && fOpensFinds){
        LoadString(vhinstCur, IDS_OPS_IN_PROGRESS, (LPTSTR)(vrgchBuff), 128 * sizeof(TCHAR));
        LoadString(vhinstCur, IDS_SHADOW_AGENT, (LPTSTR)(vrgchBuff+128* sizeof(TCHAR)), 128* sizeof(TCHAR));
        wsprintf((LPTSTR)(vrgchBuff+256), (LPTSTR)(vrgchBuff), ((NETRESOURCE *)&(lpCI->rgFill[0]))->lpRemoteName);
        MessageBox(vhwndMain, (LPTSTR)(vrgchBuff+256* sizeof(TCHAR)), (LPTSTR)(vrgchBuff+128* sizeof(TCHAR)), MB_OK);
    }

    return (iRet);
}


//
// Reconnects a list of shares
// if you pass in a parent HWND then you will get UI
//
int
ReconnectList(
    LPCONNECTINFO   *lplpHead,
    HWND            hwndParent
    )
/*++

Routine Description:

    reconnects all the connections in disconnected state.


Arguments:


Returns:


Notes:

--*/
{
    int iDone = 0;
    DWORD dwError;
    LPCONNECTINFO lpTmp = *lplpHead;
    _TCHAR * lpSave;
    HWND hwndUI=NULL;

    try
    {
        for (;lpTmp;lpTmp = lpTmp->lpnextCI){
        
            if (!(lpTmp->uStatus & SHARE_DISCONNECTED_OP))
            {
                continue;
            }

            if (((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpLocalName){
                ReintKdPrint(MERGE, ("Adding back %ls on %ls\r\n"
                , ((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpLocalName
                , ((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpRemoteName));

            }
            else{
                ReintKdPrint(MERGE, ((LPSTR)vrgchBuff, "Adding back %ls\r\n" , ((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpRemoteName));
            }

            lpSave = ((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpProvider;
            ((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpProvider = NULL;
            dwError = WNetAddConnection3(vhwndMain, (NETRESOURCE *)&(lpTmp->rgFill[0]), NULL, NULL, CONNECT_INTERACTIVE);
            ((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpProvider = lpSave;
            if (dwError!=NO_ERROR){

                ReintKdPrint(BADERRORS, ("Error=%ld \r\n", dwError));
                iDone = -1;
            }
            else if (iDone >= 0){
                ++iDone;
            }
        }

        if( hwndUI ){

            DestroyWindow(hwndUI);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        ReintKdPrint(BADERRORS, ("Took exception in Reconnect list \n"));
        iDone = 0;
    }
    return (iDone);
}

VOID
ClearConnectionList(
    LPCONNECTINFO *lplpHead
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    LPCONNECTINFO lpTmp = *lplpHead, lpSave;
    for (;lpTmp;){
        lpSave = lpTmp->lpnextCI;
        FreeMem(lpTmp);
        lpTmp = lpSave;
    }
    *lplpHead = NULL;
}

BOOL
PRIVATE
IsSlowLink(
    _TCHAR * lpPath
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    NETRESOURCE sNR;
    NETCONNECTINFOSTRUCT sNCINFO;
    int done = 0;
    BOOL fRet = FALSE;

    memset(&sNCINFO, 0, sizeof(NETCONNECTINFOSTRUCT));
    sNCINFO.cbStructure = sizeof(NETCONNECTINFOSTRUCT);
    memset(&sNR, 0, sizeof(NETRESOURCE));
    sNR.lpRemoteName=lpPath;
    if ((MultinetGetConnectionPerformance(&sNR, &sNCINFO)==WN_SUCCESS)
       && (sNCINFO.dwSpeed < SLOWLINK_SPEED)){
        fRet = TRUE;
    }

    return (fRet);
}


int RefreshConnectionsInternal(
   int  force,
   BOOL verbose
   )
{
    return (RefreshConnectionsEx(force, verbose, NULL, 0));
}


int
BreakConnectionsInternal(
    int  force,
    BOOL verbose
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    LPCONNECTINFO lpHead = NULL;
    if (FGetConnectionList(&lpHead, NULL)){
        DisconnectList(&lpHead, RefreshProc, MAKELONG(verbose,force));
        ClearConnectionList(&lpHead);
        return (1);
    }
    return (0);
}


//
// This refreshes all the connections.
// Force -
// Verbose - causes annoying UI to be displayed
// lpfn -
// dwCookie - parameter for lpfn
//
int RefreshConnectionsEx(
    int  force,
    BOOL verbose,
    LPFNREFRESHEXPROC lpfn,
    DWORD dwCookie)
{
    int cntDriveMapped, iRet = -1;
    LPCONNECTINFO lpHead = NULL;

    if (FGetConnectionList(&lpHead, NULL)){
        cntDriveMapped = DisconnectList(&lpHead, RefreshProc, MAKELONG(verbose,force));
        if (cntDriveMapped < 0){
            goto bailout;
        }
        if (lpfn){
            (*lpfn)(cntDriveMapped, dwCookie);
        }
        if (cntDriveMapped > 0){
            ReconnectList(&lpHead,verbose?vhwndMain:NULL);
        }
        ClearConnectionList(&lpHead);
        iRet = 1;
    }
    else
    {
        iRet = 0;
    }

bailout:

    return iRet;
}


BOOL
FCheckAncestor(
    node *lpnodeList,
    LPCOPYPARAMS lpCP
    )
{
    node *lpItem;
    BOOL fHaveAncestor = FALSE;
    unsigned lenDest;
#ifdef DEBUG
    unsigned lenSrc;
#endif

#ifdef DEBUG
    lenSrc = lstrlen(lpCP->lpRemotePath);
#endif
    for(lpItem = lpnodeList; lpItem; lpItem = lpItem->next)
    {
        // is it on the same share?
        if (!lstrcmpi(lpItem->lpCP->lpSharePath, lpCP->lpSharePath))
        {
            // check upto the length of the ancestor. By definition he is supposed to be smaller
            // than the src
            lenDest = lstrlen(lpItem->lpCP->lpRemotePath);
            Assert(lenDest <= lenSrc);

            // NB, we do memcmp because, the strings will have the same case
            // as they are obtained from the same source, ie, the CSC database.

            // is it a child of any item in the list?
            if (!memcmp(lpItem->lpCP->lpRemotePath, lpCP->lpRemotePath, lenDest * sizeof(_TCHAR)))
            {
                fHaveAncestor = TRUE;
                break;
            }
        }
    }

    return (fHaveAncestor);
}

DWORD
PRIVATE
GetUniqueName(
   _TCHAR * lpName,
   _TCHAR * lpUniqueName
   )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/

{
    int i=0, orglen;
    DWORD dwError;
    _TCHAR buff[10 * sizeof(_TCHAR)];

    lstrcpy(lpUniqueName, lpName);

    orglen = lstrlen(lpName);

    if (orglen >= MAX_PATH-1){
        lpUniqueName[MAX_PATH-5] = 0;
        orglen = MAX_PATH-5;
    }
    for (i=0; i<100; ++i){
        if (GetFileAttributes(lpUniqueName)==0xffffffff){
            dwError = GetLastError();
            if ((dwError==ERROR_FILE_NOT_FOUND)||
                (dwError == ERROR_PATH_NOT_FOUND)){
                break;
            }
        }
        lpUniqueName[orglen] = 0;
        wsprintf(buff, _TEXT("(%2d)"), i);
        lstrcat(lpUniqueName, (LPTSTR)buff);
    }
    if (i < 100){
        dwError = NO_ERROR;
    }
    else{
        dwError = 0xffffffff;
    }
    return(dwError);
}




#ifdef MAYBE_USEFUL

/***************************************************************************
 * reintegrate one server.
 */
//
// Pass in the Share to merge on
// and the parent window.
//
BOOL
PUBLIC
ReintOneShare(
    HSHARE hShare,
    HWND hwndParent
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/

{
    node  *lpnodeInsertList=NULL;                // merge file list.
    PQPARAMS sPQP;
    int state, iFileStatus, iShadowStatus;
    BOOL fConnected=FALSE, fBeginReint=FALSE, fDone = FALSE;
    BOOL fStamped = FALSE, fInsertInList = FALSE;
    SHADOWINFO  sSI;
    LPCOPYPARAMS lpCP = NULL;
    _TCHAR szDrive[3];
    unsigned long ulStatus, uAction;
    DWORD dwError;
    WIN32_FIND_DATA    sFind32Local, sFind32Remote;
    WIN32_FIND_DATA *lpFind32Remote = NULL;    // temporary variable
    HANDLE                hShadowDB;
    BOOL fAmAgent=FALSE;

    if ((hShadowDB = OpenShadowDatabaseIO()) ==INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    fAmAgent = (GetCurrentThreadId() == vdwCopyChunkThreadId);

    lpCP = LpAllocCopyParams();

    if (!lpCP){

        ReintKdPrint(BADERRORS, ("ReintOneShare():Allocation of copyparam buffer failed \r\n"));

        goto bailout;
    }

    // Reint in multiple passes. Do directories first, files next
    for (state=STATE_REINT_BEGIN;state<STATE_REINT_END;++state) {
        if (FAbortOperation())
        {
            goto bailout;
        }
        dwError = NO_ERROR;
        memset(&sPQP, 0, sizeof(PQPARAMS));
        memset(&sSI, 0, sizeof(SHADOWINFO));

        // Start looking through the queue
        if(BeginPQEnum(hShadowDB, &sPQP) == 0) {
            goto bailout;
        }
        // Start looking through the queue
        do {

            if (FAbortOperation())
            {
                goto bailout;
            }

            if(PrevPriShadow(hShadowDB, &sPQP) == 0){
                break;
            }
            // end of this enumeration
            if (!sPQP.hShadow){
                break;
            }

            if ( mShadowOrphan(sPQP.ulStatus)||
                 mShadowSuspect(sPQP.ulStatus))
            {
                continue;
            }

            // keep going if this is a file and we are trying to reintegrate directories
            // or if this entry isn't from the server we are dealing with.
            if ((sPQP.hShare != hShare) ||
                 ((state != STATE_REINT_FILES) && mShadowIsFile(sPQP.ulStatus)) ||
                 ((state == STATE_REINT_FILES) && !mShadowIsFile(sPQP.ulStatus))){
                continue;
            }


            if (mShadowNeedReint(sPQP.ulStatus)){


                if (!fStamped){

                    StampReintLog();
                    fStamped = TRUE;
                }

                if (fAmAgent && FSkipObject(sPQP.hShare, 0, 0)){
                    continue;
                }

                if (!GetShadowInfo(hShadowDB, sPQP.hDir, sPQP.hShadow,
                    &sFind32Local, &ulStatus)){

                    ReintKdPrint(BADERRORS, ("ReintOneShare: GetShadowInfo failed\n"));
                    continue;
                }

                CopyPQInfoToShadowInfo(&sPQP, &sSI);

                sSI.lpFind32 = &sFind32Local;

                if(!GetUNCPath(hShadowDB, sPQP.hShare, sPQP.hDir, sPQP.hShadow, lpCP)){

                    ReintKdPrint(BADERRORS, ("ReintOneShare: GetUNCPath failed\n"));
                    continue;
                }
                if (!fConnected){
                    DWORD dwError2;
                    dwError2 = DWConnectNetEx(lpCP->lpSharePath, szDrive, TRUE);
                    if(dwError2 == WN_SUCCESS || dwError2 == WN_CONNECTED_OTHER_PASSWORD_DEFAULT)
                    {
                        fConnected = TRUE;

                        if (!BeginReint(hShadowDB, hShare)) {
                            goto bailout;
                        }

                        fBeginReint = TRUE;
                    }
                    else{
#ifdef DEBUG
                        EnterSkipQueue(sPQP.hShare, 0, 0, lpCP->lpSharePath);
#else
                        EnterSkipQueue(sPQP.hShare, 0, 0);
#endif //DEBUG
                        // try some other server for reintegration
                        goto bailout;
                    }
                }

                ReintKdPrint(BADERRORS, ("Merging local changes to <%s%s>\n", lpCP->lpSharePath, lpCP->lpRemotePath));

                Assert((sPQP.hShare == hShare) &&    // this is the given server
                        (
                         ((state != STATE_REINT_FILES) && !mShadowIsFile(sPQP.ulStatus)) ||
                         ((state == STATE_REINT_FILES) && mShadowIsFile(sPQP.ulStatus))
                        )
                      );

                fInsertInList = FALSE;

                lpFind32Remote = NULL;

                // if there is an insertion list, then check whether his ancestor
                // didn't fail in reintegration
                if (lpnodeInsertList)
                {
                    // if there is an acestor then we should put this guy in the list
                    fInsertInList = FCheckAncestor(lpnodeInsertList, lpCP);
                }

                // if we are not supposed to put him in the list then try getting
                // his win32 strucuture
                if (!fInsertInList)
                {
                    BOOL fExists;

                    GetRemoteWin32Info(NULL, lpCP, &sFind32Remote, &fExists);

                    // insert in list only if some error happened
                    if (fExists == -1)
                    {
                        fInsertInList = TRUE;
                    }

                    // passing remote find32 only if it succeeded
                    if (fExists == TRUE)
                    {
                        lpFind32Remote = &sFind32Remote;
                    }
                }

                // find out what needs to be done
                // this one central place to infer all the stuff
                InferReplicaReintStatus(
                                        &sSI,    // shadowinfo
                                        &sFind32Local,    // win32 info for the shadow
                                        lpFind32Remote,    // remote win32 info
                                        &iShadowStatus,
                                        &iFileStatus,
                                        &uAction
                                        );

                // insert if it had an ancestor in the list or some merge needed to be done
                fInsertInList = (fInsertInList || (uAction == RAIA_MERGE) || (uAction==RAIA_CONFLICT));

                if (!fInsertInList)
                {
                    ReintKdPrint(BADERRORS, ("Silently doing <%s%s>\n", lpCP->lpSharePath, lpCP->lpRemotePath));
                    fInsertInList = (PerformOneReint(
                                                    hShadowDB,
                                                    szDrive,
                                                    lpCP,
                                                    &sSI,
                                                    &sFind32Local,
                                                    lpFind32Remote,
                                                    iShadowStatus,
                                                    iFileStatus,
                                                    uAction
                                                    ) == FALSE);
                }

                if (fInsertInList)
                {
                    if(!insertList(    &lpnodeInsertList,
                                    lpCP,
                                    &sSI,
                                    &sFind32Local,
                                    lpFind32Remote,
                                    iShadowStatus,
                                    iFileStatus,
                                    uAction
                                    ))
                        {
                            ReintKdPrint(BADERRORS, ("ReintOneShare: insertlist failed in memory allocation \r\n"));
                            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                            fDone = FALSE;
                            goto bailout;
                        }
                        ReintKdPrint(BADERRORS, ("Inserted <%s%s> in list\n", lpCP->lpSharePath, lpCP->lpRemotePath));
                }
            }
        } while (sPQP.uPos); // Priority queue enumeration

        // Close the enumeration
        EndPQEnum(hShadowDB, &sPQP);

    }  // reint pass 1 & 2

    if (fBeginReint){
        // we found something to merge
        if (lpnodeInsertList)
        {
            ReintKdPrint(BADERRORS, ("Found reint list, doing UI \n"));
            fDone = DoFilesListReint(hShadowDB, szDrive, hwndParent, lpnodeInsertList);  // 1 if successful, -1 if error, 0 if cancelled
        }
        else
        {
            // all went well
            fDone = TRUE;
        }
    }

    if (fConnected){

        DWDisconnectDriveMappedNet(szDrive, TRUE); // force a disconnect
        fConnected = FALSE;
    }

    if (fDone==TRUE) {

        SetShareStatus(hShadowDB, hShare, (unsigned long)(~SHARE_REINT), SHADOW_FLAGS_AND);
    }

bailout:

    if (fBeginReint){
        EndReint(hShadowDB, hShare);
        fBeginReint = FALSE;
    }

    CloseShadowDatabaseIO(hShadowDB);

    if(lpnodeInsertList) {
        killList(lpnodeInsertList);
        lpnodeInsertList = NULL; //general paranoia
    }

    FreeCopyParams(lpCP);

    if (fConnected) {
        WNetCancelConnection2(szDrive, 0, FALSE);
    }

    // Remove the tray notification about merging
    if( CheckDirtyShares()==0 ) {

        Tray_Modify(vhwndMain,0,NULL);
    }

    return fDone;
}

/****************************************************************************
 *    Query the registry to see if we should make log copies
 */
VOID GetLogCopyStatus(VOID)
{
   HKEY hKey;
    DWORD dwSize = MAX_NAME_LEN;
    _TCHAR szDoCopy[MAX_NAME_LEN];

    // get the user name.
    if(RegOpenKey(HKEY_LOCAL_MACHINE, vszShadowReg, &hKey) !=  ERROR_SUCCESS) {
        ReintKdPrint(BADERRORS, ("GetLogCopyStatus: RegOpenKey failed\n"));
        return;
    }

    if(RegQueryValueEx(hKey, vszDoLogCopy, NULL, NULL, szDoCopy, &dwSize) != ERROR_SUCCESS) {
        RegCloseKey(hKey);
        ReintKdPrint(BADERRORS, ("GetLogCopyStatus: RegQueryValueEx failed\n"));
        return;
    }

    if(mystrnicmp(szDoCopy, MY_SZ_TRUE, strlen(szDoCopy)))
        vfLogCopying = FALSE;
    else
        vfLogCopying = TRUE;

    RegCloseKey(hKey);
}

/****************************************************************************
 *    Make a connection to the logging server and copy the log over.
 */
VOID CopyLogToShare(VOID)
{
   HKEY hKeyShadow;
    DWORD dwSize = MAX_NAME_LEN, dwRes;
    _TCHAR szComputerName[MAX_NAME_LEN];
    _TCHAR szLogDirPath[MAX_PATH], szLogPath[MAX_PATH];
    WIN32_FIND_DATAA sFind32;
    int iCurrFile=0;
    NETRESOURCE sNR;
    HANDLE hLog;

    // check to see if we should copy the log over.
    if(!vfLogCopying) {
        return;
    }

    // get the user name.
    if(RegOpenKey(HKEY_LOCAL_MACHINE, vszMachineName, &hKeyShadow) !=  ERROR_SUCCESS) {
        ReintKdPrint(BADERRORS, ("RegOpenKey failed\n"));
    }

    if(RegQueryValueEx(hKeyShadow, vszComputerName, NULL, NULL, szComputerName, &dwSize) != ERROR_SUCCESS) {
        RegCloseKey(hKeyShadow);
        ReintKdPrint(BADERRORS, ("RegQueryValueEx failed\n"));
        return;
    }
    RegCloseKey(hKeyShadow);

    lstrcpy(szLogDirPath, vszLogUNCPath);
    lstrcat(szLogDirPath, szComputerName);

    sNR.lpRemoteName = vszLogShare;
    sNR.lpLocalName = NULL;
    sNR.lpProvider = NULL;
    sNR.dwType = RESOURCETYPE_DISK;
    dwRes = WNetAddConnection3(vhwndMain, &sNR, NULL, NULL, CONNECT_TEMPORARY);
    if(dwRes != WN_SUCCESS) {
        ReintKdPrint(BADERRORS, ("CopyLogToShare() AddConn3 failed (%d)\n", dwRes));
        return;
    }

    // check to see if that dir lives on the server.
    if(!GetWin32Info(szLogDirPath, &sFind32)) {
        // if not, create it.
        ReintKdPrint(BADERRORS, ("dir not found\n"));
        if(!CreateDirectory(szLogDirPath, NULL)) {
            ReintKdPrint(BADERRORS, ("Create dir failed, reason = %d\n", GetLastError()));
        }
    }
    wsprintf(szLogPath, "%s\\status.log",szLogDirPath);
    // copy file over.
    ReintKdPrint(BADERRORS, ("we'll use <%s> next\n", szLogPath));
   if((hLog = CreateFile(szLogPath
                                  , GENERIC_READ|GENERIC_WRITE
                                  , FILE_SHARE_READ|FILE_SHARE_WRITE
                                  , NULL
                                  , OPEN_ALWAYS
                                  , 0
                                  , NULL)) != INVALID_HANDLE_VALUE) {
        ReintKdPrint(BADERRORS, ("file created\n"));
        AppendToShareLog(hLog);
        CloseHandle(hLog);
        } else {
        ReintKdPrint(BADERRORS, ("create failed, reason = %d\n", GetLastError()));
    }
    WNetCancelConnection2(vszLogShare, CONNECT_REFCOUNT, FALSE);
}

#define MAX_BUF_SIZE    1024

/****************************************************************************
 *    Copy the final stats from local log to the server version (hLog)
 */
VOID AppendToShareLog(HANDLE hLog)
{
    HANDLE hLocal=0;
    DWORD dwBytesRead, dwBytesWritten, dwPos, x;
    BOOL fDone=FALSE;
    _TCHAR cBuffer[MAX_BUF_SIZE];

   if((hLocal = CreateFile(vszLocalLogPath
                                  , GENERIC_READ
                                  , FILE_SHARE_READ
                                  , NULL
                                  , OPEN_EXISTING
                                  , 0
                                  , NULL)) != INVALID_HANDLE_VALUE) {
        ReintKdPrint(BADERRORS, ("local log file opened (0x%x)\n", hLocal));
        dwPos = SetFilePointer(hLog, 0, NULL, FILE_END);
        if(dwPos == 0xFFFFFFFF) {
            ReintKdPrint(BADERRORS, ("Failed seek on remote file, reason = %d\n", GetLastError()));
            goto cleanup;
        }
        dwPos = SetFilePointer(hLocal, 0, NULL, FILE_END);
        if(dwPos == 0xFFFFFFFF) {
            ReintKdPrint(BADERRORS, ("Failed seek on local file, reason = %d\n", GetLastError()));
            goto cleanup;
        }
        if((dwPos = SetFilePointer(hLocal, -MAX_BUF_SIZE, NULL, FILE_CURRENT)) == 0xFFFFFFFF)
            goto cleanup;

        // move backwards until we find the "!*" that I use as my start token.
        while(!fDone) {
            if(!ReadFile(hLocal, cBuffer, MAX_BUF_SIZE, &dwBytesRead, NULL) || !dwBytesRead) {
                if(!dwBytesRead) {
                    ReintKdPrint(BADERRORS, ("local eof\n"));
                } else {
                    ReintKdPrint(BADERRORS, ("R error: %d\n", GetLastError()));
                }
                goto cleanup;
            }

            for(x=0;x<dwBytesRead;x++) {
                if(cBuffer[x] == '!' && cBuffer[x+1] == '*') {
                    fDone = TRUE;
                    dwPos += x;
                    break;
                }
            }
            if(!fDone)
                if((dwPos = SetFilePointer(hLocal, -2*MAX_BUF_SIZE, NULL, FILE_CURRENT)) == 0xFFFFFFFF) {
                    ReintKdPrint(BADERRORS, ("seeked all the way and failed, error=%d\n",GetLastError()));
                    goto cleanup;
                }
        }
        // we have found the !*.  Seek there and copy until end of file.
        // tHACK.  We should have a final delimiter (ie: *!)
        if((dwPos = SetFilePointer(hLocal, dwPos, NULL, FILE_BEGIN)) == 0xFFFFFFFF)
            goto cleanup;
        for(;;) {
            if(!ReadFile(hLocal, cBuffer, MAX_BUF_SIZE, &dwBytesRead, NULL)) {
                ReintKdPrint(BADERRORS, ("R error: %d\n", GetLastError()));
                break;
            }
            if(dwBytesRead == 0)
                break;
            if(!WriteFile(hLog, cBuffer, dwBytesRead, &dwBytesWritten, NULL)) {
                ReintKdPrint(BADERRORS, ("W error: %d\n", GetLastError()));
                break;
            }
        }
    }
cleanup:
    if(hLocal)
        CloseHandle(hLocal);
    if(!FlushFileBuffers(hLog)) {
        ReintKdPrint(BADERRORS, ("FlushFileBuffers failed, reason = %d\n",GetLastError()));
    }
}

DWORD
PRIVATE
MoveConflictingFile(
   LPCOPYPARAMS     lpCP
   )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    DWORD dwError;
    _TCHAR * lpLeaf;


    lstrcpy(vrgchBuff, vszConflictDir);
    lstrcat(vrgchBuff, vszSlash);
    FormLocalNameFromRemoteName(vrgchBuff+strlen(vrgchBuff), lpCP->lpSharePath);

    dwError = InbCreateDir(vrgchBuff, 0xffffffff);

    if (dwError != NO_ERROR) {
        dwError = ERROR_NO_CONFLICT_DIR;
        goto bailout;
    }

    lpLeaf = GetLeafPtr(lpCP->lpRemotePath);

    lstrcat(vrgchBuff, vszSlash);
    lstrcat(vrgchBuff, lpLeaf);
    GetUniqueName(vrgchBuff, vrgchBuff+512);
    ReintKdPrint(BADERRORS, ("Shadow of %s!%s is saved as %s \r\n"
                  , lpCP->lpSharePath
                  , lpCP->lpRemotePath
                  , vrgchBuff+512));

    if(!MoveFile(lpCP->lpLocalPath, vrgchBuff+512)){
        dwError = GetLastError();
    }
    else{
        wsprintf(vrwBuff, "Shadow of %s!%s is saved as %s \r\n"
                     , lpCP->lpSharePath
                     , lpCP->lpRemotePath
                     , vrgchBuff+512);
        WriteLog(vrwBuff);
        dwError = 0;
    }
bailout:
    return (dwError);
}


VOID
PRIVATE
FormLocalNameFromRemoteName(
    _TCHAR * lpBuff,
    _TCHAR * lpRemoteName
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    int i;
    lstrcpy(lpBuff, lpRemoteName);
    for (i= strlen(lpRemoteName)-1; i>=0 ; --i){
        if (lpBuff[i]=='\\') {
            lpBuff[i] = '_';
        }
    }
}

int
PRIVATE
StampReintLog(
   VOID
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/

{
    SYSTEMTIME sST;

    GetLocalTime(&sST);
    wsprintf(vrgchBuff, vszTimeDateFormat, sST.wHour, sST.wMinute, sST.wSecond, sST.wMonth, sST.wDay, sST.wYear);
    return (WriteLog(vrgchBuff));
}

int PRIVATE LogReintError(
    DWORD          dwError,
    _TCHAR *          lpSharePath,
    _TCHAR *          lpRemotePath
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/

{
    int i;

    for (i=0; i< sizeof(rgErrorTab)/sizeof(ERRMSG); ++i){
        if (dwError == rgErrorTab[i].dwError){
            LoadString(vhinstCur, rgErrorTab[i].uMessageID, vrgchBuff, 128);
            wsprintf(vrgchBuff+128, "%s%s: %s \r\n"
                  , lpSharePath
                  , lpRemotePath
                  , vrgchBuff);
            WriteLog(vrgchBuff+128);
            return (1);
         }
    }
    wsprintf(vrgchBuff, "%s%s: ", lpSharePath, lpRemotePath);
    WriteLog(vrgchBuff);
    if (FormatMessage(  FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL, dwError,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        vrgchBuff, sizeof(vrgchBuff), NULL)){
        WriteLog(vrgchBuff);
    }

    WriteLog(vrgchCRLF);
}

int
PRIVATE
WriteLog(
    _TCHAR * lpStrLog
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    HANDLE hfLog;
    DWORD dwRetLen;

    if((hfLog = CreateFile(vszLogFile
                           , GENERIC_READ|GENERIC_WRITE
                           , FILE_SHARE_READ|FILE_SHARE_WRITE
                           , NULL
                           , OPEN_ALWAYS
                           , 0
                           , NULL)) != INVALID_HANDLE_VALUE){
        SetFilePointer(hfLog, 0, NULL, FILE_END);
        WriteFile(hfLog, lpStrLog, strlen(lpStrLog), &dwRetLen, NULL);
        CloseHandle(hfLog);
        return (1);
    }

    return (0);
}


#endif //MAYBE_USEFUL

BOOL
GetWin32Info(
    _TCHAR * lpFile,
    LPWIN32_FIND_DATA lpFW32
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return GetWin32InfoForNT(lpFile, lpFW32);
}


DWORD
PRIVATE
DoObjectEdit(
    HANDLE              hShadowDB,
    _TCHAR *            lpDrive,
    _TCHAR *            lptzFullPath,
    LPCOPYPARAMS        lpCP,
    LPSHADOWINFO        lpSI,
    LPWIN32_FIND_DATA   lpFind32Local,
    LPWIN32_FIND_DATA   lpFind32Remote,
    int                 iShadowStatus,
    int                 iFileStatus,
    int                 uAction,
    DWORD               dwFileSystemFlags,
    LPCSCPROC           lpfnMergeProgress,
    DWORD_PTR           dwContext
    )
/*++

Routine Description:

    This routine does the actual merge for files

Arguments:

    hShadowDB           Handle to the redir to call issue ioctl calls

    lpDrive             drivemapping to bypass CSC while making changes on the remote

    lptzFullPath        Fully qualified path

    lpCP                Copy parameters, contain share name, path relative to the share and the
                        the name in the local database

    lpSI                info such as pincount and pinflags

    lpFind32Local       win32 info for the local replica

    lpFind32Remote      win32 infor for the origianl, NULL if the original doesn't exist

    iShadowStatus       status of the local copy

    iFileStatus         status of the remote copy

    uAction             action to be performed

    dwFileSystemFlags   filesystem flags to do special things for NTFS

    lpfnMergeProgress   progress callback

    dwContext           callback context


Returns:

    error code as defined in winerror.h

Notes:

--*/

{
    HANDLE hfSrc = INVALID_HANDLE_VALUE, hfDst = INVALID_HANDLE_VALUE;
    HANDLE hDst=0;
    _TCHAR * lpT;
    LONG lOffset=0;
    DWORD dwError=ERROR_REINT_FAILED;
    BOOL fRet, fFileExists, fOverWrite=FALSE, fForceAttribute = FALSE;
    WIN32_FIND_DATA    sFind32Remote;
    DWORD   dwTotal = 0, dwRet;
    _TCHAR szSrcName[MAX_PATH+MAX_SERVER_SHARE_NAME_FOR_CSC+10];
    _TCHAR szDstName[MAX_PATH+MAX_SERVER_SHARE_NAME_FOR_CSC+10];
    _TCHAR *lprwBuff = NULL;
    _TCHAR *lptzLocalPath = NULL;
    _TCHAR *lptzLocalPathCscBmp = NULL;
    LPCSC_BITMAP_U lpbitmap = NULL;
    DWORD fileSize, fileSizeHigh;
    int cscReintRet;

    lprwBuff = LocalAlloc(LPTR, FILL_BUF_SIZE_LAN);

    if (!lprwBuff)
    {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    if (!(lptzLocalPath = GetTempFileForCSC(NULL)))
    {
        ReintKdPrint(BADERRORS, ("DoObjectEdit: failed to get temp file\r\n"));
        goto bailout;
    }

    if (!CopyShadow(hShadowDB, lpSI->hDir, lpSI->hShadow, lptzLocalPath))
    {
        ReintKdPrint(BADERRORS, ("DoObjectEdit: failed to make local copy\r\n"));
        goto bailout;
    }

    // for EFS files, we overwrite the original file, that way the encryption information
    // will not be lost due to us doing a new create followed by a rename and delete

    fOverWrite = ((lpFind32Local->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) != 0);

    if (!fOverWrite && lpFind32Remote)
    {
        fOverWrite = (((lpFind32Remote->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) != 0)||
                      ((lpFind32Remote->dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) != 0));
    }

    // if this is the DFS root, always overwrite. This is to avoind sharing violation problems
    // while merging
    if (!fOverWrite && (dwFileSystemFlags == DFS_ROOT_FILE_SYSTEM_FLAGS))
    {
        fOverWrite = TRUE;                
    }

    ReintKdPrint(MERGE, ("Overwrite=%d\r\n", fOverWrite));

    lOffset=0;

    // Create x:\foo\00010002 kind of temporary filename

    lstrcpy(szDstName, lpDrive);
    lstrcat(szDstName, lpCP->lpRemotePath);

    lpT = GetLeafPtr(szDstName);
    *lpT = 0;   // remove the remote leaf

    lpT = GetLeafPtr(lpCP->lpLocalPath);

    // attach the local leaf
    lstrcat(szDstName, lpT);

    // Let us also create the real name x:\foo\bar
    lstrcpy(szSrcName, lpDrive);
    lstrcat(szSrcName, lpCP->lpRemotePath);

    fFileExists = (lpFind32Remote != NULL);

    if (!fFileExists)
    {
        fOverWrite = FALSE;
        ReintKdPrint(MERGE, ("File doesn't exist, Overwrite=%d\r\n", fOverWrite));
    }

    if (mShadowDeleted(lpSI->uStatus)){

        ReintKdPrint(MERGE, ("Deleting %ls \r\n", szSrcName));

        if (lpFind32Remote)
        {
            if((lpFind32Remote->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                ReintKdPrint(MERGE, ("DoObjectEdit:attribute conflict on %ls \r\n", szSrcName));
                goto bailout;
            }
            if(!DeleteFile(szSrcName))
            {
                ReintKdPrint(BADERRORS, ("DoObjectEdit:delete failed %ls error=%d\r\n", szSrcName, GetLastError()));
                goto bailout;
            }
        }

        // if this operation fails we want to abort
        // directory
        if(!DeleteShadow(hShadowDB, lpSI->hDir, lpSI->hShadow))
        {
            dwError = GetLastError();
            goto error;
        }
        else
        {
            dwError = 0;
            goto bailout;
        }

    }

    if (mShadowDirty(lpSI->uStatus)
        || mShadowLocallyCreated(lpSI->uStatus)){


        hfSrc = CreateFile(  lptzLocalPath,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL);

        if (hfSrc ==  INVALID_HANDLE_VALUE)
        {
            goto bailout;
        }

        if (lpFind32Remote && uAction != RAIA_MERGE) {
            // Load the bitmap only when the remote file exists and
            // that no conflict occurs. (if there's a conflict,
            // uAction == RAIA_MERGE. See PerformOneReint()
            lptzLocalPathCscBmp = (_TCHAR *)LocalAlloc(
                                                LPTR,
                                                (lstrlen(lptzLocalPath) +
                                                CSC_BitmapStreamNameLen() + 1) * sizeof(_TCHAR));
            lstrcpy(lptzLocalPathCscBmp, lptzLocalPath);
            CSC_BitmapAppendStreamName(
                lptzLocalPathCscBmp,
                (lstrlen(lptzLocalPath) + CSC_BitmapStreamNameLen() + 1) * sizeof(_TCHAR));
            ReintKdPrint(MERGE, ("TempFileBmp (WCHAR) %ws\r\n", lptzLocalPathCscBmp));
            switch(CSC_BitmapRead(&lpbitmap, lptzLocalPathCscBmp)) {
                // for return values of CSC_BitmapRead see csc_bmpu.c
                case 0:
                    ReintKdPrint(BADERRORS, ("&lpbitmap is null, cannot happen\n"));
                    lpbitmap = NULL;
                    break;
                case 1:
                    ReintKdPrint(MERGE, ("Read bitmap successful\n"));
                    // Overwrite the updated parts of the original file in the
                    // share
                    fOverWrite = TRUE;
                    CSC_BitmapOutput(lpbitmap); // this is NOTHING in free build
                    break;
                case -2:
                    ReintKdPrint(
                        MERGE,
                        ("No Bitmap file %ws exists\n",
                        lptzLocalPathCscBmp));
                    lpbitmap = NULL;
                    break;
                case -1:
                    ReintKdPrint(
                        MERGE,
                        ("Error in reading Bitmap file %ws\n",
                        lptzLocalPathCscBmp));
                    lpbitmap = NULL;
                    break;
                default:
                    ReintKdPrint(MERGE, ("CSC_BitmapRead return code unknown\n"));
                    lpbitmap = NULL;
                    break;
            }
        }
                           
        // if the destination file has multiple streams
        // we should overwrite it
        if (mShadowDirty(lpSI->uStatus) &&
            (dwFileSystemFlags & FS_PERSISTENT_ACLS)&&  // indication of NTFS
            (fFileExists)&&
            !fOverWrite)
        {
            BOOL    fStreams = FALSE;

            // check if this has multiple streams
            if(!HasMultipleStreams(szSrcName, &fStreams) || fStreams )
            {
                // if the call failed, we go conservative and assume there are multiple streams
                ReintKdPrint(MERGE, ("Have multiple streams, overwriting\n"));
                fOverWrite = TRUE;
            }

        }
        if (!fOverWrite)
        {

            ReintKdPrint(MERGE, ("Creating temp \r\n"));

            if ((dwFileSystemFlags & FS_PERSISTENT_ACLS)&&(fFileExists))
            {
                hfDst = CreateTmpFileWithSourceAcls(
                            szSrcName,
                            szDstName);
            }
            else
            {
                hfDst = CreateFile(szDstName,
                                     GENERIC_WRITE,
                                     0,
                                     NULL,
                                     CREATE_ALWAYS,
                                     0,
                                     NULL);
            }
        }
        else
        {
            ReintKdPrint(MERGE, ("Overwriting existing file\r\n"));
            Assert(lpFind32Remote);
            if (lpFind32Remote->dwFileAttributes & FILE_ATTRIBUTE_READONLY)
            {
                ReintKdPrint(MERGE, ("Clearing Readonly attribute \r\n"));
                if(!SetFileAttributes(szSrcName, (lpFind32Remote->dwFileAttributes & ~FILE_ATTRIBUTE_READONLY))){
                    ReintKdPrint(MERGE, ("Failed to clear Readonly attribute, bailing\r\n"));
                    goto error;
                }
                
                fForceAttribute = TRUE;
            }

            // Want to open existing so can copy only those parts of
            // file that needs to be updated
            ReintKdPrint(MERGE, ("Opening %ws\n", szSrcName));
            hfDst = CreateFile(
                            szSrcName,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            (lpbitmap == NULL) ? TRUNCATE_EXISTING : OPEN_EXISTING,
                            0,
                            NULL);

            if (hfDst == INVALID_HANDLE_VALUE) {
                dwError = GetLastError();
                ReintKdPrint(MERGE, ("open failed %d\n", dwError));
                SetLastError(dwError);
                goto error;
            }

            if (lpbitmap != NULL) {

                // Resize the destination file
                fileSizeHigh = 0;
                fileSize = GetFileSize(hfSrc, &fileSizeHigh);
                if (fileSize == 0xFFFFFFFF && GetLastError() != NO_ERROR) {
                    ReintKdPrint(BADERRORS, ("Error getting source file size\n"));
                    goto error;
                }
                ReintKdPrint(MERGE, ("Source FileSize %u\n", fileSize));
                if (SetFilePointer(
                            hfDst,
                            fileSize,
                            &fileSizeHigh,
                            FILE_BEGIN) == INVALID_SET_FILE_POINTER
                                &&
                            GetLastError() != NO_ERROR
                ) {
                    ReintKdPrint(BADERRORS, ("Error setting destination file pointer\n"));
                    goto error;
                }
                if (!SetEndOfFile(hfDst)) {
                            ReintKdPrint(BADERRORS,
                    ("Error setting EOF info of destination file\n"));
                    goto error;
                }

                ReintKdPrint(MERGE, ("Resized Destination FileSize %u\n",
                GetFileSize(hfDst, NULL)));

                if (fileSizeHigh != 0 && lpbitmap) {
                    // file size cannot be represented by 32 bit (> 4Gb)
                    // do not use CSCBmp
                    CSC_BitmapDelete(&lpbitmap);
                    lpbitmap = NULL;
                }
            }
        }

        if (hfDst ==  INVALID_HANDLE_VALUE)
        {
            goto error;
        }

        // let us append
        if((lOffset = SetFilePointer(hfDst, 0, NULL, FILE_END))==0xffffffff) {
            goto error;
        }

        ReintKdPrint(MERGE, ("Copying back %ls to %ls%ls \r\n"
            , lpCP->lpLocalPath
            , lpCP->lpSharePath
            , lpCP->lpRemotePath
            ));

        do {
            unsigned cbRead;
            if (lpbitmap) {
                // Use CSC_BitmapReint Function
                cscReintRet = CSC_BitmapReint(
                                    lpbitmap,
                                    hfSrc,
                                    hfDst,
                                    lprwBuff,
                                    FILL_BUF_SIZE_LAN,
                                    &cbRead);
                if (cscReintRet == CSC_BITMAPReintCont) {
                    NOTHING;
                } else if (cscReintRet == CSC_BITMAPReintDone) {
                    ReintKdPrint(
                        MERGE,
                        ("Done reint\n"));
                    break;
                } else if (cscReintRet == CSC_BITMAPReintInvalid) {
                    ReintKdPrint(
                        BADERRORS,
                        ("Invalid param in calling CSC_BitmapReint\n"));
                    goto error;
                } else if (cscReintRet == CSC_BITMAPReintError) {
                    ReintKdPrint(
                        BADERRORS,
                        ("Error in transferring data\n"));
                    goto error;
                } else {
                    ReintKdPrint(
                        BADERRORS,
                        ("Unrecognized CSC_BitmapReint return code\n"));
                    goto error;
                }
            } else {
                if (!ReadFile(hfSrc, lprwBuff, FILL_BUF_SIZE_LAN, &cbRead, NULL)) {
                    goto error;
                }
                // ReintKdPrint(BADERRORS, ("Read %d bytes \r\n", cbRead));
                if (!cbRead) {
                    break;
                }
                if(!WriteFile(hfDst, (LPBYTE)lprwBuff, cbRead, &cbRead, NULL)){
                    goto error;
                }
                dwTotal += cbRead;
            }
            
            if (lpfnMergeProgress)
            {
                dwRet = (*lpfnMergeProgress)(
                                    szSrcName,
                                    lpSI->uStatus,
                                    lpSI->ulHintFlags,
                                    lpSI->ulHintPri,
                                    lpFind32Local,
                                    CSCPROC_REASON_MORE_DATA,
                                    cbRead,
                                    0,
                                    dwContext);

                if (dwRet != CSCPROC_RETURN_CONTINUE)
                {
                    SetLastError(ERROR_OPERATION_ABORTED);
                    goto bailout;
                }

            }
            

            if (FAbortOperation())
            {
                SetLastError(ERROR_OPERATION_ABORTED);
                goto error;
            }
        } while(TRUE);

        CloseHandle(hfSrc);
        hfSrc = 0;


        CloseHandle(hfDst);
        hfDst = 0;


        // if we are not overwriting the original file, then we must make sure to cleanup
        if (!fOverWrite)
        {
            // nuke the remote one if it exists
            if (fFileExists){
                if(!SetFileAttributes(szSrcName, FILE_ATTRIBUTE_NORMAL)
                || !DeleteFile(szSrcName)){
                    goto error;
                }
            }

            // Now rename the temp file to the real filename
            if(!MoveFile(szDstName, szSrcName)){
                ReintKdPrint(BADERRORS, ("Error #%ld Renaming %ls to %ls%ls\r\n"
                   , GetLastError()
                   , szSrcName
                   , lpCP->lpSharePath
                   , lpCP->lpRemotePath
                   ));
                goto error;
            }

            ReintKdPrint(MERGE, ("Renamed %ls to %ls%ls\r\n"
                , szDstName
                , lpCP->lpSharePath
                , lpCP->lpRemotePath));
        }
    }

    if (fForceAttribute ||
        mShadowAttribChange((lpSI->uStatus))||
        mShadowTimeChange((lpSI->uStatus))){

        if(!SetFileAttributes(szSrcName, FILE_ATTRIBUTE_NORMAL)) {
            goto error;
        }

        if (mShadowTimeChange((lpSI->uStatus))){

            if((hDst = CreateFile(szSrcName,
                                 GENERIC_WRITE,
                                 FILE_SHARE_READ,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL
                                 ))!=INVALID_HANDLE_VALUE){
                fRet = SetFileTime( hDst, NULL,
                                    NULL, &(lpFind32Local->ftLastWriteTime));
            }
            CloseHandle(hDst);
            hDst = 0;

            if (!fRet) {
                goto error;
            }
        }

        if(!SetFileAttributes(szSrcName, lpFind32Local->dwFileAttributes)){
            goto error;
        }
    }

    // Get the latest timestamps/attributes/LFN/SFN on the file we just copied back
    if (!GetWin32Info(szSrcName, &sFind32Remote)) {
        goto error;
    }

    lpSI->uStatus &= (unsigned long)(~(SHADOW_MODFLAGS));

    if (!SetShadowInfo(hShadowDB, lpSI->hDir, lpSI->hShadow, &sFind32Remote, ~(SHADOW_MODFLAGS), SHADOW_FLAGS_AND|SHADOW_FLAGS_CHANGE_83NAME))
    {
        goto error;
    }
    else
    {
        dwError = NO_ERROR;
        goto bailout;
    }

error:
    dwError = GetLastError();
    ReportLastError();

#if 0
    LogReintError(  dwError,
                    lpCP->lpSharePath,
                    lpCP->lpRemotePath);
#endif

bailout:

    if (hfSrc != INVALID_HANDLE_VALUE)
        CloseHandle(hfSrc);

    if (hfDst != INVALID_HANDLE_VALUE) {

        CloseHandle(hfDst);

        // if we failed,
        if (dwError != ERROR_SUCCESS)
            DeleteFile(szDstName);
    }

    if (lptzLocalPath) {
        DeleteFile(lptzLocalPath);
        LocalFree(lptzLocalPath);
    }

    if (lprwBuff)
        LocalFree(lprwBuff);

    if (lptzLocalPathCscBmp)
      LocalFree(lptzLocalPathCscBmp);

    if (lpbitmap)
      CSC_BitmapDelete(&lpbitmap);

    ReintKdPrint(MERGE, ("DoObjectEdit returning %d\n", dwError));
    return (dwError);
}

DWORD
PRIVATE
DoCreateDir(
    HANDLE              hShadowDB,
    _TCHAR *            lpDrive,
    _TCHAR *            lptzFullPath,
    LPCOPYPARAMS        lpCP,
    LPSHADOWINFO        lpSI,
    LPWIN32_FIND_DATA   lpFind32Local,
    LPWIN32_FIND_DATA   lpFind32Remote,
    int                 iShadowStatus,
    int                 iFileStatus,
    int                 uAction,
    DWORD               dwFileSystemFlags,
    LPCSCPROC           lpfnMergeProgress,
    DWORD_PTR           dwContext
    )
/*++

Routine Description:

    This routine does the actual merge for directories

Arguments:

    hShadowDB           Handle to the redir to call issue ioctl calls

    lpDrive             drivemapping to bypass CSC while making changes on the remote

    lptzFullPath        Fully qualified path

    lpCP                Copy parameters, contain share name, path relative to the share and the
                        the name in the local database

    lpSI                info such as pincount and pinflags

    lpFind32Local       win32 info for the local replica

    lpFind32Remote      win32 infor for the origianl, NULL if the original doesn't exist

    iShadowStatus       status of the local copy

    iFileStatus         status of the remote copy

    uAction             action to be performed

    dwFileSystemFlags   filesystem flags to do special things for NTFS

    lpfnMergeProgress   progress callback

    dwContext           callback context


Returns:

    error code as defined in winerror.h

Notes:


--*/
{
    DWORD dwError=ERROR_FILE_NOT_FOUND;
    WIN32_FIND_DATA sFind32Remote;
    BOOL fCreateDir = FALSE;
    _TCHAR szSrcName[MAX_PATH+MAX_SERVER_SHARE_NAME_FOR_CSC+10];
    _TCHAR *lprwBuff = NULL;

    lprwBuff = LocalAlloc(LPTR, FILL_BUF_SIZE_LAN);

    if (!lprwBuff)
    {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    // Let us create the real name x:\foo\bar
    lstrcpy(szSrcName, lpDrive);
    lstrcat(szSrcName, lpCP->lpRemotePath);

    if(lpFind32Remote &&
        !(lpFind32Remote->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)){

        if (lpSI->uStatus & SHADOW_REUSED){

            // we now know that a file by this name has been deleted
            // and a directory has been created in it's place
            // we try to delete the file before createing the directory
            // NB, the other way is not possible because we don't allow directory deletes
            // in disconnected mode
            dwError = (!DeleteFile(szSrcName)) ? GetLastError(): NO_ERROR;

            if ((dwError==NO_ERROR)||
                (dwError==ERROR_FILE_NOT_FOUND)||
                (dwError==ERROR_PATH_NOT_FOUND)){
                lstrcpy(lprwBuff, szSrcName);
                dwError = NO_ERROR;
            }
        }

        if (dwError != NO_ERROR){
#if 0
            LogReintError(ERROR_ATTRIBUTE_CONFLICT, lpCP->lpSharePath, lpCP->lpRemotePath);
#endif
            dwError = GetUniqueName(szSrcName, lprwBuff);
        }

        if (dwError == NO_ERROR){
            if ((dwError = InbCreateDir(    lprwBuff,
                                             (mShadowAttribChange(lpSI->uStatus)
                                             ? lpFind32Local->dwFileAttributes
                                             : 0xffffffff)
                                            ))==NO_ERROR)
            {
                if(!GetWin32Info(lprwBuff, &sFind32Remote)){
                    dwError = GetLastError();
                }
                else{
#if 0
                    lpLeaf1 = GetLeafPtr(szSrcName);
                    lpLeaf2 = GetLeafPtr(lprwBuff);
                    wsprintf(lprwBuff+512
                     , "Directory Name changed from %s to %s on %s\r\n"
                     , lpLeaf1, lpLeaf2, lpCP->lpSharePath);
                    WriteLog(lprwBuff+512);
#endif
                }
            }
        }
    }
    else{
        if ((dwError = InbCreateDir(szSrcName,
                                             (mShadowAttribChange(lpSI->uStatus)
                                             ? lpFind32Local->dwFileAttributes
                                             : 0xffffffff)
                                            ))==NO_ERROR){
            if (!GetWin32Info(szSrcName, &sFind32Remote)){
                dwError = GetLastError();
            }
         }
    }

    if (dwError == NO_ERROR){

        if(!SetShadowInfo(hShadowDB, lpSI->hDir, lpSI->hShadow, &sFind32Remote, (unsigned)(~SHADOW_MODFLAGS), SHADOW_FLAGS_AND))
        {
            dwError = GetLastError();
        }
        else
        {
            ReintKdPrint(MERGE, ("Created directory %s%s", lpCP->lpSharePath, lpCP->lpRemotePath));
        }
    }
    else{
#if 0
        wsprintf(lprwBuff, "Error merging %s%s\r\n"
                    , lpCP->lpSharePath
                    , lpCP->lpRemotePath);
        WriteLog(lprwBuff);
#endif
    }

    if (lprwBuff)
    {
        LocalFree(lprwBuff);

    }
    return (dwError);
}

VOID
CleanupReintState(
    VOID
    )
{
    if (vsRei.hShare)
    {

        ReintKdPrint(MERGE, ("CSCDLL.CleanupReintState: ending reint on hShare=%x\r\n", vsRei.hShare));
//        EndReint(INVALID_HANDLE_VALUE, vsRei.hShare);

        if (vsRei.tzDrive[0])
        {
            ReintKdPrint(MERGE, ("CSCDLL.CleanupReintState: unmapping merge drive\r\n"));
            DWDisconnectDriveMappedNet(vsRei.tzDrive, TRUE);
            vsRei.tzDrive[0] = 0;
        }

        vsRei.hShare = 0;

    }
}

HANDLE
CreateTmpFileWithSourceAcls(
    _TCHAR  *lptzSrc,
    _TCHAR  *lptzDst
    )
/*++

Routine Description:

    This routine is used by DoObjectEdit while pushing back a file during merge.
    It's job is to get the descritionary ACLs from the source file and use
    them to create a temp file to which we are going to copy the data before renaming it to
    the source

Arguments:


Returns:

    file handle is successful, INVALID_HANDLE_VALUE if failed. In case of failure,
    GetLastError() tells the specific error code.


Notes:

--*/
{
    char buff[1];
    BOOL fRet = FALSE;
    SECURITY_ATTRIBUTES sSA;
    DWORD   dwSize = 0;
    HANDLE  hDst = INVALID_HANDLE_VALUE;

    memset(&sSA, 0, sizeof(sSA));

    sSA.lpSecurityDescriptor = buff;
    dwSize = 0;

    if(!GetFileSecurity(
        lptzSrc,
        DACL_SECURITY_INFORMATION,
        sSA.lpSecurityDescriptor,
        0,
        &dwSize))
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            sSA.lpSecurityDescriptor = LocalAlloc(LPTR, dwSize);

            if (sSA.lpSecurityDescriptor)
            {
                if(GetFileSecurity(
                    lptzSrc,
                    DACL_SECURITY_INFORMATION,
                    sSA.lpSecurityDescriptor,
                    dwSize,
                    &sSA.nLength))
                {
                    sSA.nLength = sizeof(sSA);
                    fRet = TRUE;
                }
                else
                {
                    dwSize = GetLastError();
                    LocalFree(sSA.lpSecurityDescriptor);
                    SetLastError(dwSize);
                }
            }
        }
    }
    else
    {
        fRet = TRUE;
    }

    if (fRet)
    {
        hDst = CreateFile(lptzDst,
                                 GENERIC_WRITE,
                                 0,
                                 &sSA,
                                 CREATE_ALWAYS,
                                 0,
                                 NULL);

        if (hDst == INVALID_HANDLE_VALUE)
        {
            dwSize = GetLastError();
        }

        if (sSA.lpSecurityDescriptor)
        {
            LocalFree(sSA.lpSecurityDescriptor);
        }
        if (hDst == INVALID_HANDLE_VALUE)
        {
            SetLastError(dwSize);
        }

    }

    return hDst;
}

BOOL
HasMultipleStreams(
    _TCHAR  *lpExistingFileName,
    BOOL    *lpfTrueFalse
    )
/*++

Routine Description:

    This routine is used by DoObjectEdit while pushing back a file during merge.
    It looks to see whether the destination file has multiple streams.

Arguments:

    lpExistingFileName  Name of an existing file
    lpfTrueFalse        output parameter, returns TRUE is the call succeedes and there are multiple streams

Returns:

    returns TRUE if successful

Notes:

--*/
{
    HANDLE SourceFile = INVALID_HANDLE_VALUE;
    PFILE_STREAM_INFORMATION StreamInfoBase = NULL;
    ULONG StreamInfoSize;
    IO_STATUS_BLOCK IoStatus;
    BOOL    fRet = FALSE;
    DWORD   Status;

    *lpfTrueFalse = FALSE;

    SourceFile = CreateFile(
                    lpExistingFileName,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );
    if (SourceFile == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }
    //
    //  Obtain the full set of streams we have to copy.  Since the Io subsystem does
    //  not provide us a way to find out how much space this information will take,
    //  we must iterate the call, doubling the buffer size upon each failure.
    //
    //  If the underlying file system does not support stream enumeration, we end up
    //  with a NULL buffer.  This is acceptable since we have at least a default
    //  data stream,
    //

    StreamInfoSize = 4096;
    do {
        StreamInfoBase = LocalAlloc(LPTR, StreamInfoSize );

        if ( !StreamInfoBase ) {
            SetLastError( STATUS_NO_MEMORY );
            goto bailout;
        }

        Status = NtQueryInformationFile(
                    SourceFile,
                    &IoStatus,
                    (PVOID) StreamInfoBase,
                    StreamInfoSize,
                    FileStreamInformation
                    );

        if (Status != STATUS_SUCCESS) {
            //
            //  We failed the call.  Free up the previous buffer and set up
            //  for another pass with a buffer twice as large
            //

            LocalFree(StreamInfoBase);
            StreamInfoBase = NULL;
            StreamInfoSize *= 2;
        }

    } while ( Status == STATUS_BUFFER_OVERFLOW || Status == STATUS_BUFFER_TOO_SMALL );

    if (Status == STATUS_SUCCESS)
    {
        fRet = TRUE;

        if (StreamInfoBase)
        {
            if (StreamInfoBase->NextEntryOffset)
            {
                *lpfTrueFalse = TRUE;
            }
        }
    }

bailout:

    if (SourceFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(SourceFile);
    }

    if (StreamInfoBase)
    {
        LocalFree(StreamInfoBase);
    }

    return fRet;
}

#ifdef DEBUG

BOOL
CompareFilePrefixes(
    _TCHAR  *lptzRemotePath,
    _TCHAR  *lptzLocalPath,
    SHADOWINFO      *lpSI,
    WIN32_FIND_DATA *lpFind32,
    LPCSCPROC   lpfnMergeProgress,
    DWORD_PTR   dwContext
    )
{

    HANDLE hfSrc = INVALID_HANDLE_VALUE, hfDst = INVALID_HANDLE_VALUE;
    LPVOID  lpvSrc = NULL, lpvDst = NULL;
    unsigned cbSrcTotal = 0, cbDstTotal = 0;
    DWORD   dwError = NO_ERROR, dwRemoteSize;

    if (lpfnMergeProgress)
    {
        (*lpfnMergeProgress)(lptzRemotePath, lpSI->uStatus, lpSI->ulHintFlags, lpSI->ulHintPri, lpFind32, CSCPROC_REASON_BEGIN, 0, 0, dwContext);
    }

    ReintKdPrint(ALWAYS, ("Comparing %ls with %ls \r\n", lptzLocalPath, lptzRemotePath));

    lpvSrc = LocalAlloc(LPTR, FILL_BUF_SIZE_LAN);

    if (!lpvSrc)
    {
        ReintKdPrint(BADERRORS, ("CompareFilesPrefix: Memory Allocation Error\r\n"));
        goto bailout;
    }

    lpvDst = LocalAlloc(LPTR, FILL_BUF_SIZE_LAN);

    if (!lpvDst)
    {
        ReintKdPrint(BADERRORS, ("CompareFilesPrefix: Memory Allocation Error\r\n"));
        goto bailout;
    }

    hfSrc = CreateFile(lptzLocalPath,
                                 GENERIC_READ,
                                 FILE_SHARE_READ,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL);

    if (hfSrc ==  INVALID_HANDLE_VALUE)
    {
        ReintKdPrint(BADERRORS, ("Failed to open database file for Inode=%x\r\n", lpSI->hShadow));
        goto bailout;
    }

    hfDst = CreateFile(lptzRemotePath,
                                 GENERIC_READ,
                                 FILE_SHARE_READ,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL);

    if (hfDst ==  INVALID_HANDLE_VALUE)
    {
        ReintKdPrint(BADERRORS, ("Failed to open remote file for Inode=%x\r\n", lpSI->hShadow));
        goto error;
    }

    dwRemoteSize = GetFileSize(hfDst, NULL);

    if (dwRemoteSize == 0xffffffff)
    {
        ReintKdPrint(BADERRORS, ("Failed to get size for remote file for Inode=%x\r\n", lpSI->hShadow));
        goto error;
    }

    if (dwRemoteSize != lpFind32->nFileSizeLow)
    {
        ReintKdPrint(BADERRORS, ("mismatched local and remote sizes for Inode=%x\r\n", lpSI->hShadow));
        SetLastError(ERROR_INVALID_DATA);
        goto error;
    }

    do{
        unsigned cbReadSrc, cbReadDst;

        if (!ReadFile(hfSrc, lpvSrc, FILL_BUF_SIZE_LAN, &cbReadSrc, NULL)){
            goto error;
        }

        if (!cbReadSrc) {
           break;
        }

        cbSrcTotal += cbReadSrc;

        if(!ReadFile(hfDst, (LPBYTE)lpvDst, cbReadSrc, &cbReadDst, NULL)){
            goto error;
        }

        cbDstTotal += cbReadDst;

        if (cbReadSrc > cbReadDst)
        {
            ReintKdPrint(ALWAYS, ("CompareFilesPrefix: RemoteFile sized is smaller than Local Size\r\n"));
            SetLastError(ERROR_INVALID_DATA);
            goto error;
        }

        if (memcmp(lpvSrc, lpvDst, cbReadSrc))
        {
            ReintKdPrint(ALWAYS, ("mismatched!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n"));
            SetLastError(ERROR_INVALID_DATA);
            goto error;
        }

    } while(TRUE);

    goto bailout;

error:
    dwError = GetLastError();
    ReintKdPrint(BADERRORS, ("Error=%d\r\n", dwError));

bailout:
    if (hfSrc != INVALID_HANDLE_VALUE) {
        CloseHandle(hfSrc);
    }

    if (hfDst != INVALID_HANDLE_VALUE) {

        CloseHandle(hfDst);
    }

    if (lpvSrc)
    {
        FreeMem(lpvSrc);
    }

    if (lpvDst)
    {
        FreeMem(lpvDst);
    }

    if (lpfnMergeProgress)
    {
        (*lpfnMergeProgress)(lptzRemotePath, lpSI->uStatus, lpSI->ulHintFlags, lpSI->ulHintPri, lpFind32, CSCPROC_REASON_END, cbDstTotal, dwError, dwContext);
    }

    return TRUE;
}

int
CheckCSCDirCallback(
    HANDLE          hShadowDB,
    LPSECURITYINFO  pShareSecurityInfo,
    LPTSTR          lptzFullPath,
    DWORD           dwCallbackReason,
    WIN32_FIND_DATA *lpFind32,
    SHADOWINFO      *lpSI,
    LPREINT_INFO     lpRei
    )
{
    int retCode = TOD_CONTINUE;
    LPCOPYPARAMS lpCP = NULL;
    BOOL   fInsertInList = FALSE, fIsFile;
    _TCHAR *lptzLocalPath = NULL;
    _TCHAR szRemoteName[MAX_PATH+MAX_SERVER_SHARE_NAME_FOR_CSC+10];

    if (dwCallbackReason != TOD_CALLBACK_REASON_NEXT_ITEM)
    {
        return retCode;
    }
    fIsFile = ((lpFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0);

    if (!fIsFile)
    {
        return retCode;
    }

    lpCP = LpAllocCopyParams();

    if (!lpCP){
        ReintKdPrint(BADERRORS, ("CheckCSCDirCallback: Allocation of copyparam buffer failed\n"));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        retCode = TOD_ABORT;
        goto bailout;
    }

    if(!GetUNCPath(hShadowDB, lpSI->hShare, lpSI->hDir, lpSI->hShadow, lpCP)){

        ReintKdPrint(BADERRORS, ("CheckCSCDirCallback: GetUNCPath failed\n"));
        Assert(FALSE);
        retCode =  TOD_CONTINUE;
        goto bailout;
    }

    Assert(lpRei);

    if (!(lptzLocalPath = GetTempFileForCSC(NULL)))
    {
        ReintKdPrint(BADERRORS, ("CheckCSCDirCallback: failed to get temp file\r\n"));
        goto bailout;
    }

    if (!CopyShadow(hShadowDB, lpSI->hDir, lpSI->hShadow, lptzLocalPath))
    {
        ReintKdPrint(BADERRORS, ("CheckCSCDirCallback: failed to make local copy\r\n"));
        goto bailout;
    }

    // Let us create the real name x:\foo\bar
    lstrcpy(szRemoteName, lpRei->tzDrive);
    lstrcat(szRemoteName, lpCP->lpRemotePath);
    CompareFilePrefixes(
        szRemoteName,
        lptzLocalPath,
        lpSI,
        lpFind32,
        lpRei->lpfnMergeProgress,
        lpRei->dwContext
        );


bailout:
    if (lptzLocalPath)
    {
        DeleteFile(lptzLocalPath);
        LocalFree(lptzLocalPath);
    }
    if (lpCP) {
        FreeCopyParams(lpCP);
    }

    return retCode;
}

BOOL
PUBLIC
CheckCSCShare(
    _TCHAR      *lptzShare,
    LPCSCPROC   lpfnMergeProgress,
    DWORD       dwContext
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/

{
    BOOL fConnected=FALSE, fDone = FALSE;
    BOOL fStamped = FALSE, fInsertInList = FALSE, fBeginReint = FALSE, fDisabledShadowing = FALSE;
    HANDLE      hShadowDB;
    SHADOWINFO  sSI;
    int iRet;
    DWORD   dwError=NO_ERROR;
    TCHAR   tzFullPath[MAX_PATH+1];
    WIN32_FIND_DATA sFind32;
    REINT_INFO  sRei;

    if (!LpBreakPath(lptzShare, TRUE, &fDone) && !fDone)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    fDone = FALSE;

    memset(&sRei, 0, sizeof(sRei));
    sRei.lpfnMergeProgress = lpfnMergeProgress;
    sRei.dwContext = dwContext;
    memset(sRei.tzDrive, 0, sizeof(sRei.tzDrive));

    if ((hShadowDB = OpenShadowDatabaseIO()) ==INVALID_HANDLE_VALUE)
    {
        ReintKdPrint(BADERRORS, ("CheckShare: failed to open database\r\n"));
        goto bailout;
    }

    memset(&sFind32, 0, sizeof(sFind32));
    lstrcpy(sFind32.cFileName, lptzShare);

    if(!GetShadowEx(hShadowDB, 0, &sFind32, &sSI)||(!sSI.hShadow))
    {
        ReintKdPrint(BADERRORS, ("CheckShare: failed to get the share info\r\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        goto bailout;
    }

    lstrcpy(tzFullPath, lptzShare);

    dwError = DWConnectNet(lptzShare, sRei.tzDrive, NULL, NULL, NULL, 0, NULL);
    if ((dwError != WN_SUCCESS) && (dwError != WN_CONNECTED_OTHER_PASSWORD_DEFAULT))
    {
        ReintKdPrint(BADERRORS, ("CheckCSCOneShare: Error %d, couldn't connect to %s\r\n", dwError, lptzShare));
        SetLastError(dwError);
        goto bailout;

    }

    ReintKdPrint(MERGE, ("CSC.CheckShare: mapped drive letter %ls \r\n", sRei.tzDrive));

    if (lpfnMergeProgress)
    {
        (*lpfnMergeProgress)(lptzShare, 0, 0, 0, NULL, CSCPROC_REASON_BEGIN, 0, 0, dwContext);
    }

    fConnected = TRUE;

    iRet = TraverseOneDirectory(hShadowDB, NULL, 0, sSI.hShadow, tzFullPath, CheckCSCDirCallback, &sRei);

    if (lpfnMergeProgress)
    {
        (*lpfnMergeProgress)(lptzShare, 0, 0, 0, NULL, CSCPROC_REASON_END, 0, 0, dwContext);
    }

    fDone = TRUE;

bailout:

    CloseShadowDatabaseIO(hShadowDB);

    if (fConnected) {

        if(DWDisconnectDriveMappedNet(sRei.tzDrive, TRUE))
        {
            ReintKdPrint(BADERRORS, ("Failed disconnection of merge drive \r\n"));
        }
        else
        {
            ReintKdPrint(MERGE, ("Disconnected merge drive \r\n"));
        }
    }

    return (fDone);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\ntstuff.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ntstuff.c

Abstract:

    entry point and functions exported by cscdll.dll which are specific for nt

    Contents:

Author:

    Shishir Pardikar


Environment:

    Win32 (user-mode) DLL

Revision History:

    11-5-97  created

--*/

#include "pch.h"


#ifdef CSC_ON_NT

#include <winioctl.h>
#include <winwlx.h>
#endif

#include "shdcom.h"
#include "shdsys.h"
#include "reint.h"
#include "utils.h"
#include "resource.h"
#include "strings.h"
// this sets flags in a couple of headers to not include some defs.
#define REINT
#include "lib3.h"

#ifdef CSC_ON_NT

#include "ntioapi.h"
#include "npapi.h"
#include "ntddnfs.h"
#include "dfsfsctl.h"
#define MAX_LOGONS  64

#define FLAG_AGENT_SEC_LOCAL_SYSTEM 0x00000001

typedef struct tagAGENT_SEC AGENT_SEC, *LPAGENT_SEC;

typedef struct tagAGENT_SEC {
    LPAGENT_SEC             lpASNext;    // next in the list !ACHTUNG, this must be the first element
    DWORD                   dwFlags;
    HANDLE                  hDupToken;         // thread token
    ULONG                   ulPrincipalID;      // ID of this principal in the CSC database
    LUID                    luidAuthId;     // auth ID to disambiguate between tokens with the same SID
    TOKEN_USER              sTokenUser;
}
AGENT_SEC, *LPAGENT_SEC;

//
// Globals/Locals
//
#define REG_VALUE_DISABLE_AGENT L"DisableAgent"
#define REG_VALUE_INACTIVE_AGENT L"InactiveAgent"
#define NT_PREFIX_FOR_UNC   L"\\??\\UNC"

#define SHUTDOWN_SLEEP_INTERVAL_MS  (1000)
#define SHUTDOWN_WAIT_INTERVAL_MS   (60*1000)

BOOL    fAgentThreadRunning = FALSE;    // agent is running

LPAGENT_SEC vlpASHead = NULL;     // head of the security info list for all logged on users

DWORD   rgdwCSCSecIndx[MAX_LOGONS];
DWORD   dwLogonCount = 0;

HDESK   hdesktopUser = NULL;    // set at every logon logon, reset at every logon
HDESK   hdesktopCur = NULL;     // set while reporting events, reset at logoff

_TCHAR  vszNTLANMAN[] = _TEXT("ntlanman.dll");

static UNICODE_STRING DfsDriverObjectName =
{
    sizeof(DFS_DRIVER_NAME) - sizeof(UNICODE_NULL),
    sizeof(DFS_DRIVER_NAME) - sizeof(UNICODE_NULL),
    DFS_DRIVER_NAME
};


AssertData;
AssertError;


//
// prototypes
//

BOOL
OkToLaunchAgent(
    VOID
);


BOOL
AttachAuthInfoForThread(
    HANDLE  hTokenInput
    );

BOOL
ReleaseAuthInfoForThread(
    HANDLE  hTokenInput
    );


BOOL
ImpersonateALoggedOnUser(
    VOID
    );


#ifdef __cplusplus
extern "C" {
#endif

DWORD APIENTRY
NPAddConnection3ForCSCAgent(
    HWND            hwndOwner,
    LPNETRESOURCE   lpNetResource,
    LPTSTR          pszPassword,
    LPTSTR          pszUserName,
    DWORD           dwFlags,
    BOOL            *lpfIsDfsConnect
    );

DWORD APIENTRY
NPCancelConnectionForCSCAgent (
    LPCTSTR         szName,
    BOOL            fForce );

DWORD APIENTRY
NPGetConnectionPerformance(
    LPCWSTR         lpRemoteName,
    LPNETCONNECTINFOSTRUCT lpNetConnectInfo
    );
#ifdef __cplusplus
}
#endif


DWORD
WINAPI
MprServiceProc(
    IN LPVOID lpvParam
    );
//
// functions
//

DWORD WINAPI
WinlogonStartupEvent(
    LPVOID lpParam
    )
/*++

Routine Description:

    The routine is called by winlogon when a user logs on to the system.

Arguments:

    none

Returns:

    ERROR_SUCCESS if all went well, otherwise the appropriate error code.

Notes:

    Because of the way registry is setup for cscdll.dll, winlogon will call this routine
    (and all the winlogonXXXEvent routines) on a seperate thread. We get the auth info for
    for the localsystem if necessary and attach it in our list of currently logged on users.

    NB. This solution works only for interactive logons. This is good enough for V1 of the
    product. All the "known" services that log on non-interactively do so as local-system. We
    are already keeping the auth-info for local-system. Hence this should cover all the
    pricipals running on a system.


    Once the agent runs, it runs forever till the system shuts down.

--*/
{
    BOOL bResult;

    bResult = ProcessIdToSessionId(
                GetCurrentProcessId(),
                &vdwAgentSessionId);

    ReintKdPrint(SECURITY, ("WinlogonStartupEvent\n"));

    if (!fAgentThreadRunning)
    {
        // agent is not yet running
        if (OkToLaunchAgent())
        {
            // registry doesn't disallow from launching the agent

            // let us be the localsystem.

            // let us also get the winlogon (localsystem) token
            if(AttachAuthInfoForThread(NULL))
            {
                // launch the agent
                fAgentThreadRunning = TRUE;

                // we will essentially get stuck here for ever
                MprServiceProc(NULL);

                fAgentThreadRunning = FALSE;
            }
            else
            {
                ReintKdPrint(BADERRORS, ("Couldn't get authinfo for self, error=%d\r\n", GetLastError()));
            }

        }
        else
        {
            ReintKdPrint(BADERRORS, ("Disbaling agent launch\r\n"));
        }
    }

    return ERROR_SUCCESS;
}

DWORD WINAPI
WinlogonLogonEvent(
    LPVOID lpParam
    )
/*++

Routine Description:

    The routine is called by winlogon when a user logs on to the system.

Arguments:

    none

Returns:

    ERROR_SUCCESS if all went well, otherwise the appropriate error code.

Notes:

    Because of the way registry is setup for cscdll.dll, winlogon will call this routine
    (and all the winlogonXXXEvent routines) on a seperate thread, impersonated as the
    currently logged on user. We get the auth info this guy and also for the localsystem, if
    necessary and attach it in our list of currently logged on users.

    NB. This solution works only for interactive logons. This is good enough for V1 of the
    product. All the "known" services that log on non-interactively do so as local-system. We
    are already keeping the auth-info for local-system. Hence this should cover all the
    pricipals running on a system.


    Once the agent runs, it runs forever till the system shuts down.

--*/
{
    DWORD dwError = ERROR_SUCCESS;
    PWLX_NOTIFICATION_INFO pWlx = (PWLX_NOTIFICATION_INFO)lpParam;

    ReintKdPrint(SECURITY, ("WinlogonLogonEvent\n"));
    Assert(pWlx->hToken);

    // NTRAID-455262-1/31/2000-shishirp this desktop scheme breaks for HYDRA
    EnterAgentCrit();

    if (!hdesktopUser)
    {
        if(!DuplicateHandle( GetCurrentProcess(),
                                    pWlx->hDesktop,
                                    GetCurrentProcess(),
                                    &hdesktopUser,
                                    0,
                                    FALSE,
                                    DUPLICATE_SAME_ACCESS
                                    ))
        {
            ReintKdPrint(ALWAYS, ("Failed to dup dekstop handle Error = %d \n", GetLastError()));
        }
        else
        {
            ReintKdPrint(INIT, ("dekstop handle = %x \n", hdesktopUser));
        }
    }
    
    LeaveAgentCrit();

    UpdateExclusionList();
    UpdateBandwidthConservationList();
    InitCSCUI(pWlx->hToken);

// attached to the list of logged on users
    if(AttachAuthInfoForThread(pWlx->hToken))
    {
        if (fAgentThreadRunning)
        {
        }
    }
    else
    {
        dwError = GetLastError();
        ReintKdPrint(BADERRORS, ("Failed to get Authentication Info for the thread Error %d, disbaling agent launch\r\n", dwError));
    }

    return ERROR_SUCCESS;
}



DWORD WINAPI
WinlogonLogoffEvent(
    LPVOID lpParam
    )
/*++

Routine Description:

    The routine is called by winlogon when a user logs off the system.

Arguments:


Returns:

    ERROR_SUCCESS if all went well, otherwise the appropriate error code.

Notes:

--*/
{
    PWLX_NOTIFICATION_INFO pWlx = (PWLX_NOTIFICATION_INFO)lpParam;
    BOOL    fLastLogoff = FALSE;

    ReintKdPrint(SECURITY, ("WinlogonLogoffEvent\n"));

    Assert(pWlx->hToken);
    ReleaseAuthInfoForThread(pWlx->hToken);

    // only when there is no-one in the queue or the only guy remaining is the system,
    // we declare that we are getting logged off.

    EnterAgentCrit();
    fLastLogoff = ((vlpASHead == NULL)||(vlpASHead->lpASNext == NULL));
    LeaveAgentCrit();

    if (fLastLogoff)
    {
        TerminateCSCUI();
        if (hdesktopUser)
        {
            CloseDesktop(hdesktopUser);
            hdesktopUser = NULL;
        }
    }

#if 0
    if (fAgentThreadRunning)
    {
        Assert(vhwndMain);

        PostMessage(vhwndMain, WM_QUIT, 0, 0);
    }
#endif
    ReintKdPrint(SECURITY, ("User logging off \r\n"));
    return ERROR_SUCCESS;
}



DWORD WINAPI
WinlogonScreenSaverEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    ReintKdPrint(SECURITY, ("WinlogonScreenSaverEvent\n"));
    return ERROR_CALL_NOT_IMPLEMENTED;
}



DWORD WINAPI
WinlogonShutdownEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    DWORD   dwStart, dwCur;

    ReintKdPrint(SECURITY, ("WinlogonShutdownEvent\n"));

    if (fAgentThreadRunning)
    {
        ReintKdPrint(MAINLOOP, ("Setting Agent Shtudown \r\n"));
        SetAgentShutDownRequest();

        dwCur = dwStart = GetTickCount();

        // hang out here for sometime to see if he shuts down
        for (;;)
        {
            if (HasAgentShutDown() || ((dwCur < dwStart)||(dwCur > (dwStart+SHUTDOWN_WAIT_INTERVAL_MS))))
            {
                break;
            }


            ReintKdPrint(ALWAYS, ("Waiting 1 second for agent to shutdown \r\n"));
            // achtung!!! we use sleep becuase at this time the system is shutting down
            Sleep(SHUTDOWN_SLEEP_INTERVAL_MS);

            dwCur = GetTickCount();

        }
    }

    ReintKdPrint(SECURITY, ("WinlogonShutdownEvent exit\n"));
    return ERROR_SUCCESS;
}



DWORD WINAPI
WinlogonLockEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    ReintKdPrint(SECURITY, ("Lock \r\n"));
    return ERROR_CALL_NOT_IMPLEMENTED;
}



DWORD WINAPI
WinlogonUnlockEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    ReintKdPrint(SECURITY, ("Unlock \r\n"));
    return ERROR_CALL_NOT_IMPLEMENTED;
}


DWORD WINAPI
WinlogonStartShellEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    ReintKdPrint(SECURITY, ("WinlogonStartShellEvent\n"));
    UpdateExclusionList();
    UpdateBandwidthConservationList();
    return ERROR_SUCCESS;
}




BOOL
OkToLaunchAgent(
    VOID
)
/*++

Routine Description:

    A secret registry way of disabling the agent for testing purposes.

Arguments:


Returns:


Notes:

--*/
{
    DWORD dwDisposition;
    HKEY hKey = NULL;
    BOOL fLaunchAgent = TRUE;
    extern BOOL vfAgentQuiet;
#if 0
    NT_PRODUCT_TYPE productType;

    if( !RtlGetNtProductType( &productType ) ) {
        productType = NtProductWinNt;
    }

    switch ( productType ) {
    case NtProductWinNt:
        /* WORKSTATION */
        ReintKdPrint(INIT, ("Agent:CSC running workstation\r\n"));
        break;
    case NtProductLanManNt:
    case NtProductServer:
        /* SERVER */
        ReintKdPrint(INIT, ("Agent:CSC running server, disabling CSC\r\n"));
        return FALSE;
    }
#endif
    if (RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                    REG_KEY_CSC_SETTINGS,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_READ | KEY_WRITE,
                    NULL,
                    &hKey,
                    &dwDisposition) == ERROR_SUCCESS)
    {
        // autocheck is always be done on an unclean shutdown
        if (RegQueryValueEx(hKey, REG_VALUE_DISABLE_AGENT, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
        {
            fLaunchAgent = FALSE;
            ReintKdPrint(BADERRORS, ("Agent:CSC disabled agent launching\r\n"));
        }

        if (RegQueryValueEx(hKey, REG_VALUE_INACTIVE_AGENT, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
        {
            vfAgentQuiet = TRUE;
            ReintKdPrint(BADERRORS, ("Agent:CSC agent made inactive\r\n"));
        }

    }
    if(hKey)
    {
        RegCloseKey(hKey);
    }
    return fLaunchAgent;
}


//
// Security stuff
//

BOOL
AttachAuthInfoForThread(
    HANDLE  hTokenInput
    )
/*++

Routine Description:

    This routine is called when we get a logon notification from winlogon. We get this
    notification on a thread that is impersonating the user that has logged on.
    The routine creates an AGENT_SEC structure for this logged on user. We keep enough
    information so that the CSC agent thread can impersonate any of the logged on users.

    The agent thread does this in order to make sure that while filling incomplete files
    it is impersonating a logged on user, who has read access on the file to be filled.
    That way, sparse fills will not generate audits on the server side.

Arguments:

    None

Returns:

    TRUE if successful

Notes:
    We keep AuthenticationID as SIDs are not enough to identify the logged on user because in
    case of HYDRA, the same user could get logged in multiple times
    The AuthenticationID is guaranteed to be unique for each logon even though the SID is
    the same

--*/
{
    LPAGENT_SEC lpAS = NULL;
    BOOL    fRet = FALSE;
    HANDLE  hDupToken=NULL, hToken=NULL;
    DWORD   dwSidAndAttributeSize = 0, dwDummy;
    TOKEN_STATISTICS sStats;
    DWORD   dwError;


    if (hTokenInput)
    {
        ReintKdPrint(SECURITY, ("Opening thread token \r\n"));

        hToken = hTokenInput;
        fRet = TRUE;
#if 0
        fRet = OpenThreadToken(
                GetCurrentThread(),
                TOKEN_DUPLICATE|TOKEN_IMPERSONATE|TOKEN_READ,
                FALSE,
                &hToken);
#endif
    }
    else
    {
        ReintKdPrint(SECURITY, ("Opening process token \r\n"));

        fRet = OpenProcessToken(
                GetCurrentProcess(),
                TOKEN_DUPLICATE|TOKEN_IMPERSONATE|TOKEN_READ,
                &hToken);

    }
    if (fRet)
    {
        ReintKdPrint(SECURITY, ("Duplicating token \r\n"));

        if (DuplicateToken(hToken, SecurityImpersonation, &hDupToken))
        {
            ReintKdPrint(SECURITY, ("Getting AuthID for the duplicated thread token \r\n"));

            if(GetTokenInformation(
                hDupToken,
                TokenStatistics,
                (LPVOID)&sStats,
                sizeof(sStats),
                &dwSidAndAttributeSize
                ))
            {
                // make a dummy call to find out actually how big a buffer we need

                ReintKdPrint(SECURITY, ("Calling to find how much buffer SidAndAttribute needs\r\n"));

                GetTokenInformation(
                    hDupToken,
                    TokenUser,
                    (LPVOID)&dwDummy,
                    0,          // 0 byte buffer
                    &dwSidAndAttributeSize
                    );

                dwError = GetLastError();

                ReintKdPrint(SECURITY, ("Finding buffer size, error=%d\r\n", dwError));


                if (dwError == ERROR_INSUFFICIENT_BUFFER)
                {
                    ReintKdPrint(SECURITY, ("SidAndAttribute needs %d bytes\r\n", dwSidAndAttributeSize));

                    // allocate enough for everything and a little extra
                    lpAS = (LPAGENT_SEC)LocalAlloc(LPTR, sizeof(AGENT_SEC) + dwSidAndAttributeSize + sizeof(SID_AND_ATTRIBUTES));

                    if (lpAS)
                    {
                        ReintKdPrint(SECURITY, ("Getting SidAndAttribute for the duplicated thread token \r\n"));

                        if(GetTokenInformation(
                            hDupToken,
                            TokenUser,
                            (LPVOID)&(lpAS->sTokenUser),
                            dwSidAndAttributeSize,
                            &dwSidAndAttributeSize
                        ))
                        {

                            ReintKdPrint(SECURITY, ("Success !!!!\r\n"));

                            // all is well, fill up the info
                            lpAS->luidAuthId = sStats.AuthenticationId;
                            lpAS->hDupToken = hDupToken;
                            lpAS->ulPrincipalID = CSC_INVALID_PRINCIPAL_ID;

                            if (!hTokenInput)
                            {
                                lpAS->dwFlags |= FLAG_AGENT_SEC_LOCAL_SYSTEM;
                            }

                            fRet = TRUE;

                            EnterAgentCrit();

                            lpAS->lpASNext = vlpASHead;
                            vlpASHead = lpAS;

                            LeaveAgentCrit();
                        }
                        else
                        {
                            ReintKdPrint(BADERRORS, ("Failed to get SidIndex from the database \r\n"));
                        }

                        if (!fRet)
                        {
                            LocalFree(lpAS);
                            lpAS = NULL;
                        }
                    }
                }
            }
        }
        if (!hTokenInput)
        {
            CloseHandle(hToken);
        }
        hToken = NULL;
    }

    if (!fRet)
    {
        ReintKdPrint(BADERRORS, ("AttachAuthInfoForThread Error %d\r\n", GetLastError()));

    }
    return fRet;
}

BOOL
ReleaseAuthInfoForThread(
    HANDLE  hThreadToken
    )
/*++

Routine Description:

    This routine is called when we get a logoff notification for winlogon. We look at
    the current threads to token to get the AuthenticationId for the currently logged on user.
    We check our structures to find the one that matches with the AuthId. We remove that
    from the list.


Arguments:

    None

Returns:

    TRUE if successfull

Notes:

    We do this based on AuthenticationID rather than the SID because in case of HYDRA, the same
    user could get logged in multiple times, so he has the same SID, but the AuthenticationID is
    guaranteed to be unique

--*/
{
    BOOL    fRet = FALSE;
    DWORD   dwSidAndAttributeSize = 0;
    TOKEN_STATISTICS sStats;
    LPAGENT_SEC *lplpAS, lpAST;

    ReintKdPrint(SECURITY, ("ReleaseAuthInfoForThread: Getting AuthID for the thread token \r\n"));

    if(GetTokenInformation(
            hThreadToken,
            TokenStatistics,
            (LPVOID)&sStats,
            sizeof(sStats),
            &dwSidAndAttributeSize
            ))
    {
        ReintKdPrint(SECURITY, ("ReleaseAuthInfoForThread: looking for the right thread\r\n"));

        EnterAgentCrit();

        for (lplpAS = &vlpASHead; *lplpAS; lplpAS = &((*lplpAS)->lpASNext))
        {
            if (!memcmp(&((*lplpAS)->luidAuthId), &(sStats.AuthenticationId), sizeof(LUID)))
            {
                CloseHandle((*lplpAS)->hDupToken);

                lpAST = *lplpAS;

                *lplpAS = lpAST->lpASNext;

                LocalFree(lpAST);

                fRet = TRUE;

                ReintKdPrint(SECURITY, ("ReleaseAuthInfoForThread: found him and released\r\n"));

                break;
            }
        }

        LeaveAgentCrit();
    }


    return fRet;
}

BOOL
SetAgentThreadImpersonation(
    HSHADOW hDir,
    HSHADOW hShadow,
    BOOL    fWrite
    )
/*++

Routine Description:

    This routine checks with the database, for the given inode, any of the logged on
    users have the desired access. If such a user is found, it impersonates that user.

Arguments:

    hDir        Parent Inode of the file being accessed

    hShadow     Inode of the file being accessed

    fWrite      whether to check for write access, or read access is sufficient

Returns:

    TRUE if successfull

Notes:



--*/
{
    SECURITYINFO    rgsSecurityInfo[CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS];
    DWORD   dwSize;
    LPAGENT_SEC lpAS;
    int i;

    // for now juts impersonate the logged on user
    if (vlpASHead)
    {
        dwSize = sizeof(rgsSecurityInfo);

        if (GetSecurityInfoForCSC(INVALID_HANDLE_VALUE, hDir, hShadow, rgsSecurityInfo, &dwSize))
        {
            EnterAgentCrit();

            for (lpAS = vlpASHead; lpAS; lpAS = lpAS->lpASNext)
            {
                if (lpAS->ulPrincipalID == CSC_INVALID_PRINCIPAL_ID)
                {
                    if(!FindCreatePrincipalIDFromSID(INVALID_HANDLE_VALUE, lpAS->sTokenUser.User.Sid, GetLengthSid(lpAS->sTokenUser.User.Sid), &(lpAS->ulPrincipalID), TRUE))
                    {
                        ReintKdPrint(BADERRORS, ("Failed to get SidIndex from the database \r\n"));
                        continue;
                    }
                }

                Assert(lpAS->ulPrincipalID != CSC_INVALID_PRINCIPAL_ID);

                for (i=0;i<CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS;++i)
                {
                    // either the indices match or this is a guest index
                    if ((rgsSecurityInfo[i].ulPrincipalID == lpAS->ulPrincipalID)||
                        (rgsSecurityInfo[i].ulPrincipalID == CSC_GUEST_PRINCIPAL_ID))
                    {
                        if (rgsSecurityInfo[i].ulPermissions & ((fWrite)?FILE_GENERIC_WRITE:FILE_GENERIC_EXECUTE))
                        {
                            goto doneChecking;
                        }
                    }
                }
            }

            lpAS = NULL;
doneChecking:
            LeaveAgentCrit();
            if (!lpAS)
            {
                ReintKdPrint(SECURITY, ("Couldn't find any user with security info\r\n", GetLastError()));
            }
            else
            {
                if (SetThreadToken(NULL, lpAS->hDupToken))
                {
                    return TRUE;
                }
                else
                {
                    ReintKdPrint(BADERRORS, ("Error %d impersonating the agent\r\n", GetLastError()));
                }
            }
        }
        else
        {
            ReintKdPrint(BADERRORS, ("Couldn't get security info for hShadow=%xh\r\n", hShadow));
        }
    }
    return (FALSE);
}

BOOL
ResetAgentThreadImpersonation(
    VOID
    )
/*++

Routine Description:

    Reverts the agent to

Arguments:

    None

Returns:

    TRUE if successfull

Notes:



--*/
{
    if(!RevertToSelf())
    {
        ReintKdPrint(BADERRORS, ("Error %d reverting to self\r\n", GetLastError()));
        return FALSE;
    }

    return TRUE;
}


BOOL
ImpersonateALoggedOnUser(
    VOID
    )
{
    LPAGENT_SEC lpAS;
    BOOL fRet = FALSE;

    EnterAgentCrit();
    for (lpAS = vlpASHead; lpAS; lpAS = lpAS->lpASNext)
    {
        if (lpAS->dwFlags & FLAG_AGENT_SEC_LOCAL_SYSTEM)
        {
            continue;
        }

        fRet = SetThreadToken(NULL, lpAS->hDupToken);
    }

    LeaveAgentCrit();

    return (fRet);
}

BOOL
GetCSCPrincipalID(
    ULONG *lpPrincipalID
    )
/*++

Routine Description:

Arguments:

    None

Returns:

    TRUE if successful

Notes:

--*/
{

    TOKEN_USER *lpTokenUser = NULL;
    BOOL    fRet = FALSE;
    HANDLE  hToken=NULL;
    DWORD   dwSidAndAttributeSize = 0, dwDummy;
    TOKEN_STATISTICS sStats;
    DWORD   dwError=ERROR_SUCCESS;
    int i;
    SECURITYINFO    rgsSecurityInfo[CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS];

    *lpPrincipalID = CSC_INVALID_PRINCIPAL_ID;

    if(OpenThreadToken(GetCurrentThread(),TOKEN_QUERY,FALSE,&hToken)||
        OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&hToken))
    {

        if(GetTokenInformation(
            hToken,
            TokenStatistics,
            (LPVOID)&sStats,
            sizeof(sStats),
            &dwSidAndAttributeSize
            ))
        {
            // make a dummy call to find out actually how big a buffer we need

            GetTokenInformation(
                hToken,
                TokenUser,
                (LPVOID)&dwDummy,
                0,          // 0 byte buffer
                &dwSidAndAttributeSize
                );

            dwError = GetLastError();


            if (dwError == ERROR_INSUFFICIENT_BUFFER)
            {
                // allocate enough for everything and a little extra
                lpTokenUser = (TOKEN_USER *)LocalAlloc(LPTR, dwSidAndAttributeSize + sizeof(SID_AND_ATTRIBUTES));

                if (lpTokenUser)
                {
                    if(GetTokenInformation(
                        hToken,
                        TokenUser,
                        (LPVOID)(lpTokenUser),
                        dwSidAndAttributeSize,
                        &dwSidAndAttributeSize
                    ))
                    {
                        if(FindCreatePrincipalIDFromSID(INVALID_HANDLE_VALUE, lpTokenUser->User.Sid, GetLengthSid(lpTokenUser->User.Sid), lpPrincipalID, FALSE))
                        {
                            fRet = TRUE;                            
                        }
                        else
                        {
                            dwError = GetLastError();
                        }
                    }
                    else
                    {
                        dwError = GetLastError();
                    }

                    LocalFree(lpTokenUser);
                }
                else
                {
                    dwError = GetLastError();
                }
            }
        }
        else
        {
            dwError = GetLastError();
        }

        CloseHandle(hToken);

        hToken = NULL;
        if (!fRet)
        {
            SetLastError(dwError);
        }
    }

    return fRet;
}

BOOL
GetCSCAccessMaskForPrincipal(
    unsigned long ulPrincipalID,
    HSHADOW hDir,
    HSHADOW hShadow,
    unsigned long *pulAccessMask
    )
{
    return GetCSCAccessMaskForPrincipalEx(ulPrincipalID, hDir, hShadow, pulAccessMask, NULL, NULL);
}

BOOL
GetCSCAccessMaskForPrincipalEx(
    unsigned long ulPrincipalID,
    HSHADOW hDir,
    HSHADOW hShadow,
    unsigned long *pulAccessMask,
    unsigned long *pulActualMaskForUser,
    unsigned long *pulActualMaskForGuest
    )
/*++

Routine Description:

Arguments:

    None

Returns:

    TRUE if successful

Notes:

--*/
{
    BOOL    fRet = FALSE;
    DWORD   dwDummy,i;
    SECURITYINFO    rgsSecurityInfo[CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS];
    
    *pulAccessMask &= ~FLAG_CSC_ACCESS_MASK;

    if (pulActualMaskForUser)
    {
        *pulActualMaskForUser = 0;
    }

    if (pulActualMaskForGuest)
    {
        *pulActualMaskForGuest = 0;
    }

    if (ulPrincipalID == CSC_INVALID_PRINCIPAL_ID)
    {
        DbgPrint("Invalid Principal ID !! \n");
        return TRUE;
    }

    dwDummy = sizeof(rgsSecurityInfo);
    if (GetSecurityInfoForCSC(INVALID_HANDLE_VALUE, hDir, hShadow, rgsSecurityInfo, &dwDummy))
    {
        
        // ulPrincipalID can be a guest 

        for (i=0;i<CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS;++i)
        {
            unsigned long ulCur, ulPermissions;
            
            ulCur = rgsSecurityInfo[i].ulPrincipalID;
            ulPermissions = 0;          

            if (ulCur != CSC_INVALID_PRINCIPAL_ID)
            {
                
                // first get the bitmask
                if (rgsSecurityInfo[i].ulPermissions & FILE_GENERIC_WRITE)
                {
                    ulPermissions |= FLAG_CSC_WRITE_ACCESS;
                }
                if (rgsSecurityInfo[i].ulPermissions & FILE_GENERIC_EXECUTE)
                {
                    ulPermissions |= FLAG_CSC_READ_ACCESS;
                }

                // now shift and OR it in appropriate place
                if ((ulCur == ulPrincipalID)&&(ulCur != CSC_GUEST_PRINCIPAL_ID))
                {
                    *pulAccessMask |= (ulPermissions << FLAG_CSC_USER_ACCESS_SHIFT_COUNT);

                    if (pulActualMaskForUser)
                    {
                        *pulActualMaskForUser = rgsSecurityInfo[i].ulPermissions;
                    }
                }
                else if (ulCur == CSC_GUEST_PRINCIPAL_ID)
                {
                    *pulAccessMask |= (ulPermissions << FLAG_CSC_GUEST_ACCESS_SHIFT_COUNT);
                    if (pulActualMaskForGuest)
                    {
                        *pulActualMaskForGuest = rgsSecurityInfo[i].ulPermissions;
                    }
                }
                else
                {
                    *pulAccessMask |= (ulPermissions << FLAG_CSC_OTHER_ACCESS_SHIFT_COUNT);                                
                }
            }
        }

        fRet = TRUE;
    }
    return fRet;
}

BOOL
CheckCSCAccessForThread(
    HSHADOW hDir,
    HSHADOW hShadow,
    BOOL    fWrite
    )
/*++

Routine Description:

Arguments:

    None

Returns:

    TRUE if successful

Notes:

--*/
{
    TOKEN_USER *lpTokenUser = NULL;
    BOOL    fRet = FALSE;
    HANDLE  hToken=NULL;
    DWORD   dwSidAndAttributeSize = 0, dwDummy;
    TOKEN_STATISTICS sStats;
    DWORD   dwError=ERROR_SUCCESS;
    int i;
    SECURITYINFO    rgsSecurityInfo[CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS];

    if(OpenThreadToken(GetCurrentThread(),TOKEN_QUERY,FALSE,&hToken)||
        OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&hToken))
    {

        if(GetTokenInformation(
            hToken,
            TokenStatistics,
            (LPVOID)&sStats,
            sizeof(sStats),
            &dwSidAndAttributeSize
            ))
        {
            // make a dummy call to find out actually how big a buffer we need

            GetTokenInformation(
                hToken,
                TokenUser,
                (LPVOID)&dwDummy,
                0,          // 0 byte buffer
                &dwSidAndAttributeSize
                );

            dwError = GetLastError();


            if (dwError == ERROR_INSUFFICIENT_BUFFER)
            {
                // allocate enough for everything and a little extra
                lpTokenUser = (TOKEN_USER *)LocalAlloc(LPTR, dwSidAndAttributeSize + sizeof(SID_AND_ATTRIBUTES));

                if (lpTokenUser)
                {
                    if(GetTokenInformation(
                        hToken,
                        TokenUser,
                        (LPVOID)(lpTokenUser),
                        dwSidAndAttributeSize,
                        &dwSidAndAttributeSize
                    ))
                    {
                        ULONG ulPrincipalID;

                        if(FindCreatePrincipalIDFromSID(INVALID_HANDLE_VALUE, lpTokenUser->User.Sid, GetLengthSid(lpTokenUser->User.Sid), &ulPrincipalID, FALSE))
                        {
                            dwDummy = sizeof(rgsSecurityInfo);

                            if (GetSecurityInfoForCSC(INVALID_HANDLE_VALUE, hDir, hShadow, rgsSecurityInfo, &dwDummy))
                            {
                                Assert(ulPrincipalID != CSC_INVALID_PRINCIPAL_ID);

                                for (i=0;i<CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS;++i)
                                {
                                    // either the indices match or this is a guest index
                                    if ((rgsSecurityInfo[i].ulPrincipalID == ulPrincipalID)||
                                        (rgsSecurityInfo[i].ulPrincipalID == CSC_GUEST_PRINCIPAL_ID))
                                    {
                                        if (rgsSecurityInfo[i].ulPermissions & ((fWrite)?FILE_GENERIC_WRITE:FILE_GENERIC_EXECUTE))
                                        {
                                            fRet = TRUE;
                                            break;
                                        }

                                    }
                                }

                                if (!fRet)
                                {
                                    dwError = ERROR_ACCESS_DENIED;
                                }

                            }
                            else
                            {
                                dwError = GetLastError();
                            }

                        }
                        else
                        {
                            dwError = GetLastError();
                        }
                    }
                    else
                    {
                        dwError = GetLastError();
                    }

                    LocalFree(lpTokenUser);
                }
                else
                {
                    dwError = GetLastError();
                }
            }
        }
        else
        {
            dwError = GetLastError();
        }

        CloseHandle(hToken);
        hToken = NULL;

        if (!fRet)
        {
            SetLastError(dwError);
        }
    }

    return fRet;
}
#else   //CSC_ON_NT

BOOL
SetAgentThreadImpersonation(
    HSHADOW hDir,
    HSHADOW hShadow,
    BOOL    fWrite
    )
/*++

Routine Description:

    NOP for win9x

Arguments:

    hDir        Parent Inode of the file being accessed

    hShadow     Inode of the file being accessed

    fWrite      whether to check for write access, or read access is sufficient

Returns:

    TRUE if successfull

Notes:



--*/
{
    return (TRUE);
}

BOOL
ResetAgentThreadImpersonation(
    VOID
    )
/*++

Routine Description:

    NOP for win9x

Arguments:

    None

Returns:

    TRUE if successfull

Notes:



--*/
{
    return TRUE;
}

DWORD WINAPI
WinlogonStartupEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}

DWORD WINAPI
WinlogonLogonEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}



DWORD WINAPI
WinlogonLogoffEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}



DWORD WINAPI
WinlogonScreenSaverEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}



DWORD WINAPI
WinlogonShutdownEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}



DWORD WINAPI
WinlogonLockEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}



DWORD WINAPI
WinlogonUnlockEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}

DWORD WINAPI
WinlogonStartShellEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}
#endif //CSC_ON_NT


#ifdef CSC_ON_NT


DWORD
DoNetUseAddForAgent(
    IN  LPTSTR  lptzShareName,
    IN  LPTSTR  lptzUseName,
    IN  LPTSTR  lptzDomainName,
    IN  LPTSTR  lptzUserName,
    IN  LPTSTR  lptzPassword,
    IN  DWORD   dwFlags,
    OUT BOOL    *lpfIsDfsConnect
    )

{
    NETRESOURCE sNR;
    memset(&sNR, 0, sizeof(NETRESOURCE));
    sNR.dwType = RESOURCETYPE_DISK;
    sNR.lpRemoteName = lptzShareName;
    sNR.lpLocalName = lptzUseName;
//    return (NPAddConnection3(NULL, &sNR, lptzPassword, lptzUserName, 0));
    try
    {
        return (NPAddConnection3ForCSCAgent(NULL, &sNR, lptzPassword, lptzUserName, dwFlags, lpfIsDfsConnect));
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        ReintKdPrint(BADERRORS, ("Took exception in  DoNetUseAddForAgent list \n"));
        return GetLastError();
    }
}

DWORD
PRIVATE
DWConnectNet(
    _TCHAR  *lpServerPath,
    _TCHAR  *lpOutDrive,
    _TCHAR  *lpDomainName,
    _TCHAR  *lpUserName,
    _TCHAR  *lpPassword,
    DWORD   dwFlags,
    OUT BOOL    *lpfIsDfsConnect

    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    DWORD dwError;
    BOOL    fIsDfsConnect = FALSE;

    lpOutDrive[0]='E';
    lpOutDrive[1]=':';
    lpOutDrive[2]=0;
    do{
        if(lpOutDrive[0]=='Z') {
            break;
        }
        if ((dwError =
                DoNetUseAddForAgent(lpServerPath, lpOutDrive, lpDomainName, lpUserName, lpPassword, dwFlags, &fIsDfsConnect))
                ==WN_SUCCESS){
            if (lpfIsDfsConnect)
            {
                *lpfIsDfsConnect = fIsDfsConnect;
            }
            break;
        }
        else if ((dwError == WN_BAD_LOCALNAME)||
                (dwError == WN_ALREADY_CONNECTED)){
            ++lpOutDrive[0];
            continue;
        }
        else{
            break;
        }
    }
    while (TRUE);

    return (dwError);
}

DWORD DWDisconnectDriveMappedNet(
    LPTSTR  lptzDrive,
    BOOL    fForce
)
{
    Assert(lptzDrive);
    try
    {
        return NPCancelConnectionForCSCAgent(lptzDrive, fForce);
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        ReintKdPrint(BADERRORS, ("Took exception in  DWDisconnectDriveMappedNet list \n"));
        return GetLastError();
    }
}

ULONG
BaseSetLastNTError(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This API sets the "last error value" and the "last error string"
    based on the value of Status. For status codes that don't have
    a corresponding error string, the string is set to null.

Arguments:

    Status - Supplies the status value to store as the last error value.

Return Value:

    The corresponding Win32 error code that was stored in the
    "last error value" thread variable.

--*/

{
    ULONG dwErrorCode;

    dwErrorCode = RtlNtStatusToDosError( Status );
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}


BOOL
GetWin32InfoForNT(
    _TCHAR * lpFile,
    LPWIN32_FIND_DATA lpFW32
    )

/*++


Arguments:

    lpFileName - Supplies the file name of the file to find.  The file name
        may contain the DOS wild card characters '*' and '?'.


    lpFindFileData - Supplies a pointer whose type is dependent on the value
        of fInfoLevelId. This buffer returns the appropriate file data.

Return Value:

--*/

{
    HANDLE hFindFile = 0;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName, *pFileName;
    UNICODE_STRING PathName;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;
    struct SEARCH_BUFFER {
        union
        {
            FILE_BOTH_DIR_INFORMATION DirInfo;
            FILE_BASIC_INFORMATION    BasicInfo;
        };
        WCHAR Names[MAX_PATH];
    } Buffer;
    BOOLEAN TranslationStatus, fRet = FALSE;
    PVOID FreeBuffer = NULL;
    BOOLEAN EndsInDot;
    LPWIN32_FIND_DATAW FindFileData;
    PFILE_FULL_EA_INFORMATION EaBuffer = NULL;
    ULONG                     EaBufferSize = 0;

    FindFileData = lpFW32;

#if 0
    if (!AllocateEaBuffer(&EaBuffer, &EaBufferSize))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
#endif
    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpFile,
                            &PathName,
                            &FileName.Buffer,
                            NULL
                            );

    if ( !TranslationStatus) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        goto bailout;
    }


    FreeBuffer = PathName.Buffer;

    //
    //  If there is a a file portion of this name, determine the length
    //  of the name for a subsequent call to NtQueryDirectoryFile.
    //

    if (FileName.Buffer) {
        FileName.Length =
            PathName.Length - (USHORT)((ULONG_PTR)FileName.Buffer - (ULONG_PTR)PathName.Buffer);
        PathName.Length -= (FileName.Length);
        PathName.MaximumLength -= (FileName.Length);
        pFileName = &FileName;
        FileName.MaximumLength = FileName.Length;
    } else {
        pFileName = NULL;
    }


    InitializeObjectAttributes(
        &Obja,
        &PathName,
        0,
        NULL,
        NULL
        );

    if (pFileName)
    {
        Status = NtCreateFile(
                    &hFindFile,
                    SYNCHRONIZE | FILE_LIST_DIRECTORY,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN,
                    FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                    EaBuffer,
                    EaBufferSize
                    );



        if ( !NT_SUCCESS(Status) ) {
            ReintKdPrint(ALWAYS, ("GetWin32InfoForNT Failed Status=%x\n", Status));
            BaseSetLastNTError(Status);
            goto bailout;
        }
        //
        // If there is no file part, but we are not looking at a device,
        // then bail.
        //

        DirectoryInfo = &Buffer.DirInfo;

        Status = NtQueryDirectoryFile(
                    hFindFile,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    DirectoryInfo,
                    sizeof(Buffer),
                    FileBothDirectoryInformation,
                    TRUE,
                    pFileName,
                    FALSE
                    );

        if ( !NT_SUCCESS(Status) ) {
            ReintKdPrint(ALWAYS, ("Failed Status=%x\n", Status));
            BaseSetLastNTError(Status);
            goto bailout;
        }

        //
        // Attributes are composed of the attributes returned by NT.
        //

        FindFileData->dwFileAttributes = DirectoryInfo->FileAttributes;
        FindFileData->ftCreationTime = *(LPFILETIME)&DirectoryInfo->CreationTime;
        FindFileData->ftLastAccessTime = *(LPFILETIME)&DirectoryInfo->LastAccessTime;
        FindFileData->ftLastWriteTime = *(LPFILETIME)&DirectoryInfo->LastWriteTime;
        FindFileData->nFileSizeHigh = DirectoryInfo->EndOfFile.HighPart;
        FindFileData->nFileSizeLow = DirectoryInfo->EndOfFile.LowPart;

        RtlMoveMemory( FindFileData->cFileName,
                       DirectoryInfo->FileName,
                       DirectoryInfo->FileNameLength );

        FindFileData->cFileName[DirectoryInfo->FileNameLength >> 1] = UNICODE_NULL;

        RtlMoveMemory( FindFileData->cAlternateFileName,
                       DirectoryInfo->ShortName,
                       DirectoryInfo->ShortNameLength );

        FindFileData->cAlternateFileName[DirectoryInfo->ShortNameLength >> 1] = UNICODE_NULL;

        //
        // For NTFS reparse points we return the reparse point data tag in dwReserved0.
        //

        if ( DirectoryInfo->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) {
            FindFileData->dwReserved0 = DirectoryInfo->EaSize;
        }

        fRet = TRUE;
    }
    else
    {
        Status = NtOpenFile(
                    &hFindFile,
                    FILE_LIST_DIRECTORY| FILE_READ_EA | FILE_READ_ATTRIBUTES,
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_DIRECTORY_FILE
                    );

        if ( !NT_SUCCESS(Status) ) {
            ReintKdPrint(ALWAYS, ("GetWin32InfoForNT Failed Status=%x\n", Status));
            BaseSetLastNTError(Status);
            goto bailout;
        }

        Buffer.BasicInfo.FileAttributes = FILE_ATTRIBUTE_NORMAL;
        Status = NtQueryInformationFile(
                     hFindFile,
                     &IoStatusBlock,
                     (PVOID)&Buffer.BasicInfo,
                     sizeof(Buffer),
                     FileBasicInformation
                     );

        if ( !NT_SUCCESS(Status) ) {
            ReintKdPrint(ALWAYS, ("GetWin32InfoForNT Failed Status=%x\n", Status));
            BaseSetLastNTError(Status);
            goto bailout;
        }

        FindFileData->dwFileAttributes = Buffer.BasicInfo.FileAttributes;
        FindFileData->ftCreationTime = *(LPFILETIME)&Buffer.BasicInfo.CreationTime;
        FindFileData->ftLastAccessTime = *(LPFILETIME)&Buffer.BasicInfo.LastAccessTime;
        FindFileData->ftLastWriteTime = *(LPFILETIME)&Buffer.BasicInfo.LastWriteTime;
        FindFileData->nFileSizeHigh = 0;
        FindFileData->nFileSizeLow = 0;
        lstrcpy(FindFileData->cFileName, lpFile);
        FindFileData->cAlternateFileName[0] = UNICODE_NULL;
        fRet = TRUE;
    }

bailout:

    if (FreeBuffer)
    {
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    }
#if 0
    if (EaBuffer)
    {
        FreeEaBuffer(EaBuffer);
    }
#endif
    if (hFindFile)
    {
        NtClose(hFindFile);
    }

    return fRet;
}

BOOL
GetConnectionInfoForDriveBasedName(
    _TCHAR * lpName,
    LPDWORD lpdwSpeed
    )

/*++


Arguments:

    lpFileName - Supplies the file name of the file to find.  The file name
        may contain the DOS wild card characters '*' and '?'.


    lpFindFileData - Supplies a pointer whose type is dependent on the value
        of fInfoLevelId. This buffer returns the appropriate file data.

Return Value:

--*/

{
    HANDLE hFindFile = 0;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING PathName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus, fRet = FALSE;
    LMR_REQUEST_PACKET request;
    PVOID FreeBuffer = NULL;
    USHORT uBuff[4];
    LMR_CONNECTION_INFO_3 ConnectInfo;

    *lpdwSpeed = 0xffffffff;

    if (lstrlen(lpName) <2)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;        
    }

    uBuff[0] = lpName[0];
    uBuff[1] = ':';
    uBuff[2] = '\\';
    uBuff[3] = 0;

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            uBuff,
                            &PathName,
                            NULL,
                            NULL
                            );

    if ( !TranslationStatus) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        goto bailout;
    }

    FreeBuffer = PathName.Buffer;

    InitializeObjectAttributes(
        &Obja,
        &PathName,
        0,
        NULL,
        NULL
        );

    Status = NtCreateFile(
                &hFindFile,
                SYNCHRONIZE | FILE_LIST_DIRECTORY,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );

    if ( !NT_SUCCESS(Status) ) {
        ReintKdPrint(ALWAYS, ("Failed Status=%x\n", Status));
        BaseSetLastNTError(Status);
        goto bailout;
    }

    memcpy(&ConnectInfo, EA_NAME_CSCAGENT, sizeof(EA_NAME_CSCAGENT));

    Status = NtFsControlFile(
                        hFindFile,               // handle
                        NULL,                            // no event
                        NULL,                            // no APC routine
                        NULL,                            // no APC context
                        &IoStatusBlock,                  // I/O stat blk (set)
                        FSCTL_LMR_GET_CONNECTION_INFO,   // func code
                        NULL,
                        0,
                        &ConnectInfo,
                        sizeof(ConnectInfo));



    if ( !NT_SUCCESS(Status) ) {
        ReintKdPrint(ALWAYS, ("Failed Status=%x\n", Status));
        BaseSetLastNTError(Status);
        goto bailout;
    }

    *lpdwSpeed = ConnectInfo.Throughput * 8 / 100;
    


    fRet = TRUE;

bailout:

    if (FreeBuffer)
    {
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    }

    if (hFindFile)
    {
        NtClose(hFindFile);
    }

    return fRet;
}

BOOL
ReportTransitionToDfs(
    _TCHAR *lptServerName,
    BOOL    fOffline,
    DWORD   cbLen
    )
/*++

Routine Description:


Parameters:

Return Value:

Notes:

--*/
{
    ULONG   DummyBytesReturned;
    BOOL    fRet=FALSE;
    HANDLE  hDFS;
    PFILE_FULL_EA_INFORMATION eaBuffer = NULL;
    ULONG eaLength = 0;
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatus;
    PUNICODE_STRING name;
    
    ACCESS_MASK DesiredAccess;

    if (lptServerName)
    {
        if (cbLen == 0xffffffff)
        {
            cbLen = lstrlen(lptServerName) * sizeof(_TCHAR);
        }
    }
    else
    {
        cbLen = 0;
    }

    name = &DfsDriverObjectName;

    InitializeObjectAttributes(
        &objectAttributes,
        name,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    //
    // The CSC agent goes offline, and we require that the agent be in admin
    // or system mode, to avoid a non-privileged user from causing us to go
    // offline.
    // To go back online, the check is less stringent, since the online
    // transition is more of a hint and causing an incorrect online
    // indication does not cause wrong results.
    //
    DesiredAccess = (fOffline) ? FILE_WRITE_DATA : 0;

    status = NtCreateFile(
        &hDFS,
        SYNCHRONIZE | DesiredAccess,
        &objectAttributes,
        &ioStatus,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        FILE_OPEN_IF,
        FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
        eaBuffer,
        eaLength
    );

    if (NT_SUCCESS(status))
    {

        status = NtFsControlFile(
            hDFS,
            NULL,           // Event,
            NULL,           // ApcRoutine,
            NULL,           // ApcContext,
            &ioStatus,
            (fOffline)?FSCTL_DFS_CSC_SERVER_OFFLINE:FSCTL_DFS_CSC_SERVER_ONLINE,
            (LPVOID)(lptServerName),
            cbLen,
            NULL,
            0);

            CloseHandle(hDFS);
        if (NT_SUCCESS(status))
        {
            fRet = TRUE;
        }
    }

    if (!fRet)
    {
        ReintKdPrint(BADERRORS, ("ReportTransitionToDfs failed, Status %x\n", status));
    }

    return fRet;    
}

BOOL
UncPathToDfsPath(
    PWCHAR UncPath,
    PWCHAR DfsPath,
    ULONG cbLen)
{
    BOOL    fRet = FALSE;
    HANDLE  hDfs;
    NTSTATUS NtStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;

    if (UncPath == NULL)
        goto AllDone;
    
    InitializeObjectAttributes(
        &ObjectAttributes,
        &DfsDriverObjectName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    NtStatus = NtCreateFile(
        &hDfs,
        SYNCHRONIZE,
        &ObjectAttributes,
        &IoStatus,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        FILE_OPEN_IF,
        FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0);

    if (NT_SUCCESS(NtStatus)) {
        NtStatus = NtFsControlFile(
            hDfs,
            NULL,           // Event,
            NULL,           // ApcRoutine,
            NULL,           // ApcContext,
            &IoStatus,
            FSCTL_DFS_GET_SERVER_NAME,
            (PVOID)UncPath,
            wcslen(UncPath) * sizeof(WCHAR),
            (PVOID)DfsPath,
            cbLen);

        CloseHandle(hDfs);

        if (NT_SUCCESS(NtStatus))
            fRet = TRUE;
    }

AllDone:
    return fRet;    
}


#else   // CSC_ON_NT is not TRUE
BOOL
GetWin32InfoForNT(
    _TCHAR * lpFile,
    LPWIN32_FIND_DATA lpFW32
    )
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}
#endif



#if 0
#ifdef CSC_ON_NT

#define ROUND_UP_COUNT(Count,Pow2) \
        ( ((Count)+(Pow2)-1) & (~((Pow2)-1)) )

#define ALIGN_WCHAR             sizeof(WCHAR)

// need to include ntxxx.h where the ea is defined
#define EA_NAME_CSCAGENT    "CscAgent"

ULONG
BaseSetLastNTError(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This API sets the "last error value" and the "last error string"
    based on the value of Status. For status codes that don't have
    a corresponding error string, the string is set to null.

Arguments:

    Status - Supplies the status value to store as the last error value.

Return Value:

    The corresponding Win32 error code that was stored in the
    "last error value" thread variable.

--*/

{
    ULONG dwErrorCode;

    dwErrorCode = RtlNtStatusToDosError( Status );
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}


BOOL
AllocateEaBuffer(
    PFILE_FULL_EA_INFORMATION   *ppEa,
    ULONG                       *pEaLength

)
{
    FILE_ALLOCATION_INFORMATION AllocationInfo;

    PFILE_FULL_EA_INFORMATION EaBuffer = NULL;
    ULONG                     EaBufferSize = 0;

    UCHAR   CscAgentEaNameSize;
    DWORD   CscAgentEaValue = 0;

    CscAgentEaNameSize = (UCHAR)ROUND_UP_COUNT(
                                   strlen(EA_NAME_CSCAGENT) +
                                   sizeof(CHAR),
                                   ALIGN_WCHAR
                                   ) - sizeof(CHAR);

    EaBufferSize += FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0]) +
                    CscAgentEaNameSize + sizeof(CHAR) +
                    sizeof(CscAgentEaValue);

    EaBuffer = RtlAllocateHeap(
                   RtlProcessHeap(),
                   0,
                   EaBufferSize);

    memset(EaBuffer, 0, EaBufferSize);

    if (EaBuffer == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    strcpy((LPSTR) EaBuffer->EaName, EA_NAME_CSCAGENT);

    EaBuffer->EaNameLength = CscAgentEaNameSize;
    EaBuffer->EaValueLength = sizeof(CscAgentEaValue);

    RtlCopyMemory(
        &EaBuffer->EaName[CscAgentEaNameSize],
        &CscAgentEaValue,
        sizeof(CscAgentEaValue));

    *ppEa = EaBuffer;
    *pEaLength = EaBufferSize;
    return TRUE;
}

VOID
FreeEaBuffer(
    PFILE_FULL_EA_INFORMATION pEa
    )
{
    RtlFreeHeap(RtlProcessHeap(), 0, pEa);
}


BOOL
CreateFileForAgent(
    PHANDLE         h,
    PCWSTR          lpFileName,
    ULONG           dwDesiredAccess,
    ULONG           dwFlagsAndAttributes,
    ULONG           dwShareMode,
    ULONG           CreateDisposition,
    ULONG           CreateFlags
    )
/*++

Routine Description:

    This routine opens/creates a file/directory for "only" on the server. The redir
    triggers off of the extended attribute that is sent down to it by this call.

Arguments:

    None.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/
{
    NTSTATUS            Status;
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      FileName;
    IO_STATUS_BLOCK     IoStatusBlock;
    BOOLEAN             TranslationStatus, fRet=FALSE;
    PVOID               FreeBuffer=NULL;
    FILE_ALLOCATION_INFORMATION AllocationInfo;
    PFILE_FULL_EA_INFORMATION EaBuffer = NULL;
    ULONG                     EaBufferSize = 0;

    if (!AllocateEaBuffer(&EaBuffer, &EaBufferSize))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            NULL
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto bailout;
    }

    FreeBuffer = FileName.Buffer;

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtCreateFile(
                h,
                (ACCESS_MASK)dwDesiredAccess | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                NULL,
                dwFlagsAndAttributes & (FILE_ATTRIBUTE_VALID_FLAGS),
                dwShareMode,
                CreateDisposition,
                CreateFlags,
                EaBuffer,
                EaBufferSize
                );

    if (Status != STATUS_SUCCESS)
    {
        Assert(fRet == FALSE);
        BaseSetLastNTError(Status);
    }
    else
    {
        fRet = TRUE;
    }
bailout:
    if (FreeBuffer)
    {
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    }
    if (EaBuffer)
    {
        FreeEaBuffer(EaBuffer);
    }

    return (fRet);
}


BOOL
AgentDeleteFile(
    PCWSTR          lpFileName,
    BOOL            fFile
    )
{
    HANDLE hFile;
    FILE_DISPOSITION_INFORMATION Disposition;
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS    Status;
    BOOL    fRet = FALSE;

    if (CreateFileForAgent(
            &hFile,
            lpFileName,
           (ACCESS_MASK)DELETE | FILE_READ_ATTRIBUTES,
           FILE_ATTRIBUTE_NORMAL,
           FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
           FILE_OPEN,
           (fFile)?FILE_NON_DIRECTORY_FILE:FILE_DIRECTORY_FILE
       ))
    {
#undef  DeleteFile

        Disposition.DeleteFile = TRUE;

#define DeleteFile  DeleteFileW

        Status = NtSetInformationFile(
                     hFile,
                     &IoStatus,
                     &Disposition,
                     sizeof(Disposition),
                     FileDispositionInformation
                     );

        NtClose(hFile);

        if (Status == STATUS_SUCCESS)
        {
            fRet = TRUE;
        }
        else
        {
            Assert(fRet == FALSE);
            BaseSetLastNTError(Status);
        }
    }

    return fRet;
}


BOOL
AgentSetFileInformation(
    PCWSTR      lpFileName,
    DWORD       *lpdwFileAttributes,
    FILETIME    *lpftLastWriteTime,
    BOOL        fFile
    )
{
    NTSTATUS    Status;
    BOOL        fRet = FALSE;
    IO_STATUS_BLOCK IoStatus;
    FILE_BASIC_INFORMATION  sFileBasicInformation;
    HANDLE hFile;

    if (!CreateFileForAgent(
           &hFile,
           lpFileName,
           (ACCESS_MASK)FILE_READ_ATTRIBUTES|FILE_WRITE_ATTRIBUTES,
           FILE_ATTRIBUTE_NORMAL,
           FILE_SHARE_READ | FILE_SHARE_WRITE,
           FILE_OPEN,
           (fFile)?FILE_NON_DIRECTORY_FILE:FILE_DIRECTORY_FILE))
    {
        return FALSE;
    }

    Status = NtQueryInformationFile(
                hFile,
                &IoStatus,
                (PVOID) &sFileBasicInformation,
                sizeof(sFileBasicInformation),
                FileBasicInformation
                );
    if (Status == STATUS_SUCCESS)
    {
        if (lpdwFileAttributes)
        {
            sFileBasicInformation.FileAttributes = *lpdwFileAttributes;
        }
        if (lpftLastWriteTime)
        {
            sFileBasicInformation.LastWriteTime = *(LARGE_INTEGER *)lpftLastWriteTime;

        }

        Status = NtSetInformationFile(
                hFile,
                &IoStatus,
                (PVOID) &sFileBasicInformation,
                sizeof(sFileBasicInformation),
                FileBasicInformation
                );
    }

    NtClose(hFile);

    if (Status == STATUS_SUCCESS)
    {
        fRet = TRUE;
    }
    else
    {
        Assert(fRet == FALSE);

        BaseSetLastNTError(Status);
    }

    return fRet;
}


BOOL
AgentRenameFile(
    _TCHAR *lpFileSrc,
    _TCHAR *lpFileDst
    )
{

    HANDLE hFile;
    char    chBuff[sizeof(FILE_RENAME_INFORMATION) + (MAX_PATH+1) * sizeof(_TCHAR)];
    PFILE_RENAME_INFORMATION pFileRenameInformation;
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS    Status;
    BOOL    fRet = FALSE;

    memset(chBuff, 0, sizeof(chBuff));
    pFileRenameInformation = (PFILE_RENAME_INFORMATION)chBuff;
    pFileRenameInformation->FileNameLength = lstrlen(lpFileDst) * sizeof(_TCHAR);
    if (pFileRenameInformation->FileNameLength > MAX_PATH * sizeof(_TCHAR))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    pFileRenameInformation->ReplaceIfExists = TRUE;
    memcpy(pFileRenameInformation->FileName, lpFileDst, pFileRenameInformation->FileNameLength);

    if (CreateFileForAgent(
            &hFile,
            lpFileSrc,
           (ACCESS_MASK)DELETE | FILE_READ_ATTRIBUTES,
           FILE_ATTRIBUTE_NORMAL,
           FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
           FILE_OPEN,
           FILE_NON_DIRECTORY_FILE
       ))
    {
        Status = NtSetInformationFile(
                     hFile,
                     &IoStatus,
                     pFileRenameInformation,
                     sizeof(chBuff),
                     FileRenameInformation
                     );

        NtClose(hFile);

        if (Status == STATUS_SUCCESS)
        {
            fRet = TRUE;
        }
        else
        {
            Assert(fRet == FALSE);
            BaseSetLastNTError(Status);
        }
    }

    return fRet;
}

BOOL
GetWin32Info(
    _TCHAR * lpFile,
    LPWIN32_FIND_DATA lpFW32
    )

/*++


Arguments:

    lpFileName - Supplies the file name of the file to find.  The file name
        may contain the DOS wild card characters '*' and '?'.


    lpFindFileData - Supplies a pointer whose type is dependent on the value
        of fInfoLevelId. This buffer returns the appropriate file data.

Return Value:

--*/

{
    HANDLE hFindFile = 0;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName, *pFileName;
    UNICODE_STRING PathName;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;
    struct SEARCH_BUFFER {
        FILE_BOTH_DIR_INFORMATION DirInfo;
        WCHAR Names[MAX_PATH];
    } Buffer;
    BOOLEAN TranslationStatus, fRet = FALSE;
    PVOID FreeBuffer = NULL;
    BOOLEAN EndsInDot;
    LPWIN32_FIND_DATAW FindFileData;
    PFILE_FULL_EA_INFORMATION EaBuffer = NULL;
    ULONG                     EaBufferSize = 0;

    FindFileData = lpFW32;

    if (!AllocateEaBuffer(&EaBuffer, &EaBufferSize))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpFile,
                            &PathName,
                            &FileName.Buffer,
                            NULL
                            );

    if ( !TranslationStatus) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        goto bailout;
    }

    FreeBuffer = PathName.Buffer;

    //
    //  If there is a a file portion of this name, determine the length
    //  of the name for a subsequent call to NtQueryDirectoryFile.
    //

    if (FileName.Buffer) {
        FileName.Length =
            PathName.Length - (USHORT)((ULONG_PTR)FileName.Buffer - (ULONG_PTR)PathName.Buffer);
        PathName.Length -= (FileName.Length+sizeof(WCHAR));
        PathName.MaximumLength -= (FileName.Length+sizeof(WCHAR));
        pFileName = &FileName;
        FileName.MaximumLength = FileName.Length;
    } else {
        pFileName = NULL;
    }


    InitializeObjectAttributes(
        &Obja,
        &PathName,
        0,
        NULL,
        NULL
        );

    Status = NtCreateFile(
                &hFindFile,
                SYNCHRONIZE | FILE_LIST_DIRECTORY,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                EaBuffer,
                EaBufferSize
                );


    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        goto bailout;
    }
    //
    // If there is no file part, but we are not looking at a device,
    // then bail.
    //

    DirectoryInfo = &Buffer.DirInfo;

    if (pFileName)
    {
        Status = NtQueryDirectoryFile(
                    hFindFile,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    DirectoryInfo,
                    sizeof(Buffer),
                    FileBothDirectoryInformation,
                    TRUE,
                    pFileName,
                    FALSE
                    );
    }
    else
    {
        Status = NtQueryInformationFile(
                    hFindFile,
                    &IoStatusBlock,
                    DirectoryInfo,
                    sizeof(Buffer),
                    FileBothDirectoryInformation,
                    );

    }

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        goto bailout;
    }

    //
    // Attributes are composed of the attributes returned by NT.
    //

    FindFileData->dwFileAttributes = DirectoryInfo->FileAttributes;
    FindFileData->ftCreationTime = *(LPFILETIME)&DirectoryInfo->CreationTime;
    FindFileData->ftLastAccessTime = *(LPFILETIME)&DirectoryInfo->LastAccessTime;
    FindFileData->ftLastWriteTime = *(LPFILETIME)&DirectoryInfo->LastWriteTime;
    FindFileData->nFileSizeHigh = DirectoryInfo->EndOfFile.HighPart;
    FindFileData->nFileSizeLow = DirectoryInfo->EndOfFile.LowPart;

    RtlMoveMemory( FindFileData->cFileName,
                   DirectoryInfo->FileName,
                   DirectoryInfo->FileNameLength );

    FindFileData->cFileName[DirectoryInfo->FileNameLength >> 1] = UNICODE_NULL;

    RtlMoveMemory( FindFileData->cAlternateFileName,
                   DirectoryInfo->ShortName,
                   DirectoryInfo->ShortNameLength );

    FindFileData->cAlternateFileName[DirectoryInfo->ShortNameLength >> 1] = UNICODE_NULL;

    //
    // For NTFS reparse points we return the reparse point data tag in dwReserved0.
    //

    if ( DirectoryInfo->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) {
        FindFileData->dwReserved0 = DirectoryInfo->EaSize;
    }

    fRet = TRUE;

bailout:

    if (FreeBuffer)
    {
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    }
    if (EaBuffer)
    {
        FreeEaBuffer(EaBuffer);
    }
    if (hFindFile)
    {
        NtClose(hFindFile);
    }

    return fRet;
}


BOOL
AgentGetFileInformation(
    PCWSTR      lpFileName,
    DWORD       *lpdwFileAttributes,
    FILETIME    *lpftLastWriteTime,
    BOOL        fFile
    )
{
    NTSTATUS    Status;
    BOOL        fRet = FALSE;
    IO_STATUS_BLOCK IoStatus;
    FILE_BASIC_INFORMATION  sFileBasicInformation;
    HANDLE hFile;

    if (!CreateFileForAgent(
           &hFile,
           lpFileName,
           (ACCESS_MASK)FILE_READ_ATTRIBUTES|FILE_WRITE_ATTRIBUTES,
           FILE_ATTRIBUTE_NORMAL,
           FILE_SHARE_READ | FILE_SHARE_WRITE,
           FILE_OPEN,
           (fFile)?FILE_NON_DIRECTORY_FILE:FILE_DIRECTORY_FILE))
    {
        return FALSE;
    }

    Status = NtQueryInformationFile(
                hFile,
                &IoStatus,
                (PVOID) &sFileBasicInformation,
                sizeof(sFileBasicInformation),
                FileBasicInformation
                );
    if (Status == STATUS_SUCCESS)
    {
        if (lpdwFileAttributes)
        {
            *lpdwFileAttributes = sFileBasicInformation.FileAttributes;
        }
        if (lpftLastWriteTime)
        {
            *(LARGE_INTEGER *)lpftLastWriteTime = sFileBasicInformation.LastWriteTime;
        }
    }

    NtClose(hFile);

    if (Status == STATUS_SUCCESS)
    {
        fRet = TRUE;
    }
    else
    {
        Assert(fRet == FALSE);

        BaseSetLastNTError(Status);
    }

    return fRet;
}


DWORD
PRIVATE
DoObjectEdit(
    HANDLE              hShadowDB,
    _TCHAR *            lpDrive,
    LPCOPYPARAMS        lpCP,
    LPSHADOWINFO        lpSI,
    LPWIN32_FIND_DATA   lpFind32Local,
    LPWIN32_FIND_DATA   lpFind32Remote,
    int                 iShadowStatus,
    int                 iFileStatus,
    int                 uAction,
    LPCSCPROC           lpfnMergeProgress,
    DWORD               dwContext
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/

{
    HANDLE hfSrc = 0, hfDst = 0;
    HANDLE hDst=0;
    _TCHAR * lpT;
    LONG lOffset=0;
    DWORD dwError=ERROR_REINT_FAILED;
    WIN32_FIND_DATA    sFind32Remote;
    DWORD   dwTotal = 0, dwRet;
    _TCHAR szSrcName[MAX_PATH+MAX_SERVER_SHARE_NAME_FOR_CSC+10];
    _TCHAR szDstName[MAX_PATH+MAX_SERVER_SHARE_NAME_FOR_CSC+10];
    _TCHAR *lprwBuff = NULL;

    lprwBuff = LocalAlloc(LPTR, FILL_BUF_SIZE_LAN);

    if (!lprwBuff)
    {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }
    lOffset=0;

    // Create \\server\share\foo\00010002 kind of temporary filename

    lstrcpy(szDstName, lpCP->lpServerPath);
    lstrcat(szDstName, lpCP->lpRemotePath);

    lpT = GetLeafPtr(szDstName);
    *lpT = 0;   // remove the remote leaf

    lpT = GetLeafPtr(lpCP->lpLocalPath);

    // attach the local leaf
    lstrcat(szDstName, lpT);

    // Let us also create the real name \\server\share\foo\bar
    // we will use this to issue the rename ioctl

    lstrcpy(szSrcName, lpCP->lpServerPath);
    lstrcat(szSrcName, lpCP->lpRemotePath);

    ReintKdPrint(MERGE, ("Reintegrating file %s \r\n", szSrcName));

    if (mShadowDeleted(lpSI->uStatus)){

        ReintKdPrint(MERGE, ("Deleting %s from the share\r\n", szSrcName));

        if (lpFind32Remote)
        {
            if((lpFind32Remote->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                ReintKdPrint(MERGE, ("DoObjectEdit:attribute conflict on %s \r\n", szSrcName));
                goto bailout;
            }

            if (lpFind32Remote->dwFileAttributes & FILE_ATTRIBUTE_READONLY)
            {
                DWORD   dwT = FILE_ATTRIBUTE_NORMAL;

                if(!AgentSetFileInformation(szSrcName, &dwT, NULL, TRUE))
                {
                    ReintKdPrint(BADERRORS, ("DoObjectEdit: failed setattribute before delete on %s error=%d\r\n", szSrcName, GetLastError()));
                    goto bailout;
                }
            }

            // delete a file
            if(!AgentDeleteFile(szSrcName, TRUE))
            {
                dwError = GetLastError();

                if ((dwError==ERROR_FILE_NOT_FOUND)||
                    (dwError==ERROR_PATH_NOT_FOUND)){

                    ReintKdPrint(MERGE, ("DoObjectEdit:delete failed %s benign error=%d\r\n", szSrcName, dwError));
                }
                else
                {
                    ReintKdPrint(BADERRORS, ("DoObjectEdit:delete failed %s error=%d\r\n", szSrcName, dwError));
                }

                goto bailout;
            }

        }

        ReintKdPrint(MERGE, ("Deleted %s \r\n", szSrcName));

        DeleteShadow(hShadowDB, lpSI->hDir, lpSI->hShadow);

        dwError = NO_ERROR;

        goto bailout;
    }

    if (mShadowDirty(lpSI->uStatus)
        || mShadowLocallyCreated(lpSI->uStatus)){

        ReintKdPrint(MERGE, ("Writing data for %s \r\n", szSrcName));

        hfSrc = CreateFile( lpCP->lpLocalPath,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL);

        if (hfSrc ==  INVALID_HANDLE_VALUE)
        {
            ReintKdPrint(BADERRORS, ("DoObjectEdit:failed to open database file %s error=%d\r\n", szDstName, GetLastError()));
            goto bailout;
        }

        if (!CreateFileForAgent(
                &hfDst,
                szDstName,
                GENERIC_READ|GENERIC_WRITE,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                FILE_CREATE,
                FILE_NON_DIRECTORY_FILE))
        {
            ReintKdPrint(BADERRORS, ("DoObjectEdit:failed to create new temp file %s error=%d\r\n", szDstName, GetLastError()));
            goto bailout;
        }

        // let us append
        if((lOffset = SetFilePointer(hfDst, 0, NULL, FILE_END))==0xffffffff) {
            ReintKdPrint(BADERRORS, ("DoObjectEdit:failed to set filepointer on  %s error=%d\r\n", szDstName, GetLastError()));
            goto error;
        }

        ReintKdPrint(MERGE, ("Copying back %s to %s%s \r\n"
            , lpCP->lpLocalPath
            , lpCP->lpServerPath
            , lpCP->lpRemotePath
            ));

        lpSI->uStatus &= ~SHADOW_DIRTY;
        SetShadowInfo(  hShadowDB, lpSI->hDir, lpSI->hShadow, NULL,
                        lpSI->uStatus, SHADOW_FLAGS_ASSIGN);

        do{
            unsigned cbRead;
            if (!ReadFile(hfSrc, lprwBuff, FILL_BUF_SIZE_LAN, &cbRead, NULL)){
                ReintKdPrint(BADERRORS, ("DoObjectEdit:failed to read database file %s error=%d\r\n", szDstName, GetLastError()));
                goto error;
            }

            if (!cbRead) {
                break;
            }

            if(!WriteFile(hfDst, (LPBYTE)lprwBuff, cbRead, &cbRead, NULL)){
                ReintKdPrint(BADERRORS, ("DoObjectEdit:failed to write temp file %s error=%d\r\n", szDstName, GetLastError()));
                goto error;
            }

            dwTotal += cbRead;

            if (lpfnMergeProgress)
            {
                dwRet = (*lpfnMergeProgress)(
                                szSrcName,
                                lpSI->uStatus,
                                lpSI->ulHintFlags,
                                lpSI->ulHintPri,
                                lpFind32Local,
                                CSCPROC_REASON_MORE_DATA,
                                cbRead,
                                0,
                                dwContext
                            );
                if (dwRet != CSCPROC_RETURN_CONTINUE)
                {
                    ReintKdPrint(BADERRORS, ("DoObjectEdit: Callback function cancelled the operation\r\n"));
                    SetLastError(ERROR_OPERATION_ABORTED);
                    goto bailout;
                }

            }

            if (FAbortOperation())
            {
                ReintKdPrint(BADERRORS, ("DoObjectEdit: got an abort command from the redir\r\n"));
                SetLastError(ERROR_OPERATION_ABORTED);
                goto error;
            }
        } while(TRUE);

        CloseHandle(hfSrc);
        hfSrc = 0;

        NtClose(hfDst);
        hfDst = 0;

        // nuke the remote one if it exists
        if (lpFind32Remote){
            DWORD dwT = FILE_ATTRIBUTE_NORMAL;
            if(!AgentSetFileInformation(szSrcName, &dwT, NULL, TRUE)||
                !AgentDeleteFile(szSrcName, TRUE))
            {
                ReintKdPrint(BADERRORS, ("DoObjectEdit: failed to delete file %s error=%d\r\n", szSrcName, GetLastError()));
                goto error;
            }
        }


        if(!AgentRenameFile(szDstName, szSrcName))
        {
            ReintKdPrint(BADERRORS, ("DoObjectEdit: failed to rename file %s to %s error=%d\r\n", szDstName, szSrcName, GetLastError()));
            goto bailout;
        }

    }

    if (mShadowAttribChange(lpSI->uStatus)||mShadowTimeChange(lpSI->uStatus)){

        if(!AgentSetFileInformation(szSrcName, &(lpFind32Local->dwFileAttributes), &(lpFind32Local->ftLastWriteTime), TRUE))
        {
            ReintKdPrint(BADERRORS, ("DoObjectEdit: failed to change attributes on file %s error=%d\r\n", szSrcName, GetLastError()));
            goto bailout;
        }

    }

    // Get the latest timestamps/attributes/LFN/SFN on the file we just copied back
    if (!GetWin32Info(szSrcName, &sFind32Remote)) {
        goto error;
    }

    lpSI->uStatus &= (unsigned long)(~(SHADOW_MODFLAGS));

    SetShadowInfo(hShadowDB, lpSI->hDir, lpSI->hShadow, &sFind32Remote, lpSI->uStatus, SHADOW_FLAGS_ASSIGN|SHADOW_FLAGS_CHANGE_83NAME);

    dwError = NO_ERROR;
    goto bailout;

error:

bailout:
    if (hfSrc) {
        CloseHandle(hfSrc);
    }

    if (hfDst) {

        NtClose(hfDst);

        // if we failed,
        if (dwError != ERROR_SUCCESS)
        {
            DeleteFile(szDstName);
        }
    }

    if (lprwBuff)
    {
        LocalFree(lprwBuff);
    }
    if (dwError == NO_ERROR)
    {
        ReintKdPrint(MERGE, ("Done Reintegration for file %s \r\n", szSrcName));
    }
    else
    {
        dwError = GetLastError();
        ReintKdPrint(MERGE, ("Failed Reintegration for file %s Error = %d\r\n", szSrcName, dwError));
    }

    return (dwError);
}

DWORD
PRIVATE
DoCreateDir(
    HANDLE              hShadowDB,
    _TCHAR *            lpDrive,
    LPCOPYPARAMS        lpCP,
    LPSHADOWINFO        lpSI,
    LPWIN32_FIND_DATA   lpFind32Local,
    LPWIN32_FIND_DATA   lpFind32Remote,
    int                 iShadowStatus,
    int                 iFileStatus,
    int                 uAction,
    LPCSCPROC           lpfnMergeProgress,
    DWORD               dwContext
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    DWORD dwError=ERROR_FILE_NOT_FOUND;
    WIN32_FIND_DATA sFind32Remote;
    BOOL fCreateDir = FALSE;
    _TCHAR szSrcName[MAX_PATH+MAX_SERVER_SHARE_NAME_FOR_CSC+10];
    HANDLE hFile;

    // Let us create the real name x:\foo\bar
    lstrcpy(szSrcName, lpCP->lpServerPath);
    lstrcat(szSrcName, lpCP->lpRemotePath);

    ReintKdPrint(MERGE, ("CSC.DoCreateDirectory: Reintegrating directory %s \r\n", szSrcName));

    if(lpFind32Remote &&
        !(lpFind32Remote->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)){

        if (lpSI->uStatus & SHADOW_REUSED){

            ReintKdPrint(MERGE, ("CSC.DoCreateDirectory: %s is a file on the server, attempting to delete\r\n", szSrcName));

            // we now know that a file by this name has been deleted
            // and a directory has been created in it's place
            // we try to delete the file before creating the directory
            // NB, the other way is not possible because we don't allow directory deletes
            // in disconnected mode

            if (lpFind32Remote->dwFileAttributes & FILE_ATTRIBUTE_READONLY)
            {
                DWORD   dwT = FILE_ATTRIBUTE_NORMAL;

                if(!AgentSetFileInformation(szSrcName, &dwT, NULL, TRUE))
                {
                    ReintKdPrint(BADERRORS, ("CSC.DoCreateDirectory: failed setattribute before delete on %s error=%d\r\n", szSrcName, GetLastError()));
                    goto bailout;
                }
            }

            // delete the remote file before trying to create a directory
            if(!AgentDeleteFile(szSrcName, TRUE))
            {
                dwError = GetLastError();

                if ((dwError==ERROR_FILE_NOT_FOUND)||
                    (dwError==ERROR_PATH_NOT_FOUND)){
                    ReintKdPrint(MERGE, ("DoCreateDirectory: file delete failed %s benign error=%d\r\n", szSrcName, dwError));
                }
                else
                {
                    ReintKdPrint(BADERRORS, ("DoCreateDirectory: file delete failed %s error=%d\r\n", szSrcName, dwError));
                    goto bailout;
                }
            }
        }

        if (!CreateFileForAgent(
               &hFile,
               szSrcName,
               (ACCESS_MASK)FILE_READ_ATTRIBUTES|FILE_WRITE_ATTRIBUTES,
               FILE_ATTRIBUTE_NORMAL,
               FILE_SHARE_READ | FILE_SHARE_WRITE,
               FILE_OPEN_IF,
               FILE_DIRECTORY_FILE))
        {
            ReintKdPrint(BADERRORS, ("DoCreateDirectory: failed to create %s error=%d\r\n", szSrcName, GetLastError()));
            goto bailout;
        }

        NtClose(hFile);

        if(!AgentSetFileInformation(szSrcName, &(lpFind32Local->dwFileAttributes), NULL, FALSE))
        {
            ReintKdPrint(BADERRORS, ("DoCreateDirectory: failed to set attributes on %s error=%d\r\n", szSrcName, GetLastError()));
            goto bailout;
        }

        if(!GetWin32Info(szSrcName, &sFind32Remote)){
            ReintKdPrint(BADERRORS, ("DoCreateDirectory: failed to get win32 info for %s error=%d\r\n", szSrcName, GetLastError()));
            goto bailout;
        }

        dwError = NO_ERROR;

        SetShadowInfo(hShadowDB, lpSI->hDir, lpSI->hShadow, &sFind32Remote, (unsigned)(~SHADOW_MODFLAGS), SHADOW_FLAGS_AND);
        ReintKdPrint(MERGE, ("Created directory %s%s", lpCP->lpServerPath, lpCP->lpRemotePath));
    }

bailout:

    if (dwError != NO_ERROR)
    {
        dwError = GetLastError();
        ReintKdPrint(MERGE, ("CSC.DoCreateDirectory: Failed Reintegrating directory %s Error = %d \r\n", szSrcName, dwError));
    }
    else
    {
        ReintKdPrint(MERGE, ("CSC.DoCreateDirectory: Done Reintegrating directory %s \r\n", szSrcName));
    }
    return (dwError);
}

#endif  // ifdef CSC_ON_NT
#endif  // if 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\sources.inc ===
SOURCES  = \
        ..\ui.c \
        ..\reint.c \
        ..\utils.c \
        ..\list.c \
        ..\strings.c\
        ..\shdchk.c \
        ..\exports.c \
        ..\api.c \
        ..\ntstuff.c \
        ..\reint.rc \
        ..\csc_bmpu.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by reint.rc
//
#define menuAllApis                     0
#define menuMain                        1
#define IDS_SHADOW_SW_ERR               1
#define IDS_SHADOW_AGENT                2
#define IDM_CONTEXT_MENU                2
#define IDM_TRAY_MERGE                  103
#define IDM_TRAY_FILL_SHADOW            104
#define IDM_SHADOW_LOG                  105
#define IDM_SHADOWING                   106
#define IDM_TRAY_FREE_SPACE             107
#define IDM_MERGE_DIALOG                108
#define IDM_TRAY_FORCE_LOG              108
#define IDM_LOGON						109
#define IDM_LOGOFF						110


#define IDD_MERGE_LIST                  109
#define IDC_RECACTION                   110
#define IDB_ACTIONS                     111
#define IDI_LEATHER_BRIEF               120
#define IDI_METAL_BRIEF                 121
#define IDI_SPLIT_FILE                  122
#define IDI_SPLIT_FOLDER                123
#define IDI_SPLIT_MULT                  124
#define IDI_UPDATE_FILE                 125
#define IDI_UPDATE_FOLDER               126
#define IDI_UPDATE_MULT                 127
#define IDI_UPDATE_DOCK                 128
#define IDI_ADD_FOLDER                  129
#define IDI_REPLACE_FILE                130
#define IDI_REPLACE_FOLDER              131
#define IDI_UPDATE                      132
#define IDI_OPEN_FOLDER                 133
#define IDI_OLD_IDLE                    134
#define IDI_OLD_FILL                    135
#define IDI_OLD_MERGE                   136
#define miLogCopying                    140

#define IDD_DIALOG1                     140
#define IDM_LOG_COPYING_ON              140
#define IDM_LOG_COPYING                 140
#define miSpeadOpt                      141
#define IDM_SPEED_OPT                   141
#define IDD_DIALOG2                     142
#define IDI_FILL                        142
#define IDM_FILL_SHADOW                 143
#define IDI_MERGE                       143
#define IDD_SHARES_RECONNECT            143
#define miUpdate                        144
#define IDM_FREE_SPACE                  144
#define IDI_NETTRACKER                  144
#define IDM_FORCE_LOG_COPY              145
#define IDI_IDLE                        145
#define IDM_LOG_ON                      146
#define IDM_SHADOW_ON                   147
#define IDM_LOG_COPY_ON                 148
#define IDM_OPTIMIZE                    149
#define IDM_PROPERTIES                  150
#define IDM_REFRESH_CONNECTIONS         151
#define IDM_BREAK_CONNECTIONS           152
#define IDC_MERGE_TEXT					153

#define iconReint                       300
#define IDC_SHARE_NAME                  1000
#define ID_BASE                         0x2000
#define IDS_MENU_REPLACE                14336
#define IDS_MENU_CREATE                 14337
#define IDS_MENU_WHATSTHIS              14338
#define IDS_MENU_UPDATE                 14340
#define IDS_MENU_UPDATEALL              14341
#define IDS_MENU_SKIP                   14342
#define IDS_MENU_MERGE                  14343
#define IDS_InLocation                  14609
#define IDS_InBriefcase                 14610
#define IDS_BYTES                       14611
#define IDS_BOGUSDBTEMPLATE             14612
#define IDS_BC_DATABASE                 14613
#define IDS_BC_NAME                     14614
#define IDS_DATESIZELINE                14615
#define IDS_ORDERKB                     14616
#define IDS_ORDERMB                     14617
#define IDS_ORDERGB                     14618
#define IDS_ORDERTB                     14619
#define IDS_BC_DATABASE_SHORT           14620
#define IDS_BC_NAME_SHORT               14621
#define IDS_ALTNAME                     14622
#define IDS_STATE_Creates               15360
#define IDS_STATE_Replaces              15361
#define IDS_STATE_Skip                  15362
#define IDS_STATE_Conflict              15363
#define IDS_STATE_Merge                 15364
#define IDS_STATE_Uptodate              15365
#define IDS_STATE_NeedToUpdate          15366
#define IDS_STATE_Orphan                15367
#define IDS_STATE_Subfolder             15368
#define IDS_STATE_Changed               15369
#define IDS_STATE_Unchanged             15370
#define IDS_STATE_NewFile               15371
#define IDS_STATE_Unavailable           15372
#define IDS_STATE_UptodateInBrf         15373
#define IDS_STATE_SystemFile            15374
#define IDS_NEEDS_REINT                 15375
#define IDS_ATTEMPTING_RECONNECT        15376
#define IDS_DONE_RECONNECT              15377
#define IDS_NEW_LOGON                   15378
#define IDS_CREATE_CONFLICT             15379
#define IDS_DELETE_CONFLICT             15380
#define IDS_UPDATE_CONFLICT             15381
#define IDS_ATTRIBUTE_CONFLICT          15382
#define IDS_OPS_IN_PROGRESS             15383
#define IDS_TIP_MERGE_REQUIRED          15384
#define	IDS_MERGING_SHARE				15385
#define IDS_NETS_ARRIVING				15386
#define IDS_INITING_OFFLINE_NET 		15387
#define	IDS_FILLING_BEFORE_OFFLINE		15388
#define IDS_DB_CREATION_FAILED          15389
#define IDS_DB_UPGRADE_FAILED           15390
#define IDS_CSC_ENABLE_FAILED           15391

#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        146
#define _APS_NEXT_COMMAND_VALUE         151
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           140
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\strings.h ===
//
// Global strings here.
//


extern LPCTSTR  vszReintClass;
extern LPCTSTR  vszReintWnd;
extern LPCTSTR  vszCreateOK ;
extern LPCTSTR  vszConnectError ;
extern LPCTSTR  vszConnectOK ;
extern LPCTSTR  vszPanic;
extern LPCTSTR  vszTimeDateFormat ;
extern LPCTSTR  vszLogFile;
extern LPCTSTR  vszReintWnd;

extern LPCTSTR  vszSeekErr;
extern LPCTSTR  vszReadErr;
extern LPCTSTR  vszWriteErr;
extern LPCTSTR  vszMinSparseFillPri;
extern LPCTSTR  vsz386Enh;
extern LPCTSTR  vszSystemIni;
extern LPCTSTR  vszConflictMsg;
extern LPCTSTR  vszSlash;
extern LPCTSTR  vszOpsInProgress ;
extern LPCTSTR  vszShadowReg;
extern LPCTSTR  vszExclHint;
extern LPCTSTR  vszExclDelim;
extern LPCTSTR  vszDoLogCopy;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\traynoti.c ===
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#include "pch.h"

#include "traynoti.h"
#include "resource.h"

//
// Modifies the Tray notification icon.
//
BOOL Tray_Message(HWND hDlg, DWORD dwMessage, UINT uID, HICON hIcon, LPTSTR pszTip)
{
	NOTIFYICONDATA tnd;

	tnd.cbSize				= sizeof(NOTIFYICONDATA);
	tnd.hWnd				= hDlg;
	tnd.uID					= uID;

	tnd.uFlags				= NIF_MESSAGE|NIF_ICON;
	tnd.uCallbackMessage	= TRAY_NOTIFY;
	tnd.hIcon				= hIcon;

    // Work out what tip we sould use and set NIF_TIP
	*tnd.szTip=0;	
	if (pszTip)
	{
	    if(HIWORD(pszTip))
	    {
		    lstrcpyn(tnd.szTip, pszTip, sizeof(tnd.szTip));
		    tnd.uFlags |= NIF_TIP;
		}
		else
		{
		    if( LoadString(vhinstCur, LOWORD(pszTip), tnd.szTip, sizeof(tnd.szTip) ) )
    		    tnd.uFlags |= NIF_TIP;
	    }
    }

	return Shell_NotifyIcon(dwMessage, &tnd);
}

//
// Removes the icon from the Tray.
//
BOOL Tray_Delete(HWND hDlg)
{
	return Tray_Message(hDlg, NIM_DELETE, 0, NULL, NULL);
}

//
//
//
BOOL Tray_Add(HWND hDlg, UINT uIndex)
{
	HICON hIcon;

    DEBUG_PRINT(("Tray_Add used: Should use Tray_Modify instead"));

	if(!(hIcon = LoadImage(vhinstCur, MAKEINTRESOURCE(uIndex), IMAGE_ICON, 16, 16, 0)))
		return FALSE;
	return Tray_Message(hDlg, NIM_ADD, 0, hIcon, NULL);
}

//
// Will add the tray icon if its not already there. LPTSTR can be a MAKEINTRESOURCE
// If uIndex is NULL then we are to remove the tip
//
BOOL Tray_Modify(HWND hDlg, UINT uIndex, LPTSTR pszTip)
{
	HICON hIcon;

    if( !uIndex )
        return Tray_Delete(hDlg);

	if(!(hIcon = LoadImage(vhinstCur, MAKEINTRESOURCE(uIndex), IMAGE_ICON, 16, 16, 0)))
	{
	    DEBUG_PRINT(("Tray_Add: LoadIcon failed for icon %d\n",uIndex));
		return FALSE;
	}

    // If the notify fails, try adding the icon.
	if(!Tray_Message(hDlg, NIM_MODIFY, 0, hIcon, pszTip))
		return Tray_Message(hDlg, NIM_ADD, 0, hIcon, pszTip);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\reint.h ===
#ifndef __REINTH
#define __REINTH


#define  ERROR_SHADOW_OP_FAILED  3000L
#define  ERROR_REINT_FAILED      3001L
#define  ERROR_STALE             3002L
#define  ERROR_REMOTE_OP_FAILED  3003L


#define  ERROR_CONFLICT_FIRST       3100L
#define  ERROR_CREATE_CONFLICT      3100L // A locally created file already exists
#define  ERROR_DELETE_CONFLICT      3101L // A lcally modified shadow has been deleted from the remote
#define  ERROR_UPDATE_CONFLICT      3102L // Updated on remote while client changed it when disconnected
#define  ERROR_ATTRIBUTE_CONFLICT   3103L
#define  ERROR_NO_CONFLICT_DIR      3104L
#define  ERROR_CONFLICT_LAST        3104L



// Force level fro refreshconnections

#define REFRESH_FORCE_UNC_ONLY      0   // nuke UNC connections if no outstanding ops
#define REFRESH_FORCE_GENTLE        1   // nuke all connections if no outstanding ops
#define REFRESH_FORCE_SHADOW        2   // nuke all shadow connections
#define REFRESH_FORCE_ALL           3   // nuke all connection


// Verbose level while nuking connections
#define REFRESH_SILENT              0
#define REFRESH_NOISY               1

#ifdef CSC_ON_NT

#define  FILL_BUF_SIZE_SLOWLINK 4096
#define  FILL_BUF_SIZE_LAN      (FILL_BUF_SIZE_SLOWLINK * 4)

#define MyStrChr            wcschr
#define MyPathIsUNC(lpT)    ((*(lpT)==_T('\\')) && (*(lpT+1)==_T('\\')))
#else

#define  FILL_BUF_SIZE_SLOWLINK 512
#define  FILL_BUF_SIZE_LAN      (4096-1024)

#define MyStrChr            StrChr
#define MyPathIsUNC(lpT)    PathIsUNC(lpT)

#endif

#define  PUBLIC   FAR   PASCAL
#define  PRIVATE  NEAR  PASCAL

/******************* Macros *************************************************/
#define  mModifiedOffline(ulStatus) ((ulStatus) & (SHADOW_DIRTY|SHADOW_TIME_CHANGE|SHADOW_ATTRIB_CHANGE))

/******************* Typedefs ***********************************************/

typedef struct tagERRMSG
   {
   DWORD dwError;
   unsigned uMessageID;
   }
ERRMSG;

typedef struct tagFAILINFO
   {
   struct tagFAILINFO FAR *lpnextFI;
   HSHARE  hShare;
   HSHADOW  hDir;
   HSHADOW  hShadow;
   unsigned short cntFail;
   unsigned short cntMaxFail;
   DWORD    dwFailTime;
#ifdef DEBUG
   _TCHAR    rgchPath[MAX_PATH+1];
#endif //DEBUG
   }
FAILINFO, FAR *LPFAILINFO;

typedef struct tagCONNECTINFO
   {
   struct tagCONNECTINFO *lpnextCI;
   unsigned uStatus;
#ifdef _WIN64
 __declspec(align(8))
#endif
   byte rgFill[];
   }
CONNECTINFO, FAR *LPCONNECTINFO;

typedef  int (CALLBACK *LPFNREFRESHPROC)(LPCONNECTINFO, DWORD);
typedef  int (CALLBACK *LPFNREFRESHEXPROC)(int, DWORD);
// In reint.c
int PRIVATE PurgeSkipQueue(
   BOOL fAll,
   HSHARE  hShare,
   HSHADOW  hDir,
   HSHADOW  hShadow
   );

int PUBLIC ReintAllShares(HWND hwndParent);

typedef struct tagUPDATEINFO
{
    HSHARE hShare;
    HWND hwndParent;
} UPDATEINFO, FAR * PUPDATEINFO;



//
// Pass in the Share to merge on
// and the parent window.
//
int PUBLIC ReintOneShare(HSHARE hShare, HSHADOW hRoot, _TCHAR *, _TCHAR *, _TCHAR *, ULONG, LPCSCPROC lpfnMergeProgress, DWORD_PTR dwContext);

BOOL FGetConnectionList(LPCONNECTINFO *, int *);
BOOL FGetConnectionListEx(LPCONNECTINFO *lplpHead, LPCTSTR  lptzShareName, BOOL fAllSharesOnServer, BOOL fForceOffline, int *lpcntDiscon);
int DisconnectList(LPCONNECTINFO *, LPFNREFRESHPROC lpfn, DWORD dwCookie);
int ReconnectList(LPCONNECTINFO *,HWND hwndParent);
VOID ClearConnectionList(LPCONNECTINFO *);
void DoFreeShadowSpace(void);
void GetLogCopyStatus(void);
_TCHAR * PRIVATE LpGetExclusionList( VOID );
VOID PRIVATE ReleaseExclusionList( LPVOID lpBuff);

DWORD
PRIVATE
DWConnectNet(
    _TCHAR  *lpSharePath,
    _TCHAR  *lpOutDrive,
    _TCHAR  *lpDomainName,
    _TCHAR  *lpUserName,
    _TCHAR  *lpPassword,
    DWORD   dwFlags,
    BOOL    *lpfIsDfsConnect
    );

DWORD DWDisconnectDriveMappedNet(
    LPTSTR  lptzDrive,
    BOOL    fForce
    );
#ifdef DEBUG
VOID EnterSkipQueue(
   HSHARE hShare,
   HSHADOW hDir,
   HSHADOW hShadow,
   _TCHAR * lpPath );
#else
VOID EnterSkipQueue(
   HSHARE hShare,
   HSHADOW hDir,
   HSHADOW hShadow);
#endif //DEBUG

BOOL GetWin32Info(
    _TCHAR * lpFile,
    LPWIN32_FIND_DATA lpFW32 );

LPCOPYPARAMS LpAllocCopyParams(VOID);
VOID FreeCopyParams( LPCOPYPARAMS lp );
BOOL CALLBACK ShdLogonProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

int BreakConnectionsInternal(
   int  force,
   BOOL verbose
   );

int RefreshConnectionsInternal(
   int  force,
   BOOL verbose
   );

int RefreshConnectionsEx(
   int  force,
   BOOL verbose,
   LPFNREFRESHEXPROC lpfn,
   DWORD dwCookie
   );


//Synchronization functions
int PUBLIC
EnterAgentCrit(
    VOID
    );

VOID PUBLIC
LeaveAgentCrit(
    VOID
    );


int
ExtractSpaceStats(
    IN GLOBALSTATUS *lpsGS,
    OUT unsigned long   *lpulMaxSpace,
    OUT unsigned long   *lpulCurSpace,
    OUT unsigned long   *lpulFreeSpace
    );

VOID
ReInt_DoFreeShadowSpace(
    GLOBALSTATUS *lpsGS,
    int fForce
    );

BOOL
CALLBACK
ShdLogonProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
TruncateAndMarkSparse(
    HANDLE,
    _TCHAR *,
    LPSHADOWINFO
    );

DWORD
DWConnectNetEx(
    _TCHAR * lpSharePath,
    _TCHAR * lpOutDrive,
    BOOL fInteractive
    );

int
AttemptCacheFill (
    HSHARE  hShare,
    int         type,
    BOOL        fFullSync,
    ULONG       ulPrincipalID,
    LPCSCPROC   lpfnFillProgress,
    DWORD_PTR   dwContext
);

DWORD
DoSparseFill(
    HANDLE      hShadowDB,
    _TCHAR      *,
    _TCHAR      *,
    LPSHADOWINFO,
    WIN32_FIND_DATA *,
    LPCOPYPARAMS    lpCP,
    BOOL    fStalenessCheck,
    ULONG       ulPrincipalID,
    LPCSCPROC,
    DWORD_PTR
    );

DWORD
DoRefresh(
    HANDLE    hShadowDB,
    LPCOPYPARAMS lpCP,
    _TCHAR *,
    LPSHADOWINFO,
    _TCHAR *
    );

VOID
ReportLastError(
    VOID
    );

int
CheckDirtyShares(
    VOID
    );

// Shadow Cache Maintenance Functions
int DoDBMaintenance(VOID);
int ClearShadowCache(VOID);

void CopyLogToShare(void);

BOOL
FStopAgent(
    VOID
    );

BOOL
UpdateExclusionList(
    VOID
    );

BOOL
UpdateBandwidthConservationList(
    VOID
    );

BOOL
SetAgentThreadImpersonation(
    HSHADOW hDir,
    HSHADOW hShadow,
    BOOL    fWrite
    );

BOOL
ResetAgentThreadImpersonation(
    VOID
    );

BOOL
FAbortOperation(
    VOID
    );

VOID
SetAgentShutDownRequest(
    VOID
    );

BOOL
HasAgentShutDown(
    VOID
    );

VOID
CleanupReintState(
    VOID
    );

BOOL
InitCSCUI(
    HANDLE  hToken
    );

VOID
TerminateCSCUI(
    VOID
    );

BOOL
GetWin32InfoForNT(
    _TCHAR * lpFile,
    LPWIN32_FIND_DATA lpFW32
    );

DWORD
DoNetUseAddForAgent(
    IN  LPTSTR  lptzShareName,
    IN  LPTSTR  lptzUseName,
    IN  LPTSTR  lptzDomainName,
    IN  LPTSTR  lptzUserName,
    IN  LPTSTR  lptzPassword,
    IN  DWORD   dwFlags,
    OUT BOOL    *lpfIsDfsConnect
    );

#define  DO_ONE_OBJECT               1
#define  DO_ONE_SHARE               2
#define  DO_ALL                      3

#define TOD_CALLBACK_REASON_BEGIN       0
#define TOD_CALLBACK_REASON_NEXT_ITEM   1
#define TOD_CALLBACK_REASON_END         2


#define TOD_CONTINUE        0
#define TOD_ABORT           1
#define TOD_SKIP_DIRECTORY  2

typedef int (*TRAVERSEFUNC)(
                    HANDLE,
                    LPSECURITYINFO,
                    _TCHAR *,
                    DWORD,
                    WIN32_FIND_DATA *,
                    LPSHADOWINFO,
                    LPVOID);

int
TraverseOneDirectory(
    HANDLE          hShadowDB,
    LPSECURITYINFO  pShareSecurityInfo,
    HSHADOW         hParentDir,
    HSHADOW         hDir,
    LPTSTR          lptzInputPath,
    TRAVERSEFUNC    lpfnTraverseDir,
    LPVOID          lpContext
    );


BOOL
GetCSCPrincipalID(
    ULONG *lpPrincipalID
    );

BOOL
GetCSCAccessMaskForPrincipal(
    unsigned long ulPrincipalID,
    HSHADOW hDir,
    HSHADOW hShadow,
    unsigned long *pulAccessMask
    );

BOOL
GetCSCAccessMaskForPrincipalEx(
    unsigned long ulPrincipalID,
    HSHADOW hDir,
    HSHADOW hShadow,
    unsigned long *pulAccessMask,
    unsigned long *pulActualMaskForUser,
    unsigned long *pulActualMaskForGuest
    );

BOOL
GetConnectionInfoForDriveBasedName(
    _TCHAR * lpName,
    LPDWORD lpdwSpeed
    );

BOOL
ReportTransitionToDfs(
    _TCHAR *lptServerName,
    BOOL    fOffline,
    DWORD   cbLen
    );

BOOL
CSCEnumForStatsInternal(
    IN  LPCTSTR     lpszShareName,
    IN  LPCSCPROC   lpfnEnumProgress,
    IN  BOOL        fPeruserInfo,
    IN  BOOL        fUpdateShareReintBit,
    IN  DWORD_PTR   dwContext
);

// interval in milliseconds between two sparsefill attempts
#define WAIT_INTERVAL_ATTEMPT_MS            (1000*60)   // 1  minute

// interval in milliseconds between two polls for global status
#define WAIT_INTERVAL_GLOBALSTATUS_MS       (1000*60*10)    // 10 minutes

// duration in milliseconds after which an entry that is in the skip queue is nuked
#define WAIT_INTERVAL_SKIP_MS               (1000*60*10)    // 10 minutes

// duration in milliseconds between two stalenesscheck iterations

#define WAIT_INTERVAL_BETWEEN_ITERATIONS_MS (1000*60*10)

// interval in milliseconds between two staleness check attempts
#define WAIT_INTERVAL_STALE_MS              (1000*5)        // 5 seconds

#define WAIT_INTERVAL_CHECK_SERVER_ONLINE_MS    (1000*60*8)     // 8 minutes
#define WAIT_INTERVAL_FILL_THROTTLE_MS          (1000*60*2)     // 2 minutes

// delay to wait for PNP to settle down
#define WAIT_INTERVAL_PNP                   (1000*15)   // 15 seconds

// for some Registry queries, this is the max len buffer that I want back
#define MAX_NAME_LEN    100
#define SZ_TRUE "true"
#define SZ_FALSE "false"

extern  _TCHAR *    vlpExclusionList;
extern  HANDLE  vhMutex;
extern  BOOL    vfLogCopying,vfCopying,allowAttempt;
extern  HCURSOR  vhcursor;
extern  HWND    vhdlgShdLogon;
extern  DWORD   dwVxDEvent;
extern  HWND    vhwndMain;
extern  HANDLE  vhShadowDB;
extern  DWORD   vdwAgentThreadId;
extern  DWORD   vdwAgentSessionId;
#ifdef CSC_ON_NT
extern  DWORD   vdwCopyChunkThreadId;
extern  HDESK   hdesktopUser;
#endif
extern  BOOL    fFillers;

#define RWM_UPDATE (WM_USER+0x200)
#define RWM_UPDATEALL (WM_USER+0x201)

#ifdef DEBUG
//dbgprint interface
#define ReintKdPrint(__bit,__x) {\
    if (((REINT_KDP_##__bit)==0) || (ReintKdPrintVector & (REINT_KDP_##__bit))) {\
    DEBUG_PRINT(__x);\
    }\
}
#define REINT_KDP_ALWAYS                0x00000000
#define REINT_KDP_BADERRORS             0x00000001
#define REINT_KDP_INIT                  0x00000002
#define REINT_KDP_MAINLOOP              0x00000004
#define REINT_KDP_FILL                  0x00000008
#define REINT_KDP_MERGE                 0x00000010
#define REINT_KDP_API                   0x00000020
#define REINT_KDP_SPACE                 0x00000040
#define REINT_KDP_STALENESS             0x00000080
#define REINT_KDP_SKIPQUEUE             0x00000100
#define REINT_KDP_SECURITY              0x00000200

#define REINT_KDP_GOOD_DEFAULT (REINT_KDP_BADERRORS)

extern ULONG ReintKdPrintVector;

#else

#define ReintKdPrint(__bit,__x) ;

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\shdchk.c ===
#define DEFINED_UNICODE

#include "pch.h"
#ifdef CSC_ON_NT
#pragma hdrstop

#include <winioctl.h>
#endif //CSC_ON_NT

#include "shdcom.h"
#include "shdsys.h"
#include "reint.h"
#include "lib3.h"
#include "strings.h"
#include "oslayeru.h"
#include "record.h"
#include "utils.h"

#define  MAX_SHADOW_DIR_NAME  16
typedef unsigned long ulong;
typedef unsigned short ushort;
typedef VOID (*PRINTPROC)(LPSTR);

typedef struct tagRBA
{
    unsigned        ulidShadow;                 // Inode which is represented by this structure
    GENERICHEADER   sGH;                        // it's header
    CSCHFILE           hf;                         // open handle to the file
    DWORD           cntRBE;                     // count of buffer entries in the array
    DWORD           cntRecsPerRBE;              // #of records per buffer entry
    DWORD           cbRBE;                      // size in bytes of each buffer entry
    LPBYTE          rgRBE[];                    // buffer entry array
}
RBA, *LPRBA;    // stands for RecordBuffArray

#define MAX_RECBUFF_ENTRY_SIZE  (0x10000-0x100)
#define MAX_RBES_EXPECTED       1024


#define INODE_NULL        0L
#define UPDATE_REC        1
#define FIND_REC          2
#define DELETE_REC        3
#define ALLOC_REC         4
#define SHADOW_FILE_NAME_SIZE   8

extern BOOL vfCSCEnabled;
extern DWORD   vdwAgentThreadId;
extern char vszDBDir[MAX_PATH];

static char szBackslash[] = "\\";
static const char vszWorstCaseDefDir[] ="c:\\csc\\";
// directory name where the CSC database lives
// subdirectories under CSC directory
char szStarDotStar[]="*.*";
char vchBuff[256], vchPrintBuff[1024];

extern DWORD vdwDBCapacity, vdwClusterSize;

#define RecFromInode(hShadow)       ((hShadow & 0x7fffffff) - (ULID_FIRST_USER_DIR-1))

AssertData;
AssertError;


int DoDBMaintenance(VOID);
int CALLBACK CheckDBProc(
    int cntDrives,
    DWORD dwCookie
    );
int PUBLIC CheckPQ(VOID);
int CountProc(HANDLE hf, LPQHEADER    lpQH, LPQREC        lpQR, unsigned *lpcnt);

BOOL
FindCreateDBDir(
    BOOL    *lpfCreated,
    BOOL    fCleanup    // empty the directory if found
    );

BOOL
DeleteDirectoryFiles(
    LPCSTR  lpszDir
);

int ClearShadowCache();
int CALLBACK ReinitShadowDBProc(
    int cntDrives,
    DWORD dwCookie
    );
BOOL IsValidName(LPSTR lpName);
int SetDefaultSpace(LPSTR lpShadowDir);

VOID
PrintShareHeader(
    LPSHAREHEADER lpSH,
    PRINTPROC lpfnPrintProc
    );

VOID
PrintPQHeader(
    LPQHEADER   lpQH,
    PRINTPROC lpfnPrintProc
    );

VOID
PrintFileHeader(
    LPFILEHEADER lpFH,
    unsigned    ulSpaces,
    PRINTPROC lpfnPrintProc
    );

VOID PrintShareRec(
    unsigned ulRec,
    LPSHAREREC lpSR,
    PRINTPROC lpfnPrintProc
    );

VOID PrintFilerec(
    unsigned ulRec,
    LPFILERECEXT    lpFR,
    unsigned    ulSpaces,
    PRINTPROC lpfnPrintProc
    );

VOID
PrintPQrec(
    unsigned    ulRec,
    LPQREC  lpQrec,
    PRINTPROC lpfnPrintProc
    );

int
PrintSpaces(
    LPSTR   lpBuff,
    unsigned    ulSpaces
    );

#ifdef CSC_ON_NT
BOOL
PUBLIC
CheckCSCShare(
    USHORT  *lptzShare,
    LPCSCPROC   lpfnMergeProgress,
    DWORD       dwContext
    );
#else
BOOL
PUBLIC
CheckCSCShare(
    LPSTR   lptzShare,
    LPCSCPROC   lpfnMergeProgress,
    DWORD       dwContext
    );
#endif

#ifndef CSC_ON_NT

BOOL
CheckCSCDatabaseVersion(
    BOOL    *lpfWasDirty
)
{

    char *lpszName = NULL;
    SHAREHEADER sSH;
    PRIQHEADER    sPQ;

    CSCHFILE hfShare = 0, hfPQ=0;
    BOOL    fOK = FALSE;
    DWORD   dwErrorShare=NO_ERROR, dwErrorPQ=NO_ERROR;

//    OutputDebugStringA("Checking version...\r\n");
    lpszName = FormNameString(vszDBDir, ULID_SHARE);

    if (!lpszName)
    {
        return FALSE;
    }

    if(!(hfShare = OpenFileLocal(lpszName)))
    {
        dwErrorShare = GetLastError();
    }


    FreeNameString(lpszName);

    lpszName = FormNameString(vszDBDir, ULID_PQ);

    if (!lpszName)
    {
        goto bailout;
    }


    if(!(hfPQ = OpenFileLocal(lpszName)))
    {
        dwErrorPQ = GetLastError();
    }

    FreeNameString(lpszName);
    lpszName = NULL;

    if ((dwErrorShare == NO_ERROR)&&(dwErrorPQ==NO_ERROR))
    {
        if(ReadFileLocal(hfShare, 0, &sSH, sizeof(SHAREHEADER))!=sizeof(SHAREHEADER))
        {
            //error message
            goto bailout;
        }

        if (sSH.ulVersion != CSC_DATABASE_VERSION)
        {
            goto bailout;
        }

        if (lpfWasDirty)
        {
            *lpfWasDirty = ((sSH.uFlags & FLAG_SHAREHEADER_DATABASE_OPEN) != 0);
        }

        // reset the database open flag
        sSH.uFlags &= ~FLAG_SHAREHEADER_DATABASE_OPEN;

        // don't worry about any errors here
        WriteFileLocal(hfShare, 0, &sSH, sizeof(SHAREHEADER));

        if(ReadFileLocal(hfPQ, 0, &sPQ, sizeof(PRIQHEADER))!=sizeof(PRIQHEADER))
        {
            //error message
            goto bailout;
        }

        if (sPQ.ulVersion != CSC_DATABASE_VERSION)
        {
            goto bailout;
        }

        fOK = TRUE;
    }
    else
    {
        if (((dwErrorShare == ERROR_FILE_NOT_FOUND)&&(dwErrorPQ==ERROR_FILE_NOT_FOUND))||
            ((dwErrorShare == ERROR_PATH_NOT_FOUND)&&(dwErrorPQ==ERROR_PATH_NOT_FOUND)))
        {
            fOK = TRUE;
        }
    }

bailout:

    if (lpszName)
    {
        FreeNameString(lpszName);
    }

    if (hfShare)
    {
        CloseFileLocal(hfShare);
    }

    if (hfPQ)
    {
        CloseFileLocal(hfPQ);
    }

    return (fOK);
}

BOOL
UpgradeCSCDatabase(
    LPSTR   lpszDir

)
{
    BOOL    fCreated;

    return (FindCreateDBDir(&fCreated, TRUE)); // cleanup dirs if exist
}

BOOL
FindCreateDBDirEx(
    BOOL    *lpfCreated,
    BOOL    *lpfIncorrectSubdirs,
    BOOL    fCleanup    // empty the directory if found
    )
/*++

Routine Description:


Parameters:

Return Value:

Notes:

--*/
{
    DWORD    dwAttr;
    BOOL fRet = FALSE;
    char buff[MAX_PATH+1];
    int i;
    UINT lenDir;


    *lpfIncorrectSubdirs = *lpfCreated = FALSE;

    Assert(vszDBDir[0]);


    DEBUG_PRINT(("InbCreateDir: looking for %s \r\n", vszDBDir));

    if ((dwAttr = GetFileAttributesA(vszDBDir)) == 0xffffffff)
    {
        DEBUG_PRINT(("InbCreateDir: didnt' find the CSC directory trying to create one \r\n"));
        if(CreateDirectoryA(vszDBDir, NULL))
        {
            *lpfCreated = TRUE;
        }
        else
        {
            goto bailout;
        }
    }
    else
    {
        if (dwAttr & FILE_ATTRIBUTE_DIRECTORY)
        {
            if (fCleanup && !DeleteDirectoryFiles(vszDBDir))
            {
                goto bailout;
            }
        }
        else
        {
            goto bailout;
        }
    }


    strcpy(buff, vszDBDir);

    lenDir = strlen(buff);
    buff[lenDir++] = '\\';
    buff[lenDir++] = CSCDbSubdirFirstChar();
    buff[lenDir++] = '1';
    buff[lenDir] = 0;

    for (i=0; i<CSCDB_SUBDIR_COUNT; ++i)
    {
        if ((dwAttr = GetFileAttributesA(buff)) == 0xffffffff)
        {
            *lpfIncorrectSubdirs = TRUE;

            DEBUG_PRINT(("InbCreateDir: didnt' find the CSC directory trying to create one \r\n"));
            if(!CreateDirectoryA(buff, NULL))
            {
                goto bailout;
            }
        }
        else
        {
            if (!(dwAttr & FILE_ATTRIBUTE_DIRECTORY))
            {
                goto bailout;
            }

            if (fCleanup && !DeleteDirectoryFiles(buff))
            {
                goto bailout;
            }

        }

        buff[lenDir-1]++;
    }

    fRet = TRUE;


bailout:

    return (fRet);
}

BOOL
FindCreateDBDir(
    BOOL    *lpfCreated,
    BOOL    fCleanup    // empty the directory if found
    )
/*++

Routine Description:


Parameters:

Return Value:

Notes:

--*/
{
    BOOL    fIncorrectSubdirs = FALSE, fRet;

    if (fRet = FindCreateDBDirEx(lpfCreated, &fIncorrectSubdirs, fCleanup))
    {
        // if the root directory wasn't created and there in correct subdirs
        // then we need to recreate the database.

        if (!*lpfCreated && fIncorrectSubdirs)
        {
            fRet = FindCreateDBDirEx(lpfCreated, &fIncorrectSubdirs, TRUE);
        }
    }
    return fRet;
}

BOOL
DeleteDirectoryFiles(
    LPCSTR  lpszDir
)
{
    WIN32_FIND_DATAA sFind32;
    char buff[MAX_PATH+32];
    HANDLE  hFind;
    int lenDir;
    BOOL fOK = TRUE;


    lstrcpyA(buff, lpszDir);
    lenDir = lstrlenA(buff);

    if (!lenDir)
    {
        return (FALSE);
    }

    if (buff[lenDir-1] != '\\')
    {
        buff[lenDir++] ='\\';
        buff[lenDir]=0;
    }


    lstrcatA(buff, szStarDotStar);


    if ((hFind = FindFirstFileA(buff, &sFind32))!=INVALID_HANDLE_VALUE)
    {
        do
        {
            buff[lenDir] = 0;

            if (!(sFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                && IsValidName(sFind32.cFileName))
            {
                lstrcatA(buff, sFind32.cFileName);
                fOK = DeleteFileA(buff);
                if (!fOK)
                {
                    break;
                }
            }
        }
        while(FindNextFileA(hFind, &sFind32));

        FindClose(hFind);
    }
    return (fOK);
}


BOOL IsValidName(LPSTR lpName)
{
    int len = strlen(lpName), ch, i=0;

    if (len != INODE_STRING_LENGTH)
    {
        return FALSE;
    }

    while (len--)
    {
        ++i;

        ch = *lpName++;
        if (!(((ch>='0') && (ch <='9'))||
            ((ch>='A') && (ch <='F'))||
            ((ch>='a') && (ch <='f'))))
        {
            return FALSE;
        }
    }

    if (i != INODE_STRING_LENGTH)
    {
        return FALSE;
    }

    return (TRUE);
}

#endif



BOOL WINAPI CheckCSCEx(
    LPSTR       lpszShare,
    LPCSCPROC   lpfnProgress,
    DWORD       dwContext,
    DWORD       dwType
)
{
#ifdef DEBUG
#ifdef CSC_ON_NT
    USHORT uBuff[MAX_PATH];

    memset(uBuff, 0, sizeof(uBuff));
    if (MultiByteToWideChar(CP_ACP, 0, lpszShare, strlen(lpszShare), uBuff, sizeof(uBuff)))
    {
        return(CheckCSCShare(uBuff, lpfnProgress, dwContext));
    }
#else
    return(CheckCSCShare(lpszShare, lpfnProgress, dwContext));

#endif
#else
    return FALSE;
#endif
    return FALSE;
}

BOOL
WINAPI
CheckCSC(
    LPSTR       lpszDBDir,
    BOOL        fFix
    )
{
    LPVOID lpdbID = NULL;
    BOOL    fRet = FALSE;
    char    szDBDir[MAX_PATH+1];
    DWORD   dwDBCapacity;
    DWORD   dwClusterSize;
    ULONG   ulDatabaseStatus;
    
    // if we are the agent and CSC is enabled then bailout;
    if (vdwAgentThreadId)
    {
        if (vfCSCEnabled)
        {
            DEBUG_PRINT(("CheckCSC: CSC is enabled, cannot do database check\r\n"));
            return FALSE;
        }
    }
    else
    {
        unsigned ulSwitch = SHADOW_SWITCH_SHADOWING;
        if(ShadowSwitches(INVALID_HANDLE_VALUE, &ulSwitch, SHADOW_SWITCH_GET_STATE))
        {
            if((ulSwitch & SHADOW_SWITCH_SHADOWING)!=0)
            {
                DEBUG_PRINT(("CheckCSC: CSC is enabled, cannot do database check\r\n"));
                return FALSE;
            }
        }
    }

    if (InitValues(szDBDir, sizeof(szDBDir), &dwDBCapacity, &dwClusterSize))
    {
        if (!(lpdbID = OpenRecDB((lpszDBDir)?lpszDBDir:szDBDir, "Test", 0, dwDBCapacity, dwClusterSize, FALSE, NULL, &ulDatabaseStatus)))
        {
            DEBUG_PRINT(("CheckCSC: failed to open record database at %s\r\n", (lpszDBDir)?lpszDBDir:szDBDir));
            goto bailout;
        }

        fRet = TraverseHierarchy(lpdbID, fFix);
    }
bailout:
    if (lpdbID)
    {
        CloseRecDB(lpdbID);
    }

    return (fRet);
}




VOID
PrintShareHeader(
    LPSHAREHEADER lpSH,
    PRINTPROC lpfnPrintProc
    )
{
    int iRet=0;

    if (lpfnPrintProc)
    {
        iRet += wsprintfA(vchPrintBuff,"****ShareHeader****\r\n" );

        iRet+=wsprintfA(vchPrintBuff+iRet,"Header: Flags=%xh Version=%lxh Records=%ld Size=%d \r\n",
                    lpSH->uchFlags, lpSH->ulVersion, lpSH->ulRecords, lpSH->uRecSize);

        iRet+=wsprintfA(vchPrintBuff+iRet,"Store: Max=%ld Current=%ld \r\n", lpSH->sMax.ulSize, lpSH->sCur.ulSize);

        iRet+=wsprintfA(vchPrintBuff+iRet,"\r\n");

        (lpfnPrintProc)(vchPrintBuff);
    }
}

VOID
PrintPQHeader(
    LPQHEADER   lpQH,
    PRINTPROC lpfnPrintProc
    )
{
    int iRet=0;

    if (lpfnPrintProc)
    {
        iRet += wsprintfA(vchPrintBuff+iRet,"****PQHeader****\r\n" );

        iRet += wsprintfA(vchPrintBuff+iRet,"Flags=%xh Version=%lxh Records=%ld Size=%d head=%ld tail=%ld\r\n",
                    lpQH->uchFlags, lpQH->ulVersion, lpQH->ulRecords, lpQH->uRecSize, lpQH->ulrecHead, lpQH->ulrecTail);
        iRet += wsprintfA(vchPrintBuff+iRet,"\r\n");

        (lpfnPrintProc)(vchPrintBuff);
    }
}

VOID
PrintFileHeader(
    LPFILEHEADER lpFH,
    unsigned    ulSpaces,
    PRINTPROC lpfnPrintProc
    )
{

    int iRet=0;

    if (lpfnPrintProc)
    {
        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);
        iRet += wsprintfA(vchPrintBuff+iRet,"****FileHeader****\r\n" );

        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);
        iRet += wsprintfA(vchPrintBuff+iRet,"Flags=%xh Version=%lxh Records=%ld Size=%d\r\n",
                    lpFH->uchFlags, lpFH->ulVersion, lpFH->ulRecords, lpFH->uRecSize);

        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);
        iRet += wsprintfA(vchPrintBuff+iRet,"bytes=%ld entries=%d Share=%xh Dir=%xh\r\n",
                    lpFH->ulsizeShadow, lpFH->ucShadows, lpFH->ulidShare, lpFH->ulidDir);

        iRet += wsprintfA(vchPrintBuff+iRet,"\r\n");

        (lpfnPrintProc)(vchPrintBuff);
    }
}

VOID
PrintPQrec(
    unsigned    ulRec,
    LPQREC      lpQrec,
    PRINTPROC lpfnPrintProc
    )
{
    int iRet=0;

    if (lpfnPrintProc)
    {
        iRet += wsprintfA(vchPrintBuff+iRet,"rec=%xh: Srvr=%xh dir=%xh shd=%xh prev=%xh next=%xh Stts=%xh, RfPr=%d PnCnt=%x PnFlgs=%xh DrEntr=%d\r\n"
                    ,ulRec
                    , lpQrec->ulidShare
                    , lpQrec->ulidDir
                    , lpQrec->ulidShadow
                    , lpQrec->ulrecPrev
                    , lpQrec->ulrecNext
                    , (unsigned long)(lpQrec->usStatus)
                    , (unsigned long)(lpQrec->uchRefPri)
                    , (unsigned long)(lpQrec->uchHintPri)
                    , (unsigned long)(lpQrec->uchHintFlags)
                    , lpQrec->ulrecDirEntry

            );

        (lpfnPrintProc)(vchPrintBuff);
    }
}

VOID PrintShareRec(
    unsigned ulRec,
    LPSHAREREC lpSR,
    PRINTPROC lpfnPrintProc
    )
{
    int iRet=0;

    if (lpfnPrintProc)
    {
        iRet += wsprintfA(vchPrintBuff+iRet,"Type=%c Flags=%xh hShare=%lxh Root=%0lxh status=%xh Share=%s \r\n"
             , lpSR->uchType, (unsigned)lpSR->uchFlags, ulRec, lpSR->ulidShadow
             , lpSR->uStatus, lpSR->rgPath);
        iRet += wsprintfA(vchPrintBuff+iRet,"Hint: HintFlags=%xh\r\n",
                     (unsigned)(lpSR->uchHintFlags));

        iRet += wsprintfA(vchPrintBuff+iRet, "\r\n");

        (lpfnPrintProc)(vchPrintBuff+iRet);
    }
}

VOID PrintFilerec(
    unsigned ulRec,
    LPFILERECEXT    lpFR,
    unsigned    ulSpaces,
    PRINTPROC lpfnPrintProc
    )
{
    int i;
    int iRet=0;

    if (lpfnPrintProc)
    {
        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);

        iRet += wsprintfA(vchPrintBuff+iRet,"Type=%c Flags=%xh Inode=%0lxh status=%xh 83Name=%ls size=%ld attrib=%lxh \r\n",
            lpFR->sFR.uchType, (unsigned)lpFR->sFR.uchFlags, lpFR->sFR.ulidShadow,
            lpFR->sFR.uStatus, lpFR->sFR.rgw83Name, lpFR->sFR.ulFileSize, lpFR->sFR.dwFileAttrib);

        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);

        iRet += wsprintfA(vchPrintBuff+iRet,"time: hi=%lxh lo=%lxh orgtime: hi=%lxh lo=%lxh\r\n"
                     , lpFR->sFR.ftLastWriteTime.dwHighDateTime,lpFR->sFR.ftLastWriteTime.dwLowDateTime
                     , lpFR->sFR.ftOrgTime.dwHighDateTime,lpFR->sFR.ftOrgTime.dwLowDateTime);

        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);

        iRet += wsprintfA(vchPrintBuff+iRet,"Hint: HintFlags=%xh, RefPri=%d, HintPri=%d AliasInode=%0lxh \r\n",
                     (unsigned)(lpFR->sFR.uchHintFlags)
                     , (int)(lpFR->sFR.uchRefPri)
                     , (int)(lpFR->sFR.uchHintPri)
                     , lpFR->sFR.ulidShadowOrg);

        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);

        iRet += wsprintfA(vchPrintBuff+iRet,"LFN=%-14ls", lpFR->sFR.rgwName);

        for(i = 0; i < OvfCount(lpFR); ++i)
        {
            iRet += wsprintfA(vchPrintBuff+iRet,"%-74s", &(lpFR->sFR.ulidShadow));
        }

        iRet += wsprintfA(vchPrintBuff+iRet,"\r\n");

        (lpfnPrintProc)(vchPrintBuff);
    }
}

int
PrintSpaces(
    LPSTR   lpBuff,
    unsigned    ulSpaces
    )
{
    unsigned i;
    int iRet=0;

    for (i=0; i< ulSpaces; ++i)
    {
        iRet += wsprintfA(lpBuff+iRet," ");
    }
    return iRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\strings.c ===
//
// Global strings here.
//

/******************* Includes and Controlling Defines ***********************/
#include "pch.h"

/***************  Initialized data ****************************************/

// #pragma data_seg(DATASEG_READONLY)

const _TCHAR szReintClass[] = _T("AgentClass");	// main window class name
const _TCHAR szReintWnd[] = _T("Agent");			// main window name
const _TCHAR szShadowDevice[] = _T("\\\\.\\shadow");
const _TCHAR szCreateError[] = _T("Couldn't create shadow device file");
const _TCHAR szCreateOK[] = _T("Created shadow device file");
const _TCHAR szConnectError[] = _T("Couldn't register with shadow device");
const _TCHAR szConnectOK[] = _T("Registered with shadow device");
const _TCHAR szPanic[]=_T("Panic");
const _TCHAR szTimeDateFormat[] = _T("\r\n%02d:%02d:%02.2d %02d-%02d-%02d\r\n");
const _TCHAR szSeekErr[]=_T("Seek Error");
const _TCHAR szReadErr[]=_T("Read Error");
const _TCHAR szWriteErr[]=_T("Write Error");
const _TCHAR szMinSparseFillPri[]=_T("SparseFillAbove");
const _TCHAR sz386Enh[]=_T("386enh");
const _TCHAR szSystemIni[]=_T("system.ini");
const _TCHAR szConflictMsg[]=_T("Errors/Conflicts while merging! Check c:\\merge.log");
const _TCHAR szLogFile[]=_T("C:\\merge.log");
const _TCHAR szConflictDir[]=_T("C:\\ConflictsWhileMerging");
const _TCHAR szSlash[]=_T("\\");
const _TCHAR szOpsInProgress[] = _T("Close all open files on %s");
const _TCHAR szShadowReg[]=_T("System\\CurrentControlSet\\Services\\VxD\\Shadow");
const _TCHAR szExclHint[]=_T("ExcludeExtensions");
const _TCHAR szExclDelim[]=_T(", ;");
const _TCHAR szDoLogCopy[]=_T("CopyLogToServer");

// #pragma data_seg()

const _TCHAR * vszReintClass=szReintClass;
const _TCHAR * vszReintWnd=szReintWnd;
const _TCHAR * vszShadowDevice=szShadowDevice;
const _TCHAR * vszCreateError=szCreateError;
const _TCHAR * vszCreateOK=szCreateOK;
const _TCHAR * vszConnectError=szConnectError;
const _TCHAR * vszConnectOK=szConnectOK;
const _TCHAR * vszPanic=szPanic;
const _TCHAR * vszTimeDateFormat=szTimeDateFormat;
const _TCHAR * vszSeekErr=szSeekErr;
const _TCHAR * vszReadErr=szReadErr;
const _TCHAR * vszWriteErr=szWriteErr;
const _TCHAR * vszMinSparseFillPri=szMinSparseFillPri;
const _TCHAR * vsz386Enh=sz386Enh;
const _TCHAR * vszSystemIni=szSystemIni;
const _TCHAR * vszConflictMsg=szConflictMsg;
const _TCHAR * vszLogFile=szLogFile;
const _TCHAR * vszConflictDir=szConflictDir;
const _TCHAR * vszSlash=szSlash;
const _TCHAR * vszOpsInProgress=szOpsInProgress;
const _TCHAR * vszShadowReg=szShadowReg;
const _TCHAR * vszExclHint=szExclHint;
const _TCHAR * vszExclDelim=szExclDelim;
const _TCHAR * vszDoLogCopy=szDoLogCopy;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\traynoti.h ===
extern HANDLE vhinstCur;			// current instance from reint.c

BOOL Tray_Delete(HWND hDlg);
BOOL Tray_Add(HWND hDlg, UINT uIndex);  // You should use Tray_Modify instead.
BOOL Tray_Modify(HWND hDlg, UINT uIndex, LPTSTR pszTip);

#define TRAY_NOTIFY		(WM_APP+100)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\utils.h ===
#include "shdcom.h"
#include "oslayeru.h"

LPTSTR PUBLIC LpGetServerPart(LPTSTR, LPTSTR, int);
LPTSTR PUBLIC LpGetNextPathElement(LPTSTR, LPTSTR, int);
LPTSTR PUBLIC GetLeafPtr(LPTSTR);

#if 0
BOOL PUBLIC FMatchFile(LPTSTR lpFileName, LPBYTE lpList);
BOOL PUBLIC ExtnMatch(LPTSTR, LPTSTR);
BOOL PUBLIC PrefixMatch(LPTSTR, LPTSTR);
#endif

void DebugPrint(char *szFmt, ...);

LPTSTR
LpBreakPath(
	LPTSTR lpszNextPath,
	BOOL fFirstTime,
	BOOL *lpfDone
	);

void
RestorePath(
	LPTSTR	lpszPtr
);

BOOL
FindCreateShadowFromPath(
	LPCTSTR	lpszFile,
	BOOL	fCreate,	// create if necessary
	LPWIN32_FIND_DATA lpsFind32,
	LPSHADOWINFO lpSI,
	BOOL	*lpfCreated
);

BOOL
IsShareReallyConnected(
    LPCTSTR  lpszShareName
);

BOOL
AnyActiveNets(
    BOOL *lpfSlowLink
    );

BOOL
GetWideStringFromRegistryString(
    IN  LPSTR   lpszKeyName,    // registry key
    IN  LPSTR   lpszParameter,  // registry value name
    OUT LPWSTR  *lplpwzList,    // wide character string
    OUT LPDWORD lpdwLength      // length in bytes
    );

LPTSTR
GetTempFileForCSC(
    LPTSTR  lpszBuff
    );

BOOL
SetRegValueDWORDA(
    IN  HKEY    hKey,
    IN  LPCSTR  lpSubKey,
    IN  LPCSTR  lpValueName,
    IN  DWORD   dwValue
    );

BOOL
QueryRegValueDWORDA(
    IN  HKEY    hKey,
    IN  LPCSTR  lpSubKey,
    IN  LPCSTR  lpValueName,
    OUT LPDWORD lpdwValue
    );

BOOL
DeleteRegValueA(
    IN  HKEY    hKey,
    IN  LPCSTR  lpSubKey,
    IN  LPCSTR  lpValueName
    );
BOOL
GetDiskSizeFromPercentage(
    LPSTR       lpszDir,
    unsigned    uPercent,
    DWORD       *lpdwSize,
    DWORD       *lpdwClusterSize
    );


BOOL
InitValues(
    LPSTR   lpszDBDir,
    DWORD   cbDBDirSize,
    LPDWORD lpdwDBCapacity,
    LPDWORD lpdwClusterSize
    );

BOOL
QueryFormatDatabase(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\ui.c ===
/*

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ui.c

Abstract:

    This file contains the mainloop for the Client Side Caching agent. The code has to mesh
    with the system startup, logon and logoff and these are different on NT and win9x.
    This file and all others in the reint directory have been written such that for NT they
    call the wide character win32 APIs while for win9x they call ANSI APIs.

    The agent runs as a thread in the context of winlogon.exe. CSCDLL.DLL resgisters itself
    to recieve a call from winlogon when a user logs on. The call is on a separate thread and
    is impersonated as the logged on user. This thread eventually calls reint_winmain which
    loops for ever, till the system is about to shutdown.

    file ntstuff.c contains the interface which is exposed to winlogon. On every logon
    this interface gets called, at which point, all the info necessary to impersonate the
    logged on user is obtained and kept in an in memory list of logged on users. The list
    also contains the SID for Local System.

    For doing sparse filling and Inode, the agent looks in the database to see which of
    the users on the list have read access right for the given file and uses that to fill
    the file.


Author(s):

    Trent Gray Donald/Felix Andrews/Shishir Pardikar

    1-9-1994

Environment:

    Win32 (user-mode) DLL

Revision History:

    NT source formatting
        
        Shishir Pardikar 2-19-97
    
    Winlogon Integration
    
        Shishir Pardikar 10-19-97

    

--*/

#include "pch.h"
#pragma hdrstop

#include "resource.h"
#include "traynoti.h"
#include <dbt.h>
#include "lib3.h"
#include "reint.h"
#include "utils.h"
#include "strings.h"
#include "cscuiext.h"
#include <userenv.h>
#include <safeboot.h>

//
// defines/macros useed in this file
//


#if (_TCHAR != wchar_t)
#error "Bad _TCHAR definition"
#endif

#if (_TEXT != L)
#error "BAD _Text definiton"
#endif

// Timer to deal with double clicks and stuff like that.
#define TRAY_ID 100

// timer ID to make sure the Tray icon appears!
#define TIMER_ADD_TRAY 101

#define minOfFour(one,two,three,four) (min(min(one,two),min(three,four)))

#define    FILE_OPEN_THRESHOLD    16
#define     CI_LOGON    1
#define     CI_LOGOFF   2
// #define     STWM_CSCCLOSEDIALOGS            (WM_USER + 212)

typedef HWND (WINAPI *CSCUIINITIALIZE)(HANDLE hToken, DWORD    dwFlags);
typedef LRESULT (WINAPI *CSCUISETSTATE)(UINT uMsg, WPARAM wParam, LPARAM lParam);

#define    REG_VALUE_NT_BUILD_NUMBER        _TEXT("NTBuildNumber")
#define    REG_VALUE_DISABLE_AUTOCHECK      _TEXT("DisableAutoCheck")
#define    REG_KEY_NETCACHE_SETTINGS        _TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\NetCache")

#define     AGENT_ALIVE                 (vfCSCEnabled && !vfStopRecieved)
#define     AGENT_ALIVE_AND_ACTIVE      (AGENT_ALIVE && !vfAgentQuiet)
#define     AGENT_ALIVE_AND_HAVE_NET    (AGENT_ALIVE && vcntNetDevices)
#define     FIVE_MINUTES    (5 * 1000 * 60)


#define MAX_LIST_SIZE   1024

#define PI_LITELOAD     0x00000004      // Lite load of the profile (for system use only)

//
// Data declarations/definitions
//


#pragma data_seg(DATASEG_READONLY)

_TCHAR vszKernel32[] = _TEXT("KERNEL32.DLL");
_TCHAR vszOpenVxDHandle[]=_TEXT("OpenVxDHandle");

static const _TCHAR szWkssvcToAgentStartEvent[] = _T("WkssvcToAgentStartEvent");
static const _TCHAR szWkssvcToAgentStopEvent[] = _T("WkssvcToAgentStopEvent");
static const _TCHAR szAgentToWkssvcEvent[] = _T("AgentToWkssvcEvent");
static const _TCHAR szAgentExistsEvent[] = _T("AgentExistsEvent");

static const _TCHAR vtzCSCUI[] = _TEXT("cscui.dll");
static const char vszCSCUIInitialize[] = "CSCUIInitialize";
static const char vszCSCUISetState[] = "CSCUISetState";
static const _TCHAR vtzDefaultExclusionList[] = L" *.SLM *.MDB *.LDB *.MDW *.MDE *.PST *.DB?";

DWORD vdwManualFileDetectionCount = 0;

#pragma data_seg()

#pragma data_seg(DATASEG_PERINSTANCE)

static _TCHAR vrgchBuff[1024], vrwBuff[4096], vrgchSrcName[350], vrgchDstName[300];
static HMENU g_MainMenu;
char    vszDBDir[MAX_PATH]={0};
DWORD   vdwDBCapacity = 0, vdwClusterSize = 0;
DWORD   vdwRedirStartTime = 0;
AssertData;
AssertError;

#pragma  data_seg()

HWND    vhwndMain = NULL;            // main window

BOOL vfAgentEnabledCSC=FALSE;   // this is used to detect whether the remoteboot enabled CSC
BOOL vfCSCEnabled=FALSE;        // csc is enabled
BOOL vfOKToEnableCSC = FALSE;
HANDLE vhProfile = NULL;
#pragma data_seg()

BOOL    vfFormatDatabase = FALSE;   // set at init time

#ifdef DEBUG
ULONG ReintKdPrintVector = REINT_KDP_GOOD_DEFAULT;
ULONG ReintKdPrintVectorDef = REINT_KDP_GOOD_DEFAULT;
#endif

unsigned ulFreePercent=30;       // Amount of % cache freeing to be attempted
                                 // if the cache is full

UINT vcntNetDevices = 0;        // count of net devices
BOOL g_bShowMergeIcon;          // menu icon
BOOL vfAgentRegistered = FALSE;
BOOL vfClassRegistered = TRUE;
BOOL vfMerging = FALSE;

BOOL    vfAgentQuiet = FALSE;
DWORD   vdwAgentThreadId = 0;
DWORD   vdwAgentSessionId = 0xffff;
GLOBALSTATUS vsGS;
BOOL    allowAttempt;                    // set if we want to allow AttemptCacheFill now

//
// event handles of named events shared between usermode and kernel mode
//
HANDLE      heventPerSess = NULL;
HANDLE      heventSharedFill = NULL;
HANDLE      vhMutex = NULL;
DWORD       dwVxDEvent = 0;    // handle for VxD event obtained from heventShared
HANDLE      vhShadowDBForEvent = INVALID_HANDLE_VALUE;

extern     LPCONNECTINFO  vlpLogonConnectList;
extern     _TCHAR * vrgchCRLF;
HWND     vhdlgShdLogon=NULL;

// net start-stop vars
HANDLE  heventWkssvcToAgentStart = NULL;// event set by Workstation service on redir start
HANDLE  heventWkssvcToAgentStop = NULL; // event set by Workstation service on redir stop
HANDLE  heventAgentToWkssvc = NULL;     // event used by agent to respond to wkssvc to tell it that
                                        // it is OK to stop the redir
HANDLE  heventShutDownAgent = NULL;
HANDLE  heventShutDownThread = NULL;
HANDLE  hCopyChunkThread = NULL;
DWORD   vdwCopyChunkThreadId = 0;
BOOL    vfRedirStarted  = -1;

BOOL    vfStartRecieved = FALSE;
BOOL    vfStopRecieved = FALSE;

BOOL    fAgentShutDownRequested = FALSE;
BOOL    fAgentShutDown = FALSE;


// CSCUI related

HANDLE  vhlibCSCUI = NULL;
CSCUIINITIALIZE vlpfnCSCUIInitialize = NULL;
CSCUISETSTATE   vlpfnCSCUISetState = NULL;
BOOL    vfShowingOfflineDlg = FALSE;
ULONG   uOldDatabaseErrorFlags = 0;


//
// Function Prototypes
//




LRESULT
CALLBACK
ReInt_WndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

DWORD ReInt_AttemptCacheFill(
    LPVOID  lpContext
    );

BOOL
ReInt_RefreshTray(
    BOOL bHide
    );

BOOL
ReInt_AnythingToMerge(
    VOID
    );

int InitMaint(
    VOID
    );  // Initialize the maintenance subsystem

BOOL
CheckCSCDatabaseVersion(
    BOOL    *lpfWasDirty
);

BOOL
UpgradeCSCDatabase(
    LPSTR   lpszDir
);

BOOL
IsNetConnected(
    VOID
    );

int
ExtractSpaceStats(
    IN GLOBALSTATUS     *lpsGS,
    OUT unsigned long   *lpulMaxSpace,
    OUT unsigned long   *lpulCurSpace,
    OUT unsigned long   *lpulFreeSpace
    );

int
InitCacheSize(
    VOID
    );

int
SetDefaultSpace(
    LPSTR lpShadowDir
    );

BOOL
NEAR
PASCAL
ReInt_InitApp(
    HANDLE hInstance
    );

BOOL
NEAR
PASCAL
ReInt_InitInstance(
    HANDLE hInstance,
    HANDLE hPrevInstance,
    int cmdShow);

BOOL
NEAR
PASCAL
ReInt_TermInstance(
    VOID
    );

int
DoEventProcessing(
    VOID
);

BOOL
FindCreateDBDir(
    BOOL    *lpfCreated,
    BOOL    fCleanup    // empty the directory if found
    );

BOOL
CreatePerSessSyncObjects(
    VOID
    );

BOOL
CreateSharedFillSyncObjects(
    VOID
    );

BOOL
EnableCSC(
    VOID
    );
BOOL
DisableCSC(
    VOID
    );
BOOL
IsCSCOn(
    VOID
    );

VOID
ProcessStartStopAgent(
    VOID
    );

BOOL
FStartAgent(
    VOID
    );

int
StartStopCheck(
    VOID
    );

BOOL
Reint_RegisterAgent(
    VOID
    );

VOID
Reint_UnregisterAgent(
    VOID
    );

BOOL
QueryEnableCSC(
    VOID
    );

VOID
QueryMiscRegistryValues(
    VOID
    );


BOOL
CreateStartStopEvents(
    VOID
    );

VOID
DestroyStartStopEvents(
    VOID
    );


BOOL
ProcessNetArrivalMessage(
    VOID
    );

BOOL
ProcessNetDepartureMessage(
    BOOL    fInvokeAutoDial
    );

BOOL
WINAPI
CheckCSC(
    LPSTR,
    BOOL
    );

BOOL
ReportShareNetArrivalDeparture(
    BOOL    fOneServer,
    HSHARE hShare,
    BOOL    fInvokeAutoDial,
    BOOL    fArrival
    );

LRESULT
ReportEventsToSystray(
    DWORD   dwMessage,
    WPARAM  dwWParam,
    LPARAM  dwLParam
    );

BOOL
CheckServerOnline(
    VOID
    );

VOID
SetAgentShutDown(
    VOID
    );


BOOL
IsAgentShutDownRequested(
    VOID
    );

BOOL
LaunchSystrayForLoggedonUser(
    VOID
    );

BOOL
ImpersonateALoggedOnUser(
    VOID
    );

VOID
ReportCreateDelete(
    HSHADOW hDir,
    HSHADOW hShadow,
    BOOL    fCreated
    );

BOOL
GetNameOfServerGoingOfflineEx(
    HANDLE  hShadowDB,
    _TCHAR  **lplptzServerName,
    DWORD   *lpdwSize,
    BOOL    *lpfAllocated
    );

BOOL
AreAnyServersOffline(
    VOID);

BOOL
IsPersonal(
    VOID);

BOOL
IsMultipleUsersEnabled(
    void);

BOOL
IsFastUserSwitchingEnabled(
    VOID);

BOOL 
AreConnectionsAllowed (
	VOID);

BOOL 
CanCSCLivewithTS(
	VOID);

BOOL
IsWorkstation(
	VOID);

//
// Functions
//

int
PASCAL
ReInt_WinMain(
    HANDLE hInstance,
    HANDLE hPrevInstance,
    LPSTR lpszCommandLine,
    int cmdShow)
/*++
Routine Description:
    This is the mainloop for the agent processing. It "schedules" different agent activities
    based on either an event set by the rdr or by predefined time intervals for these
    activities. The activities include

    a) Filling partially filled files
    b) checking for stale files
    c) maintaining space within limits
    d) reducing reference priority of all files for every FILE_OPEN_THRESHOLD fileopens
--*/
{
    MSG     msg;
    DWORD   result;                   // result from Wait...
    BOOL    done = FALSE;             // to detect a quit message.
    BOOL    staleInited = FALSE;      // ensure that Staleness code runs
    DWORD   timeToWait;
    DWORD   nextGlobalStatusTime;
    DWORD   newTick;
    DWORD   nextSkipPurgeTime;        // to figure out if we should perform an action.
    HANDLE  hT[4];

    if (hPrevInstance) {
        return FALSE;
    }


    vdwAgentThreadId = GetCurrentThreadId();

    ReintKdPrint(MAINLOOP, ("Agent(1):----------ReInt_WinMain----------\n"));

    if (ReInt_InitApp(hInstance) && ReInt_InitInstance(hInstance, hPrevInstance, cmdShow)) {
        if (!AnyActiveNets(NULL))
            vcntNetDevices = 1;
        newTick = GetTickCount();
        nextGlobalStatusTime = newTick + WAIT_INTERVAL_GLOBALSTATUS_MS;
        nextSkipPurgeTime = newTick + WAIT_INTERVAL_SKIP_MS;
        hT[0] = heventPerSess;
        hT[1] = heventWkssvcToAgentStart;
        hT[2] = heventWkssvcToAgentStop;
        hT[3] = heventShutDownAgent;
        StartStopCheck();
        ProcessStartStopAgent();
        while (!done) {
            timeToWait = INFINITE;
            ReintKdPrint(MAINLOOP, ("Agent(1): Wait INFINITE\n"));
            result = WaitForMultipleObjects(4, hT, FALSE, timeToWait);
            newTick=GetTickCount();
            if ((result == WAIT_OBJECT_0) || (result == (WAIT_OBJECT_0+4))) {
                ReintKdPrint(MAINLOOP, ("Agent(1):Event %d was fired or ReadGlobalStatus set\n",
                                            result));
                DoEventProcessing();
                // During event processing, we also do globalstatus check and
                // any other maintenance tasks. So let us restart the timer for
                // globalstatus
                nextGlobalStatusTime = newTick + WAIT_INTERVAL_GLOBALSTATUS_MS;
            } else if ((result == (WAIT_OBJECT_0+1)) || (result  == (WAIT_OBJECT_0+2))) {
                ReintKdPrint(MAINLOOP, ("Agent(1): Received startstop \r\n"));
                vfStartRecieved = (result == (WAIT_OBJECT_0+1));
                vfStopRecieved = (result  == (WAIT_OBJECT_0+2));
                ProcessStartStopAgent();
                continue;
            } else if (result == (WAIT_OBJECT_0+3)) {
                ReintKdPrint(MAINLOOP, ("Agent(1):Agent ShutdownRequested, terminating agent\r\n"));
                SetAgentShutDown();
                goto AllDone;
            }
            // do work only if CSC enabled
            if (vfCSCEnabled && AGENT_ALIVE_AND_ACTIVE) {
                // reset the staleness check time interval
                if(((int)(newTick - nextSkipPurgeTime)) >= 0) {
                    // Unmark failures for servers that are known to be
                    // disconnected and connection has not been attempted on them
                    // for the last WAIT_INTERVAL_SKIP_MS milliseconds
                    PurgeSkipQueue(FALSE, 0, 0, 0);
                    vhcursor = NULL;
                    nextSkipPurgeTime = newTick + WAIT_INTERVAL_SKIP_MS;
                    ReintKdPrint(MAINLOOP, ("Agent(1):nextSkipPurgeTime = %d\n", nextSkipPurgeTime));
                }
                if(((int)(newTick - nextGlobalStatusTime)) >= 0) {
                    nextGlobalStatusTime = newTick + WAIT_INTERVAL_GLOBALSTATUS_MS;
                    ReintKdPrint(MAINLOOP,("Agent(1):nextGlobalStatusTime = %d\n", nextGlobalStatusTime));
                    // We haven't gotten an event for sometime now from the
                    // rdr, so let us go look what is up with him
                    DoEventProcessing();
                    // reset the globalstatus time interval
                    nextGlobalStatusTime = newTick + WAIT_INTERVAL_GLOBALSTATUS_MS;
                }
            }
        }
    }
AllDone:
    // do termination processing
    ReintKdPrint(MAINLOOP, ("Agent(1):Exiting mainloop \r\n"));
    ReInt_TermInstance();
    return 0;
}

BOOL
NEAR
PASCAL
ReInt_InitApp(
    HANDLE hInstance
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:

--*/
{
    if (
        CreateSharedFillSyncObjects()
            &&
        CreatePerSessSyncObjects()
    ) {
        if (!CreateStartStopEvents()) {
            ReintKdPrint(BADERRORS, ("Agent:Failed to create Sync events \r\n"));
            return FALSE;
        }
        if (!(hCopyChunkThread = CreateThread(
                                    NULL,
                                    8192,
                                    ReInt_AttemptCacheFill,
                                    NULL,
                                    0,
                                    &vdwCopyChunkThreadId))
        ) {
            ReintKdPrint(BADERRORS, ("Agent:Failed to create copychunk thread\r\n"));
            return FALSE;
        }
        return TRUE;
    } else {
        ReintKdPrint(BADERRORS, ("Failed to Create shared events\n"));
        return FALSE;
    }
}

BOOL
NEAR
PASCAL
ReInt_InitInstance(
    HANDLE hInstance,
    HANDLE hPrevInstance,
    int cmdShow)
/*++

Routine Description:

Parameters:

Return Value:

Notes:

--*/
{
    BOOL    fRet;

    fRet = InitValues(vszDBDir, sizeof(vszDBDir), &vdwDBCapacity, &vdwClusterSize);

    Assert(fRet);

    fAgentShutDown = FALSE;
    fAgentShutDownRequested = FALSE;

    if (!(vfOKToEnableCSC = QueryEnableCSC()))
    {
        ReintKdPrint(INIT, ("cscdll: Registry says disable CSC, not enabling\r\n"));
    }

    vfFormatDatabase = QueryFormatDatabase();

    ReintKdPrint(INIT, ("Format=%d\n", vfFormatDatabase));

    return (TRUE);
}

/*--------------------------------------------------------------------------*/
BOOL
NEAR
PASCAL
ReInt_TermInstance(
    VOID
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:

--*/
{

    DisableCSC();

    if (heventPerSess) {
        CloseHandle(heventPerSess);
        heventPerSess = NULL;
    }

    if (heventSharedFill) {
        CloseHandle(heventSharedFill);
        heventSharedFill = NULL;
    }

    PurgeSkipQueue(TRUE, 0, 0, 0);

    if (vhMutex) {
        ReleaseMutex(vhMutex);
        vhMutex = NULL;
    }

    // tell the workstation service that the agent is
    // going away
    if (heventAgentToWkssvc) {
        SetEvent(heventAgentToWkssvc);
    }

    if (heventShutDownThread) {
        DWORD   dwRet;

        //Assert(hCopyChunkThread);
        SetEvent(heventShutDownThread);

        //If CopyChunk thread was created then cleanup - bug 562543
        if (hCopyChunkThread) {
            dwRet = WaitForSingleObject(hCopyChunkThread, WAIT_INTERVAL_ATTEMPT_MS);
            ReintKdPrint(MAINLOOP, ("wait on thread handle %d \r\n", dwRet));
            CloseHandle(hCopyChunkThread);
        }
    }

    DestroyStartStopEvents();

    if (vfClassRegistered) {
        UnregisterClass(vszReintClass, vhinstCur);
        vfClassRegistered = FALSE;

    }
    return TRUE;
}


DWORD
ReInt_AttemptCacheFill(
    LPVOID  lpParams
    )
/*++
Routine Description:

    A wrapper for AttemptCacheFill. On NT many agent threads can do copychunk
    simultaneously, so there is no need to do mutual exclusion.
--*/
{
    DWORD nextCheckServerOnlineTime;
    DWORD dwWaitResult;
    DWORD dwWaitResult2;
    DWORD dwWaitTime;
    DWORD newTick;
    ULONG nFiles = 0;
    ULONG nYoungFiles = 0;
    HANDLE hT[2];
    DWORD dwManualFileDetectionCount = 0xffff;

    // on NT we run as a winlogon thread which has a very high process priority
    // so we have to get to the lowest
    if(!SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_LOWEST)) {
        ReintKdPrint(BADERRORS, ("RE: SetTheadPriority failed, reason: 0x%08x\n", GetLastError()));
    }

    ReintKdPrint(MAINLOOP, ("Agent(2): Launched.\n"));

    hT[0] = heventShutDownThread;
    hT[1] = heventSharedFill;

    nextCheckServerOnlineTime = GetTickCount() +
                                WAIT_INTERVAL_CHECK_SERVER_ONLINE_MS +
                                WAIT_INTERVAL_FILL_THROTTLE_MS;
    for (;;) {
        ReintKdPrint(MAINLOOP, ("Agent(2): nYoungFiles=%d\n", nYoungFiles));
        if (nYoungFiles > 0 || AreAnyServersOffline() == TRUE) {
            dwWaitTime = WAIT_INTERVAL_CHECK_SERVER_ONLINE_MS;
            ReintKdPrint(MAINLOOP, ("Agent(2): Wait 8 min\n"));
        } else {
            dwWaitTime = INFINITE;
            ReintKdPrint(MAINLOOP, ("Agent(2): Wait INFINITE\n"));
        }
        dwWaitResult = WaitForMultipleObjects(2, hT, FALSE, dwWaitTime);
        if (dwWaitResult == (WAIT_OBJECT_0+0)) {  // shutdown event
            ReintKdPrint(MAINLOOP, ("Agent(2): Termination event...\n"));
            if (AGENT_ALIVE && vdwAgentSessionId == 0)
                CSCPurgeUnpinnedFiles(100, &nFiles, &nYoungFiles);
            goto AllDone;
        }
        ReintKdPrint(MAINLOOP, ("Agent(2): Wait 2 min\n"));
        dwWaitResult2 = WaitForSingleObject(heventShutDownThread, WAIT_INTERVAL_FILL_THROTTLE_MS);
        if (dwWaitResult2 == (WAIT_OBJECT_0+0)) {  // shutdown event
            ReintKdPrint(MAINLOOP, ("Agent(2): Termination event...\n"));
            if (AGENT_ALIVE && vdwAgentSessionId == 0)
                CSCPurgeUnpinnedFiles(100, &nFiles, &nYoungFiles);
            goto AllDone;
        }
        if (dwWaitResult == WAIT_TIMEOUT) {  // timeout
            if (AGENT_ALIVE) {
                ReintKdPrint(MAINLOOP, ("Agent(2): Timeout...\n"));
                AttemptCacheFill(0, DO_ONE_OBJECT, FALSE, CSC_INVALID_PRINCIPAL_ID, NULL, 0);
                if (vdwAgentSessionId == 0) {
                    GetManualFileDetectionCounter(INVALID_HANDLE_VALUE,&dwManualFileDetectionCount);
                    vdwManualFileDetectionCount = dwManualFileDetectionCount;
                    CSCPurgeUnpinnedFiles(100, &nFiles, &nYoungFiles);
                }
            }
        } else if (dwWaitResult == (WAIT_OBJECT_0+1)) { // kernel told us to run
            if (AGENT_ALIVE) {
                ReintKdPrint(MAINLOOP, ("Agent(2): Shared Event signal...\n"));
                AttemptCacheFill(0, DO_ONE_OBJECT, FALSE, CSC_INVALID_PRINCIPAL_ID, NULL, 0);
                GetManualFileDetectionCounter(INVALID_HANDLE_VALUE,&dwManualFileDetectionCount);
                if (dwManualFileDetectionCount != vdwManualFileDetectionCount) {
                    vdwManualFileDetectionCount = dwManualFileDetectionCount;
                    CSCPurgeUnpinnedFiles(100, &nFiles, &nYoungFiles);
                }
            }
        }
        newTick = GetTickCount();
        if(((int)(newTick - nextCheckServerOnlineTime)) >= 0) {
            if (AGENT_ALIVE) {
                // check whether one or more shares that are presently in
                // disconnected state have come online.
                // If they are, report them to the UI
                CheckServerOnline();
                nextCheckServerOnlineTime = newTick +
                                            WAIT_INTERVAL_CHECK_SERVER_ONLINE_MS +
                                            WAIT_INTERVAL_FILL_THROTTLE_MS;
            }
        }
    }
AllDone:
    ReintKdPrint(MAINLOOP, ("Agent(2):Thread exit\n"));
    return 0;
}

VOID
ReInt_DoFreeShadowSpace(
    GLOBALSTATUS    *lpsGS,
    int fForce
    )
/*++

Routine Description:
         The function is called from the main
         loop every "n" minutes to see if we are running out of space.
         If so, it tries to free up some percentage of the shadow cache.

Parameters:
   fForce:  0 => do it only if we don't have space and we are
                 on the net
            1 => do it if we are on the net

            2 => just do it


Return Value:

Notes:

--*/
{
    ULONG ulMax;
    ULONG ulCur;
    ULONG ulFree;
    WIN32_FIND_DATA sFind32;
    LPCOPYPARAMS lpCP = NULL;

    if (!lpsGS) {
        lpsGS = &vsGS;
    }

    ReintKdPrint(MERGE, ("ReInt_DoFreeShadowSpace(1)\r\n"));

    // Get space stats
    if (ExtractSpaceStats(lpsGS, &ulMax, &ulCur, &ulFree) >= 0){
        ReintKdPrint(MERGE, ("ReInt_DoFreeShadowSpace(2)\r\n"));
        // do we have space and are not forced to free up?
        if ((fForce < 1) && (ulFree > 0)){
             ReintKdPrint(MERGE, ("ReInt_DoFreeShadowSpace(3)\r\n"));
             return;
        }
        //
        // We are forced or there is no space
        //
        // NB!!!! We check for a net device and if it exists we assume that
        // it is OK to freespace on all shares.
        if ((fForce < 2) && !vcntNetDevices){
            ReintKdPrint(MERGE, ("ReInt_DoFreeShadowSpace: No net, aborting \r\n"));
            return;
        }

        // Maximum force, or all conditions for freeing are being met
        // ie. there is no space and we are on the net
        memset(&sFind32, 0, sizeof(sFind32));

        // NB the math below is done to avoid overflow.
        // The consequence is that the resulting value is less than
        // the percentage of cache space to be freed.
        ulFree = (ulMax/100) * ulFreePercent;

        // if the cached data is more than the earmarked space
        // then add the extra too.
        if (ulCur > ulMax) {
            ulFree += (ulCur - ulMax);
        }
        DosToWin32FileSize(ulFree, &sFind32.nFileSizeHigh, &sFind32.nFileSizeLow);
        ReintKdPrint(MERGE, ("ReInt_DoFreeShadowSpace(): freeing %d\n", ulFree));
        ReintKdPrint(MERGE, ("                nFileSizeLow=%d\n", sFind32.nFileSizeLow));
        FreeShadowSpace(INVALID_HANDLE_VALUE,
                        sFind32.nFileSizeHigh,
                        sFind32.nFileSizeLow,
                        FALSE);  // don't clear all
        ReintKdPrint(MERGE, ("ReInt_DoFreeShadowSpace(): ending.\n"));
    }
}

/*********************** Merging related routines **************************/

//
// DoubleClick/Menu handler.
//
VOID
ReInt_DoNetProp(
    VOID
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:

--*/
{
    HINSTANCE hLib=LoadLibrary(_TEXT("shhndl.dll"));
    ReintKdPrint(BADERRORS, ("LoadLibrary of shhndl returned %d\n",hLib));
    if(hLib)
    {
        FARPROC lpFn=GetProcAddress(hLib,"NetProp_Create");
        ReintKdPrint(BADERRORS, ("NetProp_Create is 0x%x\n",lpFn));
        if(lpFn)
            lpFn();
        FreeLibrary(hLib);
    }

}

//
//  Command Handler
//
BOOL
NEAR
PASCAL
ReInt_CommandHandler(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:

--*/
{
    unsigned long ulSwitch, ulSav;
    switch (wParam)
    {
        case IDM_PROPERTIES:
            ReInt_DoNetProp();
        break;

        case IDM_SHADOW_LOG:
        {
            if(ShadowSwitches(INVALID_HANDLE_VALUE, &ulSwitch, SHADOW_SWITCH_GET_STATE))
            {
                ulSav = (ulSwitch & SHADOW_SWITCH_LOGGING);
                ulSwitch = SHADOW_SWITCH_LOGGING;
                if (ShadowSwitches(INVALID_HANDLE_VALUE, &ulSwitch, (ulSav)?SHADOW_SWITCH_OFF:SHADOW_SWITCH_ON))
                    CheckMenuItem(GetMenu(hwnd), IDM_SHADOW_LOG , MF_BYCOMMAND|((ulSav)?MF_UNCHECKED:MF_CHECKED));
            }
        }
        break;

        case IDM_LOG_COPYING:
        {
#ifdef TEST
            HKEY hKey=0;
            _TCHAR szDoCopy[MAX_NAME_LEN];



            vfLogCopying = vfLogCopying?0:1;
            CheckMenuItem(GetMenu(hwnd), IDM_LOG_COPYING , MF_BYCOMMAND|((vfLogCopying)?MF_UNCHECKED:MF_CHECKED));

            if(RegOpenKey(HKEY_LOCAL_MACHINE, REG_KEY_CSC_SETTINGS, &hKey) !=  ERROR_SUCCESS)
            {
                ReintKdPrint(BADERRORS, ("IDM_LOG_COPYING: RegOpenKey failed\n"));
                goto done;
            }

            if(vfLogCopying)
                strcpy(szDoCopy, SZ_TRUE);
            else
                strcpy(szDoCopy, SZ_FALSE);

            if(RegSetValueEx(hKey, vszDoLogCopy, (DWORD) 0, REG_SZ, szDoCopy, strlen(szDoCopy)+1) != ERROR_SUCCESS)
            {
                ReintKdPrint(BADERRORS, ("IDM_LOG_COPYING: RegSetValueEx failed\n"));
            }
            done:
            if(hKey)
                RegCloseKey(hKey);
#endif //TEST
        }
        break;

        case IDM_SHADOWING:
        break;

        case IDM_SPEED_OPT:
        break;

        case IDM_TRAY_FILL_SHADOW:
        break;


        case IDM_TRAY_MERGE:
        break;

        case IDM_TRAY_FREE_SPACE:
        break;

        case IDM_TRAY_FORCE_LOG:
        break;

        case IDM_REFRESH_CONNECTIONS:
        break;

        case IDM_BREAK_CONNECTIONS:
        break;

        case IDM_LOGON:
            if (lParam)
            {
                vfStartRecieved = TRUE;
                // logon is done, try enabling CSC
                // if CSC is already enabled, the routine will do the right thing
                //
                EnableCSC();

            }
            break;
        case IDM_LOGOFF:
            // no need to trap this, we get WM_QUERYENDSESSION and WM_ENDSESSION
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

LRESULT
CALLBACK
ReInt_WndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:

--*/
{
    LPARAM lRet = 0L;

    switch (message)
    {
        case RWM_UPDATE:
            ReintKdPrint(BADERRORS, ("Update hShare:%0x hWnd=%0x\n",wParam, lParam));
            PurgeSkipQueue(TRUE, (HSHARE)wParam, 0, 0);
//            return ReintOneShare((HSHARE)wParam,(HWND)lParam);
            break;

        case RWM_UPDATEALL:
            break;

        case WM_TIMER:
        break;

        case TRAY_NOTIFY:
        break;

        case WM_DEVICECHANGE:
        {
            switch (wParam)
            {
                case DBT_DEVICEARRIVAL:
                    if (((DEV_BROADCAST_NET *)lParam)->dbcn_devicetype == DBT_DEVTYP_NET)
                    {
//                        ProcessNetArrivalMessage();

                    }
                    break;
                case DBT_DEVICEREMOVECOMPLETE:
                    if (((DEV_BROADCAST_NET *)lParam)->dbcn_devicetype == DBT_DEVTYP_NET)
                    {
//                        ProcessNetDepartureMessage(FALSE);

                    }
                    break;
            }
            break;
        }

        case WM_INITMENU:
            return TRUE;
        break;

        case WM_INITMENUPOPUP:
        break;

        case WM_COMMAND:
            if(lRet = ReInt_CommandHandler(hwnd, wParam, lParam))
                return lRet;
            break;

        case WM_CLOSE:
            ReintKdPrint(BADERRORS, ("WM_CLOSE hit.\n"));
            break;

        case WM_DESTROY:
            ReintKdPrint(BADERRORS, ("WM_DESTROY hit.\n"));
            PostQuitMessage((int)wParam);
            return 1L;

        case WM_SETCURSOR:
        break;
        case WM_QUERYENDSESSION:
            return TRUE;
        case WM_ENDSESSION:
            ReintKdPrint(BADERRORS, ("Turning off shadowing on WM_ENDSESSION\r\n"));
           DisableCSC();
           break;
        case WM_FILE_OPENS:
            break;

        case WM_SHADOW_ADDED:
        case WM_SHADOW_DELETED:
            ReintKdPrint(BADERRORS, ("allowAttempt = TRUE\n"));
            allowAttempt = TRUE;
            break;

        case WM_SHARE_DISCONNECTED:
            ReintKdPrint(BADERRORS, ("REINT: VxD notification(0x%08x)\n",message));
            break;

        default:
            break;
    }

    return DefWindowProc(hwnd, message, wParam, lParam);
}

BOOL ReInt_AnythingToMerge(
    VOID
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:

--*/
{
    return (CheckDirtyShares() != 0);
}

//
//
BOOL
ReInt_RefreshTray(
    BOOL bHide
    )
/*++

Routine Description:
    Called to update the tray ICON to reflect the merge status.

Parameters:

    bHide   = TRUE means hide it
            = FALSE means work it out.

Return Value:

Notes:

--*/
{
    return TRUE;
}

// See if shadfowing is ON
// Returns: TRUE=> ON, FALSE=> OFF, -1 => soem error happened
BOOL
IsCSCOn(
    VOID
    )
{

    if (vfCSCEnabled)
    {
#ifdef DEBUG
        unsigned ulSwitch = SHADOW_SWITCH_SHADOWING;
        if(ShadowSwitches(INVALID_HANDLE_VALUE, &ulSwitch, SHADOW_SWITCH_GET_STATE))
        {
            Assert((ulSwitch & SHADOW_SWITCH_SHADOWING)!=0);
        }
#endif
        return (TRUE);
    }
    return (FALSE);
}

// Disable Shadowing
// Returns: 1 => done, -1 => some error happened
int
DisableCSC()
{
    unsigned ulSwitch = SHADOW_SWITCH_SHADOWING;

    if (vfCSCEnabled && vfAgentEnabledCSC) {

        if(ShadowSwitches(INVALID_HANDLE_VALUE, &ulSwitch, SHADOW_SWITCH_OFF))
        {
            vfCSCEnabled = FALSE;
            if (vhShadowDBForEvent != INVALID_HANDLE_VALUE)
            {
                CloseHandle(vhShadowDBForEvent);
                vhShadowDBForEvent = INVALID_HANDLE_VALUE;
            }

            Reint_UnregisterAgent();
//            SetDisabledReg();
            return (1);
        }
    }
    return (-1);
}

BOOL
EnableCSC(
    VOID
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    char szBuff[MAX_PATH];
    DWORD   dwBuffSize;
    BOOL fDirCreated=FALSE, fRedirCSCEnabled=TRUE, fWasDirty = FALSE;
    unsigned uShadowSwitches;

    ReintKdPrint(INIT, ("CSC Enabled %d \r\n", vfCSCEnabled));
    if (vfCSCEnabled==FALSE)
    {

        dwBuffSize = sizeof(szBuff);
        if(!GetUserNameA(szBuff, &dwBuffSize))
        {
            // not logged on yet
            return FALSE;
        }

        if(ShadowSwitches(INVALID_HANDLE_VALUE, &uShadowSwitches, SHADOW_SWITCH_GET_STATE))
        {
            if (uShadowSwitches & SHADOW_SWITCH_SHADOWING)
            {
                ReintKdPrint(INIT, ("cscdll: CSC already started\r\n"));
            }
            else
            {
                ReintKdPrint(INIT, ("cscdll: redir is not doing CSC yet, OK\r\n"));
                fRedirCSCEnabled = FALSE;

                if (!vfOKToEnableCSC)
                {
                    return FALSE;
                }

                vfAgentEnabledCSC = TRUE;

            }
        }
        else
        {
            ReintKdPrint(BADERRORS, ("cscdll: couldn't get the CSC state from the redir\r\n"));
        }

        if (Reint_RegisterAgent())
        {

            SetFileAttributesA(vszDBDir, FILE_ATTRIBUTE_SYSTEM|FILE_ATTRIBUTE_HIDDEN);

            ReintKdPrint(INIT,
                 ("cscdll: enabling CSC at %s for %s with capacity %d and clustersize %d\r\n",
                 vszDBDir, szBuff, vdwDBCapacity, vdwClusterSize));
            if (EnableShadowing(
                    INVALID_HANDLE_VALUE,
                    vszDBDir,
                    szBuff,
                    0,
                    vdwDBCapacity,
                    vdwClusterSize,
                    vfFormatDatabase))
            {
                vfCSCEnabled = TRUE;
                if (vhShadowDBForEvent == INVALID_HANDLE_VALUE)
                {
                    vhShadowDBForEvent = OpenShadowDatabaseIO();
                }
            }
            else
            {
                ReintKdPrint(BADERRORS, ("cscdll: EnableShadowing failed, CSC not enabled!!!!\r\n"));
            }

            if (vfCSCEnabled==FALSE)
            {
                Reint_UnregisterAgent();
            }
        }
        else
        {
            ReintKdPrint(BADERRORS, ("cscdll: EnableCSC.Agent registration failed, CSC not enabled!!!!\r\n"));
        }
    }
    if (!vfCSCEnabled)
    {
        // NTRAID-455253-1/31/2000-shishirp need to add it to the event log with the right error
        ReintKdPrint(BADERRORS, ("cscdll: CSC not enabled \r\n"));
    }

    return (vfCSCEnabled);
}

BOOL
IsNetConnected(
VOID
)
/*++

Routine Description:
        The function checks to see whether at this moment
        we are connected to any resources on the real net.

Parameters:

Return Value:

Notes:
        This is used to decide whether to start purging stuff from the
        cache. If we are in a completely disconnected state then we
        may not want to purge data that is potentially useful.

--*/
{
    CSC_ENUMCOOKIE  ulEnumCookie=NULL;
    WIN32_FIND_DATA sFind32;
    BOOL fConnected = FALSE;
    SHADOWINFO sSI;
    HANDLE hShadowDB;

    memset(&sFind32, 0, sizeof(sFind32));
    lstrcpy(sFind32.cFileName, _TEXT("*.*"));

    if ((hShadowDB = OpenShadowDatabaseIO()) == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    if(FindOpenShadow(hShadowDB, 0, FINDOPEN_SHADOWINFO_ALL, &sFind32, &sSI))
    {
        ulEnumCookie = sSI.uEnumCookie;

        do
        {
            if (sSI.uStatus & SHARE_CONNECTED) {
                if (!(sSI.uStatus & SHARE_DISCONNECTED_OP)) {
                    fConnected = TRUE;
                    break;
                }
             }
        } while(FindNextShadow(hShadowDB, ulEnumCookie, &sFind32, &sSI));

        FindCloseShadow(hShadowDB, ulEnumCookie);
    }

    CloseShadowDatabaseIO(hShadowDB);

    return fConnected;
}


int
ExtractSpaceStats(
    GLOBALSTATUS    *lpsGS,
    unsigned long     *lpulMaxSpace,
    unsigned long     *lpulCurSpace,
    unsigned long     *lpulFreeSpace
    )
/*++

Routine Description:
         The function returns the max, current and free
         space as known by the shadow cache.

Parameters:

Return Value:
    1 if there is any free space
    0 if there is no free space
    -1 if there is some error

Notes:

--*/
{
    int iRet = 1;

    if (!lpsGS)
    {
        lpsGS = &vsGS;
    }

    if (lpulMaxSpace){
        *lpulMaxSpace = lpsGS->sST.sMax.ulSize;
    }

    if (lpulCurSpace){
        *lpulCurSpace = lpsGS->sST.sCur.ulSize;
    }

    if (lpulFreeSpace){
        *lpulFreeSpace = 0;
    }

    // do we have any space?
    if (lpsGS->sST.sMax.ulSize > lpsGS->sST.sCur.ulSize){
        if (lpulFreeSpace){
            *lpulFreeSpace =  (lpsGS->sST.sMax.ulSize - lpsGS->sST.sCur.ulSize);
        }
        iRet = 1;
    }
    else{
        iRet = 0;
    }

    return iRet;
}


int
InitCacheSize(
    VOID
    )
/*++

Routine Description:
         The function returns the max, current and free
         space as known by the shadow cache.

Parameters:

Return Value:
    1 if there is any free space
    0 if there is no free space
    -1 if there is some error

Notes:

--*/
{
    unsigned ulMaxStore;
    int iRet = 0;

    if(!GetGlobalStatus(INVALID_HANDLE_VALUE, &vsGS))
    {
        return -1;
    }

    if (ExtractSpaceStats(&vsGS, &ulMaxStore, NULL, NULL)>=0){

        if (ulMaxStore==0xffffffff){

            ReintKdPrint(BADERRORS, ("Agent: Found newly created cache, setting cache size \r\n"));

            Assert(vszDBDir[0]);

            iRet = SetDefaultSpace(vszDBDir);
        }
    }
    return iRet;
}

int
SetDefaultSpace(
    LPSTR lpShadowDir
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:

--*/
{
    DWORD dwSPC, dwBPS, dwFreeC, dwTotalC, dwCapacity;
    _TCHAR szDrive[4];
    int iRet = 0;

    Assert(lpShadowDir[1]==':');
    memset(szDrive, 0, sizeof(szDrive));
    memcpy(szDrive, lpShadowDir, 3);
    if(GetDiskFreeSpace(szDrive, &dwSPC, &dwBPS, &dwFreeC, &dwTotalC )){
        dwCapacity = ((dwSPC * dwBPS * 10)/100)*dwTotalC;
        SetMaxShadowSpace(INVALID_HANDLE_VALUE, 0, dwCapacity);
        iRet = 1;
    }
    return (iRet);
}

int
DoEventProcessing(
    VOID
)
/*++

Routine Description:

    When the named event is triggered by the kernel mode component, this routine
    looks to see what needs to be taken care of and does the job.

Parameters:

Return Value:

Notes:

    This routine is called from various places in the mailoop and other loops such as
    AttemptCacheFill. It may end up showing up dialog boxes and such, so care has to be taken
    while invoking it.

--*/
{
    int iRet;
    GLOBALSTATUS sGS;

    ReintKdPrint(
        INIT,
        ("CSC Agent: CSC Enabled=%d vhShadowDBForEvent \n",
        vfCSCEnabled,
        vhShadowDBForEvent));

    ReintKdPrint(MAINLOOP, ("Agent(1):DoEventProcessing()\n"));

    if (iRet = GetGlobalStatus(vhShadowDBForEvent, &sGS)) {
        ReintKdPrint(MAINLOOP, (
                        "Agent(1):uFlagsEvents:0x%x\n"
                        "         uDatabaseErrorFlags:0x%x\n"
                        "         hShadowAdded:0x%x\n"
                        "         hDirAdded:0x%x\n"
                        "         hShadowDeleted:0x%x\n"
                        "         hDirDeleted:0x%x\n"
                        "         cntFileOpen:%d\n"
                        "         hShareDisconnected:0x%x\n",
                            sGS.uFlagsEvents,
                            sGS.uDatabaseErrorFlags,
                            sGS.hShadowAdded,
                            sGS.hDirAdded,
                            sGS.hShadowDeleted,
                            sGS.hDirDeleted,
                            sGS.cntFileOpen,
                            sGS.hShareDisconnected,
                            sGS.uFlagsEvents));
        if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_START)
            ReintKdPrint(MAINLOOP, ("Agent(1):FLAG_GLOBALSTATUS_START received\r\n"));
        if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_STOP)
            ReintKdPrint(MAINLOOP, ("Agent(1):FLAG_GLOBALSTATUS_STOP received\r\n"));
        if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_NO_NET)
            ReintKdPrint(MAINLOOP, ("Agent(1):FLAG_GLOBALSTATUS_NO_NET received\r\n"));
        if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_GOT_NET)
            ReintKdPrint(MAINLOOP, ("Agent(1):FLAG_GLOBALSTATUS_GOT_NET received\r\n"));
        if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_INVOKE_FREESPACE)
            ReintKdPrint(MAINLOOP, ("Agent(1):FLAG_GLOBALSTATUS_INVOKE_FREESPACE received\r\n"));
        if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_SHARE_DISCONNECTED)
            ReintKdPrint(
                    MAINLOOP,
                    ("Agent(1):FLAG_GLOBALSTATUS_SHARE_DISCONNECTED (share=%d) received\r\n",
                    sGS.hShareDisconnected));
        if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_START) {
            vfCSCEnabled = TRUE;
            if (vhShadowDBForEvent == INVALID_HANDLE_VALUE) {
                vhShadowDBForEvent = OpenShadowDatabaseIO();
            }
            Reint_RegisterAgent();
        } else if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_STOP) {
            vfCSCEnabled = FALSE;
            if (vhShadowDBForEvent != INVALID_HANDLE_VALUE) {
                CloseHandle(vhShadowDBForEvent);
                vhShadowDBForEvent = INVALID_HANDLE_VALUE;
            }
            Reint_UnregisterAgent();
        }
        if (AGENT_ALIVE) {
            if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_GOT_NET) {
                ProcessNetArrivalMessage();
            } else if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_NO_NET) {
                ProcessNetDepartureMessage(
                            ((sGS.uFlagsEvents & FLAG_GLOBALSTATUS_INVOKE_AUTODIAL)!=0));
            }
            if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_SHARE_DISCONNECTED) {
                ReportShareNetArrivalDeparture(
                    1,
                    sGS.hShareDisconnected,
                    ((sGS.uFlagsEvents & FLAG_GLOBALSTATUS_INVOKE_AUTODIAL)!=0),
                    FALSE); // departed
            }
            if (uOldDatabaseErrorFlags != sGS.uDatabaseErrorFlags) {
                ReportEventsToSystray(STWM_CACHE_CORRUPTED, 0, 0);
                uOldDatabaseErrorFlags = sGS.uDatabaseErrorFlags;
            }
            // see if space needs freeing
            if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_INVOKE_FREESPACE) {
                ReintKdPrint(MAINLOOP, ("Agent(1): Calling DoFreeShadowSpace(1)\r\n"));
                ReInt_DoFreeShadowSpace(&sGS, 0);
            } else {
                ReintKdPrint(MAINLOOP, ("Agent(1): Calling DoFreeShadowSpace(2)\r\n"));
                ReInt_DoFreeShadowSpace(&sGS, 0);
            }
        } else {
            if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_SHARE_DISCONNECTED) {
                ReintKdPrint(MAINLOOP, ("Agent(1): Calling ReportShareNetArrivalDeparture\r\n"));
                ReportShareNetArrivalDeparture(
                    1,
                    0,
                    ((sGS.uFlagsEvents & FLAG_GLOBALSTATUS_INVOKE_AUTODIAL)!=0),
                    FALSE); // departed
            }
        }
        vsGS = sGS;
        vsGS.uFlagsEvents = 0; // clear all event indicators
    }
    return iRet;
}

BOOL
CreatePerSessSyncObjects(
    VOID
    )
{
    NTSTATUS Status;
    UNICODE_STRING EventName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR SessEventName[100];

    // DbgPrint("CreatePerSessSyncObjects:vdwAgentSessionId = %d\n", vdwAgentSessionId);

    Assert(heventPerSess == NULL);

    wsprintf(SessEventName, L"%ws_%d", SESSION_EVENT_NAME_NT, vdwAgentSessionId);

   //  DbgPrint("CreatePerSessSyncObjects:SessEventName = [%ws]\n", SessEventName);

    RtlInitUnicodeString(&EventName, SessEventName);

    InitializeObjectAttributes( &ObjectAttributes,
                                &EventName,
                                OBJ_OPENIF,  //got this const from base\client\support.c
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    Status = NtCreateEvent(
                &heventPerSess,
                EVENT_ALL_ACCESS,
                &ObjectAttributes,
                SynchronizationEvent,
                FALSE
                );

    if (!NT_SUCCESS(Status)) {
        DbgPrint("CreatePerSessSyncObjects:NtCreateEvent returned %08lx\n",Status);
    }


    return (heventPerSess==0)?FALSE:TRUE;

}

BOOL
CreateSharedFillSyncObjects(
    VOID
    )
{
    NTSTATUS Status;
    UNICODE_STRING EventName;
    OBJECT_ATTRIBUTES ObjectAttributes;

    Assert(heventSharedFill == NULL);

    RtlInitUnicodeString(&EventName,SHARED_FILL_EVENT_NAME_NT);

    InitializeObjectAttributes( &ObjectAttributes,
                                &EventName,
                                OBJ_OPENIF,  //got this const from base\client\support.c
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    Status = NtCreateEvent(
                &heventSharedFill,
                EVENT_ALL_ACCESS,
                &ObjectAttributes,
                SynchronizationEvent,
                FALSE
                );

    if (!NT_SUCCESS(Status)) {
        DbgPrint("ntcreateeventstatus=%08lx\n",Status);
    }


    return (heventSharedFill==0)?FALSE:TRUE;

}


VOID
ProcessStartStopAgent(
    VOID
    )
{
    if (vfStartRecieved)
    {
        
        ReintKdPrint(MAINLOOP, ("Agent(1): start received, enabling CSC\r\n"));


        if (EnableCSC() == FALSE)
        {
            ReintKdPrint(ALWAYS, ("Ageint(1):Couldn't turn CSC ON!!!!!!!!! \n"));
        }
        else
        {
            UpdateExclusionList();
            UpdateBandwidthConservationList();
        }


        // set the event to indicate to wkssvc that we are alive
        if (heventAgentToWkssvc)
        {
            SetEvent(heventAgentToWkssvc);
        }

        vfStartRecieved = FALSE;
        vfRedirStarted = TRUE;
    }
    else if (vfStopRecieved)
    {
        ReintKdPrint(MAINLOOP, ("Agent(1):Stop recieved \r\n"));

        DisableCSC();

        if(heventAgentToWkssvc)
        {
            SetEvent(heventAgentToWkssvc);
        }

        vcntNetDevices = 0;
        vfStopRecieved = FALSE;
        vfRedirStarted = FALSE;
    }
}

BOOL
FStopAgent(
    VOID
    )
{

    if (StartStopCheck() && vfStopRecieved)
    {
        return TRUE;
    }

    return FALSE;
}

BOOL
StartStopCheck(
    VOID
    )
{
    DWORD    dwError;
    BOOL fRet = FALSE;
    HANDLE hT[2];
    unsigned ulSwitch=0;

    // the way we are finding out about the start makes the start event
    // redundant, but we will leave it, because it is generically the right thing to have a
    // start event and a stop event.

    if ((vfRedirStarted == -1) &&   // if newly launched agent
        (ShadowSwitches(INVALID_HANDLE_VALUE, &ulSwitch, SHADOW_SWITCH_GET_STATE)))
    {
            ReintKdPrint(INIT, ("Agent: redir already started\r\n"));
            vfStartRecieved = TRUE;
    }
    else if (heventWkssvcToAgentStart)
    {
        // we know that when it comes to events it is all or nothing
        Assert(heventWkssvcToAgentStop);

        hT[0] = heventWkssvcToAgentStart;
        hT[1] = heventWkssvcToAgentStop;

        dwError = MsgWaitForMultipleObjects(2, hT, FALSE, 0, QS_ALLINPUT);

        if (vfRedirStarted == TRUE)
        {
            vfStopRecieved = (dwError == WAIT_OBJECT_0+1);
            if (vfStopRecieved)
            {
                ReintKdPrint(INIT, ("Agent: stop recieved\r\n"));
            }
        }
        else
        {
            vfStartRecieved = (dwError == WAIT_OBJECT_0);

            if (vfStartRecieved)
            {
                ReintKdPrint(INIT, ("Agent: start recieved\r\n"));
            }
        }
    }

    return fRet;
}

BOOL
Reint_RegisterAgent(
    VOID
    )
{

    if (!vfAgentRegistered)
    {
        if (!RegisterAgent(INVALID_HANDLE_VALUE, vhwndMain, LongToHandle(dwVxDEvent)))
        {
            ReintKdPrint(BADERRORS, ("Agent registration failed \n"));
            return FALSE;
        }

        else
        {
            vfAgentRegistered = TRUE;
        }
    }
    return vfAgentRegistered;
}

VOID
Reint_UnregisterAgent(
    VOID
    )
{
    if (vfAgentRegistered)
    {
        // don't do any checking
        UnregisterAgent(INVALID_HANDLE_VALUE, vhwndMain);
        vfAgentRegistered = FALSE;
    }

}

BOOL
QueryEnableCSC(
    VOID
    )
{

    DWORD dwDisposition, dwSize, dwEnabled=0;
    HKEY hKey = NULL;
    BOOL fRet = TRUE;
    int i;
    _TCHAR  *lpKey;
    NT_PRODUCT_TYPE productType;

    if( !RtlGetNtProductType( &productType ) ) {
       productType = NtProductWinNt;
    }

    switch ( productType ) {
    case NtProductWinNt:
       /* WORKSTATION */
        ReintKdPrint(INIT, ("Agent:CSC running workstation\r\n"));
      break;
    default:
        ReintKdPrint(INIT, ("Agent:CSC NOT running workstation\r\n"));
        fRet = FALSE;   // default is fail
    }

    
	//Check if CSC can work with current settings for TS
	//Test for TS added by Navjot as per Bug#468391
    if (IsPersonal() == TRUE || !CanCSCLivewithTS() )
        return FALSE;

    for (i=0; i<2; ++i)
    {
        if (i==0)
        {
            lpKey = REG_STRING_POLICY_NETCACHE_KEY;
        }
        else
        {
            lpKey = REG_STRING_NETCACHE_KEY;
        }

        if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        lpKey,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hKey
                        ) == ERROR_SUCCESS)
        {
            dwSize = sizeof(dwEnabled);

            if (RegQueryValueEx(hKey, REG_VALUE_ENABLED, NULL, NULL, (void *)&dwEnabled, &dwSize) == ERROR_SUCCESS)
            {
                fRet = (dwEnabled != 0);
                break;
            }


            RegCloseKey(hKey);
            hKey = NULL;
        }
        else
        {
            hKey = NULL;
        }
    }

    if(hKey)
    {
        RegCloseKey(hKey);
    }

    return (fRet);
}




BOOL
CreateStartStopEvents(
    VOID
    )
{
    BOOL fOK = FALSE;

    // ensure that there are thre named autoreset events
    if (!heventWkssvcToAgentStart)
    {
        heventWkssvcToAgentStart = CreateEvent(NULL, FALSE, FALSE, szWkssvcToAgentStartEvent);

        if (!heventWkssvcToAgentStart)
        {
            ReintKdPrint(BADERRORS, ("CSC.Agent: Failed to create heventWkssvcToAgentStart, error = %d\n", GetLastError()));
            goto bailout;
        }

        Assert(!heventAgentToWkssvc);

        heventWkssvcToAgentStop = CreateEvent(NULL, FALSE, FALSE, szWkssvcToAgentStopEvent);

        if (!heventWkssvcToAgentStop)
        {
            ReintKdPrint(BADERRORS, ("CSC.Agent: Failed to create heventWkssvcToAgentStop, error = %d\n", GetLastError()));
            goto bailout;
        }

        heventAgentToWkssvc = CreateEvent(NULL, FALSE, FALSE, szAgentToWkssvcEvent);

        if (!heventAgentToWkssvc)
        {
            ReintKdPrint(BADERRORS, ("CSC.Agent: Failed to create heventAgentToWkssvc, error = %d\n", GetLastError()));
            goto bailout;
        }

        // event to detect whether the agent is alive (used by wkssvc) and
        // to signal termination (used by winlogon)
        heventShutDownAgent = CreateEvent(NULL, FALSE, FALSE, szAgentExistsEvent);

        if (!heventShutDownAgent)
        {
            ReintKdPrint(BADERRORS, ("CSC.Agent: Failed to create heventShutDownAgent, error = %d\n", GetLastError()));
            goto bailout;
        }

        heventShutDownThread = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (!heventShutDownThread)
        {
            ReintKdPrint(BADERRORS, ("CSC.Agent: Failed to create heventShutDownThread, error = %d\n", GetLastError()));
            goto bailout;
        }
    }

    fOK = TRUE;

bailout:

    if (!fOK)
    {
        DestroyStartStopEvents();
    }
    return fOK;
}

VOID
DestroyStartStopEvents(
    VOID
    )
{

    if (heventWkssvcToAgentStart)
    {
        CloseHandle(heventWkssvcToAgentStart);
        heventWkssvcToAgentStart = NULL;
    }

    if (heventWkssvcToAgentStop)
    {
        CloseHandle(heventWkssvcToAgentStop);
        heventWkssvcToAgentStop = NULL;
    }

    if (heventAgentToWkssvc)
    {
        CloseHandle(heventAgentToWkssvc);
        heventAgentToWkssvc = NULL;
    }

    if (heventShutDownAgent)
    {
        CloseHandle(heventShutDownAgent);
        heventShutDownAgent = NULL;
    }
    if (heventShutDownThread)
    {
        CloseHandle(heventShutDownThread);
        heventShutDownThread = NULL;
    }
}

BOOL
UpdateExclusionList(
    VOID
    )
/*++

Routine Description:

    Tell the kernel mode code about the exclusion list. If there is none set in the registry
    then we set the default one

Parameters:

Return Value:

Notes:


--*/
{
    LPWSTR  lpwExclusionList = NULL;
    DWORD   cbSize = 0;
    char    buff[MAX_LIST_SIZE]; // max exclusion list
    BOOL    fRet = FALSE;

    if (!vfCSCEnabled)
    {

        ReintKdPrint(INIT, ("CSC not enabled \r\n"));
        return FALSE;

    }

    ReintKdPrint(INIT, ("Getting ExclusionList \r\n"));

    // get the exclusion list from the policy key.
    // if that doesn't work then try the one from the netcache key

    if (GetWideStringFromRegistryString(REG_STRING_POLICY_NETCACHE_KEY_A,
                                        REG_STRING_EXCLUSION_LIST_A,
                                        &lpwExclusionList,
                                        &cbSize) ||
        GetWideStringFromRegistryString(REG_STRING_NETCACHE_KEY_A,
                                        REG_STRING_EXCLUSION_LIST_A,
                                        &lpwExclusionList,
                                        &cbSize)
        )
    {
        ReintKdPrint(INIT, ("Got ExclusionList \r\n"));

        if (cbSize < sizeof(buff))
        {
            memcpy(buff, lpwExclusionList, cbSize);

            ReintKdPrint(INIT, ("Setting User defined exclusion list %ls size=%d\r\n", buff, cbSize));
            if (SetExclusionList(INVALID_HANDLE_VALUE, (USHORT *)buff, cbSize))
            {
                fRet = TRUE;
            }
        }

    }
    else
    {
        // set the default
        // take the string and it's terminating null char
        cbSize = sizeof(vtzDefaultExclusionList);
        Assert(cbSize < MAX_LIST_SIZE);
        memcpy(buff, vtzDefaultExclusionList, cbSize);
        ReintKdPrint(INIT, ("Setting default exclusion list %ls size=%d\r\n", buff, cbSize));

        if (SetExclusionList(INVALID_HANDLE_VALUE, (USHORT *)buff, cbSize))
        {
            fRet = TRUE;
        }
    }

    if (lpwExclusionList)
    {
        LocalFree(lpwExclusionList);
    }
    return fRet;
}


BOOL
UpdateBandwidthConservationList(
    VOID
    )
/*++

Routine Description:

    Update the list of extensions on which bitcopy should be turned ON. We do not set any default

Parameters:

Return Value:

Notes:


--*/
{
    LPWSTR  lpwBandwidthConservationList = NULL;
    DWORD   cbSize = 0;
    char    buff[MAX_LIST_SIZE]; // max exclusion list
    BOOL    fRet = FALSE;

    if (!vfCSCEnabled)
    {

        ReintKdPrint(INIT, ("CSC not enabled \r\n"));
        return FALSE;

    }

    ReintKdPrint(INIT, ("Getting BandwidthConservationList \r\n"));

    // get the exclusion list from the policy key.
    // if that doesn't work then try the one from the netcache key

    if (GetWideStringFromRegistryString(REG_STRING_POLICY_NETCACHE_KEY_A,
                                        REG_STRING_BANDWIDTH_CONSERVATION_LIST_A,
                                        &lpwBandwidthConservationList,
                                        &cbSize) ||
        GetWideStringFromRegistryString(REG_STRING_NETCACHE_KEY_A,
                                        REG_STRING_BANDWIDTH_CONSERVATION_LIST_A,
                                        &lpwBandwidthConservationList,
                                        &cbSize)
        )
    {
        ReintKdPrint(INIT, ("Got BandwidthConservationList \r\n"));

        if (cbSize < sizeof(buff))
        {
            memcpy(buff, lpwBandwidthConservationList, cbSize);

            ReintKdPrint(INIT, ("Setting User defined bandwidth conservation list %ls size=%d\r\n", buff, cbSize));
            if (SetBandwidthConservationList(INVALID_HANDLE_VALUE, (USHORT *)buff, cbSize))
            {
                fRet = TRUE;
            }
        }

    }
    else
    {
        fRet = FALSE;
#if 0
        // set the default
        // take the string and it's terminating null char
        cbSize = sizeof(vtzDefaultBandwidthConservationList);
        Assert(cbSize < MAX_LIST_SIZE);
        memcpy(buff, vtzDefaultBandwidthConservationList, cbSize);
        ReintKdPrint(INIT, ("Setting default exclusion list %ls size=%d\r\n", buff, cbSize));

        if (SetBandwidthConservationList(INVALID_HANDLE_VALUE, (USHORT *)buff, cbSize))
        {
            fRet = TRUE;
        }
#endif
    }

    if (lpwBandwidthConservationList)
    {
        LocalFree(lpwBandwidthConservationList);
    }
    return fRet;
}



BOOL
ProcessNetArrivalMessage(
    VOID
    )
/*++

Routine Description:


Parameters:

Return Value:

Notes:

--*/
{

    vcntNetDevices = 1;
    ReportShareNetArrivalDeparture( 0,      // all shares
                                    0,
                                    FALSE,  // don't invoke autodial
                                    TRUE    // arrived
                                  );

    ReintKdPrint(INIT, ("WM_DEVICECHANGE:Net arrived, %d nets so far\r\n", vcntNetDevices));

    return (TRUE);
}

BOOL
ProcessNetDepartureMessage(
    BOOL    fInvokeAutodial
    )
/*++

Routine Description:


Parameters:

Return Value:

Notes:

--*/
{
    ReintKdPrint(MAINLOOP, ("WM_DEVICECHANGE:Net removed, %d nets so far\r\n", vcntNetDevices));

    vcntNetDevices = 0;

    ReportShareNetArrivalDeparture( 0,  // all shares
                                    0,
                                    fInvokeAutodial, // invoke auto dial
                                    FALSE // departed
                                    );

    return TRUE;
}

BOOL
ReportShareNetArrivalDeparture(
    BOOL    fOneServer,
    HSHARE hShare,
    BOOL    fInvokeAutoDial,
    BOOL    fArrival
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:

--*/
{
    SHAREINFO  sSR;
    _TCHAR  *lptzServerName;
    unsigned    ulStatus;
    DWORD dwSize;
    BOOL fGotName = FALSE;
    BOOL fAllocated = FALSE;
    BOOL fRet = FALSE;
    LRESULT lResult = LRESULT_CSCFAIL;
    LPTSTR lp = NULL;
    DWORD dwMessage = 0;
    WPARAM dwWParam = (WPARAM) 0;
    LPARAM dwLParam = (LPARAM) 0;

    lptzServerName = sSR.rgSharePath;

    if (fOneServer) {
        if (fArrival) {
            if(GetShareInfo(vhShadowDBForEvent, hShare, &sSR, &ulStatus)<= 0) {
                PrintFn("ReportShareNetArrivalDeparture: couldn't get status for server 0x%x\r\n",
                            hShare);
                ReintKdPrint(
                    BADERRORS,
                    ("ReportShareNetArrivalDeparture: couldn't get status for server 0x%x\r\n",
                    hShare));
                return FALSE;
            }
            lp = MyStrChr(sSR.rgSharePath+2, _T('\\'));
            if (!lp) {
                ReintKdPrint(
                    BADERRORS,
                    ("ReportShareNetArrivalDeparture: Invalid server name %ls\r\n",
                    sSR.rgSharePath));
                Assert(FALSE);
                return FALSE;
            }
            *lp = 0;
        } else { // A share departure
            int i;
            
            dwSize = sizeof(sSR.rgSharePath);
            fGotName = GetNameOfServerGoingOfflineEx(
                            vhShadowDBForEvent,
                            &lptzServerName,
                            &dwSize,
                            &fAllocated);
            if(!fGotName) {
                TransitionShareToOffline(vhShadowDBForEvent, fOneServer, 0xffffffff);
                goto bailout;
            }
        }
    }

    fRet = TRUE;

    ReintKdPrint(
        INIT,
        ("ReportShareNetArrivalDeparture: reporting %s to the systray\r\n",
        (fArrival) ? "arrival" : "departure"));

    dwMessage = (fArrival) ? STWM_CSCNETUP : STWM_CSCQUERYNETDOWN;
    dwWParam = (fInvokeAutoDial)
                    ? ((hShare != 0)
                        ? CSCUI_AUTODIAL_FOR_CACHED_SHARE
                        : CSCUI_AUTODIAL_FOR_UNCACHED_SHARE)
                    : CSCUI_NO_AUTODIAL;
    dwLParam = (fOneServer) ? (DWORD_PTR)(lptzServerName) : 0;

    lResult = ReportEventsToSystray(dwMessage, dwWParam, dwLParam);

    // if the redir is stuck waiting to be told whether to go offline on a share
    // tell him yes or no
    if (!fArrival) {
        if (fOneServer) {
            TransitionShareToOffline(
                vhShadowDBForEvent,
                fOneServer,
                (lResult == LRESULT_CSCWORKOFFLINE)
                    ? 1
                    : ((lResult == LRESULT_CSCRETRY)
                        ? 0
                        : 0xffffffff)
                );

            if (lResult == LRESULT_CSCWORKOFFLINE) {
                dwMessage = STWM_CSCNETDOWN;
                dwWParam = fInvokeAutoDial;
                dwLParam = (fOneServer)
                                ? ((hShare != 0)
                                    ? (DWORD_PTR)(lptzServerName)
                                    : 0xffffffff)
                                : 0;
                ReportEventsToSystray(dwMessage, dwWParam, dwLParam);
                ReportTransitionToDfs(lptzServerName, TRUE, 0xffffffff);
            }
        }
    }

bailout:
    if (fAllocated) {
        LocalFree(lptzServerName);
    }
    return (fRet);
}


BOOL
CheckServerOnline(
    VOID
    )
/*++

Routine Description:


Parameters:

Return Value:

Notes:

--*/
{
    unsigned long ulStatus;
    WIN32_FIND_DATA sFind32;
    int cntReconnected=0;
    SHADOWINFO sSI;
    HANDLE  hShadowDB;
    _TCHAR  tzDriveMap[4];
    CSC_ENUMCOOKIE  ulEnumCookie=NULL;
    DWORD   dwError;

    if (!ImpersonateALoggedOnUser())
    {
        return 0;
    }

    if ((hShadowDB = OpenShadowDatabaseIO()) ==INVALID_HANDLE_VALUE)
    {
        ResetAgentThreadImpersonation();
        return 0;
    }

    memset(&sFind32, 0, sizeof(sFind32));
    lstrcpy(sFind32.cFileName, _TEXT("*"));

    if(FindOpenShadow(  hShadowDB, 0, FINDOPEN_SHADOWINFO_ALL,
                        &sFind32, &sSI))
    {
        ulEnumCookie = sSI.uEnumCookie;

        do {
            if(GetShareStatus(hShadowDB, sSI.hShare, &ulStatus)) {

                if(ulStatus & SHARE_DISCONNECTED_OP){

                    dwError = DWConnectNet(sFind32.cFileName, tzDriveMap, NULL, NULL, NULL, 0, NULL);

                    if ((dwError == NO_ERROR)||(dwError == ERROR_ACCESS_DENIED)||(dwError==WN_CONNECTED_OTHER_PASSWORD_DEFAULT))
                    {
                        if (sSI.ulHintFlags & FLAG_CSC_HINT_PIN_SYSTEM)
                        {
                            TransitionShareToOnline(INVALID_HANDLE_VALUE, 0);
                        }
                        else
                        {
                            ReportShareNetArrivalDeparture( TRUE,
                                                            sSI.hShare, // this share
                                                            FALSE,      // don't autodial
                                                            TRUE); // Arrived
                        }

                        ++cntReconnected;
                        if (dwError == NO_ERROR || dwError == WN_CONNECTED_OTHER_PASSWORD_DEFAULT)
                        {
                            DWDisconnectDriveMappedNet(tzDriveMap, TRUE); // force disconnect
                        }
                    }
                }
            }

            Sleep(200);

        } while(FindNextShadow(hShadowDB, ulEnumCookie, &sFind32, &sSI));

        FindCloseShadow(hShadowDB, ulEnumCookie);
    }


    CloseShadowDatabaseIO(hShadowDB);

    ResetAgentThreadImpersonation();

    return (cntReconnected?TRUE:FALSE);

}

BOOL
AreAnyServersOffline(
    VOID)
{
    ULONG ulStatus;
    WIN32_FIND_DATA sFind32 = {0};
    SHADOWINFO sSI;
    HANDLE  hShadowDB;
    CSC_ENUMCOOKIE  ulEnumCookie = NULL;
    BOOL bFoundOne = FALSE;

    if ((hShadowDB = OpenShadowDatabaseIO()) ==INVALID_HANDLE_VALUE)
        return FALSE;

    wcscpy(sFind32.cFileName, L"*");
    if (FindOpenShadow(hShadowDB, 0, FINDOPEN_SHADOWINFO_ALL, &sFind32, &sSI)) {
        ulEnumCookie = sSI.uEnumCookie;
        do {
            if (GetShareStatus(hShadowDB, sSI.hShare, &ulStatus)) {
                if ((ulStatus & SHARE_DISCONNECTED_OP) != 0) {
                    bFoundOne = TRUE;
                    break;
                }
            }
        } while(FindNextShadow(hShadowDB, ulEnumCookie, &sFind32, &sSI));
        FindCloseShadow(hShadowDB, ulEnumCookie);
    }
    CloseShadowDatabaseIO(hShadowDB);
    return bFoundOne;
}

BOOL
FAbortOperation(
    VOID
    )
{

    if (!vdwAgentThreadId)
    {
        return FALSE;
    }

    if (IsAgentShutDownRequested() || HasAgentShutDown())
    {
        ReintKdPrint(MAINLOOP, ("CSC.FAbortOperation: Agentshutdown detected aborting \r\n"));
        return TRUE;
    }
    return (FStopAgent());
}

VOID
SetAgentShutDownRequest(
    VOID
    )
{
    fAgentShutDownRequested = TRUE;
    SetEvent(heventShutDownAgent);
}

BOOL
IsAgentShutDownRequested(
    VOID
    )
{
    return (fAgentShutDownRequested == TRUE);
}

VOID
SetAgentShutDown(
    VOID
    )
{
    fAgentShutDown = TRUE;
}

BOOL
HasAgentShutDown(
    VOID
    )
{
    return (fAgentShutDown == TRUE );

}


//            HWND CSCUIInitialize(HANDLE hToken, DWORD dwFlags)
BOOL
InitCSCUI(
    HANDLE  hToken
    )
{

    ReintKdPrint(INIT, (" Initializing cscui\r\n"));

    EnterAgentCrit();
    if (!vhlibCSCUI)
    {
        vhlibCSCUI = LoadLibrary(vtzCSCUI);

        if (vhlibCSCUI)
        {
            if (vlpfnCSCUIInitialize = (CSCUIINITIALIZE)GetProcAddress(vhlibCSCUI, (const char *)vszCSCUIInitialize))
            {
                if(!(vlpfnCSCUISetState = (CSCUISETSTATE)GetProcAddress(vhlibCSCUI, (const char *)vszCSCUISetState)))
                {
                    ReintKdPrint(BADERRORS, ("Failed to get proc addres for %s, Error = %d \r\n", vszCSCUISetState, GetLastError()));
                }
                else
                {
                    (*vlpfnCSCUIInitialize)(hToken, CI_INITIALIZE);
                }
            }
            else
            {
                ReintKdPrint(BADERRORS, ("Failed to get proc addres for %s, Error = %d \r\n", vszCSCUIInitialize, GetLastError()));
            }
        }
        else
        {
            ReintKdPrint(BADERRORS, ("Failed to load %ls, Error = %d \r\n", vtzCSCUI, GetLastError()));
        }
    }
    LeaveAgentCrit();

    return (vlpfnCSCUISetState != NULL);
}



VOID
TerminateCSCUI(
    VOID
    )
{

    BOOL    fShowing;

    // snapshot the state of the showing dialog
    // if we are about to show an offline dialog, ReportEventsToSystray
    // will also do the action below but will try to set the vfShowingOfflineDlg
    // variable to 1
    // If fShowing was not set to 1, then we know that we are not showing UI
    // and we set vfShowingOfflineDlg to 0xffffffff. This will make ReportEventsToSystray
    // to not show the offline popup, so we will be free to do FreeLibrary

    fShowing = (BOOL)InterlockedExchange((PLONG)&vfShowingOfflineDlg, 0xffffffff);

    if (fShowing==1)
    {
        Assert(vhlibCSCUI && vlpfnCSCUISetState);

        (vlpfnCSCUISetState)(STWM_CSCCLOSEDIALOGS, 0, 0);

        while (vfShowingOfflineDlg != 0xfffffffe)
        {
            Sleep(10);
        }
    }

    if (vhlibCSCUI)
    {
        (*vlpfnCSCUIInitialize)(0, CI_TERMINATE);
        vlpfnCSCUIInitialize = NULL;
        vlpfnCSCUISetState = NULL;
        FreeLibrary(vhlibCSCUI);
        vhlibCSCUI = NULL;
    }

    vfShowingOfflineDlg = 0;

}

LRESULT
ReportEventsToSystray(
    DWORD   dwMessage,
    WPARAM  dwWParam,
    LPARAM  dwLParam
    )
/*++

Routine Description:


Parameters:

Return Value:

Notes:

--*/
{
    LRESULT lResult = LRESULT_CSCFAIL;
    BOOL    fOk;

    HWND hwnd;
    extern HDESK hdesktopUser, hdesktopCur;

    EnterAgentCrit();

    // is there a currently logged on user?
    if (!hdesktopUser)
    {
        LeaveAgentCrit();

        ReintKdPrint(INIT, ("ReportEventsToSystray: no-user logged, not-reporting\r\n"));
        return lResult;
    }
    else
    {
        if(!SetThreadDesktop(hdesktopUser))
        {
            LeaveAgentCrit();
            PrintFn("ReportEventsToSystray: failed to set desktop for agent thread error=%d\r\n", GetLastError());
            ReintKdPrint(BADERRORS, ("ReportEventsToSystray: failed to set desktop for agent thread error=%d\r\n", GetLastError()));
            return lResult;
        }

        // set our desktop to be that of the loggedon users desktop
        hdesktopCur = hdesktopUser;

    }


    LeaveAgentCrit();

    ReintKdPrint(INIT, ("ReportEventsToSystray: reporting message dwMessage=0x%x to the systray\r\n", dwMessage));

    // snapshot the state of the showing dialog
    // if we are about to terminate, the the terminateCSCUI will have
    // will also do the action below but will try to set the vfShowingOfflineDlg
    // variable to 0xffffffff
    // If fOk was not set to 0xffffffff, then we know that we are not terminating
    // and we set vfShowingOfflineDlg to 1. This will block the terminating guy
    // and he will not free the library till thei variable gets set to FALSE;

    fOk = (BOOL)InterlockedExchange((PLONG)&vfShowingOfflineDlg, 1);

    if (fOk == 0)
    {
        if (vlpfnCSCUISetState)
        {

            lResult = (vlpfnCSCUISetState)(dwMessage, dwWParam, dwLParam);

            // change the value of vfShowingOfflineDlg to 0 only if it is 1 right now
            // it can be something other than 1 if we are about to terminate

            if((DWORD)InterlockedCompareExchange(&vfShowingOfflineDlg, 0, 1) == 0xffffffff)
            {
                // if we came here then we are terminating, set a termination value
                // so that the logoff thread will stop doing a sleep loop
                // and if we came here again fOk will never be 0
                vfShowingOfflineDlg = 0xfffffffe;
            }

        }
        else
        {
            // Not showing any dialog, restore the variable back to what it should be
            vfShowingOfflineDlg = 0;
            PrintFn("ReportEventsToSystray: CSCUI not initalized\r\n");
        }
    }

    return lResult;
}

BOOL
GetNameOfServerGoingOfflineEx(
    HANDLE  hShadowDB,
    _TCHAR  **lplptzServerName,
    DWORD   *lpdwSize,
    BOOL    *lpfAllocated
    )
/*++

Routine Description:

    This routine is called in winlogon thread to findout which server is about to go offline
    The routine may allocate memory, which must be freed by the caller
    
Parameters:

Return Value:

Notes:

--*/
{
    DWORD   dwSize, i;
    BOOL    fRet = FALSE;

    dwSize = *lpdwSize;
    *lpfAllocated = FALSE;

    for (i=0;i<2;++i)
    {

        if(!GetNameOfServerGoingOffline(
                    hShadowDB,
                    (LPBYTE)(*lplptzServerName), &dwSize))
        {
            // if we need a bigger buffer go get one
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                // we shouldn't be trying to get a bigger buffer twice
                // it should have been sufficient the first time around

                if (i==1)
                {
                    Assert(FALSE);                    
                    break;
                }

                ReintKdPrint(MAINLOOP, ("GetNameOfServerGoingOfflineEx: Need %d sized Buffer \n", dwSize));
                *lplptzServerName = LocalAlloc(LPTR, dwSize);

                if (!*lplptzServerName)
                {
                    return FALSE;                
                }

                *lpfAllocated = TRUE;
                *lpdwSize = dwSize;

                continue;                
            }
            else
            {
                break;
            }
        }
        else
        {
            // ReintKdPrint(MAINLOOP,("GetNameOfServerGoingOfflineEx:name=%ws\n", *lplptzServerName));
            fRet = TRUE;
            break;
        }
    }

    // cleanup on error
    if (!fRet && *lpfAllocated)
    {
        LocalFree(*lplptzServerName);
        *lpfAllocated = FALSE;
    }

    return fRet;
}

BOOL
IsWinlogonRegValueSet(HKEY hKey, LPSTR pszKeyName, LPSTR pszPolicyKeyName, LPSTR pszValueName)
{
    BOOL bRet = FALSE;
    DWORD dwType;
    DWORD dwSize;
    HKEY hkey;

    //
    //  first check the per-machine location.
    //
    if (RegOpenKeyExA(hKey, pszKeyName, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(bRet);
        if (RegQueryValueExA(hkey, pszValueName, NULL, &dwType, (LPBYTE)&bRet, &dwSize) == ERROR_SUCCESS)
        {
            if (dwType != REG_DWORD)
            {
                bRet = FALSE;
            }
        }
        RegCloseKey(hkey);
    }
    //
    //  then let the policy value override
    //
    if (RegOpenKeyExA(hKey, pszPolicyKeyName, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(bRet);
        if (RegQueryValueExA(hkey, pszValueName, NULL, &dwType, (LPBYTE)&bRet, &dwSize) == ERROR_SUCCESS)
        {
            if (dwType != REG_DWORD)
            {
                bRet = FALSE;
            }
        }
        RegCloseKey(hkey);
    }

    return bRet;
}



BOOL
CheckIsSafeModeType(DWORD dwSafeModeType)
{

    BOOL bResult = FALSE;
    HKEY hkey;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      TEXT("SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Option"),
                                      0,
                                      KEY_QUERY_VALUE,
                                      &hkey))
    {
     DWORD dwType;
        DWORD dwValue;
        DWORD cbValue = sizeof(dwValue);

        if (ERROR_SUCCESS == RegQueryValueEx(hkey,
                                             TEXT("OptionValue"),
                                             NULL,
                                             &dwType,
                                             (LPBYTE)&dwValue,
                                             &cbValue))
        {
            bResult = (dwValue == dwSafeModeType);
        }
        RegCloseKey(hkey);
    }
    return bResult;
}




BOOL
AllowMultipleTsSessions(void)
{
    return IsWinlogonRegValueSet(HKEY_LOCAL_MACHINE,
                                "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                                "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies\\system",
                                "AllowMultipleTSSessions");
}



BOOL
IsSafeMode(void)
{
    return CheckIsSafeModeType(SAFEBOOT_MINIMAL) ||
           CheckIsSafeModeType(SAFEBOOT_NETWORK);
}



BOOL
IsTerminalServicesEnabled(void)

{
    OSVERSIONINFOEX osVersionInfo;
    DWORDLONG dwlConditionMask;

    dwlConditionMask = 0;
    ZeroMemory(&osVersionInfo, sizeof(osVersionInfo));
    osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);
    osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS;
    VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);
    return(VerifyVersionInfo(&osVersionInfo, VER_SUITENAME, dwlConditionMask) != FALSE);
}



BOOL
IsMultipleUsersEnabled(void)
{
    return IsTerminalServicesEnabled() &&
           !IsSafeMode() &&
           AllowMultipleTsSessions();
}

 
BOOL CanCSCLivewithTS(
	VOID)

/*++

Routine Description:
	Checks if TS settings are ok to turn on csc.
	
Arguments:
	None
	
Return Value:
	TRUE - Enable CSC
	FALSE - Disable CSC
	
--*/
{
	
	if (IsWorkstation ()) // for pro and per
	{
		
	// csc does not work with Fast user switching.
		return !IsFastUserSwitchingEnabled();
	}
	else // for servers
	{
		//Both conditions have to be true
		return !(IsTerminalServicesEnabled() && AreConnectionsAllowed());
	}
	
}



BOOL AreConnectionsAllowed (
	VOID)

/*++

Routine Description:
	Checks if TS accepts connections.
	
Arguments:
	None
	
Return Value:
	TRUE - Accepts connections
	FALSE - Denys connections
	
--*/

{
    DWORD dwError;
    HKEY hkey;

	dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      TEXT("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"),
                                      0,
                                      KEY_QUERY_VALUE,
                                      &hkey);
    
    if (ERROR_SUCCESS == dwError)
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD cbValue = sizeof(dwValue);

        if (ERROR_SUCCESS == RegQueryValueEx(hkey,
                                             TEXT("fDenyTSConnections"),
                                             NULL,
                                             &dwType,
                                             (LPBYTE)&dwValue,
                                             &cbValue))
		
        {
            return !dwValue;
        }
    }
    
    //
    // could not read registry, this means connections were allowed.
    //
    return TRUE;
}


BOOL
IsFastUserSwitchingEnabled(
    VOID)

/*++

Routine Description:

    Checks to see if Terminal Services Fast User Switching is enabled.  This is
    to check if we should use the physical console session for UI dialogs, or
    always use session 0.

    Fast User Switching exists only on workstation product version, where terminal
    services are available, when AllowMultipleTSSessions is set.

    On server and above, or when multiple TS users are not allowed, session 0
    can only be attached remotely be special request, in which case it should be
    considered the "Console" session.

Arguments:

    None.

Return Value:

    Returns TRUE if Fast User Switching is currently enabled, FALSE otherwise.

--*/

{
    static BOOL bVerified = FALSE;
    static BOOL bIsTSWorkstation = FALSE;

    HKEY   hKey;
    ULONG  ulSize, ulValue;
    BOOL   bFusEnabled;

    //
    // Verify the product version if we haven't already.
    //
    if (!bVerified) {
        OSVERSIONINFOEX osvix;
        DWORDLONG dwlConditionMask = 0;

        ZeroMemory(&osvix, sizeof(OSVERSIONINFOEX));
        osvix.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

        osvix.wProductType = VER_NT_WORKSTATION;
        VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_LESS_EQUAL);

        osvix.wSuiteMask = VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS;
        VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

        if (VerifyVersionInfo(&osvix,
                              VER_PRODUCT_TYPE | VER_SUITENAME,
                              dwlConditionMask)) {
            bIsTSWorkstation = TRUE;
        }

        bVerified = TRUE;
    }

    //
    // Fast user switching (FUS) only applies to the Workstation product where
    // Terminal Services are enabled (i.e. Personal, Professional).
    //
    if (!bIsTSWorkstation) {
        return FALSE;
    }

    //
    // Check if multiple TS sessions are currently allowed.  We can't make this
    // info static because it can change dynamically.
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                     0,
                     KEY_READ,
                     &hKey) != ERROR_SUCCESS) {
        return FALSE;
    }

    ulValue = 0;
    ulSize = sizeof(ulValue);
    bFusEnabled = FALSE;

    if (RegQueryValueEx(hKey,
                        TEXT("AllowMultipleTSSessions"),
                        NULL,
                        NULL,
                        (LPBYTE)&ulValue,
                        &ulSize) == ERROR_SUCCESS) {
        bFusEnabled = (ulValue != 0);
    }
    RegCloseKey(hKey);

    return bFusEnabled;

} // IsFastUserSwitchingEnabled



BOOL
IsWorkstation(
	VOID)
 
/*++

Routine Description:
	Checks if the machine is a workstation.
	
Arguments:
	None
	
Return Value:
	TRUE - is workstation.
	FALSE - is not a workstation.
	
--*/
{
   
    
	OSVERSIONINFOEX osvix;
    DWORDLONG dwlConditionMask = 0;

    ZeroMemory(&osvix, sizeof(OSVERSIONINFOEX));
    osvix.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    osvix.wProductType = VER_NT_WORKSTATION;
    VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_LESS_EQUAL);


    if (VerifyVersionInfo(&osvix,
                          VER_PRODUCT_TYPE,
                          dwlConditionMask)) {
         return TRUE;
    }
	return FALSE;

    

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\utils.c ===
#include "pch.h"
#pragma hdrstop

#ifndef CSC_ON_NT
#ifndef DBG
#define DBG 0
#endif
#if DBG
#define DEBUG
#else
//if we don't do this DEBUG is defined in shdsys.h....sigh
#define NONDEBUG
#endif
#endif

#include "shdsys.h"
#include "utils.h"
#include "lib3.h"
#include "reint.h"
#include "regstr.h"
#include "record.h"
#include "oslayeru.h"

#define PUBLIC   FAR   PASCAL
#define PRIVATE  NEAR  PASCAL
#define cNull        0
#define SIGN_BIT 0x80000000
#define cBackSlash    _T('\\')
#define    DEFAULT_CACHE_PERCENTAGE    10


extern char vrgchBuff[1024];
extern HWND vhwndMain;

static TCHAR vszTemp[] = _TEXT("TEMP");
static TCHAR vszPrefix[] = _TEXT("C");
static const char vszCSCDirName[]="CSC";


AssertData;
AssertError;

static const _TCHAR szStarDotStar[] = _TEXT("\\*.*");

#ifdef CSC_ON_NT
#else
const TCHAR vszRNAKey[] = REGSTR_PATH_SERVICES "\\RemoteAccess";
const TCHAR vszRNAValue[] = "Remote Connection";
const TCHAR VREDIR_DEVICE_NAME[] = "\\\\.\\VREDIR";
#endif

PWCHAR TempDirs[] = {
        L"TEMP",
        L"TMP",
        L"USERPROFILE",
        NULL };

BOOL
GetCSCFixedDisk(
    TCHAR   *lptzDrive
    );


#ifdef LATER
LPSTR PUBLIC LpGetServerPart(
   LPSTR lpPath,
   LPSTR lpBuff,
   int cBuff
   )
   {
   LPSTR lp = lpPath;
   char c;
   int count;

   if ((*lp++ != cBackSlash)||(*lp++ != cBackSlash))
      return NULL;
   lp = MyStrChr(lp, cBackSlash);
   if (cBuff && lp)
      {
      count = (int)((unsigned long)lp, (unsigned long)lpPath)
      count = min(cBuff-1, count);

      // Nobody should give us bad cBuff values
      Assert(count >=0);
      strncpy(lpBuff, lpPath, count);
      lpBuff[count] = cNull;
      }
   return lp;  // Points to '\' if succeeded
   }
#endif //LATER

LPTSTR PUBLIC LpGetServerPart(
   LPTSTR lpPath,
   LPTSTR lpBuff,
   int cBuff
   )
{
    LPTSTR lp = lpPath;

    if (*(lp+1)!=_T(':'))
        return NULL;

    if (*(lp+2)!=_T('\\'))
        return NULL;

    if (cBuff)
    {
        *lpBuff = *lp;
        *(lpBuff+1) = *(lp+1);
        *(lpBuff+2) = cNull;
    }

    lp += 2;

    return lp;  // Points to '\' if succeeded
}

LPTSTR PUBLIC LpGetNextPathElement(
   LPTSTR lpPath,
   LPTSTR lpBuff,
   int cBuff
   )
{
    LPTSTR lp;
    int bytecount;

    if (*lpPath == cBackSlash)
        ++lpPath;

    lp = MyStrChr(lpPath, cBackSlash);

    if (cBuff)
    {
       // Is this a leaf?
        if (lp)
        {  // No
            Assert(*lp == cBackSlash);

            bytecount = (int)((ULONG_PTR)lp-(ULONG_PTR)lpPath);
            bytecount = min(cBuff-1, bytecount);
        }
        else  // Yes
            bytecount = lstrlen(lpPath) * sizeof(_TCHAR);

       Assert(bytecount >= 0);

       memcpy(lpBuff, lpPath, bytecount);

       lpBuff[bytecount/sizeof(_TCHAR)] = cNull;
    }

    return lp;
}

LPTSTR PUBLIC GetLeafPtr(
   LPTSTR lpPath
   )
   {
   LPTSTR lp, lpLeaf;

   // Prune the server part
   if (!(lp=LpGetServerPart(lpPath, NULL, 0)))
      lp = lpPath;

   for (;lp;)
      {
      // Step over the '\'
      if (*lp==cBackSlash)
         lp++;

      // call this the leaf, pending confirmation
      lpLeaf = lp;

      // See if there is another element
      lp = LpGetNextPathElement(lp, NULL, 0);
      }

   return (lpLeaf);
   }





//
//

LPTSTR
LpBreakPath(
    LPTSTR lpszNextPath,
    BOOL fFirstTime,
    BOOL *lpfDone
    )
{

    LPTSTR    lpT = lpszNextPath;

    if(fFirstTime)
    {
        if (MyPathIsUNC(lpT))
        {
            lpT +=2;    /* step over \ */

            /* look for \\server\ <------------- */
            lpT = MyStrChr(lpT, cBackSlash);

            if (lpT)
            {
                ++lpT; /* step over \ */

                lpT = MyStrChr(lpT, cBackSlash);

                if (!lpT)
                {
                    /* \\server\share */
                    *lpfDone = TRUE;
                }
                else
                {
                    /* \\server\\share\foo...... */
                    if (!*(lpT+1))
                    {
                        /* \\server\share\ */
                        *lpfDone = TRUE;
                    }

                    *lpT = 0;
                }
            }
        }
        else
        {
            lpT = NULL;
        }
    }
    else    // not the first time
    {
        Assert(*lpT != cBackSlash);

        lpT = MyStrChr(lpT, cBackSlash);

        if(!lpT)
        {
            *lpfDone=TRUE;
        }
        else
        {
            if(*(lpT+1) == 0)
            {// ends in a slash
                *lpfDone = TRUE;
            }

            *lpT = (char) 0;
        }
    }
    return (lpT);
}

void
RestorePath(
    LPTSTR    lpszPtr
)
{
    *lpszPtr = cBackSlash;

}


BOOL
FindCreateShadowFromPath(
    LPCTSTR                lpszFile,
    BOOL                fCreate,    // create if necessary
    LPWIN32_FIND_DATA   lpFind32,
    LPSHADOWINFO        lpSI,
    BOOL                *lpfCreated
    )
{
    HANDLE     hShadowDB = INVALID_HANDLE_VALUE, hFind;
    int done=0, first=1, fWasFirst;
    HSHADOW hDir=0, hShadow=0;
    TCHAR szParsePath[MAX_PATH], szSave[sizeof(szStarDotStar)];
    LPTSTR    lpszCurrent, lpszNext;
    BOOL    fInCreateMode = FALSE, fRet = FALSE, fDisabledShadowing = FALSE;
    DWORD    dwError = ERROR_SUCCESS, dwT;

    // do basic check
    if (lstrlen(lpszFile) >= MAX_PATH)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    hShadowDB = OpenShadowDatabaseIO();

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    if (lpfCreated)
    {
        *lpfCreated = FALSE;
    }

#ifndef CSC_ON_NT

    if (fCreate)
    {
        if (!DisableShadowingForThisThread(hShadowDB))
        {
            dwError = ERROR_NO_SYSTEM_RESOURCES;
            goto bailout;
        }

        fDisabledShadowing = TRUE;

    }
#endif

    // make a copy so we can party on it
    lstrcpy(szParsePath, lpszFile);
    lpszCurrent = szParsePath;

    do
    {
        hDir = hShadow;

        lpszNext = LpBreakPath(lpszCurrent, first, &done);

        if (!lpszNext && !done)
        {
                dwError = (ERROR_INVALID_PARAMETER);

                goto bailout;
        }

        fWasFirst = first;
        first = 0;    // not first anymore

        lstrcpy(lpFind32->cFileName, lpszCurrent);
        lpFind32->cAlternateFileName[0] = 0;    // !!!! very important, otherwise all CSC APIs
                                                //  may AV on win9x becuase of multibytetowidechar translation
                                                // in Find32AToFind32W in lib3\misc.c

        if (!fInCreateMode)
        {
            if (!GetShadowEx(hShadowDB, hDir, lpFind32, lpSI))
            {
                dwError = GetLastError();
                goto bailout;
            }
            else
            {
                if (!lpSI->hShadow)
                {
                    fInCreateMode = TRUE;
                }
                else
                {
                    Assert(hDir == lpSI->hDir);

                    hShadow = lpSI->hShadow;
                }
            }
        }

        if (fInCreateMode)
        {

            if (fCreate)
            {
                fInCreateMode = TRUE;

                if (fWasFirst)
                {
                    if (!GetWin32Info(szParsePath, lpFind32))
                    {
                        dwError = GetLastError();
                        goto bailout;
                    }

                    lstrcpy(lpFind32->cFileName, szParsePath);
                    lpFind32->cAlternateFileName[0] = 0;

                }
                else
                {
                    hFind = FindFirstFile(szParsePath, lpFind32);
                    // this would fail if we are in disconnected state
                    // becuase we don't have the shadow yet
                    if(INVALID_HANDLE_VALUE == hFind)
                    {
                        dwError = GetLastError();
                        goto bailout;
                    }
                    else
                    {
                        FindClose(hFind);
                    }
                }

                if (!CreateShadow(
                                     hShadowDB,
                                     hDir,
                                     lpFind32,
                                     SHADOW_SPARSE,
                                     &hShadow))
                {
                    dwError = GetLastError();
                    goto bailout;
                }

                // there can be a situation where, the share is also newly created, in which case
                // the hShare is not set. This is our way of doing that.

                if (!lpSI->hShare)
                {
                    if (!GetShadowEx(hShadowDB, hDir, lpFind32, lpSI))
                    {
                        dwError = GetLastError();
                        goto bailout;
                    }
                }

#ifdef CSC_ON_NT
                // on NT we open the file to get the right
                // security credentials
                if (!(lpFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                {
                    HANDLE hFile;

                    // this should be the last guy
                    hFile = CreateFile(szParsePath,
                                             GENERIC_READ,
                                             FILE_SHARE_READ,
                                             NULL,
                                             OPEN_EXISTING,
                                             0,
                                             NULL);
                    if (hFile != INVALID_HANDLE_VALUE)
                    {
                        CloseHandle(hFile);
                    }
                    else
                    {
                        dwError = GetLastError();
                        DeleteShadow(hShadowDB, hDir, hShadow);
                        goto bailout;
                    }
#endif
                }
            }
            else
            {
                // check if we were just supposed to report the status
                // of a connected share which is not in the database
                if (!(fWasFirst && done))
                {
                    dwError = ERROR_FILE_NOT_FOUND;
                }
                else if (lpSI->uStatus & SHARE_CONNECTED)
                {
                    fRet = TRUE;
                }
                goto bailout;
            }

            lpSI->hDir = hDir;
            lpSI->hShadow = hShadow;
            lpSI->uStatus = SHADOW_SPARSE;
            lpSI->ulHintPri = 0;
        }

        if (lpszNext)
        {
            RestorePath(lpszNext);

            lpszCurrent = lpszNext+1;
        }
        else
        {
            Assert(done);
        }

    } while (hShadow && !done);

    fRet = TRUE;

    if (lpfCreated)
    {
        *lpfCreated = fInCreateMode;
    }

bailout:

    if (fDisabledShadowing)
    {
        EnableShadowingForThisThread(hShadowDB);
    }

    CloseShadowDatabaseIO(hShadowDB);

    if (!fRet)
    {
        SetLastError(dwError);
    }

    return fRet;
}


BOOL
IsShareReallyConnected(
    LPCTSTR  lpszShareName
    )
{
    WIN32_FIND_DATA sFind32;
    HSHADOW hShadow;
    ULONG   uStatus;

    memset(&sFind32, 0, sizeof(sFind32));

    lstrcpyn(sFind32.cFileName, lpszShareName, MAX_PATH-1);

    if (GetShadow(INVALID_HANDLE_VALUE, 0, &hShadow, &sFind32, &uStatus))
    {
        if ((uStatus & SHARE_CONNECTED) && !(uStatus & SHARE_SHADOWNP))
        {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
AnyActiveNets(
    BOOL *lpfSlowLink
    )
{
    BOOL fOffline;

    if(IsServerOfflineW(INVALID_HANDLE_VALUE, NULL, &fOffline)) {
        // DbgPrint("AnyActiveNets returning %d\n", fOffline);
        return fOffline;
    }
    // DbgPrint("AnyActiveNets: IsServerOffline errored out!!\n");
    return FALSE;
}

BOOL
GetWideStringFromRegistryString(
    IN  LPSTR   lpszKeyName,
    IN  LPSTR   lpszParameter,  // value name
    OUT LPWSTR  *lplpwzList,    // wide character string
    OUT LPDWORD lpdwLength      // length in bytes
    )

/*++

Routine Description:

    reads a registry string and converts it to widechar

Arguments:

    lpszParameter       - registry parameter

    lplpwzList          - wide character string

    lpdwLength          - size of the widechar string

Return Value:

    DWORD
        Success - TRUE

        Failure - FALSE, GetLastError() returns the actual error

--*/

{
    HKEY    hKey = NULL;
    DWORD   dwData=1;
    DWORD   dwLen = 0;
    LPSTR   lpszString = NULL;
    BOOL    fRet = FALSE;

    *lplpwzList = NULL;
    *lpdwLength = 0;

    ReintKdPrint(INIT, ("Opening key\r\n"));
    if (RegCreateKeyExA(HKEY_LOCAL_MACHINE,
                    (lpszKeyName)?lpszKeyName:REG_KEY_CSC_SETTINGS_A,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_READ,
                    NULL,
                    &hKey,
                    &dwData) == ERROR_SUCCESS)
    {
        ReintKdPrint(INIT, ("getting size for value %s\r\n", lpszParameter));

        if(RegQueryValueExA(hKey, lpszParameter, NULL, NULL, NULL, &dwLen)==
           ERROR_SUCCESS)
        {
            lpszString = (LPSTR)LocalAlloc(LPTR, dwLen+1);

            if (lpszString)
            {
                dwData = dwLen+1;

                ReintKdPrint(INIT, ("getting value %s\r\n", lpszParameter));
                if(RegQueryValueExA(hKey, lpszParameter, NULL, NULL, lpszString, &dwData)
                    ==ERROR_SUCCESS)
                {
                    ReintKdPrint(INIT, ("value for %s is %s\r\n", lpszParameter, lpszString));

                    *lplpwzList = LocalAlloc(LPTR, *lpdwLength = dwData * sizeof(WCHAR));

                    if (*lplpwzList)
                    {
                        if (MultiByteToWideChar(CP_ACP, 0, lpszString, dwLen, *lplpwzList, *lpdwLength))
                        {
                            fRet = TRUE;
                            ReintKdPrint(INIT, ("Unicode value for %s is %ls\r\n", lpszParameter, *lplpwzList));
                        }

                    }
                }

            }
        }
    }

    if (lpszString)
    {
        LocalFree(lpszString);
    }

    if(hKey)
    {
        RegCloseKey(hKey);
    }

    if (!fRet)
    {
        if (*lplpwzList)
        {
            LocalFree(*lplpwzList);
            *lplpwzList = NULL;
        }
    }

    return fRet;
}


LPTSTR
GetTempFileForCSC(
    LPTSTR  lpszBuff
)
/*++

Routine Description:

    Generates a temporary filename prototype.  Checks %temp%, %tmp% and then
    %userprofiles%.  The temp directory has to be local.

Arguments:

    lpszBuff    If NULL, the routine will allocate space for returning the path
                If non-NULL this must be big enough to fit MAX_PATH characters

Returns:

    returns NULL if failed
    returns pointer to the buffer containing the path to use.
            If lpszBuff was non-NULL, the return value is the same as lpszBuff



Notes:

--*/
{
    LPTSTR TempName = NULL;
    DWORD nRet = 0;
    ULONG i;
    WCHAR TmpPath[MAX_PATH];
    WCHAR TmpPrefix[32];
    WCHAR Drive[4] = L"X:\\";
    BOOLEAN GotOne = FALSE;

    // check if caller wants us to allocate
    if (lpszBuff) {
        TempName = lpszBuff;
    } else {
        // caller must free
        TempName = LocalAlloc(LPTR, MAX_PATH * sizeof(TCHAR));
        if (TempName == NULL)
            return NULL;
    }

    wsprintf(TmpPrefix, L"%ws%x", vszPrefix, (GetCurrentThreadId() & 0xff));

    //
    // Find the temp directory
    //
    for (i = 0; TempDirs[i] != NULL && GotOne == FALSE; i++) {
        // DbgPrint("Trying %ws\n", TempDirs[i]);
        nRet = GetEnvironmentVariable(TempDirs[i], TmpPath, MAX_PATH);
        if (nRet >= 4 && nRet <= MAX_PATH) {
            // DbgPrint("%ws=%ws\n", TempDirs[i], TmpPath);
            Drive[0] = TmpPath[0];
            if (
                TmpPath[1] == L':'
                    &&
                TmpPath[2] == L'\\'
                    &&
                GetDriveType(Drive) == DRIVE_FIXED
            ) {
                if (GetTempFileName(TmpPath, TmpPrefix, 0, TempName)) {
                    // DbgPrint("CSC TempName=%ws\n", TempName);
                    GotOne = TRUE;
                }
            }
        }
    }

    if (GotOne == FALSE) {
        // Cleanup if we failed
        LocalFree(TempName);
        TempName = NULL;
    } else {
        // Delete file on success, as it might be encrypted
        DeleteFile(TempName);
    }

    return TempName;
}

BOOL
GetCSCFixedDisk(
    TCHAR   *lptzDrive
    )
/*++

Routine Description:

    Looks for a fixed disk drive.

Arguments:

    lptzDrive   retruns drive letter if successful.

Returns:

    TRUE if successful, FALSE if no fixed disk is found

Notes:


    OBSOLETE uses a hacky way of finding out the fixed disk. RemoteBoot lies to us and tells us that
    c: is a fixed disk.


--*/
{
    int i;
    WIN32_FIND_DATA sFind32;

    if (GetShadowDatabaseLocation(INVALID_HANDLE_VALUE, &sFind32))
    {
        if (sFind32.cFileName[1] == _TEXT(':'))
        {
            lptzDrive[0] = sFind32.cFileName[0];
            lptzDrive[1] = sFind32.cFileName[1];
            lptzDrive[2] = sFind32.cFileName[2];
            lptzDrive[3] = 0;
            return TRUE;
        }
        else
        {
            lptzDrive[0] = _TEXT('d');
        }
        lptzDrive[1] = _TEXT(':');lptzDrive[2] = _TEXT('\\');lptzDrive[3] = 0;

        for (i=0; i<24; ++i)
        {
            if(GetDriveType(lptzDrive) == DRIVE_FIXED)
            {
                return TRUE;
            }
            lptzDrive[0]++;
        }
    }

    return FALSE;
}


BOOL
SetRegValueDWORDA(
    IN  HKEY    hKey,
    IN  LPCSTR  lpSubKey,
    IN  LPCSTR  lpValueName,
    IN  DWORD   dwValue
    )
/*++

Routine Description:

    Helper regsistry routine

Arguments:

Returns:

    TRUE if successful. If FALSE, GetLastError() gives the actual error code

Notes:

--*/
{
    HKEY    hSubKey = 0;
    DWORD   dwType;
    BOOL    fRet = FALSE;

    if(RegOpenKeyA(hKey, lpSubKey, &hSubKey) ==  ERROR_SUCCESS)
    {
        if (RegSetValueExA(hSubKey, lpValueName, 0, REG_DWORD, (PBYTE)&dwValue, sizeof(DWORD))
             == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }
        RegCloseKey(hSubKey);
    }
    return fRet;
}

BOOL
QueryRegValueDWORDA(
    IN  HKEY    hKey,
    IN  LPCSTR  lpSubKey,
    IN  LPCSTR  lpValueName,
    OUT LPDWORD lpdwValue
    )
/*++

Routine Description:

    Helper regsistry routine

Arguments:

Returns:

    TRUE if successful. If FALSE, GetLastError() gives the actual error code

Notes:

--*/
{

    HKEY    hSubKey;
    DWORD   dwType, dwSize;
    BOOL    fRet = FALSE;
    
    if(RegOpenKeyA(hKey, lpSubKey, &hSubKey) ==  ERROR_SUCCESS)
    {
        dwSize = sizeof(DWORD);

        if (RegQueryValueExA(hSubKey, lpValueName, 0, &dwType, (PBYTE)lpdwValue, &dwSize)
             == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }

        RegCloseKey(hSubKey);
    }
    return fRet;
}

BOOL
DeleteRegValueA(
    IN  HKEY    hKey,
    IN  LPCSTR  lpSubKey,
    IN  LPCSTR  lpValueName
    )
/*++

Routine Description:

    Helper regsistry routine

Arguments:

Returns:

    TRUE if successful. If FALSE, GetLastError() gives the actual error code

Notes:

--*/
{
    HKEY    hSubKey;
    BOOL    fRet = FALSE;
    
    if(RegOpenKeyA(hKey, lpSubKey, &hSubKey) ==  ERROR_SUCCESS)
    {
        if(RegDeleteValueA(hSubKey, lpValueName) == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }

        RegCloseKey(hSubKey);
    }

    return fRet;

}

BOOL
QueryFormatDatabase(
    VOID
    )
/*++

Routine Description:

    Helper regsistry routine

Arguments:

Returns:

    TRUE if successful. If FALSE, GetLastError() gives the actual error code

Notes:

--*/
{
    DWORD dwSize, dwTemp=0;
    HKEY hKey = NULL;
    BOOL    fFormat = FALSE;

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                    REG_STRING_NETCACHE_KEY,
                    0,
                    KEY_READ | KEY_WRITE,
                    &hKey
                    ) == ERROR_SUCCESS)
    {

        dwSize = sizeof(dwTemp);
        dwTemp = 0;

        if (RegQueryValueEx(hKey, REG_VALUE_FORMAT_DATABASE, NULL, NULL, (void *)&dwTemp, &dwSize) == ERROR_SUCCESS)
        {
            if(RegDeleteValue(hKey, REG_VALUE_FORMAT_DATABASE) != ERROR_SUCCESS)
            {
                // deliberte print to catch it in free builds as well
                OutputDebugStringA("Not Formatting.. Failed to delete  REG_VALUE_FORMAT_DATABASE_A \n");
            }
            else
            {
                fFormat = TRUE;
            }

        }
        RegCloseKey(hKey);
        hKey = NULL;
    }
    else
    {
        hKey = NULL;
    }


    if(hKey)
    {
        RegCloseKey(hKey);
    }
    return fFormat;
}


BOOL
InitValues(
    LPSTR   lpszDBDir,
    DWORD   cbDBDirSize,
    LPDWORD lpdwDBCapacity,
    LPDWORD lpdwClusterSize
    )
/*++

Routine Description:

    Returns init values to init CSC database and enable CSC

Arguments:

Returns:

    TRUE if successful. If FALSE, GetLastError() gives the actual error code

Notes:

--*/
 {
    HKEY hKeyShadow;
    int iSize;
    DWORD dwType;
    UINT lenDir;
    BOOL    fInitedDir = FALSE, fInitedSize=FALSE;
    unsigned uPercent;


    if(RegOpenKeyA(HKEY_LOCAL_MACHINE, REG_STRING_NETCACHE_KEY_A, &hKeyShadow) ==  ERROR_SUCCESS)
    {
        iSize = (int)cbDBDirSize;

        if(RegQueryValueExA(hKeyShadow, REG_STRING_DATABASE_LOCATION_A, NULL, &dwType, lpszDBDir, &iSize)==ERROR_SUCCESS)
        {
            if ((iSize+SUBDIR_STRING_LENGTH+2)<MAX_PATH)
            {
                iSize = sizeof(DWORD);

                fInitedDir = TRUE;

                if(RegQueryValueExA(hKeyShadow, REG_VALUE_DATABASE_SIZE_A, NULL, &dwType, (LPBYTE)&uPercent, &iSize)==ERROR_SUCCESS)
                {
                    if ((uPercent <= 100) &&
                        GetDiskSizeFromPercentage(lpszDBDir, uPercent, lpdwDBCapacity, lpdwClusterSize))
                    {
                        fInitedSize = TRUE;
                    }
                }

            }

        }

        RegCloseKey(hKeyShadow);
    }

    if (!fInitedDir)
    {
        // try the default

        if(!(lenDir=GetWindowsDirectoryA(lpszDBDir, cbDBDirSize)))
        {
            DEBUG_PRINT(("InitValuse: GetWindowsDirectory failed, error=%x \r\n", GetLastError()));
            Assert(FALSE);
            return FALSE;
        }
        else
        {
            if ((lenDir+SUBDIR_STRING_LENGTH+2)>=MAX_PATH)
            {
                DEBUG_PRINT(("InbCreateDir: Windows dir name too big\r\n"));
                Assert(FALSE);

                // if even the default fails do the worst case thing.
                // this may also not be good enough as apparently in Japan
                // c: is not mandatory

                return FALSE;
            }
            else
            {
                if (lpszDBDir[lenDir-1]!='\\')
                {
                    lpszDBDir[lenDir++] = '\\';
                    lpszDBDir[lenDir] = 0;
                }

                lstrcatA(lpszDBDir, vszCSCDirName);
            }

        }
    }

    Assert(lpszDBDir[1]==':');

    if (!fInitedSize)
    {
        if(!GetDiskSizeFromPercentage(lpszDBDir, DEFAULT_CACHE_PERCENTAGE, lpdwDBCapacity, lpdwClusterSize))
        {
            return FALSE;
        }

    }

//    DEBUG_PRINT(("InitValues: CSCDb at %s Size = %d \r\n", lpszDBDir, *lpdwDBCapacity));
    return TRUE;
}

BOOL
GetDiskSizeFromPercentage(
    LPSTR   lpszDir,
    unsigned    uPercent,
    DWORD       *lpdwSize,
    DWORD       *lpdwClusterSize
    )
{
    char szDrive[4];
    DWORD dwSPC, dwBPS, dwFreeC, dwTotalC;
    ULONGLONG   ullSize = 0;

    *lpdwSize = 0;

    memset(szDrive, 0, sizeof(szDrive));
    memcpy(szDrive, lpszDir, 3);

    if(!GetDiskFreeSpaceA(szDrive, &dwSPC, &dwBPS, &dwFreeC, &dwTotalC )){
        return FALSE;
    }
    else
    {
//        DEBUG_PRINT(("dwSPC=%d dwBPS=%d uPercent=%d dwTotalC=%d \r\n",
//                     dwSPC, dwBPS, uPercent, dwTotalC));

        ullSize = (((ULONGLONG)dwSPC * dwBPS * uPercent)/100)*dwTotalC;
        
        // our max limit is 2GB
        if (ullSize > 0x7fffffff)
        {
            *lpdwSize = 0x7fffffff;                        
        }
        else
        {
            *lpdwSize = (DWORD)ullSize;
        }
        *lpdwClusterSize = dwBPS * dwSPC;
    }
    return (TRUE);
}

#ifdef MAYBE_USEFULE
typedef struct tagCSC_NAME_CACHE_ENTRY
{
    DWORD   dwFlags;
    DWORD   dwTick;
    HSHADOW hDir;
    DWORD   dwSize;
    TCHAR  *lptzName;
}
CSC_NAME_CACHE_ENTRY, *LPCSC_NAME_CACHE_ENTRY;

CSC_NAME_CACHE_ENTRY rgCSCNameCache[16];

HANDLE vhNameCacheMutex;

#define CSC_NAME_CACHE_EXPIRY_DELTA 1000*10 // 10 seconds

BOOL
FindCreateCSCNameCacheEntry(
    LPTSTR  lptzName,
    DWORD   dwSize,
    HSHADOW *lphDir,
    BOOL    fCreate
    );

BOOL
FindCreateShadowFromPathEx(
    LPCTSTR                lpszFile,
    BOOL                fCreate,    // create if necessary
    LPWIN32_FIND_DATA   lpFind32,
    LPSHADOWINFO        lpSI,
    BOOL                *lpfCreated
    )
{
    BOOL fRet = FALSE, fIsShare, fFoundInCache = FALSE;
    TCHAR   *lpT;
    DWORD   cbSize;

    lpT = GetLeafPtr((LPTSTR)lpszFile);
    if (fIsShare = ((DWORD_PTR)lpT == (DWORD_PTR)lpszFile))
    {
        cbSize = lstrlen(lpT) * sizeof(_TCHAR);
    }
    else
    {
        cbSize = (DWORD_PTR)lpT - (DWORD_PTR)lpszFile - sizeof(_TCHAR);
    }

    if (!fIsShare)
    {
        if (!fCreate)
        {
            HSHADOW hDir;
            // just look it up first
            if (FindCreateCSCNameCacheEntry((LPTSTR)lpszFile, cbSize, &hDir, FALSE))
            {
                if (hDir != 0xffffffff)
                {
                    // found it
                    if (lpfCreated)
                    {
                        *lpfCreated = FALSE;
                    }
					//Bug 5512822 - navjotv
					cbSize = min(MAX_PATH-1,(lstrlen(lpT)));
                    lstrcpyn(lpFind32->cFileName, lpT, cbSize);
					lpFind32->cFileName[cbSize+1] = 0;
                    lpFind32->cAlternateFileName[0] = 0;
                    fRet = GetShadowEx(INVALID_HANDLE_VALUE, hDir, lpFind32, lpSI);
                }
                else
                {
                    DbgPrint("Found negative cache entry %ls \n", lpszFile);
                }
                fFoundInCache = TRUE;
            }
        }

    }

    if (!fFoundInCache)
    {
        // not found, do the normal thing
        fRet = FindCreateShadowFromPath((LPTSTR)lpszFile, fCreate, lpFind32, lpSI, lpfCreated);

        if (!fRet)
        {
            lpSI->hDir = lpSI->hShadow = 0xffffffff;            
        }

        if (fRet || (GetLastError() == ERROR_FILE_NOT_FOUND))
        {
            FindCreateCSCNameCacheEntry((LPTSTR)lpszFile, cbSize, (lpSI->hDir)?&lpSI->hDir:&lpSI->hShadow, TRUE);
        }

    }
    return fRet;
}

BOOL
FindCreateCSCNameCacheEntry(
    LPTSTR  lptzName,
    DWORD   dwSize,
    HSHADOW *lphDir,
    BOOL    fCreate
    )
{
    int i, indx=-1;
    DWORD   dwTick = GetTickCount();
    BOOL    fRet = FALSE;

    if (!vhNameCacheMutex)
    {
        return FALSE;        
    }

    WaitForSingleObject(vhNameCacheMutex, INFINITE);
    
    for (i=0; i<(sizeof(rgCSCNameCache)/sizeof(CSC_NAME_CACHE_ENTRY)); ++i)
    {
        if (!rgCSCNameCache[i].dwSize)
        {
            if (indx == -1)
            {
                indx = i;
            }
        }
        else if ((rgCSCNameCache[i].dwSize == dwSize ))
        {
            //non-zero size must mean a string has been allocated
            Assert(rgCSCNameCache[i].lptzName);

            if ((dwTick < rgCSCNameCache[i].dwTick)||
                ((dwTick > (rgCSCNameCache[i].dwTick+CSC_NAME_CACHE_EXPIRY_DELTA))))
            {
                DbgPrint("%ls expired\n", rgCSCNameCache[i].lptzName);
                // the entry has expired, nuke it
                rgCSCNameCache[i].dwSize = 0;
                FreeMem(rgCSCNameCache[i].lptzName);
                rgCSCNameCache[i].lptzName = NULL;
                continue;
            }

            // do a caseinsensitve comparison
            if ((CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, 
                                            lptzName, dwSize/sizeof(_TCHAR),
                                            rgCSCNameCache[i].lptzName,dwSize/sizeof(_TCHAR))
                                            == CSTR_EQUAL))
            {
                // match found
                DbgPrint("Match Found %ls\n", rgCSCNameCache[i].lptzName);
                if (fCreate)
                {
                    rgCSCNameCache[i].hDir = *lphDir;
                    // update the tick count
                    rgCSCNameCache[i].dwTick = dwTick;
                }
                else
                {
                    // we want to find it, return the directory
                    *lphDir = rgCSCNameCache[i].hDir;
                }
                fRet = TRUE;
                break;
            }
        }
    }

    // didn't find it, we are supposed to create and there is an empty slot
    if (!fRet && fCreate && (indx >= 0) )
    {
        rgCSCNameCache[indx].lptzName = AllocMem(dwSize+sizeof(_TCHAR));
        if (rgCSCNameCache[indx].lptzName)
        {
            memcpy(rgCSCNameCache[indx].lptzName, lptzName, dwSize);
            rgCSCNameCache[indx].dwSize = dwSize;
            rgCSCNameCache[indx].dwTick = dwTick;
            rgCSCNameCache[indx].hDir = *lphDir;
            fRet = TRUE;
            DbgPrint("Inserted %ls\n", rgCSCNameCache[indx].lptzName);
        }
    }
    
    ReleaseMutex(vhNameCacheMutex);

    return fRet;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\util\cscgetinfo\cscgetinfo.c ===
#define UNICODE
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winioctl.h>
#include <shdcom.h>

#include <smbdebug.h>

CHAR *ProgName = "cscgetinfo";

PBYTE InBuf[0x50];
PBYTE OutBuf = NULL;

#define STATUS_SUCCESS                   ((ULONG)0x00000000L)
#define STATUS_BUFFER_TOO_SMALL          ((ULONG)0xC0000023L)


_cdecl
main(LONG argc, CHAR *argv[])
{
    BOOL bResult;
    HANDLE  hShadow=NULL;
    ULONG junk;
    PULONG pl = NULL;
    PIOCTL_GET_DEBUG_INFO_ARG pInfoArg = NULL;
    ULONG i;
    ULONG j;
    ULONG BufSize = 0x1000;
    ULONG Cmd = DEBUG_INFO_SERVERLIST;
    // ULONG Cmd = DEBUG_INFO_CSCFCBSLIST;

TryAgain:

    OutBuf = malloc(BufSize);

    if (OutBuf == NULL) {
        printf("Couldn't alloc memory\n");
        return 0;
    }

    hShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hShadow == INVALID_HANDLE_VALUE) {
        printf("Failed open of shadow device\n");
        return 0;
    }

    memset(InBuf, 0, sizeof(InBuf));
    pl = (PULONG)InBuf;
    *pl = Cmd;

    bResult = DeviceIoControl(
                hShadow,                        // device 
                IOCTL_GET_DEBUG_INFO,           // control code
                (LPVOID)InBuf,                  // in buffer
                sizeof(InBuf),                  // inbuffer size
                (LPVOID)OutBuf,                 // out buffer
                BufSize,                        // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

    CloseHandle(hShadow);

    pInfoArg = (PIOCTL_GET_DEBUG_INFO_ARG) OutBuf;
    if (bResult && pInfoArg->Status == STATUS_SUCCESS) {
        if (Cmd == DEBUG_INFO_SERVERLIST) {
            for (i = 0; i < pInfoArg->EntryCount; i++) {
                OFFSET_TO_POINTER(pInfoArg->ServerEntryObject[i].Name, OutBuf);
                OFFSET_TO_POINTER(pInfoArg->ServerEntryObject[i].DomainName, OutBuf);
                OFFSET_TO_POINTER(pInfoArg->ServerEntryObject[i].DfsRootName, OutBuf);
                OFFSET_TO_POINTER(pInfoArg->ServerEntryObject[i].DnsName, OutBuf);
                OFFSET_TO_POINTER(pInfoArg->ServerEntryObject[i].pNetRoots, OutBuf);
                for (j = 0; j < pInfoArg->ServerEntryObject[i].NetRootEntryCount; j++)
                    OFFSET_TO_POINTER(pInfoArg->ServerEntryObject[i].pNetRoots[j].Name, OutBuf);
            }
            printf("Status:        0x%x\n"
                   "Version:       %d\n"
                   "Entries:       %d\n",
                       pInfoArg->Status,
                       pInfoArg->Version,
                       pInfoArg->EntryCount);
            for (i = 0; i < pInfoArg->EntryCount; i++) {
                printf("=================================================\n");
                printf("Name:                       %ws\n"
                       "DomainName:                 %ws\n"
                       "ServerStatus:               0x%x\n"
                       "DfsRootName:                %ws\n"
                       "DnsName:                    %ws\n"
                       "SecuritySignaturesEnabled:  0x%x\n"
                       "NetRootEntryCount:          0x%x\n"
                       "=================================================\n",
                            pInfoArg->ServerEntryObject[i].Name,
                            pInfoArg->ServerEntryObject[i].DomainName,
                            pInfoArg->ServerEntryObject[i].ServerStatus,
                            pInfoArg->ServerEntryObject[i].DfsRootName,
                            pInfoArg->ServerEntryObject[i].DnsName,
                            pInfoArg->ServerEntryObject[i].SecuritySignaturesEnabled,
                            pInfoArg->ServerEntryObject[i].NetRootEntryCount);
                for (j = 0; j < pInfoArg->ServerEntryObject[i].NetRootEntryCount; j++) {
                    printf("    Name:                       %ws\n"
                           "    MaximalAccessRights:        0x%x\n"
                           "    GuestMaximalAccessRights:   0x%x\n"
                           "    DfsAware:                   0x%x\n"
                           "    hShare:                     0x%x\n"
                           "    hRootDir:                   0x%x\n"
                           "    ShareStatus:                0x%x\n"
                           "    CscEnabled:                 0x%x\n"
                           "    CscShadowable:              0x%x\n"
                           "    Disconnected:               0x%x\n",
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].Name,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].MaximalAccessRights,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].GuestMaximalAccessRights,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].DfsAware,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].hRootDir,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].ShareStatus,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].CscEnabled,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].CscShadowable,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].Disconnected);
                    if (j < pInfoArg->ServerEntryObject[i].NetRootEntryCount-1)
                        printf("    --------------------------------------------\n");
                }
            }
            printf("=================================================\n");
        } else if (Cmd == DEBUG_INFO_CSCFCBSLIST) {
            for (i = 0; i < pInfoArg->EntryCount; i++) {
                OFFSET_TO_POINTER(pInfoArg->FcbEntryObject[i].DfsPrefix, OutBuf);
                OFFSET_TO_POINTER(pInfoArg->FcbEntryObject[i].ActualPrefix, OutBuf);
            }
            printf("Status:        0x%x\n"
                   "Version:       %d\n"
                   "Entries:       %d\n",
                       pInfoArg->Status,
                       pInfoArg->Version,
                       pInfoArg->EntryCount);
            for (i = 0; i < pInfoArg->EntryCount; i++) {
                printf("=================================================\n");
                printf("MFlags:                     0x%x\n"
                       "Tid:                        0x%x\n"
                       "ShadowIsCorrupt:            0x%x\n"
                       "hShadow:                    0x%x\n"
                       "hParentDir:                 0x%x\n"
                       "hShadowRenamed:             0x%x\n"
                       "hParentDirRenamed:          0x%x\n"
                       "ShadowStatus:               0x%x\n"
                       "LocalFlags:                 0x%x\n"
                       "LastComponentOffset:        0x%x\n"
                       "LastComponentLength:        0x%x\n"
                       "hShare:                     0x%x\n"
                       "hRootDir:                   0x%x\n"
                       "ShareStatus:                0x%x\n"
                       "Flags:                      0x%x\n"
                       "DfsPrefix:                  %s\n"
                       "ActualPrefix:               %s\n",
                            pInfoArg->FcbEntryObject[i].MFlags,
                            pInfoArg->FcbEntryObject[i].Tid,
                            pInfoArg->FcbEntryObject[i].ShadowIsCorrupt,
                            pInfoArg->FcbEntryObject[i].hShadow,
                            pInfoArg->FcbEntryObject[i].hParentDir,
                            pInfoArg->FcbEntryObject[i].hShadowRenamed,
                            pInfoArg->FcbEntryObject[i].hParentDirRenamed,
                            pInfoArg->FcbEntryObject[i].ShadowStatus,
                            pInfoArg->FcbEntryObject[i].LocalFlags,
                            pInfoArg->FcbEntryObject[i].LastComponentOffset,
                            pInfoArg->FcbEntryObject[i].LastComponentLength,
                            pInfoArg->FcbEntryObject[i].hShare,
                            pInfoArg->FcbEntryObject[i].hRootDir,
                            pInfoArg->FcbEntryObject[i].ShareStatus,
                            pInfoArg->FcbEntryObject[i].Flags,
                            pInfoArg->FcbEntryObject[i].DfsPrefix,
                            pInfoArg->FcbEntryObject[i].ActualPrefix);
            }
        }
    } else if (bResult && pInfoArg->Status == STATUS_BUFFER_TOO_SMALL) {
        // printf("Success but status = 0x%x\n", pInfoArg->Status);
        free(OutBuf);
        OutBuf = NULL;
        BufSize *= 2;
        goto TryAgain;
    }

    if (OutBuf != NULL)
        free(OutBuf);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\util\cscgetloc\cscgetloc.c ===
#define UNICODE
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winioctl.h>
#include <shdcom.h>

#include <smbdebug.h>

CHAR *ProgName = "cscgetinfo";

PBYTE InBuf[0x50];
PBYTE OutBuf = NULL;

#define STATUS_SUCCESS                   ((ULONG)0x00000000L)
#define STATUS_BUFFER_TOO_SMALL          ((ULONG)0xC0000023L)


_cdecl
main(LONG argc, CHAR *argv[])
{
    BOOL bResult;
    HANDLE  hShadow=NULL;
    ULONG junk;
    SHADOWINFO sSI;
    WIN32_FIND_DATAW Find32W;

    printf("Starting....\n");

    hShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hShadow == INVALID_HANDLE_VALUE) {
        printf("Failed open of shadow device\n");
        return 0;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uStatus = SHADOW_SWITCH_SHADOWING;
    sSI.uOp = SHADOW_SWITCH_GET_STATE;
    sSI.lpFind32 = &Find32W;

    bResult = DeviceIoControl(
                hShadow,                        // device 
                IOCTL_SWITCHES,                 // control code
                (LPVOID)&sSI,                   // in buffer
                0,                              // in buffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

    CloseHandle(hShadow);

    printf("cFileName:%ws\n", Find32W.cFileName);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\util\cscqueryinfo\cscqueryinfo.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <cscapi.h>
#include "lmcons.h"
#include "lmuse.h"

VOID __cdecl
main(
    int argc,
    char *argv[])
{
    // PWCHAR pFileName = L"\\\\jharperdc1\\vdo\\xx\\yy.txt";
    PWCHAR pFileName = L"\\\\jharperdc1\\jim\\jim.txt";
    DWORD Status = 0;
    DWORD PinCount = 0;
    DWORD HintFlags = 0;
    DWORD UserPerms = 0;
    DWORD OtherPerms = 0;
    DWORD QueryStatus = 0;

    QueryStatus = CSCQueryFileStatusExW(
                            pFileName,
                            &Status,
                            &PinCount,
                            &HintFlags,
                            &UserPerms,
                            &OtherPerms);
    printf("CSCQueryFileStatus(%ws) returned %d(0x%x)\n", pFileName, QueryStatus, QueryStatus);

    if (QueryStatus > 0) {
        printf(
            "Status:  0x%x\n"
            "PinCount:  0x%x\n"
            "HintFlags:  0x%x\n"
            "UserPerms:  0x%x\n"
            "OtherPerms:  0x%x\n",
                    Status,
                    PinCount,
                    HintFlags,
                    UserPerms,
                    OtherPerms);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\usermode\reint\test\apitst.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    apitest.c

Abstract:

    Program to test CSC apis.

Author:

    Shishir Pardikar (shishirp) 4-24-97

Environment:

    User Mode - Win32

Revision History:

--*/
#ifdef CSC_ON_NT
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#else
typedef const char *    LPCSTR;
#endif
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <cscapi.h>
#include "lmcons.h"
#include "lmuse.h"
//#include <timelog.h>

//=================================================================================
#define MAX_COMMAND_ARGS    32
#define DEFAULT_BUFFER_SIZE 1024    // 1k
//=================================================================================

// The order of these must match the order in GlobalCommandInfo[]
typedef enum _COMMAND_CODE {
    CmdCSCPinFile,
    CmdCSCUnPinFile,
    CmdCSCQueryFileStatus,
    CmdCSCEnum,
    CmdCSCDelete,
    CmdCSCFill,
    CmdCSCMerge,
    CmdCSCCopyReplica,
    CmdTimeLog,
    CmdCheckCSC,
    CmdDbCheckCSC,
    CmdCSCEnumForStats,
    CmdCSCDoLocalRename,
    CmdCSCDoEnableDisable,
    CmdShowTime,
    CmdEncryptDecrypt,
    CmdDoRandomWrites,
    CmdHelp,
    CmdQuit,
    UnknownCommand
} COMMAND_CODE, *LPCOMMAND_CODE;

typedef struct _COMMAND_INFO {
    LPSTR CommandName;
    LPSTR CommandParams;
    COMMAND_CODE CommandCode;
} COMMAND_INFO, *LPCOMMAND_INFO;

typedef VOID (*PRINTPROC)(LPSTR);
#ifndef CSC_ON_NT
typedef BOOL (*CHECKCSCEX)(LPSTR, LPCSCPROCA, DWORD, DWORD);
#else
typedef BOOL (*CHECKCSCEX)(LPSTR, LPCSCPROCW, DWORD, DWORD);
#endif
// If Count is not already aligned, then
// round Count up to an even multiple of "Pow2".  "Pow2" must be a power of 2.
//
// DWORD
// ROUND_UP_COUNT(
//     IN DWORD Count,
//     IN DWORD Pow2
//     );

#define ROUND_UP_COUNT(Count,Pow2) \
        ( ((Count)+(Pow2)-1) & (~((Pow2)-1)) )

#define ALIGN_WCHAR             sizeof(WCHAR)

//=================================================================================
FILE *UncList = NULL;
LPSTR g_lpWriteFileBuf = NULL;
FILE *DumpUncList = NULL;
DWORD cCommands = 0;
DWORD cFails = 0;
DWORD g_dwNumIterations = 1;
DWORD g_dwIteration = 0;
DWORD g_dwNumCmdIterations = 1;
DWORD g_dwCmdIteration = 0;
DWORD g_dwFileSize = 0;
DWORD g_dwDiskCache = 0;
BOOL g_bWriteFile = FALSE;
BOOL g_bQuietMode = FALSE;
BOOL g_bPerfMode = FALSE;
BOOL g_bUseFile = FALSE;
char szDefaultTimeLogFile[] = "c:\\debug\\kd.log";
char vszFile[] = "C:\\WINNT\\private\\ntos\\rdr2\\csc\\usermode\\reint\\foo";
WCHAR vwzFileName[] = L"\\\\shishir1\\public\\foo.txt";

COMMAND_INFO GlobalCommandInfo[] = {
    {"pin",         "UNCName",                          CmdCSCPinFile},
    {"unpin",       "UNCName",                          CmdCSCUnPinFile},
    {"query",       "UNCName",                          CmdCSCQueryFileStatus},
    {"Enum",        "UNCName or nothing",               CmdCSCEnum},
    {"Del",         "UNCName",                          CmdCSCDelete},
    {"Fill",        "UNCName",                          CmdCSCFill},
    {"Merge",       "\\\\Server\\Share",                CmdCSCMerge},
    {"Move",        "UNCNAME",                          CmdCSCCopyReplica},
    {"tlog",        "logfile",                          CmdTimeLog},
    {"check",       "\\\\Server\\Share",                CmdCheckCSC},
    {"dbcheck",     "dbdir <0 (verify) or 1 (fix)>",    CmdDbCheckCSC},
    {"stats",       ""              ,                   CmdCSCEnumForStats},
    {"Ren",         "ren src containing_dst_dir [1:-replace files]", CmdCSCDoLocalRename},
    {"EnDis",       "0 (disable) or 1 enable",              CmdCSCDoEnableDisable},
    {"ShowTime",    "HHHHHHHH LLLLLLLL (Hex HighDateTime and LowDateTime)", CmdShowTime},
    {"EncDec",      "U (decrypt) anything else=> encrypt", CmdEncryptDecrypt},
    {"RandW",        "Randw filename",                  CmdDoRandomWrites},
    {"Help",        "",                                 CmdHelp},
    {"Quit",         "",                                CmdQuit}
};

LPSTR   rgszNameArray[] =
{
"EditRecordEx",
"AddFileRecordFR",
"DeleteFileRecFromInode",
"FindFileRecord",
"UpdateFileRecordFR",
"AddPriQRecord",
"DeletePriQRecord",
"FindPriQRecordInternal",
"SetPriorityForInode",
"CreateShadowInternal",
"GetShadow",
"GetShadowInfo",
"SetShadowInfoInternal",
"ChangePriEntryStatusHSHADOW",
"MRxSmbCscCreateShadowFromPath",
"MRxSmbGetFileInfoFromServer",
"EditRecordEx_OpenFileLocal",
"EditRecordEx_Lookup",
"KeAttachProcess_R0Open",
"IoCreateFile_R0Open",
"KeDetachProcess_R0Open",
"KeAttachProcess_R0Read",
"R0ReadWrite",
"KeDetachProcess_R0Read",
"FindQRecordInsertionPoint_Addq",
"LinkQRecord_Addq",
"UnlinkQRecord_Addq",
"FindQRecordInsertionPoint_Addq_dir",
"EditRecordEx_Validate",
"EditRecordEx_dat"
};

typedef struct tagCSCSTATS{
    DWORD   dwTotal;
    DWORD   dwTotalFiles;
    DWORD   dwTotalDirs;
    DWORD   dwSparseFiles;
    DWORD   dwDirtyFiles;
    DWORD   dwPinned;
    DWORD   dwPinnedAndSparse;
    DWORD   dwMismatched;
} CSCSTATS, *LPCSCSTATS;

DWORD WINAPIV Format_String(LPSTR *plpsz, LPSTR lpszFmt, ...);
DWORD WINAPI Format_Error(DWORD dwErr, LPSTR *plpsz);
DWORD WINAPI Format_StringV(LPSTR *plpsz, LPCSTR lpszFmt, va_list *vArgs);
DWORD WINAPI Format_MessageV(DWORD dwFlags, DWORD dwErr, LPSTR *plpsz, LPCSTR lpszFmt, va_list *vArgs);
VOID PrintBuffer(
    LPSTR   lpszBuff
    );


BOOL WINAPI CheckCSC(LPSTR lpszDataBaseLocation, BOOL fFix);
BOOL
DoPinningA(
    LPSTR   lpszName,
    DWORD   dwHintFlags,
    BOOL    fRecurse
    );
BOOL
DoPinningW(
    LPWSTR   lpwzName,
    DWORD   dwHintFlags,
    BOOL    fRecurse
    );

DWORD
ProcessShowTime (
    DWORD argc,
    LPSTR *argv
    );

DWORD
ProcessEncryptDecrypt(
    DWORD   argc,
    LPSTR   *argv
);


//=================================================================================
DWORD
ProcessCommandCode (
    DWORD CommandCode,
    DWORD CommandArgc,
    LPSTR *CommandArgv
    );


DWORD
GetLeafLenFromPath(
    LPSTR   lpszPath
    );

BOOL
GetStreamInformation(
    LPCSTR  lpExistingFileName,
    LPVOID  *lpStreamInformation
    );

//=================================================================================
#if DBG

#define TestDbgAssert(Predicate) \
    { \
        if (!(Predicate)) \
            TestDbgAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }

VOID
TestDbgAssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    )
/*++

Routine Description:

    Assertion failed.

Arguments:

    FailedAssertion :

    FileName :

    LineNumber :

    Message :

Return Value:

    none.

--*/
{

    printf("Assert @ %s \n", FailedAssertion );
    printf("Assert Filename, %s \n", FileName );
    printf("Line Num. = %ld.\n", LineNumber );
    printf("Message is %s\n", Message );

    DebugBreak();
}
#else

#define TestDbgAssert(_x_)

#endif // DBG

//=================================================================================
VOID
ParseArguments(
    LPSTR InBuffer,
    LPSTR *CArgv,
    LPDWORD CArgc
    )
{
    LPSTR CurrentPtr = InBuffer;
    DWORD i = 0;
    DWORD Cnt = 0;

    for ( ;; ) {

        //
        // skip blanks.
        //

        while( *CurrentPtr == ' ' ) {
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        CArgv[i++] = CurrentPtr;

        //
        // go to next space.
        //

        while(  (*CurrentPtr != '\0') &&
                (*CurrentPtr != '\n') ) {
            if( *CurrentPtr == '"' ) {      // Deal with simple quoted args
                if( Cnt == 0 )
                    CArgv[i-1] = ++CurrentPtr;  // Set arg to after quote
                else
                    *CurrentPtr = '\0';     // Remove end quote
                Cnt = !Cnt;
            }
            if( (Cnt == 0) && (*CurrentPtr == ' ') ||   // If we hit a space and no quotes yet we are done with this arg
                (*CurrentPtr == '\0') )
                break;
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        *CurrentPtr++ = '\0';
    }

    *CArgc = i;
    return;
}

#ifdef MAYBE
//=================================================================================
LPSTR
GetUncFromFile ()
{
    if (!UncList)
    {
        UncList = fopen ("Unclist", "r");
        if (UncList == NULL)
            return NULL;
    }
    if (fgets( UncBuffer, DEFAULT_BUFFER_SIZE, UncList))
    {
        UncBuffer[strlen(UncBuffer) -1] = '\0';  //kill line feed for no param cmds
        return UncBuffer;
    }
    else
    {
        fclose (UncList);
        UncList = NULL;
        return GetUncFromFile();
    }
}

#endif
//=================================================================================
COMMAND_CODE
DecodeCommand(
    LPSTR CommandName
    )
{
    DWORD i;
    DWORD NumCommands;

    NumCommands = sizeof(GlobalCommandInfo) / sizeof(COMMAND_INFO);
    TestDbgAssert( NumCommands <= UnknownCommand );
    for( i = 0; i < NumCommands; i++) {
        if(( lstrcmpi( CommandName, GlobalCommandInfo[i].CommandName ) == 0 )){
            return( GlobalCommandInfo[i].CommandCode );
        }
    }
    return( UnknownCommand );
}

//=================================================================================
VOID
PrintCommands(
    VOID
    )
{
    DWORD i;
    DWORD NumCommands;

    NumCommands = sizeof(GlobalCommandInfo) / sizeof(COMMAND_INFO);
    TestDbgAssert( NumCommands <= UnknownCommand );
    for( i = 0; i < NumCommands; i++) {
        fprintf(stderr, "    %s (%s)\n",
            GlobalCommandInfo[i].CommandName,
            GlobalCommandInfo[i].CommandParams );
    }
}

//=================================================================================
VOID
DisplayUsage(
    VOID
    )
{
    fprintf(stderr, "Usage: command <command parameters>\n" );

    fprintf(stderr, "Commands : \n");
    PrintCommands();

    return;
}

//=================================================================================
FILETIME
GetGmtTime(
    VOID
    )
{
    SYSTEMTIME SystemTime;
    FILETIME Time;

    GetSystemTime( &SystemTime );
    SystemTimeToFileTime( &SystemTime, &Time );

    return( Time );
}

//=================================================================================
LPSTR
ConvertGmtTimeToString(
    FILETIME Time,
    LPSTR OutputBuffer
    )
{
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;

    static FILETIME ftNone = {0, 0};

    if (!memcmp (&Time, &ftNone, sizeof(FILETIME)))
        sprintf (OutputBuffer, "<none>");
    else
    {
        FileTimeToLocalFileTime( &Time , &LocalTime );
        FileTimeToSystemTime( &LocalTime, &SystemTime );

        sprintf( OutputBuffer,
                    "%02u/%02u/%04u %02u:%02u:%02u ",
                    SystemTime.wMonth,
                    SystemTime.wDay,
                    SystemTime.wYear,
                    SystemTime.wHour,
                    SystemTime.wMinute,
                    SystemTime.wSecond );
    }

    return( OutputBuffer );
}


void
PrintCSCEntryInfo(
    WIN32_FIND_DATA *lpFind32,
    DWORD           dwStatus,
    DWORD           dwPinCount,
    DWORD           dwHintFlags,
    FILETIME        *lpftOrgTime
)
{
    char buff[128];
    fprintf(stderr, "\n");


    if (lpFind32)
    {
        fprintf(stderr, "LFN: %s\n", lpFind32->cFileName);
        fprintf(stderr, "SFN: %s\n", lpFind32->cAlternateFileName);
        fprintf(stderr, "Attr: %x\n", lpFind32->dwFileAttributes);
        fprintf(stderr, "Size: %d %d\n", lpFind32->nFileSizeHigh, lpFind32->nFileSizeLow);

        ConvertGmtTimeToString(lpFind32->ftLastWriteTime, buff);
        fprintf(stderr, "LastWriteTime: %s\n", buff);
    }

    if (lpftOrgTime)
    {
        ConvertGmtTimeToString(*lpftOrgTime, buff);
        fprintf(stderr, "ORGTime: %s\n", buff);
    }

    fprintf(stderr, "Status: %x\n", dwStatus);

    fprintf(stderr, "PinCount: %x\n", dwPinCount);

    fprintf(stderr, "PinFlags: %x\n", dwHintFlags);

    fprintf(stderr, "\n");

}

void
PrintCSCEntryInfoW(
    WIN32_FIND_DATAW *lpFind32,
    DWORD           dwStatus,
    DWORD           dwPinCount,
    DWORD           dwHintFlags,
    FILETIME        *lpftOrgTime
)
{

    WIN32_FIND_DATA *lpFind32P = NULL;

    fprintf(stderr, "\n");
    if (lpFind32)
    {
        WIN32_FIND_DATA sFind32;

        lpFind32P = &sFind32;
        memset(&sFind32, 0, sizeof(WIN32_FIND_DATAA));
        memcpy(&sFind32, lpFind32, sizeof(WIN32_FIND_DATAA)-sizeof(sFind32.cFileName)-sizeof(sFind32.cAlternateFileName));

        WideCharToMultiByte(CP_ACP, 0, lpFind32->cFileName, wcslen(lpFind32->cFileName), sFind32.cFileName, sizeof(sFind32.cFileName), NULL, NULL);
        WideCharToMultiByte(CP_OEMCP, 0, lpFind32->cAlternateFileName, wcslen(lpFind32->cAlternateFileName), sFind32.cAlternateFileName, sizeof(sFind32.cAlternateFileName), NULL, NULL);
    }

    PrintCSCEntryInfo(  lpFind32P,
                        dwStatus,
                        dwPinCount,
                        dwHintFlags,
                        lpftOrgTime
                    );
}

DWORD
MyCSCProc(
    const char          *lpszFullPath,
    DWORD               dwStatus,
    DWORD               dwHintFlags,
    DWORD               dwPinCount,
    WIN32_FIND_DATAA    *lpFind32,
    DWORD               dwReason,
    DWORD               dwParam1,
    DWORD               dwParam2,
    DWORD               dwContext
    )
{
    if (dwReason==CSCPROC_REASON_BEGIN)
    {
        printf("CSCPROC:Name=%s Status=0x%x HintFlags=0x%x PinCount=%d Reason=%d Param1=%d Param2=%d\r\n",
                    (lpszFullPath)?lpszFullPath:"None",
                    dwStatus,
                    dwHintFlags,
                    dwPinCount,
                    dwReason,
                    dwParam1,
                    dwParam2
        );
    }
    else if (dwReason==CSCPROC_REASON_MORE_DATA)
    {
        printf(".");
    }
    else
    {
        printf("\r\n");
        if (dwParam2==ERROR_SUCCESS)
        {
            printf("Succeeded\r\n");
        }
        else
        {
            printf("Error=%d \r\n", dwParam2);
        }
    }
    return (CSCPROC_RETURN_CONTINUE);
}

DWORD
MyCSCProcW(
    const unsigned short  *lpszFullPath,
    DWORD           dwStatus,
    DWORD           dwHintFlags,
    DWORD           dwPinCount,
    WIN32_FIND_DATAW *lpFind32,
    DWORD           dwReason,
    DWORD           dwParam1,
    DWORD           dwParam2,
    DWORD           dwContext
    )
{
    if (dwReason==CSCPROC_REASON_BEGIN)
    {
        printf("CSCPROC:Name=%ls Status=0x%x HintFlags=0x%x PinCount=%d Reason=%d Param1=%d Param2=%d\r\n",
                    (lpszFullPath)?lpszFullPath:L"None",
                    dwStatus,
                    dwHintFlags,
                    dwPinCount,
                    dwReason,
                    dwParam1,
                    dwParam2
        );
    }
    else if (dwReason==CSCPROC_REASON_MORE_DATA)
    {
        printf(".");
    }
    else
    {
        printf("\r\n");
        if (dwParam2==ERROR_SUCCESS)
        {
            printf("Succeeded\r\n");
        }
        else
        {
            printf("Error=%d \r\n", dwParam2);
        }
    }
    return (CSCPROC_RETURN_CONTINUE);
}

DWORD
MyCSCEnumForStatsProc(
    const char          *lpszFullPath,
    DWORD               dwStatus,
    DWORD               dwHintFlags,
    DWORD               dwPinCount,
    WIN32_FIND_DATAA    *lpFind32,
    DWORD               dwReason,
    DWORD               dwParam1,
    DWORD               dwParam2,
    DWORD               dwContext
    )
{
    LPCSCSTATS lpStats = (LPCSCSTATS)dwContext;

    lpStats->dwTotal++;
    if(dwParam1)
    {
        lpStats->dwTotalFiles++;
        if (dwStatus & FLAG_CSC_COPY_STATUS_SPARSE)
        {
            lpStats->dwSparseFiles++;
        }
        if (dwStatus & FLAG_CSC_COPY_STATUS_DATA_LOCALLY_MODIFIED)
        {
            lpStats->dwDirtyFiles++;
        }
        if ((dwHintFlags & (FLAG_CSC_HINT_PIN_USER|FLAG_CSC_HINT_PIN_SYSTEM))||dwPinCount)
        {
            lpStats->dwPinned++;
            if (dwStatus & FLAG_CSC_COPY_STATUS_SPARSE)
            {
                lpStats->dwPinnedAndSparse++;
            }

        }
    }
    else
    {
        lpStats->dwTotalDirs++;
    }

    return (CSCPROC_RETURN_CONTINUE);
}

DWORD
MyCSCEnumForStatsProcW(
    const unsigned short  *lpszFullPath,
    DWORD           dwStatus,
    DWORD           dwHintFlags,
    DWORD           dwPinCount,
    WIN32_FIND_DATAW *lpFind32,
    DWORD           dwReason,
    DWORD           dwParam1,
    DWORD           dwParam2,
    DWORD           dwContext
    )
{
    LPCSCSTATS lpStats = (LPCSCSTATS)dwContext;

    lpStats->dwTotal++;
    if(dwParam1)
    {
        lpStats->dwTotalFiles++;
        if (dwStatus & FLAG_CSC_COPY_STATUS_SPARSE)
        {
            lpStats->dwSparseFiles++;
        }
        if (dwStatus & FLAG_CSC_COPY_STATUS_DATA_LOCALLY_MODIFIED)
        {
            lpStats->dwDirtyFiles++;
        }
        if ((dwHintFlags & (FLAG_CSC_HINT_PIN_USER|FLAG_CSC_HINT_PIN_SYSTEM))||dwPinCount)
        {
            lpStats->dwPinned++;
            if (dwStatus & FLAG_CSC_COPY_STATUS_SPARSE)
            {
                lpStats->dwPinnedAndSparse++;
            }
        }
    }
    else
    {
        lpStats->dwTotalDirs++;
    }

    return (CSCPROC_RETURN_CONTINUE);
}

DWORD
MyCSCCheckExProc(
    const char          *lpszFullPath,
    DWORD               dwStatus,
    DWORD               dwHintFlags,
    DWORD               dwPinCount,
    WIN32_FIND_DATAA    *lpFind32,
    DWORD               dwReason,
    DWORD               dwParam1,
    DWORD               dwParam2,
    DWORD               dwContext
    )
{
    LPCSCSTATS lpStats = (LPCSCSTATS)dwContext;

    if (dwReason == CSCPROC_REASON_BEGIN)
    {
        if (lpFind32)
        {
            printf("%s size=%d\r\n", lpszFullPath, lpFind32->nFileSizeLow);
            lpStats->dwTotal++;
            lpStats->dwTotalFiles++;
        }
        else
        {
            printf("%s\r\n", lpszFullPath);
        }

    }
    else if (dwReason == CSCPROC_REASON_END)
    {
        if (dwParam2 != NO_ERROR)
        {
            if (dwParam2 == ERROR_INVALID_DATA)
            {
                printf("Mismatched, press any key to continue...\r\n", dwParam2);
            }
            else
            {
                printf("Error in comparing Errcode=%d, press any key to continue...\r\n", dwParam2);
            }
            getchar();
            lpStats->dwMismatched++;
        }
    }

    return (CSCPROC_RETURN_CONTINUE);
}

DWORD
MyCSCCheckExProcW(
    const unsigned short  *lpszFullPath,
    DWORD           dwStatus,
    DWORD           dwHintFlags,
    DWORD           dwPinCount,
    WIN32_FIND_DATAW *lpFind32,
    DWORD           dwReason,
    DWORD           dwParam1,
    DWORD           dwParam2,
    DWORD           dwContext
    )
{
    LPCSCSTATS lpStats = (LPCSCSTATS)dwContext;

    if (dwReason == CSCPROC_REASON_BEGIN)
    {
        if (lpFind32)
        {
            printf("%ls size=%d\r\n", lpszFullPath, lpFind32->nFileSizeLow);
            lpStats->dwTotal++;
            lpStats->dwTotalFiles++;
        }
        else
        {
            printf("%s\r\n", lpszFullPath);
        }
    }
    else if (dwReason == CSCPROC_REASON_END)
    {
        if (dwParam2 != NO_ERROR)
        {
            if (dwParam2 == ERROR_INVALID_DATA)
            {
                printf("Mismatched, press any key to continue...\r\n", dwParam2);
            }
            else
            {
                printf("Error in comparing Errcode=%d, press any key to continue...\r\n", dwParam2);
            }
            getchar();
            lpStats->dwMismatched++;
        }
    }
    return (CSCPROC_RETURN_CONTINUE);
}

DWORD
ProcessCSCPinFile(
    DWORD   argc,
    LPSTR   *argv
)
{
    DWORD   dwError=ERROR_SUCCESS, dwHintFlags=0;
    BOOL    fRecurse = FALSE, fRet=FALSE;
#ifdef CSC_ON_NT
    unsigned short uBuff[MAX_PATH];
#endif
    if (argc < 1)
    {
        printf("CSCPinFile: must provide a UNC path \r\n");
    }
    else
    {
        if (argc > 1)
        {
            if ((*argv[1] == 'u')||(*argv[1] == 'U'))
            {
                dwHintFlags |= FLAG_CSC_HINT_PIN_USER;
            }
            else if ((*argv[1] == 's')||(*argv[1] == 'S'))
            {
                dwHintFlags |= FLAG_CSC_HINT_PIN_SYSTEM;
            }
            else if (*argv[1] == 'i')
            {
                dwHintFlags |= FLAG_CSC_HINT_PIN_INHERIT_USER;
            }
            else if (*argv[1] == 'I')
            {
                dwHintFlags |= FLAG_CSC_HINT_PIN_INHERIT_SYSTEM;
            }
            else if (*argv[1] == 'T')
            {
                fRecurse = TRUE;
            }

        }
#ifndef CSC_ON_NT
        fRet = DoPinningA(argv[0], dwHintFlags, fRecurse);
#else
        memset(uBuff, 0, sizeof(uBuff));
        MultiByteToWideChar(CP_ACP, 0, argv[0], strlen(argv[0]), uBuff, MAX_PATH*sizeof(unsigned short));
        fRet = DoPinningW(uBuff, dwHintFlags, fRecurse);
#endif

    }

    if (!fRet)
    {
        dwError = GetLastError();
    }

    return (dwError);
}

DWORD
ProcessCSCUnPinFile(
    DWORD   argc,
    LPSTR   *argv
)
{

    DWORD dwStatus, dwError=ERROR_SUCCESS, dwPinCount, dwHintFlags=0;
#ifdef CSC_ON_NT
    unsigned short uBuff[MAX_PATH];
#endif

    if (argc < 1)
    {
        printf("CSCUnPinFile: must provide a UNC path \r\n");
    }
    else
    {
        if (argc > 1)
        {
            if ((*argv[1] == 'u')||(*argv[1] == 'U'))
            {
                dwHintFlags |= FLAG_CSC_HINT_PIN_USER;
            }
            else if ((*argv[1] == 's')||(*argv[1] == 'S'))
            {
                dwHintFlags |= FLAG_CSC_HINT_PIN_SYSTEM;
            }
            else if (*argv[1] == 'i')
            {
                dwHintFlags |= FLAG_CSC_HINT_PIN_INHERIT_USER;
            }
            else if (*argv[1] == 'I')
            {
                dwHintFlags |= FLAG_CSC_HINT_PIN_INHERIT_SYSTEM;
            }
        }

#ifndef CSC_ON_NT
        if (!CSCUnpinFileA(argv[0], dwHintFlags, &dwStatus, &dwPinCount, &dwHintFlags))
        {
            dwError = GetLastError();   
        }
        else
        {
            PrintCSCEntryInfo(NULL, dwStatus, dwPinCount, dwHintFlags, NULL);

        }
#else
        memset(uBuff, 0, sizeof(uBuff));
        MultiByteToWideChar(CP_ACP, 0, argv[0], strlen(argv[0]), uBuff, MAX_PATH*sizeof(unsigned short));

        if (!CSCUnpinFileW(uBuff, dwHintFlags, &dwStatus, &dwPinCount, &dwHintFlags))
        {
            dwError = GetLastError();   
        }
        else
        {
            PrintCSCEntryInfo(NULL, dwStatus, dwPinCount, dwHintFlags, NULL);

        }
#endif
    }
    return (dwError);
}

DWORD
ProcessCSCQueryFileStatus(
    DWORD   argc,
    LPSTR   *argv
)
{

    DWORD dwStatus, dwError=ERROR_SUCCESS, dwPinCount, dwHintFlags;
#ifdef CSC_ON_NT
    unsigned short uBuff[MAX_PATH];
#endif

    if (argc < 1)
    {
        printf("CSCQueryFileStatusA: must provide a UNC path \r\n");
    }
    else
    {
#ifndef CSC_ON_NT
        if (!CSCQueryFileStatusA(argv[0], &dwStatus, &dwPinCount, &dwHintFlags))
        {
            dwError = GetLastError();   
        }
        else
        {
            PrintCSCEntryInfo(NULL, dwStatus, dwPinCount, dwHintFlags, NULL);

        }
#else

        memset(uBuff, 0, sizeof(uBuff));
        MultiByteToWideChar(CP_ACP, 0, argv[0], strlen(argv[0]), uBuff, MAX_PATH*sizeof(unsigned short));
        if (!CSCQueryFileStatusW(uBuff, &dwStatus, &dwPinCount, &dwHintFlags))
        {
            dwError = GetLastError();   
        }
        else
        {
            PrintCSCEntryInfo(NULL, dwStatus, dwPinCount, dwHintFlags, NULL);

        }

#endif
    }
    return (dwError);
}

DWORD
ProcessCSCEnum(
    DWORD   argc,
    LPSTR   *argv
)
{
    HANDLE hFind;
    DWORD dwError = ERROR_SUCCESS, dwStatus, dwPinCount, dwHintFlags;
    FILETIME ftOrgTime;
#ifndef CSC_ON_NT
    WIN32_FIND_DATAA    sFind32;
#else
    WIN32_FIND_DATAW    sFind32;
    unsigned short uBuff[MAX_PATH];
#endif

#ifndef CSC_ON_NT
    hFind = CSCFindFirstFileA((argc<1)?NULL:argv[0], &sFind32, &dwStatus, &dwPinCount, &dwHintFlags, &ftOrgTime);

    if (hFind != INVALID_HANDLE_VALUE)
    {
        PrintCSCEntryInfo(&sFind32, dwStatus, dwPinCount, dwHintFlags, &ftOrgTime);

        while (CSCFindNextFileA(hFind, &sFind32, &dwStatus, &dwPinCount, &dwHintFlags, &ftOrgTime))
        {
            PrintCSCEntryInfo(&sFind32, dwStatus, dwPinCount, dwHintFlags, &ftOrgTime);
        }

        CSCFindClose(hFind);
    }
    else
    {
        dwError = GetLastError();
    }
#else
    memset(uBuff, 0, sizeof(uBuff));
    MultiByteToWideChar(CP_ACP, 0, argv[0], strlen(argv[0]), uBuff, MAX_PATH*sizeof(unsigned short));
    hFind = CSCFindFirstFileW(uBuff, &sFind32, &dwStatus, &dwPinCount, &dwHintFlags, &ftOrgTime);

    if (hFind != INVALID_HANDLE_VALUE)
    {
        PrintCSCEntryInfoW(&sFind32, dwStatus, dwPinCount, dwHintFlags, &ftOrgTime);

        while (CSCFindNextFileW(hFind, &sFind32, &dwStatus, &dwPinCount, &dwHintFlags, &ftOrgTime))
        {
            PrintCSCEntryInfoW(&sFind32, dwStatus, dwPinCount, dwHintFlags, &ftOrgTime);
        }

        CSCFindClose(hFind);
    }
    else
    {
        dwError = GetLastError();
    }
#endif
    return (dwError);
}

DWORD
ProcessCSCDelete(
    DWORD   argc,
    LPSTR   *argv
)
{

    DWORD dwError=ERROR_SUCCESS;
#ifdef CSC_ON_NT
    unsigned short uBuff[MAX_PATH];
#endif
    if (argc < 1)
    {
        printf("CSCQueryFileStatusA: must provide a UNC path \r\n");
    }
    else
    {
#ifndef CSC_ON_NT
        if (!CSCDeleteA(argv[0]))
        {
            dwError = GetLastError();   
        }
#else
        memset(uBuff, 0, sizeof(uBuff));
        MultiByteToWideChar(CP_ACP, 0, argv[0], strlen(argv[0]), uBuff, MAX_PATH*sizeof(unsigned short));
        if (!CSCDeleteW(uBuff))
        {
            dwError = GetLastError();   
        }
#endif
    }
    return (dwError);
}

DWORD
ProcessTimeLog(
    DWORD   argc,
    LPSTR   *argv
)
{
    DWORD dwError=ERROR_SUCCESS;
    LPSTR   lpszLogFile;
    FILE *fp= (FILE *)NULL;
    char buff[256];
    int indx = 0;
    LONGLONG llTime = 0;
    DWORD   dwMin, dwSec, dwMSec;
    if (argc < 1)
    {
        printf("No file specified assuming %s\r\n", szDefaultTimeLogFile);
        lpszLogFile = szDefaultTimeLogFile;
    }
    else
    {
        lpszLogFile = argv[0];
    }

    if (fp = fopen(lpszLogFile, "rb")){
        printf("Total time spent by routine \r\n");

         while(fgets(buff, sizeof(buff), fp) != NULL)
         {

            if (sscanf(buff, "%x %x", (DWORD *)&llTime, (DWORD *)(((BYTE *)&llTime)+sizeof(DWORD)))==2)
            {
                dwMin = (DWORD)((llTime/10000000)/60);
                dwSec = (DWORD)((llTime/10000000)%60);

                if (!dwMin && !dwSec)
                {
                    dwMSec = (DWORD)(llTime/10000);
                    printf("%d msecs:   %s\r\n", dwMSec, rgszNameArray[indx]);
                }
                else
                {
                    printf("%d min %d sec:   %s \r\n",
                        dwMin,
                        dwSec,
                        rgszNameArray[indx]);

                }
            }

            ++indx;
         }

         fclose(fp);
    }

    return (dwError);

}

DWORD
ProcessCheckCSC(
    DWORD   argc,
    LPSTR   *argv
    )
{
    CHECKCSCEX  lpCheckCscEx;
    HANDLE  hLib;
    CSCSTATS    sCscStats;
    DWORD dwError=ERROR_SUCCESS;
    BOOL fRet = TRUE;

    if (hLib = LoadLibraryA("cscdll.dll"))
    {
        if (lpCheckCscEx = (CHECKCSCEX)GetProcAddress(hLib, "CheckCSCEx"))
        {
            memset(&sCscStats, 0, sizeof(sCscStats));
#ifndef CSC_ON_NT
            fRet = lpCheckCscEx(argv[0], MyCSCCheckExProc, (DWORD)&sCscStats, 0);    // verify
#else
            fRet = lpCheckCscEx(argv[0], MyCSCCheckExProcW, (DWORD)&sCscStats, 0);    // verify
#endif
        }
        else
        {
            printf("Older version of cscdll \r\n");
            fRet = FALSE;

        }

        FreeLibrary(hLib);
    }

    if (!fRet)
    {
        dwError = GetLastError();
    }
    return dwError;
}

DWORD
ProcessDbCheckCSC(
    DWORD   argc,
    LPSTR   *argv
)
{
    DWORD dwError=ERROR_SUCCESS;
    DWORD   dwLevel=0;
    BOOL fRet = TRUE;
    PRINTPROC lpfnPrintProc = NULL;
#if 0
    PFILE_STREAM_INFORMATION pStream = NULL, pstreamT;
    char buff[1024];

    if (GetStreamInformation((LPCSTR)vszFile, (LPVOID *)&pStream))
    {
        pstreamT = pStream;

        do
        {
            memset(buff, 0, sizeof(buff));

            wcstombs(buff, pstreamT->StreamName, pstreamT->StreamNameLength);

            printf("%s\r\n", buff);

            if (!pstreamT->NextEntryOffset)
            {
                break;
            }

            pstreamT = (PFILE_STREAM_INFORMATION)((LPBYTE)pstreamT + pstreamT->NextEntryOffset);
        }
        while (TRUE);

        LocalFree(pStream);
    }

#endif

    if (argc < 1)
    {
        printf("Usage: check cscdir level{0 for verify, 1 for rebuild}\r\n");
        return (ERROR_INVALID_PARAMETER);
    }
    else if (argc>1)
    {
        dwLevel = *argv[1] - '0';
    }

    if (dwLevel > 1)
    {
        printf("Usage: check cscdir level{0 for verify, 1 for rebuild}\r\n");
        return (ERROR_INVALID_PARAMETER);
    }

    printf("Calling CheckCSC with cscdir=%s level=%d \r\n", argv[0], dwLevel);

    switch (dwLevel)
    {
        case 0:
            fRet = CheckCSC(argv[0], FALSE); // don't fix
            break;
        case 1:
            fRet = CheckCSC(argv[0], TRUE);  // fix
            break;
        default:
            break;
    }
    if (!fRet)
    {
        dwError = GetLastError();
    }
    return dwError;
}

DWORD
ProcessCSCFill(
    DWORD   argc,
    LPSTR   *argv
)
{

    DWORD dwError=ERROR_FILE_NOT_FOUND;
#ifdef CSC_ON_NT
    unsigned short uBuff[MAX_PATH];
#endif

    if (argc>=1)
    {
#ifndef CSC_ON_NT
        if (!CSCFillSparseFilesA((const char *)argv[0], FALSE, MyCSCProc, 0))
        {
            dwError = GetLastError();
        }
        else
        {
            dwError = ERROR_SUCCESS;
        }
#else
        memset(uBuff, 0, sizeof(uBuff));
        MultiByteToWideChar(CP_ACP, 0, argv[0], strlen(argv[0]), uBuff, MAX_PATH*sizeof(unsigned short));

        if (!CSCFillSparseFilesW((const unsigned short *)uBuff, FALSE, MyCSCProcW, 0))
        {
            dwError = GetLastError();
        }
        else
        {
            dwError = ERROR_SUCCESS;
        }
#endif
    }
    return dwError;
}

DWORD
ProcessCSCMerge(
    DWORD   argc,
    LPSTR   *argv
)
{

    DWORD dwError=ERROR_FILE_NOT_FOUND;
#ifdef CSC_ON_NT
    unsigned short uBuff[MAX_PATH];
#endif

    if (argc>=1)
    {
#ifndef CSC_ON_NT
        if (!CSCMergeShareA((const char *)(argv[0]), MyCSCProc, 0))
        {
            dwError = GetLastError();
        }
        else
        {
            dwError = ERROR_SUCCESS;
        }
#else
        memset(uBuff, 0, sizeof(uBuff));
        MultiByteToWideChar(CP_ACP, 0, argv[0], strlen(argv[0]), uBuff, MAX_PATH*sizeof(unsigned short));
        if (!CSCMergeShareW((const unsigned short *)uBuff, MyCSCProcW, 0))
        {
            dwError = GetLastError();
        }
        else
        {
            dwError = ERROR_SUCCESS;
        }
        CSCTransitionServerOnlineW((const unsigned short *)uBuff);
#endif

    }
    return dwError;
}

DWORD
ProcessCSCCopyReplica(
    DWORD   argc,
    LPSTR   *argv
)
{

    DWORD dwError=ERROR_FILE_NOT_FOUND;
#ifdef CSC_ON_NT
    LPWSTR  lpszTempName = NULL;
    unsigned short uBuff[MAX_PATH];
#else
    LPSTR  lpszTempName = NULL;
#endif

    if (argc>=1)
    {
#ifndef CSC_ON_NT
        if (!CSCCopyReplicaA((const char *)argv[0], &lpszTempName))
        {
            dwError = GetLastError();
        }
        else
        {
            dwError = ERROR_SUCCESS;
        }
#else
        memset(uBuff, 0, sizeof(uBuff));
        MultiByteToWideChar(CP_ACP, 0, argv[0], strlen(argv[0]), uBuff, MAX_PATH*sizeof(unsigned short));

        if (!CSCCopyReplicaW((const unsigned short *)uBuff, &lpszTempName))
        {
            dwError = GetLastError();
        }
        else
        {
            dwError = ERROR_SUCCESS;
        }
#endif
    }

    if (dwError == ERROR_SUCCESS)
    {

#ifdef CSC_ON_NT
        OutputDebugStringW(lpszTempName);
        OutputDebugStringW(L"\r\n");
#else
        OutputDebugStringA(lpszTempName);
        OutputDebugStringA("\r\n");
#endif
    }

    return dwError;
}



DWORD
ProcessCSCEnumForStats(
    DWORD   argc,
    LPSTR   *argv
)
{

    DWORD dwError=ERROR_FILE_NOT_FOUND;
    CSCSTATS   sStats;
#ifdef CSC_ON_NT
    unsigned short uBuff[MAX_PATH];
#endif

    memset(&sStats, 0, sizeof(sStats));
#ifndef CSC_ON_NT
        if (!CSCEnumForStatsA((argc >=1)?(const char *)(argv[0]):NULL, MyCSCEnumForStatsProc, (DWORD)&sStats))
        {
            dwError = GetLastError();
        }
        else
        {
            dwError = ERROR_SUCCESS;
        }
#else
        if (argc >= 1)
        {
            memset(uBuff, 0, sizeof(uBuff));
            MultiByteToWideChar(CP_ACP, 0, argv[0], strlen(argv[0]), uBuff, MAX_PATH*sizeof(unsigned short));
        }
        if (!CSCEnumForStatsW((argc>=1)?(const unsigned short *)uBuff:NULL, MyCSCEnumForStatsProcW, (DWORD)&sStats))
        {
            dwError = GetLastError();
        }
        else
        {
            dwError = ERROR_SUCCESS;
        }
#if 0
        if (argc < 1)
        {
            DWORD   dwMaxSpaceHigh, dwMaxSpaceLow, dwCurrentSpaceHigh, dwCurrentSpaceLow, cntTotalFiles, cntTotalDirs;

            if(CSCGetSpaceUsageW(uBuff, sizeof(uBuff),
                                &dwMaxSpaceHigh, &dwMaxSpaceLow,
                                &dwCurrentSpaceHigh, &dwCurrentSpaceLow,
                                &cntTotalFiles, &cntTotalDirs))
            {
                printf("\r\n Space Stats \r\n");
                printf("CSC directory location: %ls \r\n", uBuff);
                printf("MaxSpace=%d, CurrentSpaceUsed=%d, Fnles=%d Dirs=%d \r\n", dwMaxSpaceLow, dwCurrentSpaceLow, cntTotalFiles, cntTotalDirs);
            }
            else
            {
                printf("Error=%d in CSCGetSpaceUsage\r\n", GetLastError());
            }
        }
#endif
#endif
    if (dwError == ERROR_SUCCESS)
    {
        printf("Stats\n");
        printf("Total = %d, files=%d dirs=%d sparse=%d dirty=%d pinned=%d pinnedAndSparse=%d\r\n",
            sStats.dwTotal,
            sStats.dwTotalFiles,
            sStats.dwTotalDirs,
            sStats.dwSparseFiles,
            sStats.dwDirtyFiles,
            sStats.dwPinned,
            sStats.dwPinnedAndSparse

        );
    }
    return dwError;
}


DWORD
ProcessCSCDoLocalRename(
    DWORD   argc,
    LPSTR   *argv
)
{

    DWORD dwError=ERROR_FILE_NOT_FOUND;
#ifdef CSC_ON_NT
    unsigned short uBuffSrc[MAX_PATH], uBuffDst[MAX_PATH];
#endif


    if (argc<2)
    {
        printf("Usage: ren source_name dest_dir [optional character to indicate replace]\r\n");
        return ERROR_INVALID_PARAMETER;
    }

#ifndef CSC_ON_NT
    dwError = ERROR_CALL_NOT_IMPLEMENTED;
#else
    memset(uBuffSrc, 0, sizeof(uBuffSrc));
    MultiByteToWideChar(CP_ACP, 0, argv[0], strlen(argv[0]), uBuffSrc, MAX_PATH*sizeof(unsigned short));

    memset(uBuffDst, 0, sizeof(uBuffDst));
    MultiByteToWideChar(CP_ACP, 0, argv[1], strlen(argv[1]), uBuffDst, MAX_PATH*sizeof(unsigned short));

    if (!CSCDoLocalRenameW(uBuffSrc, uBuffDst, (argc > 2)))
    {
        dwError = GetLastError();
    }
    else
    {
        dwError = ERROR_SUCCESS;
    }
#endif
    return dwError;
}

DWORD
ProcessCSCDoEnableDisable(
    DWORD   argc,
    LPSTR   *argv
)
{

    DWORD dwError=ERROR_FILE_NOT_FOUND;

    if (argc<1)
    {
        printf("Usage: endis fEnable\r\n");
        return ERROR_INVALID_PARAMETER;
    }

#ifndef CSC_ON_NT
    dwError = ERROR_CALL_NOT_IMPLEMENTED;
#else

    if (!CSCDoEnableDisable(*argv[0]!='0'))
    {
        dwError = GetLastError();
    }
    else
    {
        dwError = ERROR_SUCCESS;
    }
#endif
    return dwError;
}


DWORD
ProcessDoRandomWrites(
    DWORD   argc,
    LPSTR   *argv
)
{

    DWORD dwError=ERROR_SUCCESS, dwFileSize, dwOffset, dwOffsetHigh;
    unsigned short uBuff[MAX_PATH];
    unsigned char   uchData;
    
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    int i, count;
        
    if (argc>=1)
    {
        memset(uBuff, 0, sizeof(uBuff));
        MultiByteToWideChar(CP_ACP, 0, argv[0], strlen(argv[0]), uBuff, MAX_PATH*sizeof(unsigned short));
        hFile = CreateFileW(
                        uBuff,                              // name
                        GENERIC_READ|GENERIC_WRITE,         // access mode
                        FILE_SHARE_READ|FILE_SHARE_WRITE,   // share mode
                        NULL,                               // security descriptor
                        OPEN_EXISTING,                      // create disposition
                        0,                                  // file statributes if created
                        NULL);                              // template handle
#if LARGE_FILE
        hFile = CreateFileW(
                        uBuff,                              // name
                        GENERIC_READ|GENERIC_WRITE,         // access mode
                        FILE_SHARE_READ|FILE_SHARE_WRITE,   // share mode
                        NULL,                               // security descriptor
                        OPEN_ALWAYS,                      // create disposition
                        0,                                  // file statributes if created
                        NULL);                              // template handle
#endif

        if (hFile != INVALID_HANDLE_VALUE)
        {
            dwFileSize = GetFileSize(hFile, NULL);
            if (dwFileSize == -1)
            {
                dwError = GetLastError();
                goto bailout;
            }
            if (dwFileSize == 0)
            {
                printf("0 sized file \n");
                goto bailout;
            }
            
            srand( (unsigned)time( NULL ) );
            
//            count = rand() % 100;
            count = 2;

            printf("writing %d times \n", count);
                        
            for (i=0; i< count; ++i)
            {
                DWORD   dwReturn;
                
                dwOffset = rand() % dwFileSize;
                uchData = (unsigned char)rand();

                if (SetFilePointer(hFile, dwOffset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
                {
                    dwError = GetLastError();
                    printf("Failed SetFilePointer %d \n", dwError);
                    goto bailout;
                }

                printf("writing %c at %d \n", uchData, dwOffset);
                
                if (!WriteFile(hFile, &uchData, 1, &dwReturn, NULL))
                {
                    dwError = GetLastError();
                    printf("Failed write with error %d \n", dwError);
                    goto bailout;
                }
            }
        }
#if LARGE_FILE
                dwOffsetHigh = 1;
                if (SetFilePointer(hFile, 0x400000, &dwOffsetHigh, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
                {
                    dwError = GetLastError();
                    printf("Failed SetFilePointer %d \n", dwError);
                    goto bailout;
                }
                
                if (!SetEndOfFile(hFile))
                {
                    dwError = GetLastError();
                    printf("Failed SetEof %d \n", dwError);
                    goto bailout;
                }
#endif
    }
    
bailout:
    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }
    return dwError;
}




VOID
PrintBuffer(
    LPSTR   lpszBuff
    )
{
    printf(lpszBuff);
}

//=================================================================================
DWORD
ProcessCommandCode (
    DWORD CommandCode,
    DWORD CommandArgc,
    LPSTR *CommandArgv
    )
{
    DWORD Error = ERROR_SUCCESS;

        switch( CommandCode ) {
            case CmdCSCPinFile:
                Error = ProcessCSCPinFile(CommandArgc, CommandArgv);
            break;

            case CmdCSCUnPinFile:
                Error = ProcessCSCUnPinFile(CommandArgc, CommandArgv);
            break;
            case CmdCSCQueryFileStatus:
                Error = ProcessCSCQueryFileStatus(CommandArgc, CommandArgv);
            break;
            case CmdCSCEnum:
                Error = ProcessCSCEnum(CommandArgc, CommandArgv);
            break;
            case CmdCSCDelete:
                Error = ProcessCSCDelete(CommandArgc, CommandArgv);
            break;
            case CmdHelp:
                DisplayUsage();
            break;
            case CmdTimeLog:
                Error = ProcessTimeLog(CommandArgc, CommandArgv);
            break;
            case CmdCheckCSC:
                Error = ProcessCheckCSC(CommandArgc, CommandArgv);
            break;
            case CmdDbCheckCSC:
                Error = ProcessDbCheckCSC(CommandArgc, CommandArgv);
            break;
            case CmdCSCFill:
                Error = ProcessCSCFill(CommandArgc, CommandArgv);
            break;
            case CmdCSCMerge:
                Error = ProcessCSCMerge(CommandArgc, CommandArgv);
            break;
            case CmdCSCCopyReplica:
                Error = ProcessCSCCopyReplica(CommandArgc, CommandArgv);
            break;
            case CmdCSCEnumForStats:
                Error = ProcessCSCEnumForStats(CommandArgc, CommandArgv);
            break;
            case CmdCSCDoLocalRename:
                Error = ProcessCSCDoLocalRename(CommandArgc, CommandArgv);
                break;
            case CmdCSCDoEnableDisable:
                Error = ProcessCSCDoEnableDisable(CommandArgc, CommandArgv);
                break;
            case CmdShowTime:
                Error = ProcessShowTime( CommandArgc, CommandArgv );
                break;
            case CmdEncryptDecrypt:
                Error = ProcessEncryptDecrypt(CommandArgc, CommandArgv );
                break;
            case CmdDoRandomWrites:
                Error = ProcessDoRandomWrites(CommandArgc, CommandArgv );
                break;
            case CmdQuit :
                exit (0);

        default:
            TestDbgAssert( FALSE );
            fprintf(stderr, "Unknown Command Specified.\n");
            DisplayUsage();
            break;
        }
        cCommands++;

        if( Error != ERROR_SUCCESS ) {
            LPSTR lpstr;

            cFails++;
            Format_Error(Error, &lpstr);
            printf("FAILED (%s), %ld-%s.\n",
                GlobalCommandInfo[CommandCode].CommandName, Error, lpstr );
            LocalFree(lpstr);
        }
        else {
            if(!g_bQuietMode)
                printf("Command (%s) successfully completed.\n", GlobalCommandInfo[CommandCode].CommandName );
        }
        return Error;
}


//=================================================================================
VOID
__cdecl
main(
    int argc,
    char *argv[]
    )
{

    DWORD Error;
    COMMAND_CODE CommandCode;
    CHAR InBuffer[DEFAULT_BUFFER_SIZE];
    DWORD CArgc;
    LPSTR CArgv[MAX_COMMAND_ARGS];
    unsigned u1 = 1, u2 = 0xffffffff;

    DWORD CommandArgc;
    LPSTR *CommandArgv;

    printf("u1=0x%x u2=0x%x, (int)(u1-u2)=%d, (u1-u2)=0x%x \r\n", u1, u2, (int)(u1-u2), (u1-u2));

    /* must check for batch mode.  if there are command line parms, assume batch mode */
    if (argc > 1)
    {
        //this means that the arguments translate directly into CommandArgc....
        CommandCode = DecodeCommand( argv[1] );
        if( CommandCode == UnknownCommand ) {
            printf("Unknown Command Specified.\n");
            return;
        }

        CommandArgc = argc - 2;
        CommandArgv = &argv[2];

        Error = ProcessCommandCode (CommandCode,CommandArgc,CommandArgv);

        if (DumpUncList)
            fclose(DumpUncList);
        if (UncList)
            fclose(UncList);

        return;
    }

    DisplayUsage();

    for(;;) {

        fprintf(stderr,  "Command : " );

        gets( InBuffer );

        CArgc = 0;
        ParseArguments( InBuffer, CArgv, &CArgc );

        if( CArgc < 1 ) {
            continue;
        }

        //
        // decode command.
        //

        CommandCode = DecodeCommand( CArgv[0] );
        if( CommandCode == UnknownCommand ) {
            fprintf(stderr, "Unknown Command Specified.\n");
            continue;
        }

        CommandArgc = CArgc - 1;
        CommandArgv = &CArgv[1];

        Error = ProcessCommandCode (CommandCode,CommandArgc,CommandArgv);

    }

    return;
}

//=================================================================================
DWORD
GetLeafLenFromPath(
    LPSTR   lpszPath
    )
{
    DWORD len;
    LPSTR   lpT;

    if(!lpszPath)
        return(0);

    len = lstrlen(lpszPath);

    if (len == 0) {

        return (len);

    }

    lpT = lpszPath+len-1;
    if (*lpT =='\\') {
        --lpT;
    }
    for (; lpT >= lpszPath; --lpT) {
        if (*lpT == '\\') {
            break;
        }
    }
    return (lstrlen(lpT));
}

//=================================================================================
DWORD WINAPIV Format_String(LPSTR *plpsz, LPSTR lpszFmt, ...)
{
    const char c_Func_Name[] = "[Format_String] ";
    DWORD dwRet;
    va_list vArgs;

    va_start (vArgs, lpszFmt);
    dwRet = Format_StringV(plpsz, lpszFmt, &vArgs);
    va_end (vArgs);

    return(dwRet);
}

//=================================================================================
DWORD WINAPI Format_Error(DWORD dwErr, LPSTR *plpsz)
{
    DWORD dwRet;

    if(dwErr != ERROR_SUCCESS)
    {
        dwRet = Format_MessageV(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            dwErr, plpsz, NULL, NULL);
    }
    else
    {
        const char szMsg[] = "No Error";
        Format_String(plpsz, (LPSTR)szMsg);
        dwRet = lstrlen(szMsg);
    }

    return(dwRet);
}

//=================================================================================
DWORD WINAPI Format_StringV(LPSTR *plpsz, LPCSTR lpszFmt, va_list *vArgs)
{
    return(Format_MessageV(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        0, plpsz, lpszFmt, vArgs));
}

// ***************************************************************************
DWORD WINAPI Format_MessageV(DWORD dwFlags, DWORD dwErr, LPSTR *plpsz, LPCSTR lpszFmt, va_list *vArgs)
{
    const char c_Func_Name[] = "[Format_MessageV]";

    DWORD dwRet;
    DWORD dwGLE;

    *plpsz = NULL;
    dwRet = FormatMessage(dwFlags, lpszFmt, dwErr, 0, (LPSTR) plpsz, 0, vArgs);

    if (!dwRet || !*plpsz)
    {
        dwGLE = GetLastError();
        printf("%s FormatMessage Failed: %s. dwRet: %#lx!. *plpsz:%#lx! GLE:%d\r\n", c_Func_Name, lpszFmt, dwRet, *plpsz, dwGLE);

        if (*plpsz)
            LocalFree ((HLOCAL) *plpsz);
        *plpsz = NULL;
        return 0;
    }

    return(dwRet);
}

#if 0
BOOL
GetStreamInformation(
    LPCSTR  lpExistingFileName,
    LPVOID  *lpStreamInformation
    )
{
    HANDLE SourceFile = INVALID_HANDLE_VALUE;
    PFILE_STREAM_INFORMATION StreamInfoBase = NULL;
    ULONG StreamInfoSize;
    IO_STATUS_BLOCK IoStatus;
    BOOL    fRet = FALSE;
    DWORD   Status;

    *lpStreamInformation = NULL;
    SourceFile = CreateFile(
                    lpExistingFileName,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );
    if (SourceFile == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }
    //
    //  Obtain the full set of streams we have to copy.  Since the Io subsystem does
    //  not provide us a way to find out how much space this information will take,
    //  we must iterate the call, doubling the buffer size upon each failure.
    //
    //  If the underlying file system does not support stream enumeration, we end up
    //  with a NULL buffer.  This is acceptable since we have at least a default
    //  data stream,
    //

    StreamInfoSize = 4096;
    do {
        StreamInfoBase = LocalAlloc(LPTR, StreamInfoSize );

        if ( !StreamInfoBase ) {
            SetLastError( STATUS_NO_MEMORY );
            goto bailout;
        }

        Status = NtQueryInformationFile(
                    SourceFile,
                    &IoStatus,
                    (PVOID) StreamInfoBase,
                    StreamInfoSize,
                    FileStreamInformation
                    );

        if (Status != STATUS_SUCCESS) {
            //
            //  We failed the call.  Free up the previous buffer and set up
            //  for another pass with a buffer twice as large
            //

            LocalFree(StreamInfoBase);
            StreamInfoBase = NULL;
            StreamInfoSize *= 2;
        }

    } while ( Status == STATUS_BUFFER_OVERFLOW || Status == STATUS_BUFFER_TOO_SMALL );

    if (Status == STATUS_SUCCESS)
    {
        fRet = TRUE;
    }

bailout:

    if (SourceFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(SourceFile);
    }

    *lpStreamInformation = StreamInfoBase;

    return fRet;
}
#endif


#ifdef CSC_ON_NT
BOOL
DoPinningW(
    LPWSTR   lpwzName,
    DWORD   dwHintFlags,
    BOOL    fRecurse
    )
{
    unsigned short uBuff[MAX_PATH];
    WIN32_FIND_DATAW sFind32W;
    HANDLE  hFind = NULL;
    BOOL    fRet = TRUE;
    DWORD   lenName, dwStatus, dwPinCount, dwError;

    lenName = lstrlenW(lpwzName);

    if (lenName < 5)
    {
        return FALSE;
    }

    lstrcpyW(uBuff, lpwzName);

    if (uBuff[lenName-1] == (USHORT)'\\')
    {
        uBuff[lenName-1] = 0;

        --lenName;

        if (lenName < 5)
        {
            return FALSE;
        }
    }

    hFind = FindFirstFileW(uBuff, &sFind32W);
    if (hFind==INVALID_HANDLE_VALUE)
    {
        lstrcatW(uBuff, L"\\*");

        hFind = FindFirstFileW(uBuff, &sFind32W);

        uBuff[lenName] = 0;

        if (hFind==INVALID_HANDLE_VALUE)
        {
            return FALSE;
        }

    }
    else if (sFind32W.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        FindClose(hFind);

        lstrcatW(uBuff, L"\\*");
        hFind = FindFirstFileW(uBuff, &sFind32W);
        uBuff[lenName] = 0;

        if (hFind==INVALID_HANDLE_VALUE)
        {
            return FALSE;
        }
    }

    do
    {
        if (!CSCPinFileW(uBuff, dwHintFlags, &dwStatus, &dwPinCount, &dwHintFlags))
        {
            dwError = GetLastError();   
        }
        else
        {
            PrintCSCEntryInfo(NULL, dwStatus, dwPinCount, dwHintFlags, NULL);
        }

        if (fRecurse)
        {
            do
            {
                if(!FindNextFileW(hFind, &sFind32W))
                {
                    goto bailout;
                }

                if ((!lstrcmpW(sFind32W.cFileName, L"."))||(!lstrcmpW(sFind32W.cFileName, L"..")))
                {
                    continue;
                }

                uBuff[lenName] = (USHORT)'\\';
                uBuff[lenName+1] = 0;
                lstrcatW(uBuff, sFind32W.cFileName);

                if (sFind32W.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                {
                    DoPinningW(uBuff, dwHintFlags, fRecurse);
                }

                break;
            }
            while (TRUE);
        }
        else
        {
            break;
        }
    }
    while (TRUE);

bailout:
    if (hFind)
    {
        FindClose(hFind);
    }
    return fRet;
}

#else

BOOL
DoPinningA(
    LPSTR   lpszName,
    DWORD   dwHintFlags,
    BOOL    fRecurse
    )
{
    char chBuff[MAX_PATH];
    WIN32_FIND_DATAA sFind32A;
    HANDLE  hFind = NULL;
    BOOL    fRet = TRUE;
    DWORD   lenName, dwStatus, dwPinCount, dwError;


    lenName = lstrlen(lpszName);

    if (lenName < 5)
    {
        return FALSE;
    }

    lstrcpy(chBuff, lpszName);

    if (chBuff[lenName-1] == (USHORT)'\\')
    {
        chBuff[lenName-1] = 0;
        --lenName;
        if (lenName < 5)
        {
            return FALSE;
        }
    }

    hFind = FindFirstFileA(chBuff, &sFind32A);

    if (hFind==INVALID_HANDLE_VALUE)
    {
        lstrcatA(chBuff, "\\*");
        hFind = FindFirstFileA(chBuff, &sFind32A);
        if (hFind==INVALID_HANDLE_VALUE)
        {
            return FALSE;
        }
        chBuff[lenName] = 0;
    }

    if (sFind32A.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        FindClose(hFind);

        lstrcatA(chBuff, "\\*");
        hFind = FindFirstFileA(chBuff, &sFind32A);

        if (hFind==INVALID_HANDLE_VALUE)
        {
            return FALSE;
        }
        chBuff[lenName] = 0;
    }

    do
    {
        if (!CSCPinFileA(chBuff, dwHintFlags, &dwStatus, &dwPinCount, &dwHintFlags))
        {
            dwError = GetLastError();   
        }
        else
        {
            PrintCSCEntryInfo(NULL, dwStatus, dwPinCount, dwHintFlags, NULL);
        }

        if (fRecurse)
        {
            if(!FindNextFile(hFind, &sFind32A))
            {
                goto bailout;
            }

            chBuff[lenName] = '\\';
            lstrcat(chBuff, sFind32A.cFileName);

            if (sFind32A.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                DoPinningA(chBuff, dwHintFlags, fRecurse);
            }
        }
        else
        {
            break;
        }
    }
    while (TRUE);

bailout:
    if (hFind)
    {
        FindClose(hFind);
    }
    return fRet;
}

#endif


//=================================================================================
DWORD
ProcessShowTime (
    DWORD argc,
    LPSTR *argv
    )
{
    DWORD Error, dwSize;
    FILETIME ftTemp;
    SYSTEMTIME SystemTime;

    if(argc != 2)
        return 0xffffffff;

    sscanf(argv[0], "%x", &(ftTemp.dwHighDateTime));
    sscanf(argv[1], "%x", &(ftTemp.dwLowDateTime));

    if(FileTimeToSystemTime( &ftTemp, &SystemTime )) {
        printf("%02u/%02u/%04u %02u:%02u:%02u\n ",
                    SystemTime.wMonth,
                    SystemTime.wDay,
                    SystemTime.wYear,
                    SystemTime.wHour,
                    SystemTime.wMinute,
                    SystemTime.wSecond );

    }
    else {
        printf("Wrong Times \n");
    }

    return ERROR_SUCCESS;
}

DWORD
ProcessEncryptDecrypt(
    DWORD   argc,
    LPSTR   *argv
)
{

    DWORD dwStatus, dwError=ERROR_SUCCESS;
    BOOL    fEncrypt = FALSE;
#ifdef CSC_ON_NT
    unsigned short uBuff[MAX_PATH];
#endif

    if (argc != 1)
    {
        printf("CSCUnPinFile: must provide a UNC path \r\n");
    }
    else
    {
        fEncrypt = !((*argv[0] == 'u')||(*argv[0] == 'U'));            
        if (argc == 1)
        {
            if(!CSCEncryptDecryptDatabase(fEncrypt, NULL, 0))
            {
                dwError = GetLastError();   
            }
        }
        else
        {
#if 0
            memset(uBuff, 0, sizeof(uBuff));
            MultiByteToWideChar(CP_ACP, 0, argv[1], strlen(argv[1]), uBuff, MAX_PATH*sizeof(unsigned short));

            if (!CSCEncryptDecryptFileW(uBuff, fEncrypt))
            {
                dwError = GetLastError();   
            }
#endif
        }
    }
    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\util\cscutil\db.c ===
#define UNICODE
#define PUBLIC
#define PRIVATE
#include <stdlib.h>
#include <stdio.h>
#include <memory.h>
#include <string.h>
#include <windows.h>
#include <conio.h>
#include <share.h>
#include <dos.h>
#include <sddl.h>
#include "cscapi.h"
#include "csc_bmpc.h"
#pragma pack (1)

#include "struct.h"


#define  MAX_PQ_PER_PAGE   10
#define  MAX_SHARES_PER_PAGE  6
#define  MAX_FILE_PER_PAGE   4
#define  MAX_INODES_PER_PAGE   15

#define _wtoupper(x)     ( ( ((x)>='a')&&((x)<='z') ) ? ((x)-'a'+'A'):(x))

typedef PVOID   CSCHFILE;

#include "shdcom.h"
#include "cscsec.h"

#define  ESC       0x1b

#include "record.h"

#define InodeFromRec(ulRec, fFile)  ((ulRec+ULID_FIRST_USER_DIR-1) | ((fFile)?0x80000000:0))
#define RecFromInode(hShadow)       ((hShadow & 0x7fffffff) - (ULID_FIRST_USER_DIR-1))

WCHAR rgwch[256];
WCHAR rgPrint[1024];
WCHAR rgwchPar[256];

WCHAR Shadow[] = L"\\WINDOWS\\CSC";
WCHAR Backslash[] = L"\\";
WCHAR DbDir[256];    // shadow database
WCHAR Name[MAX_PATH];     // working buffer

extern BOOLEAN fSwDebug;

// The _DB is used to distinguish this from the kernel mode CSC_BITMAP
// or the usermode _U

typedef struct _CSC_BITMAP_DB {
    DWORD bitmapsize;  // size in bits. How many bits effective in the bitmap
    DWORD numDWORD;    // how many DWORDs to accomodate the bitmap */
    LPDWORD bitmap;    // The bitmap itself
} CSC_BITMAP_DB, *LPCSC_BITMAP_DB, *PCSC_BITMAP_DB;

// append this to inode file name to get the stream name
PWCHAR CscBmpAltStrmName = L":cscbmp";

LONG DispFunc(PWSTR);
LONG EditFileFunc(PWSTR, FILEREC *);
LONG EditShareFunc(PWSTR, SHAREREC *);
VOID DisplayShares(PWSTR);
VOID DisplayInodes(VOID);
VOID DisplayPriorityQ(VOID);
VOID DisplaySids(VOID);
VOID DisplayFile(ULONG ulid, PWSTR, BOOL fForce);
VOID EditFile(ULONG ulid);
VOID EditShare(ULONG ulid);
LONG HexToA(ULONG, PWSTR, LONG);

// From recordse.c
#define CSC_NUMBER_OF_SIDS_OFFSET (0x0)
#define CSC_SID_SIZES_OFFSET      (CSC_NUMBER_OF_SIDS_OFFSET + sizeof(ULONG))

VOID
FormNameStringDB(
   PWSTR lpdbID,
   ULONG ulidFile,
   PWSTR lpName);

BOOL
FindAncestor(
    ULONG ulid,
    ULONG *lpulidDir);

LONG
RoughCompareWideStringWithAnsiString(
    PWSTR   lpSrcString,
    USHORT  *lpwDstString,
    LONG     cntMax);

PWSTR
ConvertGmtTimeToString(
    FILETIME Time,
    PWSTR OutputBuffer);

int
DBCSC_BitmapIsMarked(
    LPCSC_BITMAP_DB lpbitmap,
    DWORD bitoffset);

int
DBCSC_BitmapAppendStreamName(
    PWCHAR fname,
    DWORD bufsize);

int
DBCSC_BitmapRead(
    LPCSC_BITMAP_DB *lplpbitmap,
    LPCTSTR filename);

VOID
DBCSC_BitmapOutput(
    FILE *outStrm,
    LPCSC_BITMAP_DB lpbitmap);

#if defined(CSCUTIL_INTERNAL)
CmdDb(PWSTR DbArg)
{
   BOOL fRet;
   DWORD junk;
   unsigned uAttr;
   int iRet = -1;
   if (DbArg == NULL) {
       fRet = CSCGetSpaceUsageW(
                    DbDir,
                    sizeof(DbDir)/sizeof(WCHAR),
                    &junk,
                    &junk,
                    &junk,
                    &junk,
                    &junk,
                    &junk);
       if (fRet == FALSE)
          wcscpy(DbDir, Shadow);
    } else {
       wcscpy(DbDir, DbArg);
    }
    if((uAttr = GetFileAttributesW(DbDir)) == 0xffffffff) {
       MyPrintf(L"Error accessing directory %ws \r\n", DbDir);
    } else if (!(uAttr & _A_SUBDIR)) {
       MyPrintf(L"%ws is not a directory\r\n", DbDir);
    } else {
       do {
           memset(rgwch, 0, sizeof(rgwch));
           MyPrintf(
               L"\r\n"
               L"(S)hares [name], "
               L"Pri(Q), "
               L"(O)wner, "
               L"(F)ile inode# [name], "
               L"(E)dit inode#, "
               L"e(D)it share#, "
               L"e(X)it "
               L":");
           if (!fgetws(rgwch, sizeof(rgwch)/sizeof(WCHAR), stdin))
               break;
           MyPrintf(L"\r\n");
           if (DispFunc(rgwch) == 0)
               break;
        } while (1);
       iRet = 0;
    }
   return (iRet);
}

LONG
DispFunc(PWSTR lpBuff)
{
    WCHAR wch;
    ULONG ulid;
    LONG cnt;

    // Chop leading blanks
    if (lpBuff != NULL)
        while (*lpBuff != L'\0' && *lpBuff == L' ')
            lpBuff++;

    cnt = swscanf(lpBuff, L"%c", &wch);

    if (!cnt)
        return 0;

    switch (wch) {
        // Display shares database
        case L's':
        case L'S':
            cnt = swscanf(lpBuff, L"%c%ws", &wch, rgwchPar);
            DisplayShares((cnt==2) ? rgwchPar : NULL);
            break;
        // display priority Q database
        case L'q':
        case L'Q':
            DisplayPriorityQ();
            break;
        case L'o':
        case L'O':
            DisplaySids();
            break;
        case L'f':
        case L'F':
            cnt = swscanf(lpBuff, L"%c%x%ws", &wch, &ulid, rgwchPar);
            if (cnt==2) {
                // display Inode file
                DisplayFile(ulid, NULL, (wch == 'F') ? TRUE : FALSE);
            } else if (cnt==3) {
                MyPrintf(L"Looking for %ws in 0x%x \r\n", rgwchPar, ulid);
                // display Inode file
                DisplayFile(ulid, rgwchPar, (wch == 'F') ? TRUE : FALSE);
            }
            break;
        case L'e':
        case L'E':
            cnt = swscanf(lpBuff, L"%c%x%ws", &wch, &ulid, rgwchPar);
            if (cnt==2) {
                // display Inode file
                EditFile(ulid);
            }
            break;
        case L'd':
        case L'D':
            cnt = swscanf(lpBuff, L"%c%x%ws", &wch, &ulid, rgwchPar);
            if (cnt==2) {
                // display Inode file
                EditShare(ulid);
            }
            break;
        case L'x':
        case L'X':
            return 0;
    }
    return 1;
}

VOID
DisplaySecurityContext2(
    PWSTR pSecurityDescriptor,
    LPRECORDMANAGER_SECURITY_CONTEXT   pSecurityContext)
{
    PCACHED_SECURITY_INFORMATION pCachedSecurityInformation;
    BOOL fGotOne = FALSE;
    ULONG i;

    pCachedSecurityInformation = (PCACHED_SECURITY_INFORMATION)pSecurityContext;

    for (i = 0; i < MAXIMUM_NUMBER_OF_USERS; i++) {
        CSC_SID_INDEX SidIndex;

        SidIndex = pCachedSecurityInformation->AccessRights[i].SidIndex;
        if (SidIndex != CSC_INVALID_SID_INDEX) {
            fGotOne = TRUE;
            break;
        }
    }

    if (fGotOne == FALSE)
        return;

    MyPrintf(L"%ws Security: ", pSecurityDescriptor);
    for (i = 0; i < MAXIMUM_NUMBER_OF_USERS; i++) {
        CSC_SID_INDEX SidIndex;

        SidIndex = pCachedSecurityInformation->AccessRights[i].SidIndex;
        if (SidIndex == CSC_INVALID_SID_INDEX) {
            continue;
        }else if (SidIndex == CSC_GUEST_SID_INDEX) {
            MyPrintf(L"(G:0x%x)",
                pCachedSecurityInformation->AccessRights[i].MaximalRights);
        } else {
            MyPrintf(L"(0x%x:0x%x)",
                SidIndex,
                pCachedSecurityInformation->AccessRights[i].MaximalRights);
        }
    }
    MyPrintf(L"\r\n");
}

VOID
DisplayShares(PWSTR ShareName)
{
    FILE *fp= NULL;
    SHAREHEADER sSH;
    SHAREREC sSR;
    ULONG ulrec = 0;
    LONG count = 0;
    WCHAR TimeBuf1[30];
    WCHAR TimeBuf2[30];

    FormNameStringDB(DbDir, ULID_SHARE, Name);
    if (fp = _wfopen(Name, L"rb")) {
        if (fread(&sSH, sizeof(SHAREHEADER), 1, fp) != 1) {
            MyPrintf(L"Error reading server header \r\n");
            goto bailout;
        }

        MyPrintf(L"Header: Flags=%x Version=%lx Records=%ld Size=%d \r\n",
                sSH.uFlags, sSH.ulVersion, sSH.ulRecords, sSH.uRecSize);

        MyPrintf(L"Store(Max): Size=%d Dirs=%d Files=%d\r\n",
                         sSH.sMax.ulSize,
                         sSH.sMax.ucntDirs,
                         sSH.sMax.ucntFiles);
        MyPrintf(L"Store(Cur): Size=%d Dirs=%d Files=%d\r\n",
                         sSH.sCur.ulSize,
                         sSH.sCur.ucntDirs,
                         sSH.sCur.ucntFiles);
        MyPrintf(L"\r\n");

        for (ulrec = 1; fread(&sSR, sizeof(SHAREREC), 1, fp) == 1; ulrec++) {
            if (sSR.uchType == (UCHAR)REC_DATA) {
                if (ShareName != NULL) {
                    if (RoughCompareWideStringWithAnsiString(
                            ShareName,
                            sSR.rgPath,
                            sizeof(sSR.rgPath)/sizeof(WCHAR)-1)
                    ) {
                        continue;
                    }
                }

                MyPrintf(L"%ws (0x%x) Root=0x%x\r\n",
                                sSR.rgPath,
                                ulrec,
                                sSR.ulidShadow);
                MyPrintf(L"  Status=0x%x RootStatus=0x%x "
                         L"HntFlgs=0x%x HntPri=0x%x Attr=0x%x\r\n",
                            sSR.uStatus,
                            (unsigned)(sSR.usRootStatus),
                            (unsigned)(sSR.uchHintFlags),
                            (unsigned)(sSR.uchHintPri),
                            sSR.dwFileAttrib);

                ConvertGmtTimeToString(sSR.ftLastWriteTime, TimeBuf1);
                ConvertGmtTimeToString(sSR.ftOrgTime, TimeBuf2);
                MyPrintf(L"  LastWriteTime: %ws Orgtime: %ws\r\n", TimeBuf1, TimeBuf2);

                DisplaySecurityContext2(L"  ShareLevel",&sSR.sShareSecurity);
                DisplaySecurityContext2(L"  Root ",&sSR.sRootSecurity);
                MyPrintf(L"\r\n");
            }
        }
    }
bailout:
    if (fp)
        fclose(fp);
}

VOID
DisplayPriorityQ(VOID)
{
   FILE *fp= NULL;
   QHEADER sQH;
   QREC sQR;
   ULONG ulRec = 1;
   LONG count = 0;

   FormNameStringDB(DbDir, ULID_PQ, Name);
   if (fp = _wfopen(Name, L"rb")) {
       if (fread(&sQH, sizeof(QHEADER), 1, fp) != 1) {
           MyPrintf(L"Error reading PQ header \r\n");
           goto bailout;
        }
       MyPrintf(L"Header: Flags=%x Version=%lx Records=%ld Size=%d head=%ld tail=%ld\r\n",
                    sQH.uchFlags,
                    sQH.ulVersion,
                    sQH.ulRecords,
                    sQH.uRecSize,
                    sQH.ulrecHead,
                    sQH.ulrecTail);
       MyPrintf(L"\r\n");
       MyPrintf(
       L"  REC SHARE      DIR   SHADOW   STATUS  PRI HINTFLGS HINTPRI  PREV  NEXT DIRENT\r\n");
       for (ulRec = sQH.ulrecHead; ulRec;) {
           fseek(fp, ((ulRec-1) * sizeof(QREC))+sizeof(QHEADER), SEEK_SET);
           if (fread(&sQR, sizeof(QREC), 1, fp)!=1)
               break;
           MyPrintf(L"%5d %5x %8x %8x %8x %4d %8x %7d %5d %5d %6d\r\n",
                        ulRec,
                        sQR.ulidShare,
                        sQR.ulidDir,
                        sQR.ulidShadow,
                        sQR.usStatus,
                        (unsigned)(sQR.uchRefPri),
                        (unsigned)(sQR.uchHintFlags),
                        (unsigned)(sQR.uchHintPri),
                        sQR.ulrecPrev,
                        sQR.ulrecNext,
                        sQR.ulrecDirEntry);
            ++count;
           ulRec = sQR.ulrecNext;
        }
    }
bailout:
   if (fp)
       fclose(fp);
}

VOID
DisplaySids(VOID)
{
   DWORD Status = ERROR_SUCCESS;
   ULONG SidOffset = 0;
   ULONG NumberOfSids;
   ULONG BytesRead;
   ULONG i;
   PCSC_SIDS pCscSids = NULL;
   FILE *fp = NULL;
   LPWSTR StringSid = NULL;
   SID_NAME_USE SidUse;
   BOOL bRet = FALSE;
   DWORD cbAcctName;
   DWORD cbDomainName;
   WCHAR AcctName[MAX_PATH];
   WCHAR DomainName[MAX_PATH];

   FormNameStringDB(DbDir, ULID_SID_MAPPINGS, Name);
   fp = _wfopen(Name, L"rb");
   if (fp == NULL) {
        MyPrintf(L"Error opening SID file\r\n");
        goto bailout;
    }
   fseek(fp, CSC_NUMBER_OF_SIDS_OFFSET, SEEK_SET);
   if (fread(&NumberOfSids, sizeof(NumberOfSids), 1, fp) != 1) {
        MyPrintf(L"Error reading # SIDS\r\n");
        goto bailout;
    }

    pCscSids = (PCSC_SIDS)malloc(sizeof(CSC_SIDS) + sizeof(CSC_SID) * NumberOfSids);

    if (pCscSids == NULL) {
        MyPrintf(L"Error allocating memory of SID array\n");
        goto bailout;
    }

    pCscSids->MaximumNumberOfSids = NumberOfSids;
    pCscSids->NumberOfSids = NumberOfSids;

    for (i = 0; i < NumberOfSids; i++)
        pCscSids->Sids[i].pSid = NULL;

    fseek(fp, CSC_SID_SIZES_OFFSET, SEEK_SET);
    if (fread(&pCscSids->Sids, sizeof(CSC_SID) * NumberOfSids, 1, fp) != 1) {
        MyPrintf(L"Error reading SIDS\r\n");
        goto bailout;
    }

    // The array structure has been initialized correctly. Each of the
    // individual sids needs to be initialized.
    SidOffset = CSC_SID_SIZES_OFFSET + sizeof(CSC_SID) * NumberOfSids;

    for (i = 0; i < NumberOfSids; i++) {
        pCscSids->Sids[i].pSid = malloc(pCscSids->Sids[i].SidLength);
        if (pCscSids->Sids[i].pSid == NULL) {
            MyPrintf(L"Error allocating memory of SID array\n");
            goto bailout;
        }
        fseek(fp, SidOffset, SEEK_SET);
        if (fread(pCscSids->Sids[i].pSid, pCscSids->Sids[i].SidLength, 1, fp) != 1) {
            MyPrintf(L"Error reading SIDS\r\n");
            goto bailout;
        }
        SidOffset += pCscSids->Sids[i].SidLength;
    }

    MyPrintf(L"MaximumNumberOfSids: %d\r\n"
             L"NumberOfSids: %d\r\n",
             pCscSids->MaximumNumberOfSids,
             pCscSids->NumberOfSids);
    for (i = 0; i < NumberOfSids; i++) {
        StringSid = NULL;
        if (ConvertSidToStringSid(pCscSids->Sids[i].pSid, &StringSid)) {
            MyPrintf(L"---0x%x (%d)---\r\n"
                     L"  SidLength: %d\r\n"
                     L"  Sid: %ws\r\n",
                     i+1, i+1,
                     pCscSids->Sids[i].SidLength,
                     StringSid);
            LocalFree(StringSid);
            StringSid = NULL;
            DomainName[0] = L'0';
            AcctName[0] = L'0';
            cbAcctName = sizeof(AcctName) / sizeof(WCHAR);
            cbDomainName = sizeof(DomainName) / sizeof(WCHAR);
            bRet = LookupAccountSid(
                        NULL,
                        pCscSids->Sids[i].pSid,
                        AcctName,
                        &cbAcctName,
                        DomainName,
                        &cbDomainName,
                        &SidUse);
            if (bRet) {
                MyPrintf(L"  Name: %ws%ws%ws\r\n",
                         DomainName,
                         DomainName[0] ? L"\\" : L"",
                         AcctName);
            } else {
                MyPrintf(L"  Name: <unknown>\r\n");
            }
        } else {
            MyPrintf(L"ConvertSidToStringSid returned %d\r\n", GetLastError());
        }
    }
bailout:
   if (fp)
       fclose(fp);
}

VOID
DisplayFile(
    ULONG ulid,
    PWSTR lpwszName,
    BOOL fForce)
{
    FILE *fp= NULL;
    FILEHEADER sFH;
    FILEREC sFR;
    LONG fLfn=0;
    ULONG ulidDir=ulid;
    LONG fPrintOvf = 0, count=0;
    WCHAR strmPath[MAX_PATH];
    LPCSC_BITMAP_DB lpbitmap = NULL;
    WCHAR TimeBuf1[30];
    WCHAR TimeBuf2[30];

    if (IsLeaf(ulid)) {
        if (!FindAncestor(ulid, &ulidDir))
            return;
    }

    FormNameStringDB(DbDir, ulidDir, Name);

    if (fp = _wfopen(Name, L"rb")) {
        if (fread(&sFH, sizeof(FILEHEADER), 1, fp) != 1) {
            MyPrintf(L"Error reading file header \r\n");
            goto bailout;
        }


        if (ulid == ulidDir) {
            MyPrintf(L"Header: Flags=%x Version=%lx Records=%ld Size=%d\r\n",
                        sFH.uchFlags, sFH.ulVersion, sFH.ulRecords, sFH.uRecSize);
            MyPrintf(L"Header: bytes=%ld entries=%d Share=%ld Dir=%lx\r\n",
                        sFH.ulsizeShadow, sFH.ucShadows, sFH.ulidShare, sFH.ulidDir);
            printf ("\r\n");
            fPrintOvf = 1;
        }

        while (fread(&sFR, sizeof(FILEREC), 1, fp)==1) {
            if (sFR.uchType != (unsigned char)REC_OVERFLOW) {
                if (fLfn) {
                    if (ulidDir != ulid)
                        break;
                }
                fLfn = 0;
            }
            if (sFR.uchType==(unsigned char)REC_DATA) {
                if (ulidDir != ulid) {
                    if (ulid != sFR.ulidShadow)
                        continue;
                }
                if (lpwszName) {
                    if (RoughCompareWideStringWithAnsiString(
                            lpwszName,
                            sFR.rgwName,
                            sizeof(sFR.rgw83Name)/sizeof(WCHAR)-1)
                    ) {
                        continue;
                    }
                }

                fPrintOvf = 1;
                MyPrintf(L"%ws (0x%x)\r\n", sFR.rgw83Name, sFR.ulidShadow);
                if (fForce == TRUE) {
                    MyPrintf(L"  Type=%c Flags=0x%x status=0x%x size=%ld attrib=0x%lx\r\n",
                                sFR.uchType,
                                (unsigned)sFR.uchFlags,
                                sFR.uStatus,
                                sFR.ulFileSize,
                                sFR.dwFileAttrib);
                    MyPrintf(L"  PinFlags=0x%x PinCount=%d RefPri=%d OriginalInode=0x%0x\r\n",
                                 (unsigned)(sFR.uchHintFlags),
                                 (int)(sFR.uchHintPri),
                                 (int)(sFR.uchRefPri),
                                 sFR.ulidShadowOrg);
                    ConvertGmtTimeToString(sFR.ftLastWriteTime, TimeBuf1);
                    ConvertGmtTimeToString(sFR.ftOrgTime, TimeBuf2);
                    MyPrintf(L"  LastWriteTime: %ws Orgtime: %ws\r\n", TimeBuf1, TimeBuf2);
                    if (sFR.rgwName[0]) {
                        MyPrintf(L"  LFN:%ws", sFR.rgwName);
                        fLfn = 1;
                    }

                    MyPrintf(L"\r\n");
                    DisplaySecurityContext2(L" ",&sFR.Security);

                    if (ulidDir != ulid) {
                        MyPrintf(L"  DirInode = 0x%x\r\n", ulidDir);
                        FormNameStringDB(DbDir, sFR.ulidShadow, strmPath);
                        DBCSC_BitmapAppendStreamName(strmPath, MAX_PATH);
                        // read bitmap
                        switch(DBCSC_BitmapRead(&lpbitmap, strmPath)) {
                            case 1:
                                // Print the bitmap associated if any
                                MyPrintf(L"\r\n");
                                DBCSC_BitmapOutput(stdout, lpbitmap);
                                MyPrintf(L"\r\n");
                                // if bitmap opened delete bitmap
                                // DBCSC_BitmapDelete(&lpbitmap);
                                break;
                            case -1:
                                MyPrintf(L"Error reading bitmap file %ws or bitmap invalid\r\n",
                                                strmPath);
                                break;
                            case -2:
                                MyPrintf(L"No CSCBitmap\n");
                                break;
                            case 0:
                            default:
                                MyPrintf(L"Something strange going on with bitmap printing...\r\n");
                                break;
                        }
                        break;
                    }
                    MyPrintf(L"\r\n");
                } else if (fPrintOvf && (sFR.uchType == (unsigned char)REC_OVERFLOW)) {
                    MyPrintf(L"(overflow) ");
                    MyPrintf(L"%ws\r\n\r\n", sFR.rgwOvf);
                }
            }

            // do counting only when we are scanning the whole directory
            if (!lpwszName &&  (ulid == ulidDir)) {
                ++count;
            }
        }
        MyPrintf(L"\r\n");
    }
bailout:
    if (fp)
        fclose(fp);
}

VOID
EditFile(
    ULONG ulid)
{
    FILE *fp= NULL;
    FILEHEADER sFH;
    FILEREC sFR;
    ULONG ulidDir=ulid;
    WCHAR TimeBuf1[30];
    WCHAR TimeBuf2[30];
    LONG iRes;

    if (!IsLeaf(ulid)) {
        MyPrintf(L"0x%x is a directory.\r\n", ulid);
        return;
    }

    if (!FindAncestor(ulid, &ulidDir))
        return;

    FormNameStringDB(DbDir, ulidDir, Name);

    if (fp = _wfopen(Name, L"rb+")) {
        if (fread(&sFH, sizeof(FILEHEADER), 1, fp) != 1) {
            MyPrintf(L"Error reading file header \r\n");
            goto bailout;
        }

        while (fread(&sFR, sizeof(FILEREC), 1, fp)==1) {
            if (sFR.uchType == (unsigned char)REC_OVERFLOW) {
                continue;
            }
            if (sFR.uchType==(unsigned char)REC_DATA) {
                if (ulid != sFR.ulidShadow)
                    continue;
                do {
                    MyPrintf(L"---------------------------------------------\r\n");
                    MyPrintf(L"%ws (0x%x)\r\n", sFR.rgw83Name, sFR.ulidShadow);

                    MyPrintf(L"  Type=%c Flags=0x%x status=0x%x size=%ld attrib=0x%lx\r\n",
                                sFR.uchType,
                                (unsigned)sFR.uchFlags,
                                sFR.uStatus,
                                sFR.ulFileSize,
                                sFR.dwFileAttrib);
                    MyPrintf(L"  PinFlags=0x%x PinCount=%d RefPri=%d OriginalInode=0x%0x\r\n",
                                 (unsigned)(sFR.uchHintFlags),
                                 (int)(sFR.uchHintPri),
                                 (int)(sFR.uchRefPri),
                                 sFR.ulidShadowOrg);
                    ConvertGmtTimeToString(sFR.ftLastWriteTime, TimeBuf1);
                    ConvertGmtTimeToString(sFR.ftOrgTime, TimeBuf2);
                    MyPrintf(L"  LastWriteTime: %ws Orgtime: %ws\r\n", TimeBuf1, TimeBuf2);
                    MyPrintf(L"  DirInode = 0x%x\r\n", ulidDir);

                    memset(rgwch, 0, sizeof(rgwch));
                    MyPrintf(
                            L"\r\n"
                            L"(F)lags, "
                            L"(S)tatus, "
                            L"si(Z)e , "
                            L"(A)ttrib, "
                            L"e(X)it "
                            L":");
                    if (!fgetws(rgwch, sizeof(rgwch)/sizeof(WCHAR), stdin))
                        break;
                    MyPrintf(L"\r\n");
                        iRes = EditFileFunc(rgwch, &sFR);
                        if (iRes == 0) {
                           break;
                        } else if (iRes == 1) {
                            fseek(fp, ftell(fp) - sizeof(FILEREC), SEEK_SET);
                            fwrite(&sFR, sizeof(FILEREC), 1, fp);
                        }
                } while (1);
            }
        }
        MyPrintf(L"\r\n");
    }
bailout:
    if (fp)
        fclose(fp);
}

LONG
EditFileFunc(
    PWSTR lpBuff,
    FILEREC *sFR)
{
    WCHAR wch;
    ULONG NewFlags;
    ULONG NewStatus;
    ULONG NewSize;
    ULONG NewAttrib;
    LONG cnt;

    // Tristate return:
    // 0 -> exit
    // 1 -> write updated sFR
    // 2 -> don't write updated sFR

    // Chop leading blanks
    if (lpBuff != NULL)
        while (*lpBuff != L'\0' && *lpBuff == L' ')
            lpBuff++;

    cnt = swscanf(lpBuff, L"%c", &wch);

    if (!cnt)
        return 0;

    switch (wch) {
        // Edit flags
        case L'f':
        case L'F':
            cnt = swscanf(lpBuff, L"%c%x", &wch, &NewFlags);
            if (cnt != 2)
                return 2;
            MyPrintf(L"Flags 0x%x -> 0x%x\r\n", (unsigned)sFR->uchFlags, NewFlags);
            sFR->uchFlags = (char)NewFlags;
            break;
        // Edit status
        case L's':
        case L'S':
            cnt = swscanf(lpBuff, L"%c%x", &wch, &NewStatus);
            if (cnt != 2)
                return 2;
            MyPrintf(L"Status 0x%x -> 0x%x\r\n", sFR->uStatus, NewStatus);
            sFR->uStatus = (USHORT)NewStatus;
            break;
        // Edit size
        case L'z':
        case L'Z':
            cnt = swscanf(lpBuff, L"%c%x", &wch, &NewSize);
            if (cnt != 2)
                return 2;
            MyPrintf(L"Size 0x%x -> 0x%x\r\n", sFR->ulFileSize, NewSize);
            sFR->ulFileSize = NewSize;
            break;
        // Edit attrib
        case L'a':
        case L'A':
            cnt = swscanf(lpBuff, L"%c%x", &wch, &NewAttrib);
            if (cnt != 2)
                return 2;
            MyPrintf(L"Attrib 0x%x -> 0x%x\r\n", sFR->dwFileAttrib, NewAttrib);
            sFR->dwFileAttrib = NewAttrib;
            break;
        // Exit
        case L'x':
        case L'X':
            return 0;
    }
    return 1;
}

VOID
EditShare(
    ULONG ulid)
{
    FILE *fp= NULL;
    SHAREHEADER sSH;
    SHAREREC sSR;
    WCHAR TimeBuf1[30];
    WCHAR TimeBuf2[30];
    LONG iRes;
    ULONG ulrec = 0;

    FormNameStringDB(DbDir, ULID_SHARE, Name);

    if (fp = _wfopen(Name, L"rb+")) {
        if (fread(&sSH, sizeof(SHAREHEADER), 1, fp) != 1) {
            MyPrintf(L"Error reading server header \r\n");
            goto bailout;
        }

        for (ulrec = 1; fread(&sSR, sizeof(SHAREREC), 1, fp) == 1; ulrec++) {
            if (sSR.uchType == (UCHAR)REC_DATA) {
                if (ulid != ulrec)
                    continue;
                do {
                    MyPrintf(L"---------------------------------------------\r\n");

                    MyPrintf(L"%ws (0x%x) Root=0x%x\r\n",
                                sSR.rgPath,
                                ulrec,
                                sSR.ulidShadow);
                    MyPrintf(L"  Status=0x%x RootStatus=0x%x "
                             L"HntFlgs=0x%x HntPri=0x%x Attr=0x%x\r\n",
                                sSR.uStatus,
                                (unsigned)(sSR.usRootStatus),
                                (unsigned)(sSR.uchHintFlags),
                                (unsigned)(sSR.uchHintPri),
                                sSR.dwFileAttrib);

                    memset(rgwch, 0, sizeof(rgwch));
                    MyPrintf(
                            L"\r\n"
                            L"(S)tatus, "
                            L"(R)ootStatus, "
                            L"Hnt(F)lgs , "
                            L"Hnt(P)ri, "
                            L"(A)ttr , "
                            L"e(X)it "
                            L":");
                    if (!fgetws(rgwch, sizeof(rgwch)/sizeof(WCHAR), stdin))
                        break;
                    MyPrintf(L"\r\n");
                        iRes = EditShareFunc(rgwch, &sSR);
                        if (iRes == 0) {
                           break;
                        } else if (iRes == 1) {
                            fseek(fp, ftell(fp) - sizeof(SHAREREC), SEEK_SET);
                            fwrite(&sSR, sizeof(SHAREREC), 1, fp);
                        }
                } while (1);
            }
        }
        MyPrintf(L"\r\n");
    }
bailout:
    if (fp)
        fclose(fp);
}

LONG
EditShareFunc(
    PWSTR lpBuff,
    SHAREREC *sSR)
{
    WCHAR wch;
    ULONG NewStatus;
    ULONG NewRootStatus;
    ULONG NewHntFlgs;
    ULONG NewHntPri;
    ULONG NewAttr;
    LONG cnt;

    // Tristate return:
    // 0 -> exit
    // 1 -> write updated sSR
    // 2 -> don't write updated sSR

    // Chop leading blanks
    if (lpBuff != NULL)
        while (*lpBuff != L'\0' && *lpBuff == L' ')
            lpBuff++;

    cnt = swscanf(lpBuff, L"%c", &wch);

    if (!cnt)
        return 0;

    switch (wch) {
        // Edit status
        case L's':
        case L'S':
            cnt = swscanf(lpBuff, L"%c%x", &wch, &NewStatus);
            if (cnt != 2)
                return 2;
            MyPrintf(L"Status 0x%x -> 0x%x\r\n", (ULONG)sSR->uStatus, NewStatus);
            sSR->uStatus = (USHORT)NewStatus;
            break;
        // Edit RootStatus
        case L'r':
        case L'R':
            cnt = swscanf(lpBuff, L"%c%x", &wch, &NewRootStatus);
            if (cnt != 2)
                return 2;
            MyPrintf(L"RootStatus 0x%x -> 0x%x\r\n", (ULONG)sSR->usRootStatus, NewRootStatus);
            sSR->usRootStatus = (USHORT)NewRootStatus;
            break;
        // Edit HntFlgs
        case L'f':
        case L'F':
            cnt = swscanf(lpBuff, L"%c%x", &wch, &NewHntFlgs);
            if (cnt != 2)
                return 2;
            MyPrintf(L"HntFlgs 0x%x -> 0x%x\r\n", (ULONG)sSR->uchHintFlags, NewHntFlgs);
            sSR->uchHintFlags = (char)NewHntFlgs;
            break;
        // Edit HntPri
        case L'p':
        case L'P':
            cnt = swscanf(lpBuff, L"%c%x", &wch, &NewHntPri);
            if (cnt != 2)
                return 2;
            MyPrintf(L"HntPri 0x%x -> 0x%x\r\n", (ULONG)sSR->uchHintPri, NewHntPri);
            sSR->uchHintPri = (char)NewHntPri;
            break;
        // Edit attrib
        case L'a':
        case L'A':
            cnt = swscanf(lpBuff, L"%c%x", &wch, &NewAttr);
            if (cnt != 2)
                return 2;
            MyPrintf(L"Attrib 0x%x -> 0x%x\r\n", sSR->dwFileAttrib, NewAttr);
            sSR->dwFileAttrib = NewAttr;
            break;
        // Exit
        case L'x':
        case L'X':
            return 0;
    }
    return 1;
}

VOID
FormNameStringDB(
   PWSTR lpdbID,
   ULONG ulidFile,
   PWSTR lpName)
{
   PWSTR lp;
   WCHAR wchSubdir;

    // Prepend the local path
   wcscpy(lpName, lpdbID);
   wcscat(lpName, Backslash);

    // Bump the pointer appropriately
   lp = lpName + wcslen(lpName);

   wchSubdir = CSCDbSubdirSecondChar(ulidFile);

   // sprinkle the user files in one of the subdirectories
   if (wchSubdir) {
       // now append the subdirectory
       *lp++ = CSCDbSubdirFirstChar();
       *lp++ = wchSubdir;
       *lp++ = L'\\';
   }


   HexToA(ulidFile, lp, 8);

   lp += 8;
    *lp = 0;
}

LONG
HexToA(
   ULONG ulHex,
   PWSTR lpName,
   LONG count)
{
   int i;
   PWSTR lp = lpName + count - 1;
   WCHAR wch;

   for (i = 0; i < count; ++i) {
       wch = (WCHAR)(ulHex & 0xf) + L'0';
       if (wch > '9')
           wch += 7;    // A becomes '0' + A + 7 which is 'A'
        *lp = wch;
        --lp;
       ulHex >>= 4;
    }
    *(lpName+count) = '\0';
   return 0;
}

BOOL
FindAncestor(
    ULONG ulid,
    ULONG *lpulidDir)
{
    ULONG ulRec = RecFromInode(ulid);
    FILE *fp= (FILE *)NULL;
    QHEADER sQH;
    QREC sQR;
    BOOL fRet = FALSE;

    *lpulidDir = 0;

    FormNameStringDB(DbDir, ULID_PQ, Name);
    if (fp = _wfopen(Name, L"rb")) {
        if (fread(&sQH, sizeof(QHEADER), 1, fp) != 1) {
            MyPrintf(L"Error reading PQ header \r\n");
            goto bailout;
         }

         fseek(fp, ((ulRec-1) * sizeof(QREC))+sizeof(QHEADER), SEEK_SET);

         if (fread(&sQR, sizeof(QREC), 1, fp)!=1)
            goto bailout;
         *lpulidDir = sQR.ulidDir;
         fRet = TRUE;
     }
 bailout:
    if (fp)
        fclose(fp);
    return fRet;
}

LONG
RoughCompareWideStringWithAnsiString(
    PWSTR   lpSrcString,
    USHORT  *lpwDstString,
    LONG     cntMax)
{
    WCHAR wch;
    USHORT  uch;
    LONG i;

    for (i = 0; i < cntMax; ++i) {
        wch = *lpSrcString++;
        uch = *lpwDstString++;
        wch = _wtoupper(wch);
        uch = _wtoupper(uch);

        if (!wch) {
            return 0;
        }

        if (wch != uch) {
            return (uch - wch);
        }
    }
    if (i == cntMax) {
        return 0;
    }

    return 1;   // this should never occur
}

/*++

    DBCSC_BitmapIsMarked()

Routine Description:


Arguments:


Returns:

    -1 if lpbitmap is NULL or bitoffset is larger than the bitmap
    TRUE if the bit is marked
    FALSE if the bit is unmarked

Notes:

--*/
int
DBCSC_BitmapIsMarked(
    LPCSC_BITMAP_DB lpbitmap,
    DWORD bitoffset)
{
    DWORD DWORDnum;
    DWORD bitpos;

    if (lpbitmap == NULL)
        return -1;
    if (bitoffset >= lpbitmap->bitmapsize)
        return -1;

    DWORDnum = bitoffset/(8*sizeof(DWORD));
    bitpos = 1 << bitoffset%(8*sizeof(DWORD));

    if (lpbitmap->bitmap[DWORDnum] & bitpos)
        return TRUE;

    return FALSE;
}

/*++

    DBCSC_BitmapAppendStreamName()

Routine Description:

    Appends the CSC stream name to the existing path/file name fname.

Arguments:

    fname is the sting buffer containing the path/file.
    bufsize is the buffer size.

Returns:

    TRUE if append successful.
    FALSE if buffer is too small or other errors.

Notes:

    Unicode strings only.

--*/
int
DBCSC_BitmapAppendStreamName(
    PWCHAR fname,
    DWORD bufsize)
{
    if ((wcslen(fname) + wcslen(CscBmpAltStrmName) + 1) > bufsize)
        return FALSE;
    wcscat(fname, CscBmpAltStrmName);
    return TRUE;
}

/*++

    DBCSC_BitmapRead()

Routine Description:

    Reads the on-disk bitmap file, and if it exists, is not in use and valid,
    store it in *lplpbitmap. If *lplpbitmap is NULL allocate a new
    bitmap data structure. Otherwise, if *lplpbitmap is not NULL, the
    existing bitmap will be deleted and assigned the on-disk bitmap
    file.

Arguments:

    filename is the file that contains the bitmap. If read from a
    stream, append the stream name before passing the filename in. The
    filename is used as is and no checking of validity of the name is
    performed. For default stream name, append the global LPSTR
    CscBmpAltStrmName.

Returns:

    1 if read successful
    0 if lplpbitmap is NULL
    -1 if error in disk operation (open/read), memory allocating error,
          or invalid bitmap file format.
    -2 if bitmap not exist

Notes:

    CODE.IMPROVEMENT design a better error message propagation mechanism.
    Bitmap open for exclusive access.

--*/
int
DBCSC_BitmapRead(
    LPCSC_BITMAP_DB *lplpbitmap,
    LPCTSTR filename)
{
    CscBmpFileHdr hdr;
    HANDLE bitmapFile;
    DWORD bytesRead;
    DWORD bitmapByteSize;
    DWORD * bitmapBuf = NULL;
    DWORD errCode;
    int ret = 1;

    if (fSwDebug)
        MyPrintf(L"BitmapRead(%ws)\r\n", filename);

    if (lplpbitmap == NULL)
        return 0;

    bitmapFile = CreateFile(
                    filename,
                    GENERIC_READ,
                    0, // No sharing; exclusive
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
    if (bitmapFile == INVALID_HANDLE_VALUE) {
        errCode = GetLastError();
        if (fSwDebug)
            MyPrintf(L"BitmapRead!Createfile error %d\r\n", errCode);
        if (errCode == ERROR_FILE_NOT_FOUND) {
            // File does not exist
            return -2;
        }
        return -1;
    }

    if (!ReadFile(
            bitmapFile,
            &hdr, 
            sizeof(CscBmpFileHdr),
            &bytesRead,
            NULL)
    ) {
        if (fSwDebug)
            MyPrintf(L"BitmapRead!ReadFile of header error %d\r\n", GetLastError());
        ret = -1;
        goto CLOSEFILE;
    }

    MyPrintf(
        L"---Header---\r\n"
        L"MagicNum: 0x%x\r\n"
        L"inuse: 0x%x\r\n"
        L"valid: 0x%x\r\n"
        L"sizeinbits:0x%x\r\n"
        L"numDWORDS:0x%x\r\n",
            hdr.magicnum,
            hdr.inuse,
            hdr.valid,
            hdr.sizeinbits,
            hdr.numDWORDs);

    if (bytesRead != sizeof(CscBmpFileHdr)) {
        if (fSwDebug)
            MyPrintf(L"BitmapRead!ReadFile bytesRead != sizeof(CscBmpFileHdr).\r\n");
        ret = -1;
        goto CLOSEFILE;
    }
    if (hdr.magicnum != MAGICNUM) {
        if (fSwDebug)
            MyPrintf(L"BitmapRead!ReadFile hdr.magicnum != MAGICNUM.\r\n");
        ret = -1;
        goto CLOSEFILE;
    }
    if (!hdr.valid) {
        if (fSwDebug)
            MyPrintf(L"BitmapRead!ReadFile !hdr.valid.\r\n");
        ret = -1;
        goto CLOSEFILE;
    }
    if (hdr.inuse) {
        if (fSwDebug)
            MyPrintf(L"BitmapRead!ReadFile hdr.inuse.\r\n");
        ret = -1;
        goto CLOSEFILE;
    }

    if (hdr.sizeinbits > 0) {
        bitmapByteSize = hdr.numDWORDs*sizeof(DWORD);
        bitmapBuf = (DWORD *)malloc(bitmapByteSize);
        if (!bitmapBuf) {
            if (fSwDebug)
                MyPrintf(L"BitmapRead!malloc failed\r\n");
            ret = -1;
            goto CLOSEFILE;
        }

        if (!ReadFile(
                bitmapFile,
                bitmapBuf,
                bitmapByteSize,
                &bytesRead,
                NULL)
        ) {
            if (fSwDebug)
                MyPrintf(L"BitmapRead!ReadFile of bitmap error %d\r\n", GetLastError());
            ret = -1;
            goto CLOSEFILE;
        }

        if (bytesRead != bitmapByteSize) {
            if (fSwDebug)
                MyPrintf(
                    L"BitmapRead!ReadFile wrong size (%d vs %d).\r\n",
                        bytesRead,
                        bitmapByteSize);
            ret = -1;
            goto CLOSEFILE;
        }
    }

    if (*lplpbitmap) {
        // bitmap exist, dump old and create new
        if ((*lplpbitmap)->bitmap)
            free((*lplpbitmap)->bitmap);
        (*lplpbitmap)->bitmap = bitmapBuf;
        (*lplpbitmap)->numDWORD = hdr.numDWORDs;
        (*lplpbitmap)->bitmapsize = hdr.sizeinbits;
    } else {
        // bitmap not exist, create brand new
        *lplpbitmap = (LPCSC_BITMAP_DB)malloc(sizeof(CSC_BITMAP_DB));
        if (!(*lplpbitmap)) {
            // Error in memory allocation
            ret = -1;
            goto CLOSEFILE;
        }
        (*lplpbitmap)->bitmap = bitmapBuf;
        (*lplpbitmap)->numDWORD = hdr.numDWORDs;
        (*lplpbitmap)->bitmapsize = hdr.sizeinbits;
    }

CLOSEFILE:
    CloseHandle(bitmapFile);
    if(ret = -1 && bitmapBuf != NULL){
        free(bitmapBuf);
    }


    return ret;
}

/*++

    DBCSC_BitmapOutput()

Routine Description:

    Outputs the passed in bitmap to the ouput file stream outStrm

Arguments:


Returns:


Notes:


--*/
void
DBCSC_BitmapOutput(
    FILE * outStrm,
    LPCSC_BITMAP_DB lpbitmap)
{
    DWORD i;

    if (lpbitmap == NULL) {
        MyPrintf(L"lpbitmap is NULL\r\n");
        return;
    }

    MyPrintf(L"lpbitmap 0x%08x, bitmapsize 0x%x numDWORD 0x%x\r\n",
                (ULONG_PTR)lpbitmap, lpbitmap->bitmapsize, lpbitmap->numDWORD);

    MyPrintf(L"bitmap  |0/5        |1/6        |2/7        |3/8        |4/9\r\n");
    MyPrintf(L"number  |01234|56789|01234|56789|01234|56789|01234|56789|01234|56789");
    for (i = 0; i < lpbitmap->bitmapsize; i++) {
        if ((i % 50) == 0)
            MyPrintf(L"\r\n%08d", i);
        if ((i % 5) == 0)
            MyPrintf(L"|");
        MyPrintf(L"%1d", DBCSC_BitmapIsMarked(lpbitmap, i));
    }
    MyPrintf(L"\r\n");
}

DWORD
DumpBitMap(
    LPWSTR lpszTempName)
{
    WCHAR  lpszBitMapName[MAX_PATH];
    LPCSC_BITMAP_DB lpbitmap = NULL;
    DWORD dwError = ERROR_SUCCESS;

    wcscpy(lpszBitMapName,lpszTempName);
    DBCSC_BitmapAppendStreamName(lpszBitMapName, MAX_PATH);
    // read bitmap
    switch(DBCSC_BitmapRead(&lpbitmap, lpszBitMapName)) {
        case 1:
            // Print the bitmap associated if any
            MyPrintf(L"\r\n");
            DBCSC_BitmapOutput(stdout, lpbitmap);
            MyPrintf(L"\r\n");
            // if bitmap opened delete bitmap
            // DBCSC_BitmapDelete(&lpbitmap);
            break;
        case -1:
            MyPrintf(L"Error reading bitmap file %ws or bitmap invalid\r\n", lpszBitMapName);
            dwError = ERROR_FILE_NOT_FOUND;
            break;
        case -2:
            MyPrintf(L"No CSCBitmap\n");
            dwError = ERROR_FILE_NOT_FOUND;
            break;
        case 0:
        default:
            MyPrintf(L"Something strange going on with bitmap printing...\r\n");
            dwError = ERROR_FILE_NOT_FOUND;
            break;
    }
    return dwError;
}

#endif // CSCUTIL_INTERNAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\util\cscutil\sources.inc ===
SOURCES=    \
            cscutil.c \
            cscutil.rc \
            messages.mc \
            misc.c \
            getinfo.c \
            db.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\util\cscutil\cscutil.c ===
#define UNICODE
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winioctl.h>
#include <shdcom.h>
#include <shellapi.h>
#include <smbdebug.h>
#include <time.h>

#include "struct.h"
#include "messages.h"
#include "cscapi.h"

CHAR *ProgName = "cscutil";

#define CSC_MERGE_KEEP_LOCAL   1
#define CSC_MERGE_KEEP_NETWORK 2
#define CSC_MERGE_KEEP_BOTH    3

//
// Arguments (ie '/arg:')
//
MAKEARG(Pin);
MAKEARG(UnPin);
MAKEARG(Delete);
MAKEARG(DeleteShadow);
MAKEARG(GetShadow);
MAKEARG(GetShadowInfo);
MAKEARG(ShareId);
MAKEARG(Fill);
MAKEARG(Db);
MAKEARG(SetShareStatus);
MAKEARG(Purge);
MAKEARG(IsServerOffline);
MAKEARG(EnumForStats);
MAKEARG(SetSpace);
MAKEARG(Merge);
MAKEARG(QueryFile);
MAKEARG(QueryFileEx);
MAKEARG(QueryShare);
MAKEARG(Check);
MAKEARG(ExclusionList);
MAKEARG(BWConservationList);
MAKEARG(Disconnect);
MAKEARG(Reconnect);
MAKEARG(Enum);
MAKEARG(Move);
MAKEARG(Bitcopy);
MAKEARG(RandW);
MAKEARG(Offset);
MAKEARG(MoveShare);

//
// Switches (ie '/arg')
//
SWITCH(Info);
SWITCH(Fcblist);
SWITCH(DBStatus);
SWITCH(PQEnum);
SWITCH(User);
SWITCH(System);
SWITCH(Inherit);
SWITCH(Recurse);
SWITCH(Abort);
SWITCH(Skip);
SWITCH(Ask);
SWITCH(Eof);
SWITCH(Retry);
SWITCH(Touch);
SWITCH(Enable);
SWITCH(Disable);
SWITCH(Ioctl);
SWITCH(Flags);
SWITCH(GetSpace);
SWITCH(Encrypt);
SWITCH(Decrypt);
SWITCH(Db);
SWITCH(Set);
SWITCH(Clear);
SWITCH(Purge);
SWITCH(Detector);
SWITCH(Switches);

SWITCH(Debug);
SWITCH(Help);
SWITCH(HelpHelp);
SWITCH(Enum);
SWITCH(Resid);
SWITCH(Full);

//
// The macro can not make these
//

WCHAR SwQ[] = L"/?";
BOOLEAN fSwQ;
WCHAR SwQQ[] = L"/??";
BOOLEAN fSwQQ;

//
// Globals
//
LPWSTR pwszDisconnectArg = NULL;
LPWSTR pwszExclusionListArg = NULL;
LPWSTR pwszBWConservationListArg = NULL;
LPWSTR pwszSetShareStatusArg = NULL;
LPWSTR pwszIsServerOfflineArg = NULL;
LPWSTR pwszPurgeArg = NULL;
LPWSTR pwszPinUnPinArg = NULL;
LPWSTR pwszDeleteArg = NULL;
LPWSTR pwszDeleteShadowArg = NULL;
LPWSTR pwszGetShadowArg = NULL;
LPWSTR pwszGetShadowInfoArg = NULL;
LPWSTR pwszShareIdArg = NULL;
LPWSTR pwszReconnectArg = NULL;
LPWSTR pwszQueryFileArg = NULL;
LPWSTR pwszQueryFileExArg = NULL;
LPWSTR pwszDbArg = NULL;
LPWSTR pwszSetSpaceArg = NULL;
LPWSTR pwszQueryShareArg = NULL;
LPWSTR pwszMoveArg = NULL;
LPWSTR pwszMergeArg = NULL;
LPWSTR pwszFillArg = NULL;
LPWSTR pwszEnumArg = NULL;
LPWSTR pwszRandWArg = NULL;
LPWSTR pwszBitcopyArg = NULL;
LPWSTR pwszOffsetArg = NULL;
LPWSTR pwszEnumForStatsArg = NULL;
LPWSTR pwszCheckArg = NULL;

char statusName[4][32] = {
   "Local Path",
   "Offline Share",
   "Online Share",
   "No CSC"
};

DWORD
Usage(
    BOOLEAN fHelpHelp);

BOOLEAN
CmdProcessArg(
    LPWSTR Arg);

DWORD
CmdInfo(
    ULONG Cmd);

DWORD
CmdDBStatus(
    VOID);

DWORD
CmdPurge(
    PWSTR PurgeArg);

DWORD
CmdDetector(
    VOID);

DWORD
CmdPQEnum(
    VOID);

DWORD
CmdGetSpace(
    VOID);

DWORD
CmdSwitches(
    VOID);

DWORD
CmdDisconnect(
    PWSTR DisconnectArg);

DWORD
CmdExclusionList(
    PWSTR ExclusionListArg);

DWORD
CmdBWConservationList(
    PWSTR BWConservationListArg);

DWORD
CmdSetShareStatus(
    PWSTR SetShareStatusArg);

DWORD
CmdIsServerOffline(
    PWSTR IsServerOfflineArg);

DWORD
CmdReconnect(
    PWSTR ReconnectArg);

DWORD
CmdQueryFile(
    PWSTR QueryFileArg);

DWORD
CmdQueryFileEx(
    PWSTR QueryFileExArg);

DWORD
CmdDb(
    PWSTR DbArg);

DWORD
CmdSetSpace(
    PWSTR SetSpaceArg);

DWORD
CmdQueryShare(
    PWSTR QueryShareArg);

DWORD
CmdMove(
    PWSTR MoveArg);

DWORD
CmdMerge(
    PWSTR MergeArg);

DWORD
CmdEncryptDecrypt(
    BOOL fEncrypt);

DWORD
CmdFill(
    PWSTR FillArg);

DWORD
CmdCheck(
    PWSTR CheckArg);

DWORD
CmdEnum(
    PWSTR CmdEnumArg);

DWORD
CmdRandW(
    PWSTR CmdRandWArg);

DWORD
CmdBitcopy(
    PWSTR CmdBitcopyArg);

DWORD
CmdEnumForStats(
    PWSTR EnumForStatsArg);

DWORD
CmdDelete(
    PWSTR DeleteArg);

DWORD
CmdGetShadow(
    PWSTR GetShadowArg);

DWORD
CmdGetShadowInfo(
    PWSTR GetShadowInfoArg);

DWORD
CmdShareId(
    PWSTR ShareIdArg);

DWORD
CmdDeleteShadow(
    PWSTR DeleteArg);

DWORD
CmdPinUnPin(
    BOOL fPin,
    PWSTR PinArg);

DWORD
CmdMoveShare(
	PWSTR source,
	PWSTR dest);

SHARESTATUS 
GetCSCStatus (
	const WCHAR * pwszPath);

BOOL 
GetShareStatus (
	const WCHAR * pwszShare, 
	DWORD * pdwStatus,
    DWORD * pdwPinCount, 
	DWORD * pdwHints);

void 
MoveDirInCSC (
	const WCHAR * pwszSource,
	const WCHAR * pwszDest,
    const WCHAR * pwszSkipSubdir,
    SHARESTATUS   StatusFrom, SHARESTATUS   StatusTo,
    BOOL  bAllowRdrTimeoutForDel,
    BOOL  bAllowRdrTimeoutForRen);

DWORD 
DoCSCRename (
	const WCHAR * pwszSource, 
	const WCHAR * pwszDest,
    BOOL bOverwrite, 
	BOOL bAllowRdrTimeout);

DWORD 
DeleteCSCFileTree (
	const WCHAR * pwszSource, 
	const WCHAR * pwszSkipSubdir,
    BOOL bAllowRdrTimeout);

DWORD 
DeleteCSCFile (
	const WCHAR * pwszPath, 
	BOOL bAllowRdrTimeout);

DWORD 
DeleteCSCShareIfEmpty (
	LPCTSTR pwszFileName, 
	SHARESTATUS shStatus);

DWORD 
MergePinInfo (
	LPCTSTR pwszSource, 
	LPCTSTR pwszDest,
    SHARESTATUS StatusFrom, 
	SHARESTATUS StatusTo);

DWORD 
PinIfNecessary (
	const WCHAR * pwszPath, 
	SHARESTATUS shStatus);

DWORD
CscMergeFillAsk(
    LPCWSTR lpszFullPath);

DWORD
MyCscMergeProcW(
     LPCWSTR         lpszFullPath,
     DWORD           dwStatus,
     DWORD           dwHintFlags,
     DWORD           dwPinCount,
     WIN32_FIND_DATAW *lpFind32,
     DWORD           dwReason,
     DWORD           dwParam1,
     DWORD           dwParam2,
     DWORD_PTR       dwContext);

DWORD
MyCscFillProcW(
     LPCWSTR         lpszFullPath,
     DWORD           dwStatus,
     DWORD           dwHintFlags,
     DWORD           dwPinCount,
     WIN32_FIND_DATAW *lpFind32,
     DWORD           dwReason,
     DWORD           dwParam1,
     DWORD           dwParam2,
     DWORD_PTR       dwContext);

DWORD
MyEncryptDecryptProcW(
     LPCWSTR         lpszFullPath,
     DWORD           dwStatus,
     DWORD           dwHintFlags,
     DWORD           dwPinCount,
     WIN32_FIND_DATAW *lpFind32,
     DWORD           dwReason,
     DWORD           dwParam1,
     DWORD           dwParam2,
     DWORD_PTR       dwContext);

DWORD
MyEnumForStatsProcW(
     LPCWSTR         lpszFullPath,
     DWORD           dwStatus,
     DWORD           dwHintFlags,
     DWORD           dwPinCount,
     WIN32_FIND_DATAW *lpFind32,
     DWORD           dwReason,
     DWORD           dwParam1,
     DWORD           dwParam2,
     DWORD_PTR       dwContext);

DWORD
FileStatusToEnglish(
    DWORD Status,
    LPWSTR OutputBuffer);

DWORD
HintsToEnglish(
    DWORD Hint,
    LPWSTR OutputBuffer);

DWORD
ShareStatusToEnglish(
    DWORD Status,
    LPWSTR OutputBuffer);

BOOLEAN
LooksToBeAShare(LPWSTR Name);

LONG
CountOffsetArgs(
    PWSTR OffsetArg,
    ULONG OffsetArray[]);

DWORD
DumpBitMap(
    LPWSTR lpszTempName);

VOID
ErrorMessage(
    IN HRESULT hr,
    ...);

WCHAR NameBuf[MAX_PATH + 25];

WCHAR vtzDefaultExclusionList[] = L" *.SLM *.MDB *.LDB *.MDW *.MDE *.PST *.DB?"; // from ui.c

//
// These functions were added for Windows XP, and so we do a loadlibrary on them, so that
// this utility will work on both Windows 2000 and Windows XP
//
typedef BOOL (*CSCQUERYFILESTATUSEXW)(LPCWSTR, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD);
typedef BOOL (*CSCQUERYSHARESTATUSW)(LPCWSTR, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD);
typedef BOOL (*CSCPURGEUNPINNEDFILES)(ULONG, PULONG, PULONG);
typedef BOOL (*CSCENCRYPTDECRYPTDATABASE)(BOOL, LPCSCPROCW, DWORD_PTR);
typedef BOOL (*CSCSHAREIDTOSHARENAME)(ULONG, PBYTE, PULONG);

_cdecl
main(int argc, char *argv[])
{
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR CommandLine;
    LPWSTR *argvw;
    int argx;
    int argcw;

    // fSwDebug = TRUE;

    if (!CSCIsCSCEnabled()) {
        Usage(FALSE);
        ErrorMessage(MSG_CSC_DISABLED);
        return 1;
    }
    
    //
    // Get the command line in Unicode
    //

    CommandLine = GetCommandLine();

    argvw = CommandLineToArgvW(CommandLine, &argcw);

    if ( argvw == NULL ) {
        MyPrintf(L"cscutil:Can't convert command line to Unicode: %d\r\n", GetLastError() );
        return 1;
    }

    //
    // Get the arguments
    //
    if (argcw <= 1) {
        Usage(FALSE);
        dwErr = ERROR_SUCCESS;
        goto Cleanup;
    }

    //
    // Process arguments
    //

    for (argx = 1; argx < argcw; argx++) {
        if (CmdProcessArg(argvw[argx]) != TRUE) {
            dwErr = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
		if (fArgMoveShare) {
			break;
		}
    }

    if (fSwDebug == TRUE) {
        MyPrintf(L"Do special debug stuff here\r\n");
    }

    //
    // Do the work
    //
    if (fSwHelp == TRUE || fSwQ == TRUE) {
        dwErr = Usage(FALSE);
    } else if (fSwHelpHelp == TRUE || fSwQQ == TRUE) {
        dwErr = Usage(TRUE);
    } else if (fSwInfo == TRUE) {
        dwErr = CmdInfo(DEBUG_INFO_SERVERLIST);
    } else if (fSwFcblist == TRUE) {
        dwErr = CmdInfo(DEBUG_INFO_CSCFCBSLIST);
    } else if (fSwGetSpace == TRUE) {
        dwErr = CmdGetSpace();
    } else if (fSwDBStatus == TRUE) {
        dwErr = CmdDBStatus();
    } else if (fArgPurge == TRUE) {
        dwErr = CmdPurge(pwszPurgeArg);
    } else if (fSwPurge == TRUE) {
        dwErr = CmdPurge(NULL);
    } else if (fSwDetector == TRUE) {
        dwErr = CmdDetector();
    } else if (fSwPQEnum == TRUE) {
        dwErr = CmdPQEnum();
    } else if (fSwFlags == TRUE) {
        ErrorMessage(MSG_FLAGS);
        dwErr = ERROR_SUCCESS;
    } else if (fSwEnable == TRUE) {
        dwErr = (CSCDoEnableDisable(TRUE) == TRUE) ? ERROR_SUCCESS : GetLastError();
    } else if (fSwDisable == TRUE) {
        dwErr = (CSCDoEnableDisable(FALSE) == TRUE) ? ERROR_SUCCESS : GetLastError();
    } else if (fSwSwitches == TRUE) {
        dwErr = CmdSwitches();
    } else if (fArgDisconnect == TRUE) {
        dwErr = CmdDisconnect(pwszDisconnectArg);
    } else if (fArgExclusionList == TRUE) {
        dwErr = CmdExclusionList(pwszExclusionListArg);
    } else if (fArgBWConservationList == TRUE) {
        dwErr = CmdBWConservationList(pwszBWConservationListArg);
    } else if (fArgSetShareStatus == TRUE) {
        dwErr = CmdSetShareStatus(pwszSetShareStatusArg);
    } else if (fArgIsServerOffline == TRUE) {
        dwErr = CmdIsServerOffline(pwszIsServerOfflineArg);
    } else if (fArgReconnect == TRUE) {
        dwErr = CmdReconnect(pwszReconnectArg);
    } else if (fArgQueryFile == TRUE) {
        dwErr = CmdQueryFile(pwszQueryFileArg);
    } else if (fArgQueryFileEx == TRUE) {
        dwErr = CmdQueryFileEx(pwszQueryFileExArg);
#if defined(CSCUTIL_INTERNAL)
    } else if (fArgDb == TRUE) {
        dwErr = CmdDb(pwszDbArg);
    } else if (fSwDb == TRUE) {
        dwErr = CmdDb(NULL);
    } else if (fArgBitcopy == TRUE) {
        dwErr = CmdBitcopy(pwszBitcopyArg);
#endif // CSCUTIL_INTERNAL
    } else if (fArgSetSpace == TRUE) {
        dwErr = CmdSetSpace(pwszSetSpaceArg);
    } else if (fArgQueryShare == TRUE) {
        dwErr = CmdQueryShare(pwszQueryShareArg);
    } else if (fArgMerge == TRUE) {
        dwErr = CmdMerge(pwszMergeArg);
    } else if (fArgMove == TRUE) {
        dwErr = CmdMove(pwszMoveArg);
    } else if (fSwEncrypt == TRUE) {
        dwErr = CmdEncryptDecrypt(TRUE);
    } else if (fSwDecrypt == TRUE) {
        dwErr = CmdEncryptDecrypt(FALSE);
    } else if (fArgFill == TRUE) {
        dwErr = CmdFill(pwszFillArg);
    } else if (fArgCheck == TRUE) {
        dwErr = CmdCheck(pwszCheckArg);
    } else if (fArgEnum == TRUE) {
        dwErr = CmdEnum(pwszEnumArg);
    } else if (fSwEnum == TRUE) {
        dwErr = CmdEnum(NULL);
    } else if (fArgRandW == TRUE) {
        dwErr = CmdRandW(pwszRandWArg);
    } else if (fArgEnumForStats == TRUE) {
        dwErr = CmdEnumForStats(pwszEnumForStatsArg);
    } else if (fArgGetShadow == TRUE) {
        dwErr = CmdGetShadow(pwszGetShadowArg);
    } else if (fArgGetShadowInfo == TRUE) {
        dwErr = CmdGetShadowInfo(pwszGetShadowInfoArg);
    } else if (fArgShareId == TRUE) {
        dwErr = CmdShareId(pwszShareIdArg);
    } else if (fArgDelete == TRUE) {
        dwErr = CmdDelete(pwszDeleteArg);
    } else if (fArgDeleteShadow == TRUE) {
        dwErr = CmdDeleteShadow(pwszDeleteShadowArg);
    } else if (fArgPin == TRUE || fArgUnPin == TRUE) {
        dwErr = CmdPinUnPin(fArgPin, pwszPinUnPinArg);
	} else if (fArgMoveShare == TRUE) {
		if (argcw == 4) {
			dwErr = CmdMoveShare(argvw[2], argvw[3]);
		}
        else {
            dwErr = Usage(FALSE);
            dwErr = ERROR_INVALID_PARAMETER;
        }
	} else {
        dwErr = Usage(FALSE);
    }

Cleanup:

    if (dwErr == ERROR_SUCCESS) {
        ErrorMessage(MSG_SUCCESSFUL);
    } else {
        LPWSTR MessageBuffer;
        DWORD dwBufferLength;

        dwBufferLength = FormatMessage(
                            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL,
                            dwErr,
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                            (LPWSTR) &MessageBuffer,
                            0,
                            NULL);

        ErrorMessage(MSG_ERROR, dwErr);
        if (dwBufferLength > 0) {
            MyPrintf(L"%ws\r\n", MessageBuffer);
            LocalFree(MessageBuffer);
        }
    }

    return dwErr;
}

BOOLEAN
CmdProcessArg(LPWSTR Arg)
{
    LONG ArgLen;
    BOOLEAN dwErr = FALSE;
    BOOLEAN FoundAnArg = FALSE;

    if (fSwDebug == TRUE)
        MyPrintf(L"ProcessArg(%ws)\r\n", Arg);

    if ( Arg != NULL && wcslen(Arg) > 1) {

        dwErr = TRUE;
        ArgLen = wcslen(Arg);

        //
        // Commands with args
        //
        if (_wcsnicmp(Arg, ArgDisconnect, ArgLenDisconnect) == 0) {
            FoundAnArg = fArgDisconnect = TRUE;
            if (ArgLen > ArgLenDisconnect)
                pwszDisconnectArg = &Arg[ArgLenDisconnect];
        } else if (_wcsnicmp(Arg, ArgEnum, ArgLenEnum) == 0) {
            FoundAnArg = fArgEnum = TRUE;
            if (ArgLen > ArgLenEnum)
                pwszEnumArg = &Arg[ArgLenEnum];
		} else if (_wcsnicmp(Arg, ArgMoveShare, ArgLenMoveShare) == 0) {
			FoundAnArg = fArgMoveShare = TRUE;
#if defined(CSCUTIL_INTERNAL)
        } else if (_wcsnicmp(Arg, ArgReconnect, ArgLenReconnect) == 0) {
            FoundAnArg = fArgReconnect = TRUE;
            if (ArgLen > ArgLenReconnect)
                pwszReconnectArg = &Arg[ArgLenReconnect];
        } else if (_wcsnicmp(Arg, ArgPin, ArgLenPin) == 0) {
            FoundAnArg = fArgPin = TRUE;
            if (ArgLen > ArgLenPin)
                pwszPinUnPinArg = &Arg[ArgLenPin];
        } else if (_wcsnicmp(Arg, ArgUnPin, ArgLenUnPin) == 0) {
            FoundAnArg = fArgUnPin = TRUE;
            if (ArgLen > ArgLenUnPin)
                pwszPinUnPinArg = &Arg[ArgLenUnPin];
        } else if (_wcsnicmp(Arg, ArgDelete, ArgLenDelete) == 0) {
            FoundAnArg = fArgDelete = TRUE;
            if (ArgLen > ArgLenDelete)
                pwszDeleteArg = &Arg[ArgLenDelete];
        } else if (_wcsnicmp(Arg, ArgExclusionList, ArgLenExclusionList) == 0) {
            FoundAnArg = fArgExclusionList = TRUE;
            if (ArgLen > ArgLenExclusionList)
                pwszExclusionListArg = &Arg[ArgLenExclusionList];
        } else if (_wcsnicmp(Arg, ArgBWConservationList, ArgLenBWConservationList) == 0) {
            FoundAnArg = fArgBWConservationList = TRUE;
            if (ArgLen > ArgLenBWConservationList)
                pwszBWConservationListArg = &Arg[ArgLenBWConservationList];
        } else if (_wcsnicmp(Arg, ArgSetShareStatus, ArgLenSetShareStatus) == 0) {
            FoundAnArg = fArgSetShareStatus = TRUE;
            if (ArgLen > ArgLenSetShareStatus)
                pwszSetShareStatusArg = &Arg[ArgLenSetShareStatus];
        } else if (_wcsnicmp(Arg, ArgIsServerOffline, ArgLenIsServerOffline) == 0) {
            FoundAnArg = fArgIsServerOffline = TRUE;
            if (ArgLen > ArgLenIsServerOffline)
                pwszIsServerOfflineArg = &Arg[ArgLenIsServerOffline];
        } else if (_wcsnicmp(Arg, ArgPurge, ArgLenPurge) == 0) {
            FoundAnArg = fArgPurge = TRUE;
            if (ArgLen > ArgLenPurge)
                pwszPurgeArg = &Arg[ArgLenPurge];
        } else if (_wcsnicmp(Arg, ArgRandW, ArgLenRandW) == 0) {
            FoundAnArg = fArgRandW = TRUE;
            if (ArgLen > ArgLenRandW)
                pwszRandWArg = &Arg[ArgLenRandW];
        } else if (_wcsnicmp(Arg, ArgBitcopy, ArgLenBitcopy) == 0) {
            FoundAnArg = fArgBitcopy = TRUE;
            if (ArgLen > ArgLenBitcopy)
                pwszBitcopyArg = &Arg[ArgLenBitcopy];
        } else if (_wcsnicmp(Arg, ArgOffset, ArgLenOffset) == 0) {
            FoundAnArg = fArgOffset = TRUE;
            if (ArgLen > ArgLenOffset)
                pwszOffsetArg = &Arg[ArgLenOffset];
        } else if (_wcsnicmp(Arg, ArgDeleteShadow, ArgLenDeleteShadow) == 0) {
            FoundAnArg = fArgDeleteShadow = TRUE;
            if (ArgLen > ArgLenDeleteShadow)
                pwszDeleteShadowArg = &Arg[ArgLenDeleteShadow];
        } else if (_wcsnicmp(Arg, ArgQueryFile, ArgLenQueryFile) == 0) {
            FoundAnArg = fArgQueryFile = TRUE;
            if (ArgLen > ArgLenQueryFile)
                pwszQueryFileArg = &Arg[ArgLenQueryFile];
        } else if (_wcsnicmp(Arg, ArgQueryFileEx, ArgLenQueryFileEx) == 0) {
            FoundAnArg = fArgQueryFileEx = TRUE;
            if (ArgLen > ArgLenQueryFileEx)
                pwszQueryFileExArg = &Arg[ArgLenQueryFileEx];
        } else if (_wcsnicmp(Arg, ArgDb, ArgLenDb) == 0) {
            FoundAnArg = fArgDb = TRUE;
            if (ArgLen > ArgLenDb)
                pwszDbArg = &Arg[ArgLenDb];
        } else if (_wcsnicmp(Arg, ArgSetSpace, ArgLenSetSpace) == 0) {
            FoundAnArg = fArgSetSpace = TRUE;
            if (ArgLen > ArgLenSetSpace)
                pwszSetSpaceArg = &Arg[ArgLenSetSpace];
        } else if (_wcsnicmp(Arg, ArgGetShadow, ArgLenGetShadow) == 0) {
            FoundAnArg = fArgGetShadow = TRUE;
            if (ArgLen > ArgLenGetShadow)
                pwszGetShadowArg = &Arg[ArgLenGetShadow];
        } else if (_wcsnicmp(Arg, ArgGetShadowInfo, ArgLenGetShadowInfo) == 0) {
            FoundAnArg = fArgGetShadowInfo = TRUE;
            if (ArgLen > ArgLenGetShadowInfo)
                pwszGetShadowInfoArg = &Arg[ArgLenGetShadowInfo];
        } else if (_wcsnicmp(Arg, ArgShareId, ArgLenShareId) == 0) {
            FoundAnArg = fArgShareId = TRUE;
            if (ArgLen > ArgLenShareId)
                pwszShareIdArg = &Arg[ArgLenShareId];
        } else if (_wcsnicmp(Arg, ArgQueryShare, ArgLenQueryShare) == 0) {
            FoundAnArg = fArgQueryShare = TRUE;
            if (ArgLen > ArgLenQueryShare)
                pwszQueryShareArg = &Arg[ArgLenQueryShare];
        } else if (_wcsnicmp(Arg, ArgMove, ArgLenMove) == 0) {
            FoundAnArg = fArgMove = TRUE;
            if (ArgLen > ArgLenMove)
                pwszMoveArg = &Arg[ArgLenMove];
        } else if (_wcsnicmp(Arg, ArgMerge, ArgLenMerge) == 0) {
            FoundAnArg = fArgMerge = TRUE;
            if (ArgLen > ArgLenMerge)
                pwszMergeArg = &Arg[ArgLenMerge];
        } else if (_wcsnicmp(Arg, ArgFill, ArgLenFill) == 0) {
            FoundAnArg = fArgFill = TRUE;
            if (ArgLen > ArgLenFill)
                pwszFillArg = &Arg[ArgLenFill];
        } else if (_wcsnicmp(Arg, ArgCheck, ArgLenCheck) == 0) {
            FoundAnArg = fArgCheck = TRUE;
            if (ArgLen > ArgLenCheck)
                pwszCheckArg = &Arg[ArgLenCheck];
        } else if (_wcsnicmp(Arg, ArgEnumForStats, ArgLenEnumForStats) == 0) {
            FoundAnArg = fArgEnumForStats = TRUE;
            if (ArgLen > ArgLenEnumForStats)
                pwszEnumForStatsArg = &Arg[ArgLenEnumForStats];
#endif // CSCUTIL_INTERNAL
        }

        // Switches go at the end!!
        
        if (_wcsicmp(Arg, SwHelp) == 0) {
            FoundAnArg = fSwHelp = TRUE;
        } else if (_wcsicmp(Arg, SwResid) == 0) {
            FoundAnArg = fSwTouch = fSwEnum = fSwRecurse = TRUE;
        } else if (_wcsicmp(Arg, SwFull) == 0) {
            FoundAnArg = fSwFull = TRUE;
        } else if (_wcsicmp(Arg, SwTouch) == 0) {
            FoundAnArg = fSwTouch = TRUE;
        } else if (_wcsicmp(Arg, SwEnum) == 0) {
            FoundAnArg = fSwEnum = TRUE;
        } else if (_wcsicmp(Arg, SwQQ) == 0) {
            FoundAnArg = fSwQQ = TRUE;
        } else if (_wcsicmp(Arg, SwQ) == 0) {
            FoundAnArg = fSwQ = TRUE;
        } else if (_wcsicmp(Arg, SwRecurse) == 0) {
            FoundAnArg = fSwRecurse = TRUE;
         
#if defined(CSCUTIL_INTERNAL)
        } else if (_wcsicmp(Arg, SwDebug) == 0) {
            FoundAnArg = fSwDebug = TRUE;
        } else if (_wcsicmp(Arg, SwHelpHelp) == 0) {
            FoundAnArg = fSwHelpHelp = TRUE;
        } else if (_wcsicmp(Arg, SwPQEnum) == 0) {
            FoundAnArg = fSwPQEnum = TRUE;
        } else if (_wcsicmp(Arg, SwInfo) == 0) {
            FoundAnArg = fSwInfo = TRUE;
        } else if (_wcsicmp(Arg, SwDBStatus) == 0) {
            FoundAnArg = fSwDBStatus = TRUE;
        } else if (_wcsicmp(Arg, SwPurge) == 0) {
            FoundAnArg = fSwPurge = TRUE;
        } else if (_wcsicmp(Arg, SwDetector) == 0) {
            FoundAnArg = fSwDetector = TRUE;
        } else if (_wcsicmp(Arg, SwGetSpace) == 0) {
            FoundAnArg = fSwGetSpace = TRUE;
        } else if (_wcsicmp(Arg, SwDb) == 0) {
            FoundAnArg = fSwDb = TRUE;
        } else if (_wcsicmp(Arg, SwFcblist) == 0) {
            FoundAnArg = fSwFcblist = TRUE;
        } else if (_wcsicmp(Arg, SwEnable) == 0) {
            FoundAnArg = fSwEnable = TRUE;
        } else if (_wcsicmp(Arg, SwDisable) == 0) {
            FoundAnArg = fSwDisable = TRUE;
        } else if (_wcsicmp(Arg, SwSwitches) == 0) {
            FoundAnArg = fSwSwitches = TRUE;
        } else if (_wcsicmp(Arg, SwUser) == 0) {
            FoundAnArg = fSwUser = TRUE;
        } else if (_wcsicmp(Arg, SwSystem) == 0) {
            FoundAnArg = fSwSystem = TRUE;
        } else if (_wcsicmp(Arg, SwInherit) == 0) {
            FoundAnArg = fSwInherit = TRUE;
        } else if (_wcsicmp(Arg, SwAbort) == 0) {
            FoundAnArg = fSwAbort = TRUE;
        } else if (_wcsicmp(Arg, SwSkip) == 0) {
            FoundAnArg = fSwSkip = TRUE;
        } else if (_wcsicmp(Arg, SwAsk) == 0) {
            FoundAnArg = fSwAsk = TRUE;
        } else if (_wcsicmp(Arg, SwEof) == 0) {
            FoundAnArg = fSwEof = TRUE;
        } else if (_wcsicmp(Arg, SwRetry) == 0) {
            FoundAnArg = fSwRetry = TRUE;
        } else if (_wcsicmp(Arg, SwSet) == 0) {
            FoundAnArg = fSwSet = TRUE;
        } else if (_wcsicmp(Arg, SwClear) == 0) {
            FoundAnArg = fSwClear = TRUE;
        } else if (_wcsicmp(Arg, SwFlags) == 0) {
            FoundAnArg = fSwFlags = TRUE;
        } else if (_wcsicmp(Arg, SwIoctl) == 0) {
            FoundAnArg = fSwIoctl = TRUE;
        } else if (_wcsicmp(Arg, SwEncrypt) == 0) {
            FoundAnArg = fSwEncrypt = TRUE;
        } else if (_wcsicmp(Arg, SwDecrypt) == 0) {
            FoundAnArg = fSwDecrypt = TRUE;
#endif // CSCUTIL_INTERNAL
        }

        if (FoundAnArg == FALSE) {
            ErrorMessage(MSG_UNRECOGNIZED_OPTION, &Arg[1]);
            dwErr = FALSE;
            goto AllDone;
        }

    }

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"ProcessArg exit %d\r\n", dwErr);

    return dwErr;
}

DWORD
Usage(
    BOOLEAN fHelpHelp)
{
#if defined(CSCUTIL_INTERNAL)
    ErrorMessage(MSG_USAGE);
    if (fHelpHelp == TRUE)
        ErrorMessage(MSG_USAGE_EX);
#else
    ErrorMessage(MSG_USAGE2);
    if (fHelpHelp == TRUE)
        ErrorMessage(MSG_USAGE_EX2);
#endif // CSCUTIL_INTERNAL
    return ERROR_SUCCESS;
}

DWORD
CmdMoveShare(
	PWSTR source, 
	PWSTR dest)
{
   SHARESTATUS sFrom, sTo;

   //printf( "Attempting move from %ws to %ws.\n", source, dest );

   sFrom = GetCSCStatus(source);
   //printf( "INFO: %ws status = %s\n", source, statusName[sFrom] );
   
   sTo = GetCSCStatus(dest);
   //printf( "INFO: %ws status = %s\n", dest, statusName[sTo] );

   // Check and make sure this is valid
   if( (sFrom == PathLocal) || (sTo == PathLocal) )
   {
      ErrorMessage(MSG_TO_LOCAL);
      return ERROR_INVALID_PARAMETER;
   }

   if( (sFrom == NoCSC) || (sTo == NoCSC) )
   {
      ErrorMessage(MSG_NO_CSC);
      return ERROR_INVALID_PARAMETER;
   }

   if( sTo == ShareOffline )
   {
      ErrorMessage(MSG_NOT_ONLINE);
      return ERROR_CSCSHARE_OFFLINE;
   }

   MoveDirInCSC( source, dest, NULL, ShareOnline, ShareOnline, TRUE, TRUE );

   return ERROR_SUCCESS;
}


//+--------------------------------------------------------------------------
//
//  Function:   MoveDirInCSC
//
//  Synopsis:   this function moves a directory within the CSC cache without
//              prejudice. If the destination is a local path, it just deletes
//              the source tree from the cache
//
//  Arguments:  [in] pwszSource : the source path
//              [in] pwszDest   : the dest path
//              [in] pwszSkipSubdir : the directory to skip while moving
//              [in] StatusFrom : the CSC status of the source path
//              [in] StatusTo   : the CSC status of the dest. path
//              [in] bAllowRdrTimeout : if stuff needs to be deleted from the
//                              cache, we may not succeed immediately since
//                              the rdr keeps the handles to recently opened
//                              files open. This paramaters tells the function
//                              whether it needs to wait and retry
//
//  Returns:    nothing. it just tries its best.
//
//  History:    11/21/1998  RahulTh  created
//
//  Notes:      the value of bAllowRdrTimeout is always ignored for the
//              in-cache rename operation. we always want to wait for
//              the timeout.
//
//---------------------------------------------------------------------------
void MoveDirInCSC (const WCHAR * pwszSource, const WCHAR * pwszDest,
                   const WCHAR * pwszSkipSubdir,
                   SHARESTATUS   StatusFrom, SHARESTATUS   StatusTo,
                   BOOL  bAllowRdrTimeoutForDel,
                   BOOL  bAllowRdrTimeoutForRen)
{
    WIN32_FIND_DATA findData;
    DWORD   dwFileStatus;
    DWORD   dwPinCount;
    HANDLE  hCSCFind;
    DWORD   dwHintFlags;
    FILETIME origTime;
    WCHAR * pwszPath;
    WCHAR * pwszEnd;
    int     len;
    DWORD   StatusCSCRen = ERROR_SUCCESS;

    if (PathLocal == StatusFrom)
        return;                 //there is nothing to do. nothing was cached.

    if (PathLocal == StatusTo)
    {
        //the destination is a local path, so we should just delete the
        //files from the source
        DeleteCSCFileTree (pwszSource, pwszSkipSubdir, bAllowRdrTimeoutForDel);
    }
    else
    {
        pwszPath = (WCHAR *) malloc (sizeof (WCHAR) * ((len = wcslen (pwszSource)) + MAX_PATH + 2));
        if (!pwszPath || len <= 0)
            return;
        wcscpy (pwszPath, pwszSource);
        pwszEnd = pwszPath + len;
        if (L'\\' != pwszEnd[-1])
        {
            *pwszEnd++ = L'\\';
        }
        hCSCFind = CSCFindFirstFile (pwszSource, &findData, &dwFileStatus,
                                     &dwPinCount, &dwHintFlags, &origTime);

        if (INVALID_HANDLE_VALUE != hCSCFind)
        {
            do
            {
                if (0 != _wcsicmp (L".", findData.cFileName) &&
                    0 != _wcsicmp (L"..", findData.cFileName) &&
                    (!pwszSkipSubdir || (0 != _wcsicmp (findData.cFileName, pwszSkipSubdir))))
                {
                    wcscpy (pwszEnd, findData.cFileName);
                    if (ERROR_SUCCESS == StatusCSCRen)
                    {
                        StatusCSCRen = DoCSCRename (pwszPath, pwszDest, TRUE, bAllowRdrTimeoutForRen);
                    }
                    else
                    {
                        StatusCSCRen = DoCSCRename (pwszPath, pwszDest, TRUE, FALSE);
                    }
                }

            } while ( CSCFindNextFile (hCSCFind, &findData, &dwFileStatus,
                                       &dwPinCount, &dwHintFlags, &origTime)
                     );

            CSCFindClose (hCSCFind);
        }

        //merge the pin info. at the top level folder
        MergePinInfo (pwszSource, pwszDest, StatusFrom, StatusTo);
        
		//remove the share - Navjot.
		if (!CSCDeleteW(pwszSource))
           StatusCSCRen = GetLastError();
	}

    return;
}

//+--------------------------------------------------------------------------
//
//  Function:   DoCSCRename
//
//  Synopsis:   does a file rename within the CSC cache.
//
//  Arguments:  [in] pwszSource : full source path
//              [in] pwszDest : full path to destination directory
//              [in] bOverwrite : overwrite if the file/folder exists at
//                                  the destination
//              [in] bAllowRdrTimeout : if TRUE, retry for 10 seconds on failure
//                              so that rdr and mem. mgr. get enough time to
//                              release the handles.
//
//  Returns:    ERROR_SUCCESS if the rename was successful.
//              an error code otherwise.
//
//  History:    5/26/1999  RahulTh  created
//
//  Notes:      no validation of parameters is done. The caller is responsible
//              for that
//
//---------------------------------------------------------------------------
DWORD DoCSCRename (const WCHAR * pwszSource, const WCHAR * pwszDest,
                   BOOL bOverwrite, BOOL bAllowRdrTimeout)
{
    DWORD   Status = ERROR_SUCCESS;
    BOOL    bStatus;
    int     i;

    bStatus = CSCDoLocalRename (pwszSource, pwszDest, bOverwrite);
    if (!bStatus)
    {
        Status = GetLastError();
        if (ERROR_SUCCESS != Status &&
            ERROR_FILE_NOT_FOUND != Status &&
            ERROR_PATH_NOT_FOUND != Status &&
            ERROR_INVALID_PARAMETER != Status &&
            ERROR_BAD_NETPATH != Status)
        {
            if (bAllowRdrTimeout)
            {
                if (!bOverwrite && ERROR_FILE_EXISTS == Status)
                {
                    Status = ERROR_SUCCESS;
                }
                else
                {
                    for (i = 0; i < 11; i++)
                    {
                        Sleep (1000);   //wait for the handle to be released
                        bStatus = CSCDoLocalRename (pwszSource, pwszDest, bOverwrite);
                        if (bStatus)
                        {
                            Status = ERROR_SUCCESS;
                            break;
                        }
                    }
                }
            }
        }
        else
        {
            Status = ERROR_SUCCESS;
        }
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   DeleteCSCFileTree
//
//  Synopsis:   deletes a file tree from the CSC
//
//  Arguments:  [in] pwszSource : the path to the folder whose contents should
//                                be deleted
//              [in] pwszSkipSubdir : name of the subdirectory to be skipped.
//              [in] bAllowRdrTimeout : if true, makes multiple attempts to
//                              delete the file since the rdr may have left
//                              the handle open for sometime which can result
//                              in an ACCESS_DENIED message.
//
//  Returns:    ERROR_SUCCESS if the deletion was successful. An error code
//              otherwise.
//
//  History:    11/21/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD DeleteCSCFileTree (const WCHAR * pwszSource, const WCHAR * pwszSkipSubdir,
                        BOOL bAllowRdrTimeout)
{
    WIN32_FIND_DATA findData;
    DWORD   dwFileStatus;
    DWORD   dwPinCount;
    HANDLE  hCSCFind;
    DWORD   dwHintFlags;
    FILETIME origTime;
    WCHAR * pwszPath;
    WCHAR * pwszEnd;
    int     len;
    DWORD   Status = ERROR_SUCCESS;

    
    pwszPath = (WCHAR *) malloc (sizeof(WCHAR) * ((len = wcslen(pwszSource)) + MAX_PATH + 2));
    if (!pwszPath)
        return ERROR_OUTOFMEMORY;     //nothing much we can do if we run out of memory

    if (len <= 0)
        return ERROR_BAD_PATHNAME;

    wcscpy (pwszPath, pwszSource);
    pwszEnd = pwszPath + len;
    if (L'\\' != pwszEnd[-1])
    {
        *pwszEnd++ = L'\\';
    }

    hCSCFind = CSCFindFirstFile (pwszSource, &findData, &dwFileStatus,
                                 &dwPinCount, &dwHintFlags, &origTime);

    if (INVALID_HANDLE_VALUE != hCSCFind)
    {
        do
        {
            if (0 != _wcsicmp (L".", findData.cFileName) &&
                0 != _wcsicmp (L"..", findData.cFileName) &&
                (!pwszSkipSubdir || (0 != _wcsicmp (pwszSkipSubdir, findData.cFileName))))
            {
                wcscpy (pwszEnd, findData.cFileName);

                if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                {
                    if (ERROR_SUCCESS != Status)
                    {
                        //no point delaying the deletes since a delete has already
                        //failed.
                        DeleteCSCFileTree (pwszPath, NULL, FALSE);
                    }
                    else
                    {
                        Status = DeleteCSCFileTree (pwszPath, NULL, bAllowRdrTimeout);
                    }
                }
                else
                {
                    if (ERROR_SUCCESS != Status)
                    {
                        //no point delaying the delete if we have already failed.
                        DeleteCSCFile (pwszPath, FALSE);
                    }
                    else
                    {
                        Status = DeleteCSCFile (pwszPath, bAllowRdrTimeout);
                    }
                }
            }

        } while ( CSCFindNextFile (hCSCFind, &findData, &dwFileStatus,
                                   &dwPinCount, &dwHintFlags, &origTime)
                 );

        CSCFindClose (hCSCFind);
    }

    if (ERROR_SUCCESS != Status)
    {
        //no point in delaying the delete if we have already failed.
        DeleteCSCFile (pwszSource, FALSE);
    }
    else
    {
        Status = DeleteCSCFile (pwszSource, bAllowRdrTimeout);
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   DeleteCSCFile
//
//  Synopsis:   deletes the given path. but might make repeated attempts to
//              make sure that the rdr has enough time to release any handles
//              that it holds.
//
//  Arguments:  [in] pwszPath : the path to delete.
//              [in] bAllowRdrTimeout : make multiple attempts to delete the
//                          file with waits in between so that the rdr has
//                          enough time to release any held handles.
//
//  Returns:    ERROR_SUCCES if the delete was successful. An error code
//              otherwise.
//
//  History:    5/26/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD DeleteCSCFile (const WCHAR * pwszPath, BOOL bAllowRdrTimeout)
{
    BOOL    bStatus;
    DWORD   Status = ERROR_SUCCESS;
    int     i;

    bStatus = CSCDelete (pwszPath);
    if (!bStatus)
    {
        Status = GetLastError();
        if (ERROR_SUCCESS != Status &&
            ERROR_FILE_NOT_FOUND != Status &&
            ERROR_PATH_NOT_FOUND != Status &&
            ERROR_INVALID_PARAMETER != Status)
        {
            //this is a valid error.
            //so based on the value of bAllowRdrTimeout and based
            //on whether we have already failed in deleting something
            //we will try repeatedly to delete the file for 10 seconds
            if (bAllowRdrTimeout)
            {
                for (i = 0; i < 11; i++)
                {
                    Sleep (1000);   //wait for 1 second and try again
                    bStatus = CSCDelete (pwszPath);
                    if (bStatus)
                    {
                        Status = ERROR_SUCCESS;
                        break;
                    }
                }
            }
        }
        else
        {
            Status = ERROR_SUCCESS;
        }
    }

    return Status;
}


//+--------------------------------------------------------------------------
//
//  Function:   DeleteCSCShareIfEmpty
//
//  Synopsis:   given a file name, this function deletes from the local cache
//              the share to which the file belongs if the local cache for that
//              share is empty
//
//  Arguments:  [in] pwszFileName : the full file name -- must be UNC
//              [in] shStatus : the share status - online, offline, local etc.
//
//  Returns:    ERROR_SUCCESS : if successful
//              a win32 error code if something goes wrong
//
//  History:    4/22/1999  RahulTh  created
//
//  Notes:      we do not have to explicitly check if the share is empty
//              because if it is not, then the delete will fail anyway
//
//---------------------------------------------------------------------------
DWORD DeleteCSCShareIfEmpty (LPCTSTR pwszFileName, SHARESTATUS shStatus)
{
    DWORD   Status;
    WCHAR * pwszFullPath = NULL;
    WCHAR * pwszCurr = NULL;
    int     len;
    WCHAR * pwszShrEnd;

    if (PathLocal == shStatus || NoCSC == shStatus)
        return ERROR_SUCCESS;

    if (ShareOffline == shStatus)
        return ERROR_FILE_OFFLINE;

    len = wcslen (pwszFileName);

    if (len <= 2)
        return ERROR_BAD_PATHNAME;

    if (pwszFileName[0] != L'\\' || pwszFileName[1] != L'\\')
        return ERROR_BAD_PATHNAME;

    pwszFullPath = (WCHAR *) malloc (sizeof (WCHAR) * (len + 1));
    if (NULL == pwszFullPath)
        return ERROR_OUTOFMEMORY;

    if (NULL == _wfullpath(pwszFullPath, pwszFileName, len + 1))
        return ERROR_BAD_PATHNAME;  //canonicalization was unsuccessful.
                                    // -- rarely happens

    pwszShrEnd = wcschr (pwszFullPath + 2, L'\\');

    if (NULL == pwszShrEnd)
        return ERROR_BAD_PATHNAME;  //the path does not have the share component

    pwszShrEnd++;

    pwszShrEnd = wcschr (pwszShrEnd, L'\\');

    if (NULL == pwszShrEnd)
    {
        //we already have the path in \\server\share form, so just try to
        //delete the share.
        if (!CSCDelete (pwszFullPath))
            return GetLastError();
    }

    //if we are here, then we have a path longer than just \\server\share.
    //so try to delete all the way up to the share name. This is necessary
    //because a user might be redirected to something like
    // \\server\share\folder\%username% and we wouldn't want only \\server\share
    // and \\server\share\folder to be cached.
    Status = ERROR_SUCCESS;
    do
    {
        pwszCurr = wcsrchr (pwszFullPath, L'\\');
        if (NULL == pwszCurr)
            break;
        *pwszCurr = L'\0';
        if (!CSCDelete (pwszFullPath))
        {
            Status = GetLastError();
            if (ERROR_SUCCESS == Status ||
                ERROR_INVALID_PARAMETER == Status ||
                ERROR_FILE_NOT_FOUND == Status ||
                ERROR_PATH_NOT_FOUND == Status)
            {
                Status = ERROR_SUCCESS;
            }
        }
        if (ERROR_SUCCESS != Status)
            break;
    } while ( pwszCurr > pwszShrEnd );

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   MergePinInfo
//
//  Synopsis:   merges the pin info. from the source to destination
//
//  Arguments:  [in] pwszSource : the full path to the source
//              [in] pwszDest   : the full path to the destination
//              [in] StatusFrom : CSC status of the source share
//              [in] StatusTo   : CSC status of the destination share
//
//  Returns:    ERROR_SUCCESS : if it was successful
//              a Win32 error code otherwise
//
//  History:    4/23/1999  RahulTh  created
//
//  Notes:      the hint flags are a union of the source hint flags and
//              destination hint flags. The pin count is the greater of the
//              source and destination pin count
//
//              Usually this function should only be called for folders. The
//              CSC rename API handles files well. But this function will work
//              for files as well.
//
//---------------------------------------------------------------------------
DWORD MergePinInfo (LPCTSTR pwszSource, LPCTSTR pwszDest,
                   SHARESTATUS StatusFrom, SHARESTATUS StatusTo)
{
    BOOL    bStatus;
    DWORD   dwSourceStat, dwDestStat;
    DWORD   dwSourcePinCount, dwDestPinCount;
    DWORD   dwSourceHints, dwDestHints;
    DWORD   Status = ERROR_SUCCESS;
    DWORD   i;

    if (ShareOffline == StatusFrom || ShareOffline == StatusTo)
        return ERROR_FILE_OFFLINE;

    if (ShareOnline != StatusFrom || ShareOnline != StatusTo)
        return ERROR_SUCCESS;       //there is nothing to do if one of the shares
                                    //is local.
    if (!pwszSource || !pwszDest ||
        0 == wcslen(pwszSource) || 0 == wcslen(pwszDest))
        return ERROR_BAD_PATHNAME;

    bStatus = CSCQueryFileStatus (pwszSource, &dwSourceStat, &dwSourcePinCount,
                                  &dwSourceHints);
    if (!bStatus)
        return GetLastError();

    bStatus = CSCQueryFileStatus (pwszDest, &dwDestStat, &dwDestPinCount,
                                  &dwDestHints);
    if (!bStatus)
        return GetLastError();

    //first set the hint flags on the destination
    if (dwDestHints != dwSourceHints)
    {
        bStatus = CSCPinFile (pwszDest, dwSourceHints, &dwDestStat,
                              &dwDestPinCount, &dwDestHints);
        if (!bStatus)
            Status = GetLastError();    //note: we do not bail out here. we try
                                        //to at least merge the pin count before
                                        //leaving
    }

    //now merge the pin count : there is nothing to be done if the destination
    //pin count is greater than or equal to the source pin count
    if (dwDestPinCount < dwSourcePinCount)
    {
        for (i = 0, bStatus = TRUE; i < (dwSourcePinCount - dwDestPinCount) &&
                                    bStatus;
             i++)
        {
            bStatus = CSCPinFile( pwszDest,
                                  FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT,
                                  NULL, NULL, NULL );
        }

        if (!bStatus && ERROR_SUCCESS == Status)
            Status = GetLastError();
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   PinIfNecessary
//
//  Synopsis:   this function pins a file if necessary.
//
//  Arguments:  [in] pwszPath : full path of the file/folder to be pinned
//              [in] shStatus : CSC status of the share.
//
//  Returns:    ERROR_SUCCESS if it was successful. An error code otherwise.
//
//  History:    5/27/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD PinIfNecessary (const WCHAR * pwszPath, SHARESTATUS shStatus)
{
    DWORD   Status = ERROR_SUCCESS;
    BOOL    bStatus;
    DWORD   dwStatus;
    DWORD   dwPinCount;
    DWORD   dwHints;

    if (!pwszPath || !pwszPath[0])
        return ERROR_BAD_NETPATH;

    
    if (ShareOffline == shStatus)
        return ERROR_FILE_OFFLINE;
    else if (PathLocal == shStatus || NoCSC == shStatus)
        return ERROR_SUCCESS;

    bStatus = CSCQueryFileStatus (pwszPath, &dwStatus, &dwPinCount, &dwHints);
    if (!bStatus || dwPinCount <= 0)
    {
        bStatus = CSCPinFile (pwszPath,
                              FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT,
                              NULL, NULL, NULL);
        if (!bStatus)
            Status = GetLastError();
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetCSCStatus
//
//  Synopsis:   given a path, finds out if it is local and if it is not
//              whether it is online or offline.
//
//  Arguments:  [in] pwszPath : the path to the file
//
//  Returns:    Local/Online/Offline
//
//  History:    11/20/1998  RahulTh  created
//
//  Notes:      it is important that the path passed to this function is a
//              a full path and not a relative path
//
//              this function will return offline if the share is not live or
//              if the share is live but CSC thinks that it is offline
//
//              it will return PathLocal if the path is local or if the path
//              is a network path that cannot be handled by CSC e.g. a network
//              share with a pathname longer than what csc can handle or if it
//              is a netware share. in this case it makes sense to return
//              PathLocal because CSC won't maintain a database for these shares
//              -- same as for a local path. so as far as CSC is concerned, this
//              is as good as a local path.
//
//---------------------------------------------------------------------------
SHARESTATUS GetCSCStatus (const WCHAR * pwszPath)
{
    WCHAR * pwszAbsPath = NULL;
    WCHAR * pwszCurr = NULL;
    int     len;
    BOOL    bRetVal;
    DWORD   Status;
    DWORD   dwPinCount;
    DWORD   dwHints;

    if (!pwszPath)
        return ShareOffline;    //a path must be provided

    len = wcslen (pwszPath);

    pwszAbsPath = (WCHAR *) malloc (sizeof (WCHAR) * (len + 1));

    if (!pwszAbsPath)
    {
        //we are out of memory, so it is safest to return ShareOffline
        //so that we can bail out of redirection.
        return ShareOffline;
    }

    //get the absolute path
    pwszCurr = _wfullpath (pwszAbsPath, pwszPath, len + 1);

    if (!pwszCurr)
    {
        //in order for _wfullpath to fail, something really bad has to happen
        //so it is best to return ShareOffline so that we can bail out of
        //redirection
        return ShareOffline;
    }

    len = wcslen (pwszAbsPath);

    if (! (
           (2 <= len) &&
           (L'\\' == pwszAbsPath[0]) &&
           (L'\\' == pwszAbsPath[1])
           )
       )
    {
        //it is a local path if it does not begin with 2 backslashes
        return PathLocal;
    }

    //this is a UNC path; so extract the \\server\share part
    pwszCurr = wcschr ( & (pwszAbsPath[2]), L'\\');

    //first make sure that it is at least of the form \\server\share
    //watch out for the \\server\ case
    if (!pwszCurr || !pwszCurr[1])
        return ShareOffline;        //it is an invalid path (no share name)

    //the path is of the form \\server\share
    //note: the use _wfullpath automatically protects us against the \\server\\ case
    pwszCurr = wcschr (&(pwszCurr[1]), L'\\');
    if (pwszCurr)   //if it is of the form \\server\share\...
        *pwszCurr = L'\0';

    //now pwszAbsPath is a share name
    bRetVal = CSCCheckShareOnline (pwszAbsPath);

    if (!bRetVal)
    {
        if (ERROR_SUCCESS != GetLastError())
        {
           //either there is really a problem (e.g. invalid share name) or
           //it is just a share that is not handled by CSC e.g. a netware share
           //or a share with a name that is longer than can be handled by CSC
           //so check if the share actually exists
           if (0xFFFFFFFF != GetFileAttributes(pwszAbsPath))
           {
              //this can still be a share that is offline since GetFileAttributes
              //will return the attributes stored in the cache
              Status = 0;
              bRetVal = GetShareStatus (pwszAbsPath, &Status, &dwPinCount,
                                            &dwHints);
              if (! bRetVal || (! (FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & Status)))
                 return PathLocal;     //this is simply a valid path that CSC cannot handle
              else if (bRetVal &&
                       (FLAG_CSC_SHARE_STATUS_NO_CACHING ==
                            (FLAG_CSC_SHARE_STATUS_CACHING_MASK & Status)))
                  return PathLocal;     //CSC caching is not turned on for the share.
           }
        }

        //it is indeed an inaccessble share
        return ShareOffline;  //for all other cases, treat this as offline
    }
    else
    {
       //this means that the share is live, but CSC might still think that it
       //is offline.
       Status = 0;
       bRetVal = GetShareStatus (pwszAbsPath, &Status, &dwPinCount,
                                     &dwHints);
       if (bRetVal && (FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & Status))
          return ShareOffline;   //CSC thinks that the share is offline
       else if (bRetVal &&
                (FLAG_CSC_SHARE_STATUS_NO_CACHING ==
                            (FLAG_CSC_SHARE_STATUS_CACHING_MASK & Status)))
           return PathLocal;    //CSC caching is not turned on for the share
       else if (!bRetVal)
           return ShareOffline;

       //in all other cases, consider the share as online since
       //CSCCheckShareOnline has already returned TRUE
       return ShareOnline;
    }
}

//+--------------------------------------------------------------------------
//
//  Function:   GetShareStatus
//
//  Synopsis:   this function is a wrapper for CSCQueryFileStatus.
//              basically CSCQueryFileStatus can fail if there was never a net
//              use to a share. So this function tries to create a net use to
//              the share if CSCQueryFileStatus fails and then re-queries the
//              file status
//
//  Arguments:  [in] pwszShare : the share name
//              [out] pdwStatus : the share Status
//              [out] pdwPinCount : the pin count
//              [out] pdwHints : the hints
//
//  Returns:    TRUE : if everything was successful.
//              FALSE : if there was an error. In this case, it GetLastError()
//                      will contain the specific error code.
//
//  History:    5/11/1999  RahulTh  created
//
//  Notes:      it is very important that this function be passed a share name
//              it does not do any parameter validation. So under no
//              circumstance should this function be passed a filename.
//
//---------------------------------------------------------------------------
BOOL GetShareStatus (const WCHAR * pwszShare, DWORD * pdwStatus,
                     DWORD * pdwPinCount, DWORD * pdwHints)
{
    NETRESOURCE nr;
    DWORD       dwResult;
    DWORD       dwErr = NO_ERROR;
    BOOL        bStatus;

    bStatus = CSCQueryFileStatus(pwszShare, pdwStatus, pdwPinCount, pdwHints);

    if (!bStatus)
    {
        //try to connect to the share
        ZeroMemory ((PVOID) (&nr), sizeof (NETRESOURCE));
        nr.dwType = RESOURCETYPE_DISK;
        nr.lpLocalName = NULL;
        nr.lpRemoteName = (LPTSTR) pwszShare;
        nr.lpProvider = NULL;

        dwErr = WNetUseConnection(NULL, &nr, NULL, NULL, 0,
                                  NULL, NULL, &dwResult);

        if (NO_ERROR == dwErr)
        {
            bStatus = CSCQueryFileStatus (pwszShare, pdwStatus, pdwPinCount, pdwHints);
            if (!bStatus)
                dwErr = GetLastError();
            else
                dwErr = NO_ERROR;

            WNetCancelConnection2 (pwszShare, 0, FALSE);
        }
        else
        {
            bStatus = FALSE;
        }

    }

    SetLastError(dwErr);
    return bStatus;
}


DWORD
CmdReconnect(
    PWSTR ReconnectArg)
{
    DWORD Error = ERROR_SUCCESS;
    BOOL fRet;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdReconnect(%ws)\r\n", ReconnectArg);

    fRet = CSCTransitionServerOnlineW(ReconnectArg);
    if (fRet == FALSE)
       Error = GetLastError();

    return Error;
}

DWORD
CmdQueryFile(
    PWSTR QueryFileArg)
{
    DWORD HintFlags = 0;
    DWORD PinCount = 0;
    DWORD Status = 0;
    DWORD Error = ERROR_SUCCESS;
    BOOL fRet;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdQueryFile(%ws)\r\n", QueryFileArg);

    fRet = CSCQueryFileStatusW(
                QueryFileArg,
                &Status,
                &PinCount,
                &HintFlags);

    if (fRet == FALSE) {
       Error = GetLastError();
       goto AllDone;
    }

    if (fSwFull != TRUE) {
        MyPrintf(
            L"QueryFile of %ws:\r\n"
            L"Status:                0x%x\r\n"
            L"PinCount:              %d\r\n"
            L"HintFlags:             0x%x\r\n",
                QueryFileArg,
                Status,
                PinCount,
                HintFlags);
    } else {
        WCHAR StatusBuffer[0x100];
        WCHAR HintBuffer[0x100];
   
        if (LooksToBeAShare(QueryFileArg) == TRUE)
            ShareStatusToEnglish(Status, StatusBuffer);
        else
            FileStatusToEnglish(Status, StatusBuffer);
        HintsToEnglish(HintFlags, HintBuffer);
        MyPrintf(
            L"QueryFile of %ws:\r\n"
            L"Status:    0x%x %ws\r\n"
            L"PinCount:  %d\r\n"
            L"HintFlags: 0x%x %ws\r\n",
                QueryFileArg,
                Status,
                StatusBuffer,
                PinCount,
                HintFlags,
                HintBuffer);
    }

AllDone:
    return Error;
}

DWORD
CmdQueryFileEx(
    PWSTR QueryFileExArg)
{
    DWORD HintFlags = 0;
    DWORD PinCount = 0;
    DWORD Status = 0;
    DWORD UserPerms = 0;
    DWORD OtherPerms = 0;
    DWORD Error = ERROR_SUCCESS;
    BOOL fRet;
    HMODULE hmodCscDll = LoadLibrary(TEXT("cscdll.dll"));
    CSCQUERYFILESTATUSEXW pCSCQueryFileStatusExW = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdQueryFileEx(%ws)\r\n", QueryFileExArg);

    if (hmodCscDll == NULL) {
        Error = GetLastError();
        goto AllDone;
    }

    pCSCQueryFileStatusExW = (CSCQUERYFILESTATUSEXW) GetProcAddress(
                                                        hmodCscDll,
                                                        "CSCQueryFileStatusExW");
    if (pCSCQueryFileStatusExW == NULL) {
        Error = GetLastError();
        goto AllDone;
    }

    fRet = (pCSCQueryFileStatusExW)(
                QueryFileExArg,
                &Status,
                &PinCount,
                &HintFlags,
                &UserPerms,
                &OtherPerms);

    if (fRet == FALSE) {
       Error = GetLastError();
       goto AllDone;
    }

    if (fSwFull != TRUE) {
        MyPrintf(
            L"Query of %ws:\r\n"
            L"Status:                0x%x\r\n"
            L"PinCount:              %d\r\n"
            L"HintFlags:             0x%x\r\n"
            L"UserPerms:             0x%x\r\n"
            L"OtherPerms:            0x%x\r\n",
                QueryFileExArg,
                Status,
                PinCount,
                HintFlags,
                UserPerms,
                OtherPerms);
    } else {
        WCHAR StatusBuffer[0x100] = {0};
        WCHAR HintBuffer[0x100] = {0};
   
        if (LooksToBeAShare(QueryFileExArg) == TRUE)
            ShareStatusToEnglish(Status, StatusBuffer);
        else
            FileStatusToEnglish(Status, StatusBuffer);
        HintsToEnglish(HintFlags, HintBuffer);
        MyPrintf(
            L"Query of %ws:\r\n"
            L"Status:     0x%x %ws\r\n"
            L"PinCount:   %d\r\n"
            L"HintFlags:  0x%x %ws\r\n"
            L"UserPerms:  0x%x\r\n"
            L"OtherPerms: 0x%x\r\n",
                QueryFileExArg,
                Status,
                StatusBuffer,
                PinCount,
                HintFlags,
                HintBuffer,
                UserPerms,
                OtherPerms);
    }

AllDone:
    if (hmodCscDll != NULL)
        FreeLibrary(hmodCscDll);
    return Error;
}

DWORD
CmdSetSpace(
    PWSTR SetSpaceArg)
{
    DWORD Error = ERROR_SUCCESS;
    DWORD MaxSpaceHigh = 0;
    DWORD MaxSpaceLow;
    BOOL fRet;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSetSpace(%ws)\r\n", SetSpaceArg);

    swscanf(SetSpaceArg, L"%d", &MaxSpaceLow);

    fRet = CSCSetMaxSpace(
                MaxSpaceHigh,
                MaxSpaceLow);

    if (fRet == FALSE) {
       Error = GetLastError();
       goto AllDone;
    }

    CmdGetSpace();

AllDone:
    return Error;
}

DWORD
CmdQueryShare(
    PWSTR QueryShareArg)
{
    DWORD HintFlags = 0;
    DWORD PinCount = 0;
    DWORD Status = 0;
    DWORD UserPerms = 0;
    DWORD OtherPerms = 0;
    DWORD Error = ERROR_SUCCESS;
    BOOL fRet;
    HMODULE hmodCscDll = LoadLibrary(TEXT("cscdll.dll"));
    CSCQUERYSHARESTATUSW pCSCQueryShareStatusW = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdQueryShare(%ws)\r\n", QueryShareArg);

    if (hmodCscDll == NULL) {
        Error = GetLastError();
        goto AllDone;
    }

    pCSCQueryShareStatusW = (CSCQUERYSHARESTATUSW) GetProcAddress(
                                                        hmodCscDll,
                                                        "CSCQueryShareStatusW");
    if (pCSCQueryShareStatusW == NULL) {
        Error = GetLastError();
        goto AllDone;
    }

    fRet = (pCSCQueryShareStatusW)(
                QueryShareArg,
                &Status,
                &PinCount,
                &HintFlags,
                &UserPerms,
                &OtherPerms);

    if (fRet == FALSE) {
       Error = GetLastError();
       goto AllDone;
    }

    if (fSwFull != TRUE) {
        MyPrintf(
            L"Query of %ws:\r\n"
            L"Status:                0x%x\r\n"
            L"PinCount:              %d\r\n"
            L"HintFlags:             0x%x\r\n"
            L"UserPerms:             0x%x\r\n"
            L"OtherPerms:            0x%x\r\n",
                QueryShareArg,
                Status,
                PinCount,
                HintFlags,
                UserPerms,
                OtherPerms);
    } else {
        WCHAR StatusBuffer[0x100] = {0};
        WCHAR HintBuffer[0x100] = {0};
   
        ShareStatusToEnglish(Status, StatusBuffer);
        HintsToEnglish(HintFlags, HintBuffer);
        MyPrintf(
            L"Query of %ws:\r\n"
            L"Status:     0x%x %ws\r\n"
            L"PinCount:   %d\r\n"
            L"HintFlags:  0x%x %ws\r\n"
            L"UserPerms:  0x%x\r\n"
            L"OtherPerms: 0x%x\r\n",
                QueryShareArg,
                Status,
                StatusBuffer,
                PinCount,
                HintFlags,
                HintBuffer,
                UserPerms,
                OtherPerms);
    }
AllDone:
    if (hmodCscDll != NULL)
        FreeLibrary(hmodCscDll);
    return Error;
}

DWORD
CmdMerge(
    PWSTR MergeArg)
{
    DWORD Error = ERROR_SUCCESS;
    DWORD HowToRespond = CSCPROC_RETURN_CONTINUE; // JMH
    BOOL fRet;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdMerge(%ws)\r\n", MergeArg);

    fRet = CSCMergeShareW(MergeArg, MyCscMergeProcW, HowToRespond);
    if (fRet == FALSE) {
        Error = GetLastError();
        goto AllDone;
    }

    fRet = CSCTransitionServerOnlineW(MergeArg);
    if (fRet == FALSE)
       Error = GetLastError();

AllDone:
    return Error;
}

DWORD
CmdMove(
    PWSTR MoveArg)
{

	DWORD Error = ERROR_FILE_NOT_FOUND;
	LPWSTR  lpszTempName = NULL;

    if (!CSCCopyReplicaW(MoveArg, &lpszTempName)) {
        Error = GetLastError();
    } else {
        Error = ERROR_SUCCESS;
    }

	if (Error == ERROR_SUCCESS)
        MyPrintf(L"Copy is %ws\r\n", lpszTempName);

	return Error;
}


DWORD
CmdEncryptDecrypt(
    BOOL fEncrypt)
{
    DWORD Error = ERROR_SUCCESS;
    DWORD EncryptDecryptType = 0;
    BOOL fRet;
    HMODULE hmodCscDll = LoadLibrary(TEXT("cscdll.dll"));
    CSCENCRYPTDECRYPTDATABASE pCSCEncryptDecryptDatabase = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdEncryptDecrypt(%ws)\r\n", fEncrypt == TRUE ? L"Encrypt" : L"Decrypt");

    if (hmodCscDll == NULL) {
        Error = GetLastError();
        goto AllDone;
    }

    pCSCEncryptDecryptDatabase = (CSCENCRYPTDECRYPTDATABASE) GetProcAddress(
                                                                hmodCscDll,
                                                                "CSCEncryptDecryptDatabase");
    if (pCSCEncryptDecryptDatabase == NULL) {
        Error = GetLastError();
        goto AllDone;
    }

    fRet = (pCSCEncryptDecryptDatabase)(fEncrypt, MyEncryptDecryptProcW, EncryptDecryptType);
    if (fRet == FALSE) {
        Error = GetLastError();
        goto AllDone;
    }

AllDone:

    if (hmodCscDll != NULL)
        FreeLibrary(hmodCscDll);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdEncryptDecrypt exit %d\r\n", Error);

    return Error;
}

DWORD
CmdFill(
    PWSTR FillArg)
{
    DWORD Error = ERROR_SUCCESS;
    DWORD HowToRespond = CSCPROC_RETURN_CONTINUE;
    BOOL fRet;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdFill(%ws, %d)\r\n", FillArg, fSwFull);

    fRet = CSCFillSparseFilesW(FillArg, fSwFull, MyCscFillProcW, HowToRespond);
    if (fRet == FALSE) {
        Error = GetLastError();
    }

    return Error;
}

DWORD
CmdCheck(
    PWSTR CheckArg)
{
    DWORD Error = ERROR_SUCCESS;
    DWORD Speed = 0;
    BOOL fOnline = FALSE;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdCheck(%ws)\r\n", CheckArg);

    fOnline = CSCCheckShareOnlineExW(CheckArg, &Speed);

    MyPrintf(
        L"%ws is %s\r\n",
            CheckArg,
            (fOnline == FALSE) ? L"Offline" : L"Online");

    return Error;
}

DWORD
CmdDBStatus(
    VOID)
{
    GLOBALSTATUS sGS = {0};
    ULONG DBStatus = 0;
    ULONG DBErrorFlags = 0;
    BOOL bResult;
    HANDLE hDBShadow = INVALID_HANDLE_VALUE;
    ULONG junk;
    ULONG Status = 0;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDBStatus()\r\n");

    hDBShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hDBShadow == INVALID_HANDLE_VALUE) {
        MyPrintf(L"CmdDBStatus:Failed open of shadow device\r\n");
        Status = GetLastError();
        goto AllDone;
    }

    bResult = DeviceIoControl(
                hDBShadow,                      // device 
                IOCTL_GETGLOBALSTATUS,          // control code
                (LPVOID)&sGS,                   // in buffer
                0,                              // inbuffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

    if (!bResult) {
        MyPrintf(L"CmdDBStatus:DeviceIoControl IOCTL_GETGLOBALSTATUS failed\n");
        Status = GetLastError();
        goto AllDone;
    }

    DBStatus = sGS.sST.uFlags;
    DBErrorFlags = sGS.uDatabaseErrorFlags;

    if (DBStatus & FLAG_DATABASESTATUS_DIRTY)
        MyPrintf(L"FLAG_DATABASESTATUS_DIRTY\r\n");
    if (DBStatus & FLAG_DATABASESTATUS_UNENCRYPTED)
        MyPrintf(L"FLAG_DATABASESTATUS_UNENCRYPTED\r\n");
    if (DBStatus & FLAG_DATABASESTATUS_PARTIALLY_UNENCRYPTED)
        MyPrintf(L"FLAG_DATABASESTATUS_PARTIALLY_UNENCRYPTED\r\n");
    if (DBStatus & FLAG_DATABASESTATUS_ENCRYPTED)
        MyPrintf(L"FLAG_DATABASESTATUS_ENCRYPTED\r\n");
    if (DBStatus & FLAG_DATABASESTATUS_PARTIALLY_ENCRYPTED)
        MyPrintf(L"FLAG_DATABASESTATUS_PARTIALLY_ENCRYPTED\r\n");
	
	MyPrintf(L"Database Error Flags : 0x%x\r\n", DBErrorFlags);

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDBStatus exit %d\r\n", Status);

    if (hDBShadow != INVALID_HANDLE_VALUE)
        CloseHandle(hDBShadow);

    return Status;
}

DWORD
CmdPurge(
    PWSTR PurgeArg)
{
    ULONG nFiles = 0;
    ULONG nYoungFiles = 0;
    ULONG Status = ERROR_SUCCESS;
    ULONG Timeout = 120;
    BOOL fRet = FALSE;
    HMODULE hmodCscDll = LoadLibrary(TEXT("cscdll.dll"));
    CSCPURGEUNPINNEDFILES pCSCPurgeUnpinnedFiles = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdPurge(%ws)\r\n", PurgeArg);

    if (hmodCscDll == NULL) {
        Status = GetLastError();
        goto AllDone;
    }

    pCSCPurgeUnpinnedFiles = (CSCPURGEUNPINNEDFILES) GetProcAddress(
                                                        hmodCscDll,
                                                        "CSCPurgeUnpinnedFiles");
    if (pCSCPurgeUnpinnedFiles == NULL) {
        Status = GetLastError();
        goto AllDone;
    }

    if (PurgeArg != NULL)
        swscanf(PurgeArg, L"%d", &Timeout);

    if (fSwDebug == TRUE)
        MyPrintf(L"Timeout=%d seconds\r\n", Timeout);

    fRet = (pCSCPurgeUnpinnedFiles)(Timeout, &nFiles, &nYoungFiles);
    if (fRet == FALSE) {
        Status = GetLastError();
        goto AllDone;
    }
    MyPrintf(L"nFiles = %d nYoungFiles=%d\n", nFiles, nYoungFiles);

AllDone:
    if (hmodCscDll != NULL)
        FreeLibrary(hmodCscDll);
    if (fSwDebug == TRUE)
        MyPrintf(L"CmdPurge exit %d\r\n", Status);

    return Status;
}

DWORD
CmdPQEnum(
    VOID)
{
    PQPARAMS PQP = {0};
    BOOL bResult;
    HANDLE hDBShadow = INVALID_HANDLE_VALUE;
    ULONG junk;
    ULONG Status = 0;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdPQEnum()\r\n");

    hDBShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hDBShadow == INVALID_HANDLE_VALUE) {
        MyPrintf(L"CmdPQEnum:Failed open of shadow device\r\n");
        Status = GetLastError();
        goto AllDone;
    }

    MyPrintf(L"  POS SHARE      DIR   SHADOW   STATUS REFPRI   HPRI HINTFLG HINTPRI  VER\r\n");

    bResult = DeviceIoControl(
                hDBShadow,                      // device 
                IOCTL_SHADOW_BEGIN_PQ_ENUM,     // control code
                (LPVOID)&PQP,                   // in buffer
                0,                              // inbuffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

    if (!bResult) {
        MyPrintf(L"CmdPQEnum:DeviceIoControl IOCTL_SHADOW_BEGIN_PQ_ENUM failed\n");
        Status = GetLastError();
        goto AllDone;
    }

    do {
        bResult = DeviceIoControl(
                    hDBShadow,                      // device 
                    IOCTL_SHADOW_NEXT_PRI_SHADOW,   // control code
                    (LPVOID)&PQP,                   // in buffer
                    0,                              // inbuffer size
                    NULL,                           // out buffer
                    0,                              // out buffer size
                    &junk,                          // bytes returned
                    NULL);                          // overlapped
        if (bResult) {
           MyPrintf(L"%5d %5x %8x %8x %8x %6d %6x %7d %7d %4d\r\n",
                PQP.uPos,
                PQP.hShare,
                PQP.hDir,
                PQP.hShadow,
                PQP.ulStatus,
                PQP.ulRefPri,
                PQP.ulIHPri,
                PQP.ulHintFlags,
                PQP.ulHintPri,
                PQP.dwPQVersion);
        }
    } while (bResult && PQP.uPos != 0);

    bResult = DeviceIoControl(
                hDBShadow,                      // device 
                IOCTL_SHADOW_END_PQ_ENUM,       // control code
                (LPVOID)&PQP,                   // in buffer
                0,                              // inbuffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdPQEnum exit %d\r\n", Status);

    if (hDBShadow != INVALID_HANDLE_VALUE)
        CloseHandle(hDBShadow);

    return Status;
}

LPWSTR
ConvertGmtTimeToString(
    FILETIME Time,
    LPWSTR OutputBuffer)
{
    FILETIME LocalTime;
    SYSTEMTIME SystemTime;

    static FILETIME ftNone = {0, 0};

    if (memcmp(&Time, &ftNone, sizeof(FILETIME)) == 0) {
        wsprintf (OutputBuffer, L"<none>");
    } else {
        FileTimeToLocalFileTime( &Time , &LocalTime );
        FileTimeToSystemTime( &LocalTime, &SystemTime );
        wsprintf(
            OutputBuffer,
            L"%02u/%02u/%04u %02u:%02u:%02u ",
                    SystemTime.wMonth,
                    SystemTime.wDay,
                    SystemTime.wYear,
                    SystemTime.wHour,
                    SystemTime.wMinute,
                    SystemTime.wSecond );
    }
    return( OutputBuffer );
}

VOID
DumpCscEntryInfo(
    LPWSTR Path,
    PWIN32_FIND_DATA Find32,
    DWORD Status,
    DWORD PinCount,
    DWORD HintFlags,
    PFILETIME OrgTime)
{
    WCHAR TimeBuf1[40];
    WCHAR TimeBuf2[40];
    FILE *fp = NULL;

    if (fSwTouch == TRUE) {
        if (Path == NULL) {
            wsprintf(NameBuf, L"%ws", Find32->cFileName);
        } else {
            wsprintf(NameBuf, L"%ws\\%ws", Path, Find32->cFileName);
        }
        MyPrintf(L"%ws\r\n", NameBuf);
        if ((Find32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
            fp = _wfopen(NameBuf, L"rb");
            if (fp != NULL)
                fclose(fp);
        }
    } else if (fSwFull == TRUE) {
        WCHAR StatusBuffer[0x100];
        WCHAR HintBuffer[0x100];

        if (Path != NULL)
            MyPrintf(L"Directory %ws\r\n", Path);
        ConvertGmtTimeToString(Find32->ftLastWriteTime, TimeBuf1);
        MyPrintf(
            L"LFN:           %s\r\n"
            L"SFN:           %s\r\n"
            L"Attr:          0x%x\r\n"
            L"Size:          0x%x:0x%x\r\n"
            L"LastWriteTime: %ws\r\n",
                Find32->cFileName,
                Find32->cAlternateFileName,
                Find32->dwFileAttributes,
                Find32->nFileSizeHigh, Find32->nFileSizeLow,
                TimeBuf1);

        if (OrgTime) {
            ConvertGmtTimeToString(*OrgTime, TimeBuf1);
            MyPrintf(L"ORGTime:       %ws\r\n", TimeBuf1);
        }
        StatusBuffer[0] = L'\0';
        HintBuffer[0] = L'\0';
        if (Path == NULL) {
            ShareStatusToEnglish(Status, StatusBuffer);
            HintsToEnglish(HintFlags, HintBuffer);
        } else {
            if (LooksToBeAShare(Path) == TRUE)
                ShareStatusToEnglish(Status, StatusBuffer);
            else
                FileStatusToEnglish(Status, StatusBuffer);
            HintsToEnglish(HintFlags, HintBuffer);
        }
        MyPrintf(
            L"Status:        0x%x %ws\r\n"
            L"PinCount:      %d\r\n"
            L"HintFlags:     0x%x %ws\r\n\r\n",
                Status,
                StatusBuffer,
                PinCount,
                HintFlags,
                HintBuffer);
    } else {
        if (Path == NULL) {
            MyPrintf(L"%ws\r\n", Find32->cFileName);
        } else {
            MyPrintf(L"%ws\\%ws\r\n", Path, Find32->cFileName);
        }
        MyPrintf(L"  Attr=0x%x Size=0x%x:0x%x Status=0x%x PinCount=%d HintFlags=0x%x\r\n",
                Find32->dwFileAttributes,
                Find32->nFileSizeHigh, Find32->nFileSizeLow,
                Status,
                PinCount,
                HintFlags);
        ConvertGmtTimeToString(Find32->ftLastWriteTime, TimeBuf1);
        if (OrgTime)
            ConvertGmtTimeToString(*OrgTime, TimeBuf2);
        else
            wcscpy(TimeBuf2, L"<none>");
        MyPrintf(L"  LastWriteTime: %ws OrgTime: %ws\r\n",
                        TimeBuf1,
                        TimeBuf2);
        MyPrintf(L"\r\n");
    }
}

DWORD
CmdEnum(
    PWSTR EnumArg)
{
	HANDLE hFind;
	DWORD Error = ERROR_SUCCESS;
    DWORD Status = 0;
    DWORD PinCount = 0;
    DWORD HintFlags = 0;
	FILETIME ftOrgTime = {0};
	WIN32_FIND_DATAW sFind32 = {0};
    WCHAR FullPath[MAX_PATH];

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdEnum(%ws)\r\n", EnumArg);

    hFind = CSCFindFirstFileW(EnumArg, &sFind32, &Status, &PinCount, &HintFlags, &ftOrgTime);
    if (hFind == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
        goto AllDone;
    }
    DumpCscEntryInfo(EnumArg, &sFind32, Status, PinCount, HintFlags, &ftOrgTime);
    if (fSwRecurse == TRUE && (sFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        if (EnumArg != NULL) {
            wcscpy(FullPath, EnumArg);
            wcscat(FullPath, L"\\");
        } else {
            wcscpy(FullPath, L"");
        }
        wcscat(FullPath, sFind32.cFileName);
        CmdEnum(FullPath);
    }
    while (CSCFindNextFileW(hFind, &sFind32, &Status, &PinCount, &HintFlags, &ftOrgTime)) {
        DumpCscEntryInfo(EnumArg, &sFind32, Status, PinCount, HintFlags, &ftOrgTime);
        if (fSwRecurse == TRUE && (sFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            if (EnumArg != NULL) {
                wcscpy(FullPath, EnumArg);
                wcscat(FullPath, L"\\");
            } else {
                wcscpy(FullPath, L"");
            }
            wcscat(FullPath, sFind32.cFileName);
            CmdEnum(FullPath);
        }
    }
    CSCFindClose(hFind);

AllDone:
	return (Error);
}

DWORD
CmdEnumForStats(
    PWSTR EnumForStatsArg)
{
    DWORD Error = ERROR_SUCCESS;
    DWORD EnumForStatsType = 0;
    BOOL fRet;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdEnumForStats()\r\n");

    fRet = CSCEnumForStatsW(EnumForStatsArg, MyEnumForStatsProcW, EnumForStatsType);
    if (fRet == FALSE) {
        Error = GetLastError();
        goto AllDone;
    }

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdEnumForStats exit %d\r\n", Error);

    return Error;
}

DWORD
CmdDelete(
    PWSTR DeleteArg)
{
	DWORD Error = ERROR_SUCCESS;
    DWORD Status = 0;
    DWORD PinCount = 0;
    DWORD HintFlags = 0;
	FILETIME ftOrgTime = {0};
    BOOL fResult;
	HANDLE hFind;
	WIN32_FIND_DATAW sFind32 = {0};
    WCHAR FullPath[MAX_PATH];


    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDelete(%ws)\r\n", DeleteArg);

    //
    // Non-recursive delete
    //
    if (fSwRecurse == FALSE) {
        fResult = CSCDeleteW(DeleteArg);
        if (fResult == FALSE)
            Error = GetLastError();
        goto AllDone;
    }
    //
    // Delete recursively, using eumeration
    //
    hFind = CSCFindFirstFileW(DeleteArg, &sFind32, &Status, &PinCount, &HintFlags, &ftOrgTime);
    if (hFind == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
        goto AllDone;
    }
    if (DeleteArg != NULL) {
        wcscpy(FullPath, DeleteArg);
        wcscat(FullPath, L"\\");
    } else {
        wcscpy(FullPath, L"");
    }
    wcscat(FullPath, sFind32.cFileName);
    if (sFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        CmdDelete(FullPath);
    MyPrintf(L"CSCDeleteW(%ws) -> %d\r\n", FullPath, CSCDeleteW(FullPath));
    while (CSCFindNextFileW(hFind, &sFind32, &Status, &PinCount, &HintFlags, &ftOrgTime)) {
        if (DeleteArg != NULL) {
            wcscpy(FullPath, DeleteArg);
            wcscat(FullPath, L"\\");
        } else {
            wcscpy(FullPath, L"");
        }
        wcscat(FullPath, sFind32.cFileName);
        if (sFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            CmdDelete(FullPath);
        MyPrintf(L"CSCDeleteW(%ws) -> %d\r\n", FullPath, CSCDeleteW(FullPath));
    }
    CSCFindClose(hFind);

AllDone:
	return (Error);
}

DWORD
CmdDeleteShadow(
    PWSTR DeleteShadowArg)
{
    HSHADOW hDir;
    HSHADOW hShadow;
    SHADOWINFO sSI;
    BOOL bResult;
    HANDLE hDBShadow = INVALID_HANDLE_VALUE;
    ULONG junk;
    ULONG Status = 0;
    ULONG hShare;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDeleteShadow(%ws)\r\n", DeleteShadowArg);

    hDBShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hDBShadow == INVALID_HANDLE_VALUE) {
        MyPrintf(L"CmdDeleteShadow:Failed open of shadow device\r\n");
        Status = GetLastError();
        goto AllDone;
    }

    swscanf(DeleteShadowArg, L"0x%x:0x%x", &hDir, &hShadow);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDeleteShadow: hDir:0x%x hShadow:0x%x\r\n", hDir, hShadow);

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hDir = hDir;
    sSI.hShadow = hShadow;

    bResult = DeviceIoControl(
                hDBShadow,                      // device 
                IOCTL_SHADOW_DELETE,            // control code
                (LPVOID)&sSI,                   // in buffer
                0,                              // inbuffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

    if (!bResult) {
        MyPrintf(
                L"CmdDeleteShadow:DeviceIoControl IOCTL_SHADOW_DELETE failed 0x%x\n",
                sSI.dwError);
        Status = sSI.dwError;
        goto AllDone;
    }

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDeleteShadow exit %d\r\n", Status);

    if (hDBShadow != INVALID_HANDLE_VALUE)
        CloseHandle(hDBShadow);

    return Status;
}

DWORD
CmdPinUnPin(
    BOOL fPin,
    PWSTR PinArg)
{
    BOOL fRet;
	HANDLE hFind;
	DWORD Error = ERROR_SUCCESS;
    DWORD Status = 0;
    DWORD PinCount = 0;
    DWORD HintFlags = 0;
	FILETIME ftOrgTime = {0};
	WIN32_FIND_DATAW sFind32 = {0};
    WCHAR FullPath[MAX_PATH];

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdPinUnPin(%d,%ws)\r\n", fPin, PinArg);

    if (fSwUser == TRUE && fSwSystem == TRUE) {
        MyPrintf(L"Can not use both /SYSTEM and /USER\r\n");
        goto AllDone;
    }

    if (fSwUser == TRUE) {
        if (fSwInherit == TRUE)
            HintFlags |= FLAG_CSC_HINT_PIN_INHERIT_USER;
        else
            HintFlags |= FLAG_CSC_HINT_PIN_USER;
    }
    if (fSwSystem == TRUE) {
        if (fSwInherit == TRUE)
            HintFlags |= FLAG_CSC_HINT_PIN_INHERIT_SYSTEM;
        else
            HintFlags |= FLAG_CSC_HINT_PIN_SYSTEM;
    }

    if (fSwRecurse == TRUE && fPin == TRUE) {
        MyPrintf(L"Can not pin recursively.\r\n");
        goto AllDone;
    }
    //
    // Pin/Unpin one file
    //
    if (fSwRecurse == FALSE) {
        if (fPin == TRUE) {
            fRet = CSCPinFileW(PinArg, HintFlags, &Status, &PinCount, &HintFlags);
        } else {
            fRet = CSCUnpinFileW(PinArg, HintFlags, &Status, &PinCount, &HintFlags);
        }

        if (fRet == FALSE) {
            Error = GetLastError();
            goto AllDone;
        }

        MyPrintf(
            L"%ws of %ws:\r\n"
            L"Status:                0x%x\r\n"
            L"PinCount:              %d\r\n"
            L"HintFlags:             0x%x\r\n",
                fPin ? L"Pin" : L"Unpin",
                PinArg,
                Status,
                PinCount,
                HintFlags);

        goto AllDone;
    }
    //
    // Unpin recursively, using eumeration
    //
    hFind = CSCFindFirstFileW(PinArg, &sFind32, &Status, &PinCount, &HintFlags, &ftOrgTime);
    if (hFind == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
        goto AllDone;
    }
    if (PinArg != NULL) {
        wcscpy(FullPath, PinArg);
        wcscat(FullPath, L"\\");
    } else {
        wcscpy(FullPath, L"");
    }
    wcscat(FullPath, sFind32.cFileName);
    if (sFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        CmdPinUnPin(fPin, FullPath);
    fRet = CSCUnpinFileW(FullPath, HintFlags, &Status, &PinCount, &HintFlags);
    MyPrintf(L"CSCUnpinFile(%ws) -> %d\r\n", FullPath, fRet);
    while (CSCFindNextFileW(hFind, &sFind32, &Status, &PinCount, &HintFlags, &ftOrgTime)) {
        if (PinArg != NULL) {
            wcscpy(FullPath, PinArg);
            wcscat(FullPath, L"\\");
        } else {
            wcscpy(FullPath, L"");
        }
        wcscat(FullPath, sFind32.cFileName);
        if (sFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            CmdPinUnPin(fPin, FullPath);
        fRet = CSCUnpinFileW(FullPath, HintFlags, &Status, &PinCount, &HintFlags);
        MyPrintf(L"CSCUnpinFile(%ws) -> %d\r\n", FullPath, fRet);
    }
    CSCFindClose(hFind);
                
AllDone:

    return Error;
}

DWORD
MyCscMergeProcW(
     LPCWSTR         lpszFullPath,
     DWORD           dwStatus,
     DWORD           dwHintFlags,
     DWORD           dwPinCount,
     WIN32_FIND_DATAW *lpFind32,
     DWORD           dwReason,
     DWORD           dwParam1,
     DWORD           dwParam2,
     DWORD_PTR       dwContext)
{
	if (dwReason == CSCPROC_REASON_BEGIN || dwReason == CSCPROC_REASON_MORE_DATA) {
        if (dwReason == CSCPROC_REASON_BEGIN) {
            MyPrintf( L"BEGIN[%ws][%d/%d]",
                (lpszFullPath) ? lpszFullPath : L"None",
                dwParam1,
                dwParam2);
        } else if (dwReason == CSCPROC_REASON_MORE_DATA) {
            MyPrintf( L"MORE_DATA[%ws][%d/%d]",
                (lpszFullPath) ? lpszFullPath : L"None",
                dwParam1,
                dwParam2);
        }
        if (fSwAbort) {
            MyPrintf(L":Abort\r\n");
            return CSCPROC_RETURN_ABORT;
        } else if (fSwSkip) {
            MyPrintf(L":Skip\r\n");
            return CSCPROC_RETURN_SKIP;
        } else if (fSwRetry) {
            MyPrintf(L"Retry\r\n");
            return CSCPROC_RETURN_RETRY;
        } else if (fSwAsk) {
            MyPrintf(L" - (R)etry/(A)bort/(S)kip/(C)ontinue:");
            return CscMergeFillAsk(lpszFullPath);
        } else {
            MyPrintf(L"Continue\r\n");
            return (DWORD)dwContext;
        }
    }

    MyPrintf( L"END[%ws]:", (lpszFullPath) ? lpszFullPath : L"None");
    if (dwParam2 == ERROR_SUCCESS) {
        MyPrintf(L"SUCCEEDED\r\n");
    } else {
        MyPrintf(L"ERROR=%d \r\n", dwParam2);
    }
    return (DWORD)dwContext;
}

DWORD
MyCscFillProcW(
     LPCWSTR         lpszFullPath,
     DWORD           dwStatus,
     DWORD           dwHintFlags,
     DWORD           dwPinCount,
     WIN32_FIND_DATAW *lpFind32,
     DWORD           dwReason,
     DWORD           dwParam1,
     DWORD           dwParam2,
     DWORD_PTR       dwContext)
{
	if (dwReason == CSCPROC_REASON_BEGIN || dwReason == CSCPROC_REASON_MORE_DATA) {
        if (dwReason == CSCPROC_REASON_BEGIN) {
            MyPrintf( L"BEGIN[%ws][%d/%d]",
                (lpszFullPath) ? lpszFullPath : L"None",
                dwParam1,
                dwParam2);
        } else if (dwReason == CSCPROC_REASON_MORE_DATA) {
            MyPrintf( L"MORE_DATA[%ws][%d/%d]",
                (lpszFullPath) ? lpszFullPath : L"None",
                dwParam1,
                dwParam2);
        }
        if (fSwAbort) {
            MyPrintf(L":Abort\r\n");
            return CSCPROC_RETURN_ABORT;
        } else if (fSwSkip) {
            MyPrintf(L":Skip\r\n");
            return CSCPROC_RETURN_SKIP;
        } else if (fSwRetry) {
            MyPrintf(L"Retry\r\n");
            return CSCPROC_RETURN_RETRY;
        } else if (fSwAsk) {
            MyPrintf(L" - (R)etry/(A)bort/(S)kip/(C)ontinue:");
            return CscMergeFillAsk(lpszFullPath);
        } else {
            MyPrintf(L"Continue\r\n");
            return (DWORD)dwContext;
        }
    }

    MyPrintf( L"END[%ws]:", (lpszFullPath) ? lpszFullPath : L"None");
    if (dwParam2 == ERROR_SUCCESS) {
        MyPrintf(L"SUCCEEDED\r\n");
    } else {
        MyPrintf(L"ERROR=%d \r\n", dwParam2);
    }
    return (DWORD)dwContext;
}

DWORD
CscMergeFillAsk(LPCWSTR lpszFullPath)
{
    WCHAR wch;
    ULONG ulid;
    LONG cnt;
    WCHAR rgwch[256];
    PWCHAR lpBuff = NULL;

    do {
        lpBuff = rgwch;
        memset(rgwch, 0, sizeof(rgwch));
        if (!fgetws(rgwch, sizeof(rgwch)/sizeof(WCHAR), stdin))
           break;
        // Chop leading blanks
        if (lpBuff != NULL)
            while (*lpBuff != L'\0' && *lpBuff == L' ')
                lpBuff++;

        cnt = swscanf(lpBuff, L"%c", &wch);

        if (!cnt)
            continue;

        switch (wch) {
            case L's': case L'S':
                return CSCPROC_RETURN_SKIP;
            case L'c': case L'C':
                return CSCPROC_RETURN_CONTINUE;
            case L'a': case L'A':
                return CSCPROC_RETURN_ABORT;
            case L'r': case L'R':
                return CSCPROC_RETURN_RETRY;
        }
    } while (1);

    return CSCPROC_RETURN_CONTINUE;
}

DWORD
MyEncryptDecryptProcW(
     LPCWSTR         lpszFullPath,
     DWORD           dwStatus,
     DWORD           dwHintFlags,
     DWORD           dwPinCount,
     WIN32_FIND_DATAW *lpFind32,
     DWORD           dwReason,
     DWORD           dwParam1,
     DWORD           dwParam2,
     DWORD_PTR       dwContext)
{
	if (dwReason == CSCPROC_REASON_BEGIN) {
        return CSCPROC_RETURN_CONTINUE;
	} else if (dwReason == CSCPROC_REASON_MORE_DATA) {
		MyPrintf(L"%ws\r\n", (lpszFullPath != NULL) ? lpszFullPath : L"None");
        return CSCPROC_RETURN_CONTINUE;
    }
    //
    // CSC_PROC_END
    //
    if (dwParam2 == ERROR_SUCCESS) {
        MyPrintf(L"Succeeded\r\n");
    } else {
        MyPrintf(L"Error=%d \r\n", dwParam2);
    }
	return CSCPROC_RETURN_CONTINUE;
}

DWORD
MyEnumForStatsProcW(
     LPCWSTR         lpszFullPath,
     DWORD           dwStatus,
     DWORD           dwHintFlags,
     DWORD           dwPinCount,
     WIN32_FIND_DATAW *lpFind32,
     DWORD           dwReason,
     DWORD           dwParam1,
     DWORD           dwParam2,
     DWORD_PTR       dwContext)
{
	if (dwReason == CSCPROC_REASON_BEGIN) {
		MyPrintf(L"(1)%ws ", (lpszFullPath != NULL) ? lpszFullPath : L"None");
        if (lpFind32 != NULL)
            MyPrintf(L"[%ws]\r\n", lpFind32->cFileName);
        MyPrintf(L" Status=0x%02x HintFlags=0x%02x "
                 L"Pincount=%3d Reason=0x%x Param1=0x%x Param2=0x%x\r\n",
                        dwStatus,
                        dwHintFlags,
                        dwPinCount,
                        dwReason,
                        dwParam1,
                        dwParam2);
        return CSCPROC_RETURN_CONTINUE;
	} else if (dwReason == CSCPROC_REASON_MORE_DATA) {
		MyPrintf(L"(2)%ws ", (lpszFullPath != NULL) ? lpszFullPath : L"None");
        if (lpFind32 != NULL)
            MyPrintf(L" %ws\r\n", lpFind32->cFileName);
        MyPrintf(L" Status=0x%02x HintFlags=0x%02x "
                 L"Pincount=%3d Reason=0x%x Param1=0x%x Param2=0x%x\r\n",
                        dwStatus,
                        dwHintFlags,
                        dwPinCount,
                        dwReason,
                        dwParam1,
                        dwParam2);
        return CSCPROC_RETURN_CONTINUE;
    }
    //
    // CSC_PROC_END
    //
    MyPrintf(L"(3)%ws\r\n", (lpszFullPath != NULL) ? lpszFullPath : L"None");
    if (dwParam2 == ERROR_SUCCESS) {
        MyPrintf(L"Succeeded\r\n");
    } else {
        MyPrintf(L"Error=%d \r\n", dwParam2);
    }
	return CSCPROC_RETURN_CONTINUE;
}

struct {
    DWORD ShareStatus;
    LPWSTR ShareStatusName;
} ShareStatusStuff[] = {
    { FLAG_CSC_SHARE_STATUS_MODIFIED_OFFLINE, L"MODIFIED_OFFLINE " },
    { FLAG_CSC_SHARE_STATUS_CONNECTED, L"CONNECTED " },
    { FLAG_CSC_SHARE_STATUS_FILES_OPEN, L"FILES_OPEN " },
    { FLAG_CSC_SHARE_STATUS_FINDS_IN_PROGRESS, L"FINDS_IN_PROGRESS " },
    { FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP, L"DISCONNECTED_OP " },
    { FLAG_CSC_SHARE_MERGING, L"MERGING " },
    { 0, NULL }
};

DWORD
ShareStatusToEnglish(
    DWORD Status,
    LPWSTR OutputBuffer)
{
    ULONG i;

    OutputBuffer[0] = L'\0';
    for (i = 0; ShareStatusStuff[i].ShareStatusName; i++) {
        if (Status & ShareStatusStuff[i].ShareStatus)
            wcscat(OutputBuffer, ShareStatusStuff[i].ShareStatusName);
    }
    if ((Status & FLAG_CSC_SHARE_STATUS_CACHING_MASK) == FLAG_CSC_SHARE_STATUS_MANUAL_REINT)
        wcscat(OutputBuffer, L"MANUAL_REINT ");
    else if ((Status & FLAG_CSC_SHARE_STATUS_CACHING_MASK) == FLAG_CSC_SHARE_STATUS_AUTO_REINT)
        wcscat(OutputBuffer, L"AUTO_REINT ");
    else if ((Status & FLAG_CSC_SHARE_STATUS_CACHING_MASK) == FLAG_CSC_SHARE_STATUS_VDO)
        wcscat(OutputBuffer, L"VDO ");
    else if ((Status & FLAG_CSC_SHARE_STATUS_CACHING_MASK) == FLAG_CSC_SHARE_STATUS_NO_CACHING)
        wcscat(OutputBuffer, L"NO_CACHING ");
    return 0;
}

struct {
    DWORD FileStatus;
    LPWSTR FileStatusName;
} FileStatusStuff[] = {
    { FLAG_CSC_COPY_STATUS_DATA_LOCALLY_MODIFIED, L"DATA_LOCALLY_MODIFIED " },
    { FLAG_CSC_COPY_STATUS_ATTRIB_LOCALLY_MODIFIED, L"ATTRIB_LOCALLY_MODIFIED " },
    { FLAG_CSC_COPY_STATUS_TIME_LOCALLY_MODIFIED, L"TIME_LOCALLY_MODIFIED " },
    { FLAG_CSC_COPY_STATUS_STALE, L"STALE " },
    { FLAG_CSC_COPY_STATUS_LOCALLY_DELETED, L"LOCALLY_DELETED " },
    { FLAG_CSC_COPY_STATUS_SPARSE, L"SPARSE " },
    { FLAG_CSC_COPY_STATUS_ORPHAN, L"ORPHAN " },
    { FLAG_CSC_COPY_STATUS_SUSPECT, L"SUSPECT " },
    { FLAG_CSC_COPY_STATUS_LOCALLY_CREATED, L"LOCALLY_CREATED " },
    { 0x00010000, L"USER_READ " },
    { 0x00020000, L"USER_WRITE " },
    { 0x00040000, L"GUEST_READ " },
    { 0x00080000, L"GUEST_WRITE " },
    { 0x00100000, L"OTHER_READ " },
    { 0x00200000, L"OTHER_WRITE " },
    { FLAG_CSC_COPY_STATUS_IS_FILE, L"IS_FILE " },
    { FLAG_CSC_COPY_STATUS_FILE_IN_USE, L"FILE_IN_USE " },
    { 0, NULL }
};

DWORD
FileStatusToEnglish(
    DWORD Status,
    LPWSTR OutputBuffer)
{
    ULONG i;

    OutputBuffer[0] = L'\0';
    for (i = 0; FileStatusStuff[i].FileStatusName; i++) {
        if (Status & FileStatusStuff[i].FileStatus)
            wcscat(OutputBuffer, FileStatusStuff[i].FileStatusName);
    }
    return 0;
}

struct {
    DWORD HintFlag;
    LPWSTR HintName;
} HintStuff[] = {
    { FLAG_CSC_HINT_PIN_USER, L"PIN_USER " },
    { FLAG_CSC_HINT_PIN_INHERIT_USER, L"PIN_INHERIT_USER " },
    { FLAG_CSC_HINT_PIN_INHERIT_SYSTEM, L"PIN_INHERIT_SYSTEM " },
    { FLAG_CSC_HINT_CONSERVE_BANDWIDTH, L"CONSERVE_BANDWIDTH " },
    { FLAG_CSC_HINT_PIN_SYSTEM, L"PIN_SYSTEM " },
    { 0, NULL }
};

DWORD
HintsToEnglish(
    DWORD Hint,
    LPWSTR OutputBuffer)
{
    ULONG i;

    OutputBuffer[0] = L'\0';
    for (i = 0; HintStuff[i].HintName; i++) {
        if (Hint & HintStuff[i].HintFlag)
            wcscat(OutputBuffer, HintStuff[i].HintName);
    }
    return 0;
}

BOOLEAN
LooksToBeAShare(LPWSTR Name)
{
    //
    // See if we have \\server\share or \\server\share\<something>
    // Assume a valid name passed in...
    //

    ULONG Len = wcslen(Name);
    ULONG i;
    ULONG SlashCount = 0;

    // Remove any trailing '\'s
    while (Len >= 1) {
        if (Name[Len-1] == L'\\') {
            Name[Len-1] = L'\0';
            Len--;
        } else {
            break;
        }
    }
    for (i = 0; Name[i]; i++) {
        if (Name[i] == L'\\')
            SlashCount++;
    }
    if (SlashCount > 3)
        return FALSE;

    return TRUE;
}

DWORD
CmdDisconnect(
    PWSTR DisconnectArg)
{
    HSHADOW hDir;
    SHADOWINFO sSI;
    BOOL bResult;
    HANDLE hDBShadow = INVALID_HANDLE_VALUE;
    ULONG junk;
    ULONG Status = 0;
    ULONG hShare;
    PWCHAR wCp;
    ULONG SlashCount = 0;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDisconnect(%ws)\r\n", DisconnectArg);

    GetFileAttributes(DisconnectArg);

    Status = GetLastError();
    if (Status != NO_ERROR)
        goto AllDone;

    SlashCount = 0;
    for (wCp = DisconnectArg; *wCp; wCp++) {
        if (*wCp == L'\\')
            SlashCount++;
        if (SlashCount == 3) {
            *wCp = L'\0';
            break;
        }
    }

    hDBShadow = CreateFile(
                    L"\\\\.\\shadow",
                    FILE_EXECUTE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hDBShadow == INVALID_HANDLE_VALUE) {
        MyPrintf(L"CmdDisconnect:Failed open of shadow device\r\n");
        Status = GetLastError();
        goto AllDone;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.cbBufferSize = (wcslen(DisconnectArg)+1) * sizeof(WCHAR);
    sSI.lpBuffer = DisconnectArg;

    bResult = DeviceIoControl(
                hDBShadow,                      // device 
                IOCTL_TAKE_SERVER_OFFLINE,      // control code
                (LPVOID)&sSI,                   // in buffer
                0,                              // inbuffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

    if (!bResult) {
        MyPrintf(L"CmdDisconnect:DeviceIoControl IOCTL_TAKE_SERVER_OFFLINE failed\n");
        Status = GetLastError();
        goto AllDone;
    }

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDisconnect exit %d\r\n", Status);

    if (hDBShadow != INVALID_HANDLE_VALUE)
        CloseHandle(hDBShadow);

    return Status;
}

DWORD
CmdGetShadow(
    PWSTR GetShadowArg)
{
    DWORD Status = 0;
    DWORD dwErr = ERROR_SUCCESS;
    HANDLE hDBShadow = INVALID_HANDLE_VALUE;
    HSHADOW hShadow = 0;
    HSHADOW hDir = 0;
    WIN32_FIND_DATAW sFind32 = {0};
    SHADOWINFO sSI = {0};
    PWCHAR wCp = NULL;
    BOOL bResult = FALSE;
    DWORD junk;
    WCHAR TimeBuf1[40];
    WCHAR TimeBuf2[40];
    WCHAR TimeBuf3[40];

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdGetShadow(%ws)\r\n", GetShadowArg);

    if (GetShadowArg == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto AllDone;
    }

    swscanf(GetShadowArg, L"%x:", &hDir);
    for (wCp = GetShadowArg; *wCp && *wCp != L':'; wCp++)
        ;
    if (*wCp != L':') {
        dwErr = ERROR_INVALID_PARAMETER;
        goto AllDone;
    }
    wCp++;
    if (wcslen(wCp) >= MAX_PATH) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto AllDone;
    }
    wcscpy(sFind32.cFileName, wCp);

    if (fSwDebug == TRUE)
        MyPrintf(L"hDir=0x%x cFileName=[%ws]\r\n", hDir, sFind32.cFileName);

    hDBShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hDBShadow == INVALID_HANDLE_VALUE) {
        MyPrintf(L"CmdGetShadow:Failed open of shadow device\r\n");
        dwErr = GetLastError();
        goto AllDone;
    }

    sSI.hDir = hDir;
    sSI.lpFind32 = &sFind32;

    bResult = DeviceIoControl(
                hDBShadow,                      // device 
                IOCTL_GETSHADOW,                // control code
                (LPVOID)&sSI,                   // in buffer
                0,                              // inbuffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

    if (!bResult) {
        MyPrintf(L"CmdGetShadow:DeviceIoControl IOCTL_GETSHADOW failed\n");
        dwErr = GetLastError();
        goto AllDone;
    }

    ConvertGmtTimeToString(sFind32.ftCreationTime, TimeBuf1);
    ConvertGmtTimeToString(sFind32.ftLastAccessTime, TimeBuf2);
    ConvertGmtTimeToString(sFind32.ftLastWriteTime, TimeBuf3);

    MyPrintf(L"\r\n");
    MyPrintf(L"%ws:\r\n"
             L"   Size=0x%x:0x%x Attr=0x%x\r\n"
             L"   CreationTime:   %ws\r\n"
             L"   LastAccessTime: %ws\r\n"
             L"   LastWriteTime:  %ws\r\n",
                sFind32.cFileName,
                sFind32.nFileSizeHigh,
                sFind32.nFileSizeLow,
                sFind32.dwFileAttributes,
                TimeBuf1,
                TimeBuf2,
                TimeBuf3);
    MyPrintf(L"   hShare=0x%x hDir=0x%x hShadow=0x%x Status=0x%x HintFlags=0x%x\r\n",
                    sSI.hShare,
                    sSI.hDir,
                    sSI.hShadow,
                    sSI.uStatus,
                    sSI.ulHintFlags);
    MyPrintf(L"\r\n");

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdGetShadowArg exit %d\r\n", Status);

    if (hDBShadow != INVALID_HANDLE_VALUE)
        CloseHandle(hDBShadow);

    return dwErr;
}

DWORD
CmdGetShadowInfo(
    PWSTR GetShadowInfoArg)
{
    DWORD Status = 0;
    DWORD dwErr = ERROR_SUCCESS;
    HANDLE hDBShadow = INVALID_HANDLE_VALUE;
    HSHADOW hShadow = 0;
    HSHADOW hDir = 0;
    WIN32_FIND_DATAW sFind32 = {0};
    SHADOWINFO sSI = {0};
    BOOL bResult = FALSE;
    DWORD junk;
    WCHAR TimeBuf1[40];
    WCHAR TimeBuf2[40];
    WCHAR TimeBuf3[40];

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdGetShadowInfo(%ws)\r\n", GetShadowInfoArg);

    if (GetShadowInfoArg == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto AllDone;
    }

    swscanf(GetShadowInfoArg, L"%x:%x", &hDir, &hShadow);

    if (fSwDebug == TRUE)
        MyPrintf(L"hDir=0x%x hShadow=0x%x\r\n", hDir, hShadow);

    hDBShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hDBShadow == INVALID_HANDLE_VALUE) {
        MyPrintf(L"CmdGetShadowInfo:Failed open of shadow device\r\n");
        dwErr = GetLastError();
        goto AllDone;
    }

    sSI.hDir = hDir;
    sSI.hShadow = hShadow;
    sSI.lpFind32 = &sFind32;

    bResult = DeviceIoControl(
                hDBShadow,                      // device 
                IOCTL_SHADOW_GET_SHADOW_INFO,   // control code
                (LPVOID)&sSI,                   // in buffer
                0,                              // inbuffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

    if (!bResult) {
        MyPrintf(L"CmdGetShadowInfo:DeviceIoControl IOCTL_SHADOW_GET_SHADOW_INFO failed\n");
        dwErr = GetLastError();
        goto AllDone;
    }

    ConvertGmtTimeToString(sFind32.ftCreationTime, TimeBuf1);
    ConvertGmtTimeToString(sFind32.ftLastAccessTime, TimeBuf2);
    ConvertGmtTimeToString(sFind32.ftLastWriteTime, TimeBuf3);

    MyPrintf(L"\r\n");
    MyPrintf(L"%ws:\r\n"
             L"   Size=0x%x:0x%x Attr=0x%x\r\n"
             L"   CreationTime:   %ws\r\n"
             L"   LastAccessTime: %ws\r\n"
             L"   LastWriteTime:  %ws\r\n",
                sFind32.cFileName,
                sFind32.nFileSizeHigh,
                sFind32.nFileSizeLow,
                sFind32.dwFileAttributes,
                TimeBuf1,
                TimeBuf2,
                TimeBuf3);
    MyPrintf(L"\r\n");

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdGetShadowInfoArg exit %d\r\n", Status);

    if (hDBShadow != INVALID_HANDLE_VALUE)
        CloseHandle(hDBShadow);

    return dwErr;
}

DWORD
CmdShareId(
    PWSTR ShareIdArg)
{
    DWORD dwErr = ERROR_SUCCESS;
    ULONG ShareId = 0;
    BOOL fRet;
    WCHAR Buffer[100];
    ULONG BufSize = sizeof(Buffer);
    HMODULE hmodCscDll = LoadLibrary(TEXT("cscdll.dll"));
    CSCSHAREIDTOSHARENAME pCSCShareIdToShareName = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdShareId(%ws)\r\n", ShareIdArg);

    if (ShareIdArg == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto AllDone;
    }

    swscanf(ShareIdArg, L"%x", &ShareId);

    if (fSwDebug == TRUE)
        MyPrintf(L"ShareId=0x%x\r\n", ShareId);

    if (hmodCscDll == NULL) {
        dwErr = GetLastError();
        goto AllDone;
    }

    pCSCShareIdToShareName = (CSCSHAREIDTOSHARENAME) GetProcAddress(
                                                        hmodCscDll,
                                                        "CSCShareIdToShareName");
    if (pCSCShareIdToShareName == NULL) {
        dwErr = GetLastError();
        goto AllDone;
    }

    fRet = (pCSCShareIdToShareName)(ShareId, (PBYTE)Buffer, &BufSize);
    if (fRet == FALSE) {
        dwErr = GetLastError();
        goto AllDone;
    }

    MyPrintf(L"ShareId 0x%x  = %ws\r\n", ShareId, Buffer);

AllDone:

    if (hmodCscDll != NULL)
        FreeLibrary(hmodCscDll);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdShareIdToShareName exit %d\r\n", dwErr);

    return dwErr;
}

DWORD
CmdExclusionList(
    PWSTR ExclusionListArg)
{
    HSHADOW hDir;
    SHADOWINFO sSI;
    BOOL bResult;
    HANDLE hDBShadow = INVALID_HANDLE_VALUE;
    ULONG junk;
    ULONG Status = 0;
    ULONG hShare;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdExclusionList(%ws)\r\n", ExclusionListArg);

    if (ExclusionListArg == NULL) {
        ExclusionListArg = vtzDefaultExclusionList;
    }
    MyPrintf(L"Setting exclusion list to \"%ws\"\r\n", ExclusionListArg);

    hDBShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hDBShadow == INVALID_HANDLE_VALUE) {
        MyPrintf(L"CmdExclusionList:Failed open of shadow device\r\n");
        Status = GetLastError();
        goto AllDone;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uSubOperation = SHADOW_SET_EXCLUSION_LIST;
    sSI.lpBuffer = ExclusionListArg;
    sSI.cbBufferSize = (wcslen(ExclusionListArg)+1) * sizeof(WCHAR);

    bResult = DeviceIoControl(
                hDBShadow,                      // device 
                IOCTL_DO_SHADOW_MAINTENANCE,    // control code
                (LPVOID)&sSI,                   // in buffer
                0,                              // inbuffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdExclusionList exit %d\r\n", Status);

    if (hDBShadow != INVALID_HANDLE_VALUE)
        CloseHandle(hDBShadow);

    return Status;
}

DWORD
CmdBWConservationList(
    PWSTR BWConservationListArg)
{
    HSHADOW hDir;
    SHADOWINFO sSI;
    BOOL bResult;
    HANDLE hDBShadow = INVALID_HANDLE_VALUE;
    ULONG junk;
    ULONG Status = 0;
    ULONG hShare;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdBWConservationList(%ws)\r\n", BWConservationListArg);

    if (BWConservationListArg == NULL) {
        BWConservationListArg = L" ";
    }

    MyPrintf(L"Setting BWConservation list to \"%ws\"\r\n", BWConservationListArg);

    hDBShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hDBShadow == INVALID_HANDLE_VALUE) {
        MyPrintf(L"CmdBWConservationList:Failed open of shadow device\r\n");
        Status = GetLastError();
        goto AllDone;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uSubOperation = SHADOW_SET_BW_CONSERVE_LIST;
    sSI.lpBuffer = BWConservationListArg;
    sSI.cbBufferSize = (wcslen(BWConservationListArg)+1) * sizeof(WCHAR);

    bResult = DeviceIoControl(
                hDBShadow,                      // device 
                IOCTL_DO_SHADOW_MAINTENANCE,    // control code
                (LPVOID)&sSI,                   // in buffer
                0,                              // inbuffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdBWConservationList exit %d\r\n", Status);

    if (hDBShadow != INVALID_HANDLE_VALUE)
        CloseHandle(hDBShadow);

    return Status;
}

DWORD
CmdDetector(
    VOID)
{
    HSHADOW hDir;
    SHADOWINFO sSI;
    BOOL bResult;
    HANDLE hDBShadow = INVALID_HANDLE_VALUE;
    ULONG junk;
    ULONG Status = ERROR_SUCCESS;
    ULONG hShare;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDetector()\r\n");

    hDBShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hDBShadow == INVALID_HANDLE_VALUE) {
        MyPrintf(L"CmdDetector:Failed open of shadow device\r\n");
        Status = GetLastError();
        goto AllDone;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uSubOperation = SHADOW_SPARSE_STALE_DETECTION_COUNTER;

    bResult = DeviceIoControl(
                hDBShadow,                      // device 
                IOCTL_DO_SHADOW_MAINTENANCE,    // control code
                (LPVOID)&sSI,                   // in buffer
                0,                              // inbuffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

    if (bResult)
        MyPrintf(L"%d\r\n", sSI.dwError);
    else
        Status = sSI.dwError;

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDetector exit %d\r\n", Status);

    if (hDBShadow != INVALID_HANDLE_VALUE)
        CloseHandle(hDBShadow);

    return Status;
}

DWORD
CmdSwitches(
    VOID)
{
    HSHADOW hDir;
    SHADOWINFO sSI;
    BOOL bResult;
    HANDLE hDBShadow = INVALID_HANDLE_VALUE;
    ULONG junk;
    ULONG Status = ERROR_SUCCESS;
    ULONG hShare;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSwitches()\r\n");

    hDBShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hDBShadow == INVALID_HANDLE_VALUE) {
        MyPrintf(L"CmdSwitches:Failed open of shadow device\r\n");
        Status = GetLastError();
        goto AllDone;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uOp = SHADOW_SWITCH_GET_STATE;

    bResult = DeviceIoControl(
                hDBShadow,                      // device 
                IOCTL_SWITCHES,                 // control code
                (LPVOID)&sSI,                   // in buffer
                0,                              // inbuffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

    if (bResult) {
        MyPrintf(L"0x%08x", sSI.uStatus);
        if (sSI.uStatus != 0) {
            MyPrintf(L" (");
            if (sSI.uStatus & SHADOW_SWITCH_SHADOWING)
                MyPrintf(L"SHADOW_SWITCH_SHADOWING ");
            if (sSI.uStatus & SHADOW_SWITCH_LOGGING)
                MyPrintf(L"SHADOW_SWITCH_LOGGING ");
            if (sSI.uStatus & SHADOW_SWITCH_SPEAD_OPTIMIZE)
                MyPrintf(L"SHADOW_SWITCH_SPEAD_OPTIMIZE ");
            MyPrintf(L")");
        }
        if ((sSI.uStatus & SHADOW_SWITCH_SHADOWING) == 0)
            MyPrintf(L" ... csc is disabled");
        else
            MyPrintf(L" ... csc is enabled");
        MyPrintf(L"\r\n");
    } else {
        Status = sSI.dwError;
    }

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSwitches exit %d\r\n", Status);

    if (hDBShadow != INVALID_HANDLE_VALUE)
        CloseHandle(hDBShadow);

    return Status;
}

DWORD
CmdGetSpace(
    VOID)
{
    DWORD Error = ERROR_SUCCESS;
    WCHAR szVolume[MAX_PATH];
    LARGE_INTEGER MaxSpace;
    LARGE_INTEGER CurrentSpace;
    DWORD TotalFiles;
    DWORD TotalDirs;
    BOOL fRet;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdGetSpace()\r\n");

    fRet = CSCGetSpaceUsageW(
            szVolume,
            sizeof(szVolume)/sizeof(WCHAR),
            &MaxSpace.HighPart,
            &MaxSpace.LowPart,
            &CurrentSpace.HighPart,
            &CurrentSpace.LowPart,
            &TotalFiles,
            &TotalDirs);

    if (fRet == FALSE) {
        Error = GetLastError();
        goto AllDone;
    }

    MyPrintf(
        L"Volume:         %ws\r\n"
        L"MaxSpace:       0x%x:0x%x (%d)\r\n"
        L"CurrentSpace:   0x%x:0x%x (%d)\r\n"
        L"TotalFiles:     %d\r\n"
        L"TotalDirs:      %d\r\n",
            szVolume,
            MaxSpace.HighPart,
            MaxSpace.LowPart,
            MaxSpace.LowPart,
            CurrentSpace.HighPart,
            CurrentSpace.LowPart,
            CurrentSpace.LowPart,
            TotalFiles,
            TotalDirs);

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdGetSpace exit %d\r\n", Error);

    return Error;
}

DWORD
CmdIsServerOffline(
    PWSTR IsServerOfflineArg)
{
    DWORD Error = ERROR_SUCCESS;
    BOOL fRet;
    BOOL fOffline = FALSE;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdIsServerOffline(%ws)\r\n", IsServerOfflineArg);

    fRet = CSCIsServerOfflineW(
            IsServerOfflineArg,
            &fOffline);

    if (fRet == FALSE) {
        Error = GetLastError();
        goto AllDone;
    }

    if (fOffline == TRUE)
        MyPrintf(L"Offline\r\n");
    else
        MyPrintf(L"Online\r\n");

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdIsServerOffline exit %d\r\n", Error);

    return Error;
}

DWORD
CmdSetShareStatus(
    PWSTR SetShareStatusArg)
{
    HSHADOW hDir;
    SHADOWINFO sSI;
    BOOL bResult;
    HANDLE hDBShadow = INVALID_HANDLE_VALUE;
    ULONG junk;
    ULONG Status = 0;
    ULONG StatusToSet = 0;
    ULONG hShare = 0;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSetShareStatus(%ws)\r\n", SetShareStatusArg);

    if (fSwSet == TRUE && fSwClear == TRUE) {
        MyPrintf(L"Can't have both SET and CLEAR\r\n");
        Status = ERROR_INVALID_PARAMETER;
        goto AllDone;
    }

    hDBShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hDBShadow == INVALID_HANDLE_VALUE) {
        MyPrintf(L"CmdSetShareStatus:Failed open of shadow device\r\n");
        Status = GetLastError();
        goto AllDone;
    }

    swscanf(SetShareStatusArg, L"%x:%x", &hShare, &StatusToSet);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSetShareStatus hShare=0x%x StatusToSet=0x%x\r\n", hShare, StatusToSet);

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hShare = hShare;
    if (fSwSet == TRUE) {
        sSI.uStatus = StatusToSet;
        sSI.uOp = SHADOW_FLAGS_OR;
    } else if (fSwClear == TRUE) {
        sSI.uStatus = ~StatusToSet;
        sSI.uOp = SHADOW_FLAGS_AND;
    } else {
        MyPrintf(L"Missing /SET or /CLEAR\r\n");
        Status = ERROR_INVALID_PARAMETER;
        goto AllDone;
    }

    bResult = DeviceIoControl(
                hDBShadow,                      // device 
                IOCTL_SET_SHARE_STATUS,         // control code
                (LPVOID)&sSI,                   // in buffer
                0,                              // inbuffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

    if (!bResult) {
        MyPrintf(L"CmdSetShareStatus:DeviceIoControl IOCTL_SET_SHARE_STATUS failed\n");
        Status = GetLastError();
        goto AllDone;
    }

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSetShareStatus exit %d\r\n", Status);

    if (hDBShadow != INVALID_HANDLE_VALUE)
        CloseHandle(hDBShadow);

    return Status;
}

#define MAX_OFFSETS 256
#define PAGESIZE 4096
ULONG OffsetArgs[MAX_OFFSETS];

DWORD
CmdRandW(
    PWSTR CmdRandWArg)
{

    DWORD dwError = ERROR_SUCCESS;
    DWORD dwFileSize;
    DWORD dwOffset;
    DWORD dwOffsetHigh;
    UCHAR uchData;
    
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    ULONG i;
    LONG WriteCount = 0;
    LONG PageCount = 0;
    PBYTE wArray = NULL;

    if (fSwDebug == TRUE) {
        MyPrintf(L"CmdRandW(%ws)\r\n", CmdRandWArg);
        if (fArgOffset == TRUE)
            MyPrintf(L"  OFFSET [%ws]\r\n", pwszOffsetArg);
    }

    srand( (unsigned)time( NULL ) );

    hFile = CreateFileW(
                    CmdRandWArg,                         // name
                    GENERIC_READ|GENERIC_WRITE,         // access mode
                    FILE_SHARE_READ|FILE_SHARE_WRITE,   // share mode
                    NULL,                               // security descriptor
                    OPEN_EXISTING,                      // create disposition
                    0,                                  // file statributes if created
                    NULL);                              // template handle
    if (hFile == INVALID_HANDLE_VALUE) {
        dwError = GetLastError();
        goto AllDone;
    }
    dwFileSize = GetFileSize(hFile, NULL);
    MyPrintf(L"File size = %d bytes\r\n", dwFileSize);

    if (fArgOffset == TRUE) {
        WriteCount = CountOffsetArgs(pwszOffsetArg, OffsetArgs);
        if (WriteCount == 0) {
            MyPrintf(L"No offsets specified, or  - nothing to do.\r\n");
            goto AllDone;
        } else if (WriteCount < 0) {
            MyPrintf(L"Error in offset list.  Exiting.\r\n");
            dwError = ERROR_INVALID_PARAMETER;
            goto AllDone;
        }
    } else {
        PageCount =  (dwFileSize / PAGESIZE);
        WriteCount = rand() % PageCount;
    }
    if (fSwDebug == TRUE) {
        wArray = calloc(1, PageCount * sizeof(BYTE));
        MyPrintf(L"There are %d pages in the file\r\n", PageCount);
    }
            
    if (dwFileSize == -1) {
        dwError = GetLastError();
        if (fSwDebug == TRUE)
            MyPrintf(L"GetFileSize() failed %d\r\n", dwError);
        goto AllDone;
    }
    if (dwFileSize == 0) {
        MyPrintf(L"0 sized file - nothing to do.\r\n");
        goto AllDone;
    }
    MyPrintf(L"Writing %d times\r\n", WriteCount);
    for (i = 0; i < (ULONG)WriteCount; ++i) {
        DWORD   dwReturn;
        
        if (fArgOffset == TRUE)
            dwOffset = OffsetArgs[i];
        else
            dwOffset = ((rand() % PageCount) * PAGESIZE) + (rand() % PAGESIZE);
        uchData = (UCHAR)rand();
        if (SetFilePointer(hFile, dwOffset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
            dwError = GetLastError();
            if (fSwDebug == TRUE)
                MyPrintf(L"SetFilePointer() failed %d\r\n", dwError);
            goto AllDone;
        }
        MyPrintf(L"writing 0x02%x Page %d offset %d (offset %d(0x%x))\r\n", uchData,
                        dwOffset / PAGESIZE,
                        dwOffset % PAGESIZE,
                        dwOffset,
                        dwOffset);
        if (wArray)
            wArray[dwOffset/PAGESIZE]++;
        if (!WriteFile(hFile, &uchData, 1, &dwReturn, NULL)) {
            dwError = GetLastError();
            if (fSwDebug == TRUE)
                MyPrintf(L"WriteFile() failed %d\r\n", dwError);
            goto AllDone;
        }
    }

    if (wArray) {
        for (i = 0; i < (ULONG)PageCount; i++) {
            MyPrintf(L"%d", wArray[i]);
            if ((i % 50) == 0)
                MyPrintf(L"\r\n");
        }
        MyPrintf(L"\r\n");
    }

    // If EOF is specified, truncate the file to a random length
    if (fSwEof == TRUE) {
        ULONG xx = rand() % 5;
        ULONG NewLen = (rand() * rand()) % (dwFileSize * 2);
        if (xx == 0 || xx == 1) {
            MyPrintf(L"New EOF = %d\r\n", NewLen);
            SetFilePointer(hFile, NewLen, 0, FILE_BEGIN);
            SetEndOfFile(hFile);
        } else {
            MyPrintf(L"No EOF change.\r\n");
        }
    }

AllDone:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (wArray)
        free(wArray);
    if (fSwDebug == TRUE)
        MyPrintf(L"CmdRandW exit %d\r\n", dwError);
    return dwError;
}




LONG
CountOffsetArgs(
    PWSTR OffsetArg,
    ULONG OffsetArray[])
{
    // Expect a string of the form "N,N,N,N" where each N can be hex OR decimal.
    // Store results in OffsetArray[]
    // Limit is MAX_OFFSETS offsets, to make things easy.

    ULONG i;
    PWCHAR wCp = OffsetArg;
    PWCHAR wNum = NULL;
    ULONG iRet;

    for (i = 0; i < MAX_OFFSETS; i++) {
        if (*wCp == L'\0')
            break;
        wNum = wCp;
        while (*wCp != L',' && *wCp != L'\0')
            wCp++;
        if (*wCp == L',')
            *wCp++ = L'\0';
        iRet = swscanf(wNum, L"%Li", &OffsetArray[i]);
        if (iRet <= 0)
            return -1;
    }
    if (fSwDebug == TRUE) {
        ULONG j;
        for (j = 0; j < i; j++)
            MyPrintf(L"[%d]-0x%x(%d)\r\n", j, OffsetArray[j], OffsetArray[j]);
        MyPrintf(L"CountOffsetArgs returning %d\r\n", i);
    }
    return i;
}

#if defined(CSCUTIL_INTERNAL)
DWORD
CmdBitcopy(
    PWSTR BitcopyArg)
{
	DWORD Error = ERROR_FILE_NOT_FOUND;
	LPWSTR  lpszTempName = NULL;

    if (!CSCCopyReplicaW(BitcopyArg, &lpszTempName)) {
        Error = GetLastError();
    } else {
        Error = ERROR_SUCCESS;
    }

	if (Error == ERROR_SUCCESS) {
        Error = DumpBitMap(lpszTempName);
        DeleteFile(lpszTempName);
    }

	return Error;
}
#endif // CSCUTIL_INTERNAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\util\cscutil\struct.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       struct.h
//
//-----------------------------------------------------------------------------

#ifndef _STRUCT_H
#define _STRUCT_H

//
// Globals
//

//
// Undocumented
//
extern BOOLEAN fSwDebug;

VOID
MyPrintf(
    PWCHAR format,
    ...);

VOID
MyFPrintf(
    HANDLE hHandle,
    PWCHAR format,
    ...);

typedef enum tagSHARESTATUS
{
    PathLocal,
    ShareOffline,
    ShareOnline,
    NoCSC
} SHARESTATUS;

//
// How we make args & switches
//

#define MAKEARG(x) \
    WCHAR Arg##x[] = L"/" L#x L":"; \
    LONG ArgLen##x = (sizeof(Arg##x) / sizeof(WCHAR)) - 1; \
    BOOLEAN fArg##x;

#define SWITCH(x) \
    WCHAR Sw##x[] = L"/" L#x ; \
    BOOLEAN fSw##x;

#endif _STRUCT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\util\cscutil\getinfo.c ===
#define UNICODE
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winioctl.h>
#include <shdcom.h>

#include <smbdebug.h>

#include "struct.h"

PBYTE InBuf[0x50];
PBYTE OutBuf = NULL;

#define STATUS_SUCCESS                   ((ULONG)0x00000000L)
#define STATUS_BUFFER_TOO_SMALL          ((ULONG)0xC0000023L)

PWCHAR CscStateArray[] = {
    L"Shadowing",
    L"Disconnected",
    L"TransitioningToShadowing",
    L"TransitioningtoDisconnected"
};


DWORD
CmdInfo(ULONG Cmd)
{
    BOOL bResult;
    HANDLE  hShadow=NULL;
    ULONG junk;
    PULONG pl = NULL;
    PIOCTL_GET_DEBUG_INFO_ARG pInfoArg = NULL;
    ULONG i;
    ULONG j;
    ULONG BufSize = 0x1000;
    ULONG Status = 0;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdInfo(0x%x)\r\n", Cmd);

TryAgain:

    OutBuf = malloc(BufSize);

    if (OutBuf == NULL) {
        MyPrintf(L"CmdInfo:Couldn't alloc memory\r\n");
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto AllDone;
    }

    hShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hShadow == INVALID_HANDLE_VALUE) {
        MyPrintf(L"CmdInfo:Failed open of shadow device\r\n");
        Status = GetLastError();
        goto AllDone;
    }

    memset(InBuf, 0, sizeof(InBuf));
    pl = (PULONG)InBuf;
    *pl = Cmd;

    bResult = DeviceIoControl(
                hShadow,                        // device 
                IOCTL_GET_DEBUG_INFO,           // control code
                (LPVOID)InBuf,                  // in buffer
                sizeof(InBuf),                  // inbuffer size
                (LPVOID)OutBuf,                 // out buffer
                BufSize,                        // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

    CloseHandle(hShadow);

    if (!bResult) {
        MyPrintf(L"CmdInfo:DeviceIoControl failed\n");
        Status = GetLastError();
        goto AllDone;
    }

    pInfoArg = (PIOCTL_GET_DEBUG_INFO_ARG) OutBuf;
    if (bResult && pInfoArg->Status == STATUS_SUCCESS) {
        if (Cmd == DEBUG_INFO_SERVERLIST) {
            if (pInfoArg->Version != 2 && pInfoArg->Version != 3 && pInfoArg->Version != 4) {
                MyPrintf(L"Incorrect version.\r\n");
                goto AllDone;
            }
            for (i = 0; i < pInfoArg->EntryCount; i++) {
                OFFSET_TO_POINTER(pInfoArg->ServerEntryObject[i].Name, OutBuf);
                OFFSET_TO_POINTER(pInfoArg->ServerEntryObject[i].DomainName, OutBuf);
                OFFSET_TO_POINTER(pInfoArg->ServerEntryObject[i].DfsRootName, OutBuf);
                OFFSET_TO_POINTER(pInfoArg->ServerEntryObject[i].DnsName, OutBuf);
                OFFSET_TO_POINTER(pInfoArg->ServerEntryObject[i].pNetRoots, OutBuf);
                for (j = 0; j < pInfoArg->ServerEntryObject[i].NetRootEntryCount; j++)
                    OFFSET_TO_POINTER(pInfoArg->ServerEntryObject[i].pNetRoots[j].Name, OutBuf);
            }
            MyPrintf(L"Status:        0x%x\r\n"
                     L"Version:       %d\r\n"
                     L"Entries:       %d\r\n",
                       pInfoArg->Status,
                       pInfoArg->Version,
                       pInfoArg->EntryCount);
            for (i = 0; i < pInfoArg->EntryCount; i++) {
                PWCHAR FlagDesc = NULL;
                MyPrintf(L"=================================================\r\n");
                MyPrintf(L"Name:                                    %ws\r\n"
                         L"DomainName:                              %ws\r\n"
                         L"ServerStatus:                            0x%x\r\n"
                         L"DfsRootName:                             %ws\r\n"
                         L"DnsName:                                 %ws\r\n"
                         L"SecuritySignaturesEnabled:               0x%x\r\n"
                         L"Server.CscState:                         0x%x (%ws)\r\n"
                         L"Sever.IsFakeDfsServerForOfflineUse:      0x%x\r\n"
                         L"Sever.IsPinnedOffline:                   0x%x\r\n"
                         L"NetRootEntryCount:                       0x%x\r\n"
                         L"=================================================\n",
                            pInfoArg->ServerEntryObject[i].Name,
                            pInfoArg->ServerEntryObject[i].DomainName,
                            pInfoArg->ServerEntryObject[i].ServerStatus,
                            pInfoArg->ServerEntryObject[i].DfsRootName,
                            pInfoArg->ServerEntryObject[i].DnsName,
                            pInfoArg->ServerEntryObject[i].SecuritySignaturesEnabled,
                            pInfoArg->ServerEntryObject[i].CscState,
                            CscStateArray[pInfoArg->ServerEntryObject[i].CscState],
                            pInfoArg->ServerEntryObject[i].IsFakeDfsServerForOfflineUse,
                            pInfoArg->ServerEntryObject[i].IsPinnedOffline,
                            pInfoArg->ServerEntryObject[i].NetRootEntryCount);
                for (j = 0; j < pInfoArg->ServerEntryObject[i].NetRootEntryCount; j++) {
                    switch (pInfoArg->ServerEntryObject[i].pNetRoots[j].CscFlags) {
                    case 0x0: FlagDesc = L"SMB_CSC_CACHE_MANUAL_REINT"; break;
                    case 0x4: FlagDesc = L"SMB_CSC_CACHE_AUTO_REINT"; break;
                    case 0x8: FlagDesc = L"SMB_CSC_CACHE_VDO"; break;
                    case 0xc: FlagDesc = L"SMB_CSC_NO_CACHING"; break;
                    default:  FlagDesc = L"<unknown>"; break;
                    }
                    MyPrintf(L"    Name:                       %ws\r\n"
                             L"    MaximalAccessRights:        0x%x\r\n"
                             L"    GuestMaximalAccessRights:   0x%x\r\n"
                             L"    DfsAware:                   0x%x\r\n"
                             L"    hShare:                     0x%x\r\n"
                             L"    hRootDir:                   0x%x\r\n"
                             L"    ShareStatus:                0x%x\r\n"
                             L"    CscFlags:                   0x%x (%ws)\r\n"
                             L"    CscEnabled:                 0x%x\r\n"
                             L"    CscShadowable:              0x%x\r\n"
                             L"    Disconnected:               0x%x\r\n",
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].Name,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].MaximalAccessRights,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].GuestMaximalAccessRights,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].DfsAware,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].hShare,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].hRootDir,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].ShareStatus,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].CscFlags,
                                FlagDesc,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].CscEnabled,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].CscShadowable,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].Disconnected);
                    if (j < pInfoArg->ServerEntryObject[i].NetRootEntryCount-1)
                        MyPrintf(L"    --------------------------------------------\r\n");
                }
                if (pInfoArg->ServerEntryObject[i].NetRootEntryCount == 0)
                    MyPrintf(L"     no entries\r\n");
            }
            MyPrintf(L"=================================================\r\n");
        } else if (Cmd == DEBUG_INFO_CSCFCBSLIST) {
            for (i = 0; i < pInfoArg->EntryCount; i++) {
                OFFSET_TO_POINTER(pInfoArg->FcbEntryObject[i].DfsPrefix, OutBuf);
                OFFSET_TO_POINTER(pInfoArg->FcbEntryObject[i].ActualPrefix, OutBuf);
            }
            MyPrintf(L"Status:        0x%x\r\n"
                   L"Version:       %d\r\n"
                   L"Entries:       %d\r\n",
                       pInfoArg->Status,
                       pInfoArg->Version,
                       pInfoArg->EntryCount);
            for (i = 0; i < pInfoArg->EntryCount; i++) {
                MyPrintf(L"=================================================\r\n");
                MyPrintf(L"MFlags:                     0x%x\r\n"
                         L"Tid:                        0x%x\r\n"
                         L"ShadowIsCorrupt:            0x%x\r\n"
                         L"hShadow:                    0x%x\r\n"
                         L"hParentDir:                 0x%x\r\n"
                         L"hShadowRenamed:             0x%x\r\n"
                         L"hParentDirRenamed:          0x%x\r\n"
                         L"ShadowStatus:               0x%x\r\n"
                         L"LocalFlags:                 0x%x\r\n"
                         L"LastComponentOffset:        0x%x\r\n"
                         L"LastComponentLength:        0x%x\r\n"
                         L"hShare:                     0x%x\r\n"
                         L"hRootDir:                   0x%x\r\n"
                         L"ShareStatus:                0x%x\r\n"
                         L"Flags:                      0x%x\r\n"
                         L"DfsPrefix:                  %s\r\n"
                         L"ActualPrefix:               %s\r\n",
                            pInfoArg->FcbEntryObject[i].MFlags,
                            pInfoArg->FcbEntryObject[i].Tid,
                            pInfoArg->FcbEntryObject[i].ShadowIsCorrupt,
                            pInfoArg->FcbEntryObject[i].hShadow,
                            pInfoArg->FcbEntryObject[i].hParentDir,
                            pInfoArg->FcbEntryObject[i].hShadowRenamed,
                            pInfoArg->FcbEntryObject[i].hParentDirRenamed,
                            pInfoArg->FcbEntryObject[i].ShadowStatus,
                            pInfoArg->FcbEntryObject[i].LocalFlags,
                            pInfoArg->FcbEntryObject[i].LastComponentOffset,
                            pInfoArg->FcbEntryObject[i].LastComponentLength,
                            pInfoArg->FcbEntryObject[i].hShare,
                            pInfoArg->FcbEntryObject[i].hRootDir,
                            pInfoArg->FcbEntryObject[i].ShareStatus,
                            pInfoArg->FcbEntryObject[i].Flags,
                            pInfoArg->FcbEntryObject[i].DfsPrefix,
                            pInfoArg->FcbEntryObject[i].ActualPrefix);
            }
        }
    } else if (bResult && pInfoArg->Status == STATUS_BUFFER_TOO_SMALL) {
        free(OutBuf);
        OutBuf = NULL;
        BufSize *= 2;
        goto TryAgain;
    }

AllDone:

    if (OutBuf != NULL)
        free(OutBuf);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdInfo exit %d\r\n", Status);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\util\cscutil\misc.c ===
//--------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       misc.c
//
//--------------------------------------------------------------------------

#define UNICODE 1

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <winldap.h>
#include <stdlib.h>
#include <dsgetdc.h>
#include <lm.h>
#include <rpc.h>

#include "struct.h"
#include "messages.h"

#define MAX_BUF_SIZE	10000

WCHAR MsgBuf[MAX_BUF_SIZE];
CHAR  AnsiBuf[MAX_BUF_SIZE*3];

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

VOID
MyFormatMessageText(
    HRESULT   dwMsgId,
    PWSTR     pszBuffer,
    DWORD     dwBufferSize,
    va_list   *parglist)
{
    DWORD dwReturn = 0;

    dwReturn = FormatMessage(
                            (dwMsgId >= MSG_FIRST_MESSAGE)
                                    ? FORMAT_MESSAGE_FROM_HMODULE
                                    : FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             dwMsgId,
                             LANG_USER_DEFAULT,
                             pszBuffer,
                             dwBufferSize,
                             parglist);

    if (dwReturn == 0)
        MyPrintf(L"Formatmessage failed %d\r\n", GetLastError());
}

VOID
ErrorMessage(
    IN HRESULT hr,
    ...)
{
    ULONG cch;
    va_list arglist;

    va_start(arglist, hr);
    MyFormatMessageText(hr, MsgBuf, ARRAYLEN(MsgBuf), &arglist);
    cch = WideCharToMultiByte(CP_OEMCP, 0,
                MsgBuf, wcslen(MsgBuf),
                AnsiBuf, MAX_BUF_SIZE*3,
                NULL, NULL);
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), AnsiBuf, cch, &cch, NULL);
    va_end(arglist);
}

VOID
MyPrintf(
    PWCHAR format,
    ...)
{
    ULONG cch;
    va_list va;

    va_start(va, format);
    wvsprintf(MsgBuf, format, va);
    cch = WideCharToMultiByte(CP_OEMCP, 0,
                MsgBuf, wcslen(MsgBuf),
                AnsiBuf, MAX_BUF_SIZE*3,
                NULL, NULL);
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), AnsiBuf, cch, &cch, NULL);
    va_end(va);
    return;
}

VOID
MyFPrintf(
    HANDLE hHandle,
    PWCHAR format,
    ...)
{
    ULONG cch;
    va_list va;

    va_start(va, format);
    wvsprintf(MsgBuf, format, va);
    cch = WideCharToMultiByte(CP_OEMCP, 0,
                MsgBuf, wcslen(MsgBuf),
                AnsiBuf, MAX_BUF_SIZE*3,
                NULL, NULL);
    WriteFile(hHandle, AnsiBuf, cch, &cch, NULL);
    va_end(va);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\util\rovdo\rovdo.c ===
#define UNICODE
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winioctl.h>
#include <shdcom.h>

CHAR *ProgName = "cscgetinfo";

CHAR buf[10000];

_cdecl
main(LONG argc, CHAR *argv[])
{
    FILE *fh1;
    FILE *fh2;

    fh1 = fopen("\\\\jharperdc1\\vdo\\foo.txt", "r");
    if (fh1 == NULL) {
        printf("Open #1 failed %d\n", GetLastError());
        goto AllDone;
    }
    printf("ok1\n");
    while (fread(buf, sizeof(buf), 1, fh1) != 0)
        printf(".");
    printf("\n");
    fh2 = fopen("\\\\jharperdc1\\vdo\\foo.txt", "r+");
    if (fh2 == NULL) {
        printf("Open #2 failed %d\n", GetLastError());
        goto AllDone;
    }
    printf("ok2\n");
AllDone:
    gets(buf);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\backpack.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    backpack.h

Abstract:

    This module contains the package for pseudo polling. When a caller
    requests the same operation and gets the same error return the rdr
    must prevent flooding the network by backing off requests. Examples
    of when this is desirable are receiving 0 bytes on consequtive reads
    and consequtive fails on a file lock.

    If the caller is flooding the network, the rdr will return the 0 bytes
    or lock fail to the user until NextTime. When NextTime is reached
    the network will be used.

Author:

    Colin Watson (colinw) 02-Jan-1991


Revision History:

    ColinWatson   [ColinW]       02-Jan-1991   Created
    Joe Linn      [JoeLinn]      10-Oct-1996   Lifted from rdr1 and massaged for rdr2


--*/

#ifndef _BACKPACK_
#define _BACKPACK_

typedef struct _THROTTLING_STATE {
    LARGE_INTEGER NextTime;          //  Do not access the network until
                            //   CurrentTime >= NextTime
    ULONG CurrentIncrement;  //  Number of Increments applied to calculate NextTime
    ULONG MaximumDelay;      //  Specifies slowest rate that we will back off to
                            //  NextTime <= CurrentTime + (Interval * MaximumDelay)
    LARGE_INTEGER Increment;//  {0,10000000} == 1 second
    ULONG NumberOfQueries;
}   THROTTLING_STATE, *PTHROTTLING_STATE;

//++
//
// VOID
// RxInitializeThrottlingState(
//     IN PTHROTTLING_STATE pBP,
//     IN ULONG Increment,
//     IN ULONG MaximumDelay
//     );
//
// Routine Description:
//
//     This routine is called to initialize the back off structure (usually in
//     an Icb).
//
// Arguments:
//
//     pBP         -   Supplies back pack data for this request.
//     Increment   -   Supplies the increase in delay in milliseconds, each time a request
//                     to the network fails.
//     MaximumDelay-   Supplies the longest delay the backoff package can introduce
//                     in milliseconds.
//
// Return Value:
//
//     None.
//
//--

#define RxInitializeThrottlingState( _pBP, _Increment, _MaximumDelay ) {  \
    if ((_Increment)>0) {                                               \
        (_pBP)->Increment.QuadPart = (_Increment) * 10000;              \
        (_pBP)->MaximumDelay = (_MaximumDelay) / (_Increment);          \
        (_pBP)->CurrentIncrement = 0;                                   \
    }}

//++
//
// VOID
// RxUninitializeBackPack(
//     IN PTHROTTLING_STATE pBP
//     )
//
// Routine Description:
//
//  Resets the Back Pack specified. Currently no work needed.
//
// Arguments:
//
//     pBP   -  Supplies back pack address.
//
// Return Value:
//
//     None.
//
//--

#define RxUninitializeBackPack( pBP ) ()

//  RxShouldRequestBeThrottled indicates when the request should not go to the network.

BOOLEAN
RxShouldRequestBeThrottled(
    IN PTHROTTLING_STATE pBP
    );

//  Register the last request as failed.

VOID
RxInitiateOrContinueThrottling (
    IN PTHROTTLING_STATE pBP
    );

//  Register the last request as worked.

//++
//
// VOID
// RxTerminateThrottling(
//     IN PTHROTTLING_STATE pBP
//     )
//
// Routine Description:
//
//  Sets the Delay to zero. This routine is called each time that
//  a network request succeeds to avoid the next request backing off.
//
// Arguments:
//
//     pBP   -  Supplies back pack address.
//
// Return Value:
//
//     None.
//
//--

#define RxTerminateThrottling( pBP ) ( (pBP)->CurrentIncrement = 0 )

//++
//
// VOID
// RxInitializeBackoffPackage (
//     VOID
//     )
//
// Routine Description:
//
//     This routine initializes the redirector back off package.
//
// Arguments:
//
//     None
//
// Return Value:
//
//    None.
//
//--

#define RxInitializeBackoffPackage( )

//++
//
// VOID
// RxUninitializeBackoffPackage (
//     VOID
//     )
//
// Routine Description:
//
//     This routine uninitializes the redirector back off package.
//
// Arguments:
//
//     None
//
// Return Value:
//
//    None.
//
//--

#define RxUninitializeBackoffPackage( )

#endif /* _BACKPACK_ */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\buffring.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    buffring.h

Abstract:

    This module defines the change buffering state requests related data structures in RDBSS.

Author:

    Balan Sethu Raman (SethuR) 11-Nov-95    Created

Notes:

    The buffering manager implementation consists of two primary data structures
    (1) CHANGE_BUFFERING_STATE_REQUEST and (2) BUFFERING_MANAGER.

    The BUFFERING_MANAGER tracks and initiates actions on all change buffering state
    requests generated by the various mini redirectors as well as the RDBSS.

    There are three lists associated with the buffering manager, i.e., the registration
    list, the dispatcher list and the handler list.

    The registration list contains all the requests initiated for which no processing
    has been done. All DPC level indications merely register the indication in this
    list. The access to this list is protected by a spin lock(RxStrucsupSpinLock).

    The dispatcher list contains all the requests for which the lookup has not been
    completed. This list is organized as a two tier list. The top level is based on
    the NetRootKey. Each entry for a NetRootKey in this list has an associated cluster
    of requests corresponding to the various SrvOpenKey's. This is the reason for
    ghaving two LIST_ENTRY's in the request data structure as well. The
    NetRootListEntry field is used for inter cluster threading and the listEntry
    field is used for intra cluster threading.

    The handler list consists of all the requests for which the lookup has been completed
    and are awaiting processing.

    The dispatcher list and the handler list access is protected by the buffering manager
    mutex.

    The three routines of interest to mini rdr writers are ...

    1) RxIndicateChangeOfBufferingState -- for registering the request.

    2) RxAssociateSrvOpenKey -- for associating a SRV_OPEN instance with the key.


    Note that the key associations are irreverisble and will last the lifetime of the
    associated SRV_OPEN.

    Also note that 0 and 0xffffffff are not valid keys for SRV_OPEN. It has special
    significance for the buffering manager.

--*/

#ifndef __BUFFRING_H__
#define __BUFFRING_H__

#define RX_REQUEST_PREPARED_FOR_HANDLING  (0x10000000)

typedef struct _CHANGE_BUFFERING_STATE_REQUEST_ {
   
    LIST_ENTRY ListEntry;

    ULONG Flags;

    PSRV_OPEN SrvOpen;
    
    PVOID SrvOpenKey;
    PVOID MRxContext;

} CHANGE_BUFFERING_STATE_REQUEST, *PCHANGE_BUFFERING_STATE_REQUEST;

typedef struct _RX_BUFFERING_MANAGER_ {

    BOOLEAN DispatcherActive;
    BOOLEAN HandlerInactive;
    BOOLEAN LastChanceHandlerActive;
    UCHAR Pad;
    
    KSPIN_LOCK SpinLock;

    //
    //  This count is always incremented and never reset. This provides us with
    //  a quick mechanism to establish if a buffering state change request has
    //  been received for a given srvcall since a point in time. 
    //
    
    LONG CumulativeNumberOfBufferingChangeRequests;
    
    LONG NumberOfUnhandledRequests;
    LONG NumberOfUndispatchedRequests;
    LONG NumberOfOutstandingOpens;
    
    LIST_ENTRY DispatcherList;
    LIST_ENTRY HandlerList;
    LIST_ENTRY LastChanceHandlerList;
    
    RX_WORK_QUEUE_ITEM DispatcherWorkItem;
    RX_WORK_QUEUE_ITEM HandlerWorkItem;
    RX_WORK_QUEUE_ITEM LastChanceHandlerWorkItem;
    
    FAST_MUTEX Mutex;
    LIST_ENTRY SrvOpenLists[1];

} RX_BUFFERING_MANAGER, *PRX_BUFFERING_MANAGER;

#define RxAcquireBufferingManagerMutex(BUFMAN) ExAcquireFastMutex( &(BUFMAN)->Mutex )

#define RxReleaseBufferingManagerMutex(BUFMAN) ExReleaseFastMutex( &(BUFMAN)->Mutex )

VOID
RxpProcessChangeBufferingStateRequests (
    PSRV_CALL SrvCall,
    BOOLEAN UpdateHandlerState
    );
VOID
RxProcessChangeBufferingStateRequests (
    PSRV_CALL SrvCall
    );
VOID
RxProcessFcbChangeBufferingStateRequest (
    PFCB Fcb
    );
VOID
RxPurgeChangeBufferingStateRequestsForSrvOpen(
    PSRV_OPEN SrvOpen
    );

VOID
RxCompleteSrvOpenKeyAssociation (
    IN OUT PSRV_OPEN SrvOpen
    );

VOID
RxInitiateSrvOpenKeyAssociation (
   IN OUT PSRV_OPEN SrvOpen 
   );

NTSTATUS
RxInitializeBufferingManager (
   PSRV_CALL SrvCall
   );
NTSTATUS
RxTearDownBufferingManager (
   PSRV_CALL SrvCall
   );

NTSTATUS
RxFlushFcbInSystemCache (
    IN PFCB Fcb,
    IN BOOLEAN SynchronizeWithLazyWriter
    );

NTSTATUS
RxPurgeFcbInSystemCache (
    IN PFCB Fcb,
    IN PLARGE_INTEGER FileOffset OPTIONAL,
    IN ULONG Length,
    IN BOOLEAN UninitializeCacheMaps,
    IN BOOLEAN  FlushFile 
    );

#endif __BUFFRING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\lowio.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lowio.h

Abstract:

    This module defines all of the structures and prototypes for Low IO.

Author:

    Joe Linn (JoeLinn)    8-17-94

Revision History:

--*/

#ifndef _RXLOWIO_
#define _RXLOWIO_

#include "mrx.h" // mini redirector related definitions ....

#ifndef WIN9X
extern FAST_MUTEX RxLowIoPagingIoSyncMutex;
#endif

#define RxLowIoIsMdlLocked(MDL)  ( \
      RxMdlIsLocked((MDL)) || RxMdlSourceIsNonPaged((MDL))   \
      )

#define RxLowIoIsBufferLocked(LOWIOCONTEXT)                          \
   ( ((LOWIOCONTEXT)->Operation > LOWIO_OP_WRITE )  ||               \
     ((LOWIOCONTEXT)->ParamsFor.ReadWrite.Buffer == NULL) ||         \
     (                                                               \
      ((LOWIOCONTEXT)->ParamsFor.ReadWrite.Buffer != NULL) &&        \
      RxLowIoIsMdlLocked(((LOWIOCONTEXT)->ParamsFor.ReadWrite.Buffer)) \
     )                                                               \
   )

typedef struct _LOWIO_PER_FCB_INFO {
    LIST_ENTRY PagingIoReadsOutstanding;
    LIST_ENTRY PagingIoWritesOutstanding;
} LOWIO_PER_FCB_INFO, *PLOWIO_PER_FCB_INFO;

PVOID
NTAPI
RxLowIoGetBufferAddress (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
NTAPI
RxLowIoPopulateFsctlInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

NTSTATUS
NTAPI
RxLowIoSubmit (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PLOWIO_COMPLETION_ROUTINE CompletionRoutine
    );

NTSTATUS
NTAPI
RxLowIoCompletion (
    PRX_CONTEXT RxContext
    );

VOID
NTAPI
RxInitializeLowIoContext (
    IN PRX_CONTEXT RxContext,
    IN ULONG Operation,
    OUT PLOWIO_CONTEXT LowIoContext
    );

VOID
RxInitializeLowIoPerFcbInfo (
    PLOWIO_PER_FCB_INFO LowIoPerFcbInfo
    );


#endif   // _RXLOWIO_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\fcb.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Fcb.h

Abstract:

    This module defines File Control Block data structures, by which we mean:

       1) File Control Blocks     (FCB)
       2) File Object Extensions  (FOXB)
       3) Net Roots               (NET_ROOT)
       4) ServerSide Open Context (SRV_OPEN)
       5) Server Call Context     (SRV_CALL)
       6) View of Net Roots       (V_NET_ROOT)

    The more complete description follows the prototypes.

Author:

    Joe Linn          [JoeLinn]   19-aug-1994

Revision History:

    Balan Sethu Raman [SethuR]   1-Aug-96

--*/

#ifndef _FCB_STRUCTS_DEFINED_
#define _FCB_STRUCTS_DEFINED_

#include "fcbtable.h"
#include "buffring.h"

typedef NODE_TYPE_CODE TYPE_OF_OPEN;

struct _FCB_INIT_PACKET;
typedef struct _FCB_INIT_PACKET *PFCB_INIT_PACKET;


/* -----------------------------------------------------------
       There are six important data structures in the wrapper that are shared with the
       various mini redirectors. These data structures come in two flavours -- the
       mini redirector flavour which contains only those fields that can be manipulated
       by the mini redirector and the RDBSS flavour defined here. The mini redirector
       flavour carries the prefix MRX_.

       The six data structures are SRV_CALL,NET_ROOT,V_NET_ROOT,FCB,SRV_OPEN and FOBX
       respectively.

       The global view of these structures is the following (information on each of the
       data structures follows the locking description )

       L O C K I N G  <-------

       There are two levels of lookup tables used: a global table for srvcalls
       and netroots and a table-per-netroot for fcbs.  This allows directory
       operations on different netroots to be almost completely noninterfering
       (once the connections are established).  Directory operations on the
       same netroot do intefere slightly.  The following table describes what
       locks you need:

       OPERATION         DATATYPE              LOCK REQUIRED

       create/finalize   srvcall/(v)netroot    exclusive on netnametablelock
       ref/deref/lookup  srvcall/(v)netroot    shared on netnametablelock (at least)

       create/finalize   fcb/srvopen/fobx      exclusive on netroot->fcbtablelock
       ref/deref/lookup  fcb/srvopen/fobx      shared on netroot->fcbtablelock

       Note that manipulations on srvopens and fobxs require the same lock as
       fcbs....this is simply a memory saving idea.  It would be
       straightforward to add another resource at the fcb level to remove this;
       a set of sharted resources could be used to decrease the probability of
       collision to an acceptably low level.

       R E F   C O U N T S  <---------------

       Each of the structures is reference counted. The counts are the
       following:

       refcount(srvcall) = number of netroots pointing to srvcall + DYNAMIC
       refcount(netroot) = number of fcbs pointing to netroot + DYNAMIC
       refcount(fcb)     = number of fcbs pointing to netroot + DYNAMIC
       refcount(srvopen) = number of fcbs pointing to netroot + DYNAMIC
       refcount(fobx)    = DYNAMIC

       In each case, dynamic refers to the number of callers that have
       referenced the structure without dereferencing it. The static part of
       the refcount is maintained by the routines themselves; for example,
       CreateNetRoot increments the refcount for the associated srvcall.
       Reference and Successful Lookups increment the reference counts;
       dereference decrements the count. Creates set the reference counts to 1,

       If you require both locks (like FinalizeNetFcb), you take the fcblock
       first AND THEN the global table lock. obviously, you release in the
       opposite order.

----------------------------------*/

//
// SRV_CALL
//
// A global list of the SRV_CALL structures is maintained in the global
// data.  Each SrvCall structure has stuff that is unique to a srv_call.
// Now, the rx doesn't know what this stuff is except for
//
//     0) signature and refcount
//     a) a name and associated table stuff
//     b) a list of associated NET_ROOTs
//     c) a set of timing parameters that control how often the subrx wants
//        to be called by the rx in different circumstances (i.e. idle timouts)
//     d) the minirdr id
//     .
//     .
//     z) whatever additional storage is request by the minirdr (or creator of the block).
//
// In fact, the Unicode name of the structure is carried in the structure itself
// at the end.  The extra space begins at the end of the known stuff so that a
// mini redirector can just refer to his extra space using the context fields

// These flags are not visible to the mini redirectors.

#define SRVCALL_FLAG_NO_CONNECTION_ALLOWED (0x10000)
#define SRVCALL_FLAG_NO_WRITES_ALLOWED     (0x20000)
#define SRVCALL_FLAG_NO_DELETES_ALLOWED    (0x40000)

#ifdef __cplusplus
typedef struct _SRV_CALL : public MRX_SRV_CALL {
#else //  !__cplusplus
typedef struct _SRV_CALL {

    //
    //  The portion of SRV_CALL visible to mini redirectors.
    //

    union {
        MRX_SRV_CALL;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
        };
    };
#endif // __cplusplus

    //
    //  The finalization of a SRV_CALL instance consists of two parts,
    //  destroying the association with all NET_ROOTS etc and freeing the
    //  memory. There can be a delay between these two and this field
    //  prevents thefirst step from being duplicated.
    //

    BOOLEAN UpperFinalizationDone;

    //  
    //  Name and Prefixtable entry for name lookups
    //

    RX_PREFIX_ENTRY PrefixEntry;

    //
    //  Current condition of the SRV_CALL, i.e., good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    ULONG SerialNumberForEnum;

    //
    //  Number of delayed close files
    //

    LONG NumberOfCloseDelayedFiles;

    //
    //  List of Contexts which are waiting for the SRV_CALL transitioning
    //  to be completed before resumption of processing. This typically
    //  happens when concurrent requests are directed at a server. One of
    //  these requests initiates the construction while the other requests
    //  are queued.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  List Entry to thread together all the SRV_CALL instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  Synchronization context for coordinating the purge operations on the
    //  files opened at this server.
    //

    PURGE_SYNCHRONIZATION_CONTEXT PurgeSyncronizationContext;

    //
    //  The Buffering manager for coordinating/processing the buffering state
    //  change requests of the files opened at the server.
    //

    RX_BUFFERING_MANAGER BufferingManager;
} SRV_CALL, *PSRV_CALL;

//
//  A NET_ROOT contains
//      0) signature and refcount
//      a) a name and associated table stuff
//      b) backpointer to the SRV_CALL structure
//      c) size information for the various substructures
//      d) a lookuptable of FCB structures
//      .
//      .
//      z) whatever additional storage is request by the minirdr (or creator of the block).
//
//  A NET_ROOT is what the rx wants to deal with.....not a server.
//  Accordingly, the rx calls down to open a netroot and the subrx is
//  responsible for opening a server and calling up to put the right
//  structures.
//

#define NETROOT_FLAG_ENCLOSED_ALLOCATED       ( 0x00010000 )
#define NETROOT_FLAG_DEVICE_NETROOT           ( 0x00020000 )
#define NETROOT_FLAG_FINALIZATION_IN_PROGRESS ( 0x00040000 )
#define NETROOT_FLAG_NAME_ALREADY_REMOVED     ( 0x00080000 )

#define NETROOT_INIT_KEY (0)

#ifdef __cplusplus
typedef struct _NET_ROOT : public MRX_NET_ROOT {
#else // !__cplusplus
typedef struct _NET_ROOT {

    //
    //  The porion of NET_ROOT instance visible to mini redirectors.
    //

    union {
        MRX_NET_ROOT;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
           PSRV_CALL SrvCall;
        };
    };
#endif //  __cplusplus

    //
    //  The finalization of a NET_ROOT instance consists of two parts,
    //  destroying the association with all V_NET_ROOTS etc and freeing the
    //  memory. There can be a delay between these two and this field
    //  prevents thefirst step from being duplicated.
    //

    BOOLEAN UpperFinalizationDone;

    //
    //  Current condition of the NET_ROOT, i.e., good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    //
    //  List of Contexts which are waiting for the NET_ROOT transitioning
    //  to be completed before resumption of processing. This typically
    //  happens when concurrent requests are directed at a server. One of
    //  these requests initiates the construction while the other requests
    //  are queued.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  List Entry to thread together all the NET_ROOT instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  Synchronization context for coordinating the purge operations on the
    //  files opened for this NET_ROOt
    //

    PURGE_SYNCHRONIZATION_CONTEXT PurgeSyncronizationContext;

    //
    //  The default V_NET_ROOT instance to be used on this NET_ROOT
    //

    PV_NET_ROOT DefaultVNetRoot;

    //
    //  list of V_NET_ROOTs associated with the NET_ROOT
    //

    LIST_ENTRY VirtualNetRoots;

    //
    //  the count of V_NET_ROOT instances associated with the NET_ROOT
    //

    ULONG NumberOfVirtualNetRoots;

    ULONG SerialNumberForEnum;

    //
    //  NET_ROOT name and prefix table entry
    //

    RX_PREFIX_ENTRY PrefixEntry;

    //
    //  the FCB's associated with this NET_ROOT
    //

    RX_FCB_TABLE FcbTable;
} NET_ROOT, *PNET_ROOT;

//
//  A V_NETROOT contains
//     0) signature and refcount
//     a) ptr to netroot and links.
//     b) name info for table lookup (prefix)
//     c) name for a prefix to be added to whatever name you see. this is for simulating a netroot
//     mapped not at the root of the actual netroot.
//

#ifdef __cplusplus
typedef struct _V_NET_ROOT : public MRX_V_NET_ROOT {
#else //  !__cplusplus
typedef struct _V_NET_ROOT {

    //
    //  the portion of V_NET_ROOT visible to mini redirectors
    //

    union {
        MRX_V_NET_ROOT;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
           PNET_ROOT NetRoot;
        };
    };
#endif //  __cplusplus

    //
    //  The finalization of a V_NET_ROOT instance consists of two parts,
    //  destroying the association with all FCBs etc and freeing the
    //  memory. There can be a delay between these two and this field
    //  prevents thefirst step from being duplicated.
    //

    BOOLEAN UpperFinalizationDone;

    BOOLEAN ConnectionFinalizationDone;

    //
    //  Current condition of the V_NET_ROOT, i.e., good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    //
    //  Additional reference for the Delete FSCTL. This field is long as
    //  opposed to a BOOLEAN eventhough it can have only one of two values
    //  0 or 1. This enables the usage of interlocked instructions
    //

    LONG AdditionalReferenceForDeleteFsctlTaken;

    //
    //  Prefix table entry and V_NET_ROOT name ( prefix table entry is inserted
    //  in the RxNetNameTable)
    //

    RX_PREFIX_ENTRY PrefixEntry;

    //
    //  this name is prepended to all fcbs (not currently used)
    //

    UNICODE_STRING NamePrefix;

    //
    //  amount of bytes required to get past the netroot
    //

    ULONG PrefixOffsetInBytes;

    //
    //  List entry to wire the V_NET_ROOT instance into a list of V_NET_ROOTS
    //  maintained in the NET_ROOT
    //

    LIST_ENTRY NetRootListEntry;

    ULONG SerialNumberForEnum;

    //
    //  List of Contexts which are waiting for the NET_ROOT transitioning
    //  to be completed before resumption of processing. This typically
    //  happens when concurrent requests are directed at a server. One of
    //  these requests initiates the construction while the other requests
    //  are queued.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  List Entry to thread together all the V_NET_ROOT instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;
} V_NET_ROOT, *PV_NET_ROOT;

#define FILESIZE_LOCK_DISABLED(x)

//
//  An FCB contains
//      0) FSRTL_COMMON_HEADER
//      1) a reference count
//      a) a name and associated table stuff
//      b) backpointer to the NET_ROOT structure
//      c) a list of SRV_OPEN structures
//      d) device object
//      e) dispatch table (not yet)
//      .
//      .
//      z) whatever additional storage is request by the minirdr (or creator of the block).
//
//  The FCB is pointed to by the FsContext Field in the file object.  The
//  rule is that all the guys sharing an FCB are talking about the same
//  file.  (unfortuantely, SMB servers are implemented today in such a way
//  that names are aliased so that two different names could be the same
//  actual file.....sigh!) The Fcb is the focal point of file
//  operations...since operations on the same FCB are actually on the same
//  file, synchronization is based on the Fcb rather than some higher level
//  (the levels described so far are lower, i.e.  farther from the user).
//  Again, we will provide for colocation of FCB/SRV_OPEN/FOBX to improve
//  paging behaviour.  We don't colocate the FCB and NET_ROOT because the
//  NET_ROOTs are not paged but FCBs usually are (i.e.  unless they are
//  paging files).
//
//  The Fcb record corresponds to every open file and directory and is is split up into
//  two portions a non paged part, i.e., an instance allocated in non paged pool and
//  a paged part. The former is the NON_PAGED_FCB and the later is referred to as FCB.
//  The FCB conatins a pointer to the corresponding NON_PAGED_FCB part. A backpointer
//  is maintained from the NON_PAGED_FCB to the FCB for debugging purposes in debug builds
//

typedef struct _NON_PAGED_FCB {

    //
    //  Struct type and size for debugging/tracking
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The following field contains a record of special pointers used by
    //  MM and Cache to manipluate section objects.  Note that the values
    //  are set outside of the file system.  However the file system on an
    //  open/create will set the file object's SectionObject field to point
    //  to this field
    //

    SECTION_OBJECT_POINTERS SectionObjectPointers;

    //
    //  This resource is used in the common fsrtl routines....allocated here for
    //  space locality.
    //

    ERESOURCE HeaderResource;

    //
    //  This resource is also used in the common fsrtl routines....allocated here for
    //  space locality.
    //

    ERESOURCE PagingIoResource;

#ifdef USE_FILESIZE_LOCK

    //
    //  This mutex protect the filesize during read/write
    //

    FAST_MUTEX FileSizeLock;

#endif

    //
    //  The list of contexts whose processing has been suspended pending the state
    //  transition of the FCB.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  This context is non-zero only if the file currently has asynchronous
    //  non-cached valid data length extending writes.  It allows
    //  synchronization between pending writes and other operations.
    //

    ULONG OutstandingAsyncWrites;

    //
    //  This event is set when OutstandingAsyncWrites transitions to zero.
    //

    PKEVENT OutstandingAsyncEvent;

    KEVENT TheActualEvent;

    //
    //  The mechanism for the mini redirectors to store additional information
    //

    PVOID MiniRdrContext[2];

    //
    //  This is the mutex that is inserted into the FCB_ADVANCED_HEADER
    //  FastMutex field
    //

    FAST_MUTEX AdvancedFcbHeaderMutex;

#if DBG
    PFCB FcbBackPointer;
#endif

} NON_PAGED_FCB, *PNON_PAGED_FCB;

typedef enum _FCB_CONDITION {
    FcbGood = 1,
    FcbBad,
    FcbNeedsToBeVerified
} FCB_CONDITION;

//
//  A enumerated type distinguishing the varios contexts under which the FCB resource
//  is accquired.
//

typedef enum _RX_FCBTRACKER_CASES {
    
    RX_FCBTRACKER_CASE_NORMAL,
    RX_FCBTRACKER_CASE_NULLCONTEXT,
    RX_FCBTRACKER_CASE_CBS_CONTEXT,
    RX_FCBTRACKER_CASE_CBS_WAIT_CONTEXT,
    RX_FCBTRACKER_CASE_MAXIMUM

} RX_FCBTRACKER_CASES;

#ifdef __cplusplus
typedef struct _FCB : public MRX_FCB {
#else //  !__cplusplus
typedef struct _FCB {
    
    //
    //  Entries are reference counted. ordinarily this would be at the beginning but
    //  in the case of FCB's it will follows the common header and fixed part
    //

    union {
        MRX_FCB;
        struct {
           FSRTL_ADVANCED_FCB_HEADER spacer;
           PNET_ROOT NetRoot;
        };
    };
#endif //  !__cplusplus

    //
    //  VNetroot for this FCB, if any
    //

    PV_NET_ROOT VNetRoot;  

    //
    //  Structure for fields that must be in non-paged pool.
    //

    PNON_PAGED_FCB NonPaged;

    //
    //  List Entry to thread together all the FCB instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  The resource accquisition mechanism gives preference to buffering state change
    //  processing over other requests. Therefor when a buffering state change is
    //  indicated all subsequent requests are shunted off to wait on a buffering state
    //  change completion event. This enables the actual buffering state change processing
    //  to complete in a timely fashion.
    //

    PKEVENT pBufferingStateChangeCompletedEvent;

    //
    //  Number of contexts awaiting buffering state change processing completion
    //

    LONG NumberOfBufferingStateChangeWaiters;

    //
    //  the name in the table is always a suffix of the name as viewed by the mini
    //  redirector. the string in the prefix entry is the name in the table....
    //  the "alreadyprefixedname: points to the whole name.
    //

    RX_FCB_TABLE_ENTRY FcbTableEntry;

    //
    //  the name alongwith the MRX_NET_ROOT prefix, i.e. fully qualified name
    //

    UNICODE_STRING PrivateAlreadyPrefixedName;

    //
    //  Indicates that the V_NET_ROOT related processing on finalization is complete
    //

    BOOLEAN UpperFinalizationDone;

    //
    //  the present state of the FCB, good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    //
    //  Pointer to the private dispatch table, if any.
    //

    PRX_FSD_DISPATCH_VECTOR PrivateDispatchVector;

    //
    //  the device object that owns this fcb
    //

    PRDBSS_DEVICE_OBJECT RxDeviceObject;

    PMINIRDR_DISPATCH MRxDispatch;

    //
    //  private fast dispatch table, if any. This allows lwio to add it's own hooks
    //

    PFAST_IO_DISPATCH MRxFastIoDispatch;

    //
    //  Whenever a  FCB instance is created a correpsonding SRV_OPEN and FOBX instance
    //  is also created. More than one SRV_OPEN can be associated with a given FCB and
    //  more than one FOBX is associated with a given SRV_OPEN. In a majority of the
    //  cases the number of SRV_OPENs associated with an FCB is one and the number of
    //  FOBX associated with a given SRV_OPEN is 1. In order to improve the spatial
    //  locality and the paging behaviour in such cases the allocation for the
    //  FCB also involves an allocation for the SRV_OPEN and FOBX.
    //

    //
    //  set initially to the internally allocated srv_open
    //

    PSRV_OPEN InternalSrvOpen;

    //
    //  set to internal fobx until allocated
    //

    PFOBX InternalFobx;

    //
    //  the shared access for each time this file/directory is opened.
    //

    SHARE_ACCESS ShareAccess;
    SHARE_ACCESS ShareAccessPerSrvOpens;

    //
    //  this information is returned when the file is opened. ..might as well
    //  cache it so that so that tandard info query can be handled on the client
    //  side
    //

    ULONG NumberOfLinks;

    //
    //  Cache these entries..... speeds up RxFastQueryBasicInfo().
    //

    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER LastChangeTime;

    //
    //  used to check by mini redirs in order to decide whether to update the FCB
    //

    ULONG ulFileSizeVersion;

    //
    //  The following field is used by the filelock module
    //  to maintain current byte range locking information.
    //

    FILE_LOCK FileLock;

    //
    //  do this wierdly so that I can call stuff be the inner or outer names
    //

    union {
#ifndef __cplusplus
        LOWIO_PER_FCB_INFO;
#endif // __cplusplus
        LOWIO_PER_FCB_INFO LowIoPerFcbInfo;
    };

#ifdef USE_FILESIZE_LOCK
    PFAST_MUTEX FileSizeLock;
#endif

    //
    //  The following field is used to verify that the Ea's for a file
    //  have not changed between calls to query for Ea's.  It is compared
    //  with a similar field in a Fobx.
    //
    //  IMPORTANT!! **** DO NOT MOVE THIS FIELD ****
    //
    //              The slack space in the union above is computed from
    //              the field offset of the EaModificationCount.
    //

    ULONG EaModificationCount;

#if DBG
    PNON_PAGED_FCB CopyOfNonPaged;     //  copy of NonPaged so we can zap the real pointer and still find it
#endif
#ifdef RDBSS_TRACKER
    ULONG FcbAcquires[RX_FCBTRACKER_CASE_MAXIMUM]; //  there are four types
    ULONG FcbReleases[RX_FCBTRACKER_CASE_MAXIMUM];
#else
#error tracker must be defined
#endif

    PCHAR PagingIoResourceFile;
    ULONG PagingIoResourceLine;

} FCB, *PFCB;

//
//  Here are the Fcb state fields.
//

#define FCB_STATE_SRVOPEN_USED                   ( 0x80000000 )
#define FCB_STATE_FOBX_USED                      ( 0x40000000 )
#define FCB_STATE_ADDEDBACKSLASH                 ( 0x20000000 )
#define FCB_STATE_NAME_ALREADY_REMOVED           ( 0x10000000 )
#define FCB_STATE_WRITECACHING_ENABLED           ( 0x08000000 )
#define FCB_STATE_WRITEBUFFERING_ENABLED         ( 0x04000000 )
#define FCB_STATE_READCACHING_ENABLED            ( 0x02000000 )
#define FCB_STATE_READBUFFERING_ENABLED          ( 0x01000000 )
#define FCB_STATE_OPENSHARING_ENABLED            ( 0x00800000 )
#define FCB_STATE_COLLAPSING_ENABLED             ( 0x00400000 )
#define FCB_STATE_LOCK_BUFFERING_ENABLED         ( 0x00200000 )
#define FCB_STATE_FILESIZECACHEING_ENABLED       ( 0x00100000 )
#define FCB_STATE_FILETIMECACHEING_ENABLED       ( 0x00080000 )
#define FCB_STATE_TIME_AND_SIZE_ALREADY_SET      ( 0x00040000 )
#define FCB_STATE_SPECIAL_PATH                   ( 0x00020000 )
#define FCB_STATE_FILE_IS_SHADOWED               ( 0x00010000 )
#define FCB_STATE_FILE_IS_DISK_COMPRESSED        ( 0x00008000 )
#define FCB_STATE_FILE_IS_BUF_COMPRESSED         ( 0x00004000 )
#define FCB_STATE_BUFFERSTATE_CHANGING           ( 0x00002000 )
#define FCB_STATE_FAKEFCB                        ( 0x00001000 )
#define FCB_STATE_DELAY_CLOSE                    ( 0x00000800 )
#define FCB_STATE_READAHEAD_DEFERRED             ( 0x00000100 )
#define FCB_STATE_ORPHANED                       ( 0x00000080 )
#define FCB_STATE_BUFFERING_STATE_CHANGE_PENDING ( 0x00000040 )
#define FCB_STATE_TEMPORARY                      ( 0x00000020 )
#define FCB_STATE_DISABLE_LOCAL_BUFFERING        ( 0x00000010 )
#define FCB_STATE_LWIO_ENABLED                   ( 0x00000008 )
#define FCB_STATE_PAGING_FILE                    ( 0x00000004 )
#define FCB_STATE_TRUNCATE_ON_CLOSE              ( 0x00000002 )
#define FCB_STATE_DELETE_ON_CLOSE                ( 0x00000001 )

#define FCB_STATE_BUFFERING_STATE_MASK    \
                    (( FCB_STATE_WRITECACHING_ENABLED           \
                          | FCB_STATE_WRITEBUFFERING_ENABLED    \
                          | FCB_STATE_READCACHING_ENABLED       \
                          | FCB_STATE_READBUFFERING_ENABLED     \
                          | FCB_STATE_OPENSHARING_ENABLED       \
                          | FCB_STATE_COLLAPSING_ENABLED        \
                          | FCB_STATE_LOCK_BUFFERING_ENABLED    \
                          | FCB_STATE_FILESIZECACHEING_ENABLED  \
                          | FCB_STATE_FILETIMECACHEING_ENABLED  ))
//
//  This is the MAX recursive resource limit.
//

#define MAX_FCB_ASYNC_ACQUIRE            (0xf000)

typedef struct _FCB_INIT_PACKET {
    PULONG pAttributes;             //  in the fcb this is DirentRxFlags;
    PULONG pNumLinks;               //  in the fcb this is NumberOfLinks;
    PLARGE_INTEGER pCreationTime;   //  these fields are the same as for the Fcb
    PLARGE_INTEGER pLastAccessTime;
    PLARGE_INTEGER pLastWriteTime;
    PLARGE_INTEGER pLastChangeTime;
    PLARGE_INTEGER pAllocationSize; //  common header fields
    PLARGE_INTEGER pFileSize;
    PLARGE_INTEGER pValidDataLength;
} FCB_INIT_PACKET;

//
//  A SRV_OPEN contains
//      0) signature and refcount
//      a) backpointer to the FCB
//      b) backpointer to the NET_ROOT   //maybe
//      c) a list of FOXB structures
//      d) access rights and collapsability status
//      .
//      .
//      z) whatever additional storage is request by the minirdr (or creator of the block).
//
//  The SRV_OPEN points to a structure describing a spevific open on the
//  server; multiple file objects and fileobject extensions (FOBXs) can
//  share the same srvopen if the access rights are correct.  For example,
//  this would be where the FID is stored for SMBs.  A list of these hangs
//  from the FCB.  Similarly, all fileobject extensionss that share the same
//  serverside open are listed together here.  Also here is information
//  about whether a new open of this FCB can share this serverside open
//  context; obviously the guys that pass the test on the list.
//

//
//  The SRVOPEN flags are split into two groups, i.e., visible to mini rdrs and invisible to mini rdrs.
//  The visible ones are defined above and the definitions for the invisible ones can be found
//  in fcb.h. The convention that has been adopted is that the lower 16 flags will be visible
//  to the mini rdr and the upper 16 flags will be reserved for the wrapper. This needs to be
//  enforced in defining new flags.
//

#define SRVOPEN_FLAG_ENCLOSED_ALLOCATED  (0x10000)
#define SRVOPEN_FLAG_FOBX_USED           (0x20000)
#define SRVOPEN_FLAG_SHAREACCESS_UPDATED (0x40000)

#ifdef __cplusplus
typedef struct _SRV_OPEN : public MRX_SRV_OPEN {
#else //  !__cplusplus
typedef struct _SRV_OPEN {

    //
    //  the portion of SRV_OPEN visible to all the mini redirectors.
    //

    union {
        MRX_SRV_OPEN;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;

           //
           //  the Fcb and VNetRoot for this srv_open
           //

           PFCB Fcb;       
           PV_NET_ROOT VNetRoot;
        };
    };
#endif //  !__cplusplus

    BOOLEAN UpperFinalizationDone;

    //
    //  the current condition of the SRV_OPEN, good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    //
    //  Buffering state manager token
    //

    LONG BufferingToken;

    //
    //  List Entry to thread together all the FCB instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  The list of contexts whose processing has been suspended pending the state
    //  transition of the SRV_OPEN.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  List Head for the list of FOBXs associated with this SRV_OPEN
    //

    LIST_ENTRY FobxList;

    //
    //  The colocated instance of FOBX that is allocated whenever a SRV_OPEN
    //  instance is allocated.
    //

    PFOBX InternalFobx;

    //
    //  the data structure for maintaining the mapping between the key
    //  associated with the SRV_OPEN instance by the mini redirector and
    //  the SRV_OPEN instance
    //

    union {
       LIST_ENTRY SrvOpenKeyList;
       ULONG SequenceNumber;
    };
    NTSTATUS OpenStatus;
} SRV_OPEN, *PSRV_OPEN;

#define RxWriteCachingAllowed(FCB,SRVOPEN) \
      (FlagOn( (FCB)->FcbState, FCB_STATE_WRITECACHING_ENABLED ) && \
       !FlagOn( (SRVOPEN)->Flags, SRVOPEN_FLAG_DONTUSE_WRITE_CACHING ))

#define SRVOPEN_INIT_KEY (0)

//
//  A FOBX contains
//     0) signature and refcount
//     a) backpointer to the FCB
//     b) backpointer to the SRV_OPEN
//     c) context information about this open
//     ...
//     z) whatever additional storage is request by the minirdr (or creator of the block).
//
//  The FOBX points to the "fileobject extension", i.e.  all the stuff that
//  is per fileobject is not stored there because the IO system provides
//  fixed size filesystem objects (not a dig BTW, that's just the decision).
//  The FOBX for any file object is referenced by the FsContext2 field in
//  the fileobject.  Even tho the FOBX is ordinarily a terminus in the
//  structure, it is currently refcounted anyway.

//  The FOBX flags are split into two groups, i.e., visible to mini rdrs and invisible to mini rdrs.
//  The visible ones are defined above and the definitions for the invisible ones can be found
//  in fcb.h. The convention that has been adopted is that the lower 16 flags will be visible
//  to the mini rdr and the upper 16 flags will be reserved for the wrapper. This needs to be
//  enforced in defining new flags.
//

#define FOBX_FLAG_MATCH_ALL               (0x10000)

//
//  This tells us whether we allocated buffers to hold search templates.
//

#define FOBX_FLAG_FREE_UNICODE            (0x20000)

//
//  These flags prevents cleanup from updating the modify time, etc.
//

#define FOBX_FLAG_USER_SET_LAST_WRITE     (0x40000)
#define FOBX_FLAG_USER_SET_LAST_ACCESS    (0x80000)
#define FOBX_FLAG_USER_SET_CREATION       (0x100000)
#define FOBX_FLAG_USER_SET_LAST_CHANGE    (0x200000)

//
//  This bit says the file object associated with this Fobx was opened for
//  read only access.
//

#define FOBX_FLAG_READ_ONLY               (0x400000)

//
//  the delete on close flag is used to track a file object that was opened with delete-on-close;
//  when this object is closed, we copy the bit to the fcb and make it global
//

#define FOBX_FLAG_DELETE_ON_CLOSE         (0x800000)

//
//  this bits is used by minirdrs that do not have NT semantics. for example, the smbmini has
//  to close a file before it can try a rename or delete. after the operation, we prevent people from
//  getting back in.
//

#define FOBX_FLAG_SRVOPEN_CLOSED          (0x1000000)

//
//  this bit is used to tell whether the original name was a UNC name so that
//  we can return the name the same way
//

#define FOBX_FLAG_UNC_NAME                (0x2000000)

//
//  this flag tells if this fobx is allocated as part of a larger structure
//

#define FOBX_FLAG_ENCLOSED_ALLOCATED      (0x4000000)

//
//  this flag specfies if the FOBX was included in the count of dormant
//  files against the server.
//

#define FOBX_FLAG_MARKED_AS_DORMANT       (0x8000000)

//
//  this flag notes down the fact that some writes have been issued on this FOBX
//  this is used to issue flushes on close
//

#define FOBX_FLAG_WRITES_ISSUED           (0x10000000)

#ifdef __cplusplus
typedef struct _FOBX : public MRX_FOBX {
#else //  !__cplusplus
typedef struct _FOBX {
    //
    //  the portion of FOBX visible to the mini redirectors
    //

    union {
        MRX_FOBX;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
           PSRV_OPEN SrvOpen;
        };
    };
#endif //  __cplusplus

    //
    //  a serial number....it wraps but not often
    //

    ULONG FobxSerialNumber;

    //
    //  list entry to wire the FOBX to the list of FOBXs maintained in
    //  the associated SRV_OPEN
    //

    LIST_ENTRY FobxQLinks;

    //
    //  list entry to gather all the FOBX instance marked for garbage collection
    //  scavenging
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  list entry to thread together all the FOBXs which have a pending close
    //  operation.
    //

    LIST_ENTRY ClosePendingList;

    BOOLEAN UpperFinalizationDone;
    BOOLEAN ContainsWildCards;
    BOOLEAN fOpenCountDecremented;

    //
    //  Parameters depending on the type of file opened, pipe/file etc.
    //

    union {

        struct {

            union {
#ifndef __cplusplus
                MRX_PIPE_HANDLE_INFORMATION;
#endif //  __cplusplus
                MRX_PIPE_HANDLE_INFORMATION PipeHandleInformation;
            };

            LARGE_INTEGER CollectDataTime;
            ULONG CollectDataSize;
            THROTTLING_STATE ThrottlingState;   //  for peek and read om msgmodepipes

            //
            //  these serialization Qs must be together
            //  and read must be the first
            //

            LIST_ENTRY ReadSerializationQueue;
            LIST_ENTRY WriteSerializationQueue;
        } NamedPipe;

        struct {
            RXVBO PredictedReadOffset;
            RXVBO PredictedWriteOffset;
            THROTTLING_STATE LockThrottlingState;   //  for locks
            LARGE_INTEGER LastLockOffset;
            LARGE_INTEGER LastLockRange;
        } DiskFile;
    } Specific;
} FOBX, *PFOBX;


#define FOBX_NUMBER_OF_SERIALIZATION_QUEUES 2

//
//  The RDBSS wrapper relies upon ref. counting to mark the instances of
//  various data structures. The following macros implement a debugging
//  mechanism to track/log the reference counts associated with various
//  data structures. A fine grained control to monitor each data structure
//  separately is provided. Each of these can be further controlled to either
//  print the tracking info or log it.
//

#define RDBSS_REF_TRACK_SRVCALL  (0x00000001)
#define RDBSS_REF_TRACK_NETROOT  (0x00000002)
#define RDBSS_REF_TRACK_VNETROOT (0x00000004)
#define RDBSS_REF_TRACK_NETFOBX  (0x00000008)
#define RDBSS_REF_TRACK_NETFCB   (0x00000010)
#define RDBSS_REF_TRACK_SRVOPEN  (0x00000020)

#define RX_LOG_REF_TRACKING      (0x80000000)
#define RX_PRINT_REF_TRACKING    (0x40000000)

//
//  The reference count tracking mechanism is activated by setting the following
//  variable to the appropriate value defined above.
//

extern ULONG RdbssReferenceTracingValue;

//
//  Macros for tracking the line number and the file of each reference and
//  derefernce on the data structure. on Non DBG builds they are defined as
//  NOTHING. For each data structure the appropriate reference/dereference
//  macro is defined, These should be used instead of raw manipulation of
//  the reference counts.
//

#ifdef DBG
VOID
RxpTrackReference (
    ULONG TraceType,
    PCHAR FileName,
    ULONG Line,
    PVOID Instance
    );

BOOLEAN
RxpTrackDereference (
    ULONG TraceType,
    PCHAR FileName,
    ULONG Line,
    PVOID Instance
    );

#else
#define RxpTrackReference(Type,File,Line,Instance)    NOTHING
#define RxpTrackDereference(Type,File,Line,Instance)  NOTHING
#endif

#define REF_TRACING_ON(TraceMask)  (TraceMask & RdbssReferenceTracingValue)
#define PRINT_REF_COUNT(TYPE,Count)                                 \
        if (REF_TRACING_ON( RDBSS_REF_TRACK_ ## TYPE ) &&           \
            (RdbssReferenceTracingValue & RX_PRINT_REF_TRACKING)) { \
           DbgPrint("%ld\n",Count);                                 \
        }

#define RxReferenceSrvCallAtDpc(SrvCall)                                      \
   RxpTrackReference( RDBSS_REF_TRACK_SRVCALL, __FILE__, __LINE__, SrvCall ); \
   ASSERT( SrvCall->NodeReferenceCount > 1 );                                 \
   InterlockedIncrement( &SrvCall->NodeReferenceCount )

#define RxReferenceSrvCall(SrvCall)                                           \
   RxpTrackReference( RDBSS_REF_TRACK_SRVCALL, __FILE__, __LINE__, SrvCall ); \
   RxReference( SrvCall )

#define RxDereferenceSrvCall(SrvCall,LockHoldingState)                          \
   RxpTrackDereference( RDBSS_REF_TRACK_SRVCALL, __FILE__, __LINE__, SrvCall ); \
   RxDereference(SrvCall, LockHoldingState )

#define RxReferenceNetRoot(NetRoot)                                           \
   RxpTrackReference( RDBSS_REF_TRACK_NETROOT, __FILE__, __LINE__, NetRoot ); \
   RxReference( NetRoot )

#define RxDereferenceNetRoot( NetRoot, LockHoldingState )                      \
   RxpTrackDereference( RDBSS_REF_TRACK_NETROOT, __FILE__, __LINE__, NetRoot );\
   RxDereference( NetRoot, LockHoldingState )

#define RxReferenceVNetRoot(VNetRoot)                                        \
   RxpTrackReference( RDBSS_REF_TRACK_VNETROOT, __FILE__, __LINE__, VNetRoot );\
   RxReference( VNetRoot )

#define RxDereferenceVNetRoot( VNetRoot, LockHoldingState )                       \
   RxpTrackDereference( RDBSS_REF_TRACK_VNETROOT, __FILE__, __LINE__, VNetRoot ); \
   RxDereference( VNetRoot, LockHoldingState )

#define RxReferenceNetFobx(Fobx)                                          \
   RxpTrackReference( RDBSS_REF_TRACK_NETFOBX, __FILE__, __LINE__, Fobx );      \
   RxReference( Fobx )

#define RxDereferenceNetFobx(Fobx,LockHoldingState)                       \
   RxpTrackDereference( RDBSS_REF_TRACK_NETFOBX, __FILE__, __LINE__, Fobx );    \
   RxDereference( Fobx, LockHoldingState )

#define RxReferenceSrvOpen(SrvOpen)                                           \
   RxpTrackReference( RDBSS_REF_TRACK_SRVOPEN, __FILE__, __LINE__, SrvOpen ); \
   RxReference( SrvOpen )

#define RxDereferenceSrvOpen( SrvOpen, LockHoldingState )                      \
   RxpTrackDereference( RDBSS_REF_TRACK_SRVOPEN, __FILE__, __LINE__, SrvOpen); \
   RxDereference( SrvOpen, LockHoldingState )

#define RxReferenceNetFcb(Fcb)                                            \
   RxpTrackReference( RDBSS_REF_TRACK_NETFCB, __FILE__, __LINE__, Fcb );  \
   RxpReferenceNetFcb( Fcb )

//
//  the following macros manipulate the reference count and also return the
//  status of the final derefence or finalize call. This results in the usage
//  of the , operator.
//           

#define RxDereferenceNetFcb(Fcb)  ( \
   ((LONG)RxpTrackDereference( RDBSS_REF_TRACK_NETFCB, __FILE__, __LINE__, Fcb )), \
   RxpDereferenceNetFcb( Fcb ))

#define RxDereferenceAndFinalizeNetFcb(Fcb,RxContext,RecursiveFinalize,ForceFinalize) ( \
   RxpTrackDereference( RDBSS_REF_TRACK_NETFCB, __FILE__, __LINE__, Fcb ),              \
   RxpDereferenceAndFinalizeNetFcb( Fcb, RxContext, RecursiveFinalize, ForceFinalize )) \

//
//  Check for structure alignment errors
//            

VOID
RxCheckFcbStructuresForAlignment(
    VOID
    );


//
//  SRV_CALL related routines.
//

PSRV_CALL
RxCreateSrvCall (
    IN PRX_CONTEXT RxContext,
    IN PUNICODE_STRING Name,
    IN PUNICODE_STRING InnerNamePrefix OPTIONAL,
    IN PRX_CONNECTION_ID RxConnectionId
    );


#define RxWaitForStableSrvCall(SRVCALL,RXCONTEXT) {                                  \
    RxDbgTrace( 0, Dbg, ("RxWaitForStableSrvCall -- %lx\n",(SRVCALL)) );    \
    RxWaitForStableCondition( &(SRVCALL)->Condition, &(SRVCALL)->TransitionWaitList, (RXCONTEXT), NULL); \
    }

#define RxWaitForStableSrvCall_Async(SRVCALL,RXCONTEXT,PNTSTATUS) {                                  \
    RxDbgTrace( 0, Dbg, ("RxWaitForStableSrvCall -- %lx\n",(SRVCALL)) );    \
    RxWaitForStableCondition( &(SRVCALL)->Condition, &(SRVCALL)->TransitionWaitList, (RXCONTEXT), (PNTSTATUS) ); \
    }

#define RxTransitionSrvCall(SRVCALL,CONDITION) \
    RxDbgTrace( 0, Dbg, ("RxTransitionSrvCall -- %lx Condition -- %ld\n",(SRVCALL),(CONDITION)) ); \
    RxUpdateCondition( (CONDITION), &(SRVCALL)->Condition, &(SRVCALL)->TransitionWaitList )

BOOLEAN
RxFinalizeSrvCall (
    OUT PSRV_CALL ThisSrvCall,
    IN BOOLEAN ForceFinalize
    );

//
// NET_ROOT related routines.
//

PNET_ROOT
RxCreateNetRoot (
    IN PSRV_CALL SrvCall,
    IN PUNICODE_STRING Name,
    IN ULONG NetRootFlags,
    IN PRX_CONNECTION_ID OPTIONAL RxConnectionId
    );

VOID
RxFinishNetRootInitialization (
    IN OUT PNET_ROOT ThisNetRoot,
    IN PMINIRDR_DISPATCH Dispatch,
    IN PUNICODE_STRING  InnerNamePrefix,
    IN ULONG FcbSize,
    IN ULONG SrvOpenSize,
    IN ULONG FobxSize,
    IN ULONG NetRootFlags
    );


#define RxWaitForStableNetRoot(NETROOT,RXCONTEXT)                                   \
    RxDbgTrace(0, Dbg, ("RxWaitForStableNetRoot -- %lx\n",(NETROOT)));    \
    RxWaitForStableCondition(&(NETROOT)->Condition,&(NETROOT)->TransitionWaitList,(RXCONTEXT),NULL)

#define RxTransitionNetRoot(NETROOT,CONDITION) \
    RxDbgTrace(0, Dbg, ("RxTransitionNetRoot -- %lx Condition -- %ld\n",(NETROOT),(CONDITION))); \
    RxUpdateCondition((CONDITION),&(NETROOT)->Condition,&(NETROOT)->TransitionWaitList)

BOOLEAN
RxFinalizeNetRoot (
    OUT PNET_ROOT ThisNetRoot,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

//
// V_NET_ROOT related routines
//

NTSTATUS
RxInitializeVNetRootParameters (
   PRX_CONTEXT RxContext,
   OUT LUID *LogonId,
   OUT PULONG SessionId,
   OUT PUNICODE_STRING *UserNamePtr,
   OUT PUNICODE_STRING *UserDomainNamePtr,
   OUT PUNICODE_STRING *PasswordPtr,
   OUT PULONG Flags
   );

VOID
RxUninitializeVNetRootParameters (
   IN PUNICODE_STRING UserName,
   IN PUNICODE_STRING UserDomainName,
   IN PUNICODE_STRING Password,
   OUT PULONG Flags
   );

PV_NET_ROOT
RxCreateVNetRoot (
    IN PRX_CONTEXT RxContext,
    IN PNET_ROOT NetRoot,
    IN PUNICODE_STRING CanonicalName,
    IN PUNICODE_STRING LocalNetRootName,
    IN PUNICODE_STRING FilePath,
    IN PRX_CONNECTION_ID RxConnectionId
    );

BOOLEAN
RxFinalizeVNetRoot (
    OUT PV_NET_ROOT ThisVNetRoot,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

#define RxWaitForStableVNetRoot(VNETROOT,RXCONTEXT)                                   \
    RxDbgTrace( 0, Dbg, ("RxWaitForStableVNetRoot -- %lx\n",(VNETROOT)) );    \
    RxWaitForStableCondition( &(VNETROOT)->Condition, &(VNETROOT)->TransitionWaitList, (RXCONTEXT), NULL )

#define RxTransitionVNetRoot(VNETROOT,CONDITION) \
    RxDbgTrace( 0, Dbg, ("RxTransitionVNetRoot -- %lx Condition -- %ld\n", (VNETROOT), (CONDITION)) ); \
    RxUpdateCondition( (CONDITION), &(VNETROOT)->Condition, &(VNETROOT)->TransitionWaitList )

#ifdef USE_FILESIZE_LOCK

//
//  FCB related routines.
//

#define RxAcquireFileSizeLock(PFCB) { \
    ExAcquireFastMutex( (PFCB)->Specific.Fcb.FileSizeLock ); \
}
#define RxReleaseFileSizeLock(PFCB) { \
    ExReleaseFastMutex((PFCB)->Specific.Fcb.FileSizeLock); \
}

#endif

VOID
RxSetFileSizeWithLock (
    IN OUT PFCB Fcb,
    IN PLONGLONG FileSize
    );

VOID
RxGetFileSizeWithLock (
    IN PFCB Fcb,
    OUT PLONGLONG FileSize
    );

PFCB
RxCreateNetFcb (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PV_NET_ROOT VNetRoot,
    IN PUNICODE_STRING Name
    );

#define RxWaitForStableNetFcb(FCB,RXCONTEXT)                                   \
    RxDbgTrace( 0, Dbg, ("RxWaitForStableNetFcb -- %lx\n",(FCB)));    \
    RxWaitForStableCondition( &(FCB)->Condition, &(FCB)->NonPaged->TransitionWaitList, (RXCONTEXT), NULL )

#define RxTransitionNetFcb(FCB,CONDITION) \
    RxDbgTrace( 0, Dbg, ("RxTransitionNetFcb -- %lx Condition -- %ld\n",(FCB),(CONDITION))); \
    RxUpdateCondition( (CONDITION), &(FCB)->Condition, &(FCB)->NonPaged->TransitionWaitList )


#define RxFormInitPacket(IP,I1,I1a,I2,I3,I4a,I4b,I5,I6,I7) (\
            IP.pAttributes = I1, \
            IP.pNumLinks = I1a, \
            IP.pCreationTime = I2, \
            IP.pLastAccessTime = I3, \
            IP.pLastWriteTime = I4a, \
            IP.pLastChangeTime = I4b, \
            IP.pAllocationSize = I5, \
            IP.pFileSize = I6, \
            IP.pValidDataLength = I7, \
          &IP)

#if DBG
#define ASSERT_CORRECT_FCB_STRUCTURE_DBG_ONLY(___thisfcb) {\
    ASSERT( ___thisfcb->NonPaged == ___thisfcb->CopyOfNonPaged );       \
    ASSERT( ___thisfcb->NonPaged->FcbBackPointer == ___thisfcb );       \
    }
#else
#define ASSERT_CORRECT_FCB_STRUCTURE_DBG_ONLY(___thisfcb)
#endif

#define ASSERT_CORRECT_FCB_STRUCTURE(THIS_FCB__) { \
    ASSERT( NodeTypeIsFcb(THIS_FCB__));                                 \
    ASSERT( THIS_FCB__->NonPaged != NULL );                             \
    ASSERT( NodeType(THIS_FCB__->NonPaged) == RDBSS_NTC_NONPAGED_FCB);  \
    ASSERT_CORRECT_FCB_STRUCTURE_DBG_ONLY(THIS_FCB__) \
    }

RX_FILE_TYPE
RxInferFileType (
    IN PRX_CONTEXT RxContext
    );

VOID
RxFinishFcbInitialization (
    IN OUT PMRX_FCB Fcb,
    IN RX_FILE_TYPE FileType,
    IN PFCB_INIT_PACKET InitPacket OPTIONAL
    );

#define RxWaitForStableSrvOpen(SRVOPEN,RXCONTEXT)                                   \
    RxDbgTrace( 0, Dbg, ("RxWaitForStableFcb -- %lx\n",(SRVOPEN)) );    \
    RxWaitForStableCondition( &(SRVOPEN)->Condition, &(SRVOPEN)->TransitionWaitList, (RXCONTEXT), NULL )

#define RxTransitionSrvOpen(SRVOPEN,CONDITION) \
    RxDbgTrace( 0, Dbg, ("RxTransitionSrvOpen -- %lx Condition -- %ld\n",(SRVOPEN),(CONDITION)) ); \
    RxUpdateCondition( (CONDITION), &(SRVOPEN)->Condition, &(SRVOPEN)->TransitionWaitList )

VOID
RxRemoveNameNetFcb (
    OUT PFCB ThisFcb
    );

VOID
RxpReferenceNetFcb (
   PFCB Fcb
   );

LONG
RxpDereferenceNetFcb (
   PFCB Fcb
   );

BOOLEAN
RxpDereferenceAndFinalizeNetFcb (
    OUT PFCB ThisFcb,
    IN PRX_CONTEXT RxContext,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

#if DBG
extern BOOLEAN RxLoudFcbOpsOnExes;
BOOLEAN
RxLoudFcbMsg(
    PUCHAR msg,
    PUNICODE_STRING Name
    );
#else
#define RxLoudFcbMsg(a,b) (FALSE)
#endif


//
//  SRV_OPEN related methods
//

PSRV_OPEN
RxCreateSrvOpen (
    IN PV_NET_ROOT VNetRoot,
    IN OUT PFCB Fcb
    );

VOID
RxTransitionSrvOpenState (
    OUT PSRV_OPEN ThisSrvOpen,
    IN RX_BLOCK_CONDITION Condition
    );

BOOLEAN
RxFinalizeSrvOpen (
    OUT PSRV_OPEN ThisSrvOpen,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

#if 0
#else
INLINE 
PUNICODE_STRING
GET_ALREADY_PREFIXED_NAME (
    PMRX_SRV_OPEN SrvOpen,
    PMRX_FCB Fcb)
{
    PFCB ThisFcb = (PFCB)Fcb;

#if DBG
    if (SrvOpen != NULL ) {
        ASSERT( NodeType( SrvOpen ) == RDBSS_NTC_SRVOPEN );
        ASSERT( ThisFcb != NULL );
        ASSERT( NodeTypeIsFcb( Fcb) );
        ASSERT( SrvOpen->pFcb == Fcb );
        ASSERT( SrvOpen->pAlreadyPrefixedName == &ThisFcb->PrivateAlreadyPrefixedName );
    }
#endif

    return( &ThisFcb->PrivateAlreadyPrefixedName);
}
#endif

#define GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(Rxcontext) \
        (GET_ALREADY_PREFIXED_NAME( (Rxcontext)->pRelevantSrvOpen, (Rxcontext)->pFcb ))

//
//  FOBX related routines
//

PMRX_FOBX
RxCreateNetFobx (
    OUT PRX_CONTEXT RxContext,
    IN PMRX_SRV_OPEN MrxSrvOpen
    );

BOOLEAN
RxFinalizeNetFobx (
    OUT PFOBX ThisFobx,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

#endif // _FCB_STRUCTS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\midatlax.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    midatlas.h

Abstract:

    This module defines the data structure used in mapping MIDS to the corresponding requests/
    contexts associated with them.

Author:

    Balan Sethu Raman (SethuR) 26-Aug-95    Created

Notes:

   MID (Multiplex ID) is used at both the server and the client ( redirector ) to distinguish
   between the concurrently active requests on any connection. This data structure has been
   designed to meet the following criterion.

   1) It should scale well to handle the differing capabilities of a server, e.g., the typical
   NT server permits 50 outstanding requests on any connection. The CORE level servers can go as
   low as one and on Gateway machines the desired number can be very high ( in the oreder of thousands)

   2) The two primary operations that need to be handled well are
      i) mapping a MID to the context associated with it.
         -- This routine will be invoked to process every packet received along any connection
         at both the server and the client.
      ii) generating a new MID for sending requests to the server.
         -- This will be used at the client both for max. command enforcement as well as
         tagging each concurrent request with a unique id.

    The most common case is that of a connection between a NT client and a NT server. All
    design decisions have been made in order to ensure that the solutions are optimal
    for this case.

    The MID data structure must be efficiently able to manage the unique tagging and identification
    of a number of mids ( typically 50 ) from a possible combination of 65536 values. In order to
    ensure a proper time space tradeoff the lookup is organized as a three level hierarchy.

    The 16 bits used to represent a MID  are split upinto three bit fields. The length of the
    rightmost field ( least signifiant ) is decided by the number of mids that are to be
    allocated on creation. The remaining length is split up equally between the next two
    fields, e.g., if 50 mids are to be allocated on creation , the length of the first field
    is 6 ( 64 ( 2 ** 6 ) is greater than 50 ), 5 and 5.

--*/

#ifndef _MIDATLAX_H_
#define _MIDATLAX_H_

// 
//  Forward declaration
//

typedef struct _MID_MAP_ *PMID_MAP;


typedef struct _RX_MID_ATLAS {
   USHORT MaximumNumberOfMids;
   USHORT MidsAllocated;
   USHORT NumberOfMidsInUse;
   USHORT NumberOfMidsDiscarded;
   USHORT MaximumMidFieldWidth;
   USHORT Reserved;
   USHORT MidQuantum;
   UCHAR MidQuantumFieldWidth;
   UCHAR NumberOfLevels;
   LIST_ENTRY MidMapFreeList;
   LIST_ENTRY MidMapExpansionList;
   PMID_MAP pRootMidMap;
} RX_MID_ATLAS, *PRX_MID_ATLAS;

typedef
VOID (*PCONTEXT_DESTRUCTOR) (
      PVOID Context
      );

#define RxGetMaximumNumberOfMids(ATLAS) ((ATLAS)->MaximumNumberOfMids)

#define RxGetNumberOfMidsInUse(ATLAS) ((ATLAS)->NumberOfMidsInUse)

PRX_MID_ATLAS
RxCreateMidAtlas (
    USHORT MaximumNumberOfEntries,
    USHORT InitialAllocation
    );

VOID
RxDestroyMidAtlas (
    PRX_MID_ATLAS MidAtlas,
    PCONTEXT_DESTRUCTOR ContextDestructor
    );

PVOID
RxMapMidToContext (
    PRX_MID_ATLAS MidAtlas,
    USHORT Mid
    );

NTSTATUS
RxAssociateContextWithMid (
    PRX_MID_ATLAS MidAtlas,
    PVOID Context,
    PUSHORT NewMid
    );

NTSTATUS
RxMapAndDissociateMidFromContext (
    PRX_MID_ATLAS MidAtlas,
    USHORT Mid,
    PVOID *ContextPointer
    );

NTSTATUS
RxReassociateMid (
    PRX_MID_ATLAS MidAtlas,
    USHORT Mid,
    PVOID NewContext
    );

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\fsctlbuf.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FsCtlBuf.h

Abstract:

    This module defines routines that get the buffers for the various types of ioctl/fsctls. It is essntially
    just the reverse of the IopXXXControlFile routine in io\internal.c, the appropriate parts of which are
    reproduced here.

Author:

    Joe Linn     [JoeLinn]    4-aug-1994

Revision History:

--*/

#ifndef _fsctlbuf_
#define _fsctlbuf_

// the presentation here is in three pieces: the macros for METHODBUFFERED, METHODDIRECT, AND METHODNEITHER.
// it's set up this way so that you can find out what you've got just by reading this and not looking thru
// IO system....

/*  here is the code for case 0
    case 0:

        //
        // For this case, allocate a buffer that is large enough to contain
        // both the input and the output buffers.  Copy the input buffer to
        // the allocated buffer and set the appropriate IRP fields.
        //

        try {

            if (InputBufferLength || OutputBufferLength) {
                irp->AssociatedIrp.SystemBuffer =
                    RxAllocatePool( poolType,
                                    (InputBufferLength > OutputBufferLength) ? InputBufferLength : OutputBufferLength );

                if (ARGUMENT_PRESENT( InputBuffer )) {
                    RtlCopyMemory( irp->AssociatedIrp.SystemBuffer,
                                   InputBuffer,
                                   InputBufferLength );
                }
                irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
                irp->UserBuffer = OutputBuffer;
                if (ARGUMENT_PRESENT( OutputBuffer )) {
                    irp->Flags |= IRP_INPUT_OPERATION;
                }
            } else {
                irp->Flags = 0;
                irp->UserBuffer = (PVOID) NULL;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
              <<<elided>>>
        }

        break;

So, the bottom line is that irp->AssociatedIrp.SystemBuffer is a buffer of length (I-length+O-length) and
is preloaded with the input. Even though the original outputbuffer is passed thru in irp->UserBuffer, it is not to be used
in the FS; rather the FS writes its answer into the same buffer.  we get the
following macros:

*/
#define METHODBUFFERED_SharedBuffer(IRP)     (IRP)->AssociatedIrp.SystemBuffer


/* for 1 and 2

    case 1:
    case 2:

        //
        // For these two cases, allocate a buffer that is large enough to
        // contain the input buffer, if any, and copy the information to
        // the allocated buffer.  Then build an MDL for either read or write
        // access, depending on the method, for the output buffer.  Note
        // that the buffer length parameters have been jammed to zero for
        // users if the buffer parameter was not passed.  (Kernel callers
        // should be calling the service correctly in the first place.)
        //
        // Note also that it doesn't make a whole lot of sense to specify
        // either method #1 or #2 if the IOCTL does not require the caller
        // to specify an output buffer.
        //

        try {

            if (InputBufferLength && ARGUMENT_PRESENT( InputBuffer )) {
                irp->AssociatedIrp.SystemBuffer =
                    RxAllocatePool( poolType, InputBufferLength );
                RtlCopyMemory( irp->AssociatedIrp.SystemBuffer,
                               InputBuffer,
                               InputBufferLength );
                irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
            } else {
                irp->Flags = 0;
            }

            if (OutputBufferLength != 0) {
                irp->MdlAddress = IoAllocateMdl( OutputBuffer,
                                                 OutputBufferLength,
                                                 FALSE,
                                                 TRUE,
                                                 irp  );
                if (irp->MdlAddress == NULL) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }
                MmProbeAndLockPages( irp->MdlAddress,
                                     requestorMode,
                                     (LOCK_OPERATION) ((method == 1) ? IoReadAccess : IoWriteAccess) );
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            <<<ELIDED>>>
        }

        break;

So the deal is that the input buffer has been copied in as in case 0 but what we have is an MDL for
the output buffer. this leads to the following
*/


#define METHODDIRECT_BufferedInputBuffer(IRP)   ((IRP)->AssociatedIrp.SystemBuffer)
#define METHODDIRECT_DirectBuffer(IRP)  (((IRP)->MdlAddress) \
                                                 ? MmGetSystemAddressForMdlSafe((IRP)->MdlAddress,NormalPagePriority):NULL)

/* and finally
    case 3:

        //
        // For this case, do nothing.  Everything is up to the driver.
        // Simply give the driver a copy of the caller's parameters and
        // let the driver do everything itself.
        //

        irp->UserBuffer = OutputBuffer;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer = InputBuffer;
    }

So we can get 'em.....but we don't really know how they're gonna be used. Nevertheless.......
*/

#define METHODNEITHER_OriginalInputBuffer(IRPSP)   ((IRPSP)->Parameters.DeviceIoControl.Type3InputBuffer)
#define METHODNEITHER_OriginalOutputBuffer(IRP)    ((IRP)->UserBuffer)


#endif    // _fsctlbuf_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\cifs.h ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    cifs.h

Abstract:

    This module defines structures and constants for the Common Internet File System
	commands, request and response protocol.


--*/

#ifndef _CIFS_
#define _CIFS_


//
// The server has 16 bits available to it in each 32-bit status code.
// See \nt\sdk\inc\ntstatus.h for a description of the use of the
// high 16 bits of the status.
//
// The layout of the bits is:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------+-----------------------+
//  |Sev|C|   Facility--Server      | Class |        Code           |
//  +---+-+-------------------------+-------+-----------------------+
//
// Class values:
//     0 - a server-specific error code, not put directly on the wire.
//     1 - SMB error class DOS.  This includes those OS/2 errors
//             that share code values and meanings with the SMB protocol.
//     2 - SMB error class SERVER.
//     3 - SMB error class HARDWARE.
//     4 - other SMB error classes
//     5-E - undefined
//     F - an OS/2-specific error.  If the client is OS/2, then the
//              SMB error class is set to DOS and the code is set to
//              the actual OS/2 error code contained in the Code field.
//
// The meaning of the Code field depends on the Class value.  If the
// class is 00, then the code value is arbitrary.  For other classes,
// the code is the actual code of the error in the SMB or OS/2
// protocols.
//

#define SRV_STATUS_FACILITY_CODE 0x00980000L
#define SRV_SRV_STATUS                (0xC0000000L | SRV_STATUS_FACILITY_CODE)
#define SRV_DOS_STATUS                (0xC0001000L | SRV_STATUS_FACILITY_CODE)
#define SRV_SERVER_STATUS             (0xC0002000L | SRV_STATUS_FACILITY_CODE)
#define SRV_HARDWARE_STATUS           (0xC0003000L | SRV_STATUS_FACILITY_CODE)
#define SRV_WIN32_STATUS              (0xC000E000L | SRV_STATUS_FACILITY_CODE)
#define SRV_OS2_STATUS                (0xC000F000L | SRV_STATUS_FACILITY_CODE)

//++
//
// BOOLEAN
// SmbIsSrvStatus (
//     IN NTSTATUS Status
//     )
//
// Routine Description:
//
//     Macro to determine whether a status code is one defined by the
//     server (has the server facility code).
//
// Arguments:
//
//     Status - the status code to check.
//
// Return Value:
//
//     BOOLEAN - TRUE if the facility code is the servers, FALSE
//         otherwise.
//
//--

#define SrvIsSrvStatus(Status) \
    ( ((Status) & 0x1FFF0000) == SRV_STATUS_FACILITY_CODE ? TRUE : FALSE )

//++
//
// UCHAR
// SmbErrorClass (
//     IN NTSTATUS Status
//     )
//
// Routine Description:
//
//     This macro extracts the error class field from a server status
//     code.
//
// Arguments:
//
//     Status - the status code from which to get the error class.
//
// Return Value:
//
//     UCHAR - the server error class of the status code.
//
//--

#define SrvErrorClass(Status) ((UCHAR)( ((Status) & 0x0000F000) >> 12 ))

//++
//
// UCHAR
// SmbErrorCode (
//     IN NTSTATUS Status
//     )
//
// Routine Description:
//
//     This macro extracts the error code field from a server status
//     code.
//
// Arguments:
//
//     Status - the status code from which to get the error code.
//
// Return Value:
//
//     UCHAR - the server error code of the status code.
//
//--

#define SrvErrorCode(Status) ((USHORT)( (Status) & 0xFFF) )

//
// Status codes unique to the server.  These error codes are used
// internally only.
//

#define STATUS_ENDPOINT_CLOSED              (SRV_SRV_STATUS | 0x01)
#define STATUS_DISCONNECTED                 (SRV_SRV_STATUS | 0x02)
#define STATUS_SERVER_ALREADY_STARTED       (SRV_SRV_STATUS | 0x04)
#define STATUS_SERVER_NOT_STARTED           (SRV_SRV_STATUS | 0x05)
#define STATUS_OPLOCK_BREAK_UNDERWAY        (SRV_SRV_STATUS | 0x06)
#define STATUS_NONEXISTENT_NET_NAME         (SRV_SRV_STATUS | 0x08)

//
// Error codes that exist in both the SMB protocol and OS/2 but not NT.
// Note that all SMB DOS-class error codes are defined in OS/2.
//

#define STATUS_OS2_INVALID_FUNCTION   (SRV_DOS_STATUS | ERROR_INVALID_FUNCTION)
#define STATUS_OS2_TOO_MANY_OPEN_FILES \
                                   (SRV_DOS_STATUS | ERROR_TOO_MANY_OPEN_FILES)
#define STATUS_OS2_INVALID_ACCESS     (SRV_DOS_STATUS | ERROR_INVALID_ACCESS)

//
// SMB SERVER-class error codes that lack an NT or OS/2 equivalent.
//

#define STATUS_INVALID_SMB            (SRV_SERVER_STATUS | SMB_ERR_ERROR)
#define STATUS_SMB_BAD_NET_NAME       (SRV_SERVER_STATUS | SMB_ERR_BAD_NET_NAME)
#define STATUS_SMB_BAD_TID            (SRV_SERVER_STATUS | SMB_ERR_BAD_TID)
#define STATUS_SMB_BAD_UID            (SRV_SERVER_STATUS | SMB_ERR_BAD_UID)
#define STATUS_SMB_TOO_MANY_UIDS      (SRV_SERVER_STATUS | SMB_ERR_TOO_MANY_UIDS)
#define STATUS_SMB_USE_MPX            (SRV_SERVER_STATUS | SMB_ERR_USE_MPX)
#define STATUS_SMB_USE_STANDARD       (SRV_SERVER_STATUS | SMB_ERR_USE_STANDARD)
#define STATUS_SMB_CONTINUE_MPX       (SRV_SERVER_STATUS | SMB_ERR_CONTINUE_MPX)
#define STATUS_SMB_BAD_COMMAND        (SRV_SERVER_STATUS | SMB_ERR_BAD_COMMAND)
#define STATUS_SMB_NO_SUPPORT         (SRV_SERVER_STATUS | SMB_ERR_NO_SUPPORT_INTERNAL)

// *** because SMB_ERR_NO_SUPPORT uses 16 bits, but we have only 12 bits
//     available for error codes, it must be special-cased in the code.

//
// SMB HARDWARE-class error codes that lack an NT or OS/2 equivalent.
//

#define STATUS_SMB_DATA               (SRV_HARDWARE_STATUS | SMB_ERR_DATA)

//
// OS/2 error codes that lack an NT or SMB equivalent.
//

#include <winerror.h>

#define STATUS_OS2_INVALID_LEVEL \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_INVALID_LEVEL)

#define STATUS_OS2_EA_LIST_INCONSISTENT \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_EA_LIST_INCONSISTENT)

#define STATUS_OS2_NEGATIVE_SEEK \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_NEGATIVE_SEEK)

#define STATUS_OS2_NO_MORE_SIDS \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_NO_MORE_SEARCH_HANDLES)

#define STATUS_OS2_EAS_DIDNT_FIT \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_EAS_DIDNT_FIT)

#define STATUS_OS2_EA_ACCESS_DENIED \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_EA_ACCESS_DENIED)

#define STATUS_OS2_CANCEL_VIOLATION \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_CANCEL_VIOLATION)

#define STATUS_OS2_ATOMIC_LOCKS_NOT_SUPPORTED \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_ATOMIC_LOCKS_NOT_SUPPORTED)

#define STATUS_OS2_CANNOT_COPY \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_CANNOT_COPY)


//
// SMBDBG determines whether the get/put macros are instead defined as
// function calls.  (This is used to more reliablyfind char/short/long
// mismatches).
//

#ifndef SMBDBG
#define SMBDBG 0
#endif

//
// SMBDBG1 determines whether the names of short and long fields in SMB
// structures have an extra character appended.  This is used to ensure
// that these fields are only accessed via the get/put macros.  SMBDBG1
// must be disabled when SMBDBG is enabled.
//

#ifndef SMBDBG1
#define SMBDBG1 0
#endif

#if SMBDBG && SMBDBG1
#undef SMBDBG1
#define SMBDBG1 0
#endif

//
// If __unaligned support is available, or if we're compiling for a
// machine that handles unaligned accesses in hardware, then define
// SMB_USE_UNALIGNED as 1 (TRUE).  Otherwise, define it as 0 (FALSE).
// If SMB_USE_UNALIGNED is FALSE, then the macros below use byte
// accesses to build up word and longword accesses to unaligned fields.
//
// Currently, the machines we build for all have SMB_USE_UNALIGNED as
// TRUE.  x86 supports unaligned accesses in hardware, while the MIPS
// compiler supports the __unaligned keyword.
//
// Note that if SMB_USE_UNALIGNED is predefined, we use that definition.
// Also, if SMB_NO_UNALIGNED is defined as TRUE, it forces
// SMB_USE_ALIGNED off.  This allows us to force, for testing purposes,
// use of byte accesses in the macros.
//

#ifndef SMB_NO_UNALIGNED
#define SMB_NO_UNALIGNED 0
#endif

#ifndef SMB_USE_UNALIGNED
#if SMB_NO_UNALIGNED
#define SMB_USE_UNALIGNED 0
#else
#define SMB_USE_UNALIGNED 1
#endif
#endif

//
// ntdef.h defines UNALIGNED as "__unaligned" or "", depending on
// whether we're building for MIPS or x86, respectively.  Because we
// want to be able to disable use of __unaligned, we define
// SMB_UNALIGNED as "UNALIGNED" or "", depending on whether
// SMB_USE_UNALIGNED is TRUE or FALSE, respectively.
//

#if SMB_USE_UNALIGNED
#define SMB_UNALIGNED UNALIGNED
#else
#define SMB_UNALIGNED
#endif

//
// For ease of use, we define types for unaligned pointers to shorts
// and longs in SMBs.  Note that "PUSHORT UNALIGNED" doesn't work.
//

typedef unsigned short SMB_UNALIGNED *PSMB_USHORT;
typedef unsigned long SMB_UNALIGNED *PSMB_ULONG;

//
// Macros for renaming short and long SMB fields.
//

#if SMBDBG1

#define _USHORT( field ) USHORT field ## S
#define _ULONG( field ) ULONG field ## L

#else

#define _USHORT( field ) USHORT field
#define _ULONG( field ) ULONG field

#endif

//
// Force misalignment of the following structures
//

#ifndef NO_PACKING
#include <packon.h>
#endif // ndef NO_PACKING


//
// The SMB_DIALECT type corresponds to the different SMB dialects
// that the server can speak.  Associated with it is the DialectStrings[]
// array that holds information about the ASCIIZ strings that are passed
// in the Negotiate SMB.s
//
// These are listed in order from highest preference to lowest preference.
// The assigned numbers correspond to the array SrvClientTypes[] in the
// server module srvdata.c.
//

typedef enum _SMB_DIALECT {


    SmbDialectNtLanMan,             // NT LAN Man
    SmbDialectLanMan21,             // OS/2 Lanman 2.1
    SmbDialectDosLanMan21,          // DOS Lanman 2.1
    SmbDialectLanMan20,             // OS/2 1.2 LanMan 2.0
    SmbDialectDosLanMan20,          // DOS LanMan 2.0
    SmbDialectLanMan10,             // 1st version of full LanMan extensions
    SmbDialectMsNet30,              // Larger subset of LanMan extensions
    SmbDialectMsNet103,             // Limited subset of LanMan extensions
    SmbDialectPcLan10,              // Alternate original protocol
    SmbDialectPcNet10,              // Original protocol
    SmbDialectIllegal,

} SMB_DIALECT, *PSMB_DIALECT;

#define FIRST_DIALECT SmbDialectNtLanMan

#define FIRST_DIALECT_EMULATED  SmbDialectNtLanMan

#define LAST_DIALECT SmbDialectIllegal
#define IS_DOS_DIALECT(dialect)                                        \
    ( (BOOLEAN)( (dialect) == SmbDialectDosLanMan21 ||                 \
                 (dialect) == SmbDialectDosLanMan20 ||                 \
                 (dialect) > SmbDialectLanMan10 ) )
#define IS_OS2_DIALECT(dialect) ( (BOOLEAN)!IS_DOS_DIALECT(dialect) )

#define IS_NT_DIALECT(dialect)  (dialect) == SmbDialectNtLanMan

#define DIALECT_HONORS_UID(dialect)     \
    ( (BOOLEAN)(dialect <= SmbDialectDosLanMan20 ) )


//
// Date and time structures that conform to MS-DOS standard used in
// some SMBs.
//
// !!! These structures are not portable--they depend on a little-endian
//     machine (TwoSeconds in lowest bits, etc.)
//

typedef union _SMB_DATE {
    USHORT Ushort;
    struct {
        USHORT Day : 5;
        USHORT Month : 4;
        USHORT Year : 7;
    } Struct;
} SMB_DATE;
typedef SMB_DATE SMB_UNALIGNED *PSMB_DATE;

typedef union _SMB_TIME {
    USHORT Ushort;
    struct {
        USHORT TwoSeconds : 5;
        USHORT Minutes : 6;
        USHORT Hours : 5;
    } Struct;
} SMB_TIME;
typedef SMB_TIME SMB_UNALIGNED *PSMB_TIME;


//
// The SMB_FIND_BUFFER and SMB_FIND_BUFFER2 structures are used in the
// Transaction2 Find protocols to return files matching the requested
// specifications.  They are identical except for the EaSize field
// in SMB_FIND_BUFFER2.
//

typedef struct _SMB_FIND_BUFFER {
    SMB_DATE CreationDate;
    SMB_TIME CreationTime;
    SMB_DATE LastAccessDate;
    SMB_TIME LastAccessTime;
    SMB_DATE LastWriteDate;
    SMB_TIME LastWriteTime;
    _ULONG( DataSize );
    _ULONG( AllocationSize );
    _USHORT( Attributes );
    UCHAR FileNameLength;
    CHAR FileName[1];
} SMB_FIND_BUFFER;
typedef SMB_FIND_BUFFER SMB_UNALIGNED *PSMB_FIND_BUFFER;

typedef struct _SMB_FIND_BUFFER2 {
    SMB_DATE CreationDate;
    SMB_TIME CreationTime;
    SMB_DATE LastAccessDate;
    SMB_TIME LastAccessTime;
    SMB_DATE LastWriteDate;
    SMB_TIME LastWriteTime;
    _ULONG( DataSize );
    _ULONG( AllocationSize );
    _USHORT( Attributes );
    _ULONG( EaSize );               // this field intentionally misaligned!
    UCHAR FileNameLength;
    CHAR FileName[1];
} SMB_FIND_BUFFER2;
typedef SMB_FIND_BUFFER2 SMB_UNALIGNED *PSMB_FIND_BUFFER2;


//
// The following structures are used in OS/2 1.2 for extended attributes
// (EAs).  OS/2 2.0 uses the same structures as NT.  See the OS/2
// Programmer's Reference, Volume 4, Chapter 4 for more information.
//
// The FEA structure holds a single EA's name and value and is the
// equivalent ofthe NT structure FILE_FULL_EA_INFORMATION.
//

typedef struct _FEA {
    UCHAR fEA;
    UCHAR cbName;
    _USHORT( cbValue );
} FEA;
typedef FEA SMB_UNALIGNED *PFEA;

//
// The only legal bit in fEA is FEA_NEEDEA.
//

#define FEA_NEEDEA 0x80

//
// The FEALIST structure holds the names and values of multiple EAs
// NT has no direct equivalent but rather strings together
// FILE_FULL_EA_INFORMATION structures.
//

typedef struct _FEALIST {
    _ULONG( cbList );
    FEA list[1];
} FEALIST;
typedef FEALIST SMB_UNALIGNED *PFEALIST;

//
// The GEA structure holds the name of a single EA.  It is used to
// request the value of that EA in OS/2 API functions.  The NT
// equivalent is FILE_GET_EA_INFORMATION.
//

typedef struct _GEA {
    UCHAR cbName;
    CHAR szName[1];
} GEA;
typedef GEA SMB_UNALIGNED *PGEA;

//
// The GEALIST structure holds the names of multiple EAs.  NT has no
// direct equivalent but rather strings together FILE_GET_EA_INFORMATION
// structures.
//

typedef struct _GEALIST {
    _ULONG( cbList );
    GEA list[1];
} GEALIST;
typedef GEALIST SMB_UNALIGNED *PGEALIST;

//
// The EAOP structure holds EA information needed by API calls.  It has
// no NT equivalent.
//

typedef struct _EAOP {
    PGEALIST fpGEAList;
    PFEALIST fpFEAList;
    ULONG oError;
} EAOP;
typedef EAOP SMB_UNALIGNED *PEAOP;

//
// FSALLOCATE contains information about a disk returned by
// SrvSmbQueryFsInfo.
//

typedef struct _FSALLOCATE {
    _ULONG( idFileSystem );
    _ULONG( cSectorUnit );
    _ULONG( cUnit );
    _ULONG( cUnitAvail );
    _USHORT( cbSector );
} FSALLOCATE, *PFSALLOCATE;     // *** NOT SMB_UNALIGNED!

//
// VOLUMELABEL contains information about a volume label returned by
// SrvSmbQueryFsInformation.
//

typedef struct _VOLUMELABEL {
    UCHAR cch;
    CHAR szVolLabel[12];
} VOLUMELABEL, *PVOLUMELABEL;   // *** NOT SMB_UNALIGNED!

//
// FSINFO holds information about a volume returned by
// SrvSmbQueryFsInformation.
//

typedef struct _FSINFO {
    _ULONG( ulVsn );
    VOLUMELABEL vol;
} FSINFO, *PFSINFO;             // *** NOT SMB_UNALIGNED!

//
// File types (returned by OpenAndX and Transact2_Open)
// FileTypeIPC is a private definition for the NT redirector and
// is not in the smb protocol.
//

typedef enum _FILE_TYPE {
    FileTypeDisk = 0,
    FileTypeByteModePipe = 1,
    FileTypeMessageModePipe = 2,
    FileTypePrinter = 3,
    FileTypeCommDevice = 4,
    FileTypeIPC = 0xFFFE,
    FileTypeUnknown = 0xFFFF
} FILE_TYPE;

//
// Turn structure packing back off
//

#ifndef NO_PACKING
#include <packoff.h>
#endif // ndef NO_PACKING


//
// PVOID
// ALIGN_SMB_WSTR(
//     IN PVOID Pointer
//     )
//
// Routine description:
//
//     This macro aligns the input pointer to the next 2-byte boundary.
//     Used to align Unicode strings in SMBs.
//
// Arguments:
//
//     Pointer - A pointer
//
// Return Value:
//
//     PVOID - Pointer aligned to next 2-byte boundary.
//

#define ALIGN_SMB_WSTR( Pointer ) \
        (PVOID)( ((ULONG_PTR)Pointer + 1) & ~1 )

//
// Macro to find the size of an SMB parameter block.  This macro takes
// as input the type of a parameter block and a byte count.  It finds
// the offset of the Buffer field, which appears at the end of all
// parameter blocks, and adds the byte count to find the total size.
// The type of the returned offset is USHORT.
//
// Note that this macro does NOT pad to a word or longword boundary.
//

#define SIZEOF_SMB_PARAMS(type,byteCount)   \
            (USHORT)( (ULONG_PTR)&((type *)0)->Buffer[0] + (byteCount) )

//
// Macro to find the next location after an SMB parameter block.  This
// macro takes as input the address of the current parameter block, its
// type, and a byte count.  It finds the address of the Buffer field,
// which appears at the end of all parameter blocks, and adds the byte
// count to find the next available location.  The type of the returned
// pointer is PVOID.
//
// The byte count is passed in even though it is available through
// base->ByteCount.  The reason for this is that this number will be a
// compile-time constant in most cases, so the resulting code will be
// simpler and faster.
//
// !!! This macro does not round to a longword boundary when packing
//     is turned off.  Pre-LM 2.0 DOS redirectors cannot handle having
//     too much data sent to them; the exact amount must be sent.
//     We may want to make this macro such that the first location
//     AFTER the returned value (WordCount field of the SMB) is aligned,
//     since most of the fields are misaligned USHORTs.  This would
//     result in a minor performance win on the 386 and other CISC
//     machines.
//

#ifndef NO_PACKING

#define NEXT_LOCATION(base,type,byteCount)  \
        (PVOID)( (ULONG_PTR)( (PUCHAR)( &((type *)(base))->Buffer[0] ) ) + \
        (byteCount) )

#else

#define NEXT_LOCATION(base,type,byteCount)  \
        (PVOID)(( (ULONG_PTR)( (PUCHAR)( &((type *)(base))->Buffer[0] ) ) + \
        (byteCount) + 3) & ~3)

#endif

//
// Macro to find the offset of a followon command to an and X command.
// This offset is the number of bytes from the start of the SMB header
// to where the followon command's parameters should start.
//

#define GET_ANDX_OFFSET(header,params,type,byteCount) \
        (USHORT)( (PCHAR)(params) - (PCHAR)(header) + \
          SIZEOF_SMB_PARAMS( type,(byteCount) ) )

//
// The following are macros to assist in converting OS/2 1.2 EAs to
// NT style and vice-versa.
//

//++
//
// ULONG
// SmbGetNtSizeOfFea (
//     IN PFEA Fea
//     )
//
// Routine Description:
//
//     This macro gets the size that would be required to hold the FEA
//     in NT format.  The length is padded to account for the fact that
//     each FILE_FULL_EA_INFORMATION structure must start on a
//     longword boundary.
//
// Arguments:
//
//     Fea - a pointer to the OS/2 1.2 FEA structure to evaluate.
//
// Return Value:
//
//     ULONG - number of bytes the FEA would require in NT format.
//
//--

//
// The +1 is for the zero terminator on the name, the +3 is for padding.
//

#define SmbGetNtSizeOfFea( Fea )                                            \
            (ULONG)(( FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +   \
                      (Fea)->cbName + 1 + SmbGetUshort( &(Fea)->cbValue ) + \
                      3 ) & ~3 )

//++
//
// ULONG
// SmbGetNtSizeOfGea (
//     IN PFEA Gea
//     )
//
// Routine Description:
//
//     This macro gets the size that would be required to hold the GEA
//     in NT format.  The length is padded to account for the fact that
//     each FILE_FULL_EA_INFORMATION structure must start on a
//     longword boundary.
//
// Arguments:
//
//     Gea - a pointer to the OS/2 1.2 GEA structure to evaluate.
//
// Return Value:
//
//     ULONG - number of bytes the GEA would require in NT format.
//
//--

//
// The +1 is for the zero terminator on the name, the +3 is for padding.
//

#define SmbGetNtSizeOfGea( Gea )                                            \
            (ULONG)(( FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +   \
                      (Gea)->cbName + 1 + 3 ) & ~3 )

//++
//
// ULONG
// SmbGetOs2SizeOfNtFullEa (
//     IN PFILE_FULL_EA_INFORMATION NtFullEa;
//     )
//
// Routine Description:
//
//     This macro gets the size a FILE_FULL_EA_INFORMATION structure would
//     require to be represented in a OS/2 1.2 style FEA.
//
// Arguments:
//
//     NtFullEa - a pointer to the NT FILE_FULL_EA_INFORMATION structure
//         to evaluate.
//
// Return Value:
//
//     ULONG - number of bytes requires for the FEA.
//
//--

#define SmbGetOs2SizeOfNtFullEa( NtFullEa )                                        \
            (ULONG)( sizeof(FEA) + (NtFullEa)->EaNameLength + 1 +               \
                     (NtFullEa)->EaValueLength )

//++
//
// ULONG
// SmbGetOs2SizeOfNtGetEa (
//     IN PFILE_GET_EA_INFORMATION NtGetEa;
//     )
//
// Routine Description:
//
//     This macro gets the size a FILE_GET_EA_INFORMATION structure would
//     require to be represented in a OS/2 1.2 style GEA.
//
// Arguments:
//
//     NtGetEa - a pointer to the NT FILE_GET_EA_INFORMATION structure
//         to evaluate.
//
// Return Value:
//
//     ULONG - number of bytes requires for the GEA.
//
//--

//
// The zero terminator on the name is accounted for by the szName[0]
// field in the GEA definition.
//

#define SmbGetOs2SizeOfNtGetEa( NtGetEa )                                        \
            (ULONG)( sizeof(GEA) + (NtGetEa)->EaNameLength )


/*

Inclusion of SMB request/response structures in this file is
conditionalized in the following way:

    If INCLUDE_SMB_ALL is defined, all of the structures are defined.

    Otherwise, the following names, if defined, cause inclusion of the
    corresponding SMB categories:

        INCLUDE_SMB_ADMIN           Administrative requests:
                                        PROCESS_EXIT
                                        NEGOTIATE
                                        SESSION_SETUP_ANDX
                                        LOGOFF_ANDX

        INCLUDE_SMB_TREE            Tree connect requests:
                                        TREE_CONNECT
                                        TREE_DISCONNECT
                                        TREE_CONNECT_ANDX

        INCLUDE_SMB_DIRECTORY       Directory-related requests:
                                        CREATE_DIRECTORY
                                        DELETE_DIRECTORY
                                        CHECK_DIRECTORY

        INCLUDE_SMB_OPEN_CLOSE      File open and close requests:
                                        OPEN
                                        CREATE
                                        CLOSE
                                        CREATE_TEMPORARY
                                        CREATE_NEW
                                        OPEN_ANDX
                                        CLOSE_AND_TREE_DISC

        INCLUDE_SMB_READ_WRITE      Read and write requests:
                                        READ
                                        WRITE
                                        SEEK
                                        LOCK_AND_READ
                                        WRITE_AND_UNLOCK
                                        WRITE_AND_CLOSE
                                        READ_ANDX
                                        WRITE_ANDX


        INCLUDE_SMB_FILE_CONTROL    File control requests:
                                        FLUSH
                                        DELETE
                                        RENAME
                                        COPY
                                        MOVE

        INCLUDE_SMB_QUERY_SET       File query/set requests:
                                        QUERY_INFORMATION
                                        SET_INFORMATION
                                        QUERY_INFORMATION2
                                        SET_INFORMATION2
                                        QUERY_PATH_INFORMATION
                                        SET_PATH_INFORMATION
                                        QUERY_FILE_INFORMATION
                                        SET_FILE_INFORMATION

        INCLUDE_SMB_LOCK            Lock requests (not LOCK_AND_READ)
                                        LOCK_BYTE_RANGE
                                        UNLOCK_BYTE_RANGE
                                        LOCKING_ANDX

        INCLUDE_SMB_RAW             Raw read/write requests:
                                        READ_RAW
                                        WRITE_RAW

        INCLUDE_SMB_MPX             Multiplexed requests:
                                        READ_MPX
                                        WRITE_MPX

        INCLUDE_SMB_SEARCH          Search requests:
                                        FIND_CLOSE2
                                        FIND_NOTIFY_CLOSE
                                        SEARCH
                                        FIND
                                        FIND_UNIQUE
                                        FIND_CLOSE

        INCLUDE_SMB_TRANSACTION     Transaction and IOCTL requests:
                                        TRANSACTION
                                        IOCTL
                                        TRANSACTION2
                                        NTTRANSACTION

        INCLUDE_SMB_PRINT           Printer requests:
                                        OPEN_PRINT_FILE
                                        WRITE_PRINT_FILE
                                        CLOSE_PRINT_FILE
                                        GET_PRINT_QUEUE

        INCLUDE_SMB_MESSAGE         Message requests:
                                        SEND_MESSAGE
                                        SEND_BROADCAST_MESSAGE
                                        FORWARD_USER_NAME
                                        CANCEL_FORWARD
                                        GET_MACHINE_NAME
                                        SEND_START_MB_MESSAGE
                                        SEND_END_MB_MESSAGE
                                        SEND_TEXT_MB_MESSAGE

        INCLUDE_SMB_MISC            Miscellaneous requests:
                                        QUERY_INFORMATION_SRV
                                        ECHO
                                        QUERY_INFORMATION_DISK
*/

#ifdef INCLUDE_SMB_ALL

#define INCLUDE_SMB_ADMIN
#define INCLUDE_SMB_TREE
#define INCLUDE_SMB_DIRECTORY
#define INCLUDE_SMB_OPEN_CLOSE
#define INCLUDE_SMB_FILE_CONTROL
#define INCLUDE_SMB_READ_WRITE
#define INCLUDE_SMB_LOCK
#define INCLUDE_SMB_RAW
#define INCLUDE_SMB_MPX
#define INCLUDE_SMB_QUERY_SET
#define INCLUDE_SMB_SEARCH
#define INCLUDE_SMB_TRANSACTION
#define INCLUDE_SMB_PRINT
#define INCLUDE_SMB_MESSAGE
#define INCLUDE_SMB_MISC

#endif // def INCLUDE_SMB_ALL


//
// Force misalignment of the following structures
//

#ifndef NO_PACKING
#include <packon.h>
#endif // ndef NO_PACKING

//
// SMB servers listen on two NETBIOS addresses to facilitate connections. The
// first one is a name formulated from the computer name by padding it with
// a number of blanks ( upto NETBIOS_NAME_LEN ). This name is registered and
// resolved using the NETBIOS name registration/resolution mechanism. They also
// register under a second name *SMBSERVER which is not a valuid netbios name
// but provides a name which can be used in NETBT session setup. This eliminates
// the need for querying the remote adapter status to obtain the name.
//

#define SMBSERVER_LOCAL_ENDPOINT_NAME "*SMBSERVER      "

//
// SMB Command code definitions:
//

// *** Start of SMB commands
#define SMB_COM_CREATE_DIRECTORY         (UCHAR)0x00
#define SMB_COM_DELETE_DIRECTORY         (UCHAR)0x01
#define SMB_COM_OPEN                     (UCHAR)0x02
#define SMB_COM_CREATE                   (UCHAR)0x03
#define SMB_COM_CLOSE                    (UCHAR)0x04
#define SMB_COM_FLUSH                    (UCHAR)0x05
#define SMB_COM_DELETE                   (UCHAR)0x06
#define SMB_COM_RENAME                   (UCHAR)0x07
#define SMB_COM_QUERY_INFORMATION        (UCHAR)0x08
#define SMB_COM_SET_INFORMATION          (UCHAR)0x09
#define SMB_COM_READ                     (UCHAR)0x0A
#define SMB_COM_WRITE                    (UCHAR)0x0B
#define SMB_COM_LOCK_BYTE_RANGE          (UCHAR)0x0C
#define SMB_COM_UNLOCK_BYTE_RANGE        (UCHAR)0x0D
#define SMB_COM_CREATE_TEMPORARY         (UCHAR)0x0E
#define SMB_COM_CREATE_NEW               (UCHAR)0x0F
#define SMB_COM_CHECK_DIRECTORY          (UCHAR)0x10
#define SMB_COM_PROCESS_EXIT             (UCHAR)0x11
#define SMB_COM_SEEK                     (UCHAR)0x12
#define SMB_COM_LOCK_AND_READ            (UCHAR)0x13
#define SMB_COM_WRITE_AND_UNLOCK         (UCHAR)0x14
#define SMB_COM_READ_RAW                 (UCHAR)0x1A
#define SMB_COM_READ_MPX                 (UCHAR)0x1B
#define SMB_COM_READ_MPX_SECONDARY       (UCHAR)0x1C    // server to redir only
#define SMB_COM_WRITE_RAW                (UCHAR)0x1D
#define SMB_COM_WRITE_MPX                (UCHAR)0x1E
#define SMB_COM_WRITE_MPX_SECONDARY      (UCHAR)0x1F
#define SMB_COM_WRITE_COMPLETE           (UCHAR)0x20    // server to redir only
#define SMB_COM_QUERY_INFORMATION_SRV    (UCHAR)0x21
#define SMB_COM_SET_INFORMATION2         (UCHAR)0x22
#define SMB_COM_QUERY_INFORMATION2       (UCHAR)0x23
#define SMB_COM_LOCKING_ANDX             (UCHAR)0x24
#define SMB_COM_TRANSACTION              (UCHAR)0x25
#define SMB_COM_TRANSACTION_SECONDARY    (UCHAR)0x26
#define SMB_COM_IOCTL                    (UCHAR)0x27
#define SMB_COM_IOCTL_SECONDARY          (UCHAR)0x28
#define SMB_COM_COPY                     (UCHAR)0x29
#define SMB_COM_MOVE                     (UCHAR)0x2A
#define SMB_COM_ECHO                     (UCHAR)0x2B
#define SMB_COM_WRITE_AND_CLOSE          (UCHAR)0x2C
#define SMB_COM_OPEN_ANDX                (UCHAR)0x2D
#define SMB_COM_READ_ANDX                (UCHAR)0x2E
#define SMB_COM_WRITE_ANDX               (UCHAR)0x2F
#define SMB_COM_CLOSE_AND_TREE_DISC      (UCHAR)0x31
#define SMB_COM_TRANSACTION2             (UCHAR)0x32
#define SMB_COM_TRANSACTION2_SECONDARY   (UCHAR)0x33
#define SMB_COM_FIND_CLOSE2              (UCHAR)0x34
#define SMB_COM_FIND_NOTIFY_CLOSE        (UCHAR)0x35
#define SMB_COM_TREE_CONNECT             (UCHAR)0x70
#define SMB_COM_TREE_DISCONNECT          (UCHAR)0x71
#define SMB_COM_NEGOTIATE                (UCHAR)0x72
#define SMB_COM_SESSION_SETUP_ANDX       (UCHAR)0x73
#define SMB_COM_LOGOFF_ANDX              (UCHAR)0x74
#define SMB_COM_TREE_CONNECT_ANDX        (UCHAR)0x75
#define SMB_COM_QUERY_INFORMATION_DISK   (UCHAR)0x80
#define SMB_COM_SEARCH                   (UCHAR)0x81
#define SMB_COM_FIND                     (UCHAR)0x82
#define SMB_COM_FIND_UNIQUE              (UCHAR)0x83
#define SMB_COM_FIND_CLOSE               (UCHAR)0x84
#define SMB_COM_NT_TRANSACT              (UCHAR)0xA0
#define SMB_COM_NT_TRANSACT_SECONDARY    (UCHAR)0xA1
#define SMB_COM_NT_CREATE_ANDX           (UCHAR)0xA2
#define SMB_COM_NT_CANCEL                (UCHAR)0xA4
#define SMB_COM_NT_RENAME                (UCHAR)0xA5
#define SMB_COM_OPEN_PRINT_FILE          (UCHAR)0xC0
#define SMB_COM_WRITE_PRINT_FILE         (UCHAR)0xC1
#define SMB_COM_CLOSE_PRINT_FILE         (UCHAR)0xC2
#define SMB_COM_GET_PRINT_QUEUE          (UCHAR)0xC3
#define SMB_COM_SEND_MESSAGE             (UCHAR)0xD0
#define SMB_COM_SEND_BROADCAST_MESSAGE   (UCHAR)0xD1
#define SMB_COM_FORWARD_USER_NAME        (UCHAR)0xD2
#define SMB_COM_CANCEL_FORWARD           (UCHAR)0xD3
#define SMB_COM_GET_MACHINE_NAME         (UCHAR)0xD4
#define SMB_COM_SEND_START_MB_MESSAGE    (UCHAR)0xD5
#define SMB_COM_SEND_END_MB_MESSAGE      (UCHAR)0xD6
#define SMB_COM_SEND_TEXT_MB_MESSAGE     (UCHAR)0xD7
// *** End of SMB commands

#define SMB_COM_NO_ANDX_COMMAND          (UCHAR)0xFF


//
// Header for SMBs, see #4 page 10
//
// *** Note that we do NOT define PSMB_HEADER as SMB_UNALIGNED!  This is
//     done on the assumption that the SMB header, at least, will always
//     be properly aligned.  If you need to access an unaligned header,
//     declare the pointer as SMB_UNALIGNED *SMB_HEADER.
//

#define SMB_SECURITY_SIGNATURE_LENGTH  8

typedef struct _SMB_HEADER {
    UCHAR Protocol[4];                  // Contains 0xFF,'SMB'
    UCHAR Command;                      // Command code
    UCHAR ErrorClass;                   // Error class
    UCHAR Reserved;                     // Reserved for future use
    _USHORT( Error );                   // Error code
    UCHAR Flags;                        // Flags
    _USHORT( Flags2 );                  // More flags
    union {
        _USHORT( Reserved2 )[6];        // Reserved for future use
        struct {
            _USHORT( PidHigh );         // High part of PID (NT Create And X)
            union {
                struct {
                    _ULONG( Key );              // Encryption key (IPX)
                    _USHORT( Sid );             // Session ID (IPX)
                    _USHORT( SequenceNumber );  // Sequence number (IPX)
                    _USHORT( Gid );             // Group ID (unused?)
                };
                UCHAR SecuritySignature[SMB_SECURITY_SIGNATURE_LENGTH];
                                         // Client must send the correct Signature
                                         // for this SMB to be accepted.
            };
        };
    };
    _USHORT( Tid );                     // Authenticated user/group
    _USHORT( Pid );                     // Caller's process id
    _USHORT( Uid );                     // Unauthenticated user id
    _USHORT( Mid );                     // multiplex id
#ifdef NO_PACKING                       // ***
    _USHORT( Kludge );                  // *** make sure parameter structs
#endif                                  // *** are longword aligned
} SMB_HEADER;
typedef SMB_HEADER *PSMB_HEADER;

typedef struct _NT_SMB_HEADER {
    UCHAR Protocol[4];                  // Contains 0xFF,'SMB'
    UCHAR Command;                      // Command code
    union {
        struct {
            UCHAR ErrorClass;           // Error class
            UCHAR Reserved;             // Reserved for future use
            _USHORT( Error );           // Error code
        } DosError;
        ULONG NtStatus;                 // NT-style 32-bit error code
    } Status;
    UCHAR Flags;                        // Flags
    _USHORT( Flags2 );                  // More flags
    union {
        _USHORT( Reserved2 )[6];        // Reserved for future use
        struct {
            _USHORT( PidHigh );         // High part of PID (NT Create And X)
            union {
                struct {
                    _ULONG( Key );              // Encryption key (IPX)
                    _USHORT( Sid );             // Session ID (IPX)
                    _USHORT( SequenceNumber );  // Sequence number (IPX)
                    _USHORT( Gid );             // Group ID (unused?)
                };
                UCHAR SecuritySignature[SMB_SECURITY_SIGNATURE_LENGTH];
                                         // Client must send the correct Signature
                                         // for this SMB to be accepted.
            };
        };
    };
    _USHORT( Tid );                     // Authenticated user/group
    _USHORT( Pid );                     // Caller's process id
    _USHORT( Uid );                     // Unauthenticated user id
    _USHORT( Mid );                     // multiplex id
#ifdef NO_PACKING                       // ***
    _USHORT( Kludge );                  // *** make sure parameter structs
#endif                                  // *** are longword aligned
} NT_SMB_HEADER;
typedef NT_SMB_HEADER *PNT_SMB_HEADER;

//
// The SMB header, protocol field, as a long.
//

#define SMB_HEADER_PROTOCOL   (0xFF + ('S' << 8) + ('M' << 16) + ('B' << 24))

//
// Minimum parameter structure that can be returned.  Used in returning
// error SMBs.
//
// *** Note that this structure does NOT have a Buffer field!
//

typedef struct _SMB_PARAMS {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of bytes that follow; min = 0
} SMB_PARAMS;
typedef SMB_PARAMS SMB_UNALIGNED *PSMB_PARAMS;

//
// Generic header for AndX commands.
//

typedef struct _GENERIC_ANDX {
    UCHAR WordCount;                    // Count of parameter words
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved
    _USHORT( AndXOffset );              // Offset (from SMB header start)
} GENERIC_ANDX;
typedef GENERIC_ANDX SMB_UNALIGNED *PGENERIC_ANDX;


#ifdef INCLUDE_SMB_MESSAGE

//
// Cancel Forward SMB, see #1 page 35
// Function is SrvSmbCancelForward()
// SMB_COM_CANCEL_FORWARD 0xD3
//

typedef struct _REQ_CANCEL_FORWARD {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR ForwardedName[];            //  Forwarded name
} REQ_CANCEL_FORWARD;
typedef REQ_CANCEL_FORWARD SMB_UNALIGNED *PREQ_CANCEL_FORWARD;

typedef struct _RESP_CANCEL_FORWARD {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_CANCEL_FORWARD;
typedef RESP_CANCEL_FORWARD SMB_UNALIGNED *PRESP_CANCEL_FORWARD;

#endif // def INCLUDE_SMB_MESSAGE

#ifdef INCLUDE_SMB_DIRECTORY

//
// Check Directory SMB, see #1 page 23
// Function is SrvSmbCheckDirectory()
// SMB_COM_CHECK_DIRECTORY 0x10
//

typedef struct _REQ_CHECK_DIRECTORY {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR DirectoryPath[];            //  Directory path
} REQ_CHECK_DIRECTORY;
typedef REQ_CHECK_DIRECTORY SMB_UNALIGNED *PREQ_CHECK_DIRECTORY;

typedef struct _RESP_CHECK_DIRECTORY {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_CHECK_DIRECTORY;
typedef RESP_CHECK_DIRECTORY SMB_UNALIGNED *PRESP_CHECK_DIRECTORY;

#endif // def INCLUDE_SMB_DIRECTORY

#ifdef INCLUDE_SMB_OPEN_CLOSE

//
// Close SMB, see #1 page 10
// Function is SrvSmbClose()
// SMB_COM_CLOSE 0x04
//

typedef struct _REQ_CLOSE {
    UCHAR WordCount;                    // Count of parameter words = 3
    _USHORT( Fid );                     // File handle
    _ULONG( LastWriteTimeInSeconds );   // Time of last write, low and high
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_CLOSE;
typedef REQ_CLOSE SMB_UNALIGNED *PREQ_CLOSE;

typedef struct _RESP_CLOSE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_CLOSE;
typedef RESP_CLOSE SMB_UNALIGNED *PRESP_CLOSE;

#endif // def INCLUDE_SMB_OPEN_CLOSE

#ifdef INCLUDE_SMB_OPEN_CLOSE

//
// Close and Tree Disconnect SMB, see #? page ??
// Function is SrvSmbCloseAndTreeDisc
// SMB_COM_CLOSE_AND_TREE_DISC 0x31
//

typedef struct _REQ_CLOSE_AND_TREE_DISC {
    UCHAR WordCount;                    // Count of parameter words
    _USHORT( Fid );                     // File handle
    _ULONG( LastWriteTimeInSeconds );
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_CLOSE_AND_TREE_DISC;
typedef REQ_CLOSE_AND_TREE_DISC SMB_UNALIGNED *PREQ_CLOSE_AND_TREE_DISC;

typedef struct _RESP_CLOSE_AND_TREE_DISC {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_CLOSE_AND_TREE_DISC;
typedef RESP_CLOSE_AND_TREE_DISC SMB_UNALIGNED *PRESP_CLOSE_AND_TREE_DISC;

#endif // def INCLUDE_SMB_OPEN_CLOSE

#ifdef INCLUDE_SMB_PRINT

//
// Close Print Spool File SMB, see #1 page 29
// Function is SrvSmbClosePrintSpoolFile()
// SMB_COM_CLOSE_PRINT_FILE 0xC2
//

typedef struct _REQ_CLOSE_PRINT_FILE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Fid );                     // File handle
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_CLOSE_PRINT_FILE;
typedef REQ_CLOSE_PRINT_FILE SMB_UNALIGNED *PREQ_CLOSE_PRINT_FILE;

typedef struct _RESP_CLOSE_PRINT_FILE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_CLOSE_PRINT_FILE;
typedef RESP_CLOSE_PRINT_FILE SMB_UNALIGNED *PRESP_CLOSE_PRINT_FILE;

#endif // def INCLUDE_SMB_PRINT

#ifdef INCLUDE_SMB_FILE_CONTROL

//
// Copy SMB, see #2 page 23
// Function is SrvSmbCopy()
// SMB_COM_COPY 0x29
//

typedef struct _REQ_COPY {
    UCHAR WordCount;                    // Count of parameter words = 3
    _USHORT( Tid2 );                    // Second (target) path TID
    _USHORT( OpenFunction );            // What to do if target file exists
    _USHORT( Flags );                   // Flags to control copy operation:
                                        //  bit 0 - target must be a file
                                        //  bit 1 - target must ba a dir.
                                        //  bit 2 - copy target mode:
                                        //          0 = binary, 1 = ASCII
                                        //  bit 3 - copy source mode:
                                        //          0 = binary, 1 = ASCII
                                        //  bit 4 - verify all writes
                                        //  bit 5 - tree copy
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR SourceFileName[];           //  pathname of source file
    //UCHAR TargetFileName[];           //  pathname of target file
} REQ_COPY;
typedef REQ_COPY SMB_UNALIGNED *PREQ_COPY;

typedef struct _RESP_COPY {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Count );                   // Number of files copied
    _USHORT( ByteCount );               // Count of data bytes; min = 0
    UCHAR Buffer[1];                    // ASCIIZ pathname of file with error
} RESP_COPY;
typedef RESP_COPY SMB_UNALIGNED *PRESP_COPY;

#endif // def INCLUDE_SMB_FILE_CONTROL

#ifdef INCLUDE_SMB_OPEN_CLOSE

//
// Create SMB, see #1 page 9
// Create New SMB, see #1 page 23
// Function is SrvSmbCreate()
// SMB_COM_CREATE 0x03
// SMB_COM_CREATE_NEW 0x0F
//

typedef struct _REQ_CREATE {
    UCHAR WordCount;                    // Count of parameter words = 3
    _USHORT( FileAttributes );          // New file attributes
    _ULONG( CreationTimeInSeconds );        // Creation time
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR FileName[];                 //  File name
} REQ_CREATE;
typedef REQ_CREATE SMB_UNALIGNED *PREQ_CREATE;

typedef struct _RESP_CREATE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Fid );                     // File handle
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_CREATE;
typedef RESP_CREATE SMB_UNALIGNED *PRESP_CREATE;

#endif // def INCLUDE_SMB_OPEN_CLOSE

#ifdef INCLUDE_SMB_DIRECTORY

//
// Create Directory SMB, see #1 page 14
// Function is SrvSmbCreateDirectory
// SMB_COM_CREATE_DIRECTORY 0x00
//

typedef struct _REQ_CREATE_DIRECTORY {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR DirectoryName[];            //  Directory name
} REQ_CREATE_DIRECTORY;
typedef REQ_CREATE_DIRECTORY SMB_UNALIGNED *PREQ_CREATE_DIRECTORY;

typedef struct _RESP_CREATE_DIRECTORY {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_CREATE_DIRECTORY;
typedef RESP_CREATE_DIRECTORY SMB_UNALIGNED *PRESP_CREATE_DIRECTORY;

#endif // def INCLUDE_SMB_DIRECTORY

#ifdef INCLUDE_SMB_OPEN_CLOSE

//
// Create Temporary SMB, see #1 page 21
// Function is SrvSmbCreateTemporary()
// SMB_COM_CREATE_TEMPORARY 0x0E
//

typedef struct _REQ_CREATE_TEMPORARY {
    UCHAR WordCount;                    // Count of parameter words = 3
    _USHORT( FileAttributes );
    _ULONG( CreationTimeInSeconds );
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR DirectoryName[];            //  Directory name
} REQ_CREATE_TEMPORARY;
typedef REQ_CREATE_TEMPORARY SMB_UNALIGNED *PREQ_CREATE_TEMPORARY;

typedef struct _RESP_CREATE_TEMPORARY {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Fid );                     // File handle
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR FileName[];                 //  File name
} RESP_CREATE_TEMPORARY;
typedef RESP_CREATE_TEMPORARY SMB_UNALIGNED *PRESP_CREATE_TEMPORARY;

#endif // def INCLUDE_SMB_OPEN_CLOSE

#ifdef INCLUDE_SMB_FILE_CONTROL

//
// Delete SMB, see #1 page 16
// Function is SrvSmbDelete()
// SMB_COM_DELETE 0x06
//

typedef struct _REQ_DELETE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( SearchAttributes );
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR FileName[];                 //  File name
} REQ_DELETE;
typedef REQ_DELETE SMB_UNALIGNED *PREQ_DELETE;

typedef struct _RESP_DELETE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_DELETE;
typedef RESP_DELETE SMB_UNALIGNED *PRESP_DELETE;

#endif // def INCLUDE_SMB_FILE_CONTROL

#ifdef INCLUDE_SMB_DIRECTORY

//
// Delete Directory SMB, see #1 page 15
// Function is SrvSmbDeleteDirectory()
// SMB_COM_DELETE_DIRECTORY 0x01
//

typedef struct _REQ_DELETE_DIRECTORY {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR DirectoryName[];            //  Directory name
} REQ_DELETE_DIRECTORY;
typedef REQ_DELETE_DIRECTORY SMB_UNALIGNED *PREQ_DELETE_DIRECTORY;

typedef struct _RESP_DELETE_DIRECTORY {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_DELETE_DIRECTORY;
typedef RESP_DELETE_DIRECTORY SMB_UNALIGNED *PRESP_DELETE_DIRECTORY;

#endif // def INCLUDE_SMB_DIRECTORY

#ifdef INCLUDE_SMB_MISC

//
// Echo SMB, see #2 page 25
// Function is SrvSmbEcho()
// SMB_COM_ECHO 0x2B
//

typedef struct _REQ_ECHO {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( EchoCount );               // Number of times to echo data back
    _USHORT( ByteCount );               // Count of data bytes; min = 4
    UCHAR Buffer[1];                    // Data to echo
} REQ_ECHO;
typedef REQ_ECHO SMB_UNALIGNED *PREQ_ECHO;

typedef struct _RESP_ECHO {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( SequenceNumber );          // Sequence number of this echo
    _USHORT( ByteCount );               // Count of data bytes; min = 4
    UCHAR Buffer[1];                    // Echoed data
} RESP_ECHO;
typedef RESP_ECHO SMB_UNALIGNED *PRESP_ECHO;

#endif // def INCLUDE_SMB_MISC

#ifdef INCLUDE_SMB_SEARCH

//
// Find Close2 SMB, see #3 page 54
// Function is SrvFindClose2()
// SMB_COM_FIND_CLOSE2 0x34
//

typedef struct _REQ_FIND_CLOSE2 {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Sid );                     // Find handle
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_FIND_CLOSE2;
typedef REQ_FIND_CLOSE2 SMB_UNALIGNED *PREQ_FIND_CLOSE2;

typedef struct _RESP_FIND_CLOSE2 {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_FIND_CLOSE2;
typedef RESP_FIND_CLOSE2 SMB_UNALIGNED *PRESP_FIND_CLOSE2;

#endif // def INCLUDE_SMB_SEARCH

#ifdef INCLUDE_SMB_SEARCH

//
// Find Notify Close SMB, see #3 page 53
// Function is SrvSmbFindNotifyClose()
// SMB_COM_FIND_NOTIFY_CLOSE 0x35
//

typedef struct _REQ_FIND_NOTIFY_CLOSE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Handle );                  // Find notify handle
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_FIND_NOTIFY_CLOSE;
typedef REQ_FIND_NOTIFY_CLOSE SMB_UNALIGNED *PREQ_FIND_NOTIFY_CLOSE;

typedef struct _RESP_FIND_NOTIFY_CLOSE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_FIND_NOTIFY_CLOSE;
typedef RESP_FIND_NOTIFY_CLOSE SMB_UNALIGNED *PRESP_FIND_NOTIFY_CLOSE;

#endif // def INCLUDE_SMB_SEARCH

#ifdef INCLUDE_SMB_FILE_CONTROL

//
// Flush SMB, see #1 page 11
// Function is SrvSmbFlush()
// SMB_COM_FLUSH 0x05
//

typedef struct _REQ_FLUSH {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Fid );                     // File handle
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_FLUSH;
typedef REQ_FLUSH SMB_UNALIGNED *PREQ_FLUSH;

typedef struct _RESP_FLUSH {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_FLUSH;
typedef RESP_FLUSH SMB_UNALIGNED *PRESP_FLUSH;

#endif // def INCLUDE_SMB_FILE_CONTROL

#ifdef INCLUDE_SMB_MESSAGE

//
// Forward User Name SMB, see #1 page 34
// Function is SrvSmbForwardUserName()
// SMB_COM_FORWARD_USER_NAME 0xD2
//

typedef struct _REQ_FORWARD_USER_NAME {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR ForwardedName[];            //  Forwarded name
} REQ_FORWARD_USER_NAME;
typedef REQ_FORWARD_USER_NAME SMB_UNALIGNED *PREQ_FORWARD_USER_NAME;

typedef struct _RESP_FORWARD_USER_NAME {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_FORWARD_USER_NAME;
typedef RESP_FORWARD_USER_NAME SMB_UNALIGNED *PRESP_FORWARD_USER_NAME;

#endif // def INCLUDE_SMB_MESSAGE

#ifdef INCLUDE_SMB_MESSAGE

//
// Get Machine Name SMB, see #1 page 35
// Function is SrvSmbGetMachineName()
// SMB_COM_GET_MACHINE_NAME 0xD4
//

typedef struct _REQ_GET_MACHINE_NAME {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_GET_MACHINE_NAME;
typedef REQ_GET_MACHINE_NAME SMB_UNALIGNED *PREQ_GET_MACHINE_NAME;

typedef struct _RESP_GET_MACHINE_NAME {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR MachineName[];              //  Machine name
} RESP_GET_MACHINE_NAME;
typedef RESP_GET_MACHINE_NAME SMB_UNALIGNED *PRESP_GET_MACHINE_NAME;

#endif // def INCLUDE_SMB_MESSAGE

#ifdef INCLUDE_SMB_PRINT

//
// Get Print Queue SMB, see #1 page 29
// Function is SrvSmbGetPrintQueue()
// SMB_COM_GET_PRINT_QUEUE 0xC3
//

typedef struct _REQ_GET_PRINT_QUEUE {
    UCHAR WordCount;                    // Count of parameter words = 2
    _USHORT( MaxCount );                // Max number of entries to return
    _USHORT( StartIndex );              // First queue entry to return
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_GET_PRINT_QUEUE;
typedef REQ_GET_PRINT_QUEUE SMB_UNALIGNED *PREQ_GET_PRINT_QUEUE;

typedef struct _RESP_GET_PRINT_QUEUE {
    UCHAR WordCount;                    // Count of parameter words = 2
    _USHORT( Count );                   // Number of entries returned
    _USHORT( RestartIndex );            // Index of entry after last returned
    _USHORT( ByteCount );               // Count of data bytes; min = 3
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x01 -- Data block
    //USHORT DataLength;                //  Length of data
    //UCHAR Data[];                     //  Queue elements
} RESP_GET_PRINT_QUEUE;
typedef RESP_GET_PRINT_QUEUE SMB_UNALIGNED *PRESP_GET_PRINT_QUEUE;

#endif // def INCLUDE_SMB_PRINT

#ifdef INCLUDE_SMB_TRANSACTION

//
// Ioctl SMB, see #2 page 39
// Function is SrvSmbIoctl()
// SMB_COM_IOCTL 0x27
// SMB_COM_IOCTL_SECONDARY 0x28
//

typedef struct _REQ_IOCTL {
    UCHAR WordCount;                    // Count of parameter words = 14
    _USHORT( Fid );                     // File handle
    _USHORT( Category );                // Device category
    _USHORT( Function );                // Device function
    _USHORT( TotalParameterCount );     // Total parameter bytes being sent
    _USHORT( TotalDataCount );          // Total data bytes being sent
    _USHORT( MaxParameterCount );       // Max parameter bytes to return
    _USHORT( MaxDataCount );            // Max data bytes to return
    _ULONG( Timeout );
    _USHORT( Reserved );
    _USHORT( ParameterCount );          // Parameter bytes sent this buffer
    _USHORT( ParameterOffset );         // Offset (from header start) to params
    _USHORT( DataCount );               // Data bytes sent this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Parameters[];               //  Parameter bytes (# = ParameterCount)
    //UCHAR Pad1[];                     //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data bytes (# = DataCount)
} REQ_IOCTL;
typedef REQ_IOCTL SMB_UNALIGNED *PREQ_IOCTL;

typedef struct _RESP_IOCTL_INTERIM {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_IOCTL_INTERIM;
typedef RESP_IOCTL_INTERIM SMB_UNALIGNED *PRESP_IOCTL_INTERIM;

typedef struct _REQ_IOCTL_SECONDARY {
    UCHAR WordCount;                    // Count of parameter words = 8
    _USHORT( TotalParameterCount );     // Total parameter bytes being sent
    _USHORT( TotalDataCount );          // Total data bytes being sent
    _USHORT( ParameterCount );          // Parameter bytes sent this buffer
    _USHORT( ParameterOffset );         // Offset (from header start) to params
    _USHORT( ParameterDisplacement );   // Displacement of these param bytes
    _USHORT( DataCount );               // Data bytes sent this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( DataDisplacement );        // Displacement of these data bytes
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Parameters[];               //  Parameter bytes (# = ParameterCount)
    //UCHAR Pad1[];                     //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data bytes (# = DataCount)
} REQ_IOCTL_SECONDARY;
typedef REQ_IOCTL_SECONDARY SMB_UNALIGNED *PREQ_IOCTL_SECONDARY;

typedef struct _RESP_IOCTL {
    UCHAR WordCount;                    // Count of parameter words = 8
    _USHORT( TotalParameterCount );     // Total parameter bytes being sent
    _USHORT( TotalDataCount );          // Total data bytes being sent
    _USHORT( ParameterCount );          // Parameter bytes sent this buffer
    _USHORT( ParameterOffset );         // Offset (from header start) to params
    _USHORT( ParameterDisplacement );   // Displacement of these param bytes
    _USHORT( DataCount );               // Data bytes sent this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( DataDisplacement );        // Displacement of these data bytes
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Parameters[];               //  Parameter bytes (# = ParameterCount)
    //UCHAR Pad1[];                     //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data bytes (# = DataCount)
} RESP_IOCTL;
typedef RESP_IOCTL SMB_UNALIGNED *PRESP_IOCTL;

#endif // def INCLUDE_SMB_TRANSACTION

#ifdef INCLUDE_SMB_LOCK

//
// Lock Byte Range SMB, see #1 page 20
// Function is SrvSmbLockByteRange()
// SMB_COM_LOCK_BYTE_RANGE 0x0C
//

typedef struct _REQ_LOCK_BYTE_RANGE {
    UCHAR WordCount;                    // Count of parameter words = 5
    _USHORT( Fid );                     // File handle
    _ULONG( Count );                    // Count of bytes to lock
    _ULONG( Offset );                   // Offset from start of file
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_LOCK_BYTE_RANGE;
typedef REQ_LOCK_BYTE_RANGE SMB_UNALIGNED *PREQ_LOCK_BYTE_RANGE;

typedef struct _RESP_LOCK_BYTE_RANGE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_LOCK_BYTE_RANGE;
typedef RESP_LOCK_BYTE_RANGE SMB_UNALIGNED *PRESP_LOCK_BYTE_RANGE;

#endif // def INCLUDE_SMB_LOCK

#ifdef INCLUDE_SMB_LOCK

//
// Locking and X SMB, see #2 page 46
// Function is SrvLockingAndX()
// SMB_COM_LOCKING_ANDX 0x24
//

typedef struct _REQ_LOCKING_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 8
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Fid );                     // File handle

    //
    // When NT protocol is not negotiated the OplockLevel field is
    // omitted, and LockType field is a full word.  Since the upper
    // bits of LockType are never used, this definition works for
    // all protocols.
    //

    UCHAR( LockType );                  // Locking mode:
                                        //  bit 0: 0 = lock out all access
                                        //         1 = read OK while locked
                                        //  bit 1: 1 = 1 user total file unlock
    UCHAR( OplockLevel );               // The new oplock level
    _ULONG( Timeout );
    _USHORT( NumberOfUnlocks );         // Num. unlock range structs following
    _USHORT( NumberOfLocks );           // Num. lock range structs following
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //LOCKING_ANDX_RANGE Unlocks[];     //  Unlock ranges
    //LOCKING_ANDX_RANGE Locks[];       //  Lock ranges
} REQ_LOCKING_ANDX;
typedef REQ_LOCKING_ANDX SMB_UNALIGNED *PREQ_LOCKING_ANDX;

#define LOCKING_ANDX_SHARED_LOCK     0x01
#define LOCKING_ANDX_OPLOCK_RELEASE  0x02
#define LOCKING_ANDX_CHANGE_LOCKTYPE 0x04
#define LOCKING_ANDX_CANCEL_LOCK     0x08
#define LOCKING_ANDX_LARGE_FILES     0x10

#define OPLOCK_BROKEN_TO_NONE        0
#define OPLOCK_BROKEN_TO_II          1

typedef struct _LOCKING_ANDX_RANGE {
    _USHORT( Pid );                     // PID of process "owning" lock
    _ULONG( Offset );                   // Ofset to bytes to [un]lock
    _ULONG( Length );                   // Number of bytes to [un]lock
} LOCKING_ANDX_RANGE;
typedef LOCKING_ANDX_RANGE SMB_UNALIGNED *PLOCKING_ANDX_RANGE;

typedef struct _NT_LOCKING_ANDX_RANGE {
    _USHORT( Pid );                     // PID of process "owning" lock
    _USHORT( Pad );                     // Pad to DWORD align (mbz)
    _ULONG( OffsetHigh );               // Ofset to bytes to [un]lock (high)
    _ULONG( OffsetLow );                // Ofset to bytes to [un]lock (low)
    _ULONG( LengthHigh );               // Number of bytes to [un]lock (high)
    _ULONG( LengthLow );                // Number of bytes to [un]lock (low)
} NTLOCKING_ANDX_RANGE;
typedef NTLOCKING_ANDX_RANGE SMB_UNALIGNED *PNTLOCKING_ANDX_RANGE;
                                        //
typedef struct _RESP_LOCKING_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 2
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_LOCKING_ANDX;
typedef RESP_LOCKING_ANDX SMB_UNALIGNED *PRESP_LOCKING_ANDX;

#define LOCK_BROKEN_SIZE 51             // # of bytes in lock broken notify

#endif // def INCLUDE_SMB_LOCK

#ifdef INCLUDE_SMB_ADMIN

//
// Logoff and X SMB, see #3, page 55
// SMB_COM_LOGOFF_ANDX 0x74
//

typedef struct _REQ_LOGOFF_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 2
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_LOGOFF_ANDX;
typedef REQ_LOGOFF_ANDX SMB_UNALIGNED *PREQ_LOGOFF_ANDX;

typedef struct _RESP_LOGOFF_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 2
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_LOGOFF_ANDX;
typedef RESP_LOGOFF_ANDX SMB_UNALIGNED *PRESP_LOGOFF_ANDX;

#endif // def INCLUDE_SMB_ADMIN

#ifdef INCLUDE_SMB_FILE_CONTROL

//
// Move SMB, see #2 page 49
// Funcion is SrvSmbMove()
// SMB_COM_MOVE 0x2A
//

typedef struct _REQ_MOVE {
    UCHAR WordCount;                    // Count of parameter words = 3
    _USHORT( Tid2 );                    // Second (target) file id
    _USHORT( OpenFunction );            // what to do if target file exists
    _USHORT( Flags );                   // Flags to control move operations:
                                        //  0 - target must be a file
                                        //  1 - target must be a directory
                                        //  2 - reserved (must be 0)
                                        //  3 - reserved (must be 0)
                                        //  4 - verify all writes
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR OldFileName[];              //  Old file name
    //UCHAR NewFileName[];              //  New file name
} REQ_MOVE;
typedef REQ_MOVE SMB_UNALIGNED *PREQ_MOVE;

typedef struct _RESP_MOVE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Count );                   // Number of files moved
    _USHORT( ByteCount );               // Count of data bytes; min = 0
    UCHAR Buffer[1];                    // Pathname of file where error occurred
} RESP_MOVE;
typedef RESP_MOVE SMB_UNALIGNED *PRESP_MOVE;

#endif // def INCLUDE_SMB_FILE_CONTROL

#ifdef INCLUDE_SMB_ADMIN

//
// Negotiate SMB's for Net 1 and Net 3, see #1 page 25 and #2 page 20
// Function is SrvSmbNegotiate()
// SMB_COM_NEGOTIATE 0x72
//

typedef struct _REQ_NEGOTIATE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //struct {
    //  UCHAR BufferFormat;             //  0x02 -- Dialect
    //  UCHAR DialectName[];            //  ASCIIZ
    //} Dialects[];
} REQ_NEGOTIATE;
typedef REQ_NEGOTIATE *PREQ_NEGOTIATE;  // *** NOT SMB_UNALIGNED!

typedef struct _RESP_NEGOTIATE {
    UCHAR WordCount;                    // Count of parameter words = 13
    _USHORT( DialectIndex );            // Index of selected dialect
    _USHORT( SecurityMode );            // Security mode:
                                        //  bit 0: 0 = share, 1 = user
                                        //  bit 1: 1 = encrypt passwords
                                        //  bit 2: 1 = SMB security signatures enabled
                                        //  bit 3: 1 = SMB security signatures required
    _USHORT( MaxBufferSize );           // Max transmit buffer size
    _USHORT( MaxMpxCount );             // Max pending multiplexed requests
    _USHORT( MaxNumberVcs );            // Max VCs between client and server
    _USHORT( RawMode );                 // Raw modes supported:
                                        //  bit 0: 1 = Read Raw supported
                                        //  bit 1: 1 = Write Raw supported
    _ULONG( SessionKey );
    SMB_TIME ServerTime;                // Current time at server
    SMB_DATE ServerDate;                // Current date at server
    _USHORT( ServerTimeZone );          // Current time zone at server
    _USHORT( EncryptionKeyLength );     // MBZ if this is not LM2.1
    _USHORT( Reserved );                // MBZ
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Password encryption key
    //UCHAR EncryptionKey[];            // The challenge encryption key
    //UCHAR PrimaryDomain[];            // The server's primary domain (2.1 only)
} RESP_NEGOTIATE;
typedef RESP_NEGOTIATE *PRESP_NEGOTIATE;    // *** NOT SMB_UNALIGNED!

// Macros for SecurityMode field, above
#define NEGOTIATE_USER_SECURITY                     0x01
#define NEGOTIATE_ENCRYPT_PASSWORDS                 0x02
#define NEGOTIATE_SECURITY_SIGNATURES_ENABLED       0x04
#define NEGOTIATE_SECURITY_SIGNATURES_REQUIRED      0x08

// Macros for RawMode field, above
#define NEGOTIATE_READ_RAW_SUPPORTED    1
#define NEGOTIATE_WRITE_RAW_SUPPORTED   2

typedef struct _RESP_OLD_NEGOTIATE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( DialectIndex );            // Index of selected dialect
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_OLD_NEGOTIATE;
typedef RESP_OLD_NEGOTIATE *PRESP_OLD_NEGOTIATE;    // *** NOT SMB_UNALIGNED!

typedef struct _RESP_NT_NEGOTIATE {
    UCHAR WordCount;                    // Count of parameter words = 17
    _USHORT( DialectIndex );            // Index of selected dialect
    UCHAR( SecurityMode );              // Security mode:
                                        //  bit 0: 0 = share, 1 = user
                                        //  bit 1: 1 = encrypt passwords
                                        //  bit 2: 1 = SMB sequence numbers enabled
                                        //  bit 3: 1 = SMB sequence numbers required
    _USHORT( MaxMpxCount );             // Max pending multiplexed requests
    _USHORT( MaxNumberVcs );            // Max VCs between client and server
    _ULONG( MaxBufferSize );            // Max transmit buffer size
    _ULONG( MaxRawSize );               // Maximum raw buffer size
    _ULONG( SessionKey );
    _ULONG( Capabilities );             // Server capabilities
    _ULONG( SystemTimeLow );            // System (UTC) time of the server (low).
    _ULONG( SystemTimeHigh );           // System (UTC) time of the server (high).
    _USHORT( ServerTimeZone );          // Time zone of server (min from UTC)
    UCHAR( EncryptionKeyLength );       // Length of encryption key.
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Password encryption key
    //UCHAR EncryptionKey[];            // The challenge encryption key
    //UCHAR OemDomainName[];            // The name of the domain (in OEM chars)
} RESP_NT_NEGOTIATE;
typedef RESP_NT_NEGOTIATE *PRESP_NT_NEGOTIATE;  // *** NOT SMB_UNALIGNED!

#endif // def INCLUDE_SMB_ADMIN

//
// Server / workstation capabilities
// N.B. Most messages use a ULONG for this, so there are many more
// bits available.
//

#define CAP_RAW_MODE            0x0001
#define CAP_MPX_MODE            0x0002
#define CAP_UNICODE             0x0004
#define CAP_LARGE_FILES         0x0008
#define CAP_NT_SMBS             0x0010
#define CAP_RPC_REMOTE_APIS     0x0020
#define CAP_NT_STATUS           0x0040
#define CAP_LEVEL_II_OPLOCKS    0x0080
#define CAP_LOCK_AND_READ       0x0100
#define CAP_NT_FIND             0x0200
#define CAP_DFS                 0x1000       // This server is DFS aware
#define CAP_INFOLEVEL_PASSTHRU  0x2000       // NT information level requests can pass through
#define CAP_LARGE_READX         0x4000       // Server supports oversized READ&X on files
#define CAP_LARGE_WRITEX        0x8000

#ifdef INCLUDE_SMB_OPEN_CLOSE

//
// Open SMB, see #1, page 7
// Function is SrvSmbOpen()
// SMB_COM_OPEN 0x02
//

typedef struct _REQ_OPEN {
    UCHAR WordCount;                    // Count of parameter words = 2
    _USHORT( DesiredAccess );           // Mode - read/write/share
    _USHORT( SearchAttributes );
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR FileName[];                 //  File name
} REQ_OPEN;
typedef REQ_OPEN SMB_UNALIGNED *PREQ_OPEN;

typedef struct _RESP_OPEN {
    UCHAR WordCount;                    // Count of parameter words = 7
    _USHORT( Fid );                     // File handle
    _USHORT( FileAttributes );
    _ULONG( LastWriteTimeInSeconds );
    _ULONG( DataSize );                 // File size
    _USHORT( GrantedAccess );           // Access allowed
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_OPEN;
typedef RESP_OPEN SMB_UNALIGNED *PRESP_OPEN;

#endif // def INCLUDE_SMB_OPEN_CLOSE

#ifdef INCLUDE_SMB_OPEN_CLOSE

//
// Open and X SMB, see #2 page 51
// Function is SrvOpenAndX()
// SMB_COM_OPEN_ANDX 0x2D
//

typedef struct _REQ_OPEN_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 15
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Flags );                   // Additional information: bit set-
                                        //  0 - return additional info
                                        //  1 - set single user total file lock
                                        //  2 - server notifies consumer of
                                        //      actions which may change file
                                        //  4 - return extended response
    _USHORT( DesiredAccess );           // File open mode
    _USHORT( SearchAttributes );
    _USHORT( FileAttributes );
    _ULONG( CreationTimeInSeconds );
    _USHORT( OpenFunction );
    _ULONG( AllocationSize );           // Bytes to reserve on create or truncate
    _ULONG( Timeout );                  // Max milliseconds to wait for resource
    _ULONG( Reserved );                 // Reserved (must be 0)
    _USHORT( ByteCount );               // Count of data bytes; min = 1
    UCHAR Buffer[1];                    // File name
} REQ_OPEN_ANDX;
typedef REQ_OPEN_ANDX SMB_UNALIGNED *PREQ_OPEN_ANDX;

typedef struct _RESP_OPEN_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 15
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Fid );                     // File handle
    _USHORT( FileAttributes );
    _ULONG( LastWriteTimeInSeconds );
    _ULONG( DataSize );                 // Current file size
    _USHORT( GrantedAccess );           // Access permissions actually allowed
    _USHORT( FileType );
    _USHORT( DeviceState );             // state of IPC device (e.g. pipe)
    _USHORT( Action );                  // Action taken
    _ULONG( ServerFid );                // Server unique file id
    _USHORT( Reserved );                // Reserved (must be 0)
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_OPEN_ANDX;
typedef RESP_OPEN_ANDX SMB_UNALIGNED *PRESP_OPEN_ANDX;

typedef struct _REQ_NT_CREATE_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 24
    UCHAR AndXCommand;                  // Secondary command; 0xFF = None
    UCHAR AndXReserved;                 // MBZ
    _USHORT( AndXOffset );              // Offset to next command wordcount
    UCHAR Reserved;                     // MBZ
    _USHORT( NameLength );              // Length of Name[] in bytes
    _ULONG( Flags );                    // Create flags
    _ULONG( RootDirectoryFid );         // If non-zero, open is relative to this directory
    ACCESS_MASK DesiredAccess;          // NT access desired
    LARGE_INTEGER AllocationSize;       // Initial allocation size
    _ULONG( FileAttributes );           // File attributes for creation
    _ULONG( ShareAccess );              // Type of share access
    _ULONG( CreateDisposition );        // Action to take if file exists or not
    _ULONG( CreateOptions );            // Options to use if creating a file
    _ULONG( ImpersonationLevel );       // Security QOS information
    UCHAR SecurityFlags;                // Security QOS information
    _USHORT( ByteCount );               // Length of byte parameters
    UCHAR Buffer[1];
    //UCHAR Name[];                       // File to open or create
} REQ_NT_CREATE_ANDX;
typedef REQ_NT_CREATE_ANDX SMB_UNALIGNED *PREQ_NT_CREATE_ANDX;

// Flag bit for Security flags

#define SMB_SECURITY_DYNAMIC_TRACKING   0x01
#define SMB_SECURITY_EFFECTIVE_ONLY     0x02

typedef struct _RESP_NT_CREATE_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 26
    UCHAR AndXCommand;                  // Secondary command; 0xFF = None
    UCHAR AndXReserved;                 // MBZ
    _USHORT( AndXOffset );              // Offset to next command wordcount
    UCHAR OplockLevel;                  // The oplock level granted
    _USHORT( Fid );                     // The file ID
    _ULONG( CreateAction );             // The action taken
    TIME CreationTime;                  // The time the file was created
    TIME LastAccessTime;                // The time the file was accessed
    TIME LastWriteTime;                 // The time the file was last written
    TIME ChangeTime;                    // The time the file was last changed
    _ULONG( FileAttributes );           // The file attributes
    LARGE_INTEGER AllocationSize;       // The number of byes allocated
    LARGE_INTEGER EndOfFile;            // The end of file offset
    _USHORT( FileType );
    union {
        _USHORT( DeviceState );         // state of IPC device (e.g. pipe)
        _USHORT( FileStatusFlags );     // if a file or directory.  See below.
    };
    BOOLEAN Directory;                  // TRUE if this is a directory
    _USHORT( ByteCount );               // = 0
    UCHAR Buffer[1];
} RESP_NT_CREATE_ANDX;
typedef RESP_NT_CREATE_ANDX SMB_UNALIGNED *PRESP_NT_CREATE_ANDX;

//
// Values for FileStatusFlags, if the opened resource is a file or directory
//
#define SMB_FSF_NO_EAS          0x0001   // file/dir has no extended attributes
#define SMB_FSF_NO_SUBSTREAMS   0x0002   // file/dir has no substreams
#define SMB_FSF_NO_REPARSETAG   0x0004   // file/dir is not a reparse point


#define SMB_OPLOCK_LEVEL_NONE       0
#define SMB_OPLOCK_LEVEL_EXCLUSIVE  1
#define SMB_OPLOCK_LEVEL_BATCH      2
#define SMB_OPLOCK_LEVEL_II         3

#endif // def INCLUDE_SMB_OPEN_CLOSE

#ifdef INCLUDE_SMB_PRINT

//
// Open Print File SMB, see #1 page 27
// Function is SrvSmbOpenPrintFile()
// SMB_COM_OPEN_PRINT_FILE 0xC0
//

typedef struct _REQ_OPEN_PRINT_FILE {
    UCHAR WordCount;                    // Count of parameter words = 2
    _USHORT( SetupLength );             // Length of printer setup data
    _USHORT( Mode );                    // 0 = Text mode (DOS expands TABs)
                                        // 1 = Graphics mode
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR IdentifierString[];         //  Identifier string
} REQ_OPEN_PRINT_FILE;
typedef REQ_OPEN_PRINT_FILE SMB_UNALIGNED *PREQ_OPEN_PRINT_FILE;

typedef struct _RESP_OPEN_PRINT_FILE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Fid );                     // File handle
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_OPEN_PRINT_FILE;
typedef RESP_OPEN_PRINT_FILE SMB_UNALIGNED *PRESP_OPEN_PRINT_FILE;

#endif // def INCLUDE_SMB_PRINT

#ifdef INCLUDE_SMB_ADMIN

//
// Process Exit SMB, see #1 page 22
// Function is SrvSmbProcessExit()
// SMB_COM_PROCESS_EXIT 0x11
//

typedef struct _REQ_PROCESS_EXIT {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_PROCESS_EXIT;
typedef REQ_PROCESS_EXIT SMB_UNALIGNED *PREQ_PROCESS_EXIT;

typedef struct _RESP_PROCESS_EXIT {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_PROCESS_EXIT;
typedef RESP_PROCESS_EXIT SMB_UNALIGNED *PRESP_PROCESS_EXIT;

#endif // def INCLUDE_SMB_ADMIN

#ifdef INCLUDE_SMB_QUERY_SET

//
// Query Information SMB, see #1 page 18
// Function is SrvSmbQueryInformation()
// SMB_COM_QUERY_INFORMATION 0x08
//

typedef struct _REQ_QUERY_INFORMATION {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR FileName[];                 //  File name
} REQ_QUERY_INFORMATION;
typedef REQ_QUERY_INFORMATION SMB_UNALIGNED *PREQ_QUERY_INFORMATION;

typedef struct _RESP_QUERY_INFORMATION {
    UCHAR WordCount;                    // Count of parameter words = 10
    _USHORT( FileAttributes );
    _ULONG( LastWriteTimeInSeconds );
    _ULONG( FileSize );                 // File size
    _USHORT( Reserved )[5];             // Reserved (must be 0)
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_QUERY_INFORMATION;
typedef RESP_QUERY_INFORMATION SMB_UNALIGNED *PRESP_QUERY_INFORMATION;

#endif // def INCLUDE_SMB_QUERY_SET

#ifdef INCLUDE_SMB_QUERY_SET

//
// Query Information2 SMB, see #2 page 37
// Function is SrvSmbQueryInformation2()
// SMB_COM_QUERY_INFORMATION2 0x23
//

typedef struct _REQ_QUERY_INFORMATION2 {
    UCHAR WordCount;                    // Count of parameter words = 2
    _USHORT( Fid );                     // File handle
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_QUERY_INFORMATION2;
typedef REQ_QUERY_INFORMATION2 SMB_UNALIGNED *PREQ_QUERY_INFORMATION2;

typedef struct _RESP_QUERY_INFORMATION2 {
    UCHAR WordCount;                    // Count of parameter words = 11
    SMB_DATE CreationDate;
    SMB_TIME CreationTime;
    SMB_DATE LastAccessDate;
    SMB_TIME LastAccessTime;
    SMB_DATE LastWriteDate;
    SMB_TIME LastWriteTime;
    _ULONG( FileDataSize );             // File end of data
    _ULONG( FileAllocationSize );       // File allocation size
    _USHORT( FileAttributes );
    _USHORT( ByteCount );               // Count of data bytes; min = 0
    UCHAR Buffer[1];                    // Reserved buffer
} RESP_QUERY_INFORMATION2;
typedef RESP_QUERY_INFORMATION2 SMB_UNALIGNED *PRESP_QUERY_INFORMATION2;

#endif // def INCLUDE_SMB_QUERY_SET

#ifdef INCLUDE_SMB_MISC

//
// Query Information Disk SMB, see #1 page 24
// Function is SrvSmbQueryInformationDisk()
// SMB_COM_QUERY_INFORMATION_DISK 0x80
//

typedef struct _REQ_QUERY_INFORMATION_DISK {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_QUERY_INFORMATION_DISK;
typedef REQ_QUERY_INFORMATION_DISK SMB_UNALIGNED *PREQ_QUERY_INFORMATION_DISK;

typedef struct _RESP_QUERY_INFORMATION_DISK {
    UCHAR WordCount;                    // Count of parameter words = 5
    _USHORT( TotalUnits );              // Total allocation units per server
    _USHORT( BlocksPerUnit );           // Blocks per allocation unit
    _USHORT( BlockSize );               // Block size (in bytes)
    _USHORT( FreeUnits );               // Number of free units
    _USHORT( Reserved );                // Reserved (media identification code)
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_QUERY_INFORMATION_DISK;
typedef RESP_QUERY_INFORMATION_DISK SMB_UNALIGNED *PRESP_QUERY_INFORMATION_DISK;

#endif // def INCLUDE_SMB_MISC

#ifdef INCLUDE_SMB_MISC

//
// Query Server Information SMB, see #? page ??
// Function is SrvSmbQueryInformationServer
// SMB_COM_QUERY_INFORMATION_SRV 0x21
//

typedef struct _REQ_QUERY_INFORMATION_SRV {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Mode );
    _USHORT( ByteCount );               // Count of data bytes; min =
    UCHAR Buffer[1];                    //
} REQ_QUERY_INFORMATION_SRV;
typedef REQ_QUERY_INFORMATION_SRV SMB_UNALIGNED *PREQ_QUERY_INFORMATION_SRV;

typedef struct _RESP_QUERY_INFORMATION_SRV {
    UCHAR WordCount;                    // Count of parameter words = 20
    _ULONG( smb_fsid );
    _ULONG( BlocksPerUnit );
    _ULONG( smb_aunits );
    _ULONG( smb_fau );
    _USHORT( BlockSize );
    SMB_DATE smb_vldate;
    SMB_TIME smb_vltime;
    UCHAR smb_vllen;
    UCHAR Reserved;                     // Reserved (must be 0)
    _USHORT( SecurityMode );
    _USHORT( BlockMode );
    _ULONG( Services );
    _USHORT( MaxTransmitSize );
    _USHORT( MaxMpxCount );
    _USHORT( MaxNumberVcs );
    SMB_TIME ServerTime;
    SMB_DATE ServerDate;
    _USHORT( ServerTimeZone );
    _ULONG( Reserved2 );
    _USHORT( ByteCount );               // Count of data bytes; min =
    UCHAR Buffer[1];                    //
} RESP_QUERY_INFORMATION_SRV;
typedef RESP_QUERY_INFORMATION_SRV SMB_UNALIGNED *PRESP_QUERY_INFORMATION_SRV;

#endif // def INCLUDE_SMB_MISC

#ifdef INCLUDE_SMB_READ_WRITE

//
// Read SMB, see #1 page 12
// Lock and Read SMB, see #2 page 44
// SMB_COM_READ 0x0A, Function is SrvSmbRead
// SMB_COM_LOCK_AND_READ 0x13, Function is SrvSmbLockAndRead
//

typedef struct _REQ_READ {
    UCHAR WordCount;                    // Count of parameter words = 5
    _USHORT( Fid );                     // File handle
    _USHORT( Count );                   // Count of bytes being requested
    _ULONG( Offset );                   // Offset in file of first byte to read
    _USHORT( Remaining );               // Estimate of bytes to read if nonzero
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_READ;
typedef REQ_READ SMB_UNALIGNED *PREQ_READ;

//
// *** Warning: the following structure is defined the way it is to
//     ensure longword alignment of the data buffer.  (This only matters
//     when packing is disabled; when packing is turned on, the right
//     thing happens no matter what.)
//

typedef struct _RESP_READ {
    UCHAR WordCount;                    // Count of parameter words = 5
    _USHORT( Count );                   // Count of bytes actually returned
    _USHORT( Reserved )[4];             // Reserved (must be 0)
    _USHORT( ByteCount );               // Count of data bytes
    //UCHAR Buffer[1];                  // Buffer containing:
      UCHAR BufferFormat;               //  0x01 -- Data block
      _USHORT( DataLength );            //  Length of data
      ULONG Buffer[1];                  //  Data
} RESP_READ;
typedef RESP_READ SMB_UNALIGNED *PRESP_READ;

#endif // def INCLUDE_SMB_READ_WRITE

#ifdef INCLUDE_SMB_READ_WRITE

//
// Read and X SMB, see #2 page 56
// Function is SrvSmbReadAndX()
// SMB_COM_READ_ANDX 0x2E
//

typedef struct _REQ_READ_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 10
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Fid );                     // File handle
    _ULONG( Offset );                   // Offset in file to begin read
    _USHORT( MaxCount );                // Max number of bytes to return
    _USHORT( MinCount );                // Min number of bytes to return
    _ULONG( Timeout );
    _USHORT( Remaining );               // Bytes remaining to satisfy request
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_READ_ANDX;
typedef REQ_READ_ANDX SMB_UNALIGNED *PREQ_READ_ANDX;

typedef struct _REQ_NT_READ_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 12
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Fid );                     // File handle
    _ULONG( Offset );                   // Offset in file to begin read
    _USHORT( MaxCount );                // Max number of bytes to return
    _USHORT( MinCount );                // Min number of bytes to return
    union {
        _ULONG( Timeout );
        _USHORT( MaxCountHigh );        // upper 16 bits of MaxCount if NT request
    };
    _USHORT( Remaining );               // Bytes remaining to satisfy request
    _ULONG( OffsetHigh );               // Used for NT Protocol only
                                        // Upper 32 bits of offset
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_NT_READ_ANDX;
typedef REQ_NT_READ_ANDX SMB_UNALIGNED *PREQ_NT_READ_ANDX;

typedef struct _RESP_READ_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 12
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Remaining );               // Bytes remaining to be read
    _USHORT( DataCompactionMode );
    _USHORT( Reserved );                // Reserved (must be 0)
    _USHORT( DataLength );              // Number of data bytes (min = 0)
    _USHORT( DataOffset );              // Offset (from header start) to data
    union {
        _USHORT( Reserved2 );           // Reserved (must be 0)
        _USHORT( DataLengthHigh );      // upper 16 bits of DataLength if NT request
    };
    _ULONG( Reserved3 )[2];             // Reserved (must be 0)
    _USHORT( ByteCount );               // Count of data bytes.  Inaccurate if we
                                        //   are doing large Read&X's!
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data (size = DataLength)
} RESP_READ_ANDX;
typedef RESP_READ_ANDX SMB_UNALIGNED *PRESP_READ_ANDX;

#endif // def INCLUDE_SMB_READ_WRITE

#ifdef INCLUDE_SMB_MPX

//
// Read Block Multiplexed SMB, see #2 page 58
// Function is SrvSmbReadMpx()
// SMB_COM_READ_MPX 0x1B
// SMB_COM_READ_MPX_SECONDARY 0x1C
//

typedef struct _REQ_READ_MPX {
    UCHAR WordCount;                    // Count of parameter words = 8
    _USHORT( Fid );                     // File handle
    _ULONG( Offset );                   // Offset in file to begin read
    _USHORT( MaxCount );                // Max bytes to return (max 65535)
    _USHORT( MinCount );                // Min bytes to return (normally 0)
    _ULONG( Timeout );
    _USHORT( Reserved );
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_READ_MPX;
typedef REQ_READ_MPX SMB_UNALIGNED *PREQ_READ_MPX;

typedef struct _RESP_READ_MPX {
    UCHAR WordCount;                    // Count of parameter words = 8
    _ULONG( Offset );                   // Offset in file where data read
    _USHORT( Count );                   // Total bytes being returned
    _USHORT( Remaining );               // Bytes remaining to be read (pipe/dev)
    _USHORT( DataCompactionMode );
    _USHORT( Reserved );
    _USHORT( DataLength );              // Number of data bytes this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data (size = DataLength)
} RESP_READ_MPX;
typedef RESP_READ_MPX SMB_UNALIGNED *PRESP_READ_MPX;

#endif // def INCLUDE_SMB_MPX

#ifdef INCLUDE_SMB_RAW

//
// Read Block Raw SMB, see #2 page 61
// Function is SrvSmbReadRaw()
// SMB_COM_READ_RAW 0x1A
//

typedef struct _REQ_READ_RAW {
    UCHAR WordCount;                    // Count of parameter words = 8
    _USHORT( Fid );                     // File handle
    _ULONG( Offset );                   // Offset in file to begin read
    _USHORT( MaxCount );                // Max bytes to return (max 65535)
    _USHORT( MinCount );                // Min bytes to return (normally 0)
    _ULONG( Timeout );
    _USHORT( Reserved );
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_READ_RAW;
typedef REQ_READ_RAW SMB_UNALIGNED *PREQ_READ_RAW;

typedef struct _REQ_NT_READ_RAW {
    UCHAR WordCount;                    // Count of parameter words = 10
    _USHORT( Fid );                     // File handle
    _ULONG( Offset );                   // Offset in file to begin read
    _USHORT( MaxCount );                // Max bytes to return (max 65535)
    _USHORT( MinCount );                // Min bytes to return (normally 0)
    _ULONG( Timeout );
    _USHORT( Reserved );
    _ULONG( OffsetHigh );               // Used for NT Protocol only
                                        // Upper 32 bits of offset
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_NT_READ_RAW;
typedef REQ_NT_READ_RAW SMB_UNALIGNED *PREQ_NT_READ_RAW;

// No response params for raw read--the response is the raw data.

#endif // def INCLUDE_SMB_RAW

#ifdef INCLUDE_SMB_FILE_CONTROL

//
// Rename SMB, see #1 page 17
// Function is SrvSmbRename()
// SMB_COM_RENAME 0x07
//

typedef struct _REQ_RENAME {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( SearchAttributes );
    _USHORT( ByteCount );               // Count of data bytes; min = 4
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat1;              //  0x04 -- ASCII
    //UCHAR OldFileName[];              //  Old file name
    //UCHAR BufferFormat2;              //  0x04 -- ASCII
    //UCHAR NewFileName[];              //  New file name
} REQ_RENAME;
typedef REQ_RENAME SMB_UNALIGNED *PREQ_RENAME;


//
// Extended NT rename SMB
// Function is SrvSmbRename()
// SMB_COM_NT_RENAME 0xA5
//

typedef struct _REQ_NTRENAME {
    UCHAR WordCount;                    // Count of parameter words = 4
    _USHORT( SearchAttributes );
    _USHORT( InformationLevel );
    _ULONG( ClusterCount );
    _USHORT( ByteCount );               // Count of data bytes; min = 4
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat1;              //  0x04 -- ASCII
    //UCHAR OldFileName[];              //  Old file name
    //UCHAR BufferFormat2;              //  0x04 -- ASCII
    //UCHAR NewFileName[];              //  New file name
} REQ_NTRENAME;
typedef REQ_NTRENAME SMB_UNALIGNED *PREQ_NTRENAME;

typedef struct _RESP_RENAME {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_RENAME;
typedef RESP_RENAME SMB_UNALIGNED *PRESP_RENAME;

#endif // def INCLUDE_SMB_FILE_CONTROL

#ifdef INCLUDE_SMB_SEARCH

//
// Search SMBs.  One structure is common for both the core Search and the
// LAN Manager 1.0 Find First/Next/Close.
//
// Function is SrvSmbSearch()
//
// Search, see #1 page 26
//      SMB_COM_SEARCH 0x81
// FindFirst and FindNext, see #2 page 27
//      SMB_COM_FIND 0x82
// FindUnique, see #2 page 33
//      SMB_COM_FIND_UNIQUE 0x83
// FindClose, see #2 page 31
//      SMB_COM_FIND_CLOSE 0x84
//

typedef struct _REQ_SEARCH {
    UCHAR WordCount;                    // Count of parameter words = 2
    _USHORT( MaxCount );                // Number of dir. entries to return
    _USHORT( SearchAttributes );
    _USHORT( ByteCount );               // Count of data bytes; min = 5
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat1;              //  0x04 -- ASCII
    //UCHAR FileName[];                 //  File name, may be null
    //UCHAR BufferFormat2;              //  0x05 -- Variable block
    //USHORT ResumeKeyLength;           //  Length of resume key, may be 0
    //UCHAR SearchStatus[];             //  Resume key
} REQ_SEARCH;
typedef REQ_SEARCH SMB_UNALIGNED *PREQ_SEARCH;

typedef struct _RESP_SEARCH {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Count );                   // Number of entries returned
    _USHORT( ByteCount );               // Count of data bytes; min = 3
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x05 -- Variable block
    //USHORT DataLength;                //  Length of data
    //UCHAR Data[];                     //  Data
} RESP_SEARCH;
typedef RESP_SEARCH SMB_UNALIGNED *PRESP_SEARCH;

//
// These two structures are use to return information in the Search SMBs.
// SMB_DIRECTORY_INFORMATION is used to return information about a file
// that was found.  In addition to the usual information about the file,
// each of these structures contains an SMB_RESUME_KEY, which is used to
// continue or rewind a search.
//
// These structures must be packed, so turn on packing if it isn't
// already on.
//

#ifdef NO_PACKING
#include <packon.h>
#endif // def NO_PACKING

typedef struct _SMB_RESUME_KEY {
    UCHAR Reserved;                     // bit 7 - comsumer use
                                        // bits 5,6 - system use (must preserve)
                                        // bits 0-4 - server use (must preserve)
    UCHAR FileName[11];
    UCHAR Sid;                          // Uniquely identifies Find through Close
    _ULONG( FileIndex );                // Reserved for server use
    UCHAR Consumer[4];                  // Reserved for comsumer use
} SMB_RESUME_KEY;
typedef SMB_RESUME_KEY SMB_UNALIGNED *PSMB_RESUME_KEY;

typedef struct _SMB_DIRECTORY_INFORMATION {
    SMB_RESUME_KEY ResumeKey;
    UCHAR FileAttributes;
    SMB_TIME LastWriteTime;
    SMB_DATE LastWriteDate;
    _ULONG( FileSize );
    UCHAR FileName[13];                 // ASCII, space-filled null terminated
} SMB_DIRECTORY_INFORMATION;
typedef SMB_DIRECTORY_INFORMATION SMB_UNALIGNED *PSMB_DIRECTORY_INFORMATION;

#ifdef NO_PACKING
#include <packoff.h>
#endif // def NO_PACKING

#endif // def INCLUDE_SMB_SEARCH

#ifdef INCLUDE_SMB_READ_WRITE

//
// Seek SMB, see #1 page 14
// Function is SrvSmbSeek
// SMB_COM_SEEK 0x12
//

typedef struct _REQ_SEEK {
    UCHAR WordCount;                    // Count of parameter words = 4
    _USHORT( Fid );                     // File handle
    _USHORT( Mode );                    // Seek mode:
                                        //  0 = from start of file
                                        //  1 = from current position
                                        //  2 = from end of file
    _ULONG( Offset );                   // Relative offset
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_SEEK;
typedef REQ_SEEK SMB_UNALIGNED *PREQ_SEEK;

typedef struct _RESP_SEEK {
    UCHAR WordCount;                    // Count of parameter words = 2
    _ULONG( Offset );                   // Offset from start of file
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_SEEK;
typedef RESP_SEEK SMB_UNALIGNED *PRESP_SEEK;

#endif // def INCLUDE_SMB_READ_WRITE

#ifdef INCLUDE_SMB_MESSAGE

//
// Send Broadcast Message SMB, see #1 page 32
// Function is SrvSmbSendBroadcastMessage()
// SMB_COM_SEND_BROADCAST_MESSAGE 0xD1
//

typedef struct _REQ_SEND_BROADCAST_MESSAGE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 8
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat1;              //  0x04 -- ASCII
    //UCHAR OriginatorName[];           //  Originator name (max = 15)
    //UCHAR BufferFormat2;              //  0x04 -- ASCII
    //UCHAR DestinationName[];          //  "*"
    //UCHAR BufferFormat3;              //  0x01 -- Data block
    //USHORT DataLength;                //  Length of message; max = 128
    //UCHAR Data[];                     //  Message
} REQ_SEND_BROADCAST_MESSAGE;
typedef REQ_SEND_BROADCAST_MESSAGE SMB_UNALIGNED *PREQ_SEND_BROADCAST_MESSAGE;

// No response for Send Broadcast Message

#endif // def INCLUDE_SMB_MESSAGE

#ifdef INCLUDE_SMB_MESSAGE

//
// Send End of Multi-block Message SMB, see #1 page 33
// Function is SrvSmbSendEndMbMessage()
// SMB_COM_SEND_END_MB_MESSAGE 0xD6
//

typedef struct _REQ_SEND_END_MB_MESSAGE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( MessageGroupId );
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_SEND_END_MB_MESSAGE;
typedef REQ_SEND_END_MB_MESSAGE SMB_UNALIGNED *PREQ_SEND_END_MB_MESSAGE;

typedef struct _RESP_SEND_END_MB_MESSAGE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_SEND_END_MB_MESSAGE;
typedef RESP_SEND_END_MB_MESSAGE SMB_UNALIGNED *PRESP_SEND_END_MB_MESSAGE;

#endif // def INCLUDE_SMB_MESSAGE

#ifdef INCLUDE_SMB_MESSAGE

//
// Send Single Block Message SMB, see #1 page 31
// Function is SrvSmbSendMessage()
// SMB_COM_SEND_MESSAGE 0xD0
//

typedef struct _REQ_SEND_MESSAGE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 7
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat1;              //  0x04 -- ASCII
    //UCHAR OriginatorName[];           //  Originator name (max = 15)
    //UCHAR BufferFormat2;              //  0x04 -- ASCII
    //UCHAR DestinationName[];          //  Destination name (max = 15)
    //UCHAR BufferFormat3;              //  0x01 -- Data block
    //USHORT DataLength;                //  Length of message; max = 128
    //UCHAR Data[];                     //  Message
} REQ_SEND_MESSAGE;
typedef REQ_SEND_MESSAGE SMB_UNALIGNED *PREQ_SEND_MESSAGE;

typedef struct _RESP_SEND_MESSAGE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_SEND_MESSAGE;
typedef RESP_SEND_MESSAGE SMB_UNALIGNED *PRESP_SEND_MESSAGE;

#endif // def INCLUDE_SMB_MESSAGE

#ifdef INCLUDE_SMB_MESSAGE

//
// Send Start of Multi-block Message SMB, see #1 page 32
// Function is SrvSmbSendStartMbMessage()
// SMB_COM_SEND_START_MB_MESSAGE 0xD5
//

typedef struct _REQ_SEND_START_MB_MESSAGE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 0
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat1;              //  0x04 -- ASCII
    //UCHAR OriginatorName[];           //  Originator name (max = 15)
    //UCHAR BufferFormat2;              //  0x04 -- ASCII
    //UCHAR DestinationName[];          //  Destination name (max = 15)
} REQ_SEND_START_MB_MESSAGE;
typedef REQ_SEND_START_MB_MESSAGE SMB_UNALIGNED *PREQ_SEND_START_MB_MESSAGE;

typedef struct _RESP_SEND_START_MB_MESSAGE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( MessageGroupId );
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_SEND_START_MB_MESSAGE;
typedef RESP_SEND_START_MB_MESSAGE SMB_UNALIGNED *PSEND_START_MB_MESSAGE;

#endif // def INCLUDE_SMB_MESSAGE

#ifdef INCLUDE_SMB_MESSAGE

//
// Send Text of Multi-block Message SMB, see #1 page 33
// Function is SrvSmbSendTextMbMessage()
// SMB_COM_SEND_TEXT_MB_MESSAGE 0xD7
//

typedef struct _REQ_SEND_TEXT_MB_MESSAGE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( MessageGroupId );
    _USHORT( ByteCount );               // Count of data bytes; min = 3
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x01 -- Data block
    //USHORT DataLength;                //  Length of message; max = 128
    //UCHAR Data[];                     //  Message
} REQ_SEND_TEXT_MB_MESSAGE;
typedef REQ_SEND_TEXT_MB_MESSAGE SMB_UNALIGNED *PREQ_SEND_TEXT_MB_MESSAGE;

typedef struct _RESP_SEND_TEXT_MB_MESSAGE {
    UCHAR WordCount;                    // Count of aprameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_SEND_TEXT_MB_MESSAGE;
typedef RESP_SEND_TEXT_MB_MESSAGE SMB_UNALIGNED *PRESP_SEND_TEXT_MB_MESSAGE;

#endif // def INCLUDE_SMB_MESSAGE

#ifdef INCLUDE_SMB_ADMIN

//
// Session Setup and X SMB, see #2 page 63 and #3 page 10
// Function is SrvSmbSessionSetupAndX()
// SMB_COM_SESSION_SETUP_ANDX 0x73
//

typedef struct _REQ_SESSION_SETUP_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 10
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( MaxBufferSize );           // Consumer's maximum buffer size
    _USHORT( MaxMpxCount );             // Actual maximum multiplexed pending requests
    _USHORT( VcNumber );                // 0 = first (only), nonzero=additional VC number
    _ULONG( SessionKey );               // Session key (valid iff VcNumber != 0)
    _USHORT( PasswordLength );          // Account password size
    _ULONG( Reserved );
    _USHORT( ByteCount );               // Count of data bytes; min = 0
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR AccountPassword[];          //  Account Password
    //UCHAR AccountName[];              //  Account Name
    //UCHAR PrimaryDomain[];            //  Client's primary domain
    //UCHAR NativeOS[];                 //  Client's native operating system
    //UCHAR NativeLanMan[];             //  Client's native LAN Manager type
} REQ_SESSION_SETUP_ANDX;
typedef REQ_SESSION_SETUP_ANDX SMB_UNALIGNED *PREQ_SESSION_SETUP_ANDX;

typedef struct _REQ_NT_SESSION_SETUP_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 13
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( MaxBufferSize );           // Consumer's maximum buffer size
    _USHORT( MaxMpxCount );             // Actual maximum multiplexed pending requests
    _USHORT( VcNumber );                // 0 = first (only), nonzero=additional VC number
    _ULONG( SessionKey );               // Session key (valid iff VcNumber != 0)
    _USHORT( CaseInsensitivePasswordLength );      // Account password size, ANSI
    _USHORT( CaseSensitivePasswordLength );        // Account password size, Unicode
    _ULONG( Reserved);
    _ULONG( Capabilities );             // Client capabilities
    _USHORT( ByteCount );               // Count of data bytes; min = 0
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR CaseInsensitivePassword[];  //  Account Password, ANSI
    //UCHAR CaseSensitivePassword[];    //  Account Password, Unicode
    //UCHAR AccountName[];              //  Account Name
    //UCHAR PrimaryDomain[];            //  Client's primary domain
    //UCHAR NativeOS[];                 //  Client's native operating system
    //UCHAR NativeLanMan[];             //  Client's native LAN Manager type
} REQ_NT_SESSION_SETUP_ANDX;
typedef REQ_NT_SESSION_SETUP_ANDX SMB_UNALIGNED *PREQ_NT_SESSION_SETUP_ANDX;

//
// Action flags in the response
//
#define SMB_SETUP_GUEST          0x0001          // Session setup as a guest
#define SMB_SETUP_USE_LANMAN_KEY 0x0002          // Use the Lan Manager setup key.

typedef struct _RESP_SESSION_SETUP_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 3
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Action );                  // Request mode:
                                        //    bit0 = logged in as GUEST
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR NativeOS[];                 //  Server's native operating system
    //UCHAR NativeLanMan[];             //  Server's native LAN Manager type
    //UCHAR PrimaryDomain[];            //  Server's primary domain
} RESP_SESSION_SETUP_ANDX;
typedef RESP_SESSION_SETUP_ANDX SMB_UNALIGNED *PRESP_SESSION_SETUP_ANDX;

#endif // def INCLUDE_SMB_ADMIN

#ifdef INCLUDE_SMB_QUERY_SET

//
// Set Information SMB, see #1 page 19
// Function is SrvSmbSetInformation()
// SMB_COM_SET_INFORMATION 0x09
//

typedef struct _REQ_SET_INFORMATION {
    UCHAR WordCount;                    // Count of parameter words = 8
    _USHORT( FileAttributes );
    _ULONG( LastWriteTimeInSeconds );
    _USHORT( Reserved )[5];             // Reserved (must be 0)
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR FileName[];                 //  File name
} REQ_SET_INFORMATION;
typedef REQ_SET_INFORMATION SMB_UNALIGNED *PREQ_SET_INFORMATION;

typedef struct _RESP_SET_INFORMATION {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_SET_INFORMATION;
typedef RESP_SET_INFORMATION SMB_UNALIGNED *PRESP_SET_INFORMATION;

#endif // def INCLUDE_SMB_QUERY_SET

#ifdef INCLUDE_SMB_QUERY_SET

//
// Set Information2 SMB, see #2 page 66
// Function is SrvSmbSetInformation2
// SMB_COM_SET_INFORMATION2 0x22
//

typedef struct _REQ_SET_INFORMATION2 {
    UCHAR WordCount;                    // Count of parameter words = 7
    _USHORT( Fid );                     // File handle
    SMB_DATE CreationDate;
    SMB_TIME CreationTime;
    SMB_DATE LastAccessDate;
    SMB_TIME LastAccessTime;
    SMB_DATE LastWriteDate;
    SMB_TIME LastWriteTime;
    _USHORT( ByteCount );               // Count of data bytes; min = 0
    UCHAR Buffer[1];                    // Reserved buffer
} REQ_SET_INFORMATION2;
typedef REQ_SET_INFORMATION2 SMB_UNALIGNED *PREQ_SET_INFORMATION2;

typedef struct _RESP_SET_INFORMATION2 {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_SET_INFORMATION2;
typedef RESP_SET_INFORMATION2 SMB_UNALIGNED *PRESP_SET_INFORMATION2;

#endif // def INCLUDE_SMB_QUERY_SET

#ifdef INCLUDE_SMB_TRANSACTION

//
// Transaction and Transaction2 SMBs, see #2 page 68 and #3 page 13
// Function is SrvSmbTransaction()
// SMB_COM_TRANSACTION 0x25
// SMB_COM_TRANSACTION_SECONDARY 0x26
// SMB_COM_TRANSACTION2 0x32
// SMB_COM_TRANSACTION2_SECONDARY 0x33
//
// Structures for specific transaction types are defined in smbtrans.h.
//
// *** The Transaction2 secondary request format includes a USHORT Fid
//     field that we ignore.  We can do this because the Fid field
//     occurs at the end of the word parameters part of the request, and
//     because the rest of the request (parameter and data bytes) is
//     pointed by offset fields occurring prior to the Fid field.  (The
//     Fid field was added to speed up dispatching in the OS/2 server,
//     in which different worker processes handle each Fid.  The NT
//     server has only one process.)
//

typedef struct _REQ_TRANSACTION {
    UCHAR WordCount;                    // Count of parameter words; value = (14 + SetupCount)
    _USHORT( TotalParameterCount );     // Total parameter bytes being sent
    _USHORT( TotalDataCount );          // Total data bytes being sent
    _USHORT( MaxParameterCount );       // Max parameter bytes to return
    _USHORT( MaxDataCount );            // Max data bytes to return
    UCHAR MaxSetupCount;                // Max setup words to return
    UCHAR Reserved;
    _USHORT( Flags );                   // Additional information:
                                        //  bit 0 - also disconnect TID in Tid
                                        //  bit 1 - one-way transacion (no resp)
    _ULONG( Timeout );
    _USHORT( Reserved2 );
    _USHORT( ParameterCount );          // Parameter bytes sent this buffer
    _USHORT( ParameterOffset );         // Offset (from header start) to params
    _USHORT( DataCount );               // Data bytes sent this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    UCHAR SetupCount;                   // Count of setup words
    UCHAR Reserved3;                    // Reserved (pad above to word)
    UCHAR Buffer[1];                    // Buffer containing:
    //USHORT Setup[];                   //  Setup words (# = SetupWordCount)
    //USHORT ByteCount;                 //  Count of data bytes
    //UCHAR Name[];                     //  Name of transaction (NULL if Transact2)
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Parameters[];               //  Parameter bytes (# = ParameterCount)
    //UCHAR Pad1[];                     //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data bytes (# = DataCount)
} REQ_TRANSACTION;
typedef REQ_TRANSACTION SMB_UNALIGNED *PREQ_TRANSACTION;

#define SMB_TRANSACTION_DISCONNECT 1
#define SMB_TRANSACTION_NO_RESPONSE 2
#define SMB_TRANSACTION_RECONNECTING 4
#define SMB_TRANSACTION_DFSFILE 8

typedef struct _RESP_TRANSACTION_INTERIM {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_TRANSACTION_INTERIM;
typedef RESP_TRANSACTION_INTERIM SMB_UNALIGNED *PRESP_TRANSACTION_INTERIM;

typedef struct _REQ_TRANSACTION_SECONDARY {
    UCHAR WordCount;                    // Count of parameter words = 8
    _USHORT( TotalParameterCount );     // Total parameter bytes being sent
    _USHORT( TotalDataCount );          // Total data bytes being sent
    _USHORT( ParameterCount );          // Parameter bytes sent this buffer
    _USHORT( ParameterOffset );         // Offset (from header start) to params
    _USHORT( ParameterDisplacement );   // Displacement of these param bytes
    _USHORT( DataCount );               // Data bytes sent this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( DataDisplacement );        // Displacement of these data bytes
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Parameters[];               //  Parameter bytes (# = ParameterCount)
    //UCHAR Pad1[];                     //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data bytes (# = DataCount)
} REQ_TRANSACTION_SECONDARY;
typedef REQ_TRANSACTION_SECONDARY SMB_UNALIGNED *PREQ_TRANSACTION_SECONDARY;

typedef struct _RESP_TRANSACTION {
    UCHAR WordCount;                    // Count of data bytes; value = 10 + SetupCount
    _USHORT( TotalParameterCount );     // Total parameter bytes being sent
    _USHORT( TotalDataCount );          // Total data bytes being sent
    _USHORT( Reserved );
    _USHORT( ParameterCount );          // Parameter bytes sent this buffer
    _USHORT( ParameterOffset );         // Offset (from header start) to params
    _USHORT( ParameterDisplacement );   // Displacement of these param bytes
    _USHORT( DataCount );               // Data bytes sent this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( DataDisplacement );        // Displacement of these data bytes
    UCHAR SetupCount;                   // Count of setup words
    UCHAR Reserved2;                    // Reserved (pad above to word)
    UCHAR Buffer[1];                    // Buffer containing:
    //USHORT Setup[];                   //  Setup words (# = SetupWordCount)
    //USHORT ByteCount;                 //  Count of data bytes
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Parameters[];               //  Parameter bytes (# = ParameterCount)
    //UCHAR Pad1[];                     //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data bytes (# = DataCount)
} RESP_TRANSACTION;
typedef RESP_TRANSACTION SMB_UNALIGNED *PRESP_TRANSACTION;

typedef struct _REQ_NT_TRANSACTION {
    UCHAR WordCount;                    // Count of parameter words; value = (19 + SetupCount)
    UCHAR MaxSetupCount;                // Max setup words to return
    _USHORT( Flags );                   // Currently unused
    _ULONG( TotalParameterCount );      // Total parameter bytes being sent
    _ULONG( TotalDataCount );           // Total data bytes being sent
    _ULONG( MaxParameterCount );        // Max parameter bytes to return
    _ULONG( MaxDataCount );             // Max data bytes to return
    _ULONG( ParameterCount );           // Parameter bytes sent this buffer
    _ULONG( ParameterOffset );          // Offset (from header start) to params
    _ULONG( DataCount );                // Data bytes sent this buffer
    _ULONG( DataOffset );               // Offset (from header start) to data
    UCHAR SetupCount;                   // Count of setup words
    _USHORT( Function );                            // The transaction function code
    UCHAR Buffer[1];
    //USHORT Setup[];                   // Setup words (# = SetupWordCount)
    //USHORT ByteCount;                 // Count of data bytes
    //UCHAR Pad1[];                     // Pad to LONG
    //UCHAR Parameters[];               // Parameter bytes (# = ParameterCount)
    //UCHAR Pad2[];                     // Pad to LONG
    //UCHAR Data[];                     // Data bytes (# = DataCount)
} REQ_NT_TRANSACTION;
typedef REQ_NT_TRANSACTION SMB_UNALIGNED *PREQ_NT_TRANSACTION;

#define SMB_TRANSACTION_DISCONNECT 1
#define SMB_TRANSACTION_NO_RESPONSE 2

typedef struct _RESP_NT_TRANSACTION_INTERIM {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];
} RESP_NT_TRANSACTION_INTERIM;
typedef RESP_NT_TRANSACTION_INTERIM SMB_UNALIGNED *PRESP_NT_TRANSACTION_INTERIM;

typedef struct _REQ_NT_TRANSACTION_SECONDARY {
    UCHAR WordCount;                    // Count of parameter words = 18
    UCHAR Reserved1;                    // MBZ
    _USHORT( Reserved2 );               // MBZ
    _ULONG( TotalParameterCount );      // Total parameter bytes being sent
    _ULONG( TotalDataCount );           // Total data bytes being sent
    _ULONG( ParameterCount );           // Parameter bytes sent this buffer
    _ULONG( ParameterOffset );          // Offset (from header start) to params
    _ULONG( ParameterDisplacement );    // Displacement of these param bytes
    _ULONG( DataCount );                // Data bytes sent this buffer
    _ULONG( DataOffset );               // Offset (from header start) to data
    _ULONG( DataDisplacement );         // Displacement of these data bytes
    UCHAR Reserved3;
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];
    //UCHAR Pad1[];                     // Pad to LONG
    //UCHAR Parameters[];               // Parameter bytes (# = ParameterCount)
    //UCHAR Pad2[];                     // Pad to LONG
    //UCHAR Data[];                     // Data bytes (# = DataCount)
} REQ_NT_TRANSACTION_SECONDARY;
typedef REQ_NT_TRANSACTION_SECONDARY SMB_UNALIGNED *PREQ_NT_TRANSACTION_SECONDARY;

typedef struct _RESP_NT_TRANSACTION {
    UCHAR WordCount;                    // Count of data bytes; value = 18 + SetupCount
    UCHAR Reserved1;
    _USHORT( Reserved2 );
    _ULONG( TotalParameterCount );     // Total parameter bytes being sent
    _ULONG( TotalDataCount );          // Total data bytes being sent
    _ULONG( ParameterCount );          // Parameter bytes sent this buffer
    _ULONG( ParameterOffset );         // Offset (from header start) to params
    _ULONG( ParameterDisplacement );   // Displacement of these param bytes
    _ULONG( DataCount );               // Data bytes sent this buffer
    _ULONG( DataOf