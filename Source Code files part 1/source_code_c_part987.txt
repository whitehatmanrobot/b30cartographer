ne IDS_DISP_MODIFIED_DATE          12787
#define IDS_DISP_MODIFIED_BY            12788
#define IDS_DISP_CUSTOM1                12789
#define IDS_DISP_CUSTOM2                12790
#define IDS_DISP_CUSTOM3                12791
#define IDS_DISP_CUSTOM4                12792
#define IDS_DISP_CUSTOM5                12793
#define IDS_DISP_CUSTOM6                12794
#define IDS_IconHelp                    12795
#define IDS_SourceTermHelp              12796
#define IDS_TranslationHelp             12797
#define IDS_PreviousSourceHelp          12798
#define IDS_InstructionHelp             12799
#define IDS_TermNoteHelp                12800
#define IDS_ResourceIDHelp              12801
#define IDS_TransStatusHelp             12802
#define IDS_BinStatusHelp               12803
#define IDS_TransOriginHelp             12804
#define IDS_StringCategoryHelp          12805
#define IDS_ApprovalStatusHelp          12806
#define IDS_UserLockHelp                12807
#define IDS_DevLockHelp                 12808
#define IDS_ParserIDHelp                12809
#define IDS_ModifiedDateHelp            12810
#define IDS_ModifiedByHelp              12811
#define IDS_Custom1Help                 12812
#define IDS_Custom2Help                 12813
#define IDS_Custom3Help                 12814
#define IDS_Custom4Help                 12815
#define IDS_Custom5Help                 12816
#define IDS_Custom6Help                 12817
#define IDS_SoftwareDescription         12818
#define IDS_DISP_INSTRUCTIONS_ATT       12819
#define IDS_InstructionAttHelp          12820
#define IDS_DISP_SRC_LEN                12821
#define IDS_SRC_LEN_HELP                12822
#define IDS_DISP_TGT_LEN                12823
#define IDS_TGT_LEN_HELP                12824
#define IDS_TransLockHelp               12825
#define IDS_DISP_TRANS_LOCK             12826
#define IDS_DISP_SRC_HK                 12827
#define IDS_SRC_HK_HELP                 12828
#define IDS_DISP_TGT_HK                 12829
#define IDS_TGT_HK_HELP                 12830
#define IDS_DISP_AUTO_APPROVED          12831
#define IDS_AutoApprovedHelp            12832
#define IDS_DISP_CONFIDENCE_LEVEL       12833
#define IDS_ConfidenceLevelHelp         12834
#define IDS_ConfidenceLevel_Invalid     12835

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        12604
#define _APS_NEXT_COMMAND_VALUE         12600
#define _APS_NEXT_CONTROL_VALUE         12608
#define _APS_NEXT_SYMED_VALUE           12602
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\typeid.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    TYPEID.H

History:

--*/

#ifndef TYPEID_H
#define TYPEID_H


class LTAPIENTRY CLocTypeId : public CLocId
{
public:
	NOTHROW CLocTypeId();

	void AssertValid(void) const;

	const CLocTypeId &operator=(const CLocTypeId &);

	int NOTHROW operator==(const CLocTypeId &) const;
	int NOTHROW operator!=(const CLocTypeId &) const;

	void Serialize(CArchive &ar);

protected:

private:
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "typeid.inl"
#endif

#endif // TYPEID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\softinfo.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    SOFTINFO.H

History:

--*/

#if !defined(ESPUTIL_SoftInfo_h_INCLUDED)
#define ESPUTIL_SoftInfo_h_INCLUDED

struct LTAPIENTRY SoftCol
{
	// Unique string names for columns
	static const WCHAR * szIcon;
	static const WCHAR * szSource;
	static const WCHAR * szTarget;
	static const WCHAR * szPreviousSource;
	static const WCHAR * szInstructions;
	static const WCHAR * szInstrAtt;
	static const WCHAR * szNote;
	static const WCHAR * szResourceID;
	static const WCHAR * szTranslationStatus;
	static const WCHAR * szBinaryStatus;
	static const WCHAR * szOrigin;
	static const WCHAR * szCategory;
	static const WCHAR * szApproval;
	static const WCHAR * szLock;
	static const WCHAR * szSourceLock;
	static const WCHAR * szTransLock;
	static const WCHAR * szModifiedDate;
	static const WCHAR * szModifiedBy;
	static const WCHAR * szAutoApproved;
	static const WCHAR * szConfidenceLevel;
	static const WCHAR * szCustom1;
	static const WCHAR * szCustom2;
	static const WCHAR * szCustom3;
	static const WCHAR * szCustom4;
	static const WCHAR * szCustom5;
	static const WCHAR * szCustom6;
	static const WCHAR * szParserID;
	static const WCHAR * szSrcLen;
	static const WCHAR * szTgtLen;
	static const WCHAR * szSrcHotKey;
	static const WCHAR * szTgtHotKey;
	
	// Unique ID's for columns
	//
	// DO NOT 'INSERT' ITEMS.  You will change the ID's and break things.
	
	typedef enum
	{
		FLD_ICON,
		FLD_SOURCE_TERM,
		FLD_TARGET_TERM,
		FLD_PREVIOUS_SOURCE_TERM,
		FLD_INSTRUCTIONS,
		FLD_INSTR_ATT,
		FLD_GLOSSARY_NOTE,
		FLD_UNIQUE_ID,
		FLD_TRANSLATION_STATUS,
		FLD_BINARY_STATUS,
		FLD_TRANSLATION_ORIGIN,
		FLD_STRING_TYPE,
		FLD_APPROVAL_STATE,
		FLD_USR_LOCK,
		FLD_DEV_LOCK,
		FLD_TRANS_LOCK,
		FLD_MODIFIED_DATE,
		FLD_MODIFIED_BY,
		FLD_AUTO_APPROVED,
		FLD_CONFIDENCE_LEVEL,
		FLD_CUSTOM1,
		FLD_CUSTOM2,
		FLD_CUSTOM3,
		FLD_CUSTOM4,
		FLD_CUSTOM5,
		FLD_CUSTOM6,
		//
		//  Add displayable columns here.
		
		FLD_PARSER_ID = 50,
		//
		//  Add non-displayable, RESTBL required columns here

		FLD_SRC_LEN = 100,
		FLD_TGT_LEN,
		FLD_SRC_HK,
		FLD_TGT_HK,
		//
		//  Add non-displayable, non-RESTBL columns here. 
		
		FLD_COUNT = 30					// Make sure this is accurate!
	} FIELD;

	// RAID:  LS42 Bug 46 fixed by MikeL
	// Functions to validate the value of the above
	// column types.  All validate functions must pass
	// two parameters:  1-LPCTSTR. and 2-DWORD
	static BOOL ValidateDefault (LPCTSTR lpszNewText, DWORD dwNewNum);
	static BOOL ValidateConfidenceLevel (LPCTSTR lpszNewText, DWORD dwNewNum);

	// Exported functions
	static void GetSoftwareSchema(CTableSchema * & pSchema);
	static const CLString & GetDisplayName(FIELD col);

	static const CColumnDefinition * GetColumnDefinition(FIELD col);

	static int GetColumnCount();

	static int GetCustomColumnCount();
	static BOOL IsCustomColumn(FIELD col);

// Implementation
protected:
	static void BuildStringCategory(CTableSchema * pSchema);
	static void BuildApprovalState(CTableSchema * pSchema);
};

#endif // ESPUTIL_SoftInfo_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\typeid.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    TYPEID.INL

History:

--*/

//  
//  Inline functions for the Type ID.  This file should ONLY be included
//  by typeid.h.
//
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  All methods directed to base class
//  
//-----------------------------------------------------------------------------

inline
CLocTypeId::CLocTypeId()
{}



inline
const CLocTypeId &
CLocTypeId::operator=(
		const CLocTypeId & locId)
{
	CLocId::operator=(locId);

	return *this;
}

inline
int
CLocTypeId::operator==(
		const CLocTypeId & locId)
		const
{
	return CLocId::operator==(locId);
}



inline
int
CLocTypeId::operator!=(
		const CLocTypeId & locId)
		const
{
	return CLocId::operator!=(locId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_espenum.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _ESPENUM.H

History:

--*/

#ifndef ESPUTIL__ESPENUM_H
#define ESPUTIL__ESPENUM_H


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\uniqid.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    UNIQID.INL

History:

--*/

//  
//  Inline function definitions for the Espresso Unique ID.  This file should
//  ONLY be included by uniqid.h.
//  
 

inline
const DBID&
CLocUniqueId::GetParentId(void)
		const
{
	return m_dbid;
}



inline
const CLocTypeId &
CLocUniqueId::GetTypeId(void)
		const
{
	return m_tid;
}



inline
const CLocResId &
CLocUniqueId::GetResId(void)
		const
{
	return m_rid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the parent ID for the item.  This portion of the ID is set by the
//  parser.
//  
//-----------------------------------------------------------------------------
inline
DBID&
CLocUniqueId::GetParentId(void)
{
	return m_dbid;
}

inline
CLocTypeId &
CLocUniqueId::GetTypeId(void)
{
	return m_tid;
}

inline
CLocResId &
CLocUniqueId::GetResId(void)
{
	return m_rid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comapre two ID's.  
//  
//-----------------------------------------------------------------------------
inline
int								        //  Zero if different
CLocUniqueId::operator==(
		const CLocUniqueId &uidOther)	// ID to compare to.
		const
{
	return IsEqualTo(uidOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Compare two ID's
//  
//-----------------------------------------------------------------------------
inline
int										// Zero if identical
CLocUniqueId::operator!=(
		const CLocUniqueId &uidOther)	// ID to compare to.
		const
{
	return !IsEqualTo(uidOther);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the Parent ID component of the ID.
//  
//-----------------------------------------------------------------------------
inline
void
CLocUniqueId::SetParentId(
		const DBID& dbidNewId)			// New Parent ID
{
	m_dbid = dbidNewId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\uniqid.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    UNIQID.H

History:

--*/

#ifndef UNIQID_H
#define UNIQID_H


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocUniqueId : public CObject
{
public:
	NOTHROW CLocUniqueId();

	void AssertValid(void) const;

	NOTHROW const DBID & GetParentId(void) const;
	NOTHROW const CLocTypeId & GetTypeId(void) const;
	NOTHROW const CLocResId & GetResId(void) const;

	NOTHROW DBID & GetParentId(void);
	NOTHROW CLocTypeId & GetTypeId(void);
	NOTHROW CLocResId & GetResId(void);
	
	void GetDisplayableUniqueId(CPascalString &) const;	
	
	NOTHROW int operator==(const CLocUniqueId &) const;
	NOTHROW int operator!=(const CLocUniqueId &) const;
	
	const CLocUniqueId &operator=(const CLocUniqueId&);

	void SetParentId(const DBID&);

	NOTHROW void ClearId(void);
	NOTHROW BOOL IsNull();
	
	virtual ~CLocUniqueId();

protected:
	//
	//  Implementation functions.
	//
	NOTHROW BOOL IsEqualTo(const CLocUniqueId &) const;

private:
	
	//
	//  Prevents the default copy constructor from being called.
	//
	CLocUniqueId(const CLocUniqueId &);
	void Serialize(CArchive &ar);

	DBID       m_dbid;
	CLocTypeId m_tid;
	CLocResId  m_rid;
	
	DEBUGONLY(static CCounter m_DisplayCounter);
};

#pragma warning(default: 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "uniqid.inl"
#endif

#endif // UNIQID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_errorrep.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _ERRORREP.H

History:

--*/

//  
//  Error reporting mechanism for Espresso 2.0
//  
 
#ifndef ESPUTIL__ERRORREP_H
#define ESPUTIL__ERRORREP_H


////////////////////// the new global issuemessage functions.
void LTAPIENTRY IssueMessage(MessageSeverity, const CLString &strContext,
		const CLString &strMessage, const CLocation &, UINT uiHelpContext = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, const CLString &strContext,
		HINSTANCE hResourceDll, UINT uiStringId, const CLocation &,
		UINT uiHelpContext = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, const CLString &strContext,
		const CLocation &, CException *);
void LTAPIENTRY IssueMessage(MessageSeverity, HINSTANCE hResourceDll,
		UINT uiContext, const CLString &strMessage, 
		const CLocation &, UINT uiHelpContext = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, HINSTANCE hResourceDll,
		UINT uiContextId, UINT uiStringId, 
		const CLocation &, UINT uiHelpContext = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, HINSTANCE hResourceDll,
		UINT uiContext, const CLocation &, CException *);

void LTAPIENTRY IssueMessage(MessageSeverity, const CContext &,
		const CLString &, UINT uiHelpId = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, const CContext &,
		HINSTANCE, UINT, UINT uiHelpId = 0);

void LTAPIENTRY SetErrorReporter(CReporter *, BOOL fBatchMode);
void LTAPIENTRY GetErrorReporter(CReporter *&, BOOL &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_errorrep.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_espopts.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _ESPOPTS.H

History:

--*/


LTAPIENTRY CLocOptionValStore *  GetParserOptionStore(CLocUIOption::StorageType);
LTAPIENTRY void SetParserOptionStore(CLocUIOption::StorageType, CLocOptionValStore *);
LTAPIENTRY void UpdateParserOptionValues(void);
LTAPIENTRY CLocUIOptionSet * GetParserOptionSet(const PUID &);

LTAPIENTRY void SummarizeParserOptions(CReport *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_errorrep.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _ERRORREP.INL

History:

--*/

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
IssueMessage(
		MessageSeverity sev,
		const CLString &strContext,
		HINSTANCE hResourceDll,
		UINT uiStringId,
		const CLocation &loc,
		UINT uiHelpContext)
{
	CLString strMessage;

	strMessage.LoadString(hResourceDll, uiStringId);
	IssueMessage(sev, strContext, strMessage, loc, uiHelpContext);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
IssueMessage(
		MessageSeverity sev,
		HINSTANCE hResourceDll,
		UINT uiContext,
		const CLString &strMessage,
		const CLocation &loc,
		UINT uiHelpContext)
{
	CLString strContext;

	strContext.LoadString(hResourceDll, uiContext);

	IssueMessage(sev, strContext, strMessage, loc, uiHelpContext);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
IssueMessage(
		MessageSeverity sev,
		HINSTANCE hResourceDll,
		UINT uiContext,
		UINT uiStringId,
		const CLocation &loc,
		UINT uiHelpContext)
{
	CLString strContext;

	strContext.LoadString(hResourceDll, uiContext);
	IssueMessage(sev, strContext, hResourceDll, uiStringId, loc,uiHelpContext);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
IssueMessage(
		MessageSeverity sev,
		HINSTANCE hResourceDll,
		UINT uiContext,
		const CLocation &loc, 
		CException *pe)
{
	CLString strContext;

	strContext.LoadString(hResourceDll, uiContext);
	IssueMessage(sev, strContext, loc, pe);
}




inline
void
IssueMessage(
		MessageSeverity sev,
		const CContext &context,
		const CLString &strMessage,
		UINT uiHelpId)
{
	IssueMessage(sev, context.GetContext(), strMessage, context.GetLocation(),
			uiHelpId);
	
}



inline
void
IssueMessage(
		MessageSeverity sev,
		const CContext &context,
		HINSTANCE hResDll,
		UINT uiStringId,
		UINT uiHelpId)
{
	IssueMessage(sev, context.GetContext(), hResDll, uiStringId,
			context.GetLocation(), uiHelpId);
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_goto.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _GOTO.H

History:

--*/

#if !defined(ESPUTIL__goto_h_INCLUDED)
#define ESPUTIL__goto_h_INCLUDED
 
class LTAPIENTRY CEspGotoFactory : public CRefCount
{
public:
	CEspGotoFactory() {};
	
	virtual CGoto * CreateGoto(const CLocation &) = 0;

private:
	CEspGotoFactory(const CEspGotoFactory &);
};



void LTAPIENTRY RegisterEspGotoFactory(CEspGotoFactory *);

#endif // ESPUTIL__goto_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_globalid.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _GLOBALID.H

History:

--*/

#ifndef ESPUTIL__GLOBALID_H
#define ESPUTIL__GLOBALID_H

///////////////////////////////////////////////////////////////////////////////
//
// global id path object, represents a fully qualified path from the root of
// the project to a specified item
//
///////////////////////////////////////////////////////////////////////////////
#pragma warning(disable : 4275)
class LTAPIENTRY CGlobalIdPath : public CTypedPtrList < CPtrList, CGlobalId * >
{
public:
	int NOTHROW operator==(const CGlobalIdPath &) const;
	const CGlobalIdPath & operator = (const CGlobalIdPath& idPath);
	~CGlobalIdPath();

	void SetIdPath(const CLString &strFilePath, 
					const CLString &strResourcePath);

	void GetStrPath(CLString &strFilePath, CLString &strResourcePath) const;

	void NOTHROW DeleteContents();
};
#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_importo.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _IMPORTTO.H

History:

--*/

#ifndef ESPUTIL__IMPORTO_H
#define ESPUTIL__IMPORTO_H


#pragma warning(disable : 4251)			// class 'bar' needs to have dll-
										//interface to be used by clients of
										//class 'Foo'
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocImportOptions : public CObject
{
public:

	CLocImportOptions();
	CLocImportOptions(const CLocImportOptions&);

	enum Option
	{
		coor_size = 0,
		allNonText,
		instructions,
		lockFlag,
		translockFlag,
		stringCategory,
		approvalStatus,
		custom1,
		custom2,
		custom3,
		custom4,
		custom5,
		custom6,
		termNote,
		parserOptions,
		copy,
		MAX_OPTION		//always last in the list
	};

	NOTHROW void Reset();
	NOTHROW BOOL HasOptionSet() const;
	NOTHROW BOOL GetOption(Option opt) const;
	NOTHROW void SetOption(Option opt, BOOL bEnable);

	const CStringArray &GetGroupNames(void) const;
	void AddGroupName(const CString &);
	
	NOTHROW CLocImportOptions& operator=(const CLocImportOptions&);

	virtual void AssertValid(void) const;

protected:
	BYTE m_storage[MAX_OPTION];
	CStringArray m_aOptionGroupNames;
};

struct LTAPIENTRY ImportCount
{
	ImportCount();
	
	ULONG ulResources;
	ULONG ulParserOptions;
	ULONG ulEspressoOptions;
	ULONG ulCustomFields;
};

#pragma warning(default : 4251)
#pragma warning(default: 4275)

#endif //ESPUTIL_IMPORTO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_reporter.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _REPORTER.H

History:

--*/

#ifndef ESPUTIL__REPORTER_H
#define ESPUTIL__REPORTER_H


//
//  Throws away ALL messages.
//
class LTAPIENTRY CNullReporter : public CReporter
{
public:
	CNullReporter()	{};

	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);
};

		


#pragma warning (disable:4251)

class LTAPIENTRY CBufferReporter : public CReporter
{
public:
	CBufferReporter();

	void AssertValid(void) const;
	

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	void Clear(void);

	NOTHROW const MessageList & GetNotes(void) const;
	NOTHROW const MessageList & GetWarnings(void) const;
	NOTHROW const MessageList & GetErrors(void) const;
	NOTHROW const MessageList & GetAborts(void) const;

	NOTHROW const MessageList & GetMessages(void) const;
	void DumpTo(CReport *) const;
	
	~CBufferReporter();

	const CBufferReport & GetBufReport(void) const;

private:
	CBufferReport m_bufReport;
};


//
//  This reporter just send all its messages directly to a message box.
//
class LTAPIENTRY CMessageBoxReporter : public CReporter
{
public:
	CMessageBoxReporter();

	void AssertValid(void) const;

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

private:
	CMessageBoxReport m_mbReport;
};



//
//  This reporter is used to send all messages to a file.
//
class LTAPIENTRY CFileReporter : public CReporter
{
public:
	CFileReporter();

	BOOL InitFileReporter(const CLString &strFileName);

	virtual void Clear(void);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	~CFileReporter();

private:
	CFileReport m_fReport;
};

//
//  This reporter is used for command line utilities.  Output goes to stdout
//
class LTAPIENTRY CStdOutReporter : public CReporter
{
public:

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);
private:
	CStdOutReport m_stReport;
};


//
//  This is used to 'redirect' messages to a single reporter.  It's used
//  when several different reporters are required by the current
//  implementation, but the desired effect is that they all send their messages
//  to a common location.
//
//  This class takes ownership of another Reporter, then uses reference
//  counting semantics to determine when to delete that reporter.
//
class LTAPIENTRY CRedirectReporter : public CReporter
{
public:
	CRedirectReporter();

	virtual void Activate(void);
	virtual void Clear(void);
	virtual void SetConfidenceLevel(ConfidenceLevel);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	//  Used for initial attachment to a CReporter.
	NOTHROW void RedirectTo(CReport *pReport);

	//  Used to share a single reporter among several CRedirectReporter's.
	NOTHROW void RedirectTo(CRedirectReporter *pReporter);
	
private:
	CRedirectReport m_rdReport;
};


//
//  
//  This class is used to re-direct output through a reporter.  It will
//  automatically call Clear() and Activate() the first time output is sent
//  to the reporter.  If the usre calls Activate first on this reporter, then
//  no action is taken when something is output.
//  
//
class LTAPIENTRY CActivateReporter : public CReporter
{
public:
	CActivateReporter(CReport *);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	void Activate();
	void Clear();

private:
	CActivateReport m_actReport;
};



//
//  Allows you to use a CReport as a CReporter.
class LTAPIENTRY CReportReporter : public CReporter
{
public:
	CReportReporter(CReport *);

	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto,
			CGotoHelp *pGotoHelp);
	virtual void Activate();
	virtual void Clear();
	virtual void SetConfidenceLevel(ConfidenceLevel);
	
	
private:
	CReport *m_pReport;
};


#pragma warning(default:4251)

//
//  The following manage a global 'pool' of reporters that are used by
//  different components in the system.
//  Each reporter has to be distinct.  Once the reporter has been 'added',
//  the global pool *owns* the reporter and will delete it.  This is done by
//  ReleaseAllReporters().
//
NOTHROW LTAPIENTRY void AddReporter(COutputTabs::OutputTabs idx, CReporter *pReporter);
NOTHROW LTAPIENTRY CReporter * GetReporter(COutputTabs::OutputTabs);
NOTHROW LTAPIENTRY void ReleaseAllReporters();

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_reporter.inl"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_interface.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _INTERFACE.H

History:

--*/

#pragma once


struct LOCRESOURCEFILEINFO
{
	CFile *pFile;						// Res32 file
	LangId idLang;						// Language of the file
};

typedef LOCRESOURCEFILEINFO *LPLOCRESOURCEFILEINFO;

struct SProjectInfo
{
	CLString m_strProjPath;
	LangId m_lSource;
	LangId m_lTarget;
};


	
DECLARE_INTERFACE_(ILocExtensionResource, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	enum ResourceEvent
	{
		reNewFile,
		reUserCancel,
		reMakeSrcResFailed		// RAID: LS42 bug 250 fixed by MikeL (Added)
	};
	
	STDMETHOD_(void, GetOperationInfo)(CLString &strContext,
			COutputTabs::OutputTabs &) CONST_METHOD PURE;
	
	STDMETHOD(Start)(THIS_ CReport *, const SProjectInfo &) PURE;

	STDMETHOD(Stop)(THIS_ CReport *) PURE;

	STDMETHOD(OnEvent)(THIS_ ResourceEvent event, const CLocVariant &var,
			CReport *pReporter) PURE;
	STDMETHOD(Analyze)(THIS_
			const LOCRESOURCEFILEINFO &SourceFileInfo,
			const LOCRESOURCEFILEINFO &pTargetFileInfo,
			const CDBIDArray &aDBID,
			CReport *pReporter,
			const CLString &strContext,
			BOOL &fModifiedTarget) PURE;

	STDMETHOD_(void, SetProjName)(const CLString & strProjName) PURE;
	STDMETHOD_(BOOL, InitReports)() PURE;
};

	
interface __declspec(uuid("{9F9D180F-6F38-11d0-98FD-00C04FC2C6D8}"))
		ILocExtensionResource;


interface ILocTransFields;


DECLARE_INTERFACE_(ILocExtensionTranslation, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	enum TranslationEvent
	{
		teNewFile,
		teUserCancel,
	};
	
	enum StartLocation
	{
		slProjectTree,
		slTranslationWindow
	};

	STDMETHOD_(BOOL, IsReadOnly)() CONST_METHOD PURE;
	STDMETHOD_(void, GetOperationInfo)(CLString &strContext,
			COutputTabs::OutputTabs &) CONST_METHOD PURE;
	
	STDMETHOD(Start)(THIS_ StartLocation slStart,
			CReport *, const SProjectInfo &) PURE;
	
	STDMETHOD(Stop)(THIS_ CReport *) PURE;
	
	STDMETHOD(OnEvent)(THIS_ TranslationEvent event,
			const CLocVariant &var, CReport *pReport) PURE;

	STDMETHOD(ProcessRow)(THIS_ ILocTransFields *pITransFields,
			CReport *, const CLString &strContext) PURE;
};

interface __declspec(uuid("{C35F8B61-FE4D-11d0-A5A1-00C04FC2C6D8}"))
		ILocExtensionTranslation;



DECLARE_INTERFACE_(ILocTransFields, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	enum PreferredGoto
	{
		pgDefault,
		pgProjWindow,
		pgTransTable,
		pgVisEditor
	};
	
	//
	//  Properties
	STDMETHOD_(CGoto *, GetGoto)(PreferredGoto pg = pgDefault) CONST_METHOD PURE;
	STDMETHOD_(void, GetFullItemName)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetFullFileName)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(BOOL, HasString)() CONST_METHOD PURE;
	STDMETHOD_(BOOL, HasBinary)() CONST_METHOD PURE;
	STDMETHOD_(BOOL, IsStringLocked)() CONST_METHOD PURE;
	STDMETHOD(GetCustomFieldValues)(UINT, CPasStringArray &)
		CONST_METHOD PURE;
	
	//
	//  Data retrieval methods
	STDMETHOD_(void, GetUniqueID)(CLocUniqueId &) CONST_METHOD PURE;
	STDMETHOD_(void, GetSourceString)(CLocString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTargetString)(CLocString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetPreviousSource)(CLocString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetInstructions)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTermNote)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTextStatus)(CLS::LocStatus &) CONST_METHOD PURE;
	STDMETHOD_(void, GetBinaryStatus)(CLS::LocStatus &) CONST_METHOD PURE;
	STDMETHOD_(void, GetStringType)(CST::StringType &) CONST_METHOD PURE;
	STDMETHOD_(void, GetApprovalState)(CAS::ApprovalState &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTranslationOrigin)(CTO::TranslationOrigin &)
		CONST_METHOD PURE;
	STDMETHOD_(void, GetSourceLock)(BOOL &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTgtLockedToSource)(BOOL &) CONST_METHOD PURE;
	STDMETHOD_(void, GetUserLock)(BOOL &) CONST_METHOD PURE;
	STDMETHOD_(void, GetAutoApproved)(CAA::AutoApproved & aa) CONST_METHOD PURE;
	STDMETHOD_(void, GetParserId)(ParserId &) CONST_METHOD PURE;
	STDMETHOD_(void, GetLastUpdatedBy)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetLastUpdateTime)(COleDateTime &) CONST_METHOD PURE;
	STDMETHOD_(void, GetSourceBinary)(CLocBinary *&) PURE;
	STDMETHOD_(void, GetTargetBinary)(CLocBinary *&) PURE;
	STDMETHOD_(void, GetInstrAttn)(BOOL &) CONST_METHOD PURE;
	STDMETHOD_(void, GetConfidenceLevel)(LONG &) CONST_METHOD PURE;
	STDMETHOD(GetCustomFieldValue)(UINT, CPascalString &) CONST_METHOD PURE;

	//
	//  Danger!  Use these, and you can totally destroy user data
	//  MAKE SURE YOU KNOW WHAT YOU ARE DOING!
	STDMETHOD(BeginEdit)() PURE;
	STDMETHOD(EndEdit)(BOOL fCommit) PURE;

	//
	//  NOTE!  Set methods implement 'business logic' - changing an item may
	//  lead to several other changes - for example, changing the target
	//  string may change the localization status.
	STDMETHOD(SetCustomFieldValue)(const UINT, const CPascalString &) PURE;	
 	STDMETHOD(SetInstructions)(const CPascalString &) PURE;
 	STDMETHOD(SetTermNote)(const CPascalString &) PURE;
 	STDMETHOD(SetStringType)(const CST::StringType) PURE;

 	STDMETHOD(SetTranslationOrigin)(const CTO::TranslationOrigin) PURE;

 	STDMETHOD(SetTextStatus)(const CLS::LocStatus) PURE;
 	STDMETHOD(SetApprovalState)(const CAS::ApprovalState) PURE;
 	STDMETHOD(SetTargetString)(const CLocString &) PURE;
 	STDMETHOD(SetTgtLockedToSource)(BOOL) PURE;
 	STDMETHOD(SetUserLock)(BOOL) PURE;
 	STDMETHOD(SetAutoApproved)(const CAA::AutoApproved aa) PURE;
	STDMETHOD(SetInstrAttn)(BOOL) PURE;
	
 	STDMETHOD(RevertString)() PURE;

	STDMETHOD(SetTargetBinary)(const CLocBinary *) PURE;
 	STDMETHOD(SetBinaryStatus)(const CLS::LocStatus) PURE;

};


interface __declspec(uuid("{42C5D1E7-FE50-11d0-A5A1-00C04FC2C6D8}"))
		ILocTransFields;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_var.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _VAR.H

History:

--*/

#ifndef ESPUTIL__VAR_H
#define ESPUTIL__VAR_H


//
// variant object, represents a VARIANT
//
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY  CVar : public CObject
{
public:
	CVar();
	CVar(const CVar&);
	CVar(VARIANT);
	CVar(const CPascalString&);
	CVar(PWSTR);
	CVar(PCWSTR);
	CVar(PSTR);
	CVar(PCSTR);
	CVar(SHORT);
	CVar(WCHAR);
	CVar(UINT);
	CVar(BOOL);
	CVar(BYTE);
	CVar(LONG);
	CVar(DATE);
	CVar(DWORD);
	CVar(tm*);			// build from a date in tm format
	~CVar();

	NOTHROW const CVar& operator = (const CVar &);
	NOTHROW const CVar& operator = (VARIANT);
	NOTHROW const CVar& operator = (const CPascalString&);
	NOTHROW const CVar& operator = (PWSTR);
	NOTHROW const CVar& operator = (PCWSTR);
	NOTHROW const CVar& operator = (PSTR);
	NOTHROW const CVar& operator = (PCSTR);
	NOTHROW const CVar& operator = (SHORT);
	NOTHROW const CVar& operator = (WCHAR);
	NOTHROW const CVar& operator = (UINT);
	NOTHROW const CVar& operator = (BOOL);
	NOTHROW const CVar& operator = (BYTE);
	NOTHROW const CVar& operator = (LONG);
	NOTHROW const CVar& operator = (DATE);
	NOTHROW const CVar& operator = (DWORD);

	NOTHROW operator COleVariant   (VOID) const;
	NOTHROW operator LPVARIANT     (VOID);
	NOTHROW operator CPascalString (VOID) const;
	NOTHROW operator SHORT         (VOID) const;
	NOTHROW operator WCHAR         (VOID) const;
	NOTHROW operator UINT          (VOID) const;
	NOTHROW operator BOOL          (VOID) const;
	NOTHROW operator BYTE          (VOID) const;
	NOTHROW operator LONG          (VOID) const;
	NOTHROW operator DATE          (VOID) const;
	NOTHROW operator DWORD         (VOID) const;
	NOTHROW operator PSTR          (VOID) const;
	NOTHROW operator PCSTR         (VOID) const;
	NOTHROW operator PWSTR         (VOID) const;
	NOTHROW operator PCWSTR        (VOID) const;

	void AnsiToWide();
	void WideToAnsi();

	void SetBSTR(BSTR);
	
	void SetStringByteLen(const char * sz, unsigned int ui);

	NOTHROW int GetLength();

	NOTHROW BOOL IsNull() const;
	NOTHROW VOID SetNull();
	NOTHROW VOID SetError();

	NOTHROW BOOL operator==(const CVar& v) const;
	NOTHROW BOOL operator!=(const CVar& v) const;

	//
	// debug routines
	//
	virtual void AssertValid() const;

private:
	VARIANT m_var;
};

#pragma warning(default: 4275)


#endif //ESPUTIL_VAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_wtrmark.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _WTRMARK.INL

History:

--*/

inline
CLocWMCommon::CLocWMCommon(
	const CLString& strSource, 
	const ParserId& pid, 
	const CLString& strParserVer)
{
	m_strSource = strSource;
	m_pid = pid;
	m_strParserVer = strParserVer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\cancel.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    CANCEL.INL

History:

--*/

inline
CCancelableObject::CCancelableObject(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_reporter.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _REPORTER.INL

History:

--*/

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Note' severity messages from the CBufferReporter.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetNotes(void)
		const
{
	return m_bufReport.GetNotes();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Warning' severity messages from the CBufferReporter.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetWarnings(void)
		const
{
	return m_bufReport.GetWarnings();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Error' severity messages from the CBufferReporter.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetErrors(void)
		const
{
	return m_bufReport.GetErrors();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Abort' severity messages from the CBufferReporter.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetAborts(void)
		const
{
	return m_bufReport.GetAborts();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns ALL the messages issued to the CBufferReporter.  The messages
//  are stored in chronological order.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetMessages(void)
		const
{
	return m_bufReport.GetMessages();
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//	Returns the CBufferReport object.
//  
//-----------------------------------------------------------------------------
inline
const CBufferReport &
CBufferReporter::GetBufReport(void)
	const
{
	return m_bufReport;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\cancel.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    CANCEL.H

History:

--*/


#ifndef ESPUTIL_CANCEL_H
#define ESPUTIL_CANCEL_H



class CCancelDialog;

class LTAPIENTRY CCancelableObject : public CProgressiveObject
{
public:
	CCancelableObject(void);

	virtual void AssertValid(void) const;
	
	virtual BOOL fCancel(void) const = 0;

	virtual ~CCancelableObject();
};



#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "cancel.inl"
#endif

#endif // ESPUTIL_CANCEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\dcsgrid.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    DCSGRID.H

History:

--*/

#if !defined(__DcsGrid_h__)
#define __DcsGrid_h__

namespace MitDisplayColumns
{
	interface IOption;
	interface IColumn;
};

//------------------------------------------------------------------------------
class LTAPIENTRY CDcsGrid
{
public:
	static int DisplayOrder(MitDisplayColumns::IOption * pdcOption, 
			long nColumnID, long nOffsetDO);
	static int DisplayOrder(MitDisplayColumns::IColumn * pdcColumn, 
			long nOffsetDO);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\dbhelp.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    DBHELP.H

History:

--*/


#if !defined(ESPUTIL_DbHelp_h_INCLUDED)
#define ESPUTIL_DbHelp_h_INCLUDED

//------------------------------------------------------------------------------
class LTAPIENTRY DbHelp
{
// Operations
public:
	static void GetSecFilePath(CLString & stPathName);
	static BOOL BuildSecFile(CLString & stSystemRegKey);
	static BOOL CreateSecurityFile();
	static BOOL SetupRegistry();

// Data
protected:
	static BOOL		m_fInit;
	static CLString m_stRegKey;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_wtrmark.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _WTRMARK.H

History:

--*/

#pragma once


const int EWM_MAX_LENGTH = 512;		  // Watermarks should never be longer
                                      // than this	

static TCHAR g_cWMSep = _T('\t');

// All watermarks begin with this string
static TCHAR g_szWMLocString[] = _T("Localized");


//
// This class does not need to be exported as all implementations
// are inline
//
class CLocWMCommon
{
 public:
	CLocWMCommon(const CLString& strSource, const ParserId& pid, 
			const CLString& strParserVer);

	CLString m_strSource;		// Name of the source file
	ParserId m_pid;				// Parser using the watermark
	CLString m_strParserVer;  	// Version of the parser 
};

//
// struct defining the header of watermarks when encoded in binary file types
//
#include <pshpack1.h>

struct EWM_HEADER
{
	BYTE bVersion;	   	// Version of the binary data                            
	WORD wLength;		// Length of the string		
};

#include <poppack.h>

const BYTE EWM_ESP21_VERSION = 0;
const BYTE EWM_ESP30_VERSION = 1;
const BYTE EWM_DEFAULT_VERSION = 1;

//
// This function will retrieve the current date from the system and build the 
// common Espresso WaterMark. A Tab character separates elements of the 
// watermark.
//
void LTAPIENTRY ComposeWaterMark(const CLocWMCommon& wm, 
	CLString& strWaterMark);


//
// This function will encode the watermark into non-readable characters and 
// place the encoded string with the WM_HEADER in baOut.  
//
void LTAPIENTRY EncodeWaterMark(const CLString& strNormal, CByteArray& baOut);

void LTAPIENTRY EnCryptWaterMark(DWORD* pData, int nLength);


#include "_wtrmark.inl"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\espopts.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ESPOPTS.H

History:

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\enumplatform.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ENUMPLATFORM.H

History:

--*/
// Note: This file can be included by both MIDL and C++.  Make sure to #include
// "PreMidlEnum.h" or "PreCEnum.h" before #including this file.

//
//  This order is important: all new values must be added TO THE END, or you 
//  will break old parsers...
//

BEGIN_ENUM(Platform)
	ENUM_ENTRY_(gdo, None, 0)
	ENUM_ENTRY(gdo, Windows)
	ENUM_ENTRY(gdo, WinNT)
	ENUM_ENTRY(gdo, Macintosh)
	ENUM_ENTRY(gdo, DOS)
	ENUM_ENTRY(gdo, Other)
	ENUM_ENTRY(gdo, All)
END_ENUM(Platform)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\extlist.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    EXTLIST.H

History:

--*/
#ifndef EXTLIST_H
#define EXTLIST_H


#pragma warning(disable : 4275)

class LTAPIENTRY CLocExtensionList : public CStringList
{
public:
	CLocExtensionList();

	void AssertValid(void) const;
	
	//
	//  Conversion routines to/from CLString's.
	//
	void NOTHROW ConvertToCLString(CLString &) const;
	BOOL NOTHROW ConvertFromCLString(const CLString &);
	
	~CLocExtensionList();
private:
	
};

#pragma warning(default : 4275)

#endif // EXTLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\espreg.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ESPREG.H

History:

--*/

struct LocVersionInfo
{
	WORD    wVerMajor;
	WORD    wVerMinor;
	WORD    wVerBuild;
	CString strVerString;
};


LTAPIENTRY void NOTHROW GetVersionInfo(LocVersionInfo &);

LTAPIENTRY BOOL NOTHROW OpenEspressoUserKey(HKEY &);

LTAPIENTRY BOOL NOTHROW OpenEspressoUserSubKey(HKEY &, const CLString &);

LTAPIENTRY BOOL NOTHROW EspressoUserSubKeyExists(const CLString &);

LTAPIENTRY BOOL NOTHROW OpenEspressoMachineKey(HKEY &);

LTAPIENTRY BOOL NOTHROW OpenEspressoMachineSubKey(HKEY &, const CLString &);

LTAPIENTRY BOOL NOTHROW EspressoMachineSubKeyExists(const CLString &);

LTAPIENTRY BOOL NOTHROW MyRegDeleteKey(HKEY &, const TCHAR *);

LTAPIENTRY void NOTHROW GetRegistryString(CLString &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\enumstringtype.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ENUMSTRINGTYPE.H

History:

--*/
// Note: This file can be included by both MIDL and C++.  Make sure to #include
// "PreMidlEnum.h" or "PreCEnum.h" before #including this file.

//
//  This order is important - if must change it, make sure you make the
//  corresponding changes in GetTypeName() and GetTypeTLA()!
//  All new values must be added TO THE END, or you will break old
//  parsers...
//

BEGIN_ENUM(StringType)
	ENUM_ENTRY_(gdo, None, 0)
	ENUM_ENTRY(gdo, Text)
	ENUM_ENTRY(gdo, Message)
	ENUM_ENTRY(gdo, ErrorMessage)
	ENUM_ENTRY(gdo, Comment)
	ENUM_ENTRY(gdo, StatusBarText)
	ENUM_ENTRY(gdo, ToolTipText)
	ENUM_ENTRY(gdo, KeyName)
	ENUM_ENTRY(gdo, ArgumentName)
	ENUM_ENTRY(gdo, FunctionName)
	ENUM_ENTRY(gdo, FolderName)
	ENUM_ENTRY(gdo, FontName)
	ENUM_ENTRY(gdo, StaticText)
	ENUM_ENTRY(gdo, DialogTitle)
	ENUM_ENTRY(gdo, TabControl)
	ENUM_ENTRY(gdo, GroupBoxTitle)
	ENUM_ENTRY(gdo, EditBox)
	ENUM_ENTRY(gdo, Button)
	ENUM_ENTRY(gdo, OptionButton)
	ENUM_ENTRY(gdo, CheckBox)
	ENUM_ENTRY(gdo, CustomControl)
	ENUM_ENTRY(gdo, TrackBar)
	ENUM_ENTRY(gdo, ProgressBar)
	ENUM_ENTRY(gdo, DriveLetter)
	ENUM_ENTRY(gdo, Folder)
	ENUM_ENTRY(gdo, MenuItem)
	ENUM_ENTRY(gdo, Accelerator)
	ENUM_ENTRY(gdo, Version)
	ENUM_ENTRY(gdo, Translation)
	ENUM_ENTRY(gdo, ListBox)
	ENUM_ENTRY(gdo, ScrollBar)
	ENUM_ENTRY(gdo, ComboBox)
	ENUM_ENTRY(gdo, RadioButton)
	ENUM_ENTRY(gdo, GroupBox)
	ENUM_ENTRY(gdo, General)
	ENUM_ENTRY(gdo, Unknown)
	ENUM_ENTRY(gdo, Keyword)
	ENUM_ENTRY(gdo, TopicTitle)
	ENUM_ENTRY(gdo, PageTitle)
	ENUM_ENTRY(gdo, Command)
	ENUM_ENTRY(gdo, Address)
	ENUM_ENTRY(gdo, AlternativeText)
	ENUM_ENTRY(gdo, HTMLText)
	ENUM_ENTRY(gdo, HTMLTitle)
	ENUM_ENTRY(gdo, JavaText)
	ENUM_ENTRY(gdo, Number)
	ENUM_ENTRY(gdo, PageInformation)
	ENUM_ENTRY(gdo, Style)
	ENUM_ENTRY(gdo, VBScriptText)
	ENUM_ENTRY(gdo, Property)
	ENUM_ENTRY(gdo, MacroAction)
	ENUM_ENTRY(gdo, FileName)
	ENUM_ENTRY(gdo, Billboards)
	ENUM_ENTRY(gdo, DialogItem)
	ENUM_ENTRY(gdo, Description)
	ENUM_ENTRY(gdo, FeatureTitle)
	ENUM_ENTRY(gdo, FeatureDescription)
	ENUM_ENTRY(gdo, INIFileName)
	ENUM_ENTRY(gdo, INIFileKey)
	ENUM_ENTRY(gdo, INIFileSection)
	ENUM_ENTRY(gdo, INIFileValue)
	ENUM_ENTRY(gdo, AppData)
	ENUM_ENTRY(gdo, RegistryValue)
	ENUM_ENTRY(gdo, ResourceData)
	ENUM_ENTRY(gdo, ShortcutDescription)
	ENUM_ENTRY(gdo, ShortcutName)
	ENUM_ENTRY(gdo, ShortcutHotKey)
	ENUM_ENTRY(gdo, ShortcutArgument)
	ENUM_ENTRY(gdo, Verb)
	ENUM_ENTRY(gdo, Argument)
	ENUM_ENTRY(gdo, ComponentID)
	ENUM_ENTRY(gdo, FileSize)
	ENUM_ENTRY(gdo, Fileversion)
	ENUM_ENTRY(gdo, FileLanguage)
	ENUM_ENTRY(gdo, Documentation)
END_ENUM(StringType)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\espstate.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ESPSTATE.H

History:

--*/
#pragma once


// *************************************************************************************************
// TEMPORARY: Move to seperate file

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CEspState : public CObject
{
// Construction
public:
	CEspState();

// Enums
public:
	enum eState
	{
		esIdle				= 0,
		esUpdate			= 1,
		esGenerate			= 2,
		esUpload			= 3,
		esCopyData			= 4,
		esImportData		= 5,
		esImportGlossary	= 7,
		esInternal			= 8,
		esMerge				= 9,
		esOther					= 10,
		esOpeningMainTab		= 11,
		esOpeningResEdTab		= 12,
		esSavingResEdChanges	= 13,
		esApplyingFilter		= 14,
		esOpeningEDB            = 15,
		NUM_STATES
	};

// Data
private:
	BOOL		m_fComplete;
	IDispatch * m_pdispCheckTree;
	IDispatch * m_pdispDescBox;
	IDispatch * m_pdispDlgGlosGrid;
	eState		m_nOperation;		// Current operation
	eState		m_nLastOperation;	// Previous operation

// Operations
public:
	eState GetState();
	eState GetLastState();
	BOOL SetState(eState state);
	BOOL StartState(eState state);  // Moves to state and not complete
	BOOL FinishState();				// Moves to idle and complete

	BOOL GetComplete();
	void SetComplete(BOOL fComplete = TRUE);

	// Functions to store the current CheckTree and DescBox.
	//
	// NOTE: These functions do not AddRef() the pointers assigned since they
	// should never hold onto the interface outside of the parent's lifetime.
	//
	IDispatch * GetCurrentCheckTree();
	IDispatch * GetCurrentDescBox();
	IDispatch * GetCurrentDlgGlosGrid();
	void SetCurrentCheckTree(IDispatch * pdisp);
	void SetCurrentDescBox(IDispatch * pdisp);
	void SetCurrentDlgGlosGrid(IDispatch * pdisp);
};


//
//  Sets a state on creation, calls FinishState on destruction
class LTAPIENTRY CEspStateObj
{
public:
	CEspStateObj(CEspState::eState);
	
	~CEspStateObj();

private:
	int foo;
};

	

#pragma warning(default: 4275)

LTAPIENTRY CEspState & GetEspState();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\fieldval.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    FIELDVAL.H

History:

--*/

#pragma once

#pragma warning(disable : 4251)
class LTAPIENTRY CColumnVal
{
public:
	CColumnVal();
	explicit CColumnVal(const CColumnVal & val);
	explicit CColumnVal(const CPascalString & pasValue);
	explicit CColumnVal(long nValue);
	explicit CColumnVal(const COleDateTime & dateValue);
	explicit CColumnVal(BOOL fValue);
	
	enum ColumnValType
	{
		cvtNone,
		cvtString,
		cvtLong,
		cvtDate,
		cvtBool,
		cvtStringList,
		cvtLocTerm
	};

	void Serialize(CArchive &);
	
	const CColumnVal & operator=(const CColumnVal & val);
	void SetString(const CPascalString & pasValue);
	void SetLong(const long nValue);
	void SetDate(const COleDateTime & dateValue);
	void SetBool(const BOOL fValue);
	void SetStringIndex(const long nValue);
	
	ColumnValType GetType() const;
	const CPascalString &GetString() const;
	long GetLong() const;
	const COleDateTime & GetDate() const;
	BOOL GetBool() const;
	long GetStringIndex() const;
	
	int operator==(const CColumnVal &);
	int operator!=(const CColumnVal &);
	
#ifdef LTASSERT_ACTIVE
	void AssertValid(void) const;
#endif
	
private:
	BOOL Compare(const CColumnVal & valCompare);
	void AssignFrom(const CColumnVal & valSrc);
	
	ColumnValType m_cvt;
	
	union
	{
		long m_long;
		BOOL m_bool;
	};
	CPascalString m_pasString;
	COleDateTime m_Time;
};

typedef CColumnVal CCV;

#pragma warning(default : 4251)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "FieldVal.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\fieldval.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    FIELDVAL.INL

History:

--*/

inline
CColumnVal::CColumnVal()
{
	m_cvt = cvtNone;
}



inline
void
CColumnVal::SetString(
		const CPascalString &pas)
{
	m_cvt		= cvtString;
	m_pasString	= pas;
}



inline
void
CColumnVal::SetLong(
		long nValue)
{
	m_cvt	= cvtLong;
	m_long	= nValue;
}



inline
void
CColumnVal::SetDate(
		const COleDateTime &dt)
{
	m_cvt = cvtDate;
	m_Time = dt;
}



inline
void
CColumnVal::SetBool(
		BOOL b)
{
	m_cvt = cvtBool;

	m_bool = b;
}



inline
CColumnVal::CColumnVal(
		const CColumnVal &other)
{
	AssignFrom(other);
}



inline
CColumnVal::CColumnVal(
		const CPascalString &pas)
{
	SetString(pas);
}



inline
CColumnVal::CColumnVal(
		long nValue)
{
	SetLong(nValue);
}



inline
CColumnVal::CColumnVal(
		const COleDateTime &dt)
{
	SetDate(dt);
}



inline
CColumnVal::CColumnVal(
		BOOL b)
{
	SetBool(b);
}

		
		

inline
const CColumnVal &
CColumnVal::operator=(const CColumnVal &other)
{
	AssignFrom(other);
	
	return *this;
}



inline
void
CColumnVal::SetStringIndex(
		long idxValue)
{
	m_cvt	= cvtStringList;
	m_long	= idxValue;
}



inline
CColumnVal::ColumnValType
CColumnVal::GetType()
		const
{
	return m_cvt;
}



inline
const CPascalString &
CColumnVal::GetString()
		const
{
	LTASSERT(m_cvt == cvtString);
	return m_pasString;
}



inline
long
CColumnVal::GetLong()
		const
{
	LTASSERT(m_cvt == cvtLong);
	return m_long;
}



inline
const COleDateTime &
CColumnVal::GetDate()
		const
{
	LTASSERT(m_cvt == cvtDate);
	return m_Time;
}



inline
BOOL
CColumnVal::GetBool()
		const
{
	LTASSERT(m_cvt == cvtBool);
	return m_bool;
}



inline
long
CColumnVal::GetStringIndex()
		const
{
	LTASSERT(m_cvt == cvtStringList);
	return m_long;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\fileexcldlg.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    FILEEXCLDLG.H

History:

--*/

#if !defined(AFX_FILEEXCLDLG_H__A0269213_4B2B_11D1_9F0F_006008166DEA__INCLUDED_)
#define AFX_FILEEXCLDLG_H__A0269213_4B2B_11D1_9F0F_006008166DEA__INCLUDED_

#pragma warning(disable : 4275)
#pragma warning(disable : 4251)


class LTAPIENTRY CLFileExclDlg : public CLFileDialog
{
	DECLARE_DYNAMIC(CLFileExclDlg)

public:
	CLFileExclDlg(
		BOOL bOpenFileDialog = TRUE, // TRUE for FileOpen, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL,
		LPCTSTR pszTitle = NULL);


	BOOL GetExclusivePref( ) const;

// Dialog Data
	//{{AFX_DATA(CLFileExclDlg)
	BOOL m_bExclusive;
	//}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CLFileExclDlg)
    public:
    virtual int DoModal();
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
	//{{AFX_MSG(CLFileExclDlg)
		// NOTE - the ClassWizard will add and remove member functions here.
    virtual BOOL OnInitDialog();
	afx_msg void OnClickChkExcl();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


#pragma warning(default : 4275)
#pragma warning(default : 4251)


#endif // !defined(AFX_FILEEXCLDLG_H__A0269213_4B2B_11D1_9F0F_006008166DEA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\filedlg.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    FILEDLG.H

History:

--*/

#if !defined(__FileDlg_h__)
#define __FileDlg_h__

#pragma warning(disable : 4275)

class LTAPIENTRY CLFileDialog : public CFileDialog
{
	DECLARE_DYNAMIC(CLFileDialog)

public:
	CLFileDialog(
		BOOL bOpenFileDialog = TRUE, // TRUE for FileOpen, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL,
		LPCTSTR pszTitle = NULL);

// Operations
public:
	CString GetFileFilter();

	virtual int DoModal();

// Attributes
public:
	virtual void SetOkButtonText(TCHAR const * const szOkText);
	virtual void SetOkButtonText(HINSTANCE const hResourceDll,
			UINT const uStringId);

	virtual void SetCancelButtonText(TCHAR const * const szCancelText);
	virtual void SetCancelButtonText(HINSTANCE const hResourceDll,
			UINT const uStringId);

	virtual void SetCheckIfBufferTooSmall(BOOL const bCheckIfBufferTooSmall);

// Data
protected:
	CLString m_strOkButton;				// new OK button text for dialog
	CLString m_strCancelButton;			// new Cancel button text for dialog
	BOOL m_bCheckIfBufferTooSmall;		// should DoModal() checks condition?

// Implementation
protected:
	//{{AFX_MSG(CProjectOpenDlg)
    virtual BOOL OnInitDialog();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Implementation
protected:
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT * pResult);
};

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\fielddef.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    FIELDDEF.H

History:

--*/ 
#pragma once

#pragma warning(disable:4275)  // Exported classes

//------------------------------------------------------------------------------
struct LTAPIENTRY COLUMN_STRING_ENTRY
{
// Construction
public:
	COLUMN_STRING_ENTRY();
	COLUMN_STRING_ENTRY(const COLUMN_STRING_ENTRY & entry);

// Data
public:
	CLString	st;				// Display String
	long		nID;			// User value (unique ID)

// Operations
public:
	const COLUMN_STRING_ENTRY & operator=(const COLUMN_STRING_ENTRY & entry);
};

typedef CArray<COLUMN_STRING_ENTRY, COLUMN_STRING_ENTRY&> CColStrEntryArray;

//------------------------------------------------------------------------------
class LTAPIENTRY CColumnStrList : public CLocThingList<COLUMN_STRING_ENTRY>
{
// Operations
public:
	BOOL FindDisplayName(long nID, CLString & stName) const;
	BOOL FindID(const CLString &stName,long &nID) const;
};

// RAID:  LS42 Bug 46 fixed by MikeL
// Pointer to a function to allow each column
// type to have its own validation function.
typedef BOOL (* PFNVALIDATE) (LPCTSTR, DWORD);

// RAID:  LS42 Bug 46 fixed by MikeL
// Added m_pfnValidateFunc to allow each column
// type to have its own validation function.
//------------------------------------------------------------------------------
class LTAPIENTRY CColumnDefinition : public CRefCount
{
public:
	CColumnDefinition(const WCHAR * pszInternalName, long nID,
			const CLString &strName, const CLString &strHelp,
			CColumnVal::ColumnValType vt, Operators ops,
			BOOL fDisplayable, BOOL fSortable, BOOL fReadOnly,
			PFNVALIDATE pfnValidateFunc);

	void SetStringList(const CColumnStrList & lstColumnStr);
	
	const CPascalString & GetInternalName() const;
	long GetID() const;
	const CLString & GetDisplayName() const;
	const CLString & GetHelpText() const;
	BOOL IsDisplayable() const;
	BOOL IsSortable() const;
	BOOL IsReadOnly() const;
	
	CColumnVal::ColumnValType GetColumnType() const;
	Operators GetOperators() const;

	const CColumnStrList & GetStringList() const; 

	BOOL Validate (LPCTSTR lpsz, DWORD dw) const;

	
private:
	CPascalString	m_pasInternalName;	// Unique String ID
	long		m_nID;				// Unique Number ID (can be any number)
	CLString	m_strDisplayName;	// Displayed name
	CLString	m_strHelpText;		// Description of column
	CColumnVal::ColumnValType m_vt;	// Type of data
	Operators	m_ops;				// Valid filtering operations
	BOOL		m_fDisplayable;		// Column is displayable
	BOOL		m_fSortable;		// Column is sortable
	BOOL		m_fReadOnly;		// Column is read-only
	PFNVALIDATE	m_pfnValidateFunc;	// Pointer to column value validation func

	CColumnStrList m_lstColumnStr;
};


//------------------------------------------------------------------------------
// CEnumIntoColStrList provides a method of enumerating directly into a list of
// COLUMN_STRING_ENTRY's.
//
class LTAPIENTRY CEnumIntoColStrList : public CEnumCallback
{
// Construction
public:
	CEnumIntoColStrList(CColumnStrList & lstColStr, BOOL fLock = TRUE);
	~CEnumIntoColStrList();

// CEnumCallback implementation
public:
	virtual BOOL ProcessEnum(const EnumInfo &);

protected:
	CColumnStrList & m_lstColStr;
	BOOL	m_fLock;				// Lock list when finished
};


//------------------------------------------------------------------------------
class LTAPIENTRY CColDefUtil
{
// Operations
public:
	static void FillBool(CButton * pbtn, BOOL fValue = TRUE);	
	static void FillBool(CListBox * plbc, BOOL fValue = TRUE, BOOL fEmpty = TRUE);	
	static void FillBool(CComboBox * pcbc, BOOL fValue = TRUE, BOOL fEmpty = TRUE);	

	static void FillStringList(CListBox * plbc, const CColumnStrList & lstColStr,
			long idSelect = -1, BOOL fEmpty = TRUE);	
	static void FillStringList(CComboBox * pcbc, const CColumnStrList & lstColStr,
			long idSelect = -1, BOOL fEmpty = TRUE);


	//------------------------------------------------------------------------------
	class LTAPIENTRY CColDefCB : public CObject
	{
	public:
		virtual int AddItem(const CLString & stName, long nID);
		virtual void SetCurSel(long nSelect);
		virtual void FillBool(BOOL fValue = TRUE, BOOL fEmpty = TRUE);
		virtual void FillStringList(const CColumnStrList & lstColStr, long idSelect = -1, BOOL fEmpty = TRUE);
		virtual void Empty();

#ifdef _DEBUG
		virtual void AssertValid() const;
#endif
	};


	//------------------------------------------------------------------------------
	class LTAPIENTRY CCheckBoxCB : public CColDefCB
	{
	public:
		CCheckBoxCB(CButton * pbtn);
		virtual void FillBool(BOOL fValue = TRUE, BOOL fEmpty = TRUE);

#ifdef _DEBUG
		virtual void AssertValid() const;
#endif

	protected:
		CButton * const m_pbtn;
	};


	//------------------------------------------------------------------------------
	class LTAPIENTRY CListBoxCB : public CColDefCB
	{
	public:
		CListBoxCB(CListBox * plbc);
		virtual int AddItem(const CLString & stName, long nID);
		virtual void SetCurSel(long nSelect);
		virtual void FillBool(BOOL fValue = TRUE, BOOL fEmpty = TRUE);
		virtual void FillStringList(const CColumnStrList & lstColStr, long idSelect = -1, BOOL fEmpty = TRUE);
		virtual void Empty();

#ifdef _DEBUG
		virtual void AssertValid() const;
#endif

	protected:
		CListBox * const m_plbc;
	};


	//------------------------------------------------------------------------------
	class LTAPIENTRY CComboBoxCB : public CColDefCB
	{
	public:
		CComboBoxCB(CComboBox * pcbc);
		virtual int AddItem(const CLString & stName, long nID);
		virtual void SetCurSel(long nSelect);
		virtual void FillBool(BOOL fValue = TRUE, BOOL fEmpty = TRUE);
		virtual void FillStringList(const CColumnStrList & lstColStr, long idSelect = -1, BOOL fEmpty = TRUE);
		virtual void Empty();

#ifdef _DEBUG
		virtual void AssertValid() const;
#endif

	protected:
		CComboBox * const m_pcbc;
	};
};

LTAPIENTRY int AddListBoxItem(CListBox * plbc, const CLString & stAdd, DWORD dwItemData);
LTAPIENTRY int AddComboBoxItem(CComboBox * pcbc, const CLString & stAdd, DWORD dwItemData);
LTAPIENTRY int AddListBoxItem(CListBox * plbc, HINSTANCE hDll, UINT nStringID, DWORD dwItemData);
LTAPIENTRY int AddComboBoxItem(CComboBox * pcbc, HINSTANCE hDll, UINT nStringID, DWORD dwItemData);

LTAPIENTRY void GetBoolValue(BOOL fValue, CLString & stValue);

#pragma warning(default:4275)  // Exported classes
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\goto.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    GOTO.H

History:

--*/
#pragma once

class LTAPIENTRY CGoto : public CRefCount
{
public:
	CGoto()	{};
	
	virtual void Edit() = 0;
	virtual BOOL Go() = 0;


private:
	CGoto(const CGoto &);
	
};

#pragma warning(disable:4251)

class LTAPIENTRY CShellGoto : public CGoto
{
public:
	CShellGoto(const TCHAR *szFileName);

	virtual void Edit();
	virtual BOOL Go();

private:

	CLString m_strFileName;
};

#pragma warning(default:4251)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\flddefhelp.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    FLDDEFHELP.H

History:

--*/

// RAID:  LS42 Bug 46 fixed by MikeL
// Pointer to a function to allow each column
// type to have its own validation function.
typedef BOOL (* PFNVALIDATE) (LPCTSTR, DWORD);

// RAID:  LS42 Bug 46 fixed by MikeL
// Added pfnValidateFunc to allow each column
// type to have its own validation function.
//------------------------------------------------------------------------------
struct SBasicColumn
{
	const WCHAR *szInternalName;
	long nID;
	UINT IDSName;
	UINT IDSHelp;
	CColumnVal::ColumnValType vt;
	Operators ops;
	BOOL fDisplay;
	BOOL fSort;
	BOOL fReadOnly;
	PFNVALIDATE pfnValidateFunc;
};


struct SStringListColumn
{
	SBasicColumn sBasic;
	UINT IDSStringList;
};


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CColDefHelper : public CObject
{
public:
	CColDefHelper(HINSTANCE h);

	void SetBasicColumns(const SBasicColumn * pBasic, UINT nCntBasic);
	void SetStringColumns(const SStringListColumn * pStrings, UINT nCntStrings);
	
	CTableSchema * CreateSchema(const SchemaId &, UINT IDSDescription);
	
private:
	HINSTANCE				 m_hInst;
	const SBasicColumn *	 m_pBasicColumns;
	const SStringListColumn *m_pStringColumns;
	UINT					 m_uiBasicCount;
	UINT					 m_uiStringCount;
};


#pragma warning(default : 4275)

const TCHAR COL_PICK_SEPARATOR = _T('\n');

#define BEGIN_BASIC_COLUMN_DEFS(var) \
const SBasicColumn var[] = \
{

// RAID:  LS42 Bug 46 fixed by MikeL
// Added pfnValidateFunc to allow each column
// type to have its own validate function.
#define BASIC_COLUMN_DEF_ENTRY(name, nID, IDSName, IDSHelp, cvt, ops, fDisplay, fSort, fReadOnly, pfnValidateFunc) \
	{name, nID, IDSName, IDSHelp, cvt, ops, fDisplay, fSort, fReadOnly, pfnValidateFunc}

#define END_BASIC_COLUMN_DEFS() \
}

#define BEGIN_STRING_LIST_COLUMN_DEFS(var) \
const SStringListColumn var[] = \
{

// RAID:  LS42 Bug 46 fixed by MikeL
// Added pfnValidateFunc to allow each column
// type to have its own validate function.
#define STRING_LIST_COLUMN_ENTRY(name, nID, IDSName, IDSHelp, ops, fDisplay, fSort, fReadOnly, pfnValidateFunc, IDSList) \
	{ { name, nID, IDSName, IDSHelp, CColumnVal::cvtStringList, ops, fDisplay, fSort, fReadOnly, pfnValidateFunc }, IDSList}

#define END_STRING_LIST_COLUMN_DEFS() \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\flddeflist.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    FLDDEFLIST.H

History:

--*/
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class CColumnDefinition;

//------------------------------------------------------------------------------
class LTAPIENTRY CColDefList : public CTypedPtrList<CPtrList, CColumnDefinition *>
{
// Construction
public:
	CColDefList();
	CColDefList(const CColDefList &);
	
	~CColDefList();

// Operations
public:
	BOOL FindColumnDefinition(long nSearchID, const CColumnDefinition * & pFoundColDef) const;

// Debugging
#ifdef _DEBUG
	void AssertValid() const;
#endif
};

#pragma warning(default : 4275)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\globals.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    GLOBALS.H

History:

--*/

#include "resource.h"
 
extern HINSTANCE g_hLocUtilDll;

void GlobalInit(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\gotohelp.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    GOTOHELP.H

History:

--*/
 
class LTAPIENTRY CGotoHelp : public CRefCount
{
public:
	virtual void Edit() = 0;
	
	virtual BOOL GotoHelp() = 0;
	
};



class LTAPIENTRY CEspGotoHelp : public CGotoHelp
{
public:
	explicit CEspGotoHelp(UINT uiHelpId);

	virtual void Edit();
	virtual BOOL GotoHelp();

private:
	UINT m_uiHelpId;
};


class LTAPIENTRY CExternalGotoHelp : public CGotoHelp
{
public:
	CExternalGotoHelp(const TCHAR *szFileName, UINT uiHelpId);

	virtual void Edit();
	virtual BOOL GotoHelp();

private:
	CLString m_strFileName;
	UINT m_uiHelpId;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\interface.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    INTERFACE.H

History:

--*/

//  Various public interfaces in Espresso.
//  
 
#pragma once
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\locobj.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCOBJ.H

History:

--*/

//  Defines the mother of all classes for the Espresso 2.0 project.  For now,
//  this just devolved to CObject.  We define it just in case we decide to
//  implement our own mother of all classes.
//  
 
#ifndef LOCOBJ_H
#define LOCOBJ_H


//
//  The compiler worries when you export a class that has a base class
//  that is not exported.  Since I *know* that CObject is exported
//  tell the compliler that this really isn't a problem right here.
//
#pragma warning(disable : 4275)

class LTAPIENTRY CLObject : public CObject
{
public:
	CLObject();

	virtual void AssertValid(void) const;

	virtual void Serialize(CArchive &ar);

	virtual UINT GetSchema(void) const;
	
	virtual ~CLObject();

protected:

private:
};

#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locobj.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\locenum.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    :LOCENUM.H

History:

--*/
//------------------------------------------------------------------------------
class LTAPIENTRY CStringType
{
public:
	//
	//  This order is important - if must change it, make sure you make the
	//  corresponding changes in GetTypeName() and GetTypeTLA()!
	//  All new values must be added TO THE END, or you will break old
	//  parsers...
	//
	// NOTE: These #include files define an enumeration.  They MUST be inside this
	// class definition.
	//
#include "PreCEnum.h"
#include "EnumStringType.h"
	
	static int DefaultValue;
	NOTHROW static const TCHAR * GetTypeName(CStringType::StringType);
	NOTHROW static const TCHAR * GetTypeTLA(CStringType::StringType);
	static void Enumerate(CEnumCallback &);
	static const CStringType::StringType GetStringType(const TCHAR * tChIn);
	static const TCHAR * GetDefaultStringTypeText();
	static const CStringType::StringType GetDefaultStringType();
	static bool IsValidStringType(const CStringType::StringType &nIn);
	static bool IsValidStringType(const TCHAR * tChIn);
	
private:
	//
	//  Nobody should actually CONTRUCT one of these.
	//
	CStringType();

	//
	//  Used to store the info about each element in the enum...
	//
	struct StringTypeInfo
	{
		TCHAR szTLA[4];
		const TCHAR * szName;
	};

	static const StringTypeInfo m_Info[];
};

typedef CStringType CST;


//------------------------------------------------------------------------------
class LTAPIENTRY CPlatform
{
public:
	// NOTE: These #include files define an enumeration.  They MUST be inside this
	// class definition.
	//
#include "PreCEnum.h"
#include "EnumPlatform.h"
	
	NOTHROW static const TCHAR * GetPlatformName(CPlatform::Platform);
	static void Enumerate(CEnumCallback &);
	static const CPlatform::Platform CPlatform::GetPlatformType(const TCHAR * tChplat);
	static const TCHAR * GetDefaultPlatformText();
	static const CPlatform::Platform GetDefaultPlatform();
	static bool IsValidPlatform(const CPlatform::Platform &nIn);
	static bool IsValidPlatform(const TCHAR * tChplat);
	
private:
	static int DefaultValue;
	COSPlatform();
	static const TCHAR * const m_szPlatformNames[];
};


//------------------------------------------------------------------------------
class LTAPIENTRY CLocApprovalState
{
public:
	enum ApprovalState
	{
		Invalid = 0,
		Old_Pending,					// OBSOLETE! Do Not Use!
		Approved,
		PreApproved,
		NotReady,
		Failed,
		ForResearch,
		NotApplicable
	};
	static ApprovalState DefaultValue;
	NOTHROW static const TCHAR * GetApprovalText(CLocApprovalState::ApprovalState);
	static void Enumerate(CEnumCallback &);
	static const CLocApprovalState::ApprovalState GetApprovalState(const TCHAR * );
	static const TCHAR * GetDefaultApprovalText();
	static const CLocApprovalState::ApprovalState GetDefaultApprovalState();
	static BOOL IsValidApprovalState(const CLocApprovalState::ApprovalState &nIn);
	static BOOL IsValidApprovalState(const TCHAR * );
	
private:
	struct SStateName
	{
		ApprovalState as;
		const TCHAR *szName;
	};
	
	static const SStateName m_aStateNames[];
	CLocApprovalState();
};

typedef CLocApprovalState CAS;


//------------------------------------------------------------------------------
class LTAPIENTRY CLocAutoApproved
{
// Operations
public:
	enum AutoApproved
	{
		Invalid = 0,
		No,
		Partial,
		Yes,
		NotApplicable
	};

	NOTHROW static TCHAR const * GetAutoApprovedText(AutoApproved const aa);
	static void Enumerate(CEnumCallback & cbEnumCallback);
	static AutoApproved const GetAutoApproved(TCHAR const * const tChIn);
	static TCHAR const * GetDefaultAutoApprovedText();
	static AutoApproved const GetDefaultAutoApproved();
	static bool IsValidAutoApproved(AutoApproved const nIn);
	static bool IsValidAutoApproved(TCHAR const * tChIn);
	
// Construction
private:
	// prevent constructing, copying and assigning
	CLocAutoApproved();
	CLocAutoApproved(CLocAutoApproved const &);
	CLocAutoApproved const & operator=(CLocAutoApproved const &);

// Member Variables
private:
	static TCHAR const * const m_szAutoApprovedNames[];
	static AutoApproved const DefaultValue;
};

typedef CLocAutoApproved CAA;


//------------------------------------------------------------------------------
class LTAPIENTRY CLocTranslationOrigin
{
public:
	enum TranslationOrigin
	{
		Invalid = 0,
		New,
		Uploaded,
		AutoTranslated,
		Copied,
		PreviousVersion,
		NotApplicable
	};

	NOTHROW static const TCHAR * GetOriginText(CLocTranslationOrigin::TranslationOrigin);
	static void Enumerate(CEnumCallback &);
	
private:
	static const TCHAR *const m_szOriginNames[];
	CLocTranslationOrigin();
};

typedef CLocTranslationOrigin CTO;

class LTAPIENTRY COutputTabs
{
public:
	enum OutputTabs
	{
		File,
		Test,
		Messages,
		Update,
		Utility,
		GlobalErrorBox,
		OutputMax
	};

	static void Enumerate(CEnumCallback &);
	
private:
	static const UINT m_nStateNames[];
	COutputTabs();
};



class LTAPIENTRY CValidationCode
{
public:
	enum ValidationCode
	{
		NotHandled,			// for sub-parser use ONLY
		NoError,
		Warning,
		Error
	};

	NOTHROW static ValidationCode UpgradeValue(ValidationCode OldValue,
			ValidationCode NewValue);
	
private:
	CValidationCode();
};

typedef CValidationCode CVC;


//------------------------------------------------------------------------------
class LTAPIENTRY CValidationOptions
{
public:
	CValidationOptions();
	
	enum ValidationOption
	{
		CheckDBCSHotKeyPos = 0,
		CheckDBCSHotKeyChar,
		CheckRemovedHotKey,
		CheckAddedHotKey,
		CheckHotKeyPosition,
		CheckRemovedAccelerator,
		CheckReorderableParams,
		CheckPrintf,
		CheckBlankTarget,
		CheckBlankSource,
		CheckNewLineCount,
		CheckChangedTerminator,
		CheckLeadingPunctuation,
		CheckTrailingPunctuation,
		CheckLeadingSpaces,
		CheckTrailingSpaces,
		CheckTranslationSize,
		CheckNULChanges,
		CheckCharsInCodePage,
		//
		//  Internal value, DO NOT USE
		//
		END_MARKER
	};

	static void Enumerate(CEnumCallback &);
	NOTHROW static void GetText(ValidationOption, CLString &);
	NOTHROW static void GetLongText(ValidationOption vo, CLString &strText);

	NOTHROW void SetFlag(ValidationOption, BOOL);
	NOTHROW BOOL GetFlag(ValidationOption) const;
	NOTHROW const CValidationOptions & operator=(const CValidationOptions &);
	
private:
	DWORD dwFlags;
};

typedef CValidationOptions CVO;


//------------------------------------------------------------------------------
class LTAPIENTRY CAmpKeyword
{
public:
	enum AmpKeyword
	{
		amp = 0,
		lt,
		gt,
	};
	
	static const WCHAR * GetValue(CAmpKeyword::AmpKeyword);
	static unsigned int GetValueLength(CAmpKeyword::AmpKeyword);
	static WCHAR GetEquivalentChar(CAmpKeyword::AmpKeyword);
	static int FindAmpKeyword(const WCHAR * pwszStr, unsigned int nPos);
	
private:
	//
	//  Nobody should actually CONTRUCT one of these.
	//
	CAmpKeyword();

	//
	//  Used to store the info about each element in the enum...
	//
	struct SAmpKeyword
	{
		const WCHAR * m_wszValue;
		WCHAR m_chEquivalentChar;
	};

	static const SAmpKeyword m_aAmpKeywords[];
	static const int m_nNumAmpKeywords;
};

typedef CAmpKeyword CAK;


//------------------------------------------------------------------------------
// CEnumIntoPasStrList provides a method of enumerating directly into a list of
// CPascalString's.
//
// ASSUMPTIONS:
// 1.  Enumerators will send data in proper increasing order
// 2.  No gaps in indicies.
//
class LTAPIENTRY CEnumIntoPasStrList: public CEnumCallback
{
// Construction
public:
	CEnumIntoPasStrList(CPasStringList & lstPasStr, BOOL fLock = TRUE);
	~CEnumIntoPasStrList();

// CEnumCallback implementation
public:
	virtual void SetRange(UINT nStart, UINT nFinish);
	virtual BOOL ProcessEnum(const EnumInfo &);

protected:
	CPasStringList & m_lstPasStr;
	UINT	m_nStart;				// Start of range
	UINT	m_nFinish;				// End of range
	UINT	m_nCurrent;				// Check of current item TO retrieve
	BOOL	m_fLock;				// Lock list when finished
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\locobj.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCOBJ.INL

History:

--*/ 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Mother object constructor.  Does nothing, since for now we rely on
//  AFX CObject to do the work for us.
//  
//-----------------------------------------------------------------------------
inline
CLObject::CLObject()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\locpct.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCPCT.H

History:

--*/

#ifndef LOCUTIL__LocPct_H__INCLUDED
#define LOCUTIL__LocPct_H__INCLUDED

// Classes in this header file
class CLocPercentHelper;
class CLocPercentFrame;

//
// The CLocPercentHelper class can help in building acurate
// percentage complete messages for complicated processes.
//
// Here is how the CLocPercentHelper works.
//
// The CLocPercentHelper class deals with "frames" of work.  Each frame
// is 100% of a unit of work.  A CLocPercentHelper will always
// start off with 1 frame.  If you want to use these functions
// you first need to call PercentSetUnits passing a number that will
// represent 100% complete.  For example if you need to process 4 items
// you could set this to 4.  After you process each item you would
// call PercentAddValue.  Correct status messages would be sent
// indicating you are 1/4, 2/4, 3/4, and 4/4 done.

// This processing comes in handy when you break up the work
// in sub functions, or "frames" of work.  Each function only 
// knows about what it needs to do.  

// Say in the resource example you call a function to handle each
// resource.  Each time the handler is called it is given 1/4 
// of the total time.  The handler can break up its time however 
// it likes without knowing how much total time there is.  

// Say the sub function needs to do 10 things.  It calls PercentSetUnits(10).
// It then calls PercentAddValue as each of the 10 things are
// accomplished.  The total percent will reflect that 100% of this
// sub function is really only 1/4 of the total percent.  The sub function
// only needs to worry about what it knows it has to do.  
// The sub function can assign part of its work to other functions
// by creating frames for them.  There is no limit to the number
// of frames.
// 

// Override the virtual function void OnSendPercentage(UINT nPct) 
// in your subclass of CLocPercentHelper to do what you want
// with the percent calculated from the helper.

// Example:

/*

	CLocPercentHelper pctHelp;
	pctHelp.PercentSetUnits(4); //assume 4 items to process
	
	do
	{
		pctHelp.PercentPushFrame(1); //Set up a new Frame equal
		                             //to 1 of my units of work.
									 //In this case 1/4 of the
									 //total time.
									 
									 //All of the Percent... functions
									 //called made now deal with
									 //this new frame.
		
		HandleItem(pctHelp);
		
		pctHelp.PersentPopFrame();	 //Remove the frame created
		                             //and mark the amount 
									 //of time it was equal to
									 //completed.
									 
	  
	}
	while (more items)
	  
-----------------------------------------------------------------------

  HandleItem(CLocPercentHelper& pctHelp) function
  
	pctHelp.PercentSetUnits(10);  //Assume this is a dialog resource
	                              //with 10 controls.  
								  //This function divides up 
								  //the work it needs to do in
								  //a way that makes sence for it.
								  //
								  //When this "frame" is at 100%
								  //the total percentage is still
								  //just 1/4 of the total time
								  //since this frame was given 1/4
								  //of the total time from the caller.
								  
  
	do
	{
					
		// This function can assign part of its processing 
		// to another function by calling PercentPushFrame also.
		
		HandleControl();
		pctHelp.PercentAddValue();	//Send a message to the 
		                            //handler indicating the 
									//current percentage.
									//The object will calculate
									//the total percent based on 
									//the current stack of frames.
	}
	
	while (more controls)  
		
		  
			
*/



//
// CLocPercentFrame represents a working unit of progress.  
// The progress model implemented with the CLocPercentHelper will
// support unlimited levels of work units.  
//
// This class is a helper class used only by CLocPercentHelper
//


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocPercentFrame : public CObject
{
	friend CLocPercentHelper;

protected:
	CLocPercentFrame();
	CLocPercentFrame(CLocPercentFrame* pParent, UINT nValueInParent);
	
	void SetComplete();
	// Force this frame to represent 100%. 
	
	void AddValue(UINT nValue);
	// Add nValue to the internal value.
	// The internal value will never be greater than
	// the internal units.
	
	void SetValue(UINT nValue);
	// Set the internal value.
	// The internal value will never be greater than
	// the internal units.
	
	void SetUnits(UINT nUnits);
	// Set the internal units
	
	UINT m_nUnits;			     //Number that represents 100%
	UINT m_nValue;          	 //Number that represent how far done
	                             //this frame is.
	
	CLocPercentFrame* m_pParent;	 //Pointer to the parent frame
	UINT m_nValueInParent;       //How much this frame is worth
	                             //in the parents context.
	
	void MemberInit();			 
	// Initialize member values 
};

//
// List of frames in the helper
//

class LTAPIENTRY CLocPercentFrameList : public CTypedPtrList<CPtrList, CLocPercentFrame*>
{
};


class LTAPIENTRY CLocPercentHelper : public CObject
{
public:
	
	CLocPercentHelper();

	virtual ~CLocPercentHelper();
	
	void PercentSetUnits(UINT nUnits, BOOL bReport = FALSE);
	// Set the units of the current frame.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.

	void PercentSetValue(UINT nValue, BOOL bReport = TRUE);
	// Set the value of the current frame.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.

	void PercentAddValue(UINT nValue = 1, BOOL bReport = TRUE);
	// Add nValue to the value of the current frame.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.
	
	void PercentSetComplete(BOOL bReport = TRUE);
	// Set the current frame complete.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.
	
	void PercentForceAllComplete(BOOL bReport = TRUE);
	// Force all frames complete.
	// Calculate and report 100% done through 
	// OnSendPercentage if bReport is TRUE.
	
	void PercentPushFrame(UINT nValueInParent = 1);
	// Create a new frame and assign in nValueInParent 
	// All Percent... calls made after this call deal with
	// the new frame.  
	
	void PercentPopFrame(BOOL bReport = TRUE);
	// Set the current frame complete and add the current
	// frames valueInParent to its parent frame. 
	// The current frames parent is now the current frame.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.
	
	void PercentSetStrict(BOOL bOnOff = TRUE);
	// Strict behavior means the helper will ASSERT (_DEBUG only) if 
	// the calculated percent is over 100%.  This can happen
	// if the unit values assigned to frames are not truly what 
	// the process does.  If you are unable to set acurate
	// unit values and the program quesses, you can turn
	// strict off.
	
	BOOL PercentIsStrict();
	// Return TRUE or FALSE if strict is on.
	
protected:

	// Support for Progress Reporting
	CLocPercentFrame m_FrameMain;	        //The main frame always 
	                                    //present.  This frame
	                                    //will never have a parent.
	
	CLocPercentFrameList m_FrameList;      //List of open frames.
	
	CLocPercentFrame* m_pCurrentFrame;     //Pointer to the current
	                                    //frame
	
	BOOL m_bStrict;						//Strict on will ASSERT if 
										//total % gets over 100
	
	
	void SendPercentage();
	// Calculates the percentage based on the current frame
	// Calles OnSendPercentage with the calulated value.
	
	void SafeDeleteFrame(CLocPercentFrame* pFrame);
	// Safely deletes a frame making sure the pFrame is 
	// not m_FrameMain.
	
	virtual void OnSendPercentage(UINT nPct);
	// Callback function for subclasses to do what they
	// want with the percentage.  Default implementation
	// does nothing.
 	
};

#pragma warning(default: 4275)

//
// Helper class with a CProgressiveObject
//
class LTAPIENTRY CLocPctProgress : public CLocPercentHelper
{
public:
	CLocPctProgress();
	CLocPctProgress(CProgressiveObject* pProgObj);

	void SetProgressiveObject(CProgressiveObject* pProgObj);

protected:
	virtual void OnSendPercentage(UINT nPct);

	CProgressiveObject* m_pProgObj;
};

#endif // LOCUTIL__LocPct_H__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\logfile.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOGFILE.INL

History:

--*/

inline
CLogFile::CLogFile()
{}



inline
CLogFile::~CLogFile()
{}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\logfile.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOGFILE.H

History:

--*/

#ifndef LOCUTIL_LOGFILE_H
#define LOCUTIL_LOGFILE_H


class LTAPIENTRY CLogFile
{
public:
	CLogFile();
	
	virtual void IssueMessage(const CLString &strFileName, const CLString &strItemId,
			const CLString  &strChange, UINT uiChangeId,
			const CLString &strDetails, CGoto *, CGotoHelp *) = 0;
	
	virtual ~CLogFile();
	

private:
	CLogFile(const CLogFile &);
	const CLogFile &operator=(const CLogFile &);
};



CLString LTAPIENTRY GetLogFileName(const TCHAR *szProjectPath,
		const TCHAR *szAddOn, const TCHAR *szExtension);

#include "logfile.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\locstr.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCSTR.INL

History:

--*/

//  Inline functions for the CLocString object.  This file is included by
//  locstr.h, and should never be used directly.
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Return the 'generic' type of the string.  
//  
//-----------------------------------------------------------------------------
inline
CST::StringType
CLocString::GetStringType(void)
		const
{
	if (!m_pasBaseString.IsNull())
	{
		return m_stStringType;
	}
	else
	{
		return CST::None;
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the 'Base' string.  This is the localizable string, 
//  It is the part that weighs most heavily in auto-translation.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocString::GetString(void)
		const
{
	return m_pasBaseString;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the code page type for the string.
//  
//-----------------------------------------------------------------------------
inline
CodePageType
CLocString::GetCodePageType(void)
		const
{
	return m_cptCodePageType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocString::GetNote(void)
		const
{
	return m_pstrNote;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the string type.  The parser and database are the only people who
//  should be setting this.
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetStringType(
		CST::StringType newType)
{ 
	m_stStringType = newType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the 'Base' string.
//
//  This method can throw the following exceptions:
//      CMemoryException
//
//-----------------------------------------------------------------------------
inline
void
CLocString::SetString(
		const CPascalString &pstrNewBaseString)
{
	m_pasBaseString = pstrNewBaseString;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the code page type for the string.
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetCodePageType(
		CodePageType cptNew)
{
	m_cptCodePageType = cptNew;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Clears out the hot-key to an uninitialized state.
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::ClearHotKey(void)
{
	m_wchHotKeyChar = L'\0';
	m_uiHotKeyPos = 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetNote(
		const CPascalString &pstrNote)
{
	m_pstrNote = pstrNote;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  See if the hotkey has any info in it.  Checks to see if the hotkey is
//  a valid character (ie non-zero).
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if it contains a hotkey
CLocString::HasHotKey(void)
		const
{
	return (m_wchHotKeyChar != L'\0');
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the hot-key character.  If the hot-key is not initialized, this
//  returns NUL.
//  
//-----------------------------------------------------------------------------
inline
WCHAR									// Hot key character.
CLocString::GetHotKeyChar(void)
		const
{
	return m_wchHotKeyChar;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the hot-key position.  Interpretationb of the position is left up
//  to the caller.  If the hot-key is uninitialized, this returns 0.
//  
//-----------------------------------------------------------------------------
inline
UINT									// Position of the hot key.
CLocString::GetHotKeyPos(void)
		const
{
	return m_uiHotKeyPos;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the hot-key character
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetHotKeyChar(
		WCHAR wchNewHotKeyChar)			// Character to set as hot key.
{
	m_wchHotKeyChar = wchNewHotKeyChar;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the position of the hot-key
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetHotKeyPos(
		UINT uiNewHotKeyPos)			// Position for the hot-key.
{
	m_uiHotKeyPos = uiNewHotKeyPos;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator for LocStrings.
//  
//-----------------------------------------------------------------------------
inline
const CLocString &
CLocString::operator=(
		const CLocString &lsSource)
{
	CopyLocString(lsSource);

	return *this;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator == version of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int								              // TRUE (1) if equal
CLocString::operator==(
		const CLocString &lsOtherString) // String to compare
		const
{
	return ((((HasHotKey() && lsOtherString.HasHotKey()) &&
			(GetHotKeyChar() == lsOtherString.GetHotKeyChar()) &&
			(GetHotKeyPos() == lsOtherString.GetHotKeyPos())) ||
			(!HasHotKey() && !lsOtherString.HasHotKey())) &&
			m_pasBaseString == lsOtherString.m_pasBaseString);
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator == version of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int								              // TRUE (1) if equal
CLocString::operator!=(
		const CLocString &lsOtherString) // String to compare
		const
{
	return !(operator==(lsOtherString));
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the Translation Object.  Just sets the components to
//  default bad values.
//  
//-----------------------------------------------------------------------------
inline
CLocTranslation::CLocTranslation()
{
	m_lidSource = BAD_LOCALE;
	m_lidTarget = BAD_LOCALE;
	m_uiRanking = 0;
}



//-----------------------------------------------------------------------------
//  
//  Implementation for copying a translation.
//  
//-----------------------------------------------------------------------------
inline
void
CLocTranslation::CopyTranslation(
		const CLocTranslation &Source)
{
	m_lsSource = Source.m_lsSource;
	m_lidSource = Source.m_lidSource;
	m_lsTarget = Source.m_lsTarget;
	m_lidTarget = Source.m_lidTarget;
	m_pstrGlossaryNote = Source.m_pstrGlossaryNote;
	m_uiRanking = Source.m_uiRanking;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Copy constructor for a CLocTranslation
//  
//-----------------------------------------------------------------------------
inline
CLocTranslation::CLocTranslation(
		const CLocTranslation &Source)
{
	CopyTranslation(Source);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets all the required components of a translation.
//  
//-----------------------------------------------------------------------------
inline
void
CLocTranslation::SetTranslation(
		const CLocString &Source,
		LangId lidSource,
		const CLocString &Target,
 		LangId lidTarget)
{
	m_lsSource = Source;
	m_lidSource = lidSource;
	m_lsTarget = Target;
	m_lidTarget = lidTarget;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the glossary note for the translation.
//  
//-----------------------------------------------------------------------------
inline
void
CLocTranslation::SetNote(
		const CPascalString &pstrNote)
{
	m_pstrGlossaryNote = pstrNote;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the translation that takes all the required info.
//  
//-----------------------------------------------------------------------------
inline
CLocTranslation::CLocTranslation(
		const CLocString &Source,
		LangId lidSource,
		const CLocString &Target,
 		LangId lidTarget)
{
	SetTranslation(Source, lidSource, Target, lidTarget);
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator == version of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int 
CLocTranslation::operator==(const CLocTranslation &locTran) const
{
	return (
			GetSourceString() == locTran.GetSourceString()
			&& GetSourceString().GetStringType() 
					== locTran.GetSourceString().GetStringType()
			&& GetTargetString() == locTran.GetTargetString()
			&& GetTargetString().GetStringType() 
					== locTran.GetTargetString().GetStringType()
			&& GetNote() == locTran.GetNote()
			&& GetRanking() == locTran.GetRanking()
		   );
}

inline
int 
CLocTranslation::operator!=(const CLocTranslation &locTran) const
{
	return !(operator==(locTran));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the source string of the translation.
//  
//-----------------------------------------------------------------------------
inline
const CLocString &
CLocTranslation::GetSourceString(void)
		const
{
	return m_lsSource;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the target string for the translation.
//  
//-----------------------------------------------------------------------------
inline
const CLocString &
CLocTranslation::GetTargetString(void)
		const
{
	return m_lsTarget;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the glkossary note for the translation.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocTranslation::GetNote(void)
		const
{
	return m_pstrGlossaryNote;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the translation ranking for the strnslation.  See
//  CalculateRanking().
//  
//-----------------------------------------------------------------------------
inline
UINT
CLocTranslation::GetRanking(void)
		const
{
	return m_uiRanking;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the embedded source language for the translation.
//  
//-----------------------------------------------------------------------------
inline
LangId
CLocTranslation::GetSourceLanguage(void)
		const
{
	return m_lidSource;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the embedded target language for the translation.
//  
//-----------------------------------------------------------------------------
inline
LangId
CLocTranslation::GetTargetLanguage(void)
		const
{
	return m_lidTarget;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Validates the translation.  This make sure that all the needed components
//  of tghe source string exist in some form in the target string.  This
//  simply returns a validation code.
//  
//-----------------------------------------------------------------------------
inline
CVC::ValidationCode
CLocTranslation::ValidateTranslation(
		const CValidationOptions &Options)
		const
{
	CLString str;
	
	return ValidateTranslation(Options, FALSE, str, NULL, NULL);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator for the translation object.
//  
//-----------------------------------------------------------------------------
inline
const CLocTranslation &
CLocTranslation::operator=(
		const CLocTranslation &Source)	// Translation to copy from.
{
	CopyTranslation(Source);
	
	return *this;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Destructor for the translation.  Nothing interesting happens here.
//  
//-----------------------------------------------------------------------------
inline
CLocTranslation::~CLocTranslation()
{
	DEBUGONLY(AssertValid());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\lstime.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LSTIME.H

History:

--*/

VOID
LTAPIENTRY GMTTimeToLocalTime(COleDateTime &);


VOID
LTAPIENTRY LocalTimeToGMTTime(COleDateTime &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\progress.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PROGRESS.INL

History:

--*/

inline
CProgressiveObject::CProgressiveObject()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\report.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    REPORTER.INL

History:

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\operator.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    OPERATOR.H

History:

--*/

#pragma once

typedef UINT Operators;


class LTAPIENTRY CColumnOp
{
public:
	enum Operator
	{
		None   = 0,
		EQ 	   = 0x00000001,
		NOTEQ  = 0x00000002,
		GT     = 0x00000004,
		LT     = 0x00000008,
		LTEQ   = 0x00000010,
		GTEQ   = 0x00000020,
		WITHIN = 0x00000040,
		BEYOND = 0x00000080,

		CONTAINS     = 0x00000100,
		CONTAINSWORD = 0x00000200,
		STARTWITH    = 0x00000400,
		ENDWITH      = 0x00000800,
	};

	typedef CList<Operator, Operator> COperatorList;

	static CLString GetText(Operator);
	static void GetOperators(const Operators, COperatorList &);


private:
	CColumnOp();
};

typedef CColumnOp CCO;

const Operators NoOps = 0;
const Operators NumericOps = CCO::EQ | CCO::NOTEQ | CCO::GT | CCO::LT;
const Operators SimpStrOps = CCO::EQ | CCO::NOTEQ | CCO::STARTWITH | CCO::ENDWITH;
const Operators CompStrOps = CCO::CONTAINS | CCO::CONTAINSWORD;
const Operators StringOps  = SimpStrOps | CompStrOps;
const Operators StrListOps = CCO::EQ | CCO::NOTEQ;
const Operators DateOps    = CCO::LT | CCO::GT | CCO::EQ | CCO::NOTEQ | CCO::WITHIN | CCO::BEYOND;
const Operators BooleanOps = CCO::EQ | CCO::NOTEQ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\product.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PRODUCT.H

History:

--*/
#pragma once


struct ESP_USER_SETUP_DATA
{
	CLString strName;
	CLString strCompany;
};


BOOL LTAPIENTRY GetEspressoVersion(CLString& strVersion);

BOOL LTAPIENTRY GetEspressoFileVersion(const CLString& strFile, 
	CLString& strVersion);

BOOL LTAPIENTRY GetEspressoFileCopyright(const CLString& strFile, 
	CLString& strCopyright);

BOOL LTAPIENTRY GetSetupUserInfo(ESP_USER_SETUP_DATA& userData);

void LTAPIENTRY GetApplicationDirectory(CLString &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\progress.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PROGRESS.H

History:

--*/
#ifndef _ESPUTIL_PROGRESS
#define _ESPUTIL_PROGRESS


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CProgressiveObject : virtual public CObject
{
public:
	CProgressiveObject();

	void AssertValid(void) const;
	
	virtual void SetProgressIndicator(UINT uiPercentage) = 0;
	virtual void SetDescription(HINSTANCE, DWORD);

	~CProgressiveObject();

	virtual void SetCurrentTask(CLString const & strTask) = 0;
	virtual void SetDescriptionString(CLString const & strDescription) = 0;
	
private:
	//
	// Private so nobody will use them...
	//
	CProgressiveObject(const CProgressiveObject &);
	const CProgressiveObject &operator=(const CProgressiveObject &);
};

#pragma warning(default: 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "progress.inl"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\locstr.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCSTR.H

History:

--*/

//  Definition of a localizable string.  The following classes are defined:
//      CLocString - all the operations we can do on a localizable string.
 

#ifndef LOCSTR_H
#define LOCSTR_H


interface ILocStringValidation;

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocString : public CObject
{
public:
	NOTHROW CLocString();

	void AssertValid(void) const;
	
	//
	//  Information about the localizable string...
	//
	NOTHROW BOOL HasHotKey(void) const;
	NOTHROW WCHAR GetHotKeyChar(void) const;
	NOTHROW UINT GetHotKeyPos(void) const;
	NOTHROW const CPascalString & GetNote(void) const;
	NOTHROW const CPascalString & GetString(void) const;
	
	NOTHROW int operator==(const CLocString &) const;
	NOTHROW int operator!=(const CLocString &) const;
	//
	//  Some useful assigment operators.
	//
 	NOTHROW void SetString(const CPascalString&);
	NOTHROW void SetHotKeyChar(WCHAR);
	NOTHROW void SetHotKeyPos(UINT);
	NOTHROW void ClearHotKey(void);
	NOTHROW void SetNote(const CPascalString &);
	
	// Conversion from/to Windows hot key strings
	// This is also the format used to display strings in edit mode
	NOTHROW int ParseString(const CPascalString & pasStr, WORD langId);
	NOTHROW void ComposeString(CPascalString & pasStr, WORD langId) const;


	NOTHROW CST::StringType GetStringType(void) const;
	NOTHROW CodePageType GetCodePageType(void) const;
	NOTHROW void SetStringType(CST::StringType);
	NOTHROW void SetCodePageType(CodePageType);


	// Conversion from/to displayable string in the resource table.
	void GetDisplayLString(CLString &strDest, LangId langId);
	void GetDisplayPString(CPascalString &strDest, LangId langId, BOOL bReplaceMetaCharacters);
	void GetEditableString(CLString &strDest, LangId langId);
	int ParseEditableString(const CLString &strSrc, LangId langId, CString &strErr);
	int ParseEscapeChar(BOOL bSetHotkeyPos, CPascalString &strErr);
	int ParseAmpersand(LangId langId,BOOL bSetHotkeyPos,CPascalString &strErr);
	
	NOTHROW const CLocString& operator=(const CLocString&);
	
	NOTHROW ~CLocString();

protected:

private:

	//
	//  Private implementation functions.
	//
	NOTHROW void CopyLocString(const CLocString &);
	virtual void Serialize(CArchive &) {}
	
	//
	//  Prevents the default copy constructor from being called.
	//
	CLocString(const CLocString&);

	CPascalString m_pasBaseString;
	CST::StringType m_stStringType;
	WCHAR m_wchHotKeyChar;
	UINT m_uiHotKeyPos;
	CodePageType m_cptCodePageType;		 //  cpAnsi
	CPascalString m_pstrNote;
};



class LTAPIENTRY CLocTranslation : public CObject
{
public:
	CLocTranslation();
	CLocTranslation(const CLocTranslation &);
	CLocTranslation(const CLocString &Source, LangId lidSource,
			const CLocString &Target, LangId lidTarget);

	NOTHROW int operator==(const CLocTranslation &) const;
	NOTHROW int operator!=(const CLocTranslation &) const;

	void AssertValid(void) const;

	NOTHROW void SetTranslation(const CLocString &Source, LangId lidSource,
			const CLocString &Target, LangId lidTarget);
	NOTHROW void SetNote(const CPascalString &);
	NOTHROW void CalculateRanking(const CLocString &);
	
	NOTHROW const CLocString & GetSourceString(void) const;
	NOTHROW const CLocString & GetTargetString(void) const;
	NOTHROW const CPascalString & GetNote(void) const;
	NOTHROW UINT GetRanking(void) const;
	NOTHROW LangId GetSourceLanguage(void) const;
	NOTHROW LangId GetTargetLanguage(void) const;
	
	NOTHROW CVC::ValidationCode ValidateTranslation(
			const CValidationOptions &) const;

	NOTHROW CVC::ValidationCode ValidateTranslation(
			const CValidationOptions &, BOOL,
			const CLString &, CReport *, CGoto *) const;
	
	NOTHROW const CLocTranslation & operator=(const CLocTranslation &);
	
	~CLocTranslation();

private:
	NOTHROW void CopyTranslation(const CLocTranslation &);

	NOTHROW void ReordBuildSig(const CLocString &, CPascalString *) const;
	NOTHROW void PrintfBuildSig(const CLocString &, CPascalString &) const;
	NOTHROW int ReplaceableLength(const CPascalString &, UINT) const;
	
	CLocString      m_lsSource;
	LangId          m_lidSource;
	CLocString      m_lsTarget;
	LangId          m_lidTarget;
	CPascalString   m_pstrGlossaryNote;
	UINT            m_uiRanking;
};

#pragma warning(default: 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locstr.inl"
#endif


#endif //LOCSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\passtrmerge.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PASSTRMERGE.H

History:

--*/

// Declaration of a class which handles the merge of two Pascal strings.
//
 
#ifndef LOCUTIL_PasStrMerge_h_INCLUDED
#define LOCUTIL_PasStrMerge_h_INCLUDED


class LTAPIENTRY CPascalStringMerge
{
public:
	static BOOL NOTHROW Merge(CPascalString &, const CPascalString &);

	static BOOL NOTHROW Merge(CPascalString & pasDestination,
			CPascalString const & pasSource, UINT const nMaxLength,
			CReport * const pReport, CLString const & strContext,
			CGoto * const pGoto = NULL);

private:
	static BOOL NOTHROW IsParagraph(const CPascalString &, const CPascalString &);

};


#endif	// #ifndef LOCUTIL_PasStrMerge_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\showwarnings.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    SHOWWARNINGS.H

History:

--*/
#if !defined(PKGUTIL__ShowWarnings_h__INCLUDED)
#define PKGUTIL__ShowWarnings_h__INCLUDED

enum eWarningFilter
{
	wfNote,
	wfWarning,
	wfError,
	wfAbort,
	wfAll
};


int LTAPIENTRY ShowWarnings(const CBufferReport * pBufMsg, LPCTSTR pszTitle = NULL,
		eWarningFilter wf = wfWarning, BOOL fShowContext = FALSE, UINT nMsgBoxFlags = MB_OK);

#endif // PKGUTIL__ShowWarnings_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\resource.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    RESOURCE.H

History:

--*/
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LocUtil.rc
//
#define IDD_CANCELABLE                  12600
#define IDC_CANCEL_CURRENT              12601
#define IDC_TASK                        12602
#define IDD_PROGRESS                    12603
#define IDC_CANCEL_DESCRIPTION          12603
#define IDC_PROGDLG_PROGRESS            12604
#define IDC_OPERATION                   12606
#define IDC_PROGRESS                    12607
#define IDD_WARNINGS                    12608
#define IDC_CHK_EXCL                    12608
#define IDC_WARNINGS_EDT                12609
#define IDD_OPEN_EXCL                   12610
#define IDS_SETTINGS_INDENT             12700
#define IDS_SETTINGS_SEP                12701
#define IDS_SETTINGS_CTX                12702
#define IDS_SETTINGS_DEFAULT            12703
#define IDS_SETTINGS_USER               12704
#define IDS_SETTINGS_OVERRIDE           12705
#define IDS_TRUNCATED_TO_FIT            12706
#define IDS_AMPERSAND_NOT_ALONE         12707
#define IDS_CANT_HAVE_2HOTKEY           12708
#define IDS_AMPERSAND_NO_BLANK          12709
#define IDS_INVALID_HOTKEY_CHAR         12710
#define IDS_OUTTAB_FILE                 12712
#define IDS_OUTTAB_TEST                 12713
#define IDS_OUTTAB_GBOX                 12714
#define IDS_OUTTAB_LOCK                 12715
#define IDS_OUTTAB_UPDATE               12716
#define IDS_OUTTAB_MESSAGES             12717
#define IDS_VAL_BLANK_TARGET            12718
#define IDS_VAL_BLANK_SOURCE            12719
#define IDS_VAL_REMOVE_HK               12720
#define IDS_VAL_ADDED_HK                12721
#define IDS_VAL_LINE_COUNT              12722
#define IDS_VAL_REMOVE_ACCEL            12723
#define IDS_VAL_CHANGED_TERMINATOR      12724
#define IDS_VAL_LEADING_WHITESPACE      12725
#define IDS_VAL_LEADING_PUNCTUATION     12726
#define IDS_VAL_TRAILING_WHITESPACE     12727
#define IDS_VAL_TRAILING_PUNCTUATION    12728
#define IDS_VAL_TRANSLATION_SIZE        12729
#define IDS_VAL_HOTKEY_POSITION         12730
#define IDS_VAL_DBCS_POS                12731
#define IDS_VAL_DBCS_CHAR               12732
#define IDS_VAL_BLANK_TARGET_LONG       12733
#define IDS_VAL_BLANK_SOURCE_LONG       12734
#define IDS_VAL_REMOVE_HK_LONG          12735
#define IDS_VAL_ADDED_HK_LONG           12736
#define IDS_VAL_LINE_COUNT_LONG         12737
#define IDS_VAL_REMOVE_ACCEL_LONG       12738
#define IDS_VAL_CHANGED_TERMINATOR_LONG 12739
#define IDS_VAL_LEADING_WHITESPACE_LONG 12740
#define IDS_VAL_LEADING_PUNCTUATION_LONG 12741
#define IDS_VAL_TRAILING_WHITESPACE_LONG 12742
#define IDS_VAL_TRAILING_PUNCTUATION_LONG 12743
#define IDS_VAL_TRANSLATION_SIZE_LONG   12744
#define IDS_VAL_HOTKEY_POSITION_LONG    12745
#define IDS_VAL_DBCS_POS_LONG           12746
#define IDS_VAL_DBCS_CHAR_LONG          12747
#define IDS_VAL_REORDERABLE             12748
#define IDS_VAL_PRINTF                  12749
#define IDS_VAL_REORDERABLE_LONG        12750
#define IDS_VAL_PRINTF_LONG             12751
#define IDS_VAL_CHECK_NUL               12752
#define IDS_VAL_CHECK_NUL_LONG          12753
#define IDS_VAL_CHECK_CHARS_IN_CP       12754
#define IDS_VAL_CHECK_CHARS_IN_CP_LONG  12755
#define IDS_NOTE                        12756
#define IDS_WARNING                     12757
#define IDS_ERROR                       12758
#define IDS_ABORT                       12759
#define IDS_TOO_MANY_FILES_SELECTED     12760
#define IDS_TRUE                        12761
#define IDS_FALSE                       12762
#define IDS_OUTTAB_UTILITY              12763
#define IDS_EQ                          12764
#define IDS_NOTEQ                       12765
#define IDS_GT                          12766
#define IDS_LT                          12767
#define IDS_LTEQ                        12768
#define IDS_GTEQ                        12769
#define IDS_WITHIN                      12770
#define IDS_BEYOND                      12771
#define IDS_CONTAINS                    12772
#define IDS_EXTENSIONS                  12773
#define IDS_EXTENSIONS_HELP             12774
#define IDS_CONTAINSWORD                12775
#define IDS_CANCEL                      12776
#define IDS_STOP                        12777
#define IDS_STARTWITH                   12778
#define IDS_ENDWITH                     12779

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        12611
#define _APS_NEXT_COMMAND_VALUE         12600
#define _APS_NEXT_CONTROL_VALUE         12609
#define _APS_NEXT_SYMED_VALUE           12602
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\stdafx.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STDAFX.H

History:

--*/
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__9BCC8577_DEA0_11D0_A709_00C04FC2C6D8__INCLUDED_)
#define AFX_STDAFX_H__9BCC8577_DEA0_11D0_A709_00C04FC2C6D8__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#include <afxtempl.h>
#include <afxole.h>

#include <mitutil.h>
#include <MitTL.h>

// Import TypeLibs before header files
#include <MitWarning.h>				// MIT Template Library warnings
#pragma warning(ZCOM_WARNING_DISABLE)
#import <TypeLibs\MitDC.tlb> named_guids, raw_method_prefix("raw_")
#pragma warning(ZCOM_WARNING_DEFAULT)

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9BCC8577_DEA0_11D0_A709_00C04FC2C6D8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\schema.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    SCHEMA.H

History:

--*/
#if !defined(LOCUTIL_Schema_h_INCLUDED)
#define LOCUTIL_Schema_h_INCLUDED

#pragma once

namespace MitDisplayColumns
{
	interface IManager;
	interface IOption;
};

class CColDefList;

//------------------------------------------------------------------------------
class LTAPIENTRY SchemaId : public _GUID
{
public:
	SchemaId();
	SchemaId(const _GUID &);
	
	void Load(CArchive &);
	void Store(CArchive &) const;
	void Serialize(CArchive &);

	const SchemaId & operator=(const SchemaId &);
	const SchemaId & operator=(const _GUID &);
	
	INT operator==(const SchemaId &);
	INT operator!=(const SchemaId &);

private:
	BOOL Compare(const SchemaId &);
};


//------------------------------------------------------------------------------
class LTAPIENTRY CTableSchema : public CRefCount
{
// Construction
public:
	CTableSchema(const SchemaId &, const CLString &, const CColDefList &);
	
// Data
protected:
	SchemaId	m_Schema;
	CLString	m_strDescription;
	CColDefList	m_lstColDefs;

// Attributes
public:
	const SchemaId & GetSchemaId() const;
	const CLString & GetDescription() const;
	const CColDefList & GetColDefList() const;

	int GetDisplayColumnCount() const;

// Operations
public:
	const CColumnDefinition * GetColumnDefinition(long nSearchID) const;
	const CColumnDefinition * GetColumnDefinition(const CLString & stSearchID) const;

// Debugging
#ifdef _DEBUG
	void AssertValid() const;
#endif
};


//------------------------------------------------------------------------------
struct LTAPIENTRY DcsHelp
{
	static void
			BuildDCOption(CTableSchema const * const pSchema, _bstr_t bstrID, 
			MitDisplayColumns::IManager * const pManager, 
			MitDisplayColumns::IOption ** ppOption = NULL);

	static void 
			BuildDCOption(CTableSchema const * const pSchema, _bstr_t bstrID, _bstr_t bstrName, 
			MitDisplayColumns::IManager * const pManager, long rgID[], int cIDs,
			MitDisplayColumns::IOption ** ppOption = NULL);
};


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "schema.inl"
#endif

#endif // LOCUTIL_Schema_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\warndlg.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    WARNDLG.H

History:

--*/

#if !defined(LOCUTIL__WarnDlg_h__INCLUDED)
#define LOCUTIL__WarnDlg_h__INCLUDED

//------------------------------------------------------------------------------
class CWarningsDlg : public CDialog
{
// Construction
public:
	CWarningsDlg(const CBufferReport * pBufMsg, LPCTSTR pszTitle = NULL, 
			eWarningFilter wf = wfWarning, BOOL fShowContext = FALSE, 
			UINT nMsgBoxFlags = MB_OK, CWnd* pParent = NULL);

// Dialog Data
	//{{AFX_DATA(CWarningsDlg)
	enum { IDD = IDD_WARNINGS };
	CButton	m_btnYes;
	CButton	m_btnCancel;
	CButton	m_btnNo;
	CButton	m_btnOK;
	//}}AFX_DATA

// Data
protected:
	const CBufferReport *	m_pBufMsg;
	CLString				m_stTitle;
	eWarningFilter			m_wf;
	BOOL					m_fShowContext;
	UINT					m_nMsgBoxFlags;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWarningsDlg)
	public:
	virtual int DoModal();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void AddString(CEdit * pebc, const CLString & stAdd, int & len);

	// Generated message map functions
	//{{AFX_MSG(CWarningsDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnYes();
	afx_msg void OnNo();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif  // LOCUTIL__WarnDlg_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\report.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    REPORT.H

History:

--*/

//  
//  Mechanism for reporting messages and such to people.
//  

enum MessageSeverity
{
	esNote,
	esWarning,
	esError,
	esAbort
};

//
//  Basic output mechanism for Espresso 2.x.  Allows the caller to uniformly
//  report messages of various severities to the user without worrying about
//  the exact implementation or destination.
//
//  We provide ways of outputting strings, or for loading messages from string
//  tables and outputting those.
//
//  The confidence level allow the caller to tell the Reporter that messages
//  will actually provide meaningful information.  This is used (in particular)
//  in the parsers when a file has not yet ever been parsed.
//
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CReport  // : virtual public CObject
{
public:
	CReport();

	virtual void AssertValid(void) const;

	virtual void Activate(void);
	virtual void Clear(void);

	enum ConfidenceLevel
	{
		Low,
		High
	};
	
	virtual void SetConfidenceLevel(ConfidenceLevel);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL) = 0;
	
	NOTHROW static const CLString & GetErrorCodeText(MessageSeverity ms);
	
	virtual ~CReport();

private:
	//
	//  Prevent usage of copy constructor or assignment operator.
	//
	CReport(const CReport &);
	const CReport &operator=(const CReport &);

	//
	//  Text for MessageSeverities.
	//
	static CLString strSeverities[4];
	friend void GlobalInitStrings(void);
};

#pragma warning(default: 4275)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\schema.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    SCHEMA.INL

History:

--*/ 


inline
SchemaId::SchemaId()
	: _GUID(GUID_NULL)
{}

	

inline
SchemaId::SchemaId(
		const _GUID &guid)
	: _GUID(guid)
{}



inline
void
SchemaId::Load(
		CArchive &ar)
{
	if (ar.Read((_GUID *) this, sizeof(_GUID)) != sizeof(_GUID))
	{
		AfxThrowArchiveException(CArchiveException::endOfFile);
	}
}



inline
void
SchemaId::Store(
		CArchive &ar)
		const
{
	ar.Write((_GUID *) this, sizeof(_GUID));
}




inline
void
SchemaId::Serialize(
		CArchive &ar)
{
	if (ar.IsStoring())
	{
		Store(ar);
	}
	else
	{
		Load(ar);
	}
}



inline
const SchemaId &
SchemaId::operator=(
		const SchemaId &other)
{
	return operator=((_GUID &)other);
}



inline
const SchemaId &
SchemaId::operator=(
		const _GUID &other)
{
	(_GUID &)(*this) = other;

	return *this;
}



inline
int
SchemaId::operator==(
		const SchemaId &other)
{
	return Compare(other);
}



inline
int
SchemaId::operator!=(
		const SchemaId &other)
{
	return !Compare(other);
}



inline
BOOL
SchemaId::Compare(
		const SchemaId &other)
{
	return ((_GUID &)*this) == ((_GUID &)other);
}



inline
const SchemaId & 
CTableSchema::GetSchemaId() const
{
	return m_Schema;
}


inline
const CLString & 
CTableSchema::GetDescription() const
{
	return m_strDescription;
}


inline
const CColDefList & 
CTableSchema::GetColDefList() const
{
	return m_lstColDefs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\stringhelp.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STRINGHELP.H

History:

--*/
#if !defined(LOCUTIL__StringHelp_h__INCLUDED)
#define LOCUTIL__StringHelp_h__INCLUDED

//------------------------------------------------------------------------------
class LTAPIENTRY CStringHelp
{
// Enums
public:
	enum Mode
	{
		mDisplay,	// Use display-mode logic
		mEdit		// Use edit-mode logic
	};

// Construction
public:
	CStringHelp(Mode mode, CReport * pReport);

// Data
protected:
	Mode		m_mode;
	CReport *	m_pReport;
	int			m_cErrors;
	CLString	m_stContext;

	BOOL			m_fFirstErrorSet;
	CWnd const *	m_pwndError;		// Optional window of first error
	int				m_idxError;			// Optional index of first error

// Attributes
public:
	int GetErrorCount();
	void ResetErrorCount();
	const CLString & GetContext();
	void SetContext(const CLString & stContext);

	BOOL GetFirstError(CWnd const * & pwnd, int & idxError);

// Operations
public:
	void LoadString(const CPascalString & pasSrc, CLString & stDest);
	void LoadString(_bstr_t bstrSrc, CLString & stDest);
	void LoadString(const CPascalString & pasSrc, CEdit * pebc);
	void LoadString(_bstr_t bstrSrc, CEdit * pebc);

	BOOL SaveString(const CLString & stSrc, CPascalString & pasDest);
	BOOL SaveString(const CLString & stSrc, _bstr_t & bstrDest);
	BOOL SaveString(CEdit const * const pebc, CPascalString & pasDest);
	BOOL SaveString(CEdit const * const pebc, _bstr_t & bstrDest);

// Implementation
protected:
	void SetError(CWnd const * pwnd, int idxError);

	BOOL SaveString(const CLString & stSrc, CPascalString & pasDest, CWnd const * pwnd);
	BOOL SaveString(const CLString & stSrc, _bstr_t & bstrDest, CWnd const * pwnd);
};

#endif // LOCUTIL__StringHelp_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_interface.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _INTERFACE.H

History:

--*/
 
#pragma once
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_cancel.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _CANCEL.INL

History:

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_extension.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _EXTENSION.H

History:

--*/

#pragma once

typedef UUID ExtensionID;
typedef UUID OperationID;

struct LTAPIENTRY LOCEXTENSIONMENU
{
	LOCEXTENSIONMENU();
	
	CLString strMenuName;				// Name of the Menu
	IID      iidProcess;				// IID for the process interface the
										// menu requires
	OperationID    idOp;				// Allows a single DLL to implement
};

typedef CArray<LOCEXTENSIONMENU, LOCEXTENSIONMENU &> CLocMenuArray;


DECLARE_INTERFACE_(ILocExtension, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;


	//
	//  ILocExtension methods
	//

	//
	//  In Initialize, extension will...
	//   Add any menus it needs to the array of menu obejcts
	//   Register any options it has with Espresso
	//   Ignore the IUnknown for now.
	STDMETHOD(Initialize)(IUnknown *) PURE;

	//
	//  Since extensions may have state, we can't use QueryInterface.
	//  This method has similar semantics, except that in most cases
	//  we expect to get a new objects.  Also, QI on a returned
	//  object doesn't have to support ILocExtension.
	STDMETHOD(GetExtension)(const OperationID &, LPVOID FAR*ppvObj) PURE;
	
	//
	//  In UnInitialize the extension will...
	//   UnRegister any of its options.
	STDMETHOD(UnInitialize)(void) PURE;
};

struct __declspec(uuid("{9F9D180E-6F38-11d0-98FD-00C04FC2C6D8}"))
		ILocExtension;

LTAPIENTRY void UUIDToString(const UUID &, CLString &);

LTAPIENTRY void RegisterExtension(const ExtensionID &,
		const TCHAR *szDescription, HINSTANCE,
		const CLocMenuArray &);
LTAPIENTRY void UnRegisterExtension(const ExtensionID &);

LTAPIENTRY BOOL RegisterExtensionOptions(CLocUIOptionSet *);
LTAPIENTRY void UnRegisterExtensionOptions(const TCHAR *szName);


//
//  Extensions need to export the following function:
//  STDAPI GetExtension(ILocExtension *&);
typedef HRESULT (STDAPICALLTYPE *PFNExtensionEntryPoint)(ILocExtension *&);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_espopts.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _ESPOPTS.H

History:

--*/

#if !defined(LOCUTIL__espopts_h_INCLUDED)
#define LOCUTIL__espopts_h_INCLUDED

LTAPIENTRY BOOL RegisterOptions(CLocUIOptionSet *);
LTAPIENTRY void UnRegisterOptions(const TCHAR *szName);
LTAPIENTRY BOOL GetOptionValue(const TCHAR *szName, CLocOptionVal *&);
LTAPIENTRY BOOL GetGroupName(const TCHAR * szName, CLString & strGroup);
LTAPIENTRY BOOL SetOptionDefault(const TCHAR *szName, const CLocVariant &);

LTAPIENTRY const CLocUIOptionSetList &  GetOptions(void);

LTAPIENTRY CLocOptionValStore *  GetOptionStore(CLocUIOption::StorageType);
LTAPIENTRY void SetOptionStore(CLocUIOption::StorageType, CLocOptionValStore *);
LTAPIENTRY void UpdateOptionValues(void);

LTAPIENTRY void SummarizeOptions(CReport *);


#pragma warning(disable : 4251) // class 'foo' needs to have dll-interface 
								// to be used by clients of class 'bar' 

class LTAPIENTRY CLocOptionManager
{
public:
	const CLocUIOptionSetList &GetOptions(void);

	CLocOptionValStore *GetOptionStore(CLocUIOption::StorageType);
	void SetOptionStore(CLocUIOption::StorageType, CLocOptionValStore *);
	BOOL RegisterOptions(CLocUIOptionSet *);
	void UnRegisterOptions(const TCHAR *szOptSetName);

	BOOL GetOptionValue(const TCHAR *szName, CLocOptionVal *&);
	BOOL GetOptionValue(const TCHAR *szGroupName, const TCHAR *szName,
			CLocOptionVal *&);
	
	void UpdateOptionValues(void);
	void SummarizeOptionValues(CReport *pReport);
	
	BOOL SetOptionDefault(const TCHAR *szName, const
			CLocVariant &varValue);
	void UpdateCurrentValue(CLocUIOption *pOption);
	BOOL GetGroupName(const TCHAR* szName, CLString& strGroup);	
protected:
	void NotifyAll(void);
	void GetCurrentValue(CLocUIOption *, CLocOptionVal *&);
	void DumpOptionSet(CLocUIOptionSet *, UINT, CReport *);
	
private:
	CLocUIOptionSetList m_osOptSetList;
	SmartRef<CLocOptionValStore> m_spUserStore;
	SmartRef<CLocOptionValStore> m_spOverrideStore;
};

#pragma warning(default : 4251)

#endif // LOCUTIL__espopts_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_errorrep.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _ERRORREP.H

History:

--*/

#if !defined(LOCUTIL__errorrep_h_INCLUDED)
#define LOCUTIL__errorrep_h_INCLUDED

////////////////////// the new global issuemessage functions.

UINT LTAPIENTRY EspMessageBox(const CLString strMessage, UINT uiType = MB_OK,
		UINT uiDefault=IDOK, UINT uiHelpContext=0);
UINT LTAPIENTRY EspMessageBox(HINSTANCE hResourceDll, UINT uiStringId,
		UINT uiType=MB_OK, UINT uiDefault=IDOK, UINT uiHelp = 0);

class CReport;

void LTAPIENTRY SetErrorReport(CReport *, BOOL fBatchMode);
void LTAPIENTRY GetErrorReport(CReport *&, BOOL &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_errorrep.inl"
#endif

#endif // LOCUTIL__errorrep_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_errorrep.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _ERRORREP.INL

History:

--*/
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
UINT
EspMessageBox(
		HINSTANCE hResourceDll,
		UINT uiStringId,
		UINT uiType,
		UINT uiDefault,
		UINT uiHelp)
{
	CLString strMessage;

	strMessage.LoadString(hResourceDll, uiStringId);
	return EspMessageBox(strMessage, uiType, uiDefault, uiHelp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_cancel.h ===
//-----------------------------------------------------------------------------
//
// File: _cancel.h
// Copyright (C) 1994-1998 Microsoft Corporation
// All rights reserved.
//
//-----------------------------------------------------------------------------

#ifndef ESPUTIL__CANCEL_H
#define ESPUTIL__CANCEL_H

#pragma once

#pragma warning(disable:4275 4251)

class CCancelDialog;

class LTAPIENTRY CCancelDisplay : public CCancelableObject
{
public:
	CCancelDisplay(CWnd *pParent = NULL);

	//
	//  CCancelableObject methods.
	virtual BOOL fCancel(void) const;

	virtual void SetDescriptionString(const CLString &);
	virtual void SetCurrentTask(const CLString &);

	//
	//  CProgressiveObject methods.
	virtual void SetProgressIndicator(UINT uiPercentage);

	~CCancelDisplay();

	void SetDelay(clock_t);

	enum CancelButtonText { nCancel, nStop, COUNT_OF_ENUM };
	void SetCancelButtonText(CancelButtonText const nCancelButtonText);

	void DisplayDialog(BOOL);

protected:
	friend CCancelDialog;
	void SetCancel(BOOL);
	void ChangeCancelButtonText();

private:
	BOOL m_fCancel;
	CCancelDialog *m_pCancelDialog;
	CLString m_strDescription;
	CLString m_strTask;
	UINT m_uiLastPercentage;
	clock_t m_ctLastTime;
	clock_t m_ctDisplayTime;
	CancelButtonText m_nCancelButtonText;
	BOOL m_fDisplay;
	BOOL	m_fWaitCursor;
	SmartPtr<CInputBlocker>	m_spBlocker;

	CWnd *m_pParent;
};


#pragma warning(default:4275 4251)


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_cancel.inl"
#endif

#endif // ESPUTIL__CANCEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_locenum.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _LOCENUM.H

History:

--*/

#if !defined(LOCUTIL__locenum_h_INCLUDED)
#define LOCUTIL__locenum_h_INCLUDED
 
//
//  This class is used in UI. SetSel() is used to set the initial
//	selection in the combo box
//
class LTAPIENTRY CEnumIntoComboBox: public CEnumCallback
{
public:
	CEnumIntoComboBox(CComboBox *pLB=NULL, DWORD val=0, BOOL bAbbrev=FALSE);
	void SetSel(DWORD val);
	virtual BOOL ProcessEnum(const EnumInfo &);

protected:
	CComboBox	*m_pLB;
	BOOL		m_bAbbrev;
	DWORD		m_dwVal;
};

class LTAPIENTRY CEnumIntoListBox: public CEnumCallback
{
public:
	CEnumIntoListBox(CListBox *pLB=NULL, 
				DWORD val=0, BOOL bAbbrev=FALSE, LPCTSTR lpszPrefix=NULL);
	void SetSel(DWORD val);
	virtual BOOL ProcessEnum(const EnumInfo &);

protected:
	CListBox	*m_pLB;
	BOOL		m_bAbbrev;
	DWORD		m_dwVal;
	LPCTSTR		m_lpszPrefix;
};


class LTAPIENTRY CWEnumIntoComboBox: public CWEnumCallback
{
public:
	CWEnumIntoComboBox(CComboBox *pLB=NULL, BOOL bForEdit = TRUE, DWORD val=0, BOOL bAbbrev=FALSE);
	void SetSel(DWORD val);
	virtual BOOL ProcessEnum(const WEnumInfo &);

protected:
	CComboBox	*m_pLB;
	BOOL		m_bAbbrev;
	DWORD		m_dwVal;
	BOOL		m_bForEdit;   // If this flag is true, the strings in the Combo box are displayed in Editing mode
};


class LTAPIENTRY CWEnumIntoListBox: public CWEnumCallback
{
public:
	CWEnumIntoListBox(CListBox *pLB=NULL, 
				BOOL bForEdit = TRUE, DWORD val=0, BOOL bAbbrev=FALSE, LPCTSTR lpszPrefix=NULL);
	void SetSel(DWORD val);
	virtual BOOL ProcessEnum(const WEnumInfo &);

protected:
	CListBox	*m_pLB;
	BOOL		m_bAbbrev;
	DWORD		m_dwVal;
	LPCTSTR		m_lpszPrefix;
	BOOL		m_bForEdit;		// If this flag is true, the strings in the Listbox are displayed in Editing mode
};

#endif  // LOCUTIL__locenum_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_progress.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _PROGRESS.H

History:

--*/

#ifndef ESPUTIL__PROGRESS_H
#define ESPUTIL__PROGRESS_H

class CProgressDialog;
class CInputBlocker;

#pragma warning(disable:4251)

class LTAPIENTRY CProgressDisplay : public CProgressiveObject
{
public:
	CProgressDisplay(CWnd *pParent = NULL);

	void SetDelay(clock_t);
	void DisplayDialog(BOOL);

	void SetProgressIndicator(UINT uiPercentage);

	void SetTitle(const CLString &);
	void SetTitle(HINSTANCE, DWORD);
	~CProgressDisplay();

	virtual void SetCurrentTask(CLString const & strTask);
	virtual void SetDescriptionString(CLString const & strDescription);

private:
	CProgressDialog *m_pDialog;
	UINT m_uiLastPercentage;
	clock_t m_ctLastTime;
	clock_t         m_ctDisplayTime;
	BOOL	m_fDisplay;
	BOOL	m_fWaitCursor;
	SmartPtr<CInputBlocker>	m_spBlocker;

	CLString m_strTitle;
	CLString m_strDescription;

	CWnd *m_pParent;
};

#pragma warning(default:4251)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_pumpidle.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _PUMPIDLE.H

History:

--*/

#ifndef ESPUTIL__PUMPIDLE_H
#define ESPUTIL__PUMPIDLE_H


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CPumpAndIdle : public CObject
{
public:
	CPumpAndIdle(BOOL fDelete);
	
	virtual BOOL PumpAndIdle(long lCount) = 0;

	void Delete(void);
	
private:
	CPumpAndIdle();
	CPumpAndIdle(const CPumpAndIdle &);
	void operator=(const CPumpAndIdle &);

	BOOL m_fDelete;
};

#pragma warning(default: 4275)

class LTAPIENTRY CTimerPump : public CPumpAndIdle
{
public:
	CTimerPump(BOOL fDelete, UINT uiSeconds);

	BOOL PumpAndIdle(long lCount);

	virtual void OnTimeout(void)  = 0;
	
private:
	UINT m_uiTimeout;
	clock_t m_tLastRun;
};



void LTAPIENTRY NOTHROW AddPumpClass(CPumpAndIdle *);
BOOL LTAPIENTRY NOTHROW RemovePumpClass(CPumpAndIdle *);

BOOL LTAPIENTRY PumpAndIdle(long lCount);
void LTAPIENTRY PumpAndIdle(void);

class CProgressDialog;

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CInputBlocker : public CObject
{
public:
	CInputBlocker(CWnd* pParent = NULL);

	~CInputBlocker();

private:
	CInputBlocker(const CInputBlocker &);
	void operator=(const CInputBlocker &);

	CProgressDialog *pDlg;
	
};

#pragma warning(default: 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_report.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _REPORT.INL

History:

--*/

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Note' severity messages from the CBufferReport.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetNotes(void)
		const
{
	return m_mlNotes;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Warning' severity messages from the CBufferReport.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetWarnings(void)
		const
{
	return m_mlWarnings;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Error' severity messages from the CBufferReport.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetErrors(void)
		const
{
	return m_mlErrors;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Abort' severity messages from the CBufferReport.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetAborts(void)
		const
{
	return m_mlAborts;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns ALL the messages issued to the CBufferReport.  The messages
//  are stored in chronological order.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetMessages(void)
		const
{
	return m_mlMessages;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_optvalstore.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _OPTVALSTORE.H

History:

--*/

#pragma once



#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocOptionValStore : public CRefCount, public CObject
{ public: CLocOptionValStore() {};

	void AssertValid(void) const;

	virtual CLocOptionValSet *GetOptions(const CLString &strOptionGroup)
			= 0;

	virtual BOOL RemoveOption(const CLString &strOptionGroup,
 			const CLString &strOptionName) = 0;
	virtual BOOL StoreOption(const CLString &strOptionGroup,
			const CLocOptionVal *);
	virtual BOOL StoreOption(const CLString &strOptionGroup,
			const CLString &strName, const CLocVariant &) = 0;
	virtual BOOL RemoveOptions(const CLString &strOptionGroup) = 0;

private:
	CLocOptionValStore(const CLocOptionValStore &);
	void operator=(int);
};
	

class LTAPIENTRY CLocOptionValRegStore : public CLocOptionValStore
{
public:
	CLocOptionValRegStore();

	void AssertValid(void) const;
	
	BOOL SetRegistryKeyName(const TCHAR *);

	virtual CLocOptionValSet *GetOptions(const CLString &strOptionGroup);

	virtual BOOL RemoveOption(const CLString &strOptionGroup,
			const CLString &strOptionName);
	virtual BOOL StoreOption(const CLString &strOptionGroup,
			const CLString &strName, const CLocVariant &);
	virtual BOOL RemoveOptions(const CLString &strOptionGroup);

	virtual ~CLocOptionValRegStore();

private:
	HKEY m_hkRegStorage;
	CLocOptionValSetList m_oslCache;

	void PurgeOptionCache(void);
};



#pragma warning(default: 4275)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_locstr.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _LOCSTR.H

History:

--*/


#ifndef ESPUTIL__LOCSTR_H
#define ESPUTIL__LOCSTR_H


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 
class LTAPIENTRY CLocTranslationArray : public CArray<CLocTranslation, CLocTranslation &>
{
public:

protected:
	 NOTHROW void SwapElements(UINT, UINT);
};


#pragma warning(disable : 4251)	// class 'foo' needs to have dll-interface to be
							    // used by clients of class 'bar' 

class LTAPIENTRY CLocCrackedString : public CObject
{
public:
	CLocCrackedString();
			
	void AssertValid(void) const;
	
	const CLocCrackedString &operator=(const CLocCrackedString &);

	NOTHROW int operator==(const CLocCrackedString &) const;
	NOTHROW int operator!=(const CLocCrackedString &) const;

	NOTHROW void CrackLocString(const CLocString &, BOOL fAsSource);
	NOTHROW UINT GetRanking(const CLocCrackedString &) const;

	NOTHROW BOOL HasExtension(void) const;
	NOTHROW BOOL HasControl(void) const;
	NOTHROW BOOL HasHotKey() const;

	NOTHROW const CPascalString & GetBaseString(void) const;
	NOTHROW const CPascalString & GetExtension(void) const;
	NOTHROW const CPascalString & GetControl(void) const;
	NOTHROW WCHAR GetHotKeyChar(void) const;
	NOTHROW UINT GetHotKeyPos(void) const;
	NOTHROW CST::StringType GetStringType(void) const;
	
	void SetBaseString(const CPascalString &pasBaseString);
	void SetHotKey(WCHAR cHotKeyChar, UINT uiHotKeyPos);
	
	void MergeCrackedStrings(const CLocCrackedString &, LangId,
			BOOL fMergeAccel);

	NOTHROW void ConvertToLocString(CLocString &) const;

	static void SetModifiers(const CPasStringList &);
	static void SetKeyNames(const CPasStringList &);
	static WCHAR m_cKeyNameSeparator;
	
	~CLocCrackedString();

private:
	CLocCrackedString(const CLocCrackedString &);

	NOTHROW BOOL Compare(const CLocCrackedString &) const;
	NOTHROW void ClearCrackedString(void);
	NOTHROW static BOOL IsControl(const CPascalString &, BOOL fAsSource);
	NOTHROW static void TranslateControl(CPascalString &);
	void SetDefaultModifierNames();
	void SetDefaultKeyNames();
	
	NOTHROW static BOOL IsTerminator(const CPascalString &);
	static CPasStringArray m_psaModifiersSource;
	static CPasStringArray m_psaKeyNamesSource;
	static CPasStringArray m_psaModifiersTarget;
	static CPasStringArray m_psaKeyNamesTarget;
	static BOOL m_fModifiersInitialized;
	static BOOL m_fKeyNamesInitialized;
	
	CPascalString m_pstrBaseString;
	CPascalString m_pstrExtension;
	CPascalString m_pstrControl;
	WCHAR m_cControlLeader;
	WCHAR m_cHotKeyChar;
	UINT m_uiHotKeyPos;
	CST::StringType m_stStringType;
};

#pragma warning(default : 4275)
#pragma warning(default : 4251)	

LTAPIENTRY const CValidationOptions & GetValidationOptions(void);
LTAPIENTRY void SetValidationOptions(const CValidationOptions &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_locstr.inl"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_report.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _REPORT.H

History:

--*/
 
#ifndef LOCUTIL_REPORT_H
#define LOCUTIL_REPORT_H

#pragma once

//
//  Throws away ALL messages.
//
class LTAPIENTRY CNullReport : public CReport
{
public:
	CNullReport() {};
	
	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

};


//
//  This stuff is used for an implementation of CReport that will
//  'buffer' messages.  Use CBufferReporter if you don't want to
//  process messages until after the process producing them is done.
//  You can get the messages either by severity, or as a list of all
//  messages as they were issued.
//
struct ReportMessage
{
	MessageSeverity sev;
	CLString strContext;
	CLString strMessage;
	SmartRef<CGoto> spGoto;
	SmartRef<CGotoHelp> spGotoHelp;
};


typedef CTypedPtrList<CPtrList, ReportMessage *> MessageList;

#pragma warning (disable:4251)

class LTAPIENTRY CBufferReport : public CReport
{
public:
	CBufferReport();

	void AssertValid(void) const;
	

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	void Clear(void);

	NOTHROW const MessageList & GetNotes(void) const;
	NOTHROW const MessageList & GetWarnings(void) const;
	NOTHROW const MessageList & GetErrors(void) const;
	NOTHROW const MessageList & GetAborts(void) const;

	NOTHROW const MessageList & GetMessages(void) const;
	void DumpTo(CReport *) const;
	
	~CBufferReport();

private:

	MessageList m_mlNotes;
	MessageList m_mlWarnings;
	MessageList m_mlErrors;
	MessageList m_mlAborts;

	mutable MessageList m_mlMessages;
};


//
//  This reporter just send all its messages directly to a message box.
//
class LTAPIENTRY CMessageBoxReport : public CReport
{
public:
	CMessageBoxReport();

	void AssertValid(void) const;

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	~CMessageBoxReport();

private:
	
};



//
//  This reporter is used to send all messages to a file.
//
class LTAPIENTRY CFileReport : public CReport
{
public:
	CFileReport();

	BOOL InitFileReport(const CLString &strFileName);

	virtual void Clear(void);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	~CFileReport();

private:

	CFile m_OutputFile;
};

//
//  This reporter is used for command line utilities.  Output goes to stdout
//
class LTAPIENTRY CStdOutReport : public CReport
{
public:

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	virtual void SetConfidenceLevel(ConfidenceLevel);

private:
	BOOL m_fEnabled;
};


//
//  This is used to 'redirect' messages to a single reporter.  It's used
//  when several different reporters are required by the current
//  implementation, but the desired effect is that they all send their messages
//  to a common location.
//
//  This class takes ownership of another Reporter, then uses reference
//  counting semantics to determine when to delete that reporter.
//
class LTAPIENTRY CRedirectReport : public CReport
{
public:
	CRedirectReport();

	virtual void Activate(void);
	virtual void Clear(void);
	virtual void SetConfidenceLevel(ConfidenceLevel);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	//  Used for initial attachment to a CReporter.
	NOTHROW void RedirectTo(CReport *pReport);

	//  Used to share a single reporter among several CRedirectReporter's.
	NOTHROW void RedirectTo(CRedirectReport *pReport);
	
	~CRedirectReport();

private:
	struct RedirectInfo
	{
		SmartPtr<CReport> pReport;
		UINT uiRefCount;
	};

	RedirectInfo *m_pRedirectInfo;
	void NOTHROW Detach(void);
};


//
//  
//  This class is used to re-direct output through a reporter.  It will
//  automatically call Clear() and Activate() the first time output is sent
//  to the reporter.  If the usre calls Activate first on this reporter, then
//  no action is taken when something is output.
//  
//
class LTAPIENTRY CActivateReport : public CReport
{
public:
	CActivateReport(CReport *);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	void Activate();
	void Clear();

private:
	BOOL m_fActivated;
	CReport *m_pReport;
};



//
//  The following manage a global 'pool' of reporters that are used by
//  different components in the system.
//  Each reporter has to be distinct.  Once the reporter has been 'added',
//  the global pool *owns* the reporter and will delete it.  This is done by
//  ReleaseAllReporters().
//
NOTHROW LTAPIENTRY void AddReport(COutputTabs::OutputTabs idx, CReport *pReport);
NOTHROW LTAPIENTRY CReport * GetReport(COutputTabs::OutputTabs);
NOTHROW LTAPIENTRY void ReleaseAllReports();

#include "_report.inl"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_locstr.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _LOCSTR.INL

History:

--*/


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Swaps two elements of the translation array.
//  
//-----------------------------------------------------------------------------
inline
void
CLocTranslationArray::SwapElements(
		UINT iOne,						// First index to swap
		UINT iTwo)						// Second index to swap
{
	CLocTranslation Temp;
	
	LTASSERT(iOne <= (UINT)GetSize());
	LTASSERT(iTwo <= (UINT)GetSize());

	Temp = (*this)[iOne];
	(*this)[iOne] = (*this)[iTwo];
	(*this)[iTwo] = Temp;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator for cracked strings.
//  
//-----------------------------------------------------------------------------
inline
const CLocCrackedString &
CLocCrackedString::operator=(
		const CLocCrackedString &csSource)
{
	m_pstrBaseString = csSource.m_pstrBaseString;
	m_pstrExtension = csSource.m_pstrExtension;
	m_pstrControl = csSource.m_pstrControl;
	m_cControlLeader = csSource.m_cControlLeader;
	m_cHotKeyChar = csSource.m_cHotKeyChar;
	m_uiHotKeyPos = csSource.m_uiHotKeyPos;

	return *this;
}



//-----------------------------------------------------------------------------
//  
//  Implementation for comparing two cracked strings.  Language ID and
//  string type are NOT significant!
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocCrackedString::Compare(
		const CLocCrackedString &csOther)
		const
{
	return ((m_uiHotKeyPos    == csOther.m_uiHotKeyPos) &&
			(m_cHotKeyChar    == csOther.m_cHotKeyChar) &&
			(m_pstrControl    == csOther.m_pstrControl) &&
			(m_cControlLeader == csOther.m_cControlLeader) &&
			(m_pstrExtension  == csOther.m_pstrExtension) &&
			(m_pstrBaseString == csOther.m_pstrBaseString));
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparision operator.
//  
//-----------------------------------------------------------------------------
inline
int
CLocCrackedString::operator==(
		const CLocCrackedString &csOther)
		const
{
	return Compare(csOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparision operator.
//  
//-----------------------------------------------------------------------------
inline
int
CLocCrackedString::operator!=(
		const CLocCrackedString &csOther)
		const
{
	return !Compare(csOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Tests to see if the Cracked string has an 'extension'.  The extension
//  is a sequence of characters ("...", ">>", stc) that indicates that this
//  item leads to another UI element.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if the extension is non-null.
CLocCrackedString::HasExtension(void)
		const
{
	return m_pstrExtension.GetStringLength() != 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Tests to see if the cracked string has a 'control' sequence.  This is
//  usually text describing a shortcut key that invokes the same action as this
//  item, for example "Ctrl + F".
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if the control seq. is non-null
CLocCrackedString::HasControl(void)
		const
{
	return m_pstrControl.GetStringLength() != 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Check to see if the cracked string has a hot-key.  This come directly out
//  of the CLocString that was parsed into the Cracked String.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if the string has a hot-key.
CLocCrackedString::HasHotKey(void)
		const
{
	return (m_cHotKeyChar != 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the 'base string'.  This is the original string stripped of
//  extension and control sequences, and of the hot-key.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Base string.
CLocCrackedString::GetBaseString(void)
		const
{
	return m_pstrBaseString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the extension component of the string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocCrackedString::GetExtension(void)
		const
{
	return m_pstrExtension;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the constol sequence of the string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocCrackedString::GetControl(void)
		const
{
	return m_pstrControl;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the hot-key character for the string.
//  
//-----------------------------------------------------------------------------
inline
WCHAR
CLocCrackedString::GetHotKeyChar(void)
		const
{
	LTASSERT(HasHotKey());
	
	return m_cHotKeyChar;
}



inline
UINT
CLocCrackedString::GetHotKeyPos(void)
		const
{
	LTASSERT(HasHotKey());
	
	return m_uiHotKeyPos;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the string type for the string.
//  
//-----------------------------------------------------------------------------
inline
CST::StringType
CLocCrackedString::GetStringType(void)
		const
{
	return m_stStringType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Cleans out all the components of the cracked string.
//  
//-----------------------------------------------------------------------------
inline
void
CLocCrackedString::ClearCrackedString(void)
{
	m_pstrBaseString.ClearString();
	m_pstrExtension.ClearString();
	m_pstrControl.ClearString();
	m_cControlLeader = L'\0';
	m_cHotKeyChar = L'\0';
	m_uiHotKeyPos = 0;
	m_stStringType = CST::None;
}



inline
void
CLocCrackedString::SetBaseString(
		const CPascalString &pasBase)
{
	m_pstrBaseString = pasBase;
}



inline
void
CLocCrackedString::SetHotKey(
		WCHAR cHotKeyChar,
		UINT uiHotKeyPos)
{
	m_cHotKeyChar = cHotKeyChar;
	m_uiHotKeyPos = uiHotKeyPos;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\inc\mitctrl.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MITCTRL.H

History:

--*/

#include "..\mitctrl\mitctrllib.h"

#ifndef MIT_MITCTRL_H
#define MIT_MITCTRL_H

//TODO get this from some other place
const	eventidSelChanged = 1L;
const	eventidCheckStateChange = 2L;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_username.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _USERNAME.H

History:

--*/

#ifndef ESPUTIL__USERNAME_H
#define ESPUTIL__USERNAME_H

LTAPIENTRY const NOTHROW CPascalString &GetCurrentUserName();
LTAPIENTRY void NOTHROW SetUserName(const CPascalString &);
LTAPIENTRY void NOTHROW ResetUserName(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\inc\buildnum.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    BUILDNUM.H

History:

--*/

#pragma once

#include "prodver\prodver.h"

#define stringize2(x) #x
#define stringize(x) stringize2(x)
#define frmj rmj
#define frmm rmm
#define frup rup
#define prmj rmj
#define prmm rmm
#define prup rup

#define RELEASE 

#if defined(_DEBUG)
#define ProdVerString stringize(prmj.prmm.prup (Debug) RELEASE\0)
#define FileVerString stringize(frmj.frmm.frup (Debug) RELEASE\0)
#else
#define ProdVerString stringize(prmj.prmm.prup RELEASE\0)
#define FileVerString stringize(frmj.frmm.frup RELEASE\0)
#endif

//
//  Common version information
//
#define CompanyNameString "Microsoft Corporation\0"
#define CopyrightString "Copyright \251 1994-1998 Microsoft Corp.\0"
// copyright for command line tools
#define CopyrightStringCMD "Copyright (C) 1994-1998 Microsoft Corp. All rights reserved.\0"
#define ProductNameString "Microsoft Localization Studio\0"
#define TrademarkString  \
"Microsoft is a registered trademark of Microsoft Corporation. \
Windows(TM) is a trademark of Microsoft Corporation.\0"

#define TIMESTAMP stringize(__TIME__\0)
#define DATESTAMP stringize(__DATE__\0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\inc\mitwarning.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MITWARNING.H

History:

--*/

#if !defined(MIT_MitWarning)
#define MIT_MitWarning

#define ZCOM_WARNING_DISABLE disable: 473 454 4100 4244 4310 4505 4510 4610
#define ZCOM_WARNING_DEFAULT default: 473 454 4100 4244 4310 4505 4510 4610

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\inc\mittl.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MITTL.H

History:

--*/

#if !defined(MIT_TL_INCLUDED)
#define MIT_TL_INCLUDED

// General helpers

#include "..\MitTL\ComHelp.h"

#if defined(__ATLCOM_H__)			// Include ATL helpers if ATL is defined
	#include "..\MitTL\AtlComHelp.h"
#endif

#include "..\MitTL\MapHelp.h"

#include "MitThrow.h"
#include "..\MitTL\SmartPtr.h"

// Shared objects

#if defined(MitTL_UseDispIDCache)
	#include "..\MitTL\DispIDCache.h"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\inc\ltapi.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LTAPI.H

History:

--*/


#ifdef LTAPIENTRY
#undef LTAPIENTRY
#endif

#ifdef IMPLEMENT
#define LTAPIENTRY __declspec(dllexport)

#else  // IMPLEMENT
#define LTAPIENTRY __declspec(dllimport)

#endif // IMPLEMENT


#ifndef LTAPI_H
#define LTAPI_H
//
//  Allow the use of C++ reference types and const methods, without
//  breaking the 'C' world.
//
#ifdef __cplusplus
#define REFERENCE &
#define CONST_METHOD const
#else
#define REFERENCE *
#define CONST_METHOD
#endif

#include <MitThrow.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\inc\mitui.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MITUI.H

History:

--*/


#pragma once

#pragma comment(lib, "MITUI.LIB")

#include "..\mitui\bumpbox.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\inc\mitthrow.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MITTHROW.H

History:

--*/


#if !defined(MIT_MitThrow)
#define MIT_MitThrow

#if !defined(NO_NOTHROW)

#if !defined(NOTHROW)
#define NOTHROW __declspec(nothrow)
#endif

#else

#if defined(NOTHROW)
#undef NOTHROW
#endif

#define NOTHROW

#endif

#endif // MIT_MitThrow
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\inc\mitutil.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MITUTIL.H

History:

--*/


#pragma once

#ifndef IMPLEMENT
#pragma comment(lib, "mitutil.lib")
#endif

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#ifdef __cplusplus


#ifndef __AFXTEMPL_H__
#include <afxtempl.h>
#pragma message("Warning: <afxtempl.h> not in pre-compiled header file, including")
#endif

#ifndef _OLE2_H_
#include <ole2.h>
#pragma message("Warning: <ole2.h> not in pre-compiled header file, including")
#endif

#include <ltapi.h>						// Provide interface definitions
#include "..\mitutil\macros.h"
#include "..\mitutil\ltdebug.h"					//  Espresso debugging facilities
#ifndef MIT_NO_DEBUG
#include "..\mitutil\stacktrace.h"
#include "..\mitutil\counter.h"
#endif

#ifndef MIT_NO_IMAGEHLP
#include <imagehlp.h>
#include "..\mitutil\imagehelp.h"	 	//	Helper class for imagehlp.dll
#endif

#include "..\mitutil\refcount.h"


#ifndef MIT_NO_SMART
#include "..\mitutil\smartptr.h"
#include "..\mitutil\smartref.h"
#endif


#ifndef MIT_NO_STRING
#include "..\mitutil\counter.h"
#include "..\mitutil\clstring.h"		//  Wrapper for CString
#include "..\mitutil\mitenum.h"
#include "..\mitutil\espnls.h"			//  Language Supportxo
#include "..\mitutil\cowblob.h"			//  Copy-on-write Blob class
#include "..\mitutil\passtr.h"			//  Pascal style (counted) strings
#include "..\mitutil\StringBlast.h"
#include "..\mitutil\strlist.h"
#include "..\mitutil\stringtokenizer.h"
#endif

#ifndef MIT_NO_FILE
#include "..\mitutil\loadlib.h"	        //  Wrapper for LoadLibrary
#include "..\mitutil\blobfile.h"
#include "..\mitutil\path.h"
#endif

#ifndef MIT_NO_OPTIONS
#include "..\mitutil\smartref.h"
#include "..\mitutil\locid.h"			//  Espresso ID's
#include "..\mitutil\locvar.h"			//  Variant type for CBinary
#include "..\mitutil\optionval.h"
#include "..\mitutil\optvalset.h"
#include "..\mitutil\uioptions.h"
#include "..\mitutil\uioptset.h"
#include "..\mitutil\uiopthelp.h"
#endif

#ifndef MIT_NO_MISC
#include "..\mitutil\flushmem.h"
#include "..\MitUtil\RegHelp.h"			// Registry helpers
#include "..\MitUtil\EditHelp.h"
#endif

#ifndef MIT_NO_DIFF
#include "..\mitutil\redvisit.h"
#include "..\mitutil\gnudiffalg.h"
#endif

#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\inc\precenum.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PRECENUM.H

History:

--*/

#undef BEGIN_ENUM
#define BEGIN_ENUM(name) \
	enum name \
	{

#undef ENUM_ENTRY
#define ENUM_ENTRY(typelib, name) \
	name,

#undef ENUM_ENTRY_
#define ENUM_ENTRY_(typelib, name, number) \
	name = number,

#undef MARK_ENTRY
#define MARK_ENTRY(name, enumconst) \
	name = enumconst,

#undef END_ENUM
#define END_ENUM(name) \
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\inc\mitdiff.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MITDIFF.H

History:

--*/

#ifndef _MITDIFF_H
#define _MITDIFF_H


#ifdef MITDIFF
#define MITDIFFAPI __declspec(dllexport)
#else
#define MITDIFFAPI __declspec(dllimport)
#endif


//------------------------------------------------------------------------------
//
//	Support routines
//
//------------------------------------------------------------------------------

// Rotating hash from DDJ Sept. 97
inline unsigned
_HashString (const wchar_t *pwch, int cwch)
{
	int h = cwch;
	while (cwch--)
	{
		h = (h << 5) ^ (h >> 27) ^ *pwch++;
	}
	return h;
}


//------------------------------------------------------------------------------
//
//	Define the data types we want to diff
//
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Encapsulates a _bstr_t
class CBStr
{
public:
	CBStr () { }

	operator unsigned () const;								// Hash
	bool operator== (const CBStr& rhs) const;				// Compare

	_bstr_t m_bstr;
};

inline
CBStr::operator unsigned () const
{
	return _HashString (m_bstr, wcslen (m_bstr));
}

inline bool
CBStr::operator== (const CBStr& rhs) const
{
	return wcscmp (m_bstr, rhs.m_bstr) == 0;
}


//------------------------------------------------------------------------------
// Word (not zero-terminated) including word-class
class CWord
{
public:
	CWord () { }

	operator unsigned () const;								// Hash
	bool operator== (const CWord& rhs) const;				// Compare

	const wchar_t *m_pwchWord;
	int m_cwchWord;

	enum wordclass
	{
		wcWORD, wcSPACE, wcMIXED
	};
	wordclass m_wc;
};

inline
CWord::operator unsigned () const
{
	return _HashString (m_pwchWord, m_cwchWord);
}

inline bool
CWord::operator== (const CWord& rhs) const
{
	return m_wc == rhs.m_wc &&
			m_cwchWord == rhs.m_cwchWord &&
			memcmp (m_pwchWord, rhs.m_pwchWord, m_cwchWord * sizeof (wchar_t)) == 0;
}


//------------------------------------------------------------------------------
// Zero-terminated string + custom data
class CCustomString
{
public:
	CCustomString () { }

	operator unsigned () const;								// Hash
	bool operator== (const CCustomString& rhs) const;		// Compare

	const wchar_t *m_pwsz;
	DWORD m_custdata;
};

inline
CCustomString::operator unsigned () const
{
	return _HashString (m_pwsz, wcslen (m_pwsz));
}

inline bool
CCustomString::operator== (const CCustomString& rhs) const
{
	return m_custdata == rhs.m_custdata &&
			wcscmp (m_pwsz, rhs.m_pwsz) == 0;
}


//------------------------------------------------------------------------------
// Binary data block of size 16
class CBlob16
{
public:
	operator unsigned () const;								// Hash
	bool operator== (const CBlob16& rhs) const;				// Compare

	BYTE m_data[16];
};

inline
CBlob16::operator unsigned () const
{
	return _HashString ((const wchar_t *) m_data, 8);
}

inline bool
CBlob16::operator== (const CBlob16& rhs) const
{
	return memcmp (m_data, rhs.m_data, 16) == 0;
}


//------------------------------------------------------------------------------
//
//	Class holding diff result
//
//------------------------------------------------------------------------------

class CDiffResult
{
public:
	CByteArray m_abChanges1;
	CByteArray m_abChanges2;
	int m_iNumAdditions;
	int m_iNumDeletions;
	int m_iNumSubstitutions;
};


//------------------------------------------------------------------------------
//
//	Exported functions
//
//------------------------------------------------------------------------------

// Diff arrays of CBStr
void MITDIFFAPI Diff (
		const CBStr *aElems1,
		int iNumElems1,
		const CBStr *aElems2,
		int iNumElems2,
		CDiffResult *result);

// Diff arrays of CWord
void MITDIFFAPI Diff (
		const CWord *aElems1,
		int iNumElems1,
		const CWord *aElems2,
		int iNumElems2,
		CDiffResult *result);

// Diff arrays of CCustomString
void MITDIFFAPI Diff (
		const CCustomString *aElems1,
		int iNumElems1,
		const CCustomString *aElems2,
		int iNumElems2,
		CDiffResult *result);

// Diff arrays of CBlob16
void MITDIFFAPI Diff (
		const CBlob16 *aElems1,
		int iNumElems1,
		const CBlob16 *aElems2,
		int iNumElems2,
		CDiffResult *result);

// Diff arrays of wchar_t (no class definition needed)
void MITDIFFAPI Diff (
		const wchar_t *aElems1,
		int iNumElems1,
		const wchar_t *aElems2,
		int iNumElems2,
		CDiffResult *result);


#endif	// !_MITDIFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\inc\premidlenum.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PREMIDLENUM.H

History:

--*/

#undef BEGIN_ENUM
#define BEGIN_ENUM(name) \
	typedef enum \
	{

#undef ENUM_ENTRY
#define ENUM_ENTRY(typelib, name) \
	typelib##name,

#undef ENUM_ENTRY_
#define ENUM_ENTRY_(typelib, name, number) \
	typelib##name = number,

#undef MARK_ENTRY
#define MARK_ENTRY(name, enumconst)

#undef END_ENUM
#define END_ENUM(name) \
	} name;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\inc\profile.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PROFILE.H

History:

--*/


#include "icecap\icapexp.h"

// Marks for profiling

// Note: numbers must be > 1000 

const long MARK_GRIDONPAINT1 = 1001;
const long MARK_GRIDONPAINT2 = 1002;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\blobfile.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    BLOBFILE.INL

History:

--*/

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Gets the position with in the file. The position can be set (by calling
//	'Seek()') beyond the end of the data in the file, even beyond the space 
//	allocated for the file. In any case, 'Read()' and 'Write()' will deal with
//	that.
//------------------------------------------------------------------------------
inline
DWORD	//Returns current file position 
CBlobFile::GetPosition() const
{
	ASSERT_VALID(this);
	return m_nPosition;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Gets the actual data size in the file, which is what determines the end
//	of file during readings.
//------------------------------------------------------------------------------
inline
DWORD	//Returns the file data length in bytes.
CBlobFile::GetLength() const
{
	ASSERT_VALID(this);
	return m_nFileSize; 
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Since we keep the file in memory always, we don't need to flush.
//------------------------------------------------------------------------------
inline
void CBlobFile::Flush()
{
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Aborting is like closing.
//------------------------------------------------------------------------------
inline
void CBlobFile::Abort()
{
	ASSERT_VALID(this);

	Close();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Unsupported function
//------------------------------------------------------------------------------
inline
void CBlobFile::LockRange(DWORD /* dwPos */, DWORD /* dwCount */)
{
	AfxThrowNotSupportedException();
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Unsupported function
//------------------------------------------------------------------------------
inline 
void CBlobFile::UnlockRange(DWORD /* dwPos */, DWORD /* dwCount */)
{
	AfxThrowNotSupportedException();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Unsupported function
//------------------------------------------------------------------------------
inline
CFile* CBlobFile::Duplicate() const
{
	AfxThrowNotSupportedException();
	return NULL;
}

inline
UINT CBlobFile::GetBlobSize(void) const
{
	ASSERT_VALID(this);
	return m_blobData.GetBlobSize();
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//	That's the only way to that a caller can have access to the buffer data
//	of the blobfile's internal cowblob.	  
//  
//-----------------------------------------------------------------------------
inline
CBlobFile::operator const CLocCOWBlob &(void)
{
	return GetBlob();
}

inline
const CLocCOWBlob &
CBlobFile::GetBlob(void)
{
 	if (m_pBuffer != NULL)
	{
		m_blobData.ReleasePointer();
		m_pBuffer = NULL;
	}
	//Set correct requested cowblob size before giving access to the data.
	m_blobData.ReallocBlob(m_nFileSize);
	return m_blobData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\clstring.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    CLSTRING.H

History:

--*/


#ifndef CLSTRING_H
#define CLSTRING_H


#pragma warning(disable : 4275)

class LTAPIENTRY CLString : public CString
{
public:
	CLString();
	CLString(const CLString& stringSrc);
	CLString(TCHAR ch, int nRepeat = 1);
	CLString(LPCSTR lpsz);
	CLString(LPCTSTR lpch, int nLength);
	CLString(const unsigned char* psz);
	CLString(HINSTANCE, UINT);
	
	BOOL ReplaceAll(LPCTSTR lpszFind, LPCTSTR lpszReplace, BOOL bMatchCase);

	// overloaded assignment
	NOTHROW const CLString& operator=(const CString& stringSrc);
	
	NOTHROW const CLString& operator=(TCHAR ch);
#ifdef _UNICODE
	NOTHROW const CLString& operator=(char ch);
#endif
	NOTHROW const CLString& operator=(LPCSTR lpsz);
	NOTHROW const CLString& operator=(const unsigned char* psz);

	// string concatenation
	NOTHROW const CLString& operator+=(const CString &);
	NOTHROW const CLString& operator+=(TCHAR ch);
#ifdef _UNICODE
	NOTHROW const CLString& operator+=(char ch);
#endif
	NOTHROW const CLString& operator+=(LPCTSTR lpsz);

	CLString operator+(const CString &) const;
	CLString operator+(LPCTSTR sz) const;

	NOTHROW BOOL LoadString(HMODULE, UINT nId);

	//
	//  The following were copied from CString so we can
	//  'overload' them.

	NOTHROW void Format(LPCTSTR lpszFormat, ...);
	NOTHROW void Format(HMODULE, UINT nFormatID, ...);

	enum ECRLF
	{
		eNone	= 0,
		eCR		= 0x0001,		// '\r'
		eLF		= 0x0002,		// '\n'
		eAll	= eCR | eLF
	};
	void FixCRLF(UINT nCRLF, LPCTSTR pszIndent = NULL);

	DEBUGONLY(~CLString());
protected:

private:
	DEBUGONLY(static CCounter m_UsageCounter);

	//
	//  Evil!  Implicit Unicode conversions!
	CLString(LPCWSTR lpsz);
	NOTHROW const CLString& operator=(LPCWSTR lpsz);
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;

};

#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "clstring.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\blobfile.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    BLOBFILE.H

History:

--*/

#ifndef ESPUTIL_BLOBFILE_H
#define ESPUTIL_BLOBFILE_H


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Class CBlobFile is similar to CMemFile, except that it is implemented 
//	with a CLocCOWBlob
//------------------------------------------------------------------------------
//
//  The compiler worries when you export a class that has a base class
//  that is not exported.  Since I *know* that CFile is exported
//  tell the compliler that this really isn't a problem right here.
//
#pragma warning(disable : 4275)

class LTAPIENTRY CBlobFile : public CFile
{
	DECLARE_DYNAMIC(CBlobFile)

public:
	// Constructor
	CBlobFile(UINT nGrowBytes = 0);
	CBlobFile(const CLocCOWBlob &, UINT nGrowBytes = 0);
	
	virtual ~CBlobFile();

	virtual void AssertValid() const;
	UINT GetBlobSize(void) const;

	virtual DWORD GetPosition() const;
	BOOL GetStatus(CFileStatus& rStatus) const;
	virtual LONG Seek(LONG lOff, UINT nFrom);
	virtual DWORD GetLength() const;
	virtual void SetLength(DWORD dwNewLen);
	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);
	virtual void Abort();
	virtual void Flush();
	virtual void Close();
	virtual UINT GetBufferPtr(UINT nCommand, UINT nCount = 0,
		void** ppBufStart = NULL, void** ppBufMax = NULL);

	//
	//  These operators can't work on const objects, since they
	//  'fix up' the blob size.
	//
	operator const CLocCOWBlob &(void);
	const CLocCOWBlob &GetBlob(void);
	
	// Unsupported APIs
	virtual CFile* Duplicate() const;
	virtual void LockRange(DWORD dwPos, DWORD dwCount);
	virtual void UnlockRange(DWORD dwPos, DWORD dwCount);

protected:
	// Advanced Overridables
	virtual BYTE* Memcpy(BYTE* lpMemTarget, const BYTE* lpMemSource, UINT nBytes);
	virtual void GrowFile(DWORD dwNewLen);

protected:
	// Implementation
	UINT m_nGrowBytes;	//unit of growth of 'm_blobData'
	const UINT cm_nDefaultGrowth; //default unit of growth
	DWORD m_nPosition;	//current position within file
	DWORD m_nFileSize;	//actual number of bytes written to the file
	CLocCOWBlob m_blobData; //file data
	BYTE * m_pBuffer;		//pointer to buffer in blob

};

#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "blobfile.inl"
#endif

#endif  //  BLOBFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\counter.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    COUNTER.H

History:

--*/

#ifndef ESPUTIL_COUNTER_H
#define ESPUTIL_COUNTER_H


class LTAPIENTRY CCounter
{
public:
	CCounter(const TCHAR *);
	
	UINT operator++(void);
	UINT operator--(void);
	void operator+=(UINT);
	void operator-=(UINT);
	
	void Dump(void) const;
	
	~CCounter();
	
private:
	UINT m_uiCurCount;
	UINT m_uiMaxCount;
	UINT m_uiTotal;
	
	const TCHAR *m_szDescription;
};


//------------------------------------------------------------------------------
class LTAPIENTRY CSmartCheck
{
public:
	CSmartCheck(DWORD dwFreqMilli = 2000);

	void Reset();
	BOOL Check();

protected:
	DWORD	m_dwFreqMilli;
	DWORD	m_dwCancelTickMin;	// prevents calling fCancel() too often
	DWORD	m_dwCancelTickMax;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\cowblob.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    COWBLOB.H

History:

--*/

#ifndef COWBLOB_H
#define COWBLOB_H


class LTAPIENTRY CLocCOWBlob 
{
public:
	CLocCOWBlob();
	CLocCOWBlob(const CLocCOWBlob &);

	void AssertValid(void) const;

	LTASSERTONLY(UINT GetWriteCount(void) const);
	
	UINT GetBlobSize(void) const;
	void SetBlobSize(UINT);
	void ReallocBlob(UINT);
	void SetGrowSize(UINT);
	
	void *GetPointer(void);
	void ReleasePointer(void);
	void SetBuffer(const void *, size_t);
	
	operator const void *(void) const;

	const CLocCOWBlob &operator=(const CLocCOWBlob &);
	void Serialize(CArchive &ar);
	void Load(CArchive &ar);
	void Store(CArchive &ar) const;
	
	~CLocCOWBlob();

	//  Comparison operators
	//
	NOTHROW int operator==(const CLocCOWBlob &) const;
	NOTHROW int operator!=(const CLocCOWBlob &) const;

protected:

private:
	typedef struct
	{
		DWORD RefCount;
		DWORD AllocSize;
		DWORD RequestedSize;
	} BlobHeader;

	NOTHROW void Attach(const CLocCOWBlob &);
	NOTHROW void Detach(void);
	NOTHROW void MakeWritable(void);
	NOTHROW BYTE * DataPointer(void) const;
	NOTHROW BlobHeader * GetBlobHeader(void);
	NOTHROW const BlobHeader * GetBlobHeader(void) const;
	NOTHROW DWORD & GetRefCount(void);
	NOTHROW DWORD GetAllocatedSize(void) const;
	NOTHROW DWORD GetRequestedSize(void) const;
	NOTHROW DWORD CalcNewSize(DWORD) const;
	BOOL Compare(const CLocCOWBlob &) const;
	
	BYTE *m_pBuffer;
	DWORD m_WriteCount;
	UINT m_uiGrowSize;
	static const UINT m_uiDefaultGrowSize;

#ifdef _DEBUG
	static CCounter m_UsageCounter;
	void FillEndZone(void);
	void CheckEndZone();
#endif
	
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "cowblob.inl"
#endif

#endif // COWBLOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\diff.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    DIFF.INL

History:

--*/

inline
CDifference::~CDifference()
{
}

inline
CDelta::~CDelta()
{
}

inline
CDiffAlgorithm::~CDiffAlgorithm()
{
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Calculates the delta following the given algorithm and then traverses
//	the delta and calls back the delta visitor for each difference in the delta.
//------------------------------------------------------------------------------
inline
void 
CDiffEngine::Diff(
	CDiffAlgorithm & diffalg, 
	const wchar_t * seq1, // [in] old sequence
	const wchar_t * seq2, // [in] new sequence
	const CDeltaVisitor & dv)
{
	CDelta * d;
	d = diffalg.CalculateDelta(seq1, seq2);
	d->Traverse(dv);
	delete d;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\dllvars.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    DLLVARS.H

History:

--*/
 
#pragma once

extern HINSTANCE g_hMITUtilDll;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\edithelp.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    EDITHELP.H

History:

--*/

#if !defined(MITUTIL__EditHelp_h__INCLUDED)
#define MITUTIL__EditHelp_h__INCLUDED

//------------------------------------------------------------------------------
struct LTAPIENTRY EditHelp
{
	static BOOL SetTopLine(CEdit * pebc, int iLine);

	static BOOL CanUndo(CEdit * pebc);
	static BOOL CanRedo(CEdit * pebc);
	static BOOL CanCut(CEdit * pebc);
	static BOOL CanClear(CEdit * pebc);
	static BOOL CanPaste(CEdit * pebc);
	static BOOL CanCopy(CEdit * pebc);
	static BOOL CanSelectAll(CEdit * pebc);

	static BOOL Undo(CEdit * pebc);
	static BOOL Redo(CEdit * pebc);
	static void Cut(CEdit * pebc);
	static void Copy(CEdit * pebc);
	static void Clear(CEdit * pebc);
	static void Paste(CEdit * pebc);
	static void SelectAll(CEdit * pebc);
	
	static BOOL IsReadOnly(CEdit * pebc);
	static BOOL IsEnabled(CEdit * pebc, UINT nCmdID);

	static BOOL DoEditCmd(CEdit * pebc, UINT nCmdID);
};

#endif // MITUTIL__EditHelp_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\clstring.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    CLSTRING.INL

History:

--*/

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  All these methods re-direct to the CString methods.
//  
//-----------------------------------------------------------------------------
inline
CLString::CLString()
		:
		CString()
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		const CLString &stringSrc)
		:
		CString(stringSrc)
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		TCHAR ch,
		int nRepeat)
		:
		CString(ch, nRepeat)
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		LPCSTR lpsz)
		:
		CString(lpsz)
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		LPCTSTR lpch,
		int nLength)
		:
		CString(lpch, nLength)
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		const unsigned char * psz)
		:
		CString(psz)
{
	DEBUGONLY(++m_UsageCounter);
}



inline
CLString::CLString(
		HINSTANCE hDll,
		UINT uiStringID)
{
	LTVERIFY(LoadString(hDll, uiStringID));
	DEBUGONLY(++m_UsageCounter);
}



inline 
const CLString &
CLString::operator=(
		const CString& stringSrc)
{
	CString::operator=(stringSrc);

	return *this;
}

inline
const CLString &
CLString::operator=(
		TCHAR ch)
{
	CString::operator=(ch);

	return *this;
}


#ifdef _UNICODE

inline
const CLString &
CLString::operator=(
		char ch)
{
	CString::operator=(ch);

	return *this;
}

#endif //  _UNICODE

inline
const CLString &
CLString::operator=(
		LPCSTR lpsz)
{
	CString::operator=(lpsz);

	return *this;
}

inline
const CLString &
CLString::operator=(
		const unsigned char * psz)
{
	CString::operator=(psz);

	return *this;
}

inline
const CLString &
CLString::operator+=(
		const CString & string)
{
	CString::operator+=(string);

	return *this;
}



inline 
const CLString &
CLString::operator+=(
		TCHAR ch)
{
	CString::operator+=(ch);

	return *this;
}

		

#ifdef _UNICODE

inline
const CLString &
CLString::operator+=(
		char ch)
{
	CString::operator+=(ch);

	return *this;
}

#endif  // _UNICODE

inline
const CLString &
CLString::operator+=(
		LPCTSTR lpsz)
{
	CString::operator+=(lpsz);

	return *this;
}


inline
CLString
CLString::operator+(
		const CString &str)
		const
{
	return CLString(*this)+=str;
}



inline
CLString
CLString::operator+(
		const TCHAR *sz)
		const
{
	return CLString(*this)+=sz;
}



inline
void
CLString::Format(
		LPCTSTR lpszFormat, ...)
{

	//
	//  This stolen from CString::Format()
	//
	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
	
}

inline
void
CLString::Format(
		HMODULE hResourceModule,
		UINT nFormatID, ...)
{
	CLString strFormat;
	strFormat.LoadString(hResourceModule, nFormatID);

	va_list argList;
	va_start(argList, nFormatID);
	FormatV(strFormat, argList);
	va_end(argList);
}


#ifdef _DEBUG
inline
CLString::~CLString()
{
	DEBUGONLY(--m_UsageCounter);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\cowblob.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    COWBLOB.INL

History:

--*/

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the blob.  Set the current size to zero.
//  
//-----------------------------------------------------------------------------
inline
CLocCOWBlob::CLocCOWBlob()
{
	m_pBuffer = NULL;
	m_WriteCount = 0;

	m_uiGrowSize = m_uiDefaultGrowSize;

	DEBUGONLY(++m_UsageCounter);
}




#ifdef LTASSERT_ACTIVE
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the number of outstanding GetPointer()'s there are.
//  DEBUGONLY method!
//
//-----------------------------------------------------------------------------
inline
UINT
CLocCOWBlob::GetWriteCount(void)
		const
{
	return m_WriteCount;
}

#endif // _DEBUG



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the granularity for memory allocations.  Memory will always be
//  allocated in amounts that are a multiple of the GrowSize.  This can be
//  useful if you are making small incremental reallocs - by setting a larger
//  grow size, you will allocate memory less often (but some may end up
//  being unused).
//  
//-----------------------------------------------------------------------------
inline
void
CLocCOWBlob::SetGrowSize(
		UINT uiGrowSize)
{
	LTASSERT(uiGrowSize != 0);
	
	if (uiGrowSize == 0)
	{
		m_uiGrowSize = m_uiDefaultGrowSize;
	}
	else
	{
		m_uiGrowSize = uiGrowSize;
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Release a writable pointer.  GetPointer and ReleasePointer should be
//  paired.
//  
//-----------------------------------------------------------------------------
inline
void
CLocCOWBlob::ReleasePointer(void)
{
	LTASSERT(m_WriteCount != 0);

	if (m_WriteCount != 0)
	{
		m_WriteCount--;
	}
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Return a read only pointer to storage.
//  
//-----------------------------------------------------------------------------
inline
CLocCOWBlob::operator const void *(void)
		const
{
	return DataPointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Destructor.  Just detaches this blob from the user memory.
//  
//-----------------------------------------------------------------------------
inline
CLocCOWBlob::~CLocCOWBlob()
{
	DEBUGONLY(CLocCOWBlob::AssertValid());
	
	Detach();

	DEBUGONLY(--m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is the data of this blob NOT equal to the data in the given blob?
//
//-----------------------------------------------------------------------------
inline
int										//TRUE if both blobs are NOT identical
CLocCOWBlob::operator!=(
		const CLocCOWBlob & SourceBlob)
		const
{
	return !Compare(SourceBlob);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is the data of this blob IS equal to the data in the given blob?
//
//-----------------------------------------------------------------------------
inline
int										//TRUE if both blobs ARE identical
CLocCOWBlob::operator==(
		const CLocCOWBlob & SourceBlob)
		const
{
	return Compare(SourceBlob);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\diff.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    DIFF.H

History:

--*/

#ifndef DIFF_H
#define DIFF_H


class CDifference;
class CDeltaVisitor;
class CDelta;
class CDiffAlgorithm;
class CDiffAlgortihmFactory;
class CDiffEngine;

class CDifference // Represents each of the elements in a CDelta object
{
public:
	virtual ~CDifference();
	enum ChangeType
	{
		NoChange,
		Added,
		Deleted
	};
	virtual ChangeType GetChangeType() const = 0;	// types of change that caused the difference
	virtual const wchar_t * GetUnit() const = 0; // comparison unit (0-terminated string)
	virtual int GetOldUnitPosition() const = 0; // 0-based position in old sequence. -1 if Added
	virtual int GetNewUnitPosition() const = 0;	// 0-based position in new sequence. -1 if Deleted
	virtual const wchar_t * GetPrefix() const = 0; //prpend this string to unit string
	virtual const wchar_t * GetSufix() const = 0; //append this string to unit string
	virtual bool IsFirst() const = 0; //is this first difference in delta?
	virtual bool IsLast() const = 0; //is this last difference in delta?
};

class LTAPIENTRY CDeltaVisitor
{
public:
	//called for each element in a CDelta
	virtual void VisitDifference(const CDifference & diff) const = 0; 
};

class CDelta // sequence of CDifference elements
{
public:
	virtual ~CDelta();
	// Starts a visit to all CDifference elements in CDelta
	virtual void Traverse(const CDeltaVisitor & dv) = 0; 
};

class LTAPIENTRY CDiffAlgorithm
{
public:
	virtual ~CDiffAlgorithm();
	// Computes a CDelta object based on a certain diff algorithm
	virtual CDelta * CalculateDelta(
		const wchar_t * seq1, 
		const wchar_t * seq2) = 0; 
};

// Encapsulates the creation of the diff algorithm
class LTAPIENTRY CDiffAlgorithmFactory
{
public:
	virtual CDiffAlgorithm * CreateDiffAlgorithm() = 0;
};



// Generic diff engine that calculates delta and processes each difference in it
class LTAPIENTRY CDiffEngine
{
public:
	static void Diff(CDiffAlgorithm & diffalg, 
		const wchar_t * seq1, 
		const wchar_t * seq2, 
		const CDeltaVisitor & dv);
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "diff.inl"
#endif

#endif  //  DIFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\espnls.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ESPNLS.H

History:

--*/


#ifndef ESPUTIL_ESPNLS_H
#define ESPUTIL_ESPNLS_H


typedef int CodePage;
const CodePage cpInvalidCodePage = 0xDEADBEEF;
const CodePage US_ACP = 1252;

typedef WORD LangId;
const int BAD_LOCALE = 0xFFFF;

enum CodePageType
{
	cpUnknown,
	cpAnsi,
	cpDos,
	cpMac,
	cpUnicode
};


struct LanguageInfo
{
	LangId lid;
	CodePage cpAnsi;
	CodePage cpDos;
	CodePage cpMac;
	const TCHAR *szName;
	const TCHAR *szShortName;
	WORD fLangFlags;
};

const WORD lfNoFlags = 0;
const WORD lfDBCSHotKey = 0x0001;

typedef void (*pfnLangHandler)(const LanguageInfo &, void *);

class LTAPIENTRY CLocLangId 
{
public:
	CLocLangId(void);
	
	LTASSERTONLY(void AssertValid(void) const);

	NOTHROW LangId GetLanguageId(void) const;
	NOTHROW CodePage GetCodePage(CodePageType) const;
	NOTHROW void GetLangName(CLString &) const;
	NOTHROW void GetLangShortName(CLString &) const;
	
	NOTHROW BOOL SetLanguageId(LangId);
	NOTHROW const CLocLangId & operator=(const CLocLangId &);
	
	NOTHROW int operator==(const CLocLangId &) const;
	NOTHROW int operator!=(const CLocLangId &) const;
	
	NOTHROW static UINT GetNumLangInfo(void);
	static void EnumerateLanguages(pfnLangHandler, void *);
	static void Enumerate(CEnumCallback &);
	NOTHROW static BOOL IsDBCSHotKey(LangId);
	NOTHROW BOOL IsDBCSHotKey(void) const;
	NOTHROW static BOOL IsValidLangId(LangId lid);
	
	LTASSERTONLY(~CLocLangId());
	
private:
	//
	//  Private implementation.
	//
	NOTHROW static const LanguageInfo & LocateLangInfo(LangId);
	NOTHROW static const LanguageInfo & GetLangInfo(UINT);
	
	//
	//  Private data.
	//
	LangId m_lid;
	const LanguageInfo *m_pLangInfo;
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "espnls.inl"
#endif

#endif // ESPUTIL_ESPNLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\flushmem.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    FLUSHMEM.H

History:

--*/


#pragma once


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CFlushMemory : public CObject
{
public:
	CFlushMemory(BOOL fDelete);

	virtual void FlushMemory(void) = 0;

	void Delete(void);

private:
	CFlushMemory();
	CFlushMemory(const CFlushMemory &);
	void operator=(const CFlushMemory &);

	BOOL m_fDelete;
};



class LTAPIENTRY CMinWorkSet : public CFlushMemory
{
public:
	CMinWorkSet(BOOL fDelete);
	
	void FlushMemory(void);
};



#pragma warning(default: 4275)

void LTAPIENTRY NOTHROW AddFlushClass(CFlushMemory *);
BOOL LTAPIENTRY NOTHROW RemoveFlushClass(CFlushMemory *);

void LTAPIENTRY FlushMemory(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\gnudiffalg.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    GNUDIFFALG.INL

History:

--*/

inline 
CDiffAlgorithm * 
CGNUDiffAlgFact::CreateDiffAlgorithm()
{
	return new CGNUDiffAlgorithm;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\gnudiffalg.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    GNUDIFFALG.H

History:

--*/

#ifndef GNUDIFFALG_H
#define GNUDIFFALG_H

#include "diff.h"

class LTAPIENTRY CGNUDiffAlgorithm : public CDiffAlgorithm
{
public:
	virtual CDelta * CalculateDelta(
		const wchar_t * seq1, 
		const wchar_t * seq2); 
};

class LTAPIENTRY CGNUDiffAlgFact : public CDiffAlgorithmFactory
{
public:
	virtual CDiffAlgorithm * CreateDiffAlgorithm();
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "gnudiffalg.inl"
#endif

#endif  //  GNUDIFFALG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\imagehelp.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    IMAGEHELP.H

Abstract:

    Re-director for imagehlp.dll.

History:

--*/

#ifndef ESPUTIL_IMAGEHLP_H
#define ESPUTIL_IMAGEHLP_H




class LTAPIENTRY CImageHelp
{
public:
	CImageHelp();
	BOOL ImagehlpAvailable(void);
			
	BOOL EnumerateLoadedModules(HANDLE, PENUMLOADED_MODULES_CALLBACK, void *);
	PIMAGE_NT_HEADERS ImageNtHeader(LPVOID);

	LPAPI_VERSION ImagehlpApiVersion(void);
	BOOL StackWalk(
			DWORD                             MachineType,
			HANDLE                            hProcess,
			HANDLE                            hThread,
			LPSTACKFRAME                      StackFrame,
			LPVOID                            ContextRecord,
			PREAD_PROCESS_MEMORY_ROUTINE      ReadMemoryRoutine,
			PFUNCTION_TABLE_ACCESS_ROUTINE    FunctionTableAccessRoutine,
			PGET_MODULE_BASE_ROUTINE          GetModuleBaseRoutine,
			PTRANSLATE_ADDRESS_ROUTINE        TranslateAddress
		);

	BOOL SymGetModuleInfo(
			IN  HANDLE              hProcess,
			IN  DWORD               dwAddr,
			OUT PIMAGEHLP_MODULE    ModuleInfo
		);
	LPVOID SymFunctionTableAccess(
			HANDLE  hProcess,
			DWORD   AddrBase
		);

	BOOL SymGetSymFromAddr(
			IN  HANDLE              hProcess,
			IN  DWORD               dwAddr,
			OUT PDWORD              pdwDisplacement,
			OUT PIMAGEHLP_SYMBOL    Symbol
		);

	BOOL SymInitialize(
			IN HANDLE   hProcess,
			IN LPSTR    UserSearchPath,
			IN BOOL     fInvadeProcess
		);

	BOOL SymUnDName(
			IN  PIMAGEHLP_SYMBOL sym,               // Symbol to undecorate
			OUT LPSTR            UnDecName,         // Buffer to store undecorated name in
			IN  DWORD            UnDecNameLength    // Size of the buffer
		);

	DWORD SymLoadModule(
			IN  HANDLE          hProcess,
			IN  HANDLE          hFile,
			IN  PSTR            ImageName,
			IN  PSTR            ModuleName,
			IN  DWORD           BaseOfDll,
			IN  DWORD           SizeOfDll
		);
	DWORD UnDecorateSymbolName(
			LPSTR    DecoratedName,         // Name to undecorate
			LPSTR    UnDecoratedName,       // If NULL, it will be allocated
			DWORD    UndecoratedLength,     // The maximym length
			DWORD    Flags                  // See IMAGEHLP.H
		);

	DWORD SymGetOptions(void);
	DWORD SymSetOptions(DWORD);
	
	PIMAGE_NT_HEADERS CheckSumMappedFile(
	    LPVOID BaseAddress,
	    DWORD FileLength,
	    LPDWORD HeaderSum,
	    LPDWORD CheckSum
	    );

	BOOL MakeSureDirectoryPathExists(const TCHAR *);
	
private:

	void LoadImageHelp(void);
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\listdelta.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LISTDELTA.H

History:

--*/


#ifndef LISTDELTA_H
#define LISTDELTA_H

#include "diff.h"

class CListDelta : public CDelta, public CList<CDifference *, CDifference * &>
{
public:
	virtual ~CListDelta();
	virtual void Traverse(const CDeltaVisitor & dv); 
};

#endif  //  LISTDELTA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\loadlib.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOADLIB.H

History:

--*/

#ifndef ESPUTIL_LOADLIB_H
#define ESPUTIL_LOADLIB_H


#pragma warning(disable : 4251)
class LTAPIENTRY CLoadLibrary
{
public:
	NOTHROW CLoadLibrary(void);
	NOTHROW CLoadLibrary(const CLoadLibrary &);

	NOTHROW BOOL LoadLibrary(const TCHAR *szFileName);
	NOTHROW BOOL FreeLibrary(void);

	NOTHROW void WrapLibrary(HINSTANCE);
	
	NOTHROW void operator=(const CLoadLibrary &);

	NOTHROW HINSTANCE GetHandle(void) const;
	NOTHROW HINSTANCE ExtractHandle(void);
	NOTHROW operator HINSTANCE(void) const;

	NOTHROW FARPROC GetProcAddress(const TCHAR *) const;
	
	NOTHROW const CString & GetFileName(void) const;
	
	NOTHROW ~CLoadLibrary();
	
private:
	CString m_strFileName;
	HINSTANCE m_hDll;
};


#pragma warning(default : 4251)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "loadlib.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\espnls.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ESPNLS.INL

History:

--*/


inline
LangId
CLocLangId::GetLanguageId(void)
		const
{
	return m_lid;
}



inline
void
CLocLangId::GetLangName(
		CLString &strLangName)
		const
{
	LTASSERT(m_lid != 0);
	
	strLangName = m_pLangInfo->szName;
}



inline
void
CLocLangId::GetLangShortName(
		CLString &strLangShortName)
		const
{

	strLangShortName = m_pLangInfo->szShortName;
}



inline
int
CLocLangId::operator==(
		const CLocLangId &lidOther)
		const
{
	return (m_lid == lidOther.GetLanguageId());
}



inline
int
CLocLangId::operator!=(
		const CLocLangId &lidOther)
		const
{
	return !operator==(lidOther);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\loadlib.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOADLIB.INL

History:

--*/

inline
CLoadLibrary::CLoadLibrary(void)
{
	m_hDll = NULL;
}



inline
HINSTANCE
CLoadLibrary::GetHandle(void)
		const
{
	return m_hDll;
}



inline
CLoadLibrary::operator HINSTANCE(void)
		const
{
	return GetHandle();
}



inline
HINSTANCE
CLoadLibrary::ExtractHandle(void)
{
	HINSTANCE hReturn;

	hReturn = m_hDll;

	m_strFileName.Empty();
	m_hDll = NULL;

	return hReturn;
}

	   

inline
const CString &
CLoadLibrary::GetFileName(void)
		const
{
	return m_strFileName;
}



inline
BOOL
CLoadLibrary::LoadLibrary(
		const TCHAR *szFileName)
{
	LTASSERT(m_hDll == NULL);
	   
	m_strFileName = szFileName;
	m_hDll = AfxLoadLibrary(m_strFileName);

	return (m_hDll != NULL);
}



inline
void
CLoadLibrary::WrapLibrary(
		HINSTANCE hDll)
{
	m_hDll = hDll;
}



inline
CLoadLibrary::CLoadLibrary(
		const CLoadLibrary &llSource)
{
	m_hDll = NULL;

	if (llSource.GetHandle() != NULL)
	{
		LoadLibrary(llSource.GetFileName());
	}
}



inline
void
CLoadLibrary::operator=(
		const CLoadLibrary &llSource)
{
	LTASSERT(m_hDll == NULL);

	if (llSource.GetHandle() != NULL)
	{
		LoadLibrary(llSource.GetFileName());
	}
}



inline
FARPROC
CLoadLibrary::GetProcAddress(
		const TCHAR *szProcName)
		const
{
	FARPROC fpFunction = NULL;
	
	if (m_hDll != NULL)
	{
		fpFunction = ::GetProcAddress(m_hDll, szProcName);
	}

	return fpFunction;
}



inline
BOOL
CLoadLibrary::FreeLibrary(void)
{
	BOOL fRetVal = TRUE;
	
 	if (m_hDll != NULL)
	{
		fRetVal = AfxFreeLibrary(m_hDll);
		m_hDll = NULL;
		m_strFileName.Empty();
	}

	return fRetVal;
}



inline
CLoadLibrary::~CLoadLibrary()
{
	FreeLibrary();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\locid.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCID.H

History:

--*/

//  
//  This is the definition of a localization ID.  It makes up part of the
//  localization unique ID, and is eesentially the implementation for
//  CLocResId and CLocTypeId.
//  
 
#ifndef LOCID_H
#define LOCID_H

#pragma warning(disable : 4275)

class LTAPIENTRY CLocId : public CObject
{
public:
	NOTHROW CLocId();

	void AssertValid(void) const;

	BOOL NOTHROW HasNumericId(void) const;
	BOOL NOTHROW HasStringId(void) const;
	BOOL NOTHROW IsNull(void) const;
	
	BOOL NOTHROW GetId(ULONG &) const;
	BOOL NOTHROW GetId(CPascalString &) const;

	void NOTHROW GetDisplayableId(CPascalString &) const;

	//
	//  These 'set' functions are 'write once'.  Once the ID has been
	//  set, it can't be changed.  Trying to set the ID again will
	//  cause an AfxNotSupportedException to be thrown.
	//
	void SetId(ULONG);
	void SetId(const CPascalString &);
	void SetId(const WCHAR *);
	void SetId(ULONG, const CPascalString &);
	void SetId(ULONG, const WCHAR *);
	
	const CLocId &operator=(const CLocId &);

	void NOTHROW ClearId(void);
	
	int NOTHROW operator==(const CLocId &) const;
	int NOTHROW operator!=(const CLocId &) const;

	virtual void Serialize(CArchive &ar);

	virtual ~CLocId();

protected:
	//
	//  Internal implementation functions.
	//
	BOOL NOTHROW IsIdenticalTo(const CLocId&) const;
	void NOTHROW CheckPreviousAssignment(void) const;
	 
private:
	//
	//  This prevent the default copy constructor from being
	//  called.
	//
	CLocId(const CLocId&);

	ULONG m_ulNumericId;            //  The numeric ID of the resource
	CPascalString m_pstrStringId;   //  The string ID of the resource
	BOOL m_fHasNumericId :1;		//  Indicates if the numeric ID is valid
	BOOL m_fHasStringId  :1;		//  Indicates if the string ID is valid

	DEBUGONLY(static CCounter m_UsageCounter);
	DEBUGONLY(static CCounter m_DisplayCounter);
};
#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locid.inl"
#endif

#endif  //  LOCID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\macros.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MACROS.H

History:

--*/


#define COUNTOF(x) (sizeof(x)/sizeof(*x))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\locid.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCID.INL

History:

--*/


//  In line definitions for the CLocID class.  This fgile should ONLY be
//  included by locid.h
//  
 

//-----------------------------------------------------------------------------
//  
//  Implementation.  Clears the contents of the ID.  Both parts are marked
//  invalid.
//  
//-----------------------------------------------------------------------------
inline
void
CLocId::ClearId(void)
{
	m_fHasNumericId = FALSE;
	m_fHasStringId = FALSE;

	m_ulNumericId = 0;
	m_pstrStringId.ClearString();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constuctor for a localization ID.  Sets it to have no valid ID.
//  
//-----------------------------------------------------------------------------
inline
CLocId::CLocId()
{
	ClearId();

	DEBUGONLY(++m_UsageCounter);
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Tests if the numeric ID is valid.
//  
//-----------------------------------------------------------------------------
inline
BOOL                              //  TRUE means the numeric ID is valid
CLocId::HasNumericId(void)
		const
{
	return m_fHasNumericId;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Tests if the string ID is valid.
//  
//-----------------------------------------------------------------------------
inline
BOOL							        //  TRUE means the string ID is valid
CLocId::HasStringId(void)
		const
{
	return m_fHasStringId;
}



inline
BOOL
CLocId::IsNull(void)
		const
{
	return
		!HasStringId() &&
		!HasNumericId();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current numeric ID.  If the ID is invalid, the ID will be
//  zero.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE indicates the ID is valid
CLocId::GetId(
		ULONG &ulNumericId)				// Location to put ID
		const
{
	ulNumericId = m_ulNumericId;
	
	return m_fHasNumericId;
}

		

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current string ID.  If the ID is invalid, it will be a NULL
//  string.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE indicates the ID is valid
CLocId::GetId(
		CPascalString &pstrStringId)	// Location to put the ID.
		const
{
	pstrStringId = m_pstrStringId;
	
	return m_fHasStringId;
}


//-----------------------------------------------------------------------------
//  
//  Checks if the ID has been assigned to before.  If it has, throw an
//  exception.
//  
//-----------------------------------------------------------------------------
inline
void
CLocId::CheckPreviousAssignment(void)
		const
{
	if (m_fHasStringId || m_fHasNumericId)
	{
		AfxThrowNotSupportedException();
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Compares two ID's to see if they are the same.  
//  
//-----------------------------------------------------------------------------
inline
int
CLocId::operator==(
		const CLocId &lidOther)			// ID to compare to
		const
{
	return IsIdenticalTo(lidOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Checks for in-equality between two ID's
//  
//-----------------------------------------------------------------------------
inline
int
CLocId::operator!=(
		const CLocId &lidOther)
		const
{
	return !IsIdenticalTo(lidOther);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\locvar.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCVAR.H

History:

--*/


//  Declaration of CLocVariant, our variant class.
//  
 
#ifndef ESPUTIL_LOCVAR_H
#define ESPUTIL_LOCVAR_H


enum LocVariantType
{
	lvtNone,
	lvtInteger,
	lvtString,
	lvtIntPlusString,
	lvtBOOL,
	lvtBlob,
	lvtStringList,
	lvtFileName,			// stores file name and editing extension string
};


typedef CLocThingList<CPascalString> CPasStringList;

UINT StoreToBlob(const CPasStringList &, CLocCOWBlob &, UINT uiOffset);
UINT LoadFromBlob(CPasStringList &, const CLocCOWBlob &, UINT uiOffset);
#pragma warning(disable : 4275 4251)

class LTAPIENTRY CLocVariant : public CObject
{
public:
	NOTHROW CLocVariant();

	void AssertValid(void) const;

	NOTHROW LocVariantType GetVariantType(void) const;
	
	NOTHROW DWORD GetDword(void) const;
	NOTHROW BOOL GetBOOL(void) const;
	NOTHROW const CPascalString & GetString(void) const;
	NOTHROW const CLocId & GetIntPlusString(void) const;
	NOTHROW const CLocCOWBlob & GetBlob(void) const;
	NOTHROW const CPasStringList & GetStringList(void) const;
	NOTHROW const CLString & GetFileExtensions(void) const;
	
	NOTHROW int operator==(const CLocVariant &) const;
	NOTHROW int operator!=(const CLocVariant &) const;
	
	NOTHROW void SetDword(const DWORD);
	NOTHROW void SetBOOL(const BOOL);
	NOTHROW void SetString(const CPascalString &);
	NOTHROW void SetIntPlusString(const CLocId &);
	NOTHROW void SetBlob(const CLocCOWBlob &);
	NOTHROW void SetStringList(const CPasStringList &);
	NOTHROW void SetFileName(const CPascalString &, const CLString &);
	
	NOTHROW const CLocVariant & operator=(const CLocVariant &);
	BOOL ImportVariant(const VARIANT& var);
	BOOL ExportVariant(VARIANT& var) const;

	void Serialize(CArchive &);
	void Load(CArchive &);
	void Store(CArchive &) const;
	
protected:
	NOTHROW BOOL IsEqualTo(const CLocVariant &) const;
	
private:
	CLocVariant(const CLocVariant &);

	
	LocVariantType m_VarType;

	//
	//  Class objects can't be in a union.
	//
	union
	{
		DWORD m_dwInteger;
		BOOL  m_fBOOL;
	};
	CPascalString  m_psString;
	CLocId         m_IntPlusString;
	CLocCOWBlob    m_Blob;
	CPasStringList m_StringList;
	CLString       m_strFileExtensions;
};

#pragma warning(default : 4275 4251)


void Store(CArchive &, const CPasStringList &);
void Load(CArchive &, CPasStringList &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locvar.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\locvar.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCVAR.INL

History:

--*/

//  
//  Inline functions for the variant class.  This should ONLY be included from
//  locvar.h
//  
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Default constructor.  Sets the variant type to none ie no value is in
//  the variant.
//  
//-----------------------------------------------------------------------------
inline
CLocVariant::CLocVariant()
{
	m_VarType = lvtNone;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the type of the data in the variant.
//  
//-----------------------------------------------------------------------------
inline
LocVariantType
CLocVariant::GetVariantType(void)
		const
{
	return m_VarType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the integer data in the variant.  The data must have been set
//  previously as an integer.
//  
//-----------------------------------------------------------------------------
inline
DWORD
CLocVariant::GetDword(void)
		const
{
	LTASSERT(m_VarType == lvtInteger || m_VarType == lvtStringList);

	if (m_VarType == lvtInteger)
	{
		return m_dwInteger;
	}
	else
	{
		return m_StringList.GetIndex();
	}
}



inline
BOOL
CLocVariant::GetBOOL(void)
		const
{
	LTASSERT(m_VarType == lvtBOOL);
	
	return m_fBOOL;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the string data in the variant.  The data must have been set
//  previously as an string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocVariant::GetString(void)
		const
{
	LTASSERT(m_VarType == lvtString || m_VarType == lvtFileName);
		
	return m_psString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the dual string/integer data in the variant.  The data must have
//  been set previously as an dual string/integer.
//  
//-----------------------------------------------------------------------------
inline
const CLocId &
CLocVariant::GetIntPlusString(void)
		const
{
	LTASSERT(m_VarType == lvtIntPlusString);

	return m_IntPlusString;
}



inline
const CLocCOWBlob &
CLocVariant::GetBlob(void)
		const
{
	LTASSERT(m_VarType == lvtBlob);

	return m_Blob;
}



inline
const CPasStringList &
CLocVariant::GetStringList(void)
		const
{
	LTASSERT(m_VarType == lvtStringList);

	return m_StringList;
}

inline
const CLString & 
CLocVariant::GetFileExtensions(void) 
	const
{
	LTASSERT(m_VarType == lvtFileName);

	return m_strFileExtensions;
}	


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparison operator.
//  
//-----------------------------------------------------------------------------
inline
int
CLocVariant::operator==(
		const CLocVariant &lvOther)
		const
{

	return IsEqualTo(lvOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparison operator.
//  
//-----------------------------------------------------------------------------
inline
int
CLocVariant::operator!=(
		const CLocVariant &lvOther)
		const
{
	return !IsEqualTo(lvOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the variant to an integer value.
//  
//-----------------------------------------------------------------------------
inline
void
CLocVariant::SetDword(
		const DWORD dwNewValue)
{
	m_VarType = lvtInteger;

	m_dwInteger = dwNewValue;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
CLocVariant::SetBOOL(
		const BOOL fNewValue)
{
	m_VarType = lvtBOOL;

	m_fBOOL = fNewValue;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the variant to a CPascalString value.
//  
//-----------------------------------------------------------------------------
inline
void
CLocVariant::SetString(
		const CPascalString &psNewValue)
{
	m_VarType = lvtString;

	m_psString = psNewValue;
}

inline
void 
CLocVariant::SetFileName(
	const CPascalString &psNewValue,
	const CLString & strExtensions)
{
	m_VarType = lvtFileName;

	m_psString = psNewValue;
	m_strFileExtensions = strExtensions;

}	


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the variant to a dual string/integer value.
//  
//-----------------------------------------------------------------------------
inline
void
CLocVariant::SetIntPlusString(
		const CLocId &NewIntPlusString)
{
	m_VarType = lvtIntPlusString;

	m_IntPlusString = NewIntPlusString;
}



inline
void
CLocVariant::SetBlob(
		const CLocCOWBlob &blbNewValue)
{
	m_VarType = lvtBlob;

	m_Blob = blbNewValue;
}



inline
void
CLocVariant::SetStringList(
		const CPasStringList &slNewValue)
{
	m_VarType = lvtStringList;

	m_StringList = slNewValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\ltimalloc.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LTIMALLOC.H

History:

--*/

class LTIMallocSpy : public IMallocSpy
{
public:
	LTIMallocSpy();
	~LTIMallocSpy();

	
	//
	// IUnknown interface
	virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
	
	virtual ULONG STDMETHODCALLTYPE AddRef( void);
	
	virtual ULONG STDMETHODCALLTYPE Release( void);
	
private:

	//
	// IMallocSpy methods.
	virtual ULONG STDMETHODCALLTYPE PreAlloc( 
            /* [in] */ ULONG cbRequest);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PostAlloc( 
            /* [in] */ void __RPC_FAR *pActual);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PreFree( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
	virtual void STDMETHODCALLTYPE PostFree( 
            /* [in] */ BOOL fSpyed);
        
	virtual ULONG STDMETHODCALLTYPE PreRealloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ ULONG cbRequest,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppNewRequest,
            /* [in] */ BOOL fSpyed);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PostRealloc( 
            /* [in] */ void __RPC_FAR *pActual,
            /* [in] */ BOOL fSpyed);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PreGetSize( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
	virtual ULONG STDMETHODCALLTYPE PostGetSize( 
            /* [in] */ ULONG cbActual,
            /* [in] */ BOOL fSpyed);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PreDidAlloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
	virtual int STDMETHODCALLTYPE PostDidAlloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed,
            /* [in] */ int fActual);
        
	virtual void STDMETHODCALLTYPE PreHeapMinimize( void);
        
	virtual void STDMETHODCALLTYPE PostHeapMinimize( void);

	UINT m_uiRefCount;
	CCounter m_IMallocCounter;
	CCounter m_IMallocUsage;

	ULONG m_ulSize;
};


void DumpOutstandingAllocs(void);
void SetTrackingMode(BOOL);

void LTAPIENTRY BreakOnIMalloc(DWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\ltdebug.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LTDEBUG.H

History:

--*/


//  
//  Debugging facilities for Espresso 2.x.  Included are augmented TRACE
//  and ASSERT facilities.
//  
 
#ifndef MITUTIL_LtDebug_h_INCLUDED
#define MITUTIL_LtDebug_h_INCLUDED

#pragma once


#if defined(_DEBUG)
#define LTTRACE_ACTIVE
#define LTASSERT_ACTIVE

#define new DEBUG_NEW
#define LTGetAllocNumber() LTGetAllocNumberImpl()

//
//  Executes code only in a DEBUG build.
//
#define DEBUGONLY(x) x

#define LTDebugBreak() LTBreak()

#else  // _DEBUG

#define DEBUGONLY(x) 

#define LTDebugBreak() (void) 0
#define LTGetAllocNumber() 0

#endif  // _DEBUG

#if defined(LTASSERT_ACTIVE) || defined (ASSERT_ALWAYS)
#ifdef ASSERT
#undef ASSERT
#endif
#ifdef VERIFY
#undef VERIFY
#endif
#define ASSERT LTASSERT
#define VERIFY LTVERIFY

#ifndef _DEBUG
#pragma message("Warning: LTASSERT Active in non-debug build")
#endif
//
// The multilevel assert macros ensure that the line numbers get expanded to
// something like "115" instead of "line" or "__LINE__"
//
// This will evaluate the expression only once, UNLESS to ask it to 'Retry'.
// Then it will re-evaluate the expression after the return from the debugger.
//
#define LTASSERTONLY(x) x

#define LTASSERT(x) LTASSERT2(x, TEXT(__FILE__), __LINE__)

#define LTASSERT2(exp, file, line)  \
        while (!(exp) && LTFailedAssert(TEXT(#exp), file, line)) (void) 0

#define LTVERIFY(x) LTASSERT(x)

#else // defined(_DEBUG) || defined(ASSERT_ALWAYS)

#define LTASSERTONLY(x)
#define LTASSERT(x) (void) 0
#define LTVERIFY(x) x

#endif // defined(_DEBUG) || defined(ASSERT_ALWAYS)


#ifndef MIT_NO_DEBUG
//
//  Name of the project
//
#ifndef LTTRACEPROJECT
#define LTTRACEPROJECT "Borg"
#endif

//
//  Default value for the exe name if one was not supplied.
//
#ifndef LTTRACEEXE
#define LTTRACEEXE MSLOC
#endif

//
//  Used to put quotes around the LTTRACEEXE macro.
//
#define __stringify2(x) #x
#define __stringify(x) __stringify2(x)

//
// TODO - find a better place for this

		LTAPIENTRY void CopyToClipboard(const char *szMessage);

		
		
struct LTModuleInfo
{
	UINT uiPreferredLoadAddress;
	UINT uiActualLoadAddress;
	UINT uiModuleSize;
	char szName[MAX_PATH];
};

LTAPIENTRY void LTInitDebug(void);

LTAPIENTRY void LTInstallIMallocTracking();
LTAPIENTRY void LTDumpIMallocs(void);
LTAPIENTRY void LTTrackIMalloc(BOOL f);
LTAPIENTRY void LTRevokeIMallocTracking();

LTAPIENTRY void LTShutdownDebug(void);

LTAPIENTRY BOOL LTSetAssertSilent(BOOL);
LTAPIENTRY BOOL LTFailedAssert(const TCHAR *, const TCHAR *, int);
LTAPIENTRY void LTBreak(void);

LTAPIENTRY LONG LTGetAllocNumberImpl(void);
LTAPIENTRY void LTBreakOnAlloc(const char *szFilename, int nLineNum, long nAllocNum);

LTAPIENTRY BOOL LTCheckBaseAddress(HMODULE);
LTAPIENTRY BOOL LTCheckAllBaseAddresses(void);
LTAPIENTRY void LTCheckPagesFor(HINSTANCE);
LTAPIENTRY void LTCheckPagesForAll(void);

LTAPIENTRY void LTDumpAllModules(void);
LTAPIENTRY BOOL LTLocateModule(DWORD dwAddress, HMODULE *pInstance);
LTAPIENTRY BOOL LTGetModuleInfo(HMODULE, LTModuleInfo *);

LTAPIENTRY UINT LTGenStackTrace(TCHAR *szBuffer, UINT nBuffSize,
		UINT nSkip, UINT nTotal);

LTAPIENTRY void LTSetBoringModules(const char *aszBoring[]);
LTAPIENTRY void LTTrackAllocations(BOOL);
LTAPIENTRY void LTDumpAllocations(void);

LTAPIENTRY BOOL LTCheckResourceRange(HINSTANCE, WORD UniqueStart, WORD UniqueEnd,
		WORD SharedStart, WORD SharedEnd);
LTAPIENTRY BOOL LTCheckAllResRanges(WORD, WORD);

#pragma warning(disable:4275)

class LTAPIENTRY CAssertFailedException : public CException
{
public:
	CAssertFailedException(const TCHAR *);
	CAssertFailedException(const TCHAR *, BOOL);

	BOOL GetErrorMessage(LPTSTR lpszError, UINT nMaxError,
			PUINT pnHelpContext = NULL);

	~CAssertFailedException();
	
private:
	CAssertFailedException();
	CAssertFailedException(const CAssertFailedException &);

	TCHAR *m_pszAssert;
};



class LTAPIENTRY LTTracePoint
{
public:
	LTTracePoint(const TCHAR *);

	~LTTracePoint();

private:
	LTTracePoint();

	const TCHAR *m_psz;
};



#pragma warning(default:4275)

//
//  Comment this out to remove ASSERTs from retail builds
//  #define LTASSERT_ACTIVE


#if defined(LTTRACE_ACTIVE)


static const TCHAR *szLTTRACEEXE = TEXT(__stringify(LTTRACEEXE));

//
//  The following let us control the output dynamically.  We use a function
//  pointer to route our debug output, and change the function pointer to
//  enable/disable tracing.
//
static void LTTRACEINIT(const TCHAR *, ...);
static void (*LTTRACE)(const TCHAR *, ...) = LTTRACEINIT;

void LTAPIENTRY LTTRACEOUT(const TCHAR *szFormat, va_list args);
void LTAPIENTRY LTTRACEON(const TCHAR *szFormat, ...);
void LTAPIENTRY LTTRACEOFF(const TCHAR *szFormat, ...);


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  LTTRACE is initialized to point to this function.  When first called, it
//  determines if tracing should be enabled, then routes LTTRACE through the
//  right handler.
//  
//-----------------------------------------------------------------------------
static
void
LTTRACEINIT(
		const TCHAR *szFormat,			//  printf style formatting string
		...)							//  Variable argument list to format 
{
	BOOL fDoTrace = 1;
	va_list args;
	const TCHAR * const szTraceProfile = TEXT("lttrace.ini");

	fDoTrace = GetPrivateProfileInt(
			TEXT("ProjectTracing"),
			TEXT("Default"),
			fDoTrace,
			szTraceProfile);
	
	fDoTrace = GetPrivateProfileInt(
			TEXT("ProjectTracing"),
			TEXT(LTTRACEPROJECT),
			fDoTrace,
			szTraceProfile);
	
	if (fDoTrace)
	{
		fDoTrace = GetPrivateProfileInt(
				TEXT("ExecutableTracing"),
				szLTTRACEEXE,
				fDoTrace,
				szTraceProfile);
	}
	
	if (fDoTrace)
	{
		LTTRACE = LTTRACEON;
		
		va_start(args, szFormat);
		
		LTTRACEOUT(szFormat, args);
	}
	else
	{
		LTTRACE = LTTRACEOFF;
	}
}


#define LTTRACEPOINT(sz) LTTracePoint lttp##__LINE__(TEXT(sz))

#else // defined(LTTRACE_ACTIVE)

//
//  Retail version of the debugging macros.  Everything
//  just 'goes away'.  We use (void) 0 so that these things
//  are statements in both the debug and retail builds.
//

static inline void LTNOTRACE(const TCHAR *, ...) 
{}

#define LTTRACE 1 ? (void) 0 : (void) LTNOTRACE
#define LTTRACEPOINT(x) (void) 0

#endif  // defined(LTTRACE_ACTIVE)


#endif // MIT_NO_DEBUG


#endif // #ifndef MITUTIL_LtDebug_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\mitenum.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MITENUM.H

History:

--*/

#pragma once

//
//  This is the information we enumerate about enumerators.
//
struct EnumInfo
{
	const TCHAR *szDescription;
	const TCHAR *szAbbreviation;
	ULONG ulValue;
};

//
//  This class is used as a base for a call-back class when enumerating
//  enum values.  For each value, the PrecessEnum() method is called.
//
class LTAPIENTRY CEnumCallback 
{
public:
	virtual BOOL ProcessEnum(const EnumInfo &) = 0;
	virtual void SetRange(UINT /* nStart */, UINT /* nFinish */) {}
	inline CEnumCallback() {};

private:
	CEnumCallback(const CEnumCallback &);
	CEnumCallback &operator=(const CEnumCallback &);
};


//
struct WEnumInfo
{
	const WCHAR *szDescription;
	const WCHAR *szAbbreviation;
	ULONG ulValue;
};

//
//  This class is used as a base for a call-back class when enumerating
//  enum values.  For each value, the PrecessEnum() method is called.
//
class LTAPIENTRY CWEnumCallback 
{
public:
	virtual BOOL ProcessEnum(const WEnumInfo &) = 0;
	virtual void SetRange(UINT /* nStart */, UINT /* nFinish */) {}
	inline CWEnumCallback() {};

private:
	CWEnumCallback(const CWEnumCallback &);
	CWEnumCallback &operator=(const CWEnumCallback &);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\optvalset.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    OPTVALSET.H

History:

--*/

#pragma once



#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocOptionValEnumCallback : public CObject
{
public:
	CLocOptionValEnumCallback() {};

	void AssertValid(void) const;
			
	virtual BOOL ProcessOption(CLocOptionVal *) = 0;
	virtual BOOL ProcessOption(const CLocOptionVal *) = 0;
	
private:
	CLocOptionValEnumCallback(const CLocOptionValEnumCallback &);
	void operator=(int);
};


class LTAPIENTRY CLocOptionValSet;

class LTAPIENTRY CLocOptionValSetList :
	public CTypedPtrList<CPtrList, CLocOptionValSet *>
{
public:
	NOTHROW CLocOptionValSetList() {};

	void AssertValid(void) const;

	NOTHROW void ReleaseAll();
	NOTHROW ~CLocOptionValSetList();

private:
	CLocOptionValSetList(const CLocOptionValSetList &);
	void operator=(const CLocOptionValSetList &);
};

 
class LTAPIENTRY CLocOptionValSet : public CRefCount, public CObject
{
public:
	NOTHROW CLocOptionValSet();

	void AssertValid(void) const;
	
	NOTHROW void AddOption(CLocOptionVal *);
	NOTHROW void AddOptionSet(CLocOptionValSet *);
	NOTHROW void SetName(const CLString &);
	
	NOTHROW const CLocOptionValList & GetOptionList(void) const;
	NOTHROW const CLocOptionValSetList & GetOptionSets(void) const;
	NOTHROW BOOL FindOptionVal(const CLString &, CLocOptionVal *&pOption);
	NOTHROW BOOL FindOptionVal(const CLString &, const CLocOptionVal *&pOption) const;
	NOTHROW const CLString & GetName(void) const;
	
	NOTHROW BOOL IsEmpty(void) const;
	
	BOOL EnumOptions(CLocOptionValEnumCallback *);
	BOOL EnumOptions(CLocOptionValEnumCallback *) const;
	
	//
	//  Escape hatch.
	//
	NOTHROW void * GetPExtra(void) const;
	NOTHROW DWORD GetDWExtra(void) const;
	NOTHROW void SetExtra(void *);
	NOTHROW void SetExtra(DWORD);

protected:
	NOTHROW virtual ~CLocOptionValSet();

private:
	CLocOptionValList m_olOptions;
	CLocOptionValSetList m_oslSubOptions;
	CLString m_strName;
	
	union
	{
		void *m_pExtra;
		DWORD m_dwExtra;
	};
	
	CLocOptionValSet(const CLocOptionValSet &);
	void operator=(const CLocOptionValSet &);
};

#pragma warning(default: 4275)
 
#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "optvalset.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\optionval.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    OPTIONVAL.H

History:

--*/

#pragma once

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocOptionVal : public CRefCount, public CObject
{
public:
	NOTHROW CLocOptionVal();

	void AssertValid(void) const;

	enum OptionCode
	{
		ocNoError,
		ocUnknownOption,
		ocInvalidValue,
		ocInvalidType
	};

	NOTHROW void SetName(const CLString &);
	NOTHROW void SetValue(const CLocVariant &);

	NOTHROW const CLString & GetName(void) const;
	NOTHROW const CLocVariant & GetValue(void) const;

	void Serialize(CArchive &);
	void Load(CArchive &);
	void Store(CArchive &) const;
	
protected:
	virtual ~CLocOptionVal();

private:
	CLString m_strName;
	CLocVariant m_lvValue;

};


class LTAPIENTRY CLocOptionValList :
	public CTypedPtrList<CPtrList, CLocOptionVal *>
{
public:
	NOTHROW CLocOptionValList();

	void AssertValid(void) const;

	NOTHROW ~CLocOptionValList();

private:
	CLocOptionValList(const CLocOptionValList &);

	void operator=(const CLocOptionValList &);
};


#pragma warning(default: 4275)


//
//  Worker function for options upgrade.
LTAPIENTRY void DorkData(BYTE *, DWORD &);


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "optionval.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\optvalset.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    OPTVALSET.INL

History:

--*/

inline		
void
CLocOptionValSet::AddOption(
		CLocOptionVal *pOption)
{
	m_olOptions.AddTail(pOption);
}



inline
void
CLocOptionValSet::AddOptionSet(
		CLocOptionValSet *pOptionSet)
{
	m_oslSubOptions.AddTail(pOptionSet);
}



inline
void
CLocOptionValSet::SetName(
		const CLString &strName)
{
	m_strName = strName;
}



inline
const CLocOptionValList &
CLocOptionValSet::GetOptionList(void)
		const
{
	return m_olOptions;
}


inline
const CLocOptionValSetList &
CLocOptionValSet::GetOptionSets(void)
		const
{
	return m_oslSubOptions;
}



inline
const CLString &
CLocOptionValSet::GetName(void)
		const
{
	return m_strName;
}



inline
BOOL
CLocOptionValSet::IsEmpty(void)
		const
{
	return m_olOptions.IsEmpty() && m_oslSubOptions.IsEmpty();
}


inline
void *
CLocOptionValSet::GetPExtra(void)
		const
{
	return m_pExtra;
}



inline
DWORD
CLocOptionValSet::GetDWExtra(void)
		const
{
	return m_dwExtra;
}



inline
void
CLocOptionValSet::SetExtra(
		void *pExtra)
{
	m_pExtra = pExtra;
}



inline
void
CLocOptionValSet::SetExtra(
		DWORD dwExtra)
{
	m_dwExtra = dwExtra;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\optionval.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    OPTIONVAL.INL

History:

--*/

inline
const CLString &
CLocOptionVal::GetName(void)
		const
{
	return m_strName;
}



inline
const CLocVariant &
CLocOptionVal::GetValue(void)
		const
{
	return m_lvValue;
}



inline
void
CLocOptionVal::SetName(
		const CLString &strName)
{
	m_strName = strName;
}



inline
void
CLocOptionVal::SetValue(
		const CLocVariant &lvValue)
{
	m_lvValue = lvValue;

	LTASSERTONLY(AssertValid());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\redvisit.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    REDVISIT.H

History:

--*/

#ifndef REDVISIT_H
#define REDVISIT_H

#include "diff.h"

class CRichEditCtrl;

class LTAPIENTRY CRichEditDeltaVisitor : public CDeltaVisitor
{
public:
	CRichEditDeltaVisitor(CRichEditCtrl & red);
	virtual void VisitDifference(const CDifference & diff) const; 

private: 
	CRichEditCtrl & m_red;
};


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "redvisit.inl"
#endif

#endif  //  REDVISIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\redvisit.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    REDVISIT.INL

History:

--*/

inline
CRichEditDeltaVisitor::CRichEditDeltaVisitor(
	CRichEditCtrl & red) :
	m_red(red)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\passtr.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PASSTR.INL

History:

--*/

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Default constructor for a Pascal string.  Sets the length to zero, with
//  no storage.
//  
//-----------------------------------------------------------------------------
inline
CPascalString::CPascalString()
{
	//
	//  The string data class is initialized by it's constructor.
	//
	LTASSERT(m_blbData.GetBlobSize() == 0);

	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Casting operator to convert a CPascalString to a blob.
//  
//-----------------------------------------------------------------------------
inline
CPascalString::operator const CLocCOWBlob &(void)
		const
{
	return m_blbData;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator - CPascalString to CPascalString.  
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &                     // Allows a=b=c;
CPascalString::operator=(
		const CPascalString &pstrSource)  // Source string
{
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
	m_blbData = ((const CLocCOWBlob &)pstrSource);
	DEBUGONLY(m_StorageCounter += m_blbData.GetBlobSize());
	return *this;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Copy constructor for CPascalString's
//  
//-----------------------------------------------------------------------------
inline
CPascalString::CPascalString(
		const CPascalString &pstrSource)
{
	LTASSERT(pstrSource.m_blbData.GetWriteCount() == 0);
	 
	operator=(pstrSource);

	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator - Wide character C String to CPascalString.  The string
//  is COPIED into the CPascalString.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &             //  Allows a=b=c;
CPascalString::operator=(
		const WCHAR *wszSource)   //  Source, zero terminated string
{
	SetString(wszSource, wcslen(wszSource));

	return *this;
}





//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Appends a CPascalString to the current string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &			        // Allows a=b+=c syntax
CPascalString::operator+=(
		const CPascalString &pstrTail)	// Pascal string to append
{
	AppendBuffer(pstrTail, pstrTail.GetStringLength());
	
	return *this;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Append a NUL terminated Unicode string to a Pascal string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Allows a-b+=L"Hi There" syntax
CPascalString::operator+=(
		const WCHAR *szTail)			// NUL terminated string to append
{
	AppendBuffer(szTail, wcslen(szTail));
	return *this;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Append a Unicode character to a Pascal string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Allows a-b+=L"Hi There" syntax
CPascalString::operator+=(
		const WCHAR wch)			// WCHAR to append
{
	AppendBuffer(&wch, 1);
	return *this;
}



//-----------------------------------------------------------------------------
//  
//  Comparison function for Pascal strings.
//  
//-----------------------------------------------------------------------------
inline
BOOL                                                // TRUE (1) if the same
CPascalString::IsEqualTo(
		const CPascalString &pstrOtherString) const // String to compare to
{
	return m_blbData == (const CLocCOWBlob &)pstrOtherString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator == version of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int								              // TRUE (1) if equal
CPascalString::operator==(
		const CPascalString &pstrOtherString) // String to compare
		const
{
	return IsEqualTo(pstrOtherString);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator != - just the negative of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int                                                 // TRUE (1) if *not* equal
CPascalString::operator!=(
		const CPascalString &pstrOtherString) const // String to compare
{

	return !IsEqualTo(pstrOtherString);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparison operator for NUL terminated WCHAR strings.
//  
//-----------------------------------------------------------------------------
inline
int
CPascalString::operator==(
		const WCHAR *pwch)
		const
{
	return (wcscmp(*this, pwch) == 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparison operator for NUL termninated WCHAR strings.
//  
//-----------------------------------------------------------------------------
inline int
CPascalString::operator!=(
		const WCHAR *pwch)
		const
{
	return (wcscmp(*this, pwch) != 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is there anything in the string?  This is different from a string of zero
//  length.
//  
//-----------------------------------------------------------------------------
inline
BOOL
CPascalString::IsNull(void)
		const
{
	return ((const void *)m_blbData == NULL);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the length of the pascal string.  If the length is zero, there may be
//  no storage associated with the string.  Use IsNull to check for storage.
//  
//-----------------------------------------------------------------------------
inline
UINT                                         // length of the string.
CPascalString::GetStringLength(void) const
{
	UINT uiBufferSize;

	uiBufferSize = m_blbData.GetBlobSize();
	LTASSERT((uiBufferSize % sizeof(WCHAR)) == 0);
	
	return (uiBufferSize != 0 ? (uiBufferSize/sizeof(WCHAR)-1): 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Set the length of the pascal string.  String contents are not preserved
//  
//-----------------------------------------------------------------------------
inline
void                                         // length of the string.
CPascalString::SetStringLength(UINT uNewSize)
{
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
	m_blbData.SetBlobSize((uNewSize + 1) * sizeof(WCHAR));
	DEBUGONLY(m_StorageCounter += m_blbData.GetBlobSize());
	*(GetStringPointer() + uNewSize) = L'\0';
	ReleaseStringPointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Realloc a string - set true size
//  
//-----------------------------------------------------------------------------
inline
void                                         // length of the string.
CPascalString::ReallocString(UINT uNewSize)
{
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
	m_blbData.ReallocBlob((uNewSize +  1) * sizeof(WCHAR));
	DEBUGONLY(m_StorageCounter += m_blbData.GetBlobSize());
	*(GetStringPointer() + uNewSize) = L'\0';
	ReleaseStringPointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  As an optimization, the user can ask the Pascal string to reserve some
//  memory for future growth.  This would allow incremental additions to be
//  very efficent.  The reported size of the string is not changed - only the
//  amount of storage reserved for the string.
//
//  If the user requests less space than is already allocated, nothing
//  happens.
//
//-----------------------------------------------------------------------------
inline
void
CPascalString::ReserveStorage(
		UINT nMinSize)					// Size (in chars) to reserve for
{
	if (nMinSize > GetStringLength())
	{
		UINT uiCurSize;

		uiCurSize = GetStringLength();
		ReallocString(nMinSize);
		ReallocString(uiCurSize);
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get a pointer to the storage for the string.  This may be NULL if the
//  string has length 0.  This pointer should be considered INVALID if any
//  other assignment operation is performed on the Pascal string.  Calling
//  this dis-ables teh COW behavior of the CPascalString.
//  
//-----------------------------------------------------------------------------
inline
WCHAR *
CPascalString::GetStringPointer(void)
{
	return (WCHAR *)m_blbData.GetPointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Anytime you do a GetStringPointer, use ReleaseStringPointer to allow
//  the PascalString to revert to COW behavior.  Once you call this, the
//  pointer from GetStringPointer is INVALID.
//  
//-----------------------------------------------------------------------------
inline
void
CPascalString::ReleaseStringPointer(void)
{
	m_blbData.ReleasePointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Casting operator version of GetString pointer.  Cast a CPascalString to
//  const WCHAR *, and you get a pointer to the string.
//  
//-----------------------------------------------------------------------------
inline
CPascalString::operator const WCHAR *(void) const
{
	return (const WCHAR *)(const void *)(m_blbData);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Cleanup on the string.  Sets the length to zero, and remove all storage.
//  This is different than assigning a NULL string - that is a string of
//  length 1, consisting of the NUL (zero) character.
//  
//-----------------------------------------------------------------------------
inline
void
CPascalString::ClearString(void)
{
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
	m_blbData.SetBlobSize(0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Destructor for a Pascal string.  Frees up the current storage.  After
//  a Pascal string goes out of scope, all pointers to the internal storage
//  are invalid.
//  
//-----------------------------------------------------------------------------
inline
CPascalString::~CPascalString()
{
	LTASSERTONLY(AssertValid());
	DEBUGONLY(--m_UsageCounter);
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Serialize for a Pascal string.
//  
//-----------------------------------------------------------------------------
inline
void CPascalString::Serialize(CArchive &ar)
{
	if (ar.IsStoring())
	{
		Store(ar);
	}
	else
	{
		Load(ar);
	}
}



inline
void
CPascalString::Store(
		CArchive &ar)
		const
{
	LTASSERT(ar.IsStoring());
	LTASSERTONLY(AssertValid());

	//
	//  HACK HACK HACK
	//  Emulate Old Espresso 3.0 serialization.
	m_blbData.Store(ar);
	
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Helper function - comparison operator for a NUL terminated WCHAR string
//  and a CPascalString.
//  
//-----------------------------------------------------------------------------
inline
int
operator==(
		const WCHAR *pwch,
		const CPascalString &pstr)
{
	return (wcscmp(pwch, pstr) == 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Helper function - comparison operator for a NUL terminated WCHAR string
//  and a CPascalString.
//  
//-----------------------------------------------------------------------------
inline
int
operator!=(
		const WCHAR *pwch,
		const CPascalString &pstr)
{
	return (wcscmp(pwch, pstr) != 0);
}



inline
int CPascalString::operator!=(
		const _bstr_t &bsOther)
		const
{
	return !(operator==(bsOther));
}



inline
int
operator==(
		const _bstr_t &bsOther,
		const CPascalString &pstr)
{
	return pstr == bsOther;
}



inline
int
operator!=(
		const _bstr_t &bsOther,
		const CPascalString &pstr)
{
	return pstr != bsOther;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\path.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PATH.H

History:

--*/


#ifndef __PATH_H__
#define __PATH_H__

#ifndef _INC_DIRECT
#include <direct.h>
#endif

#ifndef _INC_IO
#include <io.h>
#endif

#ifndef _INC_TCHAR
#include <tchar.h>
#endif

#ifndef _WIN32
#include <ctype.h>
#endif

#ifndef _INC_STAT
#include <stat.h>
#endif

#pragma warning(disable : 4275 4251)


size_t RemoveNewlines(_TCHAR *);

//
// Compatible_GetFileAttributesEx
// g_pGetFileAttributesEx initially points to a function that chooses the new win32 api,
// GetFileAttributesEx if supported, or selects a compatible function that uses FindFirstFile.
//
extern BOOL AFX_DATA (WINAPI *g_pGetFileAttributesEx)( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation);
__inline BOOL Compatible_GetFileAttributesEx( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation)
{
	return (*g_pGetFileAttributesEx)( lpFileName, fInfoLevelId, lpFileInformation);
}


//////////////////////////////////////////////////////////////////////
// Classes defined in this file

// CObject
	class CPath;
	class CDir;
//////////////////////////////////////////////////////////////////////
// Scan a path in see if it contains special charaters that would
// required it to be quoted:
BOOL ScanPathForSpecialCharacters (const TCHAR *pPath);
//////////////////////////////////////////////////////////////////////
// CPath
class LTAPIENTRY CPath : public CObject
{
	DECLARE_DYNAMIC(CPath)

	friend	class		CDir;

	friend	static VOID		ConstructElement(CPath *);
	friend	static VOID		DestructElement(CPath *);

protected:
	// Data
			CString		m_strCanon;
			int		m_ichLastSlash;	// used to quickly extract only dir or filename
			BOOL		m_Flags;
			enum	PathFlags
				{
					eIsActualCase = 1,
					eWantsRelative = 2,
				};
				// Canonicalized representation of pathname.
			static CMapStringToString c_DirCaseMap;
public:
	// Constructors, destructors, initialization methods
	inline				CPath() { m_ichLastSlash = -1; m_Flags = 0;}
	inline				CPath(const CPath & path)
							 {
								 m_strCanon = path.m_strCanon;
								 m_ichLastSlash = path.m_ichLastSlash;
								 m_Flags = path.m_Flags;
							 }
	virtual				~CPath();

	inline	BOOL		GetAlwaysRelative() const { return ((m_Flags & eWantsRelative) != 0); }
	inline	void		SetAlwaysRelative(BOOL bWantsRel = TRUE) { m_Flags =
			(bWantsRel) ? m_Flags | eWantsRelative : m_Flags & ~eWantsRelative;}

	inline	BOOL		IsInit() const { ASSERT(this!=NULL); return (m_ichLastSlash > 0); }

			BOOL		Create(const TCHAR *);
				// Initialize the object, given a filename.  The resulting
				// canonicalized filename will be relative to the current
				// directory.  For example, if the current directory is
				// C:\TEST and the argument is "FOO.C", the resulting
				// canonicalized filename will be "C:\TEST\FOO.C".  If the
				// argument is "..\FOO.C", the resulting canonicalized
				// filename will be "C:\FOO.C".

			BOOL		CreateFromDirAndFilename(const CDir &, const TCHAR *);
				// Initialize the object given a directory (CDir object) and
				// a filename.  This behaves exactly the same as the Create()
				// method, except that the Create() method canonicalizes the
				// filename relative to the CURRENT directory, whereas this
				// method canonicalizes the filename relative to the SPECIFIED
				// directory.

			BOOL		CreateTemporaryName(const CDir &, BOOL fKeep = TRUE);
				// Initialize the object given a directory.  The resulting
				// object will represent a UNIQUE filename in that directory.
				// This is useful for creating temporary filenames.
				//
				// WARNING
				// -------
				// After this method returns, the filename represented by this
				// object will EXIST ON DISK as a zero length file.  This is
				// to prevent subsequent calls to this method from returning
				// the same filename (this method checks to make sure it
				// doesn't return the name of an existing file).  IT IS YOUR
				// RESPONSIBILITY to delete the file one way or another.
				//
				// If you don't want this behavior, pass FALSE for 'fKeep',
				// and the file will not exist on disk.  Be aware, though,
				// that if you do this, subsequent calls to this method may
				// return the same filename.

			BOOL		ContainsSpecialCharacters () const
						{
							return ::ScanPathForSpecialCharacters(m_strCanon);
						}
				// Scan the pathname for special character.  We cache this
				// information.

	inline  CPath &		operator =(const CPath & path)
						{
							ASSERT(path.IsInit());
							m_strCanon = path.m_strCanon;
							m_ichLastSlash = path.m_ichLastSlash;
							m_Flags = path.m_Flags;
							return(*this);
						}
				// Assignment operator.

	// Query methods
	inline	const TCHAR * GetFileName() const
					{
						ASSERT(IsInit());
						ASSERT(m_ichLastSlash==m_strCanon.ReverseFind('\\'));
						return ((const TCHAR *)m_strCanon + m_ichLastSlash + 1);
					}

				// Return a pointer to the filename part of the canonicalized
				// pathname, i.e., the filename with no leading drive or path
				// information. Return whole string if no backslash (not init).
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!

			VOID		PostFixNumber();
				// Modifies the path by postfixing a number on the end of the path's
				// basename. If there is no number on the end of the path's basename
				// then the number 1 is postfixed. Otherwise if there already is a
				// number on the end of the path's basename then that number is
				// incremented by 1 and postfixed on the end of the basename (less the
				// original number).
				//
				// e.g. foo.cpp -> foo1.cpp -> foo2.cpp -> foo3.cpp
			
			VOID		GetBaseNameString(CString &) const;
				// Creates a CString representing the base name of the fully
				// canonicalized pathname.  For example, the base name of
				// the pathname "C:\FOO\BAR.C" is "BAR".
				//
				// This method can't return a pointer to internal data like
				// some of the other methods since it would have to remove
				// the extension in order to do so.

			VOID  		GetDisplayNameString(
										CString &,
										int cchMax = 16,
										BOOL bTakeAllAsDefault = FALSE
										) const;
				// Creates a CString representing the name of the file
				// shortened to cchMax CHARACTERS (TCHARs, not bytes) or
				// less.  Only the actual characters are counted; the
				// terminating '\0' is not considered, so
				// CString::GetLength() on the result MAY return as much as
				// cchMax.  If cchMax is less than the length of the base
				// filename, the resulting CString will be empty, unless
				// bTakeAllAsDefault is TRUE, in which the base name is
				// copied in, regardless of length.
				//
				// As an example, "C:\SOMEDIR\OTHERDIR\SUBDIR\SPECIAL\FOO.C"
				// will be shortened to "C:\...\SPECIAL\FOO.C" if cchMax is 25.

		inline	const TCHAR * GetExtension() const
					{
						ASSERT(IsInit());
						int iDot = m_strCanon.ReverseFind(_T('.'));
 						if (iDot < m_ichLastSlash)
							iDot = m_strCanon.GetLength();
						const TCHAR * retval = ((const TCHAR *)m_strCanon) + iDot;
 						return retval;
					}

				// Return a pointer to the extension part of the canonicalized
				// pathname.  Returns a pointer to the '.' character of the
				// extension.  If the filename doesn't have an extension,
				// the pointer returned will point to the terminating '\0'.
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!

	inline	const TCHAR * GetFullPath() const { return(m_strCanon); }
				// Return a pointer to the full (canonicalized) pathname.
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!
	inline	const TCHAR * GetFullPath(CString & strPath) const { return(strPath = m_strCanon); }

	inline	BOOL		IsActualCase() const { ASSERT(this!=NULL); return ((m_Flags & eIsActualCase)!=0); }
	void GetActualCase(BOOL bEntirePath = FALSE);
				// Adjusts the paths case to match the actual path and filename
				// on disk.
	void SetActualCase(LPCTSTR pszFileCase); 
				// Adjusts the paths case to match the actual path and filename
				// on disk, where pszFileCase already contains the correct case
				// for just the filename portion.
	static void ResetDirMap();

	inline				operator const TCHAR *() const { return(m_strCanon); }
				// Return the fully canonicalized filename as a (const TCHAR *).
				// Same thing as GetFullPath(), but more convenient in some
				// cases.
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!

	inline	BOOL		IsUNC() const { return(m_strCanon[0] == _T('\\')); }
				// Returns TRUE if the pathname is UNC (e.g.,
				// "\\server\share\file"), FALSE if not.

	inline BOOL IsEmpty() const { return (m_strCanon.IsEmpty()); }

	// Comparison methods

			int			operator ==(const CPath &) const;
				// Returns 1 if the two CPaths are identical, 0 if they are
				// different.

	inline	int			operator !=(const CPath & path) const { return(!(operator ==(path))); }
				// Returns 1 if the two CPaths are different, 0 if they are
				// identical.

	// Modification methods

			VOID		ChangeFileName(const TCHAR *);
				// Changes the file name to that specified by the
				// (const TCHAR *) argument.  The directory portion of the
				// pathname remains unchanged.  DO NOT pass in anything
				// other than a simple filename, i.e., do not pass in
				// anything with path modifiers.

			VOID		ChangeExtension(const TCHAR *);
				// Changes the extension of the pathname to be that specified
				// by the (const TCHAR *) argument.  The argument can either be
				// of the form ".EXT" or "EXT".  If the current pathname has
				// no extension, this is equivalent to adding the new extension.

			BOOL 		GetRelativeName (const CDir&, CString&, BOOL bQuote = FALSE, BOOL bIgnoreAlwaysRelative = FALSE) const;
				// Makes the path name relative to the supplied directory and
				// placed the result in strResult.  Function will only go
				// down from the supplied directy (no ..'s).  Returns TRUE if
				// relativization was successful, or FALSE if not (e.g. if
				// string doesn't start with ".\" or ..\ or at least \).
				//
				// Thus, if the base directory is c:\sushi\vcpp32:
				//
				//  s:\sushi\vcpp32\c\fmake.c => s:\sushi\vcpp32\c\fmake.c
				//  c:\sushi\vcpp32\c\fmake.c => .\fmake.c
				//  c:\dolftool\bin\cl.exe    => \dolftool\bin\cl.exe
				//	\\danwhite\tmp\test.cpp   => \\danwhite\tmp\test.cpp

				// Thus, if the base directory is \\danwhite\c$\sushi\vcpp32:
				//
				// \\danwhite\c$\dolftool\bin\cl.exe => \dolftool\bin\cl.exe
				// \\danwhite\tmp\test.cpp           => \\danwhite\tmp\test.cpp

				// If bQuote is true, then quotes are put around the relative
				// file name. (Useful for writing the filename out to a file)

				// If (!bIgnoreAlwaysRelative && GetAlwaysRelative()) is TRUE
				// and if the file is on the same drive we will ALWAYS
				// relativize it. Thus for the base dir c:\sushi\vcpp32
				//  c:\dolftool\bin\cl.exe    => ..\..\dolftool\bin\cl.exe

			BOOL        CreateFromDirAndRelative (const CDir&, const TCHAR *);
				// THIS FUNCTION IS OBSOLETE.  New code should use
				// CreateFromDirAndFilename().  The only difference between
				// that function and this one is that this one will
				// automatically remove quotes from around the relative
				// path name (if present).


	// Miscellaneous methods
	inline	BOOL		IsReadOnlyOnDisk() const
						{
							HANDLE	h;

							ASSERT(IsInit());
							h = CreateFile(m_strCanon, GENERIC_WRITE,
								FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL, NULL);

							if (h == INVALID_HANDLE_VALUE && GetLastError() != ERROR_FILE_NOT_FOUND)
								return TRUE;

							if (h != INVALID_HANDLE_VALUE)
								CloseHandle(h);

							return FALSE;
						}
				// Returns TRUE if the filename represented by this object
				// is read-only on disk, FALSE if not.  NOT guaranteed to
				// work in all circumstances -- for example, will not return
				// TRUE for a file on a floppy drive that has been write-
				// protected.  I don't know of any way to get this information
				// from NT (GetFileAttributes doesn't work; GetVolumeInformation
				// doesn't work; _access just calls GetFileAttributes; etc.).
				// This method WILL correctly detect:
				//		- Files marked as read-only
				//		- Files on read-only network drives

	inline	BOOL		ExistsOnDisk() const
						{
							ASSERT(IsInit());
							return(_access(m_strCanon, 00) != -1);
						}
				// Returns TRUE if the filename represented by this object
				// exists on disk, FALSE if not.

	inline	BOOL		CanCreateOnDisk(BOOL fOverwriteOK = FALSE) const
						{
							ASSERT(IsInit());
							if (!fOverwriteOK && ExistsOnDisk())
								return(FALSE);
							int hFile = _creat(m_strCanon, _S_IREAD | _S_IWRITE);
							BOOL fCreate = (hFile != -1);
							if (fCreate)
							{
								VERIFY(_close(hFile) == 0);
								VERIFY(_unlink(m_strCanon) == 0);
							}
							return(fCreate);
						}
				// Returns TRUE if the filename represented by this object
				// can be created on disk, FALSE if not.

	inline	BOOL		DeleteFromDisk() const
						{
							ASSERT(IsInit());
#ifdef _WIN32
							return(DeleteFile((TCHAR *)(const TCHAR *)m_strCanon));
#else
							return(remove(m_strCanon) != -1);
#endif
						}
				// Removes the file represented by this object from the disk.

	BOOL GetFileTime(LPFILETIME lpftLastWrite);
	BOOL GetFileTime(CString& rstrLastWrite, DWORD dwFlags = DATE_SHORTDATE);
	// Returns the last modified time, as either an FILETIME struct or a string
};
//	Creation and destruction functions used by CMapPathToOb:

extern const CString AFX_DATA pthEmptyString;

static inline VOID ConstructElement(CPath * pNewData)
{
	memcpy(&pNewData->m_strCanon, &pthEmptyString, sizeof(CString));
}

static inline VOID DestructElement(CPath * pOldData)
{
	pOldData->m_strCanon.Empty();
}


//	File Name Utility Functions
//		These are redundant and could be replaced with use of CPath, but are
//		kept since they are easier to use and already exist in VRES.

// Remove the drive and directory from a file name.
CString StripPath(LPCTSTR szFilePath);

// Remove the name part of a file path.  Return just the drive and directory.
CString StripName(LPCTSTR szFilePath);

// Get only the extension of a file path.
CString GetExtension(LPCTSTR szFilePath);

// Return the path to szFilePath relative to szDirectory.  (e.g. if szFilePath
// is "C:\FOO\BAR\CDR.CAR" and szDirectory is "C:\FOO", then "BAR\CDR.CAR"
// is returned.  This will never use '..'; if szFilePath is not in szDirectory
// or a sub-directory, then szFilePath is returned unchanged.
//
CString GetRelativeName(LPCTSTR szFilePath, LPCTSTR szDirectory = NULL);

// Makes a file path look like in MRU.
CString GetDisplayName(LPCTSTR szFilePath, int nMaxDisplayLength,
	LPCTSTR szDirectory = NULL);

BOOL FileExists(LPCTSTR szFilePath);
BOOL IsFileWritable(LPCTSTR szFilePath);

UINT SushiGetFileTitle(LPCTSTR lpszPathName, LPTSTR lpszTitle, UINT nMax);

//////////////////////////////////////////////////////////////////////
// CDir
//
// The CDir object represents a file system directory on some disk.
//
// A CDir object can be created to represent the current directory,
// to represent the directory of a CPath object (i.e., the directory
// in which a file resides), and to represent a temporary directory.
// Note that a CDir object CANNOT be created given an arbitrary string --
// this is intentional, since this should not be necessary.
//
// The string representation of a CDir object (e.g., operator const TCHAR *())
// MAY or MAY NOT end in '\'.  The root directory of a local drive (e.g., C:)
// will end in '\' ("C:\"), while other directories on a local drive will
// not ("C:\OTHERDIR").  The root directory on a REMOTE drive will NOT end
// in '\' ("\\server\share").  Don't make any assumptions about whether or
// not the string representation ends in '\'.
//
// See also several CPath methods which use CDir objects.

class LTAPIENTRY CDir : public CObject
{
	DECLARE_DYNAMIC(CDir)

	friend	class		CPath;

	friend	static VOID		ConstructElement(CDir *);
	friend	static VOID		DestructElement(CDir *);

protected:
			CString		m_strDir;
				// Directory name, including drive letter or
				// server/share.  Do NOT make any assumptions
				// about whether or not this ends in '\'!

			// Creates multi level directories just fine
			BOOL MakeDirectory(LPCTSTR lpszPathName) const;
public:
	// Constructors, destructors, initialization methods
	inline				CDir() {}
	inline				CDir(const CDir & dir) { m_strDir = dir.m_strDir; }
	virtual				~CDir();

			BOOL		CreateFromCurrent();
				// Initialize from the current working directory.  This
				// may fail if the current working directory is unknown
				// or invalid.

			BOOL		CreateFromPath(const CPath &);
				// Initialize based on the directory of the specified
				// CPath object.  That is, if the CPath object represents
				// the file "C:\FOO\BAR\BLIX.C", the resulting directory
				// for this object will be "C:\FOO\BAR".  Returns FALSE
				// on failure.

			BOOL		CreateFromPath(const TCHAR *pszPath);
				// Initialize based on the directory of the specified
				// string.  That is, if the string contains the file name
				// "C:\FOO\BAR\BLIX.C", the generated directory for this
				// string will be "C:\FOO\BAR".  Returns FALSE on failure.

			BOOL		CreateTemporaryName();
				// Initialize this object to represent a temporary directory
				// on disk (e.g., "C:\TMP").

			inline BOOL		CreateFromString(const TCHAR * sz)
					{
						return  CreateFromStringEx(sz, FALSE);
					}	
				// Create from a string (e.g., "C:\", "C:\TMP", etc.).  Please
				// do not use this method when another would suffice!

			BOOL		CreateFromStringEx(const TCHAR * sz, BOOL fRootRelative);
				// Create from a string (e.g., "C:\", "C:\TMP", etc.).  Please
				// do not use this method when another would suffice!
				// same as CreateFromString with minor change. Not treating as bug fix to CFS
				// due to lateness in VC 4.0 project time

				// if fRootRelative true, treat dir ending with colon as relative not root dir 
				// (actual correct handling)


			BOOL		ContainsSpecialCharacters () const
						{
							return ::ScanPathForSpecialCharacters(m_strDir);
						}
				// Scan the pathname for special character.  We cache this information.

	inline	CDir &		operator =(const CDir & dir)
						{
							m_strDir = dir.m_strDir;
							return(*this);
						}
				// Assignment operator.

	// Query methods

	inline				operator const TCHAR *() const { return(m_strDir); }
				// Return the directory name as a (const TCHAR *) string.

	inline int GetLength() const { return m_strDir.GetLength(); }
	      // Returns the length of the directory name

	// Miscellaneous methods

	BOOL	MakeCurrent() const;
				// Make this object the current working directory.  May fail
				// if the directory no longer exists (e.g., a floppy drive).

	inline	BOOL		ExistsOnDisk() const
						{
							// Tests if the directory exists.  We return FALSE
							// if <m_strDir> exists but is not a directory
							struct _stat statDir;
							if (_stat(m_strDir, &statDir) == -1)
								return FALSE;		 // Not found.
							else if (!(statDir.st_mode & _S_IFDIR))
								return FALSE;		 // Not a directory.
							else
								return TRUE;
						}
				// Returns TRUE if the directory represented by this object
				// exists on disk, FALSE if not.

	inline	BOOL		CreateOnDisk() const { return MakeDirectory(m_strDir); }
				// Creates the directory on disk.  If this fails, returns
				// FALSE.  If the directory already existed on disk, returns
				// TRUE (i.e., that is not an error condition).

	inline	BOOL		RemoveFromDisk() const { return RemoveDirectory(m_strDir); }
				// Removes the directory from the disk.  If this fails for
				// any reason (directory does not exist, directory is not
				// empty, etc.), returns FALSE.

			BOOL		IsRootDir() const;
				// Returns TRUE if the directory represented by this object
				// is a root directory (e.g., "C:\"), FALSE if not.  Note that
				// calling this method will NOT tell you whether or not the
				// string representation ends in '\', since "\\server\share"
				// is a root directory, and does not end in '\'.

	inline	BOOL		IsUNC() const { return(m_strDir[0] == _T('\\')); }
				// Returns TRUE if this is a UNC directory, FALSE if not.

			VOID		AppendSubdirName(const TCHAR *);
				// Adds a subdirectory name.  For example, if this object
				// currently represents "C:\FOO\BAR", and the argument is
				// "$AUTSAV$", the resulting object represents
				// "C:\FOO\BAR\$AUTSAV$".
				//
				// WARNING: This method does NO validation of the result --
				// it does not check for illegal characters, or for a
				// directory name that is too long.  In particular, don't
				// pass "DIR1/DIR2" as an argument, since no conversion
				// (of '/' to '\') will occur.

			VOID		RemoveLastSubdirName();
				// Removes the last component of the directory name.  For
				// example, if this object currently represents
				// "C:\FOO\BAR\$AUTSAV$", after this method it will
				// represent "C:\FOO\BAR".  If you try to call this method
				// when the object represents a root directory (e.g., "C:\"),
				// it will ASSERT.

	// Comparison methods

			int			operator ==(const CDir &) const;
				// Returns 1 if the two CDirs are identical, 0 if they are
				// different.

	inline	int			operator !=(const CDir & dir) const { return(!(operator ==(dir))); }
				// Returns 1 if the two CDirs are different, 0 if they are
				// identical.
};

//	Creation and destruction functions used by CMapDirToOb:

static inline VOID ConstructElement(CDir * pNewData)
{
	memcpy(&pNewData->m_strDir, &pthEmptyString, sizeof(CString));
}

static inline VOID DestructElement(CDir * pOldData)
{
	pOldData->m_strDir.Empty();
}

///////////////////////////////////////////////////////////////////////////////
//	CCurDir
//		This class is used to switch the current drive/directory during the
//		life of the object and to restore the previous dirve/directory upon
//		destruction.

class LTAPIENTRY CCurDir : CDir
{
public:
	CCurDir(const char* szPath, BOOL bFile = FALSE);
	CCurDir(const CDir& dir);
	CCurDir();	// just saves the current directory and resets it
	~CCurDir();

	CDir m_dir;
};


///////////////////////////////////////////////////////////////////////////////
//	CFileOpenReturn
//		This class represents the return value from the Common Dialogs
//		File.Open.  It handles both single and multiple select types.
//

class LTAPIENTRY CFileOpenReturn : CObject
{
	BOOL		m_bSingle;
	BOOL		m_bBufferInUse;
	BOOL		m_bArrayHasChanged;

	int			m_cbData;
	_TCHAR * 	m_pchData;

	// Multiple Files
	CPtrArray	m_rgszNames;

public:
	CFileOpenReturn (const _TCHAR * szRawString = NULL);
	~CFileOpenReturn ();

	inline BOOL IsSingle () const;
	inline BOOL IsDirty() const;
	inline BOOL BufferOverflow () const;
	//inline int  GetLength () const;

	// GetBuffer gives permission for something else to directly change the buffer
	// ReleaseBuffer signifies that the something else is done with it.
	_TCHAR * GetBuffer (int cbBufferNew);
	inline void ReleaseBuffer ();

	// allows the object to be re-initialized
	void ReInit (const _TCHAR * szRawString);

	// This supports the dynamic file extension update in OnFileNameOK().
	void ChangeExtension (int i, const CString& szExt);

	void CopyBuffer (_TCHAR * szTarget);

	// This is the function to use to get at the user's selections,
	// whether single or multiple.
	BOOL GetPathname (int i, CString& strPath) const;

private:
	void GenArrayFromBuffer ();
	void GenBufferFromArray ();
	void ClearNamesArray ();
	void SetBuffer (const _TCHAR * szRawString);	
};


inline BOOL CFileOpenReturn::IsSingle () const
{
	return m_bSingle;
}

inline BOOL CFileOpenReturn::IsDirty() const
{
	return m_bArrayHasChanged;
}

inline BOOL CFileOpenReturn::BufferOverflow () const
{
	return m_cbData == 2 && m_pchData[0] == '?';
}

///// ReleaseBuffer - Tell object we're done changing the buffer
//
//	Processes the raw string
//
///
inline void CFileOpenReturn::ReleaseBuffer ()
{
	m_bBufferInUse = FALSE;
	GenArrayFromBuffer ();
}

///////////////////////////////////////////////////////////////////////////////
//	Smart case helpers.
//		These functions are used to do smart casing of paths and file extensions.

extern BOOL GetActualFileCase( CString& rFilename, LPCTSTR lpszDir = NULL );
extern LPCTSTR GetExtensionCase( LPCTSTR lpszFilename, LPCTSTR lpszExtension );

extern BOOL GetDisplayFile(CString &rFilename, CDC *pDC, int &cxPels); // truncates from left

/////////////////////////////////////////////////////////////////////////////
#pragma warning(default : 4275 4251)

#endif // __PATH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\refcount.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    REFCOUNT.H

History:

--*/

#pragma once



class LTAPIENTRY CRefCount
{
public:
	CRefCount();

	//
	//  Declared as STDMETHOD so as compatible with COM.
	//
	STDMETHOD_(ULONG, AddRef)(void);
	STDMETHOD_(ULONG, Release)(void);

	//
	//
	ULONG AddRef(void) const;
	ULONG Release(void) const;
	
protected:
	
	virtual ~CRefCount() = 0;

private:

	CRefCount(const CRefCount &);
	const CRefCount & operator=(const CRefCount &);
	UINT operator==(const CRefCount &);
	
	mutable UINT m_uiRefCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\smartptr.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    SMARTPTR.H

History:

--*/


#ifndef ESPUTIL_SMARTPTR_H
#define ESPUTIL_SMARTPTR_H



template<class T>
class SmartPtr
{
public:
	NOTHROW SmartPtr();
	NOTHROW SmartPtr(T *);

	NOTHROW T & operator*(void) const;
	NOTHROW T * operator->(void) const;
	NOTHROW T* Extract(void);
	NOTHROW T* GetPointer(void);
	NOTHROW const T * GetPointer(void) const;
	NOTHROW BOOL IsNull(void) const;
	
	void operator=(T *);
	operator T* &(void);

	NOTHROW ~SmartPtr();
	
private:
	T *m_pObject;

	SmartPtr(const SmartPtr<T> &);
	void operator=(const SmartPtr<T> &);
	
	//
	//  This hackery prevents Smart Pointer from being on the heap
	//
	void operator delete(void *);
};

#include "smartptr.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\resource.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    RESOURCE.H

History:

--*/
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mitutil.rc
//
#define IDS_BAD_UNICODE_CHAR            12700
#define IDS_BAD_CODE_PAGE               12701
#define IDS_UIVAL_ON                    12702
#define IDS_UIVAL_OFF                   12703
#define IDS_UIVAL_TRUE                  12704
#define IDS_UIVAL_FALSE                 12705
#define IDS_UIVAL_YES                   12706
#define IDS_UIVAL_NO                    12707
#define IDS_UIVAL_BLOB                  12708
#define IDS_HEX_MUST_BE_4DIGITS         12709
#define IDS_INVALID_ESCAPE              12710

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\passtr.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PASSTR.H

History:

--*/

//  Declaration for a pascal (counted) style wide character string class.
//  The count reflects the number of characters (including NUL characters),
//  not the amount of storage.  Any string in a PascalString is automatically
//  given a NULL terminator, even if it already has one.  This extra terminator
//  is NOT in the count of characters in the string.
//  
 
#ifndef PASSTR_H
#define PASSTR_H


class _bstr_t;

class CUnicodeException : public CSimpleException
{
public:
	enum UnicodeCause
	{
		noCause = 0,
		invalidChar = 1,
		unknownCodePage
	};

	UnicodeCause m_cause;

	NOTHROW CUnicodeException(UnicodeCause);
	NOTHROW CUnicodeException(UnicodeCause, BOOL);
	
	NOTHROW ~CUnicodeException();

	virtual BOOL GetErrorMessage(LPTSTR lpszError, UINT nMaxError, 
		PUINT pnHelpContext = NULL );
};


void LTAPIENTRY ThrowUnicodeException(CUnicodeException::UnicodeCause);


class LTAPIENTRY CPascalString
{
public:
	NOTHROW CPascalString();
	NOTHROW CPascalString(const CPascalString &);

	void AssertValid(void) const;

	//
	//  The ultimate assignment operator - any random collection
	//  of WIDE characters can be placed in the string.
	//  Also, we can convert any collection of DBCS style strings,
	//  so long as the user provides a code page to work with...
	//
	void SetString(const WCHAR *, UINT);
	void SetString(const char *, UINT, CodePage);
	void SetString(const CLString &, CodePage);
	
	//
	//  Useful assignment operators
	//
	const CPascalString & operator=(const CPascalString &);
	const CPascalString & operator=(const WCHAR *);
	const CPascalString & operator=(const _bstr_t &);
	
	const CPascalString & operator+=(const CPascalString &);
	const CPascalString & operator+=(const WCHAR *);
	const CPascalString & operator+=(const WCHAR);

	void Format(const WCHAR *, ...);

	//
	//  Comparison operators for counted strings.
	//
	NOTHROW int operator==(const CPascalString &) const;
	NOTHROW int operator!=(const CPascalString &) const;

	NOTHROW int operator==(const _bstr_t &) const;
	NOTHROW int operator!=(const _bstr_t &) const;

	NOTHROW int operator==(const WCHAR *) const;
	NOTHROW int operator!=(const WCHAR *) const;
	
	NOTHROW BOOL IsNull(void) const;

	//
	//  Retrieving the data from the string.
	//
	NOTHROW UINT GetStringLength(void) const;
	void SetStringLength(UINT);
	void ReallocString(UINT);
	void ReserveStorage(UINT);

	NOTHROW WCHAR * GetStringPointer(void);
	NOTHROW void ReleaseStringPointer(void);

	NOTHROW operator const WCHAR *(void) const;
	// const BSTR GetBSTR(void) const;

	NOTHROW WCHAR operator[](UINT) const;
	NOTHROW WCHAR & operator[](UINT);

	//
	//  Sub-string extraction
	//
	NOTHROW void Left(CPascalString &, UINT) const;
	NOTHROW void Right(CPascalString &, UINT) const;
	NOTHROW void Mid(CPascalString &, UINT) const;
	NOTHROW void Mid(CPascalString &, UINT, UINT) const;

	//
	//  Locate
	//
	NOTHROW BOOL Find(WCHAR, UINT, UINT &) const;
	NOTHROW BOOL FindOneOf(const CPascalString&, UINT, UINT &) const;
	NOTHROW BOOL FindExcept(const CPascalString &, UINT, UINT &) const;
	NOTHROW BOOL FindSubString(const CPascalString &, UINT, UINT &) const;
	
	NOTHROW BOOL ReverseFind(WCHAR, UINT, UINT &) const;
	NOTHROW BOOL ReverseFindOneOf(const CPascalString &, UINT, UINT &) const;
	NOTHROW BOOL ReverseFindExcept(const CPascalString &, UINT, UINT &) const;
	
	//
	//  Clears the contents of a Pascal string.
	//
	NOTHROW void ClearString(void);

	//
	//  Conversion API's for Pascal style strings.
	//
	enum ConvFlags 
	{
		ConvNoFlags = 0,					// No conversion options
		HexifyDefaultChars = 0x01,			// Hexify chars that convert to the default char
		HexifyNonPrintingChars = 0x02,
		HexifyWhiteSpace = 0x04,
		ConvAddNull = 0x08,
		ConvAllFlags = 0xFF
	};
	
	void ConvertToCLString(CLString &, CodePage, BOOL fHex=FALSE) const;
	void ConvertToMBCSBlob(CLocCOWBlob &, CodePage, DWORD dwFlags = ConvNoFlags) const;
	NOTHROW void MakeUpper(void);
	NOTHROW void MakeLower(void);
	_bstr_t MakeBSTRT() const;
	
	void Serialize(CArchive &ar);
	void Load(CArchive &ar);
	void Store(CArchive &ar) const;
	
	static const char *szUnmappableChar;
	static char cHexLeaderChar;
	
 	static void EscapeBackSlash(const CPascalString &srcStr, 
		CPascalString &destStr);

	int ParseEscapeSequences(CPascalString &pasError);
	
	~CPascalString();
 
protected:
	NOTHROW BOOL IsEqualTo(const CPascalString &) const;
	NOTHROW void AppendBuffer(const WCHAR *, UINT);
	
private:
	void FormatV(const WCHAR *, va_list arglist);
	
	CLocCOWBlob m_blbData;
	operator const CLocCOWBlob &(void) const;

	DEBUGONLY(static CCounter m_UsageCounter);
	DEBUGONLY(static CCounter m_StorageCounter);
};

typedef CArray<CPascalString, CPascalString &> CPasStringArray;
	
//
//  Comparison helper functions.  These should all have the
//  CPascalString as the SECOND arguement.
//
NOTHROW int LTAPIENTRY operator==(const WCHAR *, const CPascalString &);
NOTHROW int LTAPIENTRY operator!=(const WCHAR *, const CPascalString &);

NOTHROW int LTAPIENTRY operator==(const _bstr_t &, const CPascalString &);
NOTHROW int LTAPIENTRY operator!=(const _bstr_t, const CPascalString &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "passtr.inl"
#endif

#endif  //  PASSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\reghelp.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    REGHELP.H

History:

--*/

#if !defined(MITUTIL_RegHelp_h_INCLUDED)
#define MITUTIL_RegHelp_h_INCLUDED

#pragma once

//------------------------------------------------------------------------------
class LTAPIENTRY CRegHelp
{
public:
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, CString & stValue);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, DWORD & dwNum);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, long & nNum);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, BOOL & fNum);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, VARIANT_BOOL & fNum);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, GUID & guid);
};

#endif // MITUTIL_RegHelp_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\smartref.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    SMARTREF.H

History:

--*/
#ifndef ESPUTIL_SmartRef_H
#define ESPUTIL_SmartRef_H


template<class T>
class SmartRef
{
private:
	T *m_pInterface;

public:
	NOTHROW SmartRef()
	{
		m_pInterface = NULL;
	}

	//  Compiler bug, must be inline!
	NOTHROW SmartRef(T *pI) {m_pInterface = pI;};
	NOTHROW SmartRef(const SmartRef<T> &);

	NOTHROW T * operator->(void)
	{
		LTASSERT(m_pInterface != NULL);
		return m_pInterface;
	}
	
	NOTHROW const T * operator->(void) const
	{
		LTASSERT(m_pInterface != NULL);
		return m_pInterface;
	}
	
	NOTHROW T & operator*(void)
	{
		LTASSERT(m_pInterface != NULL);
		return *m_pInterface;
	}
	NOTHROW T * Extract(void)
	{
		return ExtractImpl();
	};
	
	NOTHROW T * GetInterface(BOOL fAddRef = FALSE)	
	{
		return GetInterfaceImpl(fAddRef);
	};

	NOTHROW const T * GetInterface(void) const
	{
		return m_pInterface;
	}
	
	NOTHROW BOOL IsNull(void) const
	{
		return m_pInterface == NULL;
	}
	
	NOTHROW ~SmartRef()
	{
		if (m_pInterface != NULL)
		{
			m_pInterface->Release();
		}
	}

	void operator=(T* pOther)
	{
		opEqImpl(pOther);
	}
	void operator=(const SmartRef<T> &other);

	T ** operator&(void);
	operator T* &(void) {return opTpRef();};
	
private:
	void operator delete(void *);

	NOTHROW T * ExtractImpl(void);
	NOTHROW T * GetInterfaceImpl(BOOL fAddRef);
	NOTHROW T * & opTpRef(void);
	void opEqImpl(T* pOther);

};

#include "SmartRef.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\stacktrace.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STACKTRACE.H

History:

--*/

//  
//  Provides a mechanism for generating stacktraces and converting them to
//  human readable form.
//  
 
#ifndef ESPUTIL_STACKTRACE_H
#define ESPUTIL_STACKTRACE_H


const UINT MODULE_NAME_LEN = 64;
const UINT SYMBOL_NAME_LEN = 128;


//
//  'human readable' form of a stack-frame.  Provides module and function name.
struct SYMBOL_INFO1
{
	DWORD dwAddress;
	DWORD dwOffset;
    TCHAR szModule[MODULE_NAME_LEN];
    TCHAR szSymbol[SYMBOL_NAME_LEN];
	BOOL fSymbolLocated;
};

#pragma warning(disable:4275)

//
//  How we return a complete human readable stack walk.
//
class LTAPIENTRY CSymbolList : public CTypedPtrList<CPtrList, SYMBOL_INFO1 *>
{
public:
	CSymbolList();

	void Clear(void);
	~CSymbolList();

private:
	CSymbolList(const CSymbolList &);
	void operator=(const CSymbolList &);
};

#pragma warning(default:4275)	

//
//  Class for generating stack traces.  Provides both native (compact) data
//  (in case you want to store it for later), and a human (versbose) form.
//
#pragma warning(disable : 4251)
class LTAPIENTRY CStackTrace
{
public:
	CStackTrace();

	~CStackTrace();

	void CreateStackTrace(void);
	void CreateStackTrace(UINT nSkip, UINT nTotal);
	void SetAddresses(const CDWordArray &);
	
	const CDWordArray &GetAddresses(void) const;

	void GetSymbolList(CSymbolList &) const;
	
private:
	CStackTrace(const CStackTrace &);
	void operator=(const CStackTrace &);

	CDWordArray m_adwAddresses;
};
#pragma warning(default : 4251)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\smartptr.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    SMARTPTR.INL

History:

--*/

template <class T>
SmartPtr< T >::SmartPtr()
{
	m_pObject = NULL;
}



template <class T>
SmartPtr< T >::SmartPtr(
		T *pObject)
{
	m_pObject = pObject;
}



template <class T>
T &
SmartPtr< T >::operator*(void)
		const
{
	LTASSERT(m_pObject != NULL);
	return *m_pObject;
}



template <class T>
T *
SmartPtr< T >::operator->(void)
		const
{
	LTASSERT(m_pObject != NULL);
	
	return m_pObject;
}


template <class  T>
T *
SmartPtr< T >::Extract(void)
{
	T *pObj = m_pObject;
	m_pObject = NULL;

	return pObj;
}



template <class T>
T*
SmartPtr< T >::GetPointer(void)
{
	return m_pObject;
}


template <class T>
const T*
SmartPtr< T >::GetPointer(void) const
{
	return m_pObject;
}


template <class T>
BOOL
SmartPtr< T >::IsNull(void)
		const
{
	return m_pObject == NULL;
}



template <class T>
void
SmartPtr< T >::operator=(
		T *pObject)
{
	LTASSERT(m_pObject == NULL);

	if (m_pObject != NULL)
	{
		delete m_pObject;
	}
	m_pObject = pObject;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  This should only be used to init a smart pointer.
//  
//-----------------------------------------------------------------------------
template <class T>
SmartPtr< T >::operator T * & (void)
{
	LTASSERT(m_pObject == NULL);
	
	return m_pObject;
}


template <class T>
void
SmartPtr< T >::operator delete(
		void *)
{
	LTASSERT(m_pObject != NULL);

	delete m_pObject;
	m_pObject = NULL;
}



template <class T>
SmartPtr< T >::~SmartPtr()
{
	if (m_pObject != NULL)
	{
		delete m_pObject;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\stringblast.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STRINGBLAST.H

History:

--*/

#if !defined(MITUTIL__StringBlast_h__INCLUDED)
#define MITUTIL__StringBlast_h__INCLUDED

//------------------------------------------------------------------------------
struct LTAPIENTRY StringBlast
{
// Fast Win32 conversions
	static CLString MakeString(_bstr_t bstrSrc);
	static CLString MakeString(const CPascalString & pasSrc);
	static CLString MakeStringFromBStr(BSTR bstrSrc);
	static CLString MakeStringFromWide(const wchar_t * szwSrc);

	static _bstr_t MakeBStr(const char * szBuffer);
	static _bstr_t MakeBStrFromWide(const wchar_t * wszBuffer);
	static _bstr_t MakeBStr(const CLString & stSrc);
	static _bstr_t MakeBStrFromBStr(BSTR bstrSrc);
	static _bstr_t MakeBStr(const CPascalString & pasSrc);
	static _bstr_t MakeBStr(HINSTANCE hDll, UINT nStringID);

	// Use these functions when you need to get a raw BSTR
	static BSTR MakeDetachedBStr(const char * szBuffer);
	static BSTR MakeDetachedBStrFromWide(const wchar_t * wszBuffer);
	static BSTR MakeDetachedBStr(const CLString & stSrc);

};

#endif // MITUTIL__StringBlast_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\smartref.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    SMARTREF.INL

History:

--*/

template <class T>
SmartRef< T >::SmartRef(
		const SmartRef<T> &other)
{
	m_pInterface = const_cast<T *>(other.m_pInterface);
	m_pInterface->AddRef();
}



template <class T>
void
SmartRef< T >::operator=(
		const SmartRef<T> &pInterface)
{
	if (m_pInterface != NULL)
	{
		m_pInterface->Release();
	}
	m_pInterface = ((SmartRef<T> &)pInterface).GetInterface(TRUE);
}



template <class T>
T **
SmartRef< T >::operator&(void)
{
	if (m_pInterface != NULL)
	{
		m_pInterface->Release();
		m_pInterface = NULL;
	}

	return &m_pInterface;
}



template <class T>
T *
SmartRef< T >::ExtractImpl(void)
{
	T *pInterface = m_pInterface;
	m_pInterface = NULL;
	return pInterface;
}


template <class T>
T *
SmartRef< T >::GetInterfaceImpl(
	BOOL fAddRef /*= FALSE*/)
{
	// Should never ask to AddRef with a NULL pointer

	LTASSERT(!fAddRef || NULL != m_pInterface);

	if (fAddRef)
	{
		m_pInterface->AddRef();
	}

	return m_pInterface;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// 
// This should only be used to init a smart pointer.
// 
//-----------------------------------------------------------------------------
template <class T>
T * &
SmartRef< T >::opTpRef(void)
{
	LTASSERT(m_pInterface == NULL);
	
	return m_pInterface;
}


template <class T>
void
SmartRef< T >::opEqImpl(
		T *pOther)
{
	if (m_pInterface != NULL)
	{
		m_pInterface->Release();
	}
	m_pInterface = pOther;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\strlist.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STRLIST.H

History:

--*/
#ifndef ESPUTIL_STRLIST_H
#define ESPUTIL_STRLIST_H


const UINT NO_INDEX = (DWORD) -1;
	
template<class T>
class CLocThingList
{
	
public:
	NOTHROW CLocThingList();

	UINT NOTHROW GetIndex(void) const;
	const CArray<T, T&> &GetStringArray(void) const;
	BOOL NOTHROW AdditionsAllowed(void) const;

	void SetThingList(const CArray<T, T&> &);
	UINT AddThing(T &);
	void InsertThing(UINT idxInsert, T & tNew);
	BOOL DeleteThing(UINT);
	BOOL NOTHROW SetIndex(UINT);
	void NOTHROW SetAdditionsAllowed(BOOL);
	UINT GetSize();

	const CLocThingList<T> &operator=(const CLocThingList<T> &);
	int NOTHROW operator==(const CLocThingList<T> &) const;
	int NOTHROW operator!=(const CLocThingList<T> &) const;
	
	NOTHROW ~CLocThingList();

private:
	CLocThingList(const CLocThingList<T> &);

	UINT m_uiIndex;
	CArray<T, T&> m_aThings;
	BOOL m_fAdditionsAllowed;
};

#include "strlist.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\stringtokenizer.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STRINGTOKENIZER.H

History:

--*/

//
//  This file declares the CStringTokenizer class, which implements simple
//  linear tokenization of a String. The set of delimiters, which defaults
//  to common whitespace characters, may be specified at creation time or on a 
//  per-token basis.
//  Example usage:
//	CString s = "a test string";
//	CStringTokenizer st = new CStringTokenizer(s);
//	while (st.hasMoreTokens())
//  {
//		cout << st.nextToken() << endl;
//	}

#pragma once

#ifndef StringTokenizer_h
#define StringTokenizer_h

class LTAPIENTRY CStringTokenizer 
{
public:
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// constructs a tokenizer with default delimiters
//-----------------------------------------------------------------------------
  CStringTokenizer();
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// constructs a tokenizer with default delimiters
//   str - in, the string to be tokenized
//-----------------------------------------------------------------------------
  CStringTokenizer(const WCHAR* str);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// constructs a tokenizer
//   str - in, the string to be tokenized
//   delimiters - in, the delimiters; null terminated
//-----------------------------------------------------------------------------
  CStringTokenizer(const WCHAR* str, const WCHAR* delimiters);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// constructs a tokenizer
//   str - in, the string to be tokenized
//   delimiters - in, the delimiters; null terminated
//   returnTokens - in, TRUE indicates return delimiter as token
//-----------------------------------------------------------------------------
  CStringTokenizer(const WCHAR* str,
                   const WCHAR* delimiters,
                   BOOL  returnTokens);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// destructs this tokenizer
//-----------------------------------------------------------------------------
  virtual ~CStringTokenizer();

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// configure whether return delimiter as token
//   returnTokens - in, TRUE indicates return delimiter as token
//-----------------------------------------------------------------------------
  void setReturnTokens(BOOL returnTokens);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// sets delimiters
//   delimiters - in, the delimiters; null terminated
//-----------------------------------------------------------------------------
  void setDelimiters(const WCHAR* delimiters);

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// parse a string to be tokenized
//   str - in, the null terminated string
//-----------------------------------------------------------------------------
  void parse(const WCHAR* str);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// checks whether there are more tokens
//-----------------------------------------------------------------------------
  BOOL hasMoreTokens();

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// get next token
//   length - out, the length of the token
//   return the pointer to the begining of the token
//-----------------------------------------------------------------------------
  const WCHAR* nextToken(unsigned int & length);

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// count total number of tokens
//-----------------------------------------------------------------------------
  int     countTokens();

private:
  void skipDelimiters();
  int  IsDelimiter(WCHAR ch) const;

  int          m_currentPosition;
  int          m_maxPosition;
  const WCHAR* m_str;
  WCHAR*       m_delimiters;
  int          m_lenDelimiters;
  BOOL         m_retTokens;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\stdafx.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STDAFX.H

History:

--*/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__857ED3C1_A0BE_11D0_A6EB_00C04FC2C6D8__INCLUDED_)
#define AFX_STDAFX_H__857ED3C1_A0BE_11D0_A6EB_00C04FC2C6D8__INCLUDED_

#pragma once


// StrigBlast requires the CString implicit conversions.
#ifdef _LS_NO_IMPLICIT
#undef _LS_NO_IMPLICIT
#endif // #ifdef _LS_NO_IMPLICIT

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxtempl.h>
#include <afxdisp.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.


#endif // !defined(AFX_STDAFX_H__857ED3C1_A0BE_11D0_A6EB_00C04FC2C6D8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\strlist.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STRLIST.INL

History:

--*/

template <class T>
CLocThingList<T>::CLocThingList()
{
	m_fAdditionsAllowed = FALSE;
	m_uiIndex = NO_INDEX;
}


template <class T>
UINT
CLocThingList<T>::GetIndex(void)
		const
{
	return m_uiIndex;
}



template <class T>
const CArray<T, T&> &
CLocThingList<T>::GetStringArray(void)
		const
{
	return m_aThings;
}



template <class T>
BOOL
CLocThingList<T>::AdditionsAllowed(void)
		const
{
	return m_fAdditionsAllowed;
}



template <class T>
void
CLocThingList<T>::SetThingList(
		const CArray<T, T&> &aNewThings)
{
	UINT uiNewSize = aNewThings.GetSize();
	
	m_aThings.SetSize(uiNewSize);

	for (UINT i=0; i<uiNewSize; i++)
	{
		m_aThings[i] = aNewThings[i];
	}
}



template <class T>
inline
UINT
CLocThingList<T>::AddThing(
		T &NewThing)
{
	return m_aThings.Add(NewThing);
}


template <class T>
inline
void
CLocThingList<T>::InsertThing(
		UINT idxInsert, 
		T & tNew
		)
{
	m_aThings.InsertAt(idxInsert, tNew);
}


template <class T>
inline
BOOL
CLocThingList<T>::DeleteThing(
		UINT iIndex)
{
    BOOL fRetVal = FALSE;
	if (iIndex < GetSize())
	{
		m_aThings.RemoveAt(iIndex);
		fRetVal = TRUE;
	}
	return fRetVal;	
}



template <class T>
inline
BOOL
CLocThingList<T>::SetIndex(
		UINT uiNewIndex)
{
	m_uiIndex = uiNewIndex;
	return FALSE;
}



template <class T>
inline
void
CLocThingList<T>::SetAdditionsAllowed(
		BOOL fAllowed)
{
	m_fAdditionsAllowed = fAllowed;
}


template <class T>
inline
UINT
CLocThingList<T>::GetSize()
{
	return m_aThings.GetSize();
}


template <class T>
const CLocThingList<T> &
CLocThingList<T>::operator=(
		const CLocThingList<T>& slOther)
{
	SetThingList(slOther.GetStringArray());
	SetIndex(slOther.GetIndex());

	SetAdditionsAllowed(slOther.AdditionsAllowed());
	
	return *this;
}


template <class T>
CLocThingList<T>::~CLocThingList()
{
	m_aThings.SetSize(0);
}

template <class T>
inline
int 
CLocThingList<T>::operator==(
		const CLocThingList<T>& list)
		const
{
	if (m_uiIndex != list.m_uiIndex
		|| m_fAdditionsAllowed != list.m_fAdditionsAllowed
		|| m_aThings.GetSize() != list.m_aThings.GetSize())
	{
		return 0;
	}

	for (int i=m_aThings.GetUpperBound(); i>=0; i--)
	{
		if (m_aThings[i] != list.m_aThings[i])
		{
			return 0;
		}
	}
	
	return 1;
}

template <class T>
inline
int 
CLocThingList<T>::operator!=(
		const CLocThingList<T>& list)
		const
{
	return !(operator==(list));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\uioptions.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    UIOPTIONS.H

History:

--*/

#pragma once


class CReport;

#pragma warning(disable : 4251)

class LTAPIENTRY CLocUIOptionData
{
public:

	enum OptVal
	{
		ovCurrent,
		ovDefault,
		ovUser,
		ovOverride
	};
	
	CLocOptionVal *GetOptionValue(OptVal);

	CLocOptionVal *GetOptionValue(OptVal) const;
	
	void SetOptionValue(OptVal, CLocOptionVal *);
	BOOL Purge(void);
	
private:
	SmartRef<CLocOptionVal> m_spCurrentVal;
	SmartRef<CLocOptionVal> m_spUserVal;
	SmartRef<CLocOptionVal> m_spOverrideVal;
};


class CLocUIOptionSet;

class LTAPIENTRY CLocUIOption: public CLocOptionVal
{
public:
	CLocUIOption();

	void AssertValid(void) const;

	//
	//  New editor types should go at the END, so that old parsers
	//  can still use the ENUM without being re-compiled..
	//
	enum EditorType
	{
		etNone,
		etInteger,						// Maps to lvtInteger
		etUINT,							// Maps to lvtInteger
		etString,						// Maps to lvtString
		etFileName,						// Maps to lvtFileName
		etDirName,						// Maps to lvtString
		etStringList,					// Maps to lvtStringList
		etPickOne,						// Maps to lvtStringList
		etCheckBox,						// Maps to lvtBOOL
		etTrueFalse,					// Maps to lvtBOOL
		etYesNo,						// Maps to lvtBOOL
		etOnOff,						// Maps to lvtBOOL
		etCustom,						// Custom editor
	};

	//
	//  Used as bit flags to indicate where the option can be stored.
	enum StorageType
	{
		stUser = 0x0001,
		stOverride = 0x0002
	};

	enum OptionCode
	{
		ocNoError,
		ocUnknownOption,
		ocInvalidValue,
		ocInvalidType
	};

	void NOTHROW SetDescription(const HINSTANCE hDll, UINT nDescriptionID);
	void NOTHROW SetHelpText(const HINSTANCE hDll, UINT nHelpTextId);
	void NOTHROW SetEditor(EditorType);
	void NOTHROW SetStorageTypes(WORD);
	void NOTHROW SetDisplayOrder(UINT);
	
	void NOTHROW GetDescription(CLString &) const;
	void NOTHROW GetHelpText(CLString &) const;
	EditorType NOTHROW GetEditor(void) const;
	WORD NOTHROW GetStorageTypes(void) const;
	UINT NOTHROW GetDisplayOrder(void) const;
	CLocUIOptionData::OptVal GetOptionValLocation(void) const;
	
	virtual BOOL IsReadOnly(void) const = 0;
	virtual BOOL IsVisible(void) const = 0;
	virtual const CLString &GetGroupName(void) const = 0;
	virtual OptionCode ValidateOption(CReport *, 
		const CLocVariant& var) const = 0;
	virtual void FormatDisplayString(const CLocVariant& var, 
		CLString& strOut, BOOL fVerbose = FALSE) = 0;
	virtual void EditCustom(CWnd* pWndParent, CLocVariant& var) = 0;

protected:
	virtual ~CLocUIOption();

	friend class CLocUIOptionSet;
	friend class CLocOptionManager;
	friend class CUpdateOptionValCallback;
	
	void SetParent(CLocUIOptionSet *);
	const CLocUIOptionSet *GetParent(void) const;

	const CLocUIOptionData &GetOptionValues(void) const;
	CLocUIOptionData &GetOptionValues(void);
	
private:
	HINSTANCE m_hDescDll, m_hHelpDll;
	UINT m_idsDesc, m_idsHelp;
	EditorType m_etEditor;
	WORD m_wStorageTypes;
	UINT m_uiDisplayOrder;
	
	CLocUIOptionSet *m_pParent;
	CLocUIOptionData m_Values;
};


// Validate callback function
// This function will be called during the ValidateOption handling.

typedef CLocUIOption::OptionCode (*PFNOnValidateUIOption)
	(const CLocUIOption *pOption, CReport *pReport, const CLocVariant&);
 
class LTAPIENTRY CLocUIOptionDef : public CLocUIOption
{
public:
	CLocUIOptionDef();
	
	enum ControlType
	{
		ctDefault,
		ctAlways,
		ctNever
	};
	
	void SetReadOnly(ControlType);
	void SetVisible(ControlType);
	
	virtual BOOL IsReadOnly(void) const;
	virtual BOOL IsVisible(void) const;
	virtual const CLString &GetGroupName(void) const;
	virtual OptionCode ValidateOption(CReport *, 
		const CLocVariant& var) const;
	virtual void FormatDisplayString(const CLocVariant& var, 
		CLString& strOut, BOOL fVerbose = FALSE);
	virtual void EditCustom(CWnd* pWndParent, CLocVariant& var);

	void SetValidationFunction(PFNOnValidateUIOption);
	
private:
	ControlType m_ctReadOnly;
	ControlType m_ctVisible;
	PFNOnValidateUIOption m_pfnValidate;
};

	

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocUIOptionList :
	public CTypedPtrList<CPtrList, CLocUIOption *>
{
public:
	NOTHROW CLocUIOptionList();

	void AssertValid(void) const;

	NOTHROW ~CLocUIOptionList();
 
private:
	CLocUIOptionList(const CLocUIOptionList &);

	void operator=(const CLocUIOptionList &);
};

#pragma warning(default: 4275 4251)


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "uioptions.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\uioptset.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    UIOPTSET.H

History:

--*/
#pragma once


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class CLocUIOption;
class CLocUIOptionList;

class LTAPIENTRY CLocUIOptionEnumCallback : public CObject
{
public:
	CLocUIOptionEnumCallback() {};

	void AssertValid(void) const;
			
	virtual BOOL ProcessOption(CLocUIOption *) = 0;
	virtual BOOL ProcessOption(const CLocUIOption *) = 0;
	
private:
	CLocUIOptionEnumCallback(const CLocUIOptionEnumCallback &);
	void operator=(int);
};


class LTAPIENTRY CLocUIOptionSet;

class LTAPIENTRY CLocUIOptionSetList :
	public CTypedPtrList<CPtrList, CLocUIOptionSet *>
{
public:
	NOTHROW CLocUIOptionSetList() {};

	void AssertValid(void) const;

	NOTHROW ~CLocUIOptionSetList();

private:
	CLocUIOptionSetList(const CLocUIOptionSetList &);
	void operator=(const CLocUIOptionSetList &);
};


//
//  This is used to control the order of the tabs displayed in the options
//  dialog.
enum OptionSetDisplayOrder
{
	osDefault = 50
};



class LTAPIENTRY CLocUIOptionSet : public CRefCount, public CObject
{
public:
	NOTHROW CLocUIOptionSet();

	void AssertValid(void) const;
	
	NOTHROW void AddOption(CLocUIOption *);
	NOTHROW void AddOptionSet(CLocUIOptionSet *);
	NOTHROW void RemoveOptionSet(const TCHAR *);
	
	NOTHROW const CLocUIOptionList & GetOptionList(void) const;
	NOTHROW const CLocUIOptionSetList & GetOptionSets(void) const;
	NOTHROW BOOL FindUIOption(const TCHAR *, CLocUIOption *&pOption);
	NOTHROW BOOL FindUIOption(const TCHAR *, const CLocUIOption *&pOption) const;
	
	NOTHROW void SetDescription(const HINSTANCE hDescDll, UINT idsDesc);
	NOTHROW void SetDescription(const CLString &);
	NOTHROW void SetHelpText(const HINSTANCE hHelpDll, UINT idsHelp);
	NOTHROW void SetHelpText(const CLString &);
	NOTHROW void SetHelpID(UINT);
	void SetGroupName(const TCHAR *);
	NOTHROW void SetDisplayOrder(UINT);
	
	NOTHROW void GetDescription(CLString &) const;
	NOTHROW void GetHelpText(CLString &) const;
	NOTHROW UINT GetHelpID(void) const;
	NOTHROW BOOL IsEmpty(void) const;
	const CLString &GetGroupName(void) const;
	NOTHROW UINT GetDisplayOrder(void) const;
	
	virtual BOOL IsReadOnly(void) const = 0;
	virtual BOOL IsVisible(void) const = 0;
		
	BOOL EnumOptions(CLocUIOptionEnumCallback *);
	BOOL EnumOptions(CLocUIOptionEnumCallback *) const;
	
	virtual void OnChange(void) const = 0;
	
protected:
	NOTHROW virtual ~CLocUIOptionSet();

	void SetParent(const CLocUIOptionSet *);
	const CLocUIOptionSet *GetParent(void) const;

private:
	CLocUIOptionList m_olOptions;
	CLocUIOptionSetList m_oslSubOptions;
	CLString m_strDesc, m_strHelp;
	UINT m_idHelp;
	const CLocUIOptionSet *m_pParent;
	CLString m_strGroup;
	UINT m_uiDisplayOrder;
	
	CLocUIOptionSet(const CLocUIOptionSet &);
	void operator=(const CLocUIOptionSet &);
};


class LTAPIENTRY CLocUIOptionSetDef : public CLocUIOptionSet
{
public:
	CLocUIOptionSetDef();

	enum ControlType
	{
		ctDefault,
		ctAlways,
		ctNever
	};
	
	void SetReadOnly(ControlType);
	void SetVisible(ControlType);

	virtual BOOL IsReadOnly(void) const;
	virtual BOOL IsVisible(void) const;

	virtual void OnChange(void) const;

	const CLocUIOptionSetDef & operator=(const CLocUIOptionSetDef &);
	
private:
	ControlType m_ctReadOnly;
	ControlType m_ctVisible;
};

#pragma warning(default: 4275)
 
#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "uioptset.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\uiopthelp.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    UIOPTHELP.H

History:

--*/

//  Class used to represent a single 'option'.
 
#pragma once

//
// Base structure
//
struct UI_OPTS_BASE
{
	TCHAR* pszName;				   // internal name of the option 
	UINT nDisplayName;			   // string id of the display name
	UINT nDisplayHelp;			   // string id of the help string
	PFNOnValidateUIOption pfnVal;    // function to call during validation. 
	                               // This may be null
	WORD wStorageTypes;			   // storage type of option	
	CLocUIOptionDef::ControlType wReadOnly;	  // ReadOnly value
	CLocUIOptionDef::ControlType wVisible;	  // Visible value
};



// Structures of option data

//
// BOOL options
//

struct UI_OPTS_BOOL
{
	UI_OPTS_BASE base;                // base class data 
	BOOL bDefValue;				   // default value of the option
	CLocUIOption::EditorType et;     // type of BOOL option
};

//
//  PICK options
//

struct UI_OPTS_PICK
{
	UI_OPTS_BASE base;                // base class data 
	DWORD dwDefValue;			   // default value of the option
	BOOL bAdd;					   // allow additions to the list	
	UINT nListEntries;             // list of entries to pick from
	                               // Each entry is separated by \n
	                               // The last entry does not have a \n
};

const TCHAR UI_PICK_TERMINATOR = _T('\n');

// 
// DWORD options

struct UI_OPTS_DWORD
{
	UI_OPTS_BASE base;                // base class data 
	DWORD dwDefValue;			   // default value of the option
	CLocUIOption::EditorType et;     // type of DWORD option
};


//
// String options
//
struct UI_OPTS_STR
{
	UI_OPTS_BASE base;                // base class data 
	UINT nDefValue;				   // string table entry for default value 
	CLocUIOption::EditorType et;
};


//
//  String list options
//

struct UI_OPTS_STRLIST
{
	UI_OPTS_BASE base;					// base class data 
	UINT nDefList;						// Each entry is separated by \n
										// The last entry does not have a \n
};


//
// File Name options
//
struct UI_OPTS_FILENAME
{
	UI_OPTS_BASE base;                // base class data 
	UINT nExtensions;	    		  // The default extensions to the UI
	UINT nDefValue;			  	      // string table entry for default value 
};


//
// Helper class definition
//

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocUIOptionImpHelper : public CObject
{
public:

	CLocUIOptionImpHelper(HINSTANCE hInst);

	void GetOptions(CLocUIOptionSet *pOptionSet, UINT nDesc, UINT nHelp);
	
	void SetBools(const UI_OPTS_BOOL* pBools, int nCntBools);
	void SetPicks(const UI_OPTS_PICK* pPicks, int nCntPicks);
	void SetDwords(const UI_OPTS_DWORD* pDwords, int nCntDwords);
	void SetStrs(const UI_OPTS_STR* pStrs, int nCntStrs);
	void SetStrLists(const UI_OPTS_STRLIST* pStrLists, int nCntStrLists);
	void SetFNames(const UI_OPTS_FILENAME* pFNames, int nCntFNames);

	void AssertValid(void) const;

protected:
	HINSTANCE m_hInst;

	const UI_OPTS_BOOL* m_pBools;
	int m_nCntBools;

	const UI_OPTS_PICK* m_pPicks;
	int m_nCntPicks;

	const UI_OPTS_DWORD* m_pDwords;
	int m_nCntDwords;

	const UI_OPTS_STR* m_pStrs;
	int m_nCntStrs;

	const UI_OPTS_STRLIST* m_pStrLists;
	int m_nCntStrLists;

	const UI_OPTS_FILENAME* m_pFNames;
	int m_nCntFNames;

	void GetBoolOptions(CLocUIOptionSet* pOptionSet);
	void GetPicksOptions(CLocUIOptionSet* pOptionSet);
	void GetDwordsOptions(CLocUIOptionSet* pOptionSet);
	void GetStrsOptions(CLocUIOptionSet* pOptionSet);
	void GetStrListsOptions(CLocUIOptionSet* pOptionSet);
	void GetFNamesOptions(CLocUIOptionSet* pOptionSet);

	void GetListFromId(UINT nId, CPasStringList& pasList);
	void GetStringFromId(UINT nId, CPascalString& pas);
};

#pragma warning(default : 4275)

//
// Helper macros for building data structures
//
// The _EXT versions of the macros allow setting the less common
// attributes (readonly and visible)
//


// BOOL
#define BEGIN_LOC_UI_OPTIONS_BOOL(var) \
const UI_OPTS_BOOL var[] =    \
{								 

#define LOC_UI_OPTIONS_BOOL_ENTRY(name, def, et, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, def, et}

#define LOC_UI_OPTIONS_BOOL_ENTRY_EXT(name, def, et, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, def, et}

#define END_LOC_UI_OPTIONS_BOOL() \
}                             



// Pick
#define BEGIN_LOC_UI_OPTIONS_PICK(var) \
const UI_OPTS_PICK var[] = \
{

#define LOC_UI_OPTIONS_PICK_ENTRY(name, def, add, list, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, def, add, list}

#define LOC_UI_OPTIONS_PICK_ENTRY_EXT(name, def, add, list, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, def, add, list}

#define END_LOC_UI_OPTIONS_PICK() \
}


// DWORD
#define BEGIN_LOC_UI_OPTIONS_DWORD(var) \
const UI_OPTS_DWORD var[] =    \
{								 

#define LOC_UI_OPTIONS_DWORD_ENTRY(name, def, et, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault},def, et}

#define LOC_UI_OPTIONS_DWORD_ENTRY_EXT(name, def, et, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible},def, et}

#define END_LOC_UI_OPTIONS_DWORD() \
}


// String
#define BEGIN_LOC_UI_OPTIONS_STR(var) \
const UI_OPTS_STR var[] =    \
{								 

#define LOC_UI_OPTIONS_STR_ENTRY(name, def, et, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, def, et}

#define LOC_UI_OPTIONS_STR_ENTRY_EXT(name, def, et, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, def, et}

#define END_LOC_UI_OPTIONS_STR() \
}


// String List
#define BEGIN_LOC_UI_OPTIONS_STRLIST(var) \
const UI_OPTS_STRLIST var[] =    \
{								 

#define LOC_UI_OPTIONS_STRLIST_ENTRY(name, def, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, def}

#define LOC_UI_OPTIONS_STRLIST_ENTRY_EXT(name, def, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, def}

#define END_LOC_UI_OPTIONS_STRLIST() \
}

// File Names
#define BEGIN_LOC_UI_OPTIONS_FILENAME(var) \
const UI_OPTS_FILENAME var[] =    \
{								 

#define LOC_UI_OPTIONS_FILENAME_ENTRY(name, def, id, idHelp, idExt, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, idExt, def}

#define LOC_UI_OPTIONS_FILENAME_ENTRY_EXT(name, def, id, idHelp, idExt, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, idExt, def}

#define END_LOC_UI_OPTIONS_FILENAME() \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\worddiff.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    WORDDIFF.INL

History:

--*/

#include "ltdebug.h"

inline
CWordDiff::CWordDiff(
	CDifference::ChangeType type, 
	int nOldPos,
	int nNewPos,
	bool bIsFirst,
	bool bIsLast,
	_bstr_t bstrWord,
	const wchar_t * pwszPrefix,
	const wchar_t * pwszSufix) :
	m_ChangeType(type), m_Word(bstrWord), m_pwszPrefix(pwszPrefix),
	m_pwszSufix(pwszSufix), m_bIsFirst(bIsFirst), m_bIsLast(bIsLast),
	m_nOldPos(nOldPos), m_nNewPos(nNewPos)

{
	LTASSERT(pwszPrefix != NULL);
	LTASSERT(pwszSufix != NULL);
	LTASSERT(nOldPos >= -1);
	LTASSERT(nNewPos >= -1);
}

inline
CDifference::ChangeType 
CWordDiff::GetChangeType() 
const
{
	return m_ChangeType;
}

inline
const wchar_t * 
CWordDiff::GetUnit() 
const
{
	return m_Word;
}

inline
int 
CWordDiff::GetOldUnitPosition() 
const 
{
	return m_nOldPos;
}

inline
int 
CWordDiff::GetNewUnitPosition() 
const
{
	return m_nNewPos;
}

inline
const wchar_t * 
CWordDiff::GetPrefix() 
const
{
	return m_pwszPrefix;
}

inline
const wchar_t * 
CWordDiff::GetSufix() 
const
{
	return m_pwszSufix;
}

inline
bool 
CWordDiff::IsFirst() 
const
{
	return m_bIsFirst;
}

inline
bool 
CWordDiff::IsLast() 
const
{
	return m_bIsLast;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\uioptions.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    UIOPTIONS.INL

History:

--*/


inline
CLocUIOption::CLocUIOption()
{
	m_hDescDll = NULL;
	m_hHelpDll = NULL;
	m_idsDesc = 0;
	m_idsHelp = 0;
	m_etEditor = etNone;

	m_wStorageTypes = 0;
	m_uiDisplayOrder = 0;

	m_pParent = NULL;
}



inline
void
CLocUIOption::SetDescription(
		const HINSTANCE hDll,
		UINT nDescriptionID)
{
	m_hDescDll = hDll;
	m_idsDesc = nDescriptionID;
}



inline
void
CLocUIOption::SetHelpText(
		const HINSTANCE hDll,
		UINT nHelpTextId)
{
	m_hHelpDll = hDll;
	m_idsHelp = nHelpTextId;
}



inline
void
CLocUIOption::SetEditor(
		EditorType et)
{
	m_etEditor = et;
}


inline
void
CLocUIOption::SetStorageTypes(
		WORD wStorageTypes)
{
	m_wStorageTypes = wStorageTypes;
}



inline 
CLocUIOption::EditorType
CLocUIOption::GetEditor(void) 
		const
{
	return m_etEditor;
}



inline
void
CLocUIOption::GetDescription(
		CLString &strDesc)
		const
{
	LTASSERT(m_hDescDll != NULL);
	LTASSERT(m_idsDesc != 0);
	
	strDesc.LoadString(m_hDescDll, m_idsDesc);
}



inline
void
CLocUIOption::GetHelpText(
		CLString &strHelp)
		const
{
	LTASSERT(m_hHelpDll != NULL);
	LTASSERT(m_idsHelp != 0);

	strHelp.LoadString(m_hHelpDll, m_idsHelp);
}



inline
WORD
CLocUIOption::GetStorageTypes(void)
		const
{
	return m_wStorageTypes;
}



inline
void
CLocUIOption::SetParent(
		CLocUIOptionSet *pParent)
{
	m_pParent = pParent;
}



inline
const CLocUIOptionSet *
CLocUIOption::GetParent(void)
		const
{
	return m_pParent;
}



inline
const CLocUIOptionData &
CLocUIOption::GetOptionValues(void) const
{
	return m_Values;
}



inline
CLocUIOptionData &
CLocUIOption::GetOptionValues(void)
{
	return m_Values;
}

inline
void CLocUIOptionDef::SetReadOnly(
	ControlType ct)
{
	m_ctReadOnly = ct;		
}	

inline
void CLocUIOptionDef::SetVisible(
	ControlType ct)
{
	m_ctVisible = ct;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\uioptset.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    UIOPTSET.INL

History:

--*/

inline		
void
CLocUIOptionSet::AddOption(
		CLocUIOption *pOption)
{
	m_olOptions.AddTail(pOption);

	pOption->SetParent(this);
}



inline
void
CLocUIOptionSet::AddOptionSet(
		CLocUIOptionSet *pOptionSet)
{
	m_oslSubOptions.AddTail(pOptionSet);

	pOptionSet->SetParent(this);
}


inline
const CLocUIOptionList &
CLocUIOptionSet::GetOptionList(void)
		const
{
	return m_olOptions;
}


inline
const CLocUIOptionSetList &
CLocUIOptionSet::GetOptionSets(void)
		const
{
	return m_oslSubOptions;
}



inline
const CLString &
CLocUIOptionSet::GetGroupName(void)
		const
{
	if (GetParent() != NULL)
	{
		return GetParent()->GetGroupName();
	}
	else
	{
		return m_strGroup;
	}
}

inline
UINT 
CLocUIOptionSet::GetDisplayOrder()
	 const
{
	return m_uiDisplayOrder;	
}	


inline
void
CLocUIOptionSet::SetDescription(
		const HINSTANCE hDll,
		UINT idsDesc)
{
	m_strDesc.LoadString(hDll, idsDesc);
}



inline
void
CLocUIOptionSet::SetDescription(
		const CLString &strDesc)
{
	m_strDesc = strDesc;
}


inline
void
CLocUIOptionSet::SetHelpText(
		const HINSTANCE hDll,
		UINT idsHelp)
{
	m_strHelp.LoadString(hDll, idsHelp);
}



inline
void
CLocUIOptionSet::SetHelpID(UINT uiHelpId)
{
	m_idHelp = uiHelpId;
}



inline
void
CLocUIOptionSet::SetGroupName(
		const TCHAR *szGroupName)
{
	m_strGroup = szGroupName;
}




inline
void
CLocUIOptionSet::SetHelpText(
		const CLString &strHelp)
{
	m_strHelp = strHelp;
}



inline
void
CLocUIOptionSet::GetDescription(
		CLString &strDesc)
		const
{
	strDesc = m_strDesc;
}



inline
void
CLocUIOptionSet::GetHelpText(
		CLString &strHelp)
		const
{
	strHelp = m_strHelp;
}



inline
UINT
CLocUIOptionSet::GetHelpID(void)
		const
{
	return m_idHelp;
}



inline
BOOL
CLocUIOptionSet::IsEmpty(void)
		const
{
	return m_olOptions.IsEmpty() && m_oslSubOptions.IsEmpty();
}


inline
void
CLocUIOptionSet::SetParent(
		const CLocUIOptionSet *pParent)
{
	m_pParent = pParent;
}

inline
void 
CLocUIOptionSet::SetDisplayOrder(
	UINT uiDisplayOrder)
{
	m_uiDisplayOrder = uiDisplayOrder;
}	


inline
const
CLocUIOptionSet *
CLocUIOptionSet::GetParent(void)
		const
{
	return m_pParent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\worddiff.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    WORDDIFF.H

History:

--*/
 
#ifndef WORDDIFF_H
#define WORDDIFF_H

typedef _bstr_t CWordUnit;

class CWordDiff : public CDifference
{
public:
	CWordDiff(ChangeType type, 
		int nOldPos,
		int nNewPos,
		bool bIsFirst,
		bool bIsLast,
		_bstr_t bstrWord,
		const wchar_t * pwszPrefix,
		const wchar_t * pwszSufix);

	virtual ChangeType GetChangeType() const;	// types of change that caused the difference
	virtual const wchar_t * GetUnit() const; // comparison unit (0-terminated string)
	virtual int GetOldUnitPosition() const; // 0-based position in old sequence. -1 if Added
	virtual int GetNewUnitPosition() const;	// 0-based position in new sequence. -1 if Deleted
	virtual const wchar_t * GetPrefix() const; //prpend this string to unit string
	virtual const wchar_t * GetSufix() const; //append this string to unit string
	virtual bool IsFirst() const; //is this first difference in delta?
	virtual bool IsLast() const; //is this last difference in delta?

private:
	ChangeType m_ChangeType;
	CWordUnit m_Word;
	const wchar_t * m_pwszPrefix;
	const wchar_t * m_pwszSufix;
	bool m_bIsFirst;
	bool m_bIsLast;
	int m_nOldPos;
	int m_nNewPos;
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "worddiff.inl"
#endif

#endif  //  WORDDIFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\parseman\pdesc.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PDESC.H

History:

--*/
 
#ifndef PARSEMAN_PDESC_H
#define PARSEMAN_PDESC_H

typedef CTypedPtrList<CPtrList, EnumInfo *> FileDescriptionList;

//
//  This class is used to gather all the file descriptions before
//  we write them into the registry.  
//
class CFileDescriptionsCallback : public CEnumCallback
{
public:
	CFileDescriptionsCallback();
	
	BOOL ProcessEnum(const EnumInfo &);
	
	const FileDescriptionList &GetFileDescriptions(void) const;
	
	~CFileDescriptionsCallback();
	
private:
	FileDescriptionList m_FileDescriptions;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\parseman\stdafx.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STDAFX.H

History:

--*/

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>
#include <afxtempl.h>

#include <esputil.h>
#include <pbase.h>
#include <parserid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\parseman\resource.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    RESOURCE.H

History:

--*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by parseman.rc
//
#define IDS_PARSEMAN_CONTEXT            12700
#define IDS_BAD_VERSION                 12701
#define IDS_FILT_ALL_FILES              12702
#define IDS_DEBUG_MISMATCH              12703

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\parsers\parsutil\locbinary.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCBINARY.H

History:

--*/
 
#if !defined (PARSUTIL_LOCBINARY_H)
#define PARSUTIL_LOCBINARY_H


#pragma warning(disable : 4275)

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocBinary : public ILocBinary, public CPULocChild
{
// Construction
public:
	CPULocBinary(CPULocParser * pParent);

	DECLARE_CLUNKNOWN();

// COM Interfaces
public:
	//  Standard Debugging interface.
	void STDMETHODCALLTYPE AssertValidInterface() const;

	//
	// ILocBinary interface
	//
	BOOL STDMETHODCALLTYPE CreateBinaryObject(BinaryId,	CLocBinary * REFERENCE);
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\parseman\pinfo.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PINFO.H

History:

--*/

#ifndef PINFO_H
#define PINFO_H


class CLocParserManager;

class CLocParserInfo;
typedef CTypedPtrList<CPtrList, CLocParserInfo *> CLocParserList;

#pragma warning(disable : 4251)

interface ILocParser;
interface ILocStringValidation;

class LTAPIENTRY CLocParserInfo : public CLObject
{
public:

	void AssertValid(void) const;

	const CLString &GetParserName(void) const;
	const CLString &GetParserDescription(void) const;
	const CLString &GetParserHelp(void) const;
	ParserId GetParserId(void) const;
	BOOL GetDllVersion(CLString &) const;
	const CLocExtensionList &GetExtensionList() const;
	const CLocParserList &GetSubParserList(void) const;

	~CLocParserInfo();

protected:
	friend CLocParserManager;
	
	CLocParserInfo();

	HINSTANCE GetParserHandle(void) const;
	ILocParser * GetParserPointer(void) const;
	ILocStringValidation *GetValidationPointer(void);
	
	BOOL LoadParserDll(void);
	BOOL InitSubParsers(ILocParser *);
	
	BOOL FreeParserDll(void);
	BOOL AttemptUnload(void);
	
	BOOL IsLoaded(void) const;
	
	void SetParserName(const CLString &);
	void SetParserDescription(const CLString &);
	void SetParserHelp(const CLString &);
	
	void SetParserId(ParserId);
	BOOL SetExtensionList(const CLString  &);
	void AddSubParser(CLocParserInfo *);
	void AddExtensions(const CLocExtensionList &);
	CLocParserList &GetSubParserList(void);

	clock_t GetLastAccessTime(void) const;
	
	static BOOL LoadParserDll(const CLString &strFileName,
			CReporter *pReporter, HMODULE &hDll, ILocParser *&pLocParser);
	static BOOL GetParserObjects(CReporter *, CLoadLibrary &, ILocParser *&);
	
private:
	
	CLString m_strParserName;
	CLString m_strParserDescription;
	CLString m_strParserHelp;
	CLocExtensionList m_elExtList;
	ParserId m_pidParserId;
	HINSTANCE m_hParserDll;
	ILocParser *m_pParserObject;
	ILocStringValidation *m_pValidationObject;
	BOOL m_fLoadAttempted;
	BOOL m_fValidationTried;
	UINT m_uiSubParserUsageCount;
	mutable clock_t m_tLastAccess;
	
	CLocParserList m_pSubParsers;
};

#pragma warning(default : 4251)



#endif  // PINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\parseman\unloader.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    UNLOADER.H

History:

--*/
 
#pragma once

class CParserUnloader : public CFlushMemory
{
public:
	CParserUnloader(BOOL fDelete);
	
	void FlushMemory(void);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\parseman\pmanager.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PMANAGER.H

History:

--*/

#ifndef PMANAGER_H
#define PMANAGER_H


#pragma warning(disable : 4251)

typedef CTypedPtrMap<CMapWordToPtr, ParserId, CLocParserInfo *> CLocParserMap;
typedef CTypedPtrMap<CMapStringToPtr, CString, CLocParserList *> CLocExtMap;
typedef CTypedPtrList<CPtrList, EnumInfo *> FileDescriptionList;

interface ILocFile;
struct ParserInfo;

class CParserUnloader;

class LTAPIENTRY CLocParserManager : public CLObject
{
	friend CLocParserInfo;
public:
	CLocParserManager();
	
	void AssertValid(void) const;
	
	BOOL InitParserManager(IUnknown *);
	static BOOL ReloadRegistry(void);
	static void UnloadParsers(void);
	static void UnloadUnusedParsers(void);
	
	static void GetManagerVersion(DWORD &dwMajor, DWORD &dwMinor, BOOL &fDebug);
	static BOOL AddParserToSystem(const CLString &);
	static const CLocParserInfo *GetParserInfo(ParserId pid, ParserId pidParent);
	static BOOL RemoveParserFromSystem(ParserId pid, ParserId pidParent);
	static UINT FindParsers(void);
	
	static BOOL GetLocParser(ParserId, ILocParser *&);
	static BOOL GetLocFile(const CFileSpec &, ParserId, FileType,
			ILocFile *&, CReporter &);
	static BOOL FindLocFile(const CPascalString &, CLocParserIdArray &);
	static BOOL GetStringValidation(ParserId, ILocStringValidation *&);
	
	static const CLocParserList &GetParserList(void);

	static void GetParserFilterString(CLString &);

	~CLocParserManager();

protected:
	static void RemoveCurrentInfo(void);
	static BOOL LoadParserInfo(const HKEY &, CLocParserInfo *&);
	static BOOL LoadMasterParserInfo(const HKEY &);
	static BOOL LoadSubParsers(const HKEY &, CLocParserInfo *);
	static BOOL WriteFileTypes(const HKEY &, const FileDescriptionList &);
	
	static BOOL OpenParserSubKey(HKEY &, ParserId, ParserId);
	static BOOL AddParserToRegistry(const CLString &, const ParserInfo &,
			const FileDescriptionList &);

	static void AddToFilter(const CLocParserInfo *, const CLocExtensionList &);

private:
	static LONG             m_lRefCount;    // 
	static CLocParserMap    m_ParserMap;    // Associative map, ID -> Parser.
	static CLocParserList   m_ParserList;   // List of open parser DLL's.
	static CLocParserList   m_SubParserList;// list of all sub-parsers.
	static CLocExtMap       m_ExtensionMap;	// Associative map, extension->parser.
	static CLString         m_strFilter;    // Filter list for parser files.
	static IUnknown *       m_pUnknown;
	static CParserUnloader  m_Unloader;
};


//
//  Undecorated versions of these functions for GetProcAddress users...
//
extern "C"
{
	LTAPIENTRY HRESULT AddParserToSystem(const TCHAR *strFileName);
	LTAPIENTRY HRESULT RemoveParserFromSystem(ParserId pid, ParserId pidParent);
}

		
#pragma warning(default : 4251)

#endif // PMANAGER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\parsers\parsutil\locchild.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCCHILD.H

History:

--*/
 
#if !defined (PARSUTIL_LOCCHILD_H)
#define PARSUTIL_LOCCHILD_H


#pragma warning(disable : 4275)


class CPULocParser;

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocChild : public CLUnknown, public CLObject
{
// Construction
public:
	CPULocChild(CPULocParser * pParent);
	virtual ~CPULocChild();

// Data
private:
	CPULocParser * m_pParent;

// Attributes
public:
	CPULocParser * GetParent() const;

// COM Interfaces
public:

// Overrides
public:

// Implementation
protected:

	//  CLObject

	virtual void AssertValid(void) const;
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\parsers\parsutil\locversion.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCVERSION.H

History:

--*/
 
#if !defined (PARSUTIL_LOCVERSION_H)
#define PARSUTIL_LOCVERSION_H

#include "LocChild.h"

#pragma warning(disable : 4275)

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocVersion : public CPULocChild, public ILocVersion
{
// Construction
public:
	CPULocVersion(CPULocParser * pParent);

	DECLARE_CLUNKNOWN();

// COM Interfaces
public:
	//  Standard Debugging interface.
	void STDMETHODCALLTYPE AssertValidInterface() const;

	//  ILocVersion
	void STDMETHODCALLTYPE GetParserVersion(DWORD &dwMajor, DWORD &dwMinor,
			BOOL &fDebug) const;
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\parsers\parsutil\parsutil.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PARSUTIL.H

History:

--*/


#if !defined (__ParsUtil_h__)
#define __ParsUtil_h__

void IncrementClassCount();
void DecrementClassCount();

extern HMODULE g_hDll;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\parsers\parsutil\resource.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    RESOURCE.H

History:

--*/

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\parsers\parsutil\locstrval.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCSTRVAL.H

History:

--*/

#if !defined (PARSUTIL_LOCSTRVAL_H)
#define PARSUTIL_LOCSTRVAL_H

#include "LocChild.h"

#pragma warning(disable : 4275)

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocStringValidation : public CPULocChild, public ILocStringValidation
{
// Construction
public:
	CPULocStringValidation(CPULocParser * pParent);

	DECLARE_CLUNKNOWN();

// COM Interfaces
public:
	//  Standard Debugging interface.
	void STDMETHODCALLTYPE AssertValidInterface() const;

	//  ILocStringValidation
	CVC::ValidationCode STDMETHODCALLTYPE ValidateString(
			const CLocTypeId &ltiType, const CLocTranslation &trTrans,
			CReporter *pReporter, const CContext &context);
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\parsers\parsutil\stdafx.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STDAFX.H

History:

--*/


#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#include <afxcoll.h>		// MFC collection support
#include <afxtempl.h>		// MFC template support

#include <esputil.h>
#include <pbase.h>
#include <parserid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\parsers\parsutil\locparser.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCPARSER.H

History:

--*/
 
#if !defined (PARSUTIL_LOCPARSER_H)
#define PARSUTIL_LOCPARSER_H


#pragma warning(disable : 4275)

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocParser : public ILocParser, public CLObject
{
// Construction
public:
	CPULocParser(HINSTANCE hDll);
	virtual ~CPULocParser();

// Data
private:
	ULONG				m_ulRefCount;	// COM reference count
	HINSTANCE			m_hInst;		// Instance Handle

	BOOL				m_fEnableVersion;
	BOOL				m_fEnableBinary;
	BOOL				m_fEnableStrVal;

// COM Interfaces
public:

	//  IUnknown standard interface.
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID * ppvObj);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	//  Standard Debugging interface.
	void STDMETHODCALLTYPE AssertValidInterface() const;

	//  ILocParser interface implementation
	HRESULT STDMETHODCALLTYPE Init(IUnknown *);
	HRESULT STDMETHODCALLTYPE CreateFileInstance(ILocFile * REFERENCE, FileType);
	void STDMETHODCALLTYPE GetParserInfo(ParserInfo &) const;
	void STDMETHODCALLTYPE GetFileDescriptions(CEnumCallback &) const;

// Operations
public:

// Implementation
protected:
	BOOL EnableInterface(REFIID riid, BOOL fEnable = TRUE);
	virtual BOOL IsInterfaceEnabled(REFIID riid) const;

// Overrides
public:

	// IUnknown
	virtual HRESULT OnQueryInterface(REFIID riid, LPVOID * ppvObj);

	// ILocParser
	virtual HRESULT OnInit(IUnknown *);
	virtual HRESULT OnCreateFileInstance(ILocFile * &, FileType) = 0;
	virtual void OnGetParserInfo(ParserInfo &) const = 0;
	virtual void OnGetFileDescriptions(CEnumCallback &) const = 0;

	// ILocVersion
	virtual void OnGetParserVersion(DWORD &dwMajor,	DWORD &dwMinor,
			BOOL &fDebug) const = 0;

	// ILocBinary
	virtual BOOL OnCreateBinaryObject(BinaryId id, CLocBinary * REFERENCE pBinary);

	// ILocStringValidation
	virtual CVC::ValidationCode OnValidateString(const CLocTypeId &ltiType,
			const CLocTranslation &, CReporter *pReporter,
			const CContext &context) = 0;
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase\idupdate.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    IDUPDATE.H

History:

--*/
 
#ifndef PBASE_IDUPDATE_H
#define PBASE_IDUPDATE_H

extern const IID IID_ILocIDUpdate;

DECLARE_INTERFACE_(ILocIDUpdate, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//
	//  ID Update methods.
	//
	STDMETHOD_(BOOL, RequiresUpdate)(THIS_ FileType) PURE;
	STDMETHOD_(FileType, GetUpdatedFileType)(THIS_ FileType) PURE;

	STDMETHOD_(BOOL, GetOldUniqueId)(THIS_ CLocUniqueId REFERENCE) PURE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase\binary.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    BINARY.H

Abstract:

    Class to hold 'binary' (non-string) information about a localizable item.

History:

--*/

#ifndef BINARY_H
#define BINARY_H

//
//  Binary interface.  Parsers provide an implementation of this in order
//  to create binary objects for other users.
//
extern const IID IID_ILocBinary;

DECLARE_INTERFACE_(ILocBinary, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD_(BOOL, CreateBinaryObject)(THIS_ BinaryId, CLocBinary *REFERENCE) PURE;
};



#endif  // BINARY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase\locfile.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCFILE.H

History:

--*/

#ifndef PBASE_LOCFILE_H
#define PBASE_LOCFILE_H


class CLocItemHandler;


extern const IID IID_ILocFile;


DECLARE_INTERFACE_(ILocFile, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//
	//  ILocFile methods.
	//
	STDMETHOD_(BOOL, OpenFile)(THIS_ const CFileSpec REFERENCE,
			CReporter REFERENCE) PURE;
	STDMETHOD_(FileType, GetFileType)(THIS) const PURE;
	STDMETHOD_(void, GetFileTypeDescription)(THIS_ CLString REFERENCE)
		const PURE;
	STDMETHOD_(BOOL, GetAssociatedFiles)(THIS_ CStringList REFERENCE)
		const PURE;

	STDMETHOD_(BOOL, EnumerateFile)(THIS_ CLocItemHandler REFERENCE,
			const CLocLangId &, const DBID REFERENCE) PURE;
	STDMETHOD_(BOOL, GenerateFile)(THIS_ const CPascalString REFERENCE,
			CLocItemHandler REFERENCE, const CLocLangId REFERENCE,
			const CLocLangId REFERENCE, const DBID REFERENCE) PURE;
};


#endif //  PBASE_LOCFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase\parseapi.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PARSEAPI.H

History:

--*/

 
#ifndef PARSEAPI_H
#define PARSEAPI_H


extern const IID IID_ILocParser;
extern const IID IID_ILocParser_20;

struct ParserInfo
{
	CArray<PUID, PUID &> aParserIds;
	CLString strDescription;
	CLocExtensionList elExtensions;
	CLString strHelp;
};


DECLARE_INTERFACE_(ILocParser, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//
	//  LocParser methods.
	//
	STDMETHOD(Init)(THIS_ IUnknown *) PURE;
	
	STDMETHOD(CreateFileInstance)(THIS_ ILocFile *REFERENCE, FileType) PURE;

	STDMETHOD_(void, GetParserInfo)(THIS_ ParserInfo REFERENCE)
		CONST_METHOD PURE;
	STDMETHOD_(void, GetFileDescriptions)(THIS_ CEnumCallback &)
		CONST_METHOD PURE;
};


//
//  Here for DOCUMENTATION only.  Implementors should export the following
//  functions from every Parser DLL.
//
static const char * szParserEntryPointName = "DllGetParserCLSID";
typedef void (STDAPICALLTYPE *PFNParserEntryPoint)(CLSID REFERENCE);

STDAPI_(void) DllGetParserCLSID(CLSID REFERENCE);


static const char * szParserRegisterEntryPointName = "DllRegisterParser";
typedef HRESULT (STDAPICALLTYPE *PFNParserRegisterEntryPoint)(void);

STDAPI DllRegisterParser(void);


static const char *szParserUnregisterEntryPointName = "DllUnregisterParser";
typedef HRESULT (STDAPICALLTYPE *PFNParserUnregisterEntryPoint)(void);

STDAPI DllUnregisterParser(void);

//
//  Implementors also need to implement the DllGetClassObject function.
//  An optional (but RECOMMENDED) function is DllCanUnloadNow.
//  See the OLE 2 reference manual for details about these functions.
//

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv);
STDAPI DllCanUnloadNow(void);


#endif // PARSEAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase\imgres32.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    IMGRES32.H

History:

--*/

#ifndef IMGRES32_H
#define IMGRES32_H


struct Res32FontInfo
{
	WORD wLength;			//Structure length
	WORD wPointSize;		
	WORD wWeight;
	WORD wStyle;
	CPascalString pasName;
};

class CLocItemPtrArray;
class CFile;

extern const IID IID_ILocRes32Image;

DECLARE_INTERFACE_(ILocRes32Image, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;
	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//Builds a Res32 file image of a resource from the resource's CLocItem objects
	//Inputs:
	//	- A pointer to a CLocItemPtrArray object containing the CLocItem objects of
	//	a resource (like a dialog or a menu).
	//	- An array index to the root item of the resource.
	//	- An array index to the selected item of the resource.
	//	- The resource's language id.
	//	- A pointer to an existing empty CFile.
	//  - A pointer to a Res32FontInfo structure
	//	- A pointer to a reporter object where all error messages are sent.
	//Outputs:
	//	- The CFile object has the res32 image of the resource.
	//	- The CLocItemPtrArray object has its items ordered by physical
	//	location in the res32 image.	
	//Return:
	//	TRUE if the image was created successfully. FALSE, otherwise.
	STDMETHOD_(BOOL, MakeRes32Image)(THIS_ CLocItemPtrArray *, int, int, 
		LangId, CFile *, Res32FontInfo*, CLocItemHandler *) PURE;

	//Breaks the Res32 image of a resource into the corresponding CLocItem objects.
	//Inputs:
	//	- A pointer to a CFile object containing the res32 image of a resource.
	//	- The resource's language id.
	//	- A pointer to a CLocItemPtrArray containing the CLocItem objects of the
 	//	resource. The items are expected to be ordered by position in the res32 image.
	//	- A pointer to a reporter object where all error messages are sent.
	//Outputs:
	//	- The items in the CLocItemPtrArray object are updated with the new data from
 	//	the res32 image.
	//Return:
	//	TRUE if the imaged could be parsed and if the items could be updated successfully.
	//	FALSE, otherwise.
	STDMETHOD_(BOOL, CrackRes32Image)(THIS_ CFile *, LangId, CLocItemPtrArray *, CLocItemHandler *) PURE;
};



#endif  // IMGRES32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase\mnemonic.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MNEUMONIC.H

History:

--*/


#ifndef MNEMONIC_H
#define MNEMONIC_H


extern const IID IID_ILocMnemonics;

DECLARE_INTERFACE_(ILocMnemonics, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;
	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//Gets the mnemonics (aka hotkeys) in the resource array of locitems.
	//Inputs:
	//	- A pointer to a CLocItemPtrArray object containing the CLocItem objects of
	//	a resource (like a dialog or a menu).
	//	- An array index to the root item of the resource.
	//	- An array index to the selected item of the resource.
	//	- The resource's language id.
	//	- A pointer to a reporter object where all error messages are sent.
	//Outputs:
	//	- A 'CHotkeysMap' map containing the mnemonics.
	//Return:
	//	TRUE if the mnemonics could be retrieved successfully. FALSE, otherwise.
	STDMETHOD_(BOOL, GetMnemonics)
			(THIS_ CLocItemPtrArray &, int, int, LangId, CReporter * pReporter, 
			CMnemonicsMap &) PURE;

};



#endif  // MNEMONIC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase\iresobj.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    IRESOBJ.H

Abstract:

    This interface allows conversion of localizable items of resource into a
    res32 image, and vice-versa.

History:

--*/

#ifndef IRESOBJ_H
#define IRESOBJ_H


class CLocItemPtrArray;
class CFile;
class CResObj;
class CLocItem;

extern const IID IID_ICreateResObj;

DECLARE_INTERFACE_(ICreateResObj, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;
	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	// Creates a CResObj for win32 resoruce processing
	//Inputs:
	//	- A pointer to a CLocItem object containing the type and Id of the item
	//	- The size of the resource.
	//	- An void pointer to unknown data to be passed from enumeration to generate
	//Return:
	//	- A CResObj pointer or NULL if the type is not recognized
	STDMETHOD_(CResObj *, CreateResObj)(THIS_ CLocItem * pLocItem,
		DWORD dwSize, void * pvHeader) PURE;
};
#endif  // IRESOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase\pversion.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PVERSION.H

History:

--*/
 
#ifndef PVERSION_H
#define PVERSION_H

extern const IID IID_ILocVersion;

extern const DWORD dwCurrentMajorVersion;
extern const DWORD dwCurrentMinorVersion;
#ifdef _DEBUG
const BOOL fCurrentDebugMode = TRUE;
#else
const BOOL fCurrentDebugMode = FALSE;
#endif

DECLARE_INTERFACE_(ILocVersion, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//
	//
	//
	STDMETHOD_(void, GetParserVersion)(
			THIS_ DWORD REFERENCE dwMajor,
			DWORD REFERENCE dwMinor,
			BOOL REFERENCE fDebug)
		CONST_METHOD PURE;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase\stdafx.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STDAFX.H

History:

--*/

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase\pstrval.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PSTRVAL.H

History:

--*/

 
#ifndef PBASE_PSTRVAL_H
#define PBASE_PSTRVAL_H

extern const IID IID_ILocStringValidation;

DECLARE_INTERFACE_(ILocStringValidation, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD_(CVC::ValidationCode, ValidateString)
		(THIS_ const CLocTypeId REFERENCE, const CLocString REFERENCE,
				CReporter *) PURE;
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\sys\locking.h ===
/***
*sys/locking.h - flags for locking() function
*
*	Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the flags for the locking() function.
*	[System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_LOCKING
#define _INC_LOCKING

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#define _LK_UNLCK	0	/* unlock the file region */
#ifdef _WIN32
#define _LK_LOCK	1	/* lock the file region */
#endif
#define _LK_NBLCK	2	/* non-blocking lock */
#ifdef _WIN32
#define _LK_RLCK	3	/* lock for writing */
#endif
#define _LK_NBRLCK	4	/* non-blocking lock for writing */

#if !__STDC__
/* Non-ANSI names for compatibility */
#define LK_UNLCK	_LK_UNLCK
#ifdef _WIN32
#define LK_LOCK 	_LK_LOCK
#endif
#define LK_NBLCK	_LK_NBLCK
#ifdef _WIN32
#define LK_RLCK 	_LK_RLCK
#endif
#define LK_NBRLCK	_LK_NBRLCK
#endif

#endif	/* _INC_LOCKING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\sys\stat.h ===
/***
*sys/stat.h - defines structure used by stat() and fstat()
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structure used by the _stat() and _fstat()
*       routines.
*       [System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STAT
#define _INC_STAT

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


#include <sys/types.h>


#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif


#ifdef _WIN32
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif
#endif /* _WIN32 */


/* define structure for returning status information */

#ifndef _STAT_DEFINED

struct _stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#if     !__STDC__

/* Non-ANSI names for compatibility */

struct stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#endif  /* __STDC__ */

#if     _INTEGRAL_MAX_BITS >= 64
struct _stati64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };
#endif

#define _STAT_DEFINED
#endif


#define _S_IFMT         0170000         /* file type mask */
#define _S_IFDIR        0040000         /* directory */
#define _S_IFCHR        0020000         /* character special */
#define _S_IFIFO        0010000         /* pipe */
#define _S_IFREG        0100000         /* regular */
#define _S_IREAD        0000400         /* read permission, owner */
#define _S_IWRITE       0000200         /* write permission, owner */
#define _S_IEXEC        0000100         /* execute/search permission, owner */


/* Function prototypes */

_CRTIMP int __cdecl _fstat(int, struct _stat *);
_CRTIMP int __cdecl _stat(const char *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _fstati64(int, struct _stati64 *);
_CRTIMP int __cdecl _stati64(const char *, struct _stati64 *);
#endif

#ifdef _WIN32
#ifndef _WSTAT_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _wstat(const wchar_t *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _wstati64(const wchar_t *, struct _stati64 *);
#endif

#define _WSTAT_DEFINED
#endif
#endif /* _WIN32 */


#if     !__STDC__

/* Non-ANSI names for compatibility */

#define S_IFMT   _S_IFMT
#define S_IFDIR  _S_IFDIR
#define S_IFCHR  _S_IFCHR
#define S_IFREG  _S_IFREG
#define S_IREAD  _S_IREAD
#define S_IWRITE _S_IWRITE
#define S_IEXEC  _S_IEXEC

_CRTIMP int __cdecl fstat(int, struct stat *);
_CRTIMP int __cdecl stat(const char *, struct stat *);

#endif  /* __STDC__ */


#ifdef __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STAT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\sys\timeb.h ===
/***
*sys/timeb.h - definition/declarations for _ftime()
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file define the _ftime() function and the types it uses.
*       [System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TIMEB
#define _INC_TIMEB

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif


/* Structure returned by _ftime system call */

#ifndef _TIMEB_DEFINED
struct _timeb {
        time_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };

#if     !__STDC__

/* Non-ANSI name for compatibility */

struct timeb {
        time_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };

#endif

#define _TIMEB_DEFINED
#endif


/* Function prototypes */

_CRTIMP void __cdecl _ftime(struct _timeb *);

#if     !__STDC__

/* Non-ANSI name for compatibility */

_CRTIMP void __cdecl ftime(struct timeb *);

#endif


#ifdef __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_TIMEB */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\sys\types.h ===
/***
*sys/types.h - types returned by system level calls for file and time info
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines types used in defining values returned by system
*       level calls for file status and time information.
*       [System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TYPES
#define _INC_TYPES

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif


#ifndef _INO_T_DEFINED

typedef unsigned short _ino_t;          /* i-node number (not used on DOS) */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned short ino_t;
#endif

#define _INO_T_DEFINED
#endif


#ifndef _DEV_T_DEFINED

typedef unsigned int _dev_t;            /* device code */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned int dev_t;
#endif

#define _DEV_T_DEFINED
#endif


#ifndef _OFF_T_DEFINED

typedef long _off_t;                    /* file offset value */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef long off_t;
#endif

#define _OFF_T_DEFINED
#endif

#endif  /* _INC_TYPES */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\sys\utime.h ===
/***
*sys/utime.h - definitions/declarations for utime()
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structure used by the utime routine to set
*       new file access and modification times.  NOTE - MS-DOS
*       does not recognize access time, so this field will
*       always be ignored and the modification time field will be
*       used to set the new time.
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_UTIME
#define _INC_UTIME

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif

#ifdef  _WIN32
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif
#endif  /* _WIN32 */

#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif

/* define struct used by _utime() function */

#ifndef _UTIMBUF_DEFINED

struct _utimbuf {
        time_t actime;          /* access time */
        time_t modtime;         /* modification time */
        };

#if     !__STDC__
/* Non-ANSI name for compatibility */
struct utimbuf {
        time_t actime;          /* access time */
        time_t modtime;         /* modification time */
        };
#endif

#define _UTIMBUF_DEFINED
#endif


/* Function Prototypes */

_CRTIMP int __cdecl _utime(const char *, struct _utimbuf *);
#ifdef _WIN32
_CRTIMP int __cdecl _futime(int, struct _utimbuf *);

/* Wide Function Prototypes */
_CRTIMP int __cdecl _wutime(const wchar_t *, struct _utimbuf *);
#endif /* _WIN32 */

#if     !__STDC__
/* Non-ANSI name for compatibility */
_CRTIMP int __cdecl utime(const char *, struct utimbuf *);
#endif

#ifdef __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_UTIME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase\subparse.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    SUBPARSE.H

History:

--*/


#ifndef PBASE_SUBPARSE_H
#define PBASE_SUBPARSE_H


extern const IID IID_ILocSubParserManager;

typedef CTypedPtrArray<CPtrArray, ILocParser *> ILocSubParserArray;

DECLARE_INTERFACE_(ILocSubParserManager, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD(InitSubParsers)(THIS_ ILocSubParserArray REFERENCE)
		CONST_METHOD PURE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase\updatelog.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    UPDATELOG.H

History:

--*/
 
#ifndef PBASE_UPDATELOG_H
#define PBASE_UPDATELOG_H


extern const IID IID_ILocUpdateLog;

DECLARE_INTERFACE_(ILocUpdateLog, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD_(BOOL, ReportItemDifferences)
		(THIS_ const CLocItem *pOldItem, const CLocItem *pNewItem,
				CItemInfo *, CLogFile *) PURE;
};


struct __declspec(uuid("{6005AF23-EE76-11d0-A599-00C04FC2C6D8}")) ILocUpdateLog;




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\prodver\prodver.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PRODVER.H

Abstract:

    Product versions

History:

--*/

#define rmj 4
#define rmm 2
#define rup 169
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\cmdtokenizer.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: CmdTokenizer.cpp 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: The CCmdTokenizer class provides with the 
							  functionality for tokenizing a command entered
							  as input on the command line, following the 
							  pre-defined rules for tokenizing.
Revision History			: 
		Last Modified By	: P. Sashank
		Last Modified Date	: 10th-April-2001
****************************************************************************/ 
#include "Precomp.h"
#include "CmdTokenizer.h"

/*------------------------------------------------------------------------
   Name				 :CCmdTokenizer
   Synopsis	         :This function initializes the member variables when
                      an object of the class type is instantiated
   Type	             :Constructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CCmdTokenizer::CCmdTokenizer()
{
	m_nTokenOffSet		= 0;
	m_nTokenStart		= 0;
	m_pszCommandLine	= NULL;
	m_bEscapeSeq		= FALSE;
	m_bFormatToken		= FALSE;
}

/*------------------------------------------------------------------------
   Name				 :~CCmdTokenizer
   Synopsis	         :This function uninitializes the member variables 
					  when an object of the class type goes out of scope.
   Type	             :Destructor
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CCmdTokenizer::~CCmdTokenizer()
{
	Uninitialize();
}

/*------------------------------------------------------------------------
   Name				 :Uninitialize
   Synopsis	         :This function uninitializes the member variables 
					  when the execution of a command string issued on the
					  command line is completed.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :Uninitialize()
   Notes             :None
------------------------------------------------------------------------*/
void CCmdTokenizer::Uninitialize()
{
	m_nTokenOffSet		= 0;
	m_nTokenStart		= 0;
	m_bEscapeSeq		= FALSE;
	SAFEDELETE(m_pszCommandLine);
	CleanUpCharVector(m_cvTokens);
}

/*------------------------------------------------------------------------
   Name				 :TokenizeCommand
   Synopsis	         :This function tokenizes the command string entered 
					  as input based on the pre-identified delimiters and
					  stores the tokens in the list of m_cvTokens.
   Type	             :Member Function
   Input parameter   :
	pszCommandInpout - Command line Input
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :TokenizeCommand(pszCommandInput)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCmdTokenizer::TokenizeCommand(_TCHAR* pszCommandInput) throw(WMICLIINT)
{
	BOOL bResult = TRUE;
	// Free the memory pointed by the member variable m_pszCommandLine
	// if the pointer is not NULL.
	SAFEDELETE(m_pszCommandLine);
	
	if(pszCommandInput)
	{
		try
		{
			// Allocate the memory for the command line string.
			m_pszCommandLine = new _TCHAR [lstrlen(pszCommandInput) + 1];
			if (m_pszCommandLine != NULL)
			{
				// Copy the contents to the member variable m_pszCommandLine
				lstrcpy(m_pszCommandLine, pszCommandInput);

				// Set the token-offset and token-start counters to '0'
				m_nTokenOffSet = 0;
				m_nTokenStart = 0;

				WMICLIINT nCmdLength = lstrlen(m_pszCommandLine);
				// Tokenize the command string.
				while (m_nTokenOffSet < nCmdLength)
				{
					NextToken();
				}
			}
			else
				throw OUT_OF_MEMORY;
		}	
		catch(...)
		{
			bResult = FALSE;
		}
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :NextToken
   Synopsis	         :This function dissects the command string entered
					  as input, and adjusts the the token-offset and 
					  token-start positions, and call the  Token()
					  function for extracting the token out of the
					  input string.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :NextToken
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCmdTokenizer::NextToken()
{
	WMICLIINT nCmdLength = lstrlen(m_pszCommandLine);

	// step over leading whitespace(s)
	while ((m_pszCommandLine[m_nTokenOffSet] == _T(' ') ||
		    m_pszCommandLine[m_nTokenOffSet] == _T('\t'))
			&& (m_nTokenOffSet < nCmdLength))
	{
		m_nTokenOffSet++;
	}
    m_nTokenStart = m_nTokenOffSet;

	CHARVECTOR::iterator theIterator;
	theIterator = m_cvTokens.end();

    //step up to next delimiter i.e '/', '-' or '?'
	if ((m_pszCommandLine[m_nTokenOffSet] == _T('/')) 
		|| (m_pszCommandLine[m_nTokenOffSet] == _T('-')) 
		|| (m_pszCommandLine[m_nTokenOffSet] == _T(','))
		|| (m_pszCommandLine[m_nTokenOffSet] == _T('('))
		|| (m_pszCommandLine[m_nTokenOffSet] == _T(')'))
		|| (m_pszCommandLine[m_nTokenOffSet] == _T('=') &&
		   !CompareTokens(*(theIterator-1), CLI_TOKEN_WHERE) &&
		   !CompareTokens(*(theIterator-1), CLI_TOKEN_PATH)))
	{
		// To handle optional parenthesis with WHERE
		if (m_pszCommandLine[m_nTokenOffSet] == _T('('))
		{
			if (m_cvTokens.size())
			{
				//Check whether the previous token is "WHERE"
				if (CompareTokens(*(theIterator-1), CLI_TOKEN_WHERE))
				{
					m_nTokenOffSet++;
					while ((m_nTokenOffSet < nCmdLength) 
						&& (m_pszCommandLine[m_nTokenOffSet] != _T(')')))
					{
						m_nTokenOffSet++;		
					}
				}
			}
		}
		m_nTokenOffSet++;
	}
	else
	{
		while (m_nTokenOffSet < nCmdLength)
		{
			if ((m_pszCommandLine[m_nTokenOffSet] == _T('/')) 
				|| (m_pszCommandLine[m_nTokenOffSet] == _T('-'))
				|| (m_pszCommandLine[m_nTokenOffSet] == _T(' '))
				|| (m_pszCommandLine[m_nTokenOffSet] == _T('\t'))
				|| (m_pszCommandLine[m_nTokenOffSet] == _T(','))
				|| (m_pszCommandLine[m_nTokenOffSet] == _T('('))
				|| (m_pszCommandLine[m_nTokenOffSet] == _T(')'))
				|| (m_pszCommandLine[m_nTokenOffSet] == _T('=') &&
					!CompareTokens(*(theIterator-1), CLI_TOKEN_WHERE) &&
					!CompareTokens(*(theIterator-1), CLI_TOKEN_PATH)))
			{
				break;
			}

			// if the command option is specified in quotes
			if (m_pszCommandLine[m_nTokenOffSet] == _T('"'))
			{
				m_nTokenOffSet++;

				// To include " within an quoted string it should
				// be preceded by \ 
				while (m_nTokenOffSet < nCmdLength) 
				{
					if (m_pszCommandLine[m_nTokenOffSet] == _T('"'))
					{
						if (m_pszCommandLine[m_nTokenOffSet-1] == _T('\\'))
						{
							m_bEscapeSeq = TRUE;			
						}
						else
							break;
					}
					m_nTokenOffSet++;		
				}
			}
			m_nTokenOffSet++;	
		}
	}
	return Token();
}

/*------------------------------------------------------------------------
   Name				 :Token
   Synopsis	         :This function extracts the portion of the command
					  string using the token-start and token-offset value.
					  If the token is not NULL, adds it to the list of 
					  tokens in the token vector.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :Token()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCmdTokenizer::Token() throw(WMICLIINT)
{

	WMICLIINT	nLength = (m_nTokenOffSet - m_nTokenStart);
	_TCHAR* sToken	= NULL;
	CHARVECTOR::iterator theIterator = NULL;

	if (nLength > 0)
	{
		// Allocate the memory for the new token.
		sToken = new _TCHAR [nLength + 1];
		if (sToken)
		{
			try
			{
				WMICLIINT nLoop = 0;
				WMICLIINT nInd = 0;
				BOOL bSpecialChar = FALSE;
				BOOL bPush = TRUE;
								
				// Form the token(s).
				while(nInd < nLength)
				{	
					BOOL bPush = TRUE;
					while (nInd < nLength)
					{
						//If the character is ':'
						if(m_pszCommandLine[nInd + m_nTokenStart] == _T(':') &&
					 		bSpecialChar == FALSE)
						{
							_TCHAR*    sToktemp = NULL;
							sToktemp  = new _TCHAR [nLoop + 1];

							if (sToktemp == NULL)
								throw OUT_OF_MEMORY;

							if(lstrlen(sToken) > 0)
							{
								lstrcpyn(sToktemp,sToken,nLoop + 1);
								sToktemp[nLoop] = _T('\0');
								
								//if ':' is preceeded by ASSOC token
								if(CompareTokens(sToktemp,CLI_TOKEN_ASSOC))								
								{
									
									bSpecialChar = TRUE;
									bPush = FALSE;
									SAFEDELETE(sToktemp);	
									break;

								}
								//if ':' is preceded by FORMAT token 
								else if(CompareTokens(sToktemp,CLI_TOKEN_FORMAT))
										
								{	theIterator = m_cvTokens.end();
									if((theIterator - 1) >= m_cvTokens.begin() &&
									   IsOption(*(theIterator - 1)))
									{
										m_bFormatToken = TRUE;
										bSpecialChar = TRUE;
										bPush = FALSE;
										SAFEDELETE(sToktemp);
										break;
									}
								}
								SAFEDELETE(sToktemp);
							}
							if (!m_cvTokens.empty())
							{

								theIterator = m_cvTokens.end();

								//if ':' is present previous token is '/' 
								//(case arises when ':' 
								//is specified without space after a switch)
								if( (theIterator - 1) >= m_cvTokens.begin() &&
									IsOption(*(theIterator - 1)))
								{
									bSpecialChar = TRUE;
									bPush = FALSE;
									break;
								}
								//if ':' is first character in the new token
								//(case arises when ':' is preceded by blank space)
								else if(m_nTokenStart != 0 && 
									m_pszCommandLine[m_nTokenStart] == _T(':'))
								{
									bSpecialChar = TRUE;
									bPush = FALSE;
									break;
								}
								//if ':' is encountered after format switch 
								//and previous token is ':' or a ',' 
								//(case arises for specifying format switch)
								else if(m_bFormatToken == TRUE && 
										(CompareTokens(*(theIterator - 1),_T(":"))) ||
										(CompareTokens(*(theIterator - 1), CLI_TOKEN_COMMA)) ||
										(IsOption(*(theIterator - 1))))
								{
									bSpecialChar = TRUE;
									bPush = FALSE;
									break;
								}
								//if ':' is preceded by '?' and '?' in turn 
								//is preceded by '/'
								//(case arises for specifying help option)
								else 
								{		
									theIterator = m_cvTokens.end();
									if(theIterator &&
										(theIterator - 2) >= m_cvTokens.begin() &&
										(CompareTokens(*(theIterator - 1),_T("?"))) &&
										(IsOption(*(theIterator - 2))))
									{
										bSpecialChar = TRUE;
										bPush = FALSE;
										break;
									}
								}
							}
						}
						//if character is '?'(for help switch)
						else if(m_pszCommandLine[nInd + m_nTokenStart] == 
											_T('?') && bSpecialChar == FALSE)
						{
							if (!m_cvTokens.empty())
							{
								theIterator = m_cvTokens.end();

								//if character is '?' and preceded by '/'(for help switch)
								if( (theIterator - 1) >= m_cvTokens.begin() &&
									IsOption(*(theIterator - 1)))
								{
									bSpecialChar = TRUE;
									bPush = FALSE;
									break;						
								}
							}
						}
						
						sToken[nLoop] = m_pszCommandLine[nInd + m_nTokenStart];
						nLoop++;
						nInd++;

						if(m_pszCommandLine[nInd - 1 + m_nTokenStart] == _T('"'))
						{
							while(nInd < nLength)
							{
								sToken[nLoop] = m_pszCommandLine[
														nInd + m_nTokenStart];
								nLoop++;
								nInd++;

								if(nInd < nLength &&
									m_pszCommandLine[nInd + m_nTokenStart] 
																== _T('"'))
								{
									if(m_pszCommandLine[nInd - 1 + m_nTokenStart] 
																	== _T('\\'))
									{
										m_bEscapeSeq = TRUE;
									}
									else
									{
										sToken[nLoop] = m_pszCommandLine[
														nInd + m_nTokenStart];
										nLoop++;
										nInd++;
										break;
									}
								}														
								
							}
						}

					}

					// terminate the string with '\0' 
					sToken[nLoop] = _T('\0');
					UnQuoteString(sToken);
					
					// If Escape sequence flag is set
					if (m_bEscapeSeq)
					{
						try
						{
							CHString	sTemp((WCHAR*)sToken);
							/* Remove the escape sequence character i.e \ */
							RemoveEscapeChars(sTemp);
							lstrcpy(sToken, sTemp);
							m_bEscapeSeq = FALSE;
						}
						catch(CHeap_Exception)
						{
							throw OUT_OF_MEMORY;
						}
						catch(...)
						{
							throw OUT_OF_MEMORY;		
						}
					}

					_TCHAR* sTokenTemp = NULL;

					sTokenTemp = new _TCHAR[nLoop + 1];
					if (sTokenTemp == NULL)
						throw OUT_OF_MEMORY;
					lstrcpy(sTokenTemp,sToken);

					if(bPush == TRUE || lstrlen(sTokenTemp) > 0)
						m_cvTokens.push_back(sTokenTemp);
					else
						SAFEDELETE(sTokenTemp);

					//reset m_FormatToken if next switch is expected
					if(m_bFormatToken == TRUE && IsOption(sTokenTemp))
						m_bFormatToken = FALSE;
					
					//if the character is found to be a special character
					if(bSpecialChar == TRUE)
					{
						sToken[0] = m_pszCommandLine[nInd + m_nTokenStart];
						sToken[1] = _T('\0');
						sTokenTemp = new _TCHAR[2];
						if (sTokenTemp == NULL)
							throw OUT_OF_MEMORY;
						lstrcpy(sTokenTemp,sToken);
						bSpecialChar = FALSE;
						nLoop = 0;
						nInd++;
						m_cvTokens.push_back(sTokenTemp);
						bPush = TRUE;
						theIterator++;
											
					}
				}
				SAFEDELETE(sToken);
			}
			catch(...)
			{
				SAFEDELETE(sToken);
				throw OUT_OF_MEMORY;
			}
		}
		else
			throw OUT_OF_MEMORY;
	}
	return sToken;
}
/*------------------------------------------------------------------------
   Name				 :GetTokenVector
   Synopsis	         :This function returns a reference to the token 
					  vector
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :CHARVECTOR&
   Global Variables  :None
   Calling Syntax    :GetTokenVector()
   Notes             :None
------------------------------------------------------------------------*/
CHARVECTOR& CCmdTokenizer::GetTokenVector()
{
	return m_cvTokens;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\cmdalias.cpp ===
/*****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: CmdAlias.cpp 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: The CmdAlias class encapsulates the 
							  functionality for retrieving alias information.
Revision History			: 
		Last Modified By	: C V Nandi
		Last Modified Date	: 16th-March-2001
*****************************************************************************/
#include "Precomp.h"
#include "GlobalSwitches.h"
#include "CommandSwitches.h"
#include "HelpInfo.h"
#include "ErrorLog.h"
#include "ParsedInfo.h"
#include "CmdAlias.h"
#include "CmdTokenizer.h"
#include "ErrorInfo.h"
#include "WMICliXMLLog.h"
#include "ParserEngine.h"
#include "ExecEngine.h"
#include "FormatEngine.h"
#include "WmiCmdLn.h"

/*----------------------------------------------------------------------------
   Name				 :CCmdAlias
   Synopsis	         :This function initializes the member variables when an 
					  object of the class type is instantiated.
   Type	             :Constructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
----------------------------------------------------------------------------*/
CCmdAlias::CCmdAlias()
{
	m_pIAliasNS			= NULL;
	m_pILocalizedNS		= NULL;
	m_bTrace			= FALSE;
	m_eloErrLogOpt		= NO_LOGGING;
}

/*----------------------------------------------------------------------------
   Name				 :~CCmdAlias
   Synopsis	         :This function uninitializes the member variables when an
					  object of the class type goes out of scope.
   Type	             :Destructor
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
----------------------------------------------------------------------------*/
CCmdAlias::~CCmdAlias()
{
	SAFEIRELEASE(m_pIAliasNS);
	SAFEIRELEASE(m_pILocalizedNS);
}

/*----------------------------------------------------------------------------
   Name				 :Uninitialize
   Synopsis	         :This function uninitializes the member variables when 
					  the execution of a command string issued on the command 
					  line is completed.
   Type	             :Member Function
   Input Parameter(s):
			bFinal	- boolean value which when set indicates that the program
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :Uninitialize(bFinal)
   Notes             :None
----------------------------------------------------------------------------*/
void CCmdAlias::Uninitialize(BOOL bFinal)
{
	m_bTrace = FALSE;
	// If end of program 
	if (bFinal)
	{
		SAFEIRELEASE(m_pILocalizedNS);
		SAFEIRELEASE(m_pIAliasNS);
	}
}

/*----------------------------------------------------------------------------
   Name				 :ConnectToAlias
   Synopsis          :This function connects to WMI namespace on the specified
					  machine using the information available CParsedInfo 
					  class object.
   Type	             :Member Function
   Input parameter(s):
		rParsedInfo   - reference to CParsedInfo class object.
		pIWbemLocator - IWbemLocator object for connecting to WMI .						
   Output parameter(s):
		rParsedInfo   - reference to CParsedInfo class object.
   Return Type       :HRESULT  
   Global Variables  :None
   Calling Syntax    :ConnectToAlias(rParsedInfo,pIWbemLocator)
   Notes             :None
----------------------------------------------------------------------------*/
HRESULT CCmdAlias::ConnectToAlias(CParsedInfo& rParsedInfo, 
								  IWbemLocator* pIWbemLocator)
{
	// Get current thread for logging the success or failure of the command.
	DWORD	dwThreadId	= GetCurrentThreadId();
	HRESULT hr			= S_OK;

	// Set the trace flag 
	m_bTrace		= rParsedInfo.GetGlblSwitchesObject().GetTraceStatus();
	m_eloErrLogOpt	= rParsedInfo.GetErrorLogObject().GetErrLogOption();

	try
	{
		// If the /ROLE has been changed since last invocation
		if (rParsedInfo.GetGlblSwitchesObject().GetRoleFlag() == TRUE)
		{
			SAFEIRELEASE(m_pIAliasNS);
			CHString chsMsg;
			
			// Connect to the specified namespace of Windows Management on the
			// local computer using the locator object. 
			hr = Connect(pIWbemLocator, &m_pIAliasNS,
					_bstr_t(rParsedInfo.GetGlblSwitchesObject().GetRole()),
					NULL, NULL,	_bstr_t(rParsedInfo.GetGlblSwitchesObject().
					GetLocale()), rParsedInfo);

			// If /TRACE is ON
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format( 
						 L"IWbemLocator::ConnectServer(L\"%s\", NULL, NULL, "
						 L"L\"%s\", 0L, NULL, NULL, -)",
						rParsedInfo.GetGlblSwitchesObject().GetRole(),
						rParsedInfo.GetGlblSwitchesObject().GetLocale());

				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
								   dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);
			
			// Set the interface level security
			hr = 
				SetSecurity(m_pIAliasNS, NULL, NULL, NULL, NULL,
				 rParsedInfo.GetGlblSwitchesObject().GetAuthenticationLevel(),
				 rParsedInfo.GetGlblSwitchesObject().GetImpersonationLevel());

			// If /TRACE is ON
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"CoSetProxyBlanket(-, RPC_C_AUTHN_WINNT, "
							L"RPC_C_AUTHZ_NONE, NULL, %d, %d, -, EOAC_NONE)",
				 rParsedInfo.GetGlblSwitchesObject().GetAuthenticationLevel(),
				 rParsedInfo.GetGlblSwitchesObject().GetImpersonationLevel());

				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
									dwThreadId, rParsedInfo, m_bTrace);
			}
			
			ONFAILTHROWERROR(hr);
			rParsedInfo.GetGlblSwitchesObject().SetRoleFlag(FALSE);
			
		}

		// Connect to the localized Namespace
		hr = ConnectToLocalizedNS(rParsedInfo, pIWbemLocator);
		ONFAILTHROWERROR(hr);
	}

	catch(_com_error& e)
	{
		// Set the COM error
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}

	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :ObtainAliasInfo
   Synopsis          :Obtains the following info of the alias specified.
					  1. alias PWhere expression
					  2. alias target string
					  3. alias description
					  from the alias definition and updates the information in
					  the CParsedInfo object passed as reference.
   Type	             :Member Function
   Input parameter(s):
		rParsedInfo   - The parsed info from command line input.
   Output parameter(s):
   		rParsedInfo   - The parsed info from command line input.		
   Return Type       :RETCODE  
   Global Variables  :None
   Calling Syntax    :ObtainAliasInfo(rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CCmdAlias::ObtainAliasInfo(CParsedInfo& rParsedInfo)
{
	// Variables being used in this function.
	IWbemClassObject	*pIWbemObj			= NULL;
	IUnknown			*pIUnknown			= NULL;
	IWbemClassObject	*pIEmbedObj			= NULL;
	HRESULT				hr					= S_OK;
	RETCODE				retCode				= PARSER_CONTINUE;
	DWORD				dwThreadId			= GetCurrentThreadId();

	// Variants to save the properties and also for the embedded objects.
	VARIANT	vtProp, vtEmbedProp;
	VariantInit(&vtProp);
	VariantInit(&vtEmbedProp);

	try
	{
		_bstr_t			bstrResult;
		CHString		chsMsg;
		// Object path of the required alias.
		_bstr_t bstrPath = _bstr_t("MSFT_CliAlias.FriendlyName='") +
							_bstr_t(rParsedInfo.GetCmdSwitchesObject().
								GetAliasName()) + _bstr_t(L"'");

		//Retrieving the object from the namespace in m_pIAliasNS
		hr = m_pIAliasNS->GetObject(bstrPath, 0, NULL, &pIWbemObj, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", 0, NULL, -)",
														   (WCHAR*) bstrPath);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
								dwThreadId, rParsedInfo, m_bTrace);
		}
		// To set errata code that indicates a more user friendly error
		// message to the user.
		if ( FAILED ( hr ) )
		{
			// Don't set com error in catch block.
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
													   IDS_E_ALIAS_NOT_FOUND);
		}
		ONFAILTHROWERROR(hr);

		//1. Retrieve the value of 'Target' property object
		hr = pIWbemObj->Get(_bstr_t(L"Target"), 0, &vtProp, 0, 0 );
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemClassObject::Get(L\"Target\", 0, -, 0, 0)");
			GetBstrTFromVariant(vtProp, bstrResult);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
							   (LPCWSTR)chsMsg, dwThreadId, rParsedInfo,
							   m_bTrace, 0, bstrResult);
		}
		ONFAILTHROWERROR(hr);

		if (vtProp.vt != VT_NULL && vtProp.vt != VT_EMPTY)
		{
			if(!rParsedInfo.GetCmdSwitchesObject().SetAliasTarget(
													(_TCHAR*)vtProp.bstrVal))
			{
				rParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(OUT_OF_MEMORY);
				retCode = PARSER_OUTOFMEMORY;
			}
		}
		if(retCode != PARSER_OUTOFMEMORY)
		{
			VARIANTCLEAR(vtProp);

			//2. Retrieve the value of 'PWhere' property object
			VariantInit(&vtProp);
			hr = pIWbemObj->Get(_bstr_t(L"PWhere"), 0, &vtProp, 0, 0);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemClassObject::Get(L\"PWhere\", 0, -,"
																    L"0, 0)");
				GetBstrTFromVariant(vtProp, bstrResult);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
									dwThreadId, rParsedInfo, m_bTrace,
									0, bstrResult);
			}
			ONFAILTHROWERROR(hr);

			if (vtProp.vt != VT_NULL && vtProp.vt != VT_EMPTY)
			{
				if(!rParsedInfo.GetCmdSwitchesObject().SetPWhereExpr(
													(_TCHAR*)vtProp.bstrVal))
				{
					rParsedInfo.GetCmdSwitchesObject().
												SetErrataCode(OUT_OF_MEMORY);
					retCode = PARSER_OUTOFMEMORY;
				}
			}
			if(retCode != PARSER_OUTOFMEMORY)
			{
				VARIANTCLEAR(vtProp);

				// Retrieve the  "Connection" property value
				VariantInit(&vtProp);
				hr = pIWbemObj->Get(_bstr_t(L"Connection"), 0, &vtProp, 0, 0);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Get(L\"Connection\","
															  L"0, -, 0, 0)");
					GetBstrTFromVariant(vtProp, bstrResult);
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
										dwThreadId, rParsedInfo, m_bTrace,
										 0, bstrResult);
				}
				ONFAILTHROWERROR(hr);

				if (vtProp.vt != VT_NULL && vtProp.vt != VT_EMPTY)
				{
					pIUnknown = vtProp.punkVal;
					hr = pIUnknown->QueryInterface(IID_IWbemClassObject,
													(void**)&pIEmbedObj);

					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(L"QueryInterface("
												 L"IID_IWbemClassObject, -)");
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
											(LPCWSTR)chsMsg, dwThreadId, 
											rParsedInfo, m_bTrace);
					}
					ONFAILTHROWERROR(hr);

					retCode = 
						   ObtainAliasConnectionInfo(rParsedInfo, pIEmbedObj);

					//Releasing the embedded object.
					SAFEIRELEASE(pIEmbedObj);
					VARIANTCLEAR(vtProp);
				}
			}
		}

		// Obtain the alias description
		if (retCode != PARSER_OUTOFMEMORY)
		{
			_bstr_t bstrDesc;
			hr = GetDescOfObject(pIWbemObj, bstrDesc, rParsedInfo, TRUE);
			ONFAILTHROWERROR(hr);
		
			if(!rParsedInfo.GetCmdSwitchesObject().
											  SetAliasDesc((_TCHAR*)bstrDesc))
			{
				rParsedInfo.GetCmdSwitchesObject().
												 SetErrataCode(OUT_OF_MEMORY);
				retCode = PARSER_OUTOFMEMORY;
			}
		}
		SAFEIRELEASE(pIWbemObj);
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIWbemObj);
		SAFEIRELEASE(pIEmbedObj);
		VARIANTCLEAR(vtProp);
		VARIANTCLEAR(vtEmbedProp);

		// No errata code then set com error. 
		if ( rParsedInfo.GetCmdSwitchesObject().GetErrataCode() == 0 )
			rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		retCode = PARSER_ERRMSG;
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIWbemObj);
		SAFEIRELEASE(pIEmbedObj);
		VARIANTCLEAR(vtProp);
		VARIANTCLEAR(vtEmbedProp);
		retCode = PARSER_ERRMSG;
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ObtainAliasConnectionInfo
   Synopsis          : Obtain the alias connection information like
					   1. namespace		2. user		3. password
					   4. locale		5. server	6. authority
   Type	             :Member Function
   Input parameter(s):
		rParsedInfo  - The parsed info from command line input.		
		pIEmbedObj	 - Pointer to the IWbem class object
   Output parameter(s):
   		rParsedInfo   - The parsed info from command line input.		
   Return Type       :RETCODE
   Global Variables  :None
   Calling Syntax    :ObtainAliasConnectionInfo(rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CCmdAlias::ObtainAliasConnectionInfo(CParsedInfo& rParsedInfo,
											 IWbemClassObject* pIEmbedObj)
{
	RETCODE retCode				= PARSER_CONTINUE;
	HRESULT	hr					= S_OK;
	UINT	uConnFlag			= 0;
	DWORD	dwThreadId			= GetCurrentThreadId();
	
	VARIANT vtEmbedProp;
	VariantInit(&vtEmbedProp);
	
	uConnFlag = rParsedInfo.GetGlblSwitchesObject().GetConnInfoFlag();

	try
	{
		CHString chsMsg;
		_bstr_t bstrResult;
		if (!(uConnFlag & NAMESPACE))
		{
			// retrieve the value of 'Namespace' property
			hr = pIEmbedObj->Get(_bstr_t(L"Namespace"), 0, &vtEmbedProp, 0,0);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemClassObject::Get(L\"Namespace\", 0, -,"
																	L"0, 0)");
				GetBstrTFromVariant(vtEmbedProp, bstrResult);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
									dwThreadId, rParsedInfo, m_bTrace,
								    0, bstrResult);
			}
			ONFAILTHROWERROR(hr);

			if (vtEmbedProp.vt != VT_NULL && vtEmbedProp.vt != VT_EMPTY)
			{
				if(!rParsedInfo.GetCmdSwitchesObject().SetAliasNamespace(
												(_TCHAR*)vtEmbedProp.bstrVal))
				{
					rParsedInfo.GetCmdSwitchesObject().
												 SetErrataCode(OUT_OF_MEMORY);
					retCode = PARSER_OUTOFMEMORY;
				}
				VARIANTCLEAR(vtEmbedProp);
			}
		}
		if(retCode != PARSER_OUTOFMEMORY)
		{
			if (!(uConnFlag & LOCALE))
			{
				// retrieve the value of 'Locale' property
				hr = pIEmbedObj->Get(_bstr_t(L"Locale"), 0, &vtEmbedProp,0,0);

				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Get(L\"Locale\", 0,"
																 L"-, 0, 0)");
					GetBstrTFromVariant(vtEmbedProp, bstrResult);
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg,
										dwThreadId, rParsedInfo, m_bTrace,
										0, bstrResult);
				}
				ONFAILTHROWERROR(hr);

				if (vtEmbedProp.vt != VT_NULL && vtEmbedProp.vt != VT_EMPTY)
				{
					if(!rParsedInfo.GetCmdSwitchesObject().SetAliasLocale(
												(_TCHAR*)vtEmbedProp.bstrVal))
					{
						rParsedInfo.GetCmdSwitchesObject().
												 SetErrataCode(OUT_OF_MEMORY);
						retCode = PARSER_OUTOFMEMORY;
					}
					VARIANTCLEAR(vtEmbedProp);
				}
			}

			if(retCode != PARSER_OUTOFMEMORY)
			{
				if (!(uConnFlag & USER))
				{
					// retrieve the value of 'User' property
					hr = 
					  pIEmbedObj->Get(_bstr_t(L"User"), 0, &vtEmbedProp, 0,0);
					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(L"IWbemClassObject::Get(L\"User\", 0,"
																 L"-, 0, 0)");
					    GetBstrTFromVariant(vtEmbedProp, bstrResult);
						WMITRACEORERRORLOG( hr, __LINE__, __FILE__, 
											(LPCWSTR)chsMsg, dwThreadId, 
											rParsedInfo, m_bTrace,
										    0, bstrResult );
					}
					ONFAILTHROWERROR(hr);

					if (vtEmbedProp.vt != VT_NULL && 
						vtEmbedProp.vt != VT_EMPTY)
					{
						if(!rParsedInfo.GetCmdSwitchesObject().SetAliasUser(
											    (_TCHAR*)vtEmbedProp.bstrVal))
						{
							rParsedInfo.GetCmdSwitchesObject().
												 SetErrataCode(OUT_OF_MEMORY);
							retCode = PARSER_OUTOFMEMORY;
						}
						VARIANTCLEAR(vtEmbedProp);
					}
				}
				
				if(retCode != PARSER_OUTOFMEMORY)
				{
					if (!(uConnFlag & PASSWORD))
					{
						// retrieve the value of 'Password' property
						hr = pIEmbedObj->Get(_bstr_t(L"Password"), 
											 0, &vtEmbedProp, 0,0);
						if (m_bTrace || m_eloErrLogOpt)
						{
							chsMsg.Format(L"IWbemClassObject::Get"
											  L"(L\"Password\", 0, -, 0, 0)");
							GetBstrTFromVariant(vtEmbedProp, bstrResult);
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__,
											   (LPCWSTR)chsMsg, dwThreadId, 
											   rParsedInfo, m_bTrace,
											   0, bstrResult);
						}
						ONFAILTHROWERROR(hr);

						if (vtEmbedProp.vt != VT_NULL && 
							vtEmbedProp.vt != VT_EMPTY)
						{
							if(!rParsedInfo.GetCmdSwitchesObject().
							   SetAliasPassword((_TCHAR*)vtEmbedProp.bstrVal))
							{
								rParsedInfo.GetCmdSwitchesObject().
												 SetErrataCode(OUT_OF_MEMORY);
								retCode = PARSER_OUTOFMEMORY;
							}
							VARIANTCLEAR(vtEmbedProp);
						}
					}
					if(retCode != PARSER_OUTOFMEMORY)
					{
						if (!(uConnFlag & NODE))
						{
							// retrieve the value of 'Server' property
							hr = pIEmbedObj->Get(_bstr_t(L"Server"),
												 0, &vtEmbedProp, 0,0);
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(L"IWbemClassObject::Get"
												L"(L\"Server\", 0, -, 0, 0)");
								GetBstrTFromVariant(vtEmbedProp, bstrResult);
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__,
												   (LPCWSTR)chsMsg,dwThreadId,
												   rParsedInfo, m_bTrace,
												   0, bstrResult);
							}
							ONFAILTHROWERROR(hr);

							if (vtEmbedProp.vt != VT_NULL && 
								vtEmbedProp.vt != VT_EMPTY)
							{
								if(!rParsedInfo.GetCmdSwitchesObject().
								   SetAliasNode((_TCHAR*)vtEmbedProp.bstrVal))
								{
									rParsedInfo.GetCmdSwitchesObject().
												 SetErrataCode(OUT_OF_MEMORY);
									retCode = PARSER_OUTOFMEMORY;
								}
								VARIANTCLEAR(vtEmbedProp);
							}
						}

						if (retCode != PARSER_OUTOFMEMORY)
						{
							// retrieve the value of 'Authority' property
							hr = pIEmbedObj->Get(_bstr_t(L"Authority"),
												 0, &vtEmbedProp, 0,0);
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(L"IWbemClassObject::Get"
											 L"(L\"Authority\", 0, -, 0, 0)");
								GetBstrTFromVariant(vtEmbedProp, bstrResult);
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
												   (LPCWSTR)chsMsg,dwThreadId,
												   rParsedInfo, m_bTrace,
												   0, bstrResult);
							}
							ONFAILTHROWERROR(hr);

							if (vtEmbedProp.vt != VT_NULL && 
								vtEmbedProp.vt != VT_EMPTY)
							{
								if(!rParsedInfo.GetGlblSwitchesObject().
								   SetAuthority((_TCHAR*)vtEmbedProp.bstrVal))
								{
									rParsedInfo.GetCmdSwitchesObject().
												 SetErrataCode(OUT_OF_MEMORY);
									retCode = PARSER_OUTOFMEMORY;
								}
								VARIANTCLEAR(vtEmbedProp);
							}
						}
					}
				}
			}
		}
	}
	catch(_com_error& e)
	{	
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		retCode = PARSER_OUTOFMEMORY;
		VARIANTCLEAR(vtEmbedProp);
	}
	catch(CHeap_Exception)
	{
		retCode = PARSER_OUTOFMEMORY;
		VARIANTCLEAR(vtEmbedProp);
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return retCode;
}


/*----------------------------------------------------------------------------
   Name				 :ObtainAliasVerbDetails
   Synopsis          :Obtains the verbs and their details associated with the 
					  alias object and updates the CCommandSwitches  of 
					  CParsedInfo object passed to it.
   Type	             :Member Function
   Input parameter(s):
		rParsedInfo   - The parsed info from command line input.
   Output parameter(s):
   		rParsedInfo   - The parsed info from command line input.		
   Return Type       :HRESULT  
   Global Variables  :None
   Calling Syntax    :ObtainAliasVerbDetails(rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
HRESULT CCmdAlias::ObtainAliasVerbDetails(CParsedInfo& rParsedInfo)
{
	// variables being used in this function.
	IWbemClassObject	*pIWbemObj			= NULL;
	IWbemClassObject	*pIEmbedObj			= NULL;
	IWbemClassObject	*pIEmbedObj2		= NULL;
	HRESULT				hr					= S_OK;
	_TCHAR				szNumber[BUFFER512] = NULL_STRING; 
	DWORD				dwThreadId			= GetCurrentThreadId();
	VARIANT				vtVerbs,	vtVerbName, vtParameters, 
						vtParaId,	vtParaType,	vtVerbType, 
						vtVerbDerivation, vtDefaultParamValue;	
	VariantInit(&vtVerbs);
	VariantInit(&vtVerbName);
	VariantInit(&vtParameters);
	VariantInit(&vtParaId);
	VariantInit(&vtParaType);
	VariantInit(&vtVerbType);
	VariantInit(&vtVerbDerivation);
	VariantInit(&vtDefaultParamValue);
	try
	{
		CHString chsMsg;
		_bstr_t             bstrResult;
		// Initialize methDetMap each time.
		rParsedInfo.GetCmdSwitchesObject().GetMethDetMap().clear();

		_bstr_t bstrPath = _bstr_t("MSFT_CliAlias.FriendlyName='") + 
				   _bstr_t(rParsedInfo.GetCmdSwitchesObject().GetAliasName())+
				   _bstr_t(L"'");

		//Retrieving the object from the namespace in m_pIAliasNS
		hr = m_pIAliasNS->GetObject(bstrPath, 0, NULL, &pIWbemObj, NULL);

		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", 0, NULL, -)",
														   (WCHAR*) bstrPath);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
										   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Obtain verb name and method name to get info of verb name
		// or method name only if they are specified.
		_TCHAR* pVerbName = rParsedInfo.GetCmdSwitchesObject().GetVerbName();
		_TCHAR* pMethodName = rParsedInfo.GetCmdSwitchesObject().
															  GetMethodName();

		BOOL bCompareVerb = FALSE, bCompareMethod = FALSE;
		if ( pVerbName != NULL &&
			CompareTokens(pVerbName,CLI_TOKEN_CALL) &&
			pMethodName != NULL )
			bCompareMethod = TRUE;
		else if ( pVerbName != NULL &&
				  !CompareTokens(pVerbName,CLI_TOKEN_CALL))
				  bCompareVerb = TRUE;

		// Get "Verbs" property.
		hr = pIWbemObj->Get(_bstr_t(L"Verbs"), 0, &vtVerbs, 0, 0) ;
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemClassObject::Get(L\"Verbs\", 0, -, 0, 0)"); 
			GetBstrTFromVariant(vtVerbs, bstrResult);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
							   dwThreadId, rParsedInfo, m_bTrace,
							   0, bstrResult);
		}
		ONFAILTHROWERROR(hr);

		if ( vtVerbs.vt != VT_EMPTY && vtVerbs.vt != VT_NULL)
		{
			// Get lower and upper bounds of Verbs array
			LONG lUpper = 0, lLower = 0;
			hr = SafeArrayGetLBound(vtVerbs.parray, vtVerbs.parray->cDims,
									&lLower);
			if ( m_eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetLBound(-, -, -)"); 
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
								   dwThreadId, rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			hr = SafeArrayGetUBound(vtVerbs.parray, vtVerbs.parray->cDims,
									&lUpper);
			if ( m_eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetUBound(-, -, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
								   dwThreadId, rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			for (LONG lIndex = lLower; lIndex <= lUpper; lIndex++)
			{
				pIEmbedObj = NULL;
				// Get "Name" property.
				hr = SafeArrayGetElement(vtVerbs.parray,&lIndex,&pIEmbedObj);
				if ( m_eloErrLogOpt )
				{
					chsMsg.Format(L"SafeArrayGetElement(-, -, -)");
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg,
									   dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);
	
				hr = pIEmbedObj->Get(_bstr_t(L"Name"),0,&vtVerbName,0,0);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Get(L\"Name\", 0, -,"
																    L"0, 0)");
					GetBstrTFromVariant(vtVerbName, bstrResult);
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg,
									   dwThreadId, rParsedInfo, m_bTrace,
									   0, bstrResult);
				}
				ONFAILTHROWERROR(hr);

				// if user defined verb or method is specified then get info
				// of only related to user defined or method name.
				BOOL bContinue = FALSE;
				if ( bCompareMethod == TRUE &&
					 !CompareTokens(pMethodName,
								  (_TCHAR*)_bstr_t(vtVerbName.bstrVal) ) )
					bContinue = TRUE;
				else if ( bCompareVerb == TRUE &&
						 !CompareTokens(pVerbName,
										(_TCHAR*)_bstr_t(vtVerbName.bstrVal)))
					bContinue = TRUE;

				if ( bContinue == TRUE )
				{
					SAFEIRELEASE(pIEmbedObj);
					continue;
				}

				_bstr_t bstrDesc;
				hr = GetDescOfObject(pIEmbedObj, bstrDesc, rParsedInfo);
				ONFAILTHROWERROR(hr);
				
				//  Obtaining the input parameters and thier type.
				// Get "Parameters" property.
				hr = pIEmbedObj->Get(_bstr_t(L"Parameters"), 
									 0, &vtParameters, 0, 0);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Get(L\"Parameters\","
															  L"0, -, 0, 0)");
					GetBstrTFromVariant(vtParameters, bstrResult);
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg, 
									   dwThreadId, rParsedInfo, m_bTrace,
									   0, bstrResult);
				}
				ONFAILTHROWERROR(hr);

				if ( vtVerbName.vt != VT_EMPTY && vtVerbName.vt != VT_NULL )
				{
					if ( bCompareVerb == TRUE || bCompareMethod == TRUE)
					{
						// Get "VerbType" property.
						hr = pIEmbedObj->Get(_bstr_t(L"VerbType"),
											 0, &vtVerbType, 0, 0);
						if (m_bTrace || m_eloErrLogOpt)
						{
							chsMsg.Format(L"IWbemClassObject::Get"
											  L"(L\"VerbType\", 0, -, 0, 0)");
							GetBstrTFromVariant(vtVerbType, bstrResult);
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
											   (LPCWSTR)chsMsg, dwThreadId,
											   rParsedInfo, m_bTrace, 
											   0, bstrResult );
						}
						ONFAILTHROWERROR(hr);

						if ( vtVerbType.vt == VT_I4 )
						{
							rParsedInfo.GetCmdSwitchesObject().SetVerbType(
												 VERBTYPE(V_I4(&vtVerbType)));
						}
						else
						{
							rParsedInfo.GetCmdSwitchesObject().SetVerbType(
																	NONALIAS);
						}
						
						// Get "Derivation" property.
						hr = pIEmbedObj->Get(_bstr_t(L"Derivation"), 0,
											 &vtVerbDerivation, 0, 0);
						if (m_bTrace || m_eloErrLogOpt)
						{
							chsMsg.Format(L"IWbemClassObject::Get"
											L"(L\"Derivation\", 0, -, 0, 0)");
							GetBstrTFromVariant(vtVerbDerivation, bstrResult);
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
											   (LPCWSTR)chsMsg, dwThreadId,
											   rParsedInfo, m_bTrace,
											   0, bstrResult);
					
						}
						ONFAILTHROWERROR(hr);

						if ( vtVerbDerivation.vt == VT_BSTR )
							rParsedInfo.GetCmdSwitchesObject().
										SetVerbDerivation(
										 _bstr_t(vtVerbDerivation.bstrVal));
					}

					METHODDETAILS mdMethDet;
					mdMethDet.Description = bstrDesc;
					if ( vtParameters.vt != VT_EMPTY && 
						 vtParameters.vt != VT_NULL )
					{
						// Get lower and upper bounds of Descriptions array
						LONG lUpper = 0, lLower = 0;
						hr = SafeArrayGetLBound(vtParameters.parray,
									vtParameters.parray->cDims, &lLower);
						if ( m_eloErrLogOpt )
						{
							chsMsg.Format(L"SafeArrayGetLBound(-, -, -)");
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
											   (LPCWSTR)chsMsg, dwThreadId, 
											   rParsedInfo, FALSE);
						}
						ONFAILTHROWERROR(hr);

						hr = SafeArrayGetUBound(vtParameters.parray,
										 vtParameters.parray->cDims, &lUpper);
						if ( m_eloErrLogOpt )
						{
							chsMsg.Format(L"SafeArrayGetUBound(-, -, -)"); 
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
											   (LPCWSTR)chsMsg, dwThreadId,
											   rParsedInfo, FALSE);
						}
						ONFAILTHROWERROR(hr);

						for (LONG lIndex = lLower; lIndex <= lUpper; lIndex++)
						{
							hr = SafeArrayGetElement(vtParameters.parray,
													 &lIndex, &pIEmbedObj2);
							if ( m_eloErrLogOpt )
							{
								chsMsg.Format(L"SafeArrayGetElement(-, -, -)");
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
												   (LPCWSTR)chsMsg,dwThreadId,
												   rParsedInfo, FALSE);
							}
							ONFAILTHROWERROR(hr);
							
							// Get "ParaId" property.
							hr = pIEmbedObj2->Get(_bstr_t(L"ParaId"),
												  0, &vtParaId, 0, 0);
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(L"IWbemClassObject::Get"
												L"(L\"ParaId\", 0, -, 0, 0)");
								GetBstrTFromVariant(vtParaId, bstrResult);
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
												   (LPCWSTR)chsMsg,dwThreadId,
												   rParsedInfo, m_bTrace,
												   0, bstrResult);
							}
							ONFAILTHROWERROR(hr);

							// Get "Type" property.
							hr = pIEmbedObj2->Get(_bstr_t(L"Type"), 0,
												  &vtParaType, 0, 0);
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(L"IWbemClassObject::Get"
												  L"(L\"Type\", 0, -, 0, 0)");
								GetBstrTFromVariant(vtParaType, bstrResult);
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
												   (LPCWSTR)chsMsg,dwThreadId,
												   rParsedInfo, m_bTrace,
												   0, bstrResult);
							}
							ONFAILTHROWERROR(hr);

							// Get "Default" property.
							hr = pIEmbedObj2->Get(_bstr_t(L"Default"), 0,
												  &vtDefaultParamValue, 0, 0);
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(L"IWbemClassObject::Get"
											   L"(L\"Default\", 0, -, 0, 0)");
								GetBstrTFromVariant(vtDefaultParamValue, 
													bstrResult);
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
												   (LPCWSTR)chsMsg,dwThreadId,
												   rParsedInfo, m_bTrace,
												   0, bstrResult);
							}
							ONFAILTHROWERROR(hr);

							if ( vtParaId.vt != VT_EMPTY && 
								 vtParaId.vt != VT_NULL )
							{
								PROPERTYDETAILS pdPropDet;

								pdPropDet.InOrOut = UNKNOWN;
								hr = GetQualifiers(pIEmbedObj2, pdPropDet,
												   rParsedInfo);

								if ( vtParaType.vt == VT_BSTR )
									pdPropDet.Type = vtParaType.bstrVal;
								else
									pdPropDet.Type = _bstr_t("Not Available");

								if ( vtDefaultParamValue.vt == VT_BSTR )
									pdPropDet.Default = vtDefaultParamValue.
														bstrVal;

								// Making bstrPropName begin with numbers to 
								// maintain the order of method arguments in
								// map. while displaying remove numbers and 
								// display the parameters in case of help only

								// Also for named paramlist and cmdline 
								// utility processing.
								_bstr_t bstrNumberedPropName; 
								if ( rParsedInfo.GetGlblSwitchesObject().
															  GetHelpFlag() ||
									 rParsedInfo.GetCmdSwitchesObject().
													GetVerbType() == CMDLINE )
								{
									_TCHAR szMsg[BUFFER512];
									_ltot(lIndex, szNumber, 10);
									_stprintf(szMsg, _T("%-5s"), szNumber);
									bstrNumberedPropName = _bstr_t(szMsg) +
													_bstr_t(vtParaId.bstrVal);
								}
								else
									bstrNumberedPropName = 
													_bstr_t(vtParaId.bstrVal);

								mdMethDet.Params.insert(
									PROPDETMAP::value_type(
											bstrNumberedPropName, pdPropDet));
							}
							
							VARIANTCLEAR(vtParaId);
							VARIANTCLEAR(vtParaType);
							VARIANTCLEAR(vtDefaultParamValue);
							SAFEIRELEASE(pIEmbedObj2);
						}
					}

					rParsedInfo.GetCmdSwitchesObject().AddToMethDetMap
											  (vtVerbName.bstrVal, mdMethDet);
				}

				VARIANTCLEAR(vtVerbName);
				VARIANTCLEAR(vtVerbType);
				VARIANTCLEAR(vtVerbDerivation);
				VARIANTCLEAR(vtParameters);
				SAFEIRELEASE(pIEmbedObj);
				if ( bCompareVerb == TRUE || bCompareMethod == TRUE)
					break;
			}
		}	
		VARIANTCLEAR(vtVerbs);
		SAFEIRELEASE(pIWbemObj);
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIWbemObj);
		SAFEIRELEASE(pIEmbedObj);
		VARIANTCLEAR(vtVerbs);
		VARIANTCLEAR(vtVerbName);
		VARIANTCLEAR(vtVerbType);
		VARIANTCLEAR(vtVerbDerivation);
		VARIANTCLEAR(vtDefaultParamValue);
		hr = e.Error();
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIWbemObj);
		SAFEIRELEASE(pIEmbedObj);
		VARIANTCLEAR(vtVerbs);
		VARIANTCLEAR(vtVerbName);
		VARIANTCLEAR(vtVerbType);
		VARIANTCLEAR(vtVerbDerivation);
		VARIANTCLEAR(vtDefaultParamValue);
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :ObtainAliasFriendlyNames
   Synopsis          :Obtains all the Friendly Names and descriptions in the 
					  CmdAlias and updates it in the CCommandSwitches of 
					  CParsedInfo object passed to it.
   Type	             :Member Function
   Input parameter(s):
		rParsedInfo   - The parsed info from command line input.		
   Output parameter(s):
   		rParsedInfo   - The parsed info from command line input.		
   Return Type       :HRESULT  
   Global Variables  :None
   Calling Syntax    :ObtainAliasFriendlyNames(rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
HRESULT CCmdAlias::ObtainAliasFriendlyNames(CParsedInfo& rParsedInfo)
{
	// variables being used in this function.
	HRESULT hr = S_OK;
	IEnumWbemClassObject		*pIEnumObj			= NULL;
	IWbemClassObject			*pIWbemObj			= NULL;
	DWORD						dwThreadId			= GetCurrentThreadId();
	VARIANT						vtName;
	VariantInit(&vtName);
	
	try
	{
		CHString chsMsg;
		_bstr_t						bstrResult;
		// Get alias object
		hr = m_pIAliasNS->ExecQuery(_bstr_t(L"WQL"), 
									_bstr_t(L"SELECT * FROM MSFT_CliAlias"),
									WBEM_FLAG_FORWARD_ONLY|
									WBEM_FLAG_RETURN_IMMEDIATELY,
									NULL, &pIEnumObj);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemServices::ExecQuery(L\"WQL\"," 
					  L"L\"SELECT * FROM MSFT_CliAlias\","
					  L"WBEM_FLAG_FORWARD_ONLY|WBEM_FLAG_RETURN_IMMEDIATELY,"
					  L"NULL, -)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Set the security
		hr = SetSecurity(pIEnumObj, NULL, NULL, NULL, NULL,
				rParsedInfo.GetGlblSwitchesObject().GetAuthenticationLevel(),
				rParsedInfo.GetGlblSwitchesObject().GetImpersonationLevel());

		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format( 
				L"CoSetProxyBlanket(-, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,"
				L"NULL, %d,   %d, -, EOAC_NONE)",
				rParsedInfo.GetGlblSwitchesObject().GetAuthenticationLevel(),
				rParsedInfo.GetGlblSwitchesObject().GetImpersonationLevel());
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		ULONG ulReturned = 0; 
		
	 	// Obtain the object starting at the current position in the
		// enumeration and loop through the instance list.
		while(((hr=pIEnumObj->Next(WBEM_INFINITE,1,&pIWbemObj,&ulReturned))==
												   S_OK) && (ulReturned == 1))
		{
			VariantInit(&vtName);

			// Gets "FriendlyName" array property of alias object
			hr = pIWbemObj->Get(_bstr_t(L"FriendlyName"), 0, &vtName, 0, 0);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemClassObject::Get(L\"FriendlyName\", 0,"
	     														 L"-, 0, 0)");
		        GetBstrTFromVariant(vtName, bstrResult);		
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace,
								   0, bstrResult);
			}
			ONFAILTHROWERROR(hr);

			if (vtName.vt != VT_NULL && vtName.vt != VT_EMPTY)
			{
				_bstr_t bstrFriendlyName = vtName.bstrVal;
				_bstr_t bstrDesc;
				hr = GetDescOfObject(pIWbemObj, bstrDesc, rParsedInfo, TRUE);
				ONFAILTHROWERROR(hr);

				//Add the "FriendlyName" to FriendlyName Map
				rParsedInfo.GetCmdSwitchesObject().
						AddToAlsFrnNmsOrTrnsTblMap(CharUpper(bstrFriendlyName)
												   ,bstrDesc);
			}
			VARIANTCLEAR(vtName);
			SAFEIRELEASE(pIWbemObj);
		}
		SAFEIRELEASE(pIEnumObj);
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIEnumObj);
		SAFEIRELEASE(pIWbemObj);
		VARIANTCLEAR(vtName);
		hr = e.Error();
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIEnumObj);
		SAFEIRELEASE(pIWbemObj);
		VARIANTCLEAR(vtName);
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :ObtainAliasFormat
   Synopsis          :Obtains the Derivation of the properties for the Format 
					  associated with the alias object and updates the 
					  CCommandSwitches of CParsedInfo object passed to it.
   Type	             :Member Function
   Input parameter(s):
		rParsedInfo   - The parsed info from command line input.		
   Output parameter(s):
   		rParsedInfo   - The parsed info from command line input.		
   Return Type       :BOOL : TRUE - if valid format is not present
							 FALSE - if invalid format
   Global Variables  :None
   Calling Syntax    :ObtainAliasFormat(rParsedInfo)
   Notes             :If bCheckForListFrmsAvail == TRUE then functions checks 
					  only for availibilty of list formats with the alias.
----------------------------------------------------------------------------*/
BOOL CCmdAlias::ObtainAliasFormat(CParsedInfo& rParsedInfo,
								  BOOL bCheckForListFrmsAvail)
{
	// variables being used in this function.
	HRESULT				hr					= S_OK;
	IWbemClassObject	*pIWbemObj			= NULL;
	IWbemClassObject	*pIEmbedObj			= NULL;
	IWbemClassObject	*pIEmbedObj2		= NULL;
	BOOL				bExist				= FALSE;
	DWORD				dwThreadId			= GetCurrentThreadId();
	VARIANT				vtFormats, vtFormatName, 
						vtProperties, vtPropertyName, vtPropertyDerivation ;
	BOOL				bHelp				= rParsedInfo.
											  GetGlblSwitchesObject().
											  GetHelpFlag();
	// Initializing all Variants variables being used in this function.
	VariantInit(&vtFormats);
	VariantInit(&vtFormatName);
	VariantInit(&vtProperties);
	VariantInit(&vtPropertyName);
	VariantInit(&vtPropertyDerivation);

	try
	{
		CHString			chsMsg;
		_bstr_t				bstrResult;
		_bstr_t bstrPath = 	_bstr_t("MSFT_CliAlias.FriendlyName='") + 
				 _bstr_t(rParsedInfo.GetCmdSwitchesObject().GetAliasName())+
				 _bstr_t(L"'");

		// Get alias object
		hr = m_pIAliasNS->GetObject(bstrPath, 0, NULL, &pIWbemObj, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", 0, NULL, -)",
														   (WCHAR*) bstrPath);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Get Formats array property of alias object
		hr = pIWbemObj->Get(_bstr_t(L"Formats"), 0, &vtFormats, 0, 0);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemClassObject::Get(L\"Formats\", 0, -,0, 0)");
			GetBstrTFromVariant(vtFormats, bstrResult);		
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace,
							   0, bstrResult);
		}
		ONFAILTHROWERROR(hr);

		if ( vtFormats.vt != VT_NULL && vtFormats.vt != VT_EMPTY 
			 && bCheckForListFrmsAvail == FALSE)
		{
			// Get lower and upper bounds of Formats array
			LONG lUpper = 0, lLower = 0;
			hr = SafeArrayGetLBound(vtFormats.parray, vtFormats.parray->cDims,
									&lLower);
			if ( m_eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetLBound(-, -, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
								   dwThreadId, rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			hr = SafeArrayGetUBound(vtFormats.parray, vtFormats.parray->cDims,
									&lUpper);
			if ( m_eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetUBound(-, -, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			// Iterate through the Formats array property
			for (LONG lIndex = lLower; lIndex <= lUpper; lIndex++)
		    {
				// Get this property.
				hr =SafeArrayGetElement(vtFormats.parray,&lIndex,&pIEmbedObj);
				if ( m_eloErrLogOpt )
				{
					chsMsg.Format(L"SafeArrayGetElement(-, -, -)");
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg,
									   dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);

				hr = pIEmbedObj->Get(_bstr_t(L"Name"),0,&vtFormatName,0,0);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Get(L\"Name\", 0,"
																 L"-, 0, 0)");
					GetBstrTFromVariant(vtFormatName, bstrResult);		
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg, 
									   dwThreadId, rParsedInfo, m_bTrace,
									   0, bstrResult);
				}
				ONFAILTHROWERROR(hr);

				//Comparing the specified Format in the alias against the
				//formats available for the specified alias.
				if(CompareTokens(_bstr_t(rParsedInfo.GetCmdSwitchesObject().
						GetListFormat()), _bstr_t(vtFormatName.bstrVal)))
				{
					bExist = TRUE;

					VARIANT vtFormat;
					VariantInit(&vtFormat);
					//Getting the "Format" property.
					hr = pIEmbedObj->Get(_bstr_t(L"Format"),0, 
										 &vtFormat, 0, 0);
					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format( L"IWbemClassObject::Get(L\"Format\","
															  L"0, -, 0, 0)");
						GetBstrTFromVariant(vtFormat, bstrResult);		
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
										   (LPCWSTR)chsMsg, dwThreadId, 
										   rParsedInfo, m_bTrace,
										   0, bstrResult);
					}
					ONFAILTHROWERROR(hr);

					if ( vtFormat.vt != VT_EMPTY && vtFormat.vt != VT_NULL  )
					{
						if (rParsedInfo.GetCmdSwitchesObject(). 
											GetXSLTDetailsVector().empty())
						{
							_bstr_t bstrFileName ;
							
							// If _T("") is the value, it should be treated as 
							// equivalent to <empty>
							if (CompareTokens(vtFormat.bstrVal, _T("")))
							{
								bstrFileName = _bstr_t(CLI_TOKEN_TABLE);
							}
							else
							{
								bstrFileName = _bstr_t(vtFormat.bstrVal);
							}
							
							g_wmiCmd.GetFileFromKey(bstrFileName, bstrFileName);

							XSLTDET xdXSLTDet;
							xdXSLTDet.FileName = bstrFileName;
							FrameFileAndAddToXSLTDetVector(xdXSLTDet, 
														   rParsedInfo);
						}
					}
					VariantClear(&vtFormat);

					//Getting the "Properties" property.
					hr=pIEmbedObj->Get(_bstr_t(L"Properties"), 
									   0, &vtProperties, 0, 0);
					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(L"IWbemClassObject::Get(L\"Properties\","
															  L"0, -, 0, 0)");
						GetBstrTFromVariant(vtProperties, bstrResult);
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
										   (LPCWSTR)chsMsg, dwThreadId, 
										   rParsedInfo, m_bTrace,
										   0, bstrResult);
					}
					ONFAILTHROWERROR(hr);

					if ( vtProperties.vt != VT_NULL )
					{
						LONG lILower = 0, lIUpper = 0;
						hr = SafeArrayGetLBound(vtProperties.parray,
										vtProperties.parray->cDims, &lILower);
						if ( m_eloErrLogOpt )
						{
							chsMsg.Format(L"SafeArrayGetLBound(-, -, -)");
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
											   (LPCWSTR)chsMsg, dwThreadId, 
											   rParsedInfo, FALSE);
						}
						ONFAILTHROWERROR(hr);

						hr = SafeArrayGetUBound(vtProperties.parray,
										vtProperties.parray->cDims, &lIUpper);
						if ( m_eloErrLogOpt )
						{
							chsMsg.Format(L"SafeArrayGetUBound(-, -, -)");
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
											   (LPCWSTR)chsMsg, dwThreadId,
											   rParsedInfo, FALSE);
						}
						ONFAILTHROWERROR(hr);

						// Iterate through the Properties array property
						for(LONG lIIndex = lILower; 
							lIIndex <= lIUpper; 
							lIIndex++)
						{
							// Get this property.
							hr = SafeArrayGetElement(vtProperties.parray, 
													  &lIIndex, &pIEmbedObj2);

							if ( m_eloErrLogOpt )
							{
								chsMsg.Format(L"SafeArrayGetElement(-, -, -)");
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
												   (LPCWSTR)chsMsg, dwThreadId,
												   rParsedInfo, FALSE);
							}
							ONFAILTHROWERROR(hr);

							//Getting the "Name" property
							hr = pIEmbedObj2->Get(_bstr_t(L"Name"), 0,
												  &vtPropertyName,0,0);
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(L"IWbemClassObject::Get"
												  L"(L\"Name\", 0, -, 0, 0)");
								GetBstrTFromVariant(vtPropertyName,
													bstrResult);
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__,
												   (LPCWSTR)chsMsg, dwThreadId,
												   rParsedInfo, m_bTrace,
												   0, bstrResult);
							}
							ONFAILTHROWERROR(hr);

							//Getting the "Derivation" property
							hr = pIEmbedObj2->Get(_bstr_t(L"Derivation"), 0,
												  &vtPropertyDerivation,0,0);
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(L"IWbemClassObject::Get"
										    L"(L\"Derivation\", 0, -, 0, 0)");
								GetBstrTFromVariant(vtPropertyDerivation,
													bstrResult);
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__,
												   (LPCWSTR)chsMsg, dwThreadId,
												   rParsedInfo, m_bTrace,
												   0, bstrResult);
							}
							ONFAILTHROWERROR(hr);

							_bstr_t bstrPropName;
							if ( bHelp )
							{
								if ( vtPropertyName.vt == VT_BSTR )
									bstrPropName = vtPropertyName.bstrVal;
							}
							else
							{
								if ( vtPropertyDerivation.vt == VT_BSTR )
									bstrPropName = vtPropertyDerivation.bstrVal;
								else if ( vtPropertyName.vt == VT_BSTR )
									bstrPropName = vtPropertyName.bstrVal;
							}

							//Add propertyderivation to property list in 
							// rParsedInfo
							if((!bstrPropName == FALSE) &&
								!rParsedInfo.GetCmdSwitchesObject().
									   AddToPropertyList(
									   (_TCHAR*)bstrPropName))
							{
								rParsedInfo.GetCmdSwitchesObject().
												 SetErrataCode(OUT_OF_MEMORY);
								bExist = FALSE;
								VARIANTCLEAR(vtPropertyDerivation);
								break;
							}
							
							// Add propertyname to property list in
							// rParsedInfo only to avail information of Name 
							// and Derivation of list properties for XML 
							// logging.
							PROPERTYDETAILS pdPropDet;
							if ( vtPropertyDerivation.vt == VT_BSTR )
								pdPropDet.Derivation = 
												 vtPropertyDerivation.bstrVal;
							else
								pdPropDet.Derivation = _bstr_t(TOKEN_NA);

							rParsedInfo.GetCmdSwitchesObject().
									AddToPropDetMap(
									   vtPropertyName.bstrVal, pdPropDet);

							VARIANTCLEAR(vtPropertyName);
							VARIANTCLEAR(vtPropertyDerivation);
							// Release pIEmbedObj2
							SAFEIRELEASE(pIEmbedObj2);
						}
					}
					// Release memory held by vtProperties 
					VARIANTCLEAR(vtProperties);
					// Free memory held by vtFormatName
					VARIANTCLEAR(vtFormatName);
					// Release pIEmbedObj
					SAFEIRELEASE(pIEmbedObj);
					break;
				}
				// Free memory held by vtFormatName
				VARIANTCLEAR(vtFormatName);
				// Release pIEmbedObj
				SAFEIRELEASE(pIEmbedObj);
			}
			// Release memory held by vtFormats
			VARIANTCLEAR(vtFormats);
		}
		else if ( vtFormats.vt != VT_NULL && vtFormats.vt != VT_EMPTY )
		{
			bExist = TRUE;
		}
		// Release pIWbem object
		SAFEIRELEASE(pIWbemObj);
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIWbemObj);
		SAFEIRELEASE(pIEmbedObj);
		SAFEIRELEASE(pIEmbedObj2);
		VARIANTCLEAR(vtFormats);
		VARIANTCLEAR(vtFormatName);
		VARIANTCLEAR(vtProperties);
		VARIANTCLEAR(vtPropertyName);
		VARIANTCLEAR(vtPropertyDerivation);
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bExist = FALSE;
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIWbemObj);
		SAFEIRELEASE(pIEmbedObj);
		SAFEIRELEASE(pIEmbedObj2);
		VARIANTCLEAR(vtFormats);
		VARIANTCLEAR(vtFormatName);
		VARIANTCLEAR(vtProperties);
		VARIANTCLEAR(vtPropertyName);
		VARIANTCLEAR(vtPropertyDerivation);
		bExist = FALSE;
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return bExist;
}

/*----------------------------------------------------------------------------
   Name				 :ObtainAliasPropDetails
   Synopsis          :Obtains the details of the properties for the Format 
					  associated with the alias object and updates the 
					  CCommandSwitches of CParsedInfo object passed to it.
   Type	             :Member Function
   Input parameter(s):
		rParsedInfo   - The parsed info from command line input.		
   Output parameter(s):
   		rParsedInfo   - The parsed info from command line input.		
   Return Type       :HRESULT  
   Global Variables  :None
   Calling Syntax    :ObtainAliasPropDetails(rParsedInfo)
   Notes             :pbCheckWritePropsAvailInAndOut == TRUE then function 
					  checks for availibility of properties and returns in 
					  the same pbCheckWritePropsAvailInAndOut parameter.
					  pbCheckFULLPropsAvailInAndOut == TRUE then function
					  checks for availibility of alias properties i.e in FULL
					  list format.
					  Imp : Any one of the input pointers can only be 
							specified.
----------------------------------------------------------------------------*/
HRESULT CCmdAlias::ObtainAliasPropDetails(CParsedInfo& rParsedInfo,
										 BOOL *pbCheckWritePropsAvailInAndOut,
										 BOOL *pbCheckFULLPropsAvailInAndOut)
{ 
	// variables being used in this function.
	HRESULT				hr					= S_OK;
	IWbemClassObject	*pIWbemObj			= NULL;
	IWbemClassObject	*pIEmbedObj			= NULL;
	IWbemClassObject	*pIEmbedObj2		= NULL;
	BOOL				bPropList			= FALSE;
	_TCHAR				*pszVerbName		= NULL;
	DWORD				dwThreadId			= GetCurrentThreadId();
	VARIANT				vtFormats, vtFormatName, 
						vtProperties, vtPropertyName, vtPropertyDerivation;
	// Initializing all Variants variables being used in this function.
	VariantInit(&vtFormats);
	VariantInit(&vtFormatName);
	VariantInit(&vtProperties);
	VariantInit(&vtPropertyName);
	VariantInit(&vtPropertyDerivation);
	CHARVECTOR cvPropList;  

	if ( pbCheckWritePropsAvailInAndOut != NULL )
		*pbCheckWritePropsAvailInAndOut = FALSE;

	if ( pbCheckFULLPropsAvailInAndOut != NULL )
		*pbCheckFULLPropsAvailInAndOut = FALSE;

	try
	{
		CHString			chsMsg;
		_bstr_t				bstrResult;
		pszVerbName = rParsedInfo.GetCmdSwitchesObject().GetVerbName();

		cvPropList = rParsedInfo.GetCmdSwitchesObject().GetPropertyList();
		if ( cvPropList.size() != 0 )
			bPropList = TRUE;

		_bstr_t bstrPath = _bstr_t("MSFT_CliAlias.FriendlyName='") + 
				_bstr_t(rParsedInfo.GetCmdSwitchesObject().GetAliasName())+
				_bstr_t(L"'");

		// Get alias object
		hr = m_pIAliasNS->GetObject(bstrPath, 0, NULL, &pIWbemObj, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format( L"IWbemServices::GetObject(L\"%s\", 0, NULL, -)",
														   (WCHAR*) bstrPath);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Get Formats array property of alias object
		hr = pIWbemObj->Get(_bstr_t(L"Formats"), 0, &vtFormats, 0, 0);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemClassObject::Get(L\"Formats\", 0,"
																 L"-, 0, 0)");
			GetBstrTFromVariant(vtFormats, bstrResult);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace,
							   0, bstrResult);
		}
		ONFAILTHROWERROR(hr);

		BOOL bSetVerb = pszVerbName != NULL && 
					    CompareTokens(pszVerbName,CLI_TOKEN_SET);

		if ( vtFormats.vt != VT_NULL && vtFormats.vt != VT_EMPTY )
		{
			// Get lower and upper bounds of Formats array
			LONG lUpper = 0, lLower = 0;
			hr = SafeArrayGetLBound(vtFormats.parray, vtFormats.parray->cDims,
									&lLower);
			if ( m_eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetLBound(-, -, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			hr = SafeArrayGetUBound(vtFormats.parray,vtFormats.parray->cDims,
									&lUpper);
			if ( m_eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetUBound(-, -, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			// Iterate through the Formats array property
			for (LONG lIndex = lLower; lIndex <= lUpper; lIndex++)
		    {
				// Get this property.
				hr=SafeArrayGetElement(vtFormats.parray,&lIndex,&pIEmbedObj);
				if ( m_eloErrLogOpt )
				{
					chsMsg.Format(L"SafeArrayGetElement(-, -, -)");
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg, 
									   dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);

				hr = pIEmbedObj->Get(_bstr_t(L"Name"),0,&vtFormatName,0,0);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Get(L\"Name\", 0,"
															     L"-, 0, 0)");
					GetBstrTFromVariant(vtFormatName, bstrResult);
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg,
									   dwThreadId, rParsedInfo, m_bTrace,
									   0, bstrResult);
				}
				ONFAILTHROWERROR(hr);

				BOOL bGetProps = FALSE;

				if ( pbCheckWritePropsAvailInAndOut != NULL)
					bGetProps = CompareTokens(_bstr_t(vtFormatName.bstrVal),
															_T("WRITEABLE"));
				else if ( pbCheckFULLPropsAvailInAndOut != NULL)
					bGetProps = CompareTokens(_bstr_t(vtFormatName.bstrVal),
															_T("FULL"));
				else
				{
					bGetProps = (bSetVerb) ? 
					 ((rParsedInfo.GetHelpInfoObject().GetHelp(SETVerb)) ? 
					 CompareTokens(_bstr_t(vtFormatName.bstrVal),
															 _T("WRITEABLE")):
					 CompareTokens(_bstr_t(vtFormatName.bstrVal),
																_T("FULL")) ):
					 CompareTokens(_bstr_t(vtFormatName.bstrVal),_T("FULL"));
				}

				//Comparing the specified Format in the alias against
				//the formats available for the specified alias.
				if( bGetProps )
				{
					//Getting the "Properties" property.
					hr=pIEmbedObj->Get(_bstr_t(L"Properties"),0,
									   &vtProperties, 0, 0);
					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(L"IWbemClassObject::Get"
											L"(L\"Properties\", 0, -, 0, 0)");
						GetBstrTFromVariant(vtProperties, bstrResult);
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
										   (LPCWSTR)chsMsg, dwThreadId,
										   rParsedInfo, m_bTrace,
										   0, bstrResult);
					}
					ONFAILTHROWERROR(hr);

					if ( vtProperties.vt != VT_NULL )
					{
						LONG lILower = 0, lIUpper = 0;
						hr = SafeArrayGetLBound(vtProperties.parray,
										vtProperties.parray->cDims, &lILower);
						if ( m_eloErrLogOpt )
						{
							chsMsg.Format(L"SafeArrayGetLBound(-, -, -)");
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
											   (LPCWSTR)chsMsg, dwThreadId,
											   rParsedInfo, FALSE);
						}
						ONFAILTHROWERROR(hr);


						hr = SafeArrayGetUBound(vtProperties.parray,
										vtProperties.parray->cDims, &lIUpper);
						if ( m_eloErrLogOpt )
						{
							chsMsg.Format(L"SafeArrayGetUBound(-, -, -)");
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
											  (LPCWSTR)chsMsg, dwThreadId,
											  rParsedInfo, FALSE);
						}
						ONFAILTHROWERROR(hr);
					
						// Iterate through the Properties array property
						for(LONG lIIndex=lILower; lIIndex<=lIUpper; lIIndex++)
						{
							// Get this property.
							hr = SafeArrayGetElement(vtProperties.parray,
													  &lIIndex, &pIEmbedObj2);
							if ( m_eloErrLogOpt ) 
							{
								chsMsg.Format(L"SafeArrayGetElement(-, -, -)");
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
												   (LPCWSTR)chsMsg,dwThreadId,
												   rParsedInfo, FALSE);
							}
							ONFAILTHROWERROR(hr);

							//Getting the "Name" property
							hr = pIEmbedObj2->Get(_bstr_t(L"Name"),	0,
												  &vtPropertyName,0,0);
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(L"IWbemClassObject::Get"
												  L"(L\"Name\", 0, -, 0, 0)");
								GetBstrTFromVariant(vtPropertyName,
													bstrResult);
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__,
												   (LPCWSTR)chsMsg,dwThreadId,
												   rParsedInfo, m_bTrace, 
												   0, bstrResult);
							}
							ONFAILTHROWERROR(hr);
							
							//Getting the "Derivation" property
							hr = pIEmbedObj2->Get(_bstr_t(L"Derivation"),	0,
												  &vtPropertyDerivation,0,0);
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(L"IWbemClassObject::Get"
										    L"(L\"Derivation\", 0, -, 0, 0)");
								GetBstrTFromVariant(vtPropertyDerivation,
													bstrResult);
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__,
												   (LPCWSTR)chsMsg,dwThreadId, 
												   rParsedInfo, m_bTrace, 
												   0, bstrResult);
							}
							ONFAILTHROWERROR(hr);

							if (vtPropertyName.vt == VT_BSTR)
							{
								CHARVECTOR::iterator tempIterator;
								if ( bPropList == TRUE &&
									 !Find(cvPropList, 
										  _bstr_t(vtPropertyName.bstrVal),
										  tempIterator) )
								{
									SAFEIRELEASE(pIEmbedObj2)
									continue;
								}

								if ( pbCheckWritePropsAvailInAndOut != NULL)
								{
									*pbCheckWritePropsAvailInAndOut = TRUE;
									SAFEIRELEASE(pIEmbedObj2);
									break;
								}

								if ( pbCheckFULLPropsAvailInAndOut != NULL)
								{
									*pbCheckFULLPropsAvailInAndOut = TRUE;
									SAFEIRELEASE(pIEmbedObj2);
									break;
								}

								_bstr_t bstrDesc;
								hr = GetDescOfObject(pIEmbedObj2, bstrDesc, 
																 rParsedInfo);
								ONFAILTHROWERROR(hr);

								PROPERTYDETAILS pdPropDet;
								if (vtPropertyDerivation.vt == VT_BSTR)
									pdPropDet.Derivation = 
												 vtPropertyDerivation.bstrVal;
								else
									pdPropDet.Derivation = _bstr_t(TOKEN_NA);

								if (bstrDesc != _bstr_t(""))
									pdPropDet.Description = bstrDesc;
								else
									pdPropDet.Description = _bstr_t(TOKEN_NA);


								hr = GetQualifiers(pIEmbedObj2, pdPropDet,
												   rParsedInfo);
								if (!pdPropDet.Type)
									pdPropDet.Type = _bstr_t(TOKEN_NA);

								if (!pdPropDet.Operation)
									pdPropDet.Operation = _bstr_t(TOKEN_NA);
								// Add propertyname to property list in
								// rParsedInfo
								rParsedInfo.GetCmdSwitchesObject().
										AddToPropDetMap(
										   vtPropertyName.bstrVal, pdPropDet);
								VARIANTCLEAR(vtPropertyName);
								VARIANTCLEAR(vtPropertyDerivation);
							}
							SAFEIRELEASE(pIEmbedObj2)
						}
					}
					// Release memory held by vtProperties 
					VARIANTCLEAR(vtProperties);
					// Free memory held by vtFormatName
					VARIANTCLEAR(vtFormatName);
					// Release pIEmbedObj
					SAFEIRELEASE(pIEmbedObj);
					break;
				}
				// Free memory held by vtFormatName
				VARIANTCLEAR(vtFormatName);
				// Release pIEmbedObj
				SAFEIRELEASE(pIEmbedObj);
			}
			// Release memory held by vtFormats
			VARIANTCLEAR(vtFormats);
		}
		SAFEIRELEASE(pIWbemObj);
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIWbemObj);
		SAFEIRELEASE(pIEmbedObj);
		SAFEIRELEASE(pIEmbedObj2);
		VARIANTCLEAR(vtFormats);
		VARIANTCLEAR(vtFormatName);
		VARIANTCLEAR(vtProperties);
		VARIANTCLEAR(vtPropertyName);
		VARIANTCLEAR(vtPropertyDerivation);
		hr = e.Error();
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIWbemObj);
		SAFEIRELEASE(pIEmbedObj);
		SAFEIRELEASE(pIEmbedObj2);
		VARIANTCLEAR(vtFormats);
		VARIANTCLEAR(vtFormatName);
		VARIANTCLEAR(vtProperties);
		VARIANTCLEAR(vtPropertyName);
		VARIANTCLEAR(vtPropertyDerivation);
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :GetDescOfObject
   Synopsis          :Get the Localized description from alias definition.
   Type	             :Member Function
   Input parameter(s):
		pIWbemClassObject	- IWbemLocator object
		rParsedInfo			- The parsed info from command line input.		
   Output parameter(s):
		bstrDescription		- Localized description 
   		rParsedInfo`		- The parsed info from command line input.	
   Return Type       :HRESULT  
   Global Variables  :None
   Calling Syntax    :GetDescOfObject(pIObject, bstrDescription,
										rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
HRESULT CCmdAlias::GetDescOfObject(IWbemClassObject* pIObject, 
								  _bstr_t& bstrDescription, 
								  CParsedInfo& rParsedInfo,
								  BOOL bLocalizeFlag)
{
	HRESULT					hr					= S_OK;
	DWORD					dwThreadId			= GetCurrentThreadId();	
	VARIANT					vtDesc, vtRelPath;	
	VariantInit(&vtDesc);
	VariantInit(&vtRelPath);
	try
	{
		CHString	chsMsg;		
		_bstr_t		bstrRelPath;
		_bstr_t     bstrResult;
		if (!bLocalizeFlag)
		{
			// Get "Description" property.
			hr = pIObject->Get(_bstr_t(L"Description"), 0, &vtDesc, 0, 0);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemClassObject::Get(L\"Description\", 0,"
																 L"-, 0, 0)");
				GetBstrTFromVariant(vtDesc, bstrResult);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace,
								   0 ,bstrResult);
			}
			ONFAILTHROWERROR(hr);

			if (vtDesc.vt == VT_BSTR )
				bstrDescription = vtDesc.bstrVal;

			VARIANTCLEAR(vtDesc);
		}
		else // Get the localized description
		{
			// Get the __RELPATH
			hr = pIObject->Get(_bstr_t(L"__RELPATH"), 0, &vtRelPath, 0, 0);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemClassObject::Get(L\"__RELPATH\", 0,"
																 L"-, 0, 0)");
				GetBstrTFromVariant(vtRelPath, bstrResult);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace,
								   0, bstrResult);
			}
			ONFAILTHROWERROR(hr);
		
			if ((vtRelPath.vt != VT_NULL) && (vtRelPath.vt != VT_EMPTY))
			{
				// Get localized description of the  property.
				hr = GetLocalizedDesc(vtRelPath.bstrVal, 
									  bstrDescription, rParsedInfo);
				if(FAILED(hr))
				{
					hr = S_OK;
					WMIFormatMessage(IDS_E_NO_DESC, 0, bstrDescription, NULL);
				}
			}
			VARIANTCLEAR(vtRelPath);
		}
	}
	catch (_com_error& e)
	{
		VARIANTCLEAR(vtRelPath);
		VARIANTCLEAR(vtDesc);
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		VARIANTCLEAR(vtRelPath);
		VARIANTCLEAR(vtDesc);
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :ObtainTranslateTableEntries
   Synopsis          :Obtain the translate table information from the alias
					  definition
   Type	             :Member Function
   Input parameter(s):
		rParsedInfo	 - The parsed info from command line input.		
   Output parameter(s):
   		rParsedInfo  - The parsed info from command line input.	
   Return Type       :HRESULT  
   Global Variables  :None
   Calling Syntax    :ObtainTranslateTableEntries(rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL CCmdAlias::ObtainTranslateTableEntries(CParsedInfo& rParsedInfo)
{
	BOOL					bSuccess				= TRUE;
	HRESULT					hr						= S_OK;
	IWbemClassObject		*pIWbemObjOfTable		= NULL,
							*pIWbemObjOfTblEntry	= NULL;
	DWORD					dwThreadId				= GetCurrentThreadId();
	VARIANT					vtTblEntryArr, vtFromValue, vtToValue;
	VariantInit(&vtTblEntryArr);
	VariantInit(&vtFromValue);
	VariantInit(&vtToValue);

	try
	{
		CHString chsMsg;
		_bstr_t  bstrResult;
		_bstr_t  bstrPath = 	_bstr_t("MSFT_CliTranslateTable.Name='") + 
		  _bstr_t(rParsedInfo.GetCmdSwitchesObject().GetTranslateTableName())+
		  _bstr_t(L"'");

		hr = m_pIAliasNS->GetObject(bstrPath, 0, NULL, 
									&pIWbemObjOfTable, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", 0, NULL, -)",
														   (WCHAR*) bstrPath);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace);
		}
		// do not add ONFAILTHROWERROR(hr) here, as following statement checks
		// for validity

		if ( pIWbemObjOfTable != NULL )
		{
			VariantInit(&vtTblEntryArr);
			hr = pIWbemObjOfTable->Get(_bstr_t(L"Tbl"), 0, 
									   &vtTblEntryArr, 0, 0 );
			if ( vtTblEntryArr.vt != VT_NULL && vtTblEntryArr.vt != VT_EMPTY )
			{
				LONG lUpper = 0, lLower = 0;
				hr = SafeArrayGetLBound(vtTblEntryArr.parray,
										vtTblEntryArr.parray->cDims,
										&lLower);
				if ( m_eloErrLogOpt )
				{
					chsMsg.Format(L"SafeArrayGetLBound(-, -, -)"); 
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg, 
									   dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);
				
				hr = SafeArrayGetUBound(vtTblEntryArr.parray,
										vtTblEntryArr.parray->cDims,
										&lUpper);
				if ( m_eloErrLogOpt )
				{
					chsMsg.Format(L"SafeArrayGetUBound(-, -, -)"); 
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg,
									   dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);


				for (LONG lIndex = lLower; lIndex <= lUpper; lIndex++)
				{
					pIWbemObjOfTblEntry = NULL;
					hr = SafeArrayGetElement(vtTblEntryArr.parray,&lIndex,
											 &pIWbemObjOfTblEntry);
					if ( m_eloErrLogOpt )
					{
						chsMsg.Format(L"SafeArrayGetElement(-, -, -)"); 
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg, 
										   dwThreadId, rParsedInfo, FALSE);
					}
					ONFAILTHROWERROR(hr);

					VariantInit(&vtFromValue);
					VariantInit(&vtToValue);
					hr = pIWbemObjOfTblEntry->Get(_bstr_t(L"FromValue"), 0, 
												  &vtFromValue, 0, 0 );
					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(L"IWbemClassObject::Get(L\"FromValue\","
															  L"0, -, 0, 0)");
						GetBstrTFromVariant(vtFromValue, bstrResult);
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
										   (LPCWSTR)chsMsg, dwThreadId, 
										   rParsedInfo, m_bTrace,
										   0, bstrResult);
					}
					ONFAILTHROWERROR(hr);

					hr = pIWbemObjOfTblEntry->Get(_bstr_t(L"ToValue"),
												  0, &vtToValue, 0, 0 );
					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(L"IWbemClassObject::Get(L\"ToValue\", "
															  L"0, -, 0, 0)");
						GetBstrTFromVariant(vtToValue, bstrResult);
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
										   (LPCWSTR)chsMsg, dwThreadId,
										   rParsedInfo, m_bTrace,
										   0 , bstrResult);
					}
					ONFAILTHROWERROR(hr);

					rParsedInfo.GetCmdSwitchesObject().
					   AddToAlsFrnNmsOrTrnsTblMap( 
												 _bstr_t(vtFromValue.bstrVal),
												 _bstr_t(vtToValue.bstrVal) );
					VARIANTCLEAR(vtFromValue);
					VARIANTCLEAR(vtToValue);
					SAFEIRELEASE(pIWbemObjOfTblEntry);
				}
			}
			else
				bSuccess = FALSE;

			SAFEIRELEASE(pIWbemObjOfTable);
			VARIANTCLEAR(vtTblEntryArr);
		}
		else
			bSuccess = FALSE;
	}

	catch(_com_error& e)
	{
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bSuccess = FALSE;
		SAFEIRELEASE(pIWbemObjOfTable);
		VARIANTCLEAR(vtTblEntryArr);
		VARIANTCLEAR(vtFromValue);
		VARIANTCLEAR(vtToValue);
		SAFEIRELEASE(pIWbemObjOfTblEntry);
	}
	catch(CHeap_Exception)
	{
		bSuccess = FALSE;
		SAFEIRELEASE(pIWbemObjOfTable);
		VARIANTCLEAR(vtTblEntryArr);
		VARIANTCLEAR(vtFromValue);
		VARIANTCLEAR(vtToValue);
		SAFEIRELEASE(pIWbemObjOfTblEntry);
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return bSuccess;
}

/*----------------------------------------------------------------------------
   Name				 :PopulateAliasFormatMap
   Synopsis          :populate the alias format map with the available formats
   Type	             :Member Function
   Input parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Output parameter(s):
   		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :PopulateAliasFormatMap(rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
HRESULT CCmdAlias::PopulateAliasFormatMap(CParsedInfo& rParsedInfo)
{
	// variables being used in this function.
	HRESULT				hr					= S_OK;
	IWbemClassObject	*pIWbemObj			= NULL;
	IWbemClassObject	*pIEmbedObj			= NULL;
	VARIANT				vtFormats, vtFormatName;
	
	// Initializing all Variants variables being used in this function.
	VariantInit(&vtFormats);
	VariantInit(&vtFormatName);
	DWORD dwThreadId = GetCurrentThreadId();
	
	try
	{
		CHString 	chsMsg;
		_bstr_t		bstrResult;
		_bstr_t bstrPath = _bstr_t("MSFT_CliAlias.FriendlyName='") + 
				  _bstr_t(rParsedInfo.GetCmdSwitchesObject().GetAliasName()) +
				  _bstr_t(L"'");

		// Get alias object
		hr = m_pIAliasNS->GetObject(bstrPath, 0, NULL, &pIWbemObj, NULL);

		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", 0, NULL, -)",
														   (WCHAR*) bstrPath);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Get Formats array property of alias object
		hr = pIWbemObj->Get(_bstr_t(L"Formats"), 0, &vtFormats, 0, 0);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemClassObject::Get(L\"Formats\", 0,"
																 L"-, 0, 0)");
			GetBstrTFromVariant(vtFormats, bstrResult);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace,
							   0, bstrResult);
		}
		ONFAILTHROWERROR(hr);

		if ( vtFormats.vt != VT_NULL && vtFormats.vt != VT_EMPTY )
		{
			// Get lower and upper bounds of Formats array
			LONG lUpper = 0, lLower = 0;
			hr = SafeArrayGetLBound(vtFormats.parray, vtFormats.parray->cDims,
									&lLower);
			if ( m_eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetLBound(-, -, -)"); 
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
								   dwThreadId, rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);
		    
			hr = SafeArrayGetUBound(vtFormats.parray, vtFormats.parray->cDims,
									&lUpper);
			if ( m_eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetUBound(-, -, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);
			
			// Iterate through the Formats array property
			for (LONG lIndex = lLower; lIndex <= lUpper; lIndex++)
		    {
				VariantInit(&vtFormatName);

				// Get this property.
				hr =SafeArrayGetElement(vtFormats.parray,&lIndex,&pIEmbedObj);
				if ( m_eloErrLogOpt )
				{
					chsMsg.Format(L"SafeArrayGetElement(-, -, -)");
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg,
									   dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);
				
				hr = pIEmbedObj->Get(_bstr_t(L"Name"),0,&vtFormatName,0,0);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Get(L\"Name\", 0,"
																 L"-, 0, 0)");
					GetBstrTFromVariant(vtFormatName, bstrResult);
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg, 
									   dwThreadId, rParsedInfo, m_bTrace,
									   0, bstrResult);
				}
				ONFAILTHROWERROR(hr);
				
				// To obtain properties from alias associated with the format
				rParsedInfo.GetCmdSwitchesObject().SetListFormat(
											   _bstr_t(vtFormatName.bstrVal));

				if ( ObtainAliasFormat(rParsedInfo) == TRUE )
				{
					CHARVECTOR cvProps = rParsedInfo.GetCmdSwitchesObject().
															GetPropertyList();
					CHARVECTOR::iterator cvIterator;
					BSTRVECTOR bvProps;
					for ( cvIterator = cvProps.begin();
						  cvIterator != cvProps.end();
						  cvIterator++ )
					{
						bvProps.push_back(_bstr_t(*cvIterator));
					}

					//Add format name to format list in rParsedInfo
					rParsedInfo.GetCmdSwitchesObject().
						AddToAliasFormatDetMap(vtFormatName.bstrVal, bvProps);

					rParsedInfo.GetCmdSwitchesObject().ClearPropertyList();
				}

				SAFEIRELEASE(pIEmbedObj);
			}
			// Release memory held by vtFormats
			VARIANTCLEAR(vtFormats);
		}
		// Release pIWbem object
		SAFEIRELEASE(pIWbemObj);
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIEmbedObj);
		SAFEIRELEASE(pIWbemObj);
		VARIANTCLEAR(vtFormats);
		VARIANTCLEAR(vtFormatName);
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIEmbedObj);
		SAFEIRELEASE(pIWbemObj);
		VARIANTCLEAR(vtFormats);
		VARIANTCLEAR(vtFormatName);
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :ObtainTranslateTables
   Synopsis          :Obtain the information about translate tables available
   Type	             :Member Function
   Input parameter(s):
		rParsedInfo   - reference to CParsedInfo class object
   Output parameter(s):
   		rParsedInfo   - reference to CParsedInfo class object
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :ObtainTranslateTables(rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
HRESULT CCmdAlias::ObtainTranslateTables(CParsedInfo& rParsedInfo)
{
	// variables being used in this function.
	HRESULT hr = S_OK;
	IEnumWbemClassObject		*pIEnumObj			= NULL;
	IWbemClassObject			*pIWbemObj			= NULL;
	DWORD						dwThreadId			= GetCurrentThreadId();
	VARIANT						vtName;
	VariantInit(&vtName);
	
	try
	{
		CHString	chsMsg;
		_bstr_t		bstrResult;
		// Get alias object
		hr = m_pIAliasNS->ExecQuery(_bstr_t(L"WQL"), 
							_bstr_t(L"SELECT * FROM MSFT_CliTranslateTable"),
							WBEM_FLAG_FORWARD_ONLY|
							WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pIEnumObj);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemServices::ExecQuery(L\"WQL\"," 
					   L"L\"SELECT * FROM MSFT_CliTranslateTable\","
					   L"WBEM_FLAG_FORWARD_ONLY|WBEM_FLAG_RETURN_IMMEDIATELY,"
					   L"NULL, -)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Set the security
		hr = SetSecurity(pIEnumObj, NULL, NULL, NULL, NULL,
				rParsedInfo.GetGlblSwitchesObject().GetAuthenticationLevel(),
				rParsedInfo.GetGlblSwitchesObject().GetImpersonationLevel());

		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format( 
				  L"CoSetProxyBlanket(-, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,"
				  L"NULL, %d,   %d, -, EOAC_NONE)",
				rParsedInfo.GetGlblSwitchesObject().GetAuthenticationLevel(),
				rParsedInfo.GetGlblSwitchesObject().GetImpersonationLevel());
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		ULONG ulReturned = 0; 
		
		hr=pIEnumObj->Next(WBEM_INFINITE,1,&pIWbemObj,&ulReturned);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IEnumWbemClassObject->Next"
				L"(WBEM_INFINITE, 1, -, -)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
				dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

	 	// Obtain the object starting at the current position in the
		// enumeration and loop through the instance list.
		while(ulReturned == 1)
		{
			VariantInit(&vtName);

			// Gets "FriendlyName" array property of alias object
			hr = pIWbemObj->Get(_bstr_t(L"Name"), 0, &vtName, 0, 0);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemClassObject::Get(L\"Name\", 0,"
						  L"-, 0, 0)"); 
				GetBstrTFromVariant(vtName, bstrResult);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__,  (LPCWSTR)chsMsg,
								   dwThreadId, rParsedInfo, m_bTrace,
								   0, bstrResult);
			}
			ONFAILTHROWERROR(hr);

			if (vtName.vt != VT_NULL && vtName.vt != VT_EMPTY)
			{
				rParsedInfo.GetCmdSwitchesObject().
										  AddToTrnsTablesList(vtName.bstrVal);
			}
			VARIANTCLEAR(vtName);
			SAFEIRELEASE(pIWbemObj);

			// Move to next instance in the enumeration.
			hr = pIEnumObj->Next(WBEM_INFINITE, 1, &pIWbemObj, &ulReturned);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(
					L"IEnumWbemClassObject->Next(WBEM_INFINITE, 1, -, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
					dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);
		}
		SAFEIRELEASE(pIEnumObj);
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIEnumObj);
		SAFEIRELEASE(pIWbemObj);
		VARIANTCLEAR(vtName);
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIEnumObj);
		SAFEIRELEASE(pIWbemObj);
		VARIANTCLEAR(vtName);
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :ConnectToLocalizedNS
   Synopsis          :This function connects to localized WMI namespace 
   Type	             :Member Function
   Input parameter(s):
		rParsedInfo  - reference to CParsedInfo class object.
		pIWbemLocator- IWbemLocator object for connecting to WMI.						
   Output parameter(s):
		rParsedInfo  - reference to CParsedInfo class object.
   Return Type       :HRESULT  
   Global Variables  :None
   Calling Syntax    :ConnectToLocalizedNS(rParsedInfo,pIWbemLocator)
   Notes             :None
----------------------------------------------------------------------------*/
HRESULT CCmdAlias::ConnectToLocalizedNS(CParsedInfo& rParsedInfo, 
								        IWbemLocator* pIWbemLocator)
{
	DWORD	dwThreadId	= GetCurrentThreadId();
	HRESULT hr			= S_OK;

	// If the /LOCALE value has been changed since last invocation
	if (rParsedInfo.GetGlblSwitchesObject().GetLocaleFlag())
	{
		SAFEIRELEASE(m_pILocalizedNS);
		
		try
		{
			CHString	chsMsg;
			_bstr_t bstrNS = _bstr_t(rParsedInfo.GetGlblSwitchesObject().
																   GetRole())
							+ _bstr_t(L"\\") 
							+ _bstr_t(rParsedInfo.GetGlblSwitchesObject().
																 GetLocale());

			// Connect to the specified namespace of Windows Management on the
			// local computer using the locator object. 
			hr = Connect(pIWbemLocator, &m_pILocalizedNS,
						 bstrNS,	NULL, NULL,	
						 _bstr_t(rParsedInfo.GetGlblSwitchesObject().
						 GetLocale()), rParsedInfo);

			// If /TRACE is ON
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format( 
						L"IWbemLocator::ConnectServer(L\"%s\", NULL, "
						L"NULL, L\"%s\", 0L, NULL, NULL, -)", 
						(WCHAR*) bstrNS,
						rParsedInfo.GetGlblSwitchesObject().GetLocale());
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);
			
			// If /TRACE is ON
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format( 
				 L"CoSetProxyBlanket(-, RPC_C_AUTHN_WINNT, "
				 L"RPC_C_AUTHZ_NONE, NULL, %d,   %d, -, EOAC_NONE)",
				 rParsedInfo.GetGlblSwitchesObject().GetAuthenticationLevel(),
				 rParsedInfo.GetGlblSwitchesObject().GetImpersonationLevel());
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);
			rParsedInfo.GetGlblSwitchesObject().SetLocaleFlag(FALSE);
		}
		catch(_com_error& e)
		{
			// Set the COM error
			rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
			hr = e.Error();
		}
		catch(CHeap_Exception)
		{
			// Set the COM error
			hr = WBEM_E_OUT_OF_MEMORY;
			_com_issue_error(hr);
		}
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :GetLocalizedDesc
   Synopsis          :This function retrieves the localized description for 
					  the object with given relative path, 
   Type	             :Member Function
   Input parameter(s):
		bstrRelPath	 - relativepath of the object for which
						localized description has to be retrieved.
		rParsedInfo  - reference to CParsedInfo class object.
   Output parameter(s):
   		bstrDesc	 - localized description
		rParsedInfo  - reference to CParsedInfo class object.
   Return Type       :HRESULT  
   Global Variables  :None
   Calling Syntax    :GetLocalizedDesc(bstrRelPath, bstrDesc, rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
HRESULT CCmdAlias::GetLocalizedDesc(_bstr_t bstrRelPath, 
									_bstr_t& bstrDesc,
									CParsedInfo& rParsedInfo)
{
	HRESULT					hr					= S_OK;
	IWbemClassObject		*pIObject			= NULL;
	DWORD					dwThreadId			= GetCurrentThreadId();
	VARIANT					vtDesc, vtTemp;
	VariantInit(&vtDesc);
	VariantInit(&vtTemp);
	
	try
	{
		CHString	chsMsg;
		_bstr_t		bstrResult;
		CHString	sTemp((WCHAR*)bstrRelPath);

		// Substitue escape characters i.e. replace '\"' with '\\\"'
		SubstituteEscapeChars(sTemp, L"\"");

		// Object path
		_bstr_t bstrPath = 
					   _bstr_t(L"MSFT_LocalizablePropertyValue.ObjectLocator=\"\",PropertyName=")		
					   + _bstr_t(L"\"Description\",RelPath=\"")
					   + _bstr_t(sTemp) + _bstr_t(L"\"");

		// Retrieve the object 
		hr = m_pILocalizedNS->GetObject(bstrPath, 0, NULL, &pIObject, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format( 
					  L"IWbemServices::GetObject(L\"%s\", 0, NULL, -)",
					  (WCHAR*) bstrPath);		
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Get localized description of the  property.
		hr = pIObject->Get(_bstr_t(L"Text"), 0, &vtDesc, 0, 0);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemClassObject::Get(L\"Text\", 0, -, 0, 0)");
			GetBstrTFromVariant(vtDesc, bstrResult);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace,
							   0, bstrResult);
		}
		ONFAILTHROWERROR(hr);

		if (vtDesc.vt != VT_EMPTY && vtDesc.vt != VT_NULL)
		{
			// Get lower and upper bounds of 'Text' array
			LONG lUpper = 0, lLower = 0;
			hr = SafeArrayGetLBound(vtDesc.parray, vtDesc.parray->cDims,
									&lLower);
			ONFAILTHROWERROR(hr);

			hr = SafeArrayGetUBound(vtDesc.parray, vtDesc.parray->cDims,
									&lUpper);
			ONFAILTHROWERROR(hr);

			// Iterate through the Formats array property
			for (LONG lIndex = lLower; lIndex <= lUpper; lIndex++)
			{
				BSTR bstrTemp = NULL;
				hr = SafeArrayGetElement(vtDesc.parray, &lIndex, &bstrTemp);
				ONFAILTHROWERROR(hr);
				if (bstrTemp)
					bstrDesc += bstrTemp;
			}
		}
		VariantClear(&vtDesc);
		SAFEIRELEASE(pIObject);
	}
	catch (_com_error& e)
	{
		VariantClear(&vtTemp);
		VariantClear(&vtDesc);
		SAFEIRELEASE(pIObject);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		VariantClear(&vtTemp);
		VariantClear(&vtDesc);
		SAFEIRELEASE(pIObject);
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :GetQualifiers
   Synopsis          :This function retrieves the qualifiers associated with 
					  propety/parameter referred by pIWbemClassObject
   Type	             :Member Function
   Input parameter(s):
		pIWbemClassObject	- pointer to IWbemClassObject
		rPropDet			- reference to PROPERTYDETAILS object
		rParsedInfo			- reference to CParsedInfo class object.
   Output parameter(s):
		rPropDet			- reference to PROPERTYDETAILS object
		rParsedInfo			- reference to CParsedInfo class object.
   Return Type       :HRESULT  
   Global Variables  :None
   Calling Syntax    :GetQualifiers(pIObj, rPropDet, rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
HRESULT CCmdAlias::GetQualifiers(IWbemClassObject *pIWbemClassObject,
								 PROPERTYDETAILS& rPropDet,
								 CParsedInfo& rParsedInfo)
{
	IWbemClassObject	*pIWbemQualObject	= NULL;
	HRESULT				hr					= S_OK;
	DWORD				dwThreadId			= GetCurrentThreadId();
	VARIANT				vtQualifiers, vtQualName, vtQualValues;
	VariantInit(&vtQualifiers);
	VariantInit(&vtQualName);
	VariantInit(&vtQualValues);
	try
	{
		CHString	chsMsg;
		_bstr_t		bstrResult;
		//Getting the "Qualifiers" property.
		hr=pIWbemClassObject->Get(_bstr_t(L"Qualifiers"), 0,
								  &vtQualifiers, 0, 0);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemClassObject::Get"
						  L"(L\"Qualifiers\", 0, -, 0, 0)"); 
			GetBstrTFromVariant(vtQualifiers, bstrResult);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
							  (LPCWSTR)chsMsg, dwThreadId, 
							  rParsedInfo, m_bTrace, 0, bstrResult);
		}
		ONFAILTHROWERROR(hr);

		if ( vtQualifiers.vt != VT_NULL && vtQualifiers.vt != VT_EMPTY )
		{
			LONG lLower = 0, lUpper = 0;
			hr = SafeArrayGetLBound(vtQualifiers.parray,
							vtQualifiers.parray->cDims, &lLower);
			if ( m_eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetLBound(-, -, -)"); 
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			hr = SafeArrayGetUBound(vtQualifiers.parray,
									vtQualifiers.parray->cDims, &lUpper);
			if ( m_eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetUBound(-, -, -)"); 
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
								   dwThreadId, rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			// Iterate through the Properties array property
			for(LONG lIndex=lLower; lIndex<=lUpper; lIndex++)
			{
				pIWbemQualObject = NULL;
				// Get this property.
				hr = SafeArrayGetElement(vtQualifiers.parray, 
										 &lIndex, &pIWbemQualObject);
				if ( m_eloErrLogOpt ) 
				{
					chsMsg.Format(L"SafeArrayGetElement(-, -, -)"); 
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg,
						dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);

				//Getting the "Name" property
				hr = pIWbemQualObject->Get(_bstr_t(L"Name"), 0,
										   &vtQualName,0,0);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Get"
												  L"(L\"Name\", 0, -, 0, 0)");
					GetBstrTFromVariant(vtQualName, bstrResult);
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg, 
									   dwThreadId, rParsedInfo, m_bTrace,
									   0, bstrResult);
				}
				ONFAILTHROWERROR(hr);

				//Getting the "QualifierValue" property.
				hr=pIWbemQualObject->Get(_bstr_t(L"QualifierValue"),0,
										 &vtQualValues, 0, 0);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Get"
								  L"(L\"QualifierValue\", 0, -, 0, 0)"); 
					GetBstrTFromVariant(vtQualValues, bstrResult);
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg, 
									   dwThreadId, rParsedInfo, m_bTrace,
									   0, bstrResult);
				}
				ONFAILTHROWERROR(hr);

				BSTRVECTOR bvQualValues;
				if ( vtQualValues.vt != VT_NULL && 
					 vtQualValues.vt != VT_EMPTY )
				{
					LONG lILower = 0, lIUpper = 0;
					hr = SafeArrayGetLBound(vtQualValues.parray,
									vtQualValues.parray->cDims, &lILower);
					if ( m_eloErrLogOpt )
					{
						chsMsg.Format(L"SafeArrayGetLBound(-, -, -)");
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg, 
										   dwThreadId, rParsedInfo, FALSE);
					}
					ONFAILTHROWERROR(hr);

					hr = SafeArrayGetUBound(vtQualValues.parray,
									vtQualValues.parray->cDims, &lIUpper);
					if ( m_eloErrLogOpt )
					{
						chsMsg.Format(L"SafeArrayGetUBound(-, -, -)"); 
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
										   (LPCWSTR)chsMsg, dwThreadId,
										   rParsedInfo, FALSE);
					}
					ONFAILTHROWERROR(hr);

					BOOL bIsType = FALSE;
					BOOL bIsRead = FALSE;
					BOOL bIsWrite = FALSE;
					BOOL bIsIn = FALSE;
					BOOL bIsOut = FALSE;
					if (CompareTokens((WCHAR*)vtQualName.bstrVal, 
   									  _T("CIMTYPE")))
					{
						bIsType = TRUE;
					}
					else if (CompareTokens((WCHAR*)vtQualName.bstrVal, 
											_T("read")))
					{
						bIsRead = TRUE;
					}
					else if (CompareTokens((WCHAR*)vtQualName.bstrVal, 
											_T("write")))
					{
						bIsWrite = TRUE;
					}
					else if (CompareTokens((WCHAR*)vtQualName.bstrVal, 
											_T("In")))
					{
						bIsIn = TRUE;
					}
					else if (CompareTokens((WCHAR*)vtQualName.bstrVal, 
											_T("Out")))
					{
						bIsOut = TRUE;
					}

					// Iterate through the Properties array property
					for(LONG lIIndex=lILower; lIIndex<=lIUpper; lIIndex++)
					{
						BSTR bstrQualValue = NULL;
						// Get this property.
						hr = SafeArrayGetElement(vtQualValues.parray, 
												  &lIIndex, &bstrQualValue);
						if ( m_eloErrLogOpt ) 
						{
							chsMsg.Format(L"SafeArrayGetElement(-, -, -)"); 
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
											  (LPCWSTR)chsMsg, dwThreadId,
											  rParsedInfo, FALSE);
						}
						ONFAILTHROWERROR(hr);

						if (bstrQualValue)
							bvQualValues.push_back(bstrQualValue);

						if ( lIIndex == 0 )
						{
							if ( bIsType == TRUE )
							{
								rPropDet.Type = bstrQualValue;
							}
							else if ( bIsRead == TRUE &&
							 CompareTokens((WCHAR*)bstrQualValue, _T("true")))
							{
								if (!rPropDet.Operation)
									rPropDet.Operation += _bstr_t("Read");
								else
									rPropDet.Operation += _bstr_t("/Read");
							}
							else if ( bIsWrite == TRUE &&
							 CompareTokens((WCHAR*)bstrQualValue, _T("true")))
							{
								if (!rPropDet.Operation)
									rPropDet.Operation += _bstr_t("Write");
								else
									rPropDet.Operation += _bstr_t("/Write");
							}
							else if ( bIsIn == TRUE &&
							 CompareTokens((WCHAR*)bstrQualValue, _T("true")))
							{
								 rPropDet.InOrOut = INP;
							}
							else if ( bIsOut == TRUE &&
							 CompareTokens((WCHAR*)bstrQualValue, _T("true")))
							{
								 rPropDet.InOrOut = OUTP;
							}
						}
					}
					VARIANTCLEAR(vtQualValues);
				}

				rPropDet.QualDetMap.insert
				   (QUALDETMAP::value_type(vtQualName.bstrVal, bvQualValues));

				VARIANTCLEAR(vtQualName);
				SAFEIRELEASE(pIWbemQualObject);
			}

			VARIANTCLEAR(vtQualifiers);
		}
	}
	catch (_com_error& e)
	{
		VARIANTCLEAR(vtQualValues);
		VARIANTCLEAR(vtQualName);
		VARIANTCLEAR(vtQualifiers);

		SAFEIRELEASE(pIWbemQualObject);
		
		hr = e.Error();
		// Set the COM error
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
	}
	catch(CHeap_Exception)
	{
		VARIANTCLEAR(vtQualValues);
		VARIANTCLEAR(vtQualName);
		VARIANTCLEAR(vtQualifiers);

		SAFEIRELEASE(pIWbemQualObject);
		
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :AreMethodsAvailable
   Synopsis          :Checks whether method are available with alias or not.
   Type	             :Member Function
   Input parameter(s):
		rParsedInfo	 - reference to CParsedInfo class object.
   Output parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :AreMethodsAvailable(rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL CCmdAlias::AreMethodsAvailable(CParsedInfo& rParsedInfo)
{
	BOOL				bMethAvail	=	TRUE;
	HRESULT				hr			=	S_OK;
	IWbemClassObject	*pIWbemObj	=	NULL;
	DWORD				dwThreadId			= GetCurrentThreadId();
	VARIANT				vtVerbs;
	VariantInit(&vtVerbs);

	try
	{
		CHString	chsMsg;
		_bstr_t		bstrResult;
		_bstr_t bstrPath = _bstr_t("MSFT_CliAlias.FriendlyName='") + 
				   _bstr_t(rParsedInfo.GetCmdSwitchesObject().GetAliasName())+
				   _bstr_t(L"'");

		//Retrieving the object from the namespace in m_pIAliasNS
		hr = m_pIAliasNS->GetObject(bstrPath, 0, NULL, &pIWbemObj, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", 0, NULL, -)",
														   (WCHAR*) bstrPath);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
								dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Get "Verbs" property.
		hr = pIWbemObj->Get(_bstr_t(L"Verbs"), 0, &vtVerbs, 0, 0) ;
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemClassObject::Get(L\"Verbs\", 0, -, 0, 0)"); 
			GetBstrTFromVariant(vtVerbs, bstrResult);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace,
							   0, bstrResult);
		}
		ONFAILTHROWERROR(hr);

		if ( vtVerbs.vt == VT_NULL || vtVerbs.vt == VT_EMPTY )
			bMethAvail	= FALSE;

		SAFEIRELEASE(pIWbemObj);
		VARIANTCLEAR(vtVerbs);

	}
	catch(_com_error& e)
	{
		bMethAvail	= FALSE;
		SAFEIRELEASE(pIWbemObj);
		VARIANTCLEAR(vtVerbs);
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bMethAvail = FALSE;
	}
	catch(CHeap_Exception)
	{
		bMethAvail	= FALSE;
		SAFEIRELEASE(pIWbemObj);
		VARIANTCLEAR(vtVerbs);
		bMethAvail = FALSE;
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return	bMethAvail;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\cmdalias.h ===
/*****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: CmdAlias.h 
Project Name				: WMI Command Line
Author Name					: Ch.Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This file consist of class declaration of
							  class CmdAlias
Revision History			: None
		Last Modified By	: C V Nandi
		Last Modified Date	: 16-March-2001
*****************************************************************************/

/*----------------------------------------------------------------------------
 Class Name			: CCmdAlias
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the functionality needed for
					  accessing the alias information from the WMI.
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: None
 Interfaces Used    : WMI COM Interfaces
 ---------------------------------------------------------------------------*/
// Forward declaration of the classes
class CParsedInfo;

class CCmdAlias
{
public:
	// Construction
	CCmdAlias();

	// Destruction
	~CCmdAlias();

	// Restrict Assignment
	CCmdAlias& operator=(CCmdAlias& rAliasObj);

// Attributes
private:
	// Points to the alias definitions namespace.
	IWbemServices* m_pIAliasNS;

	// Pointer to localized Namespace.
	IWbemServices* m_pILocalizedNS;

	// Trace flag.
	BOOL m_bTrace;

	// Error log option.
	ERRLOGOPT m_eloErrLogOpt;

// Operations
private:
	// Obtain the alias connection information like
	// 1. namespace		2. user		3. password
	// 4. locale		5. server	6. authority
	RETCODE ObtainAliasConnectionInfo(CParsedInfo& rParsedInfo,
									  IWbemClassObject* pIObj);

	// Obtain Qualifiers associated with the IWbemClassObject.
	HRESULT GetQualifiers(IWbemClassObject *pIWbemClassObject,
						  PROPERTYDETAILS& rPropDet,
						  CParsedInfo& rParsedInfo);	

public:
	// Obtains all the Friendly Names and descriptions 
	HRESULT ObtainAliasFriendlyNames(CParsedInfo& rParsedInfo);

	// Obtains the verbs and their details
	// associated with the alias object
	HRESULT ObtainAliasVerbDetails(CParsedInfo& rParsedInfo);

	// Obtains the verbs and their descriptions
	// associated with the alias object
	// pbCheckWritePropsAvailInAndOut == TRUE then functions checks for 
	// availibility of properties and returns in the same  
	// pbCheckWritePropsAvailInAndOut parameter.
	HRESULT ObtainAliasPropDetails(CParsedInfo& rParsedInfo,
								  BOOL *pbCheckWritePropsAvailInAndOut = NULL,
								  BOOL *pbCheckFULLPropsAvailInAndOut = NULL);
	
	// Obtains the properties for the Format associated with the alias object.
	// If bCheckForListFrmsAvail == TRUE then functions checks only for 
	// availibilty of list formats with the alias.
	BOOL ObtainAliasFormat(CParsedInfo& rParsedInfo,
						   BOOL bCheckForListFrmsAvail = FALSE);

	// Obtains the formats available for a given alias.
	HRESULT PopulateAliasFormatMap(CParsedInfo& rParsedInfo);
	
	// Connects to WMI with alias namespace .
	HRESULT ConnectToAlias(CParsedInfo& rParsedInfo, 
						 IWbemLocator* pIWbemLocator);
	
	// Obtain the alias information like
	// 1. alias PWhere expression value
	// 2. alias Target string
	RETCODE ObtainAliasInfo(CParsedInfo& rParsedInfo);

	// Get Description from object.
	HRESULT GetDescOfObject(IWbemClassObject* pIWbemClassObject,
						    _bstr_t& bstrDescription,
							CParsedInfo& rParsedInfo,
							BOOL bLocalizeFlag = FALSE);

	// Obtains the Translate Table Entries.
	BOOL	ObtainTranslateTableEntries(CParsedInfo& rParsedInfo);

	// Obtains translate table entries from alias definition.
	HRESULT ObtainTranslateTables(CParsedInfo& rParsedInfo);

	// Get the localized description values
	HRESULT GetLocalizedDesc(_bstr_t bstrRelPath, 
							 _bstr_t& bstrDesc,
							 CParsedInfo& rParsedInfo);

	// Connect to the localized namespace.
	HRESULT	ConnectToLocalizedNS(CParsedInfo&, IWbemLocator* pILocator);

	// Checks whether method are available with alias or not. 
	BOOL	AreMethodsAvailable(CParsedInfo& rParsedInfo);

	//Uninitializes the the member variables 
	void Uninitialize(BOOL bFinal = FALSE);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\commandswitches.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: CommandSwitches.cpp 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This class encapsulates the functionality needed
							  for accessing and storing the command switches 
							  information, which will be used by Parsing, 
							  Execution and Format Engines depending upon the 
							  applicability. 
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 20th-March-2001
****************************************************************************/ 
#include "Precomp.h"
#include "CommandSwitches.h"

/////////////////////////////////////////////////////////////////////////////
/*------------------------------------------------------------------------
   Name				 :CCommandSwitches
   Synopsis	         :This function initializes the member variables when
                      an object of the class type is instantiated
   Type	             :Constructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CCommandSwitches::CCommandSwitches()
{
	m_pszCommandInput			= NULL;
	m_pszAliasName				= NULL;
	m_pszAliasDesc				= NULL;
	m_pszClassPath				= NULL;
	m_pszPathExpr				= NULL;
	m_pszWhereExpr				= NULL;
	m_pszVerb					= NULL;
	m_pszMethodName				= NULL;
	m_pszAliasTarget			= NULL;
	m_bstrXML					= NULL;
	m_hResult					= S_OK;
	m_bSuccess					= TRUE;
	m_ulInterval				= 0;
	m_pszTransTableName			= NULL;
	m_nInteractiveMode			= DEFAULTMODE;
	m_pComError					= NULL;
	m_pszListFormat				= NULL;
	m_pszPWhereExpr             = NULL;
	m_uInformationCode			= 0;	
	m_pIMethOutParam			= NULL;
	m_pszUser					= NULL;
	m_pszPassword				= NULL;
	m_pszNamespace				= NULL;
	m_pszNode					= NULL;
	m_pszLocale					= NULL;
	m_pszVerbDerivation			= NULL;
	m_vtVerbType				= NONALIAS;
	m_bCredFlag					= FALSE;
	m_bExplicitWhereExpr		= FALSE;
	m_uErrataCode				= 0;	
	m_bTranslateFirst			= TRUE;
	m_pszResultClassName        = NULL;
	m_pszResultRoleName         = NULL;
	m_pszAssocClassName         = NULL;
	m_ulRepeatCount				= 0;
	m_bMethAvail				= FALSE;
	m_bWritePropsAvail			= FALSE;
	m_bLISTFrmsAvail			= FALSE;
	m_bNamedParamList			= FALSE;
	m_bEverySwitch              = FALSE;
	m_bOutputSwitch             = FALSE;
	m_bstrFormedQuery           = NULL;
	m_bSysProp					= FALSE;
	ClearXSLTDetailsVector();
}

/*------------------------------------------------------------------------
   Name				 :~CCommandSwitches
   Synopsis	         :This function Uninitializes the member variables when
                      an object of the class type is destructed.
   Type	             :Destructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CCommandSwitches::~CCommandSwitches()
{
	Uninitialize();
}

/*------------------------------------------------------------------------
   Name				 :SetCommandInput
   Synopsis	         :This function Assigns the parameter passed to m_psz
                      CommandInput
   Type	             :Member Function
   Input parameter   :
    pszCommandinput  -String type, Contains the command string
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetCommandInput (pszCommandInput)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetCommandInput(const _TCHAR* pszCommandInput)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszCommandInput);
	if (pszCommandInput)
	{
		m_pszCommandInput = new _TCHAR [lstrlen(pszCommandInput)+1];
		if(m_pszCommandInput)
			lstrcpy(m_pszCommandInput, pszCommandInput);	
		else
			bResult=FALSE;
	}	
	return bResult;
};

/*------------------------------------------------------------------------
   Name				 :SetAliasName
   Synopsis	         :This function assigns the parameters 
					  passed to m_pszAliasName.
   Type	             :Member Function
   Input parameter   :
     pszAliasName    -String type,Contains the alias name
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAliasName(pszAliasName)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetAliasName(const _TCHAR* pszAliasName)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszAliasName);
	if (pszAliasName)
	{
		m_pszAliasName = new _TCHAR [lstrlen(pszAliasName)+1];
		if(m_pszAliasName)
			lstrcpy(m_pszAliasName, pszAliasName);	
		else
			bResult = FALSE;
	}
	return bResult;
};

/*------------------------------------------------------------------------
   Name				 :SetAliasDesc
   Synopsis	         :This function sets the alias description
   Type	             :Member Function
   Input parameter   :
     pszAliasName    -String type,Contains the alias description
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAliasDesc(pszAliasDesc)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetAliasDesc(const _TCHAR* pszAliasDesc)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszAliasDesc);
	if (pszAliasDesc)
	{
		m_pszAliasDesc = new _TCHAR [lstrlen(pszAliasDesc)+1];
		if(m_pszAliasDesc)
			lstrcpy(m_pszAliasDesc, pszAliasDesc);	
		else
			bResult = FALSE;
	}
	return bResult;
};

/*------------------------------------------------------------------------
   Name				 :SetClassPath
   Synopsis	         :This function Assigns the parameter passed to 
					  m_pszClassPath.
   Type	             :Member Function
   Input parameter   :
     pszClassPath    -String type,Contains the class path in the command.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetClassPath(pszClassPath)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetClassPath(const _TCHAR* pszClassPath)
{
	BOOL bResult = TRUE;
    SAFEDELETE(m_pszClassPath);
	if (pszClassPath)
	{
		m_pszClassPath = new _TCHAR [lstrlen(pszClassPath)+1];
		if(m_pszClassPath)
			lstrcpy(m_pszClassPath, pszClassPath);	
		else
			bResult = FALSE;
	}
	return bResult;

}

/*------------------------------------------------------------------------
   Name				 :SetPathExpression
   Synopsis	         :This function Assigns the parameter passed to m_psz
                      PathExpr.
   Type	             :Member Function
   Input parameter   :
       pszPathExpr   -String type, Contains the path value in the command.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetPathExpression(pszPathExpr)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetPathExpression(const _TCHAR* pszPathExpr)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszPathExpr);
	if (pszPathExpr)
	{
		m_pszPathExpr = new _TCHAR [lstrlen(pszPathExpr)+1];
		if(m_pszPathExpr)
			lstrcpy(m_pszPathExpr, pszPathExpr);	
		else
			bResult = FALSE;
	}		
	return bResult;

}

/*------------------------------------------------------------------------
   Name				 :SetWhereExpression
   Synopsis	         :This function Assigns the parameter passed to 
                      m_pszWhereExpr.
   Type	             :Member Function
   Input parameter   :
      pszWhereExpr   -String type,Contains the where value in the command.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetWhereExpression(pszWhereExpr)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetWhereExpression(const _TCHAR* pszWhereExpr)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszWhereExpr);
	if (pszWhereExpr)
	{
		m_pszWhereExpr = new _TCHAR [lstrlen(pszWhereExpr)+1];
		if(m_pszWhereExpr)
			lstrcpy(m_pszWhereExpr, pszWhereExpr);	
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetMethodName
   Synopsis	         :This function Assigns the parameter passed to 
                      m_pszMethodName.
   Type	             :Member Function
   Input parameter   :
     pszMethodName   -String type,Contains the method specified for the
	                  class 
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetMethodName(pszMethodName)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetMethodName(const _TCHAR* pszMethodName)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszMethodName);
	if (pszMethodName)
	{
		m_pszMethodName = new _TCHAR [lstrlen(pszMethodName)+1];
		if(m_pszMethodName)
			lstrcpy(m_pszMethodName, pszMethodName);	
		else
			bResult = FALSE;
	}	
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :AddToXSLTDetailsVector
   Synopsis	         :This function adds a XSLTDET structure to 
					  m_xdvXSLTDetVec vector.
   Type	             :Member Function
   Input parameter   :
		xdXSLTDet    - XSLTDET type specifies the details of XSL transform.
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :AddToXSLTDetailsVector(xdXSLTDet)
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::AddToXSLTDetailsVector(XSLTDET xdXSLTDet)
{
	try
	{
		CHString sTemp(LPWSTR(xdXSLTDet.FileName));
		CHString sLastFour = sTemp.Right(4);
		CHString sXslExt(_T(".xsl"));

		WMICLIINT nPos = sLastFour.CompareNoCase(sXslExt);
		if (nPos != 0)
		{
			xdXSLTDet.FileName += _T(".xsl");
		}
	}
	catch(CHeap_Exception)
	{
		throw OUT_OF_MEMORY;
	}
	catch(...)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	m_xdvXSLTDetVec.push_back(xdXSLTDet);
}

/*------------------------------------------------------------------------
   Name				 :SetVerbName
   Synopsis	         :This function Assigns the parameter passed to 
                      m_pszVerbName.
   Type	             :Member Function
   Input parameter   :
       pszVerbName   -String type,Contains the Verbname in the command
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetVerbName( pszVerbName)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetVerbName(const _TCHAR* pszVerbName)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszVerb);
	if (pszVerbName)
	{
		m_pszVerb = new _TCHAR [lstrlen(pszVerbName)+1];
		if(m_pszVerb)
			lstrcpy(m_pszVerb, pszVerbName);	
		else
			bResult = FALSE;
	}
	return bResult;
};

/*------------------------------------------------------------------------
   Name				 :SetAliasTarget
   Synopsis	         :This function Assigns the parameter passed to 
                      m_pszAliasTarget.
   Type	             :Member Function
   Input parameters  :
     pszAliasTarget  -String type,the namespace where alias to 
					  operate against 
	                  are available.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAliasTarget(pszAliasTarget)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetAliasTarget(const _TCHAR* pszAliasTarget)
{
	BOOL bResult = TRUE; 
	SAFEDELETE(m_pszAliasTarget);
	if (pszAliasTarget)
	{
		m_pszAliasTarget = new _TCHAR [lstrlen(pszAliasTarget)+1];
		if(m_pszAliasTarget)
			lstrcpy(m_pszAliasTarget, pszAliasTarget);	
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :AddToPropertyList
   Synopsis	         :This function Adds string that is passed 
					  through parameter to m_cvproperties, which 
					  is a data member of type BSTRMAP.
   Type	             :Member Function
   Input parameter   :
       pszProperty   -String type,Used for storing properties 
	                  associated with an alias object.  
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :AddToPropertyList(pszProperty)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::AddToPropertyList(_TCHAR* const pszProperty)
{
	BOOL bRet = TRUE;
	if (pszProperty)
	{
		try
		{
			_TCHAR* pszTemp = NULL;
			pszTemp = new _TCHAR [lstrlen(pszProperty)+1];
			if ( pszTemp != NULL )
			{
				lstrcpy(pszTemp, pszProperty);
				m_cvProperties.push_back(pszTemp);
			}
			else
				bRet = FALSE;
		}
		catch(...)
		{
			bRet = FALSE;
		}
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :AddToPWhereParamsList
   Synopsis	         :This function Stores the parameter passed into
					  m_cvPWhereParams map array.
   Type	             :Member Function
   Input parameter   :
      pszParameter   -string type, Used to store parameters associated 
	                  with the verbs
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :AddToPWhereParamsList(pszParameter)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::AddToPWhereParamsList(_TCHAR* const pszParameter)
{
	BOOL bRet= TRUE;
	if (pszParameter)
	{
		try
		{
			_TCHAR* pszTemp = new _TCHAR [lstrlen(pszParameter)+1];
			if ( pszTemp != NULL )
			{
				lstrcpy(pszTemp, pszParameter);
				m_cvPWhereParams.push_back(pszTemp);
			}
			else
				bRet = FALSE;
		}
		catch(...)
		{
			bRet = FALSE;
		}
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :AddToParameterMap
   Synopsis	         :This function Adds bstrKey and bstrValue passed as 
                      parameters to m_bmParameters, which is type of
					  BSTRMAP data structure.
   Type	             :Member Function
   Input parameter   :
   bstrKey           -bstr type contains a key value used in MAP file  
   bstrValue         -bstr type contains a value associated with the key
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :AddToParameterMap(bstrKey,bstrValue)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::AddToParameterMap(_bstr_t bstrKey, _bstr_t bstrValue)
{
	BOOL bResult = TRUE;
	try
	{
		m_bmParameters.insert(BSTRMAP::value_type(bstrKey, bstrValue));
	}
	catch(...)
	{
		bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :AddToAliasFormatDetMap
   Synopsis	         :This function Adds bstrKey and bstrValue passed as 
                      parameters to m_bmAliasForamt, which is type of
					  BSTRMAP data structure.
   Type	             :Member Function
   Input parameter   :
   bstrKey           -bstr type contains a key value used in MAP file  
   bstrValue         -bstr type contains a value associated with the key
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :AddToAliasFormatDetMap(bstrKey,bvProps)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::AddToAliasFormatDetMap(_bstr_t bstrKey, BSTRVECTOR bvProps)
{
	BOOL bResult = TRUE;
	try
	{
		m_afdAlsFmtDet.insert(ALSFMTDETMAP::value_type(bstrKey, bvProps));
	}
	catch(...)
	{
		bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :UpdateParameterValue
   Synopsis	         :This function Updates bstrKey and bstrValue 
					  passed as parameters to m_bmParameters, which 
					  is type of BSTRMAP data structure.
   Type	             :Member Function
   Input parameter   :
    bstrKey          -bstr type contains a key value used in MAP file  
    bstrValue        -bstr type contains a value associated with the key
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :UpdateParameterValue(bstrKey,bstrValue)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::UpdateParameterValue(_bstr_t bstrKey, _bstr_t bstrValue)
{
	BOOL bResult = TRUE;
	try
	{
		m_bmParameters[bstrKey] = bstrValue;
	}
	catch(...)
	{
		bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :AddToAlsFrnNmsOrTrnsTblMap
   Synopsis	         :This function Adds bstrKey and bstrValue passed 
                      as parameters to m_bmAlsFrnNmsDesOrTrnsTblEntrs, 
					  which is type of BSTRMAP.
   Type	             :Member Function
   Input parameter   :
          bstrKey    -bstr type contains a key value used in MAP file  
          bstrValue  -bstr type contains a value associated with the key
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :AddToAlsFrnNmsOrTrnsTblMap(bstrKey,bstrValue)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::AddToAlsFrnNmsOrTrnsTblMap(_bstr_t bstrKey, 
												 _bstr_t bstrValue)
{
	BOOL bResult = TRUE;
	try
	{
		m_bmAlsFrnNmsDesOrTrnsTblEntrs.
				insert(BSTRMAP::value_type(bstrKey, bstrValue));
	}
	catch(...)
	{
		bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :AddToMethDetMap
   Synopsis	         :This function Adds bstrKey and mdMethDet passed as 
                      parameters to m_mdmMethDet, which is type of METHDETMAP.
   Type	             :Member Function
   Input parameter   :
           bstrKey   -bstr type contains a key value used in MAP file  
         mdMethDet   -METTHODDETAILS type contains the method attributes.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :AddToMethDetMap(bstrKey,mdMethDet)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::AddToMethDetMap(_bstr_t bstrKey, 
										METHODDETAILS mdMethDet)
{
	BOOL bResult = TRUE;
	try
	{
		m_mdmMethDet.insert(METHDETMAP::value_type(bstrKey, mdMethDet));
	}
	catch(...)
	{
		bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :AddToPropDetMap
   Synopsis	         :This function Adds bstrKey and pdPropDet passed as 
                      parameters to m_pdmPropDet,
					  which is type of PROPDETMAP.
   Type	             :Member Function
   Input parameter   :
           bstrKey   - bstr type contains a key value used in MAP file  
         pdPropDet   - PROPERTYDETAILS type contains a value associated with 
					   the key
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :AddToPropDetMap(bstrKey,pdPropDet)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::AddToPropDetMap(_bstr_t bstrKey, 
										PROPERTYDETAILS pdPropDet)
{
	BOOL bResult = TRUE;
	try
	{
		m_pdmPropDet.insert(PROPDETMAP::value_type(bstrKey, pdPropDet));
	}
	catch(...)
	{
		bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetXMLResultSet
   Synopsis	         :This function Assigns the parameter passed to 
                      m_bstrXML.
   Type	             :Member Function
   Input parameter   :
   bstrXMLResultSet  -BSTR type,XML file name containing result set.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetXMLResultSet(bstrXMLResultSet)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetXMLResultSet(const BSTR bstrXMLResultSet)
{
	BOOL bResult = TRUE;
	SAFEBSTRFREE(m_bstrXML);
	if (bstrXMLResultSet != NULL)
	{
		try
		{
			m_bstrXML = SysAllocString(bstrXMLResultSet);
		}
		catch(...)
		{
			bResult = FALSE;
		}
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetSuccessFlag
   Synopsis	         :This function Assigns the Boolean variable to 
					  m_bSuccess.
   Type	             :Member Function
   Input parameter   :
          bSuccess   -Boolean type,Specifies whether success or failure
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetSuccessFlag(bSuccess)
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::SetSuccessFlag(BOOL bSuccess)
{
	m_bSuccess = bSuccess;
	
}

/*------------------------------------------------------------------------
   Name				 :SetRetrievalInterval
   Synopsis	         :This function Assigns the integer value to m_nInterval.
   Type	             :Member Function
   Input parameter   :
         ulInterval   - unsigned long type,Specifies the time interval 
					  given by the EVERY switch in  GET verb.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetRetrievalInterval(lInterval)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetRetrievalInterval(const ULONG ulInterval)
{
	m_ulInterval = ulInterval;

	// Reset the repeat count
	m_ulRepeatCount = 0;
	return TRUE;
}

/*------------------------------------------------------------------------
   Name				 :SetTranslateTableName
   Synopsis	         :This function Assigns the string variable to 
                      m_pszTransTableName.
   Type	             :Member Function
   Input parameter   :
    pszTransTableName - String type,Specifies the occurrence of 
		              TRANSLATE switch and TABLE Name in the command for GET
					  verb.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetTranslateTableName(pszTranstableName)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetTranslateTableName(const _TCHAR* pszTransTableName)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszTransTableName);
	if (pszTransTableName)
	{
		m_pszTransTableName = new _TCHAR [lstrlen(pszTransTableName)+1];
		if(m_pszTransTableName)
			lstrcpy(m_pszTransTableName,pszTransTableName);
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetListFormat
   Synopsis	         :This function Assigns the parameter value to
                      m_pszListFormat.
   Type	             :Member Function
   Input parameter   :
     pszListFormat   -LISTFORMAT type, Specifies the list format
	                  specified in the command.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetListFormat(pszListFormat)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetListFormat(const _TCHAR *pszListFormat)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszListFormat);
	if (pszListFormat)
	{
		m_pszListFormat = new _TCHAR [lstrlen(pszListFormat)+1];
		if(m_pszListFormat)
			lstrcpy(m_pszListFormat,pszListFormat);
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetInteractiveMode
   Synopsis	         :This function sets the verb execution interactive mode 
   Type	             :Member Function
   Input parameter   :
   bInteractiveMode  -integer, sets or resets the verb execution interactive 
					  mode 
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetInteractiveMode(nInteractiveMode)
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::SetInteractiveMode(WMICLIINT nInteractiveMode)
{
	m_nInteractiveMode = nInteractiveMode;
	
}

/*------------------------------------------------------------------------
   Name				 :SetErrataCode
   Synopsis	         :This function sets the error code.
   Type	             :Member Function
   Input parameter   :
		uErrataCode  -Unsignedinttype, specifies the error code.
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetErrataCode(uErrataCode)
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::SetErrataCode(const UINT uErrataCode)
{
	m_uErrataCode = uErrataCode;
	
}

/*------------------------------------------------------------------------
   Name				 :SetRepeatCount
   Synopsis	         :This function sets the repeat count.
   Type	             :Member Function
   Input parameter   :
		uRepCount  - Unsigned inttype, specifies the repeat count.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetRepeatCount(uRepCount)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetRepeatCount(const ULONG ulRepCount)
{
	m_ulRepeatCount = ulRepCount;
	return TRUE;
}

/*------------------------------------------------------------------------
   Name				 :SetInformationCode
   Synopsis	         :This function sets the message code.
   Type	             :Member Function
   Input parameter   :
	uInformationCode -Unsignedinttype, specifies the information code.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetInformationCode(uInformationCode)
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::SetInformationCode(const UINT uInformationCode)
{
	m_uInformationCode = uInformationCode;
	
}

/*------------------------------------------------------------------------
   Name				 :SetPWhereExpr
   Synopsis	         :This function Assigns the parameter passed to 
					  m_pszPWhereExpr that represents Alias's PWhere string
   Type	             :Member Function
   Input parameter   :
     pszPWhereExpr    -String type,Contains the PWhere expr.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetPWhereExpr(pszPWhereExpr)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetPWhereExpr(const _TCHAR* pszPWhereExpr)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszPWhereExpr);
	if (pszPWhereExpr)
	{
		m_pszPWhereExpr = new _TCHAR [lstrlen(pszPWhereExpr)+1];
		if(m_pszPWhereExpr)
			lstrcpy(m_pszPWhereExpr, pszPWhereExpr);	
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetCOMError
   Synopsis	         :This function Assigns the parameter passed to 
					  m_pComError that consist of error info
   Type	             :Member Function
   Input parameter   :
     rComError	     -object of _com_error which consist of error info
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetCOMError(rComError)
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::SetCOMError(_com_error& rComError)
{
	BOOL bResult = TRUE;
	FreeCOMError();
	m_pComError = new _com_error(rComError);

	// memory allocation failed.
	if (m_pComError == NULL)
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
}

/*------------------------------------------------------------------------
   Name				 :SetAliasUser
   Synopsis	         :This function sets the alias user 
   Type	             :Member Function
   Input parameter   :
			pszUser - user name.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAliasUser()
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetAliasUser(const _TCHAR* pszUser)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszUser);
	if (pszUser)
	{
		m_pszUser = new _TCHAR [lstrlen(pszUser)+1];
		if(m_pszUser)
			lstrcpy(m_pszUser, pszUser);	
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetAliasNode
   Synopsis	         :This function sets the alias node 
   Type	             :Member Function
   Input parameter   :
				pszNode - node name.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAliasNode()
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetAliasNode(const _TCHAR* pszNode)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszNode);
	if (pszNode)
	{
		m_pszNode = new _TCHAR [lstrlen(pszNode)+1];
		if(m_pszNode)
			lstrcpy(m_pszNode, pszNode);	
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetAliasPassword
   Synopsis	         :This function sets the alias password
   Type	             :Member Function
   Input parameter   :
				pszPassword - password
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAliasPassword()
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetAliasPassword(const _TCHAR* pszPassword)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszPassword);
	if (pszPassword)
	{
		m_pszPassword = new _TCHAR [lstrlen(pszPassword)+1];
		if(m_pszPassword)
			lstrcpy(m_pszPassword, pszPassword);	
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetAliasLocale
   Synopsis	         :This function sets the alias locale
   Type	             :Member Function
   Input parameter   :
				pszLocale - locale value
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAliasLocale()
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetAliasLocale(const _TCHAR* pszLocale)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszLocale);
	if (pszLocale)
	{
		m_pszLocale = new _TCHAR [lstrlen(pszLocale)+1];
		if(m_pszLocale)
			lstrcpy(m_pszLocale, pszLocale);	
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetAliasNamespace
   Synopsis	         :This function sets the alias namespace 
   Type	             :Member Function
   Input parameter   :
				pszNamespace - namespace
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAliasNamespace()
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetAliasNamespace(const _TCHAR* pszNamespace)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszNamespace);
	if (pszNamespace)
	{
		m_pszNamespace = new _TCHAR [lstrlen(pszNamespace)+1];
		if(m_pszNamespace)
			lstrcpy(m_pszNamespace, pszNamespace);	
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetMethExecOutParam
   Synopsis	         :This function sets the parameter
					  m_pIMethExecOutParam.
   Type	             :Member Function
   Input parameter   :
	IWbemClassObject*-pIMethOutputParam 
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetMethExecOutParam(pIMethOutParam)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetMethExecOutParam(IWbemClassObject* pIMethOutParam)
{
	BOOL bSuccess = TRUE;
	SAFEIRELEASE(m_pIMethOutParam);
	if (pIMethOutParam)
	{
		try
		{
			m_pIMethOutParam = pIMethOutParam;
			m_pIMethOutParam->AddRef();
		}
		catch(...)
		{
			bSuccess = FALSE;
		}
	}
	return bSuccess;
}

/*------------------------------------------------------------------------
   Name				 :SetVerbType
   Synopsis	         :This function sets the parameter
					  m_vtVerbType.
   Type	             :Member Function
   Input parameter   :
		vtVerbType   - vtVerbType 
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetVerbType(vtVerbType)
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::SetVerbType(VERBTYPE vtVerbType)
{
	m_vtVerbType = vtVerbType;
}

/*------------------------------------------------------------------------
   Name				 :SetVerbDerivation
   Synopsis	         :This function sets the verb derivation
   Type	             :Member Function
   Input parameter   :
    pszVerbDerivation - Derivation associated with the verb.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :CCmdAlias::ObtainAliasVerbDetails()
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetVerbDerivation(const _TCHAR* pszVerbDerivation)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszVerbDerivation);
	if (pszVerbDerivation)
	{
		m_pszVerbDerivation = new _TCHAR [lstrlen(pszVerbDerivation)+1];
		if(m_pszVerbDerivation)
			lstrcpy(m_pszVerbDerivation, pszVerbDerivation);	
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :GetCommandInput
   Synopsis	         :This function Returns the command input held by
                      the Command Switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetCommandInput()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetCommandInput()
{
	return m_pszCommandInput;
}

/*------------------------------------------------------------------------
   Name				 :GetAliasName()
   Synopsis	         :This function Returns the alias name held by the 
					  command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetAliasName()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetAliasName()
{
	return m_pszAliasName;
}

/*------------------------------------------------------------------------
   Name				 :GetAliasDesc()
   Synopsis	         :This function Returns the alias description
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetAliasDesc()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetAliasDesc()
{
	return m_pszAliasDesc;
}

/*------------------------------------------------------------------------
   Name				 :GetClassPath
   Synopsis	         :This function Returns the class path held by the 
					  command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetClassPath()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetClassPath()
{
	return m_pszClassPath;
}

/*------------------------------------------------------------------------
   Name				 :GetPathExpression
   Synopsis	         :This function Returns the path expression held
                      by the command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetPathExpression()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetPathExpression()
{
	return m_pszPathExpr;
}

/*------------------------------------------------------------------------
   Name				 :GetWhereExpression
   Synopsis	         :This function Returns the where expression 
                      held by the command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetWhereExpression()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetWhereExpression()
{
	return m_pszWhereExpr;
}

/*------------------------------------------------------------------------
   Name				 :GetMethodName()
   Synopsis	         :This function Returns the method name held by the 
					  command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetMethodName()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetMethodName()
{
	return m_pszMethodName;
}

/*------------------------------------------------------------------------
   Name				 :GetXSLTDetailsVector
   Synopsis	         :This function Returns the XSLTDETVECTOR held by 
                      the command switches object.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :XSLTDETVECTOR
   Global Variables  :None
   Calling Syntax    :GetXSLTDetailsVector()
   Notes             :None
------------------------------------------------------------------------*/
XSLTDETVECTOR& CCommandSwitches::GetXSLTDetailsVector()
{
	return m_xdvXSLTDetVec;
}

/*------------------------------------------------------------------------
   Name				 :GetVerbName
   Synopsis	         :This function Returns the verb name held by the 
					  command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetVerbName()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetVerbName()
{
	return m_pszVerb;
}

/*------------------------------------------------------------------------
   Name				 :GetAliasTarget
   Synopsis	         :This function Returns the alias target held by 
                      the command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetAliasTarget()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetAliasTarget()
{
	return m_pszAliasTarget;
}

/*------------------------------------------------------------------------
   Name				 :GetXMLResultSet
   Synopsis	         :This function Returns the XML result set 
                      held by the command switches object.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BSTR
   Global Variables  :None
   Calling Syntax    :GetXMLResultSet()
   Notes             :None
------------------------------------------------------------------------*/
BSTR CCommandSwitches::GetXMLResultSet()
{
	return m_bstrXML;
}

/*------------------------------------------------------------------------
   Name				 :GetPropertyList
   Synopsis	         :This function Returns the property held by the 
					  command switches object.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :CHARVECTOR&
   Global Variables  :None
   Calling Syntax    :GetPropertyList()
   Notes             :None
------------------------------------------------------------------------*/
CHARVECTOR& CCommandSwitches::GetPropertyList()
{
	return m_cvProperties;
}

/*------------------------------------------------------------------------
   Name				 :GetPWhereParamsList
   Synopsis	         :This function Returns the PWhereParameters list held
					  by the command switches object.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :CHARVECTOR&
   Global Variables  :None
   Calling Syntax    :GetPWhereParamsList()
   Notes             :None
------------------------------------------------------------------------*/
CHARVECTOR& CCommandSwitches::GetPWhereParamsList()
{
	return m_cvPWhereParams;
}

/*------------------------------------------------------------------------
   Name				 :GetAlsFrnNmsOrTrnsTblMap
   Synopsis	         :This function Returns the alias friendly names map 
                      held by the command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BSTRMAP&
   Global Variables  :None
   Calling Syntax    :GetAlsFrnNmsOrTrnsTblMap()
   Notes             :None
------------------------------------------------------------------------*/
BSTRMAP& CCommandSwitches::GetAlsFrnNmsOrTrnsTblMap()
{
	return m_bmAlsFrnNmsDesOrTrnsTblEntrs;
}

/*------------------------------------------------------------------------
   Name				 :GetMethDetMap
   Synopsis	         :This function Returns the method or verb details
                      map held by the command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :METHDETMAP&
   Global Variables  :None
   Calling Syntax    :GetMethDetMap()
   Notes             :None
------------------------------------------------------------------------*/
METHDETMAP& CCommandSwitches::GetMethDetMap()
{
	return m_mdmMethDet;
}

/*------------------------------------------------------------------------
   Name				 :GetPropDetMap
   Synopsis	         :This function Returns the prop details map held by
					  the command switches object.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :PROPDETMAP&
   Global Variables  :None
   Calling Syntax    :GetPropDetMap()
   Notes             :None
------------------------------------------------------------------------*/
PROPDETMAP& CCommandSwitches::GetPropDetMap()
{
	return m_pdmPropDet;
}

/*------------------------------------------------------------------------
   Name				 :GetParameterMap
   Synopsis	         :This function Returns the parameter map containing
                      both key and value held by the command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BSTRMAP&
   Global Variables  :None
   Calling Syntax    :GetParameterMap()
   Notes             :None
------------------------------------------------------------------------*/
BSTRMAP& CCommandSwitches::GetParameterMap()
{
	return m_bmParameters;
}

/*------------------------------------------------------------------------
   Name				 :GetAliasFormatDetMap
   Synopsis	         :This function Returns the alias formats available
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :ALSFMTDETMAP&
   Global Variables  :None
   Calling Syntax    :GetAliasFormatDetMap()
   Notes             :None
------------------------------------------------------------------------*/
ALSFMTDETMAP& CCommandSwitches::GetAliasFormatDetMap()
{
	return m_afdAlsFmtDet;
}

/*------------------------------------------------------------------------
   Name				 :GetSuccessFlag
   Synopsis	         :This function Returns the success flag held by 
                      the command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetSuccessFlag()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::GetSuccessFlag()
{
	return m_bSuccess;
}

/*------------------------------------------------------------------------
   Name				 :GetRetrievalInterval
   Synopsis	         :This function Returns the value of m_ulInterval held 
					  by the command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :ULONG
   Global Variables  :None
   Calling Syntax    :GetRetrievalInterval()
   Notes             :None
------------------------------------------------------------------------*/
ULONG CCommandSwitches::GetRetrievalInterval()
{
	return m_ulInterval;
}

/*------------------------------------------------------------------------
   Name				 :GetTranslateTableName
   Synopsis	         :This function Returns the content of m_pszTransTableName
					  held by the command switches object.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetTranslateTableName()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetTranslateTableName()
{
	return m_pszTransTableName;
}

/*------------------------------------------------------------------------
   Name				 :GetListFormat
   Synopsis	         :This function Returns the list format type 
					  m_pszListFormat held by the command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetListFormat()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetListFormat()
{
	return m_pszListFormat;
}

/*------------------------------------------------------------------------
   Name				 :GetInteractiveMode
   Synopsis	         :This function Returns the interactive mode flag 
                      m_bInteractiveMode held by the command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :WMICLINT
   Global Variables  :None
   Calling Syntax    :GetInteractiveMode()
   Notes             :None
------------------------------------------------------------------------*/
WMICLIINT CCommandSwitches::GetInteractiveMode()
{
	return m_nInteractiveMode;
}

/*------------------------------------------------------------------------
   Name				 :GetClassOfAliasTarget
   Synopsis	         :This function gets the class of Alias
   Type	             :Member Function
   Input parameter   :Reference to bstrClassName
   Output parameters :bstrClassName
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :GetClassOfAliasTarget(bstrClassName)
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::GetClassOfAliasTarget(_bstr_t& bstrClassName)
{
	_TCHAR *pszTemp;
	try
	{
		if (m_pszAliasTarget != NULL )
		{
			pszTemp = new _TCHAR[lstrlen(m_pszAliasTarget)+1];
			if ( pszTemp != NULL )
			{
				lstrcpy(pszTemp, m_pszAliasTarget);
				_TCHAR* pszToken = NULL;

				pszToken = _tcstok(pszTemp, CLI_TOKEN_SPACE);
				while (pszToken != NULL)
				{
					bstrClassName = _bstr_t(pszToken);
					pszToken = _tcstok(NULL, CLI_TOKEN_SPACE);

					if(CompareTokens(pszToken,CLI_TOKEN_FROM))
					{
						bstrClassName = _bstr_t(pszToken);
						pszToken = _tcstok(NULL, CLI_TOKEN_SPACE);
						if (pszToken != NULL)
						{
							bstrClassName = _bstr_t(pszToken);	
							break;
						}
					}
				}
				SAFEDELETE(pszTemp);
			}
			else
				_com_issue_error(WBEM_E_OUT_OF_MEMORY);
		}
	}
	catch(_com_error& e)
	{
		SAFEDELETE(pszTemp);
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :GetErrataCode
   Synopsis	         :This function returns the error code
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :UINT
   Global Variables  :None
   Calling Syntax    :GetErrataCode()
   Notes             :None
------------------------------------------------------------------------*/
UINT CCommandSwitches::GetErrataCode()
{
	return m_uErrataCode;
}

/*------------------------------------------------------------------------
   Name				 :GetRepeatCount
   Synopsis	         :This function returns the repeat count.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :ULONG
   Global Variables  :None
   Calling Syntax    :GetRepeatCount()
   Notes             :None
------------------------------------------------------------------------*/
ULONG CCommandSwitches::GetRepeatCount()
{
	return m_ulRepeatCount;
}

/*------------------------------------------------------------------------
   Name				 :GetInformationCode
   Synopsis	         :This function returns the message code
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :UINT
   Global Variables  :None
   Calling Syntax    :GetInformationCode()
   Notes             :None
------------------------------------------------------------------------*/
UINT CCommandSwitches::GetInformationCode()
{
	return m_uInformationCode;
}

/*------------------------------------------------------------------------
   Name				 :GetPWhereExpr
   Synopsis	         :This function returns the PWhere string
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :UINT
   Global Variables  :None
   Calling Syntax    :GetPWhereExpr()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetPWhereExpr()
{
	return m_pszPWhereExpr;
}

/*------------------------------------------------------------------------
   Name				 :GetCOMError
   Synopsis	         :This function returns the COMError object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_com_error*
   Global Variables  :None
   Calling Syntax    :GetCOMError()
   Notes             :None
------------------------------------------------------------------------*/
_com_error* CCommandSwitches::GetCOMError()
{
	return m_pComError;
}

/*------------------------------------------------------------------------
   Name				 :GetMethExecOutParam
   Synopsis	         :This function returns the parameter
					  m_pIMethExecOutParam.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :Pointer to IWbemClassObject
   Global Variables  :None
   Calling Syntax    :GetMethExecOutParam()
   Notes             :None
------------------------------------------------------------------------*/
IWbemClassObject* CCommandSwitches::GetMethExecOutParam()
{
	return m_pIMethOutParam;
}

/*------------------------------------------------------------------------
   Name				 :GetAliasUser
   Synopsis	         :This function returns the alias user 
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetAliasUser()
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetAliasUser()
{
	return m_pszUser;
}

/*------------------------------------------------------------------------
   Name				 :GetAliasPassword
   Synopsis	         :This function returns the alias password
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetAliasPassword()
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetAliasPassword()
{
	return m_pszPassword;
}

/*------------------------------------------------------------------------
   Name				 :GetAliasNode
   Synopsis	         :This function returns the alias node
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetAliasNode()
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetAliasNode()
{
	return m_pszNode;
}

/*------------------------------------------------------------------------
   Name				 :GetAliasLocale
   Synopsis	         :This function returns the alias locale
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetAliasLocale()
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetAliasLocale()
{
	return m_pszLocale;
}

/*------------------------------------------------------------------------
   Name				 :GetAliasNamespace
   Synopsis	         :This function returns the alias namespace
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetAliasNamespace()
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetAliasNamespace()
{
	return m_pszNamespace;
}

/*------------------------------------------------------------------------
   Name				 :GetVerbType
   Synopsis	         :This function returns type of the verb
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :VERBTYPE
   Global Variables  :None
   Calling Syntax    :CParserEngine::ParseMethodInfo()
------------------------------------------------------------------------*/
VERBTYPE CCommandSwitches::GetVerbType()
{
	return m_vtVerbType;
}

/*------------------------------------------------------------------------
   Name				 :GetVerbDerivation
   Synopsis	         :This function Returns the derivation associated with
					  the verb.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetVerbDerivation()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetVerbDerivation()
{
	return m_pszVerbDerivation;
}

/*------------------------------------------------------------------------
   Name				 :Initialize
   Synopsis	         :This function initializes the necessary member 
					  variables.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :Initialize()
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::Initialize() throw(WMICLIINT)
{
	static BOOL bFirst		= TRUE;
	m_uErrataCode			= 0;	
	m_uInformationCode		= 0;	
	m_vtVerbType			= NONALIAS;
	m_bCredFlag				= FALSE;
	m_bExplicitWhereExpr	= FALSE;
	m_bTranslateFirst		= TRUE;

	if (bFirst)
	{
		// Default list format is assumed as FULL
		m_pszListFormat	= new _TCHAR [BUFFER32];

		if (m_pszListFormat == NULL)
			throw OUT_OF_MEMORY;
		lstrcpy(m_pszListFormat, _T("FULL"));
		bFirst = FALSE;
	}
}


/*------------------------------------------------------------------------
   Name				 :Uninitialize
   Synopsis	         :This function uninitializes the member variables 
					  when the execution of a command string issued on the
					  command line is completed.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :Uninitialize()
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::Uninitialize()
{
	SAFEDELETE(m_pszCommandInput);
	SAFEDELETE(m_pszAliasName);
	SAFEDELETE(m_pszAliasDesc);
	SAFEDELETE(m_pszClassPath);
	SAFEDELETE(m_pszPathExpr);
	SAFEDELETE(m_pszWhereExpr);
	SAFEDELETE(m_pszVerb);
	SAFEDELETE(m_pszMethodName);
	ClearXSLTDetailsVector();
	SAFEDELETE(m_pszAliasTarget);
	SAFEDELETE(m_pszUser);
	SAFEDELETE(m_pszLocale);
	SAFEDELETE(m_pszPassword);
	SAFEDELETE(m_pszNamespace);
	SAFEDELETE(m_pszNode);
	SAFEDELETE(m_pszVerbDerivation);
	SAFEDELETE(m_pszListFormat);
	SAFEDELETE(m_pszPWhereExpr);
	FreeCOMError();
	SAFEDELETE(m_pszTransTableName);

	CleanUpCharVector(m_cvProperties);
	CleanUpCharVector(m_cvInteractiveProperties);
	CleanUpCharVector(m_cvPWhereParams);
	CleanUpCharVector(m_cvTrnsTablesList);
	m_bmParameters.clear();
	m_afdAlsFmtDet.clear();
	m_bmAlsFrnNmsDesOrTrnsTblEntrs.clear();
	m_mdmMethDet.clear();
	m_pdmPropDet.clear();

	m_hResult				= S_OK;
	m_bSuccess				= TRUE;
	m_uInformationCode		= 0;	
	m_ulInterval				= 0;
	m_vtVerbType			= NONALIAS;
	m_bCredFlag				= FALSE;
	m_bExplicitWhereExpr	= FALSE;
	m_nInteractiveMode		= DEFAULTMODE;
	m_bTranslateFirst		= TRUE;
	SAFEIRELEASE(m_pIMethOutParam);
	SAFEBSTRFREE(m_bstrXML);
	SAFEDELETE(m_pszResultClassName);
	SAFEDELETE(m_pszResultRoleName);
	SAFEDELETE(m_pszAssocClassName);
	m_ulRepeatCount				= 0;
	m_bMethAvail				= FALSE;
	m_bWritePropsAvail			= FALSE;
	m_bLISTFrmsAvail			= FALSE;
	m_bNamedParamList			= FALSE;
	m_bEverySwitch              = FALSE; // do not put m_bOutputSwitch here.
	SAFEBSTRFREE(m_bstrFormedQuery);
	m_bSysProp					= FALSE;
}

/*------------------------------------------------------------------------
   Name				 :SetCredentialsFlag
   Synopsis	         :This function sets the credential flag status
   Type	             :Member Function
   Input parameter   :
				bCredFlag - credential flag value
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetCredentialsFlag()
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::SetCredentialsFlag(BOOL bCredFlag)
{
	m_bCredFlag = bCredFlag;
}

/*------------------------------------------------------------------------
   Name				 :SetExplicitWhereExprFlag
   Synopsis	         :This function sets the explicit where expression flag
   Type	             :Member Function
   Input parameter   :
				bWhereFlag - explicit where flag
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetExplicitWhereExprFlag()
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::SetExplicitWhereExprFlag(BOOL bWhereFlag)
{
	m_bExplicitWhereExpr = bWhereFlag;
}


/*------------------------------------------------------------------------
   Name				 :GetCredentialsFlagStatus
   Synopsis	         :This function returns the credential flag status
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetCredentialsFlagStatus()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::GetCredentialsFlagStatus()
{
	return m_bCredFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetExplicitWhereExprFlag
   Synopsis	         :This function returns the explicit where flag status
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetExplicitWhereExprFlag()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::GetExplicitWhereExprFlag()
{
	return m_bExplicitWhereExpr;
}

/*------------------------------------------------------------------------
   Name				 :FreeCOMError
   Synopsis	         :This function deletes the previously assigned 
					  error
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :FreeCOMError(rComError)
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::FreeCOMError()
{
	if (m_pComError != NULL)
	{
		delete m_pComError;
		m_pComError = NULL;
	}
}

/*------------------------------------------------------------------------
   Name				 :GetTrnsTablesList
   Synopsis	         :This function add the newly specified table name to 
					  the list of available translate table entries
   Type	             :Member Function
   Input parameter   :
			pszTableName - name of the translate table
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :AddToTrnsTablesList(pszTableName)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::AddToTrnsTablesList(_TCHAR* const pszTableName)
{
	BOOL bRet = TRUE;
	if (pszTableName)
	{
		try
		{
			_TCHAR* pszTemp = NULL;
			pszTemp = new _TCHAR [lstrlen(pszTableName)+1];
			if ( pszTemp != NULL )
			{
				lstrcpy(pszTemp, pszTableName);
				m_cvTrnsTablesList.push_back(pszTemp);
			}
			else
				bRet = FALSE;
		}
		catch(...)
		{
			bRet = FALSE;
		}
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :GetTrnsTablesList
   Synopsis	         :This function returns the populated translate table
					  information.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :
			reference to CHARVECTOR
   Global Variables  :None
   Calling Syntax    :GetTrnslTablesList()
   Notes             :None
------------------------------------------------------------------------*/
CHARVECTOR& CCommandSwitches::GetTrnsTablesList()
{
	return m_cvTrnsTablesList;
}

/*------------------------------------------------------------------------
   Name				 :SetTranslateFirstFlag
   Synopsis	         :This function sets the the order of the format and 
					  translate switch flag
   Type	             :Member Function
   Input parameter   :
		bTranslateFirst - order of the format and translate switch flag
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetTranslateFirstFlag(bTranslateFirst)
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::SetTranslateFirstFlag(BOOL bTranslateFirst)
{
	m_bTranslateFirst = bTranslateFirst;
}

/*------------------------------------------------------------------------
   Name				 :GetTranslateFirstFlag
   Synopsis	         :This function returns the order of the format and 
					  translate switch flag
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetTranslateFirstFlag()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::GetTranslateFirstFlag()
{
	return m_bTranslateFirst;
}

/*------------------------------------------------------------------------
   Name				 :ClearPropertyList
   Synopsis	         :This function clears the property list held by 
					  m_cvProperties. 
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :ClearPropertyList()
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::ClearPropertyList()
{
	CleanUpCharVector(m_cvProperties);
}

/*------------------------------------------------------------------------
   Name				 :SetResultClassName
   Synopsis	         :This function Assigns the string variable to 
                      m_pszTransTableName.
   Type	             :Member Function
   Input parameter   :
    pszTransTableName - String type,Specifies the occurrence of 
		              TRANSLATE switch and TABLE Name in the command for GET
					  verb.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetTranslateTableName(pszTranstableName)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetResultClassName(const _TCHAR* pszResultClassName)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszResultClassName);
	if (pszResultClassName)
	{
		m_pszResultClassName = new _TCHAR [lstrlen(pszResultClassName)+1];
		if(m_pszResultClassName)
			lstrcpy(m_pszResultClassName,pszResultClassName);
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetResultRoleName
   Synopsis	         :This function Assigns the string variable to 
                      m_pszTransTableName.
   Type	             :Member Function
   Input parameter   :
    pszTransTableName - String type,Specifies the occurrence of 
		              TRANSLATE switch and TABLE Name in the command for GET
					  verb.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetTranslateTableName(pszTranstableName)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetResultRoleName(const _TCHAR* pszResultRoleName)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszResultRoleName);
	if (pszResultRoleName)
	{
		m_pszResultRoleName = new _TCHAR [lstrlen(pszResultRoleName)+1];
		if(m_pszResultRoleName)
			lstrcpy(m_pszResultRoleName,pszResultRoleName);
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetAssocClassName
   Synopsis	         :This function Assigns the string variable to 
                      m_pszAssocClassName.
   Type	             :Member Function
   Input parameter   :
    pszAssocClassName - String type,Specifies the occurrence of 
		              TRANSLATE switch and TABLE Name in the command for GET
					  verb.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAssocClassName(pszAssocClassName)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetAssocClassName(const _TCHAR* pszAssocClassName)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszAssocClassName);
	if (pszAssocClassName)
	{
		m_pszAssocClassName = new _TCHAR [lstrlen(pszAssocClassName)+1];
		if(m_pszAssocClassName)
			lstrcpy(m_pszAssocClassName,pszAssocClassName);
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetMethodsAvailable
   Synopsis	         :This function sets the methods available flag 
					  m_bMethAvail, according to passed parameter.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetMethodsAvailable(bFlag)
   Notes             :None
------------------------------------------------------------------------*/
void	CCommandSwitches::SetMethodsAvailable(BOOL bFlag)
{
	m_bMethAvail = bFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetResultClassName
   Synopsis	         :This function Returns the content of m_pszResultClassName
					  held by the command switches object.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetResultClassName()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetResultClassName()
{
	return m_pszResultClassName;
}

/*------------------------------------------------------------------------
   Name				 :GetResultRoleName
   Synopsis	         :This function Returns the content of m_pszResultRoleName
					  held by the command switches object.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetResultRoleName()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetResultRoleName()
{
	return m_pszResultRoleName;
}

/*------------------------------------------------------------------------
   Name				 :GetAssocClassName
   Synopsis	         :This function Returns the content of m_pszAssocClassName
					  held by the command switches object.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetAssocClassName()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetAssocClassName()
{
	return m_pszAssocClassName;
}

/*------------------------------------------------------------------------
   Name				 :GetMethodsAvailable
   Synopsis	         :This function Returns the boolean value of 
					  m_bMethAvail.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetMethodsAvailable()
   Notes             :None
------------------------------------------------------------------------*/
BOOL	CCommandSwitches::GetMethodsAvailable()
{
	return m_bMethAvail;
}

/*------------------------------------------------------------------------
   Name				 :SetWriteablePropsAvailable
   Synopsis	         :This function sets writable properties available flag,
					  m_bWritePropsAvail.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetWriteablePropsAvailable(bFlag)
   Notes             :None
------------------------------------------------------------------------*/
void	CCommandSwitches::SetWriteablePropsAvailable(BOOL bFlag)
{
	m_bWritePropsAvail = bFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetWriteablePropsAvailable
   Synopsis	         :This function returns writable properties available 
					  flag, m_bWritePropsAvail.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetWriteablePropsAvailable()
   Notes             :None
------------------------------------------------------------------------*/
BOOL	CCommandSwitches::GetWriteablePropsAvailable()
{
	return m_bWritePropsAvail;
}

/*------------------------------------------------------------------------
   Name				 :SetLISTFormatsAvailable
   Synopsis	         :This function sets LIST Formats available flag,
					  m_bLISTFrmsAvail.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetLISTFormatsAvailable(bFlag)
   Notes             :None
------------------------------------------------------------------------*/
void	CCommandSwitches::SetLISTFormatsAvailable(BOOL bFlag)
{
	m_bLISTFrmsAvail = bFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetLISTFormatsAvailable
   Synopsis	         :This function returns LIST Formats available flag,
					  m_bLISTFrmsAvail.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetLISTFormatsAvailable()
   Notes             :None
------------------------------------------------------------------------*/
BOOL	CCommandSwitches::GetLISTFormatsAvailable()
{
	return m_bLISTFrmsAvail;
}

/*------------------------------------------------------------------------
   Name				 :AddToPropertyList
   Synopsis	         :This function Adds string that is passed 
					  through parameter to m_cvInteractiveProperties, 
					  which is a data member of type BSTRMAP.
   Type	             :Member Function
   Input parameter   :
       pszProperty   -String type,Used for storing properties 
	                  associated with an alias object.  
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :AddToPropertyList(pszProperty)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::AddToInteractivePropertyList(_TCHAR* const pszProperty)
{
	BOOL bRet = TRUE;
	if (pszProperty)
	{
		try
		{
			_TCHAR* pszTemp = NULL;
			pszTemp = new _TCHAR [lstrlen(pszProperty)+1];
			if ( pszTemp != NULL )
			{
				lstrcpy(pszTemp, pszProperty);
				m_cvInteractiveProperties.push_back(pszTemp);
			}
			else
				bRet = FALSE;
		}
		catch(...)
		{
			bRet = FALSE;
		}
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :GetPropertyList
   Synopsis	         :This function Returns the interactive property held 
						by the command switches object.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :CHARVECTOR&
   Global Variables  :None
   Calling Syntax    :GetPropertyList()
   Notes             :None
------------------------------------------------------------------------*/
CHARVECTOR& CCommandSwitches::GetInteractivePropertyList()
{
	return m_cvInteractiveProperties;
}

/*------------------------------------------------------------------------
   Name				 :SetNamedParamListFlag
   Synopsis	         :This function sets m_bNamedParamList member variable.
   Type	             :Member Function
   Input parameter(s):None
   Output parameter(s):
			bFlag	 - Boolean value.
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetNamedParamListFlag(bFlag)
   Notes             :None
------------------------------------------------------------------------*/
void	CCommandSwitches::SetNamedParamListFlag(BOOL bFlag)
{
	m_bNamedParamList = bFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetNamedParamListFlag
   Synopsis	         :This function returns the the boolean value held by 
					  m_bNamedParamList.
   Type	             :Member Function
   Input parameter(s):None
   Output parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetNamedParamListFlag()
   Notes             :None
------------------------------------------------------------------------*/
BOOL	CCommandSwitches::GetNamedParamListFlag()
{
	return m_bNamedParamList;
}

/*------------------------------------------------------------------------
   Name				 :ClearXSLTDetailsVector
   Synopsis	         :Clears or nullifies XSL Details vector.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :ClearXSLTDetailsVector()
   Notes             :None
------------------------------------------------------------------------*/
void	CCommandSwitches::ClearXSLTDetailsVector()
{
	m_xdvXSLTDetVec.clear();
}

/*------------------------------------------------------------------------
   Name				 :SetEverySwitchFlag
   Synopsis	         :This function sets m_bEverySwitch member variable.
   Type	             :Member Function
   Input parameter(s):None
   Output parameter(s):
			bFlag	 - Boolean value.
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetEverySwitchFlag(bFlag)
   Notes             :None
------------------------------------------------------------------------*/
void	CCommandSwitches::SetEverySwitchFlag(BOOL bFlag)
{
	m_bEverySwitch = bFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetEverySwitchFlag
   Synopsis	         :This function returns the the boolean value held by 
					  m_bEverySwitch.
   Type	             :Member Function
   Input parameter(s):None
   Output parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetEverySwitchFlag()
   Notes             :None
------------------------------------------------------------------------*/
BOOL	CCommandSwitches::GetEverySwitchFlag()
{
	return m_bEverySwitch;
}

/*------------------------------------------------------------------------
   Name				 :SetOutputSwitchFlag
   Synopsis	         :This function sets m_bOutputSwitch member variable.
   Type	             :Member Function
   Input parameter(s):None
   Output parameter(s):
			bFlag	 - Boolean value.
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetOutputSwitchFlag(bFlag)
   Notes             :None
------------------------------------------------------------------------*/
void	CCommandSwitches::SetOutputSwitchFlag(BOOL bFlag)
{
	m_bOutputSwitch = bFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetOutputSwitchFlag
   Synopsis	         :This function returns the the boolean value held by 
					  m_bOutputSwitch.
   Type	             :Member Function
   Input parameter(s):None
   Output parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetOutputSwitchFlag()
   Notes             :None
------------------------------------------------------------------------*/
BOOL	CCommandSwitches::GetOutputSwitchFlag()
{
	return m_bOutputSwitch;
}
/*------------------------------------------------------------------------
   Name				 :SetFormedQuery
   Synopsis	         :This function Assigns the parameter passed to 
                      m_bstrFormedQuery..
   Type	             :Member Function
   Input parameter   :
   bstrFormedQuery  -BSTR type,It is the query formed for the given command.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetFormedQuery(bstrFormedQuery)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetFormedQuery(const BSTR bstrFormedQuery)
{
	BOOL bResult = TRUE;
	SAFEBSTRFREE(m_bstrFormedQuery);
	if (bstrFormedQuery!= NULL)
	{
		try
		{
			m_bstrFormedQuery = SysAllocString(bstrFormedQuery);
		}
		catch(...)
		{
			bResult = FALSE;
		}
	}
	return bResult;
}
/*------------------------------------------------------------------------
   Name				 :GetFormedQuery
   Synopsis	         :This function Returns query formed for the given 
					  command.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BSTR
   Global Variables  :None
   Calling Syntax    :GetFormedQuery()
   Notes             :None
------------------------------------------------------------------------*/
BSTR CCommandSwitches::GetFormedQuery()
{
	return m_bstrFormedQuery;
}

/*------------------------------------------------------------------------
   Name				 :GetSysPropFlag
   Synopsis	         :This function returns the status of the system 
					  properties flag
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetSysPropFlag()
   Notes             :None
------------------------------------------------------------------------*/
BOOL	CCommandSwitches::GetSysPropFlag()
{
	return m_bSysProp;
}

/*------------------------------------------------------------------------
   Name				 :SetSysPropFlag
   Synopsis	         :This function sets the system properties flag, if 
					  the GET or LIST property list contains the system
					  property(s)
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetSysPropFlag(bSysProp)
   Notes             :None
------------------------------------------------------------------------*/
void	CCommandSwitches::SetSysPropFlag(BOOL bSysProp)
{
	m_bSysProp = bSysProp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\errorinfo.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: ErrorInfo.cpp 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: The CErrorInfo class provides the functionality 
							  for providing error information given the error
							  object.  
Private						: None							  
Revision History			: 
	Last Modified by		: Ch. Sriramachandramurthy
	Last Modified date		: 16th-January-2001
****************************************************************************/ 
// ErrorInfo.cpp : implementation file

#include "Precomp.h"
#include "ErrorInfo.h"

/*------------------------------------------------------------------------
   Name				 :CErrorInfo
   Synopsis	         :This function initializes the member variables when
                      an object of the class type is instantiated
   Type	             :Constructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CErrorInfo::CErrorInfo()
{
	m_pIStatus		= NULL;
	m_bWMIErrSrc	= TRUE;
	m_pszErrStr		= NULL;
}

/*------------------------------------------------------------------------
   Name				 :~CErrorInfo
   Synopsis	         :This function uninitializes the member variables 
					  when an object of the class type goes out of scope.
   Type	             :Destructor
   Input parameter   :None
   Output parameters :None
   Return Type		 :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CErrorInfo::~CErrorInfo()
{
	Uninitialize();
}

/*------------------------------------------------------------------------
   Name				 :Uninitialize
   Synopsis	         :This function uninitializes the member variables. 
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :void 
   Global Variables  :None
   Calling Syntax    :Uninitialize()
   Notes             :None
------------------------------------------------------------------------*/
void CErrorInfo::Uninitialize()
{
	SAFEIRELEASE(m_pIStatus);
	SAFEDELETE(m_pszErrStr);
	m_bWMIErrSrc	= TRUE;
}

/*------------------------------------------------------------------------
   Name				 :GetErrorString
   Synopsis	         :This function takes the error code as input and returns
					  an error string
   Type				 :Member Function
   Input parameter   :
			hr		- hresult value
			bTrace	- trace flag
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetErrorString(hr)
   Notes             :None
------------------------------------------------------------------------*/
void CErrorInfo::GetErrorString(HRESULT hr, BOOL bTrace, _bstr_t& bstrErrDesc,
									_bstr_t& bstrFacility) 
{
	try
	{
		// Get the text description of the error code
		GetWbemErrorText(hr, FALSE, bstrErrDesc, bstrFacility);

		// If the error source subsystem is 'Wbem' and the 
		// TRACE is ON (get elaborated description from the
		// string table for the error code)
		if (m_bWMIErrSrc && bTrace)
		{
			m_pszErrStr = new _TCHAR[MAX_BUFFER];
			if (m_pszErrStr != NULL)
			{	
				switch (hr)
				{
					case WBEM_NO_ERROR:
						LoadString(NULL, IDS_I_WBEM_NO_ERROR, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_ACCESS_DENIED:
						LoadString(NULL, IDS_E_WBEM_E_ACCESS_DENIED, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_ALREADY_EXISTS:
						LoadString(NULL, IDS_E_WBEM_E_ALREADY_EXISTS, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_CANNOT_BE_KEY:
						LoadString(NULL, IDS_E_WBEM_E_CANNOT_BE_KEY, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_CANNOT_BE_SINGLETON:
						LoadString(NULL, IDS_E_WBEM_E_CANNOT_BE_SINGLETON, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_CLASS_HAS_CHILDREN:
						LoadString(NULL, IDS_E_WBEM_E_CLASS_HAS_CHILDREN, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_CLASS_HAS_INSTANCES:
						LoadString(NULL, IDS_E_WBEM_E_CLASS_HAS_INSTANCES, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_CRITICAL_ERROR:
						LoadString(NULL, IDS_E_WBEM_E_CRITICAL_ERROR, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_FAILED:
						LoadString(NULL, IDS_E_WBEM_E_FAILED, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_ILLEGAL_NULL:
						LoadString(NULL, IDS_E_WBEM_E_ILLEGAL_NULL, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_ILLEGAL_OPERATION:
						LoadString(NULL, IDS_E_WBEM_E_ILLEGAL_OPERATION, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INCOMPLETE_CLASS:
						LoadString(NULL, IDS_E_WBEM_E_INCOMPLETE_CLASS, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INITIALIZATION_FAILURE:
						LoadString(NULL, IDS_E_WBEM_E_INITIALIZATION_FAILURE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_CIM_TYPE:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_CIM_TYPE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_CLASS:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_CLASS, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_CONTEXT:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_CONTEXT, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_METHOD:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_METHOD, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_METHOD_PARAMETERS:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_METHOD_PARAMETERS, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_NAMESPACE:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_NAMESPACE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_OBJECT:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_OBJECT, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_OPERATION:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_OPERATION, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_PARAMETER:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_PARAMETER, 
									m_pszErrStr, MAX_BUFFER);
 						break;

					case WBEM_E_INVALID_PROPERTY_TYPE:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_PROPERTY_TYPE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_PROVIDER_REGISTRATION:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_PROVIDER_REGISTRATION, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_QUALIFIER_TYPE:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_QUALIFIER_TYPE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_QUERY:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_QUERY, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_QUERY_TYPE:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_QUERY_TYPE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_STREAM:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_STREAM, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_SUPERCLASS:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_SUPERCLASS, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_SYNTAX:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_SYNTAX, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_NONDECORATED_OBJECT:
						LoadString(NULL, IDS_E_WBEM_E_NONDECORATED_OBJECT, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_NOT_AVAILABLE:
						LoadString(NULL, IDS_E_WBEM_E_NOT_AVAILABLE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_NOT_FOUND:
						LoadString(NULL, IDS_E_WBEM_E_NOT_FOUND, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_NOT_SUPPORTED:
						LoadString(NULL, IDS_E_WBEM_E_NOT_SUPPORTED, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_OUT_OF_MEMORY:
						LoadString(NULL, IDS_E_WBEM_E_OUT_OF_MEMORY, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_OVERRIDE_NOT_ALLOWED:
						LoadString(NULL, IDS_E_WBEM_E_OVERRIDE_NOT_ALLOWED, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_PROPAGATED_PROPERTY:
						LoadString(NULL, IDS_E_WBEM_E_PROPAGATED_PROPERTY, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_PROPAGATED_QUALIFIER:
						LoadString(NULL, IDS_E_WBEM_E_PROPAGATED_QUALIFIER, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_PROVIDER_FAILURE:
						LoadString(NULL, IDS_E_WBEM_E_PROVIDER_FAILURE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_PROVIDER_LOAD_FAILURE:
						LoadString(NULL, IDS_E_WBEM_E_PROVIDER_LOAD_FAILURE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_PROVIDER_NOT_CAPABLE:
						LoadString(NULL, IDS_E_WBEM_E_PROVIDER_NOT_CAPABLE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_PROVIDER_NOT_FOUND:
						LoadString(NULL, IDS_E_WBEM_E_PROVIDER_NOT_FOUND, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_QUERY_NOT_IMPLEMENTED:
						LoadString(NULL, IDS_E_WBEM_E_QUERY_NOT_IMPLEMENTED, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_READ_ONLY:
						LoadString(NULL, IDS_E_WBEM_E_READ_ONLY, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_TRANSPORT_FAILURE:
						LoadString(NULL, IDS_E_WBEM_E_TRANSPORT_FAILURE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_TYPE_MISMATCH:
						LoadString(NULL, IDS_E_WBEM_E_TYPE_MISMATCH, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_UNEXPECTED:
						LoadString(NULL, IDS_E_WBEM_E_UNEXPECTED, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_VALUE_OUT_OF_RANGE:
						LoadString(NULL, IDS_E_WBEM_E_VALUE_OUT_OF_RANGE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_S_ALREADY_EXISTS:
						LoadString(NULL, IDS_S_WBEM_S_ALREADY_EXISTS, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_S_DIFFERENT:
						LoadString(NULL, IDS_S_WBEM_S_DIFFERENT, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_S_FALSE:
						LoadString(NULL, IDS_S_WBEM_S_FALSE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_S_NO_MORE_DATA:
						LoadString(NULL, IDS_S_WBEM_S_NO_MORE_DATA, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_S_PENDING:
						LoadString(NULL, IDS_S_WBEM_S_PENDING, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_S_RESET_TO_DEFAULT:
						LoadString(NULL, IDS_S_WBEM_S_RESET_TO_DEFAULT, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_S_TIMEDOUT:
						LoadString(NULL, IDS_S_WBEM_S_TIMEDOUT, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEMESS_E_REGISTRATION_TOO_BROAD:
						LoadString(NULL, IDS_E_WBEMESS_E_REGISTRATION_TOO_BROAD, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEMESS_E_REGISTRATION_TOO_PRECISE:
						LoadString(NULL, IDS_E_WBEMESS_E_REGISTRATION_TOO_PRECISE, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_S_OPERATION_CANCELLED:
						LoadString(NULL, IDS_S_WBEM_S_OPERATION_CANCELLED, 
									m_pszErrStr, MAX_BUFFER);
						break;
					
				   case WBEM_S_DUPLICATE_OBJECTS:
						LoadString(NULL, IDS_S_WBEM_S_DUPLICATE_OBJECTS, 
									m_pszErrStr, MAX_BUFFER);
						break;
					
				   case WBEM_S_ACCESS_DENIED:
						LoadString(NULL, IDS_S_WBEM_S_ACCESS_DENIED, 
									m_pszErrStr, MAX_BUFFER);
						break;
				
				   case WBEM_S_PARTIAL_RESULTS:
						LoadString(NULL, IDS_S_WBEM_S_PARTIAL_RESULTS, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_SYSTEM_PROPERTY:
						LoadString(NULL, IDS_E_WBEM_E_SYSTEM_PROPERTY, 
									m_pszErrStr, MAX_BUFFER);
						break;
				
				   case WBEM_E_INVALID_PROPERTY:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_PROPERTY, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_CALL_CANCELLED:
						LoadString(NULL, IDS_E_WBEM_E_CALL_CANCELLED, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_SHUTTING_DOWN:
						LoadString(NULL, IDS_E_WBEM_E_SHUTTING_DOWN, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_PROPAGATED_METHOD:
						LoadString(NULL, IDS_E_WBEM_E_PROPAGATED_METHOD, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_UNSUPPORTED_PARAMETER:
						LoadString(NULL, IDS_E_WBEM_E_UNSUPPORTED_PARAMETER, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_MISSING_PARAMETER_ID:
						LoadString(NULL, IDS_E_WBEM_E_MISSING_PARAMETER_ID, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_INVALID_PARAMETER_ID:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_PARAMETER_ID, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_NONCONSECUTIVE_PARAMETER_IDS:
						LoadString(NULL, IDS_E_WBEM_E_NONCONSECUTIVE_PARAMETER_IDS, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_PARAMETER_ID_ON_RETVAL:
						LoadString(NULL, IDS_E_WBEM_E_PARAMETER_ID_ON_RETVAL, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_INVALID_OBJECT_PATH:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_OBJECT_PATH, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_OUT_OF_DISK_SPACE:
						LoadString(NULL, IDS_E_WBEM_E_OUT_OF_DISK_SPACE, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_BUFFER_TOO_SMALL:
						LoadString(NULL, IDS_E_WBEM_E_BUFFER_TOO_SMALL, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_UNSUPPORTED_PUT_EXTENSION:
						LoadString(NULL, IDS_E_WBEM_E_UNSUPPORTED_PUT_EXTENSION, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_UNKNOWN_OBJECT_TYPE:
						LoadString(NULL, IDS_E_WBEM_E_UNKNOWN_OBJECT_TYPE, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_UNKNOWN_PACKET_TYPE:
						LoadString(NULL, IDS_E_WBEM_E_UNKNOWN_PACKET_TYPE, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_MARSHAL_VERSION_MISMATCH:
						LoadString(NULL, IDS_E_WBEM_E_MARSHAL_VERSION_MISMATCH, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_MARSHAL_INVALID_SIGNATURE:
						LoadString(NULL, IDS_E_WBEM_E_MARSHAL_INVALID_SIGNATURE, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_INVALID_QUALIFIER:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_QUALIFIER, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_INVALID_DUPLICATE_PARAMETER:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_DUPLICATE_PARAMETER, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_TOO_MUCH_DATA:
						LoadString(NULL, IDS_E_WBEM_E_TOO_MUCH_DATA, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_SERVER_TOO_BUSY:
						LoadString(NULL, IDS_E_WBEM_E_SERVER_TOO_BUSY, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_INVALID_FLAVOR:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_FLAVOR, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_CIRCULAR_REFERENCE:
						LoadString(NULL, IDS_E_WBEM_E_CIRCULAR_REFERENCE, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_UNSUPPORTED_CLASS_UPDATE:
						LoadString(NULL, IDS_E_WBEM_E_UNSUPPORTED_CLASS_UPDATE, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_CANNOT_CHANGE_KEY_INHERITANCE:
						LoadString(NULL, IDS_E_WBEM_E_CANNOT_CHANGE_KEY_INHERITANCE, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_CANNOT_CHANGE_INDEX_INHERITANCE:
						LoadString(NULL, IDS_E_WBEM_E_CANNOT_CHANGE_INDEX_INHERITANCE, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_TOO_MANY_PROPERTIES:
						LoadString(NULL, IDS_E_WBEM_E_TOO_MANY_PROPERTIES, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_UPDATE_TYPE_MISMATCH:
						LoadString(NULL, IDS_E_WBEM_E_UPDATE_TYPE_MISMATCH, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_UPDATE_OVERRIDE_NOT_ALLOWED:
						LoadString(NULL, IDS_E_WBEM_E_UPDATE_OVERRIDE_NOT_ALLOWED, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_UPDATE_PROPAGATED_METHOD:
						LoadString(NULL, IDS_E_WBEM_E_UPDATE_PROPAGATED_METHOD, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_METHOD_NOT_IMPLEMENTED:
						LoadString(NULL, IDS_E_WBEM_E_METHOD_NOT_IMPLEMENTED, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_METHOD_DISABLED:
						LoadString(NULL, IDS_E_WBEM_E_METHOD_DISABLED, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_REFRESHER_BUSY:
						LoadString(NULL, IDS_E_WBEM_E_REFRESHER_BUSY, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_UNPARSABLE_QUERY:
						LoadString(NULL, IDS_E_WBEM_E_UNPARSABLE_QUERY, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_NOT_EVENT_CLASS:
						LoadString(NULL, IDS_E_WBEM_E_NOT_EVENT_CLASS, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_MISSING_GROUP_WITHIN:
						LoadString(NULL, WBEM_E_MISSING_GROUP_WITHIN, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_MISSING_AGGREGATION_LIST:
						LoadString(NULL, IDS_E_WBEM_E_MISSING_AGGREGATION_LIST, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_PROPERTY_NOT_AN_OBJECT:
						LoadString(NULL, IDS_E_WBEM_E_PROPERTY_NOT_AN_OBJECT, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_AGGREGATING_BY_OBJECT:
						LoadString(NULL, IDS_E_WBEM_E_AGGREGATING_BY_OBJECT, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_UNINTERPRETABLE_PROVIDER_QUERY:
						LoadString(NULL, IDS_E_WBEM_E_UNINTERPRETABLE_PROVIDER_QUERY, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_BACKUP_RESTORE_WINMGMT_RUNNING:
						LoadString(NULL, IDS_E_WBEM_E_BACKUP_RESTORE_WINMGMT_RUNNING, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_QUEUE_OVERFLOW:
						LoadString(NULL, IDS_E_WBEM_E_QUEUE_OVERFLOW, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_PRIVILEGE_NOT_HELD:
						LoadString(NULL, IDS_E_WBEM_E_PRIVILEGE_NOT_HELD, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_INVALID_OPERATOR:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_OPERATOR, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_LOCAL_CREDENTIALS:
						LoadString(NULL, IDS_E_WBEM_E_LOCAL_CREDENTIALS, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_CANNOT_BE_ABSTRACT:
						LoadString(NULL, IDS_E_WBEM_E_CANNOT_BE_ABSTRACT, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_AMENDED_OBJECT:
						LoadString(NULL, IDS_E_WBEM_E_AMENDED_OBJECT, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_CLIENT_TOO_SLOW:
						LoadString(NULL, IDS_E_WBEM_E_CLIENT_TOO_SLOW, 
									m_pszErrStr, MAX_BUFFER);
						break;
				   default:
   						LoadString(NULL, IDS_E_UNKNOWN_WBEM_ERROR, 
									m_pszErrStr, MAX_BUFFER);
						break;
				}
			}
			else
				throw OUT_OF_MEMORY;
			bstrErrDesc = m_pszErrStr;
			SAFEDELETE(m_pszErrStr);
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :GetWbemErrorText
   Synopsis	         :This function takes the error code as input and returns
					  an error string
   Type				 :Member Function
   Input parameter   :
			hr		- (error code) hresult value
			bXML	- Flag to indicate whether error is required in XML form
   Output parameters :
		bstrError	- String to containg error info in XML form
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :GetErrorString(hr)
   Notes             :None
------------------------------------------------------------------------*/
void CErrorInfo::GetWbemErrorText(HRESULT hr, BOOL bXML, _bstr_t& bstrError,
								  _bstr_t& bstrFacilityCode)
{
	try
	{
		CHString sTemp;
		if (bXML)
		{
			sTemp.Format(L"<HRESULT>0x%x</HRESULT>", hr);
		}
		bstrError += _bstr_t(sTemp);


		if (m_pIStatus == NULL)
		{
			if (SUCCEEDED(CreateStatusCodeObject()))
			{
				BSTR bstrErr = NULL, bstrFacility = NULL;

				// Get the text string description associated with 
				// the error code.
				if(SUCCEEDED(m_pIStatus->GetErrorCodeText(hr, 0, 0, &bstrErr)))
				{
					if (bXML)
					{
						bstrError += L"<DESCRIPTION>";
						bstrError += bstrErr;
						bstrError += L"</DESCRIPTION>";
					}
					else
					{
						bstrError = bstrErr;
					}

					// Get the subsystem where the error occured
					if(SUCCEEDED(m_pIStatus->GetFacilityCodeText(hr, 0, 0, 
									&bstrFacility)))
					{
						if (bstrFacility)
						{
							if (bXML)
							{
								bstrError += L"<FACILITYCODE>";
								bstrError += bstrFacility;
								bstrError += L"</FACILITYCODE>";
							}
							else
							{
								bstrFacilityCode = bstrFacility;
							}

							// If the subsystem is not Winmgmt ('Wbem') 
							// i.e. anyone of the "Windows" | "SSIP" | "RPC" set 
							// the m_bWMIErrSrc to FALSE
							if ((CompareTokens(_T("Wbem"), (_TCHAR*) bstrFacility)) ||
								(CompareTokens(_T("WMI"), (_TCHAR*) bstrFacility)))
							{
								m_bWMIErrSrc = TRUE;
							}
							else
								m_bWMIErrSrc = FALSE;
						}
					}
					SAFEBSTRFREE(bstrErr);
					SAFEBSTRFREE(bstrFacility);
				}
				else
				{
					if (bXML)
					{
						bstrError += 
						L"<DESCRIPTION>\"Unknown WBEM Error\"</DESCRIPTION>";
						bstrError += L"<FACILITYCODE/>";
					}
					m_bWMIErrSrc = FALSE;
				}
				SAFEIRELEASE(m_pIStatus);
			}
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}

/*------------------------------------------------------------------------
   Name				 :CreateStatusCodeObject()
   Synopsis	         :This function creates the single uninitialized 
					  object of the class associated with the CLSID
					  CLSID_WbemStatusCodeText
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :CreateStatusCodeObject()
   Notes             :None
-------------------------------------------------------------------*/
HRESULT CErrorInfo::CreateStatusCodeObject()
{
	// Create the single uninitialized object of the 
	// class associated with the CLSID CLSID_WbemStatusCodeText
	return CoCreateInstance(CLSID_WbemStatusCodeText, 
					0, CLSCTX_INPROC_SERVER,
					IID_IWbemStatusCodeText, 
					(LPVOID*) &m_pIStatus);
}


/*-------------------------------------------------------------------------
   Name				 :GetErrorFragment
   Synopsis	         :Frames the XML string for error info
   Type	             :Member Function
   Input parameters  :
		hr			- HResult Parameter
   Output parameters :
		bstrError	- String to containg error info in XML form
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :GetErrorFragment()
-------------------------------------------------------------------------*/
void CErrorInfo::GetErrorFragment(HRESULT hr, _bstr_t& bstrError)
{
	try
	{
		_bstr_t bstrFacility;
		bstrError = L"<ERROR>";
		GetWbemErrorText(hr, TRUE, bstrError, bstrFacility);
		bstrError += L"</ERROR>";
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\cmdtokenizer.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: CmdTokenizer.h 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This file consist of class declaration of
							  class CmdTokenizer
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 23th-February-2001
****************************************************************************/ 
/*-------------------------------------------------------------------
 Class Name			: CCmdTokenizer
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the functionality needed
					  for tokenizing the command line string passed as
					  input to the wmic.exe
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: None
 Interfaces Used    : None
 --------------------------------------------------------------------*/
/////////////////////////////////////////////////////////////////////////////
// CCmdTokenizer
class CCmdTokenizer
{
public:
// Construction
	CCmdTokenizer();

// Destruction
	~CCmdTokenizer();

// Restrict Assignment
   CCmdTokenizer& operator=(CCmdTokenizer& rCmdTknzr); 

// Attributes
private:
	// command string
	_TCHAR*			m_pszCommandLine;
	
	// token-offset counter
	WMICLIINT		m_nTokenOffSet;
	
	// token-start counter
	WMICLIINT		m_nTokenStart;
	
	// token vector	
	CHARVECTOR		m_cvTokens;

	// Escape sequence flag
	BOOL			m_bEscapeSeq;

	// Format switch
	BOOL			m_bFormatToken;

// Operations
private:
	//Extracts token and adds it to the token vector.
	_TCHAR*			Token(); 

	//Identify the Next token to be extracted by adjusting
	//m_nTokenStart and m_nTokenOffset
	_TCHAR*			NextToken();

public:
	// returns the reference to token vector.
	CHARVECTOR&		GetTokenVector();

	// tokenize the command using the pre-defined 
	// delimiters
	BOOL			TokenizeCommand(_TCHAR* pszCommandInput);

	// Free the member variables
	void			Uninitialize();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\commandswitches.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: CommandSwitches.h 
Project Name				: WMI Command Line
Author Name					: Ch.Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This file consist of class declaration of
							  class CommandSwitches
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 20th-March-2001
****************************************************************************/ 

// CommandSwitches.h : header file
//
/*-------------------------------------------------------------------
 Class Name			: CCommandSwitches
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the functionality needed
					  for accessing and storing the command switches 
					  information, which will be used by Parsing, 
					  Execution and Format Engines depending upon the 
					  applicability.
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: None
 Interfaces Used    : None
 --------------------------------------------------------------------*/
#pragma once

/////////////////////////////////////////////////////////////////////////////
// CCommandSwitches
class CCommandSwitches
{
public:
// Construction
	CCommandSwitches();

// Destruction
	~CCommandSwitches();

// Restrict Assignment
   CCommandSwitches& operator=(CCommandSwitches& rCmdSwitches);

// Attributes
private:
	//command string
	_TCHAR				*m_pszCommandInput;

	//alias name
	_TCHAR				*m_pszAliasName;

	//alias description
	_TCHAR				*m_pszAliasDesc;

    //class path
	_TCHAR				*m_pszClassPath;

    //path expression
	_TCHAR				*m_pszPathExpr;

    //where expression
	_TCHAR				*m_pszWhereExpr;

    //verb name - standard|userdefined verb 
	_TCHAR				*m_pszVerb;

    //method name
	_TCHAR				*m_pszMethodName;

    //XSLT details vector.
	XSLTDETVECTOR		m_xdvXSLTDetVec;

    //alias target class
	_TCHAR				*m_pszAliasTarget;

    //XML stream 
	BSTR				m_bstrXML;

    //session success - flag.
	BOOL				m_bSuccess;

    //HRESULT 
	HRESULT				m_hResult;

    //friendly names|trasnlate tables - map
	BSTRMAP				m_bmAlsFrnNmsDesOrTrnsTblEntrs;

    //property(s) details - map
	PROPDETMAP			m_pdmPropDet;

    //method(s) details - map
	METHDETMAP			m_mdmMethDet;

    //input property(s) - vector
	CHARVECTOR			m_cvProperties;

	//PWhere param(s) - vector
	CHARVECTOR			m_cvPWhereParams;

	//Translate table entry(s) - vector
	CHARVECTOR			m_cvTrnsTablesList;

    //input method param(s) - map
	BSTRMAP				m_bmParameters;

    //verb interactive mode
	WMICLIINT			m_nInteractiveMode;

    ///EVERY interval value
	ULONG				m_ulInterval;

    ///tablename - TRANSLATE:<tablename> 
	_TCHAR				*m_pszTransTableName;

    //listformat - LISTFORMAT type
	_TCHAR				*m_pszListFormat;

	// Errata code
	UINT				m_uErrataCode;

	// Message code
	UINT				m_uInformationCode;
	
	// Credentials flag
	BOOL				m_bCredFlag;

	// parameterized string with '#' as place holder(s) for input value(s)  
	_TCHAR				*m_pszPWhereExpr;

	// COM error object
	_com_error			*m_pComError;

	// IWbemClassObject, to store output parameters of method execution.
	IWbemClassObject	*m_pIMethOutParam;

	// alias connection information
	// alias user name
	_TCHAR				*m_pszUser;

	// alias user password
	_TCHAR				*m_pszPassword;

	// alias node
	_TCHAR				*m_pszNode;

	// alias locale
	_TCHAR				*m_pszLocale;

	// alias namespace
	_TCHAR				*m_pszNamespace;

	// Type of the verb ( CLASSMETHOD/STDVERB/CMDLINE ).
	VERBTYPE			m_vtVerbType;

	// Verb derivation string
	_TCHAR				*m_pszVerbDerivation;

	// flag to check that WHERE is specified explicitly
	BOOL				m_bExplicitWhereExpr;

	ALSFMTDETMAP		m_afdAlsFmtDet;

	BOOL				m_bTranslateFirst;

	// /RESULTCLASS switch value of ASSOC verb
	_TCHAR				*m_pszResultClassName;
     
	// /RESULTROLE  switch value of ASSOC verb
	_TCHAR				*m_pszResultRoleName;

	// /ASSOCCLASS switch value of ASSOC verb
	_TCHAR				*m_pszAssocClassName;

	// count for /REPEAT:N
	ULONG				m_ulRepeatCount;

	// Flag for availibility of methods.
	BOOL				m_bMethAvail;

	// Flag for availibility of writable properties.
	BOOL				m_bWritePropsAvail;

	// Flag for availibility list formats.
	BOOL				m_bLISTFrmsAvail;

    //input property(s) - vector
	CHARVECTOR			m_cvInteractiveProperties;

	// Flag to specify Named Parameter List.
	BOOL				m_bNamedParamList;

	// Flag to check if every switch is specified.
	BOOL                m_bEverySwitch ;     

	// Flag to check if output switch is specified.
	BOOL                m_bOutputSwitch ;   
	
	//the query formed of the given command .
	BSTR				m_bstrFormedQuery;

	BOOL				m_bSysProp;

	// Operations
public:

	//Assigns the parameter passed to m_pszCommandInput
	BOOL	SetCommandInput(const _TCHAR* pszCommandInput);

    //Assigns the parameter passed to m_pszAliasName that represents 
    //Alias object.
	BOOL	SetAliasName(const _TCHAR* pszAliasName);

	// Sets the alias description
	BOOL	SetAliasDesc(const _TCHAR* pszAliasDesc);

	// Sets the alias credentials information
	BOOL	SetAliasUser(const _TCHAR* pszUserName);
	BOOL	SetAliasNode(const _TCHAR* pszNode);
	BOOL	SetAliasPassword(const _TCHAR* pszPassword);
	BOOL	SetAliasLocale(const _TCHAR* pszLocale);
	BOOL	SetAliasNamespace(const _TCHAR* pszNamespace);

    //Assigns the parameter passed to m_pszClassPath.
	BOOL	SetClassPath(const _TCHAR* pszClassPath);

    //Assigns the parameter passed to m_pszPathExpr.
	BOOL	SetPathExpression(const _TCHAR* pszPathExpr);

    //Assigns the parameter passed to m_pszWhereExpr
	BOOL	SetWhereExpression(const _TCHAR* pszWhereExpr);

    //Assigns the parameter passed to m_pszMathodName.
	BOOL	SetMethodName(const _TCHAR* pszMethodName);

    //Adds to vector held by m_xdvXSLDetVec.
	void	AddToXSLTDetailsVector(XSLTDET xdXSLTDet);

    //Assigns the parameter passed to m_pszVerbName.
	BOOL	SetVerbName(const _TCHAR* pszVerbName);

    //Assigns the parameter passed to m_pszSesionFilePath
	BOOL	SetSessionFilePath(const _TCHAR* pszSessionFilePath);

    //Assigns the parameter passed to m_bstrXML, is used to store XML file 
	//Name that contains result set.
	BOOL	SetXMLResultSet(const BSTR bstrXMLResultSet);

    //Assigns the parameter passed to m_pszAliasTarget, is used in Parsing
	//Engine to avail the alias object informations.
	BOOL	SetAliasTarget(const _TCHAR* pszAliasTarget);

    //Adds string that passed through parameter to m_bmParameters, which is 
    //a data member of type BSTRMAP
	BOOL	AddToPropertyList(_TCHAR* const pszProperty);

	BOOL	AddToTrnsTablesList(_TCHAR* const pszTableName);

    //Adds bstrKey and bstrValue passed as parameters to m_bmParameters,which 
    //is type of BSTRMAP data structure
	BOOL	AddToParameterMap(_bstr_t bstrKey, _bstr_t bstrValue);

    //Adds bstrKey and bstrValue passed as parameters to m_bmParameters,which 
    //is type of ALSFMTDETMAP data structure
	BOOL	AddToAliasFormatDetMap(_bstr_t bstrKey, BSTRVECTOR bvProps);

    //Adds bstrKey and bstrValue passed as parameters to 
	//m_bmAlsFrnNmsDesOrTrnsTblEntrs,
    //which is type of BSTRMAP
	BOOL	AddToAlsFrnNmsOrTrnsTblMap(_bstr_t bstrKey, _bstr_t bstrValue);

    //Adds bstrKey and mdMethDet passed as parameters to m_mdmMethDet,
	//which is type of METHDETMAP.
	BOOL	AddToMethDetMap(_bstr_t bstrKey, METHODDETAILS mdMethDet);

    //Adds bstrKey and pdPropDet passed as parameters to m_pdmPropDet,
	//which is type of PROPERTYDETALS
	BOOL	AddToPropDetMap(_bstr_t bstrKey, PROPERTYDETAILS pdPropDet);

    //Assigns the Boolean variable to m_bSuccess
	void	SetSuccessFlag(BOOL bSuccess);
	
    //Assigns the string variable to m_pszTransTableName.
	BOOL	SetTranslateTableName(const _TCHAR* pszTransTableName);

    //Assigns the integer value to m_nInterval 
  	BOOL	SetRetrievalInterval(const ULONG lInterval);

    //Assigns the parameter value to m_ListFormat
	BOOL	SetListFormat(const _TCHAR *pszListFormat);

    //Set|Reset the verb interactive mode
	void	SetInteractiveMode(WMICLIINT nInteractiveMode);

    //Stores the parameter in map array
	BOOL	AddToPWhereParamsList(_TCHAR* const pszParameter);

    //Assigns the value to m_uErrataCode
	void	SetErrataCode(const UINT uErrataCode);

	//Assigns the value to m_uInformationCode
	void	SetInformationCode(const UINT uInformationCode);

	// Assigns the string to m_pszPWhereExpr
	BOOL	SetPWhereExpr(const _TCHAR* pszPWhereExpr);

	// Assigns the parameter passed to m_pComError that consist of 
	// error info
	void	SetCOMError(_com_error& rComError);

	// Set m_pIMethExecOutParam.
	BOOL	SetMethExecOutParam(IWbemClassObject* pIMethOutParam);

	// Set m_vtVerbType to passed flag.
	void	SetVerbType( VERBTYPE vtVerbType);

	// Set m_pszVerbDerivation.
	BOOL	SetVerbDerivation( const _TCHAR* pszVerbDerivation );

	//Set the credential flag status
	void	SetCredentialsFlag(BOOL bCredFlag);

	// Set the explicit where flag
	void	SetExplicitWhereExprFlag(BOOL bWhere);

	//Assigns the string variable to m_pszResultClassName.
	BOOL	SetResultClassName(const _TCHAR* pszResultClassName);

	//Assigns the string variable to m_pszResultRoleName.
	BOOL	SetResultRoleName(const _TCHAR* pszResultRoleName);
     
	//Assigns the string variable to m_pszAssocClassName.
	BOOL	SetAssocClassName(const _TCHAR* pszAssocClassName);

	// Set repeat count.
	BOOL	SetRepeatCount(const ULONG lRepCount);

	// Set methods available.
	void	SetMethodsAvailable(BOOL bFlag);

	// Retruns the alias description
	_TCHAR*	GetAliasDesc();

    //Returns the alias name held by the object	
	_TCHAR*	GetAliasName();

    //Returns the class path held by the object
	_TCHAR*	GetClassPath();

	// Return the alias credentials information.
	_TCHAR*	GetAliasUser();
	_TCHAR*	GetAliasNode();
	_TCHAR*	GetAliasPassword();
	_TCHAR*	GetAliasLocale();
	_TCHAR* GetAliasNamespace();

    //Returns the path expression held by the object
	_TCHAR*	GetPathExpression();

    //Returns the where expression held by the object
	_TCHAR*	GetWhereExpression();

    //Returns the method name held by the object
	_TCHAR*	GetMethodName();

    //Returns the XSLTDetVec held by the object.
	XSLTDETVECTOR&	GetXSLTDetailsVector();

    //Returns the verb name held by the object
	_TCHAR*	GetVerbName();

    //Returns the session file path held by the object
 	_TCHAR*	GetSessionFilePath();

    //Returns the alias target held by the object
	_TCHAR*	GetAliasTarget();

    //Returns the command input held by the object
	_TCHAR*	GetCommandInput();

    //Returns the XML result set held by the object.
	BSTR	GetXMLResultSet();

    //Returns the property held by the object.
	CHARVECTOR& GetPropertyList();

    //Returns the tables held by the object.
	CHARVECTOR& GetTrnsTablesList();

    //Returns the parameter map containing both key and value
	BSTRMAP&    GetParameterMap();

	//Returns the alias formats map
	ALSFMTDETMAP&	GetAliasFormatDetMap();

    //Returns the alias friendly names map held by the object
	BSTRMAP&	GetAlsFrnNmsOrTrnsTblMap();

    //Returns the method details map held by the object
	METHDETMAP&	GetMethDetMap();

    //Returns the alias property details map held by the object
	PROPDETMAP&	GetPropDetMap();

    //Returns the success flag held by the object
	BOOL	GetSuccessFlag();

    //Returns the value of m_ulInterval.
	ULONG	GetRetrievalInterval();

    //Returns the value of m_pszTransTableName.
 	_TCHAR*	GetTranslateTableName();

   //Returns the list format type m_ListFormat
	_TCHAR*	GetListFormat();

    //Returns the name of XSL file used for specifying format for dumping.
	_TCHAR*	GetDumpXSLFormat();

    //returns the verb interactive mode
	WMICLIINT	GetInteractiveMode();

    //Returns the PWhereParameters list
	CHARVECTOR& GetPWhereParamsList();

    //This function gets the class of Alias
	void	GetClassOfAliasTarget(_bstr_t& bstrClassName);

    //returns the error code
	UINT	GetErrataCode();

	//returns the information code
	UINT	GetInformationCode();

	// returns the PWhere expression - m_pszPWhereExpr
	_TCHAR*    GetPWhereExpr();

	// Get m_pIMethExecOutParam.
	IWbemClassObject* GetMethExecOutParam();

	// Get m_vtVerbType.
	VERBTYPE	GetVerbType();

	// Get m_pszVerbDerivation.
	_TCHAR*	GetVerbDerivation();

	// Returns the credential flag status
	BOOL	GetCredentialsFlagStatus();

	// Returns the explicit where flag status		
	BOOL	GetExplicitWhereExprFlag();

	// Get m_uRepeatCount count.
	ULONG	GetRepeatCount();

	// This function returns the COMError object
	_com_error* CCommandSwitches::GetCOMError();

	// Update the parameter value
	BOOL	UpdateParameterValue(_bstr_t bstrKey, _bstr_t bstrValue);

	// Free the COM error
	void	FreeCOMError();

	// Clear cvPropertyList.
	void	ClearPropertyList();

	// Initiliaze the necessary member variables
	void	Initialize();

    // Free the member variables
	void	Uninitialize();

	// This function sets the the order of the format and 
	// translate switch flag
	void SetTranslateFirstFlag(BOOL bTranslateFirst);

	// This function returns the order of the format and 
	// translate switch flag
	BOOL GetTranslateFirstFlag();

	//Returns the value of m_pszResultClassName.
	_TCHAR*	GetResultClassName();

	//Returns the value of  m_pszResultRoleName.
	_TCHAR*	GetResultRoleName();
     
	//Returns the value of  m_pszAssocClassName.
	_TCHAR*	GetAssocClassName();

	// Get methods available.
	BOOL	GetMethodsAvailable();

	// Set writable properties available flag.
	void	SetWriteablePropsAvailable(BOOL bFlag);

	// Get writable properties available flag.
	BOOL	GetWriteablePropsAvailable();

	// Set LIST Formats available flag.
	void	SetLISTFormatsAvailable(BOOL bFlag);

	// Get LIST Formats Available flag.
	BOOL	GetLISTFormatsAvailable();

	BOOL AddToInteractivePropertyList(_TCHAR* const pszProperty);

	CHARVECTOR& GetInteractivePropertyList();

	// Set m_bNamedParamList flag.
	void	SetNamedParamListFlag(BOOL bFlag);

	// Get m_bNamedParamList flag.
	BOOL	GetNamedParamListFlag();

	// Clear or nullify XSL Details vector.
	void	ClearXSLTDetailsVector();

	//every 
	// Set m_bEverySwitch flag.
	void	SetEverySwitchFlag(BOOL bFlag);

	// Get m_bEverySwitch  flag.
	BOOL	GetEverySwitchFlag();

	// Set m_bOutputSwitch flag.
	void	SetOutputSwitchFlag(BOOL bFlag);

	// Get m_bOutputSwitch  flag.
	BOOL	GetOutputSwitchFlag();

 	//Sets the m_bstrFormedQuery
	BOOL	SetFormedQuery(const BSTR bstrFormedQuery);
	
	//Returns the query formed for the given command.
	BSTR	GetFormedQuery();

	// Get the status of sytem properties flag
	BOOL	GetSysPropFlag();

	// Sets the status of system properties flag
	void	SetSysPropFlag(BOOL bSysProp);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\errorinfo.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: ErrorInfo.h 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Revision History			: 
	Last Modified by		: Ch. Sriramachandramurthy
	Last Modified date		: 17th-January-2001
****************************************************************************/ 

/*-------------------------------------------------------------------
 Class Name			: CErrorInfo
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the error message support 
					  functionality needed by the Format Engine for
					  dislaying the WBEM error descriptions.
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: None
 Interfaces Used    : None
 --------------------------------------------------------------------*/
/////////////////////////////////////////////////////////////////////////////
// CErrorInfo
class CErrorInfo
{
public:
// Construction
	CErrorInfo();

// Destruction
	~CErrorInfo();

// Restrict Assignment
	CErrorInfo& operator=(CErrorInfo& rErrInfo);

private:
// Attributes
	IWbemStatusCodeText		*m_pIStatus;
	BOOL					m_bWMIErrSrc;
	_TCHAR					*m_pszErrStr;
		
// Operations
private:
	HRESULT					CreateStatusCodeObject();
	void					GetWbemErrorText(HRESULT hr, BOOL bXML, 
								_bstr_t& bstrErr, _bstr_t& bstrFacility);
	
public:
	void					Uninitialize();

	// Return the description & facility code string(s) corresponding to 
	// hr passed.
	void					GetErrorString(HRESULT hr, BOOL bTrace, 
									_bstr_t& bstrErrDesc,
									_bstr_t& bstrFacility); 

	// Frames the XML string for error info
	void					GetErrorFragment(HRESULT hr, _bstr_t& bstrError);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\errorlog.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: ErrorLog.cpp 
Project Name				: WMI Command Line
Author Name					: C. V. Nandi
Date of Creation (dd/mm/yy) : 11th-January-2001
Version Number				: 1.0 
Brief Description			: This file has all the global function definitions 
Revision History			:
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date  : 12th-January-2001
*****************************************************************************/ 
// ErrorLog.cpp : implementation file
#include "Precomp.h"
#include "ErrorLog.h"

/*------------------------------------------------------------------------
   Name				 :CErrorLog
   Synopsis	         :This function initializes the member variables when
                      an object of the class type is instantiated
   Type	             :Constructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CErrorLog::CErrorLog()
{
	m_eloErrLogOpt		= NO_LOGGING;
	m_bstrLogDir		= _bstr_t("");
	m_bGetErrLogInfo	= TRUE;
	m_bCreateLogFile	= TRUE;
	m_hLogFile			= NULL;
}

/*------------------------------------------------------------------------
   Name				 :~CErrorLog
   Synopsis	         :This function uninitializes the member variables 
					  when an object of the class type goes out of scope.
   Type	             :Destructor
   Input parameter   :None
   Output parameters :None
   Return Type		 :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CErrorLog::~CErrorLog()
{
	if ( m_hLogFile )
		CloseHandle(m_hLogFile);
}

/*------------------------------------------------------------------------
   Name				 :GetErrLogInfo
   Synopsis	         :This function reads the following information from 
					  the registry:
					  1. LoggingMode and 
					  2. LogDirectory
   Type				 :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :GetErrLogInfo()
   Notes             :None
------------------------------------------------------------------------*/
void CErrorLog::GetErrLogInfo()
{
	HKEY hkKeyHandle = NULL;

	try
	{
		// Open the registry key
		if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
						   _T("SOFTWARE\\Microsoft\\Wbem\\CIMOM"), 0, 
						   KEY_QUERY_VALUE, &hkKeyHandle ) == ERROR_SUCCESS )
		{
			DWORD dwBufSize				= BUFFER512;
			TCHAR szKeyValue[BUFFER512] = NULL_STRING;
			_tcscpy(szKeyValue,CLI_TOKEN_NULL);

			// Query the "Logging" mode
			if ( RegQueryValueEx(hkKeyHandle, 
								 _T("Logging"), NULL, NULL,
								 (LPBYTE)szKeyValue, &dwBufSize) == ERROR_SUCCESS )
			{
				if ( !_tcsicmp(szKeyValue, CLI_TOKEN_ONE) )
					m_eloErrLogOpt = ERRORS_ONLY;
				else if ( !_tcsicmp(szKeyValue, CLI_TOKEN_TWO) )
					m_eloErrLogOpt = EVERY_OPERATION;
				else
					m_eloErrLogOpt = NO_LOGGING;
			}

			_TCHAR *pszKeyValue = NULL;

			// Query for the content length of the "Logging Directory"
			if ( RegQueryValueEx(hkKeyHandle, _T("Logging Directory"), NULL, 
						NULL, NULL, &dwBufSize) == ERROR_SUCCESS)
			{
				pszKeyValue = new _TCHAR [dwBufSize];
				if (pszKeyValue != NULL)
				{
					// Query the "Logging Directory"
					if ( RegQueryValueEx(hkKeyHandle, _T("Logging Directory"), 
									NULL, NULL, (LPBYTE)pszKeyValue, &dwBufSize) 
									== ERROR_SUCCESS)
					{
						m_bstrLogDir = _bstr_t(pszKeyValue);
					}
					SAFEDELETE(pszKeyValue);
				}
			}

			// Query the "Log File Max Size"
			if ( RegQueryValueEx(hkKeyHandle, 
								 _T("Log File Max Size"), NULL, NULL,
								 (LPBYTE)szKeyValue, &dwBufSize) == ERROR_SUCCESS )
			{
				m_llLogFileMaxSize = _ttol(szKeyValue);
			}
			
			// Close the registry key
			RegCloseKey(hkKeyHandle);
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :GetErrLogOption
   Synopsis	         :This function returns the logging mode
   Type				 :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :
			ERRLOGOPT - typdefined variable
   Global Variables  :None
   Calling Syntax    :GetErrLogOption()
   Notes             :None
------------------------------------------------------------------------*/
ERRLOGOPT CErrorLog::GetErrLogOption()
{
	if ( m_bGetErrLogInfo == TRUE )
	{
		GetErrLogInfo();
		m_bGetErrLogInfo = FALSE;
	}
	return m_eloErrLogOpt;
}

/*------------------------------------------------------------------------
   Name				 :CreateLogFile
   Synopsis	         :This function creates the WMIC.LOG file
   Type				 :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :GetErrLogOption()
   Notes             :None
------------------------------------------------------------------------*/
void CErrorLog::CreateLogFile() 
{
	DWORD	dwError = 0;
	try
	{
		if ( m_bGetErrLogInfo == TRUE )
		{
			GetErrLogInfo();
			m_bGetErrLogInfo = FALSE;
		}

		// Frame the file path.
		_bstr_t bstrFilePath = m_bstrLogDir;
		bstrFilePath += _bstr_t("WMIC.LOG");

		m_hLogFile = CreateFile(bstrFilePath, 
								GENERIC_READ |GENERIC_WRITE,
								FILE_SHARE_READ | FILE_SHARE_WRITE, 
								NULL, 
								OPEN_ALWAYS, 
								FILE_ATTRIBUTE_NORMAL, 
								NULL);

		// If handle is invalid.
		if (m_hLogFile == INVALID_HANDLE_VALUE)
		{
			dwError = ::GetLastError();
			::SetLastError(dwError);
			DisplayString(IDS_E_ERRLOG_OPENFAIL, CP_OEMCP, 
							NULL, TRUE, TRUE);
			::SetLastError(dwError);
			DisplayWin32Error();
			throw(dwError);
		}

		if ( SetFilePointer(m_hLogFile, 0, NULL, FILE_END) 
							== INVALID_SET_FILE_POINTER &&
					dwError != NO_ERROR )
		{
			dwError = ::GetLastError();
			::SetLastError(dwError);
			DisplayWin32Error();
			::SetLastError(dwError);
			throw(dwError);
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :LogErrorOrOperation
   Synopsis	         :This function logs the error or operation result 
   Type				 :Member Function
   Input parameter   :
		hrErrNo			- HRESULT code
		pszFileName		- file name
		lLineNo			- line number
		pszFunName		- function name
		dwThreadId		- thread id
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :GetErrLogOption()
   Notes             :None
------------------------------------------------------------------------*/
void CErrorLog::LogErrorOrOperation(HRESULT hrErrNo, char* pszFileName, 
							LONG lLineNo, _TCHAR* pszFunName, 
							DWORD dwThreadId, DWORD dwError) 
{
	try
	{
		if ( (m_eloErrLogOpt == ERRORS_ONLY && FAILED(hrErrNo)) ||
			  m_eloErrLogOpt == EVERY_OPERATION )
		{
			if ( m_bCreateLogFile == TRUE )
			{
				CreateLogFile();
				m_bCreateLogFile = FALSE;
			}
			
			SYSTEMTIME stSysTime;
			GetLocalTime(&stSysTime);

			CHAR szDate[BUFFER32];
			sprintf(szDate, "%.2d/%.2d/%.4d", stSysTime.wMonth,
										stSysTime.wDay,
										stSysTime.wYear);

			CHAR szTime[BUFFER32];
			sprintf(szTime, "%.2d:%.2d:%.2d:%.3d", stSysTime.wHour,
										   stSysTime.wMinute,
										   stSysTime.wSecond,
										   stSysTime.wMilliseconds);

			CHString chsErrMsg;
			BOOL bWriteToFile = FALSE;
			if ( FAILED(hrErrNo) )
			{
				if (dwError)
				{
					chsErrMsg.Format( 
						  L"ERROR %s - FAILED! error# %d %s %s thread:%d [%s.%d]\r\n", 
								CHString(pszFunName),dwError,CHString(szDate),
								CHString(szTime), dwThreadId, 
								CHString(pszFileName), lLineNo);
				}
				else
				{
					chsErrMsg.Format( 
						  L"ERROR %s - FAILED! error# %x %s %s thread:%d [%s.%d]\r\n", 
							CHString(pszFunName), hrErrNo, CHString(szDate),
							CHString(szTime), dwThreadId, CHString(pszFileName),
							lLineNo);
				}
				bWriteToFile = TRUE;
			}
			else if (_tcsnicmp(pszFunName,_T("COMMAND:"),8) == 0)
			{
				chsErrMsg.Format( 
						  L"SUCCESS %s - Succeeded %s %s thread:%d [%s.%d]\r\n", 
								CHString(pszFunName), CHString(szDate), 
								CHString(szTime), dwThreadId,
								CHString(pszFileName),lLineNo);
				bWriteToFile = TRUE;
			}

			_bstr_t bstrErrMsg = _bstr_t((LPCWSTR)chsErrMsg);
			CHAR *szErrMsg = (CHAR*)bstrErrMsg;
			if ( bWriteToFile == TRUE && szErrMsg != NULL)
			{
				DWORD	dwNumberOfBytes = 0;
				
				LARGE_INTEGER liFileSize;
				if ( GetFileSizeEx(m_hLogFile, &liFileSize) == TRUE &&
					 (liFileSize.QuadPart + strlen(szErrMsg)) > 
														  m_llLogFileMaxSize )
				{
					// Frame the file path.
					_bstr_t bstrLogFilePath		= m_bstrLogDir;
					_bstr_t bstrCatalogFilePath = m_bstrLogDir;

					bstrLogFilePath		+= _bstr_t("WMIC.LOG");
					bstrCatalogFilePath += _bstr_t("WMIC.LO_");

					if(!CopyFile((LPTSTR)bstrLogFilePath, 
								(LPTSTR)bstrCatalogFilePath,      
								FALSE))
					{
						DWORD dwError = ::GetLastError();
						DisplayString(IDS_E_ERRLOG_WRITEFAIL, CP_OEMCP, 
								NULL, TRUE, TRUE);
						::SetLastError(dwError);
						DisplayWin32Error();
						::SetLastError(dwError);
						throw(dwError);
					}

					// close wmic.log
					if ( m_hLogFile )
					{
						CloseHandle(m_hLogFile);
						m_hLogFile = 0;
					}

					m_hLogFile = CreateFile(bstrLogFilePath, 
											GENERIC_READ |GENERIC_WRITE,
											FILE_SHARE_READ | FILE_SHARE_WRITE, 
											NULL, 
											CREATE_ALWAYS, 
											FILE_ATTRIBUTE_NORMAL, 
											NULL);

					// If handle is invalid.
					if (m_hLogFile == INVALID_HANDLE_VALUE)
					{
						dwError = ::GetLastError();
						::SetLastError(dwError);
						DisplayString(IDS_E_ERRLOG_OPENFAIL, CP_OEMCP, 
										NULL, TRUE, TRUE);
						::SetLastError(dwError);
						DisplayWin32Error();
						throw(dwError);
					}
				}

				if (!WriteFile(m_hLogFile, szErrMsg, strlen(szErrMsg), 
								&dwNumberOfBytes, NULL))
				{
					DWORD dwError = ::GetLastError();
					DisplayString(IDS_E_ERRLOG_WRITEFAIL, CP_OEMCP, 
							NULL, TRUE, TRUE);
					::SetLastError(dwError);
					DisplayWin32Error();
					::SetLastError(dwError);
					throw(dwError);
				}
			}
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	catch(DWORD dwError)
	{
		throw (dwError);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\execengine.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: ExecEngine.h
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This file consist of member variable and
							  functions declarations of the Execution engine
							  module.
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 20th-March-2001
****************************************************************************/ 

/*-------------------------------------------------------------------
 Class Name			: CExecEngine
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the functionality needed
					  for executing the WMI statements that are obtained
					  as a result of parsing engine. It also performs 
					  verb specific processing using the information 
					  available with CParsedInfo class.
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: CParsedInfo
 Interfaces Used    : WMI COM Interfaces
 --------------------------------------------------------------------*/

class CParsedInfo;

class CExecEngine
{
public:
// Construction
	CExecEngine();

// Destruction
	~CExecEngine();

// Restrict Assignment
	CExecEngine& operator=(CExecEngine& rExecEngine);

// Attributes
private:
	// trace flag
	BOOL				m_bTrace;

	ERRLOGOPT			m_eloErrLogOpt;
	// Pointer to object of type IWbemObjectTextSrc encapsulates the 
	// functionality of WMI XML Encoder
	IWbemObjectTextSrc	*m_pITextSrc;
	
	// Pointer to object of type IWbemLocator, used to obtain IWbemServices 
	// object.
	IWbemLocator		*m_pIWbemLocator;
	
	// Pointer to object of type IWbemServices, Used to perform WMI operations
	// on target namespace.
	IWbemServices		*m_pITargetNS;

	// Context pointer
	IWbemContext		*m_pIContext;

	BOOL				m_bSysProp;

	BOOL				m_bNoAssoc;
// Operations
private:
	// Creates the instance of IWbemObjectTextSrc interface.
	HRESULT				CreateWMIXMLTextSrc(CParsedInfo& rParsedInfo);

	// Creates the instance of IWbemContext interface
	HRESULT				CreateContext(CParsedInfo& rPrasedInfo);

	// Connect to the WMI namespace on the target machine.
	HRESULT				ConnectToTargetNS(CParsedInfo& rParsedInfo);

	// Executes query to give results in XML file format. 
	// Refers data in the CCommnadSwicthes object of CParsedInfo object.
	HRESULT				ObtainXMLResultSet(BSTR bstrQuery,
										   CParsedInfo& rParsedInfo,
										   _bstr_t& bstrXML,
										   BOOL bSysProp = TRUE,
										   BOOL bNotAssoc = TRUE);

	HRESULT				FrameAssocHeader(_bstr_t bstrPath, _bstr_t& bstrFrag,
										BOOL bClass);

	// This function changes the property value for the 
    // given property name and value
	BOOL				SetPropertyInfo(CParsedInfo& rParsedInfo, 
										_bstr_t& bstrQuery, 
										_bstr_t& bstrObject);
	
	// Executes a WMI method specified in the CCommandSwicthes 
	// object of the CParsedInfo object passed to it.
	BOOL				ExecWMIMethod(CParsedInfo&);
	
	// Processes and executes GET|LIST verb referring CParsedInfo object
	// or to display help in interactive mode by displaying properties of 
	// concernrd instance.
	BOOL				ProcessSHOWInfo(CParsedInfo& rParsedInfo, BOOL bVerb=TRUE, 
															_TCHAR* pszPath=NULL);
	
	// Processes and executes CALL verb referring CParsedInfo object.
	BOOL				ProcessCALLVerb(CParsedInfo& rParsedInfo);
	
	// Processes and executes SET verb referring CParsedInfo object.
	BOOL				ProcessSETVerb(CParsedInfo& rParsedInfo);
	
	// Processes and executes CREATE verb referring CParsedInfo object.
	BOOL				ProcessCREATEVerb(CParsedInfo& rParsedInfo);

	// Processes and executes DELETE verb referring CParsedInfo object.
	BOOL				ProcessDELETEVerb(CParsedInfo& rParsedInfo);

	// Processes and executes ASSOC verb referring CParsedInfo object.
	BOOL				ProcessASSOCVerb(CParsedInfo& rParsedInfo);
	
	// This function constructs the path expression from alias info and
	// where info. Used for CALL verb only
	BOOL				FormPathExprFromWhereExpr(_bstr_t& bstrPath, 
												  CParsedInfo& rParsedInfo);

	// This function changes the property values for the given property names 
	// and values in a passed IWbemClassObject
	BOOL				SetProperties(CParsedInfo& rParsedInfo, 
				 					  IWbemClassObject* pIWbemObj, 
									  BOOL bClass);

	// Deletes the objects
	BOOL				DeleteObjects(CParsedInfo& rParsedInfo, 
									  _bstr_t& bstrQuery, 
									  _bstr_t& bstrObject);

	// Obtain user response
	INTEROPTION			GetUserResponse(_TCHAR* pszMsg);

	// Create a new instance
	BOOL				CreateInstance(CParsedInfo& rParsedInfo, 
									   BSTR bstrClass);

	// Validate the new input values supplied for the properties
	// against the qualifiers details.
	BOOL				ValidateInParams(CParsedInfo& rParsedInfo,
										 _bstr_t bstrClass);


	BOOL				ValidateAlaisInParams(CParsedInfo& rParsedInfo);

	BOOL				CheckAliasQualifierInfo(CParsedInfo& rParsedInfo,
												_bstr_t bstrParam,
												WCHAR*& pszValue,
												PROPDETMAP pdmPropDetMap);
									
	// Checks the parameter/property value against the following 
	// qualifiers:
	// 1. MaxLen, 2. Values 3. ValuesMap
	BOOL				CheckQualifierInfo(CParsedInfo& rParsedInfo,
										   IWbemClassObject* pIObject,
										   _bstr_t bstrParam,
										   WCHAR*& pszValue);

	// Method Execution 
	HRESULT				ExecuteMethodAndDisplayResults(_bstr_t bstrPath,
												 CParsedInfo& rParsedinfo,
												 IWbemClassObject* pIInParam);

	// Display the output parameters of method execution.
	void				DisplayMethExecOutput(CParsedInfo& rParsedInfo);

	// Invoke other command line Utilities
	BOOL				ExecOtherCmdLineUtlty(CParsedInfo& rParsedInfo);

	// Checks and returns TRUE if verb invocation mode is interactive
	BOOL				IsInteractive(CParsedInfo& rParsedInfo);	

	// Substitute hashes and execute command line utility.
	// If pIWbemObj != NULL then utility should be passed with appropriate 
	// instance values.
	void				SubstHashAndExecCmdUtility(CParsedInfo& rParsedInfo,
									IWbemClassObject *pIWbemObj = NULL);

	// Forms query and executes method or command line utility.
	HRESULT				FormQueryAndExecuteMethodOrUtility(
										CParsedInfo& rParsedInfo,
										IWbemClassObject *pIInParam = NULL);

	// This function takes the input as a path expression and 
	// extracts the Class and Where expression part from the 
	// path expression.
	BOOL				ExtractClassNameandWhereExpr(_TCHAR* pszPathExpr, 
										CParsedInfo& rParsedInfo,
										_TCHAR* pszWhere);

	// This function accepts the user response before going
	// ahead, when /INTERACTIVE is specified at the verb level
	INTEROPTION			GetUserResponseEx(_TCHAR* pszMsg);

	// Obtain param values from parameter map in the same order as they
	// appear in the alias verb definition.
	void				ObtainInParamsFromParameterMap(CParsedInfo& rParsedinfo, 
										CHARVECTOR& cvParamValues);

public:
	// This function uninitializes the member variables. 
	void				Uninitialize(BOOL bFlag = FALSE);
	
	// Executes the command referring to CCommandSwitches and CGlobalSwitches
	// of the CParsedInfo object of CParsedInfo object Passed to it as 
	// parameters. Puts the results back in to objects passed to it for the 
	// use of Format Engine.
	BOOL				ExecuteCommand(CParsedInfo& rParsedInfo);
	
	// Sets the locator object passed via parameter to member 
	// of the class.
	BOOL				SetLocatorObject(IWbemLocator* pILocator);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\errorlog.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: ErrorLog.h 
Project Name				: WMI Command Line
Author Name					: C. V. Nandi 
Date of Creation (dd/mm/yy) : 11th-January-2001
Version Number				: 1.0 
Revision History			: 
	Last Modified by		: Ch. Sriramachandramurthy
	Last Modified date		: 12th-January-2001
****************************************************************************/ 

/*-------------------------------------------------------------------
 Class Name			: CErrorLog
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the error logging support 
					  functionality needed by the wmic.exe for logging 
					  the errors, commands issues depending on Logging
					  key value available with the registry.
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: None
 Interfaces Used    : None
 --------------------------------------------------------------------*/
/////////////////////////////////////////////////////////////////////////////
// CErrorInfo

class CErrorLog
{
public:
//	Construction
	CErrorLog();

//	Destruction
	~CErrorLog();

//	Restrict Assignment
	CErrorLog& operator=(CErrorLog& rErrLog);

// Attributes
private:
	// typedef variable.
	ERRLOGOPT	m_eloErrLogOpt;

	_bstr_t		m_bstrLogDir;
	
	BOOL		m_bGetErrLogInfo;
	
	BOOL		m_bCreateLogFile;
	
	HANDLE		m_hLogFile;

	LONGLONG	m_llLogFileMaxSize;

// Operations
private:
	void		GetErrLogInfo();
	
	void		CreateLogFile();
public:
	ERRLOGOPT	GetErrLogOption();

	// Log the error, 
	void		LogErrorOrOperation(HRESULT hrErrNo, 
									char*	pszFileName, 
									LONG	lLineNo,	
									_TCHAR* pszFunName, 
									DWORD	dwThreadId,
									DWORD	dwError = 0); 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\formatengine.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: FormatEngine.cpp 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: The Format Engine is primarily responsible for 
							  displaying the 
							  a) the data views for the management areas by 
							  using predefined XSL style sheets
							  b) the property update/method execution status 
							  c) error messages and 
							  d) display of usage information. It depends     
							  on the output of Parsing and/or Format Engine.
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 11th-April-2001
******************************************************************************/ 

// FormatEngine.cpp : implementation file
//
#include "Precomp.h"
#include "CommandSwitches.h"
#include "GlobalSwitches.h"
#include "HelpInfo.h"
#include "ErrorLog.h"
#include "ParsedInfo.h"
#include "ErrorInfo.h"
#include  "WMICliXMLLog.h"
#include "FormatEngine.h"
#include "CmdTokenizer.h"
#include "CmdAlias.h"
#include "ParserEngine.h"
#include "ExecEngine.h"
#include "WmiCmdLn.h"

/*------------------------------------------------------------------------
   Name				 :CFormatEngine
   Synopsis	         :This function initializes the member variables when
                      an object of the class type is instantiated.
   Type	             :Constructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CFormatEngine::CFormatEngine()
{
	m_pIXMLDoc				= NULL;
	m_pIXSLDoc				= NULL;
	m_bRecord				= FALSE;
	m_bTrace				= FALSE;
	m_bHelp					= FALSE;
	m_bGetOutOpt			= TRUE;
	m_bGetAppendFilePinter	= TRUE;
	m_bGetOutputFilePinter	= TRUE;
	m_bLog					= TRUE;
	m_bInteractiveHelp		= FALSE;
}

/*------------------------------------------------------------------------
   Name				 :~CFormatEngine
   Synopsis	         :Destructor 
   Type	             :Destructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CFormatEngine::~CFormatEngine()
{
	Uninitialize(TRUE);
}

/*------------------------------------------------------------------------
   Name				 :CreateEmptyDocument
   Synopsis	         :Creates an empty XML Document and returns the same 
					  in Passed Parameter.
   Type	             :Member Function 
   Input parameter   :
   Output parameters :None
				pDoc - Pointer to pointer to IXMLDOMDocument2 Interface
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :CreateEmptyDocument(&pIXMLDoc)
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CFormatEngine::CreateEmptyDocument(IXMLDOMDocument2** pIDoc)
{
   	// Create an empty XML document
    return CoCreateInstance(CLSID_DOMDocument, NULL, 
								CLSCTX_INPROC_SERVER,
                                IID_IXMLDOMDocument2, (LPVOID*)pIDoc);
}

/*------------------------------------------------------------------------
   Name				 :Uninitialize
   Synopsis	         :Carries out the releasing process.
   Type	             :Member Function 
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :Uninitialize()
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::Uninitialize(BOOL bFinal)
{
	// Release the interface pointers
	SAFEIRELEASE(m_pIXMLDoc);
	SAFEIRELEASE(m_pIXSLDoc);

	m_bTrace				= FALSE;
	m_eloErrLogOpt			= NO_LOGGING;
	m_bHelp					= FALSE;
	m_bGetOutOpt			= TRUE;
	m_bGetAppendFilePinter	= TRUE;
	m_bGetOutputFilePinter	= TRUE;
	m_bLog					= TRUE;
	m_bstrOutput			= L"";
	m_bInteractiveHelp		= FALSE;
	
	// Uninitialize the ErrInfo object
	m_ErrInfo.Uninitialize();
	
	// Erase the help vector
	if ( !m_cvHelp.empty() )
	{
		if (m_cvHelp.size())
		{
			LPSTRVECTOR::iterator theIterator = m_cvHelp.begin();
			while (theIterator != m_cvHelp.end())
			{
				SAFEDELETE(*theIterator);
				theIterator++;
			}
		}
		m_cvHelp.erase(m_cvHelp.begin(), m_cvHelp.end());
	}
	m_WmiCliLog.Uninitialize(bFinal);
}

/*------------------------------------------------------------------------
   Name				 :ApplyXSLFormatting
   Synopsis	         :Applies a XSL style sheet containing format of the 
					  display to a XML stream containing result set.
   Type	             :Member Function 
   Input parameter   :
    	rParsedInfo  - reference to CParsedInfo class object
   Output parameters :
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :BOOL 
   Global Variables  :None
   Calling Syntax    :ApplyXSLFormatting(rParsedInfo);
   Notes             :None
------------------------------------------------------------------------*/
BOOL CFormatEngine::ApplyXSLFormatting(CParsedInfo& rParsedInfo)
{
	BOOL	bRet				= TRUE;
	DWORD	dwThreadId			= GetCurrentThreadId();
	
	if ( g_wmiCmd.GetBreakEvent() == TRUE )
	{
		bRet = TRUE;
	}
	// If the XML stream is empty (or) XSL file path is empty
	// set the return value as FALSE.
	else if (!rParsedInfo.GetCmdSwitchesObject().GetXMLResultSet() || 
			 rParsedInfo.GetCmdSwitchesObject().GetXSLTDetailsVector().empty())
	{
		bRet = FALSE;
	}
	else
	{
		HRESULT			hr					= S_OK;
		//BSTR			bstrOutput			= NULL;
		_bstr_t			bstrOutput;
		CHString		chsMsg;
		VARIANT_BOOL	varBool				= VARIANT_FALSE;
		VARIANT			varXSL;
		VariantInit(&varXSL);
		try
		{
			// Create an empty XML Document 
			hr = CreateEmptyDocument(&m_pIXMLDoc);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"CoCreateInstance(CLSID_DOMDocument, NULL,"
						 L" CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument2, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
						dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			BOOL bFlag = FALSE;
			BOOL bTranslateTable = FALSE;

			// If Translate table name is given and before format switch
			// translate switch is given then set the flag
			if( rParsedInfo.GetCmdSwitchesObject().
						GetTranslateTableName() != NULL && 
							rParsedInfo.GetCmdSwitchesObject().
									GetTranslateFirstFlag() == TRUE) 
			{
				bTranslateTable = TRUE;
			}

			// If Translate table name is given then translate 
			// the XML node list
			if ( bTranslateTable == TRUE )
			{
				bFlag = TraverseNode(rParsedInfo);
			}
			else
			{
				// Load XML content
				hr = m_pIXMLDoc->loadXML(rParsedInfo.GetCmdSwitchesObject().
											GetXMLResultSet(), &varBool);
				if (m_bTrace || m_eloErrLogOpt)
				{
					WMITRACEORERRORLOG(hr, __LINE__, 
							__FILE__, _T("IXMLDOMDocument::loadXML(-, -)"), 
							dwThreadId, rParsedInfo, m_bTrace);
				}
				ONFAILTHROWERROR(hr);
			}

			// If loading the XML document is successful or if translate table 
			// name is given and translation is successful
			if( (bTranslateTable == TRUE && bFlag == TRUE) || 
				(bTranslateTable == FALSE && varBool == VARIANT_TRUE) )
			{
				bRet = DoCascadeTransforms(rParsedInfo, bstrOutput);

				if (bRet)
				{
					STRING strOutput((_TCHAR*)bstrOutput);

					// If /TRANSLATE:<table> is specified and after format 
					// switch translate switch is given then translate the
					// result
					if ( bTranslateTable == FALSE)
					{
						// Translate the result 
						ApplyTranslateTable(strOutput, rParsedInfo);
					}

					bRet = TRUE;
					if (m_bRecord && m_bLog && !m_bInteractiveHelp)
					{
						hr = m_WmiCliLog.WriteToXMLLog(rParsedInfo,
									_bstr_t(strOutput.data()));
						if (FAILED(hr))
						{
							m_WmiCliLog.StopLogging();
							m_bRecord = FALSE;
							hr = S_OK;
							DisplayString(IDS_E_WRITELOG_FAILED, FALSE, 
										NULL, TRUE);
						}
						m_bLog = FALSE;
					}

					// Display the result
					DisplayLargeString(rParsedInfo, strOutput);
					bRet = TRUE;
				}
			}
			else
			{
				// Invalid XML content.
				rParsedInfo.GetCmdSwitchesObject()
							.SetErrataCode(IDS_E_INVALID_XML_CONTENT);
				bRet = FALSE;
			}
		}
		catch(_com_error& e)
		{
			// Set the COM error.
			rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
			bRet = FALSE;
		}
		catch(CHeap_Exception)
		{
			hr = WBEM_E_OUT_OF_MEMORY;
			_com_issue_error(hr);
		}
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :DisplayResults
   Synopsis	         :Displays the result referring CcommandSwitches and 
					  CGlobalSwitches Objects of the CParsedInfo object.
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo		 - reference to CParsedInfo class object
		bInteractiveHelp 
				TRUE	-  indicates intermediate help display in 
						   interactive mode
				FALSE	-  indicates results display in normal mode
   Output parameters :
		rParsedInfo - reference to CParsedInfo class object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :DisplayResults(rParsedInfo, bInteractiveHelp)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CFormatEngine::DisplayResults(CParsedInfo& rParsedInfo,
									BOOL bInteractiveHelp)
{
	BOOL	bRet					= TRUE;
	DWORD	dwThreadId				= GetCurrentThreadId();
	_TCHAR* pszVerbName				= NULL;
	BOOL	bLog					= TRUE;
	HRESULT	hr						= S_OK;
	
	m_bInteractiveHelp = bInteractiveHelp;
	// Frame the command part of the log entry:
	// "command: <<command input>>" 
	
	try
	{
		CHString	chsCmdMsg(_T("command: "));
		chsCmdMsg += rParsedInfo.GetCmdSwitchesObject().GetCommandInput();
		// Get the TRACE status and store it in m_bTrace
		m_bTrace		= rParsedInfo.GetGlblSwitchesObject().GetTraceStatus();

		// Get the Logging mode (VERBOSE | ERRORONLY | NOLOGGING) and store
		// it in m_eloErrLogOpt
		m_eloErrLogOpt	= rParsedInfo.GetErrorLogObject().GetErrLogOption();

		// Get the output option to redirect the output.
		m_opsOutputOpt	= rParsedInfo.GetGlblSwitchesObject().
												GetOutputOrAppendOption(TRUE);
		m_bGetOutOpt = FALSE;

		// FALSE for getting append file pointer.
		m_fpAppendFile = rParsedInfo.GetGlblSwitchesObject().
										  GetOutputOrAppendFilePointer(FALSE);
		m_bGetAppendFilePinter = FALSE;

		// TRUE for getting out file pointer.
		m_fpOutFile = rParsedInfo.GetGlblSwitchesObject().
										  GetOutputOrAppendFilePointer(TRUE);
		m_bGetOutputFilePinter = FALSE;

		// If /RECORD global switch has been specified, create the log file
		// and write the input command.
		if (rParsedInfo.GetGlblSwitchesObject().GetRPChangeStatus())
		{
			// Stop logging
			m_WmiCliLog.StopLogging();
			
			if (rParsedInfo.GetGlblSwitchesObject().GetRecordPath() != NULL)
			{
				if (!rParsedInfo.GetCmdSwitchesObject().GetEverySwitchFlag())
				{
					// Set the log file path
					m_WmiCliLog.SetLogFilePath(rParsedInfo.
								GetGlblSwitchesObject().GetRecordPath());

					// Set the m_bRecord flag to TRUE
					m_bRecord	= TRUE;

					// Set the recordpath change flag to FALSE
					rParsedInfo.GetGlblSwitchesObject().
										SetRPChangeStatus(FALSE);
				}
			}
			else
			{
				// Set the m_bRecord flag to FALSE
				m_bRecord	= FALSE;
			}
			m_bLog = FALSE;
		}

		//If the COM error is not NULL , then display the error
		if (rParsedInfo.GetCmdSwitchesObject().GetCOMError() != NULL)
		{
			DisplayCOMError(rParsedInfo);
		}
		// Check the success flag , display error in case error flag is set.
		else if (!rParsedInfo.GetCmdSwitchesObject().GetSuccessFlag())
		{
			_bstr_t bstrErrMsg;
			if (IDS_E_ALIAS_NOT_FOUND == rParsedInfo.GetCmdSwitchesObject()
										.GetErrataCode())
			{
				WMIFormatMessage(IDS_E_ALIAS_NOT_FOUND, 1, bstrErrMsg, 
							 rParsedInfo.GetCmdSwitchesObject().
															GetAliasName());
				DisplayString((LPTSTR) bstrErrMsg,  TRUE, TRUE);
			}
			else if (IDS_E_INVALID_CLASS == rParsedInfo.GetCmdSwitchesObject()
										.GetErrataCode())
			{
				WMIFormatMessage(IDS_E_INVALID_CLASS, 1, bstrErrMsg, 
							 rParsedInfo.GetCmdSwitchesObject().
														   GetClassPath());
				DisplayString((LPTSTR) bstrErrMsg,  TRUE, TRUE);
			}
			else
				DisplayString(rParsedInfo.GetCmdSwitchesObject().
							GetErrataCode(), TRUE, NULL, TRUE);

			if ( m_eloErrLogOpt )
			{
				
				chsCmdMsg += _T(", Utility returned error ID.");
				// explicit error -1 to specify errata code. 
				WMITRACEORERRORLOG(-1, __LINE__, __FILE__, (LPCWSTR)chsCmdMsg, 
							dwThreadId, rParsedInfo, FALSE, 
							rParsedInfo.GetCmdSwitchesObject().GetErrataCode());
			}
		}
		//if the help has been specified , FrameHelpVector is called .
		else if (rParsedInfo.GetGlblSwitchesObject().GetHelpFlag())
		{
			m_bHelp = TRUE;

			// Form help vector
			FrameHelpVector(rParsedInfo);

			// Display paged help
			DisplayPagedHelp(rParsedInfo);

			if ( m_eloErrLogOpt )
				WMITRACEORERRORLOG(S_OK, __LINE__, __FILE__, (LPCWSTR)chsCmdMsg, 
						dwThreadId,	rParsedInfo, FALSE);
		}
		else
		{
			// Get the verb name
			pszVerbName = rParsedInfo.GetCmdSwitchesObject().
											GetVerbName();
			// Check the information code 
			if (rParsedInfo.GetCmdSwitchesObject().GetInformationCode())
			{
				DisplayString(rParsedInfo.GetCmdSwitchesObject().
							GetInformationCode());

				if ( m_eloErrLogOpt )
				{
					WMITRACEORERRORLOG(S_OK, __LINE__, __FILE__, (LPCWSTR)chsCmdMsg, 
							dwThreadId, rParsedInfo, FALSE);
				}
			}
			else if ( CompareTokens(pszVerbName, CLI_TOKEN_LIST) || 
				CompareTokens(pszVerbName, CLI_TOKEN_ASSOC) || 
				CompareTokens(pszVerbName, CLI_TOKEN_GET) || 
				m_bInteractiveHelp)
			{
				//If XSL file is not specified - pick the default XSL.
				if(rParsedInfo.GetCmdSwitchesObject().GetXSLTDetailsVector().
																	  empty())
				{
					if(IsClassOperation(rParsedInfo))
					{
						rParsedInfo.GetCmdSwitchesObject().
										ClearXSLTDetailsVector();
					   
						//default format is MOF if CLASS 
						XSLTDET xdXSLTDet;
						g_wmiCmd.GetFileFromKey(CLI_TOKEN_MOF, 
												xdXSLTDet.FileName);
						bRet = FrameFileAndAddToXSLTDetVector(xdXSLTDet, 
															  rParsedInfo);
					}
					else
					{
						rParsedInfo.GetCmdSwitchesObject().
										ClearXSLTDetailsVector();
					   
						// Default format is TABLE if an alias or path
						// with where expression or with keyclause
						XSLTDET xdXSLTDet;
						g_wmiCmd.GetFileFromKey(CLI_TOKEN_TABLE, 
												xdXSLTDet.FileName);
						bRet = FrameFileAndAddToXSLTDetVector(xdXSLTDet, 
															  rParsedInfo);
					}

					if (bInteractiveHelp && !CompareTokens(pszVerbName, 
									CLI_TOKEN_ASSOC))
					{
						rParsedInfo.GetCmdSwitchesObject().
										ClearXSLTDetailsVector();
						XSLTDET xdXSLTDet;
						g_wmiCmd.GetFileFromKey(CLI_TOKEN_TEXTVALUE, 
												xdXSLTDet.FileName);
						bRet = FrameFileAndAddToXSLTDetVector(xdXSLTDet, 
															  rParsedInfo);
					}
				}

				// If result set is not empty
				if (!(!rParsedInfo.GetCmdSwitchesObject().GetXMLResultSet()))
				{
					// Apply the XSL formatting.
					bRet = ApplyXSLFormatting(rParsedInfo);

					// If XSL formatting fails
					if (!bRet)
					{
						//If the COM error is not NULL , then display the error
						if (rParsedInfo.GetCmdSwitchesObject().
										GetCOMError() != NULL)
						{
							DisplayCOMError(rParsedInfo);
						}
						else
						{
							DisplayString(rParsedInfo.
									GetCmdSwitchesObject().GetErrataCode(),
									TRUE, NULL, TRUE);
							if ( m_eloErrLogOpt )
							{
								
							   chsCmdMsg += _T(", Utility returned error ID.");
							   // explicit error -1 to specify errata code. 
							   WMITRACEORERRORLOG(-1, __LINE__, __FILE__,
											(LPCWSTR)chsCmdMsg, 
											dwThreadId, rParsedInfo, FALSE, 
											rParsedInfo.GetCmdSwitchesObject().
												GetErrataCode());
							}
						}
					}

					if ( m_eloErrLogOpt )
					{
						HRESULT hrTemp;
						if ( g_wmiCmd.GetSessionErrorLevel() != 0)
							hrTemp = -1;
						else
							hrTemp = S_OK;
						
						WMITRACEORERRORLOG(hrTemp, __LINE__, __FILE__, 
							(LPCWSTR)chsCmdMsg, 
							dwThreadId, rParsedInfo, FALSE);
					}
				}
				else
				{
					if (CompareTokens(pszVerbName, CLI_TOKEN_ASSOC))
					{
						if (m_bRecord && m_bLog)
						{
							hr = m_WmiCliLog.WriteToXMLLog(rParsedInfo, 
									m_bstrOutput);
							if (FAILED(hr))
							{
								m_WmiCliLog.StopLogging();
								m_bRecord = FALSE;
								hr = S_OK;
								DisplayString(IDS_E_WRITELOG_FAILED, 
												FALSE, NULL, TRUE);
							}
							m_bLog = FALSE;
						}
					}
				}
			}
			//SET, DELETE, CREATE verbs - on successfully invoked
			else
			{
				if (m_bRecord && m_bLog)
				{
					hr = m_WmiCliLog.WriteToXMLLog(rParsedInfo, m_bstrOutput);
					if (FAILED(hr))
					{
						m_WmiCliLog.StopLogging();
						m_bRecord = FALSE;
						hr = S_OK;
						DisplayString(IDS_E_WRITELOG_FAILED, 
											FALSE, NULL, TRUE);
					}
					m_bLog = FALSE;
				}
			}
		}
	}
	// To handle COM exception 
	catch (_com_error& e)
	{
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bRet = FALSE;
	}
	// To handle user-defined exceptions
	catch(WMICLIINT nVal)
	{
		// If memory allocation failed.
		if (nVal == OUT_OF_MEMORY)
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(OUT_OF_MEMORY);
		}
		bRet = FALSE;
	}
	//trap for CHeap_Exception
	catch(CHeap_Exception)
	{
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	catch(DWORD dwError)
	{
		// If Win32 function call failed.
		::SetLastError(dwError);
		rParsedInfo.GetCmdSwitchesObject().SetErrataCode(dwError);
		DisplayWin32Error();
		::SetLastError(dwError);
		bRet = FALSE;
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :DisplayGETUsage
   Synopsis	         :Displays GET usage.
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayGETUsage(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayGETUsage(CParsedInfo& rParsedInfo)
{
	BOOL bClass = FALSE;
	if(IsClassOperation(rParsedInfo))
	{
		bClass = TRUE;
	}

	if(!bClass)
	{
		DisplayInvalidProperties(rParsedInfo);
		if (rParsedInfo.GetHelpInfoObject().GetHelp(GETSwitchesOnly) == FALSE)
		{
			if ( rParsedInfo.GetCmdSwitchesObject().
					GetPropertyList().size() == 0 )
			{
				// Display the usage of the GET verb
				DisplayString(IDS_I_NEWLINE);
				DisplayString(IDS_I_GET_DESC);
				DisplayString(IDS_I_USAGE);
				DisplayString(IDS_I_NEWLINE);
				DisplayString(IDS_I_GET_USAGE);
				DisplayString(IDS_I_PROPERTYLIST_NOTE1);
			}
			
			// Display the properties
			DisplayPropertyDetails(rParsedInfo);
		}
	}
	else
	{
		// Display the usage of the CLASS <class name> GET verb
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_CLASS_GET_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_CLASS_GET_USAGE);
	}
	
	// Enumerate the available GET switches
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_GET_SWITCH_HEAD);
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_GET_SWITCH_VALUE);
	DisplayString(IDS_I_GET_SWITCH_ALL);
	DisplayString(IDS_I_SWITCH_TRANSLATE);
	DisplayString(IDS_I_SWITCH_EVERY);
	DisplayString(IDS_I_SWITCH_FORMAT);
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_TRANSFORMAT_NOTE1);
	DisplayString(IDS_I_TRANSFORMAT_NOTE2);
	DisplayString(IDS_I_TRANSFORMAT_NOTE3);
}

/*------------------------------------------------------------------------
   Name				 :DisplayLISTUsage
   Synopsis	         :Displays LIST usage.
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayLISTUsage(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayLISTUsage(CParsedInfo& rParsedInfo)
{
	try
	{
		if (rParsedInfo.GetHelpInfoObject().GetHelp(LISTSwitchesOnly) == FALSE)
		{
			// Display the usage of the LIST verb
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_LIST_DESC);
			DisplayString(IDS_I_USAGE);
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_LIST_USAGE);
		
			ALSFMTDETMAP afdAlsFmtDet = rParsedInfo.
										GetCmdSwitchesObject().
										GetAliasFormatDetMap();
			ALSFMTDETMAP::iterator theIterator; 
			if ( afdAlsFmtDet.empty() )
			{
				// If no list formats are available/defined for the 
				// alias specified.
				DisplayString(IDS_I_NEWLINE);
				DisplayString(IDS_I_LIST_NOFORMATS);
			}
			else
			{
				// Display the available/defined LIST formats for 
				// the alias specified.
				DisplayString(IDS_I_NEWLINE);
				DisplayString(IDS_I_LIST_FMT_HEAD);
				DisplayString(IDS_I_NEWLINE);

				for ( theIterator = afdAlsFmtDet.begin(); theIterator != 
						afdAlsFmtDet.end();  theIterator++ )
				{
					_bstr_t bstrProps = _bstr_t("");
					// Print props associated with the format.
					BSTRVECTOR bvProps = (*theIterator).second;
					BSTRVECTOR::iterator propIterator;
					for ( propIterator = bvProps.begin(); 
						  propIterator != bvProps.end();
						  propIterator++ )
					{
						if ( propIterator != bvProps.begin() )
							bstrProps += _bstr_t(", ");

						bstrProps += *propIterator;
					}

					_TCHAR szMsg[MAX_BUFFER] = NULL_STRING;
					_stprintf(szMsg, _T("%-25s - %s\n"), 
							(_TCHAR*)(*theIterator).first,
							(_TCHAR*)bstrProps);
					DisplayString(szMsg);
				}
			}
		}

		// Display the LIST switches
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_LIST_SWITCH_HEAD);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_SWITCH_TRANSLATE);
		DisplayString(IDS_I_SWITCH_EVERY);
		DisplayString(IDS_I_SWITCH_FORMAT);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_TRANSFORMAT_NOTE1);
		DisplayString(IDS_I_TRANSFORMAT_NOTE2);
		DisplayString(IDS_I_TRANSFORMAT_NOTE3);
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayCALLUsage
   Synopsis	         :Displays CALL usage.
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayCALLUsage(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayCALLUsage(CParsedInfo& rParsedInfo)
{
	// Display the usage of the CALL verb
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_CALL_DESC);
	DisplayString(IDS_I_USAGE);
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_CALL_USAGE);
	DisplayString(IDS_I_CALL_PARAM_NOTE);

	// Display the method details.
	DisplayMethodDetails(rParsedInfo);
}

/*------------------------------------------------------------------------
   Name				 :DisplaySETUsage
   Synopsis	         :Displays SET usage.
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplaySETUsage(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplaySETUsage(CParsedInfo& rParsedInfo)
{
	DisplayInvalidProperties(rParsedInfo, TRUE);
	if ( rParsedInfo.GetCmdSwitchesObject().
			GetPropertyList().size() == 0 )
	{
		// Display the usage of the SET verb
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_SET_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_SET_USAGE);
		DisplayString(IDS_I_ASSIGNLIST_NOTE1);
		DisplayString(IDS_I_ASSIGNLIST_NOTE2);
	}

	// Display the property details
	DisplayPropertyDetails(rParsedInfo);
}

/*------------------------------------------------------------------------
   Name				 :DisplayCREATEUsage
   Synopsis	         :Displays CREATE usage.
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayCREATEsage(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayCREATEUsage(CParsedInfo& rParsedInfo)
{
	DisplayInvalidProperties(rParsedInfo);
	if ( rParsedInfo.GetCmdSwitchesObject().
			GetPropertyList().size() == 0 )
	{
		// Display the usage of the CREATE verb
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_CREATE_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_CREATE_USAGE);
		DisplayString(IDS_I_ASSIGNLIST_NOTE1);
		DisplayString(IDS_I_ASSIGNLIST_NOTE2);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_CREATE_NOTE);
	}

	// Display the property details
	DisplayPropertyDetails(rParsedInfo);
}

/*------------------------------------------------------------------------
   Name				 :DisplayDELETEUsage
   Synopsis	         :Displays DELETE usage.
   Type	             :Member Function 
   Input parameter   :
   		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayDELETEUsage()
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayDELETEUsage(CParsedInfo& rParsedInfo)
{
	// Display the usage of the DELETE verb
	DisplayString(IDS_I_NEWLINE);

	if(IsClassOperation(rParsedInfo))
	{
		DisplayString(IDS_I_CLASS_DELETE_DESC);
	}
	else
	{
		DisplayString(IDS_I_DELETE_DESC);
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayASSOCUsage
   Synopsis	         :Displays ASSOC usage.
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayASSOCUsage(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayASSOCUsage(CParsedInfo& rParsedInfo)
{
	if (rParsedInfo.GetHelpInfoObject().GetHelp(ASSOCSwitchesOnly) == FALSE)
	{
		DisplayString(IDS_I_NEWLINE);
		if(IsClassOperation(rParsedInfo))
		{
			DisplayString(IDS_I_CLASS_ASSOC_DESC);
		}
		else
		{
			DisplayString(IDS_I_ASSOC_DESC);
		}
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_ASSOC_USAGE);
		DisplayString(IDS_I_ASSOC_FMT_NOTE);
		DisplayString(IDS_I_NEWLINE);
	}
	DisplayString(IDS_I_ASSOC_SWITCH_HEAD);
	DisplayString(IDS_I_NEWLINE);
    DisplayString(IDS_I_ASSOC_RESULTCLASS);
	DisplayString(IDS_I_ASSOC_RESULTROLE);
	DisplayString(IDS_I_ASSOC_ASSOCCLASS);
}

/*------------------------------------------------------------------------
   Name				 :DisplayAliasFriendlyNames
   Synopsis	         :Displays alias names
   Type	             :Member Function 
   Input parameter   :
	   rParsedInfo  - reference to CParsedInfo class object
	   pszAlias	   - alias name (default null)
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayAliasFriendlyNames(rParsedInfo, pszAlias)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayAliasFriendlyNames(CParsedInfo& rParsedInfo,
											_TCHAR* pszAlias)
{
	_TCHAR szMsg[MAX_BUFFER] = NULL_STRING;
	// display ALIAS help
	BSTRMAP theMap = rParsedInfo.GetCmdSwitchesObject()
									.GetAlsFrnNmsOrTrnsTblMap();
	BSTRMAP::iterator theIterator;

	// Displaying the alias specific description
	if (pszAlias)
	{
		theIterator = theMap.find(CharUpper(pszAlias));
		if (theIterator != theMap.end())
		{
			DisplayString(IDS_I_NEWLINE);
			_stprintf(szMsg,_T("%s - %s\n"),
							(LPTSTR) (*theIterator).first,
							(LPTSTR) (*theIterator).second);

			DisplayString((LPTSTR) szMsg);
		}
	}
	else if ( !theMap.empty() )
	{
		_TCHAR* pszCmdString = rParsedInfo.GetCmdSwitchesObject().
															GetCommandInput();

		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_ALIASCMD_HEAD);
	
		// Display the alias friendly names together with the 
		// descriptions
		for (theIterator = theMap.begin(); theIterator != theMap.end(); 
												theIterator++)
		{
			if ( rParsedInfo.GetGlblSwitchesObject().
					GetHelpOption() == HELPBRIEF	&&
					StrStrI(pszCmdString, _T("BRIEF")) &&
					lstrlen((*theIterator).second) > 48)
			{
				_stprintf(szMsg,_T("%-25s- %.48s...\n"),
									(LPTSTR) (*theIterator).first,
									(LPTSTR) (*theIterator).second);
			}
			else
			{
				_stprintf(szMsg,_T("%-25s- %s\n"),
									(LPTSTR) (*theIterator).first,
									(LPTSTR) (*theIterator).second);
			}

			DisplayString((LPTSTR) szMsg);
		}
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_CMD_MORE);
	}
	else
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_ALIASCMD_NOT_AVLBL);
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayGlobalSwitchesAndOtherDesc
   Synopsis	         :Display help for global switches
   Type	             :Member Function 
   Input parameter   :
	   	rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayGlobalSwitchesAndOtherDesc(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayGlobalSwitchesAndOtherDesc(
												CParsedInfo& rParsedInfo)
{
	BOOL bDisplayAllInfo = rParsedInfo.GetHelpInfoObject().
			GetHelp(GlblAllInfo);

	// Display NAMESPACE help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(Namespace))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_NAMESPACE_DESC1);
		DisplayString(IDS_I_NAMESPACE_DESC2);
		DisplayString(IDS_I_NAMESPACE_DESC3);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_NAMESPACE_USAGE);
		if (!bDisplayAllInfo)
		{
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_SPECIAL_NOTE);
		}
	}

	// Display ROLE help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(Role))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_ROLE_DESC1);
		DisplayString(IDS_I_ROLE_DESC2);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_ROLE_USAGE);
		DisplayString(IDS_I_ROLE_NOTE1);
		DisplayString(IDS_I_ROLE_NOTE2);
		DisplayString(IDS_I_ROLE_NOTE3);
		if (!bDisplayAllInfo)
		{
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_SPECIAL_NOTE);
		}
	}

	// Display NODE help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(Node))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_NODE_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_NODE_USAGE);
		DisplayString(IDS_I_NODE_NOTE);
		if (!bDisplayAllInfo)
		{
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_SPECIAL_NOTE);
		}
	}
		
	// Display IMPLEVEL help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(Level))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_IMPLEVEL_DESC1);
		DisplayString(IDS_I_IMPLEVEL_DESC2);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_IMPLEVEL_USAGE);
		DisplayString(IDS_I_IMPLEVEL_HEAD);
		DisplayString(IDS_I_IMPLEVEL_HEAD1);
		DisplayString(IDS_I_IMPLEVEL_HEAD2);
		DisplayString(IDS_I_IMPLEVEL_ANON);
		DisplayString(IDS_I_IMPLEVEL_IDENTIFY);
		DisplayString(IDS_I_IMPLEVEL_IMPERSONATE);
		DisplayString(IDS_I_IMPLEVEL_DELEGATE);
	}

	// Display AUTHLEVEL help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(AuthLevel))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_AUTHLEVEL_DESC1);
		DisplayString(IDS_I_AUTHLEVEL_DESC2);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_AUTHLEVEL_USAGE);
		DisplayString(IDS_I_AUTHLEVEL_HEAD);
		DisplayString(IDS_I_AUTHLEVEL_HEAD1);
		DisplayString(IDS_I_AUTHLEVEL_HEAD2);
		DisplayString(IDS_I_AUTHLEVEL_DEFAULT);
		DisplayString(IDS_I_AUTHLEVEL_NONE);
		DisplayString(IDS_I_AUTHLEVEL_CONNECT);
		DisplayString(IDS_I_AUTHLEVEL_CALL);
		DisplayString(IDS_I_AUTHLEVEL_PKT);
		DisplayString(IDS_I_AUTHLEVEL_PKTINTGRTY);
		DisplayString(IDS_I_AUTHLEVEL_PKTPRVCY);
	}

	// Display LOCALE help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(Locale))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_LOCALE_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_LOCALE_USAGE);
		DisplayString(IDS_I_LOCALE_NOTE1);
		DisplayString(IDS_I_LOCALE_NOTE2);
	}

	// Display PRIVILEGES help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(Privileges))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_PRIVILEGES_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_PRIVILEGES_USAGE);
		DisplayString(IDS_I_PRIVILEGES_NOTE);
	}

	// Display TRACE help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(Trace))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_TRACE_DESC1);
		DisplayString(IDS_I_TRACE_DESC2);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_TRACE_USAGE);
		DisplayString(IDS_I_TRACE_NOTE);
	}
	
	// Display RECORD help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(RecordPath))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_RECORD_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_RECORD_USAGE);
		if (!bDisplayAllInfo)
		{
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_SPECIAL_NOTE);
		}
	}

	// Display INTERACTIVE help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(Interactive))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_INTERACTIVE_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_INTERACTIVE_USAGE);
		DisplayString(IDS_I_TRACE_NOTE);
	}

	// Display FAILFAST help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(FAILFAST))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_FAILFAST_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_FAILFAST_USAGE);
		DisplayString(IDS_I_TRACE_NOTE);
	}

	// Display OUTPUT help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(OUTPUT))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_OUTPUT_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_OUTPUT_USAGE);
		DisplayString(IDS_I_OUTPUT_NOTE);
		DisplayString(IDS_I_STDOUT_NOTE);
		DisplayString(IDS_I_CLIPBOARD_NOTE);
		DisplayString(IDS_I_OUTPUT_FILE_NOTE);
		if (!bDisplayAllInfo)
		{
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_SPECIAL_NOTE);
		}
	}

	// Display APPEND help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(APPEND))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_APPEND_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_APPEND_USAGE);
		DisplayString(IDS_I_OUTPUT_NOTE);
		DisplayString(IDS_I_STDOUT_NOTE);
		DisplayString(IDS_I_CLIPBOARD_NOTE);
		DisplayString(IDS_I_APPEND_FILE_NOTE);
		if (!bDisplayAllInfo)
		{
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_SPECIAL_NOTE);
		}
	}

	// Display USER help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(User))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_USER_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_USER_USAGE);
		DisplayString(IDS_I_USER_NOTE);
		if (!bDisplayAllInfo)
		{
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_SPECIAL_NOTE);
		}
	}

	//Display AGGREGATE help
	if(bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(Aggregate))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_AGGREGATE_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_AGGREGATE_USAGE);
		DisplayString(IDS_I_AGGREGATE_NOTE);
	}
	
	// Display PASSWORD help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(Password))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_PASSWORD_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_PASSWORD_USAGE);
		if (!bDisplayAllInfo)
		{
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_SPECIAL_NOTE);
		}
	}

	if (bDisplayAllInfo)
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_HELP_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_HELP_USAGE);
		DisplayString(IDS_I_HELP_NOTE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_SPECIAL_NOTE);
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayMethodDetails
   Synopsis	         :Display help for Alias verbs
   Type	             :Member Function 
   Input parameter   :
	   	rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayMethodDetails(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayMethodDetails(CParsedInfo& rParsedInfo) 
{
	// Obtain the help option.
	HELPOPTION				hoHelpType	  = rParsedInfo.GetGlblSwitchesObject()
													.GetHelpOption();
	// Obtain the method details.
	METHDETMAP				theMap		  = rParsedInfo.GetCmdSwitchesObject().
													GetMethDetMap();
	METHDETMAP::iterator	theIterator;
	BOOL					bDisAliasVerb = rParsedInfo.GetHelpInfoObject().
												GetHelp(AliasVerb);
	BOOL					bPrinted	  = FALSE;

	_bstr_t					bstrLine;


	try
	{
		// Loop thru the method map
		for (theIterator = theMap.begin(); 
					theIterator != theMap.end(); theIterator++)
		{
						
			if (!bDisAliasVerb && theIterator == theMap.begin())
			{
				DisplayString(IDS_I_NEWLINE);
				if (rParsedInfo.GetCmdSwitchesObject().GetAliasName())
					DisplayString(IDS_I_ALIASVERB_HEAD);
				else
					DisplayString(IDS_I_VERB_HEAD);
				DisplayString(IDS_I_NEWLINE);
			}

			if ( bPrinted == FALSE )
			{
				DisplayString(IDS_I_PARAM_HEAD);
				DisplayString(IDS_I_PARAM_BORDER);
				bPrinted = TRUE;
			}

			METHODDETAILS	mdMethDet	= (*theIterator).second;
			_TCHAR			szMsg[MAX_BUFFER] = NULL_STRING;
			_stprintf(szMsg,_T("%-24s"),(LPTSTR) (*theIterator).first);
			_bstr_t			bstrMessage = _bstr_t(szMsg);


			PROPDETMAP pdmParams = mdMethDet.Params;
			PROPDETMAP::iterator paraIterator;
			for ( paraIterator = pdmParams.begin() ;  paraIterator !=
							pdmParams.end(); paraIterator++ )
			{
				if ( paraIterator != pdmParams.begin())
				{
					DisplayString(IDS_I_NEWLINE);
					_stprintf(szMsg, _T("\t\t\t"));
					bstrMessage = szMsg;
				}

				LPSTR pszParaId = NULL, pszParaType = NULL;
				PROPERTYDETAILS pdPropDet = (*paraIterator).second;
				
				if (!ConvertWCToMBCS((LPTSTR)(*paraIterator).first,(LPVOID*) &pszParaId, 
									CP_OEMCP))
					throw OUT_OF_MEMORY;
				if (!ConvertWCToMBCS(pdPropDet.Type,(LPVOID*) &pszParaType, CP_OEMCP))
					throw OUT_OF_MEMORY;
				
				_bstr_t bstrInOrOut;
				if ( pdPropDet.InOrOut == INP )
					bstrInOrOut = _bstr_t("[IN ]");
				else if ( pdPropDet.InOrOut == OUTP )
					bstrInOrOut = _bstr_t("[OUT]");
				else
					bstrInOrOut = _bstr_t("[UNKNOWN]");

				// Remove initial 5 chars from pszParaId to remove temporary 
				// number for maintaining order of paramas
				_bstr_t bstrLine = bstrInOrOut 
									+ _bstr_t(pszParaId + 5) 
									+ _bstr_t("(") 
									+ _bstr_t(pszParaType) + _bstr_t(")");
				_stprintf(szMsg,_T("%-36s\t"),(LPTSTR) bstrLine);
				bstrMessage += _bstr_t(szMsg);
				SAFEDELETE(pszParaId);
				SAFEDELETE(pszParaType);

				if ( paraIterator == pdmParams.begin() )
				{
					_stprintf(szMsg,_T("%-15s"),(LPTSTR) mdMethDet.Status);
					bstrMessage += szMsg;
				}
				bstrMessage += _bstr_t(L"\n");
				DisplayString((LPTSTR) bstrMessage);
			}

			if ( paraIterator == pdmParams.begin() )
			{
				_stprintf(szMsg,_T("\t\t\t\t\t%-15s"),(LPTSTR)mdMethDet.Status);
				bstrMessage += _bstr_t(szMsg) + _bstr_t(L"\n");
				DisplayString((LPTSTR) bstrMessage);
				DisplayString(IDS_I_NEWLINE);
			}
			DisplayString(IDS_I_NEWLINE);

			if ( hoHelpType == HELPFULL )
			{
				DisplayString(IDS_I_DESCRIPTION);
				bstrLine = mdMethDet.Description + _bstr_t(L"\n");
				DisplayString((LPTSTR) bstrLine);
				DisplayString(IDS_I_NEWLINE);
			}
		}
		if (!bPrinted)
		{
			if (rParsedInfo.GetCmdSwitchesObject().GetMethodName() != NULL)
			{
				DisplayString(IDS_I_ALIASVERB_NOT_AVLBL);
			}
			else
			{
				DisplayString(IDS_I_NEWLINE);
				DisplayString(IDS_I_VERB_NOT_AVLBL);
			}
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	catch(WMICLIINT nVal)
	{
		// If memory allocation failed.
		if (nVal == OUT_OF_MEMORY)
		{
  			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(OUT_OF_MEMORY);
		}
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayPropertyDetails
   Synopsis	         :Display help for Alias properties and their descriptions
   Type	             :Member Function 
   Input parameter   :
	  	rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayPropertyDetails(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayPropertyDetails(CParsedInfo& rParsedInfo)
{
	BOOL					bFirst				= TRUE;
	BOOL					bSetVerb			= FALSE;
	_TCHAR					szMsg[MAX_BUFFER]	= NULL_STRING;
	_bstr_t					bstrLine;
	PROPDETMAP::iterator	theIterator			= NULL;
	PROPERTYDETAILS			pdPropDet;

	HELPOPTION	hoHelpType	= rParsedInfo.GetGlblSwitchesObject().
								GetHelpOption();
	PROPDETMAP theMap = rParsedInfo.GetCmdSwitchesObject().GetPropDetMap();
	try
	{
		// If the verb is SET display only writable properties
		if (CompareTokens(rParsedInfo.GetCmdSwitchesObject().GetVerbName(), 
						CLI_TOKEN_SET))
		{
			bSetVerb = TRUE;
		}
		
		for (theIterator = theMap.begin(); 
				theIterator != theMap.end(); theIterator++)
		{
			pdPropDet = (PROPERTYDETAILS)((*theIterator).second);

			if (bFirst)
			{
				DisplayString(IDS_I_NEWLINE);
				if ( rParsedInfo.GetCmdSwitchesObject().
									GetPropertyList().size() == 0 )
				{
					if (bSetVerb)
					{
						DisplayString(IDS_I_PROP_WRITEABLE_HEAD);
					}
					else
					{
						DisplayString(IDS_I_PROP_HEAD);
					}
				}
				DisplayString(IDS_I_PROPS_HEAD);
				DisplayString(IDS_I_PROPS_BORDER);
				bFirst = FALSE;
			}

			_stprintf(szMsg,_T("%-35s\t%-20s\t%-10s\n"), 
						(LPTSTR)(*theIterator).first, 
						(LPTSTR) pdPropDet.Type, (LPTSTR) pdPropDet.Operation);
			DisplayString((LPTSTR) szMsg);
			
			if ( hoHelpType == HELPFULL )
			{
				DisplayString(IDS_I_DESCRIPTION);
				bstrLine = pdPropDet.Description + _bstr_t(L"\n");
				DisplayString((LPTSTR) bstrLine);	
				DisplayString(IDS_I_NEWLINE);
			}
		}
		
		if ( bSetVerb && 
			 rParsedInfo.GetCmdSwitchesObject().
									GetPropertyList().size() == 0 &&
			 bFirst == TRUE	)
		{
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_PROP_WRITEABLE_NOT_AVLBL);
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayStdVerbDescriptions
   Synopsis	         :Displays help for standard verbs
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayStdVerbDescriptions(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayStdVerbDescriptions(CParsedInfo& rParsedInfo)
{
	BOOL bDisAllCmdHelp = rParsedInfo.GetHelpInfoObject().GetHelp(CmdAllInfo);
	
	if (bDisAllCmdHelp)
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_STDVERB_HEAD);
	}

	if (bDisAllCmdHelp || rParsedInfo.GetHelpInfoObject().GetHelp(GETVerb))
		DisplayGETUsage(rParsedInfo);

	if (bDisAllCmdHelp || rParsedInfo.GetHelpInfoObject().GetHelp(SETVerb))
		DisplaySETUsage(rParsedInfo);
	
	if (bDisAllCmdHelp || rParsedInfo.GetHelpInfoObject().GetHelp(LISTVerb))
		DisplayLISTUsage(rParsedInfo);
	
	if (bDisAllCmdHelp || rParsedInfo.GetHelpInfoObject().GetHelp(CALLVerb))
		DisplayCALLUsage(rParsedInfo);
	
	if (bDisAllCmdHelp || rParsedInfo.GetHelpInfoObject().GetHelp(ASSOCVerb))
		DisplayASSOCUsage(rParsedInfo);

	if (bDisAllCmdHelp || rParsedInfo.GetHelpInfoObject().GetHelp(CREATEVerb))
		DisplayCREATEUsage(rParsedInfo);

	if (bDisAllCmdHelp || rParsedInfo.GetHelpInfoObject().GetHelp(DELETEVerb))
		DisplayDELETEUsage(rParsedInfo);

}


/*------------------------------------------------------------------------
   Name				 :FrameHelpVector
   Synopsis	         :Frames the help vector which will be later used for 
					  displaying the help on a page by page basis
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :FrameHelpVector(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::FrameHelpVector(CParsedInfo& rParsedInfo)
{
	m_bDispCALL	=	rParsedInfo.GetCmdSwitchesObject().
											GetMethodsAvailable();

	m_bDispSET =	rParsedInfo.GetCmdSwitchesObject().
											GetWriteablePropsAvailable();

	m_bDispLIST =	rParsedInfo.GetCmdSwitchesObject().
											GetLISTFormatsAvailable();

	if (rParsedInfo.GetHelpInfoObject().GetHelp(GlblAllInfo))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_GLBLCMD);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_GLBL_SWITCH_HEAD);

		if ( rParsedInfo.GetGlblSwitchesObject().GetHelpOption() == HELPBRIEF)
			DisplayGlobalSwitchesBrief();
		else
			DisplayGlobalSwitchesAndOtherDesc(rParsedInfo);

		DisplayString(IDS_I_NEWLINE);
		DisplayAliasFriendlyNames(rParsedInfo);

		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_CLASS_DESCFULL);
		DisplayString(IDS_I_PATH_DESCFULL);
		DisplayString(IDS_I_CONTEXT_DESCFULL);
		DisplayString(IDS_I_QUITEXIT);
		
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_CLASSPATH_MORE);
	}
	else if (rParsedInfo.GetHelpInfoObject().GetHelp(CmdAllInfo))
	{
		DisplayAliasFriendlyNames(rParsedInfo, 
					rParsedInfo.GetCmdSwitchesObject().GetAliasName());
		DisplayAliasHelp(rParsedInfo);
	}
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(PATH))
		DisplayPATHHelp(rParsedInfo);
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(WHERE))
		DisplayWHEREHelp(rParsedInfo);
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(CLASS))
		DisplayCLASSHelp(rParsedInfo);
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(PWhere))
		DisplayPWhereHelp(rParsedInfo);
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(TRANSLATE))
		DisplayTRANSLATEHelp(rParsedInfo);
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(EVERY))
		DisplayEVERYHelp(rParsedInfo);
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(REPEAT))
		DisplayREPEATHelp();
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(FORMAT))
		DisplayFORMATHelp(rParsedInfo);
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(VERBSWITCHES))
		DisplayVERBSWITCHESHelp(rParsedInfo);
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(GLBLCONTEXT))
		DisplayContext(rParsedInfo);
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(CONTEXTHELP))
		DisplayContextHelp();
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(RESULTCLASShelp))
		DisplayRESULTCLASSHelp();
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(RESULTROLEhelp))
		DisplayRESULTROLEHelp();
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(ASSOCCLASShelp))
		DisplayASSOCCLASSHelp();
	else
	{
		DisplayGlobalSwitchesAndOtherDesc(rParsedInfo);
		DisplayStdVerbDescriptions(rParsedInfo);
		if ( rParsedInfo.GetHelpInfoObject().GetHelp(AliasVerb) )
			DisplayMethodDetails(rParsedInfo);
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayAliasHelp
   Synopsis	         :Displays help for Alias 
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayAliasHelp(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayAliasHelp(CParsedInfo& rParsedInfo)
{
	try
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_ALIAS_USAGE1);
		DisplayString(IDS_I_ALIAS_USAGE2);
		DisplayString(IDS_I_NEWLINE);

		// Get the Alias Name
		_bstr_t bstrAliasName = _bstr_t(rParsedInfo.
										GetCmdSwitchesObject().GetAliasName());
		CharUpper(bstrAliasName);
		DisplayStdVerbsUsage(bstrAliasName);
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayPATHHelp
   Synopsis	         :Displays help for Alias PATH
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayPATHHelp(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayPATHHelp(CParsedInfo& rParsedInfo)
{
	if ( rParsedInfo.GetCmdSwitchesObject().GetClassPath() == NULL )
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_PATH_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_PATH_USAGE);
	}
	else
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_PATH_DESC);
		_bstr_t bstrMsg;
		WMIFormatMessage(IDS_I_PATHHELP_SUBST, 0, bstrMsg, NULL);
		DisplayStdVerbsUsage(bstrMsg);
	}	
}

/*------------------------------------------------------------------------
   Name				 :DisplayWHEREHelp
   Synopsis	         :Displays help for WHERE
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayWHEREHelp(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayWHEREHelp(CParsedInfo& rParsedInfo)
{
	try
	{
		if ( rParsedInfo.GetCmdSwitchesObject().GetWhereExpression() == NULL )
		{
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_WHERE_DESC1);
			DisplayString(IDS_I_WHERE_DESC2);
			DisplayString(IDS_I_USAGE);
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_WHERE_USAGE);
		}
		else
		{
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_WHERE_DESC1);
			DisplayString(IDS_I_WHERE_DESC2);
			_bstr_t bstrMsg;
			WMIFormatMessage(IDS_I_WHEREHELP_SUBST, 0, bstrMsg, NULL);
			DisplayStdVerbsUsage(bstrMsg);
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayCLASSHelp
   Synopsis	         :Displays help for CLASS
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayCLASSHelp(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayCLASSHelp(CParsedInfo& rParsedInfo)
{
	if ( rParsedInfo.GetCmdSwitchesObject().GetClassPath() == NULL )
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_CLASS_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_CLASS_USAGE);
	}
	else
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_CLASS_DESC);
		_bstr_t bstrMsg;
		WMIFormatMessage(IDS_I_CLASSHELP_SUBST, 0, bstrMsg, NULL);
		DisplayStdVerbsUsage(bstrMsg, TRUE);
	}		
}

/*------------------------------------------------------------------------
   Name				 :Help
   Synopsis	         :Displays help for PWhere
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayPWhereHelp(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayPWhereHelp(CParsedInfo& rParsedInfo)
{
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_PWHERE_DESC1);
	DisplayString(IDS_I_PWHERE_DESC2);
	DisplayString(IDS_I_NEWLINE);
	_bstr_t bstrMsg;
	WMIFormatMessage(IDS_I_PWHEREHELP_SUBST, 1, bstrMsg, 
						CharUpper(rParsedInfo.GetCmdSwitchesObject()
								.GetAliasName()));
	DisplayStdVerbsUsage(bstrMsg);
	DisplayString(IDS_I_PWHERE_USAGE);
}


/*------------------------------------------------------------------------
   Name				 :DisplayString
   Synopsis	         :Displays localized string
   Type	             :Member Function 
   Input parameter   :None
			uID				- string table identifier
			bAddToVector	- add to help vector.
			LPTSTR			- lpszParam (parameter for substituion)
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayString(uID, bAddToVector, lpszParam)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayString(UINT uID, BOOL bAddToVector,
								  LPTSTR lpszParam, BOOL bIsError) 
{

	LPTSTR	lpszMsg		= NULL;
	LPSTR	lpszDisp	= NULL;
	HRESULT	hr			= S_OK;

	try
	{
		lpszMsg = new _TCHAR [BUFFER1024];

		if ( m_bGetOutOpt == TRUE )
		{
			// Get the output option to redirect the output.
			m_opsOutputOpt	= g_wmiCmd.GetParsedInfoObject().
										GetGlblSwitchesObject().
										GetOutputOrAppendOption(TRUE);
			m_bGetOutOpt = FALSE;	
		}
		
		if ( m_bGetAppendFilePinter == TRUE )
		{
			// FALSE for getting append file pointer.
			m_fpAppendFile = g_wmiCmd.GetParsedInfoObject().
									GetGlblSwitchesObject().
									GetOutputOrAppendFilePointer(FALSE);
			m_bGetAppendFilePinter = FALSE;
		}

		if ( m_bGetOutputFilePinter == TRUE )
		{
			// TRUE for getting append file pointer.
			m_fpOutFile = g_wmiCmd.GetParsedInfoObject().
									GetGlblSwitchesObject().
									GetOutputOrAppendFilePointer(TRUE);
			m_bGetOutputFilePinter = FALSE;
		}

		if (lpszMsg)
		{
			LoadString(NULL, uID, lpszMsg, BUFFER1024);
			LPVOID lpMsgBuf = NULL;
			if (lpszParam)
			{
				char* pvaInsertStrs[1];
				pvaInsertStrs[0] = (char*)	lpszParam;

				DWORD dwRet = FormatMessage(
						FORMAT_MESSAGE_ALLOCATE_BUFFER | 
						FORMAT_MESSAGE_FROM_STRING | 
						FORMAT_MESSAGE_ARGUMENT_ARRAY,
						lpszMsg,
						0, 
						MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
						(LPTSTR) &lpMsgBuf,
						0,
						pvaInsertStrs);
				if (dwRet == 0)
				{
					SAFEDELETE(lpszMsg);
					throw (::GetLastError());
				}
			}

			if ( lpMsgBuf != NULL )
			{
				if (!ConvertWCToMBCS((LPTSTR)lpMsgBuf, (LPVOID*) &lpszDisp, 
																	CP_OEMCP))
				{
					LocalFree(lpMsgBuf);
					throw OUT_OF_MEMORY;
				}
			}
			else
			{
				if (!ConvertWCToMBCS(lpszMsg, (LPVOID*) &lpszDisp, CP_OEMCP))
				{
					SAFEDELETE(lpszMsg);
					throw OUT_OF_MEMORY;
				}
			}
			if (m_bHelp && bAddToVector)
			{
				m_cvHelp.push_back(lpszDisp);
			}
			else
			{
				if (m_bRecord && m_bLog && !m_bInteractiveHelp)
				{
					hr = m_WmiCliLog.WriteToXMLLog(g_wmiCmd.GetParsedInfoObject(), 
										_bstr_t(lpszDisp));
					if (FAILED(hr))
					{
						m_WmiCliLog.StopLogging();
						m_bRecord = FALSE;
						hr = S_OK;
						DisplayString(IDS_E_WRITELOG_FAILED, FALSE, NULL, TRUE);
					}
					m_bLog = FALSE;
				}

				if (m_bInteractiveHelp)
					m_bstrOutput += _bstr_t(lpszDisp);

				if ( bIsError == TRUE )
				{
					fprintf(stderr,"%s\n", lpszDisp);
					fflush(stderr);
				}
				else
				{
					if ( m_opsOutputOpt == CLIPBOARD )
					{
						g_wmiCmd.AddToClipBoardBuffer(lpszDisp);
						g_wmiCmd.AddToClipBoardBuffer("\n");
					}
					else if ( m_opsOutputOpt == FILEOUTPUT )
					{
						if (m_fpOutFile != NULL)
						{
							fprintf(m_fpOutFile, "%s", 
									lpszDisp);
						}
						else
						{
							fprintf(stdout, "%s", 
									lpszDisp);
							fflush(stdout);
						}
					}
					else
					{
						fprintf(stdout, "%s\n", 
									lpszDisp);
						fflush(stdout);
					}

					if ( m_fpAppendFile != NULL )
					{
						fprintf(m_fpAppendFile, "%s\n", 
									lpszDisp);
					}
				}

				SAFEDELETE(lpszDisp);

			}
			SAFEDELETE(lpszMsg);
			// Free the memory used up the error message
			// and then exit
			if ( lpMsgBuf != NULL )
				LocalFree(lpMsgBuf);
		}
		else
			_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
    catch(_com_error& e)
	{
		 SAFEDELETE(lpszDisp);
		 SAFEDELETE(lpszMsg);
		_com_issue_error(e.Error());
	}
	catch(CHeap_Exception)
	{
		 SAFEDELETE(lpszDisp);
		 SAFEDELETE(lpszMsg);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}

}


/*------------------------------------------------------------------------
   Name				 :DisplayString
   Synopsis	         :Displays localized string 
   Type	             :Member Function 
   Input parameter   :
			lszpMsg  - string  
			bScreen	 - TRUE	- write to screen
					   FALSE - write only to log file
			bIsError - TRUE - write to STDERR
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayString(lpszMsg, bScreen, bIsError)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayString(LPTSTR lpszMsg, BOOL bScreen, BOOL bIsError)
{
	HRESULT hr = S_OK;
	LPSTR	lpszDisp = NULL;

	try
	{
		if ( m_bGetOutOpt == TRUE )
		{
			// Get the output option to redirect the output.
			m_opsOutputOpt	= g_wmiCmd.GetParsedInfoObject().
										GetGlblSwitchesObject().
										GetOutputOrAppendOption(TRUE);
			m_bGetOutOpt = FALSE;	
		}

		if ( m_bGetAppendFilePinter == TRUE )
		{
			// FALSE for getting append file pointer.
			m_fpAppendFile = g_wmiCmd.GetParsedInfoObject().
									GetGlblSwitchesObject().
									GetOutputOrAppendFilePointer(FALSE);
			m_bGetAppendFilePinter = FALSE;
		}

		if ( m_bGetOutputFilePinter == TRUE )
		{
			// TRUE for getting append file pointer.
			m_fpOutFile = g_wmiCmd.GetParsedInfoObject().
									GetGlblSwitchesObject().
									GetOutputOrAppendFilePointer(TRUE);
			m_bGetOutputFilePinter = FALSE;
		}
	
		if (!ConvertWCToMBCS(lpszMsg, (LPVOID*) &lpszDisp, ::GetOEMCP()))
		{
			SAFEDELETE(lpszDisp);
			throw OUT_OF_MEMORY;
		}

		// If write to screen is TRUE and help flag is not enabled.
		if (bScreen && !m_bHelp)
		{
			if (m_bRecord && m_bLog && !m_bInteractiveHelp)
			{
				hr = m_WmiCliLog.WriteToXMLLog(g_wmiCmd.GetParsedInfoObject(),
							_bstr_t(lpszDisp));
				if (FAILED(hr))
				{
					m_WmiCliLog.StopLogging();
					m_bRecord = FALSE;
					hr = S_OK;
					DisplayString(IDS_E_WRITELOG_FAILED, FALSE, NULL, TRUE);
				}
				m_bLog = FALSE;
			}

			if (m_bInteractiveHelp)
			{
				m_bstrOutput += _bstr_t(lpszDisp);
			}

			if ( bIsError == TRUE )
			{
				fprintf(stderr, "%ws", lpszMsg);
				fflush(stderr);
			}
			else
			{
				if ( m_opsOutputOpt == CLIPBOARD )
					g_wmiCmd.AddToClipBoardBuffer(lpszDisp);
				else if ( m_opsOutputOpt == FILEOUTPUT )
				{
					if (m_fpOutFile != NULL)
					{
						fprintf(m_fpOutFile, "%s", 
								lpszDisp);
					}
					else
					{
						fprintf(stdout, "%s", 
								lpszDisp);
						fflush(stdout);
					}
				}
				else
				{
					fprintf(stdout, "%s", 
								lpszDisp);
					fflush(stdout);
				}

				if ( m_fpAppendFile != NULL )
				{
					fprintf(m_fpAppendFile, "%s", 
								lpszDisp);
				}
			}
			SAFEDELETE(lpszDisp);

		}
		else if (m_bHelp)
		{
			m_cvHelp.push_back(lpszDisp);
		}
	}
	catch(_com_error& e)
	{
		SAFEDELETE(lpszDisp);
		_com_issue_error(e.Error());
	}
	catch(CHeap_Exception)
	{
		SAFEDELETE(lpszDisp);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayPagedHelp
   Synopsis	         :Displays help in pages
   Type	             :Member Function 
   Input parameter   :
			rParsedInfo - reference to CParsedInfo object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayPagedHelp(rParsedInfo)
------------------------------------------------------------------------*/
void CFormatEngine::DisplayPagedHelp(CParsedInfo& rParsedInfo) 
{
	LPSTRVECTOR::iterator		itrStart	= NULL, 
								itrEnd		= NULL;
	COORD						coord; 
	HANDLE						hStdOut		= NULL;
	CONSOLE_SCREEN_BUFFER_INFO	csbiInfo;
	WMICLIINT					nHeight		= 0;
	WMICLIINT					nWidth		= 1;
	WMICLIINT					nLines		= 0;
	_TCHAR						cUserKey	= 0;
	_TCHAR						cCharESC	= 0x1B;
	_TCHAR						cCharCtrlC	= 0x03;
	_bstr_t						bstrHelp;
	HRESULT						hr			= S_OK;
	
	itrStart = m_cvHelp.begin();
	itrEnd	 = m_cvHelp.end();
	try
	{
		if (m_bRecord && m_bLog)
		{
			while (itrStart != itrEnd)
			{
				bstrHelp += *itrStart;
				itrStart++;
			}

			hr = m_WmiCliLog.WriteToXMLLog(rParsedInfo, bstrHelp);
			if (FAILED(hr))
			{
				m_WmiCliLog.StopLogging();
				m_bRecord = FALSE;
				hr = S_OK;
				DisplayString(IDS_E_WRITELOG_FAILED, FALSE, NULL, TRUE);
			}
			m_bLog = FALSE;
			itrStart = m_cvHelp.begin();
		}

		if ( m_bGetOutOpt == TRUE )
		{
			// Get the output option to redirect the output.
			m_opsOutputOpt	= g_wmiCmd.GetParsedInfoObject().
										GetGlblSwitchesObject().
										GetOutputOrAppendOption(TRUE);
			m_bGetOutOpt = FALSE;	
		}

		if ( m_bGetAppendFilePinter == TRUE )
		{
			// FALSE for getting append file pointer.
			m_fpAppendFile = g_wmiCmd.GetParsedInfoObject().
									GetGlblSwitchesObject().
									GetOutputOrAppendFilePointer(FALSE);
			m_bGetAppendFilePinter = FALSE;
		}

		if ( m_bGetOutputFilePinter == TRUE )
		{
			// TRUE for getting append file pointer.
			m_fpOutFile = g_wmiCmd.GetParsedInfoObject().
									GetGlblSwitchesObject().
									GetOutputOrAppendFilePointer(TRUE);
			m_bGetOutputFilePinter = FALSE;
		}

		// Obtain the standard output handle
		hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

		while (itrStart != itrEnd)
		{
			// Get the screen buffer size. 
			GetConsoleScreenBufferInfo(hStdOut, &csbiInfo);
			nHeight = (csbiInfo.srWindow.Bottom - csbiInfo.srWindow.Top) - 1;
			nWidth  = csbiInfo.dwSize.X;

			// if console size is positive (to address redirection)
			if ((nHeight > 0) && (m_opsOutputOpt == STDOUT))
			{
				if (nLines >= nHeight)
				{
					coord.X = 0;
					coord.Y = csbiInfo.dwCursorPosition.Y;
					DisplayString(IDS_I_PAKTC, FALSE);
		
					cUserKey = (_TCHAR)_getch();

					SetConsoleCursorPosition(hStdOut, coord);
					DisplayString(IDS_I_PAKTC_ERASE, FALSE);
					SetConsoleCursorPosition(hStdOut, coord);
					nLines = 0;

					if ( cUserKey == cCharESC || cUserKey == cCharCtrlC )
						break;
				}
				nLines += ceil(((float) strlen(*itrStart) / (float)nWidth ));
			}

			if ( m_opsOutputOpt == CLIPBOARD )
				g_wmiCmd.AddToClipBoardBuffer(*itrStart);
			else if ( m_opsOutputOpt == FILEOUTPUT )
			{
				if (m_fpOutFile != NULL)
				{
					fprintf(m_fpOutFile, "%s", 
							(*itrStart));
				}
				else
				{
					fprintf(stdout, "%s", (*itrStart));
					fflush(stdout);
				}
			}
			else
			{
				fprintf(stdout, "%s", (*itrStart));
				fflush(stdout);
			}

			if ( m_fpAppendFile != NULL )
			{
				fprintf(m_fpAppendFile,"%s", 
							(*itrStart));
			}
			// Move to next entry
			itrStart++;
		}
		if ( m_opsOutputOpt == CLIPBOARD )
			g_wmiCmd.AddToClipBoardBuffer("\n");
		else if ( m_opsOutputOpt == FILEOUTPUT )
		{
			if (m_fpOutFile != NULL)
			{
				fprintf(m_fpOutFile, "\n");
			}
			else
			{
				fprintf(stdout,"\n");
				fflush(stdout);
			}
		}
		else
		{
			fprintf(stdout, "\n");
			fflush(stdout);
		}

		if ( m_fpAppendFile != NULL )
		{
			fprintf(m_fpAppendFile, "\n");
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayStdVerbsUsage
   Synopsis	         :Displays all standard verbs available.
   Type	             :Member Function 
   Input Parameter(s):
			bstrBeginStr - string that needs to be appended.
			bClass		 
					TRUE - indicates class (drop LIST from the help)
   Output Parameter(s):None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayStdVerbsUsage(bstrBeginStr, bClass)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayStdVerbsUsage(_bstr_t bstrBeginStr, BOOL bClass)
{
	DisplayString(IDS_I_USAGE);
	DisplayString(IDS_I_NEWLINE);

	// Display help for Alias name means standard verb available to this
	// Alias name
	DisplayString(IDS_I_STDVERB_ASSOC, TRUE, (LPTSTR)bstrBeginStr);

	if ( m_bDispCALL == TRUE )
		DisplayString(IDS_I_STDVERB_CALL, TRUE, (LPTSTR)bstrBeginStr);

	DisplayString(IDS_I_STDVERB_CREATE, TRUE, (LPTSTR)bstrBeginStr);
	DisplayString(IDS_I_STDVERB_DELETE, TRUE, (LPTSTR)bstrBeginStr);

	if (!bClass)
	{
		DisplayString(IDS_I_STDVERB_GET, TRUE, (LPTSTR)bstrBeginStr);
	}
	else
	{
		DisplayString(IDS_I_CLASS_STDVERB_GET, TRUE, (LPTSTR)bstrBeginStr);
	}

	if (!bClass)
	{
		if ( m_bDispLIST == TRUE )
			DisplayString(IDS_I_STDVERB_LIST, TRUE, (LPTSTR)bstrBeginStr);
	}

	if ( m_bDispSET == TRUE )
		DisplayString(IDS_I_STDVERB_SET, TRUE, (LPTSTR)bstrBeginStr);
}

/*------------------------------------------------------------------------
   Name				 :DisplayTRANSLATEHelp
   Synopsis	         :Displays help for TRANSLATE switch
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayTRANSLATEHelp(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayTRANSLATEHelp(CParsedInfo& rParsedInfo)
{
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_TRANSLATE_FULL_DESC);
	DisplayString(IDS_I_USAGE);
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_TRANSLATE_USAGE);

	CHARVECTOR cvTables = rParsedInfo.
							GetCmdSwitchesObject().GetTrnsTablesList();
	if ( !cvTables.empty() )
	{
		CHARVECTOR::iterator theIterator;

		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_TRANSLATE_HEAD);

		for ( theIterator = cvTables.begin();
			  theIterator != cvTables.end(); theIterator++ )
		{
			DisplayString(IDS_I_NEWLINE);			
			DisplayString(*theIterator);			
		}
		DisplayString(IDS_I_NEWLINE);			
	}
	else
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_TRANSLATE_NOTABLES);
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayEVERYHelp
   Synopsis	         :Displays help for EVERY switch
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayTRANSLATEHelp(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayEVERYHelp(CParsedInfo& rParsedInfo)
{
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_EVERY_DESC_FULL);
	DisplayString(IDS_I_USAGE);
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_EVERY_USAGE);
	DisplayString(IDS_I_EVERY_NOTE);
}

/*------------------------------------------------------------------------
   Name				 :DisplayREPEATHelp
   Synopsis	         :Displays help for REPEAT switch
   Type	             :Member Function 
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayREPEATHelp()
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayREPEATHelp()
{
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_REPEAT_DESC_FULL);
	DisplayString(IDS_I_USAGE);
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_REPEAT_USAGE);
	DisplayString(IDS_I_REPEAT_NOTE);

}

/*------------------------------------------------------------------------
   Name				 :DisplayFORMATHelp
   Synopsis	         :Displays help for FORMAT switch
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayTRANSLATEHelp(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayFORMATHelp(CParsedInfo& rParsedInfo)
{
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_FORMAT_DESC_FULL);
	DisplayString(IDS_I_USAGE);
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_FORMAT_USAGE);
	DisplayString(IDS_I_FORMAT_NOTE);
}

/*------------------------------------------------------------------------
   Name				 :DisplayVERBSWITCHESHelp
   Synopsis	         :Displays help on <verb switches>
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayVERBSWITCHESHelp(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayVERBSWITCHESHelp(CParsedInfo& rParsedInfo)
{
	_TCHAR *pszVerbName = rParsedInfo.GetCmdSwitchesObject().GetVerbName(); 
	BOOL bInstanceHelp = TRUE;

	if(CompareTokens(pszVerbName, CLI_TOKEN_DELETE))
	{
		if(rParsedInfo.GetCmdSwitchesObject().
							GetInteractiveMode() != INTERACTIVE)
		{
			DisplayDELETEUsage(rParsedInfo);
		}
	}

	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_USAGE);

	if(CompareTokens(pszVerbName, CLI_TOKEN_CALL) 
		|| CompareTokens(pszVerbName, CLI_TOKEN_SET)
		|| CompareTokens(pszVerbName, CLI_TOKEN_DELETE))
	{
		if(IsClassOperation(rParsedInfo))
		{
			bInstanceHelp = FALSE;
		}
		else
		{
			if(CompareTokens(pszVerbName, CLI_TOKEN_CALL))
			{
				if ( rParsedInfo.GetCmdSwitchesObject().
									GetAliasName() != NULL )
				{
					if (rParsedInfo.GetCmdSwitchesObject().
									GetWhereExpression() == NULL)
					{
						bInstanceHelp = FALSE;
					}
					else
					{
						bInstanceHelp = TRUE;
					}
				}
				else
				{
					if ((rParsedInfo.GetCmdSwitchesObject().
									GetPathExpression() != NULL)
						&& (rParsedInfo.GetCmdSwitchesObject().
									GetWhereExpression() == NULL))
					{
						bInstanceHelp = FALSE;
					}
					else
					{
						bInstanceHelp = TRUE;
					}
				}
			}
			else
			{
				bInstanceHelp = TRUE;
			}
		}
	}
	else
	{
		bInstanceHelp = FALSE;
	}
	
	if(bInstanceHelp)
	{
		DisplayString(IDS_I_VERB_INTERACTIVE_DESC1);
		DisplayString(IDS_I_VERB_INTERACTIVE_DESC2);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_PROPERTYLIST_NOTE1);
	}
	else
	{
		DisplayString(IDS_I_VERB_SWITCH_INTERACTIVE_DESC);
	}

	if(rParsedInfo.GetCmdSwitchesObject().GetInteractiveMode() != INTERACTIVE)
	{
		DisplayString(IDS_I_VERB_SWITCH_NOINTERACTIVE_DESC);
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayCOMError
   Synopsis	         :Displays the formatted COM error
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
		bToStdErr	 
				TRUE - print to STDERR (in case of GET, LIST and ASSOC)
					   though the error being XML encoded in the format
					   required.
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayCOMError(rParsedInfo, bToStdErr)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayCOMError(CParsedInfo& rParsedInfo, BOOL bToStdErr)
{
	_com_error*	pComError				= NULL;
	_TCHAR		szBuffer[BUFFER32]		= NULL_STRING;
	_bstr_t		bstrErr, bstrFacility, bstrMsg;

	
	// Get the TRACE status and store it in m_bTrace
	m_bTrace		= rParsedInfo.GetGlblSwitchesObject().GetTraceStatus();

	// Get the Logging mode (VERBOSE | ERRORONLY | NOLOGGING) and store
	// it in m_eloErrLogOpt
	m_eloErrLogOpt	= rParsedInfo.GetErrorLogObject().GetErrLogOption();

	try
	{
		//Getting the _com_error data.
		pComError = rParsedInfo.GetCmdSwitchesObject().GetCOMError();
		
		m_ErrInfo.GetErrorString(pComError->Error(), m_bTrace, 
					bstrErr, bstrFacility);

		//Printing the _com_error into a string for displaying it
		if (m_bTrace || m_eloErrLogOpt)
		{
			_stprintf(szBuffer, _T("0x%x"), pComError->Error());
			WMIFormatMessage(IDS_I_ERROR_MSG, 3, bstrMsg, szBuffer,
							(LPWSTR) bstrErr, (LPWSTR)bstrFacility);
		}
		else
		{
			WMIFormatMessage(IDS_I_ERROR_MSG_NOTRACE, 1, bstrMsg, 
						(LPWSTR)bstrErr);
		}

		if (bToStdErr)
		{
			DisplayMessage((LPWSTR) bstrMsg, CP_OEMCP, TRUE, FALSE);
		}
		else
		{
			DisplayString((LPWSTR) bstrMsg, TRUE, TRUE);
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayGlobalSwitchesBrief
   Synopsis	         :Display help for global switches in brief
   Type	             :Member Function 
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayGlobalSwitchesBrief()
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayGlobalSwitchesBrief()
{
	DisplayString(IDS_I_NAMESPACE_BRIEF);
	DisplayString(IDS_I_ROLE_BRIEF);
	DisplayString(IDS_I_NODE_BRIEF);
	DisplayString(IDS_I_IMPLEVEL_BRIEF);
	DisplayString(IDS_I_AUTHLEVEL_BRIEF);
	DisplayString(IDS_I_LOCALE_BRIEF);
	DisplayString(IDS_I_PRIVILEGES_BRIEF);
	DisplayString(IDS_I_TRACE_BRIEF);
	DisplayString(IDS_I_RECORD_BRIEF);
	DisplayString(IDS_I_INTERACTIVE_BRIEF);
	DisplayString(IDS_I_FAILFAST_BRIEF);
	DisplayString(IDS_I_USER_BRIEF);
	DisplayString(IDS_I_PASSWORD_BRIEF);
	DisplayString(IDS_I_OUTPUT_BRIEF);
	DisplayString(IDS_I_APPEND_BRIEF);
	DisplayString(IDS_I_AGGREGATE_BRIEF);
	DisplayString(IDS_I_HELPBRIEF);
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_GLBL_MORE);
}

/*------------------------------------------------------------------------
   Name				 :DisplayContext
   Synopsis	         :Displays the environment variables (i.e global 
					  switches)
   Type	             :Member Function
   Input parameter   :
		rParsedInfo	 - reference to rParsedInfo object
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :DisplayContext(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayContext(CParsedInfo& rParsedInfo)
{
	_bstr_t bstrTemp;
	// NAMESPACE
	DisplayString(IDS_I_NAMESPACE_VALUE, TRUE, 
				rParsedInfo.GetGlblSwitchesObject().GetNameSpace());

	// ROLE
	DisplayString(IDS_I_ROLE_VALUE, TRUE, 
				rParsedInfo.GetGlblSwitchesObject().GetRole());

	// NODE(S)
	rParsedInfo.GetGlblSwitchesObject().GetNodeString(bstrTemp);
	DisplayString(IDS_I_NODELIST_VALUE, TRUE, (LPWSTR)bstrTemp);

	// IMPLEVEL
	rParsedInfo.GetGlblSwitchesObject().GetImpLevelTextDesc(bstrTemp);
	DisplayString(IDS_I_IMPLEVEL_VALUE, TRUE, (LPWSTR)bstrTemp);
			
	// AUTHLEVEL
	rParsedInfo.GetGlblSwitchesObject().GetAuthLevelTextDesc(bstrTemp);
	DisplayString(IDS_I_AUTHLEVEL_VALUE, TRUE, (LPWSTR)bstrTemp);

	// LOCALE
	DisplayString(IDS_I_LOCALE_VALUE, TRUE, 
				rParsedInfo.GetGlblSwitchesObject().GetLocale());

	// PRIVILEGES
	rParsedInfo.GetGlblSwitchesObject().GetPrivilegesTextDesc(bstrTemp);
	DisplayString(IDS_I_PRIVILEGES_VALUE, TRUE, (LPWSTR)bstrTemp);

	// TRACE
	rParsedInfo.GetGlblSwitchesObject().GetTraceTextDesc(bstrTemp);
	DisplayString(IDS_I_TRACE_VALUE, TRUE, (LPWSTR)bstrTemp);

	// RECORDPATH
	rParsedInfo.GetGlblSwitchesObject().GetRecordPathDesc(bstrTemp);
	DisplayString(IDS_I_RECORDPATH_VALUE, TRUE, (LPWSTR)bstrTemp);

	// INTERACTIVE
	rParsedInfo.GetGlblSwitchesObject().GetInteractiveTextDesc(bstrTemp);
	DisplayString(IDS_I_INTERACTIVE_VALUE, TRUE, (LPWSTR)bstrTemp);

	// FAILFAST
	rParsedInfo.GetGlblSwitchesObject().GetFailFastTextDesc(bstrTemp);
	DisplayString(IDS_I_FAILFAST_VALUE, TRUE, (LPWSTR)bstrTemp);

	// TRUE for OUTPUT option.
	rParsedInfo.GetGlblSwitchesObject().GetOutputOrAppendTextDesc(bstrTemp,
																  TRUE);
	DisplayString(IDS_I_OUTPUT_VALUE, TRUE, (LPWSTR)bstrTemp);

	// FALSE for APPEND option.
	rParsedInfo.GetGlblSwitchesObject().GetOutputOrAppendTextDesc(bstrTemp,
																  FALSE);
	DisplayString(IDS_I_APPEND_VALUE, TRUE, (LPWSTR)bstrTemp);

	// USER
	rParsedInfo.GetUserDesc(bstrTemp);
	DisplayString(IDS_I_USER_VALUE, TRUE, (LPWSTR)bstrTemp);

	//AGGREGATE
	if(rParsedInfo.GetGlblSwitchesObject().GetAggregateFlag())
		DisplayString(IDS_I_AGGREGATE_VALUE, TRUE, CLI_TOKEN_ON);
	else
		DisplayString(IDS_I_AGGREGATE_VALUE, TRUE, CLI_TOKEN_OFF);
}

/*------------------------------------------------------------------------
   Name				 :DisplayContextHelp
   Synopsis	         :Displays the help on CONTEXT keyword
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :DisplayContextHelp()
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayContextHelp()
{
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_CONTEXT_DESC);
	DisplayString(IDS_I_USAGE);
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_CONTEXT_USAGE);
}
			

/*------------------------------------------------------------------------
   Name				 :ApplyTranslateTable
   Synopsis	         :Processes the translation specified in translate table.
   Type	             :Member Function
   Input parameter   :
			rParsedInfo - CParsedInfo object, input information.
   Output parameters :
			strString	- STRING type, string to be translated.
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :ApplyTranslateTable(strOutput, rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::ApplyTranslateTable(STRING& strString, 
										CParsedInfo& rParsedInfo)
{
	BSTRMAP bmTransTbl = rParsedInfo.GetCmdSwitchesObject().
								   GetAlsFrnNmsOrTrnsTblMap();
	BSTRMAP::iterator iTransTblEntry;
	for( iTransTblEntry = bmTransTbl.begin();
		  iTransTblEntry != bmTransTbl.end();iTransTblEntry++ )
	{
		_TCHAR cValue1, cValue2, cTemp;
		if ( IsValueSet((*iTransTblEntry).first, cValue1, cValue2) )
		{
			for ( cTemp = cValue1; cTemp <= cValue2 ; cTemp++)
			{
				_TCHAR szTemp[2];
				szTemp[0] = cTemp;
				szTemp[1] = _T('\0');
				FindAndReplaceAll(strString, szTemp,
									(*iTransTblEntry).second);
			}
		}
		else
		{
			FindAndReplaceAll(strString, (*iTransTblEntry).first,
										(*iTransTblEntry).second);
		}
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayInvalidProperties
   Synopsis	         :Displays the list of invalid properties
   Type	             :Member Function
   Input parameter   :
			rParsedInfo - CParsedInfo object, input information.
			bSetVerb	- SET verb
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayInvalidProperties(rParsedInfo, bSetVerb)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayInvalidProperties(CParsedInfo& rParsedInfo, 
											 BOOL bSetVerb)
{
	CHARVECTOR::iterator	cvIterator	=  NULL;
	LONG					lCount		=  0;
	_bstr_t					bstrMsg; 	

	try
	{
		// Get the list of properties.
		CHARVECTOR cvPropertyList = rParsedInfo.GetCmdSwitchesObject().
											GetPropertyList();

		// Get the property details pooled up from alias definition
		PROPDETMAP pdmPropDetMap = rParsedInfo.GetCmdSwitchesObject().
											GetPropDetMap();

		if (cvPropertyList.size() != pdmPropDetMap.size() && 
						cvPropertyList.size() != 0)
		{
			for ( cvIterator = cvPropertyList.begin(); 
				  cvIterator != cvPropertyList.end();
				  cvIterator++ )
			{
				PROPDETMAP::iterator tempIterator = NULL;
				if ( !Find(pdmPropDetMap, *cvIterator, tempIterator) )
				{
					if ( lCount == 0)
					{
						bstrMsg += _bstr_t(*cvIterator);
					}
					else
					{
						bstrMsg += _bstr_t(L", ") + _bstr_t(*cvIterator);
					}
					lCount++;
				}
			}
			DisplayString(IDS_I_NEWLINE);
			if (bSetVerb)
				DisplayString(IDS_I_INVALID_NOWRITE_PROS, 
								TRUE, (LPWSTR)bstrMsg);
			else
				DisplayString(IDS_I_INVALID_PROS, TRUE, (LPWSTR)bstrMsg);
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayLargeString
   Synopsis	         :Displays the large string line by line. And respond 
					  to Ctr+C event.	
   Type	             :Member Function
   Input parameter(s):
			rParsedInfo		- CParsedInfo object, input information.
			strLargeString	- reference to STRING object.
   Output parameter(s):None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayLargeString(rParsedInfo, stroutput)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayLargeString(CParsedInfo& rParsedInfo, 
										STRING& strLargeString)
{
	size_t	nLineStart	= 0;
	size_t	nLineEnd	= 0;

	while ( TRUE )
	{
		if ( g_wmiCmd.GetBreakEvent() == TRUE )
		{
			DisplayString(IDS_I_NEWLINE);
			break;
		}

		nLineEnd = strLargeString.find(_T("\n"), nLineStart);

		DisplayString((LPTSTR)(strLargeString.substr(
					nLineStart, (nLineEnd - nLineStart + 1)).data()));

		if ( nLineEnd != STRING::npos )
			nLineStart = nLineEnd + 1;
		else
		{
			DisplayString(IDS_I_NEWLINE);
			break;
		}
	}
}

/*------------------------------------------------------------------------
   Name				 :TraverseNode
   Synopsis	         :Travese through XML stream node by node and translate 
					  all nodes
   Type	             :Member Function
   Input parameter   :
			rParsedInfo - CParsedInfo object, input information.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :TraverseNode(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CFormatEngine::TraverseNode(CParsedInfo& rParsedInfo)
{
	HRESULT					hr					= S_OK;
	IXMLDOMElement			*pIXMLDOMElement	= NULL;
	IXMLDOMNodeList			*pIDOMNodeList		= NULL;
	IXMLDOMNode				*pIDOMNode			= NULL;
	IXMLDOMNode				*pIParentNode		= NULL;
	IXMLDOMNode				*pINewNode			= NULL;
	LONG					lValue				= 0;
	BSTR					bstrItemText		= NULL;
	BOOL					bRet				= TRUE;
	DWORD					dwThreadId			= GetCurrentThreadId();
	try
	{
		if(m_pIXMLDoc != NULL)
		{
			_bstr_t bstrTemp = rParsedInfo.GetCmdSwitchesObject().
									GetXMLResultSet();
	
			// Load the	XML stream 
			VARIANT_BOOL varBool;
			hr = m_pIXMLDoc->loadXML(bstrTemp, &varBool);
			if (m_bTrace || m_eloErrLogOpt)
			{
				WMITRACEORERRORLOG(hr, __LINE__, 
						__FILE__, _T("IXMLDOMDocument::loadXML(-, -)"), 
						dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);
			
			if(varBool == VARIANT_TRUE)
			{
				// Get the document element.
				hr = m_pIXMLDoc->get_documentElement(&pIXMLDOMElement);
				if (m_bTrace || m_eloErrLogOpt)
				{
					WMITRACEORERRORLOG(hr, __LINE__, 
					__FILE__, _T("IXMLDOMDocument::get_documentElement(-)"), 
					dwThreadId, rParsedInfo, m_bTrace);
				}
				ONFAILTHROWERROR(hr);

				if (pIXMLDOMElement != NULL)
				{
					// Get the Node List named <VALUE> in the current XML doc
					hr = pIXMLDOMElement->getElementsByTagName
							(_bstr_t(L"VALUE"), &pIDOMNodeList);
					if (m_bTrace || m_eloErrLogOpt)
					{
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
							_T("IXMLDOMElement::getElementsByTagName"
							L"(L\"VALUE\", -)"), dwThreadId, rParsedInfo, 
							m_bTrace);
					}
					ONFAILTHROWERROR(hr);
					 
					// Get the length of the node list
					hr	= pIDOMNodeList->get_length(&lValue);
					if (m_bTrace || m_eloErrLogOpt)
					{
						WMITRACEORERRORLOG(hr, __LINE__, 
							__FILE__, _T("IXMLDOMNodeList::get_length(-)"), 
							dwThreadId, rParsedInfo, m_bTrace);
					}
					ONFAILTHROWERROR(hr);

					// Traverse through full node list and apply 
					// translate table on  each node
					for(int ii = 0; ii < lValue; ii++)
					{
						// Get a node from node list
						hr = pIDOMNodeList->get_item(ii, &pIDOMNode);
						if (m_bTrace || m_eloErrLogOpt)
						{
							WMITRACEORERRORLOG(hr, __LINE__, 
								__FILE__, _T("IXMLDOMNodeList::get_item(-,-)"), 
								dwThreadId, rParsedInfo, m_bTrace);
						}
						ONFAILTHROWERROR(hr);

						if (pIDOMNode == NULL)
							continue;

						// Get the value stored in the node
						hr = pIDOMNode->get_text(&bstrItemText);
						if (m_bTrace || m_eloErrLogOpt)
						{
							WMITRACEORERRORLOG(hr, __LINE__, 
								__FILE__, _T("IXMLDOMNode::get_text(-)"), 
								dwThreadId, rParsedInfo, m_bTrace);
						}
						ONFAILTHROWERROR(hr);

						// Get the parent node of the current node to store 
						// the  translated value in the current node
						hr = pIDOMNode->get_parentNode(&pIParentNode);
						if (m_bTrace || m_eloErrLogOpt)
						{
							WMITRACEORERRORLOG(hr, __LINE__, 
								__FILE__, _T("IXMLDOMNode::get_parentNode(-)"), 
								dwThreadId, rParsedInfo, m_bTrace);
						}
						ONFAILTHROWERROR(hr);

						// Create a clone node of current node
						VARIANT_BOOL vBool = VARIANT_FALSE;
						hr = pIDOMNode->cloneNode(vBool, &pINewNode);
						if (m_bTrace || m_eloErrLogOpt)
						{
							WMITRACEORERRORLOG(hr, __LINE__, 
								__FILE__, _T("IXMLDOMNode::cloneNode(-,-)"), 
								dwThreadId, rParsedInfo, m_bTrace);
						}
						ONFAILTHROWERROR(hr);

						if (pINewNode != NULL && pIParentNode != NULL)
						{
							// If /TRANSLATE:<table> is specified.
							STRING strOutput((_TCHAR*)bstrItemText);
							if ( rParsedInfo.GetCmdSwitchesObject().
											GetTranslateTableName() != NULL )
							{
								// Translate the result 
								ApplyTranslateTable(strOutput, rParsedInfo);
							}

							// Reconvert the char string into BSTR string
							_bstr_t bstrTemp = 
										_bstr_t((LPTSTR)strOutput.data());

							// Write the translated value into new node
							hr = pINewNode->put_text(bstrTemp);
							if (m_bTrace || m_eloErrLogOpt)
							{
								WMITRACEORERRORLOG(hr, __LINE__, 
								__FILE__, _T("IXMLDOMNode::put_text(-)"), 
								dwThreadId, rParsedInfo, m_bTrace);
							}
							ONFAILTHROWERROR(hr);

							// Replace current node with translated node 
							hr = pIParentNode->replaceChild(pINewNode, 
											pIDOMNode, NULL);
							if (m_bTrace || m_eloErrLogOpt)
							{
								WMITRACEORERRORLOG(hr, __LINE__, 
								__FILE__, 
								_T("IXMLDOMNode::replaceChild(-,-,-)"), 
								dwThreadId, rParsedInfo, m_bTrace);
							}
							ONFAILTHROWERROR(hr);
						}

						SAFEBSTRFREE(bstrItemText);
						bstrItemText = NULL;
						SAFEIRELEASE(pINewNode);
						SAFEIRELEASE(pIParentNode);
						SAFEIRELEASE(pIDOMNode);
					}
					SAFEIRELEASE(pIDOMNodeList);
					SAFEIRELEASE(pIXMLDOMElement);
					bRet = TRUE;
				}
			}
			else
				bRet = FALSE;
		}
		else
			bRet = FALSE;
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIParentNode);
		SAFEIRELEASE(pINewNode);
		SAFEIRELEASE(pIDOMNode);
		SAFEIRELEASE(pIDOMNodeList);
		SAFEIRELEASE(pIXMLDOMElement);
		SAFEBSTRFREE(bstrItemText);
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bRet = FALSE;
	}
	return bRet;
}

/*------------------------------------------------------------------------
Name			  :DisplayRESULTCLASSHelp
Synopsis	      :Displays help for RESULT CLASS  switch
Type	          :Member Function 
Input parameter   :None
Output parameters :None
Return Type       :void
Global Variables  :None
Calling Syntax    :DisplayRESULTCLASSHelp()
Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayRESULTCLASSHelp()
{
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_RESULTCLASS_DESC_FULL);
	DisplayString(IDS_I_USAGE);
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_RESULTCLASS_USAGE);
}

/*------------------------------------------------------------------------
   Name				 :DisplayRESULTROLEHelp
   Synopsis	         :Displays help for RESULT ROLE  switch
   Type	             :Member Function 
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayRESULTROLEHelp()
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayRESULTROLEHelp()
{
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_RESULTROLE_DESC_FULL );
	DisplayString(IDS_I_USAGE);
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_RESULTROLE_USAGE);	
}
/*------------------------------------------------------------------------
   Name				 :DisplayASSOCCLASSHelp
   Synopsis	         :Displays help for ASSOCCLASS switch
   Type	             :Member Function 
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayASSOCCLASSHelp()
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayASSOCCLASSHelp()
{
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_ASSOCCLASS_DESC_FULL);
	DisplayString(IDS_I_USAGE);
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_ASSOCCLASS_USAGE);	
}


/*------------------------------------------------------------------------
   Name				 :AppendtoOutputString
   Synopsis	         :Appends the content currently being displayed, to the
					  m_bstrOutput which will be used for XML logging
   Type	             :Member Function 
   Input parameter   :
		pszOutput  - output string
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :AppendtoOutputString(pszOutput)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::AppendtoOutputString(_TCHAR* pszOutput)
{
	m_bstrOutput += pszOutput;
}

/*------------------------------------------------------------------------
   Name				 :DoCascadeTransforms
   Synopsis	         :Does cascading transforms on the XML output obtained
					  as result (the intermediate transforms should data
					  which is DOM compliant)
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo object
   Output parameters :
		bstrOutput	 - transformed output
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :DoCascadeTransforms(rParsedInfo, bstrOutput)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CFormatEngine::DoCascadeTransforms(CParsedInfo& rParsedInfo,
										_bstr_t& bstrOutput)
{
	HRESULT				hr					= S_OK;
	IXMLDOMDocument2	*pIStyleSheet		= NULL;
	IXMLDOMDocument2	*pIObject			= NULL;
	IXSLTemplate		*pITemplate			= NULL;
	IXSLProcessor		*pIProcessor		= NULL;
	VARIANT				varValue;
	VariantInit(&varValue);
	VARIANT_BOOL		varLoad				= VARIANT_FALSE;
	XSLTDETVECTOR		vecXSLDetails;
	XSLTDETVECTOR::iterator vecEnd			= NULL,
						vecIterator			= NULL;

	BSTRMAP::iterator	mapItrtr			= NULL,
						mapEnd				= NULL;

	BOOL				bFirst				= TRUE;
	DWORD				dwCount				= 0;
	DWORD				dwSize				= 0;
	BOOL				bRet				= TRUE;
	CHString			chsMsg;
	DWORD				dwThreadId			= GetCurrentThreadId();

	vecXSLDetails = rParsedInfo.GetCmdSwitchesObject().GetXSLTDetailsVector();
	try
	{
		// Create single instance of the IXSLTemplate
		hr = CoCreateInstance(CLSID_XSLTemplate, NULL, CLSCTX_SERVER, 
				IID_IXSLTemplate, (LPVOID*)(&pITemplate));
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"CoCreateInstance(CLSID_XSLTemplate, NULL,"
					 L" CLSCTX_SERVER, IID_IXSLTemplate, -)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
					dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);
		
		if (pITemplate)
		{
			vecIterator = vecXSLDetails.begin();
			vecEnd		= vecXSLDetails.end();
			dwSize		= vecXSLDetails.size();

			// Loop thru the list of cascading transforms specified.
			while (vecIterator != vecEnd)
			{
				// Create single instance of IXMLDOMDocument2
				hr = CoCreateInstance(CLSID_FreeThreadedDOMDocument, NULL,
							CLSCTX_SERVER, IID_IXMLDOMDocument2, 
							(LPVOID*) (&pIStyleSheet));
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"CoCreateInstance("
						L"CLSID_FreeThreadedDOMDocument, NULL, CLSCTX_SERVER,"
						L"IID_IXMLDOMDocument2, -)");
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							dwThreadId, rParsedInfo, m_bTrace);
				}
				ONFAILTHROWERROR(hr);
	
				if (pIStyleSheet)
				{
					hr = pIStyleSheet->put_async(VARIANT_FALSE);
					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(L"IXSLDOMDocument2::put_async("
						L"VARIANT_FALSE)");
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
						 (LPCWSTR)chsMsg, dwThreadId, rParsedInfo, m_bTrace);
					}
					ONFAILTHROWERROR(hr);

					dwCount++;
											
					// Load the transform document (xsl)
					hr = pIStyleSheet->load(_variant_t((*vecIterator)
											.FileName), &varLoad);
					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(L"IXSLDOMDocument2::load("
						L"L\"%s\", -)", (WCHAR*)(*vecIterator).FileName);

						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
						 (LPCWSTR)chsMsg, dwThreadId, rParsedInfo, m_bTrace);
					}
					ONFAILTHROWERROR(hr);

					if (varLoad == VARIANT_TRUE)
					{
						// Add the reference of the stylesheet to the 
						// IXSLTemplate object
						hr = pITemplate->putref_stylesheet(pIStyleSheet);
						if (m_bTrace || m_eloErrLogOpt)
						{
							chsMsg.Format(L"IXSTemplate::putref_stylesheet("
							L"-)");
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
								(LPCWSTR)chsMsg, dwThreadId, 
								rParsedInfo, m_bTrace);
						}
						ONFAILTHROWERROR(hr);

						// Create the processor object
						hr = pITemplate->createProcessor(&pIProcessor);
						if (m_bTrace || m_eloErrLogOpt)
						{
							chsMsg.Format(L"IXSTemplate::createProcessor("
							L"-)");
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__,
								(LPCWSTR)chsMsg, dwThreadId, 
								rParsedInfo, m_bTrace);
						}
						ONFAILTHROWERROR(hr);

						if (pIProcessor)
						{
							// If parameters are specified
							if ((*vecIterator).ParamMap.size())
							{
								// Add the list of parameters specified to the
								// IXSLProcessor  interface object
								hr = AddParameters(rParsedInfo, pIProcessor, 
											(*vecIterator).ParamMap);
								ONFAILTHROWERROR(hr);
							}
							// If first tranformation, then feed the XML data
							// loaded into m_pIXMLDoc for transformation
							if (bFirst)
							{
								hr = pIProcessor->put_input(
													_variant_t(m_pIXMLDoc));
								bFirst = FALSE;
							}
							else
							{
								// Intermediate transformation - load the 
								// result data obtained in previous 
								// transformation
								hr = pIProcessor->put_input(
													_variant_t(pIObject));
							}
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(L"IXSProcessor::put_input("
								L"-)");
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
									(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, 
									m_bTrace);
							}
							ONFAILTHROWERROR(hr);
							
							// Transform the content
							hr = pIProcessor->transform(&varLoad);
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(L"IXSProcessor::tranform("
								L"-)");
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
									(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, 
									m_bTrace);
							}
							ONFAILTHROWERROR(hr);

							if (varLoad == VARIANT_TRUE)
							{
								// Retrieve the output
								hr = pIProcessor->get_output(&varValue);
								if (m_bTrace || m_eloErrLogOpt)
								{
									chsMsg.Format(L"IXSProcessor::"
										L"get_output(-)");
									WMITRACEORERRORLOG(hr, __LINE__, __FILE__,
									 (LPCWSTR)chsMsg, dwThreadId, rParsedInfo, 
									 m_bTrace);
								}
								ONFAILTHROWERROR(hr);

								// intermediate transform
								if (dwCount != dwSize)
								{
									if (pIObject == NULL)
									{
										hr = CoCreateInstance(CLSID_DOMDocument,
												NULL, CLSCTX_SERVER, 
												IID_IXMLDOMDocument2, 
												(LPVOID*)(&pIObject));
										if (m_bTrace || m_eloErrLogOpt)
										{
											chsMsg.Format(L"CoCreateInstance("
												L"CLSID_DOMDocument, NULL,"
												L" CLSCTX_INPROC_SERVER, "
												L"IID_IXMLDOMDocument2, -)");
											WMITRACEORERRORLOG(hr, __LINE__, 
												__FILE__, (LPCWSTR)chsMsg, 
												dwThreadId, rParsedInfo, 
												m_bTrace);
										}
										ONFAILTHROWERROR(hr);
									}	
	
									hr = pIObject->loadXML(
											varValue.bstrVal, &varLoad);
									if (m_bTrace || m_eloErrLogOpt)
									{
										chsMsg.Format(L"IXMLDOMDocument2::"
											L"loadXML(-, -)");
										WMITRACEORERRORLOG(hr, __LINE__, 
										__FILE__, (LPCWSTR)chsMsg, dwThreadId, 
										rParsedInfo, m_bTrace);
									}
									ONFAILTHROWERROR(hr);
								
									if (varLoad == VARIANT_FALSE)
									{
										// Invalid XML content.
										rParsedInfo.GetCmdSwitchesObject().
										SetErrataCode(
											IDS_E_INVALID_XML_CONTENT);
										bRet = FALSE;
										break;
									}
								}
								// last transform - print the result.
								else
								{
									bstrOutput = _bstr_t(varValue);
								}
								VariantClear(&varValue);
							}
							SAFEIRELEASE(pIProcessor);
						}
					}
					else
					{
						// Invalid XSL format.
						rParsedInfo.GetCmdSwitchesObject()
								.SetErrataCode(IDS_E_INVALID_FORMAT);
						bRet = FALSE;
						break;
					}
					SAFEIRELEASE(pIStyleSheet);
				}
				vecIterator++;
			}
			SAFEIRELEASE(pIProcessor);
			SAFEIRELEASE(pITemplate);
			SAFEIRELEASE(pIObject);
			SAFEIRELEASE(pITemplate);
		}
	}
	catch(_com_error& e)
	{
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		VariantClear(&varValue);
		SAFEIRELEASE(pIProcessor);
		SAFEIRELEASE(pIStyleSheet);
		SAFEIRELEASE(pITemplate);
		SAFEIRELEASE(pIObject);
		bRet = FALSE;
	}
	//trap for CHeap_Exception
	catch(CHeap_Exception)
	{
		VariantClear(&varValue);
		SAFEIRELEASE(pIProcessor);
		SAFEIRELEASE(pIStyleSheet);
		SAFEIRELEASE(pITemplate);
		SAFEIRELEASE(pIObject);
		bRet = FALSE;
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :AddParameters
   Synopsis	         :Adds parameters to the IXSLProcessor object
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo object
		pIProcessor  - IXSLProcessor object
		bstrmapParam - parameter map
   Output parameters :None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :AddParameters(rParsedInfo, pIProcessor, bstrmapParam)
   Notes             :None
------------------------------------------------------------------------*/
HRESULT	CFormatEngine::AddParameters(CParsedInfo& rParsedInfo,
									 IXSLProcessor	*pIProcessor, 
									 BSTRMAP bstrmapParam)
{
	HRESULT				hr					= S_OK;
	BSTRMAP::iterator	mapItrtr			= NULL,
						mapEnd				= NULL;
	_bstr_t				bstrProp,
						bstrVal;	
	CHString			chsMsg;
	DWORD				dwThreadId			= GetCurrentThreadId();
	try
	{
		mapItrtr	= bstrmapParam.begin();
		mapEnd		= bstrmapParam.end();	

		// Loop thru the available parameters
		while (mapItrtr != mapEnd)
		{
			bstrProp = (*mapItrtr).first;
			bstrVal	 = (*mapItrtr).second;

			// Add the parameter to the IXSLProcessor 
			hr = pIProcessor->addParameter(bstrProp, _variant_t(bstrVal));
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IXSProcessor::addParameter(L\"%s\", -)",
								(WCHAR*) bstrProp);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
					dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);
			mapItrtr++;
		}
	}
	catch(_com_error& e)
	{
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\execengine.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: ExecEngine.cpp 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This class encapsulates the functionality of    
							  Execution Engine. Obtains the needed information
							  from CGlobalSwitches and CCommandSwitches of 
							  CParsedInfo and executes needed WMI operations.
							  The result is sent to Format Engine via 
							  CGlobalSwitches and CCommandSwicthes 
							  of CParsedInfo.
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 20th-March-2001
****************************************************************************/ 

// include files
#include "Precomp.h"
#include "GlobalSwitches.h"
#include "CommandSwitches.h"
#include "HelpInfo.h"
#include "ErrorLog.h"
#include "ParsedInfo.h"
#include "ErrorInfo.h"
#include "WmiCliXMLLog.h"
#include "FormatEngine.h"
#include "CmdTokenizer.h"
#include "CmdAlias.h"
#include "ParserEngine.h"
#include "ExecEngine.h"
#include "WmiCmdLn.h"

/*------------------------------------------------------------------------
   Name				  :CExecEngine
   Synopsis	          :Constructor, This function initializes the necessary
					  member variables. 	
   Type	              :Constructor 
   Input Parameter(s) :None
   Output Parameter(s):None
   Return Type		  :None
   Global Variables   :None
   Calling Syntax     :None
   Notes              :None
------------------------------------------------------------------------*/
CExecEngine::CExecEngine()
{
	m_pITextSrc		= NULL;
	m_pIWbemLocator = NULL;
	m_pITargetNS	= NULL;
	m_pIContext		= NULL;
	m_bTrace		= FALSE;
	m_bNoAssoc		= FALSE;
}

/*------------------------------------------------------------------------
   Name				  :~CExecEngine
   Synopsis	          :Destructor, This function call Uninitialize() which 
					  frees memory held by the object. 	
   Type	              :Destructor
   Input Parameter(s) :None
   Output Parameter(s):None
   Return Type        :None
   Global Variables   :None
   Calling Syntax     :None
   Notes              :None
------------------------------------------------------------------------*/
CExecEngine::~CExecEngine()
{
	SAFEIRELEASE(m_pITextSrc);
	SAFEIRELEASE(m_pIContext);
	SAFEIRELEASE(m_pIWbemLocator);
	Uninitialize();
}

/*------------------------------------------------------------------------
   Name				  :Uninitialize
   Synopsis	          :This function uninitializes the member variables. 
   Type	              :Member Function
   Input Parameter(s):
			bFinal	- boolean value which when set indicates that the 
					  program
   Output Parameter(s):None
   Return Type        :void 
   Global Variables   :None
   Calling Syntax     :Uninitialize()
   Notes              :None
------------------------------------------------------------------------*/
void CExecEngine::Uninitialize(BOOL bFinal)
{
	SAFEIRELEASE(m_pITargetNS);
	m_bTrace		= FALSE;
	m_eloErrLogOpt	= NO_LOGGING;
	m_bNoAssoc		= FALSE;
	if (bFinal)
	{
		SAFEIRELEASE(m_pITextSrc);
		SAFEIRELEASE(m_pIContext);
		SAFEIRELEASE(m_pIWbemLocator);
	}
}

/*------------------------------------------------------------------------
   Name				 :SetLocatorObject
   Synopsis	         :Sets the locator object passed via parameter to member 
					  of the class.
   Type	             :Member Function
   Input Parameter(s):
	   pILocator - Pointer to IWbemLocator
   Output Parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetLocatorObject(pILocator)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::SetLocatorObject(IWbemLocator* pILocator)
{
	static BOOL bFirst = TRUE;
	BOOL bRet = TRUE;
	if (bFirst)
	{
		if (pILocator != NULL)
		{
			SAFEIRELEASE(m_pIWbemLocator);
			m_pIWbemLocator = pILocator;
			m_pIWbemLocator->AddRef();
		}
		else
			bRet = FALSE;
		bFirst = FALSE;
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :ExecuteCommand
   Synopsis	         :Executes the command referring to information 
					  available with the CParsedInfo object.
					  Stores the results in the CParsedInfo object.
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ExecuteCommand(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::ExecuteCommand(CParsedInfo& rParsedInfo)
{
	BOOL			bRet			= TRUE;
	HRESULT			hr				= S_OK;
	_TCHAR			*pszVerb		= NULL;
	BOOL			bContinue		= TRUE;
	DWORD			dwThreadId		= GetCurrentThreadId();
	try
	{

		// Obtain the TRACE flag
		m_bTrace = rParsedInfo.GetGlblSwitchesObject().GetTraceStatus();

		// Obtain the Logging mode
		m_eloErrLogOpt = rParsedInfo.GetErrorLogObject().GetErrLogOption();

		// Enable|Disable the privileges
		hr = ModifyPrivileges(rParsedInfo.GetGlblSwitchesObject().
												GetPrivileges());
		if ( m_eloErrLogOpt )
		{
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
				_T("ModifyPrivileges(-)"), dwThreadId,	rParsedInfo, FALSE);
		}
		ONFAILTHROWERROR(hr);
		

		// Obtian the verb name
		pszVerb = rParsedInfo.GetCmdSwitchesObject().GetVerbName();

		if (pszVerb != NULL)
		{
			// If GET | LIST verb is specified.
			if (CompareTokens(pszVerb, CLI_TOKEN_GET) || 
				CompareTokens(pszVerb, CLI_TOKEN_LIST))
			{
				bRet = ProcessSHOWInfo(rParsedInfo);
			}
			// If SET verb is specified.
			else if (CompareTokens(pszVerb, CLI_TOKEN_SET))
			{
				bRet = ProcessSETVerb(rParsedInfo);
			}
			// If CALL verb is specified.
			else if (CompareTokens(pszVerb, CLI_TOKEN_CALL))
			{
				bRet = ProcessCALLVerb(rParsedInfo);
			}
			// If ASSOC verb is specified.
			else if (CompareTokens(pszVerb, CLI_TOKEN_ASSOC))
			{
				bRet = ProcessASSOCVerb(rParsedInfo);
			}
			// If CREATE verb is specified.
			else if (CompareTokens(pszVerb, CLI_TOKEN_CREATE))
			{
				bRet = ProcessCREATEVerb(rParsedInfo);
			}
			// If DELETE verb is specified.
			else if (CompareTokens(pszVerb, CLI_TOKEN_DELETE))
			{
				bRet = ProcessDELETEVerb(rParsedInfo);
			}
			// If user defined verb is specified.
			else
				bRet = ProcessCALLVerb(rParsedInfo);
		} 
		// If no verb is specified, (default behavior is assumed to be that of
		// GET i.e a command like 'w class Win32_Process' go ahead with 
		// displaying the instance information.
		else 
		{
			if (rParsedInfo.GetCmdSwitchesObject().
								SetVerbName(_T("GET")))
			{
				bRet = ProcessSHOWInfo(rParsedInfo);
			}
			else
				bRet = FALSE;
		}
	}
	catch(_com_error& e)
	{
		// To check unhandled exceptions thrown by _bstr_t objects etc..
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bRet = FALSE;
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :ObtainXMLResultSet
   Synopsis	         :Executes query and obtain the result in XML file format. 
					  Refers data in the CCommnadSwicthes object of 
					  CParsedInfo object. 
   Type	             :Member Function
   Input Parameter(s):
		bstrQuery    - WQL query 
		rParsedInfo  - reference to CParsedInfo class object
		bstrXML		 - reference to XML result set obtained
		bSysProp	 - boolean flag indicating the presence of system 
					   properties.
		bNotAssoc	 - boolean flag indicating whether the query cotains
						ASSOCIATORS OF {xxxx} (or) SELECT * FROM xxx form.
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :ObtainXMLResultSet(bstrQuery, rParsedInfo, bstrXML,
						bSysProp, bNotAssoc);
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CExecEngine::ObtainXMLResultSet(BSTR bstrQuery,
									    CParsedInfo& rParsedInfo,
										_bstr_t& bstrXML,
										BOOL bSysProp,
										BOOL bNotAssoc)
{
	IWbemClassObject		*pIObject			= NULL;
	HRESULT					hr					= S_OK;
	IEnumWbemClassObject	*pIEnum				= NULL;
	ULONG					ulReturned			= 0;
	BSTR					bstrInstXML			= NULL;
	BOOL					bInstances			= FALSE;
	CHString				chsMsg;
	DWORD					dwThreadId			= GetCurrentThreadId();
	VARIANT					vSystem;
	
	try
	{
		VariantInit(&vSystem);
		if ( g_wmiCmd.GetBreakEvent() == FALSE )
		{
			// Add the <CIM> or <ASSOC.OBJECTARRAY> to the beginning of the 
			// XML result. This is to facilitate storing of mutiple object 
			// instances information.
			bstrXML		=  (bNotAssoc) ? MULTINODE_XMLSTARTTAG : 
							MULTINODE_XMLASSOCSTAG1;

			// Create the IWbemContext object, used for suppressing
			// the system properties.
			if (m_pIContext == NULL)
			{
				hr = CreateContext(rParsedInfo);
				if ( m_eloErrLogOpt )
				{
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
						_T("CreateContext(rParsedInfo)"), dwThreadId, 
						rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);
			}

			// Execute the WQL query
			// WBEM_FLAG_FORWARD_ONLY flag Increases the speed of execution
			// WBEM_FLAG_RETURN_IMMEDIATELY flag makes semisynchronous call
			// Setting these flags in combination saves time, space, and
			// improves responsiveness.enumerators can be polled for the
			// results of the call.
			hr = m_pITargetNS->ExecQuery(_bstr_t(L"WQL"), bstrQuery, 
										WBEM_FLAG_FORWARD_ONLY |
										WBEM_FLAG_RETURN_IMMEDIATELY, 
										NULL, &pIEnum); 
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemServices::ExecQuery(L\"WQL\", L\"%s\", "
							L"0, NULL, -)", (LPWSTR) bstrQuery);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
					dwThreadId,	rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			// If no system properties are specified adjust the context to 
			// filter out the system properties.
			vSystem.vt		= VT_BOOL;
			
			// Filterout the system properties.
			if (!bSysProp)
				vSystem.boolVal = VARIANT_TRUE;
			// Don't filter the system properties.
			else
				vSystem.boolVal = VARIANT_FALSE;

			hr = m_pIContext->SetValue(_bstr_t(EXCLUDESYSPROP), 0, &vSystem);
			if (m_bTrace || m_eloErrLogOpt)
			{
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
					 _T("IWbemContext::SetValue(L\"ExcludeSystemProperties\","
					 L"0, -)"), dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);
			VARIANTCLEAR(vSystem);

			// Set the interface level security for the IEnumWbemClass object.
			hr = SetSecurity(pIEnum, 
					 rParsedInfo.GetGlblSwitchesObject().GetAuthority(),
					 rParsedInfo.GetNode(),
					 rParsedInfo.GetUser(),
					 rParsedInfo.GetPassword(),
					 rParsedInfo.GetGlblSwitchesObject().
							GetAuthenticationLevel(),
					 rParsedInfo.GetGlblSwitchesObject().
							GetImpersonationLevel());
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"CoSetProxyBlanket(-, RPC_C_AUTHN_WINNT,"
						L"RPC_C_AUTHZ_NONE, NULL, %d,   %d, -, EOAC_NONE)",
						rParsedInfo.GetGlblSwitchesObject().
							GetAuthenticationLevel(),
						rParsedInfo.GetGlblSwitchesObject().
							GetImpersonationLevel());
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
						dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			// Loop through the available instances 
			hr = pIEnum->Next(WBEM_INFINITE, 1, &pIObject, &ulReturned);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IEnumWbemClassObject->Next"
					L"(WBEM_INFINITE, 1, -, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
					dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);
			while(ulReturned == 1)
			{
				// Set the instances flag to TRUE
				bInstances = TRUE;

				// Call the IWbemObjectTextSrc::GetText method, with 
				// IWbemClassObject as one of the arguments.
				hr = m_pITextSrc->GetText(0, pIObject, 
						WMI_OBJ_TEXT_CIM_DTD_2_0, m_pIContext, &bstrInstXML);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemObjectTextSrc::GetText(0, -, "
							L"WMI_OBJECT_TEXT_CIM_DTD_2_0, -, -)");
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,
						(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, m_bTrace);
				}
				ONFAILTHROWERROR(hr);

				// Associators should be handled separately
				if (bNotAssoc == FALSE)
				{
					// Append the XML node to the XML nodes stream
					bstrXML = bstrXML + _bstr_t(MULTINODE_XMLASSOCSTAG2) + 
						 + bstrInstXML + _bstr_t(MULTINODE_XMLASSOCETAG2);
				}
				else
				{
					// Append the XML node to the XML nodes stream
					bstrXML +=  bstrInstXML;
				}

				// Release the memory allocated for bstrInstXML
				SAFEBSTRFREE(bstrInstXML);

				SAFEIRELEASE(pIObject);

				// if break event occurs then terminate the session
				if ( g_wmiCmd.GetBreakEvent() == TRUE )
					break;

				// Move to next instance in the enumeration.
				hr = pIEnum->Next(WBEM_INFINITE, 1, &pIObject, &ulReturned);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(
						L"IEnumWbemClassObject->Next(WBEM_INFINITE, 1, -, -)");
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
						dwThreadId, rParsedInfo, m_bTrace);
				}
				ONFAILTHROWERROR(hr);
			}

			// If instances are available
			if (bInstances)
			{
				// Add the </CIM> or </ASSOC.OBJECTARRAY> at the end.
				bstrXML += (bNotAssoc) ? MULTINODE_XMLENDTAG : 
							MULTINODE_XMLASSOCETAG1;

				// if no break event occured then only set the 
				// xml result set
				if ( g_wmiCmd.GetBreakEvent() == FALSE )
				{
					if (bNotAssoc)
					{
						// Store the XML result set
						rParsedInfo.GetCmdSwitchesObject().
								SetXMLResultSet(bstrXML);
						bstrXML = L"";
					}
				}
			}
			// no instances
			else 
			{
				bstrXML = L"<ERROR>";
				_bstr_t bstrMsg;
				WMIFormatMessage((bNotAssoc) ? 
								IDS_I_NO_INSTANCES : IDS_I_NO_ASSOCIATIONS,
								0, bstrMsg, NULL);

				if (bNotAssoc)
				{
					DisplayMessage((LPWSTR)bstrMsg, CP_OEMCP, TRUE, TRUE);
				}
				else
				{
					m_bNoAssoc = TRUE;
				}
				CHString sTemp;
				sTemp.Format(_T("<DESCRIPTION>%s</DESCRIPTION>"),
							(LPWSTR) bstrMsg);
				
				bstrXML += _bstr_t(sTemp);
				bstrXML += L"</ERROR>";

				if (bNotAssoc)
				{
					// Store the XML result set
					rParsedInfo.GetCmdSwitchesObject().
							SetXMLResultSet(bstrXML);
					bstrXML = L"";
				}
			}
			SAFEIRELEASE(pIEnum);
		}
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIObject);
		SAFEIRELEASE(pIEnum);
		SAFEBSTRFREE(bstrInstXML);	
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		hr = e.Error();
	}
	//trap for CHeap_Exception
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIObject);
		SAFEIRELEASE(pIEnum);
		SAFEBSTRFREE(bstrInstXML);	
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return hr;
}

/*------------------------------------------------------------------------
   Name				 :ExecWMIMethod
   Synopsis	         :Executes a WMI method referring to the information
					  available with CParsedInfo object.
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
   		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ExecWMIMethod(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::ExecWMIMethod(CParsedInfo& rParsedInfo)
{
	HRESULT					hr					= S_OK;
	IWbemClassObject		*pIClassObj			= NULL,
							*pIInSign			= NULL, 
							*pIOutSign			= NULL,
							*pIInParam			= NULL;
	SAFEARRAY				*psaNames			= NULL;
	BSTR					bstrInParam			= NULL;
	BOOL					bContinue			= TRUE,
							bRet				= TRUE,
							bMethodDtls			= FALSE;
	CHString				chsMsg;
	DWORD					dwThreadId			= GetCurrentThreadId();
	CHARVECTOR::iterator	cviUnnamedValue		= NULL;
	BSTRMAP::iterator		bmiNamedValue		= NULL;
	VARIANT					varPut, 
							varGet, 
							varTemp;
	PROPDETMAP				pdmPropDetMap;
	PROPDETMAP::iterator	itrPropDetMap;
	VariantInit(&varPut);
	VariantInit(&varGet);
	VariantInit(&varTemp);

	METHDETMAP				mdmMethDet;
	METHDETMAP::iterator	mdmIterator		= NULL;
	mdmMethDet = rParsedInfo.GetCmdSwitchesObject().GetMethDetMap();

	try
	{
		_bstr_t					bstrClassName("");
		// Obtain the parameter details.
		if (!mdmMethDet.empty())
		{
			mdmIterator = mdmMethDet.begin();
			pdmPropDetMap = (*mdmIterator).second.Params;
			bMethodDtls = TRUE;
		}

		// Obtain the WMI class name 
		
		// If <alias> is not specified
		if (rParsedInfo.GetCmdSwitchesObject().GetClassPath() != NULL)
		{
			bstrClassName = _bstr_t(rParsedInfo.GetCmdSwitchesObject().
							GetClassPath());
		}
		// If <alias> specified
		else
		{
			rParsedInfo.GetCmdSwitchesObject().
							GetClassOfAliasTarget(bstrClassName);
		}

		// Obtain the object schema.
		hr = m_pITargetNS->GetObject(bstrClassName, 
							WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL, 
							&pIClassObj, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", 0, NULL, -)", 
					(LPWSTR) bstrClassName);		
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
					dwThreadId,	rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Get method information
		hr = pIClassObj->GetMethod(_bstr_t(rParsedInfo.GetCmdSwitchesObject()
				.GetMethodName()), 0, &pIInSign, &pIOutSign); 

		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemClassObject::GetMethod(L\"%s\", 0, -, -)", 
					rParsedInfo.GetCmdSwitchesObject().GetMethodName() ?
					rParsedInfo.GetCmdSwitchesObject().GetMethodName() 
					: L"<null>");		
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
					dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		if ( pIInSign != NULL )
		{
			// Spawn object instance.
			hr = pIInSign->SpawnInstance(0, &pIInParam);
			if ( m_eloErrLogOpt )
			{
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
					_T("IWbemClassObject::SpawnInstance(0, -)"), dwThreadId, 
					rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			CHARVECTOR cvInParams = 
				rParsedInfo.GetCmdSwitchesObject().GetPropertyList();
			BSTRMAP bmParameterMap =
				rParsedInfo.GetCmdSwitchesObject().GetParameterMap();

			// If parameter list is TRUE
			if (!cvInParams.empty() || !bmParameterMap.empty())
			{
				// Get the input paramters for this method from the input 
				// signature object.
				hr = pIInSign->GetNames(NULL, 
								WBEM_FLAG_ALWAYS | WBEM_FLAG_NONSYSTEM_ONLY, 
								NULL, 
								&psaNames);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::GetNames(NULL, "
							L"WBEM_FLAG_ALWAYS | WBEM_FLAG_NONSYSTEM_ONLY, "
							L"NULL, -)");
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							dwThreadId, rParsedInfo, m_bTrace);
				}	
				ONFAILTHROWERROR(hr);

				LONG lLower = 0, lUpper = 0, lIndex = 0; 
				hr = SafeArrayGetLBound(psaNames, 1, &lLower);
				if ( m_eloErrLogOpt )
				{
					chsMsg.Format(L"SafeArrayGetLBound(-, 1, -)"); 
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);

				hr = SafeArrayGetUBound(psaNames, 1, &lUpper);
				if ( m_eloErrLogOpt )
				{
					chsMsg.Format(L"SafeArrayGetUBound(-, 1, -)"); 
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);

				// Puting param values depend on named param list or not.
				BOOL bNamedParamList = rParsedInfo.GetCmdSwitchesObject().
													  GetNamedParamListFlag();

				// Make necessary initializations.
				if ( bNamedParamList == FALSE)
					cviUnnamedValue = cvInParams.begin();
				lIndex = lLower;

				// Associate the parameter values specified to the input 
				// parameters in the order available.
				while(TRUE)
				{
					// Breaking conditions.
					if ( lIndex > lUpper )
						break;
					if ( bNamedParamList == FALSE &&
						 cviUnnamedValue == cvInParams.end())
						 break;

					hr = SafeArrayGetElement(psaNames, &lIndex, &bstrInParam);
					if ( m_eloErrLogOpt )
					{
						chsMsg.Format(L"SafeArrayGetElement(-, -, -)"); 
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
							(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, FALSE);
					}
					ONFAILTHROWERROR(hr);

					// Obtain the property details
					PROPERTYDETAILS pdPropDet;
					GetPropertyAttributes(pIInParam, bstrInParam, 
											pdPropDet, m_bTrace);

					_TCHAR* pszValue = NULL;
					if ( bNamedParamList == TRUE )
					{
						// If in parameter not found in named parameter map.
						if (!Find(bmParameterMap, bstrInParam, bmiNamedValue)) 
						{
							// If not found in alias verb parameters. 
							if ( !Find(pdmPropDetMap, bstrInParam, 
									itrPropDetMap) )
							{
								lIndex++;
								SAFEBSTRFREE(bstrInParam);
								continue;
							}
							else // If found in alias verb parameters.
							{
								// Value should be taken from Default of alias
								// verb parameters.
								if (!((*itrPropDetMap).second.Default))
								{
									lIndex++;
									SAFEBSTRFREE(bstrInParam);
									continue;
								}
								else
									pszValue = (*itrPropDetMap).second.Default;
							}
						}
						pszValue = (*bmiNamedValue).second;
					}
					else
						pszValue = *cviUnnamedValue;

					if (rParsedInfo.GetCmdSwitchesObject().
								GetAliasName() == NULL)
					{
						// Check the parameter value supplied against
						// the qualifier information for the parameter.
						bRet = CheckQualifierInfo(rParsedInfo, pIInSign, 
										bstrInParam, pszValue);
					}
					else
					{
						// If method and parameter information is available
						if (bMethodDtls && !pdmPropDetMap.empty())
						{
							bRet = CheckAliasQualifierInfo(rParsedInfo,
									bstrInParam, pszValue, pdmPropDetMap);
						}
					}

					// The parameter value does not fit into the qualifier
					// allowed values.
					if (!bRet)
					{
						bContinue = FALSE;
						break;
					}

					VariantInit(&varTemp);
					varTemp.vt = VT_BSTR;
					varTemp.bstrVal = SysAllocString(pszValue);

					VariantInit(&varPut);
					hr = ConvertCIMTYPEToVarType(varPut, varTemp,
											 (_TCHAR*)pdPropDet.Type);
					if ( m_eloErrLogOpt )
					{
						chsMsg.Format(L"VariantChangeType(-, -, 0, -)"); 
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
							(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, FALSE);
					}
					ONFAILTHROWERROR(hr);

					hr = pIInParam->Put(bstrInParam, 0, &varPut, 0);
					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(L"IWbemClassObject::Put(L\"%s\", 0,"
								L"-, 0)", (LPWSTR) bstrInParam); 
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
						 (LPCWSTR)chsMsg, dwThreadId, rParsedInfo, m_bTrace);
					}
					ONFAILTHROWERROR(hr);

					VARIANTCLEAR(varPut);
					VARIANTCLEAR(varGet);
					VARIANTCLEAR(varTemp);
					SAFEBSTRFREE(bstrInParam);

					// Looping statements.
					
					if ( bNamedParamList == FALSE )
						cviUnnamedValue++;
					lIndex++;
				}
				// Free the memory 
				SAFEADESTROY(psaNames);

				if (bContinue)
				{
					// If insufficient parameters are specified.
					if ( bNamedParamList == FALSE  &&
						 cviUnnamedValue != cvInParams.end() )
					{
						bContinue = FALSE;
						rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
												IDS_E_INVALID_NO_OF_PARAMS);
						bRet = FALSE;
					}
				}
			}
		}
		else // No input parameters are available for this function.
		{
			// If unnamed parameters are specified.
			if (!rParsedInfo.GetCmdSwitchesObject().GetPropertyList().empty())
			{
				bContinue = FALSE;
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											   IDS_E_METHOD_HAS_NO_IN_PARAMS);
				bRet = FALSE;
			}
		}

		SAFEIRELEASE(pIInSign);
		SAFEIRELEASE(pIOutSign);
       	SAFEIRELEASE(pIClassObj);
		
		if (bContinue)
		{
			hr = FormQueryAndExecuteMethodOrUtility(rParsedInfo, pIInParam);
			ONFAILTHROWERROR(hr);
		}
	}
	catch(_com_error& e)
	{
		// Free the interface pointers and memory allocated.
		SAFEIRELEASE(pIClassObj);
		SAFEIRELEASE(pIInSign);
		SAFEIRELEASE(pIOutSign);
		SAFEIRELEASE(pIInParam);
		SAFEADESTROY(psaNames);
		SAFEBSTRFREE(bstrInParam);
		VARIANTCLEAR(varPut);
		VARIANTCLEAR(varGet);
		VARIANTCLEAR(varTemp);

		// Store the COM error object and set the return value to FALSE
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bRet = FALSE;
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIClassObj);
		SAFEIRELEASE(pIInSign);
		SAFEIRELEASE(pIOutSign);
		SAFEIRELEASE(pIInParam);
		SAFEADESTROY(psaNames);
		SAFEBSTRFREE(bstrInParam);
		VARIANTCLEAR(varPut);
		VARIANTCLEAR(varGet);
		VARIANTCLEAR(varTemp);
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :ProcessSHOWInfo
   Synopsis	         :Executed the functionality requested by GET|LIST verb 
					  referring to the information available with 
					  CParsedInfo object or to display help in interactive mode
					  by displaying properties of concernrd instance.
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
		bVerb		 - Verb or interactive info
		pszPath		 - the Path expression
   Output Parameter(s):
   		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ProcessSHOWInfo(rParsedInfo, bVerb, pszPath)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::ProcessSHOWInfo(CParsedInfo& rParsedInfo,	BOOL bVerb, 
															_TCHAR* pszPath)
{
	HRESULT					hr				= S_OK;
	BOOL					bPropList		= FALSE, 
							bRet			= TRUE, 
							bSysProp		= FALSE;
	_TCHAR					*pszWhereExpr	= NULL, 
							*pszClassPath	= NULL;
	CHARVECTOR::iterator	theIterator		= NULL, 
							theEndIterator	= NULL;
	try
	{
		_bstr_t				bstrPropList(""),	bstrClassName(""), 
							bstrQuery(""),		bstrXML("");

		//Formation of query only once , useful in case /every is specified.
		//if(rParsedInfo.GetCmdSwitchesObject().GetFirstQueryFormFlag() )
		if(rParsedInfo.GetCmdSwitchesObject().GetFormedQuery() == NULL 
					|| !bVerb)
		{	
			// Obtain the list of properties to be retrieved
			if(bVerb)
			{
				theIterator = rParsedInfo.GetCmdSwitchesObject().
								GetPropertyList().begin();
				theEndIterator = rParsedInfo.GetCmdSwitchesObject().
								GetPropertyList().end();
			}
			else
			{
				theIterator = rParsedInfo.GetCmdSwitchesObject().
								GetInteractivePropertyList().begin();
				theEndIterator = rParsedInfo.GetCmdSwitchesObject().
								GetInteractivePropertyList().end();
			}
			
			// Loop thru the list of properties specified,form comma seaprated
			// string of the properties i.e prop1, prop2, prop3, ....., propn
			while (theIterator != theEndIterator)
			{
				// Set the bPropList to TRUE
				bPropList		= TRUE;
				bstrPropList	+= _bstr_t(*theIterator);
				
				// If the system properties flag is not set to true
				if (!bSysProp)
					bSysProp = IsSysProp(*theIterator);
				
				// Move to next property
				theIterator++;
				if (theIterator != theEndIterator)
					bstrPropList += _bstr_t(L", ");
			}; 
			
			// If properties are not specified, then by default retrieve all 
			// the properties. i.e '*'
			if (!bPropList)
				bstrPropList = ASTERIX;
			
			// Obtain the alias target class
			rParsedInfo.GetCmdSwitchesObject().
						GetClassOfAliasTarget(bstrClassName);
			
			// Obtain the class path
			pszClassPath = rParsedInfo.GetCmdSwitchesObject().GetClassPath();
			
			BOOL bClass = FALSE;
			if(bVerb)
			{
				if(IsClassOperation(rParsedInfo))
				{
					bClass = TRUE;
				}
			}
			
			// If CLASS | PATH expression is specified.
			if ( pszClassPath != NULL)
			{
				if (bVerb && bClass)
				{
					bstrQuery = _bstr_t(L"SELECT * FROM") + 
								_bstr_t(" meta_class ");
				}
				else
					bstrQuery = _bstr_t(L"SELECT ") + bstrPropList + 
					_bstr_t(" FROM ") + _bstr_t(pszClassPath);
			}
			else
			{
				bstrQuery = _bstr_t("SELECT ") + bstrPropList + 
						_bstr_t(" FROM ") + bstrClassName;
			}
			
			if(bVerb)
			{
				if (bClass)
				{
					_TCHAR  pszWhere[MAX_BUFFER]	= NULL_STRING;	
					lstrcpy(pszWhere, _T("__Class =  \""));
					lstrcat(pszWhere, pszClassPath);
					lstrcat(pszWhere, _T("\""));
					pszWhereExpr = pszWhere;
				}
				else
					pszWhereExpr = rParsedInfo.GetCmdSwitchesObject().
								GetWhereExpression();
			}
			else if(pszPath)
			{
				_TCHAR  pszWhere[MAX_BUFFER]	= NULL_STRING;	
				bRet = ExtractClassNameandWhereExpr(pszPath, 
								rParsedInfo, pszWhere);
				if(bRet)
					pszWhereExpr = pszWhere;
			}
			
			if(pszWhereExpr)
			{
				bstrQuery += _bstr_t(" WHERE ") + _bstr_t(pszWhereExpr);
			}
			rParsedInfo.GetCmdSwitchesObject().SetFormedQuery(bstrQuery);
			rParsedInfo.GetCmdSwitchesObject().SetSysPropFlag(bSysProp);
		}
		else
		{
			bstrQuery = rParsedInfo.GetCmdSwitchesObject().GetFormedQuery();
			bSysProp = rParsedInfo.GetCmdSwitchesObject().GetSysPropFlag();
		}
		
		// Create the object of IWbemObjectTextSrc interface.
		if (m_pITextSrc == NULL)
			hr = CreateWMIXMLTextSrc(rParsedInfo);

		if (SUCCEEDED(hr))
		{
			// Connect to WMI namespace
			if (m_pITargetNS == NULL)
			{
				if ( IsFailFastAndNodeExist(rParsedInfo) == TRUE )
				{
					hr = ConnectToTargetNS(rParsedInfo);
					ONFAILTHROWERROR(hr);
				}
				else
					hr = -1;
			}

			if (SUCCEEDED(hr))
			{
 				// Obtain the XML Result set.
				hr = ObtainXMLResultSet(bstrQuery, rParsedInfo, 
										bstrXML, bSysProp, TRUE);
			}
			
			if(!bVerb)
			{
				BOOL bRet = g_wmiCmd.GetFormatObject().
									DisplayResults(rParsedInfo, TRUE);
				rParsedInfo.GetCmdSwitchesObject().FreeCOMError();
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(0);
				rParsedInfo.GetCmdSwitchesObject().SetInformationCode(0);
			}
		}
		bRet = FAILED(hr) ? FALSE : TRUE;
	}
	catch(_com_error& e)
	{
		bRet = FALSE;
		_com_issue_error(e.Error());
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :ProcessCALLVerb
   Synopsis	         :Processes the CALL verb request referring to the 
					  information available with CParsedInfo object.
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ProcessCALLVerb(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::ProcessCALLVerb(CParsedInfo& rParsedInfo)
{
	HRESULT hr		= S_OK;
	BOOL	bRet	= TRUE;
	try
	{
		// Connect to WMI namespace
		if (m_pITargetNS == NULL)
		{
			if ( IsFailFastAndNodeExist(rParsedInfo) == TRUE )
				hr = ConnectToTargetNS(rParsedInfo);
			else
				bRet = FALSE;

			ONFAILTHROWERROR(hr);
		}
		
		if ( bRet == TRUE )
		{
			// Check for the verb type, so as to handle lauching of other 
			// commandline utilities from the shell.
			if ( rParsedInfo.GetCmdSwitchesObject().GetVerbType() == CMDLINE )
			{
				if (!ExecOtherCmdLineUtlty(rParsedInfo))
					bRet = FALSE;
			}
			else
			{
				if (!ExecWMIMethod(rParsedInfo))		
					bRet = FALSE;
			}
		}
	}
	catch(_com_error& e)
	{
		// Store the COM error and set the return value to FALSE
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bRet = FALSE;
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :ProcessASSOCVerb
   Synopsis	         :Processes the ASSOC verb request referring to the
					  information available with CParsedInfo object.
   Type	             :Member Function
   Input Parameter(s):
   		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
   		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ProcessASSOCVerb(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::ProcessASSOCVerb(CParsedInfo& rParsedInfo)
{
	HRESULT					hr					= S_OK;
	BOOL					bRet				= TRUE;
	WMICLIINT				nReqType			= 0;
    BOOL					bSwitches			= FALSE,
							bClass				= TRUE,
							bInstances			= FALSE;

	IEnumWbemClassObject	*pIEnumObj			= NULL;
	IWbemClassObject		*pIWbemObj			= NULL;
	VARIANT					varPath;
	VariantInit(&varPath);
	try
	{
		_bstr_t		bstrClassName(""), 	bstrQuery(""),	bstrAssocWhere(""),
					bstrResult(""), 	bstrXML(""),	bstrAggResult("");

		bstrAggResult = MULTINODE_XMLSTARTTAG;

		//If assoc switches are specified, bSwitches is set and correspondingly 
		//assoc where clause is framed	
		bSwitches =((rParsedInfo.GetCmdSwitchesObject().GetResultClassName())||
			(rParsedInfo.GetCmdSwitchesObject().GetResultRoleName()) ||
			(rParsedInfo.GetCmdSwitchesObject().GetAssocClassName()));

		if(bSwitches)
		{
			bstrAssocWhere +=  _bstr_t(" WHERE ");
			if((rParsedInfo.GetCmdSwitchesObject().GetResultClassName()) 
					!= NULL )
			{
				bstrAssocWhere += _bstr_t(L" ResultClass = ") +
					_bstr_t(rParsedInfo.GetCmdSwitchesObject().
						GetResultClassName());
				
			}
			if((rParsedInfo.GetCmdSwitchesObject().GetResultRoleName()) 
					!= NULL)
			{
				bstrAssocWhere += _bstr_t(L" ResultRole = ") +
					_bstr_t(rParsedInfo.GetCmdSwitchesObject().
						GetResultRoleName());
				
			}
			if((rParsedInfo.GetCmdSwitchesObject().GetAssocClassName()) 
					!= NULL)
			{
				bstrAssocWhere += _bstr_t(L" AssocClass  = ") +
					_bstr_t(rParsedInfo.GetCmdSwitchesObject().
						GetAssocClassName());
			}
		}
					
		//NOTE: nReqType = 2 implies that first get all instances and then
		// find associations for each instance

		// If PATH is specified 
		if (rParsedInfo.GetCmdSwitchesObject().GetPathExpression() != NULL)
		{
			// If PATH is specified (with key expression).
			if (!rParsedInfo.GetCmdSwitchesObject().
								GetExplicitWhereExprFlag())
			{
				if (rParsedInfo.GetCmdSwitchesObject().
					GetWhereExpression() == NULL)
				{
					nReqType = 2;
				}
				else
				{
					nReqType = 1;

					bstrQuery = _bstr_t(L"ASSOCIATORS OF {") 
						+ _bstr_t(rParsedInfo.GetCmdSwitchesObject()
										.GetPathExpression() 
						+ _bstr_t("}"));
				}
			}
			else
				nReqType = 2;
		}


		// If CLASS expression is specified.
		//associators of the class need to be displayed
		if (rParsedInfo.GetCmdSwitchesObject().GetClassPath() != NULL
			&& rParsedInfo.GetCmdSwitchesObject().
											GetPathExpression() == NULL)
		{
			nReqType = 1;
			bstrQuery = _bstr_t(L"ASSOCIATORS OF {") 
				+ _bstr_t(rParsedInfo.GetCmdSwitchesObject().GetClassPath()) 
				+ _bstr_t("}");

			if (!bSwitches)
				bstrQuery += _bstr_t(L" WHERE SchemaOnly");
			else
				bstrQuery += bstrAssocWhere + _bstr_t(L" SchemaOnly");
		}		

		// Check for <alias> or alias and path without keyclause
		if (nReqType != 1)
		{
			// Obtain the alias target class
			if(rParsedInfo.GetCmdSwitchesObject().GetAliasName() != NULL)
			{
				rParsedInfo.GetCmdSwitchesObject().GetClassOfAliasTarget(
															bstrClassName);
			}
			else
				bstrClassName = _bstr_t(rParsedInfo.GetCmdSwitchesObject().
															GetClassPath());

			//obtain the instances corresponding to the alias target class
			bstrQuery = _bstr_t(L"SELECT * FROM ") + bstrClassName;

			//if pwhere expression is specified or where is specified
			if (rParsedInfo.GetCmdSwitchesObject().
							GetWhereExpression() != NULL)
			{
				bstrQuery += _bstr_t(" WHERE ") +_bstr_t(rParsedInfo.
							GetCmdSwitchesObject().GetWhereExpression());
			}

			nReqType = 2;
		}


		// Create the object of IWbemObjectTextSrc interface.
		if (m_pITextSrc == NULL)
			hr = CreateWMIXMLTextSrc(rParsedInfo);

		if (SUCCEEDED(hr))
		{
			// Connect to WMI namespace
			if (m_pITargetNS == NULL)
			{
				if ( IsFailFastAndNodeExist(rParsedInfo) == TRUE )
				{
					hr = ConnectToTargetNS(rParsedInfo);
					ONFAILTHROWERROR(hr);
				}
				else
					hr = -1; // Explicitly set error
			}
			
			if (SUCCEEDED(hr))
			{
				if(nReqType != 2)
				{
 					// Obtain the XML Result Set.
					hr = ObtainXMLResultSet(bstrQuery, rParsedInfo, bstrXML, 
								TRUE, FALSE);
					ONFAILTHROWERROR(hr);

					if (m_bNoAssoc)
					{
						_bstr_t bstrMsg;
						WMIFormatMessage(IDS_I_NO_ASSOC, 0, bstrMsg, NULL);
						DisplayMessage((LPWSTR)bstrMsg, CP_OEMCP, TRUE, TRUE);
						m_bNoAssoc = FALSE;
					}

					if (rParsedInfo.GetCmdSwitchesObject().
									GetPathExpression() == NULL)
					{
						bClass		= TRUE;
						hr = FrameAssocHeader(rParsedInfo.
								GetCmdSwitchesObject().GetClassPath(),	
								bstrResult, bClass);
						ONFAILTHROWERROR(hr);
					}
					else
					{
						bClass = FALSE;	
						hr = FrameAssocHeader(
								rParsedInfo.GetCmdSwitchesObject()
								.GetPathExpression(), bstrResult, bClass);
						ONFAILTHROWERROR(hr);
					}
					bstrResult += bstrXML;
					bstrResult += (bClass) ? L"</CLASS>" : L"</INSTANCE>";
					bstrAggResult += bstrResult;
				}
				else
				{
					// Set the class flag to FALSE
					bClass	= FALSE;
					ULONG					ulReturned			= 0;
					CHString				chsMsg;
					DWORD					dwThreadId			= 
											GetCurrentThreadId();
					VariantInit(&varPath);
					try
					{
						//enumerate the instances
						hr = m_pITargetNS->ExecQuery(_bstr_t(L"WQL"), 
												bstrQuery, 
												WBEM_FLAG_FORWARD_ONLY |
												WBEM_FLAG_RETURN_IMMEDIATELY, 
												NULL, &pIEnumObj);
						if (m_bTrace || m_eloErrLogOpt)
						{
							chsMsg.Format(L"IWbemServices::ExecQuery(L\"WQL\"," 
										L"L\"%s\", 0, NULL, -)", 
										(LPWSTR)bstrQuery);
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
									(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, 
									m_bTrace);
						}
						ONFAILTHROWERROR(hr);

						// Set the interface security
						hr = SetSecurity(pIEnumObj, 
								rParsedInfo.GetGlblSwitchesObject().
									GetAuthority(),
								rParsedInfo.GetNode(),
								rParsedInfo.GetUser(),
								rParsedInfo.GetPassword(),
								rParsedInfo.GetGlblSwitchesObject().
													GetAuthenticationLevel(),
								rParsedInfo.GetGlblSwitchesObject().
													GetImpersonationLevel());

						if (m_bTrace || m_eloErrLogOpt)
						{
							chsMsg.Format(
								L"CoSetProxyBlanket(-, RPC_C_AUTHN_WINNT, "
								L"RPC_C_AUTHZ_NONE, NULL, %d,   %d, -, "
								L"EOAC_NONE)",
								rParsedInfo.GetGlblSwitchesObject().
											GetAuthenticationLevel(),
								rParsedInfo.GetGlblSwitchesObject().
											GetImpersonationLevel());
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
											(LPCWSTR)chsMsg, dwThreadId,
								rParsedInfo, m_bTrace);
						}
						ONFAILTHROWERROR(hr);

						// Loop thru the available instances
						hr = pIEnumObj->Next( WBEM_INFINITE, 1, &pIWbemObj, 
									&ulReturned );

						if (m_bTrace || m_eloErrLogOpt)
						{
							chsMsg.Format(
								L"IEnumWbemClassObject->Next(WBEM_INFINITE, 1,"
								L"-, -)");
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
								(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, 
								m_bTrace);
						}
						ONFAILTHROWERROR(hr);

						// Set this property in all objects of the collection
						while (ulReturned == 1)
 						{
							bInstances = TRUE;

							VariantInit(&varPath);
							hr = pIWbemObj->Get(L"__PATH", 0, &varPath, 0, 0);				
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(
									L"IWbemClassObject::Get(L\"__PATH\", 0, -,"
											L"0, 0)"); 
								GetBstrTFromVariant(varPath, bstrResult);
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
									(LPCWSTR)chsMsg, dwThreadId, rParsedInfo,
									m_bTrace, 0, bstrResult);
							}
							ONFAILTHROWERROR(hr);
							
							//form the query for finding the associators
							//of each of the instances
							bstrQuery = _bstr_t(L"ASSOCIATORS OF {") 
										+ varPath.bstrVal
										+ _bstr_t("}") ;
							if (bSwitches)
								bstrQuery += bstrAssocWhere;
						
							hr = FrameAssocHeader(varPath.bstrVal, bstrResult,
											bClass);
							ONFAILTHROWERROR(hr);

							//Obtain the result set for the associators
							//of the corresponding instance
							hr = ObtainXMLResultSet(bstrQuery, rParsedInfo, 
									bstrXML, TRUE, FALSE);
							ONFAILTHROWERROR(hr);

							if (m_bNoAssoc)
							{
								_bstr_t bstrMsg;
								WMIFormatMessage(IDS_I_NO_ASSOCIATIONS, 1, 
									bstrMsg, (LPWSTR)varPath.bstrVal);
								DisplayMessage((LPWSTR)bstrMsg, CP_OEMCP, 
									TRUE, TRUE);
								m_bNoAssoc = FALSE;
							}

							bstrResult += bstrXML;
							bstrResult += L"</INSTANCE>";
							bstrAggResult += bstrResult;

							//check for ctrl+c
							if ( g_wmiCmd.GetBreakEvent() == TRUE )
							{
								VARIANTCLEAR(varPath);
								SAFEIRELEASE(pIWbemObj);
								break;
							}

							VARIANTCLEAR(varPath);
							SAFEIRELEASE(pIWbemObj);

							if ( bRet == FALSE )
								break;

							// Obtain the next instance in the enumeration.
							hr = pIEnumObj->Next( WBEM_INFINITE, 1, &pIWbemObj,
										&ulReturned);
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(
								  L"IEnumWbemClassObject->Next(WBEM_INFINITE,"
								  L"1, -, -)");
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
									(LPCWSTR)chsMsg,
									dwThreadId, rParsedInfo, m_bTrace);
							}
							ONFAILTHROWERROR(hr);
						}
						SAFEIRELEASE(pIEnumObj);		

						// If no instances are available
						if (bInstances == FALSE)
						{
							_bstr_t bstrMsg;
							WMIFormatMessage(IDS_I_NO_INSTANCES, 
									0, bstrMsg, NULL);
							DisplayMessage((LPWSTR)bstrMsg, CP_OEMCP, 
									TRUE, TRUE);
							CHString sTemp;
							sTemp.Format(
							_T("<ERROR><DESCRIPTION>%s</DESCRIPTION></ERROR>"),
									(LPWSTR) bstrMsg);
							bstrAggResult = _bstr_t(sTemp);
						}
					}
					catch(_com_error& e)
					{
						VARIANTCLEAR(varPath);
						SAFEIRELEASE(pIWbemObj);
						SAFEIRELEASE(pIEnumObj);		
						rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
					}
				}
				if (SUCCEEDED(hr))
				{
					if ((nReqType != 2) || ((nReqType == 2) && bInstances))
					{
						bstrAggResult += L"</CIM>";
						rParsedInfo.GetCmdSwitchesObject().
								SetXMLResultSet(bstrAggResult);
					}
				}
			}
			bRet = FAILED(hr) ? FALSE : TRUE;
		}
	}
	catch(_com_error& e)
	{
		VARIANTCLEAR(varPath);
		SAFEIRELEASE(pIWbemObj);
		SAFEIRELEASE(pIEnumObj);		
		_com_issue_error(e.Error());
	}
	// trap for CHeap_Exception
	catch(CHeap_Exception)
	{
		VARIANTCLEAR(varPath);
		SAFEIRELEASE(pIWbemObj);
		SAFEIRELEASE(pIEnumObj);		
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :ProcessSETVerb
   Synopsis	         :Processes the SET verb referring to the information
					  available with CParsedInfo object.
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
   		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ProcessSETVerb(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::ProcessSETVerb(CParsedInfo& rParsedInfo)
{
	// SET verb processing
	BOOL	 bRet		= TRUE;
	HRESULT	 hr			= S_OK;
	
	try
	{
		_bstr_t  bstrQuery(""), bstrObject(""), bstrClass("");
	
		// If anyone of the following is specified:
		// a) PATH <path expr>
		// b) PATH <class path expr> WHERE <where expr>
		if (rParsedInfo.GetCmdSwitchesObject().GetPathExpression() != NULL)
		{
			bstrClass = _bstr_t(rParsedInfo.GetCmdSwitchesObject()
												.GetClassPath());
			bstrObject = _bstr_t(rParsedInfo.GetCmdSwitchesObject()
													.GetPathExpression());

			// Form the query
			bstrQuery = _bstr_t(L"SELECT * FROM ") + bstrClass ;

			// If WHERE expresion is given
			if (rParsedInfo.GetCmdSwitchesObject().
								GetWhereExpression() != NULL)
			{
				bstrQuery +=	_bstr_t(L" WHERE ") 
								+ _bstr_t(rParsedInfo.GetCmdSwitchesObject()
														.GetWhereExpression());
			}
		}
		// If <alias> WHERE expression is specified.
		else if (rParsedInfo.GetCmdSwitchesObject().GetWhereExpression() 
				!= NULL)
		{
			rParsedInfo.GetCmdSwitchesObject().
								GetClassOfAliasTarget(bstrObject); 
			bstrQuery = _bstr_t(L"SELECT * FROM ") 
						+  bstrObject  
						+ _bstr_t(L" WHERE ") 
						+ _bstr_t(rParsedInfo.GetCmdSwitchesObject()
												.GetWhereExpression());
			bstrClass = bstrObject;
		}
		// If CLASS is specified.
		else if (rParsedInfo.GetCmdSwitchesObject().GetClassPath() != NULL)
		{
			bstrObject = _bstr_t(rParsedInfo.GetCmdSwitchesObject()
												.GetClassPath());
			bstrClass = bstrObject;
		}
		// if only <alias> is specified
		else 
		{
			rParsedInfo.GetCmdSwitchesObject().
					GetClassOfAliasTarget(bstrObject);
			bstrQuery = _bstr_t(L"SELECT * FROM ")
						+ bstrObject;
			bstrClass = bstrObject;
			
		}

		// Connect to WMI namespace
		if (m_pITargetNS == NULL)
		{
			if ( IsFailFastAndNodeExist(rParsedInfo) == TRUE )
			{
				hr = ConnectToTargetNS(rParsedInfo);
				ONFAILTHROWERROR(hr);
			}
			else
				hr = -1; // Explicitly set error
		}

		if (SUCCEEDED(hr))
		{
			// Validate the property values against the property
			// qualifier information if available.
			if (rParsedInfo.GetCmdSwitchesObject().GetAliasName() != NULL)
			{
				// Validate the input parameters against the alias
				// qualifier information.
				bRet = ValidateAlaisInParams(rParsedInfo);
			}
			else
			{
				// Validate the input parameters against the class
				// qualifier information
				bRet = ValidateInParams(rParsedInfo, bstrClass);
			}

			if (bRet)
			{
				// Set the values passed as input to the appropriate properties.
				bRet = SetPropertyInfo(rParsedInfo, bstrQuery, bstrObject);
			}
		}
		else
			bRet = FALSE;
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
		bRet = FALSE;
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :SetPropertyInfo
   Synopsis	         :This function updates the property value for the 
                      given property name and value
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - reference to the CParsedInfo object 
		bstrQuery    - String consist of WQL query
		bstrObject   - String consist of object path
   Output Parameter(s):
		rParsedInfo  - reference to the CParsedInfo object 
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetPropertyInfo(rParsedInfo, bstrQuery, bstrObject)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::SetPropertyInfo(CParsedInfo& rParsedInfo, 
								 _bstr_t& bstrQuery, _bstr_t& bstrObject)
{
	HRESULT					hr					= S_OK;
	IEnumWbemClassObject	*pIEnumObj			= NULL;
	IWbemClassObject		*pIWbemObj			= NULL;
	ULONG					ulReturned			= 0;
	BOOL					bSuccess			= TRUE;
	CHString				chsMsg;
	DWORD					dwThreadId			= GetCurrentThreadId();
	VARIANT					varPath;
	VariantInit(&varPath);
	
	try
	{
		if (bstrQuery == _bstr_t(""))
		{
			// If query is NULL then get the object of WMI Class based on 
			// PATH expression
			hr = m_pITargetNS->GetObject(bstrObject,
										 0, NULL, &pIWbemObj, NULL);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", 0, "
						L"NULL, -)", (LPWSTR) bstrObject);		
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
					dwThreadId,	rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			// If instance path is specified then modify the instance 
			// properties otherwise modify class properties
			if(rParsedInfo.GetCmdSwitchesObject().GetWhereExpression() == NULL) 
				bSuccess = SetProperties(rParsedInfo, pIWbemObj, TRUE);
			else
				bSuccess = SetProperties(rParsedInfo, pIWbemObj, FALSE);
			SAFEIRELEASE(pIWbemObj);
		}
		else
		{
			// Execute the query to get collection of objects
			hr = m_pITargetNS->ExecQuery(_bstr_t(L"WQL"), bstrQuery, 0,
										NULL, &pIEnumObj);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemServices::ExecQuery(L\"WQL\"," 
							L"L\"%s\", 0, NULL, -)", (LPWSTR)bstrQuery);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
					dwThreadId,	rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			
			// Set the interface security
			hr = SetSecurity(pIEnumObj, 
					rParsedInfo.GetGlblSwitchesObject().GetAuthority(),
					rParsedInfo.GetNode(),
					rParsedInfo.GetUser(),
					rParsedInfo.GetPassword(),
					rParsedInfo.GetGlblSwitchesObject().
								GetAuthenticationLevel(),
					rParsedInfo.GetGlblSwitchesObject().
								GetImpersonationLevel());
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"CoSetProxyBlanket(-, RPC_C_AUTHN_WINNT, "
					L"RPC_C_AUTHZ_NONE, NULL, %d,   %d, -, EOAC_NONE)",
					rParsedInfo.GetGlblSwitchesObject().
								GetAuthenticationLevel(),
					rParsedInfo.GetGlblSwitchesObject().
								GetImpersonationLevel());
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
						dwThreadId,	rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			BOOL bInstances = FALSE;

			// Loop thru the available instances
			hr = pIEnumObj->Next( WBEM_INFINITE, 1, &pIWbemObj, &ulReturned );

			// Set this property in all objects of the collection
			while (ulReturned == 1)
 			{
				bInstances = TRUE;
				
				// If instance updation failed.
				if (!SetProperties(rParsedInfo, pIWbemObj, FALSE))
				{
					bSuccess = FALSE;
					VARIANTCLEAR(varPath);
					SAFEIRELEASE(pIEnumObj);
					SAFEIRELEASE(pIWbemObj);
					break;
				}
				VARIANTCLEAR(varPath);
				SAFEIRELEASE(pIWbemObj);

				// Obtain the next instance in the enumeration.
				hr = pIEnumObj->Next( WBEM_INFINITE, 1, 
						&pIWbemObj, &ulReturned);
			}
			SAFEIRELEASE(pIEnumObj);
			// If no instances are available
			if (!bInstances)
			{
				rParsedInfo.GetCmdSwitchesObject().
					SetInformationCode(IDS_I_NO_INSTANCES);
			}
		}
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIEnumObj);
		SAFEIRELEASE(pIWbemObj);
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bSuccess = FALSE;
	}
	// trap for CHeap_Exception
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIEnumObj);
		SAFEIRELEASE(pIWbemObj);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return bSuccess;
}

/*------------------------------------------------------------------------
   Name				 :SetProperties
   Synopsis	         :This function changes the property values for the 
                      given property names and values in a passed 
					  IWbemClassObject
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - CParsedInfo object consist of parsed tokens  
		pIWbemObj    - IWbemClassObject in which property has to be set
		bClass		 - Flag to indicate whether class object is passed or 
					   instance is passed
   Output Parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetProperties(rParsedInfo, pIWbemObj, bClass)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::SetProperties(CParsedInfo& rParsedInfo, 
								IWbemClassObject* pIWbemObj, BOOL bClass)
{
	HRESULT				hr					= S_OK;
	IWbemQualifierSet	*pIQualSet			= NULL;
	BOOL				bRet				= TRUE, 
						bInteractive		= FALSE,
						bChange				= FALSE;
	CHString			chsMsg;
	DWORD				dwThreadId			= GetCurrentThreadId();
	BSTRMAP::iterator	theIterator			= NULL;
	VARIANT				varValue, 
						varDest, 
						varSrc,
						varPath, 
						varType;
	INTEROPTION			interOption			= YES;
	
	VariantInit(&varValue);
	VariantInit(&varDest);
	VariantInit(&varSrc);
	VariantInit(&varPath);
	VariantInit(&varType);

	// Get the proprty name and their corresponding value
	BSTRMAP theMap = rParsedInfo.GetCmdSwitchesObject().GetParameterMap();
	
	// Set the iterator to the start of the map.
	theIterator = theMap.begin();

	// obtian the verb interactive mode status.
	bInteractive		= IsInteractive(rParsedInfo);
	
	try
	{
		_bstr_t				bstrResult;
		// Obtain the __PATH property value
		hr = pIWbemObj->Get(_bstr_t(L"__PATH"), 0, &varPath, 0, 0);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemClassObject::Get(L\"__PATH\", 0, -,"
						L"0, 0)"); 
			GetBstrTFromVariant(varPath, bstrResult);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
				dwThreadId, rParsedInfo, m_bTrace, 0, bstrResult);
		}			
		ONFAILTHROWERROR(hr);

		// If /INTERACTIVE switch is specified, obtain the user response.
		if (bInteractive)
		{
			_bstr_t bstrMsg;
			while(TRUE)
			{
				if(IsClassOperation(rParsedInfo))
				{
					WMIFormatMessage(IDS_I_UPDATE_PROMPT, 1, bstrMsg, 
								(LPWSTR) _bstr_t(varPath.bstrVal));
					interOption	= GetUserResponse((LPWSTR)bstrMsg);
				}
				else
				{
					WMIFormatMessage(IDS_I_UPDATE_PROMPT2, 1, bstrMsg, 
								(LPWSTR) _bstr_t(varPath.bstrVal));
					interOption	= GetUserResponseEx((LPWSTR)bstrMsg);
				}
				
				if (interOption == YES || interOption == NO)
					break;
				else 
				if (interOption == HELP)
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetInformationCode(0);
					ProcessSHOWInfo(rParsedInfo, FALSE, 
							(_TCHAR*)_bstr_t(varPath.bstrVal));
				}
			}
		}
		else
		{
			_bstr_t bstrMsg;
			WMIFormatMessage(IDS_I_PROMPT_UPDATING, 1, bstrMsg, 
								(LPWSTR) _bstr_t(varPath.bstrVal));
			DisplayMessage((LPWSTR)bstrMsg, CP_OEMCP, FALSE, TRUE);
		}

		VARIANTCLEAR(varPath);	
		VariantInit(&varSrc);
		VariantInit(&varDest);

		if (interOption == YES)
		{
			PROPDETMAP pdmPropDetMap = rParsedInfo.GetCmdSwitchesObject().
															  GetPropDetMap();
			PROPDETMAP::iterator itrPropDetMap;
			BOOL bPropType = FALSE;

			// Update all properties
			while (theIterator != theMap.end())
			{
				// Get the property names and their corresponding values 
				_bstr_t bstrProp = _bstr_t((_TCHAR*)(*theIterator).first);

				// Get the derivation of property name
				if ( Find(pdmPropDetMap, bstrProp, itrPropDetMap) == TRUE )
				{
					if ( !((*itrPropDetMap).second.Derivation) == FALSE )
						bstrProp = (*itrPropDetMap).second.Derivation;
					bPropType = TRUE;
				}
				else
					bPropType = FALSE;

				// Check for the property validity(i.e. does it exist or not?)
				VariantInit(&varValue);
				hr = pIWbemObj->Get(bstrProp, 0, &varValue, 0, 0);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Get(L\"%s\", 0, -,"
								L"0, 0)", (LPWSTR) bstrProp); 
					if ( bPropType )
					{
						GetBstrTFromVariant(varValue, bstrResult, 
										(*itrPropDetMap).second.Type);
					}
					else
						GetBstrTFromVariant(varValue, bstrResult);

					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
						(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, 
						m_bTrace, 0, bstrResult);
				}
				ONFAILTHROWERROR(hr);

				// Set the change flag to TRUE
				bChange = TRUE;

				// If the property content is <empty>
				if ((varValue.vt == VT_EMPTY) || (varValue.vt == VT_NULL))
				{
					// Obtain the property qualifier set for the property
   					hr = pIWbemObj->GetPropertyQualifierSet(bstrProp, 
								&pIQualSet);
					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(
						 L"IWbemClassObject::GetPropertyQualifierSet(L\"%s\","
						 L" -)", (LPWSTR)bstrProp); 
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
						 (LPCWSTR)chsMsg, dwThreadId, rParsedInfo, m_bTrace);
					}
					ONFAILTHROWERROR(hr);
					

					VariantInit(&varType);
					if (pIQualSet)
					{
						// Obtain the CIM type of the property
						hr = pIQualSet->Get(_bstr_t(L"CIMTYPE"), 0L, 
											&varType, NULL);
						if (m_bTrace || m_eloErrLogOpt)
						{
							chsMsg.Format(L"IWbemQualifierSet::Get(L\"CIMTYPE\","
								L" 0, -, 0, 0)"); 
							GetBstrTFromVariant(varType, bstrResult);
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
								(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, 
								m_bTrace, 0, bstrResult);
						}
						ONFAILTHROWERROR(hr);

						varSrc.vt = VT_BSTR;
						varSrc.bstrVal = SysAllocString(
											(_TCHAR*)(*theIterator).second);

						hr = ConvertCIMTYPEToVarType(varDest, varSrc,
												 (_TCHAR*)varType.bstrVal);
						if ( m_eloErrLogOpt )
						{
							chsMsg.Format(L"VariantChangeType(-, -, 0, -)"); 
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__,
							 (LPCWSTR)chsMsg, dwThreadId, rParsedInfo, FALSE);
						}
						ONFAILTHROWERROR(hr);

						VARIANTCLEAR(varType);
						SAFEIRELEASE(pIQualSet);
					}
				}
				// If the property content is not <empty>
				else 
				{
					varSrc.vt		= VT_BSTR;
					varSrc.bstrVal	= SysAllocString(
										(_TCHAR*)(*theIterator).second);

					// If _T("") is the value should be treated as 
					// equivalent to <empty>
					if (CompareTokens(varSrc.bstrVal, _T("")))
						hr = VariantChangeType(&varDest, &varSrc, 0, VT_NULL);
					else
						hr = VariantChangeType(&varDest, &varSrc, 
							0, varValue.vt);

					if ( m_eloErrLogOpt )
					{
						chsMsg.Format(L"VariantChangeType(-, -, 0, -)"); 
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
							(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, FALSE);
					}
					ONFAILTHROWERROR(hr);
				}

				// Update the property value
				hr = pIWbemObj->Put(bstrProp, 0, &varDest, 0);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Put(L\"%s\", 0, -, 0)",
								(LPWSTR)bstrProp); 
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
						dwThreadId, rParsedInfo, m_bTrace);
				}
				ONFAILTHROWERROR(hr);
				VARIANTCLEAR(varSrc);
				VARIANTCLEAR(varDest);
				VARIANTCLEAR(varValue);

				// Move to next entry
				theIterator++;
			}
		}
		
		// Write the instance or class object to Windows Management 
		// Instrumentation (WMI). 
		if (bChange)
		{
			if(bClass)
			{
				// Update the class schema with the changes
				hr = m_pITargetNS->PutClass(pIWbemObj, 0, NULL, NULL);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemServices::PutClass(-, 0, "
							L"NULL, NULL)");
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							dwThreadId, rParsedInfo, m_bTrace);
				}
				ONFAILTHROWERROR(hr);
			}
			else
			{
				// Update the instance with the changes
				hr = m_pITargetNS->PutInstance(pIWbemObj, WBEM_FLAG_UPDATE_ONLY, NULL, NULL);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemServices::PutInstance(-, 0, NULL"
						L", NULL)");
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
						dwThreadId, rParsedInfo, m_bTrace);
				}
				ONFAILTHROWERROR(hr);

			}
			DisplayString(IDS_I_SET_SUCCESS, CP_OEMCP, NULL, FALSE, TRUE);
		}
	}
	catch(_com_error& e)
	{
		VARIANTCLEAR(varSrc);
		VARIANTCLEAR(varDest);
		VARIANTCLEAR(varValue);
		VARIANTCLEAR(varType);
		SAFEIRELEASE(pIQualSet);
		VARIANTCLEAR(varSrc);
		VARIANTCLEAR(varDest);

		// Store the COM error, and set the return value to FALSE.
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bRet = FALSE;
	}
	catch(CHeap_Exception)
	{
		VARIANTCLEAR(varSrc);
		VARIANTCLEAR(varDest);
		VARIANTCLEAR(varValue);
		VARIANTCLEAR(varType);
		SAFEIRELEASE(pIQualSet);
		VARIANTCLEAR(varSrc);
		VARIANTCLEAR(varDest);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :ConnectToTargetNS
   Synopsis	         :This function connects to WMI namespace on the target
					  machine with given user credentials.
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :ConnectToTargetNS(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CExecEngine::ConnectToTargetNS(CParsedInfo& rParsedInfo)
{
	HRESULT hr					= S_OK;
	CHString	chsMsg;
	DWORD	dwThreadId			= GetCurrentThreadId();
	try
	{
		SAFEIRELEASE(m_pITargetNS);
		_bstr_t bstrNameSpace = _bstr_t(L"\\\\") 
								+ _bstr_t(rParsedInfo.GetNode()) 
								+ _bstr_t(L"\\") 
								+ _bstr_t(rParsedInfo.GetNamespace());
		
		// Connect to the specified WMI namespace
		hr = Connect(m_pIWbemLocator, &m_pITargetNS, 
					bstrNameSpace, 
					_bstr_t(rParsedInfo.GetUser()),
					_bstr_t(rParsedInfo.GetPassword()),
					_bstr_t(rParsedInfo.GetLocale()),
					rParsedInfo);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemLocator::ConnectServer(L\"%s\", "
				L"L\"%s\", *, L\"%s\", 0L, NULL, NULL, -)",
				(LPWSTR)bstrNameSpace,
				(rParsedInfo.GetUser()) ? rParsedInfo.GetUser() : L"<null>",
				rParsedInfo.GetLocale());
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
				dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);


		// Set the interface level security 
		hr = SetSecurity(m_pITargetNS, 
				rParsedInfo.GetGlblSwitchesObject().GetAuthority(),
				rParsedInfo.GetNode(),
				rParsedInfo.GetUser(),
				rParsedInfo.GetPassword(),
				rParsedInfo.GetGlblSwitchesObject().GetAuthenticationLevel(),
				rParsedInfo.GetGlblSwitchesObject().GetImpersonationLevel());
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(
				L"CoSetProxyBlanket(-, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,"
				L"NULL, %d,   %d, -, EOAC_NONE)",
				rParsedInfo.GetGlblSwitchesObject().GetAuthenticationLevel(),
				rParsedInfo.GetGlblSwitchesObject().GetImpersonationLevel());
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
				dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

	}
	catch(_com_error& e)
	{
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return hr;
}

/*------------------------------------------------------------------------
   Name				 :CreateWMIXMLTextSrc
   Synopsis	         :This function creates the IWbemObjectTextSrc instance
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :CreateWMIXMLTextSrc(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CExecEngine::CreateWMIXMLTextSrc(CParsedInfo& rParsedInfo)
{
	HRESULT hr					= S_OK;
	CHString	chsMsg;
	DWORD	dwThreadId			= GetCurrentThreadId();

	try
	{
		hr = CoCreateInstance(CLSID_WbemObjectTextSrc, NULL, 
							CLSCTX_INPROC_SERVER, 
							IID_IWbemObjectTextSrc, 
							(LPVOID*) &m_pITextSrc);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"CoCreateInstance(CLSID_WbemObjectTextSrc, NULL,"
				L"CLSCTX_INPROC_SERVER, IID_IWbemObjectTextSrc, -)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
				dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

	}
	catch(_com_error& e)
	{
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return hr;
}

/*------------------------------------------------------------------------
   Name				 :CreateContext
   Synopsis	         :This function creates the IWbemContext instance
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :CreateContext(rParsedInfo)
   Calls             :CParsedInfo::GetCmdSwitchesObject()
					  CCommandSwitches::SetCOMError()
					  CoCreateInstance()
   Called by         :CExecEngine::ObtainXMLResultSet()
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CExecEngine::CreateContext(CParsedInfo& rParsedInfo)
{
	HRESULT hr					= S_OK;
	CHString	chsMsg;
	DWORD	dwThreadId			= GetCurrentThreadId();
	try
	{
		//Create context object
		MULTI_QI mqi = { &IID_IWbemContext, 0, 0 };
		hr = CoCreateInstanceEx(CLSID_WbemContext, NULL, 
					          CLSCTX_INPROC_SERVER, 
							  0, 1, &mqi);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"CoCreateInstanceEx(CLSID_WbemContext, NULL,"
					L"CLSCTX_INPROC_SERVER, 0, 1, -)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
				dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

	    m_pIContext = reinterpret_cast<IWbemContext*>(mqi.pItf);
    }
	catch(_com_error& e)
	{
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return hr;
}

/*-------------------------------------------------------------------------
   Name				 :ExecuteMethodAndDisplayResults
   Synopsis	         :This function executes and displays the
					  results corresponding to the method. If 
					  interactive mode is set, the user is prompted 
					  choose the method
   Type	             :Member Function
   Input Parameter(s):
	bstrPath		 - _bstr_t type,Path expression
	rParsedInfo		 - reference to CParsedInfo class object
	pIInParam		 - Pointer to the IWbemclassobject
   Output Parameter(s):
    rParsedInfo		 - reference to CParsedInfo class object
   Return Type       :HRESULT 
   Global Variables  :None
   Calling Syntax    :ExecuteMethodAndDisplayResults(bstrPath, rParsedInfo,
													 pIInParam)
   Calls             :None
   Called by         :CExecEngine::ExecWMIMethod()
   Notes             :none
-------------------------------------------------------------------------*/
HRESULT CExecEngine::ExecuteMethodAndDisplayResults(_bstr_t bstrPath,
												  CParsedInfo& rParsedInfo,
												  IWbemClassObject* pIInParam)
{
	_TCHAR					*pszMethodName		= NULL;
	INTEROPTION				interOption			= YES;
	IWbemClassObject		*pIOutParam			= NULL;
	HRESULT					hr					= S_OK;
	CHString				chsMsg;
	DWORD					dwThreadId			= GetCurrentThreadId();
	VARIANT					varTemp;
	VariantInit(&varTemp);

	// Obtain the method name
	pszMethodName =	rParsedInfo.GetCmdSwitchesObject().GetMethodName();

	try
	{
		// If /INTERACTIVE switch is specified, obtain the user response.
		if (IsInteractive(rParsedInfo) == TRUE)
		{
			_bstr_t bstrMsg;
			while ( TRUE )
			{
				BOOL bInstanceLevel = TRUE;
				if(IsClassOperation(rParsedInfo))
				{
					bInstanceLevel = FALSE;
				}
				else
				{
					_TCHAR *pszVerbName = rParsedInfo.GetCmdSwitchesObject().
																GetVerbName(); 
					if(CompareTokens(pszVerbName, CLI_TOKEN_CALL))
					{
						if ( rParsedInfo.GetCmdSwitchesObject().
											GetAliasName() != NULL )
						{
							if (rParsedInfo.GetCmdSwitchesObject().
											GetWhereExpression() == NULL)
							{
								bInstanceLevel = FALSE;
							}
							else
								bInstanceLevel = TRUE;
						}
						else
						{
							if ((rParsedInfo.GetCmdSwitchesObject().
											GetPathExpression() != NULL)
								&& (rParsedInfo.GetCmdSwitchesObject().
											GetWhereExpression() == NULL))
							{
								bInstanceLevel = FALSE;
							}
							else
								bInstanceLevel = TRUE;
						}
					}
					else
						bInstanceLevel = TRUE;
				}
				
				if(bInstanceLevel)
				{
					WMIFormatMessage(IDS_I_METH_EXEC_PROMPT2, 2, bstrMsg, 
										(LPWSTR) bstrPath,	pszMethodName);
					interOption = GetUserResponseEx((LPWSTR)bstrMsg);
				}
				else
				{
					WMIFormatMessage(IDS_I_METH_EXEC_PROMPT, 2, bstrMsg, 
										(LPWSTR) bstrPath,	pszMethodName);
					interOption = GetUserResponse((LPWSTR)bstrMsg);
				}
				
				if ( interOption == YES || interOption == NO )
					break;
				else if(interOption == HELP)
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetInformationCode(0);
					ProcessSHOWInfo(rParsedInfo, FALSE, (LPWSTR)bstrPath);
				}
			}
		}
		
		if ( interOption == YES )
		{
			if (IsInteractive(rParsedInfo) == FALSE)
			{
				_bstr_t bstrMsg;
				WMIFormatMessage(IDS_I_METH_EXEC_STATUS, 2, bstrMsg, 
									(LPWSTR) bstrPath,	pszMethodName);
				DisplayMessage((LPWSTR)bstrMsg, CP_OEMCP, FALSE, TRUE);
			}

			// Execute the method with the given input arguments
			hr = m_pITargetNS->ExecMethod(bstrPath,
								_bstr_t(rParsedInfo.GetCmdSwitchesObject()
													.GetMethodName()),
				   				0L,				
								NULL,			
								pIInParam,		
								&pIOutParam,	
								NULL);			
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemServices::ExecMethod(L\"%s\", L\"%s\", "
					L"0, NULL, -, -, NULL)", (LPWSTR) bstrPath, 
					rParsedInfo.GetCmdSwitchesObject().GetMethodName()
					? rParsedInfo.GetCmdSwitchesObject().GetMethodName()
					: L"<null>");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
					dwThreadId,	rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			DisplayString(IDS_I_CALL_SUCCESS, CP_OEMCP, NULL, FALSE, TRUE);

			// Check the method execution status.
			if(pIOutParam)
			{
				_TCHAR szMsg[BUFFER1024] = NULL_STRING;
				rParsedInfo.GetCmdSwitchesObject().
											 SetMethExecOutParam(pIOutParam);

				DisplayMethExecOutput(rParsedInfo);
			}
			SAFEIRELEASE(pIOutParam);
		}
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIOutParam);
		VARIANTCLEAR(varTemp);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIOutParam);
		VARIANTCLEAR(varTemp);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return hr;
}

/*------------------------------------------------------------------------
   Name				 :DisplayMethExecOutput
   Synopsis	         :Displays the result of execution of the method.
   Type	             :Member Function 
   Input Parameter(s):
		rParsedinfo	 - CParsedInfo object.
   Output Parameter(s):None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayMethExecOutput(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CExecEngine::DisplayMethExecOutput(CParsedInfo& rParsedInfo)
{
	HRESULT				hr					= S_OK;
	IWbemClassObject	*pIOutParam			= NULL;
	CHString			chsMsg;
	DWORD				dwThreadId			= GetCurrentThreadId();
	BSTR				pstrMofTextOfObj	=	NULL;		
	VARIANT				vtTemp;
	VariantInit(&vtTemp);

	try
	{
		_bstr_t				bstrResult;
		pIOutParam = rParsedInfo.GetCmdSwitchesObject().GetMethExecOutParam();
		if ( pIOutParam != NULL )
		{
			hr = pIOutParam->GetObjectText(0, &pstrMofTextOfObj);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemClassObject->GetObjectText(0, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
					dwThreadId,	rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);
			DisplayString(IDS_I_OUT_PARAMS,CP_OEMCP, NULL, FALSE, TRUE);
			DisplayMessage(_bstr_t(pstrMofTextOfObj), CP_OEMCP, FALSE, TRUE);
			DisplayMessage(_T("\n"), CP_OEMCP, TRUE, TRUE);
			SAFEBSTRFREE(pstrMofTextOfObj);
		}
	}
	catch(_com_error& e)
	{
		SAFEBSTRFREE(pstrMofTextOfObj);
		_com_issue_error(e.Error());
	}
	catch(CHeap_Exception)
	{
		SAFEBSTRFREE(pstrMofTextOfObj);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}

/*------------------------------------------------------------------------
   Name				 :ExecOtherCmdLineUtlty
   Synopsis	         :Invokes other command line utility specified in 
					  Derivation of Verb if Verb Type is "CommandLine"
   Type	             :Member Function 
   Input Parameter(s):
		rParsedinfo	 - CParsedInfo object.
   Output Parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ExecOtherCmdLineUtlty(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::ExecOtherCmdLineUtlty(CParsedInfo& rParsedInfo)
{
	BOOL	bRet				= TRUE;
	BOOL	bInvalidNoOfArgs	= FALSE;
	
	if ( rParsedInfo.GetCmdSwitchesObject().GetNamedParamListFlag() == FALSE )
	{
		METHDETMAP mdpMethDetMap = 
						 rParsedInfo.GetCmdSwitchesObject().GetMethDetMap();
		METHDETMAP::iterator iMethDetMapItr = mdpMethDetMap.begin();
		METHODDETAILS mdMethDet = (*iMethDetMapItr).second;
		
		CHARVECTOR cvInParams = 
			rParsedInfo.GetCmdSwitchesObject().GetPropertyList();

		PROPDETMAP pdmPropDetMap = mdMethDet.Params;
		if ( !pdmPropDetMap.empty() )
		{
			if ( pdmPropDetMap.size() != cvInParams.size() )
				bInvalidNoOfArgs = TRUE;
		}
	}
													   
	if ( bInvalidNoOfArgs == TRUE )
	{
		rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											IDS_E_INVALID_NO_OF_PARAMS);
		bRet = FALSE;
	}
	else
	{
		HRESULT hr = FormQueryAndExecuteMethodOrUtility(rParsedInfo);
		bRet = FAILED(hr) ? FALSE : TRUE;
	}

	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :ProcessDELETEVerb
   Synopsis	         :Processes the DELETE verb referring to the information
					  available with CParsedInfo object.
   Type	             :Member Function
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :
   		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ProcessDELETEVerb(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::ProcessDELETEVerb(CParsedInfo& rParsedInfo)
{
	// DELETE verb processing
	BOOL	 bRet			= TRUE;
	HRESULT	 hr				= S_OK;
	
	try
	{
		_bstr_t  bstrQuery(""), bstrObject("");
		// If anyone of the following is specified:
		// a) PATH <path expr>
		// b) PATH <class path expr> WHERE <where expr>
		if (rParsedInfo.GetCmdSwitchesObject().GetPathExpression() != NULL)
		{
			_bstr_t bstrClass = _bstr_t(rParsedInfo.GetCmdSwitchesObject()
												.GetClassPath());

			bstrObject = _bstr_t(rParsedInfo.GetCmdSwitchesObject()
											.GetPathExpression());

			// Form the query
			bstrQuery = _bstr_t(L"SELECT * FROM ") + bstrClass ;

			// If WHERE expresion is given
			if (rParsedInfo.GetCmdSwitchesObject().
								GetWhereExpression() != NULL)
			{
				bstrQuery +=	_bstr_t(L" WHERE ") 
								+ _bstr_t(rParsedInfo.GetCmdSwitchesObject()
														.GetWhereExpression());
			}
		}
		// If <alias> WHERE expression is specified.
		else if (rParsedInfo.GetCmdSwitchesObject().GetWhereExpression() 
			!= NULL)
		{
			rParsedInfo.GetCmdSwitchesObject().
								GetClassOfAliasTarget(bstrObject); 
			bstrQuery = _bstr_t(L"SELECT * FROM ") 
						+  bstrObject  
						+ _bstr_t(L" WHERE ") 
						+ _bstr_t(rParsedInfo.GetCmdSwitchesObject()
												.GetWhereExpression());
		}
		// If CLASS is specified.
		else if (rParsedInfo.GetCmdSwitchesObject().GetClassPath() != NULL)
		{
			bstrObject = _bstr_t(rParsedInfo.GetCmdSwitchesObject()
												.GetClassPath());
		}
		// if Alias name is specified
		else 
		{
			rParsedInfo.GetCmdSwitchesObject().
								GetClassOfAliasTarget(bstrObject); 
			bstrQuery = _bstr_t (L"SELECT * FROM ")
						+bstrObject;
		}

		// Connect to WMI namespace
		if (m_pITargetNS == NULL)
		{
			if ( IsFailFastAndNodeExist(rParsedInfo) == TRUE )
			{
				hr = ConnectToTargetNS(rParsedInfo);
				ONFAILTHROWERROR(hr);
			}
			else
				hr = -1; // Explicitly set error
		}

		if (SUCCEEDED(hr))
			bRet = DeleteObjects(rParsedInfo, bstrQuery, bstrObject);
		else
			bRet = FALSE;
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
		bRet = FALSE;
	}

	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :DeleteObjects
   Synopsis	         :This function deletes the instances(s) or class 
					  specified for deletion.
   Type	             :Member Function
   Input parameter   :
		rParsedInfo  - reference to the CParsedInfo object 
		bstrQuery    - String consist of WQL query
		bstrObject   - String consist of object path
   Output parameters :
		rParsedInfo  - reference to the CParsedInfo object 
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :DeleteObjects(rParsedInfo, bstrQuery, bstrObject)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::DeleteObjects(CParsedInfo& rParsedInfo, 
								 _bstr_t& bstrQuery, _bstr_t& bstrObject)
{
	HRESULT					hr					= S_OK;
	BOOL					bSuccess			= TRUE;
	IEnumWbemClassObject	*pIEnumObj			= NULL;		
	IWbemClassObject		*pIWbemObj			= NULL;
	ULONG					ulReturned			= 0;
	INTEROPTION				interOption			= YES;
	CHString				chsMsg;
	DWORD					dwThreadId			= GetCurrentThreadId();
	VARIANT					vtPath;
	VariantInit(&vtPath);

	try
	{ 
		_bstr_t					bstrResult;
		if (bstrQuery == _bstr_t(""))
		{
			// If /INTERACTIVE switch is specified, obtain the user response.
			if (IsInteractive(rParsedInfo) == TRUE)
			{
				_bstr_t bstrMsg;
				while ( TRUE )
				{
					if(IsClassOperation(rParsedInfo))
					{
						WMIFormatMessage(IDS_I_DELETE_CLASS_PROMPT, 1, bstrMsg, 
									(LPWSTR) bstrObject);
						interOption = GetUserResponse((LPWSTR)bstrMsg);
					}
					else
					{
					   WMIFormatMessage(IDS_I_DELETE_CLASS_PROMPT2, 1, bstrMsg, 
									(LPWSTR) bstrObject);
						interOption = GetUserResponseEx((LPWSTR)bstrMsg);
					}

					if ( interOption == YES || interOption == NO )
						break;
					else if(interOption == HELP)
					{
						rParsedInfo.GetCmdSwitchesObject().
								SetInformationCode(0);
						ProcessSHOWInfo(rParsedInfo, FALSE, 
								(LPWSTR)bstrObject);
					}
				}
			}
					
			if (interOption == YES)
			{
				// If instance path is specified then delete the instance 
				// properties otherwise delete the class
				if(!rParsedInfo.GetCmdSwitchesObject().GetWhereExpression()) 
				{
					// If WHERE expression is NULL then delete the WMI class
					hr = m_pITargetNS->DeleteClass(bstrObject, 0, NULL, NULL);

					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(L"IWbemServices::DeleteClass"
							L"(L\"%s\", 0, NULL, NULL)", (LPWSTR)bstrObject);
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
							(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, m_bTrace);
					}
					ONFAILTHROWERROR(hr);
					DisplayString(IDS_I_DELETE_SUCCESS,CP_OEMCP, 
							NULL, FALSE, TRUE);
				}
				else
				{
						// If WHERE expression is not NULL then delete the 
						// WMI instance
						DisplayString(IDS_I_DELETING_INSTANCE,
										CP_OEMCP,(LPWSTR)vtPath.bstrVal,
										FALSE, TRUE);
						hr = m_pITargetNS->DeleteInstance(bstrObject,
												0, NULL, NULL);
						if (m_bTrace || m_eloErrLogOpt)
						{
							chsMsg.Format(L"IWbemServices::DeleteInstance"
								L"(L\"%s\", 0, NULL, NULL)", 
								(LPWSTR) bstrObject);
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__,
								(LPCWSTR)chsMsg, dwThreadId, rParsedInfo,
								 m_bTrace);
						}
						ONFAILTHROWERROR(hr);
						DisplayString(IDS_I_INSTANCE_DELETE_SUCCESS,
							CP_OEMCP, NULL,	FALSE, TRUE);
				}
			}
		}
		else 
		{
			// Execute the query to get collection of objects
			hr = m_pITargetNS->ExecQuery(_bstr_t(L"WQL"), bstrQuery,
								0, NULL, &pIEnumObj);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemServices::ExecQuery(L\"WQL\"," 
							L"L\"%s\", 0, NULL, -)", (LPWSTR)bstrQuery);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
					dwThreadId,	rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			
			// Set the interface security
			hr = SetSecurity(pIEnumObj, 
					rParsedInfo.GetGlblSwitchesObject().GetAuthority(),
					rParsedInfo.GetNode(),
					rParsedInfo.GetUser(),
					rParsedInfo.GetPassword(),
					rParsedInfo.GetGlblSwitchesObject().
								GetAuthenticationLevel(),
					rParsedInfo.GetGlblSwitchesObject().
								GetImpersonationLevel());
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"CoSetProxyBlanket(-, RPC_C_AUTHN_WINNT, "
					L"RPC_C_AUTHZ_NONE, NULL, %d,   %d, -, EOAC_NONE)",
					rParsedInfo.GetGlblSwitchesObject().
								GetAuthenticationLevel(),
					rParsedInfo.GetGlblSwitchesObject().
								GetImpersonationLevel());
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
					dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);


			BOOL bInstances		= FALSE;
			BOOL bInteractive	= IsInteractive(rParsedInfo);

			hr = pIEnumObj->Next(WBEM_INFINITE, 1, &pIWbemObj, &ulReturned);
			
			// Set this property in all objects of the collection
			while (ulReturned == 1)
 			{
				INTEROPTION	interOption	= YES;
				bInstances  = TRUE;
				VariantInit(&vtPath);

				// Get the object path.
				hr = pIWbemObj->Get(_bstr_t(L"__PATH"), 0, &vtPath, NULL, NULL);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(
							L"IWbemClassObject::Get(L\"__PATH\", 0, -, 0, 0)"); 
					GetBstrTFromVariant(vtPath, bstrResult);
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
						dwThreadId, rParsedInfo, m_bTrace, 0, bstrResult);
				}
				ONFAILTHROWERROR(hr);

				// If /INTERACTIVE switch is specified, obtain user response.
				if (IsInteractive(rParsedInfo) == TRUE)
				{
					_bstr_t bstrMsg;
					while ( TRUE )
					{
						if(IsClassOperation(rParsedInfo))
						{
							WMIFormatMessage(IDS_I_DELETE_CLASS_PROMPT, 
								1, bstrMsg, (LPWSTR) vtPath.bstrVal);
							interOption = GetUserResponse((LPWSTR)bstrMsg);
						}
						else
						{
							WMIFormatMessage(IDS_I_DELETE_CLASS_PROMPT2, 1, 
								bstrMsg, (LPWSTR) vtPath.bstrVal);
							interOption = GetUserResponseEx((LPWSTR)bstrMsg);
						}

						if ( interOption == YES || interOption == NO )
							break;
						else if(interOption == HELP)
						{
							rParsedInfo.GetCmdSwitchesObject().
									SetInformationCode(0);
							ProcessSHOWInfo(rParsedInfo, FALSE, 
									(LPWSTR)vtPath.bstrVal);
						}
					}
				}
					
				if (interOption == YES)
				{
					DisplayString(IDS_I_DELETING_INSTANCE,
								CP_OEMCP,(LPWSTR)vtPath.bstrVal, FALSE, TRUE);
					hr = m_pITargetNS->DeleteInstance(vtPath.bstrVal,
											0, NULL, NULL);
					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(L"IWbemServices::DeleteInstance"
							L"(L\"%s\", 0, NULL, NULL)", 
							(LPWSTR) vtPath.bstrVal);
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
						 (LPCWSTR)chsMsg, dwThreadId, rParsedInfo, m_bTrace);
					}
					ONFAILTHROWERROR(hr);
														
				
					VARIANTCLEAR(vtPath);
					SAFEIRELEASE(pIWbemObj);
					DisplayString(IDS_I_INSTANCE_DELETE_SUCCESS,CP_OEMCP,
								NULL, FALSE, TRUE);
				}
				hr = pIEnumObj->Next( WBEM_INFINITE, 1, &pIWbemObj, 
						&ulReturned);
			}
			SAFEIRELEASE(pIEnumObj);

			// If no instances are available
			if (!bInstances)
			{
				rParsedInfo.GetCmdSwitchesObject().
					SetInformationCode(IDS_I_NO_INSTANCES);
			}
		}
	}
	catch(_com_error& e)
	{
		VARIANTCLEAR(vtPath);
		SAFEIRELEASE(pIEnumObj);
		SAFEIRELEASE(pIWbemObj);
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bSuccess = FALSE;
	}
	catch(CHeap_Exception)
	{
		VARIANTCLEAR(vtPath);
		SAFEIRELEASE(pIEnumObj);
		SAFEIRELEASE(pIWbemObj);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return bSuccess;
}

/*------------------------------------------------------------------------
   Name				 :GetUserResponse
   Synopsis	         :This function accepts the user response before going
					  ahead, when /INTERACTIVE is specified at the verb 
					  level
   Type	             :Member Function
   Input parameter   :
			pszMsg	 - message to be displayed.
   Output parameters :None
   Return Type       :INTEROPTION
   Global Variables  :None
   Calling Syntax    :GetUserResponse(pszMsg)
   Notes             :None
------------------------------------------------------------------------*/
INTEROPTION CExecEngine::GetUserResponse(_TCHAR* pszMsg)
{
	INTEROPTION bRet				= YES;
	_TCHAR 		szResp[BUFFER255]	= NULL_STRING;
	_TCHAR *pBuf					= NULL;

	if (pszMsg == NULL)
		bRet = NO;

	if(bRet != NO)
	{
		// Get the user response, till 'Y' - yes or 'N' - no
		// is keyed in
		while(TRUE)
		{
			DisplayMessage(pszMsg, CP_OEMCP, TRUE, TRUE);
			pBuf = _fgetts(szResp, BUFFER255-1, stdin);
			if(pBuf != NULL)
			{
				LONG lInStrLen = lstrlen(szResp);
				if(szResp[lInStrLen - 1] == _T('\n'))
						szResp[lInStrLen - 1] = _T('\0');
			}
			else if ( g_wmiCmd.GetBreakEvent() != TRUE )
			{
				lstrcpy(szResp, RESPONSE_NO);
				DisplayMessage(_T("\n"), CP_OEMCP, TRUE, TRUE);
			}

			if ( g_wmiCmd.GetBreakEvent() == TRUE )
			{
				g_wmiCmd.SetBreakEvent(FALSE);
				lstrcpy(szResp, RESPONSE_NO);
				DisplayMessage(_T("\n"), CP_OEMCP, TRUE, TRUE);
			}
			if (CompareTokens(szResp, RESPONSE_YES)
				|| CompareTokens(szResp, RESPONSE_NO))
				break;
		}
		if (CompareTokens(szResp, RESPONSE_NO))
			bRet = NO;
	}
	
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :ProcessCREATEVerb
   Synopsis	         :Processes the CREATE verb referring to the information
					  available with CParsedInfo object.
   Type	             :Member Function
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :
   		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ProcessCREATEVerb(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::ProcessCREATEVerb(CParsedInfo& rParsedInfo)
{ 
	// CREATE verb processing
	BOOL		bRet		= TRUE;
	INTEROPTION	interCreate	= YES;
	HRESULT		hr			= S_OK;
	
	try
	{
		_bstr_t		bstrClass("");
		// If object PATH expression is specified.
		if (rParsedInfo.GetCmdSwitchesObject().GetPathExpression() != NULL)
		{
			bstrClass = _bstr_t(rParsedInfo.GetCmdSwitchesObject()
												.GetClassPath());
		}
		// If CLASS is specified.
		else if (rParsedInfo.GetCmdSwitchesObject().GetClassPath() != NULL)
		{
			bstrClass = _bstr_t(rParsedInfo.GetCmdSwitchesObject()
												.GetClassPath());
		}
		// if Alias name is specified
		else 
		{
			rParsedInfo.GetCmdSwitchesObject().
					GetClassOfAliasTarget(bstrClass);
		}

		// Check if interactive mode 
		if (IsInteractive(rParsedInfo) == TRUE)
		{
			_bstr_t bstrMsg;
			WMIFormatMessage(IDS_I_CREATE_INST_PROMPT, 1, 
								bstrMsg, (LPWSTR) bstrClass);
			// Get the user response.
			interCreate = GetUserResponse((LPWSTR)bstrMsg);
		}
		if (interCreate == YES)
		{
			// Connect to WMI namespace
			if (m_pITargetNS == NULL)
			{
				if ( IsFailFastAndNodeExist(rParsedInfo) == TRUE )
				{
					hr = ConnectToTargetNS(rParsedInfo);
					ONFAILTHROWERROR(hr);
				}
				else
					hr = -1; // Explicitly set error
			}

			if (SUCCEEDED(hr))
			{
				// Validate the property values against the property
				// qualifier information if available.
				if (rParsedInfo.GetCmdSwitchesObject().GetAliasName() != NULL)
				{
					// Validate the input parameters against the alias
					// qualifier information.
					bRet = ValidateAlaisInParams(rParsedInfo);
				}
				else
				{
					// Validate the input parameters against the class
					// qualifier information
					bRet = ValidateInParams(rParsedInfo, bstrClass);
				}

				if (bRet)
				{
					// Set the values passed as input to the appropriate properties.
					bRet = CreateInstance(rParsedInfo, bstrClass);
				}
			}
			else
				bRet = FALSE;
		}
		else
		{
			// Message to be displayed to the user
			rParsedInfo.GetCmdSwitchesObject().
						SetInformationCode(IDS_I_NOCREATE);
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
		bRet = FALSE;
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :CreateInstance
   Synopsis	         :This function creates an instance of the specified 
					  class 
   Type	             :Member Function
   Input parameter   :
		rParsedInfo  - reference to the CParsedInfo object 
		bstrClass	 - classname
   Output parameters :
		rParsedInfo  - reference to the CParsedInfo object 
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :CreateInstance(rParsedInfo, bstrClass)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::CreateInstance(CParsedInfo& rParsedInfo, BSTR bstrClass)
{
	HRESULT					hr					= S_OK;
	IWbemClassObject		*pIWbemObj			= NULL;
	IWbemClassObject		*pINewInst			= NULL;
	IWbemQualifierSet		*pIQualSet			= NULL;
	BOOL					bSuccess			= TRUE;
	DWORD					dwThreadId			= GetCurrentThreadId();
	CHString				chsMsg;
	VARIANT					varType, 
							varSrc, 
							varDest;
	VariantInit(&varSrc);
	VariantInit(&varDest);
	VariantInit(&varType);
	
	
	// Obtain the list of properties and their associated values
	BSTRMAP theMap = rParsedInfo.GetCmdSwitchesObject().GetParameterMap();
	BSTRMAP::iterator theIterator = NULL;
	theIterator = theMap.begin();
	try
	{
		_bstr_t					bstrResult;
		// Get the class definition
		hr = m_pITargetNS->GetObject(bstrClass,
									 0, NULL, &pIWbemObj, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", 0, NULL, -)", 
					(LPWSTR) bstrClass);		
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
				dwThreadId,	rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

	    // Create a new instance.
	    hr = pIWbemObj->SpawnInstance(0, &pINewInst);
		if ( m_eloErrLogOpt )
		{
			chsMsg.Format(L"IWbemClassObject::SpawnInstance(0, -)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
				dwThreadId, rParsedInfo, FALSE);
		}
		ONFAILTHROWERROR(hr);


		PROPDETMAP pdmPropDetMap = rParsedInfo.GetCmdSwitchesObject().
														  GetPropDetMap();
		PROPDETMAP::iterator itrPropDetMap;

		// Update all properties
		while (theIterator != theMap.end())
		{
			// Get the propert name and the corresponding value 
			_bstr_t bstrProp = _bstr_t((_TCHAR*)(*theIterator).first);
		
			// Get the derivation of property name
			if ( Find(pdmPropDetMap, bstrProp, itrPropDetMap) == TRUE &&
				!((*itrPropDetMap).second.Derivation) == FALSE )
				bstrProp = (*itrPropDetMap).second.Derivation;

			// Obtain the property qualifier set for the property
   			hr = pINewInst->GetPropertyQualifierSet(bstrProp, &pIQualSet);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemClassObject::GetPropertyQualifierSet"
					L"(L\"%s\", -)", (LPWSTR) bstrProp);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
					dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			VariantInit(&varType);
			if (pIQualSet)
			{
				// Obtain the CIM type of the property
				hr = pIQualSet->Get(_bstr_t(L"CIMTYPE"), 0L, &varType, NULL);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemQualifierSet::Get(L\"CIMTYPE\", "
							L"0, -, NULL)"); 
					GetBstrTFromVariant(varType, bstrResult);
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							dwThreadId, rParsedInfo, m_bTrace, 0, bstrResult);
				}
				ONFAILTHROWERROR(hr);

				varSrc.vt = VT_BSTR;
				varSrc.bstrVal = SysAllocString((_TCHAR*)(*theIterator).second);

				hr = ConvertCIMTYPEToVarType(varDest, varSrc,
										 (_TCHAR*)varType.bstrVal);
				if ( m_eloErrLogOpt )
				{
					chsMsg.Format(L"VariantChangeType(-, -, 0, -)"); 
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
						dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);

				VARIANTCLEAR(varType);
				SAFEIRELEASE(pIQualSet);
			}
			
			// Update the property value
			hr = pINewInst->Put(bstrProp, 0, &varDest, 0);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemClassObject::Put(L\"%s\", 0, -, 0)",
							(LPWSTR) bstrProp); 
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
					dwThreadId,	rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			VARIANTCLEAR(varSrc);
			VARIANTCLEAR(varDest);
			theIterator++;
		}

		// Update the instance with the changes
		hr = m_pITargetNS->PutInstance(pINewInst, WBEM_FLAG_CREATE_ONLY,
					NULL, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemServices::PutInstance(-, "
						L"WBEM_FLAG_CREATE_ONLY, NULL, NULL)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
				dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);
		
		SAFEIRELEASE(pINewInst);
		rParsedInfo.GetCmdSwitchesObject().
						SetInformationCode(IDS_I_CREATE_SUCCESS);
	}
	catch(_com_error& e)
	{
		VARIANTCLEAR(varSrc);
		VARIANTCLEAR(varDest);
		VARIANTCLEAR(varType);
		SAFEIRELEASE(pIQualSet);
		SAFEIRELEASE(pIWbemObj);
		SAFEIRELEASE(pINewInst);

		// Store the COM error and set the return value to FALSE
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bSuccess = FALSE;
	}
	catch(CHeap_Exception)
	{
		VARIANTCLEAR(varSrc);
		VARIANTCLEAR(varDest);
		VARIANTCLEAR(varType);
		SAFEIRELEASE(pIQualSet);
		SAFEIRELEASE(pIWbemObj);
		SAFEIRELEASE(pINewInst);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return bSuccess;
}

/*------------------------------------------------------------------------
   Name				 :ValidateInParams
   Synopsis	         :Validates the property value specified against the 
					  property qualifiers for that property (i.e checking 
					  against the contents of following qualifiers if 
					  available:
					  1. MaxLen,
					  2. ValueMap
					  3. Values
   Type	             :Member Function 
   Input Parameter(s):
		rParsedinfo	 - CParsedInfo object.
		bstrClass	 - Bstr type, class name.
   Output Parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ValidateInParams(rParsedInfo, bstrClass)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::ValidateInParams(CParsedInfo& rParsedInfo, _bstr_t bstrClass)
{
	HRESULT				hr					= S_OK;
	IWbemClassObject	*pIObject			= NULL;
	IWbemQualifierSet	*pIQualSet			= NULL;
	BOOL				bRet				= TRUE;
	CHString			chsMsg;
	VARIANT				varMap, 
						varValue, 
						varLen;
	VariantInit(&varMap);
	VariantInit(&varValue);
	VariantInit(&varLen);
	BSTRMAP theMap = rParsedInfo.GetCmdSwitchesObject().GetParameterMap();
	BSTRMAP::iterator theIterator = theMap.begin();
	DWORD dwThreadId = GetCurrentThreadId();
	
	try
	{
		// Obtain the class schema
		hr = m_pITargetNS->GetObject(bstrClass,                           
						WBEM_FLAG_RETURN_WBEM_COMPLETE | 
						WBEM_FLAG_USE_AMENDED_QUALIFIERS,
							NULL,                        
							&pIObject,    
							NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
		  chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", "
			L"WBEM_FLAG_RETURN_WBEM_COMPLETE|WBEM_FLAG_USE_AMENDED_QUALIFIERS,"
			L" 0, NULL, -)", (LPWSTR) bstrClass);		
		  WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, dwThreadId, 
			  rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Loop through the list of available properties.
		while (theIterator != theMap.end())
		{
			// Get the property name and the corresponding value.
			_bstr_t bstrProp	= _bstr_t((_TCHAR*)(*theIterator).first);
			WCHAR*	pszValue	= (LPWSTR)(*theIterator).second;
			
			// Check the value against the qualifier information
			bRet = CheckQualifierInfo(rParsedInfo, pIObject, 
										bstrProp, pszValue);
			if (bRet)
			{
				// A mapping between 'Values' and 'ValueMaps' is possible, 
				// hence update the parameter value to reflect the change.
				rParsedInfo.GetCmdSwitchesObject().
					UpdateParameterValue(bstrProp, _bstr_t(pszValue));
			}
			else
				break;
			theIterator++;
		}
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIObject);
		SAFEIRELEASE(pIQualSet);
		VARIANTCLEAR(varMap);
		VARIANTCLEAR(varValue);
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bRet = FALSE;
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIObject);
		SAFEIRELEASE(pIQualSet);
		VARIANTCLEAR(varMap);
		VARIANTCLEAR(varValue);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :IsInteractive()
   Synopsis	         :Checks whether user has to be prompted for response
   Type	             :Member Function 
   Input Parameter(s):
		rParsedinfo	 - reference to CParsedInfo class object.
   Output Parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :IsInteractive(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::IsInteractive(CParsedInfo& rParsedInfo)
{
	BOOL bInteractive = FALSE;

	// Get the status of /INTERACTIVE global switch.
	bInteractive = rParsedInfo.GetGlblSwitchesObject().
						GetInteractiveStatus();

	// If /NOINTERACTIVE specified at the verb level.
	if (rParsedInfo.GetCmdSwitchesObject().
					GetInteractiveMode() == NOINTERACTIVE)
	{
		bInteractive = FALSE;
	}
	else if (rParsedInfo.GetCmdSwitchesObject().
					GetInteractiveMode() == INTERACTIVE)
	{
		bInteractive = TRUE;
	}
	return bInteractive;
}

/*------------------------------------------------------------------------
   Name				 :CheckQualifierInfo
   Synopsis	         :Validates the parameter value specified against the 
					  parameter qualifiers for that parameter(i.e checking 
					  against the contents of following qualifiers if 
					  available:
					  1. MaxLen,
					  2. ValueMap
					  3. Values
   Type	             :Member Function 
   Input Parameter(s):
		rParsedinfo	 - CParsedInfo object.
		pIMethodSign - input signature of the method.
		bstrParam	 - parameter name
		pszValue	 - new value.
   Output Parameter(s):
		pszValue	 - new value.
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :CheckQualifierInfo(rParsedInfo, pIMethodSign,
											bstrParam, pszValue)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::CheckQualifierInfo(CParsedInfo& rParsedInfo,
									  IWbemClassObject *pIObject,
									  _bstr_t bstrParam,
									  WCHAR*& pszValue)
{
	HRESULT				hr					= S_OK;
	IWbemQualifierSet	*pIQualSet			= NULL;
	BOOL				bRet				= TRUE;
	CHString			chsMsg;
	DWORD				dwThreadId			= GetCurrentThreadId();
	VARIANT				varMap, 
						varValue,
						varLen;
	VariantInit(&varMap);
	VariantInit(&varValue);
	VariantInit(&varLen);
	
	try
	{
		BOOL bFound	= FALSE;
		
		// Obtain the property qualifier set for the parameter.
		hr= pIObject->GetPropertyQualifierSet(bstrParam, &pIQualSet);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemClassObject::GetPropertyQualifierSet"
					L"(L\"%s\", -)", (LPWSTR) bstrParam);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
				dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Check whether the 'Maxlen' qualifier is applicable.
		pIQualSet->Get(_bstr_t(L"MaxLen"), 0, &varLen, NULL);
		if (varLen.vt != VT_EMPTY && varLen.vt != VT_NULL)
		{
			// If the property value length exceeds maximum length
			// allowed set the return value to FALSE
			if (lstrlen(pszValue) > varLen.lVal)
			{
				rParsedInfo.GetCmdSwitchesObject().
					SetErrataCode(IDS_E_VALUE_EXCEEDS_MAXLEN);
				bRet = FALSE;
			}
		}
		VARIANTCLEAR(varLen);

		if (bRet)
		{
			// Obtain the 'ValueMap' qualifier contents if present
			pIQualSet->Get(_bstr_t(L"ValueMap"), 0, &varMap, NULL);
			if (varMap.vt != VT_EMPTY && varMap.vt != VT_NULL)
			{

				// Get lower and upper bounds of Descriptions array
				LONG lUpper = 0, lLower = 0;
				hr = SafeArrayGetLBound(varMap.parray, varMap.parray->cDims, 
										&lLower);
				if ( m_eloErrLogOpt )
				{
					chsMsg.Format(L"SafeArrayGetLBound(-, -, -)"); 
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
						dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);

				hr = SafeArrayGetUBound(varMap.parray, varMap.parray->cDims,
										&lUpper);
				if ( m_eloErrLogOpt )
				{
					chsMsg.Format(L"SafeArrayGetUBound(-, -, -)"); 
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
						dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);

				for (LONG lIndex = lLower; lIndex <= lUpper; lIndex++) 
				{
					void* pv = NULL;
					hr = SafeArrayGetElement(varMap.parray, &lIndex, &pv);
					if ( m_eloErrLogOpt )
					{
						chsMsg.Format(L"SafeArrayGetElement(-, -, -)"); 
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
							(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, FALSE);
					}
					ONFAILTHROWERROR(hr);

					// Check whether the property value is available with the
					// value map entries.
					if (CompareTokens(pszValue, (_TCHAR*)pv))
					{
						bFound = TRUE;
						break;
					}
				}
				bRet = bFound;
			}
			
			// If not found in the ValueMap
			if (!bRet || !bFound)
			{
				// Obtain the 'Values' qualifier contents if present
				pIQualSet->Get(_bstr_t(L"Values"), 0, &varValue, NULL);
				if (varValue.vt != VT_EMPTY && varValue.vt != VT_NULL)
				{
					// Get lower and upper bounds of Descriptions array
					LONG lUpper = 0, lLower = 0;
					hr = SafeArrayGetLBound(varValue.parray, 
							varValue.parray->cDims, &lLower);
					if ( m_eloErrLogOpt )
					{
						chsMsg.Format(L"SafeArrayGetLBound(-, -, -)"); 
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
							(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, FALSE);
					}
					ONFAILTHROWERROR(hr);

					hr = SafeArrayGetUBound(varValue.parray, 
							varValue.parray->cDims,	&lUpper);
					if ( m_eloErrLogOpt )
					{
						chsMsg.Format(L"SafeArrayGetUBound(-, -, -)"); 
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
							(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, FALSE);
					}
					ONFAILTHROWERROR(hr);

					for (LONG lIndex = lLower; lIndex <= lUpper; lIndex++) 
					{
						void *pv = NULL;
						hr = SafeArrayGetElement(varValue.parray, 
								&lIndex, &pv);
						if ( m_eloErrLogOpt )
						{
							chsMsg.Format(L"SafeArrayGetElement(-, -, -)"); 
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__,
							 (LPCWSTR)chsMsg, dwThreadId, rParsedInfo, FALSE);
						}
						ONFAILTHROWERROR(hr);

						// Check for any matching entry.
						if (CompareTokens(pszValue, (_TCHAR*)pv))
						{
							void* pmv = NULL;
							if (varMap.vt != VT_EMPTY && varMap.vt != VT_NULL)
							{
								// obtain the correponding ValueMap entry.
								hr = SafeArrayGetElement(varMap.parray, 
										&lIndex, &pmv);
								if ( m_eloErrLogOpt )
								{
									chsMsg.Format(
										L"SafeArrayGetElement(-, -, -)"); 
									WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
										(LPCWSTR)chsMsg, dwThreadId, 
										rParsedInfo, FALSE);
								}
								ONFAILTHROWERROR(hr);

								// Modify the current property value 
								// (i.e 'Values' to 'ValueMap' content)
								lstrcpy(pszValue, ((_TCHAR*)pmv));

							}
							// Only 'Values' qualifier available
							else
							{
								_TCHAR szTemp[BUFFER255] = NULL_STRING;
								_itot(lIndex, szTemp, 10);
								// Modify the current property value 
								// (i.e 'Values' entry to index)
								lstrcpy(pszValue, szTemp);
							}

							bFound = TRUE;
							break;
						}

					}
					// If not match found in 'ValueMap' and 'Values' qualifier
					// list
					if (!bFound)
					{
						rParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(IDS_E_VALUE_NOTFOUND);
					}
					bRet = bFound;
				}
			}	
			VARIANTCLEAR(varValue);
			VARIANTCLEAR(varMap);
		}
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIQualSet);
		VARIANTCLEAR(varMap);
		VARIANTCLEAR(varValue);
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bRet = FALSE;
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIQualSet);
		VARIANTCLEAR(varMap);
		VARIANTCLEAR(varValue);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :ValidateAlaisInParams
   Synopsis	         :Validates the property value specified against the 
					  property qualifiers available for that property 
					  from the <alias> definition (i.e checking 
					  against the contents of following qualifiers if 
					  available:
					  1. MaxLen,
					  2. ValueMap
					  3. Values
   Type	             :Member Function 
   Input Parameter(s):
		rParsedinfo	 - reference to CParsedInfo object.
   Output Parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ValidateAlaisInParams(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::ValidateAlaisInParams(CParsedInfo& rParsedInfo)
{
	BOOL				bRet				= TRUE;
	//_TCHAR				szMsg[BUFFER1024]	= NULL_STRING;
	BSTRMAP				theParamMap;
	BSTRMAP::iterator	theIterator			= NULL;
	DWORD				dwThreadId			= GetCurrentThreadId();
	PROPDETMAP			pdmPropDetMap;

	// Get the property details map.
	pdmPropDetMap = rParsedInfo.GetCmdSwitchesObject().GetPropDetMap();

	// If the property details are available
	if (!pdmPropDetMap.empty())
	{
		// Get the parameters map
		theParamMap = rParsedInfo.GetCmdSwitchesObject().GetParameterMap();
		theIterator = theParamMap.begin();


		try
		{
			// Loop through the list of available parameters
			while (theIterator != theParamMap.end())
			{
				// Get the property name and the corresponding value.
				_bstr_t bstrProp	= _bstr_t((_TCHAR*)(*theIterator).first);
				WCHAR*	pszValue	= (LPWSTR)(*theIterator).second;
				
				// Check the value against the qualifier information
				bRet = CheckAliasQualifierInfo(rParsedInfo, bstrProp, 
									pszValue, pdmPropDetMap);
				if (bRet)
				{
					// A mapping between 'Values' and 'ValueMaps' is possible, 
					// hence update the parameter value to reflect the change.
					rParsedInfo.GetCmdSwitchesObject().
						UpdateParameterValue(bstrProp, _bstr_t(pszValue));
				}
				else
					break;
				theIterator++;
			}
		}
		catch(_com_error& e)
		{
			_com_issue_error(e.Error());
			bRet = FALSE;
		}
		catch(...)
		{
			bRet = FALSE;
		}
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :CheckAliasQualifierInfo
   Synopsis	         :Validates the parameter value specified against the 
					  parameter qualifiers for that parameter from the 
					  <alias> definition (i.e checking 
					  against the contents of following qualifiers if 
					  available:
					  1. MaxLen,
					  2. ValueMap
					  3. Values
   Type	             :Member Function 
   Input Parameter(s):
		rParsedinfo		- CParsedInfo object.
		bstrParam		- parameter name
		pszValue		- new value.
		pdmPropDetMap	- property details map
   Output Parameter(s):
		pszValue	 - new value
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :CheckAliasQualifierInfo(rParsedInfo, bstrParam, 
											pszValue, pdmPropDetMap)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::CheckAliasQualifierInfo(CParsedInfo& rParsedInfo,
												_bstr_t bstrParam,
												WCHAR*& pszValue,
												PROPDETMAP pdmPropDetMap)
{
	BOOL						bRet				= TRUE,
								bFound				= FALSE;
	PROPDETMAP::iterator		propItrtrStart		= NULL;
	PROPDETMAP::iterator		propItrtrEnd		= NULL;

	QUALDETMAP					qualMap;
	QUALDETMAP::iterator		qualDetMap			= NULL;

	BSTRVECTOR::iterator		qualEntriesStart	= NULL;
	BSTRVECTOR::iterator		qualEntriesEnd		= NULL;
	BSTRVECTOR					qualVMEntries;
	BSTRVECTOR					qualVEntries;
	BSTRVECTOR					qualMEntries;

	propItrtrStart	= pdmPropDetMap.begin();
	propItrtrEnd	= pdmPropDetMap.end();

	try
	{
		while (propItrtrStart != propItrtrEnd)
		{	
			// If the property is found.
			if (CompareTokens( (LPWSTR)bstrParam, 
					((LPWSTR)(*propItrtrStart).first) ))
			{
				// Get the qualifier map
				qualMap = ((*propItrtrStart).second).QualDetMap;
				
				// Check if the qualifier information is available.
				if (!qualMap.empty())
				{
					// Check for the 'MaxLen' qualifier
					qualDetMap = qualMap.find(_bstr_t(L"MaxLen"));

					// If MaxLen qualifier information is available.
					if (qualDetMap != qualMap.end())
					{
						qualMEntries = (*qualDetMap).second;

						BSTRVECTOR::reference qualRef = qualMEntries.at(0);
						if (lstrlen(pszValue) > _wtoi((LPWSTR)qualRef))
						{
							rParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(IDS_E_VALUE_EXCEEDS_MAXLEN);
							bRet = FALSE;
						}
					}
					
					if (bRet)
					{
						// Check for the 'ValueMap' qualfiers
						qualDetMap = qualMap.find(_bstr_t(L"ValueMap"));

						// If 'ValueMap' qualifier information is available.
						if (qualDetMap  != qualMap.end())
						{
							// Get the qualifier entries vector
							qualVMEntries		= (*qualDetMap ).second;
							qualEntriesStart	= qualVMEntries.begin();
							qualEntriesEnd		= qualVMEntries.end();

							// Loop thru the available 'ValueMap' entries.
							while (qualEntriesStart != qualEntriesEnd)
							{
								// Check whether the property value is 
								// available with the value map entries.
								if (CompareTokens(pszValue, 
												(_TCHAR*)(*qualEntriesStart)))
								{
									bFound = TRUE;
									break;
								}
								
								// Move to next entry
								qualEntriesStart++;
							}
							bRet = bFound;
						}

						// If not found in the 'ValueMap' entries
						if (!bRet || !bFound)
						{
							// Check for the 'Values' qualfiers
							qualDetMap = qualMap.find(_bstr_t(L"Values"));

							// If 'Values' qualifier information is available.
							if (qualDetMap != qualMap.end())
							{
								// Get the qualifier entries vector
								qualVEntries		= (*qualDetMap).second;
								qualEntriesStart	= qualVEntries.begin();
								qualEntriesEnd		= qualVEntries.end();

								WMICLIINT nLoop = 0;
								// Loop thru the available 'Values' entries.
								while (qualEntriesStart != qualEntriesEnd)
								{
									// Check whether the property value is 
									// available with the value map entries.
									if (CompareTokens(pszValue, 
												(_TCHAR*)(*qualEntriesStart)))
									{
										// If 'ValueMap' entries are available.
										if (!qualVMEntries.empty())
										{
											//Get corresponding entry from 
											//'ValueMap'
											BSTRVECTOR::reference qualRef = 
													qualVMEntries.at(nLoop);

											lstrcpy(pszValue, 
													(_TCHAR*)(qualRef));
										}
										bFound = TRUE;
										break;
									}
									
									// Move to next entry
									qualEntriesStart++;
									nLoop++;
								}
								// If match not found in 'ValueMap' and 
								// 'Values' qualifier entries  list
								if (!bFound)
								{
									rParsedInfo.GetCmdSwitchesObject().
										SetErrataCode(IDS_E_VALUE_NOTFOUND);
								}
								bRet = bFound;
							}
						}
					}
				}	
				break;
			}
			else
				propItrtrStart++;
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
		bRet = FALSE;
	}
	return bRet;
}
			
/*------------------------------------------------------------------------
   Name				 :SubstHashAndExecCmdUtility
   Synopsis	         :Substitute hashes and execute command line utility.
					  If pIWbemObj != NULL then utility should be passed 
					  with appropriate instance values.
   Type	             :Member Function 
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo object.
		pIWbemObj	 - pointer to object of type IWbemClassObject. 
   Output Parameter(s):None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SubstHashAndExecCmdUtility(rParsedInfo, pIWbemObj) 
   Notes             :None
------------------------------------------------------------------------*/
void CExecEngine::SubstHashAndExecCmdUtility(CParsedInfo& rParsedInfo, 
											 IWbemClassObject *pIWbemObj)
{
	size_t				nHashPos	= 0;
	size_t				nAfterVarSpacePos = 0;
	LONG				lHashLen	= lstrlen(CLI_TOKEN_HASH);
	LONG				lSpaceLen	= lstrlen(CLI_TOKEN_SPACE);
	CHString			chsMsg;
	DWORD				dwThreadId			= GetCurrentThreadId();
	HRESULT				hr					= S_OK;
	BOOL				bSubstituted		= FALSE;
	VARIANT vtInstanceValue;
	VARIANT vtPath;
		
	try
	{
		_bstr_t				bstrResult;
		_bstr_t bstrVerbDerivation =
				  _bstr_t(rParsedInfo.GetCmdSwitchesObject().
					GetVerbDerivation());
		if ( bstrVerbDerivation == _bstr_t(CLI_TOKEN_NULL) )
			bstrVerbDerivation = CLI_TOKEN_SPACE;

		STRING	strCmdLine(bstrVerbDerivation);

		BOOL bNamedParamList = rParsedInfo.GetCmdSwitchesObject().
										  GetNamedParamListFlag();

		// If NamedParamList is specified param=values are in Parameter map
		// Order them as appear in alias verb parameter definition and put
		// them in to cvInParams for further processing.
		CHARVECTOR cvInParams;
		if ( bNamedParamList == TRUE )
			ObtainInParamsFromParameterMap(rParsedInfo, cvInParams);
		else // else params are available in property list.
			cvInParams = rParsedInfo.GetCmdSwitchesObject().GetPropertyList();

		CHARVECTOR::iterator theActParamIterator = NULL;
		try
		{
			// Loop initialization.
			theActParamIterator = cvInParams.begin();

			while( TRUE )
			{
				// Loop condition.
				if (theActParamIterator == cvInParams.end())
					break;

				bSubstituted = FALSE;
				
				while ( bSubstituted == FALSE )
				{
					nHashPos = strCmdLine.find(CLI_TOKEN_HASH, 
								nHashPos, lHashLen);
					if ( nHashPos != STRING::npos )
					{
						// No instance specified.
						if ( pIWbemObj == NULL )
						{
							strCmdLine.replace(nHashPos, lHashLen,
									*theActParamIterator);
							nHashPos = nHashPos + lstrlen(*theActParamIterator);
							bSubstituted = TRUE;
						}
						else
						{
							if ( strCmdLine.compare(nHashPos + 1, 
													lSpaceLen, 
													CLI_TOKEN_SPACE) == 0 ||
								 strCmdLine.compare(nHashPos + 1,
											lstrlen(CLI_TOKEN_SINGLE_QUOTE), 
											CLI_TOKEN_SINGLE_QUOTE) == 0 )
							{
								strCmdLine.replace(nHashPos, lHashLen, 
										*theActParamIterator);
								nHashPos = nHashPos + 
											lstrlen(*theActParamIterator);
								bSubstituted = TRUE;
							}
							else
							{
								nAfterVarSpacePos = 
										strCmdLine.find(
											CLI_TOKEN_SPACE, nHashPos + 1,
											lSpaceLen);
								if ( nAfterVarSpacePos == STRING::npos )
								{
									strCmdLine.replace(nHashPos, 
										lHashLen, *theActParamIterator);
									nHashPos = nHashPos + 
											lstrlen(*theActParamIterator);
									bSubstituted = TRUE;
								}
							}
						}
					}
					else
					{
						strCmdLine.append(_T(" "));
						strCmdLine.append(*theActParamIterator);
						bSubstituted = TRUE;
					}

					if ( bSubstituted == FALSE )
						nHashPos = nHashPos + lHashLen;
				}
				
				// Loop expression.
				theActParamIterator++;
			}

			if ( pIWbemObj != NULL )
			{
				// Replacing #Variable parameters
				nHashPos	= 0;

				while ( TRUE )
				{
					nHashPos = strCmdLine.find(CLI_TOKEN_HASH, nHashPos, 
						lHashLen);
					if ( nHashPos == STRING::npos )
						break;

					nAfterVarSpacePos = 
									strCmdLine.find(CLI_TOKEN_SPACE, 
									nHashPos + 1, lSpaceLen);
					if ( nAfterVarSpacePos == STRING::npos )
						break;

					_bstr_t bstrPropName(strCmdLine.substr(nHashPos + 1,
							  nAfterVarSpacePos -  (nHashPos + 1)).data());
					VariantInit(&vtInstanceValue);
					hr = pIWbemObj->Get(bstrPropName, 0, 
									&vtInstanceValue, 0, 0);

					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(L"IWbemClassObject::Get(%s, 0, "
							L"-, 0, 0)", (LPWSTR)bstrPropName);
						GetBstrTFromVariant(vtInstanceValue, bstrResult);
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
								(LPCWSTR)chsMsg, 
							dwThreadId, rParsedInfo, m_bTrace, 0, bstrResult);
					}
					ONFAILTHROWERROR(hr);

					_bstr_t bstrInstanceValue;
					GetBstrTFromVariant(vtInstanceValue, bstrInstanceValue);

					strCmdLine.replace(nHashPos, nAfterVarSpacePos - nHashPos , 
										bstrInstanceValue);
					nHashPos = nHashPos + lstrlen(bstrInstanceValue);

					VARIANTCLEAR(vtInstanceValue);
				}
				
				VariantInit(&vtPath);
				hr = pIWbemObj->Get(L"__PATH", 0, &vtPath, 0, 0);

				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Get(L\"__PATH\", 0, "
						L"-, 0, 0)"); 
					GetBstrTFromVariant(vtPath, bstrResult);
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
						dwThreadId, rParsedInfo, m_bTrace, 0, bstrResult);
				}
				ONFAILTHROWERROR(hr);
			}

			INTEROPTION	interInvoke	= YES;
			_TCHAR szMsg[BUFFER1024] = NULL_STRING;

			// Get the user response if interactive mode is set
			if (IsInteractive(rParsedInfo) == TRUE)
			{
				_bstr_t bstrMsg;
				if ( pIWbemObj != NULL )
				{
					WMIFormatMessage(IDS_I_METH_INVOKE_PROMPT1, 2, bstrMsg,
							 (LPWSTR)vtPath.bstrVal, 
							 (LPWSTR)strCmdLine.data());
				}
				else
				{
					WMIFormatMessage(IDS_I_METH_INVOKE_PROMPT2, 1, bstrMsg,
							  (LPWSTR)strCmdLine.data());
				}
				interInvoke = GetUserResponse((LPWSTR)bstrMsg);
			}

			if ( interInvoke == YES )
			{
				DisplayMessage(L"\n", CP_OEMCP, FALSE, TRUE);
				BOOL bResult = _tsystem(strCmdLine.data());
				DisplayMessage(L"\n", CP_OEMCP, FALSE, TRUE);
			}
			VARIANTCLEAR(vtPath);
		}
		catch(_com_error& e)
		{
			VARIANTCLEAR(vtInstanceValue);
			VARIANTCLEAR(vtPath);
			rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}

/*------------------------------------------------------------------------
   Name				 :FormQueryAndExecuteMethodOrUtility
   Synopsis	         :Forms query and executes method or command line 
					  utility.
   Type	             :Member Function 
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo object.
		pIInParam	 - pointer to object of type IWbemClassObject. 
   Output Parameter(s):None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :FormQueryAndExecuteMethodOrUtility(rParsedInfo, pIInParam) 
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CExecEngine::FormQueryAndExecuteMethodOrUtility(
										CParsedInfo& rParsedInfo,
										IWbemClassObject *pIInParam)
{
	HRESULT					hr					= S_OK;
	IEnumWbemClassObject	*pIEnumObj			= NULL;
	IWbemClassObject		*pIWbemObj			= NULL;
	CHString				chsMsg;
	DWORD				dwThreadId			= GetCurrentThreadId();
	
	try
	{
		_bstr_t		bstrResult("");
		_bstr_t		bstrPath("");
		BOOL		bWhereExpr = FALSE;

		// If PATH specified
		if (rParsedInfo.GetCmdSwitchesObject().GetPathExpression() != NULL)
		{
			if(rParsedInfo.GetCmdSwitchesObject().
						GetWhereExpression() != NULL)
			{
				bWhereExpr = TRUE;
			}
			else
				bstrPath = _bstr_t(rParsedInfo.GetCmdSwitchesObject()
												.GetPathExpression());
		}
		else
		{
			// If CLASS specfied
			if (rParsedInfo.GetCmdSwitchesObject().GetClassPath() != NULL)
			{
				bstrPath = _bstr_t(rParsedInfo.GetCmdSwitchesObject().
										GetClassPath());
			}
			else if(rParsedInfo.GetCmdSwitchesObject().
						GetWhereExpression() != NULL)
			{
				bWhereExpr = TRUE;
			}
			else
				rParsedInfo.GetCmdSwitchesObject().
							GetClassOfAliasTarget(bstrPath);
		}

		// If bstrPath is not empty
		if ( !bWhereExpr )
		{
			if ( rParsedInfo.GetCmdSwitchesObject().GetVerbType() == CMDLINE )
			{
				SubstHashAndExecCmdUtility(rParsedInfo);
			}
			else
			{
				hr = ExecuteMethodAndDisplayResults(bstrPath, rParsedInfo,
													pIInParam);
			}
			ONFAILTHROWERROR(hr);
		}
		else
		{
			ULONG	ulReturned = 0;
			_bstr_t bstrQuery;

			// Frame the WMI query to be executed.
			if (rParsedInfo.GetCmdSwitchesObject().
								GetPathExpression() != NULL)
			{
				bstrPath = _bstr_t(rParsedInfo.
								GetCmdSwitchesObject().GetClassPath());
			}
			else
			{
				rParsedInfo.GetCmdSwitchesObject()
							.GetClassOfAliasTarget(bstrPath);
			}
			
			bstrQuery = _bstr_t("SELECT * FROM ") +	bstrPath; 
			if(rParsedInfo.GetCmdSwitchesObject().
								GetWhereExpression() != NULL)
			{
				bstrQuery += _bstr_t(" WHERE ") 
							 + _bstr_t(rParsedInfo.GetCmdSwitchesObject().
									GetWhereExpression());
			}
			
			hr = m_pITargetNS->ExecQuery(_bstr_t(L"WQL"), bstrQuery,
										WBEM_FLAG_FORWARD_ONLY |
										WBEM_FLAG_RETURN_IMMEDIATELY, 
										NULL, &pIEnumObj);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemServices::ExecQuery(L\"WQL\"," 
							L" L\"%s\", 0, NULL, -)", (LPWSTR)bstrQuery);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
						dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			// Set the interface security
			hr = SetSecurity(pIEnumObj, 
					rParsedInfo.GetGlblSwitchesObject().GetAuthority(),
					rParsedInfo.GetNode(),
					rParsedInfo.GetUser(),
					rParsedInfo.GetPassword(),
					rParsedInfo.GetGlblSwitchesObject().
								GetAuthenticationLevel(),
					rParsedInfo.GetGlblSwitchesObject().
								GetImpersonationLevel());
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"CoSetProxyBlanket(-, RPC_C_AUTHN_WINNT, "
					L"RPC_C_AUTHZ_NONE, NULL, %d,   %d, -, EOAC_NONE)",
					rParsedInfo.GetGlblSwitchesObject().
							GetAuthenticationLevel(),
					rParsedInfo.GetGlblSwitchesObject().
							GetImpersonationLevel());
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
					dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			BOOL bNoInstances = TRUE;

			// Loop thru the available instances
			while (((hr = pIEnumObj->Next( WBEM_INFINITE, 1, 
					&pIWbemObj, &ulReturned )) == S_OK) 
					&& (ulReturned == 1))
 			{
				bNoInstances = FALSE;
				VARIANT vtPath;
				VariantInit(&vtPath);
				hr = pIWbemObj->Get(L"__PATH", 0, &vtPath, 0, 0);

				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Get(L\"__PATH\", 0, "
						L"-, 0, 0)"); 
					GetBstrTFromVariant(vtPath, bstrResult);
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
						dwThreadId, rParsedInfo, m_bTrace, 0, bstrResult);
				}
				ONFAILTHROWERROR(hr);

				if ( vtPath.vt == VT_BSTR )
				{
					if ( rParsedInfo.GetCmdSwitchesObject().GetVerbType() 
							== CMDLINE )
					{
						SubstHashAndExecCmdUtility(rParsedInfo, pIWbemObj);
					}
					else
					{
						hr = ExecuteMethodAndDisplayResults(vtPath.bstrVal,
							rParsedInfo, pIInParam);
					}
					ONFAILTHROWERROR(hr);
				}
				VariantClear(&vtPath);
				SAFEIRELEASE(pIWbemObj);
			}
			// If next fails.
			ONFAILTHROWERROR(hr);

			SAFEIRELEASE(pIEnumObj);

			// If no instances are available
			if ( bNoInstances == TRUE )
			{
				rParsedInfo.GetCmdSwitchesObject().
							SetInformationCode(IDS_I_NO_INSTANCES);
			}
		}
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIEnumObj);
		SAFEIRELEASE(pIWbemObj);
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIEnumObj);
		SAFEIRELEASE(pIWbemObj);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :ExtractClassNameandWhereExpr
   Synopsis	         :This function takes the input as a path expression and 
					  extracts the Class and Where expression part from the 
					  path expression.
   Type	             :Member Function
   Input Parameter(s):
		pszPathExpr  - the path expression
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
		pszWhere	 -  the Where expression
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ExtractClassNameandWhereExpr(pszPathExpr, rParsedInfo,
							pszWhere)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL CExecEngine::ExtractClassNameandWhereExpr(_TCHAR* pszPathExpr, 
												 CParsedInfo& rParsedInfo,
												 _TCHAR* pszWhere)
{
	// Frame the class name and where expression based on the object path
	BOOL	bRet					= TRUE;
	_TCHAR* pszToken				= NULL;
	BOOL	bFirst					= TRUE;
	_TCHAR	pszPath[MAX_BUFFER]		= NULL_STRING;

	if (pszPathExpr == NULL || pszWhere == NULL)
		bRet = FALSE;

	try
	{
		if ( bRet == TRUE )
		{
			lstrcpy(pszPath, pszPathExpr);
			lstrcpy(pszWhere, CLI_TOKEN_NULL);
			pszToken = _tcstok(pszPath, CLI_TOKEN_DOT);
			if (pszToken != NULL)
			{
				if(CompareTokens(pszToken, pszPathExpr))
					bRet = FALSE;
			}

			while (pszToken != NULL)
			{
				pszToken = _tcstok(NULL, CLI_TOKEN_COMMA); 
				if (pszToken != NULL)
				{
					if (!bFirst)
						lstrcat(pszWhere, CLI_TOKEN_AND);
					lstrcat(pszWhere, pszToken);
					bFirst = FALSE;
				}
				else
					break;
			}
		}
	}
	catch(...)
	{
		rParsedInfo.GetCmdSwitchesObject().
						SetErrataCode(IDS_E_INVALID_PATH);
		bRet = FALSE;
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :GetUserResponseEx
   Synopsis	         :This function accepts the user response before going
					  ahead, when /INTERACTIVE is specified at the verb 
					  level
   Type	             :Member Function
   Input parameter   :
			pszMsg	 - message to be displayed.
   Output parameters :None
   Return Type       :INTEROPTION
   Global Variables  :None
   Calling Syntax    :GetUserResponseEx(pszMsg)
   Notes             :None
------------------------------------------------------------------------*/
INTEROPTION CExecEngine::GetUserResponseEx(_TCHAR* pszMsg)
{
	INTEROPTION	bRet			= YES;
	_TCHAR szResp[BUFFER255]	= NULL_STRING;
	_TCHAR *pBuf				= NULL;

	if (pszMsg == NULL)
		bRet = NO;

	if(bRet != NO)
	{
		// Get the user response, till 'Y' - yes or 'N' - no
		// is keyed in
		while(TRUE)
		{
			DisplayMessage(pszMsg, CP_OEMCP, TRUE, TRUE);
			pBuf = _fgetts(szResp, BUFFER255-1, stdin);
			if(pBuf != NULL)
			{
				LONG lInStrLen = lstrlen(szResp);
				if(szResp[lInStrLen - 1] == _T('\n'))
						szResp[lInStrLen - 1] = _T('\0');
			}
			else if ( g_wmiCmd.GetBreakEvent() != TRUE )
			{
				lstrcpy(szResp, RESPONSE_NO);
				DisplayMessage(_T("\n"), CP_OEMCP, TRUE, TRUE);
			}

			if ( g_wmiCmd.GetBreakEvent() == TRUE )
			{
				g_wmiCmd.SetBreakEvent(FALSE);
				lstrcpy(szResp, RESPONSE_NO);
				DisplayMessage(_T("\n"), CP_OEMCP, TRUE, TRUE);
			}
			if (CompareTokens(szResp, RESPONSE_YES)
				|| CompareTokens(szResp, RESPONSE_NO)
				|| CompareTokens(szResp, RESPONSE_HELP))
				break;
		}
		if (CompareTokens(szResp, RESPONSE_NO))
			bRet = NO;
		else if (CompareTokens(szResp, RESPONSE_YES))
			bRet = YES;
		else if (CompareTokens(szResp, RESPONSE_HELP))
			bRet = HELP;
	}

	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :ObtainInParamsFromParameterMap
   Synopsis	         :This function obtains param values from parameter map 
					  in the same order as they appear in the alias verb 
					  definition.
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo		- reference to CParsedInfo object
   Output Parameter(s):
		cvParamValues	- reference to parameter values vector
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :ObtainInParamsFromParameterMap(rParsedInfo, cvParamValues)
   Notes             :None
----------------------------------------------------------------------------*/
void CExecEngine::ObtainInParamsFromParameterMap(CParsedInfo& rParsedInfo, 
												 CHARVECTOR& cvParamValues)
{
	PROPDETMAP pdmVerbParamsFromAliasDef = (*(rParsedInfo.
											GetCmdSwitchesObject().
											GetMethDetMap().begin())).
											second.Params;
	PROPDETMAP::iterator itrVerbParams;

	BSTRMAP bmNamedParamList = rParsedInfo.GetCmdSwitchesObject().
															GetParameterMap();
	BSTRMAP::iterator itrNamedParamList;

	try
	{
		for ( itrVerbParams = pdmVerbParamsFromAliasDef.begin();
			  itrVerbParams != pdmVerbParamsFromAliasDef.end();	
			  itrVerbParams++ )
		{
			_TCHAR* pszVerbParamName = (*itrVerbParams).first;
			// To remove numbers from Names.
			pszVerbParamName = pszVerbParamName + 5;

			if ( Find(bmNamedParamList, pszVerbParamName, itrNamedParamList)
																	 == TRUE)
			{
				cvParamValues.push_back(_bstr_t((*itrNamedParamList).second));
			}
			else
			{
				cvParamValues.push_back(
						_bstr_t(((*itrVerbParams).second).Default));
			}
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*----------------------------------------------------------------------------
   Name				 :FrameAssocHeader
   Synopsis	         :This function frames the XML header to be used with 
					  the ASSOCIATORS output 
   Type	             :Member Function
   Input Parameter(s):
		bstrPath  - object/class path
		bClass	  - TRUE	- Indicates class level associators header
					FALSE	- Indicates instance level associators header
   Output Parameter(s):
   		bstrFrag  - fragment string
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :FrameAssocHeader(bstrPath, bstrFrag, bClass)
   Notes             :None
----------------------------------------------------------------------------*/
HRESULT CExecEngine::FrameAssocHeader(_bstr_t bstrPath, _bstr_t& bstrFrag, 
									  BOOL bClass)
{
	HRESULT				hr			= S_OK;
	IWbemClassObject	*pIObject	= NULL;
	try
	{
		_variant_t		vClass,		vSClass,	vPath, 
						vOrigin,	vType;
		_bstr_t			bstrProp;
		CHString		szBuf;

		// Get the Class/instance information.
		hr = m_pITargetNS->GetObject(bstrPath, WBEM_FLAG_USE_AMENDED_QUALIFIERS, 
						NULL, &pIObject, NULL);
		ONFAILTHROWERROR(hr);

		// Get the __CLASS property value
		bstrProp = L"__CLASS"; 
		hr = pIObject->Get(bstrProp, 0, &vClass, 0, 0);
		ONFAILTHROWERROR(hr);
		
		// Get the __PATH property value
		bstrProp = L"__PATH";
		hr = pIObject->Get(bstrProp, 0, &vPath, 0, 0);
		ONFAILTHROWERROR(hr);

		// If CLASS level associators required 
		if (bClass)
		{
			// Get the __SUPERCLASS property value
			bstrProp = L"__SUPERCLASS";
			hr = pIObject->Get(bstrProp, 0, &vSClass, NULL, NULL);
			ONFAILTHROWERROR(hr);

			szBuf.Format(_T("<CLASS NAME=\"%s\" SUPERCLASS=\"%s\"><PROPERTY "
					L"NAME=\"__PATH\" CLASSORIGIN=\"__SYSTEM\" TYPE=\"string\">"
					L"<VALUE>%s</VALUE></PROPERTY>"),
					(vClass.vt != VT_NULL && (LPWSTR)vClass.bstrVal) 
					? (LPWSTR)vClass.bstrVal : L"N/A", 
					(vSClass.vt != VT_NULL && (LPWSTR)vSClass.bstrVal)
					? (LPWSTR)vSClass.bstrVal : L"N/A",
					(vPath.vt != VT_NULL && (LPWSTR)vPath.bstrVal)
					? (LPWSTR)vPath.bstrVal : L"N/A");
		}
		else
		{
			szBuf.Format(
				_T("<INSTANCE CLASSNAME=\"%s\"><PROPERTY NAME=\"__PATH\""
					L" CLASSORIGIN=\"__SYSTEM\" TYPE=\"string\"><VALUE>%s"
					L"</VALUE></PROPERTY>"),
					(vClass.vt != VT_NULL && (LPWSTR)vClass.bstrVal)
					? (LPWSTR)vClass.bstrVal : L"N/A",
					(vPath.vt != VT_NULL && (LPWSTR)vPath.bstrVal)
					? (LPWSTR)vPath.bstrVal : L"N/A");
		}
		SAFEIRELEASE(pIObject);
		bstrFrag = _bstr_t(szBuf);
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIObject);
		hr = e.Error();
	}
	// trap for CHeap_Exception
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIObject);
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\globalswitches.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: GlobalSwitches.cpp 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This class encapsulates the functionality needed
					          for accessing and storing the global switches 
					          information, which will be used by Parsing, 
					          Execution and Format Engines depending upon the 
					          applicablity.
Revision History			: 
	Last Modified by		: Ch. Sriramachandramurthy
	Last Modified on		: 11th-April-2001
****************************************************************************/ 
// GlobalSwitches.cpp : implementation file
//
#include "precomp.h"
#include "GlobalSwitches.h"

/*------------------------------------------------------------------------
   Name				 :CGlobalSwitches
   Synopsis	         :This function initializes the member variables when
                      an object of the class type is instantiated
   Type	             :Constructor 
   Input parameters  :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CGlobalSwitches::CGlobalSwitches()
{
	m_pszNameSpace			= NULL;
	m_pszRole				= NULL;
	m_pszNode				= NULL;
	m_pszLocale				= NULL;
	m_pszAuthority			= NULL;
	m_pszUser				= NULL;
	m_pszPassword			= NULL;
	m_pszRecordPath			= NULL;
	m_bPrivileges			= TRUE;
	m_uConnInfoFlag			= 0;
	m_bRoleFlag				= TRUE;
	m_bNSFlag				= TRUE;
	m_bLocaleFlag			= TRUE;
	m_bRPChange				= FALSE;
	m_bAggregateFlag		= TRUE;

	// default impersonation level is IMPERSONATE
	m_ImpLevel				= IMPERSONATE; 

	// default authentication level is DEFAULT
	m_AuthLevel				= AUTHDEFAULT;   

	// Trace mode if OFF by default
	m_bTrace				= FALSE; 

	// Interactive mode is OFF by default
	m_bInteractive			= FALSE; 

	// Help flag is OFF by default
	m_bHelp					= FALSE; 

	// Default help option is BRIEF
	m_HelpOption			= HELPBRIEF;

	m_bAskForPassFlag		= FALSE;
	m_bFailFast				= FALSE;
	m_opsOutputOpt			= STDOUT;
	m_opsAppendOpt			= STDOUT;
	m_pszOutputFileName		= NULL;
	m_fpOutFile				= NULL;
	m_pszAppendFileName		= NULL;
	m_fpAppendFile			= NULL;
	m_nSeqNum				= 0;
	m_pszLoggedOnUser		= NULL;
	m_pszNodeName			= NULL;
	m_pszStartTime			= NULL;
}
/*------------------------------------------------------------------------
   Name				 :~CGlobalSwitches
   Synopsis	         :This function Uninitializes the member variables when
                      an object of the class type is instantiated
   Type	             :Destructor 
   Input parameters  :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CGlobalSwitches::~CGlobalSwitches()
{
	Uninitialize();
}

/*------------------------------------------------------------------------
   Name				 :Initialize
   Synopsis	         :This function initializes the necessary member 
					  variables.
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :Initialize()
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::Initialize() throw(WMICLIINT)
{
	static BOOL bFirst = TRUE;
	try
	{
		if (bFirst)
		{
			// NAMESPACE
			// Set the default namespace to 'root\cimv2'
			m_pszNameSpace = new _TCHAR [BUFFER32];

			// Check for memory allocation failure.
			if (m_pszNameSpace == NULL)
				throw OUT_OF_MEMORY;
			lstrcpy(m_pszNameSpace, CLI_NAMESPACE_DEFAULT);
			
			// Set the default role as 'root\cli'
			m_pszRole = new _TCHAR [BUFFER32];

			// Check for memory allocation failure
			if (m_pszRole == NULL)
				throw OUT_OF_MEMORY;

			lstrcpy(m_pszRole, CLI_ROLE_DEFAULT);

			// Set the system default locale in the format ms_xxx
			m_pszLocale = new _TCHAR [BUFFER32];
			
			// Check for memory allocation failure
			if (m_pszLocale == NULL)
				throw OUT_OF_MEMORY;
			_stprintf(m_pszLocale, _T("ms_%x"),  GetSystemDefaultLangID());


			m_pszNodeName	  = new _TCHAR [MAX_COMPUTERNAME_LENGTH + 1];
			if (m_pszNodeName == NULL)
				throw OUT_OF_MEMORY;

			DWORD dwCompNameBufferSize = MAX_COMPUTERNAME_LENGTH + 1;	
			if (GetComputerName(m_pszNodeName, &dwCompNameBufferSize))
			{
				m_pszNodeName[MAX_COMPUTERNAME_LENGTH] = _T('\0');
			}
			else
				lstrcpy(m_pszNodeName, L"N/A");

			// current node is the default.
			m_pszNode = new _TCHAR [lstrlen(m_pszNodeName)+1];

			// Check for memory allocation failure
			if (m_pszNode == NULL)
				throw OUT_OF_MEMORY;

			lstrcpy(m_pszNode, m_pszNodeName);
			
			ULONG nSize	 = 0;

			if(!GetUserNameEx(NameSamCompatible, NULL, &nSize))
			{
				m_pszLoggedOnUser = new _TCHAR [nSize + 1];
				if (m_pszLoggedOnUser == NULL)
					throw OUT_OF_MEMORY;

				if (!GetUserNameEx(NameSamCompatible, m_pszLoggedOnUser, &nSize))    
					lstrcpy(m_pszLoggedOnUser, L"N/A");

			}
			
			if (!AddToNodesList(m_pszNode))
				throw OUT_OF_MEMORY;

			// Populate the IMPLEVEL mappings
			m_cimImpLevel.insert(CHARINTMAP::value_type(_bstr_t(L"ANONYMOUS"), 1));
			m_cimImpLevel.insert(CHARINTMAP::value_type(_bstr_t(L"IDENTIFY"), 2));
			m_cimImpLevel.insert(CHARINTMAP::value_type(_bstr_t(L"IMPERSONATE"),3));
			m_cimImpLevel.insert(CHARINTMAP::value_type(_bstr_t(L"DELEGATE"), 4));

			// Populate the AUTHLEVEL mappings
			m_cimAuthLevel.insert(CHARINTMAP::value_type(_bstr_t(L"DEFAULT"), 0));
			m_cimAuthLevel.insert(CHARINTMAP::value_type(_bstr_t(L"NONE"), 1));
			m_cimAuthLevel.insert(CHARINTMAP::value_type(_bstr_t(L"CONNECT"), 2));
			m_cimAuthLevel.insert(CHARINTMAP::value_type(_bstr_t(L"CALL"), 3));
			m_cimAuthLevel.insert(CHARINTMAP::value_type(_bstr_t(L"PKT"), 4));
			m_cimAuthLevel.insert(CHARINTMAP::value_type(_bstr_t(L"PKTINTEGRITY"),5));
			m_cimAuthLevel.insert(CHARINTMAP::value_type(_bstr_t(L"PKTPRIVACY"),  6));

			bFirst = FALSE;
		}
	}
	catch(_com_error& e) 
	{
		_com_issue_error(e.Error());
	}
	m_HelpOption	= HELPBRIEF;
}

/*------------------------------------------------------------------------
   Name				 :Uninitialize
   Synopsis	         :This function uninitializes the member variables 
					  when the execution of a command string issued on the
					  command line is completed.
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :Uninitialize()
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::Uninitialize()
{
	SAFEDELETE(m_pszAuthority);
	SAFEDELETE(m_pszNameSpace);
	SAFEDELETE(m_pszRole);
	SAFEDELETE(m_pszLocale);
	SAFEDELETE(m_pszNode);
	CleanUpCharVector(m_cvNodesList);
	SAFEDELETE(m_pszUser);
	SAFEDELETE(m_pszPassword);
	SAFEDELETE(m_pszRecordPath);
	SAFEDELETE(m_pszOutputFileName);
	SAFEDELETE(m_pszAppendFileName);
	if ( m_fpOutFile != NULL )
	{
		fclose(m_fpOutFile);
		m_fpOutFile = NULL;
	}
	if ( m_fpAppendFile != NULL )
	{
		fclose(m_fpAppendFile);
		m_fpAppendFile = NULL;
	}
	m_bHelp			= FALSE;
	m_bTrace		= FALSE;
	m_bInteractive	= FALSE;
	m_HelpOption	= HELPBRIEF;
	m_AuthLevel		= AUTHPKT;   
	m_ImpLevel		= IMPERSONATE;
	m_uConnInfoFlag = 0;
	m_cimAuthLevel.clear();
	m_cimImpLevel.clear();
	m_nSeqNum				= 0;
	SAFEDELETE(m_pszLoggedOnUser);
	SAFEDELETE(m_pszNodeName);
	SAFEDELETE(m_pszStartTime);
}

/*------------------------------------------------------------------------
   Name				 :SetAuthority
   Synopsis	         :This function sets the authority value defined with 
                      alias to m_pszAuthority.
   Type	             :Member Function
   Input parameters   :
        pszAuthority - string type, contains the authority value
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAuthority(pszAuthority)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::SetAuthority(_TCHAR* pszAuthority)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszAuthority);
	if(pszAuthority)
	{
		m_pszAuthority = new _TCHAR [lstrlen(pszAuthority)+1];
		if (m_pszAuthority)
			lstrcpy(m_pszAuthority, pszAuthority);	
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetNameSpace
   Synopsis	         :This function Sets the namespace passed in parameter
                      to m_pszNameSpace.
   Type	             :Member Function
   Input parameters   :
      pszNameSpace   -String type,contains Namespace specified in the command
	  AliasFlag      -Boolean type,specifies whether alias flag is set or not
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetNameSpace(pszNameSpace)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::SetNameSpace(_TCHAR* pszNamespace)
{
	BOOL bResult = TRUE;
	if(pszNamespace)
	{
		// If the value specified is not _T("")
		if( !CompareTokens(pszNamespace, CLI_TOKEN_NULL) )
		{
			// Check if the same value is specified for the /NAMESPACE.
			if (!CompareTokens(pszNamespace, m_pszNameSpace))
			{
				SAFEDELETE(m_pszNameSpace);
				m_pszNameSpace = new _TCHAR [lstrlen(pszNamespace)+1];
				if (m_pszNameSpace)
				{
					lstrcpy(m_pszNameSpace, pszNamespace);	
					m_bNSFlag = TRUE;
				}
				else
					bResult = FALSE;
			}
		}
		// set back to default
		else
		{
			// If the current namespace is not the default namespace
			if (!CompareTokens(m_pszRole, CLI_NAMESPACE_DEFAULT))
			{
				SAFEDELETE(m_pszNameSpace)
				m_pszNameSpace = new _TCHAR [BUFFER255];
				if (m_pszNameSpace)
				{
					lstrcpy(m_pszNameSpace, CLI_NAMESPACE_DEFAULT);
					m_bNSFlag = TRUE;
				}
				else
					bResult = FALSE;
			}
		}
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetRole
   Synopsis	         :This function Sets the role passed in parameter 
                      to m_pszRole.
   Type	             :Member Function
   Input parameters   :
           pszRole   -String type,contains Role specified in the command
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetRole(pszRole)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::SetRole(_TCHAR* pszRole)
{
	BOOL bResult = TRUE;
	if(pszRole)
	{
		// If the value specified is not _T("")
		if( !CompareTokens(pszRole, CLI_TOKEN_NULL) )
		{
			// Check if the same value is specified for the /ROLE.
			if (!CompareTokens(pszRole, m_pszRole))
			{
				SAFEDELETE(m_pszRole);
				m_pszRole = new _TCHAR [lstrlen(pszRole)+1];
				if (m_pszRole)
				{
					lstrcpy(m_pszRole, pszRole);	
					m_bRoleFlag		= TRUE;
					m_bLocaleFlag	= TRUE;
				}
				else
					bResult = FALSE;
			}
		}
		// set back to default
		else
		{
			// If the current role is not the default role
			if (!CompareTokens(m_pszRole, CLI_ROLE_DEFAULT))
			{
				SAFEDELETE(m_pszRole)
				m_pszRole = new _TCHAR [BUFFER255];
				if (m_pszRole)
				{
					lstrcpy(m_pszRole, CLI_ROLE_DEFAULT);
					m_bRoleFlag		= TRUE;
					m_bLocaleFlag	= TRUE;
				}
				else
					bResult = FALSE;
			}
		}
	}
	return bResult;
}
/*------------------------------------------------------------------------
   Name				 :SetLocale
   Synopsis	         :This function Assigns the locale passed in parameter 
                      to m_pszLocale.
   Type	             :Member Function
   Input parameters   :
         pszLocale   -String type,It contains Locale option specified in the
                      command
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetLocale(pszLocale)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::SetLocale(_TCHAR* pszLocale)
{
	BOOL bResult = TRUE;
	if(pszLocale)
	{
		// If the value specified is not _T("")
		if (!CompareTokens(pszLocale, CLI_TOKEN_NULL))
		{
			// Check if the same value is specified for the /LOCALE.
			if (!CompareTokens(m_pszLocale, pszLocale))
			{	
				SAFEDELETE(m_pszLocale);
				m_pszLocale = new _TCHAR [lstrlen(pszLocale)+1];
				if (m_pszLocale)
				{
					lstrcpy(m_pszLocale, pszLocale);	
					m_uConnInfoFlag |= LOCALE;
					m_bLocaleFlag = TRUE;
					m_bRoleFlag	  = TRUE;
					m_bNSFlag	  = TRUE;
				}
				else
					bResult = FALSE;
			}
		}
		// If the value specified is _T("") - set to default system locale.
		else
		{
			_TCHAR szLocale[BUFFER32] = NULL_STRING;
			_stprintf(szLocale, _T("ms_%x"),  GetSystemDefaultLangID());

			// If the current role is not the default role
			if (!CompareTokens(m_pszLocale, szLocale))
			{
				SAFEDELETE(m_pszLocale);
				m_pszLocale = new _TCHAR [BUFFER32];
				if (m_pszLocale)
				{
					m_uConnInfoFlag &= ~LOCALE;
					lstrcpy(m_pszLocale, szLocale);
					m_bLocaleFlag = TRUE;
					m_bRoleFlag	  = TRUE;
					m_bNSFlag	  = TRUE;
				}
				else
					bResult = FALSE;
			}
		}
	}
	return bResult;
}
/*------------------------------------------------------------------------
   Name				 :AddToNodesList
   Synopsis	         :This function adds the node passed in parameter
                      to m_cvNodesList
   Type	             :Member Function
   Input parameters  : 
           pszNode   - String type,contains Node option specified in the
		              command
   Output parameters :None
   Return Type       :void
   Global Variables  :BOOL
   Calling Syntax    :AddToNodesList(pszNode)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::AddToNodesList(_TCHAR* pszNode)
{
	_TCHAR* pszTempNode = NULL;
	BOOL	bRet		= TRUE;

	if (!CompareTokens(pszNode, CLI_TOKEN_NULL) &&
		!CompareTokens(pszNode, CLI_TOKEN_DOT) &&
		!CompareTokens(pszNode, CLI_TOKEN_LOCALHOST) &&
		!CompareTokens(pszNode, m_pszNodeName))
	{
		pszTempNode = new _TCHAR [ lstrlen ( pszNode ) + 1 ];
		if (pszTempNode)
			lstrcpy(pszTempNode, pszNode);
		else
			bRet = FALSE;
	}
	else
	{
		// "." specifies current node
		SAFEDELETE(m_pszNode);
		m_pszNode = new _TCHAR [ lstrlen (m_pszNodeName) + 1 ];
		if (m_pszNodeName)
		{
			lstrcpy(m_pszNode, m_pszNodeName);
			pszTempNode = new _TCHAR [ lstrlen (m_pszNodeName) + 1 ];
			if (pszTempNode)
				lstrcpy(pszTempNode, m_pszNodeName);
			else
				bRet = FALSE;
		}
		else
			bRet = FALSE;
	}
	
	if (bRet)
	{
		CHARVECTOR::iterator tempIterator;
		if ( !Find(m_cvNodesList, pszTempNode, tempIterator) )
			m_cvNodesList.push_back(pszTempNode);
		else if ( CompareTokens(pszTempNode, m_pszNodeName) == TRUE )
		{
			BOOL bFound = FALSE;
			tempIterator = m_cvNodesList.begin();
			while ( tempIterator != m_cvNodesList.end() )
			{
				if ( tempIterator != m_cvNodesList.begin() )
				{
					if(CompareTokens(*tempIterator, m_pszNodeName) == TRUE)
					{
						bFound = TRUE;
						break;
					}
				}
				tempIterator++;
			}
			if(bFound == FALSE)
				m_cvNodesList.push_back(pszTempNode);
			else
				SAFEDELETE(pszTempNode);
		}
		else
			SAFEDELETE(pszTempNode);
	}
	return bRet;
}
/*------------------------------------------------------------------------
   Name				 :SetUser
   Synopsis	         :This function Assigns the user passed in parameter
                      to m_pszUser
   Type	             :Member Function
   Input parameters   :
           pszUser   -String type,contains User option specified in the 
		              command.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetUser(pszUser)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::SetUser(_TCHAR* pszUser)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszUser);
	if(pszUser)
	{
		if (!CompareTokens(pszUser, CLI_TOKEN_NULL))
		{
			m_pszUser = new _TCHAR [lstrlen(pszUser)+1];
			if (m_pszUser)
			{
				lstrcpy(m_pszUser, pszUser);	
				m_uConnInfoFlag |= USER;
			}
			else
				bResult = FALSE;
		}
		else
			m_uConnInfoFlag &= ~USER;
	}
	return bResult;
}
/*------------------------------------------------------------------------
   Name				 :SetPassword
   Synopsis	         :This function Assigns the password passed in parameter
                      to m_pszPassword
   Type	             :Member Function
   Input parameters   :
       pszPassword   -Assigns the password passed in parameter to
	                  m_pszPassword
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetPassword(pszPassword)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::SetPassword(_TCHAR* pszPassword)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszPassword)
	if (!CompareTokens(pszPassword, CLI_TOKEN_NULL))
	{
		m_pszPassword = new _TCHAR [lstrlen(pszPassword)+1];
		if (m_pszPassword) 
		{
			lstrcpy(m_pszPassword, pszPassword);	
			m_uConnInfoFlag |= PASSWORD;
		}
		else
			bResult = FALSE;
	}
	else
		m_uConnInfoFlag &= ~PASSWORD;
	return bResult;
}
/*------------------------------------------------------------------------
   Name				 :SetRecordPath(pszRecordPath)
   Synopsis	         :This function Assigns the record file passed in
                      parameter to m_pszRecordPath
   Type	             :Member Function
   Input parameters   :
     pszRecordPath   -String type,contains Record path specified in the 
	                  command.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetRecordPath(pszRecordPath)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::SetRecordPath(_TCHAR* pszRecordPath)
{
	BOOL bResult = TRUE;
	if (pszRecordPath)
	{
		// Check if the value specified is not _T("")
		if (!CompareTokens(pszRecordPath, CLI_TOKEN_NULL))
		{
			SAFEDELETE(m_pszRecordPath);
			m_pszRecordPath = new _TCHAR [lstrlen(pszRecordPath)+1];
			if (m_pszRecordPath)
			{
				lstrcpy(m_pszRecordPath, pszRecordPath);	
				m_bRPChange = TRUE;
			}
			else
				bResult = FALSE;
		}
		// if the value specified is _T("") set the recordpath to NULL
		else
		{
			SAFEDELETE(m_pszRecordPath);
			m_bRPChange = TRUE;
		}
	}
	else
	{
		SAFEDELETE(m_pszRecordPath);
		m_bRPChange = TRUE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetPrivileges(bEnable)
   Synopsis	         :This function sets bEnable flag to TRUE if Privileges 
                     :option is specified in the command                       
   Type	             :Member Function
   Input parameters   :
     pszPrivileges   -Boolean tye,Specifies whether the flag should be
	                  enabled or disabled
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetPrivileges(pszPrivileges)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::SetPrivileges(BOOL bEnable)
{
	m_bPrivileges = bEnable;
}
/*------------------------------------------------------------------------
   Name				 :SetImpersonationLevel(_TCHAR* const pszImpLevel)
   Synopsis	         :This function checks whether the specified pszImpLevel
                      is valid and assigns the mapped value to m_ImpLevel.
   Type	             :Member Function
   Input parameters   :
		pszImpLevel - IMPLEVEL input string
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetImpersonationLevel(pszImpLevel)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::SetImpersonationLevel(_TCHAR* const pszImpLevel)
{
	BOOL bResult = TRUE;
	// Check whether the string exists in the list of available values.
	CHARINTMAP::iterator theIterator = NULL;
	theIterator = m_cimImpLevel.find(CharUpper(pszImpLevel));
	if (theIterator != m_cimImpLevel.end())
	{
		m_ImpLevel = (IMPLEVEL) (*theIterator).second;
	}
	else
		bResult = FALSE;
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetAuthenticationLevel(_TCHAR* const pszAuthLevel)
   Synopsis	         :This function checks whether the specified pszAuthLevel
                      is valid and assigns the mapped value to m_AuthLevel.
   Type	             :Member Function
   Input parameters   :
		pszAuthLevel - AUTHLEVEL input string
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAuthenticationLevel(pszAuthLevel)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::SetAuthenticationLevel(_TCHAR* const pszAuthLevel)
{
	BOOL bResult = TRUE;
	// Check whether the string exists in the list of available values.
	CHARINTMAP::iterator theIterator = NULL;
	theIterator = m_cimAuthLevel.find(CharUpper(pszAuthLevel));
	if (theIterator != m_cimAuthLevel.end())
	{
		m_AuthLevel = (AUTHLEVEL) (*theIterator).second;
	}
	else
		bResult = FALSE;
	return bResult;
}
/*------------------------------------------------------------------------
   Name				 :SetTraceMode(BOOL bTrace)
   Synopsis	         :This function sets the m_bTrace to TRUE,If Trace mode
                      is specified in the command 					                      
   Type	             :Member Function
   Input parameter   :
             Trace   -Boolean type,Specifies whether the trace mode 
			          has been set or not
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetTraceMode(bTrace)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::SetTraceMode(BOOL bTrace)
{
	m_bTrace = bTrace;
}
/*------------------------------------------------------------------------
   Name				 :SetInteractiveMode
   Synopsis	         :This function sets the m_bInteractive to TRUE,If 
                      interactive mode is specified in the command                      
   Type	             :Member Function
   Input parameter   :
      bInteractive   -Boolean type,Specifies whether the interactive mode 
	                  has been set or not
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetInteractiveMode(bInteractive)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::SetInteractiveMode(BOOL bInteractive)
{
	m_bInteractive = bInteractive;
}
	
/*------------------------------------------------------------------------
   Name				 :SetHelpFlag
   Synopsis	         :sets the m_bHelp to TRUE, If /? is specified in the
                      command 
   Type	             :Member Function
   Input parameters   :
             bHelp   -BOOL type Specifies whether the helpflag has been
			          set or not
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetHelpFlag(bHelp)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::SetHelpFlag(BOOL bHelp)
{
	m_bHelp = bHelp;	
}
/*------------------------------------------------------------------------
   Name				 :SetHelpOption
   Synopsis	         :This function specifies whether the help should
                      be brief or full 
   Type	             :Member Function
   Input parameters   :
        helpOption   -Specifies whether the help should be brief or full
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetHelpOption(helpOption)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::SetHelpOption(HELPOPTION helpOption)
{
	m_HelpOption = helpOption;
}

/*------------------------------------------------------------------------
   Name				 :SetConnInfoFlag
   Synopsis	         :This function sets the Connection Info flag
   Type	             :Member Function
   Input parameter   :
			uFlag	 - Unsigned int type
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetConnInfoFlag(uFlag)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::SetConnInfoFlag(UINT uFlag)
{
	m_uConnInfoFlag = uFlag;
}
/*------------------------------------------------------------------------
   Name				 :GetConnInfoFlag
   Synopsis	         :This function returns the Connection Info flag
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :UINT
   Global Variables  :None
   Calling Syntax    :GetConnInfoFlag()
   Notes             :None
------------------------------------------------------------------------*/
UINT CGlobalSwitches::GetConnInfoFlag()
{
	return m_uConnInfoFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetNameSpace
   Synopsis	         :This function Returns the string held in m_pszNameSpace
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetNameSpace()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CGlobalSwitches::GetNameSpace()
{
	return m_pszNameSpace;
}

/*------------------------------------------------------------------------
   Name				 :GetAuthority
   Synopsis	         :This function returns the string held in m_pszAuthority
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetAuthority()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CGlobalSwitches::GetAuthority()
{
	return m_pszAuthority;
}

/*------------------------------------------------------------------------
   Name				 :GetRole
   Synopsis	         :This function Returns the string held in m_pszRole
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetRole()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CGlobalSwitches::GetRole()
{
	return m_pszRole;
}
/*------------------------------------------------------------------------
   Name				 :GetLocale
   Synopsis	         :This function Returns the string held in m_pszLocale .
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :_TCHR*
   Global Variables  :None
   Calling Syntax    :GetLocale()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CGlobalSwitches::GetLocale()
{
	return m_pszLocale;
}
/*------------------------------------------------------------------------
   Name				 :GetNodesList
   Synopsis	         :This function Returns the vector held in m_cvNodesList
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :CHARVECTOR&
   Global Variables  :None
   Calling Syntax    :GetNodesList()
   Notes             :None
------------------------------------------------------------------------*/
CHARVECTOR& CGlobalSwitches::GetNodesList()
{
	return m_cvNodesList;
}
/*------------------------------------------------------------------------
   Name				 :GetUser
   Synopsis	         :This function Returns the string held in m_pszUser.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetUser()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CGlobalSwitches::GetUser()
{
	return m_pszUser;
}
/*------------------------------------------------------------------------
   Name				 :GetPassword 
   Synopsis	         :This function Returns the string held in m_pszPassword
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetPassword()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CGlobalSwitches::GetPassword()
{
	return m_pszPassword;
}
/*------------------------------------------------------------------------
   Name				 :GetRecordPath
   Synopsis	         :This function Returns the string held in m_pszRecordPath
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetRecordPath()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CGlobalSwitches::GetRecordPath()
{
	return m_pszRecordPath;
}
/*------------------------------------------------------------------------
   Name				 :GetPrivileges
   Synopsis	         :This function Returns BOOL value held in m_bPrivileges
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetPrivileges()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::GetPrivileges()
{
	return m_bPrivileges;
}
/*------------------------------------------------------------------------
   Name				 :GetImpersonationLevel
   Synopsis	         :This function Returns impersonation level held 
                      in m_ImpLevel
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :LONG
   Global Variables  :None
   Calling Syntax    :GetImpersonationLevel()
   Notes             :None
------------------------------------------------------------------------*/
LONG CGlobalSwitches::GetImpersonationLevel()
{
	return m_ImpLevel;
}
/*------------------------------------------------------------------------
   Name				 :GetAuthenticationLevel
   Synopsis	         :This function Returns authentication level held in 
                      m_AuthLevel
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :LONG
   Global Variables  :None
   Calling Syntax    :GetAuthenticationLevel()
   Notes             :None
------------------------------------------------------------------------*/
LONG CGlobalSwitches::GetAuthenticationLevel()
{
	return m_AuthLevel;
}
/*------------------------------------------------------------------------
   Name				 :GetTraceStatus
   Synopsis	         :This function Returns trace status held in m_bTrace
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetTraceStatus()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::GetTraceStatus()
{
	return m_bTrace;
}
/*------------------------------------------------------------------------
   Name				 :GetInteractiveStatus
   Synopsis	         :This function Returns interactive status held 
                      in m_bInteractive
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetInteractiveStatus()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::GetInteractiveStatus()
{
	return m_bInteractive;
}
/*------------------------------------------------------------------------
   Name				 :GetHelpFlag
   Synopsis	         :This function Returns help flag held in m_bHelp
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetHelpFlag()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::GetHelpFlag()
{
	return m_bHelp;
}
/*------------------------------------------------------------------------
   Name				 :GetHelpOption
   Synopsis	         :This function Returns help option held in m_bHelpOption
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :HELPOPTION
   Global Variables  :None
   Calling Syntax    :GetHelpOption()
   Notes             :None
------------------------------------------------------------------------*/
HELPOPTION CGlobalSwitches::GetHelpOption()
{
	return m_HelpOption;
}

/*------------------------------------------------------------------------
   Name				 :GetRoleFlag
   Synopsis	         :This function returns the role flag value
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
		True	- /role changed recently.
		False	- no change in role till last command
   Global Variables  :None
   Calling Syntax    :GetRoleFlag()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::GetRoleFlag()
{
	return m_bRoleFlag;
}
/*-------------------------------------------------------------------------
   Name				 :SetNameSpaceFlag
   Synopsis	         :This function sets the NameSpace flag value
   Type	             :Member Function
   Input parameter   :BOOL bNSFlag
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetNameSpaceFlag(bNSFlag)
   Notes             :None

-------------------------------------------------------------------------*/
void CGlobalSwitches::SetNameSpaceFlag(BOOL bNSFlag)
{
	m_bNSFlag = bNSFlag;
}

/*-------------------------------------------------------------------------
   Name				 :SetRoleFlag
   Synopsis	         :This function sets the Role flag value
   Type	             :Member Function
   Input parameter   :BOOL bRoleFlag
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetRoleFlag(bRoleFlag)
   Notes             :None

-------------------------------------------------------------------------*/
void CGlobalSwitches::SetRoleFlag(BOOL bRoleFlag)
{
	m_bRoleFlag = bRoleFlag;
}

/*-------------------------------------------------------------------------
   Name				 :SetLocaleFlag
   Synopsis	         :This function sets the Locale flag value
   Type	             :Member Function
   Input parameter   :BOOL bLocaleFlag
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetLocaleFlag(bLocaleFlag)
   Notes             :None

-------------------------------------------------------------------------*/
void CGlobalSwitches::SetLocaleFlag(BOOL bLocaleFlag)
{
	m_bLocaleFlag = bLocaleFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetNamespaceFlag
   Synopsis	         :This function returns the namespace flag value
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
		True	- /namespace changed recently.
		False	- no change in namespace till last command
   Global Variables  :None
   Calling Syntax    :GetRoleFlag()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::GetNameSpaceFlag()
{
	return m_bNSFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetRPChangeStatus
   Synopsis	         :This function returns the recordpath flag value
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
		True	- recordpath changed recently.
		False	- no change in recordpath till last command
   Global Variables  :None
   Calling Syntax    :GetRPChangeStatus()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::GetRPChangeStatus()
{
	return m_bRPChange;
}

/*-------------------------------------------------------------------------
   Name				 :SetRPChangeStatus
   Synopsis	         :This function sets the recordpath flag value
   Type	             :Member Function
   Input parameter   :BOOL bStatus
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetRPChangeStatus(bStatus)
   Notes             :None

-------------------------------------------------------------------------*/
void CGlobalSwitches::SetRPChangeStatus(BOOL bStatus)
{
	m_bRPChange = bStatus;
}

/*------------------------------------------------------------------------
   Name				 :GetLocaleFlag
   Synopsis	         :This function returns the Locale flag value
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
		True	- /Locale changed recently.
		False	- no change in Locale till last command
   Global Variables  :None
   Calling Syntax    :GetLocaleFlag()
   Notes             :None
------------------------------------------------------------------------*/

BOOL CGlobalSwitches::GetLocaleFlag()
{
	return m_bLocaleFlag;
}

/*------------------------------------------------------------------------
   Name				 :SetNode
   Synopsis	         :This function Assigns the node passed in parameter
                      to m_pszNode
   Type	             :Member Function
   Input parameters   :
           pszNode   -String type,contains Node option specified in the
		              command
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetNode(pszNode)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::SetNode(_TCHAR* pszNode)
{
	BOOL bResult = TRUE;	
	SAFEDELETE(m_pszNode);
	if(pszNode)
	{
		if (!CompareTokens(pszNode, CLI_TOKEN_NULL))
		{
			m_pszNode = new _TCHAR [lstrlen(pszNode)+1];
			if (m_pszNode)
			{
				lstrcpy(m_pszNode, pszNode);	
				m_uConnInfoFlag |= NODE;
			}
			else
				bResult = FALSE;
		}
		else
		// "." specifies current node
		{
			m_pszNode = new _TCHAR [lstrlen(m_pszNodeName)+1];
			if (m_pszNode)
			{
				lstrcpy(m_pszNode, m_pszNodeName);
				m_uConnInfoFlag &= ~NODE;
			}
			else
				bResult = FALSE;
		}
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :GetNode
   Synopsis	         :This function Returns the string held in m_pszNode
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetNode()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CGlobalSwitches::GetNode()
{
	return m_pszNode;
}

/*------------------------------------------------------------------------
   Name				 :ClearNodesList
   Synopsis	         :Clears the nodes list
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ClearNodesList()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::ClearNodesList()
{
	BOOL bRet = TRUE;
	CleanUpCharVector(m_cvNodesList);
	if (!AddToNodesList(CLI_TOKEN_NULL))
		bRet = FALSE;
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :SetAskForPassFlag
   Synopsis	         :This function sets the askforpassword flag
   Type	             :Member Function
   Input parameter   :bFlag
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAskForPassFlag(bFlag)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::SetAskForPassFlag(BOOL bFlag)
{
	m_bAskForPassFlag = bFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetAskForPassFlag
   Synopsis	         :This function checks and returns TRUE if the user 
					  has to be prompted for the password
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetAskForPassFlag()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::GetAskForPassFlag()
{
	return m_bAskForPassFlag;
}
/*------------------------------------------------------------------------
   Name				 :GetGetPrivilegesTextDesc
   Synopsis	         :This function checks and Returns the string 
					  equivalent of the boolean value contained in 
					  m_bPrivilges flag
   Type	             :Member Function
   Input parameter   :None
   Output parameters :
		bstrPriv - privileges status string
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :GetPrivilegesTextDesc()
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::GetPrivilegesTextDesc(_bstr_t& bstrPriv)
{
	try
	{
		if (m_bPrivileges) 
			bstrPriv = _bstr_t(CLI_TOKEN_ENABLE);
		else
			bstrPriv = _bstr_t(CLI_TOKEN_DISABLE);
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :GetTraceTextDesc
   Synopsis	         :This function checks and Returns the string 
					  equivalent of the boolean value contained in 
					  m_bTrace flag
   Type	             :Member Function
   Input parameter   :None
   Output parameters :
		bstrTrace - trace status string
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :GetTraceTextDesc(bstrTrace)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::GetTraceTextDesc(_bstr_t& bstrTrace)
{
	try
	{
		if (m_bTrace) 
			bstrTrace = CLI_TOKEN_ON;
		else
			bstrTrace = CLI_TOKEN_OFF;
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :GetInteractiveTextDesc
   Synopsis	         :This function checks and Returns the string 
					  equivalent of the boolean value contained in 
					  m_bInteractive flag
   Type	             :Member Function
   Input parameter   :None
   Output parameters :
		bstrInteractive - interactive status string
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :GetInteractiveTextDesc(bstrInteractive)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::GetInteractiveTextDesc(_bstr_t& bstrInteractive)
{
	try
	{
		if (m_bInteractive) 
			bstrInteractive = CLI_TOKEN_ON;
		else
			bstrInteractive = CLI_TOKEN_OFF;
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :GetFailFastTextDesc
   Synopsis	         :Return the string equivalent of the boolean value
					  contained in m_bFailFast flag.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :
		bstrFailFast - FailFast status string
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :GetFailFastTextDesc(bstrFailFast)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::GetFailFastTextDesc(_bstr_t& bstrFailFast)
{
	try
	{
		if (m_bFailFast) 
			bstrFailFast = CLI_TOKEN_ON;
		else
			bstrFailFast = CLI_TOKEN_OFF;
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :GetImpLevelTextDesc
   Synopsis	         :This function checks and Returns the string 
					  equivalent of the boolean value contained in 
					  m_ImpLevel flag
   Type	             :Member Function
   Input parameter   :None
   Output parameters :
		bstrImpLevel - impersonation level description
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :GetImpLevelTextDesc(bstrImpLevel)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::GetImpLevelTextDesc(_bstr_t& bstrImpLevel)
{
	try
	{
		switch(m_ImpLevel)
		{
		case 1:
				bstrImpLevel = L"ANONYMOUS";
				break;
		case 2:
				bstrImpLevel = L"IDENTIFY";
				break;
		case 3:
				bstrImpLevel = L"IMPERSONATE";
				break;
		case 4:
				bstrImpLevel = L"DELEGATE";
				break;
		default:
				bstrImpLevel = TOKEN_NA;
				break;
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}
/*------------------------------------------------------------------------
   Name				 :GetAuthLevelTextDesc
   Synopsis	         :This function checks and Returns the string 
					  equivalent of the boolean value contained in 
					  m_AuthLevel flag
   Type	             :Member Function
   Input parameter   :None
   Output parameters :
			bstrAuthLevel - authentication level description
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :GetAuthLevelTextDesc(bstrAuthLevel)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::GetAuthLevelTextDesc(_bstr_t& bstrAuthLevel)
{
	try
	{
		switch(m_AuthLevel)
		{
		case 0:
				bstrAuthLevel = L"DEFAULT";
				break;
		case 1:
				bstrAuthLevel = L"NONE";
				break;
		case 2:
				bstrAuthLevel = L"CONNECT";
				break;
		case 3:
				bstrAuthLevel = L"CALL";
				break;
		case 4:
				bstrAuthLevel = L"PKT";
				break;
		case 5:
				bstrAuthLevel = L"PKTINTEGRITY";
				break;
		case 6:
				bstrAuthLevel = L"PKTPRIVACY";
				break;
		default:
				bstrAuthLevel = TOKEN_NA;
				break;
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}
/*------------------------------------------------------------------------
   Name				 :GetNodeString
   Synopsis	         :This function Returns the ',' separated node
					  string of the available nodes
   Type	             :Member Function
   Input parameter   :None
   Output parameters :
			bstrNString - node string (comma separated)
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :GetNodeString(bstrNSString)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::GetNodeString(_bstr_t& bstrNString)
{
	try
	{
		CHARVECTOR::iterator theIterator;
		if (m_cvNodesList.size() > 1)
		{
			theIterator = m_cvNodesList.begin();
			// Move to next node
			theIterator++;
			while (theIterator != m_cvNodesList.end())
			{
				bstrNString += *theIterator;
				theIterator++;
				if (theIterator != m_cvNodesList.end())
					bstrNString += L", ";
			}
		}
		else
		{
			bstrNString = m_pszNode;
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}
/*------------------------------------------------------------------------
   Name				 :GetRecordPathDesc
   Synopsis	         :This function checks and Returns the string 
					  equivalent of the boolean value contained in 
					  m_pszRecordPath flag
   Type	             :Member Function
   Input parameter   :None
   Output parameters :
			bstrRPDesc - record path description
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :GetRecordPathDesc(bstrRPDesc)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::GetRecordPathDesc(_bstr_t& bstrRPDesc)
{
	try
	{
		if (m_pszRecordPath) 
		{
			bstrRPDesc = m_pszRecordPath;
		}
		else
			bstrRPDesc = TOKEN_NA;
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :SetFailFast
   Synopsis	         :This function sets the m_bFailFast flag.
   Type	             :Member Function
   Input parameter   :
			   bFlag - Boolean variable to set flag.
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetFailFast(bFlag)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::SetFailFast(BOOL bFlag)
{
	m_bFailFast = bFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetFailFast
   Synopsis	         :This function returns the m_bFailFast flag.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetFailFast()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::GetFailFast()
{
	return m_bFailFast;
}


/*------------------------------------------------------------------------
   Name				 :SetOutputOption
   Synopsis	         :This function sets the ouput option.
   Type	             :Member Function
   Input parameter   :opoOutputOpt - Specifies the ouput option.
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetOutputOption(opoOutputOpt)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::SetOutputOrAppendOption(OUTPUTSPEC opsOpt,
											  BOOL bIsOutput)
{
	if ( bIsOutput == TRUE )
		m_opsOutputOpt = opsOpt;
	else
		m_opsAppendOpt = opsOpt;
}

/*------------------------------------------------------------------------
   Name				 :GetOutputOption
   Synopsis	         :This function returns the ouput option.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :OUTPUTOPT
   Global Variables  :None
   Calling Syntax    :GetOutputOption()
   Notes             :None
------------------------------------------------------------------------*/
OUTPUTSPEC CGlobalSwitches::GetOutputOrAppendOption(BOOL bIsOutput)
{
	OUTPUTSPEC opsOpt;
	if ( bIsOutput == TRUE )
		opsOpt = m_opsOutputOpt;
	else
		opsOpt = m_opsAppendOpt;

	return opsOpt;
}

/*------------------------------------------------------------------------
   Name				 :SetOutputOrAppendFileName
   Synopsis	         :This function Set Output or Append File Name,
					  bOutput = TRUE for Output FALSE for Append.
   Type	             :Member Function
   Input parameter   :pszFileName - output or append file name
                      bOutput - output option 
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetOutputOrAppendFileName(pszFileName,bOutput)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::SetOutputOrAppendFileName(const _TCHAR* pszFileName,
												BOOL  bOutput)
{
	BOOL bResult = TRUE;
	
	if ( bOutput == TRUE )
	{
		SAFEDELETE(m_pszOutputFileName)
	}
	else
	{
		SAFEDELETE(m_pszAppendFileName)
	}

	if ( pszFileName != NULL )
	{
		_TCHAR* pszTempFileName;
		pszTempFileName = new _TCHAR [lstrlen(pszFileName)+1];
		if ( pszTempFileName == NULL ) 
			bResult = FALSE;
		else
		{
			if ( bOutput == TRUE )
			{
				m_pszOutputFileName = pszTempFileName;
				lstrcpy(m_pszOutputFileName, pszFileName);
			}
			else
			{
				m_pszAppendFileName = pszTempFileName;
				lstrcpy(m_pszAppendFileName, pszFileName);
			}
		}
	}

	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :GetOutputOrAppendFileName
   Synopsis	         :This function returns the output or append file name
					  depending upon the output option - bOutput.
   Input parameter   :bOutput - output option 
   Output parameters :None
   Return Type       :_TCHAR
   Global Variables  :None
   Calling Syntax    :GetOutputOrAppendFileName(BOOL	bOutput)
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR*	CGlobalSwitches::GetOutputOrAppendFileName(BOOL	bOutput)
{
	_TCHAR*		pszTempFile;

	if ( bOutput == TRUE )
		pszTempFile = m_pszOutputFileName;
	else
		pszTempFile = m_pszAppendFileName;

	return pszTempFile;
}

/*------------------------------------------------------------------------
   Name				 :GetOutputOptTextDesc
   Synopsis	         :This function returns the string equivalent of the 
					  OUTPUTOPT value contained in m_opoOutputOpt member.
   Input parameter   :None
   Output parameters :bstrOutputOpt - string equivalent of the 
					  OUTPUTOPT value
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :GetOutputOptTextDesc(bstrOutputOpt)
   Notes             :None
------------------------------------------------------------------------*/
void	CGlobalSwitches::GetOutputOrAppendTextDesc(_bstr_t& bstrOutputOpt,
												   BOOL bIsOutput)	
{
	try
	{
		if ( bIsOutput == TRUE )
		{
			if ( m_opsOutputOpt == STDOUT )
				bstrOutputOpt = CLI_TOKEN_STDOUT;
			else if ( m_opsOutputOpt == CLIPBOARD )
				bstrOutputOpt = CLI_TOKEN_CLIPBOARD;
			else
				bstrOutputOpt = _bstr_t(m_pszOutputFileName);
		}
		else
		{
			if ( m_opsAppendOpt == STDOUT )
				bstrOutputOpt = CLI_TOKEN_STDOUT;
			else if ( m_opsAppendOpt == CLIPBOARD )
				bstrOutputOpt = CLI_TOKEN_CLIPBOARD;
			else
				bstrOutputOpt = _bstr_t(m_pszAppendFileName);
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}


/*------------------------------------------------------------------------
   Name				 :SetOutputOrAppendFilePointer
   Synopsis	         :This function Sets output or append file pointer,
					  bOutput == TRUE for Output 
					  bOutput == FALSE or Append.
   Input parameter   :fpFile -  pointer to output or append
					  bOutput - ouput option
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetOutputOrAppendFilePointer(fpFile, bOutput)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::SetOutputOrAppendFilePointer(FILE* fpFile, BOOL bOutput)
{
	if ( bOutput == TRUE )
		m_fpOutFile = fpFile;
	else
		m_fpAppendFile = fpFile;
}
/*------------------------------------------------------------------------
   Name				 :GetOutputOrAppendFilePointer
   Synopsis	         :This function returns the ouput or append file pointer.
					  bOutput == TRUE for Output 
					  bOutput == FALSE or Append.
   Input parameter   :bOutput - ouput option
   Output parameters :None
   Return Type       :FILE*
   Global Variables  :None
   Calling Syntax    :GetOutputOrAppendFilePointer(bOutput)
   Notes             :None
------------------------------------------------------------------------*/
FILE* CGlobalSwitches::GetOutputOrAppendFilePointer(BOOL bOutput)
{
	FILE* fpTemp;
	if ( bOutput == TRUE )
		fpTemp = m_fpOutFile;
	else
		fpTemp = m_fpAppendFile;
	return fpTemp;
}

/*------------------------------------------------------------------------
   Name				 :GetSequenceNumber
   Synopsis	         :This function returns the sequence number of the command 
                      logged .
   Input parameter   :None
   Output parameters :None
   Return Type       :WMICLIINT
   Global Variables  :None
   Calling Syntax    :GetSequenceNumber()
   Notes             :None
------------------------------------------------------------------------*/
WMICLIINT CGlobalSwitches::GetSequenceNumber()
{
	return m_nSeqNum;
}

/*------------------------------------------------------------------------
   Name				 :GetLoggedonUser
   Synopsis	         :This function returns the current logged on user.
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetLoggedonUser()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR*	CGlobalSwitches::GetLoggedonUser()
{
	return m_pszLoggedOnUser;
}

/*------------------------------------------------------------------------
   Name				 :GetMgmtStationName
   Synopsis	         :This function returns the management station that 
				      issued the command.
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetMgmtStationName()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CGlobalSwitches::GetMgmtStationName()
{
	return m_pszNodeName;
}

/*------------------------------------------------------------------------
   Name				 :GetStartTime
   Synopsis	         :This function returns the time at which the command
					  execution started. 
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetStartTime()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR*	CGlobalSwitches::GetStartTime()
{
	return m_pszStartTime;
}

/*------------------------------------------------------------------------
   Name				 :SetStartTime
   Synopsis	         :This function sets the time at which the command
					  execution started. 
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetStartTime()
   Notes             :None
------------------------------------------------------------------------*/
BOOL	CGlobalSwitches::SetStartTime()
{
	BOOL bResult = TRUE;
	if (m_pszStartTime == NULL)
	{
		m_pszStartTime = new _TCHAR[BUFFER64];
	}
	if (m_pszStartTime)
	{
		SYSTEMTIME stSysTime;
		GetLocalTime(&stSysTime);

		_stprintf(m_pszStartTime, L"%.2d-%.2d-%.4dT%.2d:%.2d:%.2d", 
							stSysTime.wMonth, stSysTime.wDay, stSysTime.wYear,
							stSysTime.wHour, stSysTime.wMinute, stSysTime.wSecond);

		// Increment the command counter.
		m_nSeqNum++; 
	}
	else
		bResult = FALSE;
	return bResult;
}
/*------------------------------------------------------------------------
   Name				 :SetAggregateFlag
   Synopsis	         :This function sets the Aggregation flag
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetAggregateFlag(BOOL)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::SetAggregateFlag(BOOL bAggregateFlag)
{
	m_bAggregateFlag = bAggregateFlag;
}
/*------------------------------------------------------------------------
   Name				 :GetAggreagateFlag
   Synopsis	         :This function gets the Aggregation flag
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetAggregateFlag()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::GetAggregateFlag()
{
	return m_bAggregateFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetAggregateTextDesc
   Synopsis	         :This function checks and Returns the string 
					  equivalent of the boolean value contained in 
					  m_bAggregateFlag flag
   Type	             :Member Function
   Input parameter   :None
   Output parameters :
		bstrAggregate - aggreaget status string
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :GetAggregateTextDesc(bstrAggregate)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::GetAggregateTextDesc(_bstr_t& bstrAggregate)
{
	try
	{
		if (m_bAggregateFlag) 
			bstrAggregate = CLI_TOKEN_ON;
		else
			bstrAggregate = CLI_TOKEN_OFF;
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\formatengine.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: FormatEngine.h 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This file consist of class declaration of
							  class CFormatEngine
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 12th-March-2001
****************************************************************************/ 
/*-------------------------------------------------------------------
 Class Name			: CFormatEngine
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the functionality needed
					  for displaying the following:
					  1. results in the user desired format
					  2. error code(s) with description
					  3. success/failure status
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: CParsedInfo
					  CErrorInfo 	
					  CWMICliLog
 Interfaces Used    : WMI XML Adapter
 --------------------------------------------------------------------*/

// forward declaration of classes
class CParsedInfo;
class CErrorInfo;
//class CWMICliLog;
class CWMICliXMLLog;

////////////////////////////////////////////////////////////////////////
// CFormatEngine
class CFormatEngine
{
public:
// Construction
	CFormatEngine();

// Destruction
	~CFormatEngine();

// Attributes
private:
	// Pointer to object of type IXMLDOMDocument, 
	// points to XML document containing result set.
	IXMLDOMDocument2	*m_pIXMLDoc;

	// Pointer to object of type IXMLDOMDocument, 
	// points to XSL document containing format of 
	// the output result.  
	IXMLDOMDocument2	*m_pIXSLDoc;

	// Object of type CErrorInfo, Used for handling 
	// Error information.
	CErrorInfo			m_ErrInfo;

	// Object of type CWMICliLog, Used for logging 
	// the input and output to the logfile.
	//CWMICliLog			m_WmiCliLog;

	// SRIRAM - xml logging
	CWMICliXMLLog		m_WmiCliLog;
	// SRIRAM - xml logging

	// Loggin option
	ERRLOGOPT			m_eloErrLogOpt;

	// help vector
	LPSTRVECTOR			m_cvHelp;

	// Help flag
	BOOL				m_bHelp;

	// Record flag
	BOOL				m_bRecord;

	// Trace flag
	BOOL				m_bTrace;

	// Display LIST flag.
	OUTPUTSPEC			m_opsOutputOpt;

	// Get output option.
	BOOL				m_bGetOutOpt;

	// Display CALL flag.
	BOOL				m_bDispCALL;

	// Display SET flag.
	BOOL				m_bDispSET;

	// Display LIST flag.
	BOOL				m_bDispLIST;

	// Flag to specify availibilty of Append file pointer to format engine.
	BOOL				m_bGetAppendFilePinter;

	// File pointer of append file.
	FILE*				m_fpAppendFile;

	// Flag to specify availibilty of output file pointer to format engine.
	BOOL				m_bGetOutputFilePinter;

	// File pointer of out file.
	FILE*				m_fpOutFile;

	BOOL				m_bLog;

	_bstr_t				m_bstrOutput;
	BOOL				m_bInteractiveHelp;
	
// Operations
private:
	// Creates an empty XML Document and returns the same 
	// in Passed Parameter.
	HRESULT				CreateEmptyDocument(IXMLDOMDocument2** pIDoc);
	
	// Applies a XSL style sheet containing format of the 
	// display to a XML file Containing result set.
	BOOL				ApplyXSLFormatting(CParsedInfo& rParsedInfo);
	
	// Displays GET verb usage.
	void				DisplayGETUsage(CParsedInfo& rParsedInfo);
	
	// Displays LIST verb usage.
	void				DisplayLISTUsage(CParsedInfo& rParsedInfo);
	
	// Displays CALL verb usage.
	void				DisplayCALLUsage(CParsedInfo& rParsedInfo);
	
	// Displays SET verb usage.
	void				DisplaySETUsage(CParsedInfo& rParsedInfo);
	
	// Displays ASSOC verb usage.
	void				DisplayASSOCUsage(CParsedInfo& rParsedInfo);

	// Displays CREATE verb usage.
	void				DisplayCREATEUsage(CParsedInfo& rParsedInfo);

	// Displays DELETE verb usage
	void				DisplayDELETEUsage(CParsedInfo& rParsedInfo);
	
	// Frames the help vector
	void				FrameHelpVector(CParsedInfo& refParsedInfo);
	
	// Displays help for Alias 
	void				DisplayAliasHelp(CParsedInfo& rParsedInfo);

	// Displays help for Alias PATH
	void				DisplayPATHHelp(CParsedInfo& refParsedInfo);
	
	// Displays help for WHERE
	void				DisplayWHEREHelp(CParsedInfo& refParsedInfo);
	
	// Displays help for CLASS
	void				DisplayCLASSHelp(CParsedInfo& refParsedInfo);
	
	// Displays help for PWhere
	void				DisplayPWhereHelp(CParsedInfo& refParsedInfo);
	
	// Displays alias names
	void				DisplayAliasFriendlyNames(CParsedInfo& refParsedInfo, 
								_TCHAR* pszAlias = NULL);
	
	// Display help for Alias verbs
	void				DisplayMethodDetails(CParsedInfo& refParsedInfo);

	// Display help for /GET /?
	void				DisplayPropertyDetails(CParsedInfo& refParsedInfo);
	
	// Displays help for standard verbs
	void				DisplayStdVerbDescriptions(CParsedInfo& refParsedInfo);
	
	// Displays localized string given the resource string ID
	void				DisplayString(UINT uID, BOOL bAddToVector = TRUE,
									LPTSTR lpszParam = NULL,
									BOOL	bIsError = FALSE);

	// Displays help for global switches
	void				DisplayGlobalSwitchesAndOtherDesc(CParsedInfo& 
								refParsedInfo);

	// Displays help for global switches in brief
	void				DisplayGlobalSwitchesBrief();

	// Displays the page-by-page help
	void				DisplayPagedHelp(CParsedInfo& rParsedInfo);

	// Displays all usages of standard verb available.
	void				DisplayStdVerbsUsage(_bstr_t bstrBeginStr,
								BOOL bClass = FALSE);

	// Displays help for /TRANSLATE switch.
	void				DisplayTRANSLATEHelp(CParsedInfo& rParsedInfo);

	// Displays help for /EVERY switch.
	void				DisplayEVERYHelp(CParsedInfo& rParsedInfo);

	// Displays help for /FORMAT switch.
	void				DisplayFORMATHelp(CParsedInfo& rParsedInfo);

	// Displays help for Verb Switches.
	void				DisplayVERBSWITCHESHelp(CParsedInfo& rParsedInfo);

	// Translates the output.
	void				ApplyTranslateTable(STRING& strString, 
									 CParsedInfo& rParsedInfo);

	// Displays the environment variables.
	void				DisplayContext(CParsedInfo& rParsedInfo);

	// Displays the help on CONTEXT keyword
	void				DisplayContextHelp();

	// Displays invalid properties if any.
	void				DisplayInvalidProperties(CParsedInfo& rParsedInfo, 
												BOOL bSetVerb = FALSE);

	// Displays the large string line by line.
	void				DisplayLargeString(CParsedInfo& rParsedInfo, 
											STRING& strLargeString);

	// Travese through XML stream node by node and translate all nodes
	BOOL				TraverseNode(CParsedInfo& rParsedInfo);

	// Displays help for /RESULTCLASS assoc switch.
	void				DisplayRESULTCLASSHelp();
		
	// Displays help for /RESULTROLE assoc switch.
	void				DisplayRESULTROLEHelp();
	
	// Displays help for /ASSOCCLASS assoc switch.
	void				DisplayASSOCCLASSHelp();

	// Displays help for /REPEAT
	void				DisplayREPEATHelp();

	// Apply cascading transforms and return the result data in bstrOutput
	BOOL				DoCascadeTransforms(CParsedInfo& rParsedInfo,
										_bstr_t& bstrOutput);

	// Add the parameters to the IXSLProcessor object
	HRESULT				AddParameters(CParsedInfo& rParsedInfo, 
									IXSLProcessor *pIProcessor, 
									BSTRMAP bstrmapParam);
public:
	// Displays the result referring CcommandSwitches and 
	// CGlobalSwitches Objects of the CParsedInfo object.
	BOOL				DisplayResults(CParsedInfo&, BOOL bInteractiveHelp = FALSE);

	// Displays localized string given the information to be displayed.
	void				DisplayString(LPTSTR lpszMsg, BOOL bScreen = TRUE, 
									  BOOL	bIsError = FALSE);

	// Carries out the releasing process.
	void				Uninitialize(BOOL bFinal = FALSE);

	// Appends the output or prompt messages to the output string
	// Useful in the case of CALL, CREATE, DELETE and SET for logging
	// the output to XML log.
	void				AppendtoOutputString(_TCHAR* pszOutput); 

	// Returns Error info Object
	CErrorInfo&			GetErrorInfoObject() {return m_ErrInfo; };

	// Displays COM error message
	void				DisplayCOMError(CParsedInfo& rParsedInfo, 
						BOOL bToStdErr = FALSE);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\globalswitches.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: CommandSwitches.h 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This file consist of class declaration of
							  class GlobalSwitches
Revision History			: 
	Last Modified by		: Ch. Sriramachandramurthy 
	Last Modified on		: 17th-November-2000
****************************************************************************/ 

/*-------------------------------------------------------------------
 Class Name			: CGlobalSwitches
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the functionality needed
					  for accessing and storing the global switches 
					  information, which will be used by Parsing, 
					  Execution and Format Engines depending upon the 
					  applicablity.
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: None
 Interfaces Used    : None
 --------------------------------------------------------------------*/

#pragma once

class CGlobalSwitches
{
public:
// Construction
	CGlobalSwitches();

// Destruction
	~CGlobalSwitches();

// Restrict Assignment
	CGlobalSwitches& operator=(CGlobalSwitches& rGlblSwitches);

// Attributes
private:
	// Mapping b/w allowed strings for implevel and
	// the corresponding integer values.
	CHARINTMAP  m_cimImpLevel;

	// Mapping b/w allowed strings for authlevel and
	// the corresponding integer values.
	CHARINTMAP	m_cimAuthLevel;

	//String type, It stores the authority value.
	_TCHAR*		m_pszAuthority;

    //String type, It stores Namespace specified in the command.
	_TCHAR*		m_pszNameSpace;

    //String type, It stores Role specified in the command.
	_TCHAR*		m_pszRole;

    //String type, It stores Node specified in the command.
	_TCHAR*		m_pszNode;

    //CHARVECTOR type, It stores the Nodes specified in the command.
	CHARVECTOR	m_cvNodesList;

    //String type, It stores User specified in the command.
	_TCHAR*		m_pszUser;

    //String type, It stores Password specified in the command.
	_TCHAR*		m_pszPassword;

    //String type, It stores Locale value specified
	//in the command
 	_TCHAR*		m_pszLocale;

    //String type, It stores the Record  specified in the command.
	_TCHAR*		m_pszRecordPath;

    //Boolean type, It stores the value of the Privileges option specified
	//in the conmmand
    BOOL		m_bPrivileges;

	//Boolean type, It stores the value of the Aggregate option specified
	//in the conmmand
	BOOL		m_bAggregateFlag;

    //enumerated data type, It stores the value of the ImpersonationLevel 
	//specified in the command.
	IMPLEVEL	m_ImpLevel;

    //enumerated data type, It stores the value of the Authentication Level
	//specified in the command.
	AUTHLEVEL	m_AuthLevel;

    // Boolean type, It specifies presence of the Interactive option  
    //in the command
	BOOL		m_bInteractive;

    //Boolean type, It specifies presence of the trace option  in
    //the command
	BOOL		m_bTrace;

	//Boolean type, It specifies Help(/?) option in the command
	BOOL		m_bHelp;

    //HELPOPTION type, to specify type of help needed ( help option ).
	HELPOPTION	m_HelpOption;

	//CONNECTION information flag
	UINT		m_uConnInfoFlag;

	// role change flag
	BOOL		m_bRoleFlag;

	// namespace change flag
	BOOL		m_bNSFlag;

	// locale change flag
	BOOL		m_bLocaleFlag;

	// prompt for password flag
	BOOL		m_bAskForPassFlag;

	// change of recordpath flag
	BOOL		m_bRPChange;
	
	// FailFast flag.
	BOOL		m_bFailFast;

	// Output option.
	OUTPUTSPEC	m_opsOutputOpt;

	// Append option.
	OUTPUTSPEC	m_opsAppendOpt;

	// Output file name.
	_TCHAR*		m_pszOutputFileName;

	// File pointer to output file stream..
	FILE*		m_fpOutFile;

	// Append file name.
	_TCHAR*		m_pszAppendFileName;

	// File pointer to append file stream..
	FILE*		m_fpAppendFile;

	WMICLIINT	m_nSeqNum;

	_TCHAR*		m_pszLoggedOnUser;
	
	_TCHAR*		m_pszNodeName;
	
	_TCHAR*		m_pszStartTime;
// Operations
public:

	//Sets the authority value
	BOOL		SetAuthority(_TCHAR* pszAuthority);

	//Sets the namespace passed in parameter to m_pszNameSpace.
	BOOL		SetNameSpace(_TCHAR* pszNameSpace);

    //Sets the role passed in parameter to m_pszRole.
	BOOL		SetRole(_TCHAR* pszRole);

    //Assigns the locale passed in parameter to m_pszLocale.
	BOOL		SetLocale(_TCHAR* pszLocale);

    //Assigns the node passed in parameter to m_pszNode
	BOOL		SetNode(_TCHAR* pszNode);

    //Adds the node passed in parameter to m_cvNodesList vector.
	BOOL		AddToNodesList(_TCHAR* pszNode);

    //Assigns the user passed in parameter to m_pszUser
	BOOL		SetUser(_TCHAR* pszUser);

    //Assigns the password passed in parameter to m_pszPassword
	BOOL		SetPassword(_TCHAR* pszPassword);

    //Assigns the record file passed in parameter to m_pszRecordPath
	BOOL		SetRecordPath(_TCHAR* pszRecordPath);

    //Assigns the bool value passed in parameter to m_bPrivileges
	void		SetPrivileges(BOOL bEnable);
	
    //Assigns the impersonation level passed in parameter to
    //m_ImpLevel.
 	BOOL		SetImpersonationLevel(_TCHAR* const pszImpLevel);

    //Assigns the authentication level passed in parameter to
    //m_AuthLevel.
	BOOL		SetAuthenticationLevel(_TCHAR* const pszAuthLevel);

    //This function sets the m_bTrace to TRUE,If Trace mode
    //is specified in the command 
	void		SetTraceMode(BOOL bTrace);

    //This function sets the m_bInteractive to TRUE,If 
    //interactive mode is specified in the command          
	void		SetInteractiveMode(BOOL bInteractive);

    //sets the m_bHelp to TRUE, If /? is specified in the
    //command 
	void		SetHelpFlag(BOOL bHelp);

	// Sets the namespace change status flag with bNSFlag value
	void		SetNameSpaceFlag(BOOL bNSFlag);

	// Sets the role change status flag with bRoleFlag value
	void		SetRoleFlag(BOOL bRoleFlag);

	// Sets the locale change status flag with bLocaleFlag value
	void		SetLocaleFlag(BOOL bLocaleFlag);

	// Sets the recordpath change status flag with bRPChange value
	void		SetRPChangeStatus(BOOL bRPChange);

    //This function specifies whether the help should
    //be brief or full 
	void		SetHelpOption(HELPOPTION helpOption);

	//This function sets the Connection Info flag
	void		SetConnInfoFlag(UINT uFlag);

	// Set AskForPass flag.
	void		SetAskForPassFlag(BOOL bFlag);

	// Set m_bFailFast
	void		SetFailFast(BOOL bFlag);

	//This function returns the Connection Info flag
	UINT		GetConnInfoFlag();

	//Returns the string held in m_pszAuthority
	_TCHAR*		GetAuthority();

    //Returns the string held in m_pszNameSpace	
	_TCHAR*		GetNameSpace();

    //Returns the string held in m_pszRole
	_TCHAR*		GetRole();

    //Returns the string held in m_pszLocale
	_TCHAR*		GetLocale();

    //Returns the string held in m_pszNode
	_TCHAR*		GetNode();

    //Returns the referrence to m_cvNodesList.
	CHARVECTOR& GetNodesList();

    //Returns the string held in m_pszUser
	_TCHAR*		GetUser();

    //Returns the string held in m_pszPassword
	_TCHAR*		GetPassword();

    //Returns the string held in m_pszRecordPath
	_TCHAR*		GetRecordPath();

    //Returns the m_bPrivileges value
	BOOL		GetPrivileges();

	// Return the string equivalent of the boolean value
	// contained in m_bPrivilges flag
	void		GetPrivilegesTextDesc(_bstr_t& bstrPriv);

	// Return the string equivalent of the boolean value
	// contained in m_bFailFast flag
	void		GetFailFastTextDesc(_bstr_t& bstrFailFast);

	// Return the string equivalent of the OUTPUTSPEC value
	// contained in m_opsOutputOpt member.
	void		GetOutputOrAppendTextDesc(_bstr_t& bstrOutputOpt, 
										  BOOL bIsOutput);

	// Return the string equivalent of the boolean value
	// contained in m_bTrace flag
	void		GetTraceTextDesc(_bstr_t& bstrTrace);

	// Return the string equivalent of the boolean value
	// contained in m_bInteractive flag
	void		GetInteractiveTextDesc(_bstr_t& bstrInteractive);

	// Returns the string equivalent of the implevel value
	// contained in m_ImpLevel
	void		GetImpLevelTextDesc(_bstr_t& bstrImpLevel);

	// Returns the string equivalent of the authlevel value
	// contained in m_AuthLevel
	void		GetAuthLevelTextDesc(_bstr_t& bstrAuthLevel);

	// Returns the ',' separated node string of the available
	// nodes
	void		GetNodeString(_bstr_t& bstrNString);

	// Returns the content of the m_pszRecordPath
	// if NULL returns "N/A"
	void		GetRecordPathDesc(_bstr_t& bstrRP);

    //Returns impersonation level held in m_ImpLevel
	LONG		GetImpersonationLevel();

    //Returns authentication level held in m_AuthLevel
	LONG		GetAuthenticationLevel();

    //Returns Trace status held in m_bTrace	
	BOOL		GetTraceStatus();

    //Returns Interactive status held in m_bInteractive
	BOOL		GetInteractiveStatus();

    //Returns helpflag held in m_bHelp
	BOOL		GetHelpFlag();

	// Returns the change of role status
	BOOL		GetRoleFlag();

	// Returns the change of namespace status
	BOOL		GetNameSpaceFlag();

	// Returns TRUE if message for password 
	// needs to be prompted.
	BOOL		GetAskForPassFlag();

	// Returns the change of locale status flag
	BOOL		GetLocaleFlag();

	// Returns the change of recordpath status flag
	BOOL		GetRPChangeStatus();

    //Returns helpflagOption held in m_bHelpOption
	HELPOPTION	GetHelpOption();

	// Returns the m_bFailFast flag.
	BOOL		GetFailFast();

	// Initialize the necessary member varialbes
	void		Initialize();

	// General functions
	void		Uninitialize();
	
	// Clears the Nodes List
	BOOL		ClearNodesList();

	// Set Output option.
	void		SetOutputOrAppendOption(OUTPUTSPEC opsOpt,
										BOOL bIsOutput);

	// Get Output option.
	OUTPUTSPEC	GetOutputOrAppendOption(BOOL bIsOutput);

	// Set Output or append File Name, bOutput == TRUE for Output FALSE 
	// for Append.
	BOOL		SetOutputOrAppendFileName(const _TCHAR* pszFileName, 
										  BOOL	bOutput);

	// Get Output or append file name, bOutput == TRUE for Output FALSE for
	// Append.
	_TCHAR*		GetOutputOrAppendFileName(BOOL	bOutput);

	// Set output or append file pointer, bOutput == TRUE for Output FALSE 
	// for Append.
	void		SetOutputOrAppendFilePointer(FILE* fpOutFile, BOOL	bOutput);

	// Get output file pointer, bOutput == TRUE for Output FALSE for Append.
	FILE*		GetOutputOrAppendFilePointer(BOOL	bOutput);


	WMICLIINT	GetSequenceNumber();
	_TCHAR*		GetLoggedonUser();
	_TCHAR*		GetMgmtStationName();
	_TCHAR*		GetStartTime();

	BOOL		SetStartTime();

	//Assigns the Aggregate flag passed in parameter to m_bAggregateFlag
	void		SetAggregateFlag(BOOL bAggregateFlag);

	//Gets the agregate flag contained in m_bAggregateFlag
	BOOL		GetAggregateFlag();

	// This function checks and Returns the string equivalent of the 
	// boolean value contained in m_bAggregateFlag flag
	void GetAggregateTextDesc(_bstr_t& bstrAggregate);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\makefile.inc ===
$(O)\cli.mof: cli.mof
    copy copyright.mof+cli.mof $(O)\cli.mof
$(O)\cliegali.mfl: cliegaliases.mfl
    copy copyright.mof+cliegaliases.mfl $(O)\cliegali.mfl
$(O)\cliegali.mof: cliegaliases.mof
    copy copyright.mof+cliegaliases.mof+cliegaliases.mfl $(O)\cliegali.mof
$(O)\htblsort.xsl: htable-sortby.xsl
    copy htable-sortby.xsl $(O)\htblsort.xsl
$(O)\texttbl.xsl: texttable.xsl
    copy texttable.xsl $(O)\texttbl.xsl
$(O)\texttblw.xsl: texttablewsys.xsl
    copy texttablewsys.xsl $(O)\texttblw.xsl
$(O)\textvalu.xsl: textvaluelist.xsl
    copy textvaluelist.xsl $(O)\textvalu.xsl
$(O)\wmicmoff.xsl: wmiclimofformat.xsl
    copy wmiclimofformat.xsl $(O)\wmicmoff.xsl
$(O)\wmictfmt.xsl: wmiclitableformat.xsl
    copy wmiclitableformat.xsl $(O)\wmictfmt.xsl
$(O)\wmictfns.xsl: wmiclitableformatnosys.xsl
    copy wmiclitableformatnosys.xsl $(O)\wmictfns.xsl
$(O)\wmicvalu.xsl: wmiclivalueformat.xsl
    copy wmiclivalueformat.xsl $(O)\wmicvalu.xsl
$(O)\xslmap.xml: xsl-mappings.xml
    copy xsl-mappings.xml $(O)\xslmap.xml
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\parsedinfo.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: ParsedInfo.cpp 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Revision History			: 
	Last Modified by		: Ch. Sriramachandramurthy
	Last Modified Date		: 11th-April-2001
****************************************************************************/ 
#include "Precomp.h"
#include "CommandSwitches.h"
#include "GlobalSwitches.h"
#include "HelpInfo.h"
#include "ErrorLog.h"
#include "ParsedInfo.h"


/*------------------------------------------------------------------------
   Name				 :CParsedInfo
   Synopsis	         :This function initializes the member variables when
                      an object of the class type is instantiated
   Type	             :Constructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CParsedInfo::CParsedInfo()
{
	lstrcpy( m_pszPwd, NULL_STRING );
}

/*------------------------------------------------------------------------
   Name				 :~CParsedInfo
   Synopsis	         :This function uninitializes the member variables 
					  when an object of the class type goes out of scope.
   Type	             :Destructor
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CParsedInfo::~CParsedInfo()
{
	m_GlblSwitches.Uninitialize();
	m_CmdSwitches.Uninitialize();
}

/*------------------------------------------------------------------------
   Name				 :GetCmdSwitchesObject
   Synopsis	         :This function returns CCommandSwitches object data
					  member m_CmdSwitches
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :CCommandSwitches&
   Global Variables  :None
   Calling Syntax    :GetCmdSwitchesObject()
   Notes             :None
------------------------------------------------------------------------*/
CCommandSwitches& CParsedInfo::GetCmdSwitchesObject()
{
	return m_CmdSwitches;
}
/*------------------------------------------------------------------------
   Name				 :GetGlblSwitchesObject
   Synopsis	         :This function returns CGlblSwitches object data
					  member m_GlblSwitches
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :CGlobalSwitches&
   Calling Syntax    :GetGlblSwitchesObject()
   Notes             :None
------------------------------------------------------------------------*/
CGlobalSwitches& CParsedInfo::GetGlblSwitchesObject()
{
	return m_GlblSwitches;
}

/*------------------------------------------------------------------------
   Name				 :GetHelpInfoObject
   Synopsis	         :This function returns CHelpInfo object data
					  member m_HelpInfo
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :CHelpInfo&
   Calling Syntax    :GetHelpInfoObject()
   Notes             :None
------------------------------------------------------------------------*/
CHelpInfo& CParsedInfo::GetHelpInfoObject()
{
	return m_HelpInfo;
}

/*------------------------------------------------------------------------
   Name				 :GetErrorLogObject
   Synopsis	         :This function returns CErrorLog object data
					  member m_ErrorLog
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :CErrorLog&
   Calling Syntax    :GetHelpInfoObject()
   Notes             :None
------------------------------------------------------------------------*/
CErrorLog& CParsedInfo::GetErrorLogObject()
{
	return m_ErrorLog;
}

/*------------------------------------------------------------------------
   Name				 :Initialize
   Synopsis	         :This function Initializes the CParedInfo object.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :Void
   Calling Syntax    :Initialize()
   Notes             :None
------------------------------------------------------------------------*/
void CParsedInfo::Initialize()
{
	m_bNewCmd	= TRUE;
	m_bNewCycle	= TRUE;
	m_CmdSwitches.Initialize();
	m_GlblSwitches.Initialize();
	m_HelpInfo.Initialize();
}

/*------------------------------------------------------------------------
   Name				 :Uninitialize
   Synopsis	         :This function uninitializes the CGlobalSwitches and
					  CCommandSwitches object
   Type	             :Member Function
   Input parameter   :bBoth - boolean value
   Output parameters :None
   Return Type       :
   Calling Syntax    :Uninitialize(bBoth)
   Notes             :None
------------------------------------------------------------------------*/
void CParsedInfo::Uninitialize(BOOL bBoth)
{
	// If session termination
	if (bBoth)
	{
		m_GlblSwitches.Uninitialize();
		m_CmdSwitches.Uninitialize();
	}
	// if new command
	else 
	{
		m_CmdSwitches.Uninitialize();
	}
	m_bNewCmd = TRUE;
	m_bNewCycle = TRUE;
}

/*------------------------------------------------------------------------
   Name				 :GetUser
   Synopsis	         :Returns the user name
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR* 
   Calling Syntax    :GetUser()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CParsedInfo::GetUser()
{
	// Check if alias name is available
	if (m_CmdSwitches.GetAliasName())
	{
		// Check if /USER global switch is not explicitly
		// specified.
		if (!(m_GlblSwitches.GetConnInfoFlag() & USER))
		{
			// Check if alias user is not NULL, if so 
			// return the alias user name
			if (m_CmdSwitches.GetAliasUser())   
			{
				return m_CmdSwitches.GetAliasUser();
			}
		}		
	}
	return m_GlblSwitches.GetUser();
}

/*------------------------------------------------------------------------
   Name				 :GetNode
   Synopsis	         :Returns the node name
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR* 
   Calling Syntax    :GetNode()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CParsedInfo::GetNode()
{
	// Check if alias name is available
	if (m_CmdSwitches.GetAliasName())
	{
		// Check if /NODE global switch is not explicitly
		// specified.
		if (!(m_GlblSwitches.GetConnInfoFlag() & NODE))
		{
			// Check if alias node name is not NULL, if so 
			// return the alias node name
			if (m_CmdSwitches.GetAliasNode())   
			{
				return m_CmdSwitches.GetAliasNode();
			}
		}
	}
	return m_GlblSwitches.GetNode();		
}

/*------------------------------------------------------------------------
   Name				 :GetLocale
   Synopsis	         :Returns the locale value
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR* 
   Calling Syntax    :GetLocale()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CParsedInfo::GetLocale()
{
	// Check if alias name is available
	if (m_CmdSwitches.GetAliasName())
	{
		// Check if /LOCALE global switch is not explicitly
		// specified.
		if (!(m_GlblSwitches.GetConnInfoFlag() & LOCALE))
		{
			// Check if alias locale value is not NULL, if so 
			// return the alias locale value
			if (m_CmdSwitches.GetAliasLocale())   
			{
				return m_CmdSwitches.GetAliasLocale();
			}
		}
	}
	// return the locale specified with global switches
	return m_GlblSwitches.GetLocale();	
}

/*------------------------------------------------------------------------
   Name				 :GetPassword
   Synopsis	         :Returns the password
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR* 
   Calling Syntax    :GetPassword()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CParsedInfo::GetPassword()
{
	// Check if alias name is available
	if (m_CmdSwitches.GetAliasName())
	{
		// Check if /PASSWORD global switch is not explicitly
		// specified.
		if (!(m_GlblSwitches.GetConnInfoFlag() & PASSWORD))
		{
			// Check if alias password value is not NULL, if so 
			// return the alias password value
			if (m_CmdSwitches.GetAliasPassword())   
			{
				return m_CmdSwitches.GetAliasPassword();
			}
		}
	}
	// If Credflag is set to FALSE means actual value
	// of the password should be passed.
	if (!m_CmdSwitches.GetCredentialsFlagStatus())
	{
		return m_GlblSwitches.GetPassword();
	}
	else
	{
		// treat password as BLANK
		return m_pszPwd;
	}
}

/*------------------------------------------------------------------------
   Name				 :GetNamespace
   Synopsis	         :Returns the namespace value
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR* 
   Calling Syntax    :GetNamespace()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CParsedInfo::GetNamespace()
{
	// Check if alias name is available
	if (m_CmdSwitches.GetAliasName())
	{
		// Check if alias namespace value is not NULL, if so 
		// return the alias namespace value (else fallback to 
		// namespace available with global switch)
		if (m_CmdSwitches.GetAliasNamespace())   
			return m_CmdSwitches.GetAliasNamespace();
	}
	// return the namespace specified with global switches
	return m_GlblSwitches.GetNameSpace();	
}

/*------------------------------------------------------------------------
   Name				 :GetUserDesc
   Synopsis	         :Returns the user name, if no user is available returns
					  "N/A"  - used only with CONTEXT (displaying environment
					  variables)
   Type	             :Member Function
   Input parameter   :None
   Output parameters :
			bstrUser - user name string
   Return Type       :void
   Calling Syntax    :GetUserDesc()
   Notes             :None
------------------------------------------------------------------------*/
void	CParsedInfo::GetUserDesc(_bstr_t& bstrUser)
{
	// Check if alias name is available
	if (m_CmdSwitches.GetAliasName())
	{
		// Check if /USER global switch is not explicitly
		// specified.
		if (!(m_GlblSwitches.GetConnInfoFlag() & USER))
		{
			// Check if alias user is not NULL, if so 
			// return the alias user name
			if (m_CmdSwitches.GetAliasUser())   
			{
				bstrUser = m_CmdSwitches.GetAliasUser();
			}
		}		
	}
	if (m_GlblSwitches.GetUser()) 
		bstrUser = m_GlblSwitches.GetUser();
	else
		bstrUser = TOKEN_NA;
}
/*------------------------------------------------------------------------
   Name				 :GetNewCommandStatus
   Synopsis	         :Checks if a command is new or not (used for 
					  logging into xml file)
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None			
   Return Type       :BOOL
   Calling Syntax    :GetNewCommandStatus()
   Notes             :None
------------------------------------------------------------------------*/
BOOL	CParsedInfo::GetNewCommandStatus()
{
	return m_bNewCmd;
}

/*------------------------------------------------------------------------
   Name				 :SetNewCommandStatus
   Synopsis	         :Sets the status of a new command
   Type	             :Member Function
   Input parameter   :
		bStatus		 - BOOL type,status of the command
   Output parameters :None			
   Return Type       :void
   Calling Syntax    :SetNewCommandStatus(bStatus)
   Notes             :None
------------------------------------------------------------------------*/
void CParsedInfo::SetNewCommandStatus(BOOL bStatus)
{
	m_bNewCmd = bStatus;
}

/*------------------------------------------------------------------------
   Name				 :GetNewCycleStatus
   Synopsis	         :Returns the status of the new cycle flag
   Type	             :Member Function
   Input parameter   :None		
   Output parameters :None			
   Return Type       :BOOL
   Calling Syntax    :GetNewCycleStatus()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CParsedInfo::GetNewCycleStatus()
{
	return m_bNewCycle;
}

/*------------------------------------------------------------------------
   Name				 :SetNewCycleStatus
   Synopsis	         :Sets the status of a new node
   Type	             :Member Function
   Input parameter   :
		bStatus		 - BOOL type, status of the new cycle
   Output parameters :None			
   Return Type       :void
   Calling Syntax    :SetNewCycleStatus(bStatus)
   Notes             :None
------------------------------------------------------------------------*/
void CParsedInfo::SetNewCycleStatus(BOOL bStatus)
{
	m_bNewCycle = bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\helpers.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: helpers.cpp 
Project Name				: WMI Command Line
Author Name					: Ch.Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This file has all the global function definitions 
Revision History			:
		Last Modified By	: Ch Sriramachandramurthy
		Last Modified Date  : 03-March-2001
*****************************************************************************/ 
#include "Precomp.h"
#include "CommandSwitches.h"
#include "GlobalSwitches.h"
#include "HelpInfo.h"
#include "ErrorLog.h"
#include "ParsedInfo.h"
#include "CmdTokenizer.h"
#include "CmdAlias.h"
#include "ErrorInfo.h"
#include "WmiCliXMLLog.h"
#include "ParserEngine.h"
#include "ExecEngine.h"
#include "FormatEngine.h"
#include "WmiCmdLn.h"
#include <io.h>

/*----------------------------------------------------------------------------
   Name				 :CompareTokens
   Synopsis	         :It compares the two tokens passed to it as input 
					  arguments and returns a BOOL value ,
					  TRUE if they are equal 
					  FALSE if not equal.
   Type	             :Global Function
   Input parameter(s):
			pszToken1- String type, Contains the first string of the two 
					   string to be compared
			pszToken2- String type, Contains the second string of the two 
					   string to be compared
   Output parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :CompareTokens(pszToken1,pszToken2)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL CompareTokens(_TCHAR* pszToken1, _TCHAR* pszToken2)
{	
	return (CSTR_EQUAL == CompareString(LOCALE_SYSTEM_DEFAULT, 
					NORM_IGNORECASE | NORM_IGNOREWIDTH,	
					pszToken1, (pszToken1) ? lstrlen(pszToken1) : 0,
					pszToken2, (pszToken2) ? lstrlen(pszToken2) : 0)) 
					? TRUE : FALSE;
}

/*----------------------------------------------------------------------------
   Name				 :Connect
   Synopsis	         :To connect to WMI namespace on a given server  with the
					  set of input user credentials.
   Type	             :Global Function
   Input parameter(s):
		pILocator	 -	Locator object 
		bstrNS		 -	Namespae to be connected to 
		bstrUser	 -	User name with which to connect 
		bstrPwd		 -	Password  for the user name  with which to connect
		bstrLocale	 -	Locale specified 
   Output parameters :
			pISvc	 -	WMI services object
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :Connect(pILocator, &pISvc, bstrNS, bstrUser, bstPwd,
							  bstrLocale)
   Notes             :None
----------------------------------------------------------------------------*/
HRESULT Connect(IWbemLocator* pILocator, IWbemServices** pISvc,
				BSTR bstrNS, BSTR bstrUser, BSTR bstrPwd, 
				BSTR bstrLocale, CParsedInfo& rParsedInfo)
{
	HRESULT hr			= S_OK;
	BSTR	bstrPass	= NULL;

	// If the user name is not NULL and the password is 
	// a) NULL, treat the password as BLANK
	// b) not NULL, treat the password as it is.
	if (bstrUser)
	{
		if (!bstrPwd)
		{
			bstrPass = ::SysAllocString(L"");

			// Set the credentials flag to TRUE - BLANK password
			rParsedInfo.GetCmdSwitchesObject().SetCredentialsFlag(TRUE);
		}
	}

	if (pILocator != NULL)
	{	
		// Call the ConnectServer method of the IWbemLocator
		hr = pILocator->ConnectServer(bstrNS, 
						bstrUser, 
						(!bstrPass) ? bstrPwd : bstrPass, 
						bstrLocale,	
						0L,	NULL, NULL,	pISvc);

		// If the username is specified and the password is not 
		// specified (the remote machine also has the same password)
		if (FAILED(hr) && bstrUser && (hr == E_ACCESSDENIED))
		{

			hr = pILocator->ConnectServer(bstrNS, 
							bstrUser, 
							NULL, 
							bstrLocale,	
							0L,	NULL, NULL,	pISvc);

			// Set the credentials flag to FALSE - NULL password
			rParsedInfo.GetCmdSwitchesObject().SetCredentialsFlag(FALSE);
		}
	}
	else
		hr = E_FAIL;
	if (bstrPass)
		::SysFreeString(bstrPass);
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :SetSecurity
   Synopsis	         :To set the security privileges at the interface level
   Type	             :Global Function
   Input parameter(s):
		pIUnknown	 -	Interface pointer
		pszDomain	 -	domain name
		pszAuthority -	authority (always passed as NULL)
		pszUser		 -	Username
		pszPassword	 -	Password
		uAuthLevel	 -	Authentication Level
		uImpLevel	 -	Impersonation Level
   Output parameter(s):None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :SetSecurity(pIUnknown, pszDomain, pszUser, 
								  pszPassword, uAuthLevel, uImpLevel)
   Notes             :(partly taken from WMI VC samples 'utillib'
----------------------------------------------------------------------------*/
HRESULT SetSecurity(IUnknown* pIUnknown, _TCHAR* pszAuthority, 
					_TCHAR* pszDomain, _TCHAR* pszUser, 
					_TCHAR* pszPassword, UINT uAuthLevel, 
					UINT uImpLevel) throw(WMICLIINT)
{
	SCODE						sc				= S_OK;
	BSTR						bstrAuthArg		= NULL, 
								bstrUserArg		= NULL;
	SEC_WINNT_AUTH_IDENTITY_W*	pAuthIdentity	= NULL;
	try
	{
		if(pIUnknown == NULL)
			return E_INVALIDARG;

		// If we are lowering the security, no need to deal with the 
		// identification information
		if(uAuthLevel == RPC_C_AUTHN_LEVEL_NONE)
			return CoSetProxyBlanket(pIUnknown, RPC_C_AUTHN_WINNT, 
							RPC_C_AUTHZ_NONE,
							NULL, RPC_C_AUTHN_LEVEL_NONE, 
							RPC_C_IMP_LEVEL_IDENTIFY,
							NULL, EOAC_NONE);

		// If we are doing trivial case, just pass in a null authentication 
		// structure which is used if the current logged in user's credentials
		// are OK.
		if((pszAuthority == NULL || lstrlen((LPCTSTR)pszAuthority) < 1) && 
			(pszUser == NULL || lstrlen((LPCTSTR)pszUser) < 1) && 
			(pszPassword == NULL || lstrlen((LPCTSTR)pszPassword) < 1))
				return CoSetProxyBlanket(pIUnknown, RPC_C_AUTHN_WINNT, 
							RPC_C_AUTHZ_NONE, NULL, uAuthLevel,
							uImpLevel, NULL, EOAC_NONE);

		// If user, or Authority was passed in, the we need 
		// to create an authority argument for the login
		sc = ParseAuthorityUserArgs(bstrAuthArg, bstrUserArg, 
						pszAuthority, pszUser);
		if(FAILED(sc))
			return sc;
		
		pAuthIdentity = new SEC_WINNT_AUTH_IDENTITY_W;

		// Check whether the memory allocation has been successful
		if (pAuthIdentity == NULL)
			return WBEM_E_OUT_OF_MEMORY;
		ZeroMemory(pAuthIdentity, sizeof(SEC_WINNT_AUTH_IDENTITY_W));

		if(bstrUserArg)
		{
			WMICLIULONG wulUserLen = (WMICLIULONG)
												 lstrlen((LPWSTR)bstrUserArg);
			pAuthIdentity->User = new WCHAR [wulUserLen + 1];
			if (pAuthIdentity->User == NULL)
				throw OUT_OF_MEMORY;
			wcscpy(pAuthIdentity->User, (LPWSTR)bstrUserArg);
			pAuthIdentity->UserLength = wulUserLen;
		}
		if(bstrAuthArg)
		{
			WMICLIULONG wulDomainLen = (WMICLIULONG)
												lstrlen((LPWSTR) bstrAuthArg);
			pAuthIdentity->Domain = new WCHAR [wulDomainLen + 1];
			if (pAuthIdentity->Domain == NULL)
				throw OUT_OF_MEMORY;
			wcscpy(pAuthIdentity->Domain, (LPWSTR)bstrAuthArg);
			pAuthIdentity->DomainLength = wulDomainLen;
		}

		if(pszPassword)
		{
			WMICLIULONG wulPasswordLen = (WMICLIULONG)
												lstrlen((LPWSTR) pszPassword);
			pAuthIdentity->Password = new WCHAR [wulPasswordLen + 1];
			if (pAuthIdentity->Password == NULL)
				throw OUT_OF_MEMORY;
			wcscpy(pAuthIdentity->Password, pszPassword);
			pAuthIdentity->PasswordLength= wulPasswordLen;
		}
		pAuthIdentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

		sc = CoSetProxyBlanket(pIUnknown, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
						NULL, uAuthLevel, uImpLevel, pAuthIdentity, EOAC_NONE);

		SAFEDELETE(pAuthIdentity->User);
		SAFEDELETE(pAuthIdentity->Domain);
		SAFEDELETE(pAuthIdentity->Password);
		delete pAuthIdentity;
		SAFEBSTRFREE(bstrUserArg);
		SAFEBSTRFREE(bstrAuthArg);
	}
	catch(WMICLIINT nErr)
	{
		if (nErr == OUT_OF_MEMORY)
			sc = WBEM_E_OUT_OF_MEMORY;
		SAFEDELETE(pAuthIdentity->User);
		SAFEDELETE(pAuthIdentity->Domain);
		SAFEDELETE(pAuthIdentity->Password);
		if (pAuthIdentity)
			delete pAuthIdentity;
		SAFEBSTRFREE(bstrUserArg);
		SAFEBSTRFREE(bstrAuthArg);
	}
    return sc;
}

/*----------------------------------------------------------------------------
   Name				 :ConvertWCToMBCS
   Synopsis	         :Converts the wide character string to MBCS string 
					  after applying the codepage settings
   Type	             :Global Function 
   Input parameters  :
			lpszMsg  - string  (widechar string)
			uCP		 - codepage value	
   Output parameters :
			lpszDisp - string  (multibyte string)
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ConvertWCToMBCS(lpszMsg, lpszDisp, uCP)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL ConvertWCToMBCS(LPTSTR lpszMsg, LPVOID* lpszDisp, UINT uCP)
{
	BOOL bRet = TRUE;

	if (lpszMsg != NULL && lpszDisp != NULL)
	{
		WMICLIINT nRet = 0;		
		nRet = WideCharToMultiByte(uCP,		// code page
						 0,					// performance and mapping flags
						 (LPCWSTR)lpszMsg,	// wide-character string
						 -1,				// number of chars in string
						 NULL,				// buffer for new string
						 0,					// size of buffer	
						 NULL,				// default for unmappable chars
						 NULL);	

		// allocate memory to hold the message
		*lpszDisp = (LPSTR) new char [nRet]; 

		if (*lpszDisp)
		{
			nRet = WideCharToMultiByte(uCP,		// code page
							 0,					// performance and mapping flags
							 (LPCWSTR)lpszMsg,	// wide-character string
							 -1,				// number of chars in string
							 (LPSTR) *lpszDisp,	// buffer for new string
							 nRet,				// size of buffer	
							 NULL,				// default for unmappable chars
							 NULL);	
		}
		else
			bRet = FALSE;
	}
	else
		*lpszDisp = NULL;
	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :Find
   Synopsis	         :Searches for a given string in the vector list
   Input parameter(s):
		cvVector	 -	vector list
		pszStrToFind -  serach string
   Output parameter(s):None
   Return Type       :BOOL
   		TRUE		 - if match is found
		FALSE		 - if no match found
   Global Variables  :None
   Calling Syntax    :Find(cvVector, pszStrToFind)
   Notes             :overloaded function
----------------------------------------------------------------------------*/
BOOL Find(CHARVECTOR& cvVector,
		  _TCHAR* pszStrToFind,
		  CHARVECTOR::iterator& theIterator)
{
	BOOL bRet = FALSE;
	theIterator = cvVector.begin();
	CHARVECTOR ::iterator theEnd = cvVector.end();
	while (theIterator != theEnd)
	{
		if (CompareTokens(*theIterator, pszStrToFind))
		{
			bRet = TRUE;
			break;
		}
		theIterator++;
	}
	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :Find
   Synopsis	         :Find a property name in the property details map
   Type	             :Global Function
   Input parameter(s):
		pdmPropDetMap   - property map
		pszPropToFind   - property to search for
		theIterator     - Iterator
		bExcludeNumbers - Boolean value
   Output parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :Find(pdmPropDetMap, pszPropToFind, tempIterator)
   Notes             :overloaded function, 
					  bExcludeNumbers = FALSE by default.
----------------------------------------------------------------------------*/
BOOL Find(PROPDETMAP& pdmPropDetMap, 
		  _TCHAR* pszPropToFind,
		  PROPDETMAP::iterator& theIterator,
		  BOOL bExcludeNumbers)
{
	BOOL bRet = FALSE;
	theIterator = pdmPropDetMap.begin();
	PROPDETMAP::iterator theEnd = pdmPropDetMap.end();
	while (theIterator != theEnd)
	{
		_TCHAR* pszPropName = (*theIterator).first;
		if ( bExcludeNumbers == TRUE )
			pszPropName = pszPropName + 5;

		if (CompareTokens(pszPropName, pszPropToFind))
		{
			bRet = TRUE;
			break;
		}
		theIterator++;
	}
	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :Find
   Synopsis	         :Find a property name in the property details map
   Type	             :Global Function
   Input parameter(s):
		bmBstrMap    - BSTR map
		pszStrToFind - property to search for
		theIterator	 - Iterator. 	
   Output parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :Find(pdmPropDetMap, pszPropToFind)
   Notes             :overloaded function
----------------------------------------------------------------------------*/
BOOL Find(BSTRMAP& bmBstrMap, 
		  _TCHAR* pszStrToFind,
		  BSTRMAP::iterator& theIterator)
{
	BOOL bRet = FALSE;
	theIterator = bmBstrMap.begin();
	BSTRMAP::iterator theEnd = bmBstrMap.end();
	while (theIterator != theEnd)
	{
		if (CompareTokens((*theIterator).first, pszStrToFind))
		{
			bRet = TRUE;
			break;
		}
		theIterator++;
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :FrameFileAndAddToXSLTDetVector
   Synopsis          :Frames the XSL File Path
   Type	             :Global Function
   Input parameter(s):
		pszXSLFile   - the XSL File
		rParsedInfo  - reference to object of CParsedInfo
   Output parameter(s): None
   Return Type       :BOOL  
   Global Variables  :None
   Calling Syntax    :FrameXSLFilePath(pszXSLFile, rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL FrameFileAndAddToXSLTDetVector(XSLTDET xdXSLTDet,
									CParsedInfo& rParsedInfo)
{
	BOOL	bRet	  = TRUE;
	_TCHAR* pszBuffer = new _TCHAR [MAX_PATH];
	UINT	nSize	  = 0;

	try
	{
		if (pszBuffer != NULL)
		{
			// Obtain the windows system directory		
			nSize = GetSystemDirectory(pszBuffer, MAX_PATH);

			if (nSize)
			{
				if (nSize > MAX_PATH)
				{
					SAFEDELETE(pszBuffer);
					pszBuffer =	new _TCHAR [nSize + 1];
				
					if(pszBuffer == NULL)
						throw OUT_OF_MEMORY;
				}
			
				if (!GetSystemDirectory(pszBuffer, nSize))
				{
					SAFEDELETE(pszBuffer);
					throw (::GetLastError());
				}
				else
				{
					_bstr_t bstrPath = _bstr_t(pszBuffer);
					SAFEDELETE(pszBuffer);
					// Append the following path
					bstrPath +=  _bstr_t(WBEM_LOCATION) + _bstr_t(xdXSLTDet.FileName);
					xdXSLTDet.FileName = bstrPath;
					rParsedInfo.GetCmdSwitchesObject().AddToXSLTDetailsVector(
													   xdXSLTDet);
				}
			}
			else
			{
				SAFEDELETE(pszBuffer);	
				throw (::GetLastError());
			}
			SAFEDELETE(pszBuffer);
		}
		else
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(OUT_OF_MEMORY);
			bRet = FALSE;
		}
	}
	catch(_com_error& e)
	{
		SAFEDELETE(pszBuffer);
		bRet = FALSE;
		_com_issue_error(e.Error());
	}
	catch (DWORD dwError)
	{
		SAFEDELETE(pszBuffer);
		::SetLastError(dwError);
		rParsedInfo.GetCmdSwitchesObject().SetErrataCode(dwError);
		DisplayWin32Error();
		::SetLastError(dwError);
		bRet = FALSE;
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :UnquoteString
   Synopsis          :Removes the starting and ending quotes of a string
					  enclosed in double quotes.
   Type	             :Global Function
   Input parameter(s):
		pszString	 - string input
   Output parameter(s): 
   		pszString	 - string input
   Return Type       :void  
   Global Variables  :None
   Calling Syntax    :UnQuoteString(pszString)
   Notes             :None
------------------------------------------------------------------------*/
void UnQuoteString(_TCHAR*& pszString)
{
	if ((lstrlen(pszString) - 1) > 0)
	{
		// Check if the string is enclosed within quotes
		if ((pszString[0] == _T('"')) 
				&& (pszString[lstrlen(pszString)-1] == _T('"')))
		{
			WMICLIINT nLoop = 1, nLen = lstrlen(pszString)-1; 
			while (nLoop < nLen)
			{
				pszString[nLoop-1] = pszString[nLoop];
				nLoop++;
			}
			pszString[nLen-1] = _T('\0');
		}
	}
}

/*------------------------------------------------------------------------
   Name				 :ParseAuthorityUserArgs
   Synopsis          :Examines the Authority and User argument and 
					  determines the authentication type and possibly 
					  extracts the domain name from the user arugment in the 
					  NTLM case.  For NTLM, the domain can be at the end of
					  the authentication string, or in the front of the 
					  user name, ex:  "MSOFT\csriram"
   Type	             :Global Function
   Input parameter(s):
		   ConnType			-  Returned with the connection type, ie wbem,
							   ntlm
		   bstrAuthArg		-  Output, contains the domain name
		   bstrUserArg		-  Output, user name
		   bstrAuthority	-  Input
		   User				-  Input
   Output parameter(s):None 
   Return Type       :
			SCODE 
   Global Variables  :None
   Calling Syntax    :ParseAuthorityUserArgs(bstrAuthArg, bstrUserArg,
							bstrAuthority, bstrUser)
   Notes             :(taken from WMI VC samples 'utillib'
------------------------------------------------------------------------*/
SCODE ParseAuthorityUserArgs(BSTR& bstrAuthArg, BSTR& bstrUserArg,
							BSTR& bstrAuthority, BSTR& bstrUser)
{

    // Determine the connection type by examining the Authority string
    if(!(bstrAuthority == NULL || lstrlen((LPCTSTR)bstrAuthority) == 0 || 
		!_wcsnicmp(bstrAuthority, L"NTLMDOMAIN:",11)))
        return E_INVALIDARG;

    // The ntlm case is more complex.  There are four cases
    // 1)  Authority = NTLMDOMAIN:name" and User = "User"
    // 2)  Authority = NULL and User = "User"
    // 3)  Authority = "NTLMDOMAIN:" User = "domain\user"
    // 4)  Authority = NULL and User = "domain\user"

    // first step is to determine if there is a backslash in the user 
	// name somewhere between the second and second to last character

    WCHAR * pSlashInUser = NULL;
    if(bstrUser)
    {
        WCHAR * pEnd = bstrUser + lstrlen((LPCTSTR)bstrUser) - 1;
        for(pSlashInUser = bstrUser; pSlashInUser <= pEnd; pSlashInUser++)
			// dont think forward slash is allowed!
            if(*pSlashInUser == L'\\')      
                break;
        if(pSlashInUser > pEnd)
            pSlashInUser = NULL;
    }

    if(bstrAuthority && lstrlen((LPCTSTR)bstrAuthority) > 11) 
    {
        if(pSlashInUser)
            return E_INVALIDARG;

        bstrAuthArg = SysAllocString(bstrAuthority + 11);
        if(bstrUser) 
			bstrUserArg = SysAllocString(bstrUser);
        return S_OK;
    }
    else if(pSlashInUser)
    {
        WMICLIINT iDomLen = pSlashInUser-bstrUser;
        WCHAR *pszTemp = new WCHAR [iDomLen+1];
		if ( pszTemp != NULL )
		{
			wcsncpy(pszTemp, bstrUser, iDomLen);
			pszTemp[iDomLen] = 0;
			bstrAuthArg = SysAllocString(pszTemp);
			if(lstrlen((LPCTSTR)pSlashInUser+1))
				bstrUserArg = SysAllocString(pSlashInUser+1);
			SAFEDELETE(pszTemp);
		}
		else
			throw OUT_OF_MEMORY;
    }
    else
        if(bstrUser)
			bstrUserArg = SysAllocString(bstrUser);

    return S_OK;
}

/*----------------------------------------------------------------------------
   Name				 :DisplayVARIANTContent
   Synopsis	         :Displays the content of a VARIANT type data object
   Type	             :Member Function
   Input Parameter(s):
		vtObject	 - VARIANT object
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :DisplayVARIANTContent(vtObject)
   Notes             :none
----------------------------------------------------------------------------*/
void DisplayVARIANTContent(VARIANT vtObject)
{
	_TCHAR szMsg[BUFFER255] = NULL_STRING;
	switch ( vtObject.vt )
	{
	case VT_UI1:
		_stprintf(szMsg, _T("%c"), vtObject.bVal);
		break;
	case VT_I2:
		_stprintf(szMsg, _T("%i"), vtObject.iVal);
		break;
	case VT_I4:
		_stprintf(szMsg, _T("%li"),	vtObject.lVal);
		break;
	case VT_R4:
		_stprintf(szMsg, _T("%f"),	vtObject.fltVal);
		break;
	case VT_R8:
		_stprintf(szMsg, _T("%e"),	vtObject.dblVal);
		break;
	case VT_BOOL:
		_stprintf(szMsg, _T("%i"),	vtObject.boolVal);
		break;
	case VT_I1:
		_stprintf(szMsg, _T("%c"),	vtObject.cVal);
		break;
	case VT_UI2:
		_stprintf(szMsg, _T("%i"),	vtObject.uiVal);
		break;
	case VT_UI4:
		_stprintf(szMsg, _T("%ld"),	vtObject.ulVal);
		break;
	case VT_INT:
		_stprintf(szMsg, _T("%i"),	vtObject.intVal);
		break;
	case VT_UINT:
		_stprintf(szMsg, _T("%i"),	vtObject.uintVal);
		break;
	}
	DisplayMessage(szMsg, CP_OEMCP, FALSE, TRUE);
}

/*----------------------------------------------------------------------------
   Name				 :GetPropertyAttributes
   Synopsis	         :This function obtains the information about the class
					  properties 
   Type	             :Member Function
   Input Parameter(s):
		pIObj	     - pointer to IWbemClassObject object
		bstrProp     - property name
		bTrace	     - trace flag
   Output parameter(s):
   		pdPropDet    - property details structure
   Return Type       :HRESULT 
   Global Variables  :None
   Calling Syntax    :GetPropertyAttributes(pIObj, bstrProp, 
											pdPropDet, bTrace)
   Notes             :none
----------------------------------------------------------------------------*/
HRESULT GetPropertyAttributes(IWbemClassObject* pIObj, 
							  BSTR bstrProp,
							  PROPERTYDETAILS& pdPropDet,
							  BOOL bTrace)
{
	HRESULT				hr			= S_OK;
	IWbemQualifierSet*	pIQualSet	= NULL;
	VARIANT				vtType, vtOper, vtDesc;
	VariantInit(&vtType);
	VariantInit(&vtOper);
	VariantInit(&vtDesc);
	try
	{
		// Obtain the property qualifier set for the property
   		hr = pIObj->GetPropertyQualifierSet(bstrProp, &pIQualSet);
		if ( pIQualSet != NULL )
		{
			// Obtain the CIM type of the property
			hr = pIQualSet->Get(_bstr_t(L"CIMTYPE"), 0L, &vtType, NULL);

			if (SUCCEEDED(hr))
			{
				if ( vtType.vt == VT_BSTR )
					pdPropDet.Type = _bstr_t(vtType.bstrVal);
				else
					pdPropDet.Type = _bstr_t("Not Found");
			}
			else
				pdPropDet.Type = _bstr_t("Not Found");
			// Should not break here, hence the HRESULT should be set to S_OK
			hr = S_OK;
			VARIANTCLEAR(vtType);

			// Check whether the property has 'read' flag set
			_bstr_t bstrOper;
			hr = pIQualSet->Get(_bstr_t(L"read"), 0L, &vtOper, NULL);
			if (SUCCEEDED(hr))
			{
				if (vtOper.vt == VT_BOOL && vtOper.boolVal)
					bstrOper = _bstr_t(L"Read");
			}
			VARIANTCLEAR(vtOper);
			// Should not break here, hence the HRESULT should be set to S_OK
			hr = S_OK;

			// Check whether the property has 'write' flag set
			VariantInit(&vtOper);
			hr = pIQualSet->Get(_bstr_t(L"write"), 0L, &vtOper, NULL);
			if (SUCCEEDED(hr))
			{
				if ((vtOper.vt == VT_BOOL) && vtOper.boolVal)
				{
					if (!bstrOper)
						bstrOper = _bstr_t(L"Write");
					else
						bstrOper += _bstr_t(L"/Write");	
				}
			}
			VARIANTCLEAR(vtOper);
			// Should not break here, hence the HRESULT should be set to S_OK
			hr = S_OK;

			if (!bstrOper)
				pdPropDet.Operation = _bstr_t(TOKEN_NA);
			else
				pdPropDet.Operation = _bstr_t(bstrOper);

			// Retrieve the 'Description' text for the property
			if (FAILED(pIQualSet->Get(_bstr_t(L"Description"), 0L, 
						&vtDesc,NULL)))
				pdPropDet.Description = _bstr_t("Not Available");
			else
				pdPropDet.Description = _bstr_t(vtDesc.bstrVal);
			VARIANTCLEAR(vtDesc);
			SAFEIRELEASE(pIQualSet);
		}
		else
			hr = S_OK;
	}
	catch(_com_error& e)
	{
		VARIANTCLEAR(vtType);
		VARIANTCLEAR(vtOper);
		VARIANTCLEAR(vtDesc);
		SAFEIRELEASE(pIQualSet);
		hr = e.Error();
	}
	return hr;
}  

/*----------------------------------------------------------------------------
   Name				 :ConvertCIMTYPEToVarType
   Synopsis	         :Does the CIMTYPE to VARIANT conversion
   Type	             :Member Function
   Input Parameter(s):
		varSrc		 - VARIANT source 
		bstrCIMType	 - CIMTYPE 
   Output parameters :
		varDest		 - VARIANT destination
   Return Type       :HRESULT 
   Global Variables  :None
   Calling Syntax    :ConvertCIMTYPEToVarType(varDest, varSrc, bstrCIMType)
   Notes             :none
----------------------------------------------------------------------------*/
HRESULT ConvertCIMTYPEToVarType( VARIANT& varDest, VARIANT& varSrc,
								_TCHAR* bstrCIMType )
{
	HRESULT hr = S_OK;
	if (CompareTokens(varSrc.bstrVal, _T("")))
	{
		hr = VariantChangeType(&varDest, &varSrc, 0, VT_NULL);
	}
	else
	{
		if (CompareTokens(bstrCIMType,_T("string")))
			hr = VariantChangeType(&varDest, &varSrc, 0, VT_BSTR);
		else if (CompareTokens(bstrCIMType,_T("Sint16")))
			hr = VariantChangeType(&varDest, &varSrc, 0, VT_I2);
		else if (CompareTokens(bstrCIMType,_T("Sint8")))
			hr = VariantChangeType(&varDest, &varSrc, 0, VT_I2);
		else if ( CompareTokens(bstrCIMType,_T("Sint32")))
			hr = VariantChangeType(&varDest, &varSrc, 0, VT_I4);
		else if ( CompareTokens(bstrCIMType,_T("Real32")))
			hr = VariantChangeType(&varDest, &varSrc, 0, VT_R4);
		else if ( CompareTokens(bstrCIMType,_T("Sint64")))
			hr = VariantChangeType(&varDest, &varSrc, 0, VT_BSTR);
		else if ( CompareTokens(bstrCIMType,_T("Uint64")))
			hr = VariantChangeType(&varDest, &varSrc, 0, VT_BSTR);
		else if ( CompareTokens(bstrCIMType,_T("Real64")))
			hr = VariantChangeType(&varDest, &varSrc, 0, VT_R8);
		else if ( CompareTokens(bstrCIMType,_T("Boolean")))
			hr = VariantChangeType(&varDest, &varSrc, 0, VT_BOOL);
		else if ( CompareTokens(bstrCIMType,_T("Object")))
			hr = VariantChangeType(&varDest, &varSrc, 0, VT_DISPATCH);
		else if ( CompareTokens(bstrCIMType,_T("Sint8")))
			hr = VariantChangeType(&varDest, &varSrc, 0, VT_INT);
		else if ( CompareTokens(bstrCIMType,_T("Uint8")))
			hr = VariantChangeType(&varDest, &varSrc, 0, VT_UI1);
		else if ( CompareTokens(bstrCIMType,_T("Uint16")))
			hr = VariantChangeType(&varDest, &varSrc, 0, VT_I4);
		else if ( CompareTokens(bstrCIMType,_T("Uint32")))
			hr = VariantChangeType(&varDest, &varSrc, 0, VT_I4);
		else if ( CompareTokens(bstrCIMType,_T("Datetime")))
			hr = VariantChangeType(&varDest, &varSrc, 0, VT_DATE);
		else if ( CompareTokens(bstrCIMType,_T("Reference")))
			hr = VariantChangeType(&varDest, &varSrc, 0, VT_BYREF);
		else if ( CompareTokens(bstrCIMType,_T("Char16")))
			hr = VariantChangeType(&varDest, &varSrc, 0, VT_I2);
		else // (CIM_OBJECT)
			hr = VariantChangeType(&varDest, &varSrc, 0, VT_NULL);
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :DisplayMessage
   Synopsis	         :Displays localized string 
   Type	             :Global Function 
   Input parameter(s):
			lszpMsg  - string  
			uCP      - codepage value
			bIsError - Boolean type specifying error message or not.
			bIsLog   - Boolean type specifying message to be logged or not .
   Output parameter(s):None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayMessage(lpszMsg, uCP, TRUE, TRUE)
   Notes             :bIsError = FALSE, bIsLog = FALSE by default.	
----------------------------------------------------------------------------*/
void DisplayMessage(LPTSTR lpszMsg, UINT uCP, BOOL bIsError, BOOL bIsLog)
{
	LPSTR	lpszDisp = NULL;
	try
	{
		// Convert the widechar to MBCS string
		if (ConvertWCToMBCS(lpszMsg, (LPVOID*) &lpszDisp, uCP))
		{
			if (bIsLog)
			{
				// Append to the output string
				g_wmiCmd.GetFormatObject().AppendtoOutputString((_TCHAR*) 
											_bstr_t(lpszDisp));
			}

			if ( bIsError == TRUE )
			{
				fprintf(stderr, "%s", lpszDisp);
				fflush(stderr);
			}
			else
			{
				OUTPUTSPEC opsOutOpt = g_wmiCmd.GetParsedInfoObject().
												GetGlblSwitchesObject().
												GetOutputOrAppendOption(TRUE);
				// OUT for getting append file pointer.
				FILE* fpOutFile = g_wmiCmd.GetParsedInfoObject().
											GetGlblSwitchesObject().
											GetOutputOrAppendFilePointer(TRUE);

				if ( opsOutOpt == CLIPBOARD )
					g_wmiCmd.AddToClipBoardBuffer(lpszDisp);
				else if ( opsOutOpt == FILEOUTPUT )
				{
					if (fpOutFile != NULL)
					{
						fprintf(fpOutFile, "%s", lpszDisp);
					}
					else
					{
						fprintf(stdout, "%s", lpszDisp);
						fflush(stdout);
					}

				}
				else
				{
					fprintf(stdout, "%s", lpszDisp);
					fflush(stdout);
				}

				// FALSE for getting append file pointer.
				FILE* fpAppendFile = g_wmiCmd.GetParsedInfoObject().
											GetGlblSwitchesObject().
											GetOutputOrAppendFilePointer(FALSE);
											
				if ( fpAppendFile != NULL )
					fprintf(fpAppendFile, "%s", lpszDisp);
			}
			SAFEDELETE(lpszDisp);

		}
	}
	catch(_com_error& e)
	{
		SAFEDELETE(lpszDisp);
		_com_issue_error(e.Error());
	}
	
}

/*----------------------------------------------------------------------------
   Name				 :CleanUpCharVector
   Synopsis	         :Clears the character vector
   Type	             :Global Function 
   Input parameter(s):
			cvCharVector - reference to character vector.
   Output parameter(s):None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :CleanUpCharVector(cvCharVector)
   Notes             :None
----------------------------------------------------------------------------*/
void CleanUpCharVector(CHARVECTOR& cvCharVector)
{
	if ( !cvCharVector.empty() )
	{
		CHARVECTOR::iterator theIterator;
		for (	theIterator = cvCharVector.begin();	
				theIterator < cvCharVector.end(); theIterator++  )
		{
			SAFEDELETE( *theIterator );
		}
		cvCharVector.clear();
	}
}

/*----------------------------------------------------------------------------
   Name				 :FindAndReplaceAll
   Synopsis	         :Search and replace all the occurences of pszFromStr 
					  with pszToStr in the given string strString
   Type	             :Global Function 
   Input parameter   :
			strString  - string buffer
			pszFromStr - string to searched and replaced
			pszToStr   - string to be replaced by
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :CleanUpCharVector(cvCharVector)
   Notes             :None
----------------------------------------------------------------------------*/
void FindAndReplaceAll(STRING& strString, _TCHAR* pszFromStr,_TCHAR* pszToStr)
{
	if ( pszFromStr != NULL && pszToStr != NULL )
	{
		STRING::size_type stPos = 0;
		STRING::size_type stFromPos = 0;
		STRING::size_type stFromStrLen = lstrlen(pszFromStr);
		STRING::size_type stToStrLen = lstrlen(pszToStr);
		while( TRUE )
		{
			stPos = strString.find(pszFromStr, stFromPos, stFromStrLen); 
			if ( stPos == STRING::npos )
				break;
			strString.replace(stPos, stFromStrLen, pszToStr);
			stFromPos = stPos + stToStrLen;
		}
	}
}

/*----------------------------------------------------------------------------
   Name				 :IsSysProp
   Synopsis	         :Returns true if the input property is a WMI system 
					  property
   Type	             :Global Function 
   Input parameter   :
			pszProp    - property name
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Notes             :IsSysProp(pszProp)
----------------------------------------------------------------------------*/
BOOL IsSysProp(_TCHAR* pszProp)
{
	BOOL bRet = FALSE;
	if (CompareTokens(pszProp, WMISYSTEM_CLASS) ||
		CompareTokens(pszProp, WMISYSTEM_DERIVATION) ||
		CompareTokens(pszProp, WMISYSTEM_DYNASTY) ||
		CompareTokens(pszProp, WMISYSTEM_GENUS) ||
		CompareTokens(pszProp, WMISYSTEM_NAMESPACE) ||
		CompareTokens(pszProp, WMISYSTEM_PATH) ||
		CompareTokens(pszProp, WMISYSTEM_PROPERTYCOUNT) ||
		CompareTokens(pszProp, WMISYSTEM_REPLATH) ||
		CompareTokens(pszProp, WMISYSTEM_SERVER) ||
		CompareTokens(pszProp, WMISYSTEM_SUPERCLASS))
	{
		bRet = TRUE;
	}
	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :EraseMessage
   Synopsis	         :Displays white spaces at the current cursor position 
					  and sets the cursor column to zero
   Type	             :Global Function 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax	 :EraseMessage(uID)
----------------------------------------------------------------------------*/
void EraseMessage(UINT uID) 
{
	COORD						coord; 
	HANDLE						hStdOut		= NULL;
	CONSOLE_SCREEN_BUFFER_INFO	csbiInfo; 
	WMICLIINT					nHeight		= 0;
	
	// Obtain the standard output handle
	hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

	// Get the screen buffer size. 
	GetConsoleScreenBufferInfo(hStdOut, &csbiInfo);
	nHeight = csbiInfo.srWindow.Bottom - csbiInfo.srWindow.Top;

	// if console size is positive (to address redirection)
	if (nHeight > 0)
	{
		coord.X = 0;
		coord.Y = csbiInfo.dwCursorPosition.Y;
		SetConsoleCursorPosition(hStdOut, coord);
		DisplayString(uID, CP_OEMCP, NULL, TRUE, TRUE);
		SetConsoleCursorPosition(hStdOut, coord);
	}
}

/*----------------------------------------------------------------------------
   Name				 :IsRedirection
   Synopsis	         :Returns true if the the output is being redirected 
   Type	             :Global Function 
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Notes             :IsRedirection()
----------------------------------------------------------------------------*/
BOOL IsRedirection()
{
	HANDLE						hStdOut		= NULL;
	CONSOLE_SCREEN_BUFFER_INFO	csbiInfo; 
	WMICLIINT					nHeight		= 0;
	BOOL						bRet		= FALSE;

	// Obtain the standard output handle
	hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

	if (hStdOut != INVALID_HANDLE_VALUE)
	{
		// Get the screen buffer size. 
		GetConsoleScreenBufferInfo(hStdOut, &csbiInfo);
		nHeight = csbiInfo.srWindow.Bottom - csbiInfo.srWindow.Top;
		if (nHeight <= 0)
			bRet = TRUE;
	}
	else
		bRet = TRUE;
	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :WMITRACEORERRORLOG
   Synopsis	         :To display the trace of COM methods invoked
   Type	             :Global Function 
   Input parameter   :
			hr		- HRESULT value
			nLine	- the line number of the file.
			pszFile	- the file name
			pszMsg  - message to be displayed.
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax	 :WMITRACEORERRORLOG(hr, nLine, pszFile, (LPCWSTR)chsMsg, 
										 eloErrLgOpt, bTrace)
   Note				 : Default values dwError = 0, pszResult = NULL. 	
----------------------------------------------------------------------------*/
void WMITRACEORERRORLOG(HRESULT hr, INT nLine, char* pszFile, _bstr_t bstrMsg, 
						DWORD dwThreadId, CParsedInfo& rParsedInfo, 
						BOOL bTrace, DWORD dwError, _TCHAR* pszResult)
{
	_TCHAR* pszMsg = bstrMsg;
	try
	{
		if ( bTrace == TRUE && pszMsg != NULL)
		{
			if (_tcsnicmp(pszMsg,_T("COMMAND:"),8) != 0)
			{
				CHString chsMessage;
				CHString chsSInfo;
				if (FAILED (hr))
					chsMessage.Format(L"FAIL: %s\n", pszMsg?pszMsg:L"NULL");
				else
					chsMessage.Format(L"SUCCESS: %s\n",pszMsg?pszMsg:L"NULL");			
					
				_fputts((_TCHAR*)_bstr_t((LPCWSTR)chsMessage), stderr);
				fflush(stderr);
				chsSInfo.Format(L"Line: %6d File: %s\n", nLine, 
												  (LPCWSTR)CHString(pszFile));
				_fputts((_TCHAR*)_bstr_t((LPCWSTR)chsSInfo), stderr);
				fflush(stderr);

				if ( pszResult != NULL )
				{
					chsMessage.Format(L"Result:  %s\n\n", pszResult);			
					_fputts((_TCHAR*)_bstr_t((LPCWSTR)chsMessage), stderr);
					fflush(stderr);
				}
				else
				{
					_fputts(_T("\n"), stderr);
					fflush(stderr);
				}
			}
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}

	if ( rParsedInfo.GetErrorLogObject().GetErrLogOption() != NO_LOGGING )
	{
		try
		{
			rParsedInfo.GetErrorLogObject().
				LogErrorOrOperation(hr, pszFile, nLine, pszMsg, 
							dwThreadId, dwError); 
		}
		catch(DWORD dwError)
		{
			::SetLastError(dwError);
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(dwError);
		}
	}
}
	
/*----------------------------------------------------------------------------
   Name				 :DisplayWin32Error
   Synopsis	         :Displays the formatted error message for the Win32
					  function calls failure
   Type	             :Global Function 
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax	 :DisplayWin32Error()
   Notes			 :None
----------------------------------------------------------------------------*/
void DisplayWin32Error()
{
	LPVOID	lpMessage	= NULL;
	DWORD	dwError		= ::GetLastError();

	try
	{
		// If there was an error, create a text message for it
		FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
			FORMAT_MESSAGE_FROM_SYSTEM |
			FORMAT_MESSAGE_IGNORE_INSERTS,
			NULL,
			dwError,
			0, 
			(LPTSTR) &lpMessage,
			0,
			NULL);

		_bstr_t bstrMsg;
		WMIFormatMessage(IDS_I_ERROR_WIN32, 1, bstrMsg, 
					(LPWSTR) lpMessage);
		
		// Display the error message
		DisplayMessage((LPWSTR)bstrMsg, CP_OEMCP, TRUE, TRUE);
		
		// Free the memory used up the error message
		// and then exit
		LocalFree(lpMessage);

		// Used for returning the error level
		::SetLastError(dwError);
	}
	catch(_com_error& e)
	{
		if ( lpMessage != NULL )
			LocalFree(lpMessage);
		_com_issue_error(e.Error());
	}
}

/*----------------------------------------------------------------------------
   Name				 :AcceptPassword
   Synopsis	         :Prompts for the password when user name alone is 
					  specified with the command
   Type	             :Global Function 
   Input parameter   :None
   Output parameters :
			pszPassword  - password string
   Return Type       :void
   Global Variables  :None
   Calling Syntax	 :AcceptPassword(pszPassword)
   Notes             :None
----------------------------------------------------------------------------*/
void AcceptPassword(_TCHAR* pszPassword)
{
	// local variables
	TCHAR	ch;
	DWORD	dwIndex				= 0;
	DWORD	dwCharsRead			= 0;
	DWORD	dwCharsWritten		= 0;
	DWORD	dwPrevConsoleMode	= 0;
	HANDLE	hStdIn				= NULL;
	_TCHAR	szBuffer[BUFFER32]	= NULL_STRING;		

	// Get the handle for the standard input
	hStdIn = GetStdHandle( STD_INPUT_HANDLE );

	// Get the current input mode of the input buffer
	GetConsoleMode( hStdIn, &dwPrevConsoleMode );
	
	// Set the mode such that the control keys are processed by the system
	SetConsoleMode( hStdIn, ENABLE_PROCESSED_INPUT );
	
	//	Read the characters until a carriage return is hit
	while( TRUE )
	{
		if ( !ReadConsole( hStdIn, &ch, 1, &dwCharsRead, NULL ))
		{
			// Set the original console settings
			SetConsoleMode( hStdIn, dwPrevConsoleMode );
			return;
		}
		
		// Check for carraige return
		if ( ch == CARRIAGE_RETURN )
		{
			// break from the loop
			break;
		}

		// Check id back space is hit
		if ( ch == BACK_SPACE )
		{
			if ( dwIndex != 0 )
			{
				//
				// Remove a asterik from the console

				// move the cursor one character back
				FORMAT_STRING( szBuffer, _T( "%c" ), BACK_SPACE );
				WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 1, 
					&dwCharsWritten, NULL );
				
				// replace the existing character with space
				FORMAT_STRING( szBuffer, _T( "%c" ), BLANK_CHAR );
				WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 1, 
					&dwCharsWritten, NULL );

				// now set the cursor at back position
				FORMAT_STRING( szBuffer, _T( "%c" ), BACK_SPACE );
				WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 1, 
					&dwCharsWritten, NULL );

				// decrement the index 
				dwIndex--;
			}
			
			// process the next character
			continue;
		}

		// if the max password length has been reached then sound a beep
		if ( dwIndex == ( MAXPASSWORDSIZE - 1 ) )
		{
			WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), BEEP_SOUND, 1, 
				&dwCharsWritten, NULL );
		}
		else
		{
			// store the input character
			*( pszPassword + dwIndex ) = ch;
			dwIndex++;

			// display asterix onto the console
			WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), ASTERIX, 1, 
				&dwCharsWritten, NULL );
		}
	}

	// Add the NULL terminator
	*( pszPassword + dwIndex ) = NULL_CHAR;

	//Set the original console settings
	SetConsoleMode( hStdIn, dwPrevConsoleMode );

	// display the character ( new line character )
	FORMAT_STRING( szBuffer, _T( "%s" ), _T( "\n\n" ) );
	WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 2, 
		&dwCharsWritten, NULL );
}

/*----------------------------------------------------------------------------
   Name				 :IsValueSet
   Synopsis	         :Checks string passed in pszFromValue, Is a value set
					  or not.	
   Type	             :Global Function 
   Input parameter   :
			pszFromValue - string to be checked.
   Output parameters :
			cValue1		 - <value1> of value set.
			cValue2		 - <value2> of value set.
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax	 :IsValueSet(pszFromValue,cValue1,cValue2)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL IsValueSet(_TCHAR* pszFromValue, _TCHAR& cValue1, _TCHAR& cValue2)
{
	BOOL bValueSet = FALSE;
	
	if ( pszFromValue != NULL )
	{
		_TCHAR cV1 = _T('\0'), cV2 = _T('\0');

		if ( lstrlen(pszFromValue) == 3 && pszFromValue[1] == _T('-') )
		{
			bValueSet = TRUE;
			cV1 = pszFromValue[0];
			cV2 = pszFromValue[2];
			cValue1 = ( cV1 < cV2 ) ? cV1 : cV2 ;
			cValue2 = ( cV1 > cV2 ) ? cV1 : cV2 ;
		}
	}
	else
		cValue1 = cValue2 = _T('\0');

	return bValueSet;
}

/*----------------------------------------------------------------------------
   Name				 :DisplayString
   Synopsis	         :Displays localized string
   Type	             :Global Function
   Input parameter(s):
			uID		  - string table identifier
			uCP		  - codepage value
			lpszParam - String to be used as parameter in resource string.
			bIsError  - Boolean type specifying error message or not.
			bIsLog    - Boolean type specifying message to be logged or not.
   Output parameter(s):None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayString(uID, CP_OEMCP, NULL, TRUE, TRUE)
   Notes             :lpszParam = NULL, bIsError = FALSE, and bIsLog = FALSE
					  by default.	
----------------------------------------------------------------------------*/
void DisplayString(UINT uID, UINT uCP, LPTSTR lpszParam,
				   BOOL bIsError, BOOL bIsLog) throw(WMICLIINT)
{
	LPTSTR	lpszMsg		= NULL;
	LPSTR	lpszDisp	= NULL;
	lpszMsg = new _TCHAR [BUFFER1024];
	try
	{
		if (lpszMsg)
		{
			LoadString(NULL, uID, lpszMsg, BUFFER1024);
			LPVOID lpMsgBuf = NULL;
			if (lpszParam)
			{
				char* pvaInsertStrs[1];
				pvaInsertStrs[0] = (char*)	lpszParam;

				DWORD dwRet = FormatMessage(
						FORMAT_MESSAGE_ALLOCATE_BUFFER | 
						FORMAT_MESSAGE_FROM_STRING | 
						FORMAT_MESSAGE_ARGUMENT_ARRAY,
						lpszMsg,
						0, 
						MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
						(LPTSTR) &lpMsgBuf,
						0,
						pvaInsertStrs);

				if (dwRet == 0)
				{
					SAFEDELETE(lpszMsg);
					throw (::GetLastError());
				}
			}

			if ( lpMsgBuf != NULL )
			{
				if (!ConvertWCToMBCS((LPTSTR)lpMsgBuf, (LPVOID*) &lpszDisp, 
																		 uCP))
				{
					LocalFree(lpMsgBuf);
					throw OUT_OF_MEMORY;
				}
			}
			else
			{
				if (!ConvertWCToMBCS(lpszMsg, (LPVOID*) &lpszDisp, uCP))
				{
					SAFEDELETE(lpszMsg);
					throw OUT_OF_MEMORY;
				}
			}
			
			if (bIsLog)
			{
				// Append to the output string
				g_wmiCmd.GetFormatObject().AppendtoOutputString((_TCHAR*) 
											_bstr_t(lpszDisp));
			}

			if ( bIsError == TRUE )
			{
				fprintf(stderr, "%s", lpszDisp);
				fflush(stderr);
			}
			else
			{
				OUTPUTSPEC opsOutOpt = g_wmiCmd.GetParsedInfoObject().
												GetGlblSwitchesObject().
												GetOutputOrAppendOption(TRUE);
				// OUT for getting append file pointer.
				FILE* fpOutFile = g_wmiCmd.GetParsedInfoObject().
											GetGlblSwitchesObject().
											GetOutputOrAppendFilePointer(TRUE);

				if (opsOutOpt == CLIPBOARD )
					g_wmiCmd.AddToClipBoardBuffer(lpszDisp);
				else if (opsOutOpt == FILEOUTPUT )
				{
					if (fpOutFile != NULL)
					{
						fprintf(fpOutFile, "%s", lpszDisp);
					}
					else
					{
						fprintf(stdout, "%s", lpszDisp);
						fflush(stdout);
					}
				}
				else
				{
					fprintf(stdout,"%s", lpszDisp);
					fflush(stdout);
				}

				// FALSE for getting append file pointer.
				FILE* fpAppendFile = g_wmiCmd.GetParsedInfoObject().
											GetGlblSwitchesObject().
											GetOutputOrAppendFilePointer(FALSE);
									
				if ( fpAppendFile != NULL )
					fprintf(fpAppendFile, "%s", lpszDisp);
			}
			SAFEDELETE(lpszDisp);
			SAFEDELETE(lpszMsg);
			// Free the memory used up the error message
			// and then exit
			if ( lpMsgBuf != NULL )
				LocalFree(lpMsgBuf);

		}
		else
			throw OUT_OF_MEMORY;
	}
	catch(_com_error& e)
	{
		SAFEDELETE(lpszDisp);
		SAFEDELETE(lpszMsg);
		_com_issue_error(e.Error());
	}
	catch(CHeap_Exception)
	{
		SAFEDELETE(lpszDisp);
		SAFEDELETE(lpszMsg);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	
}

/*----------------------------------------------------------------------------
   Name				 :SubstituteEscapeChars
   Synopsis	         :Substitue escape character i.e '\' before the 
					  specified substring
   Type	             :Global Function
   Input parameter   :
			sSource	- source string
			lpszSub	- substring to be searched for
   Output parameters :
			sSource	- source string
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SubstituteEscapeChars(sTemp, lpszSub)
   Notes             :None
----------------------------------------------------------------------------*/
void SubstituteEscapeChars(CHString& sTemp, LPCWSTR lpszSub)
{
	try
	{
		CHString str(sTemp);
		sTemp.Empty();
		while ( str.GetLength() > 0 )
		{
			//LONG lPos = str.Find( L"\"" );
			LONG lPos = str.Find(lpszSub);
			if ( lPos != -1 )
			{
				sTemp += str.Left( lPos ) + L"\\\"";
				str = str.Mid( lPos + 1 );
			}
			else 
			{
				sTemp += str;
				str.Empty();
			}
		}
	}
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}

/*----------------------------------------------------------------------------
   Name				 :RemoveEscapeChars
   Synopsis	         :Remove escape character i.e '\' before any of the 
					  following characters 
					  	
   Type	             :Global Function
   Input parameter(s):
			sSource	- source string
   Output parameter(s):
			sSource	- source string
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :RemoveEscapeChars(sTemp)
   Notes             :None
----------------------------------------------------------------------------*/
void RemoveEscapeChars(CHString& sTemp)
{
	try
	{
		CHString str(sTemp);
		sTemp.Empty();
		while ( str.GetLength() > 0 )
		{
			LONG lPos = str.Find(L"\\");
			if ( lPos != -1 )
			{
				if (str.GetAt(lPos+1) == L'"') 
				{
					sTemp += str.Left( lPos );				
				}
				else
				{
					sTemp += str.Left( lPos ) + L"\\";
				}
				str = str.Mid( lPos + 1 );
			}
			else 
			{
				sTemp += str;
				str.Empty();
			}
		}
	}
	catch(CHeap_Exception)
	{
		throw OUT_OF_MEMORY;
	}
}

/*----------------------------------------------------------------------------
   Name				 :FrameNamespace
   Synopsis	         :Frame the new namespace 
   Type	             :Global Function
   Input parameter(s):
		pszRoleOrNS			- old namespace
		pszRoleOrNSToUpdate	- string to be appended/replaced
   Output parameter(s):
		pszRoleOrNSToUpdate	- new namespace
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :FrameNamespace(pszRoleOrNS, pszRoleOrNSToUpdate)
   Notes             :None
----------------------------------------------------------------------------*/
void FrameNamespace(_TCHAR* pszRoleOrNS, _TCHAR* pszRoleOrNSToUpdate)
{
	if ( pszRoleOrNS != NULL && pszRoleOrNSToUpdate != NULL )
	{
		LONG lRoleOrNSLen = lstrlen(pszRoleOrNS);
		LONG lRoleOrNSToUpdate = lstrlen(pszRoleOrNSToUpdate);

		_TCHAR *pszTemp = new _TCHAR[lRoleOrNSLen + lRoleOrNSToUpdate +
									 MAX_BUFFER]; 
		if ( pszTemp != NULL )
		{
			if (!CompareTokens(pszRoleOrNS, CLI_TOKEN_NULL))
			{
				//if the role does not begin with a '\\' it should be assumed
				//to be relative to the current role

				if ( _tcsncmp(pszRoleOrNS, CLI_TOKEN_2BSLASH, 2) == 0 )
					lstrcpy(pszTemp, pszRoleOrNS+2);
				else if (_tcsncmp(pszRoleOrNS, CLI_TOKEN_2DOT, 2) == 0 )
				{
					_TCHAR *lp = NULL;
					for (lp = &pszRoleOrNSToUpdate[lstrlen(pszRoleOrNSToUpdate) - 1]; 
						lp > pszRoleOrNSToUpdate; lp--)
					{
						if (_tcsncmp(lp,CLI_TOKEN_2BSLASH,1) == 0)
						{	lstrcpy(lp,NULL_STRING);
							break;
						}
					}
					lstrcpy(pszTemp, pszRoleOrNSToUpdate);
					if (_tcsncmp(pszRoleOrNS + 2, NULL_STRING, 1))
					{
						lstrcat(pszTemp, pszRoleOrNS + 2);
					}
				}
				else
				{			
					lstrcpy(pszTemp, pszRoleOrNSToUpdate);
					lstrcat(pszTemp, CLI_TOKEN_BSLASH);
					lstrcat(pszTemp, pszRoleOrNS);
				}
				//if the last character in the string pszRoleOrNS terminates 
				//with '\' terminate the string.
				//this case occurs when namespace is specified as "xyz\"
				if(CompareTokens(pszTemp + (WMICLIINT)lstrlen(pszTemp)-1, 
					CLI_TOKEN_BSLASH ) && 
						!CompareTokens(pszTemp, CLI_TOKEN_2BSLASH))
				{
					pszTemp[lstrlen(pszTemp) - 1] = _T('\0');
				}
			}
			else
				lstrcpy(pszTemp, CLI_TOKEN_NULL);

			lstrcpy(pszRoleOrNSToUpdate, pszTemp);
			SAFEDELETE(pszTemp);
		}
		else
			throw OUT_OF_MEMORY;
	}
	else
		throw OUT_OF_MEMORY;
}

/*----------------------------------------------------------------------------
   Name				 :SetScreenBuffer
   Synopsis	         :Set the buffer size of the command line to the 
					  following:
					  1) Width	- 500
					  2) Height - 3000	
   Type	             :Global Function
   Input parameter(s):
			nHeight	 - height of the console buffer
			nWidth	 - width of the console buffer
   Output parameter(s):None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetScreenBuffer(nHeight, nWidth)
   Notes             :None
----------------------------------------------------------------------------*/
void SetScreenBuffer(SHORT nHeight, SHORT nWidth)
{
	HANDLE	hStdOut = NULL;
	COORD	coord;
	coord.X = nWidth;
	coord.Y = nHeight;
    hStdOut = GetStdHandle(STD_OUTPUT_HANDLE); 
	if ( hStdOut != INVALID_HANDLE_VALUE &&
		 hStdOut != (HANDLE)0x00000013 ) // For telnet
	{
		// Set the console screen buffer info
		SetConsoleScreenBufferSize(hStdOut, coord);
	}
}

/*----------------------------------------------------------------------------
   Name				 :GetScreenBuffer
   Synopsis	         :Get the buffer size of the command line
   Type	             :Global Function
   Input parameter(s):None
   Output parameter(s):
			nHeight	 - height of the console buffer
			nWidth	 - width of the console buffer
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :GetScreenBuffer(nHeight, nWidth)
   Notes             :None
----------------------------------------------------------------------------*/
void GetScreenBuffer(SHORT& nHeight, SHORT& nWidth)
{
	HANDLE	hStdOut = NULL;
    hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
	if ( hStdOut != INVALID_HANDLE_VALUE &&
		 hStdOut != (HANDLE)0x00000013 ) // For telnet
	{
		CONSOLE_SCREEN_BUFFER_INFO csbConsoleScreenBufferInfo;
		// Set the console screen buffer info
		GetConsoleScreenBufferInfo(hStdOut, &csbConsoleScreenBufferInfo);
		nHeight = csbConsoleScreenBufferInfo.dwSize.Y;
		nWidth = csbConsoleScreenBufferInfo.dwSize.X;
	}
}

/*----------------------------------------------------------------------------
   Name				 :WMIFormatMessage
   Synopsis	         :This function loads the resource string using the 
					  ID of the string and does parameter substituion using
					  the FormatMessage() function.	
   Type	             :Global Function
   Input parameter(s):
			uID			- resource ID
			nParamCount - no. of. parameter(s) to be substituted.
			lpszParam	- first parameter. (%1)
			...			- variable number of arguments (%2, %3, ...)
   Output parameter(s):
			bstrMSG		- formatted message
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :WMIFormatMessage(uID, nParamCount, bstrMsg, 
							lpszParam,)
   Notes             :None
----------------------------------------------------------------------------*/
void WMIFormatMessage(UINT uID, WMICLIINT nParamCount, _bstr_t& bstrMsg, 
					  LPTSTR lpszParam, ...)
{
	// Load the resource string 
	_TCHAR	pszMsg[BUFFER1024];
	LoadString(NULL, uID, pszMsg, BUFFER1024);

	// If parameters are specified.
	if (lpszParam)
	{
		LPTSTR lpszTemp				= lpszParam;
		INT		nLoop				= 0;
		char*	pvaInsertStrs[5];

		va_list marker;
		va_start(marker, lpszParam);
	
		while (TRUE)
		{
			pvaInsertStrs[nLoop++] = (char*) lpszTemp;
			lpszTemp = va_arg(marker, LPTSTR);

			if (nLoop == nParamCount)
				break;
		}
		va_end(marker);
			
		LPVOID lpMsgBuf = NULL;
		FormatMessage(
				FORMAT_MESSAGE_ALLOCATE_BUFFER | 
				FORMAT_MESSAGE_FROM_STRING | 
				FORMAT_MESSAGE_ARGUMENT_ARRAY,
				pszMsg,
				0, 
				MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
				(LPTSTR) &lpMsgBuf,
				0,
				pvaInsertStrs);
		bstrMsg = (WCHAR*)lpMsgBuf;

		// Free the memory used for the message and then exit
		LocalFree(lpMsgBuf);
	}
	else
		bstrMsg = pszMsg;
}

/*----------------------------------------------------------------------------
   Name				 :InitWinsock
   Synopsis	         :This function initiates the windows sockets interface.
   Type	             :Global Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :InitWinsock ()
   Notes             :None
----------------------------------------------------------------------------*/
BOOL InitWinsock ()
{
	BOOL	bSuccess	= TRUE;
	int nRes;
	WSADATA wsaData;
	WORD wVerRequested = 0x0101; // ver 1.1

	//	The Windows Sockets WSAStartup function initiates use of Ws2_32.dll 
	//  by a process.
	// Init the sockets interface
	nRes = WSAStartup (wVerRequested, &wsaData);
	if (nRes)
		bSuccess = FALSE;

	return bSuccess;
}

/*----------------------------------------------------------------------------
   Name				 :TermWinsock
   Synopsis	         :This function uninitializes the windows sockets 
					  interface.
   Type	             :Global Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :TermWinsock ()
   Notes             :None
----------------------------------------------------------------------------*/
BOOL TermWinsock ()
{
	// Uninitailize windows socket interface.
	BOOL	bSuccess = TRUE;
	if (SOCKET_ERROR == WSACleanup ())
		bSuccess = FALSE;

	return bSuccess;
}

/*----------------------------------------------------------------------------
   Name				 :PingNode
   Synopsis	         :Pings a node to validate availibility of node using
					  windows socket functions.	 
   Type	             :Global Function
   Input parameter   :
			pszNode  - Pointer to a string specifing node name.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :PingNode(pszNode)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL PingNode(_TCHAR* pszNode)
{
	BOOL	bRet				= TRUE;
	try
	{
		if ( pszNode )
		{
			// pszNode can be IPAddress of node or node name itself. 
			_bstr_t	bstrNodeNameOrIPAddr(pszNode);

			// Initialize windows socket interface.
			if ( g_wmiCmd.GetInitWinSock() == FALSE )
			{
				bRet = InitWinsock();
				g_wmiCmd.SetInitWinSock(bRet);
			}

			if ( bRet )
			{
				// Get IPAddress. 
				ULONG	ulINAddr = inet_addr(bstrNodeNameOrIPAddr);
				// If not an IP address. then it may be computername.
				if ( ulINAddr == INADDR_NONE )
				{
					if ( gethostbyname(bstrNodeNameOrIPAddr) == NULL )
						bRet = FALSE; // "computername" is not found.
				}
				else // It is an valid IP Address.
				{
					if ( gethostbyaddr((char*) &ulINAddr, sizeof(ulINAddr), AF_INET) == NULL )
						bRet = FALSE;
				}

			}
		}
		else
			bRet = FALSE; // Null nodename pointer.
	}
	catch(_com_error& e)
	{
		bRet = FALSE;
		_com_issue_error(e.Error());
	}

	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :IsFailFastAndNodeExist
   Synopsis	         :Validates node if FailFast is on, If pszNodeName == NULL
					  then check for GetNode() else pszNodeName itself. 
   Type	             :Global Function
   Input parameter(s):
		rParsedInfo  - reference to object of CParsedInfo.
		pszNode		 - Pointer to a string specifing node name.
   Output parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :IsFailFastAndNodeExist(rParsedInfo, pszNode)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL IsFailFastAndNodeExist(CParsedInfo& rParsedInfo, _TCHAR* pszNode)
{
	BOOL	bRet	= TRUE;
	
	// If FailFast is on.
	if ( rParsedInfo.GetGlblSwitchesObject().GetFailFast() == TRUE )
	{
		// Form the appropriate node name. If pszNodeName != NULL pszNode 
		// should be validated. Else Node stored should be validated.
		_TCHAR*		pszNodeName = NULL;
		if (pszNode == NULL)
			pszNodeName = rParsedInfo.GetGlblSwitchesObject().GetNode();
		else
			pszNodeName = pszNode;

		// "." node name specifies local machine and need not to be validated.
		if ( CompareTokens(pszNodeName, CLI_TOKEN_DOT) == FALSE )
		{
			// If pinging node fails then node is unavialable. 
			if ( PingNode(pszNodeName) == FALSE )
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
										IDS_E_RPC_SERVER_NOT_AVAILABLE);
				bRet = FALSE;
			}
		}
	}

	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :GetBstrTFromVariant
   Synopsis	         :Get _bstr_t object equivalent to Varaint passed.
   Type	             :Global Function
   Input parameter(s):
			vtVar	 - variant object
			pszType	 - Pointer to string specifying type of the object passed.
   Output parameter(s):
			bstrObj	- BSTR object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetBstrTFromVariant(vtVar, bstrObj)
   Notes             :None
----------------------------------------------------------------------------*/
void GetBstrTFromVariant(VARIANT& vtVar, _bstr_t& bstrObj,
						 _TCHAR* pszType)
{
	VARTYPE	vType;
	VARIANT vtDest;
	VariantInit(&vtDest);

	try
	{
		if ( vtVar.vt != VT_NULL && vtVar.vt != VT_EMPTY )
		{
			if ( VariantChangeType(&vtDest, &vtVar,0 , VT_BSTR) == S_OK )
            {
                bstrObj = _bstr_t(vtDest);
            }
            else
            {
                // The following line assures that
                // if an exception is thrown (say
                // in the bstr_t allocation below)
                // VariantClear in the catch statement
                // won't try to clear anything.
                V_VT(&vtDest) = VT_EMPTY;

			    if ( vtVar.vt == VT_UNKNOWN )
			    {
				    if ( pszType != NULL )
                    {
					    bstrObj = _bstr_t(pszType);
                    }
				    else
                    {
					    bstrObj = _bstr_t("<Embeded Object>");
                    }
			    }
			    else if ( SafeArrayGetVartype(vtVar.parray, &vType) == S_OK )
			    {
				    if ( pszType != NULL )
                    {
					    bstrObj = _bstr_t("<Array of ") + _bstr_t(pszType) + 
							      _bstr_t(">");
                    }
				    else
                    {
					    bstrObj = _bstr_t("<Array>");
                    }
			    }
			    else
                {
				    bstrObj = _bstr_t("UNKNOWN");
                }
            }
		}
		else
        {
			bstrObj = _bstr_t(_T("<null>"));
        }

		VARIANTCLEAR(vtDest);
	}
	catch(_com_error& e)
	{
		VARIANTCLEAR(vtDest);
		_com_issue_error(e.Error());
	}
}
/*----------------------------------------------------------------------------
   Name				 :IsValidFile
   Synopsis	         :This functions checks if a given file name is
					  Valid.
   Type	             :Global Function
   Input parameter(s):
		pszFileName  - String type, Name of the file to be validated
   Output parameter(s):None
   Return Type       :RETCODE
   Global Variables  :None
   Calling Syntax    :IsValidFile(pszFileName)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE IsValidFile(_TCHAR* pszFileName)
{
	RETCODE bRet = PARSER_ERROR;
	BOOL	bValidFileName	= TRUE;

	LONG lFileNameLen	= lstrlen(pszFileName);
	LONG lCount			= lFileNameLen;
	while( lCount >= 0 )
	{
		if (pszFileName[lCount] == _T('\\'))
			break;

		lCount--;
	}

	if(lCount != 0)
		lCount++;

	while( lCount <= lFileNameLen )
	{
		if( pszFileName[lCount] == _T('/') ||
			pszFileName[lCount] == _T('\\') ||
			pszFileName[lCount] == _T(':') ||
			pszFileName[lCount] == _T('*') ||
			pszFileName[lCount] == _T('?') ||
			pszFileName[lCount] == _T('\"') ||
			pszFileName[lCount] == _T('<') ||
			pszFileName[lCount] == _T('>') ||
			pszFileName[lCount] == _T('|') )
		{
			bValidFileName = FALSE;
			break;
		}

		lCount++;
	}

	if ( pszFileName != NULL && bValidFileName == TRUE)
	{
		FILE *fpFile = _tfopen(pszFileName, _T("a"));

		if ( fpFile != NULL )
		{
			LONG lFileHandle = _fileno(fpFile);
			if ( _filelength(lFileHandle) == 0)
			{
				if ( fclose(fpFile) == 0 )
				{
					if ( _tremove(pszFileName) == 0 )
						bRet = PARSER_CONTINUE;
					else
					{
						DisplayWin32Error();
						bRet = PARSER_ERRMSG;
					}
				}
			}
			else if ( fclose(fpFile) == 0 )
					bRet = PARSER_CONTINUE;
		}

	}

	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :FindAndReplaceEntityReferences
   Synopsis	         :Search and replace all the occurences of entity 
					  references.
   Type	             :Global Function 
   Input parameter(s):
			strString  - string buffer
   Output parameter(s):None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :FindAndReplaceEntityReferences(strString);
   Notes             :None
----------------------------------------------------------------------------*/
void FindAndReplaceEntityReferences(_bstr_t& bstrString)
{
	STRING strString((_TCHAR*)bstrString);

	FindAndReplaceAll(strString, _T("&"), _T("&amp;"));
	FindAndReplaceAll(strString, _T("<"), _T("&lt;"));
	FindAndReplaceAll(strString, _T(">"), _T("&gt;"));
	FindAndReplaceAll(strString, _T("\'"), _T("&apos;"));
	FindAndReplaceAll(strString, _T("\""), _T("&quot;"));
	try
	{
		bstrString = _bstr_t((LPTSTR)strString.data());
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*----------------------------------------------------------------------------
   Name				 :IsOption
   Synopsis	         :It checks whether the current token indicates option. An
					  option can start with '/' or '-'
   Type	             :Global Function
   Input Parameter(s):
		pszToken	 - pointer to token.
   Output Parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :IsOption(pszToken)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL IsOption(_TCHAR* pszToken)
{
	BOOL bRet = TRUE;
	if ( pszToken != NULL )
	{
		bRet = (CompareTokens(pszToken, CLI_TOKEN_FSLASH) 
				|| CompareTokens(pszToken, CLI_TOKEN_HYPHEN))
				? TRUE : FALSE;
	}
	else
		bRet = FALSE;
	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :IsClassOperation
   Synopsis	         :It checks whether the current operation is class 
						level operation or instance level operation
   Type	             :Global Function
   Input Parameter(s):
	    rParsedInfo		 - reference to CParsedInfo class object
   Output Parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :IsClassOperation(rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL IsClassOperation(CParsedInfo& rParsedInfo)
{
	BOOL bClass = FALSE;
	if ( rParsedInfo.GetCmdSwitchesObject().GetAliasName() == NULL 
		&& (rParsedInfo.GetCmdSwitchesObject().
									GetWhereExpression() == NULL)
		&& (rParsedInfo.GetCmdSwitchesObject().
									GetPathExpression() == NULL))
	{
		bClass = TRUE;
	}

	return bClass;
}

/*-------------------------------------------------------------------------
   Name				 :ModifyPrivileges
   Synopsis	         :This function enables/disables all the token privileges
					  for current process token.
   Type	             :Global Function
   Input Parameter(s):
			bEnable	 -  Enable|Disable privileges flag
   Output Parameter(s):None
   Return Type       :HRESULT 
   Global Variables  :None
   Calling Syntax    :ModifyPrivileges(bEnable)
   Notes             :none
-------------------------------------------------------------------------*/
HRESULT ModifyPrivileges(BOOL bEnable)
{
	HANDLE		hToken		= NULL;
	DWORD		dwError		= ERROR_SUCCESS, 
				dwLen		= 0;	
	BOOL		bRes		= TRUE;
	TOKEN_USER	tu;
	HRESULT		hr			= WBEM_S_NO_ERROR;
	BYTE		*pBuffer	= NULL;

	// Open the access token associated with the current process. 
    bRes = OpenProcessToken(GetCurrentProcess(), 
							TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, 
							&hToken);

	if (bRes) 
	{
		// If disable privilges
		if (!bEnable)
		{
			// Store the information back into the token,after disabling all 
			// the privileges
			bRes = AdjustTokenPrivileges(hToken, TRUE, NULL, 0, NULL, NULL);
			if (!bRes)
				hr = WBEM_E_ACCESS_DENIED;
		}
		else // If enable privileges
		{
			// Get the privileges
			memset(&tu,0,sizeof(TOKEN_USER));
			bRes = GetTokenInformation(hToken, TokenPrivileges, &tu, 
					sizeof(TOKEN_USER), &dwLen); 
			pBuffer = new BYTE[dwLen];
			if(pBuffer != NULL)
			{
				bRes = GetTokenInformation(hToken, TokenPrivileges, 
									pBuffer, dwLen, &dwLen);
				if (bRes)
				{
					// Iterate through all the privileges and enable them all
					TOKEN_PRIVILEGES* pPrivs = (TOKEN_PRIVILEGES*)pBuffer;
					for (DWORD i = 0; i < pPrivs->PrivilegeCount; i++)
					{
						pPrivs->Privileges[i].Attributes 
											|= SE_PRIVILEGE_ENABLED;
					}
					// Store the information back into the token
					bRes = AdjustTokenPrivileges(hToken, FALSE, pPrivs, 0, 
													NULL, NULL);
					if (!bRes)
						hr = WBEM_E_ACCESS_DENIED;				
				}
				else
					hr = WBEM_E_ACCESS_DENIED;
				SAFEDELETE(pBuffer);
			}
			else
				hr = WBEM_E_OUT_OF_MEMORY;
		}
		CloseHandle(hToken); 
	}
	else
		hr = WBEM_E_ACCESS_DENIED;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\helpinfo.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: HelpInfo.cpp 
Project Name				: WMI Command Line
Author Name					: C. V. Nandi
Date of Creation (dd/mm/yy) : 29th-September-2000
Version Number				: 1.0 
Brief Description			: The CHelpInfo class encapsulates the 
							  functionality needed for storing and retrieving 
							  help Flag for displaying help..
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy	
		Last Modified Date	: 16th-January-2001
****************************************************************************/ 
// HelpInfo.cpp : implementation file
//
#include "Precomp.h"
#include "HelpInfo.h"

/*------------------------------------------------------------------------
   Name				 :CHelpInfo
   Synopsis	         :This function initializes the member variables when
                      an object of the class type is instantiated
   Type	             :Constructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CHelpInfo::CHelpInfo()
{
	Initialize();
}

/*------------------------------------------------------------------------
   Name				 :~CHelpInfo
   Synopsis	         :This function uninitializes the member variables 
					  when an object of the class type goes out of scope.
   Type	             :Destructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CHelpInfo::~CHelpInfo()
{
}

/*------------------------------------------------------------------------
   Name				 :Initialize
   Synopsis	         :This function initializes the member variables 
   Type	             :Member function 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :Initialize()
   Notes             :None
------------------------------------------------------------------------*/
void CHelpInfo::Initialize()
{
	m_bNameSpaceHelp		= FALSE;
	m_bRoleHelp				= FALSE;
	m_bNodeHelp				= FALSE;
	m_bUserHelp				= FALSE;
	m_bPasswordHelp			= FALSE;
	m_bLocaleHelp			= FALSE;
	m_bRecordPathHelp		= FALSE;
	m_bPrivilegesHelp		= FALSE;
	m_bLevelHelp			= FALSE;
	m_bAuthLevelHelp		= FALSE;
	m_bInteractiveHelp		= FALSE;
	m_bTraceHelp			= FALSE;
	m_bGlblAllInfoHelp		= FALSE;
	m_bCmdAllInfoHelp		= FALSE;
	m_bGetVerbHelp			= FALSE;
	m_bSetVerbHelp			= FALSE;
	m_bListVerbHelp			= FALSE;
	m_bCallVerbHelp			= FALSE;
	m_bDumpVerbHelp			= FALSE;
	m_bAssocVerbHelp		= FALSE;
	m_bCreateVerbHelp		= FALSE;
	m_bDeleteVerbHelp		= FALSE;
	m_bAliasVerbHelp		= FALSE;
	m_bPATHHelp				= FALSE;
	m_bWHEREHelp			= FALSE;
	m_bCLASSHelp			= FALSE;
	m_bEXITHelp				= FALSE;
	m_bPWhereHelp			= FALSE;
	m_bTRANSLATEHelp		= FALSE;
	m_bEVERYHelp			= FALSE;
	m_bFORMATHelp			= FALSE;
	m_bVERBSWITCHESHelp		= FALSE;
	m_bDESCRIPTIONHelp		= FALSE;
	m_bGETSwitchesOnlyHelp	= FALSE;
	m_bLISTSwitchesOnlyHelp	= FALSE;
	m_bContextHelp			= FALSE;
	m_bGlblSwitchValuesHelp = FALSE;
	m_bRESULTCLASSHelp		= FALSE;
	m_bRESULTROLE			= FALSE;
	m_bASSOCCLASS			= FALSE;
	m_bASSOCSwitchesOnlyHelp = FALSE;
	m_bFAILFASTHelp			= FALSE;
	m_bREPEATHelp			= FALSE;
	m_bOUTPUTHelp			= FALSE;
	m_bAPPENDHelp			= FALSE;
	m_bAggregateHelp		= FALSE;
}

/*------------------------------------------------------------------------
   Name				 :SetHelp
   Synopsis	         :This function sets a HelpFlag member variable
					  specified by input arguments.
   Type	             :Member function 
   Input parameter   :
		htHelp		 :Help type
		bFlag		 :Flag value
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetHelp(htHelp, bFlag )
   Notes             :None
------------------------------------------------------------------------*/
void CHelpInfo::SetHelp( HELPTYPE htHelp, BOOL bFlag )
{
	switch ( htHelp )
	{
	case Namespace:
		m_bNameSpaceHelp		= bFlag;
		break;
	case Role:
		m_bRoleHelp				= bFlag;
		break;
	case Node:
		m_bNodeHelp				= bFlag;
		break;
	case User:
		m_bUserHelp				= bFlag;
		break;
	case Aggregate:
		m_bAggregateHelp		= bFlag;
		break;
	case Password:
		m_bPasswordHelp			= bFlag;
		break;
	case Locale:
		m_bLocaleHelp			= bFlag;
		break;
	case RecordPath:
		m_bRecordPathHelp		= bFlag;
		break;
	case Privileges:
		m_bPrivilegesHelp		= bFlag;
		break;
	case Level:
		m_bLevelHelp			= bFlag;
		break;
	case AuthLevel:
		m_bAuthLevelHelp		= bFlag;
		break;
	case Interactive:
		m_bInteractiveHelp		= bFlag;
		break;
	case Trace:
		m_bTraceHelp			= bFlag;
		break;
	case GlblAllInfo:
		m_bGlblAllInfoHelp		= bFlag;
		break;
	case CmdAllInfo:
		m_bCmdAllInfoHelp		= bFlag;
		break;
	case GETVerb:
		m_bGetVerbHelp			= bFlag;
		break;
	case SETVerb:
		m_bSetVerbHelp			= bFlag;
		break;
	case LISTVerb:
		m_bListVerbHelp			= bFlag;
		break;
	case CALLVerb:
		m_bCallVerbHelp			= bFlag;
		break;
	case DUMPVerb:
		m_bDumpVerbHelp			= bFlag;
		break;
	case ASSOCVerb:
		m_bAssocVerbHelp		= bFlag;
		break;
	case DELETEVerb:
		m_bDeleteVerbHelp		= bFlag;
		break;
	case CREATEVerb:
		m_bCreateVerbHelp		= bFlag;
		break;
	case AliasVerb:
		m_bAliasVerbHelp		= bFlag;
		break;
	case PATH:
		m_bPATHHelp				= bFlag;
		break;
	case WHERE:
		m_bWHEREHelp			= bFlag;
		break;
	case CLASS:
		m_bCLASSHelp			= bFlag;
		break;
	case EXIT:
		m_bEXITHelp				= bFlag;
		break;
	case PWhere:
		m_bPWhereHelp			= bFlag;
		break;
	case TRANSLATE:
		m_bTRANSLATEHelp		= bFlag;
		break;
	case EVERY:
		m_bEVERYHelp			= bFlag;
		break;
	case FORMAT:
		m_bFORMATHelp			= bFlag;
		break;
	case VERBSWITCHES:
		m_bVERBSWITCHESHelp		= bFlag;
		break;
	case DESCRIPTION:
		m_bDESCRIPTIONHelp		= bFlag;
		break;
	case GETSwitchesOnly:
		m_bGETSwitchesOnlyHelp	= bFlag;
		break;
	case LISTSwitchesOnly:
		m_bLISTSwitchesOnlyHelp	= bFlag;
		break;
	case CONTEXTHELP:
		m_bContextHelp			= bFlag;
		break;
	case GLBLCONTEXT:
		m_bGlblSwitchValuesHelp = bFlag;
		break;
	case RESULTCLASShelp:
		m_bRESULTCLASSHelp = bFlag;
		break;
	case RESULTROLEhelp:
		m_bRESULTROLE = bFlag;
		break;
	case ASSOCCLASShelp:
		m_bASSOCCLASS = bFlag;
		break;
	case ASSOCSwitchesOnly:
		m_bASSOCSwitchesOnlyHelp = bFlag;
		break;
	case FAILFAST:
		m_bFAILFASTHelp = bFlag;
		break;
	case REPEAT:
		m_bREPEATHelp = bFlag;
		break;
	case OUTPUT:
		m_bOUTPUTHelp = bFlag;
		break;
	case APPEND:
		m_bAPPENDHelp = bFlag;
		break;
	}
}

/*------------------------------------------------------------------------
   Name				 :GetHelp
   Synopsis	         :his function returns a HelpFlag member variable
						specified by input argument
   Type	             :Member function 
   Input parameter   :
		htHelp		 :Help type
   Output parameters :None
   Return Type       :Bool
   Global Variables  :None
   Calling Syntax    :GetHelp(htHelp)
   Calls             :None
   Called by         :CFormatEngine::DisplayGlobalSwitchesAndOtherDesc,
						CFormatEngine::DisplayAliasVerbDescriptions,
						CFormatEngine::DisplayStdVerbDescriptions,
						CFormatEngine::DisplayHelp,
						CFormatEngine::DisplayMethodDetails
   Notes             :None
------------------------------------------------------------------------*/
BOOL CHelpInfo::GetHelp(HELPTYPE htHelp)
{
	BOOL bResult = FALSE;
	
	switch ( htHelp )
	{
	case Namespace:
		bResult		= m_bNameSpaceHelp;
		break;
	case Role:
		bResult		= m_bRoleHelp;
		break;
	case Node:
		bResult		= m_bNodeHelp;
		break;
	case User:
		bResult		= m_bUserHelp;
		break;
	case Aggregate:
		bResult		= m_bAggregateHelp;
		break;
	case Password:
		bResult		= m_bPasswordHelp;
		break;
	case Locale:
		bResult		= m_bLocaleHelp;
		break;
	case RecordPath:
		bResult		= m_bRecordPathHelp;
		break;
	case Privileges:
		bResult		= m_bPrivilegesHelp;
		break;
	case Level:
		bResult		= m_bLevelHelp;
		break;
	case AuthLevel:
		bResult		= m_bAuthLevelHelp;
		break;
	case Interactive:
		bResult		= m_bInteractiveHelp;
		break;
	case Trace:
		bResult		= m_bTraceHelp;
		break;
	case GlblAllInfo:
		bResult		= m_bGlblAllInfoHelp;
		break;
	case CmdAllInfo:
		bResult		= m_bCmdAllInfoHelp;
		break;
	case GETVerb:
		bResult		= m_bGetVerbHelp;
		break;
	case SETVerb:
		bResult		= m_bSetVerbHelp;
		break;
	case LISTVerb:
		bResult		= m_bListVerbHelp;
		break;
	case CALLVerb:
		bResult		= m_bCallVerbHelp;
		break;
	case DELETEVerb:
		bResult		= m_bDeleteVerbHelp;
		break;
	case CREATEVerb:
		bResult		= m_bCreateVerbHelp;
		break;
	case DUMPVerb:
		bResult		= m_bDumpVerbHelp;
		break;
	case ASSOCVerb:
		bResult		= m_bAssocVerbHelp;
		break;
	case AliasVerb:
		bResult		= m_bAliasVerbHelp;
		break;
	case PATH:
		bResult		= m_bPATHHelp;
		break;
	case WHERE:
		bResult		= m_bWHEREHelp;
		break;
	case CLASS:
		bResult		= m_bCLASSHelp;
		break;
	case EXIT:
		bResult		= m_bEXITHelp;
		break;
	case PWhere:
		bResult		= m_bPWhereHelp;
		break;
	case TRANSLATE:
		bResult		= m_bTRANSLATEHelp;
		break;
	case EVERY:
		bResult		= m_bEVERYHelp;
		break;
	case FORMAT:
		bResult		= m_bFORMATHelp;
		break;
	case VERBSWITCHES:
		bResult		= m_bVERBSWITCHESHelp;
		break;
	case DESCRIPTION:
		bResult		= m_bDESCRIPTIONHelp;
		break;
	case GETSwitchesOnly:
		bResult		= m_bGETSwitchesOnlyHelp;
		break;
	case LISTSwitchesOnly:
		bResult		= m_bLISTSwitchesOnlyHelp;
		break;
	case CONTEXTHELP:
		bResult		= m_bContextHelp;
		break;
	case GLBLCONTEXT:
		bResult		= m_bGlblSwitchValuesHelp;
		break;
	case RESULTCLASShelp:
		bResult		= m_bRESULTCLASSHelp ;
		break;
	case RESULTROLEhelp:
		bResult		= m_bRESULTROLE ;
		break;
	case ASSOCCLASShelp:
		bResult		= m_bASSOCCLASS ;
		break;
	case ASSOCSwitchesOnly:
		bResult		= m_bASSOCSwitchesOnlyHelp ;
		break;
	case FAILFAST:
		bResult		= m_bFAILFASTHelp ;
		break;
	case REPEAT:
		bResult		= m_bREPEATHelp ;
		break;
	case OUTPUT:
		bResult		= m_bOUTPUTHelp ;
		break;
	case APPEND:
		bResult		= m_bAPPENDHelp ;
		break;
	}
	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\helpinfo.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: HelpInfo.h 
Project Name				: WMI Command Line
Author Name					: C. V. Nandi
Date of Creation (dd/mm/yy) : 29th-September-2000
Version Number				: 1.0 
Brief Description			: This file consist of class declaration of
							  class CHelpInfo
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 16th-January-2001
****************************************************************************/ 
// HelpInfo.h : header file
//
/*--------------------------------------------------------------------------
 Class Name			: CHelpInfo
 Class Type			: Concrete 
 Brief Description	: The CHelpInfo class encapsulates the functionality 
					  needed for storing and retrieving help Flag for 
					  displaying help.
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: None
 Interfaces Used    : None
 --------------------------------------------------------------------*/
/////////////////////////////////////////////////////////////////////////////
// CHelpInfo
class CHelpInfo
{
public:
//	Construction
	CHelpInfo();

//	Destruction
	~CHelpInfo();

//	Restrict Assignment
	CHelpInfo& operator=(CHelpInfo& rHelpInfo);

//	Attributes
private:
	// Global Switches Help
	BOOL	m_bGlblAllInfoHelp;
	BOOL	m_bNameSpaceHelp;
	BOOL	m_bRoleHelp;
	BOOL	m_bNodeHelp;
	BOOL	m_bUserHelp;
	BOOL	m_bPasswordHelp;
	BOOL	m_bLocaleHelp;
	BOOL	m_bRecordPathHelp;
	BOOL	m_bPrivilegesHelp;
	BOOL	m_bLevelHelp;
	BOOL	m_bAuthLevelHelp;
	BOOL	m_bInteractiveHelp;
	BOOL	m_bTraceHelp;
	BOOL	m_bAggregateHelp;

	// Command Switches Help
	BOOL m_bCmdAllInfoHelp;

	BOOL	m_bGetVerbHelp;
	BOOL	m_bSetVerbHelp;
	BOOL	m_bListVerbHelp;
	BOOL	m_bCallVerbHelp;
	BOOL	m_bDumpVerbHelp;
	BOOL	m_bAssocVerbHelp;
	BOOL	m_bCreateVerbHelp;
	BOOL	m_bDeleteVerbHelp;
	BOOL	m_bAliasVerbHelp;
	BOOL	m_bPATHHelp;
	BOOL	m_bWHEREHelp;
	BOOL	m_bCLASSHelp;
	BOOL	m_bEXITHelp;
	BOOL	m_bPWhereHelp;
	BOOL	m_bTRANSLATEHelp;
	BOOL	m_bEVERYHelp;
	BOOL	m_bFORMATHelp;
	BOOL	m_bVERBSWITCHESHelp;
	BOOL	m_bDESCRIPTIONHelp;
	BOOL	m_bGETSwitchesOnlyHelp;
	BOOL	m_bLISTSwitchesOnlyHelp;
	BOOL	m_bContextHelp;
	BOOL	m_bGlblSwitchValuesHelp;
	BOOL    m_bRESULTCLASSHelp;
	BOOL    m_bRESULTROLE;
	BOOL    m_bASSOCCLASS;
	BOOL    m_bASSOCSwitchesOnlyHelp;
	BOOL    m_bFAILFASTHelp;
	BOOL    m_bREPEATHelp;
	BOOL    m_bOUTPUTHelp;
	BOOL    m_bAPPENDHelp;
//	Operations
public :
	//Initializes the member variables
	void Initialize();
	
	//sets the help flag for the item specified by htHelp argument
	void SetHelp( HELPTYPE htHelp, BOOL bFlag );
	
	//Gets the help flag for the item specified by htHelp argument
	BOOL GetHelp( HELPTYPE htHelp );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\parserengine.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: ParserEngine.cpp 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This class encapsulates the functionality needed
							  for parsing the command string entered as input
							  and validating the same.
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 18th-December-2000
*****************************************************************************/ 

// include files
#include "Precomp.h"
#include "GlobalSwitches.h"
#include "CommandSwitches.h"
#include "HelpInfo.h"
#include "ErrorLog.h"
#include "ParsedInfo.h"
#include "CmdTokenizer.h"
#include "CmdAlias.h"
#include "ParserEngine.h"
#include "WMICliXMLLog.h"
#include "ErrorInfo.h"
#include "FormatEngine.h"
#include "ExecEngine.h"
#include "WmiCmdLn.h"

/*----------------------------------------------------------------------------
   Name				 :CParserEngine
   Synopsis	         :This function initializes the member variables when an 
					  object of the class type is instantiated.
   Type	             :Constructor 
   Input Parameter(s):None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
----------------------------------------------------------------------------*/
CParserEngine::CParserEngine()
{
	m_pIWbemLocator = NULL;
	m_pITargetNS	= NULL;
	m_bAliasName	= FALSE;
}

/*----------------------------------------------------------------------------
   Name				 :~CParserEngine
   Synopsis	         :This function uninitializes the member variables when an
					  object of the class type goes out of scope.
   Type	             :Destructor
   Input Parameter(s):None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
----------------------------------------------------------------------------*/
CParserEngine::~CParserEngine()
{
	SAFEIRELEASE(m_pITargetNS);
	SAFEIRELEASE(m_pIWbemLocator);
}

/*----------------------------------------------------------------------------
   Name				 :GetCmdTokenizer
   Synopsis	         :This function returns a reference to the CCmdTokenizer 
					  object, a data member of this class.
   Type	             :Member Function
   Input Parameter(s):None
   Output parameters :None
   Return Type       :CCmdTokenizer&
   Global Variables  :None
   Calling Syntax    :GetCmdTokenizer()
   Notes             :None
----------------------------------------------------------------------------*/
CCmdTokenizer& CParserEngine::GetCmdTokenizer()
{
	return m_CmdTknzr;
}

/*----------------------------------------------------------------------------
   Name				 :Initialize
   Synopsis	         :This function initializes the neeeded data members of 
					  this class.
   Type	             :Member Function
   Input Parameter(s):None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :Initialize()
   Notes             :None
----------------------------------------------------------------------------*/
void CParserEngine::Initialize()
{
	m_bAliasName	= FALSE;
}

/*----------------------------------------------------------------------------
   Name				 :Uninitialize
   Synopsis	         :This function uninitializes the member variables when 
					  the execution of a command string issued on the command 
					  line is completed and then the parser engine variables 
					  are also uninitialized.
   Type	             :Member Function
   Input Parameter(s):
			bFinal	- boolean value which when set indicates that the program
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :Uninitialize()
   Notes             :None
----------------------------------------------------------------------------*/
void CParserEngine::Uninitialize(BOOL bFinal)
{
	m_bAliasName = FALSE;
	m_CmdTknzr.Uninitialize();
	m_CmdAlias.Uninitialize();
	if (bFinal)
	{
		m_CmdAlias.Uninitialize(TRUE);
		SAFEIRELEASE(m_pITargetNS);
		SAFEIRELEASE(m_pIWbemLocator);
	}
}

/*----------------------------------------------------------------------------
   Name				 :SetLocatorObject
   Synopsis	         :This function sets the WMI Locator Object to the 
					  m_pIWbemLocator.
   Type	             :Member Function
   Input Parameter(s):
		pIWbemLocator - pointer to IWbemLocator interface .
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetLocatorObject(pIWbemLocator)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL CParserEngine::SetLocatorObject(IWbemLocator* pIWbemLocator)
{
	static BOOL bFirst = TRUE;
	BOOL   bRet = TRUE;
	if (bFirst)
	{
		if (pIWbemLocator != NULL)
		{
			SAFEIRELEASE(m_pIWbemLocator);
			m_pIWbemLocator = pIWbemLocator;
			m_pIWbemLocator->AddRef();
		}
		else
			bRet = FALSE;
		bFirst = FALSE;
	}
	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :ProcessTokens
   Synopsis	         :This function does the processing of the tokens. It 
					  checks for the presence of switches and calls the 
					  appropriate Parsing function and updates the CParsedInfo
					  object passed to it.
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ProcessTokens(rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ProcessTokens(CParsedInfo& rParsedInfo)
{
	BOOL	bContinue			= TRUE;
	RETCODE retCode				= PARSER_EXECCOMMAND;
	
	// Obtain the token vector.
	CHARVECTOR cvTokens			= m_CmdTknzr.GetTokenVector();

	//the iterator to span throuh the vector variable 
	CHARVECTOR::iterator theIterator = NULL;

	// Check for the presence of tokens. Absence of tokens indicates
	// no command string is fed as input.
	if (!cvTokens.empty())
	{
		// Obtain the pointer to the beginning of the token vector.
	    theIterator = cvTokens.begin(); 

		// Check for the presence of the global switches and 
		// store the values specified with them (if any) in the 
		// CGlobalSwitches object. Global switches are followed
		// '/' character.
		if (IsOption(*theIterator))
		{
			retCode = ParseGlobalSwitches(cvTokens, 
									theIterator, rParsedInfo);
			if (retCode == PARSER_CONTINUE)
			{
				// If no more tokens are present
				if (theIterator >= cvTokens.end())
				{
					retCode = PARSER_MESSAGE;
					bContinue = FALSE;
				}
			}
			else
				bContinue = FALSE;
		}

		if (bContinue)
		{
			// Suppress Information Msg before Executing command.
			rParsedInfo.GetCmdSwitchesObject().SetInformationCode(0);

			// Check for the presence of the CLASS keyword
			if (CompareTokens(*theIterator, CLI_TOKEN_CLASS))
			{
				// Move to next token, and check its validity
				retCode = GetNextToken(cvTokens, theIterator,
										rParsedInfo, CLASS,
										IDS_E_INVALID_CLASS_SYNTAX);

				if (retCode == PARSER_CONTINUE)
				{
					// NOTE: Indicates direct escaping to WMI schema
					// Parse and interpret the remaining tokens following 
					// the CLASS keyword
					retCode = ParseClassInfo(cvTokens, theIterator, 
															rParsedInfo);
				}
			}
			// Check for the presence of the PATH keyword
			else if (CompareTokens(*theIterator, CLI_TOKEN_PATH))
			{
				//NOTE: Indicates PATH clause without an alias name
				// Move to next token
				retCode = GetNextToken(cvTokens, theIterator, 
									   rParsedInfo, PATH, 
									   IDS_E_INVALID_PATH_SYNTAX);
				if (retCode == PARSER_CONTINUE)
					// Parse and interpret the remaining tokens 
					// following the PATH clause
					retCode = ParsePathInfo(cvTokens, theIterator,
														rParsedInfo);
			}
			// Check for the presence of the CONTEXT keyword
			else if (CompareTokens(*theIterator, CLI_TOKEN_CONTEXT)) 
			{
				if (GetNextToken(cvTokens, theIterator))
				{
					retCode = ParseContextInfo(cvTokens, 
										theIterator, rParsedInfo);
				}
				else
				{
					rParsedInfo.GetGlblSwitchesObject().SetHelpFlag(TRUE);
					rParsedInfo.GetHelpInfoObject().SetHelp(GLBLCONTEXT, TRUE);
					retCode = PARSER_DISPHELP;
				}
			}
			// If the token value does not match against the 
			// pre-defiend keywords, it is considered as an alias.
			else 
			{
				// Validate the alias name and parse the remaining 
				// tokens following the <alias> name.
				retCode = ParseAliasInfo(cvTokens, 
										theIterator, rParsedInfo);

				if (retCode == PARSER_EXECCOMMAND)
				{
					try
					{
						_bstr_t bstrTrgtClass;
						_TCHAR	*pszClass		= NULL;

						// Check the validity of the path expression w.r.t the 
						// alias specified using the following steps: 
						// (i.e to check for alias - path conflict)
						// step1: Obtain the alias target class.
						rParsedInfo.GetCmdSwitchesObject().
								GetClassOfAliasTarget(bstrTrgtClass);

						// step2: Obtain the explicitly specified class.
						pszClass = rParsedInfo.GetCmdSwitchesObject().
								GetClassPath();
						if (!(!bstrTrgtClass) && (pszClass != NULL))
						{
							// If both are not same, set the errata code
							if(!CompareTokens((_TCHAR*)bstrTrgtClass,pszClass))
							{
								// Set the error code
								rParsedInfo.GetCmdSwitchesObject().
									SetErrataCode(IDS_I_ALIAS_PATH_CONFLICT);
								retCode = PARSER_ERROR;
							}
						}
					}
					catch(_com_error& e)
					{
						_com_issue_error(e.Error());
					}
				}
			}
		}
	}
	else
	{
		// Indicates NULL string specified as input on the WMI Command Line.
		rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(IDS_E_BLANK_COMMAND_MESSAGE);
		retCode = PARSER_ERROR;
	}

	// Get the Property qualifiers information from the alias - SET and CREATE.
	if ((retCode == PARSER_EXECCOMMAND) && 
		((CompareTokens(rParsedInfo.GetCmdSwitchesObject().GetVerbName(), 
			CLI_TOKEN_SET)) || 
		 (CompareTokens(rParsedInfo.GetCmdSwitchesObject().GetVerbName(),
			CLI_TOKEN_CREATE))))
	{
		if (m_bAliasName)
		{
			if (FAILED(m_CmdAlias.ObtainAliasPropDetails(rParsedInfo)))
				retCode = PARSER_ERRMSG;
		}
	}

	if ( retCode == PARSER_DISPHELP )
	{
		if ( m_bAliasName ||
			 rParsedInfo.GetCmdSwitchesObject().GetClassPath() != NULL )
		{
			ObtainMethodsAvailableFlag(rParsedInfo);
			ObtainWriteablePropsAvailailableFlag(rParsedInfo);
		}

		if ( m_bAliasName == TRUE )
		{
			rParsedInfo.GetCmdSwitchesObject().
						SetLISTFormatsAvailable(
							m_CmdAlias.ObtainAliasFormat(rParsedInfo, TRUE));
		}
	}

	if ( retCode == PARSER_EXECCOMMAND || retCode == PARSER_DISPHELP )
	{
		retCode = ProcessOutputAndAppendFiles(rParsedInfo, retCode, FALSE);
	}
	else if (rParsedInfo.GetCmdSwitchesObject().GetOutputSwitchFlag() == TRUE
		    && retCode == PARSER_MESSAGE)
		rParsedInfo.GetCmdSwitchesObject().SetOutputSwitchFlag(FALSE);

	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseClassInfo
   Synopsis	         :This function does the parsing and interprets if command
					  has CLASS keyword specified in it. It parses the 
					  remaining tokens following and updates the same in
					  CParsedInfo object passed to it.
   Type	             :Member Function
   Input Parameter(s)   :
		cvTokens      - the tokens vector 
		theIterator   - the Iterator to the cvTokens vector.
		rParsedInfo   - reference to CParsedInfo class object
   Output parameter(s):
		rParsedInfo   - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseClassInfo(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseClassInfo(CHARVECTOR& cvTokens,
									  CHARVECTOR::iterator& theIterator,
									  CParsedInfo& rParsedInfo )
{
	// BNF: CLASS <class path expression> [<verb clause>]
	BOOL	bContinue = TRUE;
	RETCODE retCode   = PARSER_EXECCOMMAND;

	// If option
	if (IsOption(*theIterator))
	{
		// Check for help
		retCode = IsHelp(cvTokens, theIterator,	rParsedInfo, CLASS,
								 IDS_E_INVALID_HELP_SYNTAX, LEVEL_ONE);
		if (retCode != PARSER_CONTINUE)
			bContinue = FALSE;
	}
	else 
	{
		// Store the class path in the CCommandSwitches object.
		if(!rParsedInfo.GetCmdSwitchesObject().SetClassPath(*theIterator))
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(OUT_OF_MEMORY);
			bContinue = FALSE;
			retCode = PARSER_OUTOFMEMORY;
		}
		else if ( IsValidClass(rParsedInfo) == FALSE )
		{
			rParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(IDS_E_INVALID_CLASS);
			retCode = PARSER_ERROR;
			bContinue = FALSE;
		}

		if(bContinue)
		{
			// Move to next token
			if (!GetNextToken(cvTokens, theIterator))
			{
				// i.e. <verb clause> is not specified.
				bContinue = FALSE;
				retCode = PARSER_EXECCOMMAND;
			}
		}
	}
	
	if (bContinue)
	{
		// Check for the presence of /?
		if (IsOption(*theIterator))
		{
			// Check for help
			retCode = IsHelp(cvTokens, theIterator,	rParsedInfo, CLASS, 
								   IDS_E_INVALID_HELP_SYNTAX, LEVEL_ONE);
		}
		else
		{
			// Parse and interpret the verb tokens that follow
			retCode = ParseVerbInfo(cvTokens,theIterator,rParsedInfo);
			if (retCode == PARSER_EXECCOMMAND)
			{
				// Check for verb switches
				if (GetNextToken(cvTokens, theIterator))
					retCode = ParseVerbSwitches(cvTokens, theIterator,
														rParsedInfo);
			}
		}
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseAliasInfo
   Synopsis	         :This function does the parsing and interprets if command
					  has <alias> name in it.It Validate the alias name and 
					  parses the remaining tokens following the <alias> name.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens      - the tokens vector 
		theIterator   - the Iterator to the cvTokens vector.
		rParsedInfo   - reference to CParsedInfo class object
   Output parameter(s):
		rParsedInfo   - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseAliasInfo(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseAliasInfo(CHARVECTOR& cvTokens,
										CHARVECTOR::iterator& theIterator, 
										CParsedInfo& rParsedInfo)
{
	//BNF: (<alias> | [<WMI object>] | [<alias>] <path where>) [<verb clause>]
	RETCODE		retCode		= PARSER_EXECCOMMAND;
	HRESULT		hr			= S_OK;
	BOOL		bContinue	= TRUE;
	RETCODE     tRetCode	= PARSER_ERROR;

	// Store the AliasName in the CommandSwitches object.
	if(!rParsedInfo.GetCmdSwitchesObject().SetAliasName(*theIterator))
	{	
		rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(OUT_OF_MEMORY);
		retCode = PARSER_OUTOFMEMORY;
	}
	else
	{
		m_bAliasName	= TRUE;

		// Move to next token
		retCode = GetNextToken(cvTokens, theIterator, 
								rParsedInfo, CmdAllInfo, IDS_E_INVALID_COMMAND);
		if (retCode == PARSER_ERROR)
			tRetCode = PARSER_EXECCOMMAND;

		else if(retCode == PARSER_DISPHELP && 
			rParsedInfo.GetGlblSwitchesObject().GetInteractiveStatus() == TRUE)
		{
			tRetCode = PARSER_EXECCOMMAND;
			rParsedInfo.GetGlblSwitchesObject().SetHelpFlag(FALSE);
			rParsedInfo.GetHelpInfoObject().SetHelp(CmdAllInfo, FALSE);
		}
	
		// Connect to alias and retrieve the alias information
		try
		{
			// Connect to the AliasNamespace.
			hr = m_CmdAlias.ConnectToAlias(rParsedInfo, m_pIWbemLocator);
			ONFAILTHROWERROR(hr);

			// Obtain the alias information ( Target, Namespace,...)
			retCode = m_CmdAlias.ObtainAliasInfo(rParsedInfo);
			if((retCode == PARSER_OUTOFMEMORY) || (retCode == PARSER_ERRMSG))
			{
				if (retCode == PARSER_OUTOFMEMORY)
				{
					rParsedInfo.GetCmdSwitchesObject().
									SetErrataCode(OUT_OF_MEMORY);
					retCode = PARSER_OUTOFMEMORY;
				}
				bContinue = FALSE;
			}
		}
		catch(_com_error& e)
		{
			retCode = PARSER_ERRMSG;
			bContinue = FALSE;
			_com_issue_error(e.Error());
		}

		if (bContinue && tRetCode != PARSER_EXECCOMMAND)
		{
			// Check for the presence of the PATH keyword
			if (CompareTokens(*theIterator, CLI_TOKEN_PATH))
			{
				// NOTE: Indicates PATH clause preceded by an alias name
				// Move to next token
				retCode = GetNextToken(cvTokens, theIterator, 
							rParsedInfo, PATH, IDS_E_INVALID_PATH);
				if (retCode == PARSER_CONTINUE)
					// Parse and interpret the remaining tokens following
					// the PATH clause
					retCode = ParsePathInfo(cvTokens, theIterator, 
															 rParsedInfo);
			}
			// Check for the presence of the WHERE keyword
			else if (CompareTokens(*theIterator, CLI_TOKEN_WHERE))
			{
				// NOTE: Indicates WHERE clause preceded by an alias name
				// Move to next token
				retCode = GetNextToken(cvTokens, theIterator, rParsedInfo,
										WHERE, IDS_E_INVALID_QUERY);
				if (retCode == PARSER_CONTINUE)
					// Parse and interpret the remaining tokens following
					// the WHERE clause
					retCode = ParseWhereInfo(cvTokens, theIterator, 
															rParsedInfo);
			}
			// Check for the presence of the '('
			else if (CompareTokens(*theIterator, CLI_TOKEN_LEFT_PARAN))
			{
				// Frame the parameterized WHERE expression 
				if (!ParsePWhereExpr(cvTokens, theIterator, rParsedInfo,
																	TRUE))
				{
					retCode = PARSER_ERROR;
				}
				else
				{
					// Move to next token
					if (theIterator >= cvTokens.end())
					{
						// PARSER_ERROR if no more tokens are present
						rParsedInfo.GetCmdSwitchesObject().
								 SetErrataCode(IDS_E_INVALID_COMMAND);
						retCode = PARSER_ERROR;
					}
					else
					{
						if (CompareTokens(*theIterator, CLI_TOKEN_RIGHT_PARAN))
						{
							// Move to next token
							if (!GetNextToken(cvTokens, theIterator))
							{
								// if no more tokens are present.
								retCode = PARSER_EXECCOMMAND;
							}
							else
							{
								if (IsOption(*theIterator))
								{
									retCode = IsHelp(cvTokens, 
													 theIterator,
													 rParsedInfo,
													 PWhere,
													 IDS_E_INVALID_HELP_SYNTAX,
													 LEVEL_ONE);
									if ( retCode == PARSER_DISPHELP )
									{
										if (FAILED(m_CmdAlias.
										ObtainAliasVerbDetails(rParsedInfo)))
											retCode = PARSER_ERRMSG;			
									}
								}
								else
								{
									retCode = ParseVerbInfo(cvTokens, 
												theIterator, rParsedInfo);
									// Parse and interpret the verb tokens 
									// that follow
									if (retCode == PARSER_EXECCOMMAND)
									{
										if(GetNextToken(cvTokens,
														theIterator))
											// check for the common verb
											// switches /INTERACTIVE,
											// /NOINTERACTIVE
											retCode = ParseVerbSwitches(
															cvTokens, 
															theIterator,
															rParsedInfo);
									}
								}
							}
						}
						else
						{
							// PARSER_ERROR if no more tokens are present
							rParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(IDS_E_INVALID_COMMAND);
							retCode = PARSER_ERROR;
						}
					}
				}
			}
			else 
			{
				if (IsOption(*theIterator))
				{
					// Check for help
					retCode = IsHelp(cvTokens, theIterator, rParsedInfo, 
									CmdAllInfo, IDS_E_INVALID_HELP_SYNTAX,
									LEVEL_ONE);
					
					if (retCode == PARSER_DISPHELP)
					{
						rParsedInfo.GetCmdSwitchesObject().
								AddToAlsFrnNmsOrTrnsTblMap(
								CharUpper(rParsedInfo.GetCmdSwitchesObject().
										  GetAliasName()),
							rParsedInfo.GetCmdSwitchesObject().GetAliasDesc());
					}
				}
				else
				{
					if (bContinue)
					{
						// Frame the parameterized WHERE expression 
						if (!ParsePWhereExpr(cvTokens, theIterator, 
											 rParsedInfo, FALSE))
						{
							retCode = PARSER_ERROR;
						}
						else
						{
							if ( theIterator >= cvTokens.end() )
								retCode = PARSER_EXECCOMMAND;
							else
							{
								// Parse the verb.
								if (IsOption(*theIterator))
								{
									retCode = IsHelp(cvTokens, 
													 theIterator,
													 rParsedInfo,
													 PWhere,
													 IDS_E_INVALID_HELP_SYNTAX,
													 LEVEL_ONE);

									if ( retCode == PARSER_DISPHELP )
									{
										if (FAILED(m_CmdAlias.
										ObtainAliasVerbDetails(rParsedInfo)))
											retCode = PARSER_ERRMSG;			
									}
								}
								else
								{
									retCode = ParseVerbInfo(cvTokens, 
											theIterator, rParsedInfo);
									if (retCode == PARSER_EXECCOMMAND)
									{
										if (GetNextToken(cvTokens, theIterator))
											// check for the common verb switches 
											// /INTERACTIVE, /NOINTERACTIVE
											retCode = ParseVerbSwitches(cvTokens, 
														theIterator,
														rParsedInfo);
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if(tRetCode == PARSER_EXECCOMMAND) 
	{
		if ((retCode != PARSER_ERRMSG) && (retCode != PARSER_OUTOFMEMORY))
		{
			retCode = tRetCode;
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(0);
		}
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseWhereInfo
   Synopsis	         :This function does the parsing and interprets if command
					  has alias, with where clause also specified it.It parses
					  the remaining tokens following and updates the same in 
					  CParsedInfo object passed to it.
   Type	             :Member Function
   Input Parameter(s)   :
		cvTokens      - the tokens vector 
		theIterator   - the Iterator to the cvTokens vector.
		rParsedInfo   - reference to CParsedInfo class object
   Output parameter(s) :
		rParsedInfo   - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseWhereInfo(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseWhereInfo(CHARVECTOR& cvTokens,
									  CHARVECTOR::iterator& theIterator,
									  CParsedInfo& rParsedInfo)
{
	RETCODE retCode		= PARSER_EXECCOMMAND;
	BOOL	bContinue	= TRUE;

	rParsedInfo.GetCmdSwitchesObject().SetExplicitWhereExprFlag(TRUE);

	if (IsOption(*theIterator))
	{
		// Check for help
		retCode = IsHelp(cvTokens, theIterator,	rParsedInfo, 
				WHERE, IDS_E_INVALID_WHERE_SYNTAX, LEVEL_ONE); 
		if (retCode != PARSER_CONTINUE)
			bContinue = FALSE;
	}
	
	if (bContinue)
	{
		if ( !m_bAliasName && rParsedInfo.GetCmdSwitchesObject().
								GetClassPath() == NULL )
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
								IDS_E_ALIAS_OR_PATH_SHOULD_PRECEED_WHERE);
			retCode = PARSER_ERROR;
		}
		// Store the WHERE expression in the CCommandSwitches object.
		else if(!rParsedInfo.GetCmdSwitchesObject().SetWhereExpression(
																*theIterator))
		{
			rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(OUT_OF_MEMORY);
			retCode = PARSER_OUTOFMEMORY;

		}
		else
		{
			// Move to next token
			if (!GetNextToken(cvTokens, theIterator))	
			{
				// If no more tokens are present. i.e no verb clause is present
				retCode = PARSER_EXECCOMMAND;
			}
			else
			{
				if (IsOption(*theIterator))
				{
					retCode = IsHelp(cvTokens, theIterator,	rParsedInfo, WHERE, 
										IDS_E_INVALID_HELP_SYNTAX, LEVEL_ONE);
				}
				else
				{
					// Parse and interpret the verb tokens that follow
					// Handled for /verb to verb
					retCode = ParseVerbInfo(cvTokens, theIterator, 
																rParsedInfo);
					if (retCode == PARSER_EXECCOMMAND)
					{
						if (GetNextToken(cvTokens, theIterator))
							//check for the common verb switches /INTERACTIVE,
							// /NOINTERACTIVE
							retCode = ParseVerbSwitches(cvTokens, theIterator,
														rParsedInfo);
					}
				}
			}
		}
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParsePathInfo
   Synopsis	         :This function does the parsing and interprets if command
					  has alias with path clause also specified it.It parses 
					  the remaining tokens following and updates the same in 
					  CParsedInfo object passed to it.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s) :
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParsePathInfo(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParsePathInfo(CHARVECTOR& cvTokens,
									CHARVECTOR::iterator& theIterator,
									CParsedInfo& rParsedInfo)
{
	RETCODE retCode		= PARSER_EXECCOMMAND;
	BOOL	bContinue	= TRUE;

	if (IsOption(*theIterator))
	{
		retCode = IsHelp(cvTokens, theIterator,	rParsedInfo, 
				PATH, IDS_E_INVALID_PATH_SYNTAX, LEVEL_ONE); 
		if (retCode != PARSER_CONTINUE)
			bContinue = FALSE;
	}

	if (bContinue)
	{
		// Store the object PATH expression in the CCommandSwitches object.
		if(!rParsedInfo.GetCmdSwitchesObject().SetPathExpression(*theIterator))
		{
			rParsedInfo.GetCmdSwitchesObject().
						SetErrataCode(OUT_OF_MEMORY);
			retCode = PARSER_OUTOFMEMORY;
		}
		else
		{
			//Extract the classname and where expression given path expression
			_TCHAR pszPathExpr[MAX_BUFFER] = NULL_STRING;
			lstrcpy(pszPathExpr,CLI_TOKEN_NULL);
			lstrcpy(pszPathExpr, rParsedInfo.GetCmdSwitchesObject().
												GetPathExpression());
			if (!ExtractClassNameandWhereExpr(pszPathExpr, rParsedInfo))
				retCode = PARSER_ERROR;
				// Move to next token
			else if ( IsValidClass(rParsedInfo) == FALSE )
			{
				rParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(IDS_E_INVALID_CLASS);
				bContinue = FALSE;
				retCode = PARSER_ERROR;
			}
			else if (!GetNextToken(cvTokens, theIterator))	
				// If no more tokens are present. i.e no verb clause is present
				retCode = PARSER_EXECCOMMAND;
			else
			{
				if ( CompareTokens(*theIterator, CLI_TOKEN_WHERE) )
				{
					if ( rParsedInfo.GetCmdSwitchesObject().
						 GetWhereExpression() != NULL )
					{
						rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
								IDS_E_KEY_CLASS_NOT_ALLOWED_WITH_PATHWHERE);
						retCode = PARSER_ERROR;
					}
					else
					{
						retCode = GetNextToken(cvTokens, theIterator, 
											   rParsedInfo, WHERE,
											   IDS_E_INVALID_WHERE_SYNTAX);
						if (retCode == PARSER_CONTINUE)
							// Parse and interpret the remaining tokens 
							// following the WHERE clause
							retCode = ParseWhereInfo(cvTokens, theIterator, 
																rParsedInfo);
					}
				}
				else
				{
					if (IsOption(*theIterator))
					{
						retCode = IsHelp(cvTokens, theIterator,	rParsedInfo,
										PATH, IDS_E_INVALID_HELP_SYNTAX, 
										LEVEL_ONE);
					}
					else
					{
						// Parse and interpret the verb tokens that follow
						// Handled for /verb => verb.
						retCode = ParseVerbInfo(cvTokens,theIterator,rParsedInfo);
						if (retCode == PARSER_EXECCOMMAND)
						{
							if (GetNextToken(cvTokens, theIterator))
								//check for the common verb switches /INTERACTIVE, 
								///NOINTERACTIVE
								retCode = ParseVerbSwitches(cvTokens, theIterator,
															rParsedInfo);
						}
					}
				}
			}
		}
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseVerbInfo
   Synopsis	         :This function does the parsing and interprets if command
					  has verb clause specified  in it.It parses the remaining
					  tokens following the verb and updates the same in 
					  CParsedInfo object passed to it.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens      - the tokens vector 
		theIterator   - the Iterator to the cvTokens vector.
		rParsedInfo   - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo   - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseVerbInfo(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseVerbInfo(CHARVECTOR& cvTokens,
									CHARVECTOR::iterator& theIterator,
									CParsedInfo& rParsedInfo)
{
	RETCODE retCode		= PARSER_EXECCOMMAND;
	BOOL	bContinue	= TRUE;

	// STORE the verb name in the CCommandSwitches object
	if ( rParsedInfo.GetCmdSwitchesObject().SetVerbName(*theIterator) 
															    == FALSE )
	{
		rParsedInfo.GetCmdSwitchesObject().SetErrataCode(IDS_E_MEMALLOC_FAIL);
		retCode = PARSER_ERROR;
	}
	// Check for the presence of the following standard verbs:
	// 1.GET 2.SHOW 3.SET 4.CALL 5.ASSOC 6. CREATE 7. DELETE	
	// GET verb specified
	else if (CompareTokens(*theIterator, CLI_TOKEN_GET))
	{
		retCode = ParseGETVerb(cvTokens, theIterator, rParsedInfo);
	}
	// LIST verb specified
	else if (CompareTokens(*theIterator, CLI_TOKEN_LIST))
	{
		if (m_bAliasName == FALSE)
		{
			rParsedInfo.GetCmdSwitchesObject().
				SetErrataCode(IDS_E_INVALID_LIST_USAGE);
			retCode = PARSER_ERROR;
		}
		else
			retCode =  ParseLISTVerb(cvTokens, theIterator, rParsedInfo);
	}
	// SET | CREATE verb specified
	else if (CompareTokens(*theIterator, CLI_TOKEN_SET) ||
		CompareTokens(*theIterator, CLI_TOKEN_CREATE))
	{
		// <path expression> and <where expression> cannot be specified with
		// CREATE verb. Only <class expression> should be specified.
		if (CompareTokens(*theIterator, CLI_TOKEN_CREATE)
				&& rParsedInfo.GetCmdSwitchesObject().
					GetExplicitWhereExprFlag())
		{
			rParsedInfo.GetCmdSwitchesObject().
						SetErrataCode(IDS_E_INVALID_CREATE_EXPRESSION);
			retCode = PARSER_ERROR;
		}
		else
		{
			HELPTYPE helpType = 
				CompareTokens(*theIterator, CLI_TOKEN_CREATE)
				? CREATEVerb : SETVerb;
			retCode = ParseSETorCREATEVerb(cvTokens, theIterator, 
					rParsedInfo, helpType);
		}
	}
	// CALL verb specified
	else if (CompareTokens(*theIterator, CLI_TOKEN_CALL))
	{
		retCode = ParseCALLVerb(cvTokens, theIterator, rParsedInfo);
	}
	// ASSOC verb specified
	else if (CompareTokens(*theIterator, CLI_TOKEN_ASSOC))
	{
		retCode = ParseASSOCVerb(cvTokens, theIterator, rParsedInfo);
	}
	// DELETE verb specified.
	else if (CompareTokens(*theIterator, CLI_TOKEN_DELETE))
	{
		retCode = PARSER_EXECCOMMAND;
		//ParseDELETEVerb(cvTokens, theIterator, rParsedInfo);
	}
	// User defined verb
	else if (m_bAliasName)
	{
		// User defined verbs can only be associated with alias
		retCode = ParseMethodInfo(cvTokens, theIterator, rParsedInfo);
		if (retCode == PARSER_CONTINUE)
			retCode = PARSER_EXECCOMMAND;
	}
	else
	{
		rParsedInfo.GetCmdSwitchesObject().SetErrataCode(IDS_E_INVALID_VERB);
		retCode = PARSER_ERROR;
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseMethodInfo
   Synopsis	         :This function parses the tokens following  the user 
					  defined verb and updates the info in CParsedInfo object 
					  passed to it.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens      - the tokens vector 
		theIterator   - the Iterator to the cvTokens vector.
		rParsedInfo   - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo   - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseMethodInfo(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseMethodInfo(CHARVECTOR& cvTokens,
										CHARVECTOR::iterator& theIterator,
										CParsedInfo& rParsedInfo)
{
	RETCODE retCode		= PARSER_EXECCOMMAND;
	BOOL	bContinue	= TRUE;

	// Store the method name
	if(!rParsedInfo.GetCmdSwitchesObject().SetMethodName(*theIterator))
	{
		rParsedInfo.GetCmdSwitchesObject().
						SetErrataCode(OUT_OF_MEMORY);
		retCode = PARSER_OUTOFMEMORY;
	}
	else
	{
		if(m_bAliasName)
		{
			if (FAILED(m_CmdAlias.ObtainAliasVerbDetails(rParsedInfo)))
			{
				retCode = PARSER_ERRMSG;	
				bContinue =FALSE;
			}
			else
			{
				VERBTYPE vtVerbType =
							rParsedInfo.GetCmdSwitchesObject().GetVerbType();
				_TCHAR* pszVerbDerivation =
					rParsedInfo.GetCmdSwitchesObject().GetVerbDerivation();

				if ( rParsedInfo.GetCmdSwitchesObject().GetMethDetMap().empty())
				{
					DisplayMessage(*theIterator, CP_OEMCP, TRUE, TRUE);
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(IDS_E_INVALID_ALIAS_VERB);
					retCode = PARSER_ERROR;
					bContinue = FALSE;
				}
				else if ( pszVerbDerivation == NULL )
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(IDS_E_VERB_DERV_NOT_AVAIL_IN_ALIAS);
					retCode = PARSER_ERROR;
					bContinue = FALSE;
				}
				else if ( vtVerbType == CLASSMETHOD )
				{
					if (!rParsedInfo.GetCmdSwitchesObject().SetMethodName(
														   pszVerbDerivation))
					{
						rParsedInfo.GetCmdSwitchesObject().
									SetErrataCode(OUT_OF_MEMORY);
						retCode = PARSER_OUTOFMEMORY;
						bContinue = FALSE;
					}
				}
				else if ( vtVerbType == STDVERB )
				{
					(*theIterator) = pszVerbDerivation;
					// Parse and interpret the verb tokens that follow
					// Handled for /verb => verb.
					retCode = ParseVerbInfo(cvTokens,theIterator,rParsedInfo);
					if (retCode == PARSER_EXECCOMMAND)
					{
						if (GetNextToken(cvTokens, theIterator))
							retCode = ParseVerbSwitches(cvTokens, theIterator,
												rParsedInfo);
					}
					bContinue =FALSE;
				}
			}
		}
		else 
		{
			if (!ObtainClassMethods(rParsedInfo))
			{
				retCode = PARSER_ERRMSG;
				bContinue =FALSE;
			}
			else if (rParsedInfo.GetCmdSwitchesObject().GetMethDetMap().empty())
			{
				DisplayMessage(*theIterator, CP_OEMCP, TRUE, TRUE);
				rParsedInfo.GetCmdSwitchesObject().
						SetErrataCode(IDS_E_INVALID_CLASS_METHOD);
				retCode = PARSER_ERROR;
				bContinue =FALSE;
			}
		}

		// Move to next token
		if ( bContinue == TRUE && !GetNextToken(cvTokens, theIterator) )
		{
			// indicates method with no parameters
			retCode = PARSER_EXECCOMMAND;
			bContinue =FALSE;
		}

		if (bContinue)
		{
			if (IsOption(*theIterator)) 
			{
				retCode = IsHelp(cvTokens, theIterator, rParsedInfo, AliasVerb, 
								IDS_E_INVALID_EXPRESSION, LEVEL_TWO); 

				if (retCode == PARSER_CONTINUE)
					// To facilitate ParseVerbSwitches to continue
					theIterator = theIterator - 2;
				else if (retCode == PARSER_DISPHELP)
				{
					rParsedInfo.GetCmdSwitchesObject().GetMethDetMap().
																	clear();
					if(m_bAliasName)
					{
						if (FAILED(m_CmdAlias.ObtainAliasVerbDetails(
																rParsedInfo)))
							retCode = PARSER_ERRMSG;			
					}
					else if (!ObtainClassMethods(rParsedInfo))
							retCode = PARSER_ERRMSG;
				}
			}
			else
			{
				BOOL bNamedParamList;
				// Check for NamedParamList or UnnamedParamList.
				if ( (theIterator + 1) < cvTokens.end() &&
					 CompareTokens(*(theIterator + 1), CLI_TOKEN_EQUALTO ) )
				{
					retCode = ParseSETorCREATEOrNamedParamInfo(cvTokens,
															   theIterator,
															   rParsedInfo,
															   CALLVerb);
					if ( retCode == PARSER_EXECCOMMAND )
						retCode = ValidateVerbOrMethodParams(rParsedInfo);

					bNamedParamList = TRUE;
				}
				else
				{
					retCode = ParseUnnamedParamList(cvTokens, theIterator,
													rParsedInfo);
					bNamedParamList = FALSE;
				}
				
				rParsedInfo.GetCmdSwitchesObject().SetNamedParamListFlag(
															 bNamedParamList);
			}
		}
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseSETorCREATEVerb
   Synopsis	         :This function parses the tokens following SET|CREATE verb
					  and updates the info in CParsedInfo object passed to it.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
		HELPTYPE	 - helpType
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseSETorCREATEVerb(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseSETorCREATEVerb(CHARVECTOR& cvTokens,
									CHARVECTOR::iterator& theIterator,
									CParsedInfo& rParsedInfo,
									HELPTYPE helpType)
{
	RETCODE retCode		= PARSER_EXECCOMMAND;
	BOOL	bContinue	= TRUE;
	
	try
	{
		retCode = GetNextToken(cvTokens, theIterator, rParsedInfo, 
								helpType, IDS_E_INCOMPLETE_COMMAND);

		if (retCode == PARSER_CONTINUE)
		{
			if (IsOption(*theIterator)) 
			{
				retCode = IsHelp(cvTokens, theIterator, rParsedInfo, helpType,
											IDS_E_INVALID_COMMAND, LEVEL_ONE);

				if (retCode == PARSER_DISPHELP)
				{
					if (m_bAliasName)
					{
						if (FAILED(m_CmdAlias.
								ObtainAliasPropDetails(rParsedInfo)))
									retCode = PARSER_ERRMSG;
					}
					else
					{
						if (!ObtainClassProperties(rParsedInfo))
							retCode = PARSER_ERRMSG;
					}
				}
			}
			else
				retCode = ParseSETorCREATEOrNamedParamInfo(cvTokens, 
							theIterator, rParsedInfo, helpType);
		}
		
	}
	catch(_com_error& e)
	{
		retCode = PARSER_ERROR;
		_com_issue_error(e.Error());
	}

	return retCode;
}


/*----------------------------------------------------------------------------
   Name				 :ParseGETVerb
   Synopsis	         :This function parses the tokens following the GET verb
					  and updates the info in CParsedInfo.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseGETVerb(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseGETVerb(CHARVECTOR& cvTokens,
									CHARVECTOR::iterator& theIterator,
									CParsedInfo& rParsedInfo)
{
	BOOL		bPropList		= FALSE;
	RETCODE		retCode			= PARSER_EXECCOMMAND;
	BOOL		bContinue		= TRUE;
	_TCHAR		*pszNewEntry	= NULL;

	// Move to next token
	if (!GetNextToken(cvTokens, theIterator))
	{
		// GET format | switches not specified.
		retCode = PARSER_EXECCOMMAND;
	}
	else
	{
		BOOL bClass = FALSE;
		if(IsClassOperation(rParsedInfo))
		{
			bClass = TRUE;
		}

		if(!bClass)
		{
			// Process the property list specified
			if (!IsOption(*theIterator)) 
			{
				bPropList = TRUE;
				// Obtain the list of properties specified.
				while (TRUE) 
				{
					// Add the property to the property vector of the
					// CCommandSwitches object
					if(!rParsedInfo.GetCmdSwitchesObject().
									AddToPropertyList(*theIterator))
					{
						rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											IDS_E_ADD_TO_PROP_LIST_FAILURE);
						bPropList = FALSE;
						bContinue = FALSE;
						retCode = PARSER_ERROR;
						break;
					}

					// Move to next token
					if (!GetNextToken(cvTokens, theIterator))
					{
						// set the return code as PARSER_EXECCOMMAND 
						// if no more tokens are present 
						retCode = PARSER_EXECCOMMAND;
						bContinue = FALSE;
						break;
					}

					// Check for the presence of ',' token
					if (CompareTokens(*theIterator, CLI_TOKEN_COMMA))
					{
						if (!GetNextToken(cvTokens, theIterator))
						{
							rParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(IDS_E_INVALID_EXPRESSION);
							retCode = PARSER_ERROR;
							bContinue = FALSE;
							break;
						}
					}
					else
						break;
				}
			}
		}

		if (bContinue)
		{
			// alias|class get param1,param2... /getswitches
			if (IsOption(*theIterator))
			{
				retCode = IsHelp(cvTokens, theIterator, rParsedInfo, GETVerb,
									IDS_E_INVALID_EXPRESSION, LEVEL_TWO); 

				if (retCode != PARSER_CONTINUE)
				{
					if (retCode == PARSER_DISPHELP)
					{
						if (m_bAliasName)
						{
							if (FAILED(m_CmdAlias.
									ObtainAliasPropDetails(rParsedInfo)))
										retCode = PARSER_ERRMSG;
						}
						else
						{
							if (!ObtainClassProperties(rParsedInfo))
								retCode = PARSER_ERRMSG;
						}
					}
					bContinue = FALSE;
				}

				if (bContinue)
					retCode = ParseGETSwitches(cvTokens, theIterator, 
																rParsedInfo);
			}
			else
			{
				rParsedInfo.GetCmdSwitchesObject().
									SetErrataCode(IDS_E_INVALID_GET_EXPRESSION);
				retCode = PARSER_ERROR;
			}
		}

		// If property names are specified then replace them with their 
		// derivations. 
		if ( retCode == PARSER_EXECCOMMAND )
		{
			if (m_bAliasName)
			{
				if (FAILED(m_CmdAlias.
						ObtainAliasPropDetails(rParsedInfo)))
							retCode = PARSER_ERRMSG;
			}
			else
			{
				if (!ObtainClassProperties(rParsedInfo))
					retCode = PARSER_ERRMSG;
			}

			PROPDETMAP pdmPropDet = rParsedInfo.GetCmdSwitchesObject().
									  GetPropDetMap(); 	
			PROPDETMAP::iterator itrPropDet = NULL;
			CHARVECTOR cvPropsSpecified = rParsedInfo.
										  GetCmdSwitchesObject().
										  GetPropertyList();
			CHARVECTOR::iterator theIterator = NULL;
			CHARVECTOR cvPropDerivations;
			for ( theIterator = cvPropsSpecified.begin();
				  theIterator != cvPropsSpecified.end();
				  theIterator++ )
			{
				try
				{
					BOOL bFind = Find(pdmPropDet, *theIterator, itrPropDet);
					_bstr_t bstrPropDerivation;
					if ( bFind )
						bstrPropDerivation = _bstr_t(
											 (*itrPropDet).second.Derivation);
					else
						bstrPropDerivation = _bstr_t(*theIterator);
					_TCHAR* pszNewEntry = 
									new _TCHAR[bstrPropDerivation.length()+1];

					if (pszNewEntry == NULL)
						_com_issue_error(WBEM_E_OUT_OF_MEMORY);

					lstrcpy(pszNewEntry, bstrPropDerivation);
					cvPropDerivations.push_back(pszNewEntry);
				}
				catch(_com_error& e)
				{
					SAFEDELETE(pszNewEntry);
					retCode = PARSER_ERROR;
					CleanUpCharVector(cvPropDerivations);					
					_com_issue_error(e.Error());
				}
			}

			rParsedInfo.GetCmdSwitchesObject().ClearPropertyList();
			for ( theIterator = cvPropDerivations.begin();
					  theIterator != cvPropDerivations.end();
					  theIterator++ )
			{
				rParsedInfo.GetCmdSwitchesObject().
									AddToPropertyList(*theIterator);
			}
			CleanUpCharVector(cvPropDerivations);
		}
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseLISTVerb
   Synopsis	         :This function parses the tokens following the LIST verb
					  and updates the info in CParsedInfo.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s) :
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseLISTVerb(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseLISTVerb(CHARVECTOR& cvTokens,
									CHARVECTOR::iterator& theIterator,
									CParsedInfo& rParsedInfo)
{
	RETCODE	 retCode	= PARSER_EXECCOMMAND;
	BOOL	 bContinue	= TRUE;
	HRESULT  hr			= S_OK;
	BOOL	 bSetDefaultFormat = TRUE;

	// Set the default LIST format
 	if(!rParsedInfo.GetCmdSwitchesObject().SetListFormat(CLI_TOKEN_FULL))
	{
		rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(OUT_OF_MEMORY);
		retCode = PARSER_OUTOFMEMORY;
	}
	
	if (bContinue)
	{
		// If <list format> <list switches> specified.
		if (GetNextToken(cvTokens, theIterator))
		{
			// Check for LIST formats (LIST formats are not preceded by '/')
			if (!IsOption(*theIterator)) 
			{
				// If token is not followed by "/" or "-" then it is LIST format.
				if(!rParsedInfo.GetCmdSwitchesObject().
											SetListFormat(*theIterator))
				{
					rParsedInfo.GetCmdSwitchesObject().
									SetErrataCode(OUT_OF_MEMORY);
					retCode = PARSER_OUTOFMEMORY;
					bContinue = FALSE;
				}

				// If list format explicitly specified then do not set 
				// default format.
				bSetDefaultFormat = FALSE;

				// Get all the properties from alias definition for the format 
				// specified
				if (bContinue)
				{
					// no more tokens are present.
					if (!GetNextToken(cvTokens, theIterator))
					{
						bContinue = FALSE;
						retCode = PARSER_EXECCOMMAND;
					}
					else
						rParsedInfo.GetHelpInfoObject().SetHelp(
												  LISTSwitchesOnly, TRUE);
				}
			}
			
			if (bContinue == TRUE )
			{
				if ( IsOption(*theIterator) )
				{
					retCode = IsHelp(cvTokens, theIterator,	rParsedInfo, LISTVerb,
									IDS_E_INVALID_EXPRESSION, LEVEL_TWO);

					// If more tokens are present.
					if (retCode == PARSER_CONTINUE)
					{
						BOOL bFormatSwitchSpecified; 
						// Parse for LIST switches.
						retCode = ParseLISTSwitches(cvTokens, theIterator, 
													rParsedInfo, 
													bFormatSwitchSpecified);
						// If /format is specified in list switches then 
						// do not set default format.
						if ( bFormatSwitchSpecified == TRUE )
							bSetDefaultFormat = FALSE;
					}
					else if ( retCode == PARSER_DISPHELP )
					{
						if ( rParsedInfo.GetHelpInfoObject().
									GetHelp(LISTSwitchesOnly) == FALSE )
						{
							hr = m_CmdAlias.PopulateAliasFormatMap(
																 rParsedInfo);
							ONFAILTHROWERROR(hr);
						}
					}
				}
				else
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(IDS_E_INVALID_LIST_EXPRESSION);
					retCode = PARSER_ERROR;
				}
			}
		}
	}

	if (retCode == PARSER_EXECCOMMAND)
	{
		// Obtain all properties from alias definition
		if (!m_CmdAlias.ObtainAliasFormat(rParsedInfo))
		{
			// If failed to obtain the alias properties return PARSER_ERROR
			if (rParsedInfo.GetCmdSwitchesObject().GetErrataCode() == 0)
			{
				rParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(IDS_E_INVALID_LIST_FORMAT);
			}
			retCode = PARSER_ERROR;
		}

		if ( bSetDefaultFormat == TRUE )
		{
			rParsedInfo.GetCmdSwitchesObject().ClearXSLTDetailsVector();
			XSLTDET xdXSLTDet;
			g_wmiCmd.GetFileFromKey(CLI_TOKEN_TABLE, xdXSLTDet.FileName);
			if (!FrameFileAndAddToXSLTDetVector(xdXSLTDet, rParsedInfo))
				retCode = PARSER_ERRMSG;
		}
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseASSOCVerb
   Synopsis	         :This function parses the tokens following the ASSOC verb
					  and updates the info in CParsedInfo.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseASSOCVerb(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseASSOCVerb(CHARVECTOR& cvTokens,
									CHARVECTOR::iterator& theIterator,
									CParsedInfo& rParsedInfo)
{
	RETCODE retCode		= PARSER_EXECCOMMAND;
	BOOL	bContinue	= TRUE;
	
	// Move to next token
	if (!GetNextToken(cvTokens, theIterator))
	{
		retCode = PARSER_EXECCOMMAND;
	}
	// If it is followed by a ":" <assoc format specifier is given
	// Move to next token
	else
	{
		if (CompareTokens(*theIterator, CLI_TOKEN_COLON))
		{
			// Move to next token
			if (!GetNextToken(cvTokens, theIterator))
			{
				// PARSER_ERROR if <format specifier> is missing
				rParsedInfo.GetCmdSwitchesObject().
					SetErrataCode(IDS_E_INVALID_ASSOC_FORMATSPECIFIER);
				retCode = PARSER_ERROR;
			}
			else if (IsOption(*theIterator))
			{
				rParsedInfo.GetCmdSwitchesObject().
					SetErrataCode(IDS_E_INVALID_ASSOC_FORMATSPECIFIER);
				retCode = PARSER_ERROR;
			}
			else 
			{
				rParsedInfo.GetCmdSwitchesObject().ClearXSLTDetailsVector();
				
				BOOL	bFrameXSLFile = TRUE;
				XSLTDET xdXSLTDet;
				xdXSLTDet.FileName = *theIterator;
				if(!g_wmiCmd.GetFileFromKey(*theIterator, xdXSLTDet.FileName))
					bFrameXSLFile	= FALSE;
				
				if ( bFrameXSLFile == TRUE )
				{
					if (!FrameFileAndAddToXSLTDetVector(xdXSLTDet, 
															 rParsedInfo))
						retCode = PARSER_ERRMSG;
				}
				else
					rParsedInfo.GetCmdSwitchesObject().
									AddToXSLTDetailsVector(xdXSLTDet);
			}

			GetNextToken(cvTokens, theIterator);
			rParsedInfo.GetHelpInfoObject().SetHelp(ASSOCSwitchesOnly, TRUE);

		}///END for check of ":"
		
		if ( retCode == PARSER_EXECCOMMAND && 
			 theIterator < cvTokens.end() )
		{
			if (IsOption(*theIterator)) 
			{
				retCode = IsHelp(cvTokens, theIterator, rParsedInfo, ASSOCVerb,
					IDS_E_INVALID_COMMAND,LEVEL_TWO);
				
				// If more tokens are present.
				if (retCode == PARSER_CONTINUE)
				{
					//Parse for Assoc switches.
					retCode = ParseAssocSwitches(cvTokens, theIterator, 
						rParsedInfo);
				}
			}
			else
			{
				rParsedInfo.GetCmdSwitchesObject().
					SetErrataCode(IDS_E_INVALID_ASSOC_SYNTAX);
				retCode = PARSER_ERROR;
			}
		}
	}

	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseCALLVerb
   Synopsis	         :This function parses the tokens following the CALL verb
					  and updates the info in CParsedInfo.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseCALLVerb(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseCALLVerb(CHARVECTOR& cvTokens,
									CHARVECTOR::iterator& theIterator, 
									CParsedInfo& rParsedInfo)
{
	RETCODE		retCode		= PARSER_EXECCOMMAND;
	BOOL		bContinue	= TRUE;
	
	// Move to next token
	retCode = GetNextToken(cvTokens, theIterator, rParsedInfo,
						CALLVerb, IDS_E_INCOMPLETE_COMMAND);

	if (retCode == PARSER_CONTINUE)
	{
		if (IsOption(*theIterator)) 
		{
			retCode = IsHelp(cvTokens, theIterator, rParsedInfo, CALLVerb, 
										IDS_E_INVALID_EXPRESSION, LEVEL_TWO);
			if (retCode != PARSER_CONTINUE)
			{
				if (retCode == PARSER_DISPHELP)
				{
					if(m_bAliasName)
					{
						if (FAILED(m_CmdAlias.ObtainAliasVerbDetails(rParsedInfo)))
							retCode = PARSER_ERRMSG;			
					}
					else 
					{
						if (!ObtainClassMethods(rParsedInfo))
							retCode = PARSER_ERRMSG;
					}
				}
			}
			else
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
										  IDS_E_VERB_OR_METHOD_NOT_SPECIFIED);
				retCode = PARSER_ERROR;
/*				theIterator = theIterator-2;
				retCode = PARSER_EXECCOMMAND;
*/			}
		}
		else
		{
			retCode = ParseMethodInfo(cvTokens, theIterator, rParsedInfo);
			if (retCode == PARSER_CONTINUE)
				retCode = PARSER_EXECCOMMAND;
		}
	}
	else if (retCode == PARSER_DISPHELP)
	{
		if(m_bAliasName)
		{
			if (FAILED(m_CmdAlias.ObtainAliasVerbDetails(rParsedInfo)))
				retCode = PARSER_ERRMSG;			
		}
		else 
		{
			if (!ObtainClassMethods(rParsedInfo))
				retCode = PARSER_ERRMSG;
		}
	}

	return retCode;
}


/*----------------------------------------------------------------------------
   Name				 :ParseGlobalSwitches
   Synopsis	         :This function does the parsing and interprets if command
					  has global switches specified  in it. It parses the 
					  remaining tokens following and updates the same in 
					  CParsedInfo.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseGlobalSwitches(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseGlobalSwitches(CHARVECTOR& cvTokens,
											CHARVECTOR::iterator& theIterator,
											CParsedInfo &rParsedInfo)
{
	RETCODE retCode					= PARSER_CONTINUE;
	BOOL	bContinue				= TRUE;
	BOOL	bPassFlag				= FALSE;
	BOOL	bUserFlag				= FALSE;
	BOOL	bOpenOutFileInWriteMode	= FALSE;
	
	while (TRUE)
	{
		// Move to next token
		retCode = GetNextToken(cvTokens, theIterator, rParsedInfo,
											IDS_E_INVALID_GLOBAL_SWITCH);
		if (retCode != PARSER_CONTINUE)
			break;
			
		// Check for the presence of NAMESPACE global switch
		if (CompareTokens(*theIterator, CLI_TOKEN_NAMESPACE)) 
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator, 
											IDS_E_INCORRECT_NAMESPACE,
											rParsedInfo,
											IDS_E_INVALID_NAMESPACE_SYNTAX,
											Namespace);
			if (retCode == PARSER_CONTINUE)
			{
				LONG lPresNamespaceLen = 
				  lstrlen(rParsedInfo.GetGlblSwitchesObject().GetNameSpace());
				LONG lUserInputNamespaceLen = lstrlen(*theIterator);
				_TCHAR *pszNamespaceToBeUpdated = new _TCHAR[
						// +2 for '\' and '\0' 
						lUserInputNamespaceLen + lPresNamespaceLen + 2];
				if (pszNamespaceToBeUpdated == NULL)
					throw OUT_OF_MEMORY;

				lstrcpy(pszNamespaceToBeUpdated,
					    rParsedInfo.GetGlblSwitchesObject().GetNameSpace());

				FrameNamespace(*theIterator, pszNamespaceToBeUpdated);

				if (!CompareTokens(pszNamespaceToBeUpdated, CLI_TOKEN_NULL) &&
					rParsedInfo.GetGlblSwitchesObject().
						GetInteractiveStatus() == TRUE)
				{
					if (!ValidateNodeOrNS(pszNamespaceToBeUpdated, FALSE)) 
					{
						rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(IDS_E_INVALID_NAMESPACE);
						retCode = PARSER_ERROR;
						break;
					}
				}

				if(!rParsedInfo.GetGlblSwitchesObject().
					SetNameSpace(pszNamespaceToBeUpdated))
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(OUT_OF_MEMORY);
					retCode = PARSER_OUTOFMEMORY;
					break;
				}

				SAFEDELETE(pszNamespaceToBeUpdated);
			}
			else
				break;
		}
		// Check for the presence of ROLE global switch
		else if (CompareTokens(*theIterator, CLI_TOKEN_ROLE)) 
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator, 
											IDS_E_INVALID_ROLE,
											rParsedInfo,
											IDS_E_INVALID_ROLE_SYNTAX,
											Role);
			if (retCode == PARSER_CONTINUE)
			{
				LONG lPresRoleLen = 
				  lstrlen(rParsedInfo.GetGlblSwitchesObject().GetRole());
				LONG lUserInputRoleLen = lstrlen(*theIterator);
				_TCHAR *pszRoleToBeUpdated = new _TCHAR[ 
										// +2 one for '\' and one for '\0'
										lPresRoleLen + lUserInputRoleLen + 2];
				if (pszRoleToBeUpdated == NULL)
					throw OUT_OF_MEMORY;

				lstrcpy(pszRoleToBeUpdated,
					    rParsedInfo.GetGlblSwitchesObject().GetRole());

				FrameNamespace(*theIterator, pszRoleToBeUpdated);

				if (!CompareTokens(pszRoleToBeUpdated, CLI_TOKEN_NULL) &&
					rParsedInfo.GetGlblSwitchesObject().
						GetInteractiveStatus() == TRUE)
				{
					if (!ValidateNodeOrNS(pszRoleToBeUpdated, FALSE))
					{
						rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(IDS_E_INVALID_ROLE);
						retCode = PARSER_ERROR;
						break;
					}
				}

				if(!rParsedInfo.GetGlblSwitchesObject().
						SetRole(pszRoleToBeUpdated))
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(OUT_OF_MEMORY);
					retCode = PARSER_OUTOFMEMORY;
					break;
				}
				SAFEDELETE(pszRoleToBeUpdated);
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_NODE)) 
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator, 
											IDS_E_INVALID_MACHINE_NAME,
											rParsedInfo,
											IDS_E_INVALID_NODE_SYNTAX,
											Node);

			if (retCode == PARSER_CONTINUE)
			{
				BOOL bBreakOuterLoop = FALSE;
				BOOL bGetValidNode = FALSE;
				BOOL bNodeListCleared = FALSE;

				while ( TRUE )
				{
					try
					{
						CHString chsNodeName(*theIterator);
						chsNodeName.TrimLeft();
						chsNodeName.TrimRight();

						lstrcpy(*theIterator, (LPCWSTR) chsNodeName);
					}
					catch(CHeap_Exception)
					{
						_com_issue_error(WBEM_E_OUT_OF_MEMORY);
					}

					if ( *theIterator[0] == _T('@') )
					{
						retCode = ParseNodeListFile(cvTokens, theIterator, 
													rParsedInfo);
						if ( retCode != PARSER_CONTINUE )
						{
							bBreakOuterLoop = TRUE;
							break;
						}
					}

					// If interactive mode then check for the validity of 
					// nodes
					if(rParsedInfo.GetGlblSwitchesObject().
									GetInteractiveStatus())
					{
						BOOL bNodeExist		= TRUE;
						if ( rParsedInfo.GetGlblSwitchesObject().
													   GetFailFast() == TRUE )
						{
							bNodeExist = 
							IsFailFastAndNodeExist(rParsedInfo, *theIterator);
						}
						else
							bNodeExist = ValidateNodeOrNS(*theIterator, TRUE);

						if( bNodeExist == FALSE)
						{
							// Display error message for invalid node
							DisplayString(IDS_E_INVALID_NODE, 
									::GetOEMCP(), *theIterator, TRUE);
							if ( !GetNextToken(cvTokens, theIterator))
							{
								// If no more tokens are present then stop
								// further processing
								bBreakOuterLoop = TRUE;
								break;
							}
							else
							{
								// If multiple nodes are defined then check 
								// tokens
								if (CompareTokens(*theIterator, 
											CLI_TOKEN_COMMA))
								{
									// If invalid node syntax given then report
									// error
									if ( !GetNextToken(cvTokens, theIterator) )
									{
										rParsedInfo.GetCmdSwitchesObject().
											SetErrataCode(IDS_E_INVALID_NODE_SYNTAX);
										retCode=PARSER_ERROR;
										bBreakOuterLoop = TRUE;
										break;
									}
									else if ( IsOption (*theIterator) )
									{
										rParsedInfo.GetCmdSwitchesObject().
											SetErrataCode(IDS_E_INVALID_NODE_SYNTAX);
										retCode=PARSER_ERROR;
										bBreakOuterLoop = TRUE;
										break;
									}

									//Skip adding this invalid node to node list
									continue;
								}
								else
								{
									// If no more node present
									theIterator--;
									break;
								}
							}
						}
						else
							// Set flag for valid node
							bGetValidNode = TRUE;

						// If valid node(s) are present and list is not 
						// already cleared then clear it
						if(bGetValidNode && !bNodeListCleared)
						{
							if (!rParsedInfo.GetGlblSwitchesObject().
									ClearNodesList())
							{
								rParsedInfo.GetCmdSwitchesObject().
											SetErrataCode(OUT_OF_MEMORY);
								retCode = PARSER_OUTOFMEMORY;
								break;
							}
							bNodeListCleared = TRUE;
						}
					}
					else if( bNodeListCleared == FALSE )
					{
						// If not in interactive mode then clear
						// previous node list
						if (!rParsedInfo.GetGlblSwitchesObject().
								ClearNodesList())
						{
							rParsedInfo.GetCmdSwitchesObject().
										SetErrataCode(OUT_OF_MEMORY);
							retCode = PARSER_OUTOFMEMORY;
							break;
						}
						bNodeListCleared = TRUE;
					}
					
					if (rParsedInfo.GetGlblSwitchesObject().
										AddToNodesList(*theIterator))
					{
						if ( GetNextToken(cvTokens, theIterator) )
						{
							if (CompareTokens(*theIterator, CLI_TOKEN_COMMA))
							{
								if ( !GetNextToken(cvTokens, theIterator) )
								{
									rParsedInfo.GetCmdSwitchesObject().
											SetErrataCode(IDS_E_INVALID_NODE_SYNTAX);
									retCode=PARSER_ERROR;
									bBreakOuterLoop = TRUE;
								}
								else if ( IsOption (*theIterator) )
								{
									rParsedInfo.GetCmdSwitchesObject().
											SetErrataCode(IDS_E_INVALID_NODE_SYNTAX);
									retCode=PARSER_ERROR;
									bBreakOuterLoop = TRUE;
								}
							}
							else
							{
								theIterator--;
								break;
							}
						}
						else
							bBreakOuterLoop = TRUE;
					}
					else
					{
						rParsedInfo.GetCmdSwitchesObject().
										SetErrataCode(OUT_OF_MEMORY);
						retCode = PARSER_OUTOFMEMORY;
						bBreakOuterLoop = FALSE;
					}

					if ( bBreakOuterLoop == TRUE )
						break;
				}

				if ( bBreakOuterLoop == TRUE )
					break;
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_IMPLEVEL)) 
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator, 
											IDS_E_INVALID_IMP_LEVEL,
											rParsedInfo,
											IDS_E_INVALID_IMP_LEVEL_SYNTAX,
											Level);
			if (retCode == PARSER_CONTINUE)
			{
				if (!rParsedInfo.GetGlblSwitchesObject().
								SetImpersonationLevel(*theIterator))
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(IDS_E_INVALID_IMP_LEVEL);
					retCode = PARSER_ERROR;
					break;
				}
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_AUTHLEVEL)) 
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator, 
											IDS_E_INVALID_AUTH_LEVEL,
											rParsedInfo,
											IDS_E_INVALID_AUTH_LEVEL_SYNTAX,
											AuthLevel);

			if (retCode == PARSER_CONTINUE)
			{
				if (!rParsedInfo.GetGlblSwitchesObject().
							SetAuthenticationLevel(*theIterator))
				{
					rParsedInfo.GetCmdSwitchesObject().
						SetErrataCode(IDS_E_INVALID_AUTH_LEVEL);
					retCode = PARSER_ERROR;
					break;
				}
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_LOCALE)) 
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator,
										IDS_E_INVALID_LOCALE,
										rParsedInfo,
										IDS_E_INVALID_LOCALE_SYNTAX,
										Locale);
			if (retCode == PARSER_CONTINUE)
			{
				if(!rParsedInfo.GetGlblSwitchesObject().SetLocale(*theIterator))
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(OUT_OF_MEMORY);
					retCode = PARSER_OUTOFMEMORY;
					break;
				}
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_PRIVILEGES))
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator,
										IDS_E_INVALID_PRIVILEGES_OPTION,
										rParsedInfo,
										IDS_E_INVALID_PRIVILEGES_SYNTAX,
										Privileges);
			if (retCode == PARSER_CONTINUE)
			{
				if (CompareTokens(*theIterator, CLI_TOKEN_ENABLE))
					 rParsedInfo.GetGlblSwitchesObject().SetPrivileges(TRUE);
				else if (CompareTokens(*theIterator, CLI_TOKEN_DISABLE))
					 rParsedInfo.GetGlblSwitchesObject().SetPrivileges(FALSE);
				else
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											IDS_E_INVALID_PRIVILEGES_OPTION);
					retCode = PARSER_ERROR;
					break;
				}
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_TRACE)) 
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator, 
											IDS_E_INVALID_TRACE_OPTION,
											rParsedInfo,
											IDS_E_INVALID_TRACE_SYNTAX,
											Trace);
			if (retCode == PARSER_CONTINUE)
			{
				if (CompareTokens(*theIterator, CLI_TOKEN_ON)) 
					rParsedInfo.GetGlblSwitchesObject().SetTraceMode(TRUE);
				else if (CompareTokens(*theIterator, CLI_TOKEN_OFF)) 
					rParsedInfo.GetGlblSwitchesObject().SetTraceMode(FALSE);
				else
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											IDS_E_INVALID_TRACE_OPTION);
					retCode = PARSER_ERROR;
					break;
				}
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_RECORD)) 
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator, 
												IDS_E_INVALID_RECORD_PATH,
												rParsedInfo,
												IDS_E_INVALID_RECORD_SYNTAX,
												RecordPath);
			if (retCode == PARSER_CONTINUE)
			{
				// TRUE for getting output file name.
				_TCHAR* pszOutputFileName = rParsedInfo.
									GetGlblSwitchesObject().
									GetOutputOrAppendFileName(TRUE);

				if ( pszOutputFileName != NULL &&
					 CompareTokens(*theIterator, pszOutputFileName) )
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
								   IDS_E_RECORD_FILE_ALREADY_OPEN_FOR_OUTPUT);
					retCode = PARSER_ERROR;
					break;
				}

				// FALSE for getting append file name.
				_TCHAR* pszAppendFileName = rParsedInfo.
									GetGlblSwitchesObject().
									GetOutputOrAppendFileName(FALSE);

				if ( pszAppendFileName != NULL &&
					 CompareTokens(*theIterator, pszAppendFileName) )
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
								   IDS_E_RECORD_FILE_ALREADY_OPEN_FOR_APPEND);
					retCode = PARSER_ERROR;
					break;
				}

				// /record:"" indicates stop logging.
				if (!CompareTokens(*theIterator, CLI_TOKEN_NULL))
				{
					if ( IsValidFile(*theIterator) == FALSE )
					{
						rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
													  IDS_E_INVALID_FILENAME);
						retCode = PARSER_ERROR;
						break;
					}
				}

				if(!rParsedInfo.GetGlblSwitchesObject().
									SetRecordPath(*theIterator))
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(OUT_OF_MEMORY);
					retCode = PARSER_OUTOFMEMORY;
					break;
				}
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_INTERACTIVE)) 
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator, 
											IDS_E_INVALID_INTERACTIVE_OPTION,
											rParsedInfo,
											IDS_E_INVALID_INTERACTIVE_SYNTAX,
											Interactive);
			if (retCode == PARSER_CONTINUE)
			{
				if (CompareTokens(*theIterator, CLI_TOKEN_ON))
				{
					if (rParsedInfo.GetGlblSwitchesObject().GetInteractiveStatus())
					{
						rParsedInfo.GetCmdSwitchesObject().
							SetInformationCode(IDS_I_INTERACTIVE_ALREADY_SET);
						
					}
					else
						rParsedInfo.GetCmdSwitchesObject().
							SetInformationCode(IDS_I_INTERACTIVE_SET);
					rParsedInfo.GetGlblSwitchesObject().SetInteractiveMode(TRUE);
						
				}
				else if (CompareTokens(*theIterator, CLI_TOKEN_OFF)) 
				{
					if (!rParsedInfo.GetGlblSwitchesObject().GetInteractiveStatus())
					{
						rParsedInfo.GetCmdSwitchesObject().
							SetInformationCode(IDS_I_INTERACTIVE_ALREADY_RESET);
						
					}
					else
						rParsedInfo.GetCmdSwitchesObject().
							SetInformationCode(IDS_I_INTERACTIVE_RESET);
					rParsedInfo.GetGlblSwitchesObject().SetInteractiveMode(FALSE);
				
				}
				else
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
						IDS_E_INVALID_INTERACTIVE_OPTION);
					retCode = PARSER_ERROR;
					break;
				}
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_FAILFAST))
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator, 
											IDS_E_INVALID_FAILFAST_OPTION,
											rParsedInfo,
											IDS_E_INVALID_FAILFAST_SYNTAX,
											FAILFAST);
			if (retCode == PARSER_CONTINUE)
			{
				if (CompareTokens(*theIterator, CLI_TOKEN_ON))
				{
					if (rParsedInfo.GetGlblSwitchesObject().GetFailFast())
					{
						rParsedInfo.GetCmdSwitchesObject().
							SetInformationCode(IDS_I_FAILFAST_ALREADY_SET);
						
					}
					else
						rParsedInfo.GetCmdSwitchesObject().
							SetInformationCode(IDS_I_FAILFAST_SET);
					rParsedInfo.GetGlblSwitchesObject().SetFailFast(TRUE);
						
				}
				else if (CompareTokens(*theIterator, CLI_TOKEN_OFF)) 
				{
					if (!rParsedInfo.GetGlblSwitchesObject().GetFailFast())
					{
						rParsedInfo.GetCmdSwitchesObject().
							SetInformationCode(IDS_I_FAILFAST_ALREADY_RESET);
						
					}
					else
						rParsedInfo.GetCmdSwitchesObject().
							SetInformationCode(IDS_I_FAILFAST_RESET);
					rParsedInfo.GetGlblSwitchesObject().SetFailFast(FALSE);
				
				}
				else
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
						IDS_E_INVALID_FAILFAST_OPTION);
					retCode = PARSER_ERROR;
					break;
				}
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_USER)) 
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator, 
												IDS_E_INVALID_USER_ID,
												rParsedInfo,
												IDS_E_INVALID_USER_SYNTAX,
												User);
			if (retCode == PARSER_CONTINUE)
			{
				if(!rParsedInfo.GetGlblSwitchesObject().SetUser(*theIterator))
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(OUT_OF_MEMORY);
					retCode = PARSER_OUTOFMEMORY;
					break;
				}

				bUserFlag = TRUE;
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_PASSWORD)) 
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator,
												IDS_E_INVALID_PASSWORD,
												rParsedInfo,
												IDS_E_INVALID_PASSWORD_SYNTAX,
												Password);
			if (retCode == PARSER_CONTINUE)
			{
				if(!rParsedInfo.GetGlblSwitchesObject().SetPassword(*theIterator))
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(OUT_OF_MEMORY);
					retCode=PARSER_OUTOFMEMORY;
					break;
				}

				bPassFlag = TRUE;
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_OUTPUT))
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator,
										IDS_E_INVALID_OUTPUT_OPTION,
										rParsedInfo,
										IDS_E_INVALID_OUTPUT_SYNTAX,
										OUTPUT);
			if (retCode == PARSER_CONTINUE)
			{
				rParsedInfo.GetCmdSwitchesObject().SetOutputSwitchFlag(TRUE);

				if (CompareTokens(*theIterator, CLI_TOKEN_STDOUT))
				{

					// TRUE for setting output file.
					rParsedInfo.GetGlblSwitchesObject().SetOutputOrAppendOption(
																   STDOUT, TRUE);
					rParsedInfo.GetGlblSwitchesObject().
										SetOutputOrAppendFileName(NULL, TRUE);
				}
				else if (CompareTokens(*theIterator, CLI_TOKEN_CLIPBOARD))
				{
					// TRUE for setting output file.
					rParsedInfo.GetGlblSwitchesObject().SetOutputOrAppendOption(
																   CLIPBOARD, TRUE);
					rParsedInfo.GetGlblSwitchesObject().
										SetOutputOrAppendFileName(NULL, TRUE);
				}
				else if ( CompareTokens(*theIterator, CLI_TOKEN_NULL))
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
												  IDS_E_INVALID_FILENAME);
					retCode = PARSER_ERROR;
					break;
				}
				else
				{
					// FALSE for getting append file name.
					_TCHAR* pszAppendFileName = rParsedInfo.
										GetGlblSwitchesObject().
										GetOutputOrAppendFileName(FALSE);

					if ( pszAppendFileName != NULL &&
						 CompareTokens(*theIterator, pszAppendFileName) )
					{
						rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
								   IDS_E_OUTPUT_FILE_ALREADY_OPEN_FOR_APPEND);
						retCode = PARSER_ERROR;
						break;
					}

					_TCHAR* pszRecordFileName = rParsedInfo.
										GetGlblSwitchesObject().
										GetRecordPath();

					if ( pszRecordFileName != NULL &&
						 CompareTokens(*theIterator, pszRecordFileName) )
					{
						rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
								   IDS_E_OUTPUT_FILE_ALREADY_OPEN_FOR_RECORD);
						retCode = PARSER_ERROR;
						break;
					}

					if ( CloseOutputFile() == TRUE ) 
					{
						// TRUE for getting output file name.
						_TCHAR* pszOutputFileName = rParsedInfo.
											GetGlblSwitchesObject().
											GetOutputOrAppendFileName(TRUE);

						if ( pszOutputFileName == NULL ||
							 ( pszOutputFileName != NULL &&
							   !CompareTokens(*theIterator, pszOutputFileName)))
						{
							retCode = IsValidFile(*theIterator);
							if ( retCode == PARSER_ERROR )
							{
								rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
															  IDS_E_INVALID_FILENAME);
								break;
							}
							else if ( retCode == PARSER_ERRMSG )
								break;
						}
					}
					else
					{
						retCode = PARSER_ERRMSG;
						break;
					}
										 
					// TRUE for setting output file.
					if(!rParsedInfo.GetGlblSwitchesObject().
									SetOutputOrAppendFileName(*theIterator, TRUE))
					{
						rParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(OUT_OF_MEMORY);
						retCode=PARSER_OUTOFMEMORY;
						break;
					}
					rParsedInfo.GetGlblSwitchesObject().SetOutputOrAppendOption(FILEOUTPUT,
																				TRUE);
					bOpenOutFileInWriteMode = TRUE;
				}
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_APPEND))
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator,
										IDS_E_INVALID_APPEND_OPTION,
										rParsedInfo,
										IDS_E_INVALID_APPEND_SYNTAX,
										APPEND);
			if (retCode == PARSER_CONTINUE)
			{
				if ( CompareTokens(*theIterator, CLI_TOKEN_STDOUT) )
				{
					// FALSE for setting append file.
					 rParsedInfo.GetGlblSwitchesObject().
									 SetOutputOrAppendFileName(NULL, FALSE);
					rParsedInfo.GetGlblSwitchesObject().SetOutputOrAppendOption(STDOUT,
																				FALSE);

				}
				else if ( CompareTokens(*theIterator, CLI_TOKEN_CLIPBOARD) )
				{
					// FALSE for setting append file.
					 rParsedInfo.GetGlblSwitchesObject().
									 SetOutputOrAppendFileName(NULL, FALSE);
					rParsedInfo.GetGlblSwitchesObject().SetOutputOrAppendOption(CLIPBOARD,
																				FALSE);
				}
				else if ( CompareTokens(*theIterator, CLI_TOKEN_NULL))
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
												  IDS_E_INVALID_FILENAME);
					retCode = PARSER_ERROR;
					break;
				}
				else
				{
					// TRUE for getting output file name.
					_TCHAR* pszOutputFileName = rParsedInfo.
										GetGlblSwitchesObject().
										GetOutputOrAppendFileName(TRUE);
					if ( pszOutputFileName != NULL &&
						 CompareTokens(*theIterator, pszOutputFileName) )
					{
						rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
								   IDS_E_APPEND_FILE_ALREADY_OPEN_FOR_OUTPUT);
						retCode = PARSER_ERROR;
						break;
					}
					
					_TCHAR* pszRecordFileName = rParsedInfo.
										GetGlblSwitchesObject().
										GetRecordPath();

					if ( pszRecordFileName != NULL &&
						 CompareTokens(*theIterator, pszRecordFileName) )
					{
						rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
								   IDS_E_APPEND_FILE_ALREADY_OPEN_FOR_RECORD);
						retCode = PARSER_ERROR;
						break;
					}

					if ( CloseAppendFile() == TRUE )
					{
						// FALSE for getting append file name.
						_TCHAR* pszAppendFileName = rParsedInfo.
											GetGlblSwitchesObject().
											GetOutputOrAppendFileName(FALSE);

						if ( pszAppendFileName == NULL ||
							 ( pszAppendFileName != NULL &&
							   !CompareTokens(*theIterator, pszAppendFileName)))
						{
							retCode = IsValidFile(*theIterator);
							if ( retCode == PARSER_ERROR )
							{
								rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
															  IDS_E_INVALID_FILENAME);
								break;
							}
							else if ( retCode == PARSER_ERRMSG )
								break;
						}
					}
					else
					{
						retCode = PARSER_ERRMSG;
						break;
					}

					// FALSE for setting append file.
					 if (!rParsedInfo.GetGlblSwitchesObject().
							   SetOutputOrAppendFileName(*theIterator, FALSE))
					{
						rParsedInfo.GetCmdSwitchesObject().
												 SetErrataCode(OUT_OF_MEMORY);
						retCode = PARSER_OUTOFMEMORY;
						break;
					}
					rParsedInfo.GetGlblSwitchesObject().SetOutputOrAppendOption(FILEOUTPUT,
																				FALSE);

				}
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator,CLI_TOKEN_AGGREGATE))
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator,
										IDS_E_INVALID_AGGREGATE_OPTION,
										rParsedInfo,
										IDS_E_INVALID_AGGREGATE_SYNTAX,
										Aggregate);
			if(retCode == PARSER_CONTINUE)
			{
				if(CompareTokens(*theIterator, CLI_TOKEN_ON))
					rParsedInfo.GetGlblSwitchesObject().SetAggregateFlag(TRUE);
				else if(CompareTokens(*theIterator, CLI_TOKEN_OFF))
					rParsedInfo.GetGlblSwitchesObject().SetAggregateFlag(FALSE);
				else
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											IDS_E_INVALID_AGGREGATE_OPTION);
					retCode = PARSER_ERROR;
					break;
					}
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_HELP)) 
		{
			retCode = ParseHelp(cvTokens, theIterator, rParsedInfo, TRUE);
			break;
		}
		else 
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
												IDS_E_INVALID_GLOBAL_SWITCH);
			retCode = PARSER_ERROR;
			break;
		}

		// Move to next token
		if (!GetNextToken(cvTokens, theIterator))
			// Break the loop if no more tokens are present
			break;
		// Break the loop if no more global switches are present
		if (!IsOption(*theIterator)) 
			break;
	} 

	if ( bUserFlag == TRUE && bPassFlag == FALSE )
		rParsedInfo.GetGlblSwitchesObject().SetAskForPassFlag(TRUE);

	if ( rParsedInfo.GetGlblSwitchesObject().GetPassword() != NULL &&
		 rParsedInfo.GetGlblSwitchesObject().GetUser() == NULL )
	{
		rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
									IDS_E_PASSWORD_WITHOUT_USER);
		rParsedInfo.GetGlblSwitchesObject().SetPassword(CLI_TOKEN_NULL);
		retCode = PARSER_ERROR;
	}
	
	if ( retCode == PARSER_CONTINUE &&
		 bOpenOutFileInWriteMode == TRUE )
		retCode = ProcessOutputAndAppendFiles(rParsedInfo, retCode, TRUE);

	return retCode;
}
/*----------------------------------------------------------------------------
   Name				 :ParseGETSwitches
   Synopsis	         :This function does the parsing and interprets if command
					  has GET as the verb. It parses the remaining tokens 
					  following and updates the same in CParsedInfo.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseGETSwitches(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseGETSwitches(CHARVECTOR& cvTokens,
										CHARVECTOR::iterator& theIterator,
										CParsedInfo& rParsedInfo)
{
	RETCODE		retCode		= PARSER_EXECCOMMAND;
	BOOL		bContinue	= TRUE;

	while ( retCode == PARSER_EXECCOMMAND )
	{
		// Check for the presence of VALUE switch
		if (CompareTokens(*theIterator, CLI_TOKEN_VALUE)) 
		{
			rParsedInfo.GetCmdSwitchesObject().ClearXSLTDetailsVector();
			XSLTDET xdXSLTDet;
			g_wmiCmd.GetFileFromKey(CLI_TOKEN_VALUE, xdXSLTDet.FileName);
			if (!FrameFileAndAddToXSLTDetVector(xdXSLTDet, rParsedInfo))
				retCode = PARSER_ERRMSG;
		}
		// Check for the presence of ALL switch
		else if (CompareTokens(*theIterator, CLI_TOKEN_ALL)) 
		{	
			rParsedInfo.GetCmdSwitchesObject().ClearXSLTDetailsVector();
			XSLTDET xdXSLTDet;
			g_wmiCmd.GetFileFromKey(CLI_TOKEN_TABLE, xdXSLTDet.FileName);
			if (!FrameFileAndAddToXSLTDetVector(xdXSLTDet, rParsedInfo))
				retCode = PARSER_ERRMSG;
		}
		// Check for the presence of FORMAT switch
		else if (CompareTokens(*theIterator, CLI_TOKEN_FORMAT)) 
		{
			rParsedInfo.GetCmdSwitchesObject().ClearXSLTDetailsVector();
			retCode = ParseFORMATSwitch(cvTokens, theIterator, rParsedInfo);
		}
		// Check for the presence of EVERY switch
		else if (CompareTokens(*theIterator, CLI_TOKEN_EVERY)) 
		{
			retCode = ParseEVERYSwitch(cvTokens, theIterator, rParsedInfo);
		}
		// Check for the presence of TRANSLATE switch
		else if (CompareTokens(*theIterator, CLI_TOKEN_TRANSLATE)) 
		{
			retCode = ParseTRANSLATESwitch(cvTokens, theIterator, rParsedInfo);
		}
		// Check whether /REPEAT follows /EVERY
		else if (CompareTokens(*theIterator, CLI_TOKEN_REPEAT))
		{
			if (!CompareTokens(*(theIterator-4), CLI_TOKEN_EVERY))
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											IDS_I_REPEAT_EVERY_RELATED);
				retCode = PARSER_ERROR;
				break;
			}
		} 
		// Check for the presence of HELP switch
		else if (CompareTokens(*theIterator, CLI_TOKEN_HELP)) 
		{
			rParsedInfo.GetHelpInfoObject().SetHelp(GETSwitchesOnly, TRUE);
			retCode = ParseHelp(cvTokens, theIterator, GETVerb, rParsedInfo);
			if ( retCode == PARSER_DISPHELP )
			{
				if (m_bAliasName)
				{
					if (FAILED(m_CmdAlias.
							ObtainAliasPropDetails(rParsedInfo)))
								retCode = PARSER_ERRMSG;
				}
				else
				{
					if (!ObtainClassProperties(rParsedInfo))
						retCode = PARSER_ERRMSG;
				}
			}
		}
		else
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
										IDS_E_INVALID_GET_SWITCH);
			retCode = PARSER_ERROR;
			break;
		}

		if ( retCode == PARSER_EXECCOMMAND )
		{
			if ( !GetNextToken(cvTokens, theIterator) )
				break;
			
			if ( !IsOption(*theIterator) )
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
													IDS_E_INVALID_COMMAND);
				retCode = PARSER_ERROR;
				break;
			}

			if ( !GetNextToken(cvTokens, theIterator) )
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											IDS_E_INVALID_GET_SWITCH);
				retCode = PARSER_ERROR;
				break;
			}
		}
	}

	return retCode;
}
/*----------------------------------------------------------------------------
   Name				 :ParseLISTSwitches
   Synopsis	         :This function does the parsing and interprets if command
					  has LIST as the verb. It parses the remaining tokens 
					  following and updates the same in CParsedInfo.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseLISTSwitches(cvTokens,theIterator,rParsedInfo,
										bFormatSwitchSpecified)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseLISTSwitches(CHARVECTOR& cvTokens,
										CHARVECTOR::iterator& theIterator,
										CParsedInfo& rParsedInfo,
										BOOL& bFormatSwitchSpecified)
{
	RETCODE retCode = PARSER_EXECCOMMAND;
	bFormatSwitchSpecified = FALSE;

	while ( retCode == PARSER_EXECCOMMAND )
	{
		if (CompareTokens(*theIterator, CLI_TOKEN_TRANSLATE)) 
		{
			retCode = ParseTRANSLATESwitch(cvTokens, theIterator, rParsedInfo);
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_EVERY)) 
		{
			retCode = ParseEVERYSwitch(cvTokens, theIterator, rParsedInfo);
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_FORMAT)) 
		{
			retCode = ParseFORMATSwitch(cvTokens, theIterator, rParsedInfo);
			bFormatSwitchSpecified = TRUE;
		}
		// Check whether /REPEAT follows /EVERY
		else if (CompareTokens(*theIterator, CLI_TOKEN_REPEAT))
		{
			if (!CompareTokens(*(theIterator-4), CLI_TOKEN_EVERY))
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											IDS_I_REPEAT_EVERY_RELATED);
				retCode = PARSER_ERROR;
				break;
			}
		} 
		else if (CompareTokens(*theIterator, CLI_TOKEN_HELP)) 
		{
			rParsedInfo.GetHelpInfoObject().SetHelp(LISTSwitchesOnly, TRUE);
			retCode = ParseHelp(cvTokens, theIterator, LISTVerb, rParsedInfo);
		}
		else
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
										IDS_E_INVALID_LIST_SWITCH);
			retCode = PARSER_ERROR;
			break;
		}

		if ( retCode == PARSER_EXECCOMMAND )
		{
			if ( !GetNextToken(cvTokens, theIterator) )
				break;
			
			if ( !IsOption(*theIterator) )
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
													IDS_E_INVALID_COMMAND);
				retCode = PARSER_ERROR;
				break;
			}

			if ( !GetNextToken(cvTokens, theIterator) )
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											IDS_E_INVALID_LIST_SWITCH);
				retCode = PARSER_ERROR;
				break;
			}
		}
	}

	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseSETorCREATEOrNamedParamInfo
   Synopsis	         :This function does the parsing and interprets if command
					  has SET as the verb. It parses the remaining tokens 
					  following and updates the same in CParsedInfo.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseSETorCREATEOrNamedParamInfo(cvTokens,theIterator,rParsedInfo, helpType)
   Notes             :None
-------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseSETorCREATEOrNamedParamInfo(CHARVECTOR& cvTokens,
										  CHARVECTOR::iterator& theIterator,
										  CParsedInfo& rParsedInfo, 
										  HELPTYPE helpType)
{
	RETCODE retCode		= PARSER_EXECCOMMAND;
	_TCHAR *pszProp,*pszVal;

	try
	{
		// Process the SET|CREATE verb related info i.e properties with new values.
		while (TRUE) 
		{
			pszProp = NULL;
			pszVal	= NULL;

			// Tokenize the expression checking for '='
			pszProp = *theIterator;
			if ( GetNextToken(cvTokens, theIterator) &&
				 CompareTokens(*theIterator, CLI_TOKEN_EQUALTO) &&
				 GetNextToken(cvTokens, theIterator))
				 pszVal	= *theIterator;

			if ((pszProp == NULL) || (pszVal == NULL))
			{
				if ( helpType != CALLVerb &&
					 IsOption(*(theIterator+1)) &&
					 theIterator + 2 < cvTokens.end() &&
					 CompareTokens(*(theIterator+2), CLI_TOKEN_HELP) )
				{
					theIterator++;
					theIterator++;
					retCode = ParseHelp(cvTokens, theIterator, helpType, rParsedInfo);

					if (retCode == PARSER_DISPHELP)
					{
						// Adding to PropertyList only for use in displaying help of 
						// properties
						if(!rParsedInfo.GetCmdSwitchesObject().
												AddToPropertyList(pszProp))
						{
							rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
										IDS_E_ADD_TO_PROP_LIST_FAILURE);
							retCode = PARSER_ERROR;
							break;
						}

						if (m_bAliasName)
						{
							if (FAILED(m_CmdAlias.
									ObtainAliasPropDetails(rParsedInfo)))
										retCode = PARSER_ERRMSG;
						}
						else
						{
							if (!ObtainClassProperties(rParsedInfo))
								retCode = PARSER_ERRMSG;
						}
					}
				}
				else
				{
					UINT nErrID;
					if ( helpType == CALLVerb )
						nErrID = IDS_E_INVALID_NAMED_PARAM_LIST;
					else
						nErrID = IDS_E_INVALID_ASSIGNLIST;
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(nErrID);
					retCode = PARSER_ERROR;
				}

				break;
			}

			// Unquote the strings
			UnQuoteString(pszProp);
			UnQuoteString(pszVal);
			
			// Add to the list of parameters
			if(!rParsedInfo.GetCmdSwitchesObject().
					AddToParameterMap(_bstr_t(pszProp), _bstr_t(pszVal)))
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
									IDS_E_ADD_TO_PARAM_MAP_FAILURE);
				retCode = PARSER_ERROR;
				break;
			}

			// Adding to PropertyList only for use in displaying help of 
			// properties
			if(!rParsedInfo.GetCmdSwitchesObject().
									AddToPropertyList(pszProp))
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
							IDS_E_ADD_TO_PROP_LIST_FAILURE);
				retCode = PARSER_ERROR;
				break;
			}

			// Get the next token
			if (GetNextToken(cvTokens, theIterator))
			{
				// If option (i.e either '/' or '-') specified.
				if (IsOption(*theIterator))
				{
					theIterator--;
					break;
				}
				else
				{
					if ( helpType != CALLVerb )
					{
						// check for the presence of ','
						if (CompareTokens(*theIterator, CLI_TOKEN_COMMA))
						{
							if (!GetNextToken(cvTokens, theIterator))
							{
								rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
										IDS_E_INVALID_ASSIGNLIST);
								retCode = PARSER_ERROR;
								break;
							}
						}
						else
						{
							rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
										IDS_E_INVALID_ASSIGNLIST);
							retCode = PARSER_ERROR;
							break;
						}
					}
				}
			}
			else
			{
				retCode = PARSER_EXECCOMMAND;
				break;
			}
		}
	}
	catch(_com_error& e)
	{
		retCode = PARSER_ERROR;
		_com_issue_error(e.Error());
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseVerbSwitches
   Synopsis	         :This function does the parsing and interprets if command
					  has verb switches specified. It parses the remaining 
					  tokens following and updates the same in CParsedInfo.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseVerbSwitches(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseVerbSwitches(CHARVECTOR& cvTokens, 
										CHARVECTOR::iterator& theIterator,
										CParsedInfo& rParsedInfo)
{
	RETCODE retCode			= PARSER_EXECCOMMAND;
	BOOL bInvalidVerbSwitch = FALSE;

	// Check for the '/' | '-' token
	if (IsOption(*theIterator))
	{
		// Move to next token
		if (!GetNextToken(cvTokens, theIterator))	
			bInvalidVerbSwitch = TRUE;
		else if (CompareTokens(*theIterator, CLI_TOKEN_INTERACTIVE)) 
		{

			rParsedInfo.GetCmdSwitchesObject().
							SetInteractiveMode(INTERACTIVE);

			_TCHAR *pszVerbName = rParsedInfo.GetCmdSwitchesObject().
																GetVerbName(); 
			BOOL bInstanceLevel = TRUE;

			if(CompareTokens(pszVerbName, CLI_TOKEN_CALL) 
				|| CompareTokens(pszVerbName, CLI_TOKEN_SET)
				|| CompareTokens(pszVerbName, CLI_TOKEN_DELETE))
			{
				if(IsClassOperation(rParsedInfo))
				{
					bInstanceLevel = FALSE;
				}
				else
				{
					if(CompareTokens(pszVerbName, CLI_TOKEN_CALL))
					{
						if ( rParsedInfo.GetCmdSwitchesObject().
											GetAliasName() != NULL )
						{
							if (rParsedInfo.GetCmdSwitchesObject().
											GetWhereExpression() == NULL)
							{
								bInstanceLevel = FALSE;
							}
							else
								bInstanceLevel = TRUE;
						}
						else
						{
							if ((rParsedInfo.GetCmdSwitchesObject().
											GetPathExpression() != NULL)
								&& (rParsedInfo.GetCmdSwitchesObject().
											GetWhereExpression() == NULL))
							{
								bInstanceLevel = FALSE;
							}
							else
								bInstanceLevel = TRUE;
						}
					}
					else
						bInstanceLevel = TRUE;
				}
			}
			else
				retCode = PARSER_EXECCOMMAND;

			if(bInstanceLevel)
			{
				retCode = ParseVerbInteractive(	cvTokens, theIterator, 
												rParsedInfo, bInvalidVerbSwitch);
			}
			else
				retCode = PARSER_EXECCOMMAND;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_NONINTERACT)) 
		{
			rParsedInfo.GetCmdSwitchesObject().
							SetInteractiveMode(NOINTERACTIVE);
			retCode = PARSER_EXECCOMMAND;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_HELP)) 
		{
			retCode = ParseHelp(cvTokens, theIterator, VERBSWITCHES, 
								rParsedInfo);
		}
		else
			bInvalidVerbSwitch = TRUE;

		if ( GetNextToken(cvTokens, theIterator ) )
		{
			rParsedInfo.GetCmdSwitchesObject().
										SetErrataCode(IDS_E_INVALID_COMMAND);
			retCode = PARSER_ERROR;
		}

	}
	else
		bInvalidVerbSwitch = TRUE;

	if ( bInvalidVerbSwitch == TRUE )
	{
		// no valid <verb switch> type is specified.
		rParsedInfo.GetCmdSwitchesObject().
				SetErrataCode(IDS_E_INVALID_VERB_SWITCH);
		retCode = PARSER_ERROR;
	}

	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :GetNextToken
   Synopsis	         :This function retrieves the next token from the token 
					  vector list, returns FALSE if no more tokens are present
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
   Output Parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetNextToken(cvTokens,theIterator)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL CParserEngine::GetNextToken(CHARVECTOR& cvTokens, 
								 CHARVECTOR::iterator& theIterator)
{
	theIterator++;
	return (theIterator >= cvTokens.end()) ? FALSE : TRUE;
}

/*----------------------------------------------------------------------------
   Name				 :ParsePWhereExpr
   Synopsis	         :This function does the parsing and interprets if command
					  has Path and Where expression It parses the remaining
					  tokens following and updates the same in CParsedInfo.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ParsePWhereExpr(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL CParserEngine::ParsePWhereExpr(CHARVECTOR& cvTokens,
								   CHARVECTOR::iterator& theIterator,
								   CParsedInfo& rParsedInfo,
								   BOOL bIsParan)
{
	BOOL bRet = TRUE, bContinue = FALSE;

	try
	{		
		while (TRUE)
		{
			if ( bIsParan == TRUE &&
				CompareTokens(*theIterator, CLI_TOKEN_RIGHT_PARAN) )
				break;

			if ( bIsParan == FALSE && 
				 IsStdVerbOrUserDefVerb(*theIterator, rParsedInfo) )
				 break;

			if ( bIsParan == FALSE ||
				 !CompareTokens(*theIterator, CLI_TOKEN_LEFT_PARAN))
			{
				if(!rParsedInfo.GetCmdSwitchesObject().
					AddToPWhereParamsList(*theIterator))
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
								IDS_E_ADD_TO_PARAMS_LIST_FAILURE);
					bRet = FALSE;
					break;
				}
				bContinue = TRUE;
			}

			if (!GetNextToken(cvTokens, theIterator))
				break;

			if ( IsOption(*theIterator) )
			{
				bContinue = FALSE;
				break;
			}
		}

		if(bRet != FALSE && bContinue == TRUE)
		{

			CHARVECTOR theParam = rParsedInfo.GetCmdSwitchesObject().
																GetPWhereParamsList();
			CHARVECTOR::iterator theItr		= theParam.begin();
			_TCHAR pszPWhere[MAX_BUFFER]	= NULL_STRING;
			lstrcpy(pszPWhere, CLI_TOKEN_NULL);
			_TCHAR* pszToken				= NULL;;
			CHString sTemp;
			
			if ((rParsedInfo.GetCmdSwitchesObject().GetPWhereExpr() != NULL)) 
			{
				sTemp.Format(rParsedInfo.GetCmdSwitchesObject().
												GetPWhereExpr());
				sTemp.TrimLeft();
				if(!sTemp.IsEmpty())
				{

					_bstr_t bstrPWhere = _bstr_t(rParsedInfo.
												GetCmdSwitchesObject().
												GetPWhereExpr());
					pszToken = _tcstok((WCHAR*)bstrPWhere, 
										CLI_TOKEN_HASH);
					lstrcpy(pszPWhere, CLI_TOKEN_NULL);

					while (pszToken != NULL)
					{
						lstrcat(pszPWhere, pszToken);
						if (theItr != theParam.end())
						{
						   lstrcat(pszPWhere, *theItr);
						   theItr++;
						}
						pszToken = _tcstok(NULL, CLI_TOKEN_HASH);
					}

					if(bRet != FALSE)
					{
						// Set the classpath and where expression
						pszToken = NULL;
						pszToken = _tcstok(pszPWhere, CLI_TOKEN_SPACE);
						if (pszToken != NULL)
						{
							if (CompareTokens(CLI_TOKEN_FROM, pszToken)) 
							{
								pszToken = _tcstok(NULL, CLI_TOKEN_SPACE);
								if (pszToken != NULL)
								{
									if(!rParsedInfo.GetCmdSwitchesObject().
													SetClassPath(pszToken))
									{
										rParsedInfo.GetCmdSwitchesObject().
												SetErrataCode(OUT_OF_MEMORY);
										bRet = FALSE;
									}

								}
								if(bRet != FALSE)
									pszToken = _tcstok(NULL, CLI_TOKEN_SPACE);
							}
							
							if (CompareTokens(CLI_TOKEN_WHERE, pszToken)) 
							{
								pszToken = _tcstok(NULL, CLI_TOKEN_NULL);
								if (pszToken != NULL)
								{
									if(!rParsedInfo.GetCmdSwitchesObject().
											SetWhereExpression(pszToken))
									{
										rParsedInfo.GetCmdSwitchesObject().
											SetErrataCode(OUT_OF_MEMORY);
										bRet = FALSE;
									}
								}
							}
						}
					}
				}
				else
				{
					rParsedInfo.GetCmdSwitchesObject().
										SetErrataCode(IDS_E_PWHERE_UNDEF);
					bRet = FALSE;
				}
			}
			else
			{
				rParsedInfo.GetCmdSwitchesObject().
									SetErrataCode(IDS_E_PWHERE_UNDEF);
				bRet = FALSE;
			}
		}
		if (!bContinue && bIsParan)
		{
			rParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(IDS_E_INVALID_PWHERE_EXPR);
			bRet = FALSE;
		}
	}
	catch(_com_error& e)
	{
		bRet = FALSE;
		_com_issue_error(e.Error());
	}
	catch(CHeap_Exception)
	{
		bRet = FALSE;
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :ExtractClassNameandWhereExpr
   Synopsis	         :This function takes the input as a path expression and 
					  extracts the Class and Where expression part from the 
					  path expression.
   Type	             :Member Function
   Input Parameter(s):
		pszPathExpr  - the path expression
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ParsePWhereExpr(cvTokens,theIterator)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL CParserEngine::ExtractClassNameandWhereExpr(_TCHAR* pszPathExpr, 
												 CParsedInfo& rParsedInfo)
{
	// Frame the class name and where expression based on the object path
	BOOL	bRet					= TRUE;
	_TCHAR* pszToken				= NULL;
	BOOL	bFirst					= TRUE;
	_TCHAR  pszWhere[MAX_BUFFER]	= NULL_STRING;	
	lstrcpy(pszWhere, CLI_TOKEN_NULL);

	if (pszPathExpr == NULL)
		bRet = FALSE;

	try
	{
		if ( bRet == TRUE )
		{
			lstrcpy(pszWhere, CLI_TOKEN_NULL);
			pszToken = _tcstok(pszPathExpr, CLI_TOKEN_DOT);
			if (pszToken != NULL)
			{
				if(!rParsedInfo.GetCmdSwitchesObject().SetClassPath(pszToken))
				{
					rParsedInfo.GetCmdSwitchesObject().
									SetErrataCode(OUT_OF_MEMORY);
					bRet = FALSE;
				}
			}

			if(bRet != FALSE)
			{
				while (pszToken != NULL)
				{
					pszToken = _tcstok(NULL, CLI_TOKEN_COMMA); 
					if (pszToken != NULL)
					{
						if (!bFirst)
							lstrcat(pszWhere, CLI_TOKEN_AND);
						lstrcat(pszWhere, pszToken);
						bFirst = FALSE;
					}
					else
						break;
				}
				if (lstrlen(pszWhere))
				{
					if(!rParsedInfo.GetCmdSwitchesObject().SetWhereExpression(pszWhere))
					{
						rParsedInfo.GetCmdSwitchesObject().
										SetErrataCode(OUT_OF_MEMORY);
						bRet = FALSE;
					}
				}
			}
		}
	}
	catch(...)
	{
		rParsedInfo.GetCmdSwitchesObject().
						SetErrataCode(IDS_E_INVALID_PATH);
		bRet = FALSE;
	}
	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :GetNextToken
   Synopsis	         :This function retrieves the next token from the token 
					  vector list, returns enumerated return code depending 
					  upon the context.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
		helpType     - enumerated help type 
		uErrataCode  - error string ID.
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type.
   Global Variables  :None
   Calling Syntax    :GetNextToken(cvTokens, theIterator,
								 rParsedInfo, helpType, uErrataCode)
   Notes             :overloaded function
----------------------------------------------------------------------------*/
RETCODE CParserEngine::GetNextToken(CHARVECTOR& cvTokens, 
									CHARVECTOR::iterator& theIterator,
									CParsedInfo& rParsedInfo,
									HELPTYPE helpType,
									UINT uErrataCode)
{
	RETCODE retCode = PARSER_CONTINUE;

	// Move to next token
	theIterator++;

	// If no more tokens are present
	if (theIterator >= cvTokens.end()) 
	{
		// If interactive mode is set
		if (rParsedInfo.GetGlblSwitchesObject().GetInteractiveStatus())
		{
			rParsedInfo.GetGlblSwitchesObject().SetHelpFlag(TRUE);
			rParsedInfo.GetHelpInfoObject().SetHelp(helpType, TRUE);
			retCode = PARSER_DISPHELP;
		}
		else
		{
			// PARSER_ERROR if no more tokens are present. 
			rParsedInfo.GetCmdSwitchesObject().
				SetErrataCode(uErrataCode);
			retCode = PARSER_ERROR;
		}
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :GetNextToken
   Synopsis	         :This function retrieves the next token from the token 
					  vector list, returns enumerated return code depending 
					  upon the context.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
		uErrataCode  - error string ID.
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type.
   Global Variables  :None
   Calling Syntax    :GetNextToken(cvTokens, theIterator,
								   rParsedInfo, uErrataCode)
   Notes             :overloaded function
----------------------------------------------------------------------------*/
RETCODE CParserEngine::GetNextToken(CHARVECTOR& cvTokens,
									CHARVECTOR::iterator& theIterator,
									CParsedInfo& rParsedInfo, 
									UINT uErrataCode)
{
	RETCODE retCode = PARSER_CONTINUE;
	
	// Move to next token
	theIterator++;

	// If no more tokens are present
	if (theIterator >= cvTokens.end()) 
	{
		// PARSER_ERROR if no more tokens are present 
		rParsedInfo.GetCmdSwitchesObject().
					SetErrataCode(uErrataCode);
		retCode = PARSER_ERROR;
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :IsHelp
   Synopsis	         :This function retrieves the next token from the token 
					  vector list, checks if it is '?' and returns enumerated 
					  return code depending upon the context.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
		helpType	 - enumerated help type
		uErrataCode  - error string ID.
		tokenLevel	 - token level 
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type.
   Global Variables  :None
   Calling Syntax    :IsHelp(cvTokens, theIterator, rParsedInfo,
			  		    helpType, uErrataCode, tokenLevel)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::IsHelp(CHARVECTOR& cvTokens, 
							CHARVECTOR::iterator& theIterator,
							CParsedInfo& rParsedInfo,
			  				HELPTYPE helpType,
							UINT uErrataCode,
							TOKENLEVEL tokenLevel)
{
	BOOL	bContinue	= TRUE;
	RETCODE retCode		= PARSER_CONTINUE;
	// Move to next token
	if (!GetNextToken(cvTokens, theIterator))	
	{
		// Set the retCode as PARSER_ERROR if no more tokens are present. 
		rParsedInfo.GetCmdSwitchesObject().SetErrataCode(uErrataCode);
		retCode = PARSER_ERROR;
	}
	else
	{
		// Is '?' 
		if (CompareTokens(*theIterator, CLI_TOKEN_HELP)) 
			retCode = ParseHelp(cvTokens, theIterator, helpType, rParsedInfo);
		else
		{
			// If LEVEL_ONE token then only allowed is /?, other
			// switches are invalid.
			if (tokenLevel == LEVEL_ONE)
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(uErrataCode);
				retCode =  PARSER_ERROR;
			}
			else
				retCode = PARSER_CONTINUE;
		}
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseHelp
   Synopsis	         :This function takes care of identifying the appropriate
					  help informtion to be displayed using the HELPTYPE 
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
		bGlobalHelp	 - global help flag
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE 
   Global Variables  :None
   Calling Syntax    :ParseHelp(cvTokens, theIterator, rParsedInfo)
   Notes             :overloaded fucntion
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseHelp(CHARVECTOR& cvTokens, 
								CHARVECTOR::iterator& theIterator,
								CParsedInfo& rParsedInfo,
								BOOL bGlobalHelp)
{
	BOOL	bContinue	= TRUE;
	RETCODE retCode		= PARSER_CONTINUE;

	// Move to next token (if no more tokens are present)
	if (!GetNextToken(cvTokens, theIterator))
	{
		retCode = PARSER_DISPHELP;
		rParsedInfo.GetGlblSwitchesObject().SetHelpFlag(TRUE);
		// Check for "/?" 
		if (((theIterator - 2) == cvTokens.begin()) || bGlobalHelp) 
		{
			rParsedInfo.GetHelpInfoObject().SetHelp(GlblAllInfo, TRUE);
			if(SUCCEEDED(m_CmdAlias.ConnectToAlias(rParsedInfo,m_pIWbemLocator)))
			{
				if(FAILED(m_CmdAlias.ObtainAliasFriendlyNames(rParsedInfo)))
					retCode = PARSER_ERRMSG;
			}
			else
				rParsedInfo.GetCmdSwitchesObject().FreeCOMError();

		}
	}
	// Check for the presence of the ':"
	else if (CompareTokens(*theIterator, CLI_TOKEN_COLON)) 
	{
		// Move to next token
		if (!GetNextToken(cvTokens, theIterator, rParsedInfo,
					IDS_E_INVALID_HELP_OPTION))
		// Set the retCode to PARSER_ERROR if no more tokens are specified.
		{
			retCode = PARSER_ERROR;
		}
		else
		{
			if (CompareTokens(*theIterator, CLI_TOKEN_BRIEF)) 
				rParsedInfo.GetGlblSwitchesObject().SetHelpOption(HELPBRIEF);
			else if (CompareTokens(*theIterator, CLI_TOKEN_FULL)) 
				rParsedInfo.GetGlblSwitchesObject().SetHelpOption(HELPFULL);
			else
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
												 IDS_E_INVALID_HELP_OPTION);
				retCode = PARSER_ERROR;
			}

			if ( retCode != PARSER_ERROR )
			{
				if ( GetNextToken(cvTokens, theIterator) )
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
												 IDS_E_INVALID_COMMAND);
					retCode = PARSER_ERROR;
				}
				else
				{
					retCode = PARSER_DISPHELP;
					rParsedInfo.GetGlblSwitchesObject().SetHelpFlag(TRUE);
					// Check for "/?:(BRIEF|FULL)
					if (((theIterator - 3) == cvTokens.begin()) || bGlobalHelp) 
					{
						rParsedInfo.GetHelpInfoObject().
											SetHelp(GlblAllInfo, TRUE);
						if(SUCCEEDED(m_CmdAlias.ConnectToAlias
									(rParsedInfo,m_pIWbemLocator)))
						{
							if(FAILED(m_CmdAlias.ObtainAliasFriendlyNames
									(rParsedInfo)))
							{
								retCode = PARSER_ERRMSG;
							}
						}
						else
							rParsedInfo.GetCmdSwitchesObject().FreeCOMError();
					}
				}
			}	
		}
	}
	else
	{
		rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
												   IDS_E_INVALID_COMMAND);
		retCode = PARSER_ERROR;
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseHelp
   Synopsis	         :This function takes care of identifying the appropriate
					  help informtion to be displayed using the HELPTYPE 
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		htHelp		 - help type
		rParsedInfo  - reference to CParsedInfo class object
		bGlobalHelp	 - global help flag
   Output Parameter(s):
		rParsedInfo  - ref. to CParsedInfo object
   Return Type       :RETCODE 
   Global Variables  :None
   Calling Syntax    :ParseHelp(cvTokens, theIterator, htHelp,
									rParsedInfo)
   Notes             :overloaded fucntion
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseHelp(CHARVECTOR& cvTokens, 
								CHARVECTOR::iterator& theIterator,
								HELPTYPE htHelp,
								CParsedInfo& rParsedInfo,
								BOOL bGlobalHelp)
{
	rParsedInfo.GetHelpInfoObject().SetHelp(htHelp, TRUE);
	return ParseHelp(cvTokens, theIterator, rParsedInfo, bGlobalHelp);
}

/*----------------------------------------------------------------------------
   Name				 :ObtainClassProperties
   Synopsis	         :This function obtains the information about the 
					   available properties for a given WMI class
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ObtainClassProperties(rParsedInfo)
   Notes             :If bCheckWritePropsAvail == TRUE then functions checks for 
					  availibilty of properties.
----------------------------------------------------------------------------*/
BOOL CParserEngine::ObtainClassProperties(CParsedInfo& rParsedInfo,
										  BOOL bCheckWritePropsAvail)
{
	HRESULT				hr					= S_OK;
	IWbemClassObject*	pIObject			= NULL;
    SAFEARRAY*			psaNames			= NULL;
	BSTR				bstrPropName		= NULL;
	BOOL				bRet				= TRUE;
	BOOL				bTrace				= FALSE;
	CHString			chsMsg;
	ERRLOGOPT			eloErrLogOpt		= NO_LOGGING;
	DWORD				dwThreadId			= GetCurrentThreadId();
	BOOL				bSetVerb			= FALSE;
	BOOL				bPropsAvail			= FALSE;

	if (rParsedInfo.GetCmdSwitchesObject().GetVerbName() != NULL)
	{
		if (CompareTokens(rParsedInfo.GetCmdSwitchesObject().GetVerbName(), 
						CLI_TOKEN_SET))
		{
			bSetVerb = TRUE;
		}
	}
	
	// Obtain the trace flag status
	bTrace = rParsedInfo.GetGlblSwitchesObject().GetTraceStatus();

	eloErrLogOpt = rParsedInfo.GetErrorLogObject().GetErrLogOption();

	if (SUCCEEDED(ConnectToNamespace(rParsedInfo)))
	{
		
		CHARVECTOR cvPropList;  
		BOOL bPropList = FALSE;
		
		try
		{
			cvPropList = rParsedInfo.GetCmdSwitchesObject().GetPropertyList();
			if ( cvPropList.size() != 0 )
				bPropList = TRUE;

			hr = m_pITargetNS->GetObject(_bstr_t(rParsedInfo.
								GetCmdSwitchesObject().GetClassPath()),
								WBEM_FLAG_USE_AMENDED_QUALIFIERS,	
								NULL,   &pIObject, NULL);
			if (bTrace || eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", "
						L"WBEM_FLAG_USE_AMENDED_QUALIFIERS, 0, NULL, -, -)", 
						(rParsedInfo.GetCmdSwitchesObject().GetClassPath())?
							rParsedInfo.GetCmdSwitchesObject().GetClassPath():L"<NULL>");		
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, dwThreadId,
						rParsedInfo, bTrace);
			}
			ONFAILTHROWERROR(hr);

			hr = pIObject->GetNames(NULL, WBEM_FLAG_ALWAYS | 
							WBEM_FLAG_NONSYSTEM_ONLY, NULL, &psaNames);
			if (bTrace || eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemClassObject::GetNames(NULL, "
							L"WBEM_FLAG_ALWAYS | WBEM_FLAG_NONSYSTEM_ONLY, "
							L"NULL, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, dwThreadId, 
						rParsedInfo, bTrace);
			}	
			ONFAILTHROWERROR(hr);

			// Get the number of properties.
			LONG lLower = 0, lUpper = 0; 
			hr = SafeArrayGetLBound(psaNames, 1, &lLower);
			if ( eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetLBound(-, -, -)"); 
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, dwThreadId, 
					rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			hr = SafeArrayGetUBound(psaNames, 1, &lUpper);
			if ( eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetUBound(-, -, -)"); 
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, dwThreadId, 
					rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);


			// For each property obtain the information of our interest
			for (LONG lVar = lLower; lVar <= lUpper; lVar++) 
			{
				// Get the property.
				hr = SafeArrayGetElement(psaNames, &lVar, &bstrPropName);
				if ( eloErrLogOpt )
				{
					chsMsg.Format(L"SafeArrayGetElement(-, -, -)"); 
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
						dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);

				CHARVECTOR::iterator tempIterator;
				if ( bPropList == TRUE && !Find(cvPropList, 
										_bstr_t(bstrPropName),
										tempIterator))
				{
					SAFEBSTRFREE(bstrPropName);
					continue;
				}

				PROPERTYDETAILS pdPropDet;
				hr = GetPropertyAttributes(pIObject, bstrPropName, 
					pdPropDet, 
					rParsedInfo.GetGlblSwitchesObject().GetTraceStatus());
				ONFAILTHROWERROR(hr);

				if (bSetVerb == TRUE || bCheckWritePropsAvail == TRUE)
				{
					if ( !_tcsstr((_TCHAR*)pdPropDet.Operation, CLI_TOKEN_WRITE) )
					{
						SAFEBSTRFREE(bstrPropName);
						continue;
					}
				}
				
				if ( bCheckWritePropsAvail == TRUE )
				{
					bPropsAvail = TRUE;
					SAFEBSTRFREE(bstrPropName);
					break;
				}

				pdPropDet.Derivation = bstrPropName;
				if(!rParsedInfo.GetCmdSwitchesObject().AddToPropDetMap(
													bstrPropName, pdPropDet))
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
								IDS_E_ADD_TO_PROP_DET_MAP_FAILURE);
					bRet = FALSE;
				}
				SAFEBSTRFREE(bstrPropName);
			}
			SAFEIRELEASE(pIObject);
			SAFEADESTROY(psaNames);
			SAFEBSTRFREE(bstrPropName);
		}
		catch(_com_error& e)
		{
			bRet = FALSE;
			SAFEIRELEASE(pIObject);
			SAFEADESTROY(psaNames);
			SAFEBSTRFREE(bstrPropName);
			_com_issue_error(e.Error());
		}
		catch(CHeap_Exception)
		{
			bRet = FALSE;
			SAFEIRELEASE(pIObject);
			SAFEADESTROY(psaNames);
			SAFEBSTRFREE(bstrPropName);
			_com_issue_error(WBEM_E_OUT_OF_MEMORY);
		}
	}
	else
		bRet = FALSE;

	if ( bCheckWritePropsAvail == TRUE )
		bRet = bPropsAvail;

	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :ObtainClassMethods
   Synopsis	         :This function obtains the information about the 
					  available methods for a given WMI class
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - ref. to CParsedInfo object
   Output Parameter(s):
		rParsedInfo  - ref. to CParsedInfo object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ObtainClassMethods(rParsedInfo)
   Notes             :none
----------------------------------------------------------------------------*/
BOOL CParserEngine::ObtainClassMethods(CParsedInfo& rParsedInfo, 
									   BOOL bCheckForExists)
{
	BOOL			bRet				= TRUE;
	BOOL			bTrace				= FALSE;
	CHString		chsMsg;
	ERRLOGOPT		eloErrLogOpt		= NO_LOGGING;
	DWORD			dwThreadId			= GetCurrentThreadId();
	BOOL			bMethAvail			= FALSE;
	_TCHAR*			pMethodName			= NULL;
	
	bTrace	= rParsedInfo.GetGlblSwitchesObject().GetTraceStatus();
	eloErrLogOpt = rParsedInfo.GetErrorLogObject().GetErrLogOption();

	if (SUCCEEDED(ConnectToNamespace(rParsedInfo)))
	{
		HRESULT				hr				= S_OK;
		IWbemClassObject *pIObject = NULL,*pIInSign = NULL,*pIOutSign = NULL;
		BSTR				bstrMethodName	= NULL;

		try
		{
			hr = m_pITargetNS->GetObject(_bstr_t(rParsedInfo.
								GetCmdSwitchesObject().GetClassPath()),
								WBEM_FLAG_USE_AMENDED_QUALIFIERS,	
								NULL,   &pIObject, NULL);

			if ( eloErrLogOpt )
			{
				chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", "
						L"WBEM_FLAG_USE_AMENDED_QUALIFIERS, 0, NULL, -, -)", 
						rParsedInfo.GetCmdSwitchesObject().GetClassPath());		
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, dwThreadId, 
					rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			// Begin an enumeration of the methods available for the object.
			hr = pIObject->BeginMethodEnumeration(0);
			if ( eloErrLogOpt )
			{
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
					_T("BeginMethodEnumeration(0)"),
					dwThreadId, rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);


			//To get info about only method if method is specified
			pMethodName = rParsedInfo.GetCmdSwitchesObject().
															  GetMethodName();
			// Retrieve the next method in the method enumeration 
			// sequence 
			while ((pIObject->NextMethod(0, &bstrMethodName, &pIInSign, 
										 &pIOutSign)) != WBEM_S_NO_MORE_DATA)
			{
				if ( bCheckForExists == TRUE )
				{
					bMethAvail	= TRUE;
					SAFEBSTRFREE(bstrMethodName);
					SAFEIRELEASE(pIInSign);
					SAFEIRELEASE(pIOutSign);
					break;
				}

				if(pMethodName != NULL && 
					!CompareTokens(pMethodName, (_TCHAR*)bstrMethodName))
				{
					SAFEBSTRFREE(bstrMethodName);
					SAFEIRELEASE(pIInSign);
					SAFEIRELEASE(pIOutSign);
					continue;
				}
				METHODDETAILS mdMethDet;
				if (pIInSign)
					hr = ObtainMethodParamInfo(pIInSign, mdMethDet, INP,
						rParsedInfo.GetGlblSwitchesObject().GetTraceStatus(), 
						rParsedInfo);
				ONFAILTHROWERROR(hr);

				if (pIOutSign)
					hr = ObtainMethodParamInfo(pIOutSign, mdMethDet, OUTP,
						rParsedInfo.GetGlblSwitchesObject().GetTraceStatus(),
						rParsedInfo);
				ONFAILTHROWERROR(hr);

				_bstr_t bstrStatus, bstrDesc;
				hr = GetMethodStatusAndDesc(pIObject, 
						bstrMethodName, bstrStatus, bstrDesc,
						rParsedInfo.GetGlblSwitchesObject().GetTraceStatus());
					mdMethDet.Status = _bstr_t(bstrStatus);
					mdMethDet.Description = _bstr_t(bstrDesc);
				ONFAILTHROWERROR(hr);

				
				if(!rParsedInfo.GetCmdSwitchesObject().AddToMethDetMap(
									 _bstr_t(bstrMethodName),mdMethDet))
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
									IDS_E_ADD_TO_METH_DET_MAP_FAILURE);
					SAFEBSTRFREE(bstrMethodName);
					SAFEIRELEASE(pIInSign);
					SAFEIRELEASE(pIOutSign);
					bRet = FALSE;
					break;
				}

				SAFEBSTRFREE(bstrMethodName);
				SAFEIRELEASE(pIInSign);
				SAFEIRELEASE(pIOutSign);
			}
			SAFEIRELEASE(pIObject);
		}
		catch(_com_error& e)
		{
			SAFEBSTRFREE(bstrMethodName);
			SAFEIRELEASE(pIInSign);
			SAFEIRELEASE(pIOutSign);
			SAFEIRELEASE(pIObject);
			_com_issue_error(e.Error());
			bRet = FALSE;
		}
		catch(CHeap_Exception)
		{
			bRet = FALSE;
			SAFEBSTRFREE(bstrMethodName);
			SAFEIRELEASE(pIInSign);
			SAFEIRELEASE(pIOutSign);
			SAFEIRELEASE(pIObject);
			_com_issue_error(WBEM_E_OUT_OF_MEMORY);
		}
	}
	else
		bRet = FALSE;

	if ( bCheckForExists == TRUE )
		bRet = bMethAvail;
	
	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :ConnectToNamespace
   Synopsis	         :This function connects to the WMI namespace on the 
					  target machine using the supplied user credentials.
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
   		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :HRESULT 
   Global Variables  :None
   Calling Syntax    :ConnectToNamespace(rParsedInfo)
   Notes             :none
----------------------------------------------------------------------------*/
HRESULT CParserEngine::ConnectToNamespace(CParsedInfo& rParsedInfo)
{
	HRESULT		hr		= S_OK;
	DWORD dwThreadId = GetCurrentThreadId();
	if (rParsedInfo.GetGlblSwitchesObject().GetNameSpaceFlag())
	{
		BOOL		bTrace				= FALSE;
		CHString	chsMsg;
		ERRLOGOPT	eloErrLogOpt		= NO_LOGGING;

		// Obtain the trace status
		bTrace = rParsedInfo.GetGlblSwitchesObject().GetTraceStatus();
		eloErrLogOpt = rParsedInfo.GetErrorLogObject().GetErrLogOption();

		SAFEIRELEASE(m_pITargetNS);
		try
		{
			// Connect to the WMI namespace on the target machine 
			// using the supplied user credentials.
			hr = Connect(m_pIWbemLocator, &m_pITargetNS, 
					_bstr_t(rParsedInfo.GetNamespace()),
					NULL,
					NULL,
					_bstr_t(rParsedInfo.GetLocale()),
					rParsedInfo);

			if (bTrace || eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemLocator::ConnectServer(L\"%s\", NULL, "
						L"NULL, L\"%s\", 0L, NULL, NULL, -)",
						rParsedInfo.GetNamespace(),
						rParsedInfo.GetLocale());
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, dwThreadId, 
					rParsedInfo, bTrace);
			}
			ONFAILTHROWERROR(hr);

			// set the security privileges at the interface level
			hr = SetSecurity(m_pITargetNS, NULL, NULL,	NULL, NULL,
					rParsedInfo.GetGlblSwitchesObject().
								GetAuthenticationLevel(),
					rParsedInfo.GetGlblSwitchesObject().
								GetImpersonationLevel());
			if (bTrace || eloErrLogOpt)
			{
				chsMsg.Format(L"CoSetProxyBlanket(-, RPC_C_AUTHN_WINNT, "
						L"RPC_C_AUTHZ_NONE, NULL, %d,   %d, -, EOAC_NONE)",
						rParsedInfo.GetGlblSwitchesObject().
									GetAuthenticationLevel(),
						rParsedInfo.GetGlblSwitchesObject().
									GetImpersonationLevel());
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, dwThreadId,
						rParsedInfo, bTrace);
			}
			ONFAILTHROWERROR(hr);

			rParsedInfo.GetGlblSwitchesObject().SetNameSpaceFlag(FALSE);
		}
		catch(_com_error& e)
		{
			// execption handling
			_com_issue_error(e.Error());
		}
		catch(CHeap_Exception)
		{
			_com_issue_error(WBEM_E_OUT_OF_MEMORY);
		}

	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :ObtainMethodParamInfo
   Synopsis	         :This function obtains the information about the method
					  arguments (both input and output arguments)
   Type	             :Member Function
   Input Parameter(s):
		pIObj	     - pointer to IWbemClassObject object
		bTrace	     - trace flag
		ioInOrOut    - INOROUT type specifies in or out parameter type.
   Output Parameter(s):
   		mdMethDet    - method details structure
   Return Type       :HRESULT 
   Global Variables  :None
   Calling Syntax    :ObtainMethodParamInfo(pIObj, mdMethDet, IN, bTrace, rParsedInfo)
   Notes             :none
----------------------------------------------------------------------------*/
HRESULT CParserEngine::ObtainMethodParamInfo(IWbemClassObject* pIObj, 
											 METHODDETAILS& mdMethDet,
											 INOROUT ioInOrOut,
											 BOOL bTrace, CParsedInfo& rParsedInfo)
{
	HRESULT		hr					= S_OK;
    SAFEARRAY*	psaNames			= NULL;
	BSTR		bstrPropName		= NULL;
	CHString	chsMsg;
	_TCHAR		szNumber[BUFFER512] = NULL_STRING; 
	ERRLOGOPT	eloErrLogOpt		= NO_LOGGING;
	DWORD		dwThreadId			= GetCurrentThreadId();

    // Get the property names 
	try
	{
		if ( pIObj != NULL )
		{
			hr = pIObj->GetNames(NULL, 
							WBEM_FLAG_ALWAYS | WBEM_FLAG_NONSYSTEM_ONLY, 
			   				NULL, &psaNames);
			if (bTrace || eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemClassObject::GetNames(NULL, "
							L"WBEM_FLAG_ALWAYS | WBEM_FLAG_NONSYSTEM_ONLY, "
							L"NULL, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, dwThreadId,
							rParsedInfo, bTrace);
			}	
			ONFAILTHROWERROR(hr);

			// Get the number of properties.
			LONG lLower = 0, lUpper = 0; 
			hr = SafeArrayGetLBound(psaNames, 1, &lLower);
			if ( eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetLBound(-, -, -)"); 
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, dwThreadId,
						rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			hr = SafeArrayGetUBound(psaNames, 1, &lUpper);
			if ( eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetUBound(-, -, -)"); 
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, dwThreadId, 
					rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			// For each property obtian the information of our interest
			for (LONG lVar = lLower; lVar <= lUpper; lVar++) 
			{
				// Get the property.
				hr = SafeArrayGetElement(psaNames, &lVar, &bstrPropName);
				if ( eloErrLogOpt )
				{
					chsMsg.Format(L"SafeArrayGetElement(-, -, -)"); 
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
						dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);

				PROPERTYDETAILS pdPropDet;
				hr = GetPropertyAttributes(pIObj,
					bstrPropName, pdPropDet, bTrace);
				ONFAILTHROWERROR(hr);

				// 'ReturnValue' is not a property of our interest as per
				// the expected output given in the sample, hence omitting
				// the same.
				if ( bstrPropName != NULL )
				{
					PROPERTYDETAILS pdIPropDet;
					pdIPropDet.Type = pdPropDet.Type;
					pdIPropDet.InOrOut = ioInOrOut;

					// Making bstrPropName begin with numbers to maintain
					// the order of method arguments in map.
					// while displaying remove numbers and display the 
					// parameters in case of help only.
					_bstr_t bstrNumberedPropName; 
					if ( rParsedInfo.GetGlblSwitchesObject().GetHelpFlag() )
					{
						if ( ioInOrOut == INP )
							_ltot(lVar, szNumber, 10);
						else
							_ltot(lVar + 500, szNumber, 10);

						chsMsg.Format(L"%-5s", szNumber);
						bstrNumberedPropName = _bstr_t(chsMsg) +
											   _bstr_t(bstrPropName);
					}
					else
						bstrNumberedPropName = _bstr_t(bstrPropName);

					mdMethDet.Params.insert(PROPDETMAP::value_type(
											bstrNumberedPropName,pdIPropDet));
				}

				// Free the memory allocated using SysAllocString for 
				// bstrPropName
				SAFEBSTRFREE(bstrPropName);
			}
			// Destroy array descriptor and all of the data in the array
			SAFEADESTROY(psaNames);
		}
    }
	catch(_com_error& e)
	{
		SAFEBSTRFREE(bstrPropName);
		SAFEADESTROY(psaNames);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		SAFEBSTRFREE(bstrPropName);
		SAFEADESTROY(psaNames);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :GetMethodStatusAndDesc
   Synopsis	         :This function obtains the implementation status and 
					  description of the verbs available
   Type	             :Member Function
   Input Parameter(s):
		pIObj	     - pointer to IWbemClassObject object
		bstrMethod   - method name
		bTrace	     - trace flag
   Output Parameter(s):
   		bstrStatus   - implementation status
		bstrDesc     - Method description
   Return Type       :HRESULT 
   Global Variables  :None
   Calling Syntax    : GetMethodStatusAndDesc(pIObj, bstrMethod,
						bstrStatus, bstrDesc, bTrace)
   Notes             :none
----------------------------------------------------------------------------*/
HRESULT CParserEngine::GetMethodStatusAndDesc(IWbemClassObject* pIObj, 
											  BSTR bstrMethod,
											  _bstr_t& bstrStatus,
											  _bstr_t& bstrDesc,
											  BOOL bTrace)
{
	HRESULT				hr			= S_OK;
	IWbemQualifierSet*	pIQualSet	= NULL;
	VARIANT				vtStatus, vtDesc;
	VariantInit(&vtStatus);
	VariantInit(&vtDesc);
	
	try
	{
		if ( pIObj != NULL )
		{
			// Obtain the method qualifier set.
   			hr = pIObj->GetMethodQualifierSet(bstrMethod, &pIQualSet);
			if ( pIQualSet != NULL )
			{
				// Retrieve the 'Implemented' qualifier status value
				hr = pIQualSet->Get(_bstr_t(L"Implemented"), 
								0L, &vtStatus, NULL);
				
				if (SUCCEEDED(hr))
				{
					if (vtStatus.vt != VT_EMPTY && vtStatus.vt != VT_NULL )
					{
						if ( vtStatus.boolVal ) 
							bstrStatus = L"Implemented";
						else
							bstrStatus = L"Not Implemented";
					}
					else
						bstrStatus = L"Not Found";
				}	
				else
					bstrStatus = L"Not Found";
				VARIANTCLEAR(vtStatus);
				// Should not break here, hence the HRESULT should be set to S_OK
				hr = S_OK;
				
				// Retrieve the 'Description' qualifier text
				hr = pIQualSet->Get(_bstr_t(L"Description"), 0L , 
									&vtDesc, NULL);
				if (SUCCEEDED(hr))
				{
					if (vtDesc.vt == VT_BSTR) 
						bstrDesc = _bstr_t(vtDesc.bstrVal);
					else
						bstrDesc = L"Not available";
				}
				else
					bstrDesc = L"Not available";
				VARIANTCLEAR(vtDesc);
				// Should not break here, hence the HRESULT should be set to S_OK
				hr = S_OK;
				SAFEIRELEASE(pIQualSet);
			}
			else
				hr = S_OK;
		}
	}
	catch(_com_error& e)
	{
		VARIANTCLEAR(vtStatus);
		VARIANTCLEAR(vtDesc);
		SAFEIRELEASE(pIQualSet);
		hr = e.Error();
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :CheckforHelp
   Synopsis	         :This function looks ahead one token to see if the next 
					  token is '?'
   Type	             :Member Function
   Input Parameter(s):
		cvTokens	 - the tokens vector 
		theIterator	 - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object.
		uErrataCode  - error string ID
   Output Parameter(s):
   		rParsedInfo  - reference to CParsedInfo class object

   Return Type       :RETCODE - enumerated data type.
   Global Variables  :None
   Calling Syntax    :CheckforHelp(cvtokens,theIterator,rParsedInfo,uErrataCode)
   Notes             :none
----------------------------------------------------------------------------*/
RETCODE CParserEngine::CheckForHelp(CHARVECTOR& cvTokens, 
									CHARVECTOR::iterator& theIterator,
									CParsedInfo& rParsedInfo,
									UINT uErrataCode)
{
	RETCODE retCode = PARSER_DISPHELP;
	// Set the retCode as PARSER_ERROR if no more tokens 
	// are present.
	if(!GetNextToken(cvTokens, theIterator))
	{
		retCode = PARSER_ERROR;
		rParsedInfo.GetCmdSwitchesObject().SetErrataCode(uErrataCode);
	}
	else if(!CompareTokens(*theIterator, CLI_TOKEN_HELP))
	{
		rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
							uErrataCode);
		retCode = PARSER_ERROR;
	}
	else
	{
		retCode = ParseHelp(cvTokens, theIterator, rParsedInfo, FALSE);
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ValidateGlobalSwitchValue
   Synopsis	         :This function checks whether global switches are 
					  specified in the expected format or not.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator	 - the Iterator to the cvTokens vector.
		uErrataCode	 - error string
		rParsedInfo  - reference to CParsedInfo class object.
		uErrataCode2 - error string2 ID
		htHelp		 - help type
   Output Parameter(s):
   		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type.
   Global Variables  :None
   Calling Syntax    :ValidateGlobalSwitchValue(cvTokens, theIterator, 
								uErrataCode, rParsedInfo,
								uErrataCode2, htHelp)
   Notes             :none
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ValidateGlobalSwitchValue(CHARVECTOR& cvTokens,
											CHARVECTOR::iterator& theIterator,
											UINT uErrataCode,
											CParsedInfo& rParsedInfo,
											UINT uErrataCode2,
											HELPTYPE htHelp)
{
	RETCODE retCode = PARSER_CONTINUE;
	retCode = GetNextToken(cvTokens, theIterator, rParsedInfo,
						 htHelp, uErrataCode2);

	if (retCode == PARSER_CONTINUE)
	{		
 		// Check for the presence of the ':'
		if (CompareTokens(*theIterator, CLI_TOKEN_COLON)) 
		{
			// Move to next token
			if (GetNextToken(cvTokens, theIterator, rParsedInfo,
						uErrataCode))
			{
				if (IsOption(*theIterator))
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
																uErrataCode);
					retCode = PARSER_ERROR;
				}
				else
					retCode = PARSER_CONTINUE;
			}
			else
				retCode = PARSER_ERROR;
		}
		else if (IsOption(*theIterator))
		{
			retCode = CheckForHelp(cvTokens, theIterator,
						rParsedInfo, uErrataCode2);
			if (retCode == PARSER_DISPHELP)
			{
				rParsedInfo.GetGlblSwitchesObject().SetHelpFlag(TRUE);
				rParsedInfo.GetHelpInfoObject().SetHelp(htHelp, TRUE);
			}
		}
		else
		{
			rParsedInfo.GetCmdSwitchesObject().
						SetErrataCode(uErrataCode2);
			retCode = PARSER_ERROR;
		}
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseEVERYSwitch
   Synopsis	         :This function checks whether the value specified for the
					  /EVERY swith is valid or not.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator	 - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object.
   Output Parameter(s):
   		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type.
   Global Variables  :None
   Calling Syntax    :ParseEVERYSwitch(cvTokens, theIterator, rParsedInfo)
   Notes             :none
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseEVERYSwitch(CHARVECTOR& cvTokens,
										CHARVECTOR::iterator& theIterator,
										CParsedInfo& rParsedInfo)
{
	RETCODE	retCode	= PARSER_EXECCOMMAND;	
	
	retCode = ParseNumberedSwitch(cvTokens, theIterator, rParsedInfo,
								EVERY, IDS_E_INVALID_EVERY_SWITCH,
								IDS_E_INVALID_INTERVAL);

	if ( retCode == PARSER_EXECCOMMAND )
	{
		 if (GetNextToken(cvTokens, theIterator) == TRUE )
		 {
			 if ( CompareTokens(*theIterator, CLI_TOKEN_FSLASH) == TRUE )
			 {
				 if ( GetNextToken(cvTokens, theIterator) == TRUE )
				 {
					 if (CompareTokens(*theIterator, CLI_TOKEN_REPEAT) == TRUE)
					 {
						 retCode = ParseNumberedSwitch(cvTokens, 
													theIterator,
													rParsedInfo,
													REPEAT, 
													IDS_E_INVALID_REPEAT_SWITCH,
													IDS_E_INVALID_REPEATCOUNT);
					 }
					 else
						 theIterator = theIterator - 2;
				 }
				 else
					 theIterator = theIterator - 2;
			 }
			 else
				 theIterator = theIterator - 1;
		 }
	}

	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseFORMATSwitch
   Synopsis	         :This function checks whether the value specified for the 
					  /FORMAT swith is valid or not.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator	 - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object.
   Output Parameter(s):
   		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type.
   Global Variables  :None
   Calling Syntax    :ParseFORMATSwitch(cvTokens, theIterator, rParsedInfo)
   Notes             :none
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseFORMATSwitch(CHARVECTOR& cvTokens,
										 CHARVECTOR::iterator& theIterator,
										 CParsedInfo& rParsedInfo)
{
	RETCODE retCode = PARSER_EXECCOMMAND;
	// Reset the XSL file path.
	rParsedInfo.GetCmdSwitchesObject().ClearXSLTDetailsVector();

	// Move to next token
	if (!GetNextToken(cvTokens, theIterator))
	{
		retCode = PARSER_EXECCOMMAND;

		// If Translate table name is given then set the flag
		if( rParsedInfo.GetCmdSwitchesObject().
									GetTranslateTableName() != NULL ) 
		{
			rParsedInfo.GetCmdSwitchesObject().SetTranslateFirstFlag(TRUE);
		}
		else
			rParsedInfo.GetCmdSwitchesObject().SetTranslateFirstFlag(FALSE);
	}
	else if ( IsOption(*theIterator) &&
			  (theIterator + 1) < cvTokens.end() &&
			  CompareTokens(*(theIterator+1), CLI_TOKEN_HELP) )
	{
		theIterator++;
		retCode = ParseHelp(cvTokens, theIterator, FORMAT, rParsedInfo);
	}
	else if (CompareTokens(*theIterator, CLI_TOKEN_COLON)) 
	{
		while ( retCode == PARSER_EXECCOMMAND && 
				theIterator < cvTokens.end() )
		{
			XSLTDET xdXSLTDet;
			BOOL	bFrameXSLFile = TRUE;
			// Move to next token
			if (!GetNextToken(cvTokens, theIterator))
			{
				// PARSER_ERROR if <format specifier> is missing
				rParsedInfo.GetCmdSwitchesObject().
						SetErrataCode(IDS_E_INVALID_FORMAT);
				retCode = PARSER_ERROR;
			}
			else if ( IsOption(*theIterator) )
			{
				rParsedInfo.GetCmdSwitchesObject().
						SetErrataCode(IDS_E_INVALID_FORMAT);
				retCode = PARSER_ERROR;
			}
			else 
			{
				xdXSLTDet.FileName = *theIterator;
				if(!g_wmiCmd.GetFileFromKey(*theIterator, xdXSLTDet.FileName))
					bFrameXSLFile	= FALSE;
			}

			if ( retCode == PARSER_EXECCOMMAND )
			{
				if ( !GetNextToken(cvTokens, theIterator) )
				{
					if ( bFrameXSLFile == TRUE )
					{
						if (!FrameFileAndAddToXSLTDetVector(xdXSLTDet, 
																 rParsedInfo))
							retCode = PARSER_ERRMSG;
					}
					else
						rParsedInfo.GetCmdSwitchesObject().
										AddToXSLTDetailsVector(xdXSLTDet);
					break;
				}
				else if ( IsOption(*theIterator) )
				{
					theIterator--;
					if ( bFrameXSLFile == TRUE )
					{
						if (!FrameFileAndAddToXSLTDetVector(xdXSLTDet, 
																 rParsedInfo))
							retCode = PARSER_ERRMSG;
					}
					else
						rParsedInfo.GetCmdSwitchesObject().
										AddToXSLTDetailsVector(xdXSLTDet);
					break;
				}
				else if ( CompareTokens(*theIterator, CLI_TOKEN_COLON ) )
				{
					_TCHAR* pszXSLFile = NULL;
					retCode = ParseParamsString(cvTokens, theIterator,
											   rParsedInfo, xdXSLTDet, 
											   pszXSLFile);
					if ( retCode == PARSER_EXECCOMMAND &&
					 (theIterator != cvTokens.end()) && IsOption(*theIterator) )
					{
						theIterator--;
						
						if ( bFrameXSLFile == TRUE )
						{
							if (!FrameFileAndAddToXSLTDetVector(xdXSLTDet, 
																rParsedInfo))
								retCode = PARSER_ERRMSG;
						}
						else
							rParsedInfo.GetCmdSwitchesObject().
											AddToXSLTDetailsVector(xdXSLTDet);

						if ( pszXSLFile != NULL && 
							 retCode == PARSER_EXECCOMMAND )
						{
							XSLTDET xdXSLDetOnlyFile;
							BOOL bInnerFrameXSLFile = TRUE; 
							
							xdXSLDetOnlyFile.FileName = pszXSLFile;
							if(!g_wmiCmd.GetFileFromKey(pszXSLFile,
														  xdXSLTDet.FileName))
								bInnerFrameXSLFile = FALSE;

							if ( bInnerFrameXSLFile == TRUE )
							{
								if (!FrameFileAndAddToXSLTDetVector(xdXSLDetOnlyFile, 
																		 rParsedInfo))
									retCode = PARSER_ERRMSG;
							}
							else
								rParsedInfo.GetCmdSwitchesObject().
												AddToXSLTDetailsVector(xdXSLDetOnlyFile);
						}
						break;
					}
				}
				else if ( !CompareTokens(*theIterator, CLI_TOKEN_COMMA ) )
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(IDS_E_INVALID_FORMAT);
					retCode = PARSER_ERROR;
				}
			}

			if ( retCode == PARSER_EXECCOMMAND )
			{
				if ( bFrameXSLFile == TRUE )
				{
					if (!FrameFileAndAddToXSLTDetVector(xdXSLTDet, rParsedInfo))
						retCode = PARSER_ERRMSG;
				}
				else
					rParsedInfo.GetCmdSwitchesObject().
											AddToXSLTDetailsVector(xdXSLTDet);
			}
		}

		// If Translate table name is given then set the flag
		if( rParsedInfo.GetCmdSwitchesObject().
									GetTranslateTableName() != NULL ) 
		{
			rParsedInfo.GetCmdSwitchesObject().SetTranslateFirstFlag(TRUE);
		}
		else
			rParsedInfo.GetCmdSwitchesObject().SetTranslateFirstFlag(FALSE);
	}
	else
	{
		theIterator--;
	}

	return retCode;
}
/*----------------------------------------------------------------------------
   Name				 :IsStdVerbOrUserDefVerb
   Synopsis	         :This function checks whether the verb is standard verb 
					  or user defined verb for alias.
   Type	             :Member Function
   Input Parameter(s):
		pszToken     - the verb name string
		rParsedInfo  - reference to CParsedInfo class object
		
   Output Parameter(s): None
   		
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :IsStdVerbOrUserDefVerb( pszToken,rParsedInfo)
   Notes             :none
----------------------------------------------------------------------------*/
BOOL CParserEngine::IsStdVerbOrUserDefVerb(_bstr_t bstrToken,
										   CParsedInfo& rParsedInfo)
{
	BOOL bStdVerbOrUserDefVerb = FALSE;
	
	try
	{
		if ( CompareTokens(bstrToken, CLI_TOKEN_GET)	||
			 CompareTokens(bstrToken, CLI_TOKEN_LIST)	||
			 CompareTokens(bstrToken, CLI_TOKEN_SET)	||
			 CompareTokens(bstrToken, CLI_TOKEN_CREATE)	||
			 CompareTokens(bstrToken, CLI_TOKEN_CALL)	||
			 CompareTokens(bstrToken, CLI_TOKEN_ASSOC)	||
			 CompareTokens(bstrToken, CLI_TOKEN_DELETE) )
			 bStdVerbOrUserDefVerb = TRUE;
		else
		{
			if ( m_bAliasName )
			{
				METHDETMAP mdmMethDetMap =  rParsedInfo.GetCmdSwitchesObject()
																.GetMethDetMap();
				if ( mdmMethDetMap.empty() )
				{
					m_CmdAlias.ObtainAliasVerbDetails(rParsedInfo);
					mdmMethDetMap =  rParsedInfo.GetCmdSwitchesObject()
																.GetMethDetMap();
				}

				METHDETMAP::iterator theMethIterator = NULL;
				for ( theMethIterator = mdmMethDetMap.begin();
					  theMethIterator != mdmMethDetMap.end(); theMethIterator++ )	
				{
					if ( CompareTokens((*theMethIterator).first,bstrToken) )
					{
						bStdVerbOrUserDefVerb = TRUE;
						break;
					}
				}
			}
		}
	}
	catch(_com_error& e)
	{
		bStdVerbOrUserDefVerb = FALSE;
		_com_issue_error(e.Error());		
	}
	return bStdVerbOrUserDefVerb;
}

/*----------------------------------------------------------------------------
   Name				 :ParseTRANSLATESwitch
   Synopsis	         :This function parses for translate switch in the command.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator	 - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object.
   Output Parameter(s) :
   		rParsedInfo  - reference to CParsedInfo class object
   		
   Return Type       :RETCODE-enumerated type
   Global Variables  :None
   Calling Syntax    :ParseTRANSLATESwitch(cvTokens,theIterator,rParsedInfo)
   Notes             :none
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseTRANSLATESwitch(CHARVECTOR& cvTokens,
											CHARVECTOR::iterator& theIterator,
											CParsedInfo& rParsedInfo)
{
	RETCODE retCode = PARSER_EXECCOMMAND;

	if ( GetNextToken(cvTokens, theIterator, rParsedInfo, TRANSLATE,
					 IDS_E_INVALID_TRANSLATE_SWITCH) == PARSER_CONTINUE )
	{
		if ( IsOption(*theIterator) &&
		     (theIterator + 1) < cvTokens.end() &&
		     CompareTokens(*(theIterator+1), CLI_TOKEN_HELP) )
		{
			theIterator++;
			retCode = ParseHelp(cvTokens, theIterator, TRANSLATE, 
																rParsedInfo);
			if ( retCode == PARSER_DISPHELP )
			{
				if( FAILED(m_CmdAlias.ConnectToAlias(rParsedInfo,
														m_pIWbemLocator)))
					retCode = PARSER_ERRMSG;
				if ( FAILED(m_CmdAlias.ObtainTranslateTables(rParsedInfo)))
					retCode = PARSER_ERRMSG;
			}
		}
		else if ( CompareTokens( *theIterator, CLI_TOKEN_COLON ) &&
			 GetNextToken(cvTokens, theIterator, rParsedInfo, TRANSLATE,
						 IDS_E_INVALID_TRANSLATE_SWITCH) == PARSER_CONTINUE )
		{
			rParsedInfo.GetCmdSwitchesObject().SetTranslateTableName(*theIterator);

			if ( IsOption(*theIterator) )
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
										IDS_E_INVALID_TRANSLATE_SWITCH);
				retCode = PARSER_ERROR;
			}
			else if(FAILED(m_CmdAlias.ConnectToAlias(rParsedInfo,
														m_pIWbemLocator)))
				retCode = PARSER_ERRMSG;
			else if ( m_CmdAlias.ObtainTranslateTableEntries(rParsedInfo) == TRUE )
				retCode = PARSER_EXECCOMMAND;
			else
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
										IDS_E_TRANSLATE_TABLE_NOT_EXIST);
				retCode = PARSER_ERROR;
			}

			// If Format switch is specified after translate switch then
			// set the flag else reset it
			if(rParsedInfo.GetCmdSwitchesObject().GetXSLTDetailsVector().
																	  empty())
			{
				rParsedInfo.GetCmdSwitchesObject().SetTranslateFirstFlag(TRUE);
			}
			else
				rParsedInfo.GetCmdSwitchesObject().SetTranslateFirstFlag(FALSE);
		}
		else
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
									IDS_E_INVALID_TRANSLATE_SWITCH);
			retCode = PARSER_ERROR;
		}

	}
	else
		retCode = PARSER_ERROR;
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseContextInfo
   Synopsis	         :This function does the parsing of the help on context 
					  information
   Type	             :Member Function
   Input Parameter(s):
		cvTokens      - the tokens vector 
		theIterator   - the Iterator to the cvTokens vector.
		rParsedInfo   - reference to CParsedInfo class object
   Output parameter(s):
		rParsedInfo   - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseContextInfo(cvTokens, theIterator, rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseContextInfo(CHARVECTOR& cvTokens,
										CHARVECTOR::iterator& theIterator, 
										CParsedInfo& rParsedInfo)
{
	//BNF: CONTEXT /?[:<FULL|BRIEF>]
	BOOL		bContinue = TRUE;
	RETCODE		retCode   = PARSER_MESSAGE;

	// If option
	if (IsOption(*theIterator))
	{
		// Check for help
		retCode = IsHelp(cvTokens, theIterator,	rParsedInfo, CONTEXTHELP,
								 IDS_E_INVALID_CONTEXT_SYNTAX, LEVEL_ONE);

		// If more tokens are present.
		if (retCode == PARSER_CONTINUE)
		{
			rParsedInfo.GetCmdSwitchesObject().
				SetErrataCode(IDS_E_INVALID_CONTEXT_SYNTAX);
			retCode = PARSER_ERROR;
		}
			
	}
	else 
	{
		rParsedInfo.GetCmdSwitchesObject().
				SetErrataCode(IDS_E_INVALID_CONTEXT_SYNTAX);
		retCode = PARSER_ERROR;
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ValidateNodeOrNS
   Synopsis	         :This function validates the node or namespace
   Type	             :Member Function
   Input Parameter(s):
		pszInput	  - node/namesapce to be validated
		bNode		  - TRUE  - pszInput refers to NODE
						FALSE - pszInput refers to NAMESPACE
   Output parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ValidateNodeOrNS(pszInput, bNode)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL CParserEngine::ValidateNodeOrNS(_TCHAR* pszInput, BOOL bNode)
{
	IWbemServices*	pISvc	=	NULL;
	BOOL			bRet	=	TRUE;	
	HRESULT			hr		=	S_OK;

	try
	{	
		if(pszInput == NULL)
			bRet = FALSE;
		
		if(bRet)
		{
			
			if (m_pIWbemLocator != NULL)
			{	
				// Check for the presence of the following invalid
				// characters for NODE.
				if (bNode)
				{
					CHString str(pszInput);
					if (str.FindOneOf(L"\"\\,/[]:<>+=;?$#{}~`^@!'()*") != -1)
					{
						bRet = FALSE;
					};
				}

				if (bRet)
				{

					// Try to connect to root namespace
					_bstr_t bstrNS;
					if (bNode)
						bstrNS = _bstr_t(L"\\\\") + _bstr_t(pszInput) + _bstr_t(L"\\root");
					else
						bstrNS = _bstr_t(L"\\\\.\\") + _bstr_t(pszInput); 

					// Call the ConnectServer method of the IWbemLocator
					hr = m_pIWbemLocator->ConnectServer(bstrNS, NULL, NULL, NULL, 0L,
														NULL, NULL, &pISvc);
					if (FAILED(hr))
					{
						// If invalid machine name
						// 0x800706ba - RPC_SERVER_UNAVAILABLE
						if (bNode && (hr == 0x800706ba))
						{
							bRet = FALSE;
						}

						// If invalid namespace
						// 0x8004100E - WBEM_E_INVALID_NAMESPACE
						if (!bNode 
							&& ((hr == WBEM_E_INVALID_NAMESPACE) || 
								(hr == WBEM_E_INVALID_PARAMETER)))
						{
							bRet = FALSE;
						}
					}
					SAFEIRELEASE(pISvc);
				}
			}
		}
	}
	catch(_com_error& e)
	{
		bRet = FALSE;
		SAFEIRELEASE(pISvc);
		_com_issue_error(e.Error());
	}
	catch(CHeap_Exception)
	{
		bRet = FALSE;
		SAFEIRELEASE(pISvc);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return bRet;
}

/*----------------------------------------------------------------------------
Name				 :ParseAssocSwitches
Synopsis	         :This function does the parsing and interprets if command
					  has ASSOC as the verb. It parses the remaining tokens 
					  following and updates the same in CParsedInfo.
Type	             :Member Function
Input Parameter(s)   :cvTokens     - the tokens vector 
					  theIterator  - the Iterator to the cvTokens vector.
					  rParsedInfo  - reference to CParsedInfo class object
Output Parameter(s)  :rParsedInfo  - reference to CParsedInfo class object
Return Type          :RETCODE - enumerated data type
Global Variables     :None
Calling Syntax       :ParseAssocSwitch(cvTokens,theIterator,rParsedInfo)
Notes                :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseAssocSwitches(CHARVECTOR& cvTokens,
		CHARVECTOR::iterator& theIterator,
		CParsedInfo& rParsedInfo)
{
	RETCODE retCode = PARSER_EXECCOMMAND;
	
	while ( retCode == PARSER_EXECCOMMAND )
	{
		// Check for the presence of RESULT CLASS switch
		if (CompareTokens(*theIterator, CLI_TOKEN_RESULTCLASS)) 
		{
			retCode = ParseAssocSwitchEx(cvTokens, theIterator, rParsedInfo ,RESULTCLASS );
		}
		// Check for the presence of RESULT ROLE switch
		else if (CompareTokens(*theIterator,CLI_TOKEN_RESULTROLE )) 
		{
			retCode = ParseAssocSwitchEx(cvTokens, theIterator, rParsedInfo ,RESULTROLE );
		}
		// Check for the presence of ASSOC CLASS switch
		else if (CompareTokens(*theIterator,CLI_TOKEN_ASSOCCLASS )) 
		{
			retCode = ParseAssocSwitchEx(cvTokens, theIterator, rParsedInfo , ASSOCCLASS);
		}
		// Check for the presence of help
		else if (CompareTokens(*theIterator, CLI_TOKEN_HELP)) 
		{
			rParsedInfo.GetHelpInfoObject().SetHelp(ASSOCSwitchesOnly, TRUE);
			retCode = ParseHelp(cvTokens, theIterator, ASSOCVerb, rParsedInfo);
		}
		else
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
				IDS_E_INVALID_ASSOC_SWITCH);
			retCode = PARSER_ERROR;
			break;
		}
		
		//Checking the next tokens 		
		if ( retCode == PARSER_EXECCOMMAND )
		{
			if ( !GetNextToken(cvTokens, theIterator) )
				break;
			
			if ( !IsOption(*theIterator) )
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
					IDS_E_INVALID_COMMAND);
				retCode = PARSER_ERROR;
				break;
			}
			
			if ( !GetNextToken(cvTokens, theIterator) )
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
					IDS_E_INVALID_ASSOC_SWITCH);
				retCode = PARSER_ERROR;
				break;
			}
		}
	}
	return retCode;
}

/*----------------------------------------------------------------------------
Name				 :ParseAssocSwitchEx
Synopsis	         :This function does the parsing of tokens for the assoc 
					  switches It parses the remaining tokens following and 
					  updates the same in CParsedInfo.
Type	             :Member Function
Input Parameter(s)   :cvTokens     - the tokens vector 
					  theIterator  - the Iterator to the cvTokens vector.
					  rParsedInfo  - reference to CParsedInfo class object
					  assocSwitch  - the type of assoc switch
Output Parameter(s)  :rParsedInfo  - reference to CParsedInfo class object
Return Type          :RETCODE - enumerated data type
Global Variables     :None
Calling Syntax       :ParseAssocSwitchEx(cvTokens,theIterator,
						rParsedInfo,assocSwitch)
Notes                :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseAssocSwitchEx(CHARVECTOR& cvTokens,
											CHARVECTOR::iterator& theIterator,
											CParsedInfo& rParsedInfo ,
											ASSOCSwitch assocSwitch)
{
	RETCODE retCode		= PARSER_EXECCOMMAND;
	
	//Checking the next token to continue parsing 
	if ( GetNextToken(cvTokens, theIterator, rParsedInfo, ASSOCVerb,
		IDS_E_INVALID_ASSOC_SWITCH) == PARSER_CONTINUE )
	{
		//Checking for help option 
		if ( IsOption(*theIterator) &&
			(theIterator + 1) < cvTokens.end() &&
			CompareTokens(*(theIterator+1), CLI_TOKEN_HELP) )
		{
			theIterator++;
			//Help on RESULTCLASS
			if (assocSwitch == RESULTCLASS)
			{
				retCode = ParseHelp(cvTokens, theIterator, RESULTCLASShelp, 
					rParsedInfo);
				
			}	
			//Help on RESULTROLE
			if (assocSwitch == RESULTROLE)
			{
				retCode = ParseHelp(cvTokens, theIterator, RESULTROLEhelp, 
					rParsedInfo);
			}
			//Help on ASSOCCLASS
			if (assocSwitch == ASSOCCLASS)
			{
				retCode = ParseHelp(cvTokens, theIterator, ASSOCCLASShelp, 
					rParsedInfo);						
			}			
		}
		
		//If the command has ":" , then the corresponding data 
		//has to be set in Command object
		else if ( CompareTokens( *theIterator, CLI_TOKEN_COLON ) &&
			GetNextToken(cvTokens, theIterator, rParsedInfo, ASSOCVerb,
			IDS_E_INVALID_ASSOC_SWITCH) == PARSER_CONTINUE )
		{
			if ( IsOption(*theIterator) )
			{
				rParsedInfo.GetCmdSwitchesObject().
					SetErrataCode(IDS_E_INVALID_ASSOC_SWITCH);
				retCode = PARSER_ERROR;
			}
			
			else
			{
				//Setting the ResultClassName
				if (assocSwitch == RESULTCLASS)
				{
					if(rParsedInfo.GetCmdSwitchesObject().
						SetResultClassName(*theIterator))
					{
						retCode = PARSER_EXECCOMMAND;
					}
					else
					{
						retCode = PARSER_ERROR;
					}
				}
				//Setting the Result Role Name
				if (assocSwitch == RESULTROLE)
				{
					if(rParsedInfo.GetCmdSwitchesObject().
						SetResultRoleName(*theIterator))
					{
						retCode = PARSER_EXECCOMMAND;
					}
					else
					{
						retCode = PARSER_ERROR;
					}
				}
				//Setting the Assoc Class Name
				if (assocSwitch == ASSOCCLASS)
				{
					if(rParsedInfo.GetCmdSwitchesObject().
						SetAssocClassName(*theIterator))
					{
						retCode = PARSER_EXECCOMMAND;
					}
					else
					{
						retCode = PARSER_ERROR;
					}
				}
			}
		}
		else
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
				IDS_E_INVALID_ASSOC_SWITCH);
			retCode = PARSER_ERROR;
		}
	}
	else
		retCode = PARSER_ERROR;
	return retCode;
}

/*----------------------------------------------------------------------------
Name				 :ParseNumberedSwitch
Synopsis	         :This function does the parsing of tokens for the every 
					  and repeat switches. It parses the remaining tokens 
					  following and updates the same in CParsedInfo.
Type	             :Member Function
Input Parameter(s)   :cvTokens			- the tokens vector 
					  theIterator		- the Iterator to the cvTokens vector.
					  rParsedInfo		- reference to CParsedInfo class object
					  htHelp			- enumerated help type 
					  uSwitchErrCode	- error string ID.
					  uNumberErrCode	- error string ID.
					  
Output Parameter(s)  :rParsedInfo  - reference to CParsedInfo class object
Return Type          :RETCODE - enumerated data type
Global Variables     :None
Calling Syntax       :ParseNumberedSwitch(cvTokens, theIterator, rParsedInfo,
								EVERYorREPEAT, uSwitchErrCode,
								uNumberErrCode);

Notes                :None
----------------------------------------------------------------------------*/
RETCODE		CParserEngine::ParseNumberedSwitch(CHARVECTOR& cvTokens,
											CHARVECTOR::iterator& theIterator,
											CParsedInfo& rParsedInfo,
											HELPTYPE htHelp,
											UINT uSwitchErrCode,
											UINT uNumberErrCode)
{
	RETCODE retCode				= PARSER_EXECCOMMAND;
	BOOL	bInvalidSwitch		= FALSE;

	// Move to next token
	if (!GetNextToken(cvTokens, theIterator, rParsedInfo, htHelp,
					  uSwitchErrCode))	
		bInvalidSwitch = TRUE;
	else if ( IsOption(*theIterator) &&
			  (theIterator + 1) < cvTokens.end() &&
			  CompareTokens(*(theIterator+1), CLI_TOKEN_HELP) )
	{
		theIterator++;
		retCode = ParseHelp(cvTokens, theIterator, htHelp, rParsedInfo);
	}
	else if (CompareTokens(*theIterator, CLI_TOKEN_COLON)) 
	{
		BOOL bSuccess = FALSE;
		// Move to next token
		if (GetNextToken(cvTokens, theIterator))	
		{
			if ( IsOption(*theIterator) )
			{
				rParsedInfo.GetCmdSwitchesObject().
											SetErrataCode(uSwitchErrCode);
				retCode = PARSER_ERROR;
			}
			else
			{
				_TCHAR* pszEndPtr = NULL;
				ULONG	ulNumber = _tcstoul(*theIterator, &pszEndPtr, 10);
				if (!lstrlen(pszEndPtr))
				{
					BOOL bSetValue = TRUE;
					if ( htHelp == EVERY )
					{
						bSetValue = rParsedInfo.GetCmdSwitchesObject().
												SetRetrievalInterval(ulNumber);
					}
					else if ( htHelp == REPEAT )
					{
						if ( ulNumber == 0)
						{
							rParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(
								IDS_E_INVALID_REPEATCOUNT);
							retCode = PARSER_ERROR;
							bSetValue = FALSE;
						}
						else
						{
							bSetValue = rParsedInfo.GetCmdSwitchesObject().
								SetRepeatCount(ulNumber);
						}
					}
					
					if ( bSetValue == TRUE)
					{
						bSuccess = TRUE;
						rParsedInfo.GetCmdSwitchesObject().SetEverySwitchFlag(TRUE);
						retCode = PARSER_EXECCOMMAND;
					}
					else
					{
						bSuccess = FALSE;
						retCode = PARSER_ERROR;
					}
				}
			}
		}
		if ( bSuccess == FALSE )
		{
			// PARSER_ERROR if no more tokens are present. i.e <interval>
			// is not specified.
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(uNumberErrCode);
			retCode = PARSER_ERROR;
		}
	}
	else
		bInvalidSwitch = TRUE;

	if ( bInvalidSwitch == TRUE )
	{
		// PARSER_ERROR if no more tokens are present. i.e <interval>
		// is not specified.
		rParsedInfo.GetCmdSwitchesObject().SetErrataCode(uSwitchErrCode);
		retCode = PARSER_ERROR;
	}
	return retCode;
}

/*----------------------------------------------------------------------------
Name				 :IsValidClass
Synopsis	         :This function validates the class specified and 
					  returns True or False accordingly as the validity of
					  the class
Type	             :Member Function
Input Parameter(s)   :rParsedInfo  - reference to CParsedInfo class object					  			  
Output Parameter(s)  :rParsedInfo  - reference to CParsedInfo class object
Return Type          :BOOL
Global Variables     :None
Calling Syntax       :IsValidClass(rParsedInfo)
Notes                :None
----------------------------------------------------------------------------*/
BOOL	CParserEngine::IsValidClass(CParsedInfo& rParsedInfo)
{
	HRESULT				hr					= S_OK;
	IWbemClassObject*	pIObject			= NULL;
	CHString			chsMsg;
	DWORD				dwThreadId			= GetCurrentThreadId();
	BOOL				bTrace				= FALSE;
	ERRLOGOPT			eloErrLogOpt		= NO_LOGGING;
	
	// Obtain the trace flag status
	bTrace = rParsedInfo.GetGlblSwitchesObject().GetTraceStatus();

	eloErrLogOpt = rParsedInfo.GetErrorLogObject().GetErrLogOption();

	try 
	{
		hr = ConnectToNamespace(rParsedInfo);
		ONFAILTHROWERROR(hr);
		
		hr = m_pITargetNS->GetObject(_bstr_t(rParsedInfo.
							GetCmdSwitchesObject().GetClassPath()),
							WBEM_FLAG_USE_AMENDED_QUALIFIERS,	
							NULL,   &pIObject, NULL);
		if (bTrace || eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", "
					L"WBEM_FLAG_USE_AMENDED_QUALIFIERS, 0, NULL, -, -)", 
					rParsedInfo.GetCmdSwitchesObject().GetClassPath());		
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, dwThreadId,
					rParsedInfo, bTrace);
		}
		// do not add ONFAILTHROWERROR() here.
		SAFEIRELEASE(pIObject);
	}
	catch(_com_error &e)
	{
		hr = e.Error();
		SAFEIRELEASE(pIObject);
		_com_issue_error(e.Error());
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIObject);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return (SUCCEEDED(hr))? TRUE : FALSE;
}
									
/*----------------------------------------------------------------------------
Name				 :ObtainMethodsAvailableFlag
Synopsis	         :This function Checks whether methods are available with
					  alias in case of alias specified.and with class in case 
					  of class speicified.
Type	             :Member Function
Input Parameter(s)   :
		rParsedInfo  - reference to CParsedInfo class object					  			  
Output Parameter(s)  :None
Return Type          :void
Global Variables     :None
Calling Syntax       :ObtainMethodsAvailableFlag(rParsedInfo)
Notes                :None
----------------------------------------------------------------------------*/
void	CParserEngine::ObtainMethodsAvailableFlag(CParsedInfo& rParsedInfo)
{
	BOOL		bMethAvail	= TRUE;

	if ( m_bAliasName == TRUE )
		bMethAvail = m_CmdAlias.AreMethodsAvailable(rParsedInfo);
	else
		bMethAvail = ObtainClassMethods(rParsedInfo, TRUE);

	rParsedInfo.GetCmdSwitchesObject().SetMethodsAvailable(bMethAvail);
}

/*----------------------------------------------------------------------------
Name				 :ObtainWriteablePropsAvailailableFlag
Synopsis	         :Checks whether writable props are available with alias in 
					  case of alias specified. and with class in case of class 
					  speicified.
Type	             :Member Function
Input Parameter(s)   :
		rParsedInfo  - reference to CParsedInfo class object					  			  
Output Parameter(s)  :None
Return Type          :void
Global Variables     :None
Calling Syntax       :ObtainWriteablePropsAvailailableFlag(rParsedInfo)
Notes                :None
----------------------------------------------------------------------------*/
void	CParserEngine::ObtainWriteablePropsAvailailableFlag(
													CParsedInfo& rParsedInfo)
{
	BOOL		bWritePropsAvail	= TRUE;
	HRESULT     hr = S_OK;
	
	try
	{

		if ( m_bAliasName == TRUE )
		{
			hr = m_CmdAlias.ObtainAliasPropDetails(rParsedInfo, &bWritePropsAvail);
			ONFAILTHROWERROR(hr);
		}

		else
			bWritePropsAvail = ObtainClassProperties(rParsedInfo, TRUE);

		rParsedInfo.GetCmdSwitchesObject().SetWriteablePropsAvailable(
																bWritePropsAvail);
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*----------------------------------------------------------------------------
Name				 :ParseVerbInteractive
Synopsis	         :This function parses the verb interactive option
Type	             :Member Function
Input Parameter(s)   :
		cvTokens      - the tokens vector 
		theIterator   - the Iterator to the cvTokens vector.
		rParsedInfo   - reference to CParsedInfo class object					  			  
Output Parameter(s)  :
		rParsedInfo		- reference to CParsedInfo class object
		bInvalidOption  - Invalid syntax for interactive
Return Type          :RETCODE
Global Variables     :None
Calling Syntax       :ParseVerbInteractive(rParsedInfo)
Notes                :None
----------------------------------------------------------------------------*/
RETCODE	CParserEngine::ParseVerbInteractive(CHARVECTOR& cvTokens,
							CHARVECTOR::iterator& theIterator, 
							CParsedInfo& rParsedInfo, BOOL& bInvalidOption)
{
	RETCODE	retCode = PARSER_EXECCOMMAND;

	if (GetNextToken(cvTokens, theIterator))
	{
		// check for the presence of ':'
		if (CompareTokens(*theIterator, CLI_TOKEN_COLON))
		{			
			if (GetNextToken(cvTokens, theIterator))
			{
				if (IsOption(*theIterator))
				{
					if (GetNextToken(cvTokens, theIterator))
					{
						if (CompareTokens(*theIterator, CLI_TOKEN_HELP)) 
						{
							retCode = ParseHelp(cvTokens, theIterator, VERBSWITCHES, 
												rParsedInfo);
						}
						else
						{
							bInvalidOption = TRUE;
						}
					}
					else
					{
						bInvalidOption = TRUE;
					}
				}
				else
				{
					while (TRUE)
					{
						if(!rParsedInfo.GetCmdSwitchesObject().
												AddToInteractivePropertyList(*theIterator))
						{
							rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
										IDS_E_ADD_TO_PROP_LIST_FAILURE);
							retCode = PARSER_ERROR;
						}
						if (GetNextToken(cvTokens, theIterator))
						{
							// check for the presence of ','
							if (CompareTokens(*theIterator, CLI_TOKEN_COMMA))
							{
								if (!GetNextToken(cvTokens, theIterator))
								{
									rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											IDS_E_INVALID_PARAMLIST);
									retCode = PARSER_ERROR;
									break;
								}
							}
							else
							{
								rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											IDS_E_INVALID_PARAMLIST);
								retCode = PARSER_ERROR;
								break;
							}
						}
						else
						{
							retCode = PARSER_EXECCOMMAND;
							break;
						}
					}
				}
			}
			else
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
							IDS_E_INVALID_PARAMLIST);
				retCode = PARSER_ERROR;
			}
		}
		else if (IsOption(*theIterator))
		{
			if (GetNextToken(cvTokens, theIterator))
			{
				if (CompareTokens(*theIterator, CLI_TOKEN_HELP)) 
				{
					retCode = ParseHelp(cvTokens, theIterator, VERBSWITCHES, 
										rParsedInfo);
				}
				else
				{
					bInvalidOption = TRUE;
				}
			}
			else
			{
				bInvalidOption = TRUE;
			}
		}
		else
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
						IDS_E_INVALID_PARAMLIST);
			retCode = PARSER_ERROR;
		}
	}

	return retCode;
}

/*----------------------------------------------------------------------------
Name				 :ProcessOutputAndAppendFiles
Synopsis	         :Prepares the output and append files for output 
					  redirection.
Type	             :Member Function
Input Parameter(s)   :
	rParsedInfo		 - reference to CParsedInfo class object.
	retOCode		 - RETCODE type, specifies the initial RETCODE before 
					   calling the function.	 
	bOpenOutInWriteMode - boolean type, to specify flag of OpenOutInWriteMode. 
Output Parameter(s)  :
		rParsedInfo		- reference to CParsedInfo class object
Return Type          :RETCODE
Global Variables     :None
Calling Syntax       :ProcessOutputAndAppendFiles(rParsedInfo, retCode, FALSE)
Notes                :None
----------------------------------------------------------------------------*/
RETCODE	CParserEngine::ProcessOutputAndAppendFiles(CParsedInfo& rParsedInfo, 
												   RETCODE retOCode,
												   BOOL bOpenOutInWriteMode)
{
	RETCODE retCode = retOCode;

	// TRUE for getting output file name.
	_TCHAR* pszOutputFileName =
		rParsedInfo.GetGlblSwitchesObject().GetOutputOrAppendFileName(
																	TRUE);
	if ( pszOutputFileName != NULL )
	{
		// redirect the output to file.
		if ( CloseOutputFile() == TRUE )
		{
			FILE *fpOutFile;
			if ( bOpenOutInWriteMode == TRUE )
				fpOutFile = _tfopen(pszOutputFileName, _T("w"));
			else
				fpOutFile = _tfopen(pszOutputFileName, _T("a"));

			if ( fpOutFile == NULL )
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											  IDS_E_OPEN_OUTPUT_FILE_FAILURE);
				retCode = PARSER_ERROR;
			}
			else // TRUE for setting output file pointer.
				rParsedInfo.GetGlblSwitchesObject().
						SetOutputOrAppendFilePointer(fpOutFile, TRUE);
		}
	}

	// Processing for append file.

	if ( retCode == retOCode && bOpenOutInWriteMode == FALSE)
	{
		// FALSE for getting append file name.
		_TCHAR* pszAppendFileName =
			rParsedInfo.GetGlblSwitchesObject().GetOutputOrAppendFileName(
																	   FALSE);
		if ( pszAppendFileName != NULL )
		{
			if ( CloseAppendFile() == TRUE )
			{
				FILE* fpOpenAppendFile = _tfopen(pszAppendFileName, _T("a"));
				if ( fpOpenAppendFile == NULL )
				{
					 rParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(IDS_E_OPEN_APPEND_FILE_FAILURE);
					 retCode = PARSER_ERROR;
				}
				else
				{
					// FALSE for setting append file pointer. 
					rParsedInfo.GetGlblSwitchesObject().
								SetOutputOrAppendFilePointer(fpOpenAppendFile,
															 FALSE);
				}
			}
		}
	}

	return retCode;
}

/*----------------------------------------------------------------------------
Name				 :ParseUnnamedParamList
Synopsis	         :Parses Unnamed Parameter list.
Type	             :Member Function
Input Parameter(s)   :
	rParsedInfo		 - reference to CParsedInfo class object.
	cvTokens		 - the tokens vector 
	theIterator		 - the Iterator to the cvTokens vector.
Output Parameter(s)  :
	rParsedInfo		 - reference to CParsedInfo class object
Return Type          :RETCODE
Global Variables     :None
Calling Syntax       :ParseUnnamedParamList(cvTokens, theIterator,rParsedInfo);
Notes                :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseUnnamedParamList(CHARVECTOR& cvTokens,
											CHARVECTOR::iterator& theIterator,
											CParsedInfo& rParsedInfo)
{
	RETCODE	retCode		= PARSER_EXECCOMMAND;
	
	while (TRUE)
	{
		if(!rParsedInfo.GetCmdSwitchesObject().
								AddToPropertyList(*theIterator))
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
						IDS_E_ADD_TO_PROP_LIST_FAILURE);
			retCode = PARSER_ERROR;
		}
		if (GetNextToken(cvTokens, theIterator))
		{
			if (IsOption(*theIterator))
			{
				// To facilitate ParseVerbSwitches to continue
				theIterator--;
				break;
			}
			else
			{
				// check for the presence of ','
				if (CompareTokens(*theIterator, CLI_TOKEN_COMMA))
				{
					if (!GetNextToken(cvTokens, theIterator))
					{
						rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
								IDS_E_INVALID_PARAMLIST);
						retCode = PARSER_ERROR;
						break;
					}
				}
				else
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
								IDS_E_INVALID_PARAMLIST);
					retCode = PARSER_ERROR;
					break;
				}
			}
		}
		else
			break;
	}

	return retCode;
}

/*----------------------------------------------------------------------------
Name				 :ValidateVerbOrMethodParams
Synopsis	         :Validates the named params with verb or method parameters.
Type	             :Member Function
Input Parameter(s)   :
	rParsedInfo		 - reference to CParsedInfo class object.	
Output Parameter(s)  :
	rParsedInfo		 - reference to CParsedInfo class object
Return Type          :RETCODE
Global Variables     :None
Calling Syntax       :ValidateVerbOrMethodParams(rParsedInfo);
Notes                :None
----------------------------------------------------------------------------*/
RETCODE		CParserEngine::ValidateVerbOrMethodParams(CParsedInfo& rParsedInfo)
{
	RETCODE retCode	= PARSER_EXECCOMMAND;
	BSTRMAP::iterator theIterator;
	PROPDETMAP::iterator propIterator;
	// Info about verb or method params.
	PROPDETMAP pdmVerbOrMethParams = (*(rParsedInfo.GetCmdSwitchesObject().
									  GetMethDetMap().begin())).second.Params;

	BSTRMAP	   bmNamedParams = rParsedInfo.GetCmdSwitchesObject().
															GetParameterMap();

	for ( theIterator = bmNamedParams.begin();
		  theIterator != bmNamedParams.end(); theIterator++ )
	{
		BOOL bFind;
		if ( rParsedInfo.GetCmdSwitchesObject().GetVerbType() == CMDLINE )
			bFind = Find(pdmVerbOrMethParams,(*theIterator).first, 
														propIterator, TRUE);
		else
			bFind = Find(pdmVerbOrMethParams,(*theIterator).first, 
														propIterator);

		if ( bFind == FALSE )
		{
			DisplayMessage((*theIterator).first, CP_OEMCP, TRUE, TRUE);
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
												IDS_E_NOT_A_VERBORMETH_PARAM);
			retCode = PARSER_ERROR;
			break;
		}
		else if ( (*propIterator).second.InOrOut != INP )
		{
			DisplayMessage((*theIterator).first, CP_OEMCP, TRUE, TRUE);
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
												IDS_E_NOT_A_INPUT_PARAM);
			retCode = PARSER_ERROR;
			break;
		}
	}
	
	return retCode;
}

/*----------------------------------------------------------------------------
Name				 :ParseParamsString
Synopsis	         :Parses the parameter string 
Type	             :Member Function
Input Parameter(s)   :
	rParsedInfo		 - reference to CParsedInfo class object.	
	cvTokens		 - the tokens vector 
	theIterator		 - the Iterator to the cvTokens vector.
	xdXSLTDet		 - reference to the XSLdetails vector
	pszXSLFile		 - string type, XSL file name.
Output Parameter(s)  :
	rParsedInfo		 - reference to CParsedInfo class object
Return Type          :RETCODE
Global Variables     :None
Calling Syntax       :ParseParamsString(cvTokens, theIterator, rParsedInfo, 
										xdXSLTDet, pszXSLFile);
Notes                :None
----------------------------------------------------------------------------*/
RETCODE		CParserEngine::ParseParamsString(CHARVECTOR& cvTokens,
											CHARVECTOR::iterator& theIterator,
											CParsedInfo& rParsedInfo,
											XSLTDET& xdXSLTDet,
											_TCHAR* pszXSLFile)
{
	pszXSLFile = NULL;
	RETCODE retCode = PARSER_EXECCOMMAND ;

	try
	{
		if ( !GetNextToken(cvTokens, theIterator) )
		{
			rParsedInfo.GetCmdSwitchesObject().
					SetErrataCode(IDS_E_INVALID_FORMAT);
			retCode = PARSER_ERROR;
		}
		else if ( IsOption(*theIterator) )
		{
			rParsedInfo.GetCmdSwitchesObject().
					SetErrataCode(IDS_E_INVALID_FORMAT);
			retCode = PARSER_ERROR;
		}
		else
		{
			while ( retCode == PARSER_EXECCOMMAND )
			{
		
				_TCHAR*		pszParam		= NULL;
				_TCHAR*		pszParamValue	= NULL;

				pszParam = _tcstok(*theIterator,CLI_TOKEN_EQUALTO);

				if(pszParam != NULL)
				{
					pszParamValue = _tcstok(NULL,CLI_TOKEN_EQUALTO);
					if(pszParamValue != NULL)
					{
						_bstr_t bstrParam = pszParam;
						_bstr_t bstrParamValue = pszParamValue;
						if(IsOption(pszParamValue))
						{
							rParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(IDS_E_INVALID_FORMAT);
							retCode = PARSER_ERROR;
						}
						else
							xdXSLTDet.ParamMap.insert(BSTRMAP::value_type(
												  bstrParam, bstrParamValue));

					}
					else
						pszXSLFile = pszParam;
				}
				else
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(IDS_E_INVALID_FORMAT);
					retCode = PARSER_ERROR;
				}

				if ( retCode == PARSER_EXECCOMMAND )
				{
					if ( !GetNextToken(cvTokens, theIterator) )
						break;
					else if ( IsOption(*theIterator) )
						break;
					else if (CompareTokens(*theIterator, CLI_TOKEN_COMMA))
					{
						if ( theIterator + 1 == cvTokens.end() )
							break;
						else if ( theIterator + 2 == cvTokens.end() )
							break;
						else if ( pszParamValue == NULL )
							break;
						else
							theIterator++;
					}
				}
			}
		}
	}
	catch(_com_error& e)
	{
		retCode = PARSER_ERROR;
		_com_issue_error(e.Error());
	}
	return retCode;
}

/*----------------------------------------------------------------------------
Name				 :ParseNodeListFile
Synopsis	         :Parses the node list file.
Type	             :Member Function
Input Parameter(s)   :
	rParsedInfo		 - reference to CParsedInfo class object.	
	cvTokens		 - the tokens vector 
	theIterator		 - the Iterator to the cvTokens vector.	
Output Parameter(s)  :
	rParsedInfo		 - reference to CParsedInfo class object
Return Type          :RETCODE
Global Variables     :None
Calling Syntax       :ParseNodeListFile(cvTokens, theIterator,rParsedInfo);
Notes                :None
----------------------------------------------------------------------------*/
RETCODE	CParserEngine::ParseNodeListFile(CHARVECTOR& cvTokens,
								   	     CHARVECTOR::iterator& theIterator,
										 CParsedInfo& rParsedInfo)
{
	RETCODE				retCode					= PARSER_CONTINUE;
	_TCHAR				*pszTempFileName		= (*theIterator+1);
	_TCHAR				*szNodeListFileName		= new _TCHAR [BUFFER512];
	if (szNodeListFileName == NULL)
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);

	lstrcpy(szNodeListFileName, pszTempFileName);
	UnQuoteString(szNodeListFileName);
	FILE				*fpNodeListFile			= 
										_tfopen(szNodeListFileName, _T("rb"));
	LONG				lNumberOfInserts		= 0;
	CHARVECTOR::iterator itrVectorInCmdTkzr		= NULL;
	_TCHAR				*pszComma				= NULL;
	_TCHAR				*pszNode				= NULL;
	FILETYPE			eftNodeFileType			= ANSI_FILE;
	char				*pszFirstTwoBytes		= NULL;
	
	try
	{
		if ( fpNodeListFile != NULL )
		{
			Find(m_CmdTknzr.GetTokenVector(), *theIterator, itrVectorInCmdTkzr);
			SAFEDELETE(*itrVectorInCmdTkzr);
			itrVectorInCmdTkzr = m_CmdTknzr.GetTokenVector().erase(itrVectorInCmdTkzr);

			// Remove @nodelistfile token from token vector.
			theIterator = cvTokens.erase(theIterator);

			// Indentifing the file type whether Unicode or ANSI.
			pszFirstTwoBytes = new char[2];
			fread(pszFirstTwoBytes, 2, 1, fpNodeListFile);

			if ( memcmp(pszFirstTwoBytes, UNICODE_SIGNATURE, 2)	== 0 )
			{
				eftNodeFileType = UNICODE_FILE;
			} 
			else if (memcmp(pszFirstTwoBytes, UNICODE_BIGEND_SIGNATURE, 2) == 0 )
			{
				eftNodeFileType = UNICODE_BIGENDIAN_FILE;
			}
			else if( memcmp(pszFirstTwoBytes, UTF8_SIGNATURE, 2) == 0 )
			{
				eftNodeFileType = UTF8_FILE;
			}
			else
			{
				eftNodeFileType = ANSI_FILE;
				fseek(fpNodeListFile, 0, SEEK_SET);
			}
			SAFEDELETE(pszFirstTwoBytes);

			_TCHAR	szNodeName[BUFFER512] = NULL_STRING;

			if ( GetNodeFromNodeFile(fpNodeListFile, eftNodeFileType,
														szNodeName) == FALSE )
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
														IDS_E_NODELISTFILE_EMPTY);
				retCode = PARSER_ERROR;
			}
			else
			{
				BOOL	bFirstTime = TRUE;
				do
				{
					LONG lNodeStrLen = lstrlen(szNodeName); 
					if ( szNodeName[lNodeStrLen-1] == _T('\n') )
						szNodeName[lNodeStrLen-1] = _T('\0');

					CHString strRawNodeName(szNodeName);
					strRawNodeName.TrimLeft();
					strRawNodeName.TrimRight();

					lstrcpy(szNodeName, strRawNodeName.GetBuffer(BUFFER512));

					if ( szNodeName[0] != _T('#') &&
						 strRawNodeName.IsEmpty() == FALSE )
					{
						if ( bFirstTime == FALSE )
						{
							pszComma = new _TCHAR[lstrlen(
														CLI_TOKEN_COMMA) + 1];
							if (pszComma == NULL)
								_com_issue_error(WBEM_E_OUT_OF_MEMORY);

							lstrcpy(pszComma, CLI_TOKEN_COMMA);
							theIterator = cvTokens.insert(theIterator, pszComma);
							theIterator++;
							itrVectorInCmdTkzr = m_CmdTknzr.GetTokenVector().
													insert(itrVectorInCmdTkzr,
														   pszComma);
							itrVectorInCmdTkzr++;
							lNumberOfInserts++;
						}
						else
							bFirstTime = FALSE;

						lNodeStrLen = lstrlen(szNodeName);

						pszNode = new _TCHAR[lNodeStrLen + 1];
						if (pszNode == NULL)
							_com_issue_error(WBEM_E_OUT_OF_MEMORY);

						lstrcpy(pszNode, szNodeName);

						theIterator = cvTokens.insert(theIterator, pszNode);
						theIterator++;
						itrVectorInCmdTkzr = m_CmdTknzr.GetTokenVector().insert(
													 itrVectorInCmdTkzr, pszNode);
						itrVectorInCmdTkzr++;
						lNumberOfInserts++;
					}
				}
				while ( GetNodeFromNodeFile(fpNodeListFile, eftNodeFileType,
														szNodeName) == TRUE );

				if ( lNumberOfInserts == 0 )
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
													IDS_E_NO_NODES_FOR_INSERTION);
					retCode = PARSER_ERROR;
				}

				theIterator = theIterator - lNumberOfInserts;
			}

			fclose(fpNodeListFile);
		}
		else
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
												 IDS_E_NODELISTFILE_OPEN_FAILURE);
			retCode = PARSER_ERROR;
		}
		SAFEDELETE(szNodeListFileName);
	}
	catch(CHeap_Exception)
	{
		retCode = PARSER_ERROR;
		SAFEDELETE(szNodeListFileName);
		SAFEDELETE(pszFirstTwoBytes);
		retCode = PARSER_ERROR;
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	catch(_com_error& e)
	{
		retCode = PARSER_ERROR;
		SAFEDELETE(szNodeListFileName);
		SAFEDELETE(pszComma);
		SAFEDELETE(pszNode);
		SAFEDELETE(pszFirstTwoBytes);
		_com_issue_error(e.Error());
	}
	return retCode;
}


/*----------------------------------------------------------------------------
Name				 :GetNodeFromNodeFile
Synopsis	         :Retrieves the node list file.
Type	             :Member Function
Input Parameter(s)   :
	fpNodeListFile	 - pointer to File containing node list.
	eftNodeFileType  - Enum value specifing unicode or ANSI ....
Output Parameter(s)  :
	szNodeName		 - pointer to string specifing node to be returned.	
Return Type          :BOOL
Global Variables     :None
Calling Syntax       :GetNodeFromNodeFile(fpNodeListFile, eftNodeFileType,
																  szNodeName);
Notes                :None
----------------------------------------------------------------------------*/
BOOL CParserEngine::GetNodeFromNodeFile(FILE*	 fpNodeListFile, 
										FILETYPE eftNodeFileType,
										_TCHAR*	 szNodeName)
{
	WCHAR		wszNodeName[2]			= L"";
	char		cszNodeName[2]			= "";
	_TCHAR		szTemp[2]				= NULL_STRING; 

	try
	{
		lstrcpy(szNodeName, NULL_STRING);

		while( TRUE )
		{
			lstrcpy(szTemp, NULL_STRING);
			
			if ( eftNodeFileType == UNICODE_FILE )
			{
				if ( fgetws(wszNodeName, 2, fpNodeListFile) != NULL )
				{
					lstrcpy(szTemp, (_TCHAR*)_bstr_t(wszNodeName));
				}
				else
					break;
			}
			else if ( eftNodeFileType == UNICODE_BIGENDIAN_FILE )
			{
				if ( fgetws(wszNodeName, 2, fpNodeListFile) != NULL )
				{
					BYTE HiByte = HIBYTE(wszNodeName[0]);
					BYTE LowByte = LOBYTE(wszNodeName[0]);
					wszNodeName[0] = MAKEWORD(HiByte, LowByte);
					lstrcpy(szTemp, (_TCHAR*)_bstr_t(wszNodeName));
				}
				else
					break;
			}
			else if ( eftNodeFileType == UTF8_FILE )
			{
				if ( fgets(cszNodeName, 2, fpNodeListFile) != NULL )
				{
					MultiByteToWideChar(
					  CP_UTF8,         // code page
					  0,         // character-type options
					  cszNodeName, // string to map
					  2,       // number of bytes in string
					  wszNodeName,  // wide-character buffer
					  2        // size of buffer
						);
					lstrcpy(szTemp, (_TCHAR*)_bstr_t(wszNodeName));
				}
				else
					break;
			}
			else
			{
				if ( fgets(cszNodeName, 2, fpNodeListFile) != NULL )
				{
					lstrcpy(szTemp, (_TCHAR*)_bstr_t(cszNodeName));
				}
				else
					break;
			}

			if ( _tcscmp(szTemp, CLI_TOKEN_SPACE)		== 0	||
				 _tcscmp(szTemp, CLI_TOKEN_TAB)			== 0	||
				 _tcscmp(szTemp, CLI_TOKEN_SEMICOLON)	== 0	||
				 _tcscmp(szTemp, CLI_TOKEN_COMMA)		== 0	||
				 _tcscmp(szTemp, CLI_TOKEN_DOUBLE_QUOTE)== 0	||
				 _tcscmp(szTemp, CLI_TOKEN_NEWLINE)		== 0 )
			{
				break;
			}
			else
			{
				lstrcat(szNodeName, szTemp);
			}
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}

	return (!feof(fpNodeListFile) || _tcscmp(szNodeName, NULL_STRING));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\parsedinfo.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: ParsedInfo.h 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Revision History			: 
	Last Modified by		: Ch. Sriramachandramurthy
	Last Modified Date		: 16th-January-2001
****************************************************************************/ 
/*-------------------------------------------------------------------
 Class Name			: CParsedInfo
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the functionality needed
					  for accessing the storing the parsed command line
					  information. 
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: CGlobalSwitches
					  CCommandSwitches	
					  CHelpInfo
 Interfaces Used    : None
 --------------------------------------------------------------------*/
class CGlobalSwitches;
class CCommandSwitches;
class CHelpInfo;
class CErrorLog;

/////////////////////////////////////////////////////////////////////////////
class CParsedInfo
{
// Construction
public:
	CParsedInfo();

// Destruction
public:
	~CParsedInfo();

// Restrict Assignment
	CParsedInfo& operator=(CParsedInfo& rParsedInfo);

// Attributes
private:
	//member variable for storing Command switches
	CCommandSwitches	m_CmdSwitches;
	
	//member variable for storing Global switches
	CGlobalSwitches		m_GlblSwitches;
	
	//member variable for Help support
	CHelpInfo			m_HelpInfo;

	CErrorLog			m_ErrorLog;

	_TCHAR				m_pszPwd[2];
	
	WMICLIINT			m_bNewCmd;

	BOOL				m_bNewCycle;

// Operations
public:
	//Returns the member object "m_CmdSwitches"
	CCommandSwitches&	GetCmdSwitchesObject();
	
	//Returns the member object "m_GLblSwitches"
	CGlobalSwitches&	GetGlblSwitchesObject();
	
	//Returns the member object "m_HelpInfo"
	CHelpInfo&			GetHelpInfoObject();

	//Returns the member object m_ErrorLog;
	CErrorLog&			GetErrorLogObject();
	
	//Member function for initializing member variables
	void				Initialize();
	
	//Member function for uninitializing member variables
	void				Uninitialize(BOOL bBoth);
	
	// Returns user name
	_TCHAR*				GetUser();
	
	// Returns node name
	_TCHAR*				GetNode();

	// Returns locale value
	_TCHAR*				GetLocale();

	// Returns password 
	_TCHAR*				GetPassword();

	// Returns namespace value
	_TCHAR*				GetNamespace();

	// Returns the user. if NULL returns "N/A"
	void				GetUserDesc(_bstr_t& bstrUser);

	BOOL				GetNewCommandStatus();

	void				SetNewCommandStatus(BOOL bStatus);

	BOOL				GetNewCycleStatus();

	void				SetNewCycleStatus(BOOL bStatus);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WmiCli.rc
//
#define IDS_E_BLANK_COMMAND_MESSAGE     44001
#define IDS_E_INCOMPLETE_COMMAND        44002
#define IDS_E_RPC_SERVER_NOT_AVAILABLE  44003
#define IDS_E_0_REPEAT_NOT_WITH_0_EVERY 44004
#define IDS_E_INVALID_COMMAND           44005
#define IDS_E_INVALID_REPEAT_SWITCH     44006
#define IDS_E_INVALID_LIST_USAGE        44007
#define IDS_E_INVALID_REPEATCOUNT       44008
#define IDS_E_0_EVERY_NOT_WITH_0_REPEAT 44009
#define IDS_E_PWHERE_UNDEF              44010
#define IDS_E_CLOSE_OUT_FILE_ERROR      44011
#define IDS_E_INVALID_TRANSLATE_SWITCH  44012
#define IDS_E_TRANSLATE_TABLE_NOT_EXIST 44013
#define IDS_I_NOEXECUTE                 44014
#define IDS_E_VERBS_NOT_AVAIL           44015
#define IDS_E_CLASSMETHS_NOT_AVAIL      44016
#define IDS_E_STDOUT_REDIR_FAIL         44017
#define IDS_E_FILE_ALREADY_OPEN_FOR_APPEND 44018
#define IDS_E_OUTPUT_FILE_ALREADY_OPEN_FOR_APPEND 44018
#define IDS_E_FILE_ALREADY_OPEN_FOR_OUTPUT 44019
#define IDS_E_APPEND_FILE_ALREADY_OPEN_FOR_OUTPUT 44019
#define IDS_E_CLOSE_APPEND_FILE_ERROR   44020
#define INVALID_E_FILE_NAME_OPENS_WITH_NAME 44021
#define IDS_E_VERB_DERV_NOT_AVAIL_IN_ALIAS 44022
#define IDS_E_INVALID_FILENAME          44023
#define IDS_E_REDIRECTION_FAIL          44024
#define IDS_E_FILE_ALREADY_OPEN_FOR_RECORD 44025
#define IDS_E_OUTPUT_FILE_ALREADY_OPEN_FOR_RECORD 44025
#define IDS_E_RECORD_FILE_ALREADY_OPEN_FOR_OUTPUT 44026
#define IDS_E_RECORD_FILE_ALREADY_OPEN_FOR_APPEND 44027
#define IDS_E_INVALID_CLASS_METHOD      44028
#define IDS_E_INVALID_ALIAS_VERB        44029
#define IDS_E_NODELISTFILE_OPEN_FAILURE 44030
#define IDS_E_NODELISTFILE_EMPTY        44031
#define IDS_E_NO_NODES_FOR_INSERTION    44032
#define IDS_E_APPEND_FILE_ALREADY_OPEN_FOR_RECORD 44033
#define IDS_E_INVALID_NAMESPACE_SYNTAX  44102
#define IDS_E_INVALID_MACHINE_NAME      44103
#define IDS_E_INVALID_IMP_LEVEL         44104
#define IDS_E_INVALID_AUTH_LEVEL        44105
#define IDS_E_INVALID_LOCALE            44106
#define IDS_E_INCORRECT_NAMESPACE       44107
#define IDS_E_INVALID_NODE_SYNTAX       44108
#define IDS_E_INVALID_IMP_LEVEL_SYNTAX  44109
#define IDS_E_INVALID_ROLE_SYNTAX       44110
#define IDS_E_INVALID_AUTH_LEVEL_SYNTAX 44111
#define IDS_E_INVALID_LOCALE_SYNTAX     44112
#define IDS_E_INVALID_PRIVILEGES_SYNTAX 44113
#define IDS_E_INVALID_PRIVILEGES        44114
#define IDS_E_INVALID_TRACE_SYNTAX      44115
#define IDS_E_INVALID_TRACE_OPTION      44116
#define IDS_E_INVALID_RECORD_SYNTAX     44117
#define IDS_E_INVALID_RECORD_PATH       44118
#define IDS_E_INVALID_USER_SYNTAX       44119
#define IDS_E_INVALID_USER_ID           44120
#define IDS_E_INVALID_PASSWORD_SYNTAX   44121
#define IDS_E_INVALID_PASSWORD          44122
#define IDS_E_INVALID_HELP_OPTION       44123
#define IDS_E_INVALID_HELP_SYNTAX       44124
#define IDS_E_INVALID_GLOBAL_SWITCH     44125
#define IDS_E_INVALID_PRIVILEGES_OPTION 44126
#define IDS_E_INVALID_CODEPAGE          44127
#define IDS_E_INVALID_CODEPAGE_SYNTAX   44128
#define IDS_E_INVALID_ROLE              44129
#define IDS_E_INVALID_LIST_SWITCH       44130
#define IDS_E_PASSWORD_WITHOUT_USER     44131
#define IDS_E_INVALID_NAMESPACE         44132
#define IDS_E_INVALID_NODE              44133
#define IDS_E_INVALID_INTERACTIVE_OPTION 44134
#define IDS_E_ALIAS_NOT_FOUND           44135
#define IDS_E_INVALID_FAILFAST_OPTION   44136
#define IDS_E_INVALID_OUTPUT_OPTION     44137
#define IDS_E_INVALID_OUTPUT_SYNTAX     44138
#define IDS_E_INVALID_APPEND_OPTION     44139
#define IDS_E_INVALID_APPEND_SYNTAX     44140
#define IDS_E_OPEN_APPEND_FILE_FAILURE  44141
#define IDS_E_OPEN_OUTPUT_FILE_FAILURE  44142
#define IDS_E_INVALID_AGGREGATE_OPTION  44143
#define IDS_E_INVALID_AGGREGATE_SYNTAX  44144
#define IDS_E_INVALID_PATH              44201
#define IDS_E_INVALID_QUERY             44202
#define IDS_E_INVALID_EXPRESSION        44204
#define IDS_E_INVALID_VERB              44205
#define IDS_E_INVALID_INTERVAL          44206
#define IDS_E_INVALID_PATH_SYNTAX       44207
#define IDS_E_INVALID_WHERE_SYNTAX      44208
#define IDS_E_INVALID_CLASS_SYNTAX      44209
#define IDS_E_INVALID_FORMAT            44210
#define IDS_E_INVALID_LIST_FORMAT       44211
#define IDS_E_INVALID_GET_SWITCH        44212
#define IDS_E_INVALID_XML_CONTENT       44213
#define IDS_E_INVALID_LIST_EXPRESSION   44214
#define IDS_E_INVALID_CLASS             44215
#define IDS_E_INVALID_INTERIM_XML_CONTENT 44216
#define IDS_E_REGMOF_FAILED             44217
#define IDS_E_ERRLOG_WRITEFAIL          44218
#define IDS_E_ERRLOG_OPENFAIL           44219
#define IDS_E_INVALID_GET_EXPRESSION    44220
#define IDS_E_INVALID_ALIAS_COMMAND     44503
#define IDS_E_MEMALLOC_FAIL             44504
#define IDS_E_INVALID_EVERY_SWITCH      44505
#define IDS_E_INVALID_VERB_SWITCH       44506
#define IDS_E_INVALID_NO_OF_PARAMS      44507
#define IDS_E_INVALID_NAMED_PARAM_LIST  44508
#define IDS_E_CMD_INTERPTR_NOT_FOUND    44509
#define IDS_E_CMD_INTPTR_INVALID_FORMAT 44510
#define IDS_E_NOT_ENOUGH_MEM_AVLBL      44511
#define IDS_E_ALIAS_OR_PATH_SHOULD_PRECEED_WHERE 44512
#define IDS_E_INVALID_PWHERE_EXPR       44513
#define IDS_E_INVALID_INTERACTIVE_SYNTAX 44514
#define IDS_E_INVALID_FAILFAST_SYNTAX   44515
#define IDS_E_WRITELOG_FAILED           44516
#define IDS_E_NOT_A_INPUT_PARAM         44517
#define IDS_E_METHOD_HAS_NO_IN_PARAMS   44518
#define IDS_E_INAVALID_PROP_LIST        44519
#define IDS_E_WMIC_UNKNOWN_ERROR        44520
#define IDS_I_USAGE                     45001
#define IDS_I_GET_DESC                  45002
#define IDS_I_GET_USAGE                 45003
#define IDS_I_GET_SWITCH_HEAD           45004
#define IDS_I_GET_SWITCH_VALUE          45005
#define IDS_I_GET_SWITCH_ALL            45006
#define IDS_I_SWITCH_TRANSLATE          45007
#define IDS_I_SWITCH_EVERY              45008
#define IDS_I_SWITCH_FORMAT             45009
#define IDS_I_NEWLINE                   45010
#define IDS_I_LIST_DESC                 45011
#define IDS_I_LIST_USAGE                45012
#define IDS_I_LIST_NOFORMATS            45013
#define IDS_I_LIST_FMT_HEAD             45014
#define IDS_I_LIST_SWITCH_HEAD          45015
#define IDS_I_CALL_DESC                 45016
#define IDS_I_CALL_USAGE                45017
#define IDS_I_CALL_PARAM_NOTE           45018
#define IDS_I_SET_DESC                  45019
#define IDS_I_SET_USAGE                 45020
#define IDS_I_ASSIGNLIST_NOTE1          45021
#define IDS_I_ASSIGNLIST_NOTE2          45022
#define IDS_I_CREATE_DESC               45023
#define IDS_I_PROPERTYLIST_NOTE1        45024
#define IDS_I_CREATE_NOTE               45025
#define IDS_I_CREATE_USAGE              45026
#define IDS_I_DELETE_DESC               45027
#define IDS_I_DELETE_NOTE               45028
#define IDS_I_DELETE_USAGE              45029
#define IDS_I_ASSOC_DESC                45030
#define IDS_I_ASSOC_USAGE               45031
#define IDS_I_ASSOC_FMT_NOTE            45032
#define IDS_I_ALIASCMD_HEAD             45033
#define IDS_I_CMD_MORE                  45034
#define IDS_I_ALIASCMD_NOT_AVLBL        45035
#define IDS_I_NAMESPACE_DESC1           45036
#define IDS_I_NAMESPACE_DESC2           45037
#define IDS_I_NAMESPACE_DESC3           45038
#define IDS_I_NAMESPACE_DESC4           45039
#define IDS_I_NAMESPACE_USAGE           45040
#define IDS_I_REPEAT_NOTE               45041
#define IDS_I_ROLE_DESC1                45042
#define IDS_I_ROLE_DESC2                45043
#define IDS_I_ROLE_USAGE                45044
#define IDS_I_ROLE_NOTE1                45045
#define IDS_I_ROLE_NOTE2                45046
#define IDS_I_ROLE_NOTE3                45047
#define IDS_I_NODE_DESC                 45048
#define IDS_I_NODE_USAGE                45049
#define IDS_I_NODE_NOTE                 45050
#define IDS_I_IMPLEVEL_DESC1            45051
#define IDS_I_IMPLEVEL_DESC2            45052
#define IDS_I_IMPLEVEL_USAGE            45053
#define IDS_I_IMPLEVEL_HEAD             45054
#define IDS_I_IMPLEVEL_HEAD1            45055
#define IDS_I_IMPLEVEL_HEAD2            45056
#define IDS_I_IMPLEVEL_ANON             45057
#define IDS_I_IMPLEVEL_IDENTIFY         45058
#define IDS_I_IMPLEVEL_IMPERSONATE      45059
#define IDS_I_IMPLEVEL_DELEGATE         45060
#define IDS_I_AUTHLEVEL_DESC1           45061
#define IDS_I_AUTHLEVEL_DESC2           45062
#define IDS_I_AUTHLEVEL_HEAD            45063
#define IDS_I_AUTHLEVEL_HEAD1           45064
#define IDS_I_AUTHLEVEL_HEAD2           45065
#define IDS_I_AUTHLEVEL_DEFAULT         45066
#define IDS_I_AUTHLEVEL_NONE            45067
#define IDS_I_AUTHLEVEL_CONNECT         45068
#define IDS_I_AUTHLEVEL_CALL            45069
#define IDS_I_AUTHLEVEL_PKT             45070
#define IDS_I_AUTHLEVEL_PKTINTGRTY      45071
#define IDS_I_AUTHLEVEL_PKTPRVCY        45072
#define IDS_I_AUTHLEVEL_USAGE           45073
#define IDS_I_LOCALE_DESC               45074
#define IDS_I_LOCALE_USAGE              45075
#define IDS_I_LOCALE_NOTE1              45076
#define IDS_I_LOCALE_NOTE2              45077
#define IDS_I_PRIVILEGES_DESC           45078
#define IDS_I_PRIVILEGES_USAGE          45079
#define IDS_I_PRIVILEGES_NOTE           45080
#define IDS_I_TRACE_DESC1               45081
#define IDS_I_TRACE_DESC2               45082
#define IDS_I_TRACE_USAGE               45083
#define IDS_I_TRACE_NOTE                45084
#define IDS_I_RECORD_DESC               45085
#define IDS_I_RECORD_USAGE              45086
#define IDS_I_INTERACTIVE_DESC          45087
#define IDS_I_INTERACTIVE_USAGE         45088
#define IDS_I_USER_DESC                 45089
#define IDS_I_USER_USAGE                45090
#define IDS_I_USER_NOTE                 45091
#define IDS_I_PASSWORD_DESC             45092
#define IDS_I_PASSWORD_USAGE            45093
#define IDS_I_HELP_DESC                 45094
#define IDS_I_HELP_USAGE                45095
#define IDS_I_HELP_NOTE                 45096
#define IDS_I_ALIASVERB_HEAD            45097
#define IDS_I_VERB_HEAD                 45098
#define IDS_I_ALIASVERB_NOT_AVLBL       45099
#define IDS_I_VERB_NOT_AVLBL            45100
#define IDS_I_PROP_WRITEABLE_HEAD       45101
#define IDS_I_PROP_HEAD                 45102
#define IDS_I_PROP_WRITEABLE_NOT_AVLBL  45103
#define IDS_I_STDVERB_HEAD              45104
#define IDS_I_GLBLCMD                   45105
#define IDS_I_GLBL_SWITCH_HEAD          45106
#define IDS_I_CLASSPATH_MORE            45107
#define IDS_I_PATH_DESC                 45108
#define IDS_I_PATH_USAGE                45109
#define IDS_I_WHERE_DESC1               45110
#define IDS_I_WHERE_DESC2               45111
#define IDS_I_WHERE_USAGE               45112
#define IDS_I_CLASS_DESC                45113
#define IDS_I_CLASS_USAGE               45114
#define IDS_I_PWHERE_DESC1              45115
#define IDS_I_PWHERE_DESC2              45116
#define IDS_I_PWHERE_USAGE              45117
#define IDS_I_PAKTC                     45118
#define IDS_I_PAKTC_ERASE               45119
#define IDS_I_SWITCH_TRANSLATE_FULL_DESC 45120
#define IDS_I_SWITCH_TRANSLATE_USAGE    45121
#define IDS_I_TRANSLATE_HEAD            45122
#define IDS_I_TRANSLATE_NOTABLES        45123
#define IDS_I_SWITCH_EVERY_DESC_FULL    45124
#define IDS_I_SWITCH_EVERY_USAGE        45125
#define IDS_I_EVERY_NOTE                45126
#define IDS_I_SWITCH_FORMAT_DESC_FULL   45127
#define IDS_I_SWITCH_FORMAT_USAGE       45128
#define IDS_I_FORMAT_NOTE               45129
#define IDS_I_VERB_SWITCH_INTERACTIVE_DESC 45130
#define IDS_I_VERB_SWITCH_NOINTERACTIVE_DESC 45131
#define IDS_I_NAMESPACE_BRIEF           45132
#define IDS_I_ROLE_BRIEF                45133
#define IDS_I_NODE_BRIEF                45134
#define IDS_I_IMPLEVEL_BRIEF            45135
#define IDS_I_AUTHLEVEL_BRIEF           45136
#define IDS_I_LOCALE_BRIEF              45137
#define IDS_I_PRIVILEGES_BRIEF          45138
#define IDS_I_TRACE_BRIEF               45139
#define IDS_I_RECORD_BRIEF              45140
#define IDS_I_INTERACTIVE_BRIEF         45141
#define IDS_I_USER_BRIEF                45142
#define IDS_I_PASSWORD_BRIEF            45143
#define IDS_I_HELPBRIEF                 45144
#define IDS_I_GLBL_MORE                 45145
#define IDS_I_HAKTBTC                   45146
#define IDS_I_HAKTBTC_ERASE             45147
#define IDS_I_INPUT                     45148
#define IDS_I_COLON                     45149
#define IDS_I_OUTPUT                    45150
#define IDS_I_CONTEXT_DESC              45151
#define IDS_I_CONTEXT_USAGE             45152
#define IDS_I_NAMESPACE_VALUE           45153
#define IDS_I_ROLE_VALUE                45154
#define IDS_I_AUTHLEVEL_VALUE           45155
#define IDS_I_IMPLEVEL_VALUE            45156
#define IDS_I_PRIVILEGES_VALUE          45157
#define IDS_I_LOCALE_VALUE              45158
#define IDS_I_INTERACTIVE_VALUE         45159
#define IDS_I_RECORDPATH_VALUE          45160
#define IDS_I_TRACE_VALUE               45161
#define IDS_I_USER_VALUE                45162
#define IDS_I_NODELIST_VALUE            45163
#define IDS_I_CLASS_DESCFULL            45164
#define IDS_I_PATH_DESCFULL             45165
#define IDS_I_CONTEXT_DESCFULL          45166
#define IDS_I_STDVERB_ASSOC             45167
#define IDS_I_STDVERB_CALL              45168
#define IDS_I_STDVERB_CREATE            45169
#define IDS_I_STDVERB_GET               45170
#define IDS_I_STDVERB_SET               45171
#define IDS_I_STDVERB_DELETE            45172
#define IDS_I_STDVERB_LIST              45173
#define IDS_I_INVALID_PROS              45174
#define IDS_I_INVALID_NOWRITE_PROS      45175
#define IDS_I_INTERACTIVE_SET           45176
#define IDS_I_INTERACTIVE_ALREADY_SET   45177
#define IDS_I_QUITEXIT                  45178
#define IDS_I_WMIC_INST                 45179
#define IDS_I_WMIC_INST_ERASE           45180
#define IDS_I_ASSOC_SWITCH_HEAD         45181
#define IDS_I_ASSOC_RESULTCLASS         45182
#define IDS_I_ASSOC_RESULTROLE          45183
#define IDS_I_ASSOC_ASSOCCLASS          45184
#define IDS_I_SWITCH_RESULTCLASS_DESC_FULL 45185
#define IDS_I_SWITCH_RESULTCLASS_USAGE  45186
#define IDS_I_SWITCH_RESULTROLE_DESC_FULL 45187
#define IDS_I_SWITCH_RESULTROLE_USAGE   45188
#define IDS_I_SWITCH_ASSOCCLASS_DESC_FULL 45189
#define IDS_I_SWITCH_ASSOCCLASS_USAGE   45190
#define IDS_E_INVALID_ASSOC_FORMATSPECIFIER 45191
#define IDS_E_INVALID_ASSOC_SWITCH      45192
#define IDS_I_FAILFAST_ALREADY_SET      45193
#define IDS_I_FAILFAST_SET              45194
#define IDS_I_FAILFAST_BRIEF            45195
#define IDS_I_FAILFAST_DESC             45196
#define IDS_I_FAILFAST_USAGE            45197
#define IDS_I_FAILFAST_VALUE            45198
#define IDS_I_SWITCH_REPEAT_DESC_FULL   45199
#define IDS_I_SWITCH_REPEAT_USAGE       45200
#define IDS_I_ALIAS_USAGE1              45201
#define IDS_I_ALIAS_USAGE2              45202
#define IDS_I_PATHHELP_SUBST            45203
#define IDS_I_WHEREHELP_SUBST           45204
#define IDS_I_CLASSHELP_SUBST           45205
#define IDS_I_PWHEREHELP_SUBST          45206
#define IDS_I_OUTPUT_DESC               45207
#define IDS_I_OUTPUT_USAGE              45208
#define IDS_I_OUTPUT_NOTE               45209
#define IDS_I_OUTPUT_BRIEF              45210
#define IDS_I_OUTPUT_VALUE              45211
#define IDS_I_DELETING_INSTANCE         45212
#define IDS_I_INSTANCE_DELETE_FAIL      45213
#define IDS_I_INSTANCE_DELETE_SUCCESS   45214
#define IDS_I_VERB_INTERACTIVE_DESC1    45215
#define IDS_I_APPEND_DESC               45216
#define IDS_I_VERB_INTERACTIVE_DESC2    45217
#define IDS_I_APPEND_USAGE              45218
#define IDS_I_APPEND_NOTE               45219
#define IDS_I_APPEND_BRIEF              45220
#define IDS_I_APPEND_VALUE              45221
#define IDS_I_REPEAT_EVERY_RELATED      45222
#define IDS_I_STDOUT_NOTE               45223
#define IDS_I_CLIPBOARD_NOTE            45224
#define IDS_I_OUTPUT_FILE_NOTE          45225
#define IDS_I_APPEND_FILE_NOTE          45226
#define IDS_E_NOT_A_VERBORMETH_PARAM    45227
#define IDS_I_AGGREGATE_DESC            45228
#define IDS_I_AGGREGATE_USAGE           45229
#define IDS_I_AGGREGATE_VALUE           45230
#define IDS_I_AGGREGATE_BRIEF           45231
#define IDS_I_AGGREGATE_NOTE            45232
#define IDS_E_VERB_OR_METHOD_NOT_SPECIFIED 45233
#define IDS_I_CLASS_STDVERB_GET         45234
#define IDS_I_CLASS_GET_USAGE           45235
#define IDS_I_CLASS_GET_DESC            45236
#define IDS_I_CLASS_DELETE_DESC         45237
#define IDS_I_CLASS_ASSOC_DESC          45238
#define IDS_E_NO_DESC                   45239
#define IDS_I_CALL_SUCCESS              46003
#define IDS_I_CALL_FAIL                 46004
#define IDS_I_SET_SUCCESS               46005
#define IDS_I_SET_FAIL                  46006
#define IDS_I_MEMORY_ALLOC_FAIL         46007
#define IDS_I_LOCATE_SYSTEMDIR_FAIL     46008
#define IDS_I_ALIAS_PATH_CONFLICT       46009
#define IDS_NOT_IMPLEMENTED             46010
#define IDS_I_SET_NOCHANGE              46011
#define IDS_I_NO_INSTANCES              46012
#define IDS_I_DELETE_SUCCESS            46013
#define IDS_I_DELETE_FAIL               46014
#define IDS_I_NODELETE                  46015
#define IDS_I_NOCREATE                  46016
#define IDS_I_CREATE_SUCCESS            46017
#define IDS_E_KEY_CLASS_NOT_ALLOWED_WITH_PATHWHERE 46018
#define IDS_E_INVALID_ASSOC_SYNTAX      46019
#define IDS_I_INTERACTIVE_ALREADY_RESET 46020
#define IDS_I_INTERACTIVE_RESET         46021
#define IDS_I_NO_ASSOCIATIONS           46022
#define IDS_I_FAILFAST_ALREADY_RESET    46023
#define IDS_I_FAILFAST_RESET            46024
#define IDS_I_NO_ASSOC                  46025
#define IDS_E_SET_COMMAND_INPUT_FAILURE 47025
#define IDS_E_SET_ALIAS_NAME_FAILURE    47026
#define IDS_E_SET_NAMESPACE_FAILURE     47027
#define IDS_E_SET_ROLE_FAILURE          47028
#define IDS_E_SET_LOCALE_FAILURE        47029
#define IDS_E_SET_NODE_FAILURE          47030
#define IDS_E_SET_USER_FAILURE          47031
#define IDS_E_SET_PASSWORD_FAILURE      47032
#define IDS_E_SET_RECORDPATH_FAILURE    47033
#define IDS_I_INVOCATION_SUCCESS        47034
#define IDS_I_INVOCATION_FAIL           47035
#define IDS_E_SET_PATH_EXP_FAILURE      47036
#define IDS_E_SET_WHERE_EXP_FAILURE     47037
#define IDS_E_SET_METHOD_NAME_FAILURE   47038
#define IDS_I_ASSOC_INST_MSG            47039
#define IDS_E_ADD_TO_PARAM_MAP_FAILURE  47041
#define IDS_E_ADD_TO_PROP_DET_MAP_FAILURE 47042
#define IDS_E_ADD_TO_PROP_LIST_FAILURE  47043
#define IDS_E_METH_DET_ADD_TO_MAP_FAILURE 47044
#define IDS_E_SET_LIST_FORMAT_FAILURE   47045
#define IDS_E_ADD_TO_PARAMS_LIST_FAILURE 47046
#define IDS_E_SET_PWHERE_EXP_FAILURE    47047
#define IDS_E_ADD_TO_METH_DET_MAP_FAILURE 47048
#define IDS_E_SET_CLASS_PATH_FAILURE    47049
#define IDS_E_SET_ALIASSTRGT_FAILURE    47050
#define IDS_E_VALUE_EXCEEDS_MAXLEN      47051
#define IDS_E_VALUE_NOTFOUND            47052
#define IDS_E_INVALID_ASSIGNLIST        47053
#define IDS_E_INVALID_PARAMLIST         47054
#define IDS_E_SET_AUTHORITY_FAILURE     47058
#define IDS_E_INVALID_CREATE_EXPRESSION 47059
#define IDS_I_METH_EXEC_SUCCESS         47060
#define IDS_I_METH_EXEC_FAILED          47061
#define IDS_I_UPDATE_PROMPT             47062
#define IDS_I_DELETE_INST_PROMPT        47063
#define IDS_I_DELETE_CLASS_PROMPT       47064
#define IDS_I_CREATE_INST_PROMPT        47065
#define IDS_I_INVOKE_PROMPT             47066
#define IDS_I_METH_EXEC_PROMPT          47067
#define IDS_I_ASSOC_INSTANCE            47069
#define IDS_I_PWD_PROMPT                47070
#define IDS_I_MOF_PARSE_ERROR           47071
#define IDS_I_ERROR_MSG                 47072
#define IDS_I_METH_RETCODE              47073
#define IDS_I_METH_INVOKE_PROMPT1       47074
#define IDS_I_METH_INVOKE_PROMPT2       47075
#define IDS_I_METH_INVOKE_PROMPT3       47076
#define IDS_I_METH_INVOKE_PROMPT4       47077
#define IDS_I_PARAM_HEAD                47078
#define IDS_I_PARAM_BORDER              47079
#define IDS_I_PROPS_HEAD                47080
#define IDS_I_PROPS_BORDER              47081
#define IDS_I_METH_EXEC_STATUS          47082
#define IDS_I_DESCRIPTION               47083
#define IDS_I_TRANSFORMAT_NOTE1         47084
#define IDS_I_TRANSFORMAT_NOTE2         47085
#define IDS_I_TRANSFORMAT_NOTE3         47086
#define IDS_I_METH_EXEC_PROMPT2         47087
#define IDS_I_UPDATE_PROMPT2            47088
#define IDS_I_DELETE_CLASS_PROMPT2      47089
#define IDS_I_PROMPT_UPDATING           47090
#define IDS_I_ERROR_MSG_NOTRACE         47091
#define IDS_I_ERROR_WIN32               47092
#define IDS_I_NODENAME_MSG              47093
#define IDS_I_SPECIAL_NOTE              47094
#define IDS_I_OUT_PARAMS                47095
#define IDS_I_WBEM_NO_ERROR             48000
#define IDS_E_WBEM_E_ACCESS_DENIED      48001
#define IDS_E_WBEM_E_ALREADY_EXISTS     48002
#define IDS_E_WBEM_E_CANNOT_BE_KEY      48003
#define IDS_E_WBEM_E_CANNOT_BE_SINGLETON 48004
#define IDS_E_WBEM_E_CLASS_HAS_CHILDREN 48005
#define IDS_E_WBEM_E_CLASS_HAS_INSTANCES 48006
#define IDS_E_WBEM_E_CRITICAL_ERROR     48007
#define IDS_E_WBEM_E_FAILED             48008
#define IDS_E_WBEM_E_ILLEGAL_NULL       48009
#define IDS_E_WBEM_E_ILLEGAL_OPERATION  48010
#define IDS_E_WBEM_E_INCOMPLETE_CLASS   48011
#define IDS_E_WBEM_E_INITIALIZATION_FAILURE 48012
#define IDS_E_WBEM_E_INVALID_CIM_TYPE   48013
#define IDS_E_WBEM_E_INVALID_CLASS      48014
#define IDS_E_WBEM_E_INVALID_CONTEXT    48015
#define IDS_E_WBEM_E_INVALID_METHOD     48016
#define IDS_E_WBEM_E_INVALID_METHOD_PARAMETERS 48017
#define IDS_E_WBEM_E_INVALID_NAMESPACE  48018
#define IDS_E_WBEM_E_INVALID_OBJECT     48019
#define IDS_E_WBEM_E_INVALID_OPERATION  48020
#define IDS_E_WBEM_E_INVALID_PARAMETER  48021
#define IDS_E_WBEM_E_INVALID_PROPERTY_TYPE 48022
#define IDS_E_WBEM_E_INVALID_PROVIDER_REGISTRATION 48023
#define IDS_E_WBEM_E_INVALID_QUALIFIER_TYPE 48024
#define IDS_E_WBEM_E_INVALID_QUERY      48025
#define IDS_E_WBEM_E_INVALID_QUERY_TYPE 48026
#define IDS_E_WBEM_E_INVALID_STREAM     48027
#define IDS_E_WBEM_E_INVALID_SUPERCLASS 48028
#define IDS_E_WBEM_E_INVALID_SYNTAX     48029
#define IDS_E_WBEM_E_NONDECORATED_OBJECT 48030
#define IDS_E_WBEM_E_NOT_AVAILABLE      48031
#define IDS_E_WBEM_E_NOT_FOUND          48032
#define IDS_E_WBEM_E_NOT_SUPPORTED      48033
#define IDS_E_WBEM_E_OUT_OF_MEMORY      48034
#define IDS_E_WBEM_E_OVERRIDE_NOT_ALLOWED 48035
#define IDS_E_WBEM_E_PROPAGATED_PROPERTY 48036
#define IDS_E_WBEM_E_PROPAGATED_QUALIFIER 48037
#define IDS_E_WBEM_E_PROVIDER_FAILURE   48038
#define IDS_E_WBEM_E_PROVIDER_LOAD_FAILURE 48039
#define IDS_E_WBEM_E_PROVIDER_NOT_CAPABLE 48040
#define IDS_E_WBEM_E_PROVIDER_NOT_FOUND 48041
#define IDS_E_WBEM_E_QUERY_NOT_IMPLEMENTED 48042
#define IDS_E_WBEM_E_READ_ONLY          48043
#define IDS_E_WBEM_E_TRANSPORT_FAILURE  48044
#define IDS_E_WBEM_E_TYPE_MISMATCH      48045
#define IDS_E_WBEM_E_UNEXPECTED         48046
#define IDS_E_WBEM_E_VALUE_OUT_OF_RANGE 48047
#define IDS_S_WBEM_S_ALREADY_EXISTS     48048
#define IDS_S_WBEM_S_DIFFERENT          48049
#define IDS_S_WBEM_S_FALSE              48050
#define IDS_S_WBEM_S_NO_MORE_DATA       48051
#define IDS_S_WBEM_S_PENDING            48052
#define IDS_S_WBEM_S_RESET_TO_DEFAULT   48053
#define IDS_S_WBEM_S_TIMEDOUT           48054
#define IDS_E_WBEMESS_E_REGISTRATION_TOO_BROAD 48055
#define IDS_S_WBEMESS_E_REGISTRATION_TOO_PRECISE 48056
#define IDS_S_WBEM_S_OPERATION_CANCELLED 48057
#define IDS_S_WBEM_S_DUPLICATE_OBJECTS  48058
#define IDS_S_WBEM_S_ACCESS_DENIED      48059
#define IDS_S_WBEM_S_PARTIAL_RESULTS    48060
#define IDS_E_WBEM_E_SYSTEM_PROPERTY    48061
#define IDS_E_WBEM_E_INVALID_PROPERTY   48062
#define IDS_E_WBEM_E_CALL_CANCELLED     48063
#define IDS_E_WBEM_E_SHUTTING_DOWN      48064
#define IDS_E_WBEM_E_PROPAGATED_METHOD  48065
#define IDS_E_WBEM_E_UNSUPPORTED_PARAMETER 48066
#define IDS_E_WBEM_E_MISSING_PARAMETER_ID 48067
#define IDS_E_WBEM_E_INVALID_PARAMETER_ID 48068
#define IDS_E_WBEM_E_NONCONSECUTIVE_PARAMETER_IDS 48069
#define IDS_E_WBEM_E_PARAMETER_ID_ON_RETVAL 48070
#define IDS_E_WBEM_E_INVALID_OBJECT_PATH 48071
#define IDS_E_WBEM_E_OUT_OF_DISK_SPACE  48072
#define IDS_E_WBEM_E_BUFFER_TOO_SMALL   48073
#define IDS_E_WBEM_E_UNSUPPORTED_PUT_EXTENSION 48074
#define IDS_E_WBEM_E_UNKNOWN_OBJECT_TYPE 48075
#define IDS_E_WBEM_E_UNKNOWN_PACKET_TYPE 48076
#define IDS_E_WBEM_E_MARSHAL_VERSION_MISMATCH 48077
#define IDS_E_WBEM_E_MARSHAL_INVALID_SIGNATURE 48078
#define IDS_E_WBEM_E_INVALID_QUALIFIER  48079
#define IDS_E_WBEM_E_INVALID_DUPLICATE_PARAMETER 48080
#define IDS_E_WBEM_E_TOO_MUCH_DATA      48081
#define IDS_E_WBEM_E_SERVER_TOO_BUSY    48082
#define IDS_E_WBEM_E_INVALID_FLAVOR     48083
#define IDS_E_WBEM_E_CIRCULAR_REFERENCE 48084
#define IDS_E_WBEM_E_UNSUPPORTED_CLASS_UPDATE 48085
#define IDS_E_WBEM_E_CANNOT_CHANGE_KEY_INHERITANCE 48086
#define IDS_E_WBEM_E_CANNOT_CHANGE_INDEX_INHERITANCE 48087
#define IDS_E_WBEM_E_TOO_MANY_PROPERTIES 48088
#define IDS_E_WBEM_E_UPDATE_TYPE_MISMATCH 48089
#define IDS_E_WBEM_E_UPDATE_OVERRIDE_NOT_ALLOWED 48090
#define IDS_E_WBEM_E_UPDATE_PROPAGATED_METHOD 48091
#define IDS_E_WBEM_E_METHOD_NOT_IMPLEMENTED 48092
#define IDS_E_WBEM_E_METHOD_DISABLED    48093
#define IDS_E_WBEM_E_REFRESHER_BUSY     48094
#define IDS_E_WBEM_E_UNPARSABLE_QUERY   48095
#define IDS_E_WBEM_E_NOT_EVENT_CLASS    48096
#define IDS_E_WBEM_E_MISSING_GROUP_WITHIN 48097
#define IDS_E_WBEM_E_MISSING_AGGREGATION_LIST 48098
#define IDS_E_WBEM_E_PROPERTY_NOT_AN_OBJECT 48099
#define IDS_E_WBEM_E_AGGREGATING_BY_OBJECT 48100
#define IDS_E_WBEM_E_UNINTERPRETABLE_PROVIDER_QUERY 48101
#define IDS_E_WBEM_E_BACKUP_RESTORE_WINMGMT_RUNNING 48102
#define IDS_E_WBEM_E_QUEUE_OVERFLOW     48103
#define IDS_E_WBEM_E_PRIVILEGE_NOT_HELD 48104
#define IDS_E_WBEM_E_INVALID_OPERATOR   48105
#define IDS_E_WBEM_E_LOCAL_CREDENTIALS  48106
#define IDS_E_WBEM_E_CANNOT_BE_ABSTRACT 48107
#define IDS_E_WBEM_E_AMENDED_OBJECT     48108
#define IDS_E_WBEM_E_CLIENT_TOO_SLOW    48109
#define IDS_E_WBEMESS_E_REGISTRATION_TOO_PRECISE 48110
#define IDS_E_MEMALLOCFAILED            48111
#define IDS_E_CONCTRL_HNDLRSET          48112
#define IDS_E_INVALID_CONTEXT_SYNTAX    48113
#define IDS_E_UNKNOWN_WBEM_ERROR        48114

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\precomp.h ===
#if !defined __PCH_H
#define __PCH_H

#define SECURITY_WIN32 1

// The debugger can't handle symbols more than 255 characters long.
// STL often creates symbols longer than that.
// When symbols are longer than 255 characters, the warning is issued.
#pragma warning(disable:4786)
//////////////////////////////////////////////////////////////////////
//						HEADER INCLUDES								//
//////////////////////////////////////////////////////////////////////
#include "resource.h"
#include <windows.h>
#include <vector>
#include <map>
#include <tchar.h>
#include <comdef.h>	
#include <wbemidl.h>
#include <iostream>
#include <msxml2.h>
#include <lmcons.h>
#include <conio.h>
#include <math.h>
#include <chstring.h>
#include <shlwapi.h>
#include <winsock2.h>
#include <security.h>
#include <Provexce.h>

using namespace std;

class CParsedInfo;
class CWMICommandLine;
extern CWMICommandLine g_wmiCmd;


#ifdef _WIN64
	typedef __int64 WMICLIINT;
#else
	typedef int WMICLIINT;
#endif

#ifdef _WIN64
	typedef UINT_PTR WMICLIUINT;
#else
	typedef UINT WMICLIUINT;
#endif

#ifdef _WIN64
	typedef DWORD_PTR WMICLIULONG;
#else
	typedef ULONG WMICLIULONG;
#endif


//////////////////////////////////////////////////////////////////////
//						USER DEFINED CONSTANTS						//
//////////////////////////////////////////////////////////////////////
#define MAX_BUFFER				4095
#define BUFFER32				32				
#define BUFFER64				64				
#define	BUFFER512				512
#define BUFFER255				255
#define BUFFER1024				1024

#define	CLI_ROLE_DEFAULT		_T("root\\cli")
#define CLI_NAMESPACE_DEFAULT	_T("root\\cimv2")
#define CLI_LOCALE_DEFAULT		_T("ms_409")

#define	CLI_TOKEN_W				_T("W")
#define CLI_TOKEN_CLASS			_T("CLASS")
#define CLI_TOKEN_PATH			_T("PATH")
#define CLI_TOKEN_WHERE			_T("WHERE")
#define CLI_TOKEN_EXIT			_T("EXIT")
#define CLI_TOKEN_RESTORE		_T("RESTORE")
#define CLI_TOKEN_QUIT			_T("QUIT")
#define	CLI_TOKEN_CONTEXT		_T("CONTEXT")

#define CLI_TOKEN_GET			_T("GET")
#define CLI_TOKEN_LIST			_T("LIST")
#define CLI_TOKEN_SET			_T("SET")
#define CLI_TOKEN_DUMP			_T("DUMP")
#define CLI_TOKEN_CALL			_T("CALL")
#define CLI_TOKEN_ASSOC			_T("ASSOC")
#define CLI_TOKEN_CREATE		_T("CREATE")
#define CLI_TOKEN_DELETE		_T("DELETE")

#define CLI_TOKEN_HELP			_T("?")
#define CLI_TOKEN_NAMESPACE		_T("NAMESPACE")
#define CLI_TOKEN_ROLE			_T("ROLE")
#define CLI_TOKEN_NODE			_T("NODE")
#define CLI_TOKEN_IMPLEVEL		_T("IMPLEVEL")
#define CLI_TOKEN_AUTHLEVEL		_T("AUTHLEVEL")
#define CLI_TOKEN_LOCALE		_T("LOCALE")
#define CLI_TOKEN_PRIVILEGES	_T("PRIVILEGES")
#define CLI_TOKEN_TRACE			_T("TRACE")
#define CLI_TOKEN_RECORD		_T("RECORD")
#define CLI_TOKEN_INTERACTIVE   _T("INTERACTIVE")
#define CLI_TOKEN_FAILFAST	    _T("FAILFAST")
#define CLI_TOKEN_USER			_T("USER")
#define CLI_TOKEN_PASSWORD	    _T("PASSWORD")
#define CLI_TOKEN_OUTPUT	    _T("OUTPUT")
#define CLI_TOKEN_APPEND	    _T("APPEND")
#define CLI_TOKEN_AGGREGATE		_T("AGGREGATE")

#define CLI_TOKEN_COLON			_T(":")
#define CLI_TOKEN_COMMA			_T(",")
#define CLI_TOKEN_FSLASH        _T("/")
#define CLI_TOKEN_HYPHEN	    _T("-")
#define CLI_TOKEN_HASH			_T("#")
#define CLI_TOKEN_SPACE         _T(" ")
#define CLI_TOKEN_DOT			_T(".")
#define CLI_TOKEN_2DOT			_T("..")
#define CLI_TOKEN_EQUALTO		_T("=")
#define CLI_TOKEN_NULL			_T("")
#define CLI_TOKEN_BSLASH		_T("\\")
#define CLI_TOKEN_2BSLASH		_T("\\\\")
#define CLI_TOKEN_LEFT_PARAN	_T("(")
#define CLI_TOKEN_RIGHT_PARAN	_T(")")
#define CLI_TOKEN_ONE			_T("1")
#define CLI_TOKEN_TWO			_T("2")
#define CLI_TOKEN_SINGLE_QUOTE	_T("\'")
#define CLI_TOKEN_DOUBLE_QUOTE	_T("\"")
#define CLI_TOKEN_TAB			_T("\t")
#define CLI_TOKEN_SEMICOLON		_T(";")
#define CLI_TOKEN_NEWLINE		_T("\n")

#define CLI_TOKEN_TABLE			_T("TABLE")
#define CLI_TOKEN_MOF			_T("MOF")
#define CLI_TOKEN_TEXTVALUE		_T("TEXTVALUE")

#define CLI_TOKEN_ENABLE	    _T("ENABLE")
#define CLI_TOKEN_DISABLE		_T("DISABLE")
#define CLI_TOKEN_ON			_T("ON")
#define CLI_TOKEN_OFF			_T("OFF")

#define CLI_TOKEN_BRIEF			_T("BRIEF")
#define CLI_TOKEN_FULL			_T("FULL")

#define CLI_TOKEN_STDOUT		_T("STDOUT")
#define CLI_TOKEN_CLIPBOARD		_T("CLIPBOARD")

#define CLI_TOKEN_VALUE			_T("VALUE")
#define CLI_TOKEN_ALL			_T("ALL")
#define CLI_TOKEN_FORMAT        _T("FORMAT")
#define CLI_TOKEN_EVERY			_T("EVERY")
#define CLI_TOKEN_REPEAT		_T("REPEAT")
#define CLI_TOKEN_TRANSLATE		_T("TRANSLATE")

#define CLI_TOKEN_NONINTERACT   _T("NOINTERACTIVE")
#define CLI_TOKEN_DUMP			_T("DUMP")

#define CLI_TOKEN_FROM			_T("FROM")
#define CLI_TOKEN_WHERE			_T("WHERE")


#define XSL_FORMAT_TABLE		_T("WmiCliTableFormat.xsl")
#define XSL_FORMAT_MOF			_T("WmiCliMofFormat.xsl")
#define XSL_FORMAT_VALUE		_T("WmiCliValueFormat.xsl")
#define XSL_FORMAT_TEXTVALUE	_T("TextValueList.xsl")

#define TEMP_BATCH_FILE			_T("TempWmicBatchFile.bat")
#define CLI_XSLMAPPINGS_FILE	_T("XSL-Mappings.xml")
#define CLI_XSLSECTION_NAME		_T("XSLMAPPINGS")

#define WBEM_LOCATION			_T("\\wbem\\")

#define RESPONSE_YES			_T("Y")
#define RESPONSE_NO				_T("N")
#define RESPONSE_HELP			_T("?")

#define EXEC_NAME				_T("wmic")

#define CLI_TOKEN_AND			_T(" AND ")
#define CLI_TOKEN_WRITE			_T("Write")


#define WMISYSTEM_CLASS			_T("__CLASS")
#define WMISYSTEM_DERIVATION	_T("__DERIVATION")
#define WMISYSTEM_DYNASTY		_T("__DYNASTY")
#define WMISYSTEM_GENUS			_T("__GENUS")
#define WMISYSTEM_NAMESPACE		_T("__NAMESPACE")
#define WMISYSTEM_PATH			_T("__PATH")
#define WMISYSTEM_PROPERTYCOUNT	_T("__PROPERTYCOUNT")
#define WMISYSTEM_REPLATH		_T("__RELPATH")
#define WMISYSTEM_SERVER		_T("__SERVER")
#define WMISYSTEM_SUPERCLASS	_T("__SUPERCLASS")

#define MULTINODE_XMLSTARTTAG	_T("<CIM>")
#define MULTINODE_XMLENDTAG		_T("</CIM>")

#define MULTINODE_XMLASSOCSTAG1		_T("<ASSOC.OBJECTARRAY>")
#define MULTINODE_XMLASSOCETAG1		_T("</ASSOC.OBJECTARRAY>")
#define MULTINODE_XMLASSOCSTAG2		_T("<VALUE.OBJECT>")
#define MULTINODE_XMLASSOCETAG2		_T("</VALUE.OBJECT>")

#define CLI_TOKEN_RESULTCLASS   _T("RESULTCLASS")
#define CLI_TOKEN_RESULTROLE    _T("RESULTROLE")
#define CLI_TOKEN_ASSOCCLASS    _T("ASSOCCLASS")

#define CLI_TOKEN_LOCALHOST		_T("LOCALHOST")

#define	NULL_STRING				_T("\0")
#define NULL_CSTRING			"\0"

#define	BACK_SPACE				0x08
#define	BLANK_CHAR				0x00
#define CARRIAGE_RETURN			0x0D
#define	ASTERIX 				_T( "*" )
#define	BEEP_SOUND				_T( "\a" )
#define	NULL_CHAR				_T( '\0' )
#define TOKEN_NA				_T("N/A")
#define MAXPASSWORDSIZE			BUFFER64
#define FORMAT_STRING( buffer, format, value ) \
							wsprintf( buffer, format, value )

#define EXCLUDESYSPROP			_T("ExcludeSystemProperties")
#define NODESCAVLBL				_T("<<Descripiton - Not Available>>")

#define UNICODE_SIGNATURE			"\xFF\xFE"
#define UNICODE_BIGEND_SIGNATURE	"\xFE\xFF"
#define UTF8_SIGNATURE				"\xEF\xBB"

//////////////////////////////////////////////////////////////////////
//						NUMERIC CONSTANTS							//
//////////////////////////////////////////////////////////////////////
const WMICLIINT OUT_OF_MEMORY			= 48111;
const WMICLIINT UNKNOWN_ERROR			= 44520;
const WMICLIINT MOFCOMP_ERROR			= 49999;
const WMICLIINT SET_CONHNDLR_ROUTN_FAIL	= 48112;
const WMICLIINT NOINTERACTIVE			= 0;
const WMICLIINT INTERACTIVE				= 1;
const WMICLIINT DEFAULTMODE				= 2;
const WMICLIINT DEFAULT_SCR_BUF_HEIGHT	= 300;
const WMICLIINT DEFAULT_SCR_BUF_WIDTH	= 1500;


//////////////////////////////////////////////////////////////////////
//						ENUMERATED DATA TYPES						//
//////////////////////////////////////////////////////////////////////
// IMPERSONATION LEVEL
typedef enum tag_IMPERSONATIONLEVEL
{
	IMPDEFAULT		= 0, 
	IMPANONYMOUS	= 1, 
	IMPIDENTIFY		= 2, 
	IMPERSONATE		= 3, 
	IMPDELEGATE		= 4 
}IMPLEVEL;

// AUTHENTICATION LEVEL
typedef enum tag_AUTHENTICATIONLEVEL
{	
	AUTHDEFAULT			= 0, 
	AUTHNONE			= 1, 
	AUTHCONNECT			= 2,
	AUTHCALL			= 3, 
	AUTHPKT				= 4, 
	AUTHPKTINTEGRITY	= 5, 
	AUTHPKTPRIVACY		= 6 
}AUTHLEVEL;

// HELP OPTION
typedef enum tag_HELPOPTION
{
	HELPBRIEF	= 0,
	HELPFULL	= 1
}HELPOPTION;

// ENUMERATED RETURN CODES for PARSER ENGINE
typedef enum tag_RETCODE
{
	PARSER_ERROR				= 0,
	PARSER_DISPHELP				= 1,
	PARSER_EXECCOMMAND			= 2,
	PARSER_MESSAGE				= 3,
	PARSER_CONTINUE				= 4,
	PARSER_ERRMSG				= 5,
	PARSER_OUTOFMEMORY			= 6
} RETCODE;

// ENUMERATED HELP OPTION POSSIBILITES
typedef enum tag_HELPTYPE	
{
	GlblAllInfo, 
	Namespace, 
	Role,
	Node, 
	User, 
	Password, 
	Locale,
	RecordPath, 
	Privileges, 
	Level,
	AuthLevel, 
	Interactive, 
	Trace,
	CmdAllInfo, 
	GETVerb, 
	SETVerb, 
	LISTVerb, 
	CALLVerb, 
	DUMPVerb,
	ASSOCVerb, 
	CREATEVerb,
	DELETEVerb,
	AliasVerb, 
	PATH,
	WHERE, 
	CLASS,
	PWhere,
	EXIT,
	TRANSLATE,
	EVERY,
	FORMAT,
	VERBSWITCHES,
	DESCRIPTION,
	GETSwitchesOnly,
	LISTSwitchesOnly,
	CONTEXTHELP,
	GLBLCONTEXT,
	ASSOCSwitchesOnly,
	RESULTCLASShelp,
	RESULTROLEhelp,
	ASSOCCLASShelp,
	FAILFAST,
	REPEAT,
	OUTPUT,
	APPEND,
	Aggregate
} HELPTYPE;

// ENUMERATED TOKEN LEVELS
typedef enum tag_TOKENLEVEL
{
	LEVEL_ONE = 1,
	LEVEL_TWO = 2

} TOKENLEVEL;

// ENUMERATED SESSION RETURN CODES.
typedef enum tag_SESSIONRETCODE
{
	SESSION_ERROR			= 0,
	SESSION_SUCCESS			= 1,
	SESSION_QUIT			= 2,
} SESSIONRETCODE;

// Property In or Out type for parameters
typedef enum tag_INOROUT
{
	INP		= 0,
	OUTP	= 1,
	UNKNOWN	= 2
} INOROUT;

typedef enum tag_GLBLSWITCHFLAG
{
	NAMESPACE	=	1,
	NODE		=	2,
	USER		=	4,
	PASSWORD	=	8,
	LOCALE		=	16
} GLBLSWITCHFLAG;

typedef enum tag_VERBTYPE
{
	CLASSMETHOD	=	0,
	STDVERB		=	1,
	CMDLINE		=	2,
	NONALIAS	=	3
} VERBTYPE;

typedef enum tag_ERRLOGOPT
{
	NO_LOGGING		=	0,
	ERRORS_ONLY		=	1,
	EVERY_OPERATION	=	2
} ERRLOGOPT;

// ENUMERATED Assoc Switches POSSIBILITES
typedef enum tag_ASSOCSwitch	
{
	RESULTCLASS	= 0,
	RESULTROLE	= 1,
	ASSOCCLASS	= 2
} ASSOCSwitch;

// ENUMERATED Output or Append option
typedef enum tag_OUTPUTSPEC	
{
	STDOUT		= 0,
	CLIPBOARD	= 1,
	FILEOUTPUT	= 2
} OUTPUTSPEC;

// ENUMERATED Interactive Option POSSIBILITES
typedef enum tag_INTEROPTION
{
	NO	= 0,
	YES	= 1,
	HELP= 2
} INTEROPTION;

// ENUMERATED values for File types
typedef enum tag_FILETYPE
{
	ANSI_FILE				= 0,
	UNICODE_FILE			= 1,
	UNICODE_BIGENDIAN_FILE	= 2,
	UTF8_FILE				= 3
} FILETYPE;
//////////////////////////////////////////////////////////////////////
//						TYPE DEFINITIONS							//
//////////////////////////////////////////////////////////////////////
typedef vector<_TCHAR*> CHARVECTOR;
typedef vector<LPSTR> LPSTRVECTOR;
typedef map<_bstr_t, _bstr_t, less<_bstr_t> > BSTRMAP;
typedef map<_TCHAR*, _TCHAR*, less<_TCHAR*> > CHARMAP;
typedef basic_string<_TCHAR> STRING;
typedef map<_bstr_t, WMICLIINT> CHARINTMAP;  
typedef vector<_bstr_t> BSTRVECTOR;

typedef map<_bstr_t, BSTRVECTOR, less<_bstr_t> > QUALDETMAP;

typedef struct tag_PROPERTYDETAILS
{
	_bstr_t		Derivation;		// Derivation - actual property name.
	_bstr_t		Description;	// Description about the property.
	_bstr_t		Type;			// Type of property CIMTYPE.
	_bstr_t		Operation;		// Read or Write flag for the property.
	_bstr_t		Default;		// Default values in case of method parameters
	INOROUT		InOrOut;		// Specifies Input or Output parameter in case
								// of method arguments. 
	QUALDETMAP	QualDetMap;		// Qualifiers associated with the property.
} PROPERTYDETAILS;
typedef map<_bstr_t, PROPERTYDETAILS, less<_bstr_t> > PROPDETMAP;

typedef struct tag_METHODDETAILS // or VERBDETAILS 
{
	_bstr_t Description;	// Desription.
	_bstr_t Status;			// Implemented or Not.
	PROPDETMAP	Params;		// In and Out parameters and types of the method.
} METHODDETAILS;
typedef map<_bstr_t, METHODDETAILS, less<_bstr_t> > METHDETMAP;
typedef map<_bstr_t, BSTRVECTOR, less<_bstr_t> >	ALSFMTDETMAP;

// For cascading transforms.
typedef struct tag_XSLTDET
{
	_bstr_t		FileName;
	BSTRMAP		ParamMap;
} XSLTDET;

typedef vector<XSLTDET> XSLTDETVECTOR; 

//////////////////////////////////////////////////////////////////////
//						USER DEFINED MACROS							//
//////////////////////////////////////////////////////////////////////
// SAFEIRELEASE(pIObj)
#define SAFEIRELEASE(pIObj) \
	if (pIObj) \
	{ \
		pIObj->Release(); \
		pIObj = NULL; \
	}

// SAFEBSTRFREE(bstrVal)
#define SAFEBSTRFREE(bstrVal) \
	if(bstrVal) \
	{	\
		SysFreeString(bstrVal); \
		bstrVal = NULL;	\
	}

// SAFEADESTROY(psaNames)
#define SAFEADESTROY(psaNames) \
	if(psaNames) \
	{	\
		SafeArrayDestroy(psaNames); \
		psaNames= NULL;	\
	}

// SAFEDELETE(pszVal)
#define SAFEDELETE(pszVal) \
	if(pszVal) \
	{	\
		delete [] pszVal; \
		pszVal = NULL; \
	} 

// VARIANTCLEAR(v)
#define VARIANTCLEAR(v)	\
		VariantClear(&v); \

// ONFAILTHROWERROR(hr)
#define ONFAILTHROWERROR(hr) \
	if (FAILED(hr)) \
		_com_issue_error(hr); 

//////////////////////////////////////////////////////////////////////
//						GLOBAL FUNCTIONS							//
//////////////////////////////////////////////////////////////////////

// Compare two strings (ignore case) and returns TRUE if 
// they are equal 
BOOL CompareTokens(_TCHAR* pszToken1, _TCHAR* pszToken2);

// Connect to the WMI on the specified machine with input
// user credentials.

HRESULT Connect(IWbemLocator* pILocator, IWbemServices** pISvc,
				BSTR bstrNS, BSTR bstrUser, BSTR bstrPwd,
				BSTR bstrLocale, CParsedInfo& rParsedInfo);

// Set the security privileges at the interface level
HRESULT SetSecurity(IUnknown* pIUnknown, _TCHAR* pszAuthority,
					_TCHAR* pszDomain, _TCHAR* pszUser, 
					_TCHAR* pszPassword, UINT uAuthLevel, 
					UINT uImpLevel);

// Parse Authority string into user and domain info.
SCODE ParseAuthorityUserArgs(BSTR& bstrAuthArg, BSTR& bstrUserArg,
								BSTR& bstrAuthority, BSTR& bstrUser);

// Converts the	UNICODE string to MBCS string
BOOL ConvertWCToMBCS(LPTSTR lpszMsg, LPVOID* lpszDisp, UINT uCP);

// Finds a string in the CHARVECTOR.
BOOL Find(CHARVECTOR& cvVector, 
		  _TCHAR* pszStrToFind,
		  CHARVECTOR::iterator& theIterator);

// Finds a property in the PROPDETMAP.
BOOL Find(PROPDETMAP& pdmPropDetMap, 
		  _TCHAR* pszPropToFind,
		  PROPDETMAP::iterator& theIterator,
		  BOOL bExcludeNumbers = FALSE);

// Finds a property in the BSTRMAP.
BOOL Find(BSTRMAP& bmBstrMap, 
		  _TCHAR* pszStrToFind,
		  BSTRMAP::iterator& theIterator);

// Frames the XSL File path and updates the rParsedInfo object.
BOOL FrameFileAndAddToXSLTDetVector(XSLTDET xdXSLTDet,
									CParsedInfo& rParsedInfo);


// Unquotes the string enclosed in double quotes.
void UnQuoteString(_TCHAR*& pszString);

// Display contents of a VARIANT type data object.
void DisplayVARIANTContent(VARIANT vtObject);

// Get Attributes of property
HRESULT GetPropertyAttributes(IWbemClassObject* pIObj, 
							  BSTR bstrProp,
							  PROPERTYDETAILS& pdPropDet,
							  BOOL bTrace);
// Convert CIMTYPE to VariantType
HRESULT ConvertCIMTYPEToVarType( VARIANT& varDest, VARIANT& varSrc,
							 _TCHAR* bstrCIMType );

// Displays the localized string
void DisplayMessage(LPTSTR lpszMsg, UINT uCP = CP_OEMCP, 
					BOOL bIsError = FALSE, BOOL bIsLog = FALSE);

// Free memory held by 
void CleanUpCharVector(CHARVECTOR& cvCharVector);

void FindAndReplaceAll(STRING& strString, _TCHAR* pszFromStr, 
														_TCHAR* pszToStr);

// Search and replace all the occurences of entity references.
void FindAndReplaceEntityReferences(_bstr_t& bstrString);

BOOL IsSysProp(_TCHAR* pszProp);

void EraseMessage(UINT uID);

//To display the trace of COM methods invoked
void WMITRACEORERRORLOG(HRESULT hr, INT nLine, char* pszFile, _bstr_t bstrMsg,
						DWORD dwThreadId, CParsedInfo& rParsedInfo, BOOL bTrace,
						DWORD dwError = 0, _TCHAR* pszResult = NULL);

// Displays wi32 error. 
void DisplayWin32Error();

// Accepts password in invisible mode.
void AcceptPassword(_TCHAR* pszPassword);

// Checks for output redirection.
BOOL IsRedirection();

// Checks for value set or not.
BOOL IsValueSet(_TCHAR* pszFromValue, _TCHAR& cValue1, _TCHAR& cValue2);

// Handler routine to handle CTRL + C so as free
// the memory allocated during the program execution.
BOOL CtrlHandler(DWORD fdwCtrlType);

void DisplayString(UINT uID, UINT uCP, LPTSTR lpszParam = NULL, 
				   BOOL bIsError = FALSE, BOOL bIsLog = FALSE);

void SubstituteEscapeChars(CHString& sTemp, LPCWSTR lpszSub);

void RemoveEscapeChars(CHString& sTemp);

//Frames the Namespace 
void FrameNamespace(_TCHAR* pszRoleOrNS, _TCHAR* pszRoleOrNSToUpdate);

// Set the buffer size of the command line
void SetScreenBuffer(SHORT nHeight = DEFAULT_SCR_BUF_HEIGHT,
					 SHORT nWidth = DEFAULT_SCR_BUF_WIDTH);

// Get the buffer size of the command line
void GetScreenBuffer(SHORT& nHeight, SHORT& nWidth);

// Formats the resource string with parameter substitution.
void WMIFormatMessage(UINT uID, WMICLIINT nParamCount, _bstr_t& bstrMsg, 
					  LPTSTR lpszParam, ...);

// Validates a node by using socket functions.
BOOL PingNode(_TCHAR* pszNode);

// If pszNodeName == NULL then check for GetNode() else pszNodeName itself.
BOOL IsFailFastAndNodeExist(CParsedInfo& rParsedInfo, _TCHAR* pszNodeName = NULL);

// Initilaizes windows socket interface.
BOOL InitWinsock ();

// Uninitializes windows socket interface.
BOOL TermWinsock ();

// Get _bstr_t object equivalent to	Varaint passed.
void GetBstrTFromVariant(VARIANT& vtVar, _bstr_t& bstrObj, 
						 _TCHAR* pszType = NULL);

// Close the output file.
BOOL CloseOutputFile();

// Close the append file.
BOOL CloseAppendFile();

// Checks if the next token indicates the presence
// of '/' or '-'
BOOL  IsOption(_TCHAR* pszToken);

// Copy string to global memory.
HGLOBAL CopyStringToHGlobal(LPTSTR psz);

// Copy data to clip board.
void CopyToClipBoard(_bstr_t& bstrClipBoardBuffer);

// Checks file is valid or not.
RETCODE IsValidFile(_TCHAR* pszFileName);

// It checks whether the current operation is class 
// level operation or instance level operation
BOOL IsClassOperation(CParsedInfo& rParsedInfo);

// Enable or Disable all privileges
HRESULT	ModifyPrivileges(BOOL bEnable);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\wmiclilog.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: WMICliLog.cpp 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 4th-October-2000
Version Number				: 1.0 
Brief Description			: This class encapsulates the functionality needed
							  for logging the input and output.
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 28th-December-2000
*****************************************************************************/ 
// WMICliLog.cpp : implementation file
#include "Precomp.h"
#include "WmiCliLog.h"


/*------------------------------------------------------------------------
   Name				 :CWMICliLog
   Synopsis	         :Constructor 
   Type	             :Constructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CWMICliLog::CWMICliLog()
{
	m_pszLogFile	= NULL;
	m_bCreate		= FALSE;
}

/*------------------------------------------------------------------------
   Name				 :~CWMICliLog
   Synopsis	         :Destructor
   Type	             :Destructor
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CWMICliLog::~CWMICliLog()
{
	//Close the File handle
	if (m_bCreate)
		CloseHandle(m_hFile);

	//Delete the file
	SAFEDELETE(m_pszLogFile);
}

/*------------------------------------------------------------------------
   Name				 :WriteToLog
   Synopsis	         :Log the input to the logfile created
   Type	             :Member Function 
   Input parameter   :
		pszMsg	 - string, contents to be written to the log file
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :WriteToLog(pszInput)
   Notes             :None
------------------------------------------------------------------------*/
void CWMICliLog::WriteToLog(LPSTR pszMsg) throw (WMICLIINT)
{
    int j = 0;
    if(pszMsg && ((j = strlen(pszMsg)) > 0))
    {
        //if the file has not been created 
	    if (!m_bCreate)
	    {
		    try
		    {
			    //creates the log file 
			    CreateLogFile();
		    }
		    catch(WMICLIINT nErr)
		    {
			    if (nErr == WIN32_FUNC_ERROR)
				    throw(WIN32_FUNC_ERROR);
		    }
		    m_bCreate = TRUE;
	    }

	    //No of bytes written into the file .
	    DWORD	dwNumberOfBytes = 0;
	    
	    //writes data to a file 
	    if (!WriteFile(m_hFile, pszMsg, j, 
					    &dwNumberOfBytes, NULL))
	    {
		    DisplayWin32Error();
		    throw(WIN32_FUNC_ERROR);
	    }
    }
}

/*------------------------------------------------------------------------
   Name				 :CreateLogFile
   Synopsis	         :Create the log file 
   Type	             :Member Function 
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :CreateLogFile()
   Notes             :None
------------------------------------------------------------------------*/
void CWMICliLog::CreateLogFile() throw(WMICLIINT)
{
	//Create a file and returns the handle 
	m_hFile = CreateFile(m_pszLogFile, GENERIC_WRITE, 0, 
		NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 
		NULL);
	
	if (m_hFile == INVALID_HANDLE_VALUE)
	{
		DisplayWin32Error();
		throw(WIN32_FUNC_ERROR);
	}
}

/*------------------------------------------------------------------------
   Name				 :SetLogFilePath
   Synopsis	         :This function sets the m_pszLogFile name with the 
					  input
   Type	             :Member Function
   Input parameter   :
     pszLogFile  -  String type,Contains the log file name
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetLogFilePath(pszLogFile)
   Notes             :None
------------------------------------------------------------------------*/
void CWMICliLog::SetLogFilePath(_TCHAR* pszLogFile) throw (WMICLIINT)
{
	SAFEDELETE(m_pszLogFile);
	m_pszLogFile = new _TCHAR [lstrlen(pszLogFile) + 1];
	if (m_pszLogFile)
	{
		//Copy the input argument into the log file name
		lstrcpy(m_pszLogFile, pszLogFile);
	}
	else
		throw(OUT_OF_MEMORY);
}

/*------------------------------------------------------------------------
   Name				 :CloseLogFile
   Synopsis	         :Closes the the log file 
   Type	             :Member Function 
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :CloseLogFile()
   Notes             :None
------------------------------------------------------------------------*/
void CWMICliLog::CloseLogFile()
{
	//Close the File handle
	if (m_bCreate)
	{
		CloseHandle(m_hFile);
		m_bCreate = FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\wcmain.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: wcmain.cpp 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: The _tmain function is the entry point of the
							  WMICli program.  
Revision History			: 
	Last Modified by		:Biplab Mistry
	Last Modified date		:4/11/00
****************************************************************************/ 

// wcmain.cpp :main function implementation file
#include "Precomp.h"
	
#include "CommandSwitches.h"
#include "GlobalSwitches.h"
#include "HelpInfo.h"
#include "ErrorLog.h"
#include "ParsedInfo.h"
#include "CmdTokenizer.h"
#include "CmdAlias.h"
#include "ParserEngine.h"
#include "ExecEngine.h"
#include "ErrorInfo.h"
#include "WmiCliXMLLog.h"
#include "FormatEngine.h"
#include "WmiCmdLn.h"

CWMICommandLine g_wmiCmd;
_TCHAR*			g_pszBuffer	= NULL;

/*------------------------------------------------------------------------
   Name				 :_tmain
   Synopsis	         :This function takes the error code as input and return
						an error string
   Type	             :Member Function
   Input parameters   :
      argc			 :argument count
	  argv			 :Pointer to string array storing command line arguments
   Output parameters :None
   Return Type       :Integer
   Global Variables  :None
   Calling Syntax    :
   Calls             :CWMICommandLine::Initialize,
					  CWMICommandLine::UnInitialize,
					  CFormatEngine::DisplayResults,
					  CWMICommandLine::ProcessCommandAndDisplayResults
					  
   Called by         :None
   Notes             :None
------------------------------------------------------------------------*/
__cdecl _tmain(WMICLIINT argc, _TCHAR **argv)
{
	SESSIONRETCODE	ssnRetCode			= SESSION_SUCCESS;
	BOOL			bFileEmpty			= FALSE;
	BOOL			bIndirectionInput	= FALSE;
	FILE			*fpInputFile		= NULL;
	WMICLIUINT		uErrLevel			= 0;

	try
	{
		_bstr_t bstrBuf;
		
		// Initailize the CWMICommandLine object.
		if (g_wmiCmd.Initialize())
		{
			HANDLE hStd=GetStdHandle(STD_INPUT_HANDLE);
			
			if(hStd != (HANDLE)0x00000003 && hStd != INVALID_HANDLE_VALUE &&
			   hStd != (HANDLE)0x0000000f)
			{
				if (!(g_wmiCmd.ReadXMLOrBatchFile(hStd)) ||
					(fpInputFile = _tfopen(TEMP_BATCH_FILE, _T("r"))) == NULL)
				{  
					g_wmiCmd.SetSessionErrorLevel(SESSION_ERROR);
					uErrLevel = g_wmiCmd.GetSessionErrorLevel();
					g_wmiCmd.Uninitialize();
					return uErrLevel;
				}
				bIndirectionInput = TRUE;
			}
			// If no command line arguments are specified.
			if (argc == 1)
			{
				// Allocate memory for the g_pszBuffer
				g_pszBuffer = new _TCHAR[MAX_BUFFER];	

				// If memory allocation successfull
				if (g_pszBuffer)
				{
					while (TRUE)
					{
						OUTPUTSPEC opsOutOpt = g_wmiCmd.GetParsedInfoObject().
										GetGlblSwitchesObject().
										GetOutputOrAppendOption(TRUE);
						OUTPUTSPEC opsSavedOutOpt = opsOutOpt;
						CHString chsSavedOutFileName;
						if ( opsSavedOutOpt == FILEOUTPUT )
							chsSavedOutFileName = 
										g_wmiCmd.GetParsedInfoObject().
												GetGlblSwitchesObject().
												GetOutputOrAppendFileName(TRUE);

						// Make propmt to be diplayed to stdout.
						if ( opsOutOpt != STDOUT )
						{
							g_wmiCmd.GetParsedInfoObject().
										GetGlblSwitchesObject().
										SetOutputOrAppendOption(STDOUT, TRUE);
						}
						
						// Preserve append file pointer.
						FILE* fpAppend = 
							g_wmiCmd.GetParsedInfoObject().
									GetGlblSwitchesObject().
											 GetOutputOrAppendFilePointer(FALSE);
						// Set append file pointer = null.
						g_wmiCmd.GetParsedInfoObject().
								GetGlblSwitchesObject().
									SetOutputOrAppendFilePointer(NULL, FALSE);

						// Display the prompt;
						bstrBuf = _bstr_t(EXEC_NAME);
						bstrBuf += _bstr_t(":");
						bstrBuf += _bstr_t(g_wmiCmd.GetParsedInfoObject().
										  GetGlblSwitchesObject().GetRole());
						bstrBuf += _bstr_t(">");
						DisplayMessage(bstrBuf, CP_OEMCP, FALSE, FALSE);

						// To handle Ctrl+C at propmt, Start accepting command
						g_wmiCmd.SetAcceptCommand(TRUE);

						// To handle batch input from file.
						_TCHAR *pBuf = NULL;
						while(TRUE)
						{
							if ( bIndirectionInput == TRUE )
								pBuf = _fgetts(g_pszBuffer, MAX_BUFFER-1, 
																 fpInputFile);
							else
								pBuf = _fgetts(g_pszBuffer, MAX_BUFFER-1, stdin);

							if(pBuf != NULL)
							{
								if ( bIndirectionInput == TRUE )
								{
									DisplayMessage(g_pszBuffer, CP_OEMCP, 
																FALSE, FALSE);
								}
								LONG lInStrLen = lstrlen(g_pszBuffer);
								if(g_pszBuffer[lInStrLen - 1] == _T('\n'))
										g_pszBuffer[lInStrLen - 1] = _T('\0');
								break;
							}

							// Indicates end of file
							if (pBuf == NULL)
							{
								// Set the bFileEmpty flag to TRUE
								bFileEmpty = TRUE;
								break;
							}
						}	
						// To handle Ctrl+C at propmt, End accepting command
						// and start of executing command
						g_wmiCmd.SetAcceptCommand(FALSE);

						// Set append file pointer = saved.
						g_wmiCmd.GetParsedInfoObject().
								GetGlblSwitchesObject().
								SetOutputOrAppendFilePointer(fpAppend, FALSE);

						// Redirect the output back to file specified.
						if ( opsOutOpt != STDOUT )
						{
							g_wmiCmd.GetParsedInfoObject().
								GetGlblSwitchesObject().
									SetOutputOrAppendOption(opsOutOpt, TRUE);
						}

						// Set the error level to success.
						g_wmiCmd.SetSessionErrorLevel(SESSION_SUCCESS);

						// If all the commands in the batch file got executed.
						if (bFileEmpty)
						{
							SAFEDELETE(g_pszBuffer);
							break;
						}

						// Set Break Event to False
						g_wmiCmd.SetBreakEvent(FALSE);

						// Clear the clipboard.
						g_wmiCmd.EmptyClipBoardBuffer();
						
						// Process the command and display results.
						ssnRetCode = g_wmiCmd.ProcessCommandAndDisplayResults
												(g_pszBuffer);
						uErrLevel = g_wmiCmd.GetSessionErrorLevel();

						// Break the loop if "QUIT" keyword is keyed-in.
						if(ssnRetCode == SESSION_QUIT)
						{
							SAFEDELETE(g_pszBuffer);
							break;
						}

						opsOutOpt = g_wmiCmd.GetParsedInfoObject().
												GetGlblSwitchesObject().
												GetOutputOrAppendOption(TRUE);

						if ( opsOutOpt == CLIPBOARD )
							CopyToClipBoard(g_wmiCmd.GetClipBoardBuffer());

						if ( ( opsOutOpt != FILEOUTPUT && 
							   CloseOutputFile() == FALSE ) ||
							   CloseAppendFile() == FALSE )
						{
							SAFEDELETE(g_pszBuffer);
							break;
						}

						if ( g_wmiCmd.GetParsedInfoObject().
												GetCmdSwitchesObject().
												GetOutputSwitchFlag() == TRUE )
						{
							if ( opsOutOpt	== FILEOUTPUT &&
								 CloseOutputFile() == FALSE )
							{
								SAFEDELETE(g_pszBuffer);
								break;
							}

							g_wmiCmd.GetParsedInfoObject().
										GetCmdSwitchesObject().
										SetOutputSwitchFlag(FALSE);

							if ( opsOutOpt	== FILEOUTPUT )
								g_wmiCmd.GetParsedInfoObject().
										GetGlblSwitchesObject().
										SetOutputOrAppendFileName(NULL, TRUE);

							g_wmiCmd.GetParsedInfoObject().
										GetGlblSwitchesObject().
										SetOutputOrAppendOption(opsSavedOutOpt
																, TRUE);

							if ( opsSavedOutOpt	== FILEOUTPUT )
								g_wmiCmd.GetParsedInfoObject().
										GetGlblSwitchesObject().
										SetOutputOrAppendFileName(
										 _bstr_t((LPCWSTR)chsSavedOutFileName),
										 TRUE);
						}
					}
				}
				else
				{
					ssnRetCode = SESSION_ERROR;
					g_wmiCmd.GetParsedInfoObject().GetCmdSwitchesObject().
									SetErrataCode(OUT_OF_MEMORY);
					g_wmiCmd.SetSessionErrorLevel(ssnRetCode);
					uErrLevel = g_wmiCmd.GetSessionErrorLevel();
				}	
			}
			// If command line arguments are specified.
			else 
			{
				// Obtain the command line string
				g_pszBuffer = GetCommandLine();
				if (g_pszBuffer != NULL)
				{
					// Set the error level to success.
					g_wmiCmd.SetSessionErrorLevel(SESSION_SUCCESS);

					// Process the command and display results.
					while( *(++g_pszBuffer) != _T(' '));
					ssnRetCode = g_wmiCmd.ProcessCommandAndDisplayResults(g_pszBuffer);
					uErrLevel = g_wmiCmd.GetSessionErrorLevel();
				}
			}

			// Call the uninitialize function of the CWMICommandLine object.
			g_wmiCmd.Uninitialize();

			if ( bIndirectionInput == TRUE )
			{
				fclose(fpInputFile);
				DeleteFile(TEMP_BATCH_FILE);
			}
		}
		else
		{
			ssnRetCode = SESSION_ERROR;

			// If COM error.
			if (g_wmiCmd.GetParsedInfoObject().
						GetCmdSwitchesObject().GetCOMError())
			{
				g_wmiCmd.GetFormatObject().
						DisplayResults(g_wmiCmd.GetParsedInfoObject());
			}
			g_wmiCmd.SetSessionErrorLevel(ssnRetCode);
			uErrLevel = g_wmiCmd.GetSessionErrorLevel();
			g_wmiCmd.Uninitialize();
		}
	}
	catch(...)
	{
		ssnRetCode = SESSION_ERROR;
		g_wmiCmd.GetParsedInfoObject().GetCmdSwitchesObject().
						SetErrataCode(UNKNOWN_ERROR);
		g_wmiCmd.SetSessionErrorLevel(ssnRetCode);
		DisplayString(IDS_E_WMIC_UNKNOWN_ERROR, CP_OEMCP, 
							NULL, TRUE, TRUE);
		uErrLevel = g_wmiCmd.GetSessionErrorLevel();
		g_wmiCmd.Uninitialize();
		SAFEDELETE(g_pszBuffer);
		if ( bIndirectionInput == TRUE )
		{
			fclose(fpInputFile);
			DeleteFile(TEMP_BATCH_FILE);
		}
	}
	return uErrLevel;
}

/*------------------------------------------------------------------------
   Name				 :CtrlHandler
   Synopsis	         :Handler routine to handle CTRL + C so as free
					  the memory allocated during the program execution.   
   Type	             :Global Function
   Input parameters  :
		fdwCtrlType	 - control handler type
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :
			g_pszBuffer - command buffer
			g_wmiCmd    - wmi command line object
   Notes             :None
------------------------------------------------------------------------*/
BOOL CtrlHandler(DWORD fdwCtrlType) 
{ 
	BOOL bRet = FALSE;
    switch (fdwCtrlType) 
    { 
        case CTRL_C_EVENT:
			// if at command propmt
			if ( g_wmiCmd.GetAcceptCommand() == TRUE )
			{
				SAFEDELETE(g_pszBuffer);
				g_wmiCmd.Uninitialize();
				bRet = FALSE; 
			}
			else // executing command
			{
				g_wmiCmd.SetBreakEvent(TRUE);
				bRet = TRUE;
			}
			break;
        case CTRL_CLOSE_EVENT: 
        default: 
			SAFEDELETE(g_pszBuffer);
			g_wmiCmd.Uninitialize();
            bRet = FALSE; 
			break;
    } 

	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :CloseOutputFile
   Synopsis	         :Close the output file.
   Type	             :Global Function
   Input parameters  :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :
			g_wmiCmd    - wmi command line object
   Calling Syntax	 :CloseOutputFile()	
   Notes             :None
------------------------------------------------------------------------*/
BOOL CloseOutputFile()
{
	BOOL bRet = TRUE;

	// TRUE for getting output file pointer.
	FILE* fpOutputFile = 
	   g_wmiCmd.GetParsedInfoObject().GetGlblSwitchesObject().
										   GetOutputOrAppendFilePointer(TRUE);

	// If currently output is going to file close the file.
	if ( fpOutputFile != NULL )
	{
		if ( fclose(fpOutputFile) == EOF )
		{
			DisplayString(IDS_E_CLOSE_OUT_FILE_ERROR, CP_OEMCP, 
						NULL, TRUE, TRUE);
			bRet = FALSE;
		}
		else // TRUE for setting output file pointer.
			g_wmiCmd.GetParsedInfoObject().GetGlblSwitchesObject().
									 SetOutputOrAppendFilePointer(NULL, TRUE);
	}

	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :CloseAppendFile
   Synopsis	         :Close the append file.
   Type	             :Global Function
   Input parameters  :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :
			g_wmiCmd    - wmi command line object
   Calling Syntax	 :CloseAppendFile()	
   Notes             :None
------------------------------------------------------------------------*/
BOOL CloseAppendFile()
{
	BOOL bRet = TRUE;

	// FALSE for getting append file pointer.
	FILE* fpAppendFile = 
	   g_wmiCmd.GetParsedInfoObject().GetGlblSwitchesObject().
										  GetOutputOrAppendFilePointer(FALSE);

	if ( fpAppendFile != NULL )
	{
		if ( fclose(fpAppendFile) == EOF )
		{
			DisplayString(IDS_E_CLOSE_APPEND_FILE_ERROR, CP_OEMCP, 
						NULL, TRUE, TRUE);
			bRet = FALSE;
		}
		else // FASLE for setting output file pointer.
			g_wmiCmd.GetParsedInfoObject().GetGlblSwitchesObject().
									 SetOutputOrAppendFilePointer(NULL, FALSE);
	}

	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :CopyToClipBoard
   Synopsis	         :Copy data to clip board.
   Type	             :Global Function
   Input parameters  :
		bstrClipBoardBuffer - reference to object of type _bstr_t.
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax	 :CopyToClipBoard(bstrClipBoardBuffer)	
   Notes             :None
------------------------------------------------------------------------*/
void CopyToClipBoard(_bstr_t& bstrClipBoardBuffer)
{
	HGLOBAL	hMem = CopyStringToHGlobal(bstrClipBoardBuffer);
	if (hMem != NULL)
	{    
		if (OpenClipboard(NULL))        
		{        
			EmptyClipboard();
			SetClipboardData(CF_UNICODETEXT, hMem);        
			CloseClipboard();        
		}    
		else        
			GlobalFree(hMem);  //We must clean up.
	}
}

/*------------------------------------------------------------------------
   Name				 :CopyStringToHGlobal
   Synopsis	         :Copy string to global memory.
   Type	             :Global Function
   Input parameters  :
			psz		 - LPTSTR type, specifying string to get memory allocated.
   Output parameters :None
   Return Type       :HGLOBAL
   Global Variables  :None
   Calling Syntax	 :CopyStringToHGlobal(psz)	
   Notes             :None
------------------------------------------------------------------------*/
HGLOBAL CopyStringToHGlobal(LPTSTR psz)    
{    
	HGLOBAL    hMem;
	LPTSTR     pszDst;
	hMem = GlobalAlloc(GHND, (DWORD) (lstrlen(psz)+1) * sizeof(TCHAR));
	
	if (hMem != NULL)
	{        
		pszDst = (LPTSTR) GlobalLock(hMem);        
		lstrcpy(pszDst, psz);
        GlobalUnlock(hMem);        
	}
	
	return hMem;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\parserengine.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: ParserEngine.h 
Project Name				: WMI Command Line
Author Name					: Ch.Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This file consist of class declaration of class
							  CParserEngine.
Revision History			: 		
		Last Modified By	: Sashank P
		Last Modified Date	: 10th-April-2001
*****************************************************************************/ 

/*----------------------------------------------------------------------------
 Class Name			: CParserEngine
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the functionality needed for 
					  parsing the command string entered as input and 
					  validating the same.
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: CParsedInfo
					  CCmdTokenizer
					  CCmdAlias
 Interfaces Used    : WMI COM Interfaces
----------------------------------------------------------------------------*/
// forward declaration of classes
class CParsedInfo;
class CCmdTokenizer;
class CCmdAlias;

class CParserEngine
{
public:
// Construction
	CParserEngine();

// Destruction
	~CParserEngine();

// Restrict Assignment
	CParserEngine& operator=(CParserEngine& rParserEngine);

// Attributes
private:
	// IWbemLocator interface to obtain the initial namespace pointer to the 
	//Windows Management on a particular host computer
	IWbemLocator*	m_pIWbemLocator;

	//IWbemServices interface is used by clients and providers to access WMI
	//services.This interface provides management services to client processes 
	
	IWbemServices*	m_pITargetNS;
	
	// Tokenizer object used for tokenize the command string
	CCmdTokenizer	m_CmdTknzr;
	
	// Alias object used for accessing the alias information from the WMI.
	CCmdAlias		m_CmdAlias;

	// flag to indicate whether <alias> name
	// is specified.
	BOOL			m_bAliasName;

// Operations
private:

	// Parses the global switches.
	RETCODE		ParseGlobalSwitches(CHARVECTOR& cvTokens,
								CHARVECTOR::iterator& theIterator, 
								CParsedInfo& rParsedInfo);

	// Parses the <alias> information.
	RETCODE		ParseAliasInfo(CHARVECTOR& cvTokens,
						   CHARVECTOR::iterator& theIterator,
						   CParsedInfo& rParsedInfo);

	// Parses the CLASS information.
	RETCODE		ParseClassInfo(CHARVECTOR& cvTokens,
						   CHARVECTOR::iterator& theIterator,
						   CParsedInfo& rParsedInfo);

	// Parses the Verb information 	
	RETCODE		ParseVerbInfo(CHARVECTOR& cvTokens,
						  CHARVECTOR::iterator& theIterator, 
						  CParsedInfo& rParsedInfo);
	
	// Parse the GET verb information
	RETCODE		ParseGETVerb(CHARVECTOR& cvTokens,
						 CHARVECTOR::iterator& theIterator, 
						 CParsedInfo& rParsedInfo);


	// Parse the LIST verb information
	RETCODE		ParseLISTVerb(CHARVECTOR& cvTokens,
						  CHARVECTOR::iterator& theIterator, 
						  CParsedInfo& rParsedInfo);

	// Parse the SET | CREATE verb information
	RETCODE		ParseSETorCREATEVerb(CHARVECTOR& cvTokens,
						 CHARVECTOR::iterator& theIterator, 
						 CParsedInfo& rParsedInfo,
						 HELPTYPE helpType);

	// Parse the ASSOC verb information
	RETCODE		ParseASSOCVerb(CHARVECTOR& cvTokens,
						   CHARVECTOR::iterator& theIterator, 
						   CParsedInfo& rParsedInfo);

	// Parse the CALL verb information
	RETCODE		ParseCALLVerb(CHARVECTOR& cvTokens,
						  CHARVECTOR::iterator& theIterator, 
						  CParsedInfo& rParsedInfo);

	// Parse the method information
	RETCODE		ParseMethodInfo(CHARVECTOR& cvTokens,
							CHARVECTOR::iterator& theIterator, 
							CParsedInfo& rParsedInfo);

	// Parses the GET verb switches information
	RETCODE		ParseGETSwitches(CHARVECTOR& cvTokens,
							 CHARVECTOR::iterator& theIterator,
							 CParsedInfo& rParsedInfo);
	
	//Checks for help option in advance.
	RETCODE		CheckForHelp(CHARVECTOR& cvTokens, 
						 CHARVECTOR::iterator& theIterator,
						 CParsedInfo& rParsedInfo,
						 UINT uErrataCode);

	// Parses the PATH expression.
	RETCODE		ParsePathInfo(CHARVECTOR& cvTokens,
						  CHARVECTOR::iterator& theIterator,
						  CParsedInfo& rParsedInfo);

	// Parses the WHERE expression.
	RETCODE		ParseWhereInfo(CHARVECTOR& cvTokens,
						   CHARVECTOR::iterator& theIterator,
						   CParsedInfo& rParsedInfo);
	
	// Parses the SET | CREATE | NamedParams verb argument list
	RETCODE		ParseSETorCREATEOrNamedParamInfo(CHARVECTOR& cvTokens,
							 CHARVECTOR::iterator& theIterator,
							 CParsedInfo& rParsedInfo,
							 HELPTYPE helpType);

	// Parses the LIST switches information 
	RETCODE		ParseLISTSwitches(CHARVECTOR& cvTokens,
							  CHARVECTOR::iterator& theIterator,
							  CParsedInfo& rParsedInfo,
							  BOOL& bFormatSwitchSpecified);
	
	// Parses the Verb switches information 
	RETCODE		ParseVerbSwitches(CHARVECTOR& cvTokens, 
							  CHARVECTOR::iterator& theIterator,
							  CParsedInfo& rParsedInfo);

	// Gets the next token from the Tokens vector - overload 1.
	BOOL		GetNextToken(CHARVECTOR& cvTokens, 
					  CHARVECTOR::iterator& theIterator);

	// Gets the next token from the Tokens vector - overload 2.
	RETCODE		GetNextToken(CHARVECTOR& cvTokens, 
						 CHARVECTOR::iterator& theIterator,
						 CParsedInfo& rParsedInfo,
						 HELPTYPE helpType,
						 UINT uErrataCode);

	// Gets the next token from the Tokens vector - overload 3.
	RETCODE		GetNextToken(CHARVECTOR& cvTokens,
  						 CHARVECTOR::iterator& theIterator,
						 CParsedInfo& rParsedInfo, 
						 UINT uErrataCode);

	// Check whether the next token is '?' 
	RETCODE		IsHelp(CHARVECTOR& cvTokens, 
					CHARVECTOR::iterator& theIterator,
					CParsedInfo& rParsedInfo,
					HELPTYPE helpType,
					UINT uErrataCode,
					TOKENLEVEL tokenLevel = LEVEL_ONE);

	// Parse for help information - overload 1
	RETCODE		ParseHelp(CHARVECTOR& cvTokens, 
					  CHARVECTOR::iterator& theIterator,
					  CParsedInfo& rParsedInfo,
					  BOOL bGlobalHelp = FALSE);

	// Parse for help information - overload 2
	RETCODE		ParseHelp(CHARVECTOR& cvTokens, 
					  CHARVECTOR::iterator& theIterator,
					  HELPTYPE htHelp,
					  CParsedInfo& rParsedInfo,
					  BOOL bGlobalHelp = FALSE);

	// Parse and form a PWhere expression 
	BOOL		ParsePWhereExpr(CHARVECTOR& cvTokens,    
						 CHARVECTOR::iterator& theIterator,
						 CParsedInfo& rParsedInfo,
						 BOOL bIsParan);

	// Extracts the Classname and the where expression 
	// out of the given path expression
	BOOL		ExtractClassNameandWhereExpr(_TCHAR* pszPathExpr, 
							  		  CParsedInfo& rParsedInfo);

	// Obtains properties associated with the class for /get help
	// If bCheckWritePropsAvail == TRUE then functions checks for availibilty 
	// of properties.
	BOOL		ObtainClassProperties(CParsedInfo& rParsedInfo, 
									  BOOL bCheckWritePropsAvail = FALSE);

	// Obtains parameters of the method
	HRESULT		ObtainMethodParamInfo(IWbemClassObject* pIObj, 
								  METHODDETAILS& mdMethDet,
								  INOROUT ioInOrOut,
								  BOOL bTrace, CParsedInfo& rParsedInfo);

	// Get the status of method ( implemented or not ).
	HRESULT		GetMethodStatusAndDesc(IWbemClassObject* pIObj, 
								   BSTR bstrMethod,
								   _bstr_t& bstrStatus,
								   _bstr_t& bstrDesc,
								   BOOL bTrace);

	// Obtain class methods. if bCheckForExists == TRUE then it 
	// checks for availibility of methods with class.
	BOOL		ObtainClassMethods(CParsedInfo& rParsedInfo, 
								   BOOL bCheckForExists = FALSE);

	// Connects to Target Namespace. 
	HRESULT		ConnectToNamespace(CParsedInfo& rParsedInfo);

	// Parses EVERY switch.
	RETCODE		ParseEVERYSwitch(CHARVECTOR& cvTokens,
			    			 CHARVECTOR::iterator& theIterator,
							 CParsedInfo& rParsedInfo);

	// Parses FORMAT switch.
	RETCODE		ParseFORMATSwitch(CHARVECTOR& cvTokens,
			 				  CHARVECTOR::iterator& theIterator,
							  CParsedInfo& rParsedInfo);

	// Validates the value passed with global switches.
	RETCODE		ValidateGlobalSwitchValue(CHARVECTOR& cvTokens,
									  CHARVECTOR::iterator& theIterator, 
									  UINT uErrataCode,
									  CParsedInfo& rParsedInfo,
									  UINT uErrataCode2,
									  HELPTYPE htHelp);

	// Is pszToken is Std verb or User defined verb.
	BOOL		IsStdVerbOrUserDefVerb( _bstr_t pszToken,
		  					     CParsedInfo& rParsedInfo );

	// Parses the TRANSLATE switch.
	RETCODE		ParseTRANSLATESwitch(CHARVECTOR& cvTokens,
			  					 CHARVECTOR::iterator& theIterator,
								 CParsedInfo& rParsedInfo);

	// Parsed the CONTEXT switch.
	RETCODE		ParseContextInfo(CHARVECTOR& cvTokens,
								CHARVECTOR::iterator& theIterator, 
								CParsedInfo& rParsedInfo);

	// Validates the node name/namespace
	BOOL		ValidateNodeOrNS(_TCHAR* pszInput, BOOL bNode);

	// Parses the ASSOC switches information 
	RETCODE		ParseAssocSwitches(CHARVECTOR& cvTokens,
								CHARVECTOR::iterator& theIterator,
								CParsedInfo& rParsedInfo);

	// Parses the ASSOC switches - RESULTCLASSS,RESULTROLE ,ASSOCCLASSS  
	RETCODE		ParseAssocSwitchEx(CHARVECTOR& cvTokens,
								CHARVECTOR::iterator& theIterator,
								CParsedInfo& rParsedInfo, 
								ASSOCSwitch assocSwitch);

	// Parsing Switch:Count ( /EVERY:N and /REPEAT:N )
	RETCODE		ParseNumberedSwitch(CHARVECTOR& cvTokens,
									CHARVECTOR::iterator& theIterator,
									CParsedInfo& rParsedInfo,
									HELPTYPE htHelp,
									UINT uSwitchErrCode,
									UINT uNumberErrCode);

	// Validates a class;
	BOOL	IsValidClass(CParsedInfo& rParsedInfo);

	// Checks whether methods are available with alias in case of alias specified.
	// and with class in case of class speicified.
	void	ObtainMethodsAvailableFlag(CParsedInfo& rParsedInfo);

	// Checks whether Writeable Props are available with alias in case of alias 
	//	specified. and with class in case of class speicified.
	void	ObtainWriteablePropsAvailailableFlag(CParsedInfo& rParsedInfo);

	// Checks whether FULL Props are available with alias in case of alias 
	//	specified. and with class in case of class speicified.
	void	ObtainFULLPropsAvailailableFlag(CParsedInfo& rParsedInfo);

	// This function parses the verb interactive option
	RETCODE	ParseVerbInteractive(CHARVECTOR& cvTokens,
							CHARVECTOR::iterator& theIterator, 
							CParsedInfo& rParsedInfo, BOOL& bInvalidOption);

	// Prepares the output and append files for output redirection.
	RETCODE	ProcessOutputAndAppendFiles(CParsedInfo& rParsedInfo, RETCODE retCode,
										BOOL bOpenOutInWriteMode);

	// Parse Unnamed Parameter list.
	RETCODE ParseUnnamedParamList(CHARVECTOR& cvTokens,
								  CHARVECTOR::iterator& theIterator,
								  CParsedInfo& rParsedInfo);

	// Validates the named params with verb or method parameters.
	RETCODE	ValidateVerbOrMethodParams(CParsedInfo& rParsedInfo);

	// Parses paramName = paramValue strings.
	RETCODE	ParseParamsString(CHARVECTOR& cvTokens,
							  CHARVECTOR::iterator& theIterator,
							  CParsedInfo& rParsedInfo,
							  XSLTDET& xdXSLTDet,
							  _TCHAR* pszXSLFile);

	// Parses the node list file.
	RETCODE	ParseNodeListFile(CHARVECTOR& cvTokens,
							  CHARVECTOR::iterator& theIterator,
							  CParsedInfo& rParsedInfo);

	// Retrieve Node by Node from Node list file
	BOOL GetNodeFromNodeFile(FILE*		fpNodeListFile, 
							 FILETYPE   eftNodeFileType,
							 _TCHAR*	szNodeName);
public:
	// Gets the command tokenizer 
	CCmdTokenizer& GetCmdTokenizer();
	
	// It does the Processing the token .
	RETCODE ProcessTokens(CParsedInfo& rParsedInfo);
	
	// Initializes the member variables 
	void Initialize();
	
	// Uninitializes the member variables 
	void Uninitialize(BOOL bFinal = FALSE);
	
	// Sets the locator object .
	BOOL SetLocatorObject(IWbemLocator* pIWbemLocator);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\wmiclixmllog.cpp ===
///////////////////////////////////////////////////////////////////////
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: WMICliLog.cpp 
Project Name				: WMI Command Line
Author Name					: Biplab Mistry
Date of Creation (dd/mm/yy) : 02-March-2001
Version Number				: 1.0 
Brief Description			: This class encapsulates the functionality needed
							  for logging the input and output.
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 27-March-2001
*****************************************************************************/ 
// WMICliXMLLog.cpp : implementation file
#include "Precomp.h"
#include "helpinfo.h"
#include "ErrorLog.h"
#include "GlobalSwitches.h"
#include "CommandSwitches.h"
#include "ParsedInfo.h"
#include "WMICliXMLLog.h"

/*------------------------------------------------------------------------
   Name				 :CWMICliXMLLog
   Synopsis	         :Constructor 
   Type	             :Constructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CWMICliXMLLog::CWMICliXMLLog()
{
	m_pIXMLDoc		= NULL;
	m_pszLogFile	= NULL;
	m_bCreate		= FALSE;
	m_nItrNum		= 0;
	m_bTrace		= FALSE;
	m_eloErrLogOpt	= NO_LOGGING;
}	

/*------------------------------------------------------------------------
   Name				 :~CWMICliXMLLog
   Synopsis	         :Destructor
   Type	             :Destructor
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CWMICliXMLLog::~CWMICliXMLLog()
{
	SAFEDELETE(m_pszLogFile);
	SAFEIRELEASE(m_pIXMLDoc);
}

/*----------------------------------------------------------------------------
   Name				 :Uninitialize
   Synopsis	         :This function uninitializes the member variables when 
					  the execution of a command string issued on the command 
					  line is completed.
   Type	             :Member Function
   Input Parameter(s):
			bFinal	- boolean value which when set indicates that the program
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :Uninitialize(bFinal)
   Notes             :None
----------------------------------------------------------------------------*/
void CWMICliXMLLog::Uninitialize(BOOL bFinal)
{
	if (bFinal)
	{
		SAFEDELETE(m_pszLogFile);
		SAFEIRELEASE(m_pIXMLDoc);
	}
	m_bTrace		= FALSE;
	m_eloErrLogOpt	= NO_LOGGING;
}

/*------------------------------------------------------------------------
   Name				 :WriteToXMLLog
   Synopsis	         :Logs the input & output to the xml log file
   Type	             :Member Function 
   Input parameter   :
				rParsedInfo - reference to CParsedInfo object
				bstrOutput  - output that goes into CDATA section.
   Output parameters :None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :WriteToXMLLog(rParsedInfo, bstrOutput)
   Notes             :None
------------------------------------------------------------------------*/
HRESULT	CWMICliXMLLog::WriteToXMLLog(CParsedInfo& rParsedInfo, BSTR bstrOutput)
{
	HRESULT				hr					= S_OK;
	_variant_t			varValue;
	DWORD				dwThreadId			= GetCurrentThreadId();
	BSTR				bstrUser			= NULL,
						bstrStart			= NULL,
						bstrInput			= NULL,
						bstrTarget			= NULL,
						bstrNode			= NULL;
	WMICLIINT			nSeqNum				= 0;
	BOOL				bNewCmd				= FALSE;
	BOOL				bNewCycle			= FALSE;

	// Initialize the TRACE and ERRORLOG variables.
	m_bTrace		= rParsedInfo.GetGlblSwitchesObject().GetTraceStatus();
	m_eloErrLogOpt	= rParsedInfo.GetErrorLogObject().GetErrLogOption();
	bNewCmd			= rParsedInfo.GetNewCommandStatus();
	bNewCycle		= rParsedInfo.GetNewCycleStatus();
	CHString		chsMsg;
	try
	{
		bstrUser  = ::SysAllocString(rParsedInfo.GetGlblSwitchesObject().
								GetLoggedonUser());
		bstrStart = ::SysAllocString(rParsedInfo.GetGlblSwitchesObject().
								GetStartTime());
		bstrInput = ::SysAllocString(rParsedInfo.GetCmdSwitchesObject().
								GetCommandInput());

		if (!rParsedInfo.GetGlblSwitchesObject().GetAggregateFlag())
		{
			bstrTarget= ::SysAllocString(rParsedInfo.GetGlblSwitchesObject().
								GetNode());
		}
		else
		{
			_bstr_t bstrTemp;
			_TCHAR* pszVerb = rParsedInfo.GetCmdSwitchesObject().GetVerbName();
			if (pszVerb)
			{
				if ( CompareTokens(pszVerb, CLI_TOKEN_LIST) || 
				CompareTokens(pszVerb, CLI_TOKEN_ASSOC) || 
				CompareTokens(pszVerb, CLI_TOKEN_GET))
				{
					rParsedInfo.GetGlblSwitchesObject().GetNodeString(bstrTemp);
					bstrTarget = ::SysAllocString((LPWSTR)bstrTemp);
				}
				// CALL, SET, CREATE, DELETE and, user defined verbs
				else 
				{
					bstrTarget= ::SysAllocString(rParsedInfo.GetGlblSwitchesObject().
								GetNode());
				}
			}
			else
			{
				rParsedInfo.GetGlblSwitchesObject().GetNodeString(bstrTemp);
				bstrTarget = ::SysAllocString((LPWSTR)bstrTemp);
			}
			
		}

		bstrNode  = ::SysAllocString(rParsedInfo.GetGlblSwitchesObject().
								GetMgmtStationName());
		nSeqNum	  = rParsedInfo.GetGlblSwitchesObject().GetSequenceNumber();
		// If first time.
		if(!m_bCreate)
		{
			// Create the XML root node
			hr = CreateXMLLogRoot(rParsedInfo, bstrUser);
			ONFAILTHROWERROR(hr);
		}

		if (bNewCmd == TRUE)
		{
			m_nItrNum = 1;
			// Create the node fragment and append it
			hr = CreateNodeFragment(nSeqNum, bstrNode, bstrStart, 
								bstrInput, bstrOutput, bstrTarget,
								rParsedInfo);
			ONFAILTHROWERROR(hr);
		}
		else
		{
			if (bNewCycle)
				m_nItrNum++;
			hr = AppendOutputNode(bstrOutput, bstrTarget, rParsedInfo);
			ONFAILTHROWERROR(hr);
		}

		// Save the result to the XML file specified.
		varValue = (WCHAR*) m_pszLogFile;
		hr = m_pIXMLDoc->save(varValue);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMDocument2::save(L\"%s\")", 
						(LPWSTR) varValue.bstrVal);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
										   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);
		::SysFreeString(bstrUser);
		::SysFreeString(bstrStart);
		::SysFreeString(bstrInput);
		::SysFreeString(bstrTarget);
		::SysFreeString(bstrNode);
	}
	catch(_com_error& e)
	{
		::SysFreeString(bstrUser);
		::SysFreeString(bstrStart);
		::SysFreeString(bstrInput);
		::SysFreeString(bstrTarget);
		::SysFreeString(bstrNode);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		::SysFreeString(bstrUser);
		::SysFreeString(bstrStart);
		::SysFreeString(bstrInput);
		::SysFreeString(bstrTarget);
		::SysFreeString(bstrNode);
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	return hr;
}

/*------------------------------------------------------------------------
   Name				 :SetLogFilePath
   Synopsis	         :This function sets the m_pszLogFile name with the 
					  input
   Type	             :Member Function
   Input parameter   :
     pszLogFile  -  String type,Contains the log file name
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetLogFilePath(pszLogFile)
   Notes             :None
------------------------------------------------------------------------*/
void CWMICliXMLLog::SetLogFilePath(_TCHAR* pszLogFile) throw (WMICLIINT)
{
	SAFEDELETE(m_pszLogFile);
	m_pszLogFile = new _TCHAR [lstrlen(pszLogFile) + 1];
	if (m_pszLogFile)
	{
		//Copy the input argument into the log file name
		lstrcpy(m_pszLogFile, pszLogFile);
	}
	else
		throw(OUT_OF_MEMORY);
}

/*------------------------------------------------------------------------
   Name				 :CreateXMLLogRoot
   Synopsis	         :Creates the root node of the xml log file
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo	- reference to CParsedInfo object
		bstrUser	- current user name
   Output parameters :None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :CreateXMLLogRoot(rParsedInfo, bstrUser)
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CWMICliXMLLog::CreateXMLLogRoot(CParsedInfo& rParsedInfo, BSTR bstrUser)
{
	HRESULT			hr					= S_OK;
	IXMLDOMNode		*pINode				= NULL;
	DWORD			dwThreadId			= GetCurrentThreadId();
	CHString		chsMsg;

	try
	{
		// Create single instance of the IXMLDOMDocument2 interface
		hr = CoCreateInstance(CLSID_DOMDocument, NULL, 
									CLSCTX_INPROC_SERVER,
									IID_IXMLDOMDocument2, 
									(LPVOID*)&m_pIXMLDoc);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"CoCreateInstance(CLSID_DOMDocument, NULL,"
				L"CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument2, -)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
										   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Create the XML root node <WMICRECORD USER=XXX>
		_variant_t			varType((short)NODE_ELEMENT);
		_bstr_t				bstrName(L"WMIRECORD");
		_variant_t			varValue;

		// Create a new node 
		hr = CreateNodeAndSetContent(&pINode, varType, bstrName, NULL,
									rParsedInfo); 
		ONFAILTHROWERROR(hr);

		// Append the attribute "USER"
		bstrName = L"USER";
		varValue = (WCHAR*)bstrUser;
		
		hr = AppendAttribute(pINode, bstrName, varValue, rParsedInfo);
		ONFAILTHROWERROR(hr);

		hr = m_pIXMLDoc->appendChild(pINode, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMNode::appendChild(-, NULL)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
										   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		SAFEIRELEASE(pINode);

		// set the m_bCreate flag to TRUE
		m_bCreate=TRUE;
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pINode);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pINode);
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	return hr;
}

/*------------------------------------------------------------------------
   Name				 :StopLogging
   Synopsis	         :Stops logging and closes the xml DOM document object
   Type	             :Member Function 
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :StopLogging()
   Notes             :None
------------------------------------------------------------------------*/
void CWMICliXMLLog::StopLogging()
{
	SAFEDELETE(m_pszLogFile);
	SAFEIRELEASE(m_pIXMLDoc);
	m_bCreate = FALSE;
}

/*------------------------------------------------------------------------
   Name				 :CreateNodeAndSetContent
   Synopsis	         :Creates the new node and sets the content
   Type	             :Member Function 
   Input parameter   :
		pINode		- pointer to node object
		varType		- node type
		bstrName	- Node name
		bstrValue	- node content
		rParsedInfo - reference to CParsedInfo object
   Output parameters :None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :CreateNodeAndSetContent(&pINode, varType, 
									bstrName, bstrValue, rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CWMICliXMLLog::CreateNodeAndSetContent(IXMLDOMNode** pINode, 
								VARIANT varType,
								BSTR bstrName,	BSTR bstrValue,
								CParsedInfo& rParsedInfo)
{
	HRESULT					hr					= S_OK;
	DWORD					dwThreadId			= GetCurrentThreadId();
	CHString				chsMsg;
	try
	{
		hr = m_pIXMLDoc->createNode(varType, bstrName, L"", pINode);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMDocument2::createNode(%d, \"%s\", L\"\","
								L" -)", varType.lVal, (LPWSTR) bstrName);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
										   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		if (bstrValue)
		{
			hr = (*pINode)->put_text(bstrValue);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IXMLDOMNode::put_text(L\"%s\")",	(LPWSTR) bstrValue);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
										   dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);
		}
	}
	catch(_com_error& e)
	{
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	return hr;
}

/*------------------------------------------------------------------------
   Name				 :AppendAttribute
   Synopsis	         :Append attribute with the given value to the node 
					  specified.
   Type	             :Member Function 
   Input parameter   :
		pINode			- node object
		bstrAttribName	- Attribute name
		varValue		- attribute value
		rParsedInfo		- reference to CParsedInfo object
   Output parameters :None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :AppendAttribute(pINode, bstrAttribName, varValue, 
						rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CWMICliXMLLog::AppendAttribute(IXMLDOMNode* pINode, BSTR bstrAttribName, 
						VARIANT varValue, CParsedInfo& rParsedInfo)
{
	HRESULT					hr					= S_OK;
	IXMLDOMNamedNodeMap		*pINodeMap			= NULL;
	IXMLDOMAttribute		*pIAttrib			= NULL;
	DWORD					dwThreadId			= GetCurrentThreadId();
	CHString				chsMsg;

	try
	{
		// Get the attributes map
		hr = pINode->get_attributes(&pINodeMap);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMNode::get_attributes(-)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
									   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		if (pINodeMap)
		{
			// Create the attribute with the given name.
			hr = m_pIXMLDoc->createAttribute(bstrAttribName, &pIAttrib);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IXMLDOMDocument2::createAttribute(L\"%s\", -)",
									(LPWSTR) bstrAttribName);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
									   dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			// Set the attribute value
			if (pIAttrib)
			{
				hr = pIAttrib->put_nodeValue(varValue);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IXMLDOMAttribute::put_nodeValue(L\"%s\")",
							(LPWSTR) _bstr_t(varValue));
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
									   dwThreadId, rParsedInfo, m_bTrace);
				}
				ONFAILTHROWERROR(hr);

				hr = pINodeMap->setNamedItem(pIAttrib, NULL);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IXMLDOMNamedNodeMap::setNamedItem(-, NULL)");
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
									   dwThreadId, rParsedInfo, m_bTrace);
				}
				ONFAILTHROWERROR(hr);
				SAFEIRELEASE(pIAttrib);
			}
			SAFEIRELEASE(pINodeMap);
		}
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIAttrib);
		SAFEIRELEASE(pINodeMap);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIAttrib);
		SAFEIRELEASE(pINodeMap);
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	return hr;
}

/*------------------------------------------------------------------------
   Name				 :CreateNodeFragment
   Synopsis	         :Creates a new node fragment with the predefined format
					  and appends it to the document object
   Type	             :Member Function 
   Input parameter   :
		nSeqNum			- sequence # of the command.
		bstrNode		- management workstation name
		bstrStart		- command issued time
		bstrInput		- commandline input
		bstrOutput		- commandline output
		bstrTarget		- target node
		rParsedInfo		- reference to CParsedInfo object
   Output parameters :None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :CreateNodeFragment(nSeqNum, bstrNode, bstrStart, 
						bstrInput, bstrOutput, bstrTarget, rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CWMICliXMLLog::CreateNodeFragment(WMICLIINT nSeqNum, BSTR bstrNode, 
										  BSTR bstrStart, BSTR bstrInput,
										  BSTR bstrOutput, BSTR bstrTarget,
										  CParsedInfo& rParsedInfo)
		
{
	HRESULT					hr					= S_OK;
	IXMLDOMNode				*pINode				= NULL,
							*pISNode			= NULL,
							*pITNode			= NULL;
	IXMLDOMDocumentFragment	*pIFrag				= NULL;
	IXMLDOMElement			*pIElement			= NULL;

	_variant_t				varType;
	_bstr_t					bstrName;
	_variant_t				varValue;
	DWORD					dwThreadId			= GetCurrentThreadId();
	CHString				chsMsg;
	
	try
	{
		// The nodetype is NODE_ELEMENT
		varType = ((short)NODE_ELEMENT);

		bstrName = _T("RECORD");
		// Create a new node
		hr = CreateNodeAndSetContent(&pINode, varType, 
							bstrName, NULL, rParsedInfo); 
		ONFAILTHROWERROR(hr);

		// Append the attribute "SEQUENCENUM"
		bstrName = L"SEQUENCENUM";
		varValue = (long) nSeqNum;
		hr = AppendAttribute(pINode, bstrName, varValue, rParsedInfo);
		ONFAILTHROWERROR(hr);

		// Append the attribute "ISSUEDFROM"
		bstrName = L"ISSUEDFROM";
		varValue = (WCHAR*)bstrNode;
		hr = AppendAttribute(pINode, bstrName, varValue, rParsedInfo);
		ONFAILTHROWERROR(hr);

		// Append the attribute "STARTTIME"
		bstrName = L"STARTTIME";
		varValue = (WCHAR*) bstrStart;
		hr = AppendAttribute(pINode, bstrName, varValue, rParsedInfo);
		ONFAILTHROWERROR(hr);

		// Create a document fragment and associate the new node with it.
		hr = m_pIXMLDoc->createDocumentFragment(&pIFrag);	
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMDocument2::createDocumentFragment(-)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);
		
		hr = pIFrag->appendChild(pINode, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMDocumentFragment::appendChild(-, NULL)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Append the REQUEST node together with the input command.
		bstrName = _T("REQUEST");
		hr = CreateNodeAndSetContent(&pISNode, varType, 
							bstrName, NULL, rParsedInfo); 
		ONFAILTHROWERROR(hr);

		hr = pINode->appendChild(pISNode, &pITNode);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMNode::appendChild(-, NULL)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);			
		}
		ONFAILTHROWERROR(hr);
		SAFEIRELEASE(pISNode);

		bstrName  = _T("COMMANDLINE");
		hr = CreateNodeAndSetContent(&pISNode, varType, 
							bstrName, bstrInput, rParsedInfo); 
		ONFAILTHROWERROR(hr);

		hr = pITNode->appendChild(pISNode, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMNode::appendChild(-, NULL)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);						
		}
		ONFAILTHROWERROR(hr);
		SAFEIRELEASE(pISNode);
		SAFEIRELEASE(pITNode);

		hr = FrameOutputNode(&pINode, bstrOutput, bstrTarget, rParsedInfo);

		// Get the document element of the XML log file
		hr = m_pIXMLDoc->get_documentElement(&pIElement);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMDocument2::get_documentElement(-, NULL)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);				
		}
		ONFAILTHROWERROR(hr);

		// Append the newly create fragment to the document element
		hr = pIElement->appendChild(pIFrag,	NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMElement::appendChild(-, NULL)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);							
		}
		ONFAILTHROWERROR(hr);

		SAFEIRELEASE(pINode);
		SAFEIRELEASE(pIFrag);
		SAFEIRELEASE(pIElement);
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pISNode);
		SAFEIRELEASE(pITNode);
		SAFEIRELEASE(pINode);
		SAFEIRELEASE(pIFrag);
		SAFEIRELEASE(pIElement);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pISNode);
		SAFEIRELEASE(pITNode);
		SAFEIRELEASE(pINode);
		SAFEIRELEASE(pIFrag);
		SAFEIRELEASE(pIElement);
		hr = WBEM_E_OUT_OF_MEMORY;
	}

	return hr;
}

/*------------------------------------------------------------------------
   Name				 :FrameOutputNode
   Synopsis	         :Frames a new output node 
   Type	             :Member Function 
   Input parameter   :
		pINode			- pointer to pointer to IXMLDOMNode object
		bstrOutput		- commandline output
		bstrTarget		- target node
		rParsedInfo		- reference to CParsedInfo object
   Output parameters :
		pINode			- pointer to pointer to IXMLDOMNode object
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :FrameOutputNode(&pINode, bstrOutput, bstrTarget,
								rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CWMICliXMLLog::FrameOutputNode(IXMLDOMNode	**pINode, BSTR bstrOutput, 
										BSTR bstrTarget, 
										CParsedInfo& rParsedInfo)
{
	HRESULT					hr					= S_OK;
	IXMLDOMNode				*pISNode			= NULL;
	IXMLDOMCDATASection		*pICDATASec			= NULL;
	_bstr_t					bstrName;
	_variant_t				varType,
							varValue;		
	DWORD					dwThreadId			= GetCurrentThreadId();
	CHString				chsMsg;
	try
	{
		// The nodetype is NODE_ELEMENT
		varType = ((short)NODE_ELEMENT);

		// Append the OUTPUT node together with the output generated.
		bstrName = _T("OUTPUT");
		hr = CreateNodeAndSetContent(&pISNode, varType, 
							bstrName, NULL, rParsedInfo); 
		ONFAILTHROWERROR(hr);

		// Append the attribute "TARGETNODE"
		bstrName = L"TARGETNODE";
		varValue = (WCHAR*) bstrTarget;
		hr = AppendAttribute(pISNode, bstrName, varValue, rParsedInfo);
		ONFAILTHROWERROR(hr);

		// Append the attribute "ITERATION"
		bstrName = L"ITERATION";
		varValue = (long)m_nItrNum;
		hr = AppendAttribute(pISNode, bstrName, varValue, rParsedInfo);
		ONFAILTHROWERROR(hr);

		// Create the CDATASection 
		hr = m_pIXMLDoc->createCDATASection(bstrOutput, &pICDATASec);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMDocument2::createCDATASection(-, -)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);										
		}
		ONFAILTHROWERROR(hr);

		// Append the CDATASection node to the OUTPUT node.
		hr = pISNode->appendChild(pICDATASec, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMNode::appendChild(-, NULL)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);		
		}
		ONFAILTHROWERROR(hr);
		SAFEIRELEASE(pICDATASec);

		hr = (*pINode)->appendChild(pISNode, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMNode::appendChild(-, NULL)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);			
		}
		ONFAILTHROWERROR(hr);
		
		SAFEIRELEASE(pISNode);
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pICDATASec);
		SAFEIRELEASE(pISNode);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pICDATASec);
		SAFEIRELEASE(pISNode);
		hr = WBEM_E_OUT_OF_MEMORY;

	}
	return hr;
}

/*------------------------------------------------------------------------
   Name				 :AppendOutputNode
   Synopsis	         :appends the newoutput node element to the exisitng
					  and that too last RECORD node
   Type	             :Member Function 
   Input parameter   :
		bstrOutput		- commandline output
		bstrTarget		- target node
		rParsedInfo		- reference to CParsedInfo object
   Output parameters : None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :AppendOutputNode(bstrOutput, bstrTarget,
								rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CWMICliXMLLog::AppendOutputNode(BSTR bstrOutput, BSTR bstrTarget,
										CParsedInfo& rParsedInfo)
{
	IXMLDOMNodeList		*pINodeList			= NULL;
	HRESULT				hr					= S_OK;
	LONG				lValue				= 0;	
	IXMLDOMNode			*pINode				= NULL;
	IXMLDOMNode			*pIParent			= NULL,
						*pIClone			= NULL;	
	DWORD				dwThreadId			= GetCurrentThreadId();
	CHString			chsMsg;

	try
	{
		hr = m_pIXMLDoc->getElementsByTagName(_T("RECORD"), &pINodeList);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMDocument2::getElementsByTagName(L\"RECORD\", -)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);			
		}
		ONFAILTHROWERROR(hr);

		hr = pINodeList->get_length(&lValue);
		ONFAILTHROWERROR(hr);

		hr = pINodeList->get_item(lValue-1, &pINode);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMNodeList::get_item(%d, -)", lValue-1);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);				
		}
		ONFAILTHROWERROR(hr);

		if (pINode)
		{
			hr = pINode->cloneNode(VARIANT_TRUE, &pIClone);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IXMLDOMNode::cloneNode(VARIANT_TRUE, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);					
			}
			ONFAILTHROWERROR(hr);

			hr = pINode->get_parentNode(&pIParent);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IXMLDOMNode::get_ParentNode(-)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);				
			}
			ONFAILTHROWERROR(hr);

			hr = FrameOutputNode(&pIClone, bstrOutput, bstrTarget, rParsedInfo);
			ONFAILTHROWERROR(hr);

			hr = pIParent->replaceChild(pIClone, pINode, NULL);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IXMLDOMNode::replaceChild(-, -, NULL)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);				
			}
			ONFAILTHROWERROR(hr);
		}
		SAFEIRELEASE(pINodeList);
		SAFEIRELEASE(pIClone);
		SAFEIRELEASE(pIParent);
		SAFEIRELEASE(pINode);
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pINodeList);
		SAFEIRELEASE(pIClone);
		SAFEIRELEASE(pIParent);
		SAFEIRELEASE(pINode);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pINodeList);
		SAFEIRELEASE(pIClone);
		SAFEIRELEASE(pIParent);
		SAFEIRELEASE(pINode);
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\wmiclilog.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: WMICliLog.h 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 4th-October-2000
Version Number				: 1.0 
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 18th-November-2000
****************************************************************************/ 
// WMICliLog.h : header file
//
/*-------------------------------------------------------------------
 Class Name			: CWMICliLog
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the functionality needed
					  for logging the input and output
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: None
 Interfaces Used    : None
 --------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CWMICliLog
class CWMICliLog
{
public:
	// Construction
	CWMICliLog();
	
	// Destruction
	~CWMICliLog();
	
	// Restrict Assignment
	CWMICliLog& operator=(CWMICliLog& rWmiCliLog);
	
// Attributes
private:
	//the log file 
	_TCHAR* m_pszLogFile;

	//handle to the log file
	HANDLE  m_hFile;
	
	//status of whether the file has to created or not
	BOOL	m_bCreate;

// Operations
private:
	//Creates the Log File
	void CreateLogFile();

public:
	//write in to the log file
	void WriteToLog(LPSTR pszInput);
	
	//sets the Log File Path
	void SetLogFilePath(_TCHAR*);

	//Close the Log File
	void CloseLogFile();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\wmicmdln.cpp ===
/***************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: WMICommandLine.cpp 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This class encapsulates the functionality needed
							  for synchronization the funtionality of three 
							  functional components identified for the 
							  wmic.exe.Object of this class is created in
							  the main program and used to handle 
							  functionality of Parsing Engine, Execution 
							  Engine,and Format Engine thorough class members.
Global Functions			: CompareTokens(_TCHAR* pszTok1, _TCHAR* pszTok2)
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 11th-April-2001	  	
*****************************************************************************/ 
// WmiCmdLn.cpp : implementation file
#include "Precomp.h"
#include "CommandSwitches.h"
#include "GlobalSwitches.h"
#include "HelpInfo.h"
#include "ErrorLog.h"
#include "ParsedInfo.h"
#include "CmdTokenizer.h"
#include "CmdAlias.h"
#include "ParserEngine.h"
#include "ExecEngine.h"
#include "ErrorInfo.h"
#include "WmiCliXMLLog.h"
#include "FormatEngine.h"
#include "wmicmdln.h"
#include "conio.h"

/////////////////////////////////////////////////////////////////////////////
// CWMICommandLine
/*------------------------------------------------------------------------
   Name				 :CWMICommandLine
   Synopsis	         :This function initializes the member variables when
                      an object of the class type is instantiated
   Type	             :Constructor 
   Input parameters   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CWMICommandLine::CWMICommandLine()
{
	m_uErrLevel		= 0;
	m_pIWbemLocator = NULL;
	m_hKey			= NULL;
	m_bBreakEvent	= FALSE;
	m_bAccCmd		= TRUE; //To come out of the program when registering mofs
	m_bDispRes		= TRUE;
	m_bInitWinSock	= FALSE;
	EmptyClipBoardBuffer();
}

/*------------------------------------------------------------------------
   Name				 :~CWMICommandLine
   Synopsis	         :This function uninitializes the member variables 
					  when an object of the class type goes out of scope.
   Type	             :Destructor
   Input parameters   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CWMICommandLine::~CWMICommandLine()
{
	SAFEIRELEASE(m_pIWbemLocator);
}

/*------------------------------------------------------------------------
   Name				 :Uninitialize
   Synopsis	         :This function uninitializes the member variables 
					  when the execution of a command string issued on the
					  command line is completed.It internally calls 
					  uninitialize for CParsedInfo,CExecEngine,ParserEngine
					  and CFormatEngine .
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :Uninitialize()
   Notes             :None
------------------------------------------------------------------------*/
void CWMICommandLine::Uninitialize()
{
	m_ParsedInfo.Uninitialize(TRUE);
	m_ExecEngine.Uninitialize(TRUE);
	m_ParserEngine.Uninitialize(TRUE);
	m_FormatEngine.Uninitialize(TRUE);
	SAFEIRELEASE(m_pIWbemLocator);

	if (m_hKey != NULL)
	{
		RegCloseKey(m_hKey);
		m_hKey = NULL;
	}

	// Uninitialize windows socket interface.
	if ( m_bInitWinSock == TRUE )
		TermWinsock();
	
	CoUninitialize();
	m_bmKeyWordtoFileName.clear();
	SetScreenBuffer(m_nHeight, m_nWidth);
}

/*------------------------------------------------------------------------
   Name				 :Initialize
   Synopsis	         :This function returns initializes the COM library and
					  sets the process security, also it creates an instance
					  of the IWbemLocator object
   Type	             :Member Function
   Input parameters   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :Initialize()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CWMICommandLine::Initialize()
{
	HRESULT hr		= S_OK;
	BOOL	bRet	= TRUE;
	m_bBreakEvent	= FALSE;
	m_bAccCmd		= TRUE; //To come out of the program when registering mofs
	try
	{
		GetScreenBuffer(m_nHeight, m_nWidth);
		// Set the console scree buffer size.
		SetScreenBuffer();

		// Initialize the COM library
		hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
		ONFAILTHROWERROR(hr);

		
		// Initialize the security 
		hr = CoInitializeSecurity(NULL, -1, NULL, NULL, 
								   RPC_C_AUTHN_LEVEL_NONE,
								   RPC_C_IMP_LEVEL_IMPERSONATE,
								   NULL, EOAC_NONE, 0);

		ONFAILTHROWERROR(hr);

		// Create an instance of the IWbemLocator interface.
		hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
							  IID_IWbemLocator, (LPVOID *) &m_pIWbemLocator);
		ONFAILTHROWERROR(hr);

		// Enable the security privileges
		hr = ModifyPrivileges(TRUE);
		ONFAILTHROWERROR(hr);

		try
		{
			hr = RegisterMofs();
			ONFAILTHROWERROR(hr);

			// Initialize the Globalswitches and Commandswitches. 
			m_ParsedInfo.GetGlblSwitchesObject().Initialize();
			m_ParsedInfo.GetCmdSwitchesObject().Initialize();
		}
		catch(WMICLIINT nVal)
		{
			if (nVal == OUT_OF_MEMORY)
			{
				m_ParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(OUT_OF_MEMORY);
			}
	
			// If mofcomp error
			if (nVal == MOFCOMP_ERROR)
			{
				m_ParsedInfo.GetCmdSwitchesObject().
						SetErrataCode(MOFCOMP_ERROR);
			}
			bRet = FALSE;

		}
		catch(DWORD dwError)
		{
			// If Win32 Error
			DisplayString(IDS_E_REGMOF_FAILED, CP_OEMCP, 
							NULL, TRUE, TRUE);
			::SetLastError(dwError);
			DisplayWin32Error();
			m_ParsedInfo.GetCmdSwitchesObject().SetErrataCode(dwError);
			bRet = FALSE;
		}

		// Set the console control handler
		if (!SetConsoleCtrlHandler((PHANDLER_ROUTINE) CtrlHandler, TRUE))
		{
			m_ParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(SET_CONHNDLR_ROUTN_FAIL);
			bRet = FALSE;
		}
		GetFileNameMap();
   	}
	catch (_com_error& e)
	{
		SAFEIRELEASE(m_pIWbemLocator);
		m_ParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bRet = FALSE;
	}
	return bRet;
}

/*-------------------------------------------------------------------------
   Name				 :GetFormatObject
   Synopsis	         :This function returns a reference to the 
					  CFormatEngine Object
   Type	             :Member Function
   Input parameters   :None
   Output parameters :None
   Return Type       :CFormatEngine &
   Global Variables  :None
   Calling Syntax    :GetFormatObject()
   Notes             :None
-------------------------------------------------------------------------*/
CFormatEngine& CWMICommandLine::GetFormatObject()
{
	return m_FormatEngine;
}
	
/*-------------------------------------------------------------------------
   Name				 :GetParsedInfoObject
   Synopsis	         :This function returns a reference to the 
					  CParsedInfo Object
   Type	             :Member Function
   Input parameters   :None
   Output parameters :None
   Return Type       :CParsedInfo &
   Global Variables  :None
   Calling Syntax    :GetParsedInfoObject()
   Notes             :None
-------------------------------------------------------------------------*/
CParsedInfo& CWMICommandLine::GetParsedInfoObject()
{
	return m_ParsedInfo;
}
	
/*-------------------------------------------------------------------------
   Name				 :ProcessCommandAndDisplayResults
   Synopsis	         :It processes the given command string by giving the  
					  the command to CParsedInfo as input, initializing the 
					  CParserEngine,CExecEngine and CFormatEngine and 
					  synchronizes the operation between all the modules.
   Type	             :Member Function
   Input parameters   :
			pszBuffer - input command string
   Output parameters :None
   Return Type       :SESSIONRETCODE
   Global Variables  :None
   Calling Syntax    :ProcessCommandAndDisplayResults(pszBuffer)
   Notes             :None
-------------------------------------------------------------------------*/
SESSIONRETCODE CWMICommandLine::ProcessCommandAndDisplayResults(
												_TCHAR* pszBuffer)
{
	SESSIONRETCODE  ssnRetCode	= SESSION_SUCCESS;
	try
	{
		// Initialize the local variables.
		ULONG			ulRetTime	= 0;
		RETCODE			retCode		= PARSER_EXECCOMMAND;
		BOOL			bExecute	= FALSE;
		BOOL			bFirst		= TRUE;
		_bstr_t			bstrXML		= L"";		
		_bstr_t			bstrAggregateXML = L"";
		_bstr_t			bstrTempXML = L"";
		_bstr_t			bstrHeader	= L"";
		_bstr_t			bstrRequest;

		// Reset the erratacode
		m_ParsedInfo.GetCmdSwitchesObject().SetErrataCode(0);
		m_ParsedInfo.SetNewCycleStatus(FALSE);
		m_ParsedInfo.SetNewCommandStatus(TRUE);

		//Store the starttime and increment the commandsequence
		// number to one.
		if (!m_ParsedInfo.GetGlblSwitchesObject().SetStartTime())
		{
			m_ParsedInfo.GetCmdSwitchesObject().SetErrataCode(OUT_OF_MEMORY);
			ssnRetCode = SESSION_ERROR;
		}

		//Initialize the command input in CParsedInfo
		if(!m_ParsedInfo.GetCmdSwitchesObject().SetCommandInput(pszBuffer))
		{
			m_ParsedInfo.GetCmdSwitchesObject().SetErrataCode(OUT_OF_MEMORY);
			ssnRetCode = SESSION_ERROR;
		}
		
		if(ssnRetCode != SESSION_ERROR)
		{
			//Tokenize the command string as per the pre-defined delimiters
			if (m_ParserEngine.GetCmdTokenizer().TokenizeCommand(pszBuffer))
			{
				// Check whether the input indicates end of session.
				// i.e either QUIT or EXIT 
				if(!IsSessionEnd())
				{
					//Setting the IWbemLocator object .
					m_ParserEngine.SetLocatorObject(m_pIWbemLocator);

					// Initilaize ParsedInfo Object to release earlier messages
					m_ParsedInfo.Initialize();

					//Call CParserEngine ProcessTokens to process the 
					//tokenized commands .	
					retCode = m_ParserEngine.ProcessTokens(m_ParsedInfo);

					//Checking if the return code indicates Command execution
					if (retCode == PARSER_EXECCOMMAND)
					{
						// Check whether user should be prompted for password
						CheckForPassword();

						// Obtain the /EVERY interval value
						ulRetTime = m_ParsedInfo.GetCmdSwitchesObject()
									.GetRetrievalInterval();

						// Set the execute flag to TRUE.
						bExecute = TRUE;

						CHARVECTOR cvNodesList = 
								m_ParsedInfo.GetGlblSwitchesObject().
								GetNodesList();
						CHARVECTOR::iterator iNodesIterator;
						m_ParsedInfo.SetNewCommandStatus(TRUE);
						
						BOOL bXMLEncoding = FALSE;
						_TCHAR *pszVerbName = m_ParsedInfo.
												GetCmdSwitchesObject().
												GetVerbName(); 
						if(CompareTokens(pszVerbName, CLI_TOKEN_GET)
							|| CompareTokens(pszVerbName, CLI_TOKEN_LIST)
							|| CompareTokens(pszVerbName, CLI_TOKEN_ASSOC)
							|| pszVerbName == NULL)
						{
							bXMLEncoding = TRUE;
						}
						
						BOOL bBreak		= TRUE;
						BOOL bMsgFlag	= FALSE;
						LONG lLoopCount = 0;
						ULONG ulRepeatCount = 
							m_ParsedInfo.GetCmdSwitchesObject().
															 GetRepeatCount();
						BOOL			bFirstEvery = TRUE;
						OUTPUTSPEC		opsOutOpt	= 
							m_ParsedInfo.GetGlblSwitchesObject().
												GetOutputOrAppendOption(TRUE);
						while (TRUE)
						{
							m_ParsedInfo.SetNewCycleStatus(TRUE);
							if(bXMLEncoding)
							{
								bstrHeader = L"";
							}

							// Iterate thru the list of nodes
							for ( iNodesIterator = cvNodesList.begin(); 
								  iNodesIterator <
								  cvNodesList.end(); iNodesIterator++ )
							{
								if(bXMLEncoding)
								{
									bstrTempXML = L"";
								}
								
								// Reset the error and information code(s).
								m_ParsedInfo.GetCmdSwitchesObject().
										SetInformationCode(0);
								m_ParsedInfo.GetCmdSwitchesObject().
										SetErrataCode(0);
									
								if ( iNodesIterator == cvNodesList.begin() && 
									 cvNodesList.size() > 1 )
									 continue;

								if(!bXMLEncoding)
								{
									if ( cvNodesList.size() > 2 )
									{
										_bstr_t bstrNode;
										WMIFormatMessage(IDS_I_NODENAME_MSG, 1,
											bstrNode, (LPWSTR)*iNodesIterator);
										DisplayMessage((LPWSTR)bstrNode, 
														CP_OEMCP, 
														FALSE, FALSE);
									}
								}
								else
								{
									CHString		sBuffer;
									_bstr_t bstrRessultsNode = 
															(*iNodesIterator);
									FindAndReplaceEntityReferences(
															bstrRessultsNode);
									sBuffer.Format(L"<RESULTS NODE=\"%s\">", 
													(LPWSTR)bstrRessultsNode);
									bstrTempXML += _bstr_t(sBuffer);
								}

								// Setting the locator object .
								m_ExecEngine.SetLocatorObject(m_pIWbemLocator);

								m_ParsedInfo.GetGlblSwitchesObject().
													SetNode(*iNodesIterator);

								//Call ExecEngine ExecuteCommand to execute the
								// tokenized command
								if (m_ExecEngine.ExecuteCommand(m_ParsedInfo))
								{ 
									// Set the successflag to TRUE
									m_ParsedInfo.GetCmdSwitchesObject().
												SetSuccessFlag(TRUE);

									if(bXMLEncoding)
									{
										// Append the XML result set obtained 
										// to the aggregated output 
										if (m_ParsedInfo.GetCmdSwitchesObject().
														GetXMLResultSet())
										{
											bstrTempXML	+= _bstr_t(m_ParsedInfo.
														GetCmdSwitchesObject().
														GetXMLResultSet());
										}
																
										// Free the XML result set.
										m_ParsedInfo.GetCmdSwitchesObject().
													SetXMLResultSet(NULL);
									}
									else
									{
										bBreak = TRUE;
										if (!m_FormatEngine.
												DisplayResults(m_ParsedInfo))
										{
											ssnRetCode = SESSION_ERROR;
											SetSessionErrorLevel(ssnRetCode);
											break;
										}
										m_ParsedInfo.SetNewCommandStatus(FALSE);
										m_ParsedInfo.SetNewCycleStatus(FALSE);
									}
								}
								else
								{
									//Set the sucess flag to FALSE 
									m_ParsedInfo.GetCmdSwitchesObject().
														SetSuccessFlag(FALSE);
									ssnRetCode	= SESSION_ERROR;

									if(bXMLEncoding)
									{
										_bstr_t bstrNode, bstrError;
										UINT uErrorCode = 0;

										WMIFormatMessage(IDS_I_NODENAME_MSG, 1,
											bstrNode, (LPWSTR)*iNodesIterator);
										DisplayMessage((LPWSTR)bstrNode, 
														CP_OEMCP, 
														TRUE, FALSE);
								
										// Retrieve the error code
										uErrorCode = m_ParsedInfo.
													GetCmdSwitchesObject().
													 GetErrataCode() ;
										if ( uErrorCode != 0 )
										{
											_bstr_t	bstrTemp;
											CHString		sBuffer;
											WMIFormatMessage(uErrorCode, 
													0, bstrTemp, NULL);

											sBuffer.Format(L"<ERROR><DESCRIPTION>"
															 L"%s</DESCRIPTION>"
															 L"</ERROR>",
															(LPWSTR)(bstrTemp));
											bstrError = _bstr_t(sBuffer);
											// Write the error to stderr
											DisplayMessage((LPWSTR)bstrTemp, 
														CP_OEMCP, TRUE, FALSE);
										}
										else
										{
											m_FormatEngine.
												GetErrorInfoObject().
													GetErrorFragment(
													m_ParsedInfo.
													GetCmdSwitchesObject().
													GetCOMError()->Error(), 
													bstrError);

											// Write the error to stderr
											m_FormatEngine.
												DisplayCOMError(m_ParsedInfo,
												TRUE);
										}
										bstrTempXML += bstrError;
									}
									else
									{
										bBreak = TRUE;
										if (!m_FormatEngine.
											DisplayResults(m_ParsedInfo))
										{
											// Set the session error level 
											SetSessionErrorLevel(ssnRetCode);
											break;
										}
										m_ParsedInfo.SetNewCommandStatus(FALSE);
									}
									
									// Set the session error level 
									SetSessionErrorLevel(ssnRetCode);
								}

								if(bXMLEncoding)
									bstrTempXML += L"</RESULTS>";
								
								if(bXMLEncoding && bFirst)
								{
									bFirst = FALSE;
									FrameXMLHeader(bstrHeader, lLoopCount);
									
									if(lLoopCount == 0)
										FrameRequestNode(bstrRequest);
									bstrXML += bstrHeader;
									bstrXML += bstrRequest;
								}

								m_ExecEngine.Uninitialize();
								m_FormatEngine.Uninitialize();
								m_ParsedInfo.GetCmdSwitchesObject().
												SetCredentialsFlag(FALSE);
								m_ParsedInfo.GetCmdSwitchesObject().
												FreeCOMError();
								m_ParsedInfo.GetCmdSwitchesObject().
												SetSuccessFlag(TRUE);

								if(bXMLEncoding)
								{
									if(!m_ParsedInfo.GetGlblSwitchesObject().
												GetAggregateFlag())
									{
										_bstr_t bstrNodeResult = L"";
										bstrNodeResult += bstrXML;
										bstrNodeResult += bstrTempXML;
										bstrNodeResult += L"</COMMAND>";
										m_ParsedInfo.GetCmdSwitchesObject().
												SetXMLResultSet((LPWSTR) 
													bstrNodeResult);

										if (!m_FormatEngine.
												DisplayResults(m_ParsedInfo))
										{
											bBreak = TRUE;
											ssnRetCode = SESSION_ERROR;
											SetSessionErrorLevel(ssnRetCode);
											m_FormatEngine.Uninitialize();
											break;
										}
										m_ParsedInfo.SetNewCommandStatus(FALSE);
										m_ParsedInfo.SetNewCycleStatus(FALSE);
										m_FormatEngine.Uninitialize();
									}
									else
									{
										bstrAggregateXML += bstrTempXML;
									}
								}

								if (_kbhit()) 
								{
									_getch();
									bBreak = TRUE;
									break;
								}

								if (GetBreakEvent() == TRUE)
								{
									bBreak = TRUE;
									break;
								}
							}
							
							if(m_ParsedInfo.GetGlblSwitchesObject().
									GetAggregateFlag() && bXMLEncoding)
							{
								bstrXML += bstrAggregateXML;
								bstrXML += L"</COMMAND>";
								bFirst	= TRUE;
								m_ParsedInfo.GetCmdSwitchesObject().
										SetXMLResultSet((LPWSTR) bstrXML);
								if (!m_FormatEngine.
										DisplayResults(m_ParsedInfo))
								{
									bBreak = TRUE;
									ssnRetCode = SESSION_ERROR;
									SetSessionErrorLevel(ssnRetCode);
									m_FormatEngine.Uninitialize();
									break;
								}
								m_FormatEngine.Uninitialize();
								bstrAggregateXML = L"";
								bstrXML = L"";
								m_ParsedInfo.SetNewCommandStatus(FALSE);
							}

							//Checking the Sucess flag and the retrievel time .
							if (m_ParsedInfo.GetCmdSwitchesObject().
								GetSuccessFlag() == TRUE && 
								m_ParsedInfo.GetCmdSwitchesObject().
								GetEverySwitchFlag() == TRUE )
							{
								bBreak = FALSE;
								lLoopCount++;

								if (!IsRedirection() && 
											GetBreakEvent() == FALSE)
								{
									if ( opsOutOpt == STDOUT || 
										 bFirstEvery == TRUE)
									{
										DisplayString(IDS_I_HAKTBTC, CP_OEMCP, 
													NULL, TRUE, TRUE);
										bMsgFlag = TRUE;
										bFirstEvery = FALSE;
									}
								}
								
								if ( ulRepeatCount != 0 )
								{
									if ( lLoopCount >= ulRepeatCount )
									{
										if (bMsgFlag && !IsRedirection())
											EraseMessage(IDS_I_HAKTBTC_ERASE);
										bBreak = TRUE;
									}
								}

								//No action till time out is no over 
								// Or no key is hit.
								if(!bBreak)
								{
									SleepTillTimeoutOrKBhit(ulRetTime * 1000);
								
									if (bMsgFlag && !IsRedirection())
									{
										if ( opsOutOpt == STDOUT )
										{
											bMsgFlag = FALSE;
											EraseMessage(IDS_I_HAKTBTC_ERASE);
										}
									}
								}

								if (_kbhit()) 
								{
									_getch();
									if (bMsgFlag && !IsRedirection())
										EraseMessage(IDS_I_HAKTBTC_ERASE);
									bBreak = TRUE;
								}

								if (GetBreakEvent() == TRUE)
									bBreak = TRUE;
							}
							else
								bBreak = TRUE;

							if (bBreak)
								break;
						}
					}
					else if ((retCode == PARSER_ERRMSG) || 
							(retCode == PARSER_ERROR))
					{
						// Set the success flag to FALSE
						m_ParsedInfo.GetCmdSwitchesObject().
										SetSuccessFlag(FALSE);
						ssnRetCode	= SESSION_ERROR;

						// Display the error message 
						if (!m_FormatEngine.DisplayResults(m_ParsedInfo))
							ssnRetCode = SESSION_ERROR;
					}
					else if (retCode == PARSER_OUTOFMEMORY)
					{
						ssnRetCode = SESSION_ERROR;
					}
					else 
					{
						CheckForPassword();

						// Set the success flag to TRUE
						m_ParsedInfo.GetCmdSwitchesObject().
									SetSuccessFlag(TRUE);
						ssnRetCode	= SESSION_SUCCESS;

						// Display the information
						if (!m_FormatEngine.DisplayResults(m_ParsedInfo))
							ssnRetCode = SESSION_ERROR;
					}
				}
				else
				{
					ssnRetCode = SESSION_QUIT;
				}
			}
			else
			{
				m_ParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(OUT_OF_MEMORY);
				ssnRetCode = SESSION_ERROR;
			}
		}

		// Set the session error level to be returned.
		if (!bExecute)
			SetSessionErrorLevel(ssnRetCode);		
	}
	catch(_com_error& e)
	{
		m_ParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		m_FormatEngine.DisplayResults(m_ParsedInfo);
		ssnRetCode = SESSION_ERROR;
		SetSessionErrorLevel(ssnRetCode);
	}
	catch(CHeap_Exception)
	{
		_com_error e(WBEM_E_OUT_OF_MEMORY);
		m_ParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		m_FormatEngine.DisplayResults(m_ParsedInfo);
		ssnRetCode = SESSION_ERROR;
		g_wmiCmd.SetSessionErrorLevel(ssnRetCode);
	}
	catch(DWORD dwError)
	{
		::SetLastError(dwError);
		DisplayWin32Error();
		::SetLastError(dwError);
		ssnRetCode = SESSION_ERROR;
		g_wmiCmd.SetSessionErrorLevel(ssnRetCode);
	}
	catch(WMICLIINT nVal)
	{
		if (nVal == OUT_OF_MEMORY)
		{
			GetParsedInfoObject().GetCmdSwitchesObject().
						SetErrataCode(OUT_OF_MEMORY);
			m_FormatEngine.DisplayResults(m_ParsedInfo);
			ssnRetCode = SESSION_ERROR;
			SetSessionErrorLevel(ssnRetCode);
		}
	}	
	catch(...)
	{	
		ssnRetCode = SESSION_ERROR;
		GetParsedInfoObject().GetCmdSwitchesObject().
						SetErrataCode(UNKNOWN_ERROR);
		SetSessionErrorLevel(ssnRetCode);
		DisplayString(IDS_E_WMIC_UNKNOWN_ERROR, CP_OEMCP, 
							NULL, TRUE, TRUE);
	}

	if(ssnRetCode != SESSION_QUIT)
	{
		//sets the help flag
		m_ParsedInfo.GetGlblSwitchesObject().SetHelpFlag(FALSE);
		m_ParsedInfo.GetGlblSwitchesObject().SetAskForPassFlag(FALSE);
		
		//Call Uninitialize on Parse Info 
		m_ParsedInfo.Uninitialize(FALSE);
		
		//Call Uninitialize on Execution Engine
		m_ExecEngine.Uninitialize();

		//Call Uninitialize on Format Engine
		m_FormatEngine.Uninitialize();
		
		//Call Uninitialize Parser Engine
		m_ParserEngine.Uninitialize();
	}
	m_ParsedInfo.SetNewCommandStatus(FALSE);
	
	return ssnRetCode;
}

/*-------------------------------------------------------------------------
   Name				 :PollForKBhit
   Synopsis	         :Polls for keyboard input
   Type	             :Member Function (Thread procedure)
   Input parameters   :LPVOID lpParam
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :PollForKBhit(lpParam)
   Notes             :None
-------------------------------------------------------------------------*/
DWORD WINAPI CWMICommandLine::PollForKBhit(LPVOID lpParam)
{
	HANDLE hEvent = NULL;
	hEvent = *((HANDLE*) lpParam );
	//Checks the console for keyboard input
	while (1 )
	{
		if ( _kbhit() )
			break;
		else if ( WaitForSingleObject(hEvent, 500) != WAIT_TIMEOUT )
			break;
	}
	return(0);
}

/*-------------------------------------------------------------------------
   Name				 :SleepTillTimeoutOrKBhit
   Synopsis	         :It causes the process to enter a wait state  
				      by WaitForSingleObject .
					  It creates a thread and executed PollForKBhit.					  
   Type	             :Member Function
   Input parameters   :
			dwMilliSeconds - time-out interval in milliseconds				
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SleepTillTimeoutOrKBhit( dwMilliSeconds)
   Notes             :None
-------------------------------------------------------------------------*/
void CWMICommandLine::SleepTillTimeoutOrKBhit(DWORD dwMilliSeconds)
{
	DWORD dwThreadId = 0;
	HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	//Create thread and execute PollForKBhit.					  	
	HANDLE hPollForKBhit = CreateThread(0, 0, 
				(LPTHREAD_START_ROUTINE)PollForKBhit, &hEvent, 0, &dwThreadId);
		
	//waits for the hPollForKBhit state or the time-out interval to elapse.
	
	DWORD dwWait = WaitForSingleObject(hPollForKBhit, dwMilliSeconds); 
	if ( dwWait == WAIT_TIMEOUT )
	{
		SetEvent( hEvent );
		WaitForSingleObject(hPollForKBhit, INFINITE); 
	}
	CloseHandle(hEvent);
	CloseHandle(hPollForKBhit);
}

/*-------------------------------------------------------------------------
   Name				 :IsSessionEnd
   Synopsis	         :It checks whether the keyed-in input indicates end of
					  the session. i.e "quit" has been specified as the 1st
					  token.
   Type	             :Member Function
   Input parameters   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :IsSessionEnd()
   Notes             :None
-------------------------------------------------------------------------*/
BOOL CWMICommandLine::IsSessionEnd()
{
	// Obtain the token vector.
	CHARVECTOR cvTokens = m_ParserEngine.GetCmdTokenizer().GetTokenVector();
	//the iterator to span throuh the vector variable 
	CHARVECTOR::iterator theIterator;
	BOOL bRet=FALSE;
	// Check for the presence of tokens. Absence of tokens indicates
	// no command string is fed as input.
	if (cvTokens.size())
	{
		// Obtain the pointer to the beginning of the token vector.
	    theIterator = cvTokens.begin(); 

		// Check for the presence of the keyword 'quit'
		if (CompareTokens(*theIterator, CLI_TOKEN_QUIT) 
			|| CompareTokens(*theIterator, CLI_TOKEN_EXIT))
		{
			bRet=TRUE;
		}
	}
	return bRet;
}

/*-------------------------------------------------------------------------
   Name				 :SetSessionErrorLevel
   Synopsis	         :Set the session error level value
   Type	             :Member Function
   Input parameters  :
		ssnRetCode	 - session return code
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetSessionErrorLevel()
-------------------------------------------------------------------------*/
//Set the session error value
void CWMICommandLine::SetSessionErrorLevel(SESSIONRETCODE ssnRetCode)
{
	try
	{
		if (ssnRetCode == SESSION_ERROR)
		{
			// If the COM error is not NULL , then display the error
			if (m_ParsedInfo.GetCmdSwitchesObject().GetCOMError())
			{
				// Getting the _com_error data.
				_com_error*	pComError = m_ParsedInfo.GetCmdSwitchesObject().
								GetCOMError();
				m_uErrLevel = pComError->Error();
			}
	
			CHString	chsMsg(_T("command: "));
			chsMsg += m_ParsedInfo.GetCmdSwitchesObject().GetCommandInput();
			DWORD dwThreadId = GetCurrentThreadId();
			
			if (m_ParsedInfo.GetCmdSwitchesObject().GetErrataCode())
			{
				m_uErrLevel = m_ParsedInfo.GetCmdSwitchesObject().GetErrataCode();
				if (m_uErrLevel == OUT_OF_MEMORY)
				{
					DisplayString(IDS_E_MEMALLOCFAILED, CP_OEMCP, 
								NULL, TRUE, TRUE);
				}
				if (m_uErrLevel == SET_CONHNDLR_ROUTN_FAIL)
				{
					DisplayString(IDS_E_CONCTRL_HNDLRSET, CP_OEMCP, 
								NULL, TRUE, TRUE);
				}
				if ( m_uErrLevel == OUT_OF_MEMORY || 
					 m_uErrLevel == SET_CONHNDLR_ROUTN_FAIL )
				{
					if (m_ParsedInfo.GetErrorLogObject().GetErrLogOption())	
					{
						chsMsg += _T(", Utility returned error ID.");
						// explicit error -1 to specify errata code. 
						WMITRACEORERRORLOG(-1, __LINE__, __FILE__, 
									(LPCWSTR)chsMsg, 
									dwThreadId, m_ParsedInfo, FALSE, 
									m_ParsedInfo.GetCmdSwitchesObject()
												.GetErrataCode());
					}
				}
					 
				if ( m_uErrLevel == ::GetLastError() )
				{
					if (m_ParsedInfo.GetErrorLogObject().GetErrLogOption())	
					{
						WMITRACEORERRORLOG(-1,	__LINE__, __FILE__, 
											_T("Win32Error"), dwThreadId, 
											m_ParsedInfo, FALSE,
											m_uErrLevel);
					}
				}

				if (m_uErrLevel == MOFCOMP_ERROR)
				{
					if (m_ParsedInfo.GetErrorLogObject().GetErrLogOption())	
					{
						WMITRACEORERRORLOG(-1,	__LINE__, __FILE__, 
										_T("MOF Compilation Error (the errorlevel "
										   L"is utility specific)"), dwThreadId,
										m_ParsedInfo, FALSE, m_uErrLevel);
					}
				}
			}
		}
		else
		{
			// Set the error level to 0
			m_uErrLevel = 0; 
		}
	}
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}

/*-------------------------------------------------------------------------
   Name				 :GetSessionErrorLevel
   Synopsis	         :Get the session error value
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :WMICLIUINT
   Global Variables  :None
   Calling Syntax    :GetSessionErrorLevel()
-------------------------------------------------------------------------*/
WMICLIUINT CWMICommandLine::GetSessionErrorLevel()
{
	return m_uErrLevel;
}

/*-------------------------------------------------------------------------
   Name				 :CheckForPassword
   Synopsis	         :Prompt for user password, in case user is specified 
					  without password.
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :CheckForPassword()
-------------------------------------------------------------------------*/
void CWMICommandLine::CheckForPassword()
{
	if ( m_ParsedInfo.GetGlblSwitchesObject().GetAskForPassFlag() == TRUE &&
		 m_ParsedInfo.GetGlblSwitchesObject().GetUser() != NULL )
	{
		_TCHAR szPassword[BUFFER64] = NULL_STRING;
		DisplayString(IDS_I_PWD_PROMPT, CP_OEMCP, NULL, TRUE);
		AcceptPassword(szPassword);
		m_ParsedInfo.GetGlblSwitchesObject().SetPassword(
												szPassword);
	}
}

/*-------------------------------------------------------------------------
   Name				 :RegisterMofs
   Synopsis	         :Register the mof file(s) if not registered earlier.
   Type	             :Member Function
   Input parameters  :None
   Output parameters :
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :RegisterMofs()
-------------------------------------------------------------------------*/
HRESULT CWMICommandLine::RegisterMofs() 
{
	HRESULT						hr						= S_OK;
	IMofCompiler				*pIMofCompiler			= NULL;
	BOOL						bCompile				= FALSE;
	BOOL						bFirst					= FALSE;
	DWORD						dwBufSize				= BUFFER32;
	_TCHAR						pszLocale[BUFFER32]		= NULL_STRING;
	_TCHAR						szKeyValue[BUFFER32]	= NULL_STRING;
	_TCHAR*						pszBuffer				= NULL;
	WMICLIINT					nError					= 0;
	HRESULT						hRes					= S_OK;
	LONG						lRetVal					= 0;
	try
	{
		_bstr_t bstrMofPath, bstrNS;

		// Check|Create the registry entry.
		bFirst = IsFirstTime();

		// Check whether the "mofcompstatus" key value is 0
		if (!bFirst)
		{
			// Query the "mofcompstatus" mode
			lRetVal = RegQueryValueEx(m_hKey, L"mofcompstatus", NULL, NULL,
			                 (LPBYTE)szKeyValue, &dwBufSize);
			if (lRetVal == ERROR_SUCCESS)

			{
				// If the value is not "1", then set the bFirst to TRUE
				if (!CompareTokens(szKeyValue, CLI_TOKEN_ONE))
					bFirst = TRUE;
			}
			else
			{
				::SetLastError(lRetVal);
				throw (::GetLastError());
			}
		}

		// If the WMIC is being used for the first time.
		if (bFirst)
			DisplayString(IDS_I_WMIC_INST, CP_OEMCP);

		// Create an instance of the IMofCompiler interface.
		hr = CoCreateInstance(CLSID_MofCompiler,	
								 NULL,				
								 CLSCTX_INPROC_SERVER,
								 IID_IMofCompiler,
								 (LPVOID *) &pIMofCompiler);
		ONFAILTHROWERROR(hr);

		UINT nSize  = 0;
		pszBuffer = new _TCHAR [MAX_PATH];

		if(pszBuffer == NULL)
			throw OUT_OF_MEMORY;

		// Obtain the system directory path
		nSize = GetSystemDirectory(pszBuffer, MAX_PATH);

		if(nSize)
		{
			if (nSize > MAX_PATH)
			{
				SAFEDELETE(pszBuffer);
				pszBuffer =	new _TCHAR [nSize + 1];
				if(pszBuffer == NULL)
					throw OUT_OF_MEMORY;
			}

			if (!GetSystemDirectory(pszBuffer, nSize))
				throw (::GetLastError());
		}
		else
		{
			throw(::GetLastError());
		}
		
		/* Frame the location of the mof file(s) %systemdir%\\wbem\\ */
		bstrMofPath = _bstr_t(pszBuffer) + _bstr_t(L"\\wbem\\");
		SAFEDELETE(pszBuffer);

		// Frame the namespace
		bstrNS = L"\\\\.\\root\\cli";

		// If first time (or) the namespace "root\cli" is not
		// available then mofcomp cli.mof.
		if (bFirst || !IsNSAvailable(bstrNS))
		{
			bCompile = TRUE;
			// Register the Cli.mof
			hr = CompileMOFFile(pIMofCompiler, 
								bstrMofPath + _bstr_t(L"Cli.mof"),
								nError);
			ONFAILTHROWERROR(hr);
			if (nError)
				throw MOFCOMP_ERROR;

		}
		
		// Frame the localized namespace
		_stprintf(pszLocale, _T("ms_%x"),  GetSystemDefaultLangID());
		bstrNS = _bstr_t(L"\\\\.\\root\\cli\\") + _bstr_t(pszLocale);

		// If first time (or) the namespace "root\cli\ms_xxx" is not
		// available then mofcomp cliegaliases.mfl.
		if (bFirst || !IsNSAvailable(bstrNS))
		{
			bCompile = TRUE;
			// Register the CliEgAliases.mfl
			hr = CompileMOFFile(pIMofCompiler, 
								bstrMofPath + _bstr_t(L"CliEgAliases.mfl"),
								nError);
			ONFAILTHROWERROR(hr);
			if (nError)
				throw MOFCOMP_ERROR;
		}
	
		// If compiled either cli.mof (or) cliegaliases.mfl
		if (bCompile == TRUE)
		{
			// Register the CliEgAliases.mof
			hr = CompileMOFFile(pIMofCompiler, 
								bstrMofPath + _bstr_t(L"CliEgAliases.mof"),
								nError);
			ONFAILTHROWERROR(hr);
			if (nError)
				throw MOFCOMP_ERROR;
		}
		SAFEIRELEASE(pIMofCompiler);

		// Set the default value.
		lRetVal = RegSetValueEx(m_hKey, L"mofcompstatus", 0, 
							REG_SZ, (LPBYTE) CLI_TOKEN_ONE,
							lstrlen(CLI_TOKEN_ONE) + 1);
							
		if (lRetVal != ERROR_SUCCESS)
		{
			::SetLastError(lRetVal);
			// failed to set the default value
			throw (::GetLastError());
		}

		if (m_hKey != NULL)
		{
			RegCloseKey(m_hKey);
			m_hKey = NULL;
		}
	}
	catch(WMICLIINT nErr)
	{
		SAFEIRELEASE(pIMofCompiler);
		SAFEDELETE(pszBuffer);
		throw nErr;
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIMofCompiler);
		SAFEDELETE(pszBuffer);
		hr = e.Error();
	}
	catch (DWORD dwError)
	{
		SAFEIRELEASE(pIMofCompiler);
		SAFEDELETE(pszBuffer);
		throw dwError;
	}
	if (bFirst)
		EraseMessage(IDS_I_WMIC_INST_ERASE);
	return hr;
}

/*-------------------------------------------------------------------------
   Name				 :IsFirstTime
   Synopsis	         :Checks for the availability of the registry location 
					 "HKLM\SOFTWARE\Microsoft\Wbem\WMIC", creates one if does
					  not exist. 
   Type	             :Member Function
   Input parameters  :None
   Output parameters :
   Return Type       :
		BOOL: TRUE	- registry entry created 
			  FALSE - registry entry already available.
   Global Variables  :None
   Calling Syntax    :IsFirstTime()
-------------------------------------------------------------------------*/
BOOL CWMICommandLine::IsFirstTime()
{
	BOOL	bFirst					= FALSE;
	DWORD	dwDisposition			= 0;
	TCHAR	szKeyValue[BUFFER32]	= NULL_STRING;
	LONG	lRetVal					= 0;
	
	// Open|Create the registry key
    lRetVal = RegCreateKeyEx(HKEY_LOCAL_MACHINE, 
						L"SOFTWARE\\\\Microsoft\\\\Wbem\\\\WMIC", 
						0, NULL_STRING, REG_OPTION_NON_VOLATILE,
						KEY_ALL_ACCESS, NULL, &m_hKey, &dwDisposition);

	if (lRetVal == ERROR_SUCCESS)
	{
		// If the registry entry is not available
		if (dwDisposition == REG_CREATED_NEW_KEY)
		{
			bFirst = TRUE;
			lstrcpy(szKeyValue, _T("0"));
			// Set the default value i.e '0'.
			lRetVal = RegSetValueEx(m_hKey, L"mofcompstatus", 0, 
								REG_SZ, (LPBYTE) szKeyValue,
								lstrlen(szKeyValue) + 1);
			
			if (lRetVal != ERROR_SUCCESS)
			{
				// failed to set the default value
				::SetLastError(lRetVal);
				throw (::GetLastError());
			}
		}
	}
	else
	{
		::SetLastError(lRetVal);
		throw (::GetLastError());
	}
	return bFirst;
}

/*-------------------------------------------------------------------------
   Name				 :IsNSAvailable
   Synopsis	         :Checks whether the namespace specified exists
   Type	             :Member Function
   Input parameters  :
			bstrNS	- namespace
   Output parameters :None
   Return Type       :
		BOOL: TRUE	- namespace exists
			  FALSE - namespace does not exist
   Global Variables  :None
   Calling Syntax    :IsNSAvailable()
-------------------------------------------------------------------------*/
BOOL CWMICommandLine::IsNSAvailable(const _bstr_t& bstrNS)
{
	HRESULT			hr			= S_OK;
	IWbemServices	*pISvc		= NULL;
	BOOL			bNSExist	= TRUE;
	hr = m_pIWbemLocator->ConnectServer(bstrNS, NULL, NULL, NULL, 0,
							NULL, NULL, &pISvc);

	// If the namespace does not exist.
	if (FAILED(hr) && (hr == WBEM_E_INVALID_PARAMETER 
					|| hr == WBEM_E_INVALID_NAMESPACE))
	{
		bNSExist = FALSE;
	}
	SAFEIRELEASE(pISvc);
	return bNSExist;
}

/*-------------------------------------------------------------------------
   Name				 :CompileMOFFile
   Synopsis	         :mofcomp's the file specified as input parameter thru
					  bstrFile
   Type	             :Member Function
   Input parameters  :
			pIMofComp	- IMofCompiler interface pointer.
			bstrFile	- filename.
			nError		- parsing phase error.
   Output parameters :None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :CompileMOFFile()
-------------------------------------------------------------------------*/
HRESULT CWMICommandLine::CompileMOFFile(IMofCompiler* pIMofComp, 
										const _bstr_t& bstrFile,
										WMICLIINT& nError)
{
	HRESULT						hr			= S_OK;
	WBEM_COMPILE_STATUS_INFO	wcsInfo;
	
	try
	{
		// Register the moffile
		hr = pIMofComp->CompileFile(bstrFile, NULL, NULL, NULL, 
									NULL, 0, 0,	0, &wcsInfo);

		// If the compilation is not successful
		if (hr == WBEM_S_FALSE)
		{
			_TCHAR	szPhaseErr[BUFFER32] = NULL_STRING,
					szComplErr[BUFFER32] = NULL_STRING;
			_bstr_t	bstrMsg;

			_stprintf(szPhaseErr, _T("%d"), wcsInfo.lPhaseError);
			_stprintf(szComplErr, _T("0x%x"), wcsInfo.hRes);
			WMIFormatMessage(IDS_I_MOF_PARSE_ERROR, 3, bstrMsg, 
							(WCHAR*) bstrFile, szPhaseErr, 
							szComplErr);
			DisplayMessage((WCHAR*) bstrMsg, CP_OEMCP, TRUE, FALSE);
			nError	= wcsInfo.lPhaseError;
		}
	}
	catch(_com_error& e)
	{
		hr = e.Error();		
	}
	return hr;
}

/*-------------------------------------------------------------------------
   Name				 :SetBreakEvent
   Synopsis	         :This function sets the CTRC+C (break) event flag
   Type	             :Member Function
   Input parameters  :
				bFlag - TRUE or FALSE
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetBreakEvent()
-------------------------------------------------------------------------*/
void CWMICommandLine::SetBreakEvent(BOOL bFlag)
{
	m_bBreakEvent = bFlag;
}

/*-------------------------------------------------------------------------
   Name				 :GetBreakEvent
   Synopsis	         :This function returns the break event status.
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetBreakEvent()
-------------------------------------------------------------------------*/
BOOL CWMICommandLine::GetBreakEvent() 
{	
	return m_bBreakEvent;
}

/*-------------------------------------------------------------------------
   Name				 :SetAcceptCommand
   Synopsis	         :This function sets the accept command flag 
   Type	             :Member Function
   Input parameters  :
				bFlag - TRUE or FALSE
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetAcceptComamnd()
-------------------------------------------------------------------------*/
void CWMICommandLine::SetAcceptCommand(BOOL bFlag)
{
	m_bAccCmd = bFlag;
}

/*-------------------------------------------------------------------------
   Name				 :GetAcceptCommand
   Synopsis	         :This function returns accept command flag status.
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetAcceptCommand()
-------------------------------------------------------------------------*/
BOOL CWMICommandLine::GetAcceptCommand()
{
	return m_bAccCmd;
}

/*-------------------------------------------------------------------------
   Name				 :GetDisplayResultsFlag
   Synopsis	         :This function returns Display Results flag status.
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetDisplayResultsFlag()
-------------------------------------------------------------------------*/
BOOL CWMICommandLine::GetDisplayResultsFlag()
{
	return m_bDispRes;
}

/*-------------------------------------------------------------------------
   Name				 :SetDisplayResultsFlag
   Synopsis	         :This function sets the display results flag status
   Type	             :Member Function
   Input parameters  :
				bFlag - TRUE or FALSE
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetDisplayResultsFlag()
-------------------------------------------------------------------------*/
void CWMICommandLine::SetDisplayResultsFlag(BOOL bFlag)
{
	m_bDispRes = bFlag;
}

/*-------------------------------------------------------------------------
   Name				 :SetInitWinSock
   Synopsis	         :This function sets the windows socket library 
					  initialization status
   Type	             :Member Function
   Input parameters  :
				bFlag - TRUE or FALSE
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetInitWinSock()
-------------------------------------------------------------------------*/
void CWMICommandLine::SetInitWinSock(BOOL bFlag)
{
	m_bInitWinSock = bFlag;
}

/*-------------------------------------------------------------------------
   Name				 :GetInitWinSock
   Synopsis	         :This function returns the socket library initialization
					  status
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetInitWinSock()
-------------------------------------------------------------------------*/
BOOL CWMICommandLine::GetInitWinSock()
{
	return m_bInitWinSock;
}

/*-------------------------------------------------------------------------
   Name				 :AddToClipBoardBuffer
   Synopsis	         :This function buffers the data to be added to the clip
					  board.
   Type	             :Member Function
   Input parameters  :pszOutput - string to be buffered
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :AddToClipBoardBuffer(pszOutput)
-------------------------------------------------------------------------*/
void CWMICommandLine::AddToClipBoardBuffer(LPSTR pszOutput)
{
	try
	{
		if ( pszOutput != NULL )
		{
			if ( m_bstrClipBoardBuffer == _bstr_t("") )
				m_bstrClipBoardBuffer = _bstr_t(pszOutput);
			else
				m_bstrClipBoardBuffer += _bstr_t(pszOutput);
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*-------------------------------------------------------------------------
   Name				 :GetClipBoardBuffer
   Synopsis	         :This function return the buffered data for the
					  clipboard
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :_bstr_t&
   Global Variables  :None
   Calling Syntax    :GetClipBoardBuffer()
-------------------------------------------------------------------------*/
_bstr_t& CWMICommandLine::GetClipBoardBuffer()
{
	return m_bstrClipBoardBuffer;
}

// Clear Clip Board Buffer.
/*-------------------------------------------------------------------------
   Name				 :EmptyClipBoardBuffer
   Synopsis	         :This function clears the clipboard buffer.
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :EmptyClipBoardBuffer()
-------------------------------------------------------------------------*/
void CWMICommandLine::EmptyClipBoardBuffer()
{
	try
	{
		m_bstrClipBoardBuffer = _bstr_t("");
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*-------------------------------------------------------------------------
   Name				 :ReadXMLOrBatchFile
   Synopsis	         :Check if the file is xml or batch file. If it is batch file
						then parse it, get commands and write the commands into
						batch file.
   Type	             :Member Function
   Input parameters  :
			hInFile  - Handle to XML or Batch file
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ReadXMLOrBatchFile()
-------------------------------------------------------------------------*/
BOOL CWMICommandLine::ReadXMLOrBatchFile(HANDLE hInFile)
{
	// Check if the file is xml, if yes store its contents in buffer, parse
	// it and then store parsed info in another file, if not then copy all 
	// contents in another file as it is.
	HRESULT				hr					= 0;
	BOOL				bRetValue			= TRUE;
	HANDLE				hOutFile			= NULL;
	IXMLDOMDocument		*pIXMLDOMDocument	= NULL;
	IXMLDOMElement		*pIXMLDOMElement	= NULL;
	IXMLDOMNode			*pIXMLDOMNode		= NULL;
	IXMLDOMNodeList		*pIXMLDOMNodeList	= NULL;
	BSTR				bstrItemText		= NULL;
	DWORD				dwThreadId			= GetCurrentThreadId();

	// Get the TRACE status 
	BOOL bTrace = m_ParsedInfo.GetGlblSwitchesObject().GetTraceStatus();

	// Get the Logging mode (VERBOSE | ERRORONLY | NOLOGGING)
	ERRLOGOPT eloErrLogOpt = m_ParsedInfo.GetErrorLogObject().GetErrLogOption();

	try
	{
		//Read all input bytes 
		DWORD dwNumberOfBytes = 0;
		_bstr_t bstrInput;
		_TCHAR* pszBuffer = NULL;
		while(TRUE)
		{
			pszBuffer = new _TCHAR[MAX_BUFFER];
			if (pszBuffer)
			{
				TCHAR *pBuf = NULL;
				pBuf = _fgetts(pszBuffer, MAX_BUFFER-1, stdin);
			
				// Indicates end of file
				if (pBuf == NULL)
				{
					SAFEDELETE(pszBuffer);
					break;
				}

				bstrInput += _bstr_t(pszBuffer) + _bstr_t("\n");
			}
			else 
				break;

			SAFEDELETE(pszBuffer);
		}	

		//Create a file and returns the handle 
		hOutFile = CreateFile(TEMP_BATCH_FILE, GENERIC_WRITE, 0, 
			NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 
			NULL);
		if (hOutFile == INVALID_HANDLE_VALUE)
		{
			throw (::GetLastError());;
		}

		hr=CoCreateInstance(CLSID_DOMDocument, NULL, 
									CLSCTX_INPROC_SERVER,
									IID_IXMLDOMDocument2, 
									(LPVOID*)&pIXMLDOMDocument);
		if (bTrace || eloErrLogOpt)
		{
			CHString	chsMsg;
			chsMsg.Format(L"CoCreateInstance(CLSID_DOMDocument, "
				  L"NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument2,"
				  L" -)"); 
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
						dwThreadId, m_ParsedInfo, bTrace);
		}
		ONFAILTHROWERROR(hr);

		VARIANT_BOOL bSuccess =	VARIANT_FALSE;
		hr = pIXMLDOMDocument->loadXML(bstrInput,&bSuccess);
		if(FAILED(hr) || bSuccess == VARIANT_FALSE)
		{
			//writes data to a file 
			if (!WriteFile(hOutFile, (LPSTR)bstrInput, bstrInput.length(), 
							&dwNumberOfBytes, NULL))
			{
				throw(::GetLastError());
			}
		}
		else
		{
			// Traverse the XML node and get the  content of COMMANDLINE nodes
			// Get the document element.
			hr = pIXMLDOMDocument->get_documentElement(&pIXMLDOMElement);
			if (bTrace || eloErrLogOpt)
			{
				WMITRACEORERRORLOG(hr, __LINE__, 
					__FILE__, _T("IXMLDOMDocument::get_documentElement(-)"), 
					dwThreadId, m_ParsedInfo, bTrace);
			}
			ONFAILTHROWERROR(hr);

			if (pIXMLDOMElement != NULL)
			{
				hr = pIXMLDOMElement->getElementsByTagName(
							_bstr_t(L"COMMANDLINE"), &pIXMLDOMNodeList);
				if (bTrace || eloErrLogOpt)
				{
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
					_T("IXMLDOMElement::getElementsByTagName"
					L"(L\"COMMANDLINE\", -)"),dwThreadId,m_ParsedInfo, bTrace);
				}
				ONFAILTHROWERROR(hr);

				LONG value = 0;
				hr = pIXMLDOMNodeList->get_length(&value);
				if (bTrace || eloErrLogOpt)
				{
					WMITRACEORERRORLOG(hr, __LINE__, 
						__FILE__, _T("IXMLDOMNodeList::get_length(-)"), 
						dwThreadId, m_ParsedInfo, bTrace);
				}
				ONFAILTHROWERROR(hr);

				for(WMICLIINT i = 0; i < value; i++)
				{
					hr = pIXMLDOMNodeList->get_item(i, &pIXMLDOMNode);
					if (bTrace || eloErrLogOpt)
					{
						WMITRACEORERRORLOG(hr, __LINE__, 
							__FILE__, _T("IXMLDOMNodeList::get_item(-,-)"), 
							dwThreadId, m_ParsedInfo, bTrace);
					}
					ONFAILTHROWERROR(hr);
		
					if (pIXMLDOMNode == NULL)
						continue;

					hr = pIXMLDOMNode->get_text(&bstrItemText);
					if (bTrace || eloErrLogOpt)
					{
						WMITRACEORERRORLOG(hr, __LINE__, 
							__FILE__, _T("IXMLDOMNode::get_text(-)"), 
							dwThreadId, m_ParsedInfo, bTrace);
					}
					ONFAILTHROWERROR(hr);

					//write in the file
					_bstr_t bstrItem = _bstr_t(bstrItemText);
					BOOL bRetCode = WriteFile(hOutFile, (LPSTR)bstrItem, 
											bstrItem.length(),
											&dwNumberOfBytes, NULL);
					if(bRetCode == 0)
					{
						throw (::GetLastError());
					}
					
					bRetCode = WriteFile(hOutFile, "\n", 1, 
													&dwNumberOfBytes, NULL);
					if(bRetCode == 0)
					{
						throw (::GetLastError());
					}
		
					SAFEBSTRFREE(bstrItemText);
					SAFEIRELEASE(pIXMLDOMNode);
				}
				SAFEIRELEASE(pIXMLDOMNodeList);
				SAFEIRELEASE(pIXMLDOMElement);
			}
			SAFEIRELEASE(pIXMLDOMDocument);
		}

		if(hInFile)
			CloseHandle(hInFile);
		if(hOutFile)
			CloseHandle(hOutFile);

		_tfreopen(_T("CONIN$"),_T("r"),stdin);
		bRetValue=TRUE;
	}
	catch(_com_error& e) 
	{
		SAFEIRELEASE(pIXMLDOMDocument);
		SAFEIRELEASE(pIXMLDOMElement);
		SAFEIRELEASE(pIXMLDOMNode);
		SAFEIRELEASE(pIXMLDOMNodeList);
		SAFEBSTRFREE(bstrItemText);

		if(hInFile)
			CloseHandle(hInFile);
		if(hOutFile)
			CloseHandle(hOutFile);

		m_ParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bRetValue = FALSE;
		GetFormatObject().DisplayResults(m_ParsedInfo, CP_OEMCP);
	}
	catch(DWORD dwError)
	{
		SAFEIRELEASE(pIXMLDOMDocument);
		SAFEIRELEASE(pIXMLDOMElement);
		SAFEIRELEASE(pIXMLDOMNode);
		SAFEIRELEASE(pIXMLDOMNodeList);
		SAFEBSTRFREE(bstrItemText);

		if(hInFile)
			CloseHandle(hInFile);
		if(hOutFile)
			CloseHandle(hOutFile);

		::SetLastError(dwError);
		DisplayWin32Error();
		m_ParsedInfo.GetCmdSwitchesObject().SetErrataCode(dwError);
		::SetLastError(dwError);

		bRetValue=FALSE;
		GetFormatObject().DisplayResults(m_ParsedInfo, CP_OEMCP);
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIXMLDOMDocument);
		SAFEIRELEASE(pIXMLDOMElement);
		SAFEIRELEASE(pIXMLDOMNode);
		SAFEIRELEASE(pIXMLDOMNodeList);
		SAFEBSTRFREE(bstrItemText);

		if(hInFile)
			CloseHandle(hInFile);
		if(hOutFile)
			CloseHandle(hOutFile);

		bRetValue=FALSE;
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}

	return bRetValue;
}


/*-------------------------------------------------------------------------
   Name				 :FrameXMLHeader
   Synopsis	         :Frames the XML header info
   Type	             :Member Function
   Input parameters  :
		nIter		- Every count
   Output parameters :
		bstrHeader	- String to containg XML header info
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :FrameXMLHeader()
-------------------------------------------------------------------------*/
void CWMICommandLine::FrameXMLHeader(_bstr_t& bstrHeader, WMICLIINT nIter)
{
	try
	{
		CHString				strTemp;
		_bstr_t bstrString = m_ParsedInfo.GetGlblSwitchesObject().
												GetMgmtStationName();
		FindAndReplaceEntityReferences(bstrString);

		strTemp.Format(L"<COMMAND SEQUENCENUM=\"%d\" ISSUEDFROM=\"%s\" "
			L"STARTTIME=\"%s\" EVERYCOUNT=\"%d\">", 
			m_ParsedInfo.GetGlblSwitchesObject().GetSequenceNumber(),
			(TCHAR*)bstrString,
			m_ParsedInfo.GetGlblSwitchesObject().GetStartTime(),
			nIter);
		bstrHeader = _bstr_t(strTemp);	
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	//trap to catch CHeap_Exception
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}


/*-------------------------------------------------------------------------
   Name				 :FrameRequestNode
   Synopsis	         :Frames the XML string for Request info
   Type	             :Member Function
   Input parameters  :None
   Output parameters :
		bstrRequest	- String to containg Request info in XML form
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :FrameRequestNode()
-------------------------------------------------------------------------*/
void CWMICommandLine::FrameRequestNode(_bstr_t& bstrRequest)
{
	try
	{
		CHString	strTemp;
		_bstr_t		bstrContext;
		_bstr_t		bstrCommandComponent;

		bstrRequest = L"<REQUEST>";
		_bstr_t bstrString = m_ParsedInfo.GetCmdSwitchesObject().GetCommandInput();
		FindAndReplaceEntityReferences(bstrString);
		strTemp.Format(L"<COMMANDLINE>%s</COMMANDLINE>",
									(TCHAR*)bstrString);
		bstrRequest += _bstr_t(strTemp);
		
		FrameCommandLineComponents(bstrCommandComponent);
		bstrRequest += bstrCommandComponent;
		FrameContextInfoFragment(bstrContext);
		bstrRequest += bstrContext;
		bstrRequest += L"</REQUEST>";
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	//trap to catch CHeap_Exception
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}


/*-------------------------------------------------------------------------
   Name				 :FrameContextInfoFragment
   Synopsis	         :Frames the XML string for context info
   Type	             :Member Function
   Input parameters  :None
   Output parameters :
		bstrContext	- String to containg context info in XML form
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :FrameContextInfoFragment()
-------------------------------------------------------------------------*/
void CWMICommandLine::FrameContextInfoFragment(_bstr_t& bstrContext)
{
	try
	{
		_bstr_t		bstrAuthLevel,	bstrImpLevel,	bstrPrivileges,
					bstrTrace,		bstrRecordPath,	bstrInteractive,
					bstrFailFast,	bstrAppend,		bstrOutput,
					bstrUser,		bstrAggregate,	bstrNamespace,
					bstrRole,		bstrLocale;
		CHString	strTemp;
		
		m_ParsedInfo.GetGlblSwitchesObject().GetImpLevelTextDesc(bstrImpLevel);
		m_ParsedInfo.GetGlblSwitchesObject().GetAuthLevelTextDesc(bstrAuthLevel);
		m_ParsedInfo.GetGlblSwitchesObject().GetPrivilegesTextDesc(bstrPrivileges);
		m_ParsedInfo.GetGlblSwitchesObject().GetTraceTextDesc(bstrTrace);
		m_ParsedInfo.GetGlblSwitchesObject().GetInteractiveTextDesc(bstrInteractive);
		m_ParsedInfo.GetGlblSwitchesObject().GetFailFastTextDesc(bstrFailFast);
		m_ParsedInfo.GetGlblSwitchesObject().GetAggregateTextDesc(bstrAggregate);

		m_ParsedInfo.GetGlblSwitchesObject().GetOutputOrAppendTextDesc(bstrOutput,
																	  TRUE);
		FindAndReplaceEntityReferences(bstrOutput);
		
		m_ParsedInfo.GetGlblSwitchesObject().GetOutputOrAppendTextDesc(bstrAppend,
																	  FALSE);
		FindAndReplaceEntityReferences(bstrAppend);

		m_ParsedInfo.GetGlblSwitchesObject().GetRecordPathDesc(bstrRecordPath);
		FindAndReplaceEntityReferences(bstrRecordPath);

		m_ParsedInfo.GetUserDesc(bstrUser);
		FindAndReplaceEntityReferences(bstrUser);

		bstrNamespace = m_ParsedInfo.GetGlblSwitchesObject().GetNameSpace();
		FindAndReplaceEntityReferences(bstrNamespace);

		bstrRole = m_ParsedInfo.GetGlblSwitchesObject().GetRole();
		FindAndReplaceEntityReferences(bstrRole);

		bstrLocale = m_ParsedInfo.GetGlblSwitchesObject().GetLocale();
		FindAndReplaceEntityReferences(bstrLocale);

		strTemp.Format(L"<CONTEXT><NAMESPACE>%s</NAMESPACE><ROLE>%s</ROLE>"
					L"<IMPLEVEL>%s</IMPLEVEL><AUTHLEVEL>%s</AUTHLEVEL>"
					L"<LOCALE>%s</LOCALE><PRIVILEGES>%s</PRIVILEGES>"
					L"<TRACE>%s</TRACE><RECORD>%s</RECORD>"
					L"<INTERACTIVE>%s</INTERACTIVE>"
					L"<FAILFAST>%s</FAILFAST><OUTPUT>%s</OUTPUT>"
					L"<APPEND>%s</APPEND><USER>%s</USER>"
					L"<AGGREGATE>%s</AGGREGATE></CONTEXT>",
					(LPWSTR)bstrNamespace, (LPWSTR)bstrRole,
					(LPWSTR)bstrImpLevel, (LPWSTR) bstrAuthLevel,
					(LPWSTR)bstrLocale,
					(LPWSTR)bstrPrivileges, (LPWSTR)bstrTrace,  	
					(LPWSTR)bstrRecordPath, (LPWSTR) bstrInteractive,
					(LPWSTR)bstrFailFast, (LPWSTR) bstrOutput,	
					(LPWSTR)bstrAppend, (LPWSTR) bstrUser,
					(LPWSTR)bstrAggregate);
		bstrContext = strTemp;
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	//trap to catch CHeap_Exception
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}


/*-------------------------------------------------------------------------
   Name				 :FrameCommandLineComponents
   Synopsis	         :Frames the XML string for commandline info
   Type	             :Member Function
   Input parameters  :None
   Output parameters :
		bstrContext	- String to containg commandline info in XML form
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :FrameCommandLineComponents()
-------------------------------------------------------------------------*/
void CWMICommandLine::FrameCommandLineComponents(_bstr_t& bstrCommandComponent)
{
	try
	{
		CHString	strTemp;
		_bstr_t		bstrNodeList;

		bstrCommandComponent = L"<COMMANDLINECOMPONENTS>";
		FrameNodeListFragment(bstrNodeList);
		bstrCommandComponent += bstrNodeList;

		_TCHAR *pszVerbName = m_ParsedInfo.GetCmdSwitchesObject().
															GetVerbName(); 
		if(CompareTokens(pszVerbName, CLI_TOKEN_LIST))
		{
			_bstr_t bstrString = m_ParsedInfo.GetCmdSwitchesObject().
														GetAliasName();

			if (!bstrString) 
				bstrString = L"N/A";
			FindAndReplaceEntityReferences(bstrString);
			strTemp.Format(L"<FRIENDLYNAME>%s</FRIENDLYNAME>",
										(TCHAR*)bstrString);
			bstrCommandComponent += _bstr_t(strTemp);
			 
			bstrString = m_ParsedInfo.GetCmdSwitchesObject().GetAliasTarget();
			if (!bstrString) 
				bstrString = L"N/A";

			FindAndReplaceEntityReferences(bstrString);
			strTemp.Format(L"<TARGET>%s</TARGET>",
										(TCHAR*)bstrString);
			bstrCommandComponent += _bstr_t(strTemp);

			_bstr_t bstrClassName;
			m_ParsedInfo.GetCmdSwitchesObject().GetClassOfAliasTarget(bstrClassName);

			if (!bstrClassName) 
				bstrClassName = L"N/A";

			bstrCommandComponent += L"<ALIASTARGET>";
			bstrCommandComponent += bstrClassName;
			bstrCommandComponent += L"</ALIASTARGET>";

			bstrString = m_ParsedInfo.GetCmdSwitchesObject().GetPWhereExpr();

			if (!bstrString) 
				bstrString = L"N/A";

			FindAndReplaceEntityReferences(bstrString);
			strTemp.Format(L"<PWHERE>%s</PWHERE>", 
										(TCHAR*)bstrString);
			bstrCommandComponent += _bstr_t(strTemp);

			bstrString = m_ParsedInfo.GetCmdSwitchesObject().GetAliasNamespace();
			if (!bstrString) 
				bstrString = L"N/A";
			FindAndReplaceEntityReferences(bstrString);
			strTemp.Format(L"<NAMESPACE>%s</NAMESPACE>",
										(TCHAR*)bstrString);
			bstrCommandComponent += _bstr_t(strTemp);

			bstrString = m_ParsedInfo.GetCmdSwitchesObject().GetAliasDesc();
			if (!bstrString) 
				bstrString = L"N/A";
			FindAndReplaceEntityReferences(bstrString);
			strTemp.Format(L"<DESCRIPTION>%s</DESCRIPTION>",
										(TCHAR*)bstrString);
			bstrCommandComponent += _bstr_t(strTemp);

			bstrString = m_ParsedInfo.GetCmdSwitchesObject().GetFormedQuery();
			if (!bstrString) 
				bstrString = L"N/A";
			FindAndReplaceEntityReferences(bstrString);
			strTemp.Format(L"<RESULTANTQUERY>%s</RESULTANTQUERY>",
										(TCHAR*)bstrString);
			bstrCommandComponent += _bstr_t(strTemp);

			_bstr_t		bstrFormats;
			FrameFormats(bstrFormats);
			bstrCommandComponent += bstrFormats;

			_bstr_t		bstrProperties;
			FramePropertiesInfo(bstrProperties);
			bstrCommandComponent += bstrProperties;
		}

		bstrCommandComponent += L"</COMMANDLINECOMPONENTS>";
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	//trap to catch CHeap_Exception
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}


/*-------------------------------------------------------------------------
   Name				 :FrameNodeListFragment
   Synopsis	         :Frames the XML string for NodeList info
   Type	             :Member Function
   Input parameters  :None
   Output parameters :
		bstrContext	- String to containg NodeList info in XML form
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :FrameNodeListFragment()
-------------------------------------------------------------------------*/
void CWMICommandLine::FrameNodeListFragment(_bstr_t& bstrNodeList)
{
	try
	{
		CHString				strTemp;
		CHARVECTOR::iterator	itrStart,
								itrEnd;
		CHARVECTOR				cvNodes;
		_bstr_t					bstrString ;

		bstrNodeList = L"<NODELIST>";

		cvNodes = m_ParsedInfo.GetGlblSwitchesObject().GetNodesList();

		if (cvNodes.size() > 1)
		{
			itrStart = cvNodes.begin();
			itrEnd	 = cvNodes.end();
			// Move to next node
			itrStart++;
			while (itrStart != itrEnd)
			{
				bstrString = _bstr_t(*itrStart);
				if (!bstrString) 
					bstrString = L"N/A";
				FindAndReplaceEntityReferences(bstrString);
				strTemp.Format(L"<NODE>%s</NODE>", (LPWSTR)bstrString);
				bstrNodeList += _bstr_t(strTemp);
				itrStart++;
			}
		}
		else
		{
			bstrString = _bstr_t(m_ParsedInfo.GetGlblSwitchesObject().
															GetNode());
			if (!bstrString) 
				bstrString = L"N/A";
			FindAndReplaceEntityReferences(bstrString);
			strTemp.Format(L"<NODE>%s</NODE>", (LPWSTR)bstrString);
			bstrNodeList += _bstr_t(strTemp);
		}
		bstrNodeList += L"</NODELIST>";
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	//trap to catch CHeap_Exception
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}

}


/*-------------------------------------------------------------------------
   Name				 :FrameFormats
   Synopsis	         :Frames the XML string for formats info
   Type	             :Member Function
   Input parameters  :None
   Output parameters :
		bstrContext	- String to containg formats info in XML form
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :FrameFormats()
-------------------------------------------------------------------------*/
void CWMICommandLine::FrameFormats(_bstr_t& bstrFormats)
{
	try
	{
		CHString	strTemp;
		XSLTDETVECTOR::iterator	theIterator		= NULL, 
								theEndIterator	= NULL;
		BSTRMAP::iterator		theMapIterator	= NULL, 
								theMapEndIterator	= NULL;
		_bstr_t					bstrString;

		if(!m_ParsedInfo.GetCmdSwitchesObject().GetXSLTDetailsVector().empty())
		{
			bstrFormats = L"<FORMATS>";
			bstrFormats += L"<FORMAT>";

			theIterator = m_ParsedInfo.GetCmdSwitchesObject().
										GetXSLTDetailsVector().begin();
			theEndIterator = m_ParsedInfo.GetCmdSwitchesObject().
										GetXSLTDetailsVector().end();
			while (theIterator != theEndIterator)
			{
				bstrString = _bstr_t((*theIterator).FileName);
				FindAndReplaceEntityReferences(bstrString);
				strTemp.Format(L"<NAME>%s</NAME>",
										(_TCHAR*)bstrString);
				bstrFormats	+= _bstr_t(strTemp);

				theMapIterator = (*theIterator).ParamMap.begin();
				theMapEndIterator = (*theIterator).ParamMap.end();

				while (theMapIterator != theMapEndIterator)
				{
					bstrString = _bstr_t((*theMapIterator).first);
					FindAndReplaceEntityReferences(bstrString);
					strTemp.Format(L"<PARAM><NAME>%s</NAME>",
											(_TCHAR*)bstrString);
					bstrFormats	+= _bstr_t(strTemp);

					bstrString = _bstr_t((*theMapIterator).second);
					FindAndReplaceEntityReferences(bstrString);
					strTemp.Format(L"<VALUE>%s</VALUE>",
											(_TCHAR*)bstrString);
					bstrFormats	+= _bstr_t(strTemp);
				
					bstrFormats += L"</PARAM>";
					
					theMapIterator++;
				}
				theIterator++;
			}		
			bstrFormats += L"</FORMAT>";
			bstrFormats += L"</FORMATS>";
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	//trap to catch CHeap_Exception
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}


/*-------------------------------------------------------------------------
   Name				 :FramePropertiesInfo
   Synopsis	         :Frames the XML string for properties info
   Type	             :Member Function
   Input parameters  :None
   Output parameters :
		bstrContext	- String to containg properties info in XML form
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :FramePropertiesInfo()
-------------------------------------------------------------------------*/
void CWMICommandLine::FramePropertiesInfo(_bstr_t& bstrProperties)
{
	try
	{
		CHString	strTemp;
		PROPDETMAP::iterator	theIterator		= NULL, 
								theEndIterator	= NULL;

		if(!m_ParsedInfo.GetCmdSwitchesObject().GetPropDetMap().empty())
		{
			bstrProperties = L"<PROPERTIES>";

			theIterator = m_ParsedInfo.GetCmdSwitchesObject().
										GetPropDetMap().begin();
			theEndIterator = m_ParsedInfo.GetCmdSwitchesObject().
											GetPropDetMap().end();
			while (theIterator != theEndIterator)
			{
				bstrProperties += L"<PROPERTY>";
				strTemp.Format(L"<NAME>%s</NAME>",
							(_TCHAR*)(*theIterator).first);
				bstrProperties	+= _bstr_t(strTemp);

				strTemp.Format(L"<DERIVATION>%s</DERIVATION>",
							(_TCHAR*)(*theIterator).second.Derivation);
				bstrProperties	+= _bstr_t(strTemp);
				bstrProperties += L"</PROPERTY>";
	
				theIterator++;
			}		
			bstrProperties += L"</PROPERTIES>";
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	//trap to catch CHeap_Exception
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}

/*-------------------------------------------------------------------------
   Name				 :GetFileNameMap
   Synopsis	         :Frames the BSTR Map contains the key words and
					  corresponding files from the XSL mapping file
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :GetFileNameMap()
-------------------------------------------------------------------------*/
void CWMICommandLine::GetFileNameMap()
{
	_TCHAR*  pszFilePath = new _TCHAR[MAX_PATH];
	BSTRMAP::iterator theMapIterator = NULL;
	UINT	nSize	= 0;

	try
	{
		_bstr_t bstrFilePath;

		if(pszFilePath == NULL)
			throw OUT_OF_MEMORY;
				
		nSize = GetSystemDirectory(pszFilePath, MAX_PATH);

		if(nSize)
		{
			if(nSize > MAX_PATH)
			{
				SAFEDELETE(pszFilePath);
				pszFilePath = new _TCHAR[nSize + 1];
				if(pszFilePath == NULL)
					throw OUT_OF_MEMORY;
			}
			if(!GetSystemDirectory(pszFilePath, nSize))
			{
				SAFEDELETE(pszFilePath);
				throw (::GetLastError());
			}
			else
			{
				bstrFilePath = _bstr_t(pszFilePath);
				bstrFilePath += _bstr_t(WBEM_LOCATION) + _bstr_t(CLI_XSLMAPPINGS_FILE);
				SAFEDELETE(pszFilePath);
			}

		}
		else
		{
			SAFEDELETE(pszFilePath);
			throw (::GetLastError());
		}


		GetXSLMappings(bstrFilePath);

		//forming the BSTRMAP containing key words and filenames
		if (Find(m_bmKeyWordtoFileName,CLI_TOKEN_TABLE,theMapIterator) == FALSE)
		{
			m_bmKeyWordtoFileName.insert(BSTRMAP::value_type(CLI_TOKEN_TABLE,
														   XSL_FORMAT_TABLE));
		}

		if (Find(m_bmKeyWordtoFileName,CLI_TOKEN_MOF,theMapIterator) == FALSE)
		{
			m_bmKeyWordtoFileName.insert(BSTRMAP::value_type(CLI_TOKEN_MOF,
														   XSL_FORMAT_MOF));
		}

		if (Find(m_bmKeyWordtoFileName,CLI_TOKEN_TEXTVALUE,theMapIterator) == FALSE)
		{
			m_bmKeyWordtoFileName.insert(BSTRMAP::value_type(CLI_TOKEN_TEXTVALUE,
													   XSL_FORMAT_TEXTVALUE));
		}
		
		if (Find(m_bmKeyWordtoFileName,CLI_TOKEN_LIST,theMapIterator) == FALSE)
		{
			m_bmKeyWordtoFileName.insert(BSTRMAP::value_type(CLI_TOKEN_LIST,
														   XSL_FORMAT_VALUE));
		}
		
		if (Find(m_bmKeyWordtoFileName,CLI_TOKEN_VALUE,theMapIterator) == FALSE)
		{
			m_bmKeyWordtoFileName.insert(BSTRMAP::value_type(CLI_TOKEN_VALUE,
														   XSL_FORMAT_VALUE));
		}
	}
	catch(_com_error &e)
	{
		 SAFEDELETE(pszFilePath);
		_com_issue_error(e.Error());
	}
}

/*-------------------------------------------------------------------------
   Name				 :GetFileFromKey
   Synopsis	         :Gets the xslfile name corrsponding to the keyword passed
					  from the BSTRMAP  
   Type	             :Member Function
   Input parameters  :bstrkeyName - key word
   Output parameters :bstrFileName - the xsl filename 
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetFileFromKey(bstrkeyName, bstrFileName)
-------------------------------------------------------------------------*/
BOOL CWMICommandLine::GetFileFromKey(_bstr_t bstrkeyName, _bstr_t& bstrFileName)
{
	BOOL bFound = TRUE;
	BSTRMAP::iterator theMapIterator = NULL;
	
	if (Find(m_bmKeyWordtoFileName,bstrkeyName,theMapIterator) == TRUE)
		bstrFileName = (*theMapIterator).second;
	else
		bFound = FALSE; 

	return bFound;
}

/*-------------------------------------------------------------------------
   Name				 :GetXSLMappings
   Synopsis	         :Get the XSL file names for keywords
   Type	             :Member Function
   Input parameters  :
			pszFilePath  - XSL mappings file path
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :GetXSLMappings(pszFilePath)
-------------------------------------------------------------------------*/
void CWMICommandLine::GetXSLMappings(_TCHAR *pszFilePath)
{
	HRESULT				hr						= 0;
	BOOL				bContinue				= TRUE;
	IXMLDOMDocument		*pIXMLDOMDocument		= NULL;
	IXMLDOMElement		*pIXMLDOMElement		= NULL;
	IXMLDOMNode			*pIXMLDOMNode			= NULL;
	IXMLDOMNodeList		*pIXMLDOMNodeList		= NULL;
	IXMLDOMNamedNodeMap	*pIXMLDOMNamedNodeMap	= NULL;
    IXMLDOMNode			*pIXMLDOMNodeKeyName	= NULL;
	DWORD				dwThreadId				= GetCurrentThreadId();
	BSTR				bstrItemText			= NULL;
	VARIANT				varValue, varObject;

	VariantInit(&varValue);
	VariantInit(&varObject);

	// Get the TRACE status 
	BOOL bTrace = m_ParsedInfo.GetGlblSwitchesObject().GetTraceStatus();

	// Get the Logging mode (VERBOSE | ERRORONLY | NOLOGGING) 
	ERRLOGOPT eloErrLogOpt = m_ParsedInfo.GetErrorLogObject().GetErrLogOption();

	try
	{
		hr=CoCreateInstance(CLSID_DOMDocument, NULL, 
									CLSCTX_INPROC_SERVER,
									IID_IXMLDOMDocument2, 
									(LPVOID*)&pIXMLDOMDocument);
		if (bTrace || eloErrLogOpt)
		{
			CHString	chsMsg;
			chsMsg.Format(L"CoCreateInstance(CLSID_DOMDocument, "
				  L"NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument2,"
				  L" -)"); 
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
						dwThreadId, m_ParsedInfo, bTrace);
		}
		ONFAILTHROWERROR(hr);

		VARIANT_BOOL bSuccess =	VARIANT_FALSE;
		VariantInit(&varObject);
		varObject.vt = VT_BSTR;
		varObject.bstrVal = SysAllocString(pszFilePath);

		if (varObject.bstrVal == NULL)
		{
			//Reset the variant, it will be cleaned up by the catch...
			VariantInit(&varObject);
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

		hr = pIXMLDOMDocument->load(varObject,&bSuccess);
		if(FAILED(hr) || bSuccess == VARIANT_FALSE)
		{
			bContinue = FALSE;
		}
		
		if (bContinue)
		{
			// Traverse the XML node and get the text of nodes named XSLFORMAT
			// Get the document element.
			hr = pIXMLDOMDocument->get_documentElement(&pIXMLDOMElement);
			if (bTrace || eloErrLogOpt)
			{
				WMITRACEORERRORLOG(hr, __LINE__, 
					__FILE__, _T("IXMLDOMDocument::get_documentElement(-)"), 
					dwThreadId, m_ParsedInfo, bTrace);
			}
			ONFAILTHROWERROR(hr);

			if (pIXMLDOMElement != NULL)
			{
				hr = pIXMLDOMElement->getElementsByTagName(
							_bstr_t(L"XSLFORMAT"), &pIXMLDOMNodeList);
				if (bTrace || eloErrLogOpt)
				{
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
					_T("IXMLDOMElement::getElementsByTagName"
					L"(L\"XSLFORMAT\", -)"), dwThreadId, m_ParsedInfo, bTrace);
				}
				ONFAILTHROWERROR(hr);

				LONG value = 0;
				hr = pIXMLDOMNodeList->get_length(&value);
				if (bTrace || eloErrLogOpt)
				{
					WMITRACEORERRORLOG(hr, __LINE__, 
						__FILE__, _T("IXMLDOMNodeList::get_length(-)"), 
						dwThreadId, m_ParsedInfo, bTrace);
				}
				ONFAILTHROWERROR(hr);

				for(WMICLIINT i = 0; i < value; i++)
				{
					hr = pIXMLDOMNodeList->get_item(i, &pIXMLDOMNode);
					if (bTrace || eloErrLogOpt)
					{
						WMITRACEORERRORLOG(hr, __LINE__, 
							__FILE__, _T("IXMLDOMNodeList::get_item(-,-)"), 
							dwThreadId, m_ParsedInfo, bTrace);
					}
					ONFAILTHROWERROR(hr);
		
					if(pIXMLDOMNode == NULL)
						continue;

					hr = pIXMLDOMNode->get_text(&bstrItemText);
					if (bTrace || eloErrLogOpt)
					{
						WMITRACEORERRORLOG(hr, __LINE__, 
							__FILE__, _T("IXMLDOMNode::get_text(-)"), 
							dwThreadId, m_ParsedInfo, bTrace);
					}
					ONFAILTHROWERROR(hr);

					hr = pIXMLDOMNode->get_attributes(&pIXMLDOMNamedNodeMap);
					if (bTrace || eloErrLogOpt)
					{
						WMITRACEORERRORLOG(hr, __LINE__, 
							__FILE__, _T("IXMLDOMNode::get_attributes(-)"), 
							dwThreadId, m_ParsedInfo, bTrace);
					}
					ONFAILTHROWERROR(hr);

					if(pIXMLDOMNamedNodeMap == NULL)
					{
						SAFEBSTRFREE(bstrItemText);
						SAFEIRELEASE(pIXMLDOMNode);
						continue;
					}

					hr = pIXMLDOMNamedNodeMap->getNamedItem(
						_bstr_t(L"KEYWORD"), &pIXMLDOMNodeKeyName);
					if (bTrace || eloErrLogOpt)
					{
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
						_T("IXMLDOMNamedNodeMap::getNamedItem(L\"KEYWORD\", -)"),
						dwThreadId, m_ParsedInfo, bTrace);
					}
					ONFAILTHROWERROR(hr);

					if(pIXMLDOMNodeKeyName == NULL)
					{
						SAFEBSTRFREE(bstrItemText);
						SAFEIRELEASE(pIXMLDOMNode);
						SAFEIRELEASE(pIXMLDOMNamedNodeMap);
						continue;
					}

					VariantInit(&varValue);
					hr = pIXMLDOMNodeKeyName->get_nodeValue(&varValue);
					if (bTrace || eloErrLogOpt)
					{
						WMITRACEORERRORLOG(hr, __LINE__, 
							__FILE__, _T("IXMLDOMNode::get_nodeValue(-)"), 
							dwThreadId, m_ParsedInfo, bTrace);
					}
					ONFAILTHROWERROR(hr);

					if(varValue.vt == VT_NULL || varValue.vt == VT_EMPTY)
					{
						VARIANTCLEAR(varValue);
						SAFEBSTRFREE(bstrItemText);
						SAFEIRELEASE(pIXMLDOMNode);
						SAFEIRELEASE(pIXMLDOMNamedNodeMap);
						SAFEIRELEASE(pIXMLDOMNodeKeyName);
						continue;
					}

					//forming the BSTRMAP containing key words and filenames
					m_bmKeyWordtoFileName.insert(BSTRMAP::value_type(
											varValue.bstrVal, bstrItemText));
			
					VARIANTCLEAR(varValue);
					SAFEBSTRFREE(bstrItemText);
					SAFEIRELEASE(pIXMLDOMNode);
					SAFEIRELEASE(pIXMLDOMNamedNodeMap);
					SAFEIRELEASE(pIXMLDOMNodeKeyName);
				}
				VARIANTCLEAR(varValue);
				SAFEIRELEASE(pIXMLDOMNodeList);
				SAFEIRELEASE(pIXMLDOMElement);
			}
			SAFEIRELEASE(pIXMLDOMDocument);
		}
		VARIANTCLEAR(varObject);
	}
	catch(_com_error) 
	{
		VARIANTCLEAR(varValue);
		VARIANTCLEAR(varObject);
		SAFEIRELEASE(pIXMLDOMDocument);
		SAFEIRELEASE(pIXMLDOMElement);
		SAFEIRELEASE(pIXMLDOMNode);
		SAFEIRELEASE(pIXMLDOMNodeList);
		SAFEIRELEASE(pIXMLDOMNamedNodeMap);
		SAFEIRELEASE(pIXMLDOMNodeKeyName);
		SAFEBSTRFREE(bstrItemText);
	}
	catch(CHeap_Exception)
	{
		VARIANTCLEAR(varValue);
		VARIANTCLEAR(varObject);
		SAFEIRELEASE(pIXMLDOMDocument);
		SAFEIRELEASE(pIXMLDOMElement);
		SAFEIRELEASE(pIXMLDOMNode);
		SAFEIRELEASE(pIXMLDOMNodeList);
		SAFEIRELEASE(pIXMLDOMNamedNodeMap);
		SAFEIRELEASE(pIXMLDOMNodeKeyName);
		SAFEBSTRFREE(bstrItemText);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\wmicmdln.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: WMICommandLn.h 
Project Name				: WMI Command Line
Author Name					: Ch.Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This file consist of class declaration of
							  class CWMICommandLine
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy 
		Last Modified Date	: 16th-January-2001
****************************************************************************/ 

// WMICommandLine.h : header file
//
/*-------------------------------------------------------------------
 Class Name			: CWMICommandLine
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the functionality needed
					  for synchronization the funtionality of three 
					  functional components identified for the WmiCli.exe.
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: CParsedInfo
					  CExecEngine
					  CFormatEngine
					  CParserEngine
 Interfaces Used    : WMI COM Interfaces
 --------------------------------------------------------------------*/

// forward declaration of classes
class CParserEngine;
class CExecEngine;
class CFormatEngine;
class CParsedInfo;

/////////////////////////////////////////////////////////////////////////////
// CWMICommandLine
class CWMICommandLine
{
public:
//	Construction
	CWMICommandLine();

//	Destruction
	~CWMICommandLine();

//	Restrict Assignment
	CWMICommandLine& operator=(CWMICommandLine& rWmiCmdLn);

// Attributes
private:
	//Pointer to the locator object .
	IWbemLocator	*m_pIWbemLocator;
	
	//CParserEngine object 
	CParserEngine	m_ParserEngine;
	
	//CExecEngine object 
	CExecEngine		m_ExecEngine;
	
	//CFormatEngine object 
	CFormatEngine	m_FormatEngine;
	
	//CParsedInfo object 
	CParsedInfo		m_ParsedInfo;

	// error level
	WMICLIUINT		m_uErrLevel;

	// handle to registry key
	HKEY			m_hKey;

	// handle Ctrl+ events
	BOOL			m_bBreakEvent;

	// specifies accepting input (==TRUE) or executing command (==FALSE)
	BOOL			m_bAccCmd;

	// << description to be added >>
	BOOL			m_bDispRes;

	// Flag to specify windows socket interface initialization.
	BOOL			m_bInitWinSock;

	// Buffer to hold data to be send to clipboard.
	_bstr_t			m_bstrClipBoardBuffer;

	// added by (Nag)
	BSTRMAP			m_bmKeyWordtoFileName;

	// Height of console buffer before starting utility.
	SHORT			m_nHeight;

	// Width of console buffer before starting utility.
	SHORT			m_nWidth;

// Operations
public:

	// Does the initialization ofthe COM library and the security
	// at the process level
	BOOL			Initialize();

	//Gets the Format Engine Object
	CFormatEngine&	GetFormatObject();

	//Gets the Parse Information Object
	CParsedInfo&	GetParsedInfoObject();

	//Uninitializes the the member variables when the execution of a
	//command string issued on the command line is completed.
	void			Uninitialize();

	//processes the given command string 
	SESSIONRETCODE	ProcessCommandAndDisplayResults(_TCHAR* pszBuffer);
	
	//Puts the process to a wait state, launches a worker thread 
	//that keeps track of kbhit()
	void			SleepTillTimeoutOrKBhit(DWORD dwMilliSeconds);

	//Thread procedure polling for keyboard hit
	static DWORD	WINAPI PollForKBhit(LPVOID lpParam);

	//Function to check whether the input string's first token
	//is 'quit'|'exit', if so return true else return false.
	BOOL			IsSessionEnd();

	//Set the session error value
	void			SetSessionErrorLevel(SESSIONRETCODE ssnRetCode);

	//Get the session error value
	WMICLIUINT		GetSessionErrorLevel();

	// This function check whether the /USER global switch
	// has been specified without /PASSWORD, if so prompts
	// for the password
	void			CheckForPassword();

	// Checks whether the given namespace is available or not.
	BOOL IsNSAvailable(const _bstr_t& bstrNS);

	// Checks whether the wmic.exe is being launched for the first time.
	BOOL IsFirstTime();

	// Register the aliases info / localized descriptions
	HRESULT RegisterMofs();

	// Compile the MOF file.
	HRESULT CompileMOFFile(IMofCompiler* pIMofComp, 
						   const _bstr_t& bstrFile,
						   WMICLIINT& nErr);

	// Set break event falg
	void SetBreakEvent(BOOL bFlag);

	// Get break event flag
	BOOL GetBreakEvent();

	// Set Accept Command flag
	void SetAcceptCommand(BOOL bFlag);

	// Get Accept Command flag
	BOOL GetAcceptCommand();

	// Set displayresults flag status
	void SetDisplayResultsFlag(BOOL bFlag);

	// Get DisplayResults flag status
	BOOL GetDisplayResultsFlag();

	// Set Windows sockect interface flag
	void SetInitWinSock(BOOL bFlag);

	// Get Windows sockect interface flag
	BOOL GetInitWinSock();

	// Buffer data to send clipboard. 
	void AddToClipBoardBuffer(LPSTR pszOutput);

	// Get Buffered output in clip board buffer.
	_bstr_t& GetClipBoardBuffer();

	// Clear Clip Board Buffer.
	void EmptyClipBoardBuffer();

	// Check if the file is xml or batch file. If it is batch file
	// then parse it, get commands and write the commands into
	// batch file and redirect the stdin to that file.
	BOOL ReadXMLOrBatchFile(HANDLE hInFile);

	// Frames the XML string for context info
	void FrameContextInfoFragment(_bstr_t& bstrContext);
	
	// Frames the XML header info
	void FrameNodeListFragment(_bstr_t& bstrNodeList);

	// Frames the XML string for Request info
	void FrameXMLHeader(_bstr_t& bstrHeader, WMICLIINT nIter);

	// Frames the XML string for NodeList info
	void FrameRequestNode(_bstr_t& bstrRequest);

	// Frames the XML string for commandline info
	void FrameCommandLineComponents(_bstr_t& bstrCommandComponent);

	// Frames the XML string for formats info
	void FrameFormats(_bstr_t& bstrFormats);

	// Frames the XML string for properties info
	void FramePropertiesInfo(_bstr_t& bstrProperties);

	// Gets the xslfile name corrsponding to the keyword passed
	// from the BSTRMAP  
	BOOL GetFileFromKey(_bstr_t bstrkeyName, _bstr_t& bstrFileName);
	
	// Frames the BSTR Map contains the key words and
	// corresponding files from the XSL mapping file
	void GetFileNameMap();

	// Get the XSL file names for keywords
	void GetXSLMappings(_TCHAR *pszFilePath);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\wmiclixmllog.h ===
//////////////////////////////////////////////////////////////////////
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: WMICliXMLLog.h 
Project Name				: WMI Command Line
Author Name					: Biplab Mistry
Date of Creation (dd/mm/yy) : 02-March-2001
Version Number				: 1.0 
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 09-March-2001
****************************************************************************/ 
// WMICliXMLLog.h : header file
//
/*-------------------------------------------------------------------
 Class Name			: CWMICliXMLLog
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the functionality needed
					  for logging the input and output in XML format
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: None
 Interfaces Used    : None
 --------------------------------------------------------------------*/
class CWMICliXMLLog  
{
public:
	CWMICliXMLLog();
	virtual ~CWMICliXMLLog();
	
	// Restrict Assignment
	CWMICliXMLLog& operator=(CWMICliXMLLog& rWmiCliXMLLog);
	
	// Attributes
private:
	
	// Pointer to object of type IXMLDOMDocument, 
	IXMLDOMDocument2	*m_pIXMLDoc;

	//the xml log file name
	_TCHAR				*m_pszLogFile;
	
	//status of whether the new xml document has to be created or not
	BOOL				m_bCreate;

	WMICLIINT			m_nItrNum;

	BOOL				m_bTrace;

	ERRLOGOPT			m_eloErrLogOpt;


// Operations
private:
	HRESULT CreateXMLLogRoot(CParsedInfo& rParsedInfo, BSTR bstrUser);
	
	HRESULT CreateNodeAndSetContent(IXMLDOMNode** pINode, VARIANT varType,
								BSTR bstrName,	BSTR bstrValue,
								CParsedInfo& rParsedInfo);

	HRESULT AppendAttribute(IXMLDOMNode* pINode, BSTR bstrAttribName, 
						VARIANT varValue, CParsedInfo& rParsedInfo);

	HRESULT CreateNodeFragment(WMICLIINT nSeqNum, BSTR bstrNode, BSTR bstrStart, 
							BSTR bstrInput, BSTR bstrOutput, BSTR bstrTarget,
							CParsedInfo& rParsedInfo);

	HRESULT	FrameOutputNode(IXMLDOMNode **pINode, BSTR bstrOutput, 
							BSTR bstrTarget, CParsedInfo& rParsedInfo);

	HRESULT AppendOutputNode(BSTR bstrOutput, BSTR bstrTarget, 
							CParsedInfo& rParsedInfo);
public:
	// write in to the log file
	HRESULT	WriteToXMLLog(CParsedInfo& rParsedInfo, BSTR bstrOutput);

	// Set the Log File Path
	void SetLogFilePath(_TCHAR* pszFile);

	// Stops the logging
	void StopLogging();

	void Uninitialize(BOOL bFinal = FALSE);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a51\a51fib.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __A51_FIBER__H_
#define __A51_FIBER__H_

class CFiberTask
{
public:
    virtual ~CFiberTask(){}
    virtual HRESULT Execute() = 0;
};

void* CreateFiberForTask(CFiberTask* pTask);
void ReturnFiber(void* pFiber);

void* CreateOrGetCurrentFiber();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a51\a51tools.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include "a51tools.h"

__int64 g_nCurrentTime = 1;

__int64 g_nReadFailures = 0;
__int64 g_nWriteFailures = 0;

//
// FILE_ATTRIBUTE_NOT_CONTENT_INDEXED is not actually supported on CreateFile,
// contrary to the docs.  However, also contrary to the docs, it is inherited
// from the parent directory
//

#define A51_FILE_CREATION_FLAGS 0 //FILE_ATTRIBUTE_NOT_CONTENT_INDEXED

CTempMemoryManager g_Manager;

void* TempAlloc(DWORD dwLen)
{
    return g_Manager.Allocate(dwLen);
}
    
void TempFree(void* p, DWORD dwLen)
{
    g_Manager.Free(p, dwLen);
}

void* TempAlloc(CTempMemoryManager& Manager, DWORD dwLen)
{
    return Manager.Allocate(dwLen);
}
    
void TempFree(CTempMemoryManager& Manager, void* p, DWORD dwLen)
{
    Manager.Free(p, dwLen);
}

HANDLE A51GetNewEvent()
{
    return CreateEvent(NULL, TRUE, FALSE, NULL);
}

void A51ReturnEvent(HANDLE hEvent)
{
    CloseHandle(hEvent);
}

HRESULT A51TranslateErrorCode(long lRes)
{
    switch(lRes)
    {
    case ERROR_FILE_NOT_FOUND:
    case ERROR_PATH_NOT_FOUND:
        return WBEM_E_NOT_FOUND;
    case ERROR_OUTOFMEMORY:
        return WBEM_E_OUT_OF_MEMORY;
    case ERROR_NOT_ENOUGH_QUOTA:
    case ERROR_DISK_FULL:
        return WBEM_E_OUT_OF_DISK_SPACE;
    default:
        return WBEM_E_FAILED;
    }
}

long __stdcall EnsureDirectory(LPCWSTR wszPath, LPSECURITY_ATTRIBUTES pSA)
{
    if(!CreateDirectoryW(wszPath, NULL))
    {
		long lRes = GetLastError();
        if(lRes != ERROR_ALREADY_EXISTS)
            return lRes;
        else
            return ERROR_SUCCESS;
    }
    else
        return ERROR_SUCCESS;
}

long __stdcall EnsureDirectoryRecursiveForFile(LPWSTR wszPath, 
                                                LPSECURITY_ATTRIBUTES pSA);
long __stdcall EnsureDirectoryForFile(LPCWSTR wszPath, LPSECURITY_ATTRIBUTES pSA)
{
    //
    // Make a copy, since we will be messing with it
    //

    CFileName wszNewPath;
	if (wszNewPath == NULL)
		return ERROR_OUTOFMEMORY;
    wcscpy(wszNewPath, wszPath);

    return EnsureDirectoryRecursiveForFile(wszNewPath, pSA);
}


long __stdcall EnsureDirectoryRecursiveForFile(LPWSTR wszPath, 
                                                LPSECURITY_ATTRIBUTES pSA)
{
    long lRes;

    //
    // Find the last backslash and remove
    //

    WCHAR* pwcLastSlash = wcsrchr(wszPath, L'\\');
    if(pwcLastSlash == NULL)
        return ERROR_BAD_PATHNAME;

    *pwcLastSlash = 0;

    //
    // Try to create it
    //

    if(!CreateDirectoryW(wszPath, pSA))
    {
        //
        // Call ourselves recursively --- to create our parents
        //

        lRes = EnsureDirectoryRecursiveForFile(wszPath, pSA);
        if(lRes != ERROR_SUCCESS)
        {
            *pwcLastSlash = L'\\';
            return lRes;
        }

        //
        // Try again
        //

        BOOL bRes = CreateDirectoryW(wszPath, pSA);
        *pwcLastSlash = L'\\';
        if(bRes)
            return ERROR_SUCCESS;
        else
            return GetLastError();
    }
    else
    {
        *pwcLastSlash = L'\\';
        return ERROR_SUCCESS;
    }
}
        
inline WCHAR HexDigit(BYTE b)
{
    if(b < 10)
        return L'0' + b;
    else
        return L'A' + b - 10;
}
        
bool A51Hash(LPCWSTR wszName, LPWSTR wszHash)
{
	//
	// Have to upper-case everything
	//

    DWORD dwBufferSize = wcslen(wszName)*2+2;
    LPWSTR wszBuffer = (WCHAR*)TempAlloc(dwBufferSize);
	if (wszBuffer == NULL)
		return false;
    CTempFreeMe vdm(wszBuffer, dwBufferSize);

    wbem_wcsupr(wszBuffer, wszName);

    BYTE RawHash[16];
    MD5::Transform((void*)wszBuffer, wcslen(wszBuffer)*2, RawHash);

    WCHAR* pwc = wszHash;
    for(int i = 0; i < 16; i++)
    {
        *(pwc++) = HexDigit(RawHash[i]/16);        
        *(pwc++) = HexDigit(RawHash[i]%16);        
    }
	*pwc = 0;
    return true;
}

long A51WriteFile(LPCWSTR wszFullPath, DWORD dwLen, BYTE* pBuffer)
{
    long lRes;

    A51TRACE(( "Create file %S\n", wszFullPath));

    //
    // Create the right file
    //

    HANDLE hFile = CreateFileW(wszFullPath, GENERIC_WRITE, 0,
                    NULL, CREATE_ALWAYS, A51_FILE_CREATION_FLAGS, NULL);
    
    if(hFile == INVALID_HANDLE_VALUE)
    {
        lRes = GetLastError();
        if(lRes == ERROR_PATH_NOT_FOUND)
        {
            lRes = EnsureDirectoryForFile(wszFullPath, NULL);
            if(lRes != ERROR_SUCCESS)
                return lRes;

            hFile = CreateFileW(wszFullPath, GENERIC_WRITE, 0,
                            NULL, CREATE_ALWAYS, A51_FILE_CREATION_FLAGS, NULL);
    
            if(hFile == INVALID_HANDLE_VALUE)
            {
                lRes = GetLastError();
                _ASSERT(lRes != ERROR_SUCCESS, L"success error code from fail");
                return lRes;
            }
        }
        else
            return lRes;
    }
        
    CCloseMe cm(hFile);

    //
    // Write it and close
    //

    if(!WriteFile(hFile, pBuffer, dwLen, &dwLen, NULL))
    {
        lRes = GetLastError();
        _ASSERT(lRes != ERROR_SUCCESS, L"success error code from fail");
        return lRes;
    }

    return ERROR_SUCCESS;
}

long A51DeleteFile(LPCWSTR wszFullPath)
{
    A51TRACE(("Delete file %S\n", wszFullPath));

    //
    // Delete the right file
    //

    if(!DeleteFileW(wszFullPath))
        return GetLastError();
    return ERROR_SUCCESS;
}

long A51WriteToFileAsync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen, OVERLAPPED* pov)
{
    pov->Offset = lStartingOffset;
    pov->OffsetHigh = 0;
    pov->hEvent = A51GetNewEvent();

    BOOL bRes;
    DWORD dwWritten;
    while(!(bRes = WriteFile(hFile, pBuffer, dwBufferLen, &dwWritten, pov)) &&
            (GetLastError() == ERROR_INVALID_USER_BUFFER ||
             GetLastError() == ERROR_NOT_ENOUGH_MEMORY))
    {
        //
        // Out of buffer-space --- wait a bit and retry
        //

        g_nWriteFailures++;
        Sleep(16);
    }

    if(!bRes)
    {
        long lRes = GetLastError();
        if(lRes == ERROR_IO_PENDING)
            // perfect!
            return ERROR_SUCCESS;
        else
        {
            A51ReturnEvent(pov->hEvent);
            pov->hEvent = NULL;
            return lRes;
        }
    }
    else
    {
        //
        // Succeeded synchronously --- clean up and return
        //

        A51ReturnEvent(pov->hEvent);
        pov->hEvent = NULL;

        if(dwWritten != dwBufferLen)
            return ERROR_OUTOFMEMORY;
        else
            return ERROR_SUCCESS;
    }
}

long A51WriteToFileSync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen)
{
    OVERLAPPED ov;
    
    long lRes = A51WriteToFileAsync(hFile, lStartingOffset, pBuffer, 
                                    dwBufferLen, &ov);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    if(ov.hEvent)
    {
        CReturnMe rm(ov.hEvent);
    
        //
        // Wait for completion
        //
    
        DWORD dwWritten;
        if(!GetOverlappedResult(hFile, &ov, &dwWritten, TRUE))
            return GetLastError();
    
        if(dwWritten != dwBufferLen)
            return ERROR_OUTOFMEMORY;
    }

    return ERROR_SUCCESS;
}
    
long A51ReadFromFileAsync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen, OVERLAPPED* pov)
{
    long lRes;

    pov->Offset = lStartingOffset;
    pov->OffsetHigh = 0;
    pov->hEvent = A51GetNewEvent();

    BOOL bRes;
    DWORD dwRead;
    while(!(bRes = ReadFile(hFile, pBuffer, dwBufferLen, &dwRead, pov)) &&
            (GetLastError() == ERROR_INVALID_USER_BUFFER ||
             GetLastError() == ERROR_NOT_ENOUGH_MEMORY))
    {
        //
        // Out of buffer-space --- wait a bit and retry
        //

        g_nReadFailures++;
        Sleep(16);
    }

    if(!bRes)
    {
        if(GetLastError() == ERROR_IO_PENDING)
            // perfect!
            return ERROR_SUCCESS;
        else
        {
            lRes = GetLastError();
            _ASSERT(lRes != ERROR_SUCCESS, L"Success returned on failure");
            A51ReturnEvent(pov->hEvent);
            pov->hEvent = NULL;
            return lRes;
        }
    }
    else
    {
        //
        // Succeeded synchronously --- clean up and return
        //

        A51ReturnEvent(pov->hEvent);
        pov->hEvent = NULL;

        if(dwRead != dwBufferLen)
        {
            return ERROR_OUTOFMEMORY;
        }
        else
            return ERROR_SUCCESS;
    }
}

long A51ReadFromFileSync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen)
{
    OVERLAPPED ov;
    
    long lRes = A51ReadFromFileAsync(hFile, lStartingOffset, pBuffer, 
                                    dwBufferLen, &ov);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    if(ov.hEvent)
    {
        CReturnMe rm(ov.hEvent);
    
        //
        // Wait for completion
        //
    
        DWORD dwRead = 0;
        if(!GetOverlappedResult(hFile, &ov, &dwRead, TRUE))
        {
            lRes = GetLastError();
            _ASSERT(lRes != ERROR_SUCCESS, L"Success returned on failure");
            return lRes;
        }
    
        if(dwRead != dwBufferLen)
        {
            return ERROR_OUTOFMEMORY;
        }
    }

    return ERROR_SUCCESS;
}
    
    

long RemoveDirectoryRecursive(LPCWSTR wszDirectoryPath);
long A51RemoveDirectory(LPCWSTR wszFullPath)
{
    long lRes = RemoveDirectoryRecursive(wszFullPath);
    if(lRes == ERROR_PATH_NOT_FOUND || lRes == ERROR_FILE_NOT_FOUND)
        return ERROR_FILE_NOT_FOUND;
    else
        return lRes;
}

long RemoveDirectoryRecursive(LPCWSTR wszDirectoryPath)
{
    long lRes;

    //
    // Try removing it right away
    //

    if(!RemoveDirectoryW(wszDirectoryPath))
    {
        long lRes = GetLastError();
        if(lRes == ERROR_PATH_NOT_FOUND || lRes == ERROR_FILE_NOT_FOUND)
            return ERROR_FILE_NOT_FOUND;
        else if(lRes != ERROR_DIR_NOT_EMPTY && lRes != ERROR_SHARING_VIOLATION)
            return lRes;
    }
    else 
        return ERROR_SUCCESS;

    //
    // Not empty (or at least we are not sure it is empty) --- enumerate 
    // everything
    //

    CFileName wszMap;
	if (wszMap == NULL)
		return ERROR_OUTOFMEMORY;
    wcscpy(wszMap, wszDirectoryPath);
    wcscat(wszMap, L"\\*");

    CFileName wszChild;
	if (wszChild == NULL)
		return ERROR_OUTOFMEMORY;
    wcscpy(wszChild, wszDirectoryPath);
    wcscat(wszChild, L"\\");
    long lChildLen = wcslen(wszChild);

    WIN32_FIND_DATAW fd;
    HANDLE hSearch = FindFirstFileW(wszMap, &fd);
    if(hSearch == INVALID_HANDLE_VALUE)
        return ERROR_DIR_NOT_EMPTY;

    do
    {
        if(fd.cFileName[0] == L'.')
            continue;

        if((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
        {
            // There is a file --- give up
            FindClose(hSearch);
            return ERROR_DIR_NOT_EMPTY;
        }

        wcscpy(wszChild + lChildLen, fd.cFileName);
        lRes = RemoveDirectoryRecursive(wszChild);
        if(lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND)
        {
            FindClose(hSearch);
            return lRes;
        }
    }
    while(FindNextFileW(hSearch, &fd));

    FindClose(hSearch);
            
    //
    // And try again
    //

    if(!RemoveDirectoryW(wszDirectoryPath))
    {
        long lRes = GetLastError();
        if(lRes == ERROR_PATH_NOT_FOUND || lRes == ERROR_FILE_NOT_FOUND)
            return ERROR_FILE_NOT_FOUND;
        else if(lRes == ERROR_SHARING_VIOLATION)
            return ERROR_SUCCESS;
        else 
            return lRes;
    }

    return ERROR_SUCCESS;
}
    
CRITICAL_SECTION g_csLog;
char* g_szText = NULL;
long g_lTextLen = 0;
WCHAR g_wszLogFilename[MAX_PATH] = L"";
void A51Trace(LPCSTR szFormat, ...)
{
    if((g_wszLogFilename[0] == 0) || (g_szText == NULL))
    {
        InitializeCriticalSection(&g_csLog);

		delete g_szText;
		g_wszLogFilename[0] = 0;
		g_szText = NULL;

		HKEY hKey;
		long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
						L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
						0, KEY_READ, &hKey);
		if(lRes)
		{
			wcscpy(g_wszLogFilename, L"c:\\a51.log");
		}
		else
		{
			DWORD dwLen = MAX_PATH;
			CFileName wszTmp;
			if (wszTmp == 0)
			{
				wcscpy(g_wszLogFilename, L"c:\\a51.log");
				RegCloseKey(hKey);
			}
			else
			{
				lRes = RegQueryValueExW(hKey, L"Logging Directory", NULL, NULL, 
							(LPBYTE)(wchar_t*)wszTmp, &dwLen);
				RegCloseKey(hKey);
				if(lRes)
				{
					wcscpy(g_wszLogFilename, L"c:\\a51.log");
				}
				else
				{
					if (ExpandEnvironmentStringsW(wszTmp,g_wszLogFilename,MAX_PATH) == 0)
					{
						wcscpy(g_wszLogFilename, L"c:\\a51.log");
					}
					else
					{
						if (g_wszLogFilename[wcslen(g_wszLogFilename)] == L'\\')
						{
							wcscat(g_wszLogFilename, L"a51.log");
						}
						else
						{
							wcscat(g_wszLogFilename, L"\\a51.log");
						}
					}
				}
			}
		}
        
        g_szText = new char[3000000];
		if (g_szText == NULL)
			return;
    }

    EnterCriticalSection(&g_csLog);
    
    char szBuffer[256];
    va_list argptr;
    va_start(argptr, szFormat);
    vsprintf(szBuffer, szFormat, argptr);
    long lLen = strlen(szBuffer);
    if(g_lTextLen + lLen > 2900000)
        A51TraceFlush();

    strcpy(g_szText + g_lTextLen, szBuffer);
    g_lTextLen += lLen;

    LeaveCriticalSection(&g_csLog);
}

void A51TraceFlush()
{
	FILE* fLog = NULL;
	fLog = _wfopen(g_wszLogFilename, L"a");
    if(fLog)
    {
        fwrite(g_szText, 1, g_lTextLen, fLog);
        g_lTextLen = 0;
//      fflush(fLog);
		fclose(fLog);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a51\a51tools.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __A51_TOOLS__H_
#define __A51_TOOLS__H_

#include <sync.h>
#include <newnew.h>
#include <xmemory>

#ifdef DBG
  #define _A51_INTERNAL_ASSERT
#endif

typedef LONGLONG TFileOffset;

#define MAX_HASH_LEN 32

void* TempAlloc(DWORD dwLen);
void TempFree(void* p, DWORD dwLen = 0);

void* TempAlloc(CTempMemoryManager& Manager, DWORD dwLen);
void TempFree(CTempMemoryManager& Manager, void* p, DWORD dwLen);

HRESULT A51TranslateErrorCode(long lRes);

#define TEMPFREE_ME

class CTempFreeMe
{
protected:
    void* m_p;
    DWORD m_dwLen;
public:
    CTempFreeMe(void* p, DWORD dwLen = 0) : m_p(p), m_dwLen(dwLen){}
    ~CTempFreeMe() {TempFree(m_p, m_dwLen);}
};

HANDLE A51GetNewEvent();
void A51ReturnEvent(HANDLE hEvent);

class CReturnMe
{
protected:
    HANDLE m_h;
public:
    CReturnMe(HANDLE h) : m_h(h){}
    ~CReturnMe() {A51ReturnEvent(m_h);}
};


inline void wbem_wcsupr(WCHAR* pwcTo, const WCHAR* pwcFrom)
{
    while(*pwcFrom)
    {
        if(*pwcFrom >= 'a' && *pwcFrom <= 'z')
            *pwcTo = *pwcFrom + ('A'-'a');
        else
            *pwcTo = towupper(*pwcFrom);
        pwcTo++;
        pwcFrom++;
    }
    *pwcTo = 0;
}

class CFileName
{
private:
	wchar_t *m_wszFilename;

public:
	DWORD Length() { return MAX_PATH + 1; }
	CFileName() { m_wszFilename = (wchar_t*)TempAlloc(sizeof(wchar_t) * Length()); }
	~CFileName() { TempFree(m_wszFilename, sizeof(wchar_t) * Length()); }
	operator wchar_t *() { return m_wszFilename; }
};

long EnsureDirectory(LPCWSTR wszPath, LPSECURITY_ATTRIBUTES pSA = NULL);
long EnsureDirectoryForFile(LPCWSTR wszPath, LPSECURITY_ATTRIBUTES pSA = NULL);
bool A51Hash(LPCWSTR wszName, LPWSTR wszHash);
long A51DeleteFile(LPCWSTR wszFullPath);
long A51WriteFile(LPCWSTR wszFullPath, DWORD dwLen, BYTE* pBuffer);
long A51RemoveDirectory(LPCWSTR wszFullPath);
long A51WriteToFileAsync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen, OVERLAPPED* pov);
long A51WriteToFileSync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen);
long A51ReadFromFileAsync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen, OVERLAPPED* pov);
long A51ReadFromFileSync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen);

extern __int64 g_nCurrentTime;

#undef _ASSERT

#ifdef _A51_INTERNAL_ASSERT
#define _ASSERT(X, MSG) {if(!(X)) {A51TraceFlush(); DebugBreak();}}
#else
#define _ASSERT(X, MSG)
#endif

extern FILE* g_fLog;

#ifdef _A51_INTERNAL_DEBUG
#define A51TRACE(X) A51Trace X
#else
#define A51TRACE(X)
#endif

void A51Trace(LPCSTR szFormat, ...);

void A51TraceFlush();

template<class T>
class CTempAllocator
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef T *pointer;
    typedef const T *const_pointer;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T value_type;

    char* _Charalloc(size_t n)
    {
        return (char*)TempAlloc(n);
    }

    void deallocate(void* p, size_t n)
    {
        TempFree(p, 0);
    }

    void construct(pointer p, const T& val)
    {
        new ((void*)p) T(val);
    }

    void destroy(pointer p)
    {
        p->T::~T();
    }
};

template<class T>
class CPrivateTempAllocator
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef T *pointer;
    typedef const T *const_pointer;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T value_type;

    CPrivateTempAllocator(CTempMemoryManager* pManager) 
        : m_pManager(pManager)
    {}
    
    char* _Charalloc(size_t n)
    {
        return (char*)m_pManager->Allocate(n);
    }

    void deallocate(void* p, size_t n)
    {
        m_pManager->Free(p, 0);
    }

    void construct(pointer p, const T& val)
    {
        new ((void*)p) T(val);
    }

    void destroy(pointer p)
    {
        p->T::~T();
    }
protected:
    CTempMemoryManager* m_pManager;
};

    
            
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a51\a51fib.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include "a51fib.h"
#include <tls.h>

void CALLBACK A51FiberBase(void* p)
{
    CFiberTask* pTask = (CFiberTask*)p;
    pTask->Execute();

    //
    // No need to clean up --- it's the job of our caller
    //
}

void* CreateFiberForTask(CFiberTask* pTask)
{
    //
    // For now, just create it
    //

    void* pFiber = CreateFiber(0, A51FiberBase, pTask);
    return pFiber;
}

void ReturnFiber(void* pFiber)
{
    //
    // For now, just delete it
    //

    DeleteFiber(pFiber);
}
    
CTLS g_tlsInit;
void* CreateOrGetCurrentFiber()
{
    if(!g_tlsInit.IsValid())
        return NULL;

    void* pFiber = g_tlsInit.Get();
    if(pFiber == NULL)
    {
        //
        // We have never seen this thread before --- convert to fiber
        //

        pFiber = ConvertThreadToFiber(NULL);
        if(pFiber == NULL)
            return NULL;
        
        //
        // Remember it for the future
        //

        g_tlsInit.Set(pFiber);
    }

    return pFiber;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a51\a51rep.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <windows.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <stdio.h>
#include <wbemcomn.h>
#include <ql.h>
#include <time.h>
#include "a51rep.h"
#include <md5.h>
#include <objpath.h>
#include "lock.h"
#include <persistcfg.h>
#include "a51fib.h"
#include "RepositoryPackager.h"

CForestCache* g_ForestCache = NULL;
CFileCache* g_FileCache = NULL;
_IWmiCoreServices* g_pCoreServices = NULL;
CLock g_readWriteLock;
long g_lRootDirLen;
WCHAR g_wszRootDir[MAX_PATH];
bool g_bShuttingDown = false;
long g_lActiveRepNs = 0;

#define A51_REP_FS_VERSION 2

#define A51_CLASSDEF_FILE_PREFIX L"CD_"

#define A51_CLASSRELATION_DIR_PREFIX L"CR_"
#define A51_CHILDCLASS_FILE_PREFIX L"C_"

#define A51_KEYROOTINST_DIR_PREFIX L"KI_"
#define A51_INSTDEF_FILE_PREFIX L"I_"

#define A51_CLASSINST_DIR_PREFIX L"CI_"
#define A51_INSTLINK_FILE_PREFIX L"IL_"

#define A51_INSTREF_DIR_PREFIX L"IR_"
#define A51_REF_FILE_PREFIX L"R_"

#define A51_SCOPE_DIR_PREFIX L"SC_"

//TO USE FIBERS, UNCOMMENT THE FOLLOWING LINE...
#define A51_USE_FIBER

//*****************************************************************************

INTERNAL CForestCache* CRepository::GetForestCache() 
{
    return g_ForestCache;
}

INTERNAL _IWmiCoreServices* CRepository::GetCoreServices() 
{
    return g_pCoreServices;
}

INTERNAL CFileCache* CNamespaceHandle::GetFileCache() 
{
    return g_FileCache;
}

HRESULT CRepository::Initialize()
{
    HRESULT hRes = WBEM_E_FAILED;
	{
        //
        // Make sure that the version that created the repository is the same
        // as the one we are currently running
        //

		CPersistentConfig cfg;
		DWORD dwVal = 0;
		if (!cfg.GetPersistentCfgValue(PERSIST_CFGVAL_CORE_FSREP_VERSION, dwVal)
             || 
            ((dwVal != 0) && (dwVal != A51_REP_FS_VERSION)))
		{
			return WBEM_E_DATABASE_VER_MISMATCH;
		}
		else if (dwVal == 0)
		{
            //
            // First time --- write the right version in
            //

			cfg.SetPersistentCfgValue(PERSIST_CFGVAL_CORE_FSREP_VERSION, 
                                        A51_REP_FS_VERSION);
		}
	}

    //
    // Initialize time index
    //

    FILETIME ft;
    GetSystemTimeAsFileTime(&ft);

    g_nCurrentTime = ft.dwLowDateTime + ((__int64)ft.dwHighDateTime << 32);

    //
    // Get the repository directory
    //

    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ, &hKey);
    if(lRes)
        return WBEM_E_FAILED;

    CFileName wszTmp;
	if (wszTmp == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    DWORD dwLen = wszTmp.Length();
    lRes = RegQueryValueExW(hKey, L"Repository Directory", NULL, NULL, 
                (LPBYTE)(wchar_t*)wszTmp, &dwLen);
	RegCloseKey(hKey);
    if(lRes)
        return WBEM_E_FAILED;

    CFileName wszRepDir;
	if (wszRepDir == NULL)
		return WBEM_E_OUT_OF_MEMORY;

	if (ExpandEnvironmentStringsW(wszTmp,wszRepDir,wszTmp.Length()) == 0)
		return WBEM_E_FAILED;


    lRes = EnsureDirectory(wszRepDir);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Append standard postfix --- that is our root
    //
    wcscpy(g_wszRootDir, wszRepDir);
    wcscat(g_wszRootDir, L"\\FS");
    g_lRootDirLen = wcslen(g_wszRootDir);

    //
    // Ensure the directory is there
    //

    lRes = EnsureDirectory(g_wszRootDir);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    SetFileAttributesW(g_wszRootDir, FILE_ATTRIBUTE_NOT_CONTENT_INDEXED);

    //
    // initialze all our global resources
    //
    g_FileCache = new CFileCache;
    if (g_FileCache == NULL)
    {
        hRes = WBEM_E_OUT_OF_MEMORY;
        goto error;
    }
    g_FileCache->AddRef();
    g_ForestCache = new CForestCache;
    if (g_ForestCache ==  NULL)
    {
        hRes = WBEM_E_OUT_OF_MEMORY;
        goto error;
    }
    g_ForestCache->AddRef();

    lRes = g_FileCache->RepositoryExists(g_wszRootDir);
    if (lRes == ERROR_FILE_NOT_FOUND)
    {
        //We may need to do a database restore!
        CFileName wszBackupFile;
	    if (wszBackupFile == NULL)
        {
            hRes = WBEM_E_OUT_OF_MEMORY;
            goto error;
        }
        wcscpy(wszBackupFile, wszRepDir);
        wcscat(wszBackupFile, L"\\repdrvfs.rec");

        DWORD dwAttributes = GetFileAttributesW(wszBackupFile);
        if (dwAttributes != -1)
        {
		    DWORD dwMask =	FILE_ATTRIBUTE_DEVICE |
						    FILE_ATTRIBUTE_DIRECTORY |
						    FILE_ATTRIBUTE_OFFLINE |
						    FILE_ATTRIBUTE_REPARSE_POINT |
						    FILE_ATTRIBUTE_SPARSE_FILE;

		    if (!(dwAttributes & dwMask))
            {
                CRepositoryPackager packager;
	            lRes = packager.UnpackageRepository(wszBackupFile);

                //We are going to ignore the error so if there was a problem we will just
                //load all the standard MOFs.
                if (lRes != WBEM_E_OUT_OF_MEMORY)
                    lRes = WBEM_S_NO_ERROR;
            }
        }
    }
    if (FAILED(lRes))
    {
        hRes = lRes;
        goto error;
    }
    //
    // Initialize file cache.  It will read the registry itself to find out
    // its size limitations
    //

    lRes = g_FileCache->Initialize(g_wszRootDir);
    if(lRes != ERROR_SUCCESS)
    {
        hRes = WBEM_E_FAILED;
        goto error;
    }

    //
    // Initialize class cache.  It will read the registry itself to find out
    // its size limitations
    //

    lRes = g_ForestCache->Initialize();
    if(lRes != ERROR_SUCCESS)
    {
        hRes = WBEM_E_FAILED;
        goto error;
    }
    
    hRes = CoCreateInstance(CLSID_IWmiCoreServices, NULL,
                CLSCTX_INPROC_SERVER, IID__IWmiCoreServices,
                (void**)&g_pCoreServices);
    if(FAILED(hRes))
    {
        ERRORTRACE((LOG_WBEMCORE,
            "CRITICAL: Event system not available!!!!\n"));
    }

    g_bShuttingDown = false;
    return WBEM_S_NO_ERROR;

error:
    g_FileCache->Release();
    g_FileCache = NULL;
    g_ForestCache->Release();
    g_ForestCache = NULL;
    return hRes;

}

HRESULT STDMETHODCALLTYPE CRepository::Logon(
      WMIDB_LOGON_TEMPLATE *pLogonParms,
      DWORD dwFlags,
      DWORD dwRequestedHandleType,
     IWmiDbSession **ppSession,
     IWmiDbHandle **ppRootNamespace
    )
{
    //If not initialized, initialize all subsystems...
    if (!g_FileCache)
    {
        HRESULT hres = Initialize();
        if (FAILED(hres))
            return hres;
    }

    CSession* pSession = new CSession(m_pControl);
	if (pSession == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    CNamespaceHandle* pHandle = new CNamespaceHandle(m_pControl, this);
	if (pHandle == NULL)
	{
		delete pSession;
		return WBEM_E_OUT_OF_MEMORY;
	}

    *ppSession = pSession;
    (*ppSession)->AddRef();


    pHandle->Initialize(L"");

    *ppRootNamespace = pHandle;
    
    (*ppRootNamespace)->AddRef();

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRepository::GetLogonTemplate(
       LCID  lLocale,
       DWORD dwFlags,
      WMIDB_LOGON_TEMPLATE **ppLogonTemplate
    )
{
    WMIDB_LOGON_TEMPLATE* lt = (WMIDB_LOGON_TEMPLATE*)CoTaskMemAlloc(sizeof(WMIDB_LOGON_TEMPLATE));

    lt->dwArraySize = 0;
    lt->pParm = NULL;

    *ppLogonTemplate = lt;
    return S_OK;
}
    

HRESULT STDMETHODCALLTYPE CRepository::FreeLogonTemplate(
     WMIDB_LOGON_TEMPLATE **ppTemplate
    )
{
    CoTaskMemFree(*ppTemplate);
    *ppTemplate = NULL;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRepository::Shutdown(
     DWORD dwFlags
    )
{
    g_bShuttingDown = true;
    CAutoWriteLock lock(&g_readWriteLock);
    g_FileCache->Release();
    g_FileCache = NULL;
    g_ForestCache->Release();
    g_ForestCache = NULL;
    if (g_pCoreServices)
        g_pCoreServices->Release();
    g_pCoreServices = NULL;
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CRepository::SetCallTimeout(
     DWORD dwMaxTimeout
    )
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRepository::SetCacheValue(
     DWORD dwMaxBytes
    )
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ | KEY_WRITE, &hKey);
    if(lRes)
        return lRes;
    CRegCloseMe cm(hKey);
    DWORD dwLen = sizeof(DWORD);
    DWORD dwMaxAge;
    lRes = RegQueryValueExW(hKey, L"Max Class Cache Item Age (ms)", NULL, NULL, 
                (LPBYTE)&dwMaxAge, &dwLen);

    if(lRes != ERROR_SUCCESS)
    {
        dwMaxAge = 10000;
        lRes = RegSetValueExW(hKey, L"Max Class Cache Item Age (ms)", 0, 
                REG_DWORD, (LPBYTE)&dwMaxAge, sizeof(DWORD));
    }
    g_ForestCache->SetMaxMemory(dwMaxBytes, dwMaxAge);
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRepository::FlushCache(
     DWORD dwFlags
    )

{
//    g_ForestCache->Flush();
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRepository::GetStatistics(
      DWORD  dwParameter,
     DWORD *pdwValue
    )
{
    return S_OK;
}

HRESULT CRepository::GetNamespaceHandle(LPCWSTR wszNamespaceName,
                                    RELEASE_ME CNamespaceHandle** ppHandle)
{
    HRESULT hres;

    //
    // No validation --- that would be too hard.  Just create a handle and
    // return
    //

    CNamespaceHandle* pNewHandle = new CNamespaceHandle(m_pControl, this);
	if (pNewHandle == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    pNewHandle->AddRef();
    CReleaseMe rm1(pNewHandle);

    hres = pNewHandle->Initialize(wszNamespaceName);
    if(FAILED(hres)) 
        return hres;

    *ppHandle = pNewHandle;
    pNewHandle->AddRef();
    return S_OK;
}

HRESULT CRepository::Backup(LPCWSTR wszBackupFile, long lFlags)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

	// params have already been verified by the calling method (CWbemBackupRestore::DoBackup),
	// but do it again just in case things change and this is no longer the case
    if (NULL == wszBackupFile || (lFlags != 0))
        return WBEM_E_INVALID_PARAMETER;

    //We need to lock the database so no one writes to it while we are backing it up
	CAutoReadLock lock(&g_readWriteLock);

    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;

    //We need to wait for the stage write to flush...
    DWORD dwCount = 0;
    while (!g_FileCache->IsFullyFlushed())
    {
        Sleep(100);

        if (++dwCount ==100000)
        {
            //We have a real problem here!  We need to fail the operation.
            hRes = WBEM_E_TIMED_OUT;
            break;
        }
    }

    if (SUCCEEDED(hRes))
    {
	    CRepositoryPackager packager;
	    hRes = packager.PackageRepository(wszBackupFile);
    }

	return hRes;
}
HRESULT CRepository::Restore(LPCWSTR wszBackupFile, long lFlags)
{
    return WBEM_E_NOT_SUPPORTED;
}
//**************************************************************************************************



HRESULT STDMETHODCALLTYPE CSession::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWmiDbSession || 
                riid == IID_IWmiDbSessionEx)
    {
        AddRef();
        *ppv = this;
        return S_OK;
    }
    else return E_NOINTERFACE;
}

ULONG STDMETHODCALLTYPE CSession::Release()
{
    return CUnkBase<IWmiDbSessionEx, &IID_IWmiDbSessionEx>::Release();
}

CSession::~CSession()
{
    if(m_lRef != 0)
        DebugBreak();
}
    

HRESULT STDMETHODCALLTYPE CSession::GetObject(
     IWmiDbHandle *pScope,
     IWbemPath *pPath,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult
    )
{
	try
	{
        HRESULT hres;
        CAutoReadLock lock(&g_readWriteLock, FALSE);

        if (!m_bInWriteTransaction)
        {
		    lock.Lock();
        }
        if (g_bShuttingDown)
        {
            return WBEM_E_SHUTTING_DOWN;
        }
    
        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            return pNs->GetErrorStatus();
        }

		hres = pNs->GetObject(pPath, dwFlags, dwRequestedHandleType, 
                                        ppResult);

        return hres;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}


HRESULT STDMETHODCALLTYPE CSession::GetObjectDirect(
     IWmiDbHandle *pScope,
     IWbemPath *pPath,
     DWORD dwFlags,
     REFIID riid,
    LPVOID *pObj
    )
{
	try
	{
        HRESULT hres;
        CAutoReadLock lock(&g_readWriteLock, FALSE);

        if (!m_bInWriteTransaction)
        {
		    lock.Lock();
        }
        if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;

        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            return pNs->GetErrorStatus();
        }

		hres = pNs->GetObjectDirect(pPath, dwFlags, riid, pObj);

        return hres;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

HRESULT STDMETHODCALLTYPE CSession::GetObjectByPath(
     IWmiDbHandle *pScope,
     LPCWSTR wszObjectPath,
     DWORD dwFlags,
     REFIID riid,
    LPVOID *pObj
    )
{
	try
	{
        HRESULT hres;
        CAutoReadLock lock(&g_readWriteLock, FALSE);

        if (!m_bInWriteTransaction)
        {
		    lock.Lock();
        }
        if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;

        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            return pNs->GetErrorStatus();
        }

		DWORD dwLen = wcslen(wszObjectPath)+1;
		LPWSTR wszPath = (WCHAR*)TempAlloc(dwLen*sizeof(WCHAR));
		if (wszPath == NULL)
        {
			return WBEM_E_OUT_OF_MEMORY;
        }
		wcscpy(wszPath, wszObjectPath);

		CTempFreeMe vdm(wszPath, dwLen * sizeof(WCHAR));
		hres = pNs->GetObjectByPath(wszPath, dwFlags, riid, pObj);

        return hres;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}
    


HRESULT STDMETHODCALLTYPE CSession::PutObject(
     IWmiDbHandle *pScope,
     REFIID riid,
    LPVOID pObj,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult
    )
{
	try
	{
        HRESULT hres;
        long lRes;
        CAutoWriteLock lock(&g_readWriteLock, FALSE);
        CEventCollector aNonTransactedEvents;
        CEventCollector *aEvents = &m_aTransactedEvents;

        if (!m_bInWriteTransaction)
        {
		    lock.Lock();
            if (g_bShuttingDown)
                return WBEM_E_SHUTTING_DOWN;
            aEvents = &aNonTransactedEvents;
            lRes = g_FileCache->BeginTransaction();
            if(lRes != ERROR_SUCCESS)
                return A51TranslateErrorCode(lRes);
        }
        else if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;


        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            if(!m_bInWriteTransaction)
            {
                g_FileCache->AbortTransaction();
            }
            return pNs->GetErrorStatus();
        }

		hres =  pNs->PutObject(riid, pObj, dwFlags, dwRequestedHandleType, ppResult, *aEvents);
        
        if(!m_bInWriteTransaction)
        {
            if (FAILED(hres))
            {
                g_FileCache->AbortTransaction();
            }
            else
            {
                lRes = g_FileCache->CommitTransaction();
                if(lRes != ERROR_SUCCESS)
                {
                    hres = A51TranslateErrorCode(lRes);
                    g_FileCache->AbortTransaction();
                }
                else
                {
                    lock.Unlock();
                    aNonTransactedEvents.SendEvents(g_pCoreServices);
                }
            }
            aNonTransactedEvents.DeleteAllEvents();
        }
    
		return hres;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

HRESULT STDMETHODCALLTYPE CSession::DeleteObject(
     IWmiDbHandle *pScope,
     DWORD dwFlags,
     REFIID riid,
     LPVOID pObj
    )
{
	try
	{
        HRESULT hres;
        long lRes;
        CAutoWriteLock lock(&g_readWriteLock, FALSE);
        CEventCollector aNonTransactedEvents;
        CEventCollector *aEvents = &m_aTransactedEvents;

        if (!m_bInWriteTransaction)
        {
		    lock.Lock();
            if (g_bShuttingDown)
                return WBEM_E_SHUTTING_DOWN;
            aEvents = &aNonTransactedEvents;
            lRes = g_FileCache->BeginTransaction();
            if(lRes != ERROR_SUCCESS)
                return A51TranslateErrorCode(lRes);

        }
        else if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;

        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            if(!m_bInWriteTransaction)
            {
                g_FileCache->AbortTransaction();
            }
            return pNs->GetErrorStatus();
        }

		hres = pNs->DeleteObject(dwFlags, riid, pObj, *aEvents);

        if(!m_bInWriteTransaction)
        {
            if (FAILED(hres))
            {
                g_FileCache->AbortTransaction();
            }
            else
            {
                lRes = g_FileCache->CommitTransaction();
                if(lRes != ERROR_SUCCESS)
                {
                    hres = A51TranslateErrorCode(lRes);
                    g_FileCache->AbortTransaction();
                }
                else
                {
                    lock.Unlock();
                    aNonTransactedEvents.SendEvents(g_pCoreServices);
                }
            }
            aNonTransactedEvents.DeleteAllEvents();
        }

		return hres;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

HRESULT STDMETHODCALLTYPE CSession::DeleteObjectByPath(
     IWmiDbHandle *pScope,
     LPCWSTR wszObjectPath,
     DWORD dwFlags
    )
{
	try
	{
        HRESULT hres;
        long lRes;
        CAutoWriteLock lock(&g_readWriteLock, FALSE);
        CEventCollector aNonTransactedEvents;
        CEventCollector *aEvents = &m_aTransactedEvents;

        if (!m_bInWriteTransaction)
        {
		    lock.Lock();
            if (g_bShuttingDown)
                return WBEM_E_SHUTTING_DOWN;
            aEvents = &aNonTransactedEvents;
            lRes = g_FileCache->BeginTransaction();
            if(lRes != ERROR_SUCCESS)
                return A51TranslateErrorCode(lRes);

        }
        else if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;

        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            if(!m_bInWriteTransaction)
            {
                g_FileCache->AbortTransaction();
            }
            return pNs->GetErrorStatus();
        }
		DWORD dwLen = wcslen(wszObjectPath)+1;
		LPWSTR wszPath = (WCHAR*)TempAlloc(dwLen*sizeof(WCHAR));
		if (wszPath == NULL)
        {
            if(!m_bInWriteTransaction)
            {
                g_FileCache->AbortTransaction();
            }
			return WBEM_E_OUT_OF_MEMORY;
        }
		wcscpy(wszPath, wszObjectPath);

		CTempFreeMe vdm(wszPath, dwLen * sizeof(WCHAR));

		hres = pNs->DeleteObjectByPath(dwFlags, wszPath, *aEvents);

        if(!m_bInWriteTransaction)
        {
            if (FAILED(hres))
            {
                g_FileCache->AbortTransaction();
            }
            else
            {
                lRes = g_FileCache->CommitTransaction();
                if(lRes != ERROR_SUCCESS)
                {
                    hres = A51TranslateErrorCode(lRes);
                    g_FileCache->AbortTransaction();
                }
                else
                {
                    lock.Unlock();
                    aNonTransactedEvents.SendEvents(g_pCoreServices);
                }
            }
            aNonTransactedEvents.DeleteAllEvents();
        }

		return hres;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

HRESULT STDMETHODCALLTYPE CSession::ExecQuery(
     IWmiDbHandle *pScope,
     IWbemQuery *pQuery,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    DWORD *dwMessageFlags,
    IWmiDbIterator **ppQueryResult
    )
{
	try
	{
        HRESULT hres;
        CAutoReadLock lock(&g_readWriteLock, FALSE);

        if (!m_bInWriteTransaction)
        {
		    lock.Lock();
        }
        if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;

        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            return pNs->GetErrorStatus();
        }

		hres = pNs->ExecQuery(pQuery, dwFlags,
				 dwRequestedHandleType, dwMessageFlags, ppQueryResult);

        return hres;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

HRESULT STDMETHODCALLTYPE CSession::ExecQuerySink(
     IWmiDbHandle *pScope,
     IWbemQuery *pQuery,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
     IWbemObjectSink* pSink,
    DWORD *dwMessageFlags
    )
{
	try
	{
        HRESULT hres;
        CAutoReadLock lock(&g_readWriteLock, FALSE);

        if (!m_bInWriteTransaction)
        {
		    lock.Lock();
        }
        if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;

        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            return pNs->GetErrorStatus();
        }

		hres = pNs->ExecQuerySink(pQuery, dwFlags,
				 dwRequestedHandleType, pSink, dwMessageFlags);

        return hres;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}
                    
    
HRESULT STDMETHODCALLTYPE CSession::RenameObject(
     IWbemPath *pOldPath,
     IWbemPath *pNewPath,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult
    )
{
    DebugBreak();
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSession::Enumerate(
     IWmiDbHandle *pScope,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbIterator **ppQueryResult
    )
{
    DebugBreak();
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSession::AddObject(
     IWmiDbHandle *pScope,
     IWbemPath *pPath,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult
    )
{
    DebugBreak();
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSession::RemoveObject (
     IWmiDbHandle *pScope,
     IWbemPath *pPath,
     DWORD dwFlags
    )
{
    DebugBreak();
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSession::SetDecoration(
     LPWSTR lpMachineName,
     LPWSTR lpNamespacePath
    )
{
    DebugBreak();
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSession::BeginWriteTransaction(DWORD dwFlags)
{
    g_readWriteLock.WriteLock();
    if (g_bShuttingDown)
    {
        g_readWriteLock.WriteUnlock();
        return WBEM_E_SHUTTING_DOWN;
    }

    long lRes = g_FileCache->BeginTransaction();
    if(lRes != ERROR_SUCCESS)
    {
        g_readWriteLock.WriteUnlock();
        return A51TranslateErrorCode(lRes);
    }

    m_bInWriteTransaction = true;
    return ERROR_SUCCESS;
}

HRESULT STDMETHODCALLTYPE CSession::BeginReadTransaction(DWORD dwFlags)
{
    g_readWriteLock.ReadLock();
    if (g_bShuttingDown)
    {
        g_readWriteLock.ReadUnlock();
        return WBEM_E_SHUTTING_DOWN;
    }

    return ERROR_SUCCESS;
}

HRESULT STDMETHODCALLTYPE CSession::CommitTransaction(DWORD dwFlags)
{
    if (m_bInWriteTransaction)
    {
        long lRes = g_FileCache->CommitTransaction();
        if(lRes != ERROR_SUCCESS)
        {
            HRESULT hres = A51TranslateErrorCode(lRes);
            AbortTransaction(0);
            return hres;
        }
        m_bInWriteTransaction = false;

        //Copy the event list and delete the original.  We need to deliver
        //outside the write lock.
        CEventCollector aTransactedEvents;
        aTransactedEvents.TransferEvents(m_aTransactedEvents);

        g_readWriteLock.WriteUnlock();

        aTransactedEvents.SendEvents(g_pCoreServices);
        aTransactedEvents.DeleteAllEvents();
    }
    else
    {
        if (m_aTransactedEvents.GetSize())
		{
            _ASSERT(false, L"Read transaction has events to send");
		}
        g_readWriteLock.ReadUnlock();
   }
    return ERROR_SUCCESS;
}

HRESULT STDMETHODCALLTYPE CSession::AbortTransaction(DWORD dwFlags)
{
    if (m_bInWriteTransaction)
    {
        m_bInWriteTransaction = false;
        g_FileCache->AbortTransaction();
        m_aTransactedEvents.DeleteAllEvents();
        g_readWriteLock.WriteUnlock();
    }
    else
    {
        if (m_aTransactedEvents.GetSize())
		{
            _ASSERT(false, L"Read transaction has events to send");
		}
        g_readWriteLock.ReadUnlock();
    }
    return ERROR_SUCCESS;
}


CNamespaceHandle::CNamespaceHandle(CLifeControl* pControl, 
                                    CRepository* pRepository)
    : TUnkBase(pControl), m_pClassCache(NULL),
       m_pNullClass(NULL), m_pRepository(pRepository), m_bCached(false)
{
    m_pRepository->AddRef();
    m_ForestCache = m_pRepository->GetForestCache();
    m_ForestCache->AddRef();
    InterlockedIncrement(&g_lActiveRepNs);
}

CNamespaceHandle::~CNamespaceHandle()
{
    if(m_pClassCache && m_pRepository)
    {
        m_ForestCache->ReleaseNamespaceCache(m_wsNamespace, m_pClassCache);
    }

    m_pRepository->Release();
    m_ForestCache->Release();
    if(m_pNullClass)
        m_pNullClass->Release();
    InterlockedDecrement(&g_lActiveRepNs);
}

HRESULT CNamespaceHandle::GetErrorStatus()
{
    //
    // TEMP CODE: Someone is calling us on an impersonated thread.  Let's catch
    // the, ahem, culprit
    //

    HANDLE hToken;
    BOOL bRes = OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken);
    if(bRes)
    {
        //_ASSERT(false, L"Called with a thread token");
        ERRORTRACE((LOG_WBEMCORE, "Repository called with a thread token! "
                        "It shall be removed\n"));
        CloseHandle(hToken);
        SetThreadToken(NULL, NULL);
    }

    return m_pClassCache->GetError();
}

void CNamespaceHandle::SetErrorStatus(HRESULT hres)
{
    m_pClassCache->SetError(hres);
}

HRESULT CNamespaceHandle::Initialize(LPCWSTR wszNamespace, LPCWSTR wszScope)
{
    HRESULT hres;

    m_wsNamespace = wszNamespace;
    m_wsFullNamespace = L"\\\\.\\";
    m_wsFullNamespace += wszNamespace;

    DWORD dwSize = MAX_COMPUTERNAME_LENGTH+1;
    GetComputerNameW(m_wszMachineName, &dwSize);

    if(wszScope)
        m_wsScope = wszScope;

    //
    // Ask the forest for the cache for this namespace
    //

    m_pClassCache = m_pRepository->GetForestCache()->
                        GetNamespaceCache(wszNamespace);
    if(m_pClassCache == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    wcscpy(m_wszClassRootDir, m_pRepository->GetRootDir());

    //
    // Append namespace-specific prefix
    //

    wcscat(m_wszClassRootDir, L"\\NS_");

    //
    // Append hashed namespace name
    //

    if (!Hash(wszNamespace, m_wszClassRootDir + wcslen(m_wszClassRootDir)))
		return WBEM_E_OUT_OF_MEMORY;
	m_lClassRootDirLen = wcslen(m_wszClassRootDir);

    //
    // Constuct the instance root dir
    //

    if(wszScope == NULL)
    {
        //
        // Basic namespace --- instances go into the root of the namespace
        //

        wcscpy(m_wszInstanceRootDir, m_wszClassRootDir);
        m_lInstanceRootDirLen = m_lClassRootDirLen;
    }   
    else
    {
        wcscpy(m_wszInstanceRootDir, m_wszClassRootDir);
        wcscat(m_wszInstanceRootDir, L"\\" A51_SCOPE_DIR_PREFIX);
        if(!Hash(m_wsScope, 
                 m_wszInstanceRootDir + wcslen(m_wszInstanceRootDir)))
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        m_lInstanceRootDirLen = wcslen(m_wszInstanceRootDir);
    }
        

    return WBEM_S_NO_ERROR;
}



HRESULT CNamespaceHandle::GetObject(
     IWbemPath *pPath,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult
    )
{
    HRESULT hres;

    if((dwRequestedHandleType & WMIDB_HANDLE_TYPE_COOKIE) == 0)
    {
        DebugBreak();
        return E_NOTIMPL;
    }

    DWORD dwLen = 0;
    hres = pPath->GetText(WBEMPATH_GET_ORIGINAL, &dwLen, NULL);
    if(FAILED(hres) && hres != WBEM_E_BUFFER_TOO_SMALL)
        return hres;

    WCHAR* wszBuffer = (WCHAR*)TempAlloc(dwLen * sizeof(WCHAR));
    if(wszBuffer == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszBuffer, dwLen * sizeof(WCHAR));

    if(FAILED(pPath->GetText(WBEMPATH_GET_ORIGINAL, &dwLen, wszBuffer)))
        return WBEM_E_FAILED;

    return GetObjectHandleByPath(wszBuffer, dwFlags, dwRequestedHandleType, 
        ppResult);
}

HRESULT CNamespaceHandle::GetObjectHandleByPath(
     LPWSTR wszBuffer,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult
    )
{
    //
    // Get the key from path
    //

    DWORD dwLen = wcslen(wszBuffer)*sizeof(WCHAR)+2;
    LPWSTR wszKey = (WCHAR*)TempAlloc(dwLen);
    if(wszKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszKey, dwLen);

    bool bIsClass;
    LPWSTR wszClassName = NULL;
    HRESULT hres = ComputeKeyFromPath(wszBuffer, wszKey, &wszClassName, 
                                        &bIsClass);
    if(FAILED(hres))
        return hres;
    CTempFreeMe tfm1(wszClassName, (wcslen(wszClassName)+1) * sizeof(WCHAR*));

    //
    // Check if it exists (except for ROOT --- it's fake)
    //

    _IWmiObject* pObj = NULL;
    if(m_wsNamespace.Length() > 0)
    {
        hres = GetInstanceByKey(wszClassName, wszKey, IID__IWmiObject, 
            (void**)&pObj);
        if(FAILED(hres))
            return hres;
    }
    CReleaseMe rm1(pObj);

    CNamespaceHandle* pNewHandle = new CNamespaceHandle(m_pControl, 
                                                            m_pRepository);
	if (pNewHandle == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    pNewHandle->AddRef();
    CReleaseMe rm2(pNewHandle);

    //
    // Check if this is a namespace or not
    //

    if(pObj == NULL || pObj->InheritsFrom(L"__Namespace") == S_OK)
    {
        //
        // It's a namespace.  Open a basic handle pointing to it
        //

        WString wsName = m_wsNamespace;
        if(wsName.Length() > 0)
            wsName += L"\\";
        wsName += wszKey;
    
        hres = pNewHandle->Initialize(wsName);

        //
        // Since our namespace is for real, tell the cache that it is now valid.
        // The cache might have been invalidated if this namespace was deleted 
        // in the past
        //

        pNewHandle->SetErrorStatus(S_OK);
    }
    else
    {
        // 
        // It's a scope.  Construct the new scope name by appending this 
        // object's path to our own scope
        //

        VARIANT v;
        VariantInit(&v);
        CClearMe cm(&v);
        hres = pObj->Get(L"__RELPATH", 0, &v, NULL, NULL);
        if(FAILED(hres))
            return hres;
        if(V_VT(&v) != VT_BSTR)
            return WBEM_E_INVALID_OBJECT;

        WString wsScope = m_wsScope;
        if(wsScope.Length() > 0)
            wsScope += L":";
        wsScope += V_BSTR(&v);

        hres = pNewHandle->Initialize(m_wsNamespace, wsScope);
    }
        
    if(FAILED(hres))
        return hres;

    return pNewHandle->QueryInterface(IID_IWmiDbHandle, (void**)ppResult);
}
    
HRESULT CNamespaceHandle::ComputeKeyFromPath(LPWSTR wszPath, LPWSTR wszKey,
                                            TEMPFREE_ME LPWSTR* pwszClass,
                                            bool* pbIsClass,
                                            TEMPFREE_ME LPWSTR* pwszNamespace)
{
    HRESULT hres;

    *pbIsClass = false;

    //
    // Get and skip the namespace portion.
    //

    if(wszPath[0] == '\\' || wszPath[0] == '/')
    {
        //
        // Find where the server portion ends
        //

        WCHAR* pwcNextSlash = wcschr(wszPath+2, wszPath[0]);
        if(pwcNextSlash == NULL)
            return WBEM_E_INVALID_OBJECT_PATH;
        
        //
        // Find where the namespace portion ends
        //

        WCHAR* pwcColon = wcschr(pwcNextSlash, L':');
        if(pwcColon == NULL)
            return WBEM_E_INVALID_OBJECT_PATH;
    
        if(pwszNamespace)
        {
            DWORD dwLen = pwcColon - pwcNextSlash;
            *pwszNamespace = (WCHAR*)TempAlloc(dwLen * sizeof(WCHAR));
            if(*pwszNamespace == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            
            *pwcColon = 0;
            wcscpy(*pwszNamespace, pwcNextSlash+1);
        }

        //
        // Advance wszPath to beyond the namespace portion
        //

        wszPath = pwcColon+1;
    }
    else if(pwszNamespace)
    {
        *pwszNamespace = NULL;
    }

    // Get the first key

    WCHAR* pwcFirstEq = wcschr(wszPath, L'=');
    if(pwcFirstEq == NULL)
    {
        //
        // It's a class!
        //

        *pbIsClass = true;
        // path to the "class" to distinguish from its  instances
        wszKey[0] = 1;
        wszKey[1] = 0;

        *pwszClass = (WCHAR*)TempAlloc((wcslen(wszPath)+1) * sizeof(WCHAR));
        if(*pwszClass == NULL)
        {
            if(pwszNamespace)
                TempFree(*pwszNamespace);
            return WBEM_E_OUT_OF_MEMORY;
        }
        wcscpy(*pwszClass, wszPath);
        return S_OK;
    }

    WCHAR* pwcFirstDot = wcschr(wszPath, L'.');

    if(pwcFirstDot == NULL || pwcFirstDot > pwcFirstEq)
    {
        // No name on the first key

        *pwcFirstEq = 0;

        *pwszClass = (WCHAR*)TempAlloc((wcslen(wszPath)+1) * sizeof(WCHAR));
        if(*pwszClass == NULL)
		{
			if(pwszNamespace)
				TempFree(*pwszNamespace);
			return WBEM_E_OUT_OF_MEMORY;
		}
        wcscpy(*pwszClass, wszPath);
    
        WCHAR* pwcThisKey = NULL;
        WCHAR* pwcEnd = NULL;
        hres = ParseKey(pwcFirstEq+1, &pwcThisKey, &pwcEnd);
        if(FAILED(hres))
        {
            TempFree(*pwszClass);
            if(pwszNamespace)
                TempFree(*pwszNamespace);

            return hres;
        }
        if(*pwcEnd != NULL)
        {
            TempFree(*pwszClass);
            if(pwszNamespace)
                TempFree(*pwszNamespace);

            return WBEM_E_INVALID_OBJECT_PATH;
        }

        wcscpy(wszKey, pwcThisKey);
        return S_OK;
    }

    //
    // Normal case
    //

    //
    // Get all the key values
    //

    struct CKeyStruct
    {
        WCHAR* m_pwcValue;
        WCHAR* m_pwcName;
    } aKeys[256];
    DWORD dwNumKeys = 0;

    *pwcFirstDot = NULL;

    *pwszClass = (WCHAR*)TempAlloc((wcslen(wszPath)+1) * sizeof(WCHAR));
    if(*pwszClass == NULL)
    {
        if(pwszNamespace)
            TempFree(*pwszNamespace);
        return WBEM_E_OUT_OF_MEMORY;
    }

    wcscpy(*pwszClass, wszPath);

    WCHAR* pwcNextKey = pwcFirstDot+1;

    do
    {
        pwcFirstEq = wcschr(pwcNextKey, L'=');
        if(pwcFirstEq == NULL)
        {
            TempFree(*pwszClass);
            if(pwszNamespace)
                TempFree(*pwszNamespace);

            return WBEM_E_INVALID_OBJECT_PATH;
        }
        
        *pwcFirstEq = 0;

        aKeys[dwNumKeys].m_pwcName = pwcNextKey;
        hres = ParseKey(pwcFirstEq+1, &(aKeys[dwNumKeys].m_pwcValue), 
                            &pwcNextKey);
        if(FAILED(hres))
        {
            TempFree(*pwszClass);
            if(pwszNamespace)
                TempFree(*pwszNamespace);

            return hres;
        }
		dwNumKeys++;
    }
    while(*pwcNextKey);

    if(*pwcNextKey != 0)
    {
        TempFree(*pwszClass);
        if(pwszNamespace)
            TempFree(*pwszNamespace);

        return WBEM_E_INVALID_OBJECT_PATH;
    }
    
    //
    // We have the array of keys --- sort it
    //

    DWORD dwCurrentIndex = 0;
    while(dwCurrentIndex < dwNumKeys-1)
    {
        if(wbem_wcsicmp(aKeys[dwCurrentIndex].m_pwcName, 
                        aKeys[dwCurrentIndex+1].m_pwcName) > 0)
        {
            CKeyStruct Temp = aKeys[dwCurrentIndex];
            aKeys[dwCurrentIndex] = aKeys[dwCurrentIndex+1];
            aKeys[dwCurrentIndex+1] = Temp;
            if(dwCurrentIndex)
                dwCurrentIndex--;
            else
                dwCurrentIndex++;
        }
        else
            dwCurrentIndex++;
    }

    //
    // Now generate the result
    //
    
    WCHAR* pwcKeyEnd = wszKey;
    for(DWORD i = 0; i < dwNumKeys; i++)
    {
        wcscpy(pwcKeyEnd, aKeys[i].m_pwcValue);
        pwcKeyEnd += wcslen(aKeys[i].m_pwcValue);
        if(i < dwNumKeys-1)
            *(pwcKeyEnd++) = -1;
    }
    *pwcKeyEnd = 0;
    return S_OK;
}

HRESULT CNamespaceHandle::ParseKey(LPWSTR wszKeyStart, LPWSTR* pwcRealStart,
                                    LPWSTR* pwcNextKey)
{
    if(wszKeyStart[0] == L'"' || wszKeyStart[0] == L'\'')
    {
        WCHAR wcStart = wszKeyStart[0];
        WCHAR* pwcRead = wszKeyStart+1;
        WCHAR* pwcWrite = wszKeyStart+1;
        while(*pwcRead && *pwcRead != wcStart)  
        {
            if(*pwcRead == '\\')
                pwcRead++;

            *(pwcWrite++) = *(pwcRead++);
        }
        if(*pwcRead == 0)
            return WBEM_E_INVALID_OBJECT_PATH;

        *pwcWrite = 0;
        if(pwcRealStart)
            *pwcRealStart = wszKeyStart+1;

        //
        // Check separator
        //
    
        if(pwcRead[1] && pwcRead[1] != L',')
            return WBEM_E_INVALID_OBJECT_PATH;
            
        if(pwcNextKey)
		{
			//
			// If there is a separator, skip it.  Don't skip end of string!
			//

			if(pwcRead[1])
	            *pwcNextKey = pwcRead+2;
			else
				*pwcNextKey = pwcRead+1;
		}
    }
    else
    {
        if(pwcRealStart)
            *pwcRealStart = wszKeyStart;
        WCHAR* pwcComma = wcschr(wszKeyStart, L',');
        if(pwcComma == NULL)
        {
            if(pwcNextKey)
                *pwcNextKey = wszKeyStart + wcslen(wszKeyStart);
        }
        else
        {
            *pwcComma = 0;
            if(pwcNextKey)
                *pwcNextKey = pwcComma+1;
        }
    }

    return S_OK;
}
            

HRESULT CNamespaceHandle::GetObjectDirect(
     IWbemPath *pPath,
     DWORD dwFlags,
     REFIID riid,
    LPVOID *pObj
    )
{
    HRESULT hres;

    DWORD dwLen = 0;
    hres = pPath->GetText(WBEMPATH_GET_ORIGINAL, &dwLen, NULL);

    LPWSTR wszPath = (WCHAR*)TempAlloc(dwLen*sizeof(WCHAR));
	if (wszPath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe vdm(wszPath, dwLen * sizeof(WCHAR));

    hres = pPath->GetText(WBEMPATH_GET_ORIGINAL, &dwLen, wszPath);
    if(FAILED(hres))
        return hres;


    return GetObjectByPath(wszPath, dwFlags, riid, pObj);
}

HRESULT CNamespaceHandle::GetObjectByPath(
     LPWSTR wszPath,
     DWORD dwFlags,
     REFIID riid,
     LPVOID *pObj
    )
{
    HRESULT hres;

    //
    // Get the key from path
    //

    DWORD dwLen = wcslen(wszPath)*sizeof(WCHAR)+2;
    LPWSTR wszKey = (WCHAR*)TempAlloc(dwLen);
    if(wszKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszKey, dwLen);

    bool bIsClass;
    LPWSTR wszClassName = NULL;
    hres = ComputeKeyFromPath(wszPath, wszKey, &wszClassName, &bIsClass);
    if(FAILED(hres))
        return hres;
    CTempFreeMe tfm1(wszClassName, (wcslen(wszClassName)+1) * sizeof(WCHAR*));

    if(bIsClass)
    {
        return GetClassDirect(wszClassName, riid, pObj, true);
    }
    else
    {
        return GetInstanceByKey(wszClassName, wszKey, riid, pObj);
    }
}

HRESULT CNamespaceHandle::GetInstanceByKey(LPCWSTR wszClassName,
                                LPCWSTR wszKey,
                                REFIID riid, void** ppObj)
{
    HRESULT hres;

    //
    // Get the class definition
    //

    _IWmiObject* pClass = NULL;
    hres = GetClassDirect(wszClassName, IID__IWmiObject, (void**)&pClass, 
                            false);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pClass);

    //
    // Construct directory path
    //

    CFileName wszFilePath;
	if (wszFilePath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructKeyRootDirFromClass(wszFilePath, wszClassName);
    if(FAILED(hres))
        return hres;

    //
    // Construct the file path
    //

    int nLen = wcslen(wszFilePath);
    wszFilePath[nLen] = L'\\';

    hres = ConstructInstanceDefName(wszFilePath+nLen+1, wszKey);
    if(FAILED(hres))
        return hres;
    
    //
    // Get the object from that file
    //

    _IWmiObject* pInst;
    hres = FileToInstance(wszFilePath, &pInst);
    if(FAILED(hres))
        return hres;
	CReleaseMe rm2(pInst);

    //
    // Return
    //

    return pInst->QueryInterface(riid, (void**)ppObj);
}

HRESULT CNamespaceHandle::GetClassByHash(LPCWSTR wszHash, bool bClone, 
                                            _IWmiObject** ppClass,
                                            __int64* pnTime,
                                            bool* pbRead)
{
    HRESULT hres;

    //
    // Check the cache first
    //

    *ppClass = m_pClassCache->GetClassDefByHash(wszHash, bClone, pnTime, pbRead);
    if(*ppClass)
        return S_OK;

    //
    // Not found --- construct the file name and read it
    //

    if(pbRead)
        *pbRead = true;

    CFileName wszFileName;
	if (wszFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassDefFileNameFromHash(wszHash, wszFileName);
    if(FAILED(hres))
        return hres;

    CFileName wszFilePath;
	if (wszFilePath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    swprintf(wszFilePath, L"%s\\%s", m_wszClassRootDir, wszFileName);

    hres = FileToClass(wszFilePath, ppClass, bClone, pnTime);
    if(FAILED(hres))
        return hres;

    return S_OK;
}

    
HRESULT CNamespaceHandle::GetClassDirect(LPCWSTR wszClassName,
                                REFIID riid, void** ppObj, bool bClone,
                                __int64* pnTime,
                                bool* pbRead)
{
    HRESULT hres;

    if(wszClassName == NULL || wcslen(wszClassName) == 0)
    {
        if(m_pNullClass == NULL)
        {
            hres = CoCreateInstance(CLSID_WbemClassObject, NULL, 
                        CLSCTX_INPROC_SERVER,
                        IID__IWmiObject, (void **)&m_pNullClass);
            if (FAILED(hres))
                return hres;
        }

        IWbemClassObject* pRawObj;
        hres = m_pNullClass->Clone(&pRawObj);
		if (FAILED(hres))
			return hres;
        CReleaseMe rm(pRawObj);
        if(pnTime)
            *pnTime = 0;
        if(pbRead)
            *pbRead = false;

        return pRawObj->QueryInterface(riid, ppObj);
    }

    _IWmiObject* pClass;

    //
    // Check the cache first
    //

    pClass = m_pClassCache->GetClassDef(wszClassName, bClone, pnTime, pbRead);
    if(pClass)
    {
        CReleaseMe rm1(pClass);
        return pClass->QueryInterface(riid, ppObj);
    }

    if(pbRead)
        *pbRead = true;

    //
    // Construct the path for the file
    //

    CFileName wszFileName;
	if (wszFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassDefFileName(wszClassName, wszFileName);
    if(FAILED(hres))
        return hres;

    CFileName wszFilePath;
	if (wszFilePath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    swprintf(wszFilePath, L"%s\\%s", m_wszClassRootDir, wszFileName);

    //
    // Read it from the file
    //

    hres = FileToClass(wszFilePath, &pClass, bClone, pnTime);
    if(FAILED(hres))
	    return hres;
    CReleaseMe rm1(pClass);

    return pClass->QueryInterface(riid, ppObj);
}

HRESULT CNamespaceHandle::FileToInstance(LPCWSTR wszFileName, 
                    _IWmiObject** ppInstance, bool bMustBeThere)
{
    HRESULT hres;

    //
    // Read the data from the file
    //

	DWORD dwSize;
	BYTE* pBlob;
	long lRes = GetFileCache()->ReadFile(wszFileName, &dwSize, &pBlob, 
                                         bMustBeThere);
	if(lRes != ERROR_SUCCESS)
	{
		if(lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND)
			return WBEM_E_NOT_FOUND;
		else
			return WBEM_E_FAILED;
	}

	CTempFreeMe tfm1(pBlob, dwSize);

    _ASSERT(dwSize > sizeof(__int64), L"Instance blob too short");
    if(dwSize <= sizeof(__int64))
        return WBEM_E_OUT_OF_MEMORY;

    //
    // Extract the class hash
    //

    WCHAR wszClassHash[MAX_HASH_LEN+1];
    DWORD dwClassHashLen = MAX_HASH_LEN*sizeof(WCHAR);
    memcpy(wszClassHash, pBlob, MAX_HASH_LEN*sizeof(WCHAR));
    wszClassHash[MAX_HASH_LEN] = 0;

    __int64 nInstanceTime;
    memcpy(&nInstanceTime, pBlob + dwClassHashLen, sizeof(__int64));

    __int64 nOldClassTime;
    memcpy(&nOldClassTime, pBlob + dwClassHashLen + sizeof(__int64), 
            sizeof(__int64));

    BYTE* pInstancePart = pBlob + dwClassHashLen + sizeof(__int64)*2;
    DWORD dwInstancePartSize = dwSize - dwClassHashLen - sizeof(__int64)*2;

    //
    // Get the class def
    //

    _IWmiObject* pClass = NULL;
    __int64 nClassTime;
    bool bRead;
    hres = GetClassByHash(wszClassHash, false, &pClass, &nClassTime, &bRead);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pClass);

#ifdef _A51_TRACK_TIME
    _ASSERT(nClassTime <= nInstanceTime, L"Instance is older than its class");

    _ASSERT(nClassTime == nOldClassTime, L"Instance verified with the wrong "
                        L"class definition");
#endif

    //
    // Construct the instance
    //
                    
    _IWmiObject* pInst = NULL;
    hres = pClass->Merge(WMIOBJECT_MERGE_FLAG_INSTANCE, 
                            dwInstancePartSize, pInstancePart, &pInst);
    if(FAILED(hres))
        return hres;

    //
    // Decorate it
    //

    pInst->SetDecoration(m_wszMachineName, m_wsNamespace);

    A51TRACE(("Read instance from %S in namespace %S\n", 
        wszFileName, (LPCWSTR)m_wsNamespace));

    *ppInstance = pInst;
    return S_OK;
}

HRESULT CNamespaceHandle::FileToClass(LPCWSTR wszFileName, 
                                    _IWmiObject** ppClass, bool bClone,
                                    __int64* pnTime)
{
    HRESULT hres;

    //
    // Read the data from the file
    //

	DWORD dwSize;
	BYTE* pBlob;
	long lRes = GetFileCache()->ReadFile(wszFileName, &dwSize, &pBlob);
	if(lRes != ERROR_SUCCESS)
	{
		if(lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND)
			return WBEM_E_NOT_FOUND;
		else
			return WBEM_E_FAILED;
	}

	CTempFreeMe tfm1(pBlob, dwSize);

    _ASSERT(dwSize > sizeof(__int64), L"Class blob too short");
    if(dwSize <= sizeof(__int64))
        return WBEM_E_OUT_OF_MEMORY;

    //
    // Read off the superclass name
    //

    DWORD dwSuperLen;
    memcpy(&dwSuperLen, pBlob, sizeof(DWORD));
    LPWSTR wszSuperClass = (WCHAR*)TempAlloc(dwSuperLen*sizeof(WCHAR)+2);
	if (wszSuperClass == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe vdm1(wszSuperClass, dwSuperLen*sizeof(WCHAR)+2);

    wszSuperClass[dwSuperLen] = 0;
    memcpy(wszSuperClass, pBlob+sizeof(DWORD), dwSuperLen*sizeof(WCHAR));
    DWORD dwPrefixLen = sizeof(DWORD) + dwSuperLen*sizeof(WCHAR);

    __int64 nTime;
    memcpy(&nTime, pBlob + dwPrefixLen, sizeof(__int64));

    //
    // Get the superclass
    //

    _IWmiObject* pSuperClass;
    __int64 nSuperTime;
    bool bRead;
    hres = GetClassDirect(wszSuperClass, IID__IWmiObject, (void**)&pSuperClass,
                            false, &nSuperTime, &bRead);
    if(FAILED(hres))
        return WBEM_E_CRITICAL_ERROR;

    CReleaseMe rm1(pSuperClass);

    //_ASSERT(nSuperTime <= nTime, L"Parent class is older than child");

    DWORD dwClassLen = dwSize - dwPrefixLen - sizeof(__int64);
    _IWmiObject* pNewObj;
    hres = pSuperClass->Merge(0, dwClassLen, 
                              pBlob + dwPrefixLen + sizeof(__int64), &pNewObj);
    if(FAILED(hres))
        return hres;

    //
    // Decorate it
    //

    pNewObj->SetDecoration(m_wszMachineName, m_wsNamespace);

    //
    // Cache it!
    //

    VARIANT vClass;
    hres = pNewObj->Get(L"__CLASS", 0, &vClass, NULL, NULL);
    if(FAILED(hres) || V_VT(&vClass) != VT_BSTR)
        return WBEM_E_INVALID_OBJECT;
    CClearMe cm1(&vClass);

    A51TRACE(("Read class %S from disk in namespace %S\n",
        V_BSTR(&vClass), m_wsNamespace));

    m_pClassCache->AssertClass(pNewObj, V_BSTR(&vClass), bClone, nTime);

    *ppClass = pNewObj;
    if(pnTime)
        *pnTime = nTime;
    return S_OK;
}

HRESULT CNamespaceHandle::PutObject(
     REFIID riid,
    LPVOID pObj,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult,
	CEventCollector &aEvents
    )
{
    HRESULT hres;

    _IWmiObject* pObjEx = NULL;
    ((IUnknown*)pObj)->QueryInterface(IID__IWmiObject, (void**)&pObjEx);
	CReleaseMe rm1(pObjEx);
    
    if(pObjEx->IsObjectInstance() == S_OK)
    {
        hres = PutInstance(pObjEx, dwFlags, aEvents);
    }
    else
    {
        hres = PutClass(pObjEx, dwFlags, aEvents);
    }

    if(FAILED(hres))
        return hres;

    if(ppResult)
    {
        //
        // Got to get a handle
        //

        VARIANT v;
        hres = pObjEx->Get(L"__RELPATH", 0, &v, NULL, NULL);
        if(FAILED(hres) || V_VT(&v) != VT_BSTR)
            return WBEM_E_INVALID_OBJECT;

        hres = GetObjectHandleByPath(V_BSTR(&v), 0, WMIDB_HANDLE_TYPE_COOKIE, 
            ppResult);
        if(FAILED(hres))
            return hres;
    }
    return S_OK;
}

HRESULT CNamespaceHandle::PutInstance(_IWmiObject* pInst, DWORD dwFlags, 
                                        CEventCollector &aEvents)
{
    HRESULT hres;

    bool bDisableEvents = ((dwFlags & WMIDB_DISABLE_EVENTS)?true:false);

    //
    // Get the class name
    //

    VARIANT vClass;

    hres  = pInst->Get(L"__CLASS", 0, &vClass, NULL, NULL);
    if(FAILED(hres) || V_VT(&vClass) != VT_BSTR)
        return WBEM_E_INVALID_OBJECT;

    CClearMe cm1(&vClass);
    LPCWSTR wszClassName = V_BSTR(&vClass);

    //
	// Get the class so we can compare to make sure it is the same class used to
    // create the instance
    //

    _IWmiObject* pClass = NULL;
    __int64 nClassTime;
    hres = GetClassDirect(wszClassName, IID__IWmiObject, (void**)&pClass, 
                            false, &nClassTime);
    if(FAILED(hres))
        return hres;

    CReleaseMe rm2(pClass);

    if(wszClassName[0] != L'_')
	{
        hres = pInst->IsParentClass(0, pClass);
        if(FAILED(hres))
            return hres;

        if(hres == WBEM_S_FALSE)
            return WBEM_E_INVALID_CLASS;
    }

    //
    // Get the path
    //

    BSTR strKey = NULL;
    hres = pInst->GetKeyString(0, &strKey);
    if(FAILED(hres))
        return hres;
    CSysFreeMe sfm(strKey);

    A51TRACE(("Putting instance %S of class %S\n", strKey, wszClassName));

    //
    // Get the old copy
    //

    _IWmiObject* pOldInst = NULL;
    hres = GetInstanceByKey(wszClassName, strKey, IID__IWmiObject, 
            (void**)&pOldInst);
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
        return hres;
    CReleaseMe rm1(pOldInst);

	if ((dwFlags & WBEM_FLAG_CREATE_ONLY) && (hres != WBEM_E_NOT_FOUND))
		return WBEM_E_ALREADY_EXISTS;
	else if ((dwFlags & WBEM_FLAG_UPDATE_ONLY) && (hres != WBEM_S_NO_ERROR))
		return WBEM_E_NOT_FOUND;

    if(pOldInst)
    {
        // 
        // Check that this guy is of the same class as the new one
        //

        //
        // Get the class name
        //
    
        VARIANT vClass;
        hres  = pOldInst->Get(L"__CLASS", 0, &vClass, NULL, NULL);
        if(FAILED(hres))
            return hres;
        if(V_VT(&vClass) != VT_BSTR)
            return WBEM_E_INVALID_OBJECT;
    
        CClearMe cm1(&vClass);

        if(wbem_wcsicmp(V_BSTR(&vClass), wszClassName))
            return WBEM_E_INVALID_CLASS;
    }

    //
    // Construct the hash for the file
    //

    CFileName wszInstanceHash;
	if (wszInstanceHash == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    if(!Hash(strKey, wszInstanceHash))
        return WBEM_E_OUT_OF_MEMORY;

    //
    // Construct the path to the instance file in key root
    //

    CFileName wszInstanceFilePath;
	if (wszInstanceFilePath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructKeyRootDirFromClass(wszInstanceFilePath, wszClassName);
    if(FAILED(hres))
        return hres;

    wcscat(wszInstanceFilePath, L"\\" A51_INSTDEF_FILE_PREFIX);
    wcscat(wszInstanceFilePath, wszInstanceHash);

    //
    // Clean up what was there, if anything
    //

    if(pOldInst)   
    {
        //
        // Just delete it, but be careful not to delete the scope!
        //

        hres = DeleteInstanceSelf(wszInstanceFilePath, pOldInst, false);
        if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
            return hres;
    }
        
    //
    // Create the actual instance def under key root
    //

    hres = InstanceToFile(pInst, wszClassName, wszInstanceFilePath, nClassTime);
    if(FAILED(hres))
	    return hres;

    //
    // Create the link under the class
    //

    hres = WriteInstanceLinkByHash(wszClassName, wszInstanceHash);
    if(FAILED(hres))
	    return hres;

    //
    // Write the references
    //

    hres = WriteInstanceReferences(pInst, wszClassName, wszInstanceFilePath);
    if(FAILED(hres))
	    return hres;
    
    if(!bDisableEvents)
    {
        //
        // Fire Event
        //
    
        if(pInst->InheritsFrom(L"__Namespace") == S_OK)
        {
            //
            // Get the namespace name
            //

            VARIANT vClass;
            VariantInit(&vClass);
            CClearMe cm1(&vClass);

            hres = pInst->Get(L"Name", 0, &vClass, NULL, NULL);
            if(FAILED(hres) || V_VT(&vClass) != VT_BSTR)
                return WBEM_E_INVALID_OBJECT;

            if(pOldInst)
            {
                hres = FireEvent(aEvents, WBEM_EVENTTYPE_NamespaceModification,
                            V_BSTR(&vClass), pInst, pOldInst);
            }
            else
            {
                hres = FireEvent(aEvents, WBEM_EVENTTYPE_NamespaceCreation, 
                            V_BSTR(&vClass), pInst);
            }
        }
        else
        {
            if(pOldInst)
            {
                hres = FireEvent(aEvents, WBEM_EVENTTYPE_InstanceModification, 
                            wszClassName, pInst, pOldInst);
            }
            else
            {
                hres = FireEvent(aEvents, WBEM_EVENTTYPE_InstanceCreation, 
                            wszClassName, pInst);
            }
        }
    }

	A51TRACE(("PutInstance for %S of class %S succeeded\n", 
                strKey, wszClassName));
    return S_OK;
}

HRESULT CNamespaceHandle::GetKeyRoot(LPCWSTR wszClass, 
                                     TEMPFREE_ME LPWSTR* pwszKeyRootClass)
{
    HRESULT hres;

    //
    // Look in the cache first
    //

    hres = m_pClassCache->GetKeyRoot(wszClass, pwszKeyRootClass);
    if(hres == S_OK)
        return S_OK;
    else if(hres == WBEM_E_CANNOT_BE_ABSTRACT)
        return WBEM_E_CANNOT_BE_ABSTRACT;

    //
    // Walk up the tree getting classes until you hit an unkeyed one
    //

    WString wsThisName = wszClass;
    WString wsPreviousName;

    while(1)
    {
        _IWmiObject* pClass = NULL;

        hres = GetClassDirect(wsThisName, IID__IWmiObject, (void**)&pClass, 
                                false);
        if(FAILED(hres))
            return hres;
        CReleaseMe rm1(pClass);

        //
        // Check if this class is keyed
        //

        unsigned __int64 i64Flags = 0;
        hres = pClass->QueryObjectFlags(0, WMIOBJECT_GETOBJECT_LOFLAG_KEYED,
                                        &i64Flags);
        if(FAILED(hres))
            return hres;
    
        if(i64Flags == 0)
        {
            //
            // It is not keyed --- the previous class wins!
            //

            if(wsPreviousName.Length() == 0)    
                return WBEM_E_CANNOT_BE_ABSTRACT;

            DWORD dwLen = (wsPreviousName.Length()+1)*sizeof(WCHAR);
            *pwszKeyRootClass = (WCHAR*)TempAlloc(dwLen);
			if (*pwszKeyRootClass == NULL)
				return WBEM_E_OUT_OF_MEMORY;
            wcscpy(*pwszKeyRootClass, (LPCWSTR)wsPreviousName);
            return S_OK;
        }

        //
        // It is keyed --- get the parent and continue;
        //

        VARIANT vParent;
        VariantInit(&vParent);
        CClearMe cm(&vParent);
        hres = pClass->Get(L"__SUPERCLASS", 0, &vParent, NULL, NULL);
        if(FAILED(hres))
            return hres;

        if(V_VT(&vParent) != VT_BSTR)
        {
            //
            // We've reached the top --- return this class
            //
        
            DWORD dwLen = (wsThisName.Length()+1)*sizeof(WCHAR);
            *pwszKeyRootClass = (WCHAR*)TempAlloc(dwLen);
			if (*pwszKeyRootClass == NULL)
				return WBEM_E_OUT_OF_MEMORY;
            wcscpy(*pwszKeyRootClass, (LPCWSTR)wsThisName);
            return S_OK;
        }

        wsPreviousName = wsThisName;
        wsThisName = V_BSTR(&vParent);
    }

    // Never here

    DebugBreak();
    return WBEM_E_CRITICAL_ERROR;
}

HRESULT CNamespaceHandle::GetKeyRootByHash(LPCWSTR wszClassHash, 
                                     TEMPFREE_ME LPWSTR* pwszKeyRootClass)
{
    //
    // Look in the cache first
    //

    HRESULT hres = m_pClassCache->GetKeyRootByKey(wszClassHash, 
                                                  pwszKeyRootClass);
    if(hres == S_OK)
        return S_OK;
    else if(hres == WBEM_E_CANNOT_BE_ABSTRACT)
        return WBEM_E_CANNOT_BE_ABSTRACT;

    //
    // NOTE: this could be done more efficiently, but it happens once in a 
    // lifetime, so it's not worth the complexity.
    //

    //
    // Get Class definition
    //

    _IWmiObject* pClass = NULL;
    hres = GetClassByHash(wszClassHash, false, &pClass);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pClass);

    //
    // Get the class name
    //

    VARIANT vClass;

    hres  = pClass->Get(L"__CLASS", 0, &vClass, NULL, NULL);
    if(FAILED(hres) || (V_VT(&vClass) != VT_BSTR) || 
        !V_BSTR(&vClass) || !wcslen(V_BSTR(&vClass)))
    {
        return WBEM_E_INVALID_OBJECT;
    }

    CClearMe cm1(&vClass);
    LPCWSTR wszClassName = V_BSTR(&vClass);

    //
    // Now get it by name
    //

    return GetKeyRoot(wszClassName, pwszKeyRootClass);
}

HRESULT CNamespaceHandle::ConstructKeyRootDirFromClass(LPWSTR wszDir,
                                            LPCWSTR wszClassName)
{
    HRESULT hres;

    //
    // NULL class stands for "meta-class"
    //

    if(wszClassName == NULL)
        return ConstructKeyRootDirFromKeyRoot(wszDir, L"");

    //
    // Figure out the key root for the class
    //

    LPWSTR wszKeyRootClass = NULL;

    hres = GetKeyRoot(wszClassName, &wszKeyRootClass);
    if(FAILED(hres))
        return hres;
    if(wszKeyRootClass == NULL)
    {
        // Abstract class --- bad error
        return WBEM_E_INVALID_CLASS;
    }
    CTempFreeMe tfm(wszKeyRootClass, (wcslen(wszKeyRootClass)+1)*sizeof(WCHAR));

    return ConstructKeyRootDirFromKeyRoot(wszDir, wszKeyRootClass);
}

HRESULT CNamespaceHandle::ConstructKeyRootDirFromClassHash(LPWSTR wszDir,
                                            LPCWSTR wszClassHash)
{
    HRESULT hres;

    //
    // Figure out the key root for the class
    //

    LPWSTR wszKeyRootClass = NULL;

    hres = GetKeyRootByHash(wszClassHash, &wszKeyRootClass);
    if(FAILED(hres))
        return hres;
    if(wszKeyRootClass == NULL)
    {
        // Abstract class --- bad error
        return WBEM_E_INVALID_CLASS;
    }
    CTempFreeMe tfm(wszKeyRootClass, (wcslen(wszKeyRootClass)+1)*sizeof(WCHAR));

    return ConstructKeyRootDirFromKeyRoot(wszDir, wszKeyRootClass);
}

HRESULT CNamespaceHandle::ConstructKeyRootDirFromKeyRoot(LPWSTR wszDir, 
                                                LPCWSTR wszKeyRootClass)
{
    wcscpy(wszDir, m_wszInstanceRootDir);
    wszDir[m_lInstanceRootDirLen] = L'\\';
    wcscpy(wszDir+m_lInstanceRootDirLen+1, A51_KEYROOTINST_DIR_PREFIX);
    if(!Hash(wszKeyRootClass, 
             wszDir+m_lInstanceRootDirLen+wcslen(A51_KEYROOTINST_DIR_PREFIX)+1))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return S_OK;
}

HRESULT CNamespaceHandle::ConstructLinkDirFromClass(LPWSTR wszDir, 
                                                LPCWSTR wszClassName)
{
    wcscpy(wszDir, m_wszInstanceRootDir);
    wszDir[m_lInstanceRootDirLen] = L'\\';
    wcscpy(wszDir+m_lInstanceRootDirLen+1, A51_CLASSINST_DIR_PREFIX);
    if(!Hash(wszClassName, 
             wszDir+m_lInstanceRootDirLen+wcslen(A51_CLASSINST_DIR_PREFIX)+1))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return S_OK;
}

HRESULT CNamespaceHandle::ConstructLinkDirFromClassHash(LPWSTR wszDir, 
                                                LPCWSTR wszClassHash)
{
    wcscpy(wszDir, m_wszInstanceRootDir);
    wszDir[m_lInstanceRootDirLen] = L'\\';
    wcscpy(wszDir+m_lInstanceRootDirLen+1, A51_CLASSINST_DIR_PREFIX);
    wcscat(wszDir, wszClassHash);

    return S_OK;
}
    
                        

HRESULT CNamespaceHandle::WriteInstanceLinkByHash(LPCWSTR wszClassName,
                                            LPCWSTR wszInstanceHash)
{
    HRESULT hres;

    //
    // Construct the path to the link file under the class
    //

    CFileName wszInstanceLinkPath;
	if (wszInstanceLinkPath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructLinkDirFromClass(wszInstanceLinkPath, wszClassName);
    if(FAILED(hres))
        return hres;

    wcscat(wszInstanceLinkPath, L"\\" A51_INSTLINK_FILE_PREFIX);
    wcscat(wszInstanceLinkPath, wszInstanceHash);

    //
    // Create an empty file there
    //

    long lRes = GetFileCache()->WriteFile(wszInstanceLinkPath, 0, NULL);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    return S_OK;
}
    



HRESULT CNamespaceHandle::WriteInstanceReferences(_IWmiObject* pInst, 
                                                    LPCWSTR wszClassName,
                                                    LPCWSTR wszFilePath)
{
    HRESULT hres;

    pInst->BeginEnumeration(WBEM_FLAG_REFS_ONLY);
    
    VARIANT v;
    BSTR strName;
    while((hres = pInst->Next(0, &strName, &v, NULL, NULL)) == S_OK)
    {
        CSysFreeMe sfm(strName);
        CClearMe cm(&v);

        if(V_VT(&v) == VT_BSTR)
            WriteInstanceReference(wszFilePath, wszClassName, strName, 
                                        V_BSTR(&v));
    }

    pInst->EndEnumeration();
    
    return S_OK;
}

// NOTE: will clobber wszTargetPath
HRESULT CNamespaceHandle::ConstructReferenceDir(LPWSTR wszTargetPath,
                                            LPWSTR wszReferenceDir)
{
    //
    // Deconstruct the target path name so that we could get a directory
    // for it
    //

    DWORD dwKeySpace = (wcslen(wszTargetPath)+1) * sizeof(WCHAR);
    LPWSTR wszKey = (LPWSTR)TempAlloc(dwKeySpace);
    if(wszKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm2(wszKey, dwKeySpace);

    LPWSTR wszClassName = NULL;
    LPWSTR wszTargetNamespace = NULL;
    bool bIsClass;
    HRESULT hres = ComputeKeyFromPath(wszTargetPath, wszKey, &wszClassName,
                                        &bIsClass, &wszTargetNamespace);
    if(FAILED(hres))
        return hres;
    CTempFreeMe tfm1(wszClassName);
    wszTargetPath = NULL; // invalidated by parsing

    CTempFreeMe tfm3(wszTargetNamespace);

    //
    // Check if the target namespace is the same as ours
    //

    CNamespaceHandle* pTargetHandle = NULL;
    if(wszTargetNamespace && wbem_wcsicmp(wszTargetNamespace, m_wsNamespace))
    {
        //
        // It's different --- open it!
        //

        hres = m_pRepository->GetNamespaceHandle(wszTargetNamespace,
                                &pTargetHandle);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_WBEMCORE, "Unable to open target namespace "
                "'%S' in namespace '%S'\n", wszTargetNamespace,
                (LPCWSTR)m_wsNamespace));
            return hres;
        }
    }
    else
    {
        pTargetHandle = this;
        pTargetHandle->AddRef();
    }

    CReleaseMe rm1(pTargetHandle);

    if(bIsClass)
    {
        return pTargetHandle->ConstructReferenceDirFromKey(NULL, wszClassName, 
                                            wszReferenceDir);
    }
    else
    {
        return pTargetHandle->ConstructReferenceDirFromKey(wszClassName, wszKey,
                                            wszReferenceDir);
    }
}

HRESULT CNamespaceHandle::ConstructReferenceDirFromKey(LPCWSTR wszClassName,
                                LPCWSTR wszKey, LPWSTR wszReferenceDir)
{
    HRESULT hres;

    //
    // Construct the class directory for this instance
    //

    hres = ConstructKeyRootDirFromClass(wszReferenceDir, wszClassName);
    if(FAILED(hres))
        return hres;

    int nLen = wcslen(wszReferenceDir);
    wcscpy(wszReferenceDir+nLen, L"\\" A51_INSTREF_DIR_PREFIX);
    nLen += 1 + wcslen(A51_INSTREF_DIR_PREFIX);

    //
    // Write instance hash
    //

    if(!Hash(wszKey, wszReferenceDir+nLen))
        return WBEM_E_OUT_OF_MEMORY;

    return S_OK;
}

    

    
    
    
// NOTE: will clobber wszReference
HRESULT CNamespaceHandle::ConstructReferenceFileName(LPWSTR wszReference,
                        LPCWSTR wszReferringFile, LPWSTR wszReferenceFile)
{
    HRESULT hres = ConstructReferenceDir(wszReference, wszReferenceFile);
    if(FAILED(hres))
        return hres;
    wszReference = NULL; // invalid

    //
    // It is basically 
    // irrelevant, we should use a randomly constructed name.  Right now, we
    // use a hash of the class name of the referrer --- THIS IS A BUG, THE SAME
    // INSTANCE CAN POINT TO THE SAME ENDPOINT TWICE!!
    //

    wcscat(wszReferenceFile, L"\\"A51_REF_FILE_PREFIX);
    DWORD dwLen = wcslen(wszReferenceFile);
    if (!Hash(wszReferringFile, wszReferenceFile+dwLen))
		return WBEM_E_OUT_OF_MEMORY;
    return S_OK;
}

// NOTE: will clobber wszReference
HRESULT CNamespaceHandle::WriteInstanceReference(LPCWSTR wszReferringFile,
                            LPCWSTR wszReferringClass,
                            LPCWSTR wszReferringProp, LPWSTR wszReference)
{
	HRESULT hres;

    //
    // Figure out the name of the file for the reference.  
    //

    CFileName wszReferenceFile;
	if (wszReferenceFile == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructReferenceFileName(wszReference, wszReferringFile, 
                                wszReferenceFile);
	if(FAILED(hres))
	{
		if(hres == WBEM_E_NOT_FOUND)
		{
			//
			// Oh joy. A reference to an instance of a *class* that does not
			// exist (not a non-existence instance, those are normal).
			// Forget it (BUGBUG)
			//

			return S_OK;
		}
		else
			return hres;
	}
	
    //
    // Construct the buffer
    //

    DWORD dwTotalLen = 4 * sizeof(DWORD) + 
                (wcslen(wszReferringClass) + wcslen(wszReferringProp) + 
                    wcslen(wszReferringFile) - m_pRepository->GetRootDirLen() + 
                    wcslen(m_wsNamespace) + 4) 
                        * sizeof(WCHAR);

    BYTE* pBuffer = (BYTE*)TempAlloc(dwTotalLen);
	if (pBuffer == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe vdm(pBuffer, dwTotalLen);

    BYTE* pCurrent = pBuffer;
    DWORD dwStringLen;

    //
    // Write namespace name
    //

    dwStringLen = wcslen(m_wsNamespace);
    memcpy(pCurrent, &dwStringLen, sizeof(DWORD));
    pCurrent += sizeof(DWORD);

    memcpy(pCurrent, m_wsNamespace, sizeof(WCHAR)*dwStringLen);
    pCurrent += sizeof(WCHAR)*dwStringLen;

    //
    // Write the referring class name
    //

    dwStringLen = wcslen(wszReferringClass);
    memcpy(pCurrent, &dwStringLen, sizeof(DWORD));
    pCurrent += sizeof(DWORD);
    
    memcpy(pCurrent, wszReferringClass, sizeof(WCHAR)*dwStringLen);
    pCurrent += sizeof(WCHAR)*dwStringLen;

    //
    // Write referring property name
    //

    dwStringLen = wcslen(wszReferringProp);
    memcpy(pCurrent, &dwStringLen, sizeof(DWORD));
    pCurrent += sizeof(DWORD);
    
    memcpy(pCurrent, wszReferringProp, sizeof(WCHAR)*dwStringLen);
    pCurrent += sizeof(WCHAR)*dwStringLen;

    //
    // Write referring file name minus the database root path. Notice that we 
    // cannot skip the namespace-specific prefix lest we break cross-namespace
    // associations
    //

    dwStringLen = wcslen(wszReferringFile) - m_pRepository->GetRootDirLen();
    memcpy(pCurrent, &dwStringLen, sizeof(DWORD));
    pCurrent += sizeof(DWORD);
    
    memcpy(pCurrent, wszReferringFile + m_pRepository->GetRootDirLen(), 
        sizeof(WCHAR)*dwStringLen);
    pCurrent += sizeof(WCHAR)*dwStringLen;

    //
    // All done --- create the file
    //

    long lRes = GetFileCache()->WriteFile(wszReferenceFile, dwTotalLen,
                    pBuffer);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;
    
    return S_OK;
}

    
    
    
    

    
    
    



HRESULT CNamespaceHandle::PutClass(_IWmiObject* pClass, DWORD dwFlags, 
                                        CEventCollector &aEvents)
{
    HRESULT hres;

    bool bDisableEvents = ((dwFlags & WMIDB_DISABLE_EVENTS)?true:false);

    //
    // Get the class name
    //

    VARIANT vClass;

    hres  = pClass->Get(L"__CLASS", 0, &vClass, NULL, NULL);
    if(FAILED(hres) || (V_VT(&vClass) != VT_BSTR) || 
        !V_BSTR(&vClass) || !wcslen(V_BSTR(&vClass)))
    {
        return WBEM_E_INVALID_OBJECT;
    }

    CClearMe cm1(&vClass);
    LPCWSTR wszClassName = V_BSTR(&vClass);

    //
	// Check to make sure this class was created from a valid parent class
    //

    VARIANT vSuperClass;

    hres  = pClass->Get(L"__SUPERCLASS", 0, &vSuperClass, NULL, NULL);
    if (FAILED(hres))
        return WBEM_E_INVALID_OBJECT;
    CClearMe cm2(&vSuperClass);

    _IWmiObject* pSuperClass = NULL;
    if ((V_VT(&vSuperClass) == VT_BSTR) && V_BSTR(&vSuperClass) && 
        wcslen(V_BSTR(&vSuperClass)))
    {
        LPCWSTR wszSuperClassName = V_BSTR(&vSuperClass);

        hres = GetClassDirect(wszSuperClassName, IID__IWmiObject, 
                                (void**)&pSuperClass, false); // do not clone
        if (hres == WBEM_E_NOT_FOUND)
            return WBEM_E_INVALID_SUPERCLASS;
        if (FAILED(hres))
            return hres;

	    if(wszClassName[0] != L'_')
	    {
            hres = pClass->IsParentClass(0, pSuperClass);
            if(FAILED(hres))
                return hres;
            if(hres == WBEM_S_FALSE)
                return WBEM_E_INVALID_SUPERCLASS;
        }
	}
    CReleaseMe rm(pSuperClass);

    //
    // Retrieve the previous definition, if any
    //

    _IWmiObject* pOldClass = NULL;
    __int64 nOldTime = 0;
    hres = GetClassDirect(wszClassName, IID__IWmiObject, (void**)&pOldClass,
                            false, &nOldTime); // do not clone
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
        return hres;
	CReleaseMe rm1(pOldClass);

	if ((dwFlags & WBEM_FLAG_CREATE_ONLY) && (hres !=  WBEM_E_NOT_FOUND))
		return WBEM_E_ALREADY_EXISTS;

	if ((dwFlags & WBEM_FLAG_UPDATE_ONLY) && (FAILED(hres)))
		return WBEM_E_NOT_FOUND;

    //
	// If the class exists, we need to check the update scenarios to make sure 
    // we do not break any
    //

	bool bNoClassChangeDetected = false;
	if (pOldClass)
	{
		hres = pClass->CompareDerivedMostClass(0, pOldClass);
		if ((hres != WBEM_S_FALSE) && (hres != WBEM_S_NO_ERROR))
			return hres;
		else if (hres == WBEM_S_NO_ERROR)
			bNoClassChangeDetected = true;
	}

    A51TRACE(("Putting class %S, dwFlags=0x%X.  Old was %p, changed=%d\n",
                wszClassName, dwFlags, pOldClass, !bNoClassChangeDetected));

	if (!bNoClassChangeDetected)
	{
		if (pOldClass != NULL) 
		{
			hres = CanClassBeUpdatedCompatible(dwFlags, wszClassName, pOldClass,
                                                pClass);

			if (((hres == WBEM_E_CLASS_HAS_CHILDREN) || 
                 (hres == WBEM_E_CLASS_HAS_INSTANCES)) &&
				((dwFlags & WBEM_FLAG_UPDATE_SAFE_MODE) || 
                 (dwFlags & WBEM_FLAG_UPDATE_FORCE_MODE)))
			{
                //
				// This is a safe mode or force mode update which takes more 
                // than a compatible update to carry out the operation
                //

				return UpdateClassSafeForce(pSuperClass, dwFlags, wszClassName, 
                                            pOldClass, pClass, aEvents);
			}
			else if (FAILED(hres))
			{
				return hres;
			}
		}

        //
        // Either there was no previous copy, or it is compatible with the new
        // one, so we can perform a compatible update
        //

		hres = UpdateClassCompatible(pSuperClass, wszClassName, pClass, 
                                            pOldClass, nOldTime);
		if (FAILED(hres))
			return hres;

	}

    if(!bDisableEvents)
    {
        if(pOldClass)
        {
            hres = FireEvent(aEvents, WBEM_EVENTTYPE_ClassModification, 
                                wszClassName, pClass, pOldClass);
        }
        else
        {
            hres = FireEvent(aEvents, WBEM_EVENTTYPE_ClassCreation, 
                                wszClassName, pClass);
        }
    }

    return S_OK;
}

HRESULT CNamespaceHandle::UpdateClassCompatible(_IWmiObject* pSuperClass, 
            LPCWSTR wszClassName, _IWmiObject *pClass, _IWmiObject *pOldClass, 
            __int64 nFakeUpdateTime)
{
	HRESULT hres;

	//
	// Construct the path for the file
	//
    CFileName wszHash;
    if (wszHash == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    if(!A51Hash(wszClassName, wszHash))
        return WBEM_E_OUT_OF_MEMORY;

	A51TRACE(("Class %S has has %S\n", wszClassName, wszHash));

	return UpdateClassCompatibleHash(pSuperClass, wszHash, pClass, pOldClass, 
                                        nFakeUpdateTime);
}

HRESULT CNamespaceHandle::UpdateClassCompatibleHash(_IWmiObject* pSuperClass,
            LPCWSTR wszClassHash, _IWmiObject *pClass, _IWmiObject *pOldClass, 
            __int64 nFakeUpdateTime)
{
	HRESULT hres;

	CFileName wszFileName;
	CFileName wszFilePath;
	if ((wszFileName == NULL) || (wszFilePath == NULL))
		return WBEM_E_OUT_OF_MEMORY;

	wcscpy(wszFileName, A51_CLASSDEF_FILE_PREFIX);
	wcscat(wszFileName, wszClassHash);

	wcscpy(wszFilePath, m_wszClassRootDir);
	wcscat(wszFilePath, L"\\");
	wcscat(wszFilePath, wszFileName);

	//
	// Write it into the file
	//

	hres = ClassToFile(pSuperClass, pClass, wszFilePath, 
                        nFakeUpdateTime);
	if(FAILED(hres))
		return hres;

	//
	// Add all needed references --- parent, pointers, etc	
	//

	if (pOldClass)
	{
		VARIANT v;
		VariantInit(&v);
		hres = pClass->Get(L"__CLASS", 0, &v, NULL, NULL);
		CClearMe cm(&v);

		if(SUCCEEDED(hres))
		{
			hres = EraseClassRelationships(V_BSTR(&v), pOldClass, wszFileName);
		}
		if (FAILED(hres))
			return hres;
	}

	hres = WriteClassRelationships(pClass, wszFileName);

	return hres;

}



HRESULT CNamespaceHandle::UpdateClassSafeForce(_IWmiObject* pSuperClass,
            DWORD dwFlags, LPCWSTR wszClassName, _IWmiObject *pOldClass, 
            _IWmiObject *pNewClass, CEventCollector &aEvents)
{
    //
	// First validate that we can update the class...
    //
    // TBD: We don't really need this anymore --- just try and abort if need be
    //

	HRESULT hres = UpdateClassAggressively(pSuperClass, dwFlags, wszClassName, 
                                        pNewClass, pOldClass, true, aEvents);

    //If this is a force mode update and we failed for anything other than out of memory 
    //then we should delete the class and try again.
    if (FAILED(hres) && (hres != WBEM_E_OUT_OF_MEMORY) && (dwFlags & WBEM_FLAG_UPDATE_FORCE_MODE))
    {
        //We need to delete the class and try again.
        hres = DeleteClass(wszClassName, aEvents);
        if (SUCCEEDED(hres))
        {
	        hres = UpdateClassAggressively(pSuperClass, dwFlags, wszClassName, 
                                                pNewClass, pOldClass, true, aEvents);
        }
    }
	if (SUCCEEDED(hres))
	{
        //
		// The validation that we can update succeeded, so now we need to do 
        // and do it!
        //
    
		hres = UpdateClassAggressively(pSuperClass, dwFlags, wszClassName, 
                                        pNewClass, pOldClass, false, aEvents);
	}

	return hres;
}

HRESULT CNamespaceHandle::UpdateClassAggressively(_IWmiObject* pSuperClass,
           DWORD dwFlags, LPCWSTR wszClassName, _IWmiObject *pNewClass, 
           _IWmiObject *pOldClass, bool bValidateOnly, CEventCollector &aEvents)
{
	HRESULT hres = WBEM_S_NO_ERROR;

	if (bValidateOnly && ((dwFlags & WBEM_FLAG_UPDATE_FORCE_MODE) == 0))
	{
        //
		// If we have instances we need to quit as we cannot update them.
        // 

		hres = ClassHasInstances(wszClassName);
		if (hres == WBEM_S_NO_ERROR)
		{
			hres = WBEM_E_CLASS_HAS_INSTANCES;
		}
		else if (hres == WBEM_S_FALSE)
			hres = WBEM_S_NO_ERROR;
	}
	else if (!bValidateOnly && (dwFlags & WBEM_FLAG_UPDATE_FORCE_MODE))
	{
        //
		// We need to delete the instances
        //

		hres = DeleteClassInstances(wszClassName, pOldClass, aEvents);
	}

	if (SUCCEEDED(hres))
	{
        //
		// Retrieve all child classes and update them
        //

		CWStringArray wsChildHashes;
		hres = GetChildHashes(wszClassName, wsChildHashes);
		if (SUCCEEDED(hres))
		{
			for (int i = 0; i != wsChildHashes.Size(); i++)
			{
				hres = UpdateChildClassAggressively(dwFlags, wsChildHashes[i], 
                                            pNewClass, bValidateOnly, aEvents);
				if (FAILED(hres))
					break;
			}
		}
	}

    //
	// Now we need to write the class back, update class refs etc.
    //

	if (SUCCEEDED(hres) && !bValidateOnly)
	{
		hres = UpdateClassCompatible(pSuperClass, wszClassName, pNewClass, 
                                        pOldClass);

		//Generate the class modification event...
		if(!(dwFlags & WMIDB_DISABLE_EVENTS))
		{
			hres = FireEvent(aEvents, WBEM_EVENTTYPE_ClassModification, 
									wszClassName, pNewClass, pOldClass);
		}

	}

	return hres;
}

HRESULT CNamespaceHandle::UpdateChildClassAggressively(DWORD dwFlags, 
            LPCWSTR wszClassHash, _IWmiObject *pNewParentClass, 
            bool bValidateOnly, CEventCollector &aEvents)
{
	HRESULT hres = WBEM_S_NO_ERROR;

	if (bValidateOnly && ((dwFlags & WBEM_FLAG_UPDATE_FORCE_MODE) == 0))
	{
		hres = ClassHasInstancesFromClassHash(wszClassHash);
		if (hres == WBEM_S_NO_ERROR)
		{
			hres = WBEM_E_CLASS_HAS_INSTANCES;
		}
		else if (hres == WBEM_S_FALSE)
			hres = WBEM_S_NO_ERROR;
	}

    //
	// Get the old class definition
    //

	_IWmiObject *pOldClass = NULL;
	if (SUCCEEDED(hres))
	{
		hres = GetClassByHash(wszClassHash, true, &pOldClass);
	}
	CReleaseMe rm1(pOldClass);

	if (SUCCEEDED(hres))
	{
		if (!bValidateOnly && (dwFlags & WBEM_FLAG_UPDATE_FORCE_MODE))
		{
            //
            // Need to delete all its instances, if any
            //

			VARIANT v;
			VariantInit(&v);
			hres = pOldClass->Get(L"__CLASS", 0, &v, NULL, NULL);
			CClearMe cm(&v);

			if (SUCCEEDED(hres))
			{
				hres = DeleteClassInstances(V_BSTR(&v), pOldClass, aEvents);
			}
		}
	}

    //
	// Update the existing class definition to work with the new parent class
    //

	_IWmiObject *pNewClass = NULL;
	if (SUCCEEDED(hres))
	{
		hres = pNewParentClass->Update(pOldClass, dwFlags, &pNewClass);
	}
	CReleaseMe rm2(pNewClass);

    //
	// Now we have to recurse through all child classes and do the same
    //

	if (SUCCEEDED(hres))
	{
		CWStringArray wsChildHashes;
		hres = GetChildHashesByHash(wszClassHash, wsChildHashes);
		if (SUCCEEDED(hres))
		{
			for (int i = 0; i != wsChildHashes.Size(); i++)
			{
				hres = UpdateChildClassAggressively(dwFlags, wsChildHashes[i], 
                                            pNewClass, bValidateOnly, aEvents);
				if (FAILED(hres))
					break;
			}
		}
	}

    // 
	// Now we need to write the class back, update class refs etc
    //

	if (SUCCEEDED(hres) && !bValidateOnly)
	{
		hres = UpdateClassCompatibleHash(pNewParentClass, wszClassHash, 
                                            pNewClass, pOldClass);
	}
	return hres;
}

HRESULT CNamespaceHandle::CanClassBeUpdatedCompatible(DWORD dwFlags, 
        LPCWSTR wszClassName, _IWmiObject *pOldClass, _IWmiObject *pNewClass)
{
	HRESULT hres;
	{
        //
		// Do we have subclasses?
        //

		hres = ClassHasChildren(wszClassName);
		if (hres == WBEM_S_NO_ERROR)
			hres = WBEM_E_CLASS_HAS_CHILDREN;
		else if (hres == WBEM_S_FALSE)
			hres = WBEM_S_NO_ERROR;
	}

	if (SUCCEEDED(hres))
	{
        //
		// Do we have instances belonging to this class?  Don't even need to
		// worry about sub-classes because we know we have none at this point!
        //

		hres = ClassHasInstances(wszClassName);
		if (hres == WBEM_S_NO_ERROR)
			hres = WBEM_E_CLASS_HAS_INSTANCES;
		else if (hres == WBEM_S_FALSE)
			hres = WBEM_S_NO_ERROR;
	}

	if ((hres == WBEM_E_CLASS_HAS_CHILDREN) || 
        (hres == WBEM_E_CLASS_HAS_INSTANCES))
	{
        //
		// Can we reconcile this class safely?
        //

		HRESULT hres2 = pOldClass->ReconcileWith(
                            WMIOBJECT_RECONCILE_FLAG_TESTRECONCILE, pNewClass);
		if (hres2 == WBEM_S_NO_ERROR)
			hres = WBEM_S_NO_ERROR;
	}

	return hres;
}

HRESULT CNamespaceHandle::FireEvent(CEventCollector &aEvents, 
									DWORD dwType, LPCWSTR wszArg1,
                                    _IWmiObject* pObj1, _IWmiObject* pObj2)
{
	try
	{
		CRepEvent *pEvent = new CRepEvent(dwType, m_wsFullNamespace, wszArg1, 
                                            pObj1, pObj2);
		if (pEvent == NULL)
			return WBEM_E_OUT_OF_MEMORY;
		if (!aEvents.AddEvent(pEvent))
        {
            delete pEvent;
			return WBEM_E_OUT_OF_MEMORY;
        }
		return WBEM_S_NO_ERROR;
	}
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
}
HRESULT CNamespaceHandle::SendEvents(CEventCollector &aEvents)
{
    aEvents.SendEvents(m_pRepository->GetCoreServices());

    //
    // Ignore ESS return codes --- they do not invalidate the operation
    //

	return WBEM_S_NO_ERROR;
}

HRESULT CNamespaceHandle::WriteClassRelationships(_IWmiObject* pClass,
                                                LPCWSTR wszFileName)
{
    HRESULT hres;

    //
    // Get the parent
    //

    VARIANT v;
    VariantInit(&v);
    hres = pClass->Get(L"__SUPERCLASS", 0, &v, NULL, NULL);
    CClearMe cm(&v);

    if(FAILED(hres))
        return hres;

    if(V_VT(&v) == VT_BSTR)
        WriteParentChildRelationship(wszFileName, V_BSTR(&v));
    else
        WriteParentChildRelationship(wszFileName, L"");

    //
    // Write references
    //

    hres = pClass->BeginEnumeration(WBEM_FLAG_REFS_ONLY);
    if(FAILED(hres))
        return hres;
    
    BSTR strName = NULL;
    while((hres = pClass->Next(0, &strName, NULL, NULL, NULL)) == S_OK)
    {
        CSysFreeMe sfm(strName);

        WriteClassReference(pClass, wszFileName, strName);
    }

    pClass->EndEnumeration();

    return S_OK;
}

HRESULT CNamespaceHandle::WriteClassReference(_IWmiObject* pReferringClass,
                            LPCWSTR wszReferringFile,
                            LPCWSTR wszReferringProp)
{
	HRESULT hres;

    //
    // Figure out the class we are pointing to
    //

    DWORD dwSize = 0;
    DWORD dwFlavor = 0;
    CIMTYPE ct;
    hres = pReferringClass->GetPropQual(wszReferringProp, L"CIMTYPE", 0, 0,
            &ct, &dwFlavor, &dwSize, NULL);
    if(dwSize == 0)
        return WBEM_E_OUT_OF_MEMORY;

    LPWSTR wszQual = (WCHAR*)TempAlloc(dwSize);
    if(wszQual == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszQual, dwSize);

    hres = pReferringClass->GetPropQual(wszReferringProp, L"CIMTYPE", 0, dwSize,
            &ct, &dwFlavor, &dwSize, wszQual);
    if(FAILED(hres))
        return hres;
    
    //
    // Parse out the class name
    //

    WCHAR* pwcColon = wcschr(wszQual, L':');
    if(pwcColon == NULL)
        return S_OK; // untyped reference requires no bookkeeping

    LPCWSTR wszReferredToClass = pwcColon+1;

    //
    // Figure out the name of the file for the reference.  
    //

    CFileName wszReferenceFile;
	if (wszReferenceFile == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassReferenceFileName(wszReferredToClass, 
                                wszReferringFile, wszReferringProp,
                                wszReferenceFile);
    if(FAILED(hres))
        return hres;

    //
    // Create the empty file
    //

    long lRes = GetFileCache()->WriteFile(wszReferenceFile, 0, NULL);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    return S_OK;
}

HRESULT CNamespaceHandle::WriteParentChildRelationship(
                            LPCWSTR wszChildFileName, LPCWSTR wszParentName)
{
    CFileName wszParentChildFileName;
	if (wszParentChildFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    HRESULT hres = ConstructParentChildFileName(wszChildFileName,
                                                wszParentName,
												wszParentChildFileName);

    //
    // Create the file
    //

    long lRes = GetFileCache()->WriteFile(wszParentChildFileName, 0, NULL);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    return S_OK;
}

HRESULT CNamespaceHandle::ConstructParentChildFileName(
                            LPCWSTR wszChildFileName, LPCWSTR wszParentName,
							LPWSTR wszParentChildFileName)
{
    //
    // Construct the name of the directory where the parent class keeps its
    // children
    //

    HRESULT hres = ConstructClassRelationshipsDir(wszParentName, 
                                                    wszParentChildFileName);
    if(FAILED(hres))
        return hres;

    //
    // Append the filename of the child, but substituting the child-class prefix
    // for the class-def prefix
    //

    wcscat(wszParentChildFileName, L"\\" A51_CHILDCLASS_FILE_PREFIX);
    wcscat(wszParentChildFileName, 
        wszChildFileName + wcslen(A51_CLASSDEF_FILE_PREFIX));

    return S_OK;
}


HRESULT CNamespaceHandle::ConstructClassRelationshipsDir(LPCWSTR wszClassName,
                                LPWSTR wszDirPath)
{
    wcscpy(wszDirPath, m_wszClassRootDir);
    wcscpy(wszDirPath + m_lClassRootDirLen, L"\\" A51_CLASSRELATION_DIR_PREFIX);
    
    if(!Hash(wszClassName, 
        wszDirPath + m_lClassRootDirLen + 1 + wcslen(A51_CLASSRELATION_DIR_PREFIX)))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    return S_OK;
}

HRESULT CNamespaceHandle::ConstructClassRelationshipsDirFromHash(
                                LPCWSTR wszHash, LPWSTR wszDirPath)
{
    wcscpy(wszDirPath, m_wszClassRootDir);
    wcscpy(wszDirPath + m_lClassRootDirLen, L"\\" A51_CLASSRELATION_DIR_PREFIX);
    wcscpy(wszDirPath + m_lClassRootDirLen + 1 +wcslen(A51_CLASSRELATION_DIR_PREFIX),
            wszHash);
    return S_OK;
}

HRESULT CNamespaceHandle::ConstructClassReferenceFileName(
                                LPCWSTR wszReferredToClass,
                                LPCWSTR wszReferringFile, 
                                LPCWSTR wszReferringProp,
                                LPWSTR wszFileName)
{
    HRESULT hres;

    hres = ConstructClassRelationshipsDir(wszReferredToClass, wszFileName);
    if(FAILED(hres))
        return hres;

    //
    // Extract the portion of the referring file containing the class hash
    //

    WCHAR* pwcLastUnderscore = wcsrchr(wszReferringFile, L'_');
    if(pwcLastUnderscore == NULL)
        return WBEM_E_CRITICAL_ERROR;
    LPCWSTR wszReferringClassHash = pwcLastUnderscore+1;

    wcscat(wszFileName, L"\\" A51_REF_FILE_PREFIX);
    wcscat(wszFileName, wszReferringClassHash);
    return S_OK;
}

HRESULT CNamespaceHandle::DeleteObject(
     DWORD dwFlags,
     REFIID riid,
     LPVOID pObj,
	 CEventCollector &aEvents
    )
{
	DebugBreak();
	return E_NOTIMPL;
}

HRESULT CNamespaceHandle::DeleteObjectByPath(DWORD dwFlags,	LPWSTR wszPath, 
                                                CEventCollector &aEvents)
{
	HRESULT hres;

    //
    // Get the key from path
    //

    DWORD dwLen = wcslen(wszPath)*sizeof(WCHAR)+2;
    LPWSTR wszKey = (WCHAR*)TempAlloc(dwLen);
    if(wszKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszKey, dwLen);

    bool bIsClass;
    LPWSTR wszClassName = NULL;
    hres = ComputeKeyFromPath(wszPath, wszKey, &wszClassName, &bIsClass);
    if(FAILED(hres))
        return hres;
    CTempFreeMe tfm1(wszClassName, (wcslen(wszClassName)+1) * sizeof(WCHAR*));

    if(bIsClass)
    {
        return DeleteClass(wszClassName, aEvents);
    }
    else
    {
        return DeleteInstance(wszClassName, wszKey, aEvents);
    }
}

HRESULT CNamespaceHandle::DeleteInstance(LPCWSTR wszClassName, LPCWSTR wszKey, 
                                            CEventCollector &aEvents)
{
    HRESULT hres;

    //
    // Get Class definition
    //

    _IWmiObject* pClass = NULL;
    hres = GetClassDirect(wszClassName, IID__IWmiObject, (void**)&pClass, 
                            false);
    if(FAILED(hres))
        return hres;

    CReleaseMe rm1(pClass);

    //
    // Create its directory
    //

    CFileName wszFilePath;
	if (wszFilePath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructKeyRootDirFromClass(wszFilePath, wszClassName);
    if(FAILED(hres))
        return hres;
    
    //
    // Construct the path for the file
    //

    CFileName wszFileName;
	if (wszFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructInstanceDefName(wszFileName, wszKey);
    if(FAILED(hres))
        return hres;

    wcscat(wszFilePath, L"\\");
    wcscat(wszFilePath, wszFileName);

    _IWmiObject* pInst;
    hres = FileToInstance(wszFilePath, &pInst);
    if(FAILED(hres))
        return hres;
	CReleaseMe rm2(pInst);

    if(pInst->InheritsFrom(L"__Namespace") == S_OK)
    {
		//Make sure this is not a deletion of the root\default namespace
		VARIANT vName;
		VariantInit(&vName);
	    CClearMe cm1(&vName);
		hres = pInst->Get(L"Name", 0, &vName, NULL, NULL);
		if(FAILED(hres))
			return WBEM_E_INVALID_OBJECT;

		LPCWSTR wszName = V_BSTR(&vName);
		if ((_wcsicmp(m_wsFullNamespace, L"\\\\.\\root") == 0) && (_wcsicmp(wszName, L"default") == 0))
			return WBEM_E_ACCESS_DENIED;
	}
	hres = DeleteInstanceByFile(wszFilePath, pInst, false, aEvents);
    if(FAILED(hres))
        return hres;

    //
    // Fire an event
    //

    if(pInst->InheritsFrom(L"__Namespace") == S_OK)
    {
        //
        // There is no need to do anything --- deletion of namespaces
        // automatically fires events in DeleteInstanceByFile (because we need
        // to accomplish it in the case of deleting a class derived from 
        // __NAMESPACE.
        //

    }
    else
    {
        hres = FireEvent(aEvents, WBEM_EVENTTYPE_InstanceDeletion, wszClassName,
                        pInst);
    }

	A51TRACE(("DeleteInstance for class %S succeeded\n", wszClassName));
    return S_OK;
}

HRESULT CNamespaceHandle::DeleteInstanceByFile(LPCWSTR wszFilePath, 
                                _IWmiObject* pInst, bool bClassDeletion,
                                CEventCollector &aEvents)
{
    HRESULT hres;

    hres = DeleteInstanceSelf(wszFilePath, pInst, bClassDeletion);
    if(FAILED(hres))
        return hres;

    hres = DeleteInstanceAsScope(pInst, aEvents);
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
        return hres;

    return S_OK;
}

HRESULT CNamespaceHandle::DeleteInstanceSelf(LPCWSTR wszFilePath, 
                                            _IWmiObject* pInst,
                                            bool bClassDeletion)
{
    HRESULT hres;

    //
    // Delete the file
    //

    long lRes = GetFileCache()->DeleteFile(wszFilePath);
    if(lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND)
        return WBEM_E_NOT_FOUND;
    else if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    hres = DeleteInstanceLink(pInst, wszFilePath);
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
        return hres;

    hres = DeleteInstanceReferences(pInst, wszFilePath);
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
        return hres;

    if(bClassDeletion)
    {
        //
        // We need to remove all dangling references to this instance, 
        // because they make no sense once the class is deleted --- we don't
        // know what key structure the new class will even have.  In the future,
        // we'll want to move these references to some class-wide location
        //

        hres = DeleteInstanceBackReferences(wszFilePath);
        if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
            return hres;
    }

    return S_OK;
}

HRESULT CNamespaceHandle::ConstructReferenceDirFromFilePath(
                                LPCWSTR wszFilePath, LPWSTR wszReferenceDir)
{
    //
    // It's the same, only with INSTDEF_FILE_PREFIX replaced with 
    // INSTREF_DIR_PREFIX
    //

    CFileName wszEnding;
	if (wszEnding == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    WCHAR* pwcLastSlash = wcsrchr(wszFilePath, L'\\');
    if(pwcLastSlash == NULL)
        return WBEM_E_FAILED;
    
    wcscpy(wszEnding, pwcLastSlash + 1 + wcslen(A51_INSTDEF_FILE_PREFIX));

    wcscpy(wszReferenceDir, wszFilePath);
    wszReferenceDir[(pwcLastSlash+1)-wszFilePath] = 0;

    wcscat(wszReferenceDir, A51_INSTREF_DIR_PREFIX);
    wcscat(wszReferenceDir, wszEnding);
    return S_OK;
}

HRESULT CNamespaceHandle::DeleteInstanceBackReferences(LPCWSTR wszFilePath)
{
    HRESULT hres;

    CFileName wszReferenceDir;
	if (wszReferenceDir == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructReferenceDirFromFilePath(wszFilePath, wszReferenceDir);
    if(FAILED(hres))
        return hres;
    wcscat(wszReferenceDir, L"\\");

    CFileName wszReferencePrefix;
	if (wszReferencePrefix == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    wcscpy(wszReferencePrefix, wszReferenceDir);
    wcscat(wszReferencePrefix, A51_REF_FILE_PREFIX);

    // 
    // Enumerate all files in it
    //

    WIN32_FIND_DATAW fd;
    void* hSearch;
    long lRes = GetFileCache()->FindFirst(wszReferencePrefix, &fd, &hSearch);
    if(lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND)
    {
        //
        // No files in dir --- no problem
        //
        return WBEM_S_NO_ERROR;
    }
    else if(lRes != ERROR_SUCCESS)
    {
        return WBEM_E_FAILED;
    }

    CFileCache::CFindCloseMe fcm(GetFileCache(), hSearch);

    //
    // Prepare a buffer for file path
    //

    CFileName wszFullFileName;
	if (wszFullFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    wcscpy(wszFullFileName, wszReferenceDir);
    long lDirLen = wcslen(wszFullFileName);

    do
    {
        if(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            continue;

        wcscpy(wszFullFileName+lDirLen, fd.cFileName);

        long lRes = GetFileCache()->DeleteFile(wszFullFileName);
        if(lRes != ERROR_SUCCESS)
        {
            ERRORTRACE((LOG_WBEMCORE, "Cannot delete reference file '%S' with "
                "error code %d\n", wszFullFileName, lRes));
            return WBEM_E_FAILED;
        }
    }
    while(GetFileCache()->FindNext(hSearch, &fd) == ERROR_SUCCESS);

    return S_OK;
}



HRESULT CNamespaceHandle::DeleteInstanceLink(_IWmiObject* pInst,
                                                LPCWSTR wszInstanceDefFilePath)
{
    HRESULT hres;

    //
    // Get the class name
    //
    
    VARIANT vClass;
    VariantInit(&vClass);
    CClearMe cm1(&vClass);
    
    hres = pInst->Get(L"__CLASS", 0, &vClass, NULL, NULL);
    if(FAILED(hres))
        return WBEM_E_INVALID_OBJECT;

    LPCWSTR wszClassName = V_BSTR(&vClass);

    //
    // Construct the link directory for the class
    //

    CFileName wszInstanceLinkPath;
	if (wszInstanceLinkPath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructLinkDirFromClass(wszInstanceLinkPath, wszClassName);
    if(FAILED(hres))
        return hres;

    wcscat(wszInstanceLinkPath, L"\\" A51_INSTLINK_FILE_PREFIX);

    //
    // It remains to append the instance-specific part of the file name.  
    // Convineintly, it is the same material as was used for the def file path,
    // so we can steal it.  ALERT: RELIES ON ALL PREFIXES ENDING IN '_'!!
    //

    WCHAR* pwcLastUnderscore = wcsrchr(wszInstanceDefFilePath, L'_');
    if(pwcLastUnderscore == NULL)
        return WBEM_E_CRITICAL_ERROR;

    wcscat(wszInstanceLinkPath, pwcLastUnderscore+1);

    //
    // Delete the file
    //

    long lRes = GetFileCache()->DeleteFile(wszInstanceLinkPath);
    if(lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND)
        return WBEM_E_NOT_FOUND;
    else if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    return S_OK;
}

    


HRESULT CNamespaceHandle::DeleteInstanceAsScope(_IWmiObject* pInst, CEventCollector &aEvents)
{
    HRESULT hres;

    //
    // For now, just check if it is a namespace
    //

    hres = pInst->InheritsFrom(L"__Namespace");
    if(FAILED(hres))
        return hres;

    if(hres != S_OK) // not a namespace
        return S_FALSE;

    //
    // It is a namespace --- construct full path
    //

    WString wsFullName = m_wsNamespace;
    wsFullName += L"\\";

    VARIANT vName;
    VariantInit(&vName);
    CClearMe cm(&vName);
    hres = pInst->Get(L"Name", 0, &vName, NULL, NULL);
    if(FAILED(hres))
        return hres;
    if(V_VT(&vName) != VT_BSTR)
        return WBEM_E_INVALID_OBJECT;

    wsFullName += V_BSTR(&vName);

    //
    // Delete it
    //

    CNamespaceHandle* pNewHandle = new CNamespaceHandle(m_pControl,
                                                        m_pRepository);
    if(pNewHandle == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pNewHandle->AddRef();
    CReleaseMe rm1(pNewHandle);

    hres = pNewHandle->Initialize(wsFullName);
    if(FAILED(hres))
        return hres;

    //
    // Mind to only fire child namespace deletion events from the inside
    //

    bool bNamespaceOnly = aEvents.IsNamespaceOnly();
    aEvents.SetNamespaceOnly(true);
    hres = pNewHandle->DeleteSelf(aEvents);
    if(FAILED(hres))
        return hres;
    aEvents.SetNamespaceOnly(bNamespaceOnly);

    //
    // Fire the event
    //

    hres = FireEvent(aEvents, WBEM_EVENTTYPE_NamespaceDeletion, 
                    V_BSTR(&vName), pInst);

    return S_OK;
}

HRESULT CNamespaceHandle::DeleteSelf(CEventCollector &aEvents)
{
    //
    // Delete all top-level classes. This will delete all namespaces    
    // (as instances of __Namespace), all classes (as children of top-levels)
    // and all instances
    //

    HRESULT hres = DeleteDerivedClasses(L"", aEvents);
    if(FAILED(hres))
        return hres;

	//
	// One extra thing --- clean up relationships for the empty class
	//

    CFileName wszRelationshipDir;
	if (wszRelationshipDir== NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassRelationshipsDir(L"", wszRelationshipDir);
    if(FAILED(hres))
        return hres;

    long lRes = GetFileCache()->RemoveDirectory(wszRelationshipDir);
    if(lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND && 
            lRes != ERROR_PATH_NOT_FOUND)
    {
        return WBEM_E_FAILED;
    }

    //
    // Delete our own root directory -- it should be empty by now
    //

    if(GetFileCache()->RemoveDirectory(m_wszInstanceRootDir) != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    //
    // We do not delete our class root directory --- if we are a namespace, it
    // is the same as our instance root directory so we are already done; if not
    // we should not be cleaning up all the classes!
    //

    m_pClassCache->SetError(WBEM_E_INVALID_NAMESPACE);

    return S_OK;
}
    

HRESULT CNamespaceHandle::DeleteInstanceReferences(_IWmiObject* pInst, 
                                                LPCWSTR wszFilePath)
{
    HRESULT hres;

    pInst->BeginEnumeration(WBEM_FLAG_REFS_ONLY);
    
    VARIANT v;
    while((hres = pInst->Next(0, NULL, &v, NULL, NULL)) == S_OK)
    {
        CClearMe cm(&v);

        if(V_VT(&v) == VT_BSTR)
            DeleteInstanceReference(wszFilePath, V_BSTR(&v));
    }

    pInst->EndEnumeration();
    return S_OK;
}
    
// NOTE: will clobber wszReference
HRESULT CNamespaceHandle::DeleteInstanceReference(LPCWSTR wszOurFilePath,
                                            LPWSTR wszReference)
{
    HRESULT hres;

    CFileName wszReferenceFile;
	if (wszReferenceFile == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructReferenceFileName(wszReference, wszOurFilePath, wszReferenceFile);
	if(FAILED(hres))
	{
		if(hres == WBEM_E_NOT_FOUND)
		{
			//
			// Oh joy. A reference to an instance of a *class* that does not
			// exist (not a non-existence instance, those are normal).
			// Forget it (BUGBUG)
			//

			return S_OK;
		}
		else
			return hres;
	}

    if(GetFileCache()->DeleteFile(wszReferenceFile) != ERROR_SUCCESS)
        return WBEM_E_FAILED;
    else
        return WBEM_S_NO_ERROR;
}


HRESULT CNamespaceHandle::DeleteClassByHash(LPCWSTR wszHash, CEventCollector &aEvents)
{
    HRESULT hres;

    //
    // Get Class definition
    //

    _IWmiObject* pClass = NULL;
    hres = GetClassByHash(wszHash, false, &pClass);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pClass);

    //
    // Get the actual class name
    //

    VARIANT v;
    hres = pClass->Get(L"__CLASS", 0, &v, NULL, NULL);
    if(FAILED(hres))
        return hres;
    CClearMe cm1(&v);

    if(V_VT(&v) != VT_BSTR)
        return WBEM_E_INVALID_CLASS;

    //
    // Construct definition file name
    //

    CFileName wszFileName;
	if (wszFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassDefFileNameFromHash(wszHash, wszFileName);
    if(FAILED(hres))
        return hres;

    return DeleteClassInternal(V_BSTR(&v), pClass, wszFileName, aEvents);
}
    
HRESULT CNamespaceHandle::DeleteClass(LPCWSTR wszClassName, CEventCollector &aEvents)
{
    HRESULT hres;

	if (wcsncmp(wszClassName, L"__", 2) == 0)
	{
		return WBEM_E_INVALID_OPERATION;
	}

	A51TRACE(("Deleting class %S\n", wszClassName));

    //
    // Construct the path for the file
    //

    CFileName wszFileName;
	if (wszFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassDefFileName(wszClassName, wszFileName);
    if(FAILED(hres))
        return hres;

    //
    // Get Class definition
    //

    _IWmiObject* pClass = NULL;
    hres = GetClassDirect(wszClassName, IID__IWmiObject, (void**)&pClass, 
                            false);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pClass);

    return DeleteClassInternal(wszClassName, pClass, wszFileName, aEvents);
}

HRESULT CNamespaceHandle::DeleteClassInternal(LPCWSTR wszClassName,
                                              _IWmiObject* pClass,
                                              LPCWSTR wszFileName,
											  CEventCollector &aEvents)
{
    HRESULT hres;

    CFileName wszFilePath;
	if (wszFilePath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    swprintf(wszFilePath, L"%s\\%s", m_wszClassRootDir, wszFileName);

    //
    // Delete all derived classes
    //

    hres = DeleteDerivedClasses(wszClassName, aEvents);
    if(FAILED(hres))
        return hres;

	//
	// Delete all instances.  Only fire events if namespaces are deleted
	//

    bool bNamespaceOnly = aEvents.IsNamespaceOnly();
    aEvents.SetNamespaceOnly(true);
    hres = DeleteClassInstances(wszClassName, pClass, aEvents);
    if(FAILED(hres))
        return hres;
    aEvents.SetNamespaceOnly(bNamespaceOnly);

    //
    // Clean up references
    //

    hres = EraseClassRelationships(wszClassName, pClass, wszFileName);
    if(FAILED(hres))
        return hres;

    //
    // Delete the file
    //

    long lRes = GetFileCache()->DeleteFile(wszFilePath);
    if(lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND)
        return WBEM_E_NOT_FOUND;
    else if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    m_pClassCache->InvalidateClass(wszClassName);

    //
    // Fire an event
    //

    hres = FireEvent(aEvents, WBEM_EVENTTYPE_ClassDeletion, wszClassName, pClass);

    return S_OK;
}

HRESULT CNamespaceHandle::DeleteDerivedClasses(LPCWSTR wszClassName, CEventCollector &aEvents)
{
    HRESULT hres;

    CWStringArray wsChildHashes;
    hres = GetChildHashes(wszClassName, wsChildHashes);
    if(FAILED(hres))
        return hres;

    HRESULT hresGlobal = S_OK;
    for(int i = 0; i < wsChildHashes.Size(); i++)
    {
        hres = DeleteClassByHash(wsChildHashes[i], aEvents);
        if(FAILED(hres))
            hresGlobal = hres;
    }

    return hresGlobal;
}

HRESULT CNamespaceHandle::GetChildDefs(LPCWSTR wszClassName, bool bRecursive,
                                    IWbemObjectSink* pSink, bool bClone)
{
    CFileName wszHash;
	if (wszHash == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    if(!A51Hash(wszClassName, wszHash))
        return WBEM_E_OUT_OF_MEMORY;

    return GetChildDefsByHash(wszHash, bRecursive, pSink, bClone);
}

HRESULT CNamespaceHandle::GetChildDefsByHash(LPCWSTR wszHash, bool bRecursive,
                                    IWbemObjectSink* pSink, bool bClone)
{
    HRESULT hres;

	long lStartIndex = m_pClassCache->GetLastInvalidationIndex();

    //
    // Get the hashes of the child filenames
    //

    CWStringArray wsChildHashes;
    hres = GetChildHashesByHash(wszHash, wsChildHashes);
    if(FAILED(hres))
        return hres;

    //
    // Get their class definitions
    //

    for(int i = 0; i < wsChildHashes.Size(); i++)
    {
        LPCWSTR wszChildHash = wsChildHashes[i];

        _IWmiObject* pClass = NULL;
        hres = GetClassByHash(wszChildHash, bClone, &pClass);
        if(FAILED(hres))
            return hres;
        CReleaseMe rm1(pClass);

        hres = pSink->Indicate(1, (IWbemClassObject**)&pClass);
        if(FAILED(hres))
            return hres;
        
        //
        // Continue recursively if indicated
        //

        if(bRecursive)
        {
            hres = GetChildDefsByHash(wszChildHash, bRecursive, pSink, bClone);
            if(FAILED(hres))
                return hres;
        }
    }

    //
    // Mark cache completeness
    //

	m_pClassCache->DoneWithChildrenByHash(wszHash, bRecursive, lStartIndex);
    return S_OK;
}

    
HRESULT CNamespaceHandle::GetChildHashes(LPCWSTR wszClassName, 
                                        CWStringArray& wsChildHashes)
{
    CFileName wszHash;
	if (wszHash == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    if(!A51Hash(wszClassName, wszHash))
        return WBEM_E_OUT_OF_MEMORY;

    return GetChildHashesByHash(wszHash, wsChildHashes);
}

HRESULT CNamespaceHandle::GetChildHashesByHash(LPCWSTR wszHash, 
                                        CWStringArray& wsChildHashes)
{
    HRESULT hres;
    long lRes;

    //
    // Construct the prefix for the children classes
    //

    CFileName wszChildPrefix;
	if (wszChildPrefix == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassRelationshipsDirFromHash(wszHash, wszChildPrefix);
    if(FAILED(hres))
        return hres;

    wcscat(wszChildPrefix, L"\\" A51_CHILDCLASS_FILE_PREFIX);

    //
    // Enumerate all such files in the cache
    //

    void* pHandle = NULL;
    WIN32_FIND_DATAW wfd;
    lRes = GetFileCache()->FindFirst(wszChildPrefix, &wfd, &pHandle);
    
    while(lRes == ERROR_SUCCESS)
    {
        wsChildHashes.Add(wfd.cFileName + wcslen(A51_CHILDCLASS_FILE_PREFIX));
        lRes = GetFileCache()->FindNext(pHandle, &wfd);
    }

	if(pHandle)
		GetFileCache()->FindClose(pHandle);

    if(lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_NO_MORE_FILES)
        return WBEM_E_FAILED;
    else
        return S_OK;
}

HRESULT CNamespaceHandle::ClassHasChildren(LPCWSTR wszClassName)
{
    CFileName wszHash;
	if (wszHash == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    if(!A51Hash(wszClassName, wszHash))
        return WBEM_E_OUT_OF_MEMORY;
    
	HRESULT hres;
    long lRes;

    //
    // Construct the prefix for the children classes
    //

    CFileName wszChildPrefix;
	if (wszChildPrefix == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassRelationshipsDirFromHash(wszHash, wszChildPrefix);
    if(FAILED(hres))
        return hres;

    wcscat(wszChildPrefix, L"\\" A51_CHILDCLASS_FILE_PREFIX);

    void* pHandle = NULL;
    WIN32_FIND_DATAW wfd;
    lRes = GetFileCache()->FindFirst(wszChildPrefix, &wfd, &pHandle);

    A51TRACE(("FindFirst %S returned %d\n", wszChildPrefix, lRes));
    
	if(pHandle)
		GetFileCache()->FindClose(pHandle);

    if(lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_NO_MORE_FILES && lRes != S_OK)
    {
        ERRORTRACE((LOG_WBEMCORE, "Unexpected error code %d from FindFirst on "
                        "'%S'", lRes, wszChildPrefix));
        return WBEM_E_FAILED;
    }
	else if (lRes == ERROR_FILE_NOT_FOUND)
		return WBEM_S_FALSE;
    else
        return WBEM_S_NO_ERROR;
}

HRESULT CNamespaceHandle::ClassHasInstances(LPCWSTR wszClassName)
{
    CFileName wszHash;
	if (wszHash == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    if(!A51Hash(wszClassName, wszHash))
        return WBEM_E_OUT_OF_MEMORY;

	return ClassHasInstancesFromClassHash(wszHash);
}

HRESULT CNamespaceHandle::ClassHasInstancesFromClassHash(LPCWSTR wszClassHash)
{
    HRESULT hres;
    long lRes;

    //
    // Check the instances in this namespace first.  The instance directory in
    // default scope is the class directory of the namespace
    //

    hres = ClassHasInstancesInScopeFromClassHash(m_wszClassRootDir, 
                                                    wszClassHash);
    if(hres != WBEM_S_FALSE)
        return hres;

    //
    // No instances in the namespace --- have to enumerate all the scopes
    //

/*
    CFileName wszScopeDir;
	if (wszScopeDir == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    wcscpy(wszScopeDir, m_wszClassRootDir);
    wcscat(wszScopeDir, L"\\" A51_SCOPE_DIR_PREFIX);

    void* pScopeHandle = NULL;
    WIN32_FIND_DATAW fdScope;
    lRes = GetFileCache()->FindFirst(wszScopeDir, &fdScope, &pScopeHandle);
    if(lRes != ERROR_SUCCESS)
    {
*/
    return WBEM_S_FALSE;
}
        
HRESULT CNamespaceHandle::ClassHasInstancesInScopeFromClassHash(
                            LPCWSTR wszInstanceRootDir, LPCWSTR wszClassHash)
{
    CFileName wszFullDirName;
	if (wszFullDirName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    wcscpy(wszFullDirName, wszInstanceRootDir);
    wcscat(wszFullDirName, L"\\" A51_CLASSINST_DIR_PREFIX);
    wcscat(wszFullDirName, wszClassHash);
    wcscat(wszFullDirName, L"\\" A51_INSTLINK_FILE_PREFIX);

    void* pHandle = NULL;
    WIN32_FIND_DATAW fd;
	LONG lRes;
    lRes = GetFileCache()->FindFirst(wszFullDirName, &fd, &pHandle);

	if(pHandle)
	    GetFileCache()->FindClose(pHandle);

    if(lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_NO_MORE_FILES && lRes != S_OK)
	{
		A51TRACE(("ClassHasInstances returning WBEM_E_FAILED for %S\\CD_%S\n", m_wsFullNamespace, wszClassHash));
        return WBEM_E_FAILED;
	}
	else if (lRes == ERROR_FILE_NOT_FOUND)
	{
		A51TRACE(("ClassHasInstances returning WBEM_S_FALSE for %S\\CD_%S\n", m_wsFullNamespace, wszClassHash));
		return WBEM_S_FALSE;
	}
    else
	{
		A51TRACE(("ClassHasInstances returning WBEM_S_NO_ERROR for %S\\CD_%S\n", m_wsFullNamespace, wszClassHash));
        return WBEM_S_NO_ERROR;
	}
}

HRESULT CNamespaceHandle::EraseParentChildRelationship(
                            LPCWSTR wszChildFileName, LPCWSTR wszParentName)
{
    CFileName wszParentChildFileName;
	if (wszParentChildFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    HRESULT hres = ConstructParentChildFileName(wszChildFileName,
                                                wszParentName,
                                                wszParentChildFileName);

    //
    // Delete the file
    //

    long lRes = GetFileCache()->DeleteFile(wszParentChildFileName);
    INTERNAL _IWmiCoreServices* GetCoreServices();
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    return S_OK;
}

HRESULT CNamespaceHandle::EraseClassRelationships(LPCWSTR wszClassName,
                            _IWmiObject* pClass, LPCWSTR wszFileName)
{
    HRESULT hres;

    //
    // Get the parent
    //

    VARIANT v;
    VariantInit(&v);
    hres = pClass->Get(L"__SUPERCLASS", 0, &v, NULL, NULL);
    CClearMe cm(&v);

    if(FAILED(hres))
        return hres;

    if(V_VT(&v) == VT_BSTR)
        EraseParentChildRelationship(wszFileName, V_BSTR(&v));
    else
        EraseParentChildRelationship(wszFileName, L"");

    //
    // Erase references
    //

    hres = pClass->BeginEnumeration(WBEM_FLAG_REFS_ONLY);
    if(FAILED(hres))
        return hres;
    
    BSTR strName = NULL;
    while((hres = pClass->Next(0, &strName, NULL, NULL, NULL)) == S_OK)
    {
        CSysFreeMe sfm(strName);

        EraseClassReference(pClass, wszFileName, strName);
    }

    pClass->EndEnumeration();

    //
    // Erase our relationship directories.  For now, they must be
    // empty at this point, BUT THIS WILL BREAK WHEN WE ADD CLASS REFERENCES.
    //

    CFileName wszRelationshipDir;
	if (wszRelationshipDir == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassRelationshipsDir(wszClassName, wszRelationshipDir);
    if(FAILED(hres))
        return hres;

    long lRes = GetFileCache()->RemoveDirectory(wszRelationshipDir, false);
    if(lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND && 
            lRes != ERROR_PATH_NOT_FOUND && lRes != ERROR_DIR_NOT_EMPTY)
    {
        return WBEM_E_FAILED;
    }


    return S_OK;
}

HRESULT CNamespaceHandle::EraseClassReference(_IWmiObject* pReferringClass,
                            LPCWSTR wszReferringFile,
                            LPCWSTR wszReferringProp)
{
	HRESULT hres;

    //
    // Figure out the class we are pointing to
    //

    DWORD dwSize = 0;
    DWORD dwFlavor = 0;
    CIMTYPE ct;
    hres = pReferringClass->GetPropQual(wszReferringProp, L"CIMTYPE", 0, 0,
            &ct, &dwFlavor, &dwSize, NULL);
    if(dwSize == 0)
        return WBEM_E_OUT_OF_MEMORY;

    LPWSTR wszQual = (WCHAR*)TempAlloc(dwSize);
    if(wszQual == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszQual, dwSize);

    hres = pReferringClass->GetPropQual(wszReferringProp, L"CIMTYPE", 0, dwSize,
            &ct, &dwFlavor, &dwSize, wszQual);
    if(FAILED(hres))
        return hres;
    
    //
    // Parse out the class name
    //

    WCHAR* pwcColon = wcschr(wszQual, L':');
    if(pwcColon == NULL)
        return S_OK; // untyped reference requires no bookkeeping

    LPCWSTR wszReferredToClass = pwcColon+1;

    //
    // Figure out the name of the file for the reference.  
    //

    CFileName wszReferenceFile;
	if (wszReferenceFile == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassReferenceFileName(wszReferredToClass, 
                                wszReferringFile, wszReferringProp,
                                wszReferenceFile);
    if(FAILED(hres))
        return hres;

    //
    // Delete the file
    //

    long lRes = GetFileCache()->DeleteFile(wszReferenceFile);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    return S_OK;
}

HRESULT CNamespaceHandle::DeleteClassInstances(LPCWSTR wszClassName, 
											   _IWmiObject* pClass,
											   CEventCollector &aEvents)
{
	HRESULT hres;

    //
    // Find the link directory for this class
    //

    CFileName wszLinkDir;
	if (wszLinkDir == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructLinkDirFromClass(wszLinkDir, wszClassName);
    if(FAILED(hres))
        return hres;
    
    // 
    // Enumerate all links in it
    //

    CFileName wszSearchPrefix;
	if (wszSearchPrefix == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    wcscpy(wszSearchPrefix, wszLinkDir);
    wcscat(wszSearchPrefix, L"\\" A51_INSTLINK_FILE_PREFIX);

    WIN32_FIND_DATAW fd;
    void* hSearch;
    long lRes = GetFileCache()->FindFirst(wszSearchPrefix, &fd, &hSearch);
    if(lRes != ERROR_SUCCESS)
    {
        if(lRes != ERROR_FILE_NOT_FOUND)
        {
            return WBEM_E_FAILED;
        }

        // Still need to do directory cleanup!
    }
    else
    {
        CFileCache::CFindCloseMe fcm(GetFileCache(), hSearch);

        //
        // Prepare a buffer for instance definition file path
        //
    
        CFileName wszFullFileName;
        if (wszFullFileName == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        hres = ConstructKeyRootDirFromClass(wszFullFileName, wszClassName);
        if(FAILED(hres))
        {
            if(hres == WBEM_E_CANNOT_BE_ABSTRACT)
                return WBEM_S_NO_ERROR;
    
            return hres;
        }
    
        long lDirLen = wcslen(wszFullFileName);
        wszFullFileName[lDirLen] = L'\\';
        lDirLen++;
    
        HRESULT hresGlobal = WBEM_S_NO_ERROR;
    
        do
        {
            hres = ConstructInstDefNameFromLinkName(wszFullFileName+lDirLen, 
                                                        fd.cFileName);
            if(FAILED(hres))
                return hres;
    
            _IWmiObject* pInst;
            hres = FileToInstance(wszFullFileName, &pInst);
            if(FAILED(hres))
				return hres;

            CReleaseMe rm1(pInst);
    
            //
            // Delete the instance, knowing that we are deleting its class. That
            // has an affect on how we deal with the references
            //
    
            hres = DeleteInstanceByFile(wszFullFileName, pInst, true, aEvents);
            if(FAILED(hres))
                hresGlobal = hres;
        }
        while(GetFileCache()->FindNext(hSearch, &fd) == ERROR_SUCCESS);
    }

    //
    // Erase our instance directories.  It must be
    // empty at this point
    //

    lRes = GetFileCache()->RemoveDirectory(wszLinkDir);
    if(lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND && 
            lRes != ERROR_PATH_NOT_FOUND)
    {
        return WBEM_E_FAILED;
    }

    //
    // Erase our key root directory, if we have a key root directory
    //

    CFileName wszPutativeKeyRootDir;
	if (wszPutativeKeyRootDir == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructKeyRootDirFromKeyRoot(wszPutativeKeyRootDir, wszClassName);
    if(FAILED(hres))
        return hres;

    lRes = GetFileCache()->RemoveDirectory(wszPutativeKeyRootDir);
    if(lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND && 
            lRes != ERROR_PATH_NOT_FOUND)
    {
        return WBEM_E_FAILED;
    }

    return S_OK;
}

class CExecQueryObject : public CFiberTask
{
protected:
    IWbemQuery* m_pQuery;
    CDbIterator* m_pIter;
    CNamespaceHandle* m_pNs;

public:
    CExecQueryObject(CNamespaceHandle* pNs, IWbemQuery* pQuery, 
                        CDbIterator* pIter)
        : m_pQuery(pQuery), m_pIter(pIter), m_pNs(pNs)
    {
        m_pQuery->AddRef();
        m_pNs->AddRef();

        //
        // Does not AddRef the iterator --- iterator owns and cleans up the req
        //
    }

    ~CExecQueryObject()
    {
        if(m_pQuery)
            m_pQuery->Release();
        if(m_pNs)
            m_pNs->Release();
    }
    
    HRESULT Execute()
    {
        HRESULT hres = m_pNs->ExecQuerySink(m_pQuery, 0, 0, m_pIter, NULL);
        m_pIter->SetStatus(WBEM_STATUS_COMPLETE, hres, NULL, NULL);
        return hres;
    }
};


HRESULT CNamespaceHandle::ExecQuery(
     IWbemQuery *pQuery,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    DWORD *dwMessageFlags,
    IWmiDbIterator **ppQueryResult
    )
{
    CDbIterator* pIter = new CDbIterator(m_pControl);
	if (pIter == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    pIter->AddRef();
    CReleaseMe rm1((IWmiDbIterator*)pIter);

    //
    // Create a fiber execution object
    //

    CExecQueryObject* pReq = new CExecQueryObject(this, pQuery, pIter);
    if(pReq == NULL)
        return WBEM_E_OUT_OF_MEMORY;

#ifdef A51_USE_FIBER
    //
    // Create a fiber for it
    //

    void* pFiber = CreateFiberForTask(pReq);
    if(pFiber == NULL)
    {
        delete pReq;
        return WBEM_E_OUT_OF_MEMORY;
    }

    pIter->SetExecFiber(pFiber, pReq);
#else
    HRESULT hRes = pReq->Execute();
    delete pReq;
    if (FAILED(hRes))
        return hRes;
#endif

    return pIter->QueryInterface(IID_IWmiDbIterator, (void**)ppQueryResult);
}

HRESULT CNamespaceHandle::ExecQuerySink(
     IWbemQuery *pQuery,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWbemObjectSink* pSink,
    DWORD *dwMessageFlags
    )
{
    HRESULT hres;

    LPWSTR wszQuery = NULL;
    hres = pQuery->GetAnalysis(WMIQ_ANALYSIS_QUERY_TEXT, 0, (void**)&wszQuery);
	if (FAILED(hres))
		return hres;

    DWORD dwLen = ((wcslen(wszQuery) + 1) * sizeof(wchar_t));
    LPWSTR strParse = (LPWSTR)TempAlloc(dwLen);
    if(strParse == NULL)
    {
		pQuery->FreeMemory(wszQuery);
        return WBEM_E_OUT_OF_MEMORY;
    }
    CTempFreeMe tfm(strParse, dwLen);
    wcscpy(strParse, wszQuery);

     if(!_wcsicmp(wcstok(strParse, L" "), L"references"))
    {
        hres = ExecReferencesQuery(wszQuery, pSink);
		pQuery->FreeMemory(wszQuery);
		return hres;
    }

    QL_LEVEL_1_RPN_EXPRESSION* pExpr;
    CTextLexSource Source(wszQuery);
    QL1_Parser Parser(&Source);
    int nRet = Parser.Parse(&pExpr);
    CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> dm(pExpr);

	pQuery->FreeMemory(wszQuery);

//  if (nRet == QL1_Parser::OUT_OF_MEMORY)
//      return WBEM_E_OUT_OF_MEMORY;
    if (nRet != QL1_Parser::SUCCESS)
        return WBEM_E_FAILED;

    if(!_wcsicmp(pExpr->bsClassName, L"meta_class"))
    {
        return ExecClassQuery(pExpr, pSink);
    }
    else
    {
        // BUGBUG: support shallow
        return ExecInstanceQuery(pExpr, pExpr->bsClassName, true, 
                                    pSink);
    }
}

HRESULT CNamespaceHandle::ExecClassQuery(QL_LEVEL_1_RPN_EXPRESSION* pExpr, 
                                            IWbemObjectSink* pSink)
{
    HRESULT hres;

    //
    // Optimizations:
    //

    LPCWSTR wszClassName = NULL;
    LPCWSTR wszSuperClass = NULL;
    LPCWSTR wszAncestor = NULL;
	bool bDontIncludeAncestorInResultSet = false;

    if(pExpr->nNumTokens == 1)
    {
        QL_LEVEL_1_TOKEN* pToken = pExpr->pArrayOfTokens;
        if(!_wcsicmp(pToken->PropertyName.GetStringAt(0), L"__SUPERCLASS") &&
            pToken->nOperator == QL1_OPERATOR_EQUALS)
        {
            wszSuperClass = V_BSTR(&pToken->vConstValue);
        }
        else if(!_wcsicmp(pToken->PropertyName.GetStringAt(0), L"__THIS") &&
            pToken->nOperator == QL1_OPERATOR_ISA)
        {
            wszAncestor = V_BSTR(&pToken->vConstValue);
        }
        else if(!_wcsicmp(pToken->PropertyName.GetStringAt(0), L"__CLASS") &&
            pToken->nOperator == QL1_OPERATOR_EQUALS)
        {
            wszClassName = V_BSTR(&pToken->vConstValue);
        }
    }
	else if (pExpr->nNumTokens == 3)
	{
        //
		// This is a special optimisation used for deep enumeration of classes,
        // and is expecting a query of:
		//   select * from meta_class where __this isa '<class_name>' 
        //                                  and __class <> '<class_name>'
		// where the <class_name> is the same class iin both cases.  This will 
        // set the wszAncestor to <class_name> and propagate a flag to not 
        // include the actual ancestor in the list.
        //

		QL_LEVEL_1_TOKEN* pToken = pExpr->pArrayOfTokens;

		if ((pToken[0].nTokenType == QL1_OP_EXPRESSION) &&
			(pToken[1].nTokenType == QL1_OP_EXPRESSION) &&
			(pToken[2].nTokenType == QL1_AND) &&
			(pToken[0].nOperator == QL1_OPERATOR_ISA) &&
			(pToken[1].nOperator == QL1_OPERATOR_NOTEQUALS) &&
			(_wcsicmp(pToken[0].PropertyName.GetStringAt(0), L"__THIS") == 0) &&
			(_wcsicmp(pToken[1].PropertyName.GetStringAt(0), L"__CLASS") == 0) 
            &&
			(wcscmp(V_BSTR(&pToken[0].vConstValue), 
                    V_BSTR(&pToken[1].vConstValue)) == 0)
           )
		{
			wszAncestor = V_BSTR(&pToken[0].vConstValue);
			bDontIncludeAncestorInResultSet = true;
		}
	}

    if(wszClassName)
    {
        _IWmiObject* pClass = NULL;
        hres = GetClassDirect(wszClassName, IID__IWmiObject, (void**)&pClass,
                                true);
        if(hres == WBEM_E_NOT_FOUND)
        {
            //
            // Class not there --- but that's success for us!
            //

            return S_OK;
        }
        else if(FAILED(hres))
        {
            return hres;
        }
        else 
        {
            CReleaseMe rm1(pClass);

            //
            // Get the class
            //

            hres = pSink->Indicate(1, (IWbemClassObject**)&pClass);
            if(FAILED(hres))
                return hres;

            return S_OK;
        }
    }
    
    hres = EnumerateClasses(pSink, wszSuperClass, wszAncestor, true, 
                                bDontIncludeAncestorInResultSet);
    if(FAILED(hres))
        return hres;
    
    return S_OK;
}

HRESULT CNamespaceHandle::EnumerateClasses(IWbemObjectSink* pSink,
                                LPCWSTR wszSuperClass, LPCWSTR wszAncestor,
                                bool bClone, 
                                bool bDontIncludeAncestorInResultSet)
{
    CWStringArray wsClasses;
    HRESULT hres;

    //
    // If superclass is given, check if its record is complete wrt children
    //

    if(wszSuperClass)
    {
        hres = m_pClassCache->EnumChildren(wszSuperClass, false, wsClasses);
        if(hres == WBEM_S_FALSE)
        {
            //
            // Not in cache --- get the info from files
            //

            return GetChildDefs(wszSuperClass, false, pSink, bClone);
        }
        else
        {
            if(FAILED(hres))
                return hres;
                
            return ListToEnum(wsClasses, pSink, bClone);
        }
    }
    else
    {
        if(wszAncestor == NULL)
            wszAncestor = L"";

        hres = m_pClassCache->EnumChildren(wszAncestor, true, wsClasses);
        if(hres == WBEM_S_FALSE)
        {
            //
            // Not in cache --- get the info from files
            //

            hres = GetChildDefs(wszAncestor, true, pSink, bClone);
            if(FAILED(hres))
                return hres;

            if(*wszAncestor && !bDontIncludeAncestorInResultSet)
            {
                //
                // The class is derived from itself
                //

                _IWmiObject* pClass =  NULL;
                hres = GetClassDirect(wszAncestor, IID__IWmiObject, 
                        (void**)&pClass, bClone);
                if(FAILED(hres))
                    return hres;
				CReleaseMe rm1(pClass);

				hres = pSink->Indicate(1, (IWbemClassObject**)&pClass);
				if(FAILED(hres))
			        return hres;
            }

            return S_OK;
        }
        else
        {
            if(FAILED(hres))
                return hres;

            if(*wszAncestor && !bDontIncludeAncestorInResultSet)
            {
	          wsClasses.Add(wszAncestor);
            }
            return ListToEnum(wsClasses, pSink, bClone);
        }
    }
}
    
HRESULT CNamespaceHandle::ListToEnum(CWStringArray& wsClasses, 
                                        IWbemObjectSink* pSink, bool bClone)
{
    HRESULT hres;

    for(int i = 0; i < wsClasses.Size(); i++)
    {
        _IWmiObject* pClass = NULL;
        if(wsClasses[i] == NULL || wsClasses[i][0] == 0)
            continue;

        hres = GetClassDirect(wsClasses[i], IID__IWmiObject, (void**)&pClass, 
                                bClone);
        if(FAILED(hres))
        {
            if(hres == WBEM_E_NOT_FOUND)
            {
                // That's OK --- class got removed
            }
            else
                return hres;
        }
        else
        {
            CReleaseMe rm1(pClass);
            hres = pSink->Indicate(1, (IWbemClassObject**)&pClass);
            if(FAILED(hres))
                return hres;
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CNamespaceHandle::ExecInstanceQuery(QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                                LPCWSTR wszClassName, bool bDeep,
                                IWbemObjectSink* pSink)
{
    HRESULT hres;

    WCHAR wszHash[MAX_HASH_LEN+1];
    if(!Hash(wszClassName, wszHash))
        return WBEM_E_OUT_OF_MEMORY;

    if(bDeep)
        hres = ExecDeepInstanceQuery(pQuery, wszHash, pSink);
    else
        hres = ExecShallowInstanceQuery(pQuery, wszHash, pSink);

    if(FAILED(hres))
        return hres;
        
    return S_OK;
}

HRESULT CNamespaceHandle::ExecDeepInstanceQuery(
                                QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                                LPCWSTR wszClassHash,
                                IWbemObjectSink* pSink)
{
    HRESULT hres;

    //
    // Get all our instances
    //

    hres = ExecShallowInstanceQuery(pQuery, wszClassHash, pSink);
    if(FAILED(hres))
        return hres;

    CWStringArray awsChildHashes;

    //
    // Check if the list of child classes is known to the cache
    //

    hres = m_pClassCache->EnumChildKeysByKey(wszClassHash, awsChildHashes);
	if (hres == WBEM_S_FALSE)
	{
        //
        // OK --- get them from the disk
        //

        hres = GetChildHashesByHash(wszClassHash, awsChildHashes);
	}
	
	if (FAILED(hres))
	{
		return hres;
	}

    //
    // We have our hashes --- call them recursively
    //

    for(int i = 0; i < awsChildHashes.Size(); i++)
    {
        LPCWSTR wszChildHash = awsChildHashes[i];
        hres = ExecDeepInstanceQuery(pQuery, wszChildHash, pSink);
        if(FAILED(hres))
            return hres;
    }

    return S_OK;
}
        
HRESULT CNamespaceHandle::ExecShallowInstanceQuery(
                                QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                                LPCWSTR wszClassHash, 
                                IWbemObjectSink* pSink)
{
    HRESULT hres;

    // 
    // Enumerate all files in the link directory
    //

    CFileName wszSearchPrefix;
	if (wszSearchPrefix == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructLinkDirFromClassHash(wszSearchPrefix, wszClassHash);
    if(FAILED(hres))
        return hres;

    wcscat(wszSearchPrefix, L"\\" A51_INSTLINK_FILE_PREFIX);

    WIN32_FIND_DATAW fd;
    void* hSearch;
    long lRes = GetFileCache()->FindFirst(wszSearchPrefix, &fd, &hSearch);
    if(lRes != ERROR_SUCCESS)
    {
        if(lRes == ERROR_FILE_NOT_FOUND)
            return WBEM_S_NO_ERROR;
        else
            return WBEM_E_FAILED;
    }

    CFileCache::CFindCloseMe fcm(GetFileCache(), hSearch);

    //
    // Get Class definition
    //

    _IWmiObject* pClass = NULL;
    hres = GetClassByHash(wszClassHash, false, &pClass);
    if(FAILED(hres))
        return hres;

    CReleaseMe rm1(pClass);

    //
    // Prepare a buffer for file path
    //

    CFileName wszFullFileName;
	if (wszFullFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    hres = ConstructKeyRootDirFromClassHash(wszFullFileName, wszClassHash);
    if(FAILED(hres))
        return hres;

    long lDirLen = wcslen(wszFullFileName);
    wszFullFileName[lDirLen] = L'\\';
    lDirLen++;

    HRESULT hresGlobal = WBEM_S_NO_ERROR;

    do
    {
        hres = ConstructInstDefNameFromLinkName(wszFullFileName+lDirLen, 
                                                fd.cFileName);
        if(FAILED(hres))
            return hres;

        _IWmiObject* pInstance = NULL;
        hres = FileToInstance(wszFullFileName, &pInstance, true);
        if(FAILED(hres))
        {
            // Oh well --- continue;
            hresGlobal = hres;
        }
        else
        {
            CReleaseMe rm1(pInstance);
            hres = pSink->Indicate(1, (IWbemClassObject**)&pInstance);
            if(FAILED(hres))
                return hres;
        }
    }
    while(GetFileCache()->FindNext(hSearch, &fd) == ERROR_SUCCESS);

    return hresGlobal;
}

HRESULT CNamespaceHandle::ExecReferencesQuery(LPCWSTR wszQuery, 
                                                IWbemObjectSink* pSink)
{
    HRESULT hres;

    //
    // Make a copy for parsing
    //

    LPWSTR wszParse = new WCHAR[wcslen(wszQuery)+1];
	if (wszParse == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<WCHAR> vdm(wszParse);
    wcscpy(wszParse, wszQuery);

    //
    // Extract the path of the target object.
    //

    //
    // Find the first brace
    //

    WCHAR* pwcStart = wcschr(wszParse, L'{');
    if(pwcStart == NULL)
        return WBEM_E_INVALID_QUERY;

    //
    // Find the beginning of the path
    //

    while(*pwcStart && iswspace(*pwcStart)) pwcStart++;
    if(!*pwcStart)
        return WBEM_E_INVALID_QUERY;

    pwcStart++;
    
    //
    // Find the ending curly brace
    //

    WCHAR* pwc = pwcStart;
    WCHAR wcCurrentQuote = 0;
    while(*pwc && (wcCurrentQuote || *pwc != L'}'))
    {
        if(wcCurrentQuote)
        {
            if(*pwc == L'\\')
            {
                pwc++;
            }
            else if(*pwc == wcCurrentQuote)
                wcCurrentQuote = 0;
        }
        else if(*pwc == L'\'' || *pwc == L'"')
            wcCurrentQuote = *pwc;

        pwc++;
    }

    if(*pwc != L'}')
        return WBEM_E_INVALID_QUERY;

    //
    // Find the end of the path
    //
    
    WCHAR* pwcEnd = pwc-1;
    while(iswspace(*pwcEnd)) pwcEnd--;

    pwcEnd[1] = 0;
    
    LPWSTR wszTargetPath = pwcStart;
    if(wszTargetPath == NULL)
        return WBEM_E_INVALID_QUERY;

    //
    // Parse the path
    //

    DWORD dwLen = (wcslen(wszTargetPath)+1) * sizeof(WCHAR);
    LPWSTR wszKey = (LPWSTR)TempAlloc(dwLen);
    if(wszKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszKey, dwLen);

    LPWSTR wszClassName = NULL;
    bool bIsClass;
    hres = ComputeKeyFromPath(wszTargetPath, wszKey, &wszClassName, &bIsClass);
    if(FAILED(hres))
        return hres;
    CTempFreeMe tfm1(wszClassName, (wcslen(wszClassName)+1) * sizeof(WCHAR*));
    
    if(bIsClass)
    {
        //
        // Need to execute an instance reference query to find all instances
        // pointing to this class
        //

        hres = ExecInstanceRefQuery(wszQuery, NULL, wszClassName, pSink);
        if(FAILED(hres))
            return hres;

        hres = ExecClassRefQuery(wszQuery, wszClassName, pSink);
        if(FAILED(hres))
            return hres;
    }
    else
    {
        hres = ExecInstanceRefQuery(wszQuery, wszClassName, wszKey, pSink);
        if(FAILED(hres))
            return hres;
    }

    return S_OK;
}

HRESULT CNamespaceHandle::ExecInstanceRefQuery(LPCWSTR wszQuery, 
                                                LPCWSTR wszClassName,
                                                LPCWSTR wszKey,
                                                IWbemObjectSink* pSink)
{
    HRESULT hres;

    //
    // Find the instance's ref dir.
    //

    CFileName wszReferenceDir;
	if (wszReferenceDir == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructReferenceDirFromKey(wszClassName, wszKey, wszReferenceDir);
    if(FAILED(hres))
        return hres;

    CFileName wszReferenceMask;
	if (wszReferenceMask == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    wcscpy(wszReferenceMask, wszReferenceDir);
    wcscat(wszReferenceMask, L"\\" A51_REF_FILE_PREFIX);

    // 
    // Enumerate all files in it
    //

    WIN32_FIND_DATAW fd;
    void* hSearch;
    long lRes = GetFileCache()->FindFirst(wszReferenceMask, &fd, &hSearch);
    if(lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND)
    {
        //
        // No files in dir --- no problem
        //
        return WBEM_S_NO_ERROR;
    }
    else if(lRes != ERROR_SUCCESS)
    {
        return WBEM_E_FAILED;
    }

    CFileCache::CFindCloseMe fcm(GetFileCache(), hSearch);

    //
    // Prepare a buffer for file path
    //

    CFileName wszFullFileName;
	if (wszFullFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    wcscpy(wszFullFileName, wszReferenceDir);
    wcscat(wszFullFileName, L"\\");
    long lDirLen = wcslen(wszFullFileName);

    HRESULT hresGlobal = WBEM_S_NO_ERROR;
    CFileName wszReferrerFileName;
	if (wszReferrerFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    wcscpy(wszReferrerFileName, m_pRepository->GetRootDir());

    do
    {
        if(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            continue;

        wcscpy(wszFullFileName+lDirLen, fd.cFileName);

        LPWSTR wszReferrerClass = NULL;
        LPWSTR wszReferrerProp = NULL;
        LPWSTR wszReferrerNamespace = NULL;
        hres = GetReferrerFromFile(wszFullFileName, 
                        wszReferrerFileName + m_pRepository->GetRootDirLen(), 
                        &wszReferrerNamespace, 
                        &wszReferrerClass, &wszReferrerProp);
        if(FAILED(hres))
            continue;
        CVectorDeleteMe<WCHAR> vdm1(wszReferrerClass);
        CVectorDeleteMe<WCHAR> vdm2(wszReferrerProp);
        CVectorDeleteMe<WCHAR> vdm3(wszReferrerNamespace);

        //
        // Check if the namespace of the referring object is the same as ours
        //

        CNamespaceHandle* pReferrerHandle = NULL;
        if(wbem_wcsicmp(wszReferrerNamespace, m_wsNamespace))
        {
            //
            // Open the other namespace
            //

            hres = m_pRepository->GetNamespaceHandle(wszReferrerNamespace,
                                    &pReferrerHandle);
            if(FAILED(hres))
            {
                ERRORTRACE((LOG_WBEMCORE, "Unable to open referring namespace "
                    "'%S' in namespace '%S'\n", wszReferrerNamespace,
                    (LPCWSTR)m_wsNamespace));
                hresGlobal = hres;
                continue;
            }
        }
        else
        {
            pReferrerHandle = this;
            pReferrerHandle->AddRef();
        }

        CReleaseMe rm1(pReferrerHandle);


        _IWmiObject* pInstance = NULL;
        hres = pReferrerHandle->FileToInstance(wszReferrerFileName, &pInstance);
        if(FAILED(hres))
        {
            // Oh well --- continue;
            hresGlobal = hres;
        }
        else
        {
            CReleaseMe rm1(pInstance);
            hres = pSink->Indicate(1, (IWbemClassObject**)&pInstance);
            if(FAILED(hres))
                return hres;
        }
    }
    while(GetFileCache()->FindNext(hSearch, &fd) == ERROR_SUCCESS);

    return hresGlobal;
}

HRESULT CNamespaceHandle::GetReferrerFromFile(LPCWSTR wszReferenceFile,
                            LPWSTR wszReferrerRelFile, 
                            LPWSTR* pwszReferrerNamespace,
                            LPWSTR* pwszReferrerClass,
                            LPWSTR* pwszReferrerProp)
{
    //
    // Get the entire buffer from the file
    //

    BYTE* pBuffer = NULL;
    DWORD dwBufferLen = 0;
    long lRes = GetFileCache()->ReadFile(wszReferenceFile, &dwBufferLen,
                                            &pBuffer);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;
    CTempFreeMe tfm(pBuffer, dwBufferLen);

    if(dwBufferLen == 0)
        return WBEM_E_OUT_OF_MEMORY;

    BYTE* pCurrent = pBuffer;
    DWORD dwStringLen;

    //
    // Get the referrer namespace
    //

    memcpy(&dwStringLen, pCurrent, sizeof(DWORD));
    pCurrent += sizeof(DWORD);
    
    *pwszReferrerNamespace = new WCHAR[dwStringLen+1];
	if (*pwszReferrerNamespace == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    (*pwszReferrerNamespace)[dwStringLen] = 0;
    memcpy(*pwszReferrerNamespace, pCurrent, dwStringLen*sizeof(WCHAR));
    pCurrent += sizeof(WCHAR)*dwStringLen;
    
    //
    // Get the referrer class name
    //

    memcpy(&dwStringLen, pCurrent, sizeof(DWORD));
    pCurrent += sizeof(DWORD);
    
    *pwszReferrerClass = new WCHAR[dwStringLen+1];
	if (*pwszReferrerClass == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    (*pwszReferrerClass)[dwStringLen] = 0;
    memcpy(*pwszReferrerClass, pCurrent, dwStringLen*sizeof(WCHAR));
    pCurrent += sizeof(WCHAR)*dwStringLen;

    //
    // Get the referrer property
    //

    memcpy(&dwStringLen, pCurrent, sizeof(DWORD));
    pCurrent += sizeof(DWORD);
    
    *pwszReferrerProp = new WCHAR[dwStringLen+1];
	if (*pwszReferrerProp == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    (*pwszReferrerProp)[dwStringLen] = 0;
    memcpy(*pwszReferrerProp, pCurrent, dwStringLen*sizeof(WCHAR));
    pCurrent += sizeof(WCHAR)*dwStringLen;

    //
    // Get referrer file path
    //

    memcpy(&dwStringLen, pCurrent, sizeof(DWORD));
    pCurrent += sizeof(DWORD);

    wszReferrerRelFile[dwStringLen] = 0;
    memcpy(wszReferrerRelFile, pCurrent, dwStringLen*sizeof(WCHAR));
    pCurrent += sizeof(WCHAR)*dwStringLen;

    return S_OK;
}
    

HRESULT CNamespaceHandle::ExecClassRefQuery(LPCWSTR wszQuery, 
                                                LPCWSTR wszClassName,
                                                IWbemObjectSink* pSink)
{
    HRESULT hres;

    //
    // Find the class's ref dir.
    //

    CFileName wszReferenceDir;
	if (wszReferenceDir == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassRelationshipsDir(wszClassName, wszReferenceDir);

    CFileName wszReferenceMask;
	if (wszReferenceMask == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    wcscpy(wszReferenceMask, wszReferenceDir);
    wcscat(wszReferenceMask, L"\\" A51_REF_FILE_PREFIX);

    // 
    // Enumerate all files in it
    //

    WIN32_FIND_DATAW fd;
    void* hSearch;
    long lRes = GetFileCache()->FindFirst(wszReferenceMask, &fd, &hSearch);
    if(lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND)
    {
        //
        // No files in dir --- no problem
        //
        return WBEM_S_NO_ERROR;
    }
    else if(lRes != ERROR_SUCCESS)
    {
        return WBEM_E_FAILED;
    }

    CFileCache::CFindCloseMe fcm(GetFileCache(), hSearch);

    do
    {
        //  
        // Extract the class hash from the name of the file
        //

        LPCWSTR wszReferrerHash = fd.cFileName + wcslen(A51_REF_FILE_PREFIX);
        
        //
        // Get the class from that hash
        //

        _IWmiObject* pClass = NULL;
        hres = GetClassByHash(wszReferrerHash, true, &pClass);
        if(FAILED(hres))
        {
            if(hres == WBEM_E_NOT_FOUND)
                continue;
            else
                return hres;
        }

        CReleaseMe rm1(pClass);
        hres = pSink->Indicate(1, (IWbemClassObject**)&pClass);
        if(FAILED(hres))
            return hres;
    }
    while(GetFileCache()->FindNext(hSearch, &fd) == ERROR_SUCCESS);

    return S_OK;
}

bool CNamespaceHandle::Hash(LPCWSTR wszName, LPWSTR wszHash)
{
    return A51Hash(wszName, wszHash);
}

HRESULT CNamespaceHandle::InstanceToFile(IWbemClassObject* pInst, 
                            LPCWSTR wszClassName, LPCWSTR wszFileName,
                            __int64 nClassTime)
{
    HRESULT hres;

    //
    // Allocate enough space for the buffer
    //

    _IWmiObject* pInstEx;
    pInst->QueryInterface(IID__IWmiObject, (void**)&pInstEx);
    CReleaseMe rm1(pInstEx);

    DWORD dwInstancePartLen = 0;
    hres = pInstEx->Unmerge(0, 0, &dwInstancePartLen, NULL);

    //
    // Add enough room for the class hash
    //

    DWORD dwClassHashLen = MAX_HASH_LEN * sizeof(WCHAR);
    DWORD dwTotalLen = dwInstancePartLen + dwClassHashLen + sizeof(__int64)*2;

    BYTE* pBuffer = (BYTE*)TempAlloc(dwTotalLen);
	if (pBuffer == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe vdm(pBuffer, dwTotalLen);

    //
    // Write the class hash
    //

    if(!Hash(wszClassName, (LPWSTR)pBuffer))
        return WBEM_E_OUT_OF_MEMORY;

    memcpy(pBuffer + dwClassHashLen, &g_nCurrentTime, sizeof(__int64));
    g_nCurrentTime++;

    memcpy(pBuffer + dwClassHashLen + sizeof(__int64), &nClassTime, 
            sizeof(__int64));

    //
    // Unmerge the instance into a buffer
    // 

    DWORD dwLen;
    hres = pInstEx->Unmerge(0, dwInstancePartLen, &dwLen, 
                            pBuffer + dwClassHashLen + sizeof(__int64)*2);
    if(FAILED(hres))
        return hres;

    //
    // Write to the file only as much as we have actually used!
    //

    long lRes = GetFileCache()->WriteFile(wszFileName, 
                    dwClassHashLen + sizeof(__int64)*2 + dwLen, pBuffer);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;
    
    return WBEM_S_NO_ERROR;
}

HRESULT CNamespaceHandle::ClassToFile(_IWmiObject* pParentClass, 
                _IWmiObject* pClass, LPCWSTR wszFileName, 
                __int64 nFakeUpdateTime)
{
    HRESULT hres;

    //
    // Get superclass name
    //

    VARIANT vSuper;
    hres = pClass->Get(L"__SUPERCLASS", 0, &vSuper, NULL, NULL);
    if(FAILED(hres))
        return hres;

    CClearMe cm1(&vSuper);

    LPCWSTR wszSuper;
    if(V_VT(&vSuper) == VT_BSTR)
        wszSuper = V_BSTR(&vSuper);
    else
        wszSuper = L"";

    VARIANT vClassName;
    hres = pClass->Get(L"__CLASS", 0, &vClassName, NULL, NULL);
    if(FAILED(hres))
        return hres;
    CClearMe cm2(&vClassName);

    LPCWSTR wszClassName;
    if(V_VT(&vClassName) == VT_BSTR)
        wszClassName = V_BSTR(&vClassName);
    else
        wszClassName = L"";

    //
    // Get unmerge length
    //

    DWORD dwUnmergedLen = 0;
    hres = pClass->Unmerge(0, 0, &dwUnmergedLen, NULL);

    //
    // Add enough space for the parent class name and the timestamp
    //

    DWORD dwSuperLen = sizeof(DWORD) + wcslen(wszSuper)*sizeof(WCHAR);

    DWORD dwLen = dwUnmergedLen + dwSuperLen + sizeof(__int64);

    BYTE* pBuffer = (BYTE*)TempAlloc(dwLen);
	if (pBuffer == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe vdm(pBuffer, dwLen);

    //
    // Write superclass name
    //

    DWORD dwActualSuperLen = wcslen(wszSuper);
    memcpy(pBuffer, &dwActualSuperLen, sizeof(DWORD));
    memcpy(pBuffer + sizeof(DWORD), wszSuper, wcslen(wszSuper)*sizeof(WCHAR));

    //
    // Write the timestamp
    //

    if(nFakeUpdateTime == 0)
    {
        nFakeUpdateTime = g_nCurrentTime;
        g_nCurrentTime++;
    }

    memcpy(pBuffer + dwSuperLen, &nFakeUpdateTime, sizeof(__int64));

    //
    // Write the unmerged portion
    //

    BYTE* pUnmergedPortion = pBuffer + dwSuperLen + sizeof(__int64);
    hres = pClass->Unmerge(0, dwUnmergedLen, &dwUnmergedLen, 
                            pUnmergedPortion);
    if(FAILED(hres))
        return hres;

    //
    // Stash away the real length
    //

    DWORD dwFileLen = dwUnmergedLen + dwSuperLen + sizeof(__int64);

    long lRes = GetFileCache()->WriteFile(wszFileName, dwFileLen, pBuffer);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    //
    // To properly cache the new class definition, first invalidate it
    //

    hres = m_pClassCache->InvalidateClass(wszClassName);
    if(FAILED(hres))
        return hres;

    //
    // Now, remerge the unmerged portion back in
    //

    if(pParentClass == NULL)
    {
        //
        // Get the empty class
        //

        hres = GetClassDirect(NULL, IID__IWmiObject, (void**)&pParentClass, 
                                false);
        if(FAILED(hres))
            return hres;
    }
    else
        pParentClass->AddRef();
    CReleaseMe rm0(pParentClass);

    _IWmiObject* pNewObj;
    hres = pParentClass->Merge(0, dwUnmergedLen, pUnmergedPortion, &pNewObj);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pNewObj);

    hres = pNewObj->SetDecoration(m_wszMachineName, m_wsNamespace);
    if(FAILED(hres))
        return hres;

    hres = m_pClassCache->AssertClass(pNewObj, wszClassName, false, 
                                        nFakeUpdateTime); 
    if(FAILED(hres))
        return hres;

    return WBEM_S_NO_ERROR;
}


HRESULT CNamespaceHandle::ConstructInstanceDefName(LPWSTR wszInstanceDefName,
                                                    LPCWSTR wszKey)
{
    wcscpy(wszInstanceDefName, A51_INSTDEF_FILE_PREFIX);
    if(!Hash(wszKey, wszInstanceDefName + wcslen(A51_INSTDEF_FILE_PREFIX)))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    return WBEM_S_NO_ERROR;
}

HRESULT CNamespaceHandle::ConstructInstDefNameFromLinkName(
                                                    LPWSTR wszInstanceDefName,
                                                    LPCWSTR wszInstanceLinkName)
{
    wcscpy(wszInstanceDefName, A51_INSTDEF_FILE_PREFIX);
    wcscat(wszInstanceDefName, 
        wszInstanceLinkName + wcslen(A51_INSTLINK_FILE_PREFIX));
    return WBEM_S_NO_ERROR;
}

HRESULT CNamespaceHandle::ConstructClassDefFileName(LPCWSTR wszClassName, 
                                            LPWSTR wszFileName)
{
    wcscpy(wszFileName, A51_CLASSDEF_FILE_PREFIX);
    if(!Hash(wszClassName, wszFileName+wcslen(A51_CLASSDEF_FILE_PREFIX)))
        return WBEM_E_INVALID_OBJECT;
    return WBEM_S_NO_ERROR;
}

HRESULT CNamespaceHandle::ConstructClassDefFileNameFromHash(LPCWSTR wszHash, 
                                            LPWSTR wszFileName)
{
    wcscpy(wszFileName, A51_CLASSDEF_FILE_PREFIX);
    wcscat(wszFileName, wszHash);
    return WBEM_S_NO_ERROR;
}



CDbIterator::CDbIterator(CLifeControl* pControl)
        : TUnkBase(pControl), m_lCurrentIndex(0), m_hresStatus(WBEM_S_FALSE),
            m_pMainFiber(NULL), m_pExecFiber(NULL), m_dwNumRequested(0),
            m_pExecReq(NULL), m_hresCancellationStatus(WBEM_S_NO_ERROR),
            m_bExecFiberRunning(false)
{
}

CDbIterator::~CDbIterator()
{
#ifdef A51_USE_FIBER
    if(m_pExecFiber)
        Cancel(0);
#endif
    if(m_pExecReq)
        delete m_pExecReq;
}

void CDbIterator::SetExecFiber(void* pFiber, CFiberTask* pReq)
{
    m_pExecFiber = pFiber;
    m_pExecReq = pReq;
}

STDMETHODIMP CDbIterator::Cancel(DWORD dwFlags)
{
    CInCritSec ics(&m_cs);

    m_qObjects.Clear();
#ifdef A51_USE_FIBER

    //
    // Mark the iterator as cancelled and allow the execution fiber to resume
    // and complete --- that guarantees that any memory it allocated will be
    // cleaned up.  The exception to this rule is if the fiber has not started
    // execution yet; in that case, we do not want to switch to it, as it would
    // have to run until the first Indicate to find out that it's been
    // cancelled.  (In the normal case, the execution fiber is suspended    
    // inside Indicate, so when we switch back we will immediately give it
    // WBEM_E_CALL_CANCELLED so that it can clean up and return)
    //

    m_hresCancellationStatus = WBEM_E_CALL_CANCELLED;

    if(m_pExecFiber)
    {
        if(m_bExecFiberRunning)
        {
            _ASSERT(m_pMainFiber == NULL && m_pExecFiber != NULL, 
                    L"Fiber trouble");

            //
            // Make sure the calling thread has a fiber
            //

            m_pMainFiber = CreateOrGetCurrentFiber();
            if(m_pMainFiber == NULL)
                return WBEM_E_OUT_OF_MEMORY;

            SwitchToFiber(m_pExecFiber);
        }
        
        // 
        // At this point, the executing fiber is dead.  We know, because in the
        // cancelled state we do not switch to the main fiber in Indicate. 
        //

        ReturnFiber(m_pExecFiber);
        m_pExecFiber = NULL;
    }

#endif
    return S_OK;
}

STDMETHODIMP CDbIterator::NextBatch(
      DWORD dwNumRequested,
      DWORD dwTimeOutSeconds,
      DWORD dwFlags,
      DWORD dwRequestedHandleType,
      REFIID riid,
      DWORD *pdwNumReturned,
      LPVOID *ppObjects
     )
{
    CInCritSec ics(&m_cs);

    //
    // TEMP CODE: Someone is calling us on an impersonated thread.  Let's catch
    // the, ahem, bastard
    //

    HANDLE hToken;
    BOOL bRes = OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken);
    if(bRes)
    {
        //_ASSERT(false, L"Called with a thread token");
        ERRORTRACE((LOG_WBEMCORE, "Repository called with a thread token! "
                        "It shall be removed\n"));
        CloseHandle(hToken);
        SetThreadToken(NULL, NULL);
    }

    _ASSERT(SUCCEEDED(m_hresCancellationStatus), L"Next called after Cancel");
    

#ifdef A51_USE_FIBER

    m_bExecFiberRunning = true;

    //
    // Wait until it's over or the right number of objects has been received
    //

    if(m_qObjects.GetQueueSize() < dwNumRequested)
    {
        _ASSERT(m_pMainFiber == NULL && m_pExecFiber != NULL, L"Fiber trouble");

        //
        // Make sure the calling thread has a fiber
        //

        m_pMainFiber = CreateOrGetCurrentFiber();
        if(m_pMainFiber == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        m_dwNumRequested = dwNumRequested;

        //
        // We need to acquire the read lock for the duration of the continuation
        // of the retrieval
        //

	    {
		    CAutoReadLock lock(&g_readWriteLock);
            if (g_bShuttingDown)
            {
                m_pMainFiber = NULL;
                return WBEM_E_SHUTTING_DOWN;
            }

            SwitchToFiber(m_pExecFiber);
        }

        m_pMainFiber = NULL;
    }
#endif
    //
    // We have as much as we are going to have!
    //
    
    DWORD dwReqIndex = 0;
    while(dwReqIndex < dwNumRequested)
    {
        if(0 == m_qObjects.GetQueueSize())
        {
            //
            // That's it --- we waited for production, so there are simply no 
            // more objects in the enumeration
            //

            *pdwNumReturned = dwReqIndex;
            return m_hresStatus;
        }

        IWbemClassObject* pObj = m_qObjects.Dequeue();
        CReleaseMe rm1(pObj);
        pObj->QueryInterface(riid, ppObjects + dwReqIndex);

        dwReqIndex++;
    }

    //
    // Got everything
    //

    *pdwNumReturned= dwNumRequested;
    return S_OK;
}

HRESULT CDbIterator::Indicate(long lNumObjects, IWbemClassObject** apObjects)
{
#ifdef A51_USE_FIBER
    if(FAILED(m_hresCancellationStatus))
    {
        //
        // --- the fiber called back with Indicate even after we 
        // cancelled! Oh well.
        //
        
        _ASSERT(false, L"Execution code ignored cancel return code!");
        return m_hresCancellationStatus;
    }
#endif

    //
    // Add the objects received to the array
    //

    for(long i = 0; i < lNumObjects; i++)
    {
        m_qObjects.Enqueue(apObjects[i]);
    }

#ifdef A51_USE_FIBER
    //
    // Check if we have compiled enough for the current request and should
    // therefore interrupt the gatherer
    //

    if(m_qObjects.GetQueueSize() >= m_dwNumRequested)
    {
        //
        // Switch us back to the original fiber
        //

        SwitchToFiber(m_pMainFiber);
    }
#endif

    return m_hresCancellationStatus;
}

HRESULT CDbIterator::SetStatus(long lFlags, HRESULT hresResult, 
                                    BSTR, IWbemClassObject*)
{
    _ASSERT(m_hresStatus == WBEM_S_FALSE, L"SetStatus called twice!");
    _ASSERT(lFlags == WBEM_STATUS_COMPLETE, L"SetStatus flags invalid");

    m_hresStatus = hresResult;

#ifdef A51_USE_FIBER
    //
    // Switch us back to the original thread, we are done
    //

    m_bExecFiberRunning = false;
    SwitchToFiber(m_pMainFiber);
#endif

    return WBEM_S_NO_ERROR;
}



    
            


CRepEvent::CRepEvent(DWORD dwType, LPCWSTR wszNamespace, LPCWSTR wszArg1, 
            _IWmiObject* pObj1, _IWmiObject* pObj2)
{
    m_dwType = dwType;
    m_pObj1 = 0;
    m_pObj2 = 0;
    m_wszArg1 = m_wszNamespace = NULL;

    if (wszArg1)
    {
        m_wszArg1 = (WCHAR*)TempAlloc((wcslen(wszArg1)+1)*sizeof(WCHAR));
        if (m_wszArg1 == NULL)
            throw CX_MemoryException();
        wcscpy(m_wszArg1, wszArg1);
    }

    if (wszNamespace)
    {
        m_wszNamespace = (WCHAR*)TempAlloc((wcslen(wszNamespace)+1)*sizeof(WCHAR));
        if (m_wszNamespace == NULL)
            throw CX_MemoryException();
        wcscpy(m_wszNamespace, wszNamespace);
    }
    if (pObj1)
    {
        m_pObj1 = pObj1;
        pObj1->AddRef();
    }
    if (pObj2)
    {
        m_pObj2 = pObj2;
        pObj2->AddRef();
    }
}

CRepEvent::~CRepEvent()
{
    TempFree(m_wszArg1, (wcslen(m_wszArg1)+1)*sizeof(WCHAR));
    TempFree(m_wszNamespace, (wcslen(m_wszNamespace)+1)*sizeof(WCHAR));
    if (m_pObj1)
        m_pObj1->Release();
    if (m_pObj2)
        m_pObj2->Release();
};

HRESULT CEventCollector::SendEvents(_IWmiCoreServices* pCore)
{
	HRESULT hresGlobal = WBEM_S_NO_ERROR;
	for (int i = 0; i != m_apEvents.GetSize(); i++)
	{
		CRepEvent *pEvent = m_apEvents[i];

		_IWmiObject* apObjs[2];
		apObjs[0] = pEvent->m_pObj1;
		apObjs[1] = pEvent->m_pObj2;

		HRESULT hres = pCore->DeliverIntrinsicEvent(
				pEvent->m_wszNamespace, pEvent->m_dwType, NULL, 
                pEvent->m_wszArg1, NULL, (pEvent->m_pObj2?2:1), apObjs);
        if(FAILED(hres))
            hresGlobal = hres;
	}

    return hresGlobal;
}

bool CEventCollector::AddEvent(CRepEvent* pEvent)
{
    EnterCriticalSection(&m_csLock);

    if(m_bNamespaceOnly)
    {
        if(pEvent->m_dwType != WBEM_EVENTTYPE_NamespaceCreation &&
           pEvent->m_dwType != WBEM_EVENTTYPE_NamespaceDeletion &&
           pEvent->m_dwType != WBEM_EVENTTYPE_NamespaceModification)
        {
            delete pEvent;
            LeaveCriticalSection(&m_csLock);
            return true;
        }
    }

    bool bRet = (m_apEvents.Add(pEvent) >= 0);
    LeaveCriticalSection(&m_csLock);
    return bRet;
}

void CEventCollector::DeleteAllEvents()
{
    EnterCriticalSection(&m_csLock);
    m_bNamespaceOnly = false;
    m_apEvents.RemoveAll();
    LeaveCriticalSection(&m_csLock);
}

void CEventCollector::TransferEvents(CEventCollector &aEventsToTransfer)
{
    m_bNamespaceOnly = aEventsToTransfer.m_bNamespaceOnly;

	while(aEventsToTransfer.m_apEvents.GetSize())
	{
		CRepEvent *pEvent = 0;
        aEventsToTransfer.m_apEvents.RemoveAt(0, &pEvent);

        m_apEvents.Add(pEvent);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a51\a51rep.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __A51PROV__H_
#define __A51PROV__H_

#include <windows.h>
#include <wbemidl.h>
#include <stdio.h>
#include <unk.h>
#include <wbemcomn.h>
#include <sync.h>
#include <reposit.h>
#include <wmiutils.h>
#include <objpath.h>
#include <filecach.h>
#include <hiecache.h>
#include <corex.h>
#include "a51fib.h"

extern long g_lRootDirLen;
extern WCHAR g_wszRootDir[MAX_PATH];

class CDbIterator;
class CRepEvent
{
public:
	DWORD m_dwType;
	LPWSTR m_wszArg1;
    LPWSTR m_wszNamespace;
	_IWmiObject* m_pObj1;
	_IWmiObject* m_pObj2;

	CRepEvent(DWORD dwType, LPCWSTR wszNamespace, LPCWSTR wszArg1, 
                _IWmiObject* pObj1, _IWmiObject* pObj2);
	~CRepEvent();

    void* operator new(size_t) {return TempAlloc(sizeof(CRepEvent));}
    void operator delete(void* p) {return TempFree(p, sizeof(CRepEvent));}
};

class CEventCollector
{
protected:
    CUniquePointerArray<CRepEvent> m_apEvents;
    bool m_bNamespaceOnly;
    CRITICAL_SECTION m_csLock;

public:
    CEventCollector() : m_bNamespaceOnly(false){ InitializeCriticalSection(&m_csLock);}
    ~CEventCollector() { DeleteCriticalSection(&m_csLock); }
    bool AddEvent(CRepEvent* pEvent);
    void SetNamespaceOnly(bool bNamespaceOnly) 
        {m_bNamespaceOnly = bNamespaceOnly;}
    bool IsNamespaceOnly() {return m_bNamespaceOnly;}

    HRESULT SendEvents(_IWmiCoreServices* pCore);

    void DeleteAllEvents();

    void TransferEvents(CEventCollector &aEventsToTransfer);

    int GetSize() { return m_apEvents.GetSize(); }
};
    

class CNamespaceHandle;
class CRepository : public CUnkBase<IWmiDbController, &IID_IWmiDbController>
{
protected:
    HRESULT Initialize();

public:

    HRESULT STDMETHODCALLTYPE Logon(
          WMIDB_LOGON_TEMPLATE *pLogonParms,
          DWORD dwFlags,
          DWORD dwRequestedHandleType,
         IWmiDbSession **ppSession,
         IWmiDbHandle **ppRootNamespace
        );

    HRESULT STDMETHODCALLTYPE GetLogonTemplate(
           LCID  lLocale,
           DWORD dwFlags,
          WMIDB_LOGON_TEMPLATE **ppLogonTemplate
        );

    HRESULT STDMETHODCALLTYPE FreeLogonTemplate(
         WMIDB_LOGON_TEMPLATE **ppTemplate
        );

    HRESULT STDMETHODCALLTYPE Shutdown(
         DWORD dwFlags
        );

    HRESULT STDMETHODCALLTYPE SetCallTimeout(
         DWORD dwMaxTimeout
        );

    HRESULT STDMETHODCALLTYPE SetCacheValue(
         DWORD dwMaxBytes
        );

    HRESULT STDMETHODCALLTYPE FlushCache(
         DWORD dwFlags
        );

    HRESULT STDMETHODCALLTYPE GetStatistics(
          DWORD  dwParameter,
         DWORD *pdwValue
        );

    HRESULT STDMETHODCALLTYPE Backup(
		LPCWSTR wszBackupFile,
		long lFlags
        );
    
    HRESULT STDMETHODCALLTYPE Restore(
		LPCWSTR wszBackupFile,
		long lFlags
        );
    
public:
    CRepository(CLifeControl* pControl) : TUnkBase(pControl)
    {}
    ~CRepository()
    {
    }

    INTERNAL CForestCache* GetForestCache();
    INTERNAL _IWmiCoreServices* GetCoreServices();

    HRESULT GetNamespaceHandle(LPCWSTR wszNamespaceName, 
                                CNamespaceHandle** ppHandle);
    LPCWSTR GetRootDir() {return g_wszRootDir;}
    int GetRootDirLen() {return g_lRootDirLen;}
};

class CSession : public CUnkBase<IWmiDbSessionEx, &IID_IWmiDbSessionEx>
{
private:
    CEventCollector m_aTransactedEvents;
    bool m_bInWriteTransaction;

public:
    CSession(CLifeControl* pControl = NULL) : TUnkBase(pControl), m_bInWriteTransaction(false) {}

    virtual ~CSession();

    ULONG STDMETHODCALLTYPE Release();

    HRESULT STDMETHODCALLTYPE GetObject(
         IWmiDbHandle *pScope,
         IWbemPath *pPath,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbHandle **ppResult
        );

    HRESULT STDMETHODCALLTYPE GetObjectDirect(
         IWmiDbHandle *pScope,
         IWbemPath *pPath,
         DWORD dwFlags,
         REFIID riid,
        LPVOID *pObj
        );

    HRESULT STDMETHODCALLTYPE PutObject(
         IWmiDbHandle *pScope,
         REFIID riid,
        LPVOID pObj,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbHandle **ppResult
        );

    HRESULT STDMETHODCALLTYPE DeleteObject(
         IWmiDbHandle *pScope,
         DWORD dwFlags,
         REFIID riid,
         LPVOID pObj
        );

    HRESULT STDMETHODCALLTYPE ExecQuery(
         IWmiDbHandle *pScope,
         IWbemQuery *pQuery,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        DWORD *dwMessageFlags,
        IWmiDbIterator **ppQueryResult
        );
    HRESULT STDMETHODCALLTYPE RenameObject(
         IWbemPath *pOldPath,
         IWbemPath *pNewPath,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbHandle **ppResult
        );

    HRESULT STDMETHODCALLTYPE Enumerate(
         IWmiDbHandle *pScope,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbIterator **ppQueryResult
        );

    HRESULT STDMETHODCALLTYPE AddObject(
         IWmiDbHandle *pScope,
         IWbemPath *pPath,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbHandle **ppResult
        );

    HRESULT STDMETHODCALLTYPE RemoveObject (
         IWmiDbHandle *pScope,
         IWbemPath *pPath,
         DWORD dwFlags
        );

    HRESULT STDMETHODCALLTYPE SetDecoration(
         LPWSTR lpMachineName,
         LPWSTR lpNamespacePath
        );

    HRESULT STDMETHODCALLTYPE SupportsQueries( 
         DWORD *dwQuerySupportLevel
         ) {return WBEM_E_FAILED;};

    HRESULT STDMETHODCALLTYPE GetObjectByPath(
         IWmiDbHandle *pScope,
         LPCWSTR wszPath,
         DWORD dwFlags,
         REFIID riid,
        LPVOID *pObj
        );

	HRESULT STDMETHODCALLTYPE DeleteObjectByPath(
		IWmiDbHandle *pScope,
		LPCWSTR wszObjectPath,
		DWORD dwFlags
    );

    HRESULT STDMETHODCALLTYPE ExecQuerySink(
		IWmiDbHandle *pScope,
         IWbemQuery *pQuery,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWbemObjectSink* pSink,
        DWORD *dwMessageFlags
        );

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

	HRESULT STDMETHODCALLTYPE BeginWriteTransaction(DWORD dwFlags);

    HRESULT STDMETHODCALLTYPE BeginReadTransaction(DWORD dwFlags);

	HRESULT STDMETHODCALLTYPE CommitTransaction(DWORD dwFlags);

	HRESULT STDMETHODCALLTYPE AbortTransaction(DWORD dwFlags);
protected:
};

class CNamespaceHandle : public CUnkBase<IWmiDbHandle, &IID_IWmiDbHandle>
{
protected:
    CRepository* m_pRepository;
    WString m_wsNamespace;
    WString m_wsScope;
    WString m_wsFullNamespace;
    WCHAR m_wszMachineName[MAX_COMPUTERNAME_LENGTH+1];

    WCHAR m_wszClassRootDir[MAX_PATH];
    long m_lClassRootDirLen;

    WCHAR m_wszInstanceRootDir[MAX_PATH];
    long m_lInstanceRootDirLen;

    CHierarchyCache* m_pClassCache;
    CForestCache* m_ForestCache;

    _IWmiObject* m_pNullClass;
    bool m_bCached;

public:
    CNamespaceHandle(CLifeControl* pControl, CRepository* pRepository);
    ~CNamespaceHandle();
    

    STDMETHOD(GetHandleType)(DWORD* pdwType) {*pdwType = 0; return S_OK;}

    HRESULT Initialize(LPCWSTR wszNamespace, LPCWSTR wszScope = NULL);

    HRESULT GetObject(
         IWbemPath *pPath,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbHandle **ppResult
        );

    HRESULT GetObjectDirect(
         IWbemPath *pPath,
         DWORD dwFlags,
         REFIID riid,
        LPVOID *pObj
        );

    HRESULT PutObject(
         REFIID riid,
        LPVOID pObj,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbHandle **ppResult,
		CEventCollector &aEvents
        );

    HRESULT DeleteObject(
         DWORD dwFlags,
         REFIID riid,
         LPVOID pObj,
		 CEventCollector &aEvents
        );

    HRESULT ExecQuery(
         IWbemQuery *pQuery,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        DWORD *dwMessageFlags,
        IWmiDbIterator **ppQueryResult
        );

    HRESULT GetObjectByPath(
        LPWSTR wszPath,
        DWORD dwFlags,
        REFIID riid,
        LPVOID *pObj
       );

    HRESULT ExecQuerySink(
         IWbemQuery *pQuery,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWbemObjectSink* pSink,
        DWORD *dwMessageFlags
        );

	HRESULT DeleteObjectByPath(DWORD dwFlags, LPWSTR wszPath, CEventCollector &aEvents);
	HRESULT SendEvents(CEventCollector &aEvents);
    HRESULT GetErrorStatus();
    void SetErrorStatus(HRESULT hres);

protected:
    HRESULT GetObjectHandleByPath(LPWSTR wszBuffer, DWORD dwFlags,
            DWORD dwRequestedHandleType, IWmiDbHandle **ppResult);
    HRESULT PutInstance(_IWmiObject* pInst, DWORD dwFlags, CEventCollector &aEvents);
    HRESULT PutClass(_IWmiObject* pClass, DWORD dwFlags, CEventCollector &aEvents);
    HRESULT ConstructClassRelationshipsDir(LPCWSTR wszClassName,
                                LPWSTR wszDirPath);
    HRESULT WriteParentChildRelationship(LPCWSTR wszChildFileName, 
                                LPCWSTR wszParentName);
    HRESULT WriteClassReferences(_IWmiObject* pClass, LPCWSTR wszFileName);
    HRESULT ExecClassQuery(QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                            IWbemObjectSink* pSink);
    HRESULT ExecInstanceQuery(QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                                LPCWSTR wszClassName, bool bDeep,
                                IWbemObjectSink* pSink);
    HRESULT GetClassDirect(LPCWSTR wszClassName, REFIID riid, void** ppObj,
                            bool bClone, __int64* pnTime = NULL,
                            bool* pbRead = NULL);
    HRESULT GetInstanceDirect(ParsedObjectPath* pPath,
                                REFIID riid, void** ppObj);
	HRESULT DeleteInstance(LPCWSTR wszClassName, LPCWSTR wszKey, CEventCollector &aEvents);
	HRESULT DeleteInstanceByFile(LPCWSTR wszFilePath, _IWmiObject* pClass, 
                            bool bClassDeletion, CEventCollector &aEvents);
	HRESULT DeleteClass(LPCWSTR wszClassName, CEventCollector &aEvents);
	HRESULT DeleteClassInstances(LPCWSTR wszClassName, _IWmiObject* pClass, CEventCollector &aEvents);
    HRESULT FileToClass(LPCWSTR wszFileName, _IWmiObject** ppClass, 
                            bool bClone, __int64* pnTime = NULL);
    HRESULT FileToInstance(LPCWSTR wszFileName, _IWmiObject** ppInstance,
                            bool bMustBeThere = false);
    HRESULT WriteInstanceReferences(_IWmiObject* pInst, LPCWSTR wszClassName,
                                    LPCWSTR wszFilePath);
    HRESULT WriteInstanceReference(LPCWSTR wszReferringFile,
                            LPCWSTR wszReferringClass,
                            LPCWSTR wszReferringProp, LPWSTR wszReference);
    HRESULT CalculateInstanceFileBase(LPCWSTR wszInstancePath, 
                            LPWSTR wszFilePath);
    HRESULT ExecClassRefQuery(LPCWSTR wszQuery, LPCWSTR wszClassName,
                                                    IWbemObjectSink* pSink);
    HRESULT ExecReferencesQuery(LPCWSTR wszQuery, IWbemObjectSink* pSink);
    HRESULT ExecInstanceRefQuery(LPCWSTR wszQuery, LPCWSTR wszClassName,
                                    LPCWSTR wszKey, IWbemObjectSink* pSink);
    HRESULT GetReferrerFromFile(LPCWSTR wszReferenceFile,
                                LPWSTR wszReferrerRelFile, 
                                LPWSTR* pwszReferrerNamespace,
                                LPWSTR* pwszReferrerClass,
                                LPWSTR* pwszReferrerProp);
    HRESULT DeleteInstanceReference(LPCWSTR wszOurFilePath,
                                            LPWSTR wszReference);
    HRESULT DeleteInstanceReferences(_IWmiObject* pInst, LPCWSTR wszFilePath);

    HRESULT EnumerateClasses(IWbemObjectSink* pSink,
                                LPCWSTR wszSuperClass, LPCWSTR wszAncestor,
                                bool bClone, bool bDontIncludeAncestorInResultSet);
    HRESULT ListToEnum(CWStringArray& wsClasses, 
                                        IWbemObjectSink* pSink, bool bClone);

    bool Hash(LPCWSTR wszName, LPWSTR wszHash);
    HRESULT InstanceToFile(IWbemClassObject* pInst, LPCWSTR wszClassName,
                            LPCWSTR wszFileName, __int64 nClassTime);
    HRESULT ConstructInstanceDefName(LPWSTR wszInstanceDefName, LPCWSTR wszKey);
    HRESULT ClassToFile(_IWmiObject* pSuperClass, _IWmiObject* pClass, 
                        LPCWSTR wszFileName, __int64 nFakeUpdateTime = 0);
    HRESULT ConstructClassName(LPCWSTR wszClassName, 
                                            LPWSTR wszFileName);
    HRESULT TryGetShortcut(LPWSTR wszPath, DWORD dwFlags, REFIID riid,
                            LPVOID *pObj);
    HRESULT ComputeKeyFromPath(LPWSTR wszPath, LPWSTR wszKey, 
                                LPWSTR* pwszClassName, bool* pbIsClass,
                                LPWSTR* pwszNamespace = NULL);
    HRESULT ParseKey(LPWSTR wszKeyStart, LPWSTR* pwcRealStart,
                                    LPWSTR* pwcNextKey);

    HRESULT GetInstanceByKey(LPCWSTR wszClassName, LPCWSTR wszKey,
                                REFIID riid, void** ppObj);
    HRESULT WriteClassRelationships(_IWmiObject* pClass, LPCWSTR wszFileName);
    HRESULT ConstructParentChildFileName(LPCWSTR wszChildFileName, 
                                    LPCWSTR wszParentName,
                                    LPWSTR wszParentChildFileName);
    HRESULT DeleteDerivedClasses(LPCWSTR wszClassName, CEventCollector &aEvents);
    HRESULT EraseParentChildRelationship(LPCWSTR wszChildFileName, 
                                        LPCWSTR wszParentName);
    HRESULT EraseClassRelationships(LPCWSTR wszClassName,
                                _IWmiObject* pClass, LPCWSTR wszFileName);
    HRESULT GetClassByHash(LPCWSTR wszHash, bool bClone, _IWmiObject** ppClass,
                            __int64* pnTime = NULL, bool* pbRead = NULL);
    HRESULT DeleteClassByHash(LPCWSTR wszHash, CEventCollector &aEvents);
    HRESULT DeleteClassInternal(LPCWSTR wszClassName, _IWmiObject* pClass,
                                LPCWSTR wszFileName, CEventCollector &aEvents);
    HRESULT GetChildHashes(LPCWSTR wszClassName, CWStringArray& wsChildHashes);
    HRESULT GetChildDefs(LPCWSTR wszClassName, bool bRecursive,
                                    IWbemObjectSink* pSink, bool bClone);
    HRESULT ConstructClassDefFileName(LPCWSTR wszClassName, LPWSTR wszFileName);
    HRESULT ConstructClassDefFileNameFromHash(LPCWSTR wszHash, 
                                            LPWSTR wszFileName);
    HRESULT ConstructClassRelationshipsDirFromHash(LPCWSTR wszHash, 
                                        LPWSTR wszDirPath);
    HRESULT GetChildHashesByHash(LPCWSTR wszHash, CWStringArray& wsChildHashes);
    HRESULT GetChildDefsByHash(LPCWSTR wszHash, bool bRecursive,
                                    IWbemObjectSink* pSink, bool bClone);
    HRESULT FireEvent(CEventCollector &aEvents, DWORD dwType, LPCWSTR wszArg1, _IWmiObject* pObj1, 
                                    _IWmiObject* pObj2 = NULL);
    HRESULT DeleteSelf(CEventCollector &aEvents);
    HRESULT DeleteInstanceAsScope(_IWmiObject* pInst, CEventCollector &aEvents);
    HRESULT DeleteInstanceSelf(LPCWSTR wszFilePath, _IWmiObject* pInst,
                                bool bClassDeletion);
    HRESULT ConstructReferenceDir(LPWSTR wszTargetPath, LPWSTR wszDir);
    HRESULT ConstructReferenceDirFromKey(LPCWSTR wszClassName,
                                LPCWSTR wszKey, LPWSTR wszReferenceDir);
    HRESULT ConstructReferenceFileName(LPWSTR wszReference,
                        LPCWSTR wszReferringFile, LPWSTR wszReferenceFile);
    HRESULT ConstructKeyRootDirFromClass(LPWSTR wszDir, LPCWSTR wszClassName);
    HRESULT ConstructKeyRootDirFromKeyRoot(LPWSTR wszDir, 
                                                    LPCWSTR wszKeyRootClass);
    HRESULT ConstructLinkDirFromClass(LPWSTR wszDir, LPCWSTR wszClassName);
    HRESULT WriteInstanceLinkByHash(LPCWSTR wszClassName,
                                                LPCWSTR wszInstanceHash);
    HRESULT DeleteInstanceLink(_IWmiObject* pInst, 
                                LPCWSTR wszInstanceDefFilePath);
    HRESULT GetKeyRoot(LPCWSTR wszClass, 
                                     TEMPFREE_ME LPWSTR* pwszKeyRootClass);
    HRESULT ConstructInstDefNameFromLinkName(LPWSTR wszInstanceDefName,
                                             LPCWSTR wszInstanceLinkName);
    HRESULT ExecDeepInstanceQuery(QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                                LPCWSTR wszClassHash,
                                IWbemObjectSink* pSink);
    HRESULT ExecShallowInstanceQuery(QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                                LPCWSTR wszClassHash, 
                                IWbemObjectSink* pSink);
    HRESULT GetKeyRootByHash(LPCWSTR wszClassHash, 
                                     TEMPFREE_ME LPWSTR* pwszKeyRootClass);
    HRESULT ConstructKeyRootDirFromClassHash(LPWSTR wszDir,
                                            LPCWSTR wszClassHash);
    HRESULT ConstructLinkDirFromClassHash(LPWSTR wszDir, LPCWSTR wszClassHash);
    HRESULT ConstructClassReferenceFileName(LPCWSTR wszReferredToClass,
                                LPCWSTR wszReferringFile, 
                                LPCWSTR wszReferringProp,
                                LPWSTR wszFieName);
    HRESULT WriteClassReference(_IWmiObject* pReferringClass,
                            LPCWSTR wszReferringFile,
                            LPCWSTR wszReferringProp);
    HRESULT EraseClassReference(_IWmiObject* pReferringClass,
                            LPCWSTR wszReferringFile,
                            LPCWSTR wszReferringProp);
    CFileCache* GetFileCache();
	
	HRESULT CanClassBeUpdatedCompatible(DWORD dwFlags, LPCWSTR wszClassName, 
                _IWmiObject *pOldClass, _IWmiObject *pNewClass);
    HRESULT DeleteInstanceBackReferences(LPCWSTR wszFilePath);
    HRESULT ConstructReferenceDirFromFilePath(LPCWSTR wszFilePath, 
                                                LPWSTR wszReferenceDir);

	HRESULT ClassHasChildren(LPCWSTR wszClassName);
	HRESULT ClassHasInstances(LPCWSTR wszClassName);
	HRESULT ClassHasInstancesFromClassHash(LPCWSTR wszClassHash);
    HRESULT ClassHasInstancesInScopeFromClassHash(
                            LPCWSTR wszInstanceRootDir, LPCWSTR wszClassHash);

	HRESULT UpdateClassCompatible(_IWmiObject* pSuperClass, 
                LPCWSTR wszClassName, _IWmiObject *pNewClass, 
                _IWmiObject *pOldClass, __int64 nFakeUpdateTime = 0);
	HRESULT UpdateClassCompatibleHash(_IWmiObject* pSuperClass, 
                LPCWSTR wszClassHash, _IWmiObject *pClass, 
                _IWmiObject *pOldClass, __int64 nFakeUpdateTime = 0);
	HRESULT UpdateClassSafeForce(_IWmiObject* pSuperClass, DWORD dwFlags, 
                LPCWSTR wcsClassName, _IWmiObject *pOldClass, 
                _IWmiObject *pNewClass, CEventCollector &aEvents);
	HRESULT UpdateClassAggressively(_IWmiObject* pSuperClass, DWORD dwFlags, 
                LPCWSTR wszClassName, _IWmiObject *pNewClass, 
                _IWmiObject *pOldClass, bool bValidateOnly, 
                CEventCollector &aEvents);
	HRESULT UpdateChildClassAggressively(DWORD dwFlags, LPCWSTR wszClassHash, 
                _IWmiObject *pNewClass, bool bValidateOnly, 
                CEventCollector &aEvents);
};

class CDbIterator : public CUnkBase2<IWmiDbIterator, &IID_IWmiDbIterator,
                                     IWbemObjectSink, &IID_IWbemObjectSink>
{
protected:
    CCritSec m_cs;
    CRefedPointerQueue<IWbemClassObject> m_qObjects;
    long m_lCurrentIndex;
    void* m_pExecFiber;
    CFiberTask* m_pExecReq;
    HRESULT m_hresStatus;
    
    void* m_pMainFiber;
    DWORD m_dwNumRequested;

    HRESULT m_hresCancellationStatus;
    bool m_bExecFiberRunning;

public:
    CDbIterator(CLifeControl* pControl);
    ~CDbIterator();

     STDMETHOD(Cancel) (DWORD dwFlags);

     STDMETHOD(NextBatch)(
      DWORD dwNumRequested,
      DWORD dwTimeOutSeconds,
      DWORD dwFlags,
      DWORD dwRequestedHandleType,
      REFIID riid,
      DWORD *pdwNumReturned,
      LPVOID *ppObjects
     );

    void SetExecFiber(void* pFiber, CFiberTask* pReq);
    
    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects);
    STDMETHOD(SetStatus)(long lFlags, HRESULT hresResult, 
                                    BSTR, IWbemClassObject*);
};
    

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a51\filecach.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __WMI_A51_FILECACHE_H_
#define __WMI_A51_FILECACHE_H_

#include "stage.h"
#include <set>
#include <string>

class CFileCache
{
protected:
    CCritSec m_cs;
    WCHAR m_wszBaseName[MAX_PATH+1];
    DWORD m_dwBaseNameLen;

    CUniquePointerArray<CStagingFile> m_apStages;
    CRealStagingFile* m_pMainStage;

    long m_lRef;

public:
    class CFileEnumerator
    {
    protected:
        CFileCache* m_pCache;
        WCHAR m_wszPrefix[MAX_PATH+1];
        DWORD m_dwPrefixDirLen;
        int m_nCurrentStage;
        bool m_bUseFiles;
        void* m_pStageEnumerator;
        HANDLE m_hFileEnum;
        std::set<WString, WSiless> m_setSent;
		DWORD m_dwBaseNameLen;

    public:
        CFileEnumerator(CFileCache* pCache, DWORD dwBaseNameLen) 
             : m_pCache(pCache), m_nCurrentStage(-1), m_pStageEnumerator(NULL),
                            m_hFileEnum(NULL), m_dwBaseNameLen(dwBaseNameLen)
        {}
        ~CFileEnumerator();

        long GetFirst(LPCWSTR wszPrefix, WIN32_FIND_DATAW* pfd);
        long GetFirstFile(WIN32_FIND_DATAW* pfd);
        void ComputeCanonicalName(WIN32_FIND_DATAW* pfd, wchar_t *wszFilePath);
        long GetNext(WIN32_FIND_DATAW* pfd);
        long GetRawNext(WIN32_FIND_DATAW* pfd);
    };
    friend CFileEnumerator;

    class CFindCloseMe
    {
    protected:
        CFileCache* m_pCache;
        void* m_hSearch;
    public:
        CFindCloseMe(CFileCache* pCache, void* hSearch) 
            : m_pCache(pCache), m_hSearch(hSearch){}

        ~CFindCloseMe() 
        {
            if(m_pCache && m_hSearch) m_pCache->FindClose(m_hSearch);
        }
    };

protected:
    int GetNumStages() {return m_apStages.GetSize();}
    INTERNAL CStagingFile* GetStageFile(int nIndex) {return m_apStages[nIndex];}
    INTERNAL CStagingFile* GetMainStagingFile() {return m_pMainStage;}

public:
    CFileCache();
    ~CFileCache();
    void Clear();
    bool IsFullyFlushed();

    long Initialize(LPCWSTR wszBaseName);
    long RepositoryExists(LPCWSTR wszBaseName);
    long WriteFile(LPCWSTR wszFileName, DWORD dwLen, BYTE* pBuffer);
    long ReadFile(LPCWSTR wszFileName, DWORD* pdwLen, BYTE** ppBuffer, 
                    bool bMustBeThere = false);
    long DeleteFile(LPCWSTR wszFileName);
    long RemoveDirectory(LPCWSTR wszFileName, bool bMustSucceed = true);
    long FindFirst(LPCWSTR wszFilePrefix, WIN32_FIND_DATAW* pfd,
                            void** ppHandle);
    long FindNext(void* pHandle, WIN32_FIND_DATAW* pfd);
    void FindClose(void* pHandle);

    long BeginTransaction();
    long CommitTransaction();
    long AbortTransaction();

    CCritSec* GetLock() {return &m_cs;}

    long AddRef() {return InterlockedIncrement(&m_lRef);}
    long Release() {long lRet = InterlockedDecrement(&m_lRef); if (!lRet) delete this; return lRet;}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a51\filecach.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <windows.h>
#include <wbemcomn.h>
#include "filecach.h"

long CFileCache::Initialize(LPCWSTR wszBaseName)
{
    long lRes;

    wcscpy(m_wszBaseName, wszBaseName);
    wcscat(m_wszBaseName, L"\\");
    m_dwBaseNameLen = wcslen(m_wszBaseName);

    //
    // Read the maximum stage-file size from the registry
    //

    HKEY hKey;
    lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ | KEY_WRITE, &hKey);
    if(lRes)
        return lRes;
    CRegCloseMe cm(hKey);

    DWORD dwLen = sizeof(DWORD);
    DWORD dwMaxLen;
    lRes = RegQueryValueExW(hKey, L"Max Stage File Size", NULL, NULL, 
                (LPBYTE)&dwMaxLen, &dwLen);

    //
    // If not there, set to default and write the default into the registry
    //

    if(lRes != ERROR_SUCCESS)
    {
        dwMaxLen = 5000000;
        lRes = RegSetValueExW(hKey, L"Max Stage File Size", 0, REG_DWORD, 
                (LPBYTE)&dwMaxLen, sizeof(DWORD));
    }

    dwLen = sizeof(DWORD);
    DWORD dwAbortTransactionLen;
    lRes = RegQueryValueExW(hKey, L"Absolute Max Stage File Size", NULL, NULL, 
                (LPBYTE)&dwAbortTransactionLen, &dwLen);

    //
    // If not there, set to default and write the default into the registry
    //

    if(lRes != ERROR_SUCCESS || dwAbortTransactionLen == dwMaxLen * 10)
    {
        dwAbortTransactionLen = 0x7FFFFFFF;
        lRes = RegSetValueExW(hKey, L"Absolute Max Stage File Size", 0, 
                REG_DWORD, (LPBYTE)&dwAbortTransactionLen, sizeof(DWORD));
    }

    if(dwMaxLen == 0)
    {
        //
        // Staged writes are disabled!
        //

        m_pMainStage = NULL;
    }
    else
    {
        //
        // Create the main staging area
        //
    
        CFileName wszStagingName;
		if (wszStagingName == NULL)
			return ERROR_OUTOFMEMORY;
        swprintf(wszStagingName, L"%s\\MainStage.dat", wszBaseName);
    
        m_pMainStage = new CExecutableStagingFile(this, m_wszBaseName, 
                                              dwMaxLen, dwAbortTransactionLen);
/*
        m_pMainStage = new CPermanentStagingFile(this, m_wszBaseName);
*/
    
        if(m_pMainStage == NULL)
            return E_OUTOFMEMORY;
    
        long lRes = m_pMainStage->Create(wszStagingName);
        if(lRes != ERROR_SUCCESS)
            return lRes;
    
        if(m_apStages.Add(m_pMainStage) < 0)
        {
            delete m_pMainStage;
            return E_OUTOFMEMORY;
        }
    }
    return ERROR_SUCCESS;
}

long CFileCache::RepositoryExists(LPCWSTR wszBaseName)
{
    CFileName wszStagingName;
	if (wszStagingName == NULL)
		return ERROR_OUTOFMEMORY;
    swprintf(wszStagingName, L"%s\\MainStage.dat", wszBaseName);

    DWORD dwAttributes = GetFileAttributesW(wszStagingName);
    if (dwAttributes == -1)
        return ERROR_FILE_NOT_FOUND;
    return ERROR_SUCCESS;

}

CFileCache::CFileCache()
: m_lRef(0)
{
}

CFileCache::~CFileCache()
{
    Clear();
}

void CFileCache::Clear()
{
}

bool CFileCache::IsFullyFlushed()
{
    CInCritSec ics(&m_cs);

    for(int i = 0; i < m_apStages.GetSize(); i++)
    {
        if(!m_apStages[i]->IsFullyFlushed())
            return false;
    }
    return true;
}


long CFileCache::WriteFile(LPCWSTR wszFileName, DWORD dwLen, BYTE* pBuffer)
{
    CInCritSec ics(&m_cs);

    //
    // Write the file into the main staging file
    //

    if(GetMainStagingFile())
    {
        return GetMainStagingFile()->WriteFile(wszFileName + m_dwBaseNameLen, 
                                            dwLen, pBuffer);
    }
    else
    {
        long lRes = A51WriteFile(wszFileName, dwLen, pBuffer);
        _ASSERT(lRes == ERROR_SUCCESS, L"Failed to create a file");
        return lRes;
    }
}

long CFileCache::DeleteFile(LPCWSTR wszFileName)
{
    CInCritSec ics(&m_cs);

    //
    // Write the file into the main staging file
    //

    if(GetMainStagingFile())
    {
        return GetMainStagingFile()->DeleteFile(wszFileName + m_dwBaseNameLen);
    }
    else
    {
        long lRes = A51DeleteFile(wszFileName);
        _ASSERT(lRes == ERROR_SUCCESS || lRes == ERROR_FILE_NOT_FOUND ||
                lRes == ERROR_PATH_NOT_FOUND, L"Failed to delete file");
        return lRes;
    }
    
}

long CFileCache::RemoveDirectory(LPCWSTR wszFileName, bool bMustSucceed)
{
    CInCritSec ics(&m_cs);

    //
    // Write the file into the main staging file
    //

    if(GetMainStagingFile())
    {
        return GetMainStagingFile()->
                    RemoveDirectory(wszFileName + m_dwBaseNameLen);
    }
    else
    {
        long lRes = A51RemoveDirectory(wszFileName);
        _ASSERT(lRes == ERROR_SUCCESS || 
                lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND ||
                lRes == ERROR_DIR_NOT_EMPTY, 
                    L"Failed to remove directory");

/*
        _ASSERT(!bMustSucceed || lRes != ERROR_DIR_NOT_EMPTY,
            L"Stuff in directory that should be empty");
*/

        return lRes;
    }
}
    
HRESULT CFileCache::ReadFile(LPCWSTR wszFileName, DWORD* pdwLen, 
                                BYTE** ppBuffer, bool bMustBeThere)
{
    long lRes;

    CInCritSec ics(&m_cs);

    //
    // Search all staging files in order
    //

    for(int i = 0; i < m_apStages.GetSize(); i++)
    {
        lRes = m_apStages[i]->ReadFile(wszFileName + m_dwBaseNameLen, pdwLen,
                                        ppBuffer, bMustBeThere);
        if(lRes != ERROR_NO_INFORMATION)
        {
            if(lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND &&
                    lRes != ERROR_PATH_NOT_FOUND)
            {
                ERRORTRACE((LOG_WBEMCORE, "Repository driver cannot read file "
                    "'%S' from the stage with error code %d\n", wszFileName,
                            lRes));
            }
            return lRes;
        }
    }
    
    //
    // Not in the staging areas --- get from disk!
    //

    WIN32_FIND_DATAW fd;
    HANDLE hSearch = ::FindFirstFileW(wszFileName, &fd);
    if(hSearch == INVALID_HANDLE_VALUE)
    {
        lRes = GetLastError();
        //_ASSERT(!bMustBeThere, L"Must-be-there file is not found!");
        _ASSERT(lRes != ERROR_SUCCESS, L"Success reported on failure");
        if(lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND)
            return ERROR_FILE_NOT_FOUND;
        else
            return lRes;
    }
    else    
        ::FindClose(hSearch);
    
    HANDLE hFile = CreateFileW(wszFileName, GENERIC_READ, FILE_SHARE_READ,
                NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    lRes = GetLastError();
    A51TRACE(("Reading %S returned %d\n", wszFileName, lRes));
    if(hFile == INVALID_HANDLE_VALUE)
    {
        _ASSERT(lRes != ERROR_SUCCESS, L"Success reported on failure");
        if(lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_PATH_NOT_FOUND)
        {
            ERRORTRACE((LOG_WBEMCORE, "Repository driver unable to open file "
                "'%S' with error code %d\n", wszFileName, lRes));
        }
        //_ASSERT(!bMustBeThere, L"Must-be-there file is not found!");
        return lRes;
    }


    CCloseMe cm(hFile);

/*
    BY_HANDLE_FILE_INFORMATION fi;
    if(!GetFileInformationByHandle(hFile, &fi))
    {
        _ASSERT(!bMustBeThere, L"Must-be-there file is not found!");
        return GetLastError();
    }
*/

    // BUG: instances must be less than 4G :-)

    //
    // Try to read one byte more than what FindFirstFile told us.  This is 
    // important because FindFirstFile has been known to lie about the size of
    // the file.  If it told us too low a number, then this longer read will
    // succeed, and we will know we've been had. 
    //
    
    // *pdwLen = fi.nFileSizeLow;
    *pdwLen = fd.nFileSizeLow + 1;
    *ppBuffer = (BYTE*)TempAlloc(*pdwLen);
    if(*ppBuffer == NULL)
        return E_OUTOFMEMORY;

    DWORD dwRead;
    if(!::ReadFile(hFile, *ppBuffer, *pdwLen, &dwRead, NULL))
    {
        lRes = GetLastError();
        ERRORTRACE((LOG_WBEMCORE, "Repository driver unable to read %d bytes "
            "from file with error %d\n", *pdwLen, lRes));
        _ASSERT(lRes != ERROR_SUCCESS, L"Success reported on failure");
        TempFree(*ppBuffer);
        //_ASSERT(!bMustBeThere, L"Must-be-there file is not found!");
        return lRes;
    }
    else 
    {
        if(dwRead == *pdwLen - 1)
        {
            // Got the right number of bytes --- remember we incrememented it
            // to catch liers

            (*pdwLen)--;
            return ERROR_SUCCESS;
        }
        else 
        {
            //
            // We were lied to by FindFirstFile.  Get the real file length and
            // try again
            //

            TempFree(*ppBuffer);
            *ppBuffer = NULL;

            BY_HANDLE_FILE_INFORMATION fi;
            if(!GetFileInformationByHandle(hFile, &fi))
            {
                return GetLastError();
            }

            SetFilePointer(hFile, 0, 0, FILE_BEGIN);

            //
            // Allocate the buffer from scratch
            //

            *pdwLen = fi.nFileSizeLow;
            *ppBuffer = (BYTE*)TempAlloc(*pdwLen);
            if(*ppBuffer == NULL)
                return E_OUTOFMEMORY;
        
            DWORD dwRead;
            if(!::ReadFile(hFile, *ppBuffer, *pdwLen, &dwRead, NULL))
            {
                lRes = GetLastError();
                ERRORTRACE((LOG_WBEMCORE, "Repository driver unable to read %d "
                    "bytes from file with error %d\n", *pdwLen, lRes));
                _ASSERT(lRes != ERROR_SUCCESS, L"Success reported on failure");
                TempFree(*ppBuffer);
                //_ASSERT(!bMustBeThere, L"Must-be-there file is not found!");
                return lRes;
            }
            else 
            {
                if(*pdwLen != dwRead)
                {
                    _ASSERT(false, L"Read the wrong number of bytes");
                    TempFree(*ppBuffer);
                    return E_OUTOFMEMORY;
                }
                else
                    return ERROR_SUCCESS;
            }
        }
    }
}


long CFileCache::FindFirst(LPCWSTR wszFilePrefix, WIN32_FIND_DATAW* pfd,
                            void** ppHandle)
{
    CInCritSec ics(&m_cs);

    //
    // Construct an enumerator 
    //

    CFileEnumerator* pEnum = new CFileEnumerator(this, m_dwBaseNameLen);
	if (pEnum == NULL)
		return E_OUTOFMEMORY;
    long lRes = pEnum->GetFirst(wszFilePrefix, pfd);
    if(lRes != ERROR_SUCCESS)
    {
        delete pEnum;
        return lRes;
    }

    *ppHandle = (void*)pEnum;
    return ERROR_SUCCESS;
}

long CFileCache::FindNext(void* pHandle, WIN32_FIND_DATAW* pfd)
{
    CInCritSec ics(&m_cs);

    CFileEnumerator* pEnum = (CFileEnumerator*)pHandle;
    return pEnum->GetNext(pfd);
}


void CFileCache::FindClose(void* pHandle)
{
    CInCritSec ics(&m_cs);

    delete (CFileEnumerator*)pHandle;
}
    
long CFileCache::BeginTransaction()
{
    if(GetMainStagingFile())
        return GetMainStagingFile()->BeginTransaction();
    else
        return ERROR_SUCCESS;
}

long CFileCache::CommitTransaction()
{
    A51TRACE(("Committing Transaction!\n"));
    if(GetMainStagingFile())
        return GetMainStagingFile()->CommitTransaction();
    else
        return ERROR_SUCCESS;
}

long CFileCache::AbortTransaction()
{
    A51TRACE(("Aborting Transaction!\n"));
    if(GetMainStagingFile())
        return GetMainStagingFile()->AbortTransaction();
    else
        return ERROR_SUCCESS;
}


CFileCache::CFileEnumerator::~CFileEnumerator()
{
    if(m_pStageEnumerator)
        m_pCache->GetStageFile(m_nCurrentStage)->FindClose(m_pStageEnumerator);

    if(m_hFileEnum)
        ::FindClose(m_hFileEnum);
}

long CFileCache::CFileEnumerator::GetFirst(LPCWSTR wszPrefix, 
                                            WIN32_FIND_DATAW* pfd)
{
    long lRes;

    wcscpy(m_wszPrefix, wszPrefix);

    WCHAR* pwcLastSlash = wcsrchr(m_wszPrefix, L'\\');
    if(pwcLastSlash == NULL)
        return E_OUTOFMEMORY;

    m_dwPrefixDirLen = pwcLastSlash - m_wszPrefix;

    //
    // We are going to start with the first staging area
    //

    m_nCurrentStage = 0;
    m_bUseFiles = false;

    //
    // Everything is set up to indicate that we are at the very beginning ---
    // GetNext will retrieve the first
    //

    lRes = GetNext(pfd);
    
    //
    // One last thing --- absense of files is ERROR_NO_MORE_FILES for GetNext,
    // but ERROR_FILE_NOT_FOUND for GetFirst, so translate
    //

    if(lRes == ERROR_NO_MORE_FILES)
        lRes = ERROR_FILE_NOT_FOUND;

    return lRes;
}

long CFileCache::CFileEnumerator::GetFirstFile(WIN32_FIND_DATAW* pfd)
{
    m_bUseFiles = true;

    CFileName wszMask;
	if (wszMask == NULL)
		return ERROR_OUTOFMEMORY;
    wcscpy(wszMask, m_wszPrefix);
    wcscat(wszMask, L"*");

    m_hFileEnum = ::FindFirstFileW(wszMask, pfd);
    long lRes = GetLastError();
    A51TRACE(("Actual FindFirstFileW on %S returning %p %d\n",
        wszMask, (void*)m_hFileEnum, lRes));
    if(m_hFileEnum == INVALID_HANDLE_VALUE)
    {
        if(lRes == ERROR_PATH_NOT_FOUND)
            return ERROR_FILE_NOT_FOUND;
        else
            return lRes;
    }
    else
        return ERROR_SUCCESS;
}

void CFileCache::CFileEnumerator::ComputeCanonicalName(WIN32_FIND_DATAW* pfd,
                                                    wchar_t *wszFilePath)
{
    wcsncpy(wszFilePath, m_wszPrefix, m_dwPrefixDirLen+1);
    wbem_wcsupr(wszFilePath+m_dwPrefixDirLen+1, pfd->cFileName);
}

long CFileCache::CFileEnumerator::GetNext(WIN32_FIND_DATAW* pfd)
{
    long lRes;

    //
    // Go through the files in the enumerator until we find a new and valid one
    //

    while((lRes = GetRawNext(pfd)) == ERROR_SUCCESS)
    {
        //
        // Compute the full name
        //

        CFileName wszFullName;
		if (wszFullName == NULL)
			return ERROR_OUTOFMEMORY;
        ComputeCanonicalName(pfd, wszFullName);

        //
        // Check if it is already in our map of returned files
        //

        if(m_setSent.find((const wchar_t*)wszFullName) != m_setSent.end())
            continue;

        //
        // Check if this file is deleted
        //

        bool bDeleted = false;
        for(int i = 0; i < m_nCurrentStage; i++)
        {
			long hres = m_pCache->GetStageFile(i)->IsDeleted(wszFullName + m_dwBaseNameLen);
			if (hres == S_OK)
            {
                bDeleted = true;
                break;
            }
			else if (FAILED(hres))
			{
				return hres;
			}
        }

        if(bDeleted)
            continue;

        //
        // All clear!
        //

        if(!m_bUseFiles)
            m_setSent.insert((const wchar_t*)wszFullName);

        return ERROR_SUCCESS;
    }

    return lRes;
}

long CFileCache::CFileEnumerator::GetRawNext(WIN32_FIND_DATAW* pfd)
{
    long lRes;

    if(m_bUseFiles)
    {
        //
        // Get the next file
        //

        if(!FindNextFileW(m_hFileEnum, pfd))
        {
            lRes = GetLastError();
            ::FindClose(m_hFileEnum);
            m_hFileEnum = NULL;
            return lRes;
        }
        else
        {
            return ERROR_SUCCESS;
        }
    }
    else
    {
        //
        // Check if we even have a stage enumerator
        //

        if(m_pStageEnumerator)
        {
            // 
            // Get the next file from the same stage
            //
    
            lRes = m_pCache->GetStageFile(m_nCurrentStage)->
                        FindNext(m_pStageEnumerator, pfd);
            if(lRes != ERROR_NO_MORE_FILES)
                return lRes;
    
            //
            // Advance to the next one
            //
        
            m_pCache->GetStageFile(m_nCurrentStage)->
                    FindClose(m_pStageEnumerator);
            m_pStageEnumerator = NULL;
            m_nCurrentStage++;
        }
        else
        {
            //
            // This is our first time --- we are all set up to pick up the first
            // file from the first stage
            //
        }

        while(1)
        {
            if(m_nCurrentStage >= m_pCache->GetNumStages())
            {
                //
                // Go to files
                //
    
                lRes = GetFirstFile(pfd);
                if(lRes == ERROR_FILE_NOT_FOUND)
                    return ERROR_NO_MORE_FILES;
                else
                    return lRes;
            }
            else
            {
                //
                // Initialize the next stage
                //
    
                lRes = m_pCache->GetStageFile(m_nCurrentStage)->
                            FindFirst(m_wszPrefix + m_dwBaseNameLen, pfd, &m_pStageEnumerator);
                if(lRes == ERROR_FILE_NOT_FOUND)
                {
                    //
                    // This stage has nothing to contribute --- move along
                    //

                    m_nCurrentStage++;
                    continue;
                }
                else
                    return lRes;
            }
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a51\lock.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    LOCK.CPP

Abstract:

    Implements the generic class for obtaining read and write locks to some 
    resource. 

    See lock.h for all documentation.

    Classes defined:

    CLock

History:

    a-levn  5-Sept-96       Created.
    3/10/97     a-levn      Fully documented

--*/

#include "precomp.h"
#include <stdio.h>
#include "lock.h"
#include <stdio.h>

// debugging.
#define PRINTF

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

CLock::CLock() : m_nReading(0), m_nWriting(0), m_nWaitingToRead(0),
            m_nWaitingToWrite(0)
{
    // Initialize the critical sections
    // ================================

    InitializeCriticalSection(&m_csAll);
    InitializeCriticalSection(&m_csEntering);

    // Create unnamed events for reading and writing
    // =============================================

    m_hCanRead = CreateEvent(NULL, TRUE, TRUE, NULL);
    m_hCanWrite = CreateEvent(NULL, TRUE, TRUE, NULL);
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************
CLock::~CLock()
{
    CloseHandle(m_hCanWrite);
    CloseHandle(m_hCanRead);
    DeleteCriticalSection(&m_csAll);
    DeleteCriticalSection(&m_csEntering);
}

BOOL CLock::IsHoldingReadLock()
{
    // Check if this thread already owns this lock
    // ===========================================

    EnterCriticalSection(&m_csAll);
    DWORD_PTR dwThreadId = GetCurrentThreadId();
    for(int i = 0; i < m_adwReaders.Size(); i++)
    {
        if(dwThreadId == (DWORD_PTR)m_adwReaders[i])
        {
            LeaveCriticalSection(&m_csAll);
            return TRUE;
        }
    }

    LeaveCriticalSection(&m_csAll);
    return FALSE;
}
    

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************
int CLock::ReadLock(DWORD dwTimeout)
{
    PRINTF("%d wants to read\n", GetCurrentThreadId());

    // Check if this thread already owns this lock
    // ===========================================

    EnterCriticalSection(&m_csAll);
    DWORD_PTR dwThreadId = GetCurrentThreadId();
    for(int i = 0; i < m_adwReaders.Size(); i++)
    {
        if(dwThreadId == (DWORD_PTR)m_adwReaders[i])
        {
            // We already have it --- add it to the list and return
            // ====================================================

            m_adwReaders.Add((void*)dwThreadId);
            m_nReading++;
            LeaveCriticalSection(&m_csAll);
            return NoError;
        }
    }

    // Don't have it already
    // =====================
        
    LeaveCriticalSection(&m_csAll);

    // Get in line for getting any kind of lock (those unlocking don't go into
    // this line)
    // =======================================================================

    EnterCriticalSection(&m_csEntering);

    // We are the only ones allowed to get any kind of lock now. Wait for the
    // event indicating that reading is enabled to become signaled
    // ======================================================================

    PRINTF("%d next to enter\n", GetCurrentThreadId());
    if(m_nWriting != 0)
    {
        int nRes = WaitFor(m_hCanRead, dwTimeout);
        if(nRes != NoError)
        {
            LeaveCriticalSection(&m_csEntering);
            return nRes;
        }
    }

    // Enter inner critical section (unlockers use it too), increment the
    // number of readers and disable writing.
    // ==================================================================

    PRINTF("%d got event\n", GetCurrentThreadId());
    EnterCriticalSection(&m_csAll);
    m_nReading++;
    m_adwReaders.Add((void*)dwThreadId);
    PRINTF("Reset write\n");
    ResetEvent(m_hCanWrite);
    PRINTF("Done\n");

    // Get out of all critical sections and return
    // ===========================================

    LeaveCriticalSection(&m_csAll);
    LeaveCriticalSection(&m_csEntering);
    PRINTF("%d begins to read\n", GetCurrentThreadId());

    return NoError;
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::ReadUnlock()
{
    PRINTF("%d wants to unlock reading\n", GetCurrentThreadId());

    // Enter internal ciritcal section and decrement the number of readers
    // ===================================================================

    EnterCriticalSection(&m_csAll);

    m_nReading--;
    if(m_nReading < 0) return Failed;

    // Remove it from the list of threads
    // ==================================

    DWORD_PTR dwThreadId = GetCurrentThreadId();
    for(int i = 0; i < m_adwReaders.Size(); i++)
    {
        if((DWORD_PTR)m_adwReaders[i] == dwThreadId)
        {
            m_adwReaders.RemoveAt(i);
            break;
        }
    }

    // If all reasders are gone, allow writers in
    // ==========================================

    if(m_nReading == 0)
    {
            PRINTF("%d is the last reader\n", GetCurrentThreadId());
            PRINTF("Set write\n");
            if(!SetEvent(m_hCanWrite))
            {
                    LeaveCriticalSection(&m_csAll);
                    return Failed;
            }
            PRINTF("Done\n");
    }
    else PRINTF("%d sees %d still reading\n", GetCurrentThreadId(), m_nReading);

    // Get out and return
    // ==================

    LeaveCriticalSection(&m_csAll);
    return NoError;
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::WriteLock(DWORD dwTimeout)
{
    PRINTF("%d wants to write\n", GetCurrentThreadId());

    // Get in line for getting any kind of lock. Those unlocking don't use this
    // critical section.
    // ========================================================================

    EnterCriticalSection(&m_csEntering);

    // We are the only ones allowed to get any kind of lock now
    // ========================================================

    PRINTF("%d next to enter\n", GetCurrentThreadId());

    // Wait for the event allowing writing to become signaled
    // ======================================================

    int nRes = WaitFor(m_hCanWrite, dwTimeout);
    PRINTF("%d got event\n", GetCurrentThreadId());
    if(nRes != NoError)
    {
            LeaveCriticalSection(&m_csEntering);
            return nRes;
    }

    // Enter internal critical section (unlockers use it too), increment the
    // number of writers (from 0 to 1) and disable both reading and writing
    // from now on.
    // ======================================================================

    EnterCriticalSection(&m_csAll);
    m_nWriting++;
    PRINTF("Reset both\n");
    ResetEvent(m_hCanWrite);
    ResetEvent(m_hCanRead);
    PRINTF("Done\n");

    // Get out and return
    // ==================

    LeaveCriticalSection(&m_csAll);
    LeaveCriticalSection(&m_csEntering);
    PRINTF("%d begins to write\n", GetCurrentThreadId());

    return NoError;
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::WriteUnlock()
{
    PRINTF("%d wants to release writing\n", GetCurrentThreadId());

    // Enter lock determination critical section
    // =========================================

    EnterCriticalSection(&m_csAll);

    m_nWriting--;
    if(m_nWriting < 0) return Failed;

    // Allow readers and writers in
    // ============================

    PRINTF("%d released writing\n", GetCurrentThreadId());

    PRINTF("Set both\n");
    if(!SetEvent(m_hCanRead))
    {
            LeaveCriticalSection(&m_csAll);
            return Failed;
    }
    else if(!SetEvent(m_hCanWrite))
    {
            LeaveCriticalSection(&m_csAll);
            return Failed;
    }
    else
    {
            PRINTF("Done\n");
            LeaveCriticalSection(&m_csAll);
            return NoError;
    }
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::DowngradeLock()
{
    // Enter lock determination critical section
    // =========================================

    EnterCriticalSection(&m_csAll);

    if(!SetEvent(m_hCanRead))
    {
        LeaveCriticalSection(&m_csAll);
        return Failed;
    }

    m_nReading++;

    LeaveCriticalSection(&m_csAll);

    return NoError;
}
    
    
    
//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::WaitFor(HANDLE hEvent, DWORD dwTimeout)
{
    DWORD dwRes;
    dwRes = WaitForSingleObject(hEvent, dwTimeout);

    // Analyze the error code and convert to ours
    // ==========================================

    if(dwRes == WAIT_OBJECT_0) return NoError;
    else if(dwRes == WAIT_TIMEOUT) return TimedOut;
    else return Failed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a51\hiecache.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __WMI_A51__HIECACHE__H_
#define __WMI_A51__HIECACHE__H_

//
// NOTE: it is critical that things be marked in the cache while the repository
// lock is held!  Otherwise, invalidation/completion logic will break
//

#include <wbemint.h>
#include <map>
#include <sync.h>
#include "a51tools.h"


class wcscless : public binary_function<LPCWSTR, LPCWSTR, bool> 
{
public:
    bool operator()(const LPCWSTR& wcs1, const LPCWSTR& wcs2) const
        {return wcscmp(wcs1, wcs2) < 0;}
};


class CClassRecord
{
protected:
    long m_lRef;
    LPWSTR m_wszClassName;
    WCHAR m_wszHash[MAX_HASH_LEN+1];

    _IWmiObject* m_pClassDef;
    DWORD m_dwClassDefSize;
    
    CClassRecord* m_pParent;
    bool m_bIsKeyed;
    CPointerArray<CClassRecord> m_apChildren;

    bool m_bTreeComplete;
    bool m_bChildrenComplete;
    LONGLONG m_lLastChildInvalidationIndex;

    DWORD m_dwLastUsed;
    CClassRecord* m_pMoreRecentlyUsed;
    CClassRecord* m_pLessRecentlyUsed;
    int m_nStatus;
    __int64 m_nClassDefCachedTime;
    bool m_bRead;

public:
    CClassRecord(LPCWSTR wszClassName, LPCWSTR wszHash);
    ~CClassRecord();

    void AddRef() {InterlockedIncrement(&m_lRef);}
    void Release() {if(InterlockedDecrement(&m_lRef) == 0) delete this;}

    HRESULT EnsureChild(CClassRecord* pChild);
    HRESULT RemoveChild(CClassRecord* pChild);

    friend class CHierarchyCache;
    friend class CForestCache;
};

class CForestCache;
class CHierarchyCache
{
protected:
    long m_lRef;
    typedef std::map<LPCWSTR, CClassRecord*, wcscless> TMap;
    typedef TMap::iterator TIterator;

    CForestCache* m_pForest;
    CCritSec m_cs;
    TMap m_map;
    LONGLONG m_lNextInvalidationIndex;
    HRESULT m_hresError;

public:
    CHierarchyCache(CForestCache* pForest);
    ~CHierarchyCache();
    long AddRef() {return InterlockedIncrement(&m_lRef);}
    long Release() {return InterlockedDecrement(&m_lRef);}

    HRESULT AssertClass(_IWmiObject* pClass, LPCWSTR wszClassName, 
                        bool bClone, __int64 nTime);
    HRESULT InvalidateClass(LPCWSTR wszClassName);

    HRESULT DoneWithChildren(LPCWSTR wszClassName, bool bRecursive, 
                            LONGLONG lStartingIndex, 
                            CClassRecord* pRecord = NULL);
    HRESULT DoneWithChildrenByHash(LPCWSTR wszHash, bool bRecursive,
                                LONGLONG lStartIndex);
    LONGLONG GetLastInvalidationIndex() {return m_lNextInvalidationIndex-1;}

    void SetError(HRESULT hresError);
    HRESULT GetError();

public:
    RELEASE_ME _IWmiObject* GetClassDef(LPCWSTR wszClassName, 
                                        bool bClone, __int64* pnTime = NULL,
                                        bool* pbRead = NULL);
    HRESULT EnumChildren(LPCWSTR wszClassName, bool bRecursive,
                            CWStringArray& awsChildren);
    HRESULT EnumChildKeysByKey(LPCWSTR wszClassKey, 
                            CWStringArray& awsChildKeys);
    HRESULT GetKeyRootByKey(LPCWSTR wszKey, 
                                    TEMPFREE_ME LPWSTR* pwszKeyRoot);
    HRESULT GetKeyRoot(LPCWSTR wszClassName, 
                                    TEMPFREE_ME LPWSTR* pwszKeyRoot);
    HRESULT GetKeyRootByRecord(CClassRecord* pRecord,
                                    TEMPFREE_ME LPWSTR* pwszKeyRoot);
    DELETE_ME LPWSTR GetParent(LPCWSTR wszClassName);
    RELEASE_ME _IWmiObject* GetClassDefByHash(LPCWSTR wszHash, bool bClone,
                                              __int64* pnTime = NULL,
                                              bool* pbRead = NULL);

protected:
    INTERNAL CClassRecord* FindClass(LPCWSTR wszClassName);
    INTERNAL CClassRecord* FindClassByKey(LPCWSTR wszKey);
    RELEASE_ME _IWmiObject* GetClassDefFromRecord(CClassRecord* pRecord,
                                                bool bClone);
    INTERNAL CClassRecord* EnsureClass(LPCWSTR wszClassName);
    HRESULT EnumChildrenInternal(CClassRecord* pRecord, 
                                        bool bRecursive,
                                        CWStringArray& awsChildren);

    HRESULT InvalidateClassInternal(CClassRecord* pRecord);
    HRESULT DoneWithChildrenByRecord(CClassRecord* pRecord,
                                bool bRecursive,  LONGLONG lStartIndex);
    static void MakeKey(LPCWSTR wszClassName, LPWSTR wszKey);
};

class CForestCache
{
protected:
    CCritSec m_cs;

    CClassRecord* m_pMostRecentlyUsed;
    CClassRecord* m_pLeastRecentlyUsed;
    DWORD m_dwMaxMemory;
    DWORD m_dwMaxAgeMs;
    DWORD m_dwTotalMemory;

    HANDLE m_hTimerQueue;
    HANDLE m_hCurrentTimer;
    HANDLE m_hCompletionEvent;

    typedef std::map<WString, CHierarchyCache*, WSiless> TMap;
    typedef TMap::iterator TIterator;

    TMap m_map;

    long m_lRef;

public:
    CForestCache() : m_dwMaxMemory(0xFFFFFFFF), m_dwTotalMemory(0),
        m_pMostRecentlyUsed(NULL), m_pLeastRecentlyUsed(NULL),
        m_dwMaxAgeMs(0), m_hTimerQueue(NULL), m_hCurrentTimer(NULL),
        m_hCompletionEvent(NULL), m_lRef(0)
    {
    }

    ~CForestCache();
    HRESULT Initialize();

    void SetMaxMemory(DWORD dwMaxMemory, DWORD dwMaxAgeMs);
    bool MakeRoom(DWORD dwSize);
    bool Flush();
    void MakeMostRecentlyUsed(CClassRecord* pRecord);
    void Add(CClassRecord* pRecord);
    void RemoveRecord(CClassRecord* pRecord);

public:
    CHierarchyCache* GetNamespaceCache(LPCWSTR wszNamespace);
    void ReleaseNamespaceCache(LPCWSTR wszNamespace, CHierarchyCache* pCache);
    long AddRef() {return InterlockedIncrement(&m_lRef);}
    long Release() {long lRet = InterlockedDecrement(&m_lRef);  if (!lRet) delete this; return lRet;}
protected:	
    CCritSec* GetLock() {return &m_cs;}
	bool Test();	
	void Untie(CClassRecord* pRecord);
    void TimerCallback();
    static void staticTimerCallback(VOID* pParam, BOOLEAN);
    friend class CHierarchyCache;

};
    
    
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a51\hiecache.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <wbemcomn.h>
#include "hiecache.h"
#include <malloc.h>
#include <corex.h>

int g_nRecords = 0;
int g_nCaches = 0;

CClassRecord::CClassRecord(LPCWSTR wszClassName, LPCWSTR wszHash)
    : m_wszClassName(NULL), m_pClassDef(NULL), m_pParent(NULL), 
        m_bIsKeyed(false), m_bTreeComplete(false), m_bChildrenComplete(false),
        m_lLastChildInvalidationIndex(-1), m_pMoreRecentlyUsed(NULL),
        m_pLessRecentlyUsed(NULL), m_lRef(0), m_nStatus(0)
{
    m_wszClassName = new WCHAR[wcslen(wszClassName)+1];
	if (m_wszClassName == NULL)
		throw CX_MemoryException();
    wcscpy(m_wszClassName, wszClassName);

    wcscpy(m_wszHash, wszHash);

    m_dwLastUsed = GetTickCount();
	g_nRecords++;
}

CClassRecord::~CClassRecord()
{
    delete [] m_wszClassName;
    if(m_pClassDef)
	{
		if(m_pClassDef->Release() != 0)
		{
			g_nRecords++;
			g_nRecords--;
		}
    }
	g_nRecords--;
}

HRESULT CClassRecord::EnsureChild(CClassRecord* pChild)
{
    A51TRACE(("Make %S child of %S\n", pChild->m_wszClassName,
            m_wszClassName));
    for(int i = 0; i < m_apChildren.GetSize(); i++)
    {
        if(m_apChildren[i] == pChild)
            return WBEM_S_FALSE;
    }
    
    if(m_apChildren.Add(pChild) < 0)
        return WBEM_E_OUT_OF_MEMORY;

    return WBEM_S_NO_ERROR;
}

HRESULT CClassRecord::RemoveChild(CClassRecord* pChild)
{
    A51TRACE(("Make %S NOT child of %S\n", 
                    pChild->m_wszClassName, m_wszClassName));
    for(int i = 0; i < m_apChildren.GetSize(); i++)
    {
        if(m_apChildren[i] == pChild)
        {
            m_apChildren.RemoveAt(i);
            return WBEM_S_NO_ERROR;
        }
    }
    
    return WBEM_E_NOT_FOUND;
}
        

    
CHierarchyCache::CHierarchyCache(CForestCache* pForest)
    : m_pForest(pForest), m_lNextInvalidationIndex(0), m_lRef(0),
        m_hresError(S_OK)
{
	g_nCaches++;
}

CHierarchyCache::~CHierarchyCache()
{
    TIterator it = m_map.begin();
    while(it != m_map.end())
    {
        CClassRecord* pRecord = it->second;
        m_pForest->RemoveRecord(pRecord);
        it = m_map.erase(it);
        pRecord->Release();
    }
	g_nCaches--;
}

void CHierarchyCache::SetError(HRESULT hresError)
{
    m_hresError = hresError;
}

HRESULT CHierarchyCache::GetError()
{
    return m_hresError;
}

void CHierarchyCache::MakeKey(LPCWSTR wszClassName, LPWSTR wszKey)
{
    // wbem_wcsupr(wszKey, wszClassName);
    A51Hash(wszClassName, wszKey);
}

INTERNAL CClassRecord* CHierarchyCache::FindClass(LPCWSTR wszClassName)
{
    CInCritSec ics(&m_cs);

    LPWSTR wszKey = (WCHAR*)_alloca(MAX_HASH_LEN*2+2);
    MakeKey(wszClassName, wszKey);

    return FindClassByKey(wszKey);
}

INTERNAL CClassRecord* CHierarchyCache::FindClassByKey(LPCWSTR wszKey)
{
    TIterator it = m_map.find(wszKey);
    if(it == m_map.end())
        return NULL;

    return it->second;
}

INTERNAL CClassRecord* CHierarchyCache::EnsureClass(LPCWSTR wszClassName)
{
    CInCritSec ics(&m_cs);

    LPWSTR wszKey = (WCHAR*)_alloca(MAX_HASH_LEN*2+2);
    MakeKey(wszClassName, wszKey);

    TIterator it = m_map.find(wszKey);
    if(it == m_map.end())
    {
        //
        // Create a new record with the name
        //

		try
		{
			CClassRecord* pRecord = new CClassRecord(wszClassName, wszKey);
			if(pRecord == NULL)
				return NULL;

			pRecord->AddRef();
			m_map[pRecord->m_wszHash] = pRecord;

			return pRecord;
		}
		catch (CX_MemoryException)
		{
			return NULL;
		}
    }
    else
    {
        return it->second;
    }
}


HRESULT CHierarchyCache::AssertClass(_IWmiObject* pClass, LPCWSTR wszClassName,
                                    bool bClone, __int64 nTime)
{
    CInCritSec ics(&m_cs);
    HRESULT hres;

    //
    // If no record is given, find one
    //

    CClassRecord* pRecord = NULL;

    if(wszClassName == NULL)
    {
        VARIANT v;
        VariantInit(&v);
        CClearMe cm(&v);

        hres = pClass->Get(L"__CLASS", 0, &v, NULL, NULL);
        if(FAILED(hres) || V_VT(&v) != VT_BSTR)
            return WBEM_E_INVALID_CLASS;

        pRecord = EnsureClass(V_BSTR(&v));
    }
    else
        pRecord = EnsureClass(wszClassName);

    if(pRecord == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    //
    // Figure out the parent
    //

    A51TRACE(("%p: Asserting %S on %I64d with %I64d\n", 
                    this, pRecord->m_wszClassName, g_nCurrentTime, nTime));

    VARIANT v;
    VariantInit(&v);
    hres = pClass->Get(L"__SUPERCLASS", 0, &v, NULL, NULL);
    CClearMe cm(&v);

    if(SUCCEEDED(hres))
    {
        if(V_VT(&v) == VT_BSTR)
            pRecord->m_pParent = EnsureClass(V_BSTR(&v));
        else
            pRecord->m_pParent = EnsureClass(L"");

        if(pRecord->m_pParent)
            pRecord->m_pParent->EnsureChild(pRecord);
    }
    else
    {
        return hres;
    }
    
    //
    // Check if the class is keyed
    //

    unsigned __int64 i64Flags = 0;
    hres = pClass->QueryObjectFlags(0, WMIOBJECT_GETOBJECT_LOFLAG_KEYED,
                                    &i64Flags);
    if(FAILED(hres))
        return hres;

    if(i64Flags)
    {
        pRecord->m_bIsKeyed = true;
    }
    else
    {
        pRecord->m_bIsKeyed = false;
    }
     
    //
    // Expell whatever definition is there from the cache
    //

    m_pForest->RemoveRecord(pRecord);

    //  
    // Figure out how much space this object will take
    //

    DWORD dwSize;
    hres = pClass->GetObjectMemory(NULL, 0, &dwSize);
    if(hres != WBEM_E_BUFFER_TOO_SMALL)
    {
        if(SUCCEEDED(hres))
            return WBEM_E_CRITICAL_ERROR;
        else
            return hres;
    }

    //
    // Good.  Make room and add to cache
    //

    if(m_pForest->MakeRoom(dwSize))
    {
        if(bClone)
        {
            IWbemClassObject* pObj = NULL;
            hres = pClass->Clone(&pObj);
            if(FAILED(hres))
                return hres;

            if(pObj)
            {
                pObj->QueryInterface(IID__IWmiObject, 
                                        (void**)&pRecord->m_pClassDef);
                pObj->Release();
            }
        }
        else
        {   pRecord->m_pClassDef = pClass;
            pClass->AddRef();
        }

        if(nTime)
        {
            pRecord->m_bRead = true;
            pRecord->m_nClassDefCachedTime = nTime;
        }
        else
        {
            pRecord->m_bRead = false;
            pRecord->m_nClassDefCachedTime = g_nCurrentTime++;
        }

        pRecord->m_dwClassDefSize = dwSize;
        
        //
        // It is most recently used, of course
        //

        m_pForest->Add(pRecord);
    }
    
    return WBEM_S_NO_ERROR;
    
}

HRESULT CHierarchyCache::InvalidateClass(LPCWSTR wszClassName)
{
    CInCritSec ics(&m_cs);

    HRESULT hres;

    //
    // Find the record if not given
    //

    CClassRecord* pRecord = NULL;
    pRecord = FindClass(wszClassName);
    if(pRecord == NULL)
    {
        // 
        // The record is not there --- there is nothing to invalidate.  This
        // is based on the assumption that if a class record is in the 
        // cache, then so are all its parents, which is true at the moment
        // because in order to construct a class we need to retrieve its
        // parents first.
        //

        return WBEM_S_FALSE;
    }

    pRecord->AddRef();
    CTemplateReleaseMe<CClassRecord> rm1(pRecord);

    LONGLONG lThisInvalidationIndex = m_lNextInvalidationIndex++;

    hres = InvalidateClassInternal(pRecord);

    //
    // Clear complete bits in all our parents, since this invalidation
    // means that no current enumeration of children can be trusted. At the same
    // time untie ourselves from the parent!
    //
    
    if(pRecord->m_pParent)
    {
        pRecord->m_pParent->m_bChildrenComplete = false;
        pRecord->m_pParent->m_bTreeComplete = false;
        pRecord->m_pParent->m_lLastChildInvalidationIndex = 
            lThisInvalidationIndex;
        pRecord->m_pParent->RemoveChild(pRecord);

        CClassRecord* pCurrent = pRecord->m_pParent->m_pParent;
        while(pCurrent)
        {
            pCurrent->m_bTreeComplete = false;
            pCurrent = pCurrent->m_pParent;
        }
    }

    return S_OK;
}


HRESULT CHierarchyCache::InvalidateClassInternal(CClassRecord* pRecord)
{
    //
    // Untie from the usage chain
    //

    A51TRACE(("%p: Invalidating %S on %I64d with %d children\n",
                    this, pRecord->m_wszClassName, g_nCurrentTime,
                    pRecord->m_apChildren.GetSize()));
    
    //
    // Remove all its children from the cache
    //

    for(int i = 0; i < pRecord->m_apChildren.GetSize(); i++)
    {
        InvalidateClassInternal(pRecord->m_apChildren[i]);
    }

    pRecord->m_apChildren.RemoveAll();

    //
    // Count ourselves out of the total memory
    //

    m_pForest->RemoveRecord(pRecord);

    //
    // Remove ourselves from the cache
    //

    m_map.erase(pRecord->m_wszHash);
	pRecord->Release();

    return S_OK;
}

HRESULT CHierarchyCache::DoneWithChildren(LPCWSTR wszClassName, bool bRecursive,
                                LONGLONG lStartIndex, CClassRecord* pRecord)
{
    CInCritSec ics(&m_cs);

    HRESULT hres;

    //
    // Find the record if not given
    //

    if(pRecord == NULL)
    {
        pRecord = FindClass(wszClassName);
        if(pRecord == NULL)
        {
            // Big time invalidation must have occurred
            return WBEM_S_FALSE;
        }
    }

    return DoneWithChildrenByRecord(pRecord, bRecursive, lStartIndex);
}

HRESULT CHierarchyCache::DoneWithChildrenByHash(LPCWSTR wszHash, 
                                bool bRecursive, LONGLONG lStartIndex)
{
    CInCritSec ics(&m_cs);

    HRESULT hres;

    //
    // Find the record if not given
    //

    CClassRecord* pRecord = FindClassByKey(wszHash);
    if(pRecord == NULL)
    {
        // Big time invalidation must have occurred
        return WBEM_S_FALSE;
    }

    return DoneWithChildrenByRecord(pRecord, bRecursive, lStartIndex);
}

HRESULT CHierarchyCache::DoneWithChildrenByRecord(CClassRecord* pRecord,
                                bool bRecursive,  LONGLONG lStartIndex)
{
    //  
    // Check if any child invalidations occurred in this node since we started
    //

    if(lStartIndex < pRecord->m_lLastChildInvalidationIndex)
        return WBEM_S_FALSE;
    else
        pRecord->m_bChildrenComplete = true;
    
    if(bRecursive)
    {
        //
        // We have completed a recursive enumeration --- descend the 
        // hierarchy and mark as complete all the children that have not been
        // modified since the start
        //

        bool bAllValid = true;
        for(int i = 0; i < pRecord->m_apChildren.GetSize(); i++)
        {
            CClassRecord* pChildRecord = pRecord->m_apChildren[i];
            HRESULT hres = DoneWithChildren(pChildRecord->m_wszClassName, true, 
                                    lStartIndex, pChildRecord);
    
            if(hres != S_OK)
                bAllValid = false;
        }
    
        if(bAllValid)
        {
            //
            // There were no invalidations anywhere in the tree, which makes
            // this record tree-complete
            //

            pRecord->m_bTreeComplete = true;
            return WBEM_S_NO_ERROR;
        }
        else
            return S_FALSE;
    }
    else
        return WBEM_S_NO_ERROR;
}


RELEASE_ME _IWmiObject* CHierarchyCache::GetClassDef(LPCWSTR wszClassName,
                                                bool bClone, __int64* pnTime,
                                                bool* pbRead)
{
    CInCritSec ics(&m_cs);

    CClassRecord* pRecord = FindClass(wszClassName);
    if(pRecord == NULL)
        return NULL;

    if(pnTime)
        *pnTime = pRecord->m_nClassDefCachedTime;

    if(pbRead)
        *pbRead = pRecord->m_bRead;

    return GetClassDefFromRecord(pRecord, bClone);
}

RELEASE_ME _IWmiObject* CHierarchyCache::GetClassDefByHash(LPCWSTR wszHash,
                                                bool bClone, __int64* pnTime,
                                                bool* pbRead)
{
    CInCritSec ics(&m_cs);

    CClassRecord* pRecord = FindClassByKey(wszHash);
    if(pRecord == NULL)
        return NULL;

    if(pbRead)
        *pbRead = pRecord->m_bRead;

    if(pnTime)
        *pnTime = pRecord->m_nClassDefCachedTime;

    return GetClassDefFromRecord(pRecord, bClone);
}

// assumes: in m_cs
RELEASE_ME _IWmiObject* CHierarchyCache::GetClassDefFromRecord(
                                                CClassRecord* pRecord,
                                                bool bClone)
{
    //
    // Accessing m_pClassDef, so we have to lock the forest
    //

    CInCritSec ics(m_pForest->GetLock());

    if(pRecord->m_pClassDef)
    {
        m_pForest->MakeMostRecentlyUsed(pRecord);

        if(bClone)
        {
            IWbemClassObject* pObj = NULL;
            if(FAILED(pRecord->m_pClassDef->Clone(&pObj)))
                return NULL;
            else
            {
                _IWmiObject* pRes = NULL;
                pObj->QueryInterface(IID__IWmiObject, (void**)&pRes);
                pObj->Release();
                return pRes;
            }
        }
        else
        {
            pRecord->m_pClassDef->AddRef();
            return pRecord->m_pClassDef;
        }
    }
    else
        return NULL;
}

HRESULT CHierarchyCache::EnumChildren(LPCWSTR wszClassName, bool bRecursive,
                            CWStringArray& awsChildren)
{
    CInCritSec ics(&m_cs);

    //
    // Get the record
    //

    CClassRecord* pRecord = FindClass(wszClassName);
    if(pRecord == NULL)
        return WBEM_S_FALSE;

    //
    // Check if it is complete for this type of enumeration
    //

    if(!pRecord->m_bChildrenComplete)
        return WBEM_S_FALSE;

    if(bRecursive && !pRecord->m_bTreeComplete)
        return WBEM_S_FALSE;

    return EnumChildrenInternal(pRecord, bRecursive, awsChildren);
}

HRESULT CHierarchyCache::EnumChildrenInternal(CClassRecord* pRecord, 
                                        bool bRecursive,
                                        CWStringArray& awsChildren)
{
    for(int i = 0; i < pRecord->m_apChildren.GetSize(); i++)
    {
        CClassRecord* pChildRecord = pRecord->m_apChildren[i];
        if(awsChildren.Add(pChildRecord->m_wszClassName) < 0)
            return WBEM_E_OUT_OF_MEMORY;
        
        if(bRecursive)
        {
            HRESULT hres = EnumChildrenInternal(pChildRecord, bRecursive, 
                                                    awsChildren);
            if(FAILED(hres))
                return hres;
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CHierarchyCache::EnumChildKeysByKey(LPCWSTR wszClassKey, 
                            CWStringArray& awsChildKeys)
{
    CInCritSec ics(&m_cs);

    //
    // Get the record
    //

    CClassRecord* pRecord = FindClassByKey(wszClassKey);
    if(pRecord == NULL)
        return WBEM_S_FALSE;

    //
    // Check if it is complete for this type of enumeration
    //

    if(!pRecord->m_bChildrenComplete)
        return WBEM_S_FALSE;

    for(int i = 0; i < pRecord->m_apChildren.GetSize(); i++)
    {
        CClassRecord* pChildRecord = pRecord->m_apChildren[i];
        if(awsChildKeys.Add(pChildRecord->m_wszHash) < 0)
            return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}

    

    

HRESULT CHierarchyCache::GetKeyRoot(LPCWSTR wszClassName, 
                                    TEMPFREE_ME LPWSTR* pwszKeyRoot)
{
    CInCritSec ics(&m_cs);

    CClassRecord* pRecord = FindClass(wszClassName);
    if(pRecord == NULL)
        return WBEM_E_NOT_FOUND;

    return GetKeyRootByRecord(pRecord, pwszKeyRoot);
}

// assumes: in cs
HRESULT CHierarchyCache::GetKeyRootByRecord(CClassRecord* pRecord,
                                    TEMPFREE_ME LPWSTR* pwszKeyRoot)
{
    *pwszKeyRoot = NULL;

    if(!pRecord->m_bIsKeyed)
        return WBEM_E_CANNOT_BE_ABSTRACT;

    //
    // Go up until an unkeyed record is found.  Keep the previous in pPrev
    //

	CClassRecord* pPrev = pRecord;
    while(pRecord && pRecord->m_bIsKeyed)
	{
		pPrev = pRecord;
        pRecord = pRecord->m_pParent;
	}

    if(pRecord)
    {
        //
        // Found unkeyed parent --- pPrev is the root
        //

        LPCWSTR wszKeyRoot = pPrev->m_wszClassName;
        DWORD dwLen = (wcslen(wszKeyRoot)+1) * sizeof(WCHAR);
        *pwszKeyRoot = (WCHAR*)TempAlloc(dwLen);
		if (*pwszKeyRoot == NULL)
			return WBEM_E_OUT_OF_MEMORY;
        wcscpy(*pwszKeyRoot, wszKeyRoot);
        return S_OK;
    }
    else
    {
        //
        // No unkeyed parents --- since "" is known to be unkeyed, we had have
        // hit a gap in the cache
        //

        return WBEM_E_NOT_FOUND;
    }
}

HRESULT CHierarchyCache::GetKeyRootByKey(LPCWSTR wszKey, 
                                    TEMPFREE_ME LPWSTR* pwszKeyRoot)
{
    CInCritSec ics(&m_cs);

    CClassRecord* pRecord = FindClassByKey(wszKey);
    if(pRecord == NULL)
        return WBEM_E_NOT_FOUND;

    return GetKeyRootByRecord(pRecord, pwszKeyRoot);
}

DELETE_ME LPWSTR CHierarchyCache::GetParent(LPCWSTR wszClassName)
{
    CInCritSec ics(&m_cs);

    CClassRecord* pRecord = FindClass(wszClassName);
    if(pRecord == NULL)
        return NULL;

    if(pRecord->m_pParent)
    {
        LPCWSTR wszParent = pRecord->m_pParent->m_wszClassName;
        LPWSTR wszCopy = new WCHAR[wcslen(wszParent)+1];
		if (wszCopy == NULL)
			return NULL;
        wcscpy(wszCopy, wszParent);
        return wszCopy;
    }
    else
        return NULL;
}



HRESULT CForestCache::Initialize()
{
    //
    // Read the size limits from the registry
    //

    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ | KEY_WRITE, &hKey);
    if(lRes)
        return lRes;
    CRegCloseMe cm(hKey);

    DWORD dwLen = sizeof(DWORD);
    DWORD dwMaxSize;
    lRes = RegQueryValueExW(hKey, L"Max Class Cache Size", NULL, NULL, 
                (LPBYTE)&dwMaxSize, &dwLen);

    //
    // If not there, set to default and write the default into the registry
    //

    if(lRes != ERROR_SUCCESS)
    {
        dwMaxSize = 5000000;
        lRes = RegSetValueExW(hKey, L"Max Class Cache Size", 0, REG_DWORD, 
                (LPBYTE)&dwMaxSize, sizeof(DWORD));
    }

    //
    // Read the maximum useful age of an item
    //

    dwLen = sizeof(DWORD);
    DWORD dwMaxAge;
    lRes = RegQueryValueExW(hKey, L"Max Class Cache Item Age (ms)", NULL, NULL, 
                (LPBYTE)&dwMaxAge, &dwLen);

    //
    // If not there, set to default and write the default into the registry
    //

    if(lRes != ERROR_SUCCESS)
    {
        dwMaxAge = 10000;
        lRes = RegSetValueExW(hKey, L"Max Class Cache Item Age (ms)", 0, 
                REG_DWORD, (LPBYTE)&dwMaxAge, sizeof(DWORD));
    }


    //
    // Apply
    //

    SetMaxMemory(dwMaxSize, dwMaxAge);

    //
    // Create a timer queue for flushing
    //

    m_hTimerQueue = CreateTimerQueue();
    m_hCompletionEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    return WBEM_S_NO_ERROR;
}


bool CForestCache::MakeRoom(DWORD dwSize)
{
    CInCritSec ics(&m_cs);

    if(dwSize > m_dwMaxMemory)
        return false; // no hope!

    //  
    // Remove records until satisfied. Also, remove all records older than the
    // maximum age
    //

    DWORD dwNow = GetTickCount();

    while(m_pLeastRecentlyUsed && 
            (m_dwTotalMemory + dwSize > m_dwMaxMemory ||
             dwNow - m_pLeastRecentlyUsed->m_dwLastUsed > m_dwMaxAgeMs)
         )
    {
		RemoveRecord(m_pLeastRecentlyUsed);
    }

    return true;
}

bool CForestCache::Flush()
{
    CInCritSec ics(&m_cs);
    while(m_pLeastRecentlyUsed)
    {
		RemoveRecord(m_pLeastRecentlyUsed);
    }

    return true;
}

bool CForestCache::Test()
{
	if(m_pMostRecentlyUsed == NULL)
	{
		if(m_pLeastRecentlyUsed)
			DebugBreak();
		return true;
	}

	if(m_pMostRecentlyUsed->m_pMoreRecentlyUsed)
		DebugBreak();

	CClassRecord* pOne = m_pMostRecentlyUsed;
	CClassRecord* pTwo = m_pMostRecentlyUsed->m_pLessRecentlyUsed;

	while(pOne && pOne != pTwo)
	{
		if(pOne->m_pLessRecentlyUsed && pOne->m_pLessRecentlyUsed->m_pMoreRecentlyUsed != pOne)
			DebugBreak();
		if(pOne->m_pClassDef == NULL)
			DebugBreak();

		if(pOne->m_pLessRecentlyUsed == NULL && pOne != m_pLeastRecentlyUsed)
			DebugBreak();
		
		pOne = pOne->m_pLessRecentlyUsed;
		if(pTwo)
			pTwo = pTwo->m_pLessRecentlyUsed;
		if(pTwo)
			pTwo = pTwo->m_pLessRecentlyUsed;
	}
	if(pOne)
		DebugBreak();
	return true;
}
        
void CForestCache::MakeMostRecentlyUsed(CClassRecord* pRecord)
{
    CInCritSec ics(&m_cs);

	//Test();
	Untie(pRecord);

	pRecord->m_pMoreRecentlyUsed = NULL;
	pRecord->m_pLessRecentlyUsed = m_pMostRecentlyUsed;
	if(m_pMostRecentlyUsed)
		m_pMostRecentlyUsed->m_pMoreRecentlyUsed = pRecord;

	m_pMostRecentlyUsed = pRecord;
	if(m_pLeastRecentlyUsed == NULL)
		m_pLeastRecentlyUsed = pRecord;


    pRecord->m_dwLastUsed = GetTickCount();
    pRecord->m_nStatus = 4;
	//Test();

    //
    // Schedule a timer to clean up, if not already there
    //

    if(m_hCurrentTimer == NULL)
    {
        CreateTimerQueueTimer(&m_hCurrentTimer, m_hTimerQueue, 
            (WAITORTIMERCALLBACK)&staticTimerCallback, this, m_dwMaxAgeMs,
            m_dwMaxAgeMs, WT_EXECUTEINTIMERTHREAD);
    }
}

void CForestCache::staticTimerCallback(void* pParam, BOOLEAN)
{
    ((CForestCache*)pParam)->TimerCallback();
}
    
void CForestCache::TimerCallback()
{
    CInCritSec ics(&m_cs);

    //
    // Clean up what's stale
    //

    MakeRoom(0);

    //
    // See if we have any more reasons to live
    //

    if(m_pMostRecentlyUsed == NULL)
    {
        DeleteTimerQueueTimer(m_hTimerQueue, m_hCurrentTimer, 
                                m_hCompletionEvent);
        m_hCurrentTimer = NULL;
    }
}

void CForestCache::Add(CClassRecord* pRecord)
{
    CInCritSec ics(&m_cs);

    MakeMostRecentlyUsed(pRecord);
    m_dwTotalMemory += pRecord->m_dwClassDefSize;
    pRecord->m_nStatus = 3;
}

void CForestCache::RemoveRecord(CClassRecord* pRecord)
{
    CInCritSec ics(&m_cs);

    if(pRecord->m_pClassDef == NULL)
		return;

	Untie(pRecord);

    m_dwTotalMemory -= pRecord->m_dwClassDefSize;

    pRecord->m_pClassDef->Release();
    pRecord->m_pClassDef = NULL;
    pRecord->m_nStatus = 2;
}

void CForestCache::Untie(CClassRecord* pRecord)
{
	//Test();

    CClassRecord* pPrev = pRecord->m_pLessRecentlyUsed;
    CClassRecord* pNext = pRecord->m_pMoreRecentlyUsed;
    if(pPrev)
        pPrev->m_pMoreRecentlyUsed = pNext;
    if(pNext)
        pNext->m_pLessRecentlyUsed = pPrev;

    if(m_pLeastRecentlyUsed == pRecord)
        m_pLeastRecentlyUsed = m_pLeastRecentlyUsed->m_pMoreRecentlyUsed;

    if(m_pMostRecentlyUsed == pRecord)
        m_pMostRecentlyUsed = m_pMostRecentlyUsed->m_pLessRecentlyUsed;

	pRecord->m_pMoreRecentlyUsed = pRecord->m_pLessRecentlyUsed = NULL;
	//Test();
}

void CForestCache::SetMaxMemory(DWORD dwMaxMemory, DWORD dwMaxAgeMs)
{
    m_dwMaxMemory = dwMaxMemory;
    m_dwMaxAgeMs = dwMaxAgeMs;
    
    // 
    // Make room for 0 bytes --- has the effect of clearing all the records
    // above the limit
    //

    MakeRoom(0);
}


CHierarchyCache* CForestCache::GetNamespaceCache(LPCWSTR wszNamespace)
{
    CInCritSec ics(&m_cs);

    //
    // See if you can find one
    //

    TIterator it = m_map.find(wszNamespace);
    if(it != m_map.end())
    {
        it->second->AddRef();
        return it->second;
    }
    else
    {
        //
        // Not there --- create one
        //

        CHierarchyCache* pCache = new CHierarchyCache(this);
        if(pCache == NULL)
            return NULL;

        pCache->AddRef();
        m_map[wszNamespace] = pCache;
        return pCache;
    }
}

void CForestCache::ReleaseNamespaceCache(LPCWSTR wszNamespace, 
                                            CHierarchyCache* pCache)
{
    CInCritSec ics(&m_cs);

    //
    // Find it in the map
    //

    TIterator it = m_map.find(wszNamespace);
    _ASSERT(it != m_map.end(), L"Releasing a non-existing namespace cache");
    _ASSERT(it->second == pCache, L"Releasing a non-matching namespace cache");

    if(pCache->Release() == 0)
    {
        //
        // Last ref-count --- remove
        //

        delete it->second;
        m_map.erase(it);
    }
}

CForestCache::~CForestCache()
{
    TIterator it = m_map.begin();
    while(it != m_map.end())
    {
        delete it->second;
        it++;
    }

    if(m_hCompletionEvent)
        CloseHandle(m_hCompletionEvent);

    if(m_hTimerQueue)
        DeleteTimerQueueEx(m_hTimerQueue, INVALID_HANDLE_VALUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a51\repositorypackager.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    RepositoryPackager.CPP

Abstract:

    Recursively packages the contents of the repository directory into a single file,
	and unpackages it.

History:

    paulall	  07/26/00  Created.
	a-shawnb  07/27/00  Finished.

--*/

#include "precomp.h"
#include <wbemcli.h>
#include "RepositoryPackager.h"

/******************************************************************************
 *
 *	CRepositoryPackager::PackageRepository
 *
 *	Description:
 *		Iterates deeply through the repository directly and packages it up 
 *		into the given file specified by the given parameter.
 *		Repository directory is the one retrieved from the registry.
 *
 *	Parameters:
 *		wszFilename:	Filename we package everything up into
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageRepository(const wchar_t *wszFilename)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	wchar_t wszRepositoryDirectory[MAX_PATH+1];
	HANDLE hFile = INVALID_HANDLE_VALUE;

    //Store the filename so when package files, we make sure we ignore this file!
    wcscpy(m_wszFileToProcess, wszFilename);

	//Get the root directory of the repository
	hres = GetRepositoryDirectory(wszRepositoryDirectory);

	//Create a new file to package contents up to...
	if (SUCCEEDED(hres))
	{
		hFile = CreateFileW(wszFilename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hFile == INVALID_HANDLE_VALUE)
			hres = WBEM_E_FAILED;
	}

	//Write the package header...
	if (SUCCEEDED(hres))
	{
		hres = PackageHeader(hFile);
	}

	if (SUCCEEDED(hres))
	{
		hres = PackageContentsOfDirectory(hFile, wszRepositoryDirectory);
	}

	//Write the end of package marker
	if (SUCCEEDED(hres))
		hres = PackageTrailer(hFile);


	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	//If things failed we should delete the file...
	if (FAILED(hres))
		DeleteFileW(wszFilename);
	return hres;
}


/******************************************************************************
 *
 *	CRepositoryPackager::UnpackageRepository
 *
 *	Description:
 *		Given the filename of a packaged up repository we unpack everything
 *		into the repository directory specified in the registry.  The 
 *		directory should have no files in it before doing this.
 *
 *	Parameters:
 *		wszFilename:	Filename we unpackage everything from
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::UnpackageRepository(const wchar_t *wszFilename)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	wchar_t wszRepositoryDirectory[MAX_PATH+1];
	HANDLE hFile = INVALID_HANDLE_VALUE;

	//Get the root directory of the repository
	hres = GetRepositoryDirectory(wszRepositoryDirectory);

	//open the file for unpacking...
	if (SUCCEEDED(hres))
	{
		hFile = CreateFileW(wszFilename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hFile == INVALID_HANDLE_VALUE)
			hres = WBEM_E_FAILED;
	}

	//unpack the package header...
	if (SUCCEEDED(hres))
	{
		hres = UnPackageHeader(hFile);
	}

	//unpack the file...
	if (SUCCEEDED(hres))
	{
		hres = UnPackageContentsOfDirectory(hFile, wszRepositoryDirectory);
	}

	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	//If things failed we should delete the partially unpacked repository...
	if (FAILED(hres))
		DeleteRepository();

	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::DeleteRepository
 *
 *	Description:
 *		Delete all files and directories under the repository directory.
 *		The repository directory location is retrieved from the registry.
 *
 *	Parameters:
 *		<none>
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::DeleteRepository()
{
	HRESULT hres = WBEM_S_NO_ERROR;
	wchar_t wszRepositoryDirectory[MAX_PATH+1];

	//Get the root directory of the repository
	hres = GetRepositoryDirectory(wszRepositoryDirectory);

	if (SUCCEEDED(hres))
	{
		hres = DeleteContentsOfDirectory(wszRepositoryDirectory);
	}
	
	return hres;
}


/******************************************************************************
 *
 *	CRepositoryPackager::PackageContentsOfDirectory
 *
 *	Description:
 *		Given a directory, iterates through all files and directories and
 *		calls into the function to package it into the file specified by the
 *		file handle passed to the method.
 *
 *	Parameters:
 *		hFile:					Handle to the destination file.
 *		wszRepositoryDirectory:	Directory to process
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageContentsOfDirectory(HANDLE hFile, const wchar_t *wszRepositoryDirectory)
{
	HRESULT hres  = WBEM_S_NO_ERROR;

	WIN32_FIND_DATAW findFileData;
	HANDLE hff = INVALID_HANDLE_VALUE;

	//create file search pattern...
	wchar_t *wszSearchPattern = new wchar_t[MAX_PATH+1];
	if (wszSearchPattern == NULL)
		hres = WBEM_E_OUT_OF_MEMORY;
	else
	{
		wcscpy(wszSearchPattern, wszRepositoryDirectory);
		wcscat(wszSearchPattern, L"\\*");
	}

	//Start the file iteration in this directory...
	if (SUCCEEDED(hres))
	{
		hff = FindFirstFileW(wszSearchPattern, &findFileData);
		if (hff == INVALID_HANDLE_VALUE)
		{
			hres = WBEM_E_FAILED;
		}
	}
	
	if (SUCCEEDED(hres))
	{
		do
		{
			//If we have a filename of '.' or '..' we ignore it...
			if ((wcscmp(findFileData.cFileName, L".") == 0) ||
				(wcscmp(findFileData.cFileName, L"..") == 0))
			{
				//Do nothing with these...
			}
			else if (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				//This is a directory, so we need to deal with that...
				hres = PackageDirectory(hFile, wszRepositoryDirectory, findFileData.cFileName);
				if (FAILED(hres))
					break;
			}
			else
			{
				//This is a file, so we need to deal with that...
				hres = PackageFile(hFile, wszRepositoryDirectory, findFileData.cFileName);
				if (FAILED(hres))
					break;
			}
			
		} while (FindNextFileW(hff, &findFileData));
	}

	if (wszSearchPattern)
		delete [] wszSearchPattern;

	if (hff != INVALID_HANDLE_VALUE)
		FindClose(hff);

	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::GetRepositoryDirectory
 *
 *	Description:
 *		Retrieves the location of the repository directory from the registry.
 *
 *	Parameters:
 *		wszRepositoryDirectory:	Array to store location in.
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1])
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ, &hKey);
    if(lRes)
        return WBEM_E_FAILED;

    wchar_t wszTmp[MAX_PATH + 1];
    DWORD dwLen = MAX_PATH + 1;
    lRes = RegQueryValueExW(hKey, L"Repository Directory", NULL, NULL, 
                (LPBYTE)wszTmp, &dwLen);
	RegCloseKey(hKey);
    if(lRes)
        return WBEM_E_FAILED;

	if (ExpandEnvironmentStringsW(wszTmp,wszRepositoryDirectory, MAX_PATH + 1) == 0)
		return WBEM_E_FAILED;

	return WBEM_S_NO_ERROR;
}

/******************************************************************************
 *
 *	CRepositoryPackager::PackageHeader
 *
 *	Description:
 *		Stores the header package in the given file.  This is a footprint
 *		so we can recognise if this really is one of our files when 
 *		we try to decode it.  Also it allows us to version it.
 *
 *	Parameters:
 *		hFile:	File handle to store header in.
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageHeader(HANDLE hFile)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	PACKAGE_HEADER header;
	strcpy(header.szSignature, "FS PKG1.1");	//NOTE!  MAXIMUM OF 10 CHARACTERS (INCLUDING TERMINATOR!)

	DWORD dwSize = 0;
	if ((WriteFile(hFile, &header, sizeof(header), &dwSize, NULL) == 0) || (dwSize != sizeof(header)))
		hres = WBEM_E_FAILED;
	
	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::PackageDirectory
 *
 *	Description:
 *		This is the code which processes a directory.  It stores the namespace
 *		header and footer marker in the file, and also iterates through
 *		all files and directories in that directory.
 *
 *	Parameters:
 *		hFile:				File handle to store directory information in.
 *		wszParentDirectory:	Full path of parent directory
 *		eszSubDirectory:	Name of sub-directory to process
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageDirectory(HANDLE hFile, const wchar_t *wszParentDirectory, wchar_t *wszSubDirectory)
{
	HRESULT hres = WBEM_S_NO_ERROR;

	{
		PACKAGE_SPACER_NAMESPACE header;
		header.dwSpacerType = PACKAGE_TYPE_NAMESPACE_START;
		wcscpy(header.wszNamespaceName, wszSubDirectory);
		DWORD dwSize = 0;
		if ((WriteFile(hFile, &header, sizeof(header), &dwSize, NULL) == 0) || (dwSize != sizeof(header)))
			hres = WBEM_E_FAILED;
	}
	
	//Get full path of new directory...
	wchar_t *wszFullDirectoryName = NULL;
	if (SUCCEEDED(hres))
	{
		wszFullDirectoryName = new wchar_t[MAX_PATH+1];
		if (wszFullDirectoryName == NULL)
			hres = WBEM_E_OUT_OF_MEMORY;
		else
		{
			wcscpy(wszFullDirectoryName, wszParentDirectory);
			wcscat(wszFullDirectoryName, L"\\");
			wcscat(wszFullDirectoryName, wszSubDirectory);
		}
	}

	//Package the contents of that directory...
	if (SUCCEEDED(hres))
	{
		hres = PackageContentsOfDirectory(hFile, wszFullDirectoryName);
	}

	//Now need to write the end of package marker...
	if (SUCCEEDED(hres))
	{
		PACKAGE_SPACER header2;
		header2.dwSpacerType = PACKAGE_TYPE_NAMESPACE_END;
		DWORD dwSize = 0;
		if ((WriteFile(hFile, &header2, sizeof(header2), &dwSize, NULL) == 0) || (dwSize != sizeof(header2)))
			hres = WBEM_E_FAILED;
	}

	delete [] wszFullDirectoryName;

	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::PackageFile
 *
 *	Description:
 *		This is the code which processes a file.  It stores the file header
 *		and the contents of the file into the destination file whose handle
 *		is passed in.  The file directory and name is passed in.
 *
 *	Parameters:
 *		hFile:				File handle to store directory information in.
 *		wszParentDirectory:	Full path of parent directory
 *		wszFilename:		Name of file to process
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageFile(HANDLE hFile, const wchar_t *wszParentDirectory, wchar_t *wszFilename)
{
	HRESULT hres = WBEM_S_NO_ERROR;
    bool bSkipFile = false; //Sometimes we need to need to skip files!

    //We can skip the mainstage file as it is fully flushed.
    if (_wcsicmp(wszFilename, L"mainstage.dat") == 0)
        return hres;

	PACKAGE_SPACER_FILE header;
	header.dwSpacerType = PACKAGE_TYPE_FILE;
	wcscpy(header.wszFileName, wszFilename);

	WIN32_FILE_ATTRIBUTE_DATA fileAttribs;
	wchar_t *wszFullFileName = new wchar_t[MAX_PATH+1];
	if (wszFullFileName == NULL)
		hres = WBEM_E_OUT_OF_MEMORY;

	if (SUCCEEDED(hres))
	{
		wcscpy(wszFullFileName, wszParentDirectory);
		wcscat(wszFullFileName, L"\\");
		wcscat(wszFullFileName, wszFilename);

		if (GetFileAttributesExW(wszFullFileName, GetFileExInfoStandard, &fileAttribs) == 0)
			hres = WBEM_E_FAILED;
		else
		{
			header.dwFileSize = fileAttribs.nFileSizeLow;
		}
	}

    //Make sure we are not packaging the file that is the destination file!
    if (SUCCEEDED(hres))
    {
        if (_wcsicmp(wszFullFileName, m_wszFileToProcess) == 0)
        {
            bSkipFile = true;
        }
    }

	//Write header...
	if (SUCCEEDED(hres) && !bSkipFile)
	{
		DWORD dwSize = 0;
		if ((WriteFile(hFile, &header, sizeof(header), &dwSize, NULL) == 0) || (dwSize != sizeof(header)))
			hres = WBEM_E_FAILED;
	}
	
	//Now need to write actual contents of file to current one... but only if the file is not 0 bytes long...
	if (SUCCEEDED(hres) && (header.dwFileSize != 0) && !bSkipFile)
	{
		HANDLE hFromFile = CreateFileW(wszFullFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hFromFile == INVALID_HANDLE_VALUE)
			hres = WBEM_E_FAILED;

		BYTE *pFileBlob = NULL;
		if (SUCCEEDED(hres))
		{
			pFileBlob = new BYTE[header.dwFileSize];
			if (pFileBlob == NULL)
				hres = WBEM_E_OUT_OF_MEMORY;
		}

		if (SUCCEEDED(hres))
		{
			DWORD dwSize = 0;
			if ((ReadFile(hFromFile, pFileBlob, header.dwFileSize, &dwSize, NULL) == 0) || (dwSize != header.dwFileSize))
				hres = WBEM_E_FAILED;
		}

		if (SUCCEEDED(hres))
		{
			DWORD dwSize = 0;
			if ((WriteFile(hFile, pFileBlob, header.dwFileSize, &dwSize, NULL) == 0) || (dwSize != header.dwFileSize))
				hres = WBEM_E_FAILED;
		}

		delete pFileBlob;

		if (hFromFile != INVALID_HANDLE_VALUE)
			CloseHandle(hFromFile);
	}

	delete [] wszFullFileName;
	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::PackageTrailer
 *
 *	Description:
 *		Writes the end of file marker to the file.
 *
 *	Parameters:
 *		hFile:				File handle to store directory information in.
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageTrailer(HANDLE hFile)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	PACKAGE_SPACER trailer;
	trailer.dwSpacerType = PACKAGE_TYPE_END_OF_FILE;

	DWORD dwSize = 0;
	if ((WriteFile(hFile, &trailer, sizeof(trailer), &dwSize, NULL) == 0) || (dwSize != sizeof(trailer)))
		hres = WBEM_E_FAILED;
	
	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::UnPackageHeader
 *
 *	Description:
 *		Unpacks the header package in the given file.  This allows us to recognise
 *		if this really is one of our files. Also it allows us to version it.
 *
 *	Parameters:
 *		hFile:	File handle to unpack header from.
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::UnPackageHeader(HANDLE hFile)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	PACKAGE_HEADER header;

    DWORD dwSize = 0;
    if ((ReadFile(hFile, &header, sizeof(header), &dwSize, NULL) == 0) || (dwSize != sizeof(header)))
    {
		hres = WBEM_E_FAILED;
    }
	else if (strncmp(header.szSignature,"FS PKG1.1", 9) != 0)
    {
		hres = WBEM_E_FAILED;
    }

	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::UnPackageContentsOfDirectory
 *
 *	Description:
 *		Unpack the contents of a namespace/directory.
 *		If a subdirectory is encountered, then it calls UnPackageDirectory to handle it.
 *		If a file is encountered, then it calls UnPackageFile to handle it.
 *		If no errors occur, then it will enventually encounter the end of the namespace,
 *		which will terminate the loop and return control to the calling function.
 *
 *	Parameters:
 *		hFile:					Handle to the file to unpack from
 *		wszRepositoryDirectory:	Directory to write to.
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::UnPackageContentsOfDirectory(HANDLE hFile, const wchar_t *wszRepositoryDirectory)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	PACKAGE_SPACER header;
	DWORD dwSize;

	while (hres == WBEM_S_NO_ERROR)
	{
		// this loop will be exited when we either
		// - successfully process a complete directory/namespace
		// - encounter an error

		dwSize = 0;
		if ((ReadFile(hFile, &header, sizeof(header), &dwSize, NULL) == 0) || (dwSize != sizeof(header)))
		{
			hres = WBEM_E_FAILED;
		}
		else if (header.dwSpacerType == PACKAGE_TYPE_NAMESPACE_START)
		{
			hres = UnPackageDirectory(hFile, wszRepositoryDirectory);
		}
		else if (header.dwSpacerType == PACKAGE_TYPE_NAMESPACE_END)
		{
			// done with this directory   
			break;
		}
		else if (header.dwSpacerType == PACKAGE_TYPE_FILE)
		{
			hres = UnPackageFile(hFile, wszRepositoryDirectory);
		}
		else if (header.dwSpacerType == PACKAGE_TYPE_END_OF_FILE)
		{
			// done unpacking
			break;
		}
		else
		{
			hres = WBEM_E_FAILED;
		}
	}

	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::UnPackageDirectory
 *
 *	Description:
 *		Unpack the start of a namespace, then call UnPackageContentsOfDirectory
 *		to handle everything within it.
 *
 *	Parameters:
 *		hFile:				File handle to unpack directory information from.
 *		wszParentDirectory:	Full path of parent directory
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::UnPackageDirectory(HANDLE hFile, const wchar_t *wszParentDirectory)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	PACKAGE_SPACER_NAMESPACE header;

	// read namespace/directory name
	DWORD dwSize = 0;
	DWORD dwSizeToRead = sizeof(header)-sizeof(PACKAGE_SPACER);
	if ((ReadFile(hFile, ((LPBYTE)&header)+sizeof(PACKAGE_SPACER), dwSizeToRead, &dwSize, NULL) == 0) || (dwSize != dwSizeToRead))
	{
		hres = WBEM_E_FAILED;
	}

	//Get full path of new directory...
	wchar_t *wszFullDirectoryName = NULL;
	if (SUCCEEDED(hres))
	{
		wszFullDirectoryName = new wchar_t[MAX_PATH+1];
		if (wszFullDirectoryName == NULL)
			hres = WBEM_E_OUT_OF_MEMORY;
		else
		{
			wcscpy(wszFullDirectoryName, wszParentDirectory);
			wcscat(wszFullDirectoryName, L"\\");
			wcscat(wszFullDirectoryName, header.wszNamespaceName);
		}
	}

	// create directory
	if (!CreateDirectoryW(wszFullDirectoryName, NULL))
	{
        if (GetLastError() != ERROR_ALREADY_EXISTS)
		    hres = WBEM_E_FAILED;
	}

	// UnPackage the contents into the new directory...
	if (SUCCEEDED(hres))
	{
		hres = UnPackageContentsOfDirectory(hFile, wszFullDirectoryName);
	}

	delete [] wszFullDirectoryName;
	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::UnPackageFile
 *
 *	Description:
 *		Unpack a file.
 *
 *	Parameters:
 *		hFile:				File handle to unpack file information from.
 *		wszParentDirectory:	Full path of parent directory
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::UnPackageFile(HANDLE hFile, const wchar_t *wszParentDirectory)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	PACKAGE_SPACER_FILE header;

	// read file name and size
	DWORD dwSize = 0;
	DWORD dwSizeToRead = sizeof(header)-sizeof(PACKAGE_SPACER);
	if ((ReadFile(hFile, ((LPBYTE)&header)+sizeof(PACKAGE_SPACER), dwSizeToRead, &dwSize, NULL) == 0) || (dwSize != dwSizeToRead))
	{
		hres = WBEM_E_FAILED;
	}

	//Get full path of new file...
	wchar_t *wszFullFileName = NULL;
	if (SUCCEEDED(hres))
	{
		wszFullFileName = new wchar_t[MAX_PATH+1];
		if (wszFullFileName == NULL)
			hres = WBEM_E_OUT_OF_MEMORY;
		else
		{
			wcscpy(wszFullFileName, wszParentDirectory);
			wcscat(wszFullFileName, L"\\");
			wcscat(wszFullFileName, header.wszFileName);
		}
	}

	// create the file
	HANDLE hNewFile = INVALID_HANDLE_VALUE;
	if (SUCCEEDED(hres))
	{
		hNewFile = CreateFileW(wszFullFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hNewFile == INVALID_HANDLE_VALUE)
			hres = WBEM_E_FAILED;
	}

	// read file blob and write to file if size is greater than zero
	if (SUCCEEDED(hres))
	{
		if (header.dwFileSize > 0)
		{
			BYTE* pFileBlob = new BYTE[header.dwFileSize];
			if (pFileBlob == NULL)
				hres = WBEM_E_OUT_OF_MEMORY;

			if (SUCCEEDED(hres))
			{
				dwSize = 0;
				if ((ReadFile(hFile, pFileBlob, header.dwFileSize, &dwSize, NULL) == 0) || (dwSize != header.dwFileSize))
				{
					hres = WBEM_E_FAILED;
				}
			}

			// write file
			if (SUCCEEDED(hres))
			{
				dwSize = 0;
				if ((WriteFile(hNewFile, pFileBlob, header.dwFileSize, &dwSize, NULL) == 0) || (dwSize != header.dwFileSize))
					hres = WBEM_E_FAILED;
			}

			if (pFileBlob)
				delete pFileBlob;
		}
	}

	if (hNewFile != INVALID_HANDLE_VALUE)
		CloseHandle(hNewFile);
	
	if (wszFullFileName)
		delete [] wszFullFileName;

	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::DeleteContentsOfDirectory
 *
 *	Description:
 *		Given a directory, iterates through all files and directories and
 *		calls into the function to delete it.
 *
 *	Parameters:
 *		wszRepositoryDirectory:	Directory to process
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::DeleteContentsOfDirectory(const wchar_t *wszRepositoryDirectory)
{
	HRESULT hres = WBEM_S_NO_ERROR;

	wchar_t *wszFullFileName = new wchar_t[MAX_PATH+1];
	if (wszFullFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;

	WIN32_FIND_DATAW findFileData;
	HANDLE hff = INVALID_HANDLE_VALUE;

	//create file search pattern...
	wchar_t *wszSearchPattern = new wchar_t[MAX_PATH+1];
	if (wszSearchPattern == NULL)
		hres = WBEM_E_OUT_OF_MEMORY;
	else
	{
		wcscpy(wszSearchPattern, wszRepositoryDirectory);
		wcscat(wszSearchPattern, L"\\*");
	}

	//Start the file iteration in this directory...
	if (SUCCEEDED(hres))
	{
		hff = FindFirstFileW(wszSearchPattern, &findFileData);
		if (hff == INVALID_HANDLE_VALUE)
		{
			hres = WBEM_E_FAILED;
		}
	}
	
	if (SUCCEEDED(hres))
	{
		do
		{
			//If we have a filename of '.' or '..' we ignore it...
			if ((wcscmp(findFileData.cFileName, L".") == 0) ||
				(wcscmp(findFileData.cFileName, L"..") == 0))
			{
				//Do nothing with these...
			}
			else if (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				//This is a directory, so we need to deal with that...
				hres = PackageDeleteDirectory(wszRepositoryDirectory, findFileData.cFileName);
				if (FAILED(hres))
					break;
			}
			else
			{
				//This is a file, so we need to deal with that...
				wcscpy(wszFullFileName, wszRepositoryDirectory);
				wcscat(wszFullFileName, L"\\");
				wcscat(wszFullFileName, findFileData.cFileName);
				if (!DeleteFileW(wszFullFileName))
				{
					hres = WBEM_E_FAILED;
					break;
				}
			}
			
		} while (FindNextFileW(hff, &findFileData));
	}
	
	if (wszFullFileName)
		delete [] wszFullFileName;

	if (wszSearchPattern)
		delete [] wszSearchPattern;

	if (hff != INVALID_HANDLE_VALUE)
		FindClose(hff);

	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::PackageDeleteDirectory
 *
 *	Description:
 *		This is the code which processes a directory.  It iterates through
 *		all files and directories in that directory.
 *
 *	Parameters:
 *		wszParentDirectory:	Full path of parent directory
 *		eszSubDirectory:	Name of sub-directory to process
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageDeleteDirectory(const wchar_t *wszParentDirectory, wchar_t *wszSubDirectory)
{
	HRESULT hres = WBEM_S_NO_ERROR;

	//Get full path of new directory...
	wchar_t *wszFullDirectoryName = NULL;
	wszFullDirectoryName = new wchar_t[MAX_PATH+1];
	if (wszFullDirectoryName == NULL)
		hres = WBEM_E_OUT_OF_MEMORY;
	else
	{
		wcscpy(wszFullDirectoryName, wszParentDirectory);
		wcscat(wszFullDirectoryName, L"\\");
		wcscat(wszFullDirectoryName, wszSubDirectory);
	}

	//Package the contents of that directory...
	if (SUCCEEDED(hres))
	{
		hres = DeleteContentsOfDirectory(wszFullDirectoryName);
	}

	// now that the directory is empty, remove it
	if (SUCCEEDED(hres))
	{
		if (!RemoveDirectoryW(wszFullDirectoryName))
			hres = WBEM_E_FAILED;
	}

	if (wszFullDirectoryName)
		delete [] wszFullDirectoryName;

	return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a51\lock.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    LOCK.H

Abstract:

	Generic class for obtaining read and write locks to some resource. 

	See lock.h for all documentation.

	Classes defined:

	CLock

History:

	a-levn  5-Sept-96       Created.
	3/10/97     a-levn      Fully documented

--*/

#ifndef __GATEWAY__LOCK__H_
#define __GATEWAY__LOCK__H_

#include <flexarry.h>

//*****************************************************************************
//
//	class CLock
//
//	Generic class for obtaining read and write locks to some resource. 
//	Simultaneous reads are allowed, but no concurrent writes or concurrent 
//	read and write accesses are.
//
//	NOTE: this class is for in-process sinchronization only!
//
//	Usage: create an instance of this class and share it among the accessing
//	threads.  Threads must call member functions of the same instance to 
//	obtain and release locks.
//
//*****************************************************************************
//
//	ReadLock
//
//	Use this function to request read access to the resource. Access will be
//	granted once no threads are writing on the resource. You must call 
//	ReadUnlock once you are done reading.
//
//	Parameters:
//
//		DWORD dwTimeout		The number of milliseconds to wait for access.
//							If access is still unavailable after this time,
//							an error is returned.
//	Returns:
//
//		NoError		On Success
//		TimedOut	On timeout.
//		Failed		On system error
//
//*****************************************************************************
//
//	ReadUnlock
//
//	Use this function to release a read lock on the resource. No check is 
//	performed to assertain that this thread holds a lock. Unmatched calls to
//	ReadUnlock may lead to lock integrity violations!
//
//	Returns:
//
//		NoError		On success
//		Failed		On system error or unmatched call.
//
//*****************************************************************************
//
//	WriteLock
//
//	Use this function to request write access to the resource. Access will be
//	granted once no threads are reading or writing on the resource. You must 
//	call WriteUnlock once you are done writing.
//
//	Parameters:
//
//		DWORD dwTimeout		The number of milliseconds to wait for access.
//							If access is still unavailable after this time,
//							an error is returned.
//	Returns:
//
//		NoError		On Success
//		TimedOut	On timeout.
//		Failed		On system error
//
//*****************************************************************************
//
//	WriteUnlock
//
//	Use this function to release a write lock on the resource. No check is 
//	performed to assertain that this thread holds a lock. Unmatched calls to
//	WriteUnlock may lead to lock integrity violations!
//
//	Returns:
//
//		NoError		On success
//		Failed		On system error or unmatched call.
//
//*****************************************************************************
//
//  DowngradeLock
//
//  Use this function to "convert" a Write lock into a Read lock. That is, if
//  you are currently holding a write lock and call DowngradeLock, you will 
//  be holding a read lock with the guarantee that no one wrote anything between
//  the unlock and the lock
//
//  Returns:
//
//      NoError     On Success
//      Failed      On system error or unmatched call
//
//******************************************************************************
class CLock
{
public:
	enum { NoError = 0, TimedOut, Failed };

	int ReadLock(DWORD dwTimeout = INFINITE);
	int ReadUnlock();
	int WriteLock(DWORD dwTimeout = INFINITE);
	int WriteUnlock();
    int DowngradeLock();

	CLock();
	~CLock();

    BOOL IsHoldingReadLock();

protected:
	int WaitFor(HANDLE hEvent, DWORD dwTimeout);

protected:
    CFlexArray m_adwReaders;
	int m_nWriting;
	int m_nReading;
	int m_nWaitingToWrite;
	int m_nWaitingToRead;

	CRITICAL_SECTION m_csEntering;
	CRITICAL_SECTION m_csAll;
	HANDLE m_hCanWrite;
	HANDLE m_hCanRead;
};

class CAutoReadLock
{
public:
	CAutoReadLock(CLock *lock, BOOL bLock = TRUE) : m_lock(lock), m_bLocked(FALSE) { if (bLock) Lock(); }
	~CAutoReadLock() { Unlock(); }
	void Unlock() {if ( m_bLocked) { m_lock->ReadUnlock(); m_bLocked = FALSE; } }
	void Lock()   {if (!m_bLocked) { m_lock->ReadLock()  ; m_bLocked = TRUE; } }

private:
	CLock *m_lock;
	BOOL m_bLocked;
};
class CAutoWriteLock
{
public:
	CAutoWriteLock(CLock *lock, BOOL bLock = TRUE) : m_lock(lock), m_bLocked(FALSE) { if (bLock) Lock(); }
	~CAutoWriteLock() { Unlock(); }
	void Unlock() {if ( m_bLocked) { m_lock->WriteUnlock(); m_bLocked = FALSE; } }
	void Lock()   {if (!m_bLocked) { m_lock->WriteLock()  ; m_bLocked = TRUE; } }

private:
	CLock *m_lock;
	BOOL m_bLocked;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a51\localloc.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a51\main.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <windows.h>
#include <wbemidl.h>
#include <commain.h>
#include <clsfac.h>
#include <wbemcomn.h>
#include <ql.h>
#include <sync.h>
#include <time.h>
#include <a51rep.h>

#include <tchar.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

DEFINE_GUID(CLSID_A51Repository, 
0x7998dc37, 0xd3fe, 0x487c, 0xa6, 0x0a, 0x77, 0x01, 0xfc, 0xc7, 0x0c, 0xc6);

class CMyServer : public CComServer
{
public:
    HRESULT Initialize()
    {
        AddClassInfo(CLSID_A51Repository, 
            new CSimpleClassFactory<CRepository>(GetLifeControl()), 
            _T("FS Repository"), TRUE);

        return S_OK;
    }

    HRESULT InitializeCom()
    {
        return CoInitializeEx(NULL, COINIT_MULTITHREADED);
    }
} Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a512rosw\filecach.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __WMI_A51_FILECACHE_H_
#define __WMI_A51_FILECACHE_H_

#include "stage.h"
#include <set>
#include <string>

namespace a51converter
{

class CFileCache
{
protected:
    CCritSec m_cs;
    WCHAR m_wszBaseName[MAX_PATH+1];
    DWORD m_dwBaseNameLen;

    CUniquePointerArray<CStagingFile> m_apStages;
    CRealStagingFile* m_pMainStage;

public:
    class CFileEnumerator
    {
    protected:
        CFileCache* m_pCache;
        WCHAR m_wszPrefix[MAX_PATH+1];
        DWORD m_dwPrefixDirLen;
        int m_nCurrentStage;
        bool m_bUseFiles;
        void* m_pStageEnumerator;
        HANDLE m_hFileEnum;
        std::set<WString, WSiless> m_setSent;
		DWORD m_dwBaseNameLen;

    public:
        CFileEnumerator(CFileCache* pCache, DWORD dwBaseNameLen) 
             : m_pCache(pCache), m_nCurrentStage(-1), m_pStageEnumerator(NULL),
                            m_hFileEnum(NULL), m_dwBaseNameLen(dwBaseNameLen)
        {}
        ~CFileEnumerator();

        long GetFirst(LPCWSTR wszPrefix, WIN32_FIND_DATAW* pfd);
        long GetFirstFile(WIN32_FIND_DATAW* pfd);
        void ComputeCanonicalName(WIN32_FIND_DATAW* pfd, wchar_t *wszFilePath);
        long GetNext(WIN32_FIND_DATAW* pfd);
        long GetRawNext(WIN32_FIND_DATAW* pfd);
    };
    friend CFileEnumerator;

    class CFindCloseMe
    {
    protected:
        CFileCache* m_pCache;
        void* m_hSearch;
    public:
        CFindCloseMe(CFileCache* pCache, void* hSearch) 
            : m_pCache(pCache), m_hSearch(hSearch){}

        ~CFindCloseMe() 
        {
            if(m_pCache && m_hSearch) m_pCache->FindClose(m_hSearch);
        }
    };

protected:
    int GetNumStages() {return m_apStages.GetSize();}
    INTERNAL CStagingFile* GetStageFile(int nIndex) {return m_apStages[nIndex];}
    INTERNAL CStagingFile* GetMainStagingFile() {return m_pMainStage;}

public:
    CFileCache();
    ~CFileCache();
    void Clear();
    bool IsFullyFlushed();

    long Initialize(LPCWSTR wszBaseName);
    long RepositoryExists(LPCWSTR wszBaseName);
    long WriteFile(LPCWSTR wszFileName, DWORD dwLen, BYTE* pBuffer);
    long ReadFile(LPCWSTR wszFileName, DWORD* pdwLen, BYTE** ppBuffer, 
                    bool bMustBeThere = false);
    long DeleteFile(LPCWSTR wszFileName);
    long RemoveDirectory(LPCWSTR wszFileName, bool bMustSucceed = true);
    long FindFirst(LPCWSTR wszFilePrefix, WIN32_FIND_DATAW* pfd,
                            void** ppHandle);
    long FindNext(void* pHandle, WIN32_FIND_DATAW* pfd);
    void FindClose(void* pHandle);

    long BeginTransaction();
    long CommitTransaction();
    long AbortTransaction();

    CCritSec* GetLock() {return &m_cs;}
};

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a51\test\main.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <windows.h>
#include <wbemcomn.h>
#include <filecach.h>
#include <stdio.h>

void __cdecl main(int argc, char** argv)
{
    TempAlloc(1);

    long lRes;

    int nNumFiles;
    sscanf(argv[1], "%d", &nNumFiles);

    CFileCache Cache;
    Cache.Initialize(L"d:\\temp\\testa51");

    char sz[100];
    
    DWORD dwStart = GetTickCount();
    for(int i = 0; i < nNumFiles; i++)
    {
        WCHAR wszBuffer[MAX_PATH+1];
        swprintf(wszBuffer, L"d:\\temp\\testa51\\LC_%d", i);
        sprintf(sz, "%d", i);
        lRes = Cache.WriteFile(wszBuffer, 100, (BYTE*)sz);
    }

    DWORD dwEnd = GetTickCount();
    printf("%dms\n", dwEnd - dwStart);

    while(!Cache.IsFullyFlushed()) Sleep(16);

    printf("%dms\n", GetTickCount() - dwEnd);
    getchar();

    dwStart = GetTickCount();
    for(i = 0; i < nNumFiles; i++)
    {
        WCHAR wszBuffer[MAX_PATH+1];
        swprintf(wszBuffer, L"d:\\temp\\testa51\\LC_%d", i);
        lRes = Cache.DeleteFile(wszBuffer);
    }

    dwEnd = GetTickCount();
    printf("%dms\n", dwEnd - dwStart);

    while(!Cache.IsFullyFlushed()) Sleep(16);

    printf("%dms\n", GetTickCount() - dwEnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a512rosw\filecach.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <windows.h>
#include <wbemcomn.h>
#include "filecach.h"

using namespace a51converter;

long CFileCache::Initialize(LPCWSTR wszBaseName)
{
    long lRes;

    wcscpy(m_wszBaseName, wszBaseName);
    wcscat(m_wszBaseName, L"\\");
    m_dwBaseNameLen = wcslen(m_wszBaseName);

    //
    // Read the maximum stage-file size from the registry
    //

    HKEY hKey;
    lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ | KEY_WRITE, &hKey);
    if(lRes)
        return lRes;
    CRegCloseMe cm(hKey);

    DWORD dwLen = sizeof(DWORD);
    DWORD dwMaxLen;
    lRes = RegQueryValueExW(hKey, L"Max Stage File Size", NULL, NULL, 
                (LPBYTE)&dwMaxLen, &dwLen);

    //
    // If not there, set to default and write the default into the registry
    //

    if(lRes != ERROR_SUCCESS)
    {
        dwMaxLen = 5000000;
        lRes = RegSetValueExW(hKey, L"Max Stage File Size", 0, REG_DWORD, 
                (LPBYTE)&dwMaxLen, sizeof(DWORD));
    }

    dwLen = sizeof(DWORD);
    DWORD dwAbortTransactionLen;
    lRes = RegQueryValueExW(hKey, L"Absolute Max Stage File Size", NULL, NULL, 
                (LPBYTE)&dwAbortTransactionLen, &dwLen);

    //
    // If not there, set to default and write the default into the registry
    //

    if(lRes != ERROR_SUCCESS || dwAbortTransactionLen == dwMaxLen * 10)
    {
        dwAbortTransactionLen = 0x7FFFFFFF;
        lRes = RegSetValueExW(hKey, L"Absolute Max Stage File Size", 0, 
                REG_DWORD, (LPBYTE)&dwAbortTransactionLen, sizeof(DWORD));
    }

    if(dwMaxLen == 0)
    {
        //
        // Staged writes are disabled!
        //

        m_pMainStage = NULL;
    }
    else
    {
        //
        // Create the main staging area
        //
    
        CFileName wszStagingName;
		if (wszStagingName == NULL)
			return ERROR_OUTOFMEMORY;
        swprintf(wszStagingName, L"%s\\MainStage.dat", wszBaseName);
    
        m_pMainStage = new CExecutableStagingFile(this, m_wszBaseName, 
                                              dwMaxLen, dwAbortTransactionLen);
/*
        m_pMainStage = new CPermanentStagingFile(this, m_wszBaseName);
*/
    
        if(m_pMainStage == NULL)
            return E_OUTOFMEMORY;
    
        long lRes = m_pMainStage->Create(wszStagingName);
        if(lRes != ERROR_SUCCESS)
            return lRes;
    
        if(m_apStages.Add(m_pMainStage) < 0)
        {
            delete m_pMainStage;
            return E_OUTOFMEMORY;
        }
    }
    return ERROR_SUCCESS;
}

long CFileCache::RepositoryExists(LPCWSTR wszBaseName)
{
    CFileName wszStagingName;
	if (wszStagingName == NULL)
		return ERROR_OUTOFMEMORY;
    swprintf(wszStagingName, L"%s\\MainStage.dat", wszBaseName);

    DWORD dwAttributes = GetFileAttributesW(wszStagingName);
    if (dwAttributes == -1)
        return ERROR_FILE_NOT_FOUND;
    return ERROR_SUCCESS;

}

CFileCache::CFileCache()
{
}

CFileCache::~CFileCache()
{
    Clear();
}

void CFileCache::Clear()
{
}

bool CFileCache::IsFullyFlushed()
{
    CInCritSec ics(&m_cs);

    for(int i = 0; i < m_apStages.GetSize(); i++)
    {
        if(!m_apStages[i]->IsFullyFlushed())
            return false;
    }
    return true;
}


long CFileCache::WriteFile(LPCWSTR wszFileName, DWORD dwLen, BYTE* pBuffer)
{
    CInCritSec ics(&m_cs);

    //
    // Write the file into the main staging file
    //

    if(GetMainStagingFile())
    {
        return GetMainStagingFile()->WriteFile(wszFileName + m_dwBaseNameLen, 
                                            dwLen, pBuffer);
    }
    else
    {
        long lRes = A51WriteFile(wszFileName, dwLen, pBuffer);
        _ASSERT(lRes == ERROR_SUCCESS, L"Failed to create a file");
        return lRes;
    }
}

long CFileCache::DeleteFile(LPCWSTR wszFileName)
{
    CInCritSec ics(&m_cs);

    //
    // Write the file into the main staging file
    //

    if(GetMainStagingFile())
    {
        return GetMainStagingFile()->DeleteFile(wszFileName + m_dwBaseNameLen);
    }
    else
    {
        long lRes = A51DeleteFile(wszFileName);
        _ASSERT(lRes == ERROR_SUCCESS || lRes == ERROR_FILE_NOT_FOUND ||
                lRes == ERROR_PATH_NOT_FOUND, L"Failed to delete file");
        return lRes;
    }
    
}

long CFileCache::RemoveDirectory(LPCWSTR wszFileName, bool bMustSucceed)
{
    CInCritSec ics(&m_cs);

    //
    // Write the file into the main staging file
    //

    if(GetMainStagingFile())
    {
        return GetMainStagingFile()->
                    RemoveDirectory(wszFileName + m_dwBaseNameLen);
    }
    else
    {
        long lRes = A51RemoveDirectory(wszFileName);
        _ASSERT(lRes == ERROR_SUCCESS || 
                lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND ||
                lRes == ERROR_DIR_NOT_EMPTY, 
                    L"Failed to remove directory");

/*
        _ASSERT(!bMustSucceed || lRes != ERROR_DIR_NOT_EMPTY,
            L"Stuff in directory that should be empty");
*/

        return lRes;
    }
}
    
HRESULT CFileCache::ReadFile(LPCWSTR wszFileName, DWORD* pdwLen, 
                                BYTE** ppBuffer, bool bMustBeThere)
{
    long lRes;

    CInCritSec ics(&m_cs);

    //
    // Search all staging files in order
    //

    for(int i = 0; i < m_apStages.GetSize(); i++)
    {
        lRes = m_apStages[i]->ReadFile(wszFileName + m_dwBaseNameLen, pdwLen,
                                        ppBuffer, bMustBeThere);
        if(lRes != ERROR_NO_INFORMATION)
        {
            if(lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND &&
                    lRes != ERROR_PATH_NOT_FOUND)
            {
                ERRORTRACE((LOG_WBEMCORE, "Repository driver cannot read file "
                    "'%S' from the stage with error code %d\n", wszFileName,
                            lRes));
            }
            return lRes;
        }
    }
    
    //
    // Not in the staging areas --- get from disk!
    //

    WIN32_FIND_DATAW fd;
    HANDLE hSearch = ::FindFirstFileW(wszFileName, &fd);
    if(hSearch == INVALID_HANDLE_VALUE)
    {
        lRes = GetLastError();
        //_ASSERT(!bMustBeThere, L"Must-be-there file is not found!");
        _ASSERT(lRes != ERROR_SUCCESS, L"Success reported on failure");
        if(lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND)
            return ERROR_FILE_NOT_FOUND;
        else
            return lRes;
    }
    else    
        ::FindClose(hSearch);
    
    HANDLE hFile = CreateFileW(wszFileName, GENERIC_READ, FILE_SHARE_READ,
                NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    lRes = GetLastError();
    A51TRACE(("Reading %S returned %d\n", wszFileName, lRes));
    if(hFile == INVALID_HANDLE_VALUE)
    {
        _ASSERT(lRes != ERROR_SUCCESS, L"Success reported on failure");
        if(lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_PATH_NOT_FOUND)
        {
            ERRORTRACE((LOG_WBEMCORE, "Repository driver unable to open file "
                "'%S' with error code %d\n", wszFileName, lRes));
        }
        //_ASSERT(!bMustBeThere, L"Must-be-there file is not found!");
        return lRes;
    }


    CCloseMe cm(hFile);

/*
    BY_HANDLE_FILE_INFORMATION fi;
    if(!GetFileInformationByHandle(hFile, &fi))
    {
        _ASSERT(!bMustBeThere, L"Must-be-there file is not found!");
        return GetLastError();
    }
*/

    // BUG: instances must be less than 4G :-)

    //
    // Try to read one byte more than what FindFirstFile told us.  This is 
    // important because FindFirstFile has been known to lie about the size of
    // the file.  If it told us too low a number, then this longer read will
    // succeed, and we will know we've been had. 
    //
    
    // *pdwLen = fi.nFileSizeLow;
    *pdwLen = fd.nFileSizeLow + 1;
    *ppBuffer = (BYTE*)TempAlloc(*pdwLen);
    if(*ppBuffer == NULL)
        return E_OUTOFMEMORY;

    DWORD dwRead;
    if(!::ReadFile(hFile, *ppBuffer, *pdwLen, &dwRead, NULL))
    {
        lRes = GetLastError();
        ERRORTRACE((LOG_WBEMCORE, "Repository driver unable to read %d bytes "
            "from file with error %d\n", *pdwLen, lRes));
        _ASSERT(lRes != ERROR_SUCCESS, L"Success reported on failure");
        TempFree(*ppBuffer);
        //_ASSERT(!bMustBeThere, L"Must-be-there file is not found!");
        return lRes;
    }
    else 
    {
        if(dwRead == *pdwLen - 1)
        {
            // Got the right number of bytes --- remember we incrememented it
            // to catch liers

            (*pdwLen)--;
            return ERROR_SUCCESS;
        }
        else 
        {
            //
            // We were lied to by FindFirstFile.  Get the real file length and
            // try again
            //

            TempFree(*ppBuffer);
            *ppBuffer = NULL;

            BY_HANDLE_FILE_INFORMATION fi;
            if(!GetFileInformationByHandle(hFile, &fi))
            {
                return GetLastError();
            }

            //
            // Allocate the buffer from scratch
            //

            *pdwLen = fi.nFileSizeLow;
            *ppBuffer = (BYTE*)TempAlloc(*pdwLen);
            if(*ppBuffer == NULL)
                return E_OUTOFMEMORY;
        
            DWORD dwRead;
            if(!::ReadFile(hFile, *ppBuffer, *pdwLen, &dwRead, NULL))
            {
                lRes = GetLastError();
                ERRORTRACE((LOG_WBEMCORE, "Repository driver unable to read %d "
                    "bytes from file with error %d\n", *pdwLen, lRes));
                _ASSERT(lRes != ERROR_SUCCESS, L"Success reported on failure");
                TempFree(*ppBuffer);
                //_ASSERT(!bMustBeThere, L"Must-be-there file is not found!");
                return lRes;
            }
            else 
            {
                if(*pdwLen != dwRead)
                {
                    _ASSERT(false, L"Read the wrong number of bytes");
                    TempFree(*ppBuffer);
                    return E_OUTOFMEMORY;
                }
                else
                    return ERROR_SUCCESS;
            }
        }
    }
}


long CFileCache::FindFirst(LPCWSTR wszFilePrefix, WIN32_FIND_DATAW* pfd,
                            void** ppHandle)
{
    CInCritSec ics(&m_cs);

    //
    // Construct an enumerator 
    //

    CFileEnumerator* pEnum = new CFileEnumerator(this, m_dwBaseNameLen);
	if (pEnum == NULL)
		return E_OUTOFMEMORY;
    long lRes = pEnum->GetFirst(wszFilePrefix, pfd);
    if(lRes != ERROR_SUCCESS)
    {
        delete pEnum;
        return lRes;
    }

    *ppHandle = (void*)pEnum;
    return ERROR_SUCCESS;
}

long CFileCache::FindNext(void* pHandle, WIN32_FIND_DATAW* pfd)
{
    CInCritSec ics(&m_cs);

    CFileEnumerator* pEnum = (CFileEnumerator*)pHandle;
    return pEnum->GetNext(pfd);
}


void CFileCache::FindClose(void* pHandle)
{
    CInCritSec ics(&m_cs);

    delete (CFileEnumerator*)pHandle;
}
    
long CFileCache::BeginTransaction()
{
    if(GetMainStagingFile())
        return GetMainStagingFile()->BeginTransaction();
    else
        return ERROR_SUCCESS;
}

long CFileCache::CommitTransaction()
{
    A51TRACE(("Committing Transaction!\n"));
    if(GetMainStagingFile())
        return GetMainStagingFile()->CommitTransaction();
    else
        return ERROR_SUCCESS;
}

long CFileCache::AbortTransaction()
{
    A51TRACE(("Aborting Transaction!\n"));
    if(GetMainStagingFile())
        return GetMainStagingFile()->AbortTransaction();
    else
        return ERROR_SUCCESS;
}


CFileCache::CFileEnumerator::~CFileEnumerator()
{
    if(m_pStageEnumerator)
        m_pCache->GetStageFile(m_nCurrentStage)->FindClose(m_pStageEnumerator);

    if(m_hFileEnum)
        ::FindClose(m_hFileEnum);
}

long CFileCache::CFileEnumerator::GetFirst(LPCWSTR wszPrefix, 
                                            WIN32_FIND_DATAW* pfd)
{
    long lRes;

    wcscpy(m_wszPrefix, wszPrefix);

    WCHAR* pwcLastSlash = wcsrchr(m_wszPrefix, L'\\');
    if(pwcLastSlash == NULL)
        return E_OUTOFMEMORY;

    m_dwPrefixDirLen = pwcLastSlash - m_wszPrefix;

    //
    // We are going to start with the first staging area
    //

    m_nCurrentStage = 0;
    m_bUseFiles = false;

    //
    // Everything is set up to indicate that we are at the very beginning ---
    // GetNext will retrieve the first
    //

    lRes = GetNext(pfd);
    
    //
    // One last thing --- absense of files is ERROR_NO_MORE_FILES for GetNext,
    // but ERROR_FILE_NOT_FOUND for GetFirst, so translate
    //

    if(lRes == ERROR_NO_MORE_FILES)
        lRes = ERROR_FILE_NOT_FOUND;

    return lRes;
}

long CFileCache::CFileEnumerator::GetFirstFile(WIN32_FIND_DATAW* pfd)
{
    m_bUseFiles = true;

    CFileName wszMask;
	if (wszMask == NULL)
		return ERROR_OUTOFMEMORY;
    wcscpy(wszMask, m_wszPrefix);
    wcscat(wszMask, L"*");

    m_hFileEnum = ::FindFirstFileW(wszMask, pfd);
    long lRes = GetLastError();
    A51TRACE(("Actual FindFirstFileW on %S returning %p %d\n",
        wszMask, (void*)m_hFileEnum, lRes));
    if(m_hFileEnum == INVALID_HANDLE_VALUE)
    {
        if(lRes == ERROR_PATH_NOT_FOUND)
            return ERROR_FILE_NOT_FOUND;
        else
            return lRes;
    }
    else
        return ERROR_SUCCESS;
}

void CFileCache::CFileEnumerator::ComputeCanonicalName(WIN32_FIND_DATAW* pfd,
                                                    wchar_t *wszFilePath)
{
    wcsncpy(wszFilePath, m_wszPrefix, m_dwPrefixDirLen+1);
    wbem_wcsupr(wszFilePath+m_dwPrefixDirLen+1, pfd->cFileName);
}

long CFileCache::CFileEnumerator::GetNext(WIN32_FIND_DATAW* pfd)
{
    long lRes;

    //
    // Go through the files in the enumerator until we find a new and valid one
    //

    while((lRes = GetRawNext(pfd)) == ERROR_SUCCESS)
    {
        //
        // Compute the full name
        //

        CFileName wszFullName;
		if (wszFullName == NULL)
			return ERROR_OUTOFMEMORY;
        ComputeCanonicalName(pfd, wszFullName);

        //
        // Check if it is already in our map of returned files
        //

        if(m_setSent.find((const wchar_t*)wszFullName) != m_setSent.end())
            continue;

        //
        // Check if this file is deleted
        //

        bool bDeleted = false;
        for(int i = 0; i < m_nCurrentStage; i++)
        {
			long hres = m_pCache->GetStageFile(i)->IsDeleted(wszFullName + m_dwBaseNameLen);
			if (hres == S_OK)
            {
                bDeleted = true;
                break;
            }
			else if (FAILED(hres))
			{
				return hres;
			}
        }

        if(bDeleted)
            continue;

        //
        // All clear!
        //

        if(!m_bUseFiles)
            m_setSent.insert((const wchar_t*)wszFullName);

        return ERROR_SUCCESS;
    }

    return lRes;
}

long CFileCache::CFileEnumerator::GetRawNext(WIN32_FIND_DATAW* pfd)
{
    long lRes;

    if(m_bUseFiles)
    {
        //
        // Get the next file
        //

        if(!FindNextFileW(m_hFileEnum, pfd))
        {
            lRes = GetLastError();
            ::FindClose(m_hFileEnum);
            m_hFileEnum = NULL;
            return lRes;
        }
        else
        {
            return ERROR_SUCCESS;
        }
    }
    else
    {
        //
        // Check if we even have a stage enumerator
        //

        if(m_pStageEnumerator)
        {
            // 
            // Get the next file from the same stage
            //
    
            lRes = m_pCache->GetStageFile(m_nCurrentStage)->
                        FindNext(m_pStageEnumerator, pfd);
            if(lRes != ERROR_NO_MORE_FILES)
                return lRes;
    
            //
            // Advance to the next one
            //
        
            m_pCache->GetStageFile(m_nCurrentStage)->
                    FindClose(m_pStageEnumerator);
            m_pStageEnumerator = NULL;
            m_nCurrentStage++;
        }
        else
        {
            //
            // This is our first time --- we are all set up to pick up the first
            // file from the first stage
            //
        }

        while(1)
        {
            if(m_nCurrentStage >= m_pCache->GetNumStages())
            {
                //
                // Go to files
                //
    
                lRes = GetFirstFile(pfd);
                if(lRes == ERROR_FILE_NOT_FOUND)
                    return ERROR_NO_MORE_FILES;
                else
                    return lRes;
            }
            else
            {
                //
                // Initialize the next stage
                //
    
                lRes = m_pCache->GetStageFile(m_nCurrentStage)->
                            FindFirst(m_wszPrefix + m_dwBaseNameLen, pfd, &m_pStageEnumerator);
                if(lRes == ERROR_FILE_NOT_FOUND)
                {
                    //
                    // This stage has nothing to contribute --- move along
                    //

                    m_nCurrentStage++;
                    continue;
                }
                else
                    return lRes;
            }
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a51\repositorypackager.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    RepositoryPackager.h

Abstract:

    Recursively packages the contents of the repository directory into a single file,
	and unpackages it.

History:

    paulall	  07/26/00  Created.
	a-shawnb  07/27/00  Finished.

--*/

#ifndef __REPOSITORYPACKAGER_H_
#define __REPOSITORYPACKAGER_H_

#define PACKAGE_TYPE_NAMESPACE_START	1
#define PACKAGE_TYPE_NAMESPACE_END		2
#define PACKAGE_TYPE_FILE				3
#define PACKAGE_TYPE_END_OF_FILE		4

typedef struct _PACKAGE_HEADER
{
	char szSignature[10];
} PACKAGE_HEADER;

typedef struct _PACKAGE_SPACER
{
	DWORD dwSpacerType;
} PACKAGE_SPACER;

typedef struct _PACKAGER_SPACER_NAMESPACE : _PACKAGE_SPACER
{
	wchar_t wszNamespaceName[MAX_PATH+1];
} PACKAGE_SPACER_NAMESPACE;

typedef struct _PACKAGER_SPACER_FILE : _PACKAGE_SPACER
{
	wchar_t wszFileName[MAX_PATH+1];
	DWORD dwFileSize;
} PACKAGE_SPACER_FILE;

class CRepositoryPackager
{
    wchar_t m_wszFileToProcess[MAX_PATH+1];
private:
	HRESULT GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1]);
	
	HRESULT PackageHeader(HANDLE hFile);
	HRESULT PackageContentsOfDirectory(HANDLE hFile, const wchar_t *wszRepositoryDirectory);
	HRESULT PackageDirectory(HANDLE hFile, const wchar_t *wszParentDirectory, wchar_t *wszSubDirectory);
	HRESULT PackageFile(HANDLE hFile, const wchar_t *wszParentDirectory, wchar_t *wszFilename);
	HRESULT PackageTrailer(HANDLE hFile);
	
	HRESULT UnPackageHeader(HANDLE hFile);
	HRESULT UnPackageContentsOfDirectory(HANDLE hFile, const wchar_t *wszRepositoryDirectory);
	HRESULT UnPackageDirectory(HANDLE hFile, const wchar_t *wszParentDirectory);
	HRESULT UnPackageFile(HANDLE hFile, const wchar_t *wszParentDirectory);

	HRESULT DeleteContentsOfDirectory(const wchar_t *wszRepositoryDirectory);
	HRESULT PackageDeleteDirectory(const wchar_t *wszParentDirectory, wchar_t *wszSubDirectory);

public:
	CRepositoryPackager() {}
	~CRepositoryPackager() {}
	
	HRESULT PackageRepository(const wchar_t *wszFilename);
	HRESULT UnpackageRepository(const wchar_t *wszFilename);
	HRESULT DeleteRepository();
};

#endif // __REPOSITORYPACKAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a512rosw\a51tools.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __A51_TOOLS__H_
#define __A51_TOOLS__H_

#include <sync.h>
#include <newnew.h>
#include <xmemory>

#ifdef DBG
  #define _A51_INTERNAL_ASSERT
#endif

typedef LONGLONG TFileOffset;

#define MAX_HASH_LEN 32

void* TempAlloc(DWORD dwLen);
void TempFree(void* p, DWORD dwLen = 0);

void* TempAlloc(CTempMemoryManager& Manager, DWORD dwLen);
void TempFree(CTempMemoryManager& Manager, void* p, DWORD dwLen);

HRESULT A51TranslateErrorCode(long lRes);

#define TEMPFREE_ME

class CTempFreeMe
{
protected:
    void* m_p;
    DWORD m_dwLen;
public:
    CTempFreeMe(void* p, DWORD dwLen = 0) : m_p(p), m_dwLen(dwLen){}
    ~CTempFreeMe() {TempFree(m_p, m_dwLen);}
};

HANDLE A51GetNewEvent();
void A51ReturnEvent(HANDLE hEvent);

class CReturnMe
{
protected:
    HANDLE m_h;
public:
    CReturnMe(HANDLE h) : m_h(h){}
    ~CReturnMe() {A51ReturnEvent(m_h);}
};


inline void wbem_wcsupr(WCHAR* pwcTo, const WCHAR* pwcFrom)
{
    while(*pwcFrom)
    {
        if(*pwcFrom >= 'a' && *pwcFrom <= 'z')
            *pwcTo = *pwcFrom + ('A'-'a');
        else if(*pwcFrom < 128)
            *pwcTo = *pwcFrom;
        else 
            *pwcTo = towupper(*pwcFrom);
        pwcTo++;
        pwcFrom++;
    }
    *pwcTo = 0;
}

class CFileName
{
private:
	wchar_t *m_wszFilename;

public:
	DWORD Length() { return MAX_PATH + 1; }
	CFileName() { m_wszFilename = (wchar_t*)TempAlloc(sizeof(wchar_t) * Length()); }
	~CFileName() { TempFree(m_wszFilename, sizeof(wchar_t) * Length()); }
	operator wchar_t *() { return m_wszFilename; }
};

long EnsureDirectory(LPCWSTR wszPath, LPSECURITY_ATTRIBUTES pSA = NULL);
long EnsureDirectoryForFile(LPCWSTR wszPath, LPSECURITY_ATTRIBUTES pSA = NULL);
bool A51Hash(LPCWSTR wszName, LPWSTR wszHash);
long A51DeleteFile(LPCWSTR wszFullPath);
long A51WriteFile(LPCWSTR wszFullPath, DWORD dwLen, BYTE* pBuffer);
long A51RemoveDirectory(LPCWSTR wszFullPath, bool bAbortOnFiles = true);
long A51WriteToFileAsync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen, OVERLAPPED* pov);
long A51WriteToFileSync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen);
long A51ReadFromFileAsync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen, OVERLAPPED* pov);
long A51ReadFromFileSync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen);

extern __int64 g_nCurrentTime;

#undef _ASSERT

#ifdef _A51_INTERNAL_ASSERT
#define _ASSERT(X, MSG) {if(!(X)) {A51TraceFlush(); DebugBreak();}}
#else
#define _ASSERT(X, MSG)
#endif

extern FILE* g_fLog;

#ifdef _A51_INTERNAL_DEBUG
#define A51TRACE(X) A51Trace X
#else
#define A51TRACE(X)
#endif

void A51Trace(LPCSTR szFormat, ...);

void A51TraceFlush();

template<class T>
class CTempAllocator
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef T *pointer;
    typedef const T *const_pointer;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T value_type;

    char* _Charalloc(size_t n)
    {
        return (char*)TempAlloc(n);
    }

    void deallocate(void* p, size_t n)
    {
        TempFree(p, 0);
    }

    void construct(pointer p, const T& val)
    {
        new ((void*)p) T(val);
    }

    void destroy(pointer p)
    {
        p->T::~T();
    }
};

template<class T>
class CPrivateTempAllocator
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef T *pointer;
    typedef const T *const_pointer;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T value_type;

    CPrivateTempAllocator(CTempMemoryManager* pManager) 
        : m_pManager(pManager)
    {}
    
    char* _Charalloc(size_t n)
    {
        return (char*)m_pManager->Allocate(n);
    }

    void deallocate(void* p, size_t n)
    {
        m_pManager->Free(p, 0);
    }

    void construct(pointer p, const T& val)
    {
        new ((void*)p) T(val);
    }

    void destroy(pointer p)
    {
        p->T::~T();
    }
protected:
    CTempMemoryManager* m_pManager;
};

    
            
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a51\stage.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __WMI_A51_STAGE__H_
#define __WMI_A51_STAGE__H_

#include <queue>
#include <map>
#include <list>
#include <sync.h>
#include "a51tools.h"

#define ERROR_NO_INFORMATION -1


class CFileCache;
class CStagingFile
{
public:
    virtual ~CStagingFile(){}
    virtual long ReadFile(LPCWSTR wszFilePath, DWORD* pdwLen,
                            DELETE_ME BYTE** ppBuffer, bool bMustBeThere) = 0;
    virtual long IsDeleted(LPCWSTR wszFilePath) = 0;
    virtual long WriteFile(LPCWSTR wszFilePath, DWORD dwLen,
                            BYTE* pBuffer) = 0;
    virtual long DeleteFile(LPCWSTR wszFilePath) = 0;
    virtual long RemoveDirectory(LPCWSTR wszFilePath) = 0;
    virtual long FindFirst(LPCWSTR wszFilePrefix, WIN32_FIND_DATAW* pfd,
                            void** ppHandle) = 0;
    virtual long FindNext(void* pHandle, WIN32_FIND_DATAW* pfd) = 0;
    virtual void FindClose(void* pHandle) = 0;
    virtual long BeginTransaction() = 0;
    virtual long CommitTransaction() = 0;
    virtual long AbortTransaction() = 0;

    virtual bool IsFullyFlushed() = 0;
    virtual void Dump() = 0;
};

class CRealStagingFile;

class CFileInstruction
{
protected:
    long m_lRef;
    CRealStagingFile* m_pFile;
    WCHAR* m_wszFilePath;
    TFileOffset m_lFileOffset;
    bool m_bCommitted;

public:
    CFileInstruction(CRealStagingFile* pFile);
    long Initialize(LPCWSTR wszFilePath);
    virtual ~CFileInstruction();

    void AddRef() {m_lRef++;}
    void Release() {if(--m_lRef == 0) delete this;}

    LPCWSTR GetFilePath() {return m_wszFilePath;}
    long GetFileOffset() {return m_lFileOffset;}
    void SetCommitted() {m_bCommitted = true;}
    bool IsCommitted() {return m_bCommitted;}

    virtual long Execute() = 0;
    virtual long RecoverData(HANDLE hFile) = 0;
    virtual bool IsDeletion() = 0;

protected:
    DWORD ComputeSpaceForName();
    BYTE* WriteFileName(BYTE* pStart);
    long RecoverFileName(HANDLE hFile);
    void ComputeFullPath(wchar_t *wszFullPath);
};

class CCreateFile : public CFileInstruction
{
protected:
    DWORD m_dwFileLen;
    DWORD m_dwFileStart;

public:
    CCreateFile(CRealStagingFile* pFile);
    long Initialize(LPCWSTR wszFilePath, DWORD dwFileLen);

    DWORD ComputeNeededSpace();
    long Write(TFileOffset lOffset, BYTE* pBuffer);
    long RecoverData(HANDLE hFile);
    long Execute();

    long GetData(HANDLE hFile, DWORD* pdwLen, BYTE** ppBuffer);
    virtual bool IsDeletion(){return false;}

    void* operator new(size_t);
    void operator delete(void* p);
};

class CDeleteFile : public CFileInstruction
{
public:
    CDeleteFile(CRealStagingFile* pFile);
    long Initialize(LPCWSTR wszFilePath);

    DWORD ComputeNeededSpace();
    long Write(TFileOffset lOffset);
    long RecoverData(HANDLE hFile);
    long Execute();
    virtual bool IsDeletion(){return true;}

    void* operator new(size_t);
    void operator delete(void* p);
};

class CRemoveDirectory : public CFileInstruction
{
public:
    CRemoveDirectory(CRealStagingFile* pFile);
    long Initialize(LPCWSTR wszFilePath);

    DWORD ComputeNeededSpace();
    long Write(TFileOffset lOffset);
    long RecoverData(HANDLE hFile);
    long Execute();
    virtual bool IsDeletion(){return false;}

    void* operator new(size_t);
    void operator delete(void* p);
};

class CFileCache;
class CRealStagingFile : public CStagingFile
{
    class wcscless : public binary_function<LPCWSTR, LPCWSTR, bool>
    {
    public:
        bool operator()(const LPCWSTR& wcs1, const LPCWSTR& wcs2) const
            {return wcscmp(wcs1, wcs2) < 0;}
    };

protected:
    wchar_t m_wszBaseName[MAX_PATH+1];

    HANDLE m_hFile;
    HANDLE m_hFlushFile;
    long m_lFirstFreeOffset;

    typedef std::map<LPCWSTR, CFileInstruction*, wcscless, 
                     CPrivateTempAllocator<CFileInstruction*> > TMap;
    typedef TMap::iterator TIterator;
    typedef std::queue<CFileInstruction*, std::list<CFileInstruction*, 
                                    CPrivateTempAllocator<CFileInstruction*> > 
              > TQueue;
    typedef std::stack<CFileInstruction*, std::list<CFileInstruction*, 
                                    CPrivateTempAllocator<CFileInstruction*> > 
              > TStack;

    CCritSec m_cs;
    TMap m_map;
    TQueue m_qToWrite;

    TStack m_stReplacedInstructions;
    TQueue m_qTransaction;

    __int64 m_nTransactionIndex;
    long m_lTransactionStartOffset;
    BYTE m_TransactionHash[16];

    bool m_bInTransaction;

    long m_lMaxFileSize;
    long m_lAbortTransactionFileSize;
    CFileCache* m_pCache;

    bool m_bFailedBefore;
    long m_lStatus;

public:
    CRealStagingFile(CFileCache* pCache, LPCWSTR wszBaseName, 
                            long lMaxFileSize, long lAbortTransactionFileSize);
    virtual ~CRealStagingFile();

    virtual long Create(LPCWSTR wszStagingFileName);
    void SetMaxFileSize(long lMaxFileSize, long lAbortTransactionFileSize);
    long ReadFile(LPCWSTR wszFilePath, DWORD* pdwLen,
                            DELETE_ME BYTE** ppBuffer, bool bMustBeThere);
    long WriteFile(LPCWSTR wszFilePath, DWORD dwLen,
                            BYTE* pBuffer);
    long DeleteFile(LPCWSTR wszFilePath);
    long RemoveDirectory(LPCWSTR wszFilePath);
    long FindFirst(LPCWSTR wszFilePrefix, WIN32_FIND_DATAW* pfd,
                            void** ppHandle);
    long FindNext(void* pHandle, WIN32_FIND_DATAW* pfd);
    void FindClose(void* pHandle);
    long IsDeleted(LPCWSTR wszFilePath);

    bool IsFullyFlushed();

    INTERNAL HANDLE GetHandle() {return m_hFile;}
    INTERNAL HANDLE GetFlushHandle() {return m_hFlushFile;}
    INTERNAL LPCWSTR GetBase() {return m_wszBaseName;}

    long WriteInstruction(long lStartingOffset, 
                            BYTE* pBuffer, DWORD dwBufferLen);

    long BeginTransaction();
    long CommitTransaction();
    long AbortTransaction();
    void Dump();

protected:
    long WaitForSpaceForTransaction();
    virtual void SignalPresense(){}

    virtual long CanStartNewTransaction();
    virtual bool CanWriteInTransaction(DWORD dwSpaceNeeded);
    long RecoverStage(HANDLE hFile);
    long RecoverTransaction(HANDLE hFile);
    BYTE ReadNextInstructionType(HANDLE hFile);
    virtual long WriteEmpty();

    long ProcessCommit();
    long ProcessBegin();
    INTERNAL CCritSec* GetLock() {return &m_cs;}
    int GetStagingFileHeaderSize();

protected:
    void ComputeKey(LPCWSTR wszFileName, LPWSTR wszKey);
    long AddInstruction(CFileInstruction* pInst);

    class CIterationHandle
    {
    protected:
        TMap& m_rMap;
        TIterator m_it;
        wchar_t m_wszPrefix[MAX_PATH+1];
        DWORD m_dwPrefixLen;
        DWORD m_dwPrefixDirLen;

    public:
        CIterationHandle(CRealStagingFile::TMap& rMap,
                    const CRealStagingFile::TIterator& rIt,
                    LPCWSTR wszPrefix);

        long GetNext(WIN32_FIND_DATAW* pfd);

        void* operator new(size_t) 
            {return TempAlloc(sizeof(CIterationHandle));}
        void operator delete(void* p) 
            {return TempFree(p, sizeof(CIterationHandle));}

        friend class CRealStagingFile;
    };
	friend class CCreateFile;
protected:
    CPointerArray<CIterationHandle> m_apIterators;
    TIterator EraseIterator(TIterator it);
};

class CExecutableStagingFile : public CRealStagingFile
{
protected:
    HANDLE m_hEvent;
    HANDLE m_hThread;
    bool m_bExitNow;

public:
    CExecutableStagingFile(CFileCache* pCache, LPCWSTR wszBaseName, 
                            long lMaxFileSize, long lAbortTransactionFileSize);
    ~CExecutableStagingFile();

    virtual long Create(LPCWSTR wszStagingFileName);

protected:
    static DWORD staticFlusher(void* pArg);

    virtual long WriteEmpty();
    virtual void SignalPresense();
    DWORD Flusher();
    long Flush();
};

class CPermanentStagingFile : public CRealStagingFile
{
public:
    CPermanentStagingFile(CFileCache* pCache, LPCWSTR wszBaseName);
    ~CPermanentStagingFile();
};
    

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a512rosw\a51tools.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include "a51tools.h"

__int64 g_nCurrentTime = 1;

__int64 g_nReadFailures = 0;
__int64 g_nWriteFailures = 0;

//
// FILE_ATTRIBUTE_NOT_CONTENT_INDEXED is not actually supported on CreateFile,
// contrary to the docs.  However, also contrary to the docs, it is inherited
// from the parent directory
//

#define A51_FILE_CREATION_FLAGS 0 //FILE_ATTRIBUTE_NOT_CONTENT_INDEXED

CTempMemoryManager g_Manager;

void* TempAlloc(DWORD dwLen)
{
    return g_Manager.Allocate(dwLen);
}
    
void TempFree(void* p, DWORD dwLen)
{
    g_Manager.Free(p, dwLen);
}

void* TempAlloc(CTempMemoryManager& Manager, DWORD dwLen)
{
    return Manager.Allocate(dwLen);
}
    
void TempFree(CTempMemoryManager& Manager, void* p, DWORD dwLen)
{
    Manager.Free(p, dwLen);
}

HANDLE A51GetNewEvent()
{
    return CreateEvent(NULL, TRUE, FALSE, NULL);
}

void A51ReturnEvent(HANDLE hEvent)
{
    CloseHandle(hEvent);
}

HRESULT A51TranslateErrorCode(long lRes)
{
    switch(lRes)
    {
    case ERROR_FILE_NOT_FOUND:
    case ERROR_PATH_NOT_FOUND:
        return WBEM_E_NOT_FOUND;
    case ERROR_OUTOFMEMORY:
        return WBEM_E_OUT_OF_MEMORY;
    case ERROR_NOT_ENOUGH_QUOTA:
    case ERROR_DISK_FULL:
        return WBEM_E_OUT_OF_DISK_SPACE;
    default:
        return WBEM_E_FAILED;
    }
}

long __stdcall EnsureDirectory(LPCWSTR wszPath, LPSECURITY_ATTRIBUTES pSA)
{
    if(!CreateDirectoryW(wszPath, NULL))
    {
		long lRes = GetLastError();
        if(lRes != ERROR_ALREADY_EXISTS)
            return lRes;
        else
            return ERROR_SUCCESS;
    }
    else
        return ERROR_SUCCESS;
}

long __stdcall EnsureDirectoryRecursiveForFile(LPWSTR wszPath, 
                                                LPSECURITY_ATTRIBUTES pSA);
long __stdcall EnsureDirectoryForFile(LPCWSTR wszPath, LPSECURITY_ATTRIBUTES pSA)
{
    //
    // Make a copy, since we will be messing with it
    //

    CFileName wszNewPath;
	if (wszNewPath == NULL)
		return ERROR_OUTOFMEMORY;
    wcscpy(wszNewPath, wszPath);

    return EnsureDirectoryRecursiveForFile(wszNewPath, pSA);
}


long __stdcall EnsureDirectoryRecursiveForFile(LPWSTR wszPath, 
                                                LPSECURITY_ATTRIBUTES pSA)
{
    long lRes;

    //
    // Find the last backslash and remove
    //

    WCHAR* pwcLastSlash = wcsrchr(wszPath, L'\\');
    if(pwcLastSlash == NULL)
        return ERROR_BAD_PATHNAME;

    *pwcLastSlash = 0;

    //
    // Try to create it
    //

    if(!CreateDirectoryW(wszPath, pSA))
    {
        //
        // Call ourselves recursively --- to create our parents
        //

        lRes = EnsureDirectoryRecursiveForFile(wszPath, pSA);
        if(lRes != ERROR_SUCCESS)
        {
            *pwcLastSlash = L'\\';
            return lRes;
        }

        //
        // Try again
        //

        BOOL bRes = CreateDirectoryW(wszPath, pSA);
        *pwcLastSlash = L'\\';
        if(bRes)
            return ERROR_SUCCESS;
        else
            return GetLastError();
    }
    else
    {
        *pwcLastSlash = L'\\';
        return ERROR_SUCCESS;
    }
}
        
inline WCHAR HexDigit(BYTE b)
{
    if(b < 10)
        return L'0' + b;
    else
        return L'A' + b - 10;
}
        
bool A51Hash(LPCWSTR wszName, LPWSTR wszHash)
{
	//
	// Have to upper-case everything
	//

    DWORD dwBufferSize = wcslen(wszName)*2+2;
    LPWSTR wszBuffer = (WCHAR*)TempAlloc(dwBufferSize);
	if (wszBuffer == NULL)
		return false;
    CTempFreeMe vdm(wszBuffer, dwBufferSize);

    wbem_wcsupr(wszBuffer, wszName);

    BYTE RawHash[16];
    MD5::Transform((void*)wszBuffer, wcslen(wszBuffer)*2, RawHash);

    WCHAR* pwc = wszHash;
    for(int i = 0; i < 16; i++)
    {
        *(pwc++) = HexDigit(RawHash[i]/16);        
        *(pwc++) = HexDigit(RawHash[i]%16);        
    }
	*pwc = 0;
    return true;
}

long A51WriteFile(LPCWSTR wszFullPath, DWORD dwLen, BYTE* pBuffer)
{
    long lRes;

    A51TRACE(( "Create file %S\n", wszFullPath));

    //
    // Create the right file
    //

    HANDLE hFile = CreateFileW(wszFullPath, GENERIC_WRITE, 0,
                    NULL, CREATE_ALWAYS, A51_FILE_CREATION_FLAGS, NULL);
    
    if(hFile == INVALID_HANDLE_VALUE)
    {
        lRes = GetLastError();
        if(lRes == ERROR_PATH_NOT_FOUND)
        {
            lRes = EnsureDirectoryForFile(wszFullPath, NULL);
            if(lRes != ERROR_SUCCESS)
                return lRes;

            hFile = CreateFileW(wszFullPath, GENERIC_WRITE, 0,
                            NULL, CREATE_ALWAYS, A51_FILE_CREATION_FLAGS, NULL);
    
            if(hFile == INVALID_HANDLE_VALUE)
            {
                lRes = GetLastError();
                _ASSERT(lRes != ERROR_SUCCESS, L"success error code from fail");
                return lRes;
            }
        }
        else
            return lRes;
    }
        
    CCloseMe cm(hFile);

    //
    // Write it and close
    //

    if(!WriteFile(hFile, pBuffer, dwLen, &dwLen, NULL))
    {
        lRes = GetLastError();
        _ASSERT(lRes != ERROR_SUCCESS, L"success error code from fail");
        return lRes;
    }

    return ERROR_SUCCESS;
}

long A51DeleteFile(LPCWSTR wszFullPath)
{
    A51TRACE(("Delete file %S\n", wszFullPath));

    //
    // Delete the right file
    //

    if(!DeleteFileW(wszFullPath))
        return GetLastError();
    return ERROR_SUCCESS;
}

long A51WriteToFileAsync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen, OVERLAPPED* pov)
{
    pov->Offset = lStartingOffset;
    pov->OffsetHigh = 0;
    pov->hEvent = A51GetNewEvent();

    BOOL bRes;
    DWORD dwWritten;
    while(!(bRes = WriteFile(hFile, pBuffer, dwBufferLen, &dwWritten, pov)) &&
            (GetLastError() == ERROR_INVALID_USER_BUFFER ||
             GetLastError() == ERROR_NOT_ENOUGH_MEMORY))
    {
        //
        // Out of buffer-space --- wait a bit and retry
        //

        g_nWriteFailures++;
        Sleep(16);
    }

    if(!bRes)
    {
        long lRes = GetLastError();
        if(lRes == ERROR_IO_PENDING)
            // perfect!
            return ERROR_SUCCESS;
        else
        {
            A51ReturnEvent(pov->hEvent);
            pov->hEvent = NULL;
            return lRes;
        }
    }
    else
    {
        //
        // Succeeded synchronously --- clean up and return
        //

        A51ReturnEvent(pov->hEvent);
        pov->hEvent = NULL;

        if(dwWritten != dwBufferLen)
            return ERROR_OUTOFMEMORY;
        else
            return ERROR_SUCCESS;
    }
}

long A51WriteToFileSync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen)
{
    OVERLAPPED ov;
    
    long lRes = A51WriteToFileAsync(hFile, lStartingOffset, pBuffer, 
                                    dwBufferLen, &ov);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    if(ov.hEvent)
    {
        CReturnMe rm(ov.hEvent);
    
        //
        // Wait for completion
        //
    
        DWORD dwWritten;
        if(!GetOverlappedResult(hFile, &ov, &dwWritten, TRUE))
            return GetLastError();
    
        if(dwWritten != dwBufferLen)
            return ERROR_OUTOFMEMORY;
    }

    return ERROR_SUCCESS;
}
    
long A51ReadFromFileAsync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen, OVERLAPPED* pov)
{
    long lRes;

    pov->Offset = lStartingOffset;
    pov->OffsetHigh = 0;
    pov->hEvent = A51GetNewEvent();

    BOOL bRes;
    DWORD dwRead;
    while(!(bRes = ReadFile(hFile, pBuffer, dwBufferLen, &dwRead, pov)) &&
            (GetLastError() == ERROR_INVALID_USER_BUFFER ||
             GetLastError() == ERROR_NOT_ENOUGH_MEMORY))
    {
        //
        // Out of buffer-space --- wait a bit and retry
        //

        g_nReadFailures++;
        Sleep(16);
    }

    if(!bRes)
    {
        if(GetLastError() == ERROR_IO_PENDING)
            // perfect!
            return ERROR_SUCCESS;
        else
        {
            lRes = GetLastError();
            _ASSERT(lRes != ERROR_SUCCESS, L"Success returned on failure");
            _ASSERT(lRes == ERROR_FILE_NOT_FOUND || 
                        lRes == ERROR_PATH_NOT_FOUND, 
                L"Invalid error code from ReadFile");
            A51ReturnEvent(pov->hEvent);
            pov->hEvent = NULL;
            return lRes;
        }
    }
    else
    {
        //
        // Succeeded synchronously --- clean up and return
        //

        A51ReturnEvent(pov->hEvent);
        pov->hEvent = NULL;

        if(dwRead != dwBufferLen)
        {
            _ASSERT(false, L"out of memory");
            return ERROR_OUTOFMEMORY;
        }
        else
            return ERROR_SUCCESS;
    }
}

long A51ReadFromFileSync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen)
{
    OVERLAPPED ov;
    
    long lRes = A51ReadFromFileAsync(hFile, lStartingOffset, pBuffer, 
                                    dwBufferLen, &ov);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    if(ov.hEvent)
    {
        CReturnMe rm(ov.hEvent);
    
        //
        // Wait for completion
        //
    
        DWORD dwRead = 0;
        if(!GetOverlappedResult(hFile, &ov, &dwRead, TRUE))
        {
            lRes = GetLastError();
            _ASSERT(lRes != ERROR_SUCCESS, L"Success returned on failure");
            _ASSERT(lRes == ERROR_FILE_NOT_FOUND || 
                        lRes == ERROR_PATH_NOT_FOUND, 
                L"Invalid error code from ReadFile");
            return lRes;
        }
    
        if(dwRead != dwBufferLen)
        {
            _ASSERT(false, L"Out of memory");
            return ERROR_OUTOFMEMORY;
        }
    }

    return ERROR_SUCCESS;
}
    
    

long RemoveDirectoryRecursive(LPCWSTR wszDirectoryPath);
long A51RemoveDirectory(LPCWSTR wszFullPath)
{
    long lRes = RemoveDirectoryRecursive(wszFullPath);
    if(lRes == ERROR_PATH_NOT_FOUND || lRes == ERROR_FILE_NOT_FOUND)
        return ERROR_FILE_NOT_FOUND;
    else
        return lRes;
}

long RemoveDirectoryRecursive(LPCWSTR wszDirectoryPath)
{
    long lRes;

    //
    // Try removing it right away
    //

    if(!RemoveDirectoryW(wszDirectoryPath))
    {
        long lRes = GetLastError();
        if(lRes == ERROR_PATH_NOT_FOUND || lRes == ERROR_FILE_NOT_FOUND)
            return ERROR_FILE_NOT_FOUND;
        else if(lRes != ERROR_DIR_NOT_EMPTY && lRes != ERROR_SHARING_VIOLATION)
            return lRes;
    }
    else 
        return ERROR_SUCCESS;

    //
    // Not empty (or at least we are not sure it is empty) --- enumerate 
    // everything
    //

    CFileName wszMap;
	if (wszMap == NULL)
		return ERROR_OUTOFMEMORY;
    wcscpy(wszMap, wszDirectoryPath);
    wcscat(wszMap, L"\\*");

    CFileName wszChild;
	if (wszChild == NULL)
		return ERROR_OUTOFMEMORY;
    wcscpy(wszChild, wszDirectoryPath);
    wcscat(wszChild, L"\\");
    long lChildLen = wcslen(wszChild);

    WIN32_FIND_DATAW fd;
    HANDLE hSearch = FindFirstFileW(wszMap, &fd);
    if(hSearch == INVALID_HANDLE_VALUE)
        return ERROR_DIR_NOT_EMPTY;

    do
    {
        if(fd.cFileName[0] == L'.')
            continue;

        if((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
        {
            // There is a file --- give up
            FindClose(hSearch);
            return ERROR_DIR_NOT_EMPTY;
        }

        wcscpy(wszChild + lChildLen, fd.cFileName);
        lRes = RemoveDirectoryRecursive(wszChild);
        if(lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND)
        {
            FindClose(hSearch);
            return lRes;
        }
    }
    while(FindNextFileW(hSearch, &fd));

    FindClose(hSearch);
            
    //
    // And try again
    //

    if(!RemoveDirectoryW(wszDirectoryPath))
    {
        long lRes = GetLastError();
        if(lRes == ERROR_PATH_NOT_FOUND || lRes == ERROR_FILE_NOT_FOUND)
            return ERROR_FILE_NOT_FOUND;
        else if(lRes == ERROR_SHARING_VIOLATION)
            return ERROR_SUCCESS;
        else 
            return lRes;
    }

    return ERROR_SUCCESS;
}
    
CRITICAL_SECTION g_csLog;
char* g_szText = NULL;
long g_lTextLen = 0;
WCHAR g_wszLogFilename[MAX_PATH] = L"";
void A51Trace(LPCSTR szFormat, ...)
{
    if((g_wszLogFilename[0] == 0) || (g_szText == NULL))
    {
        InitializeCriticalSection(&g_csLog);

		delete g_szText;
		g_wszLogFilename[0] = 0;
		g_szText = NULL;

		HKEY hKey;
		long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
						L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
						0, KEY_READ, &hKey);
		if(lRes)
		{
			wcscpy(g_wszLogFilename, L"c:\\a51.log");
		}
		else
		{
			DWORD dwLen = MAX_PATH;
			CFileName wszTmp;
			if (wszTmp == 0)
			{
				wcscpy(g_wszLogFilename, L"c:\\a51.log");
				RegCloseKey(hKey);
			}
			else
			{
				lRes = RegQueryValueExW(hKey, L"Logging Directory", NULL, NULL, 
							(LPBYTE)(wchar_t*)wszTmp, &dwLen);
				RegCloseKey(hKey);
				if(lRes)
				{
					wcscpy(g_wszLogFilename, L"c:\\a51.log");
				}
				else
				{
					if (ExpandEnvironmentStringsW(wszTmp,g_wszLogFilename,MAX_PATH) == 0)
					{
						wcscpy(g_wszLogFilename, L"c:\\a51.log");
					}
					else
					{
						if (g_wszLogFilename[wcslen(g_wszLogFilename)] == L'\\')
						{
							wcscat(g_wszLogFilename, L"a51.log");
						}
						else
						{
							wcscat(g_wszLogFilename, L"\\a51.log");
						}
					}
				}
			}
		}
        
        g_szText = new char[3000000];
		if (g_szText == NULL)
			return;
    }

    EnterCriticalSection(&g_csLog);
    
    char szBuffer[256];
    va_list argptr;
    va_start(argptr, szFormat);
    vsprintf(szBuffer, szFormat, argptr);
    long lLen = strlen(szBuffer);
    if(g_lTextLen + lLen > 2900000)
        A51TraceFlush();

    strcpy(g_szText + g_lTextLen, szBuffer);
    g_lTextLen += lLen;

    LeaveCriticalSection(&g_csLog);
}

void A51TraceFlush()
{
	FILE* fLog = NULL;
	fLog = _wfopen(g_wszLogFilename, L"a");
    if(fLog)
    {
        fwrite(g_szText, 1, g_lTextLen, fLog);
        g_lTextLen = 0;
//      fflush(fLog);
		fclose(fLog);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a51\stage.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <wbemcomn.h>
#include <sync.h>
#include <malloc.h>
#include "stage.h"
#include "filecach.h"


#define A51_TAIL_SIZE sizeof(DWORD)

#define A51_INSTRUCTION_TYPE_TAIL 0
#define A51_INSTRUCTION_TYPE_CREATEFILE 1
#define A51_INSTRUCTION_TYPE_DELETEFILE 2
#define A51_INSTRUCTION_TYPE_REMOVEDIRECTORY 3
#define A51_INSTRUCTION_TYPE_ENDTRANSACTION 10 

int g_nNumRecords;
int g_nTotalMemory;
int g_nNumRecordsMax = 0;
int g_nTotalMemoryMax = 0;

CTempMemoryManager g_FileCacheManager;

CFileInstruction::CFileInstruction(CRealStagingFile* pFile)
    : m_pFile(pFile), m_lRef(0), m_wszFilePath(NULL), m_lFileOffset(-1),
        m_bCommitted(false)
{
    g_nNumRecords++;
    if(g_nNumRecords > g_nNumRecordsMax)
        g_nNumRecordsMax = g_nNumRecords;
}
    
long CFileInstruction::Initialize(LPCWSTR wszFilePath)
{
    int nFilePathLen = wcslen(wszFilePath);
    m_wszFilePath = (WCHAR*)TempAlloc(g_FileCacheManager, (nFilePathLen+1) * sizeof(WCHAR));
    if(m_wszFilePath == NULL)
        return ERROR_OUTOFMEMORY;
    wcscpy(m_wszFilePath, wszFilePath);

    g_nTotalMemory += (nFilePathLen+1) * sizeof(WCHAR);
    if(g_nTotalMemory > g_nTotalMemoryMax)
        g_nTotalMemoryMax = g_nTotalMemory;
    
    return ERROR_SUCCESS;
}

CFileInstruction::~CFileInstruction()
{
    g_nNumRecords--;
    if (m_wszFilePath)
    {
        int nFilePathLen = wcslen(m_wszFilePath);
        g_nTotalMemory -= (nFilePathLen+1) * sizeof(WCHAR);
        TempFree(g_FileCacheManager, m_wszFilePath, (nFilePathLen+1)*sizeof(WCHAR));
    }
}


DWORD CFileInstruction::ComputeSpaceForName()
{
    return sizeof(DWORD) + wcslen(m_wszFilePath) * sizeof(WCHAR);
}

BYTE* CFileInstruction::WriteFileName(BYTE* pStart)
{
    DWORD dwStringLen = wcslen(m_wszFilePath);
    memcpy(pStart, (void*)&dwStringLen, sizeof(DWORD));
    pStart += sizeof(DWORD);
    memcpy(pStart, m_wszFilePath, dwStringLen * sizeof(WCHAR));

    return pStart + dwStringLen * sizeof(WCHAR);
}

long CFileInstruction::RecoverFileName(HANDLE hFile)
{
    _ASSERT(m_wszFilePath == NULL, 
            L"Double initialization of a file instruction!");
    //
    // Read the length
    //

    DWORD dwStringLen = 0;
    DWORD dwRead;

    if(!ReadFile(hFile, (BYTE*)&dwStringLen, sizeof(DWORD), &dwRead, NULL))
        return GetLastError();

    if(dwRead != sizeof(DWORD))
        return ERROR_HANDLE_EOF;

    //
    // Read the file name
    //

    m_wszFilePath = (WCHAR*)TempAlloc(g_FileCacheManager,
                                        (dwStringLen+1) * sizeof(WCHAR));
    if(m_wszFilePath == NULL)
        return ERROR_OUTOFMEMORY;
    
    if(!ReadFile(hFile, (BYTE*)m_wszFilePath, dwStringLen * sizeof(WCHAR),
                    &dwRead, NULL))
    {
        TempFree(m_wszFilePath, (dwStringLen+1) * sizeof(WCHAR));
        return GetLastError();
    }

    if(dwRead != dwStringLen * sizeof(WCHAR))
    {
        TempFree(m_wszFilePath, (dwStringLen+1) * sizeof(WCHAR));
        return ERROR_HANDLE_EOF;
    }

    m_wszFilePath[dwStringLen] = 0;

    g_nTotalMemory += (wcslen(m_wszFilePath)+1) * sizeof(WCHAR);
    if(g_nTotalMemory > g_nTotalMemoryMax)
        g_nTotalMemoryMax = g_nTotalMemory;

    return ERROR_SUCCESS;
}
        
    

void CFileInstruction::ComputeFullPath(wchar_t *wszFullPath)
{
    wcscpy(wszFullPath, m_pFile->GetBase());
    wcscat(wszFullPath, m_wszFilePath);
}



CCreateFile::CCreateFile(CRealStagingFile* pFile)
    : CFileInstruction(pFile), m_dwFileLen(0), m_dwFileStart(0)
{
}

void* CCreateFile::operator new(size_t) 
{
    return TempAlloc(g_FileCacheManager, sizeof(CCreateFile));
}

void CCreateFile::operator delete(void* p) 
{
    return TempFree(g_FileCacheManager, p, sizeof(CCreateFile));
}

long CCreateFile::Initialize(LPCWSTR wszFilePath, DWORD dwFileLen)
{
    long lRes = CFileInstruction::Initialize(wszFilePath);
    if(lRes != ERROR_SUCCESS)
        return lRes;
    m_dwFileLen = dwFileLen;
    return ERROR_SUCCESS;
}

DWORD CCreateFile::ComputeNeededSpace()
{
    return sizeof(BYTE) + // for the type
                ComputeSpaceForName() + // for the file name
                sizeof(DWORD) + // for the length of data
                m_dwFileLen + // for the data
                A51_TAIL_SIZE; // for the trailer
}
                    
long CCreateFile::Write(TFileOffset lOffset, BYTE* pBuffer)
{
    if(pBuffer)
        memcpy(&m_dwFileStart, pBuffer, sizeof(DWORD));
    else
        m_dwFileStart = 0;

    //
    // Construct an in-memory buffer large enough for the whole thing
    //

    DWORD dwNeededSpace = ComputeNeededSpace();
    BYTE* pWholeBuffer = (BYTE*)TempAlloc(dwNeededSpace);
    if(pWholeBuffer == NULL)
        return ERROR_OUTOFMEMORY;
    CTempFreeMe vdm(pWholeBuffer, dwNeededSpace);

    BYTE* pCurrent = pWholeBuffer;

    //
    // Write instruction type
    //

    *pCurrent = A51_INSTRUCTION_TYPE_CREATEFILE;
    pCurrent++;

    // 
    // Write the name of the file
    //

    pCurrent = WriteFileName(pCurrent);
    
    //
    // Write the length of the data for the file
    //

    memcpy(pCurrent, (void*)&m_dwFileLen, sizeof(DWORD));
    pCurrent += sizeof(DWORD);

    //
    // Write the data itself and record its offset
    //

    memcpy(pCurrent, pBuffer, m_dwFileLen);
    m_lFileOffset = lOffset + (pCurrent - pWholeBuffer);

    //
    // Write the trailer
    //

    memset(pCurrent + m_dwFileLen, 0, sizeof(DWORD));
    
    // 
    // Write it 
    //

    return m_pFile->WriteInstruction(lOffset, pWholeBuffer, dwNeededSpace);
}

long CCreateFile::RecoverData(HANDLE hFile)
{
    //
    // Recover the file name first
    //

    long lRes = CFileInstruction::RecoverFileName(hFile);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Read the length of the data from the file
    //

    DWORD dwRead;

    if(!ReadFile(hFile, (BYTE*)&m_dwFileLen, sizeof(DWORD), &dwRead, NULL))
        return GetLastError();

    if(dwRead != sizeof(DWORD))
        return ERROR_HANDLE_EOF;

    //
    // We do not need to actually read the data from the file --- we keep it
    // there until it is time to flush.  But we do need to skip it.  At the same
    // time, we need to record the position in the file where this data resides
    //

    LARGE_INTEGER liFileLen;
    liFileLen.QuadPart = m_dwFileLen;
    
    LARGE_INTEGER liNewPosition;
    if(!SetFilePointerEx(hFile, liFileLen, &liNewPosition, FILE_CURRENT))
        return GetLastError();

    _ASSERT(liNewPosition.HighPart == 0, L"Staging file too long!");

    m_lFileOffset = (long)(liNewPosition.QuadPart - m_dwFileLen);
    return ERROR_SUCCESS;
}

long CCreateFile::GetData(HANDLE hFile, DWORD* pdwLen, BYTE** ppBuffer)
{
	//
	// Lock the file
	//

	CInCritSec ics(m_pFile->GetLock());

	_ASSERT(m_pFile->m_lFirstFreeOffset >= m_lFileOffset, 
            L"Instruction points to empty space in stage file");

    if(pdwLen)
        *pdwLen = m_dwFileLen;

    if(ppBuffer == NULL)
        return ERROR_SUCCESS;

    //
    // Allocate the buffer
    //

    *ppBuffer = (BYTE*)TempAlloc(m_dwFileLen);
    if(*ppBuffer == NULL)
        return ERROR_OUTOFMEMORY;

    long lRes = A51ReadFromFileSync(hFile, m_lFileOffset, *ppBuffer, m_dwFileLen);
    if(lRes != ERROR_SUCCESS)
    {
        delete *ppBuffer;
        return lRes;
    }

    if(m_dwFileLen && m_dwFileStart && memcmp(*ppBuffer, &m_dwFileStart, sizeof(DWORD)))
    {
        _ASSERT(false, L"Stage file overwritten");
        TempFree(*ppBuffer, m_dwFileLen);
        return ERROR_OUTOFMEMORY;
    }

    return ERROR_SUCCESS;
}

    
long CCreateFile::Execute()
{
    //
    // Construct full path
    //

    CFileName wszFullPath;
	if (wszFullPath == NULL)
		return ERROR_OUTOFMEMORY;
    ComputeFullPath(wszFullPath);

    long lRes;

    //
    // Read the data from the staging file
    //

    BYTE* pBuffer = NULL;
    lRes = GetData(m_pFile->GetHandle(), NULL, &pBuffer);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    CTempFreeMe vdm(pBuffer, m_dwFileLen);
    
    return A51WriteFile(wszFullPath, m_dwFileLen, pBuffer);
}


CDeleteFile::CDeleteFile(CRealStagingFile* pFile)
    : CFileInstruction(pFile)
{
}

void* CDeleteFile::operator new(size_t) 
{
    return TempAlloc(g_FileCacheManager, sizeof(CDeleteFile));
}

void CDeleteFile::operator delete(void* p) 
{
    return TempFree(g_FileCacheManager, p, sizeof(CDeleteFile));
}

long CDeleteFile::Initialize(LPCWSTR wszFileName)
{
    return CFileInstruction::Initialize(wszFileName);
}

DWORD CDeleteFile::ComputeNeededSpace()
{
    return sizeof(BYTE) + // for instruction type
            ComputeSpaceForName() + // for the file name
            A51_TAIL_SIZE; // for the trailer
}

long CDeleteFile::Write(TFileOffset lOffset)
{
    //
    // Construct an in-memory buffer large enough for the whole thing
    //

    DWORD dwNeededSpace = ComputeNeededSpace();
    BYTE* pWholeBuffer = (BYTE*)TempAlloc(dwNeededSpace);
    if(pWholeBuffer == NULL)
        return ERROR_OUTOFMEMORY;
    CTempFreeMe vdm(pWholeBuffer, dwNeededSpace);

    BYTE* pCurrent = pWholeBuffer;

    //
    // Write the instruction type
    //
    
    *pCurrent = A51_INSTRUCTION_TYPE_DELETEFILE;
    pCurrent++;
    
    //
    // Write the file name
    //

    pCurrent = WriteFileName(pCurrent);
    m_lFileOffset = lOffset + (pCurrent - pWholeBuffer);

    //
    // Write the trailer
    //

    memset(pCurrent, 0, sizeof(DWORD));

    // 
    // Write it 
    //

    return m_pFile->WriteInstruction(lOffset, pWholeBuffer, dwNeededSpace);
}

long CDeleteFile::RecoverData(HANDLE hFile)
{
    //
    // Recover the file name 
    //

    long lRes = CFileInstruction::RecoverFileName(hFile);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    LARGE_INTEGER liZero;
    liZero.QuadPart = 0;
    LARGE_INTEGER liPosition;
    if(!SetFilePointerEx(hFile, liZero, &liPosition, FILE_CURRENT))
        return GetLastError();

    _ASSERT(liPosition.HighPart == 0, L"Staging file too long!");

    m_lFileOffset = (long)(liPosition.QuadPart);
    return ERROR_SUCCESS;
}
    
long CDeleteFile::Execute()
{
    //
    // Construct full path
    //

    CFileName wszFullPath;
	if (wszFullPath == NULL)
		return ERROR_OUTOFMEMORY;
    ComputeFullPath(wszFullPath);

    //
    // Delete the right file
    //

    if(!DeleteFileW(wszFullPath))
    {
        long lRes = GetLastError();
        if(lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_PATH_NOT_FOUND)
            return lRes;
        else
            return ERROR_SUCCESS;
    }

    return ERROR_SUCCESS;
}


CRemoveDirectory::CRemoveDirectory(CRealStagingFile* pFile)
    : CFileInstruction(pFile)
{
}

void* CRemoveDirectory::operator new(size_t) 
{
    return TempAlloc(g_FileCacheManager, sizeof(CRemoveDirectory));
}

void CRemoveDirectory::operator delete(void* p) 
{
    return TempFree(g_FileCacheManager, p, sizeof(CRemoveDirectory));
}

long CRemoveDirectory::Initialize(LPCWSTR wszFileName)
{
    return CFileInstruction::Initialize(wszFileName);
}

DWORD CRemoveDirectory::ComputeNeededSpace()
{
    return sizeof(BYTE) + // for the instruction type
            ComputeSpaceForName() + // for the file name
            A51_TAIL_SIZE; // for the trailer
}

long CRemoveDirectory::Write(TFileOffset lOffset)
{
    //
    // Construct an in-memory buffer large enough for the whole thing
    //

    DWORD dwNeededSpace = ComputeNeededSpace();
    BYTE* pWholeBuffer = (BYTE*)TempAlloc(dwNeededSpace);
    if(pWholeBuffer == NULL)
        return ERROR_OUTOFMEMORY;
    CTempFreeMe vdm(pWholeBuffer, dwNeededSpace);

    BYTE* pCurrent = pWholeBuffer;

    //
    // Write instruction type
    //

    *pCurrent = A51_INSTRUCTION_TYPE_REMOVEDIRECTORY;
    pCurrent++;

    //
    // Write the file name
    //

    pCurrent = WriteFileName(pCurrent);
    m_lFileOffset = lOffset + (pCurrent - pWholeBuffer);

    //
    // Write the trailer
    //

    memset(pCurrent, 0, sizeof(DWORD));

    // 
    // Write it 
    //

    return m_pFile->WriteInstruction(lOffset, pWholeBuffer, dwNeededSpace);
}

long CRemoveDirectory::RecoverData(HANDLE hFile)
{
    //
    // Recover the file name 
    //

    long lRes = CFileInstruction::RecoverFileName(hFile);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    LARGE_INTEGER liZero;
    liZero.QuadPart = 0;
    LARGE_INTEGER liPosition;
    if(!SetFilePointerEx(hFile, liZero, &liPosition, FILE_CURRENT))
        return GetLastError();

    _ASSERT(liPosition.HighPart == 0, L"Staging file too long!");

    m_lFileOffset = (long)(liPosition.QuadPart);
    return ERROR_SUCCESS;
}
    
long CRemoveDirectory::Execute()
{
    //
    // Construct full path
    //

    CFileName wszFullPath;
	if (wszFullPath == NULL)
		return ERROR_OUTOFMEMORY;
    ComputeFullPath(wszFullPath);

    //
    // Remove the directory
    //

    long lRes = A51RemoveDirectory(wszFullPath);
    if(lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_PATH_NOT_FOUND &&
        lRes != ERROR_DIR_NOT_EMPTY)
    {
        return lRes;
    }
    else
    {
        return ERROR_SUCCESS;
    }
}



CRealStagingFile::CRealStagingFile(CFileCache* pCache,
                                                LPCWSTR wszBaseName,
                                                long lMaxFileSize,
                                                long lAbortTransactionFileSize)
    : m_hFile(NULL), m_lFirstFreeOffset(-1), m_nTransactionIndex(0),
        m_bInTransaction(false), 
        m_map(TMap::key_compare(), TMap::allocator_type(&g_FileCacheManager)),
        m_qTransaction(TQueue::allocator_type(&g_FileCacheManager)),
        m_qToWrite(TQueue::allocator_type(&g_FileCacheManager)),
        m_stReplacedInstructions(TStack::allocator_type(&g_FileCacheManager)),
        m_lMaxFileSize(lMaxFileSize),
        m_lAbortTransactionFileSize(lAbortTransactionFileSize),
        m_bFailedBefore(false), m_lStatus(ERROR_SUCCESS),
        m_pCache(pCache)
{
    wcscpy(m_wszBaseName, wszBaseName);
}

CRealStagingFile::~CRealStagingFile()
{
    CloseHandle(m_hFile);
}

void CRealStagingFile::ComputeKey(LPCWSTR wszFileName, LPWSTR wszKey)
{
    wbem_wcsupr(wszKey, wszFileName);
}

long CRealStagingFile::WriteInstruction(long lStartingOffset, 
                            BYTE* pBuffer, DWORD dwBufferLen)
{
    long lRes = A51WriteToFileSync(m_hFile, lStartingOffset, pBuffer,
                                dwBufferLen);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Add the data to the currently running transaction hash.  Disregard the
    // trailer since it is going to be overwritten
    //

    MD5::ContinueTransform(pBuffer, dwBufferLen - A51_TAIL_SIZE, 
                            m_TransactionHash);

    return ERROR_SUCCESS;
}
    
long CRealStagingFile::BeginTransaction()
{    
    //
    // Wait for space in the staging file
    //

    long lRes = WaitForSpaceForTransaction();
    if(lRes != ERROR_SUCCESS)
        return lRes;

    return ProcessBegin();
}

long CRealStagingFile::ProcessBegin()
{
    CInCritSec ics(&m_cs);

    //
    // Reset the digest
    //

    MD5::Transform(&m_nTransactionIndex, sizeof m_nTransactionIndex,
                    m_TransactionHash);

    m_bInTransaction = true;


    return ERROR_SUCCESS;
}

long CRealStagingFile::CommitTransaction()
{
    CInCritSec ics(&m_cs);

    m_bInTransaction = false;

    //
    // Check if there is even anything to commit
    //

    if(m_qTransaction.empty())
        return ERROR_SUCCESS;

    //
    // Write transaction trailer "instruction"
    //

    DWORD dwBufferSize = sizeof(BYTE) + // instruction type
                        sizeof m_TransactionHash // transaction hash
                        + A51_TAIL_SIZE; // trailer
    BYTE* pBuffer = (BYTE*)TempAlloc(dwBufferSize);
    if(pBuffer == NULL)
        return ERROR_OUTOFMEMORY;
    CTempFreeMe tfm(pBuffer, dwBufferSize);

    memset(pBuffer, 0, dwBufferSize);
    *(DWORD*)pBuffer = A51_INSTRUCTION_TYPE_ENDTRANSACTION;
    memcpy(pBuffer + sizeof(BYTE), m_TransactionHash, 
            sizeof m_TransactionHash);

    //
    // Write it out
    //

    long lRes = A51WriteToFileSync(m_hFile, m_lFirstFreeOffset, pBuffer, 
                                dwBufferSize);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    m_lFirstFreeOffset += dwBufferSize - A51_TAIL_SIZE;

    return ProcessCommit();
}

long CRealStagingFile::ProcessCommit()
{
    //
    // Now, transfer all instructions from the transaction queue to the main
    // queue for flushing.  Wake up the flushing thread if the main queue is 
    // empty
    //

    if(m_qToWrite.empty() && !m_qTransaction.empty())
        SignalPresense();

    while(!m_qTransaction.empty())
    {
        CFileInstruction* pInst = m_qTransaction.front();
        pInst->SetCommitted();
        m_qToWrite.push(pInst);
        m_qTransaction.pop();
    }

    //
    // Erase the stack of replaced instructions --- they are replaced for good
    //

    while(!m_stReplacedInstructions.empty())
    {
        m_stReplacedInstructions.top()->Release();
        m_stReplacedInstructions.pop();
    }

    //
    // Move transaction start pointer to the next free location
    //

    m_lTransactionStartOffset = m_lFirstFreeOffset;
    m_nTransactionIndex++;

    //
    // Reset the digest
    //

    MD5::Transform(&m_nTransactionIndex, sizeof m_nTransactionIndex,
                    m_TransactionHash);

    return ERROR_SUCCESS;
}

long CRealStagingFile::AbortTransaction()
{
    CInCritSec ics(&m_cs);

    m_bInTransaction = false;

    //
    // Check if there is even anything to abort
    //

    if(m_qTransaction.empty())
        return ERROR_SUCCESS;

    ERRORTRACE((LOG_WBEMCORE, "Repository driver aborting transaction!\n"));

    //
    // Reset the first free pointer to the beginning of the transaction
    //

    m_lFirstFreeOffset = m_lTransactionStartOffset;

    //
    // Write termination marker there to simplify recovery.  It might not
    // be flushed, so recovery process does not rely on it, but still.
    //

    BYTE nType = A51_INSTRUCTION_TYPE_TAIL;
    long lRes = A51WriteToFileSync(m_hFile, m_lFirstFreeOffset, &nType, 
                                    sizeof nType);
    // ignore return

    //
    // Discard all instructions in the transaction queue
    //

    while(!m_qTransaction.empty())
    {
        CFileInstruction* pInst = m_qTransaction.front();
        TIterator it = m_map.find(pInst->GetFilePath());
        if(it != m_map.end() && it->second == pInst)
        {
            // 
            // This instruction is currently in the map. Remove it, since
            // it has been cancelled. Of course, it may have replaced something
            // else originally, but that will be fixed shortly when we put back
            // all the replaced instructions
            //

            it->second->Release();
            EraseIterator(it);
        }

        m_qTransaction.front()->Release();
        m_qTransaction.pop();
    }

    //
    // Move all the records we have displaced from the map back into the map
    //

    while(!m_stReplacedInstructions.empty())
    {
        CFileInstruction* pInst = m_stReplacedInstructions.top();
        TIterator it = m_map.find(pInst->GetFilePath());
        if(it != m_map.end())
        {
            //
            // Note: we cannot just replace the pointer, since we are using its
            // member as the key!
            //
    
            it->second->Release();
            EraseIterator(it);
        }
    
        m_map[pInst->GetFilePath()] = pInst;
    
        /* Do not postpend the instruction on the queue, since we would not
            skip it for a non-committed instruction
        //
        // We need to also postpend it onto the flushing queue, since it may
        // have been skipped by the flusher.  Event if it was not, postpending
        // it is no big deal --- we know that nobody had overwritten it in the
        // interleaving time because it was in the map (and therefore current)
        // when we started the transaction
        //

        m_qToWrite.push(pInst);
        pInst->AddRef();
        */

        m_stReplacedInstructions.pop();
    }

    //
    // Reset the digest
    //

    MD5::Transform(&m_nTransactionIndex, sizeof m_nTransactionIndex,
                    m_TransactionHash);

    //
    // Check if the flushing thread caught up with us, but could not reset the
    // staging file because we had some things on the queue.
    //

    if(m_qToWrite.empty() && m_lFirstFreeOffset != sizeof(__int64))
    {
        ERRORTRACE((LOG_WBEMCORE, "Resetting first free offset in abort"));
        WriteEmpty();
    }

    return ERROR_SUCCESS;
}
    

long CRealStagingFile::WriteFile(LPCWSTR wszFileName, DWORD dwLen, 
                                        BYTE* pBuffer)
{
    long lRes;
    CFileName wszKey;
    if (wszKey == NULL)
	return ERROR_OUTOFMEMORY;
    ComputeKey(wszFileName, wszKey);

    CCreateFile* pInst = new CCreateFile(this);
    if(pInst == NULL)
        return ERROR_OUTOFMEMORY;
    pInst->AddRef();
    CTemplateReleaseMe<CFileInstruction> rm1(pInst);

    lRes = pInst->Initialize(wszKey, dwLen);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    DWORD dwSpaceNeeded = pInst->ComputeNeededSpace();

    if(!CanWriteInTransaction(dwSpaceNeeded))
        return ERROR_NOT_ENOUGH_QUOTA;

    {
        CInCritSec ics(&m_cs);

        //
        // Write all the data into the staging area
        //
    
        lRes = pInst->Write(m_lFirstFreeOffset, pBuffer);
        if(lRes)
            return lRes;
    
        m_lFirstFreeOffset += dwSpaceNeeded - A51_TAIL_SIZE;
    
        lRes = AddInstruction(pInst);
    }
    return lRes;
}

long CRealStagingFile::DeleteFile(LPCWSTR wszFileName)
{
    long lRes;
    CFileName wszKey;
    if (wszKey == NULL)
        return ERROR_OUTOFMEMORY;
    ComputeKey(wszFileName, wszKey);

    CDeleteFile* pInst = new CDeleteFile(this);
    if(pInst == NULL)
        return ERROR_OUTOFMEMORY;
    pInst->AddRef();
    CTemplateReleaseMe<CFileInstruction> rm1(pInst);

    lRes = pInst->Initialize(wszKey);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    DWORD dwSpaceNeeded = pInst->ComputeNeededSpace();

    if(!CanWriteInTransaction(dwSpaceNeeded))
        return ERROR_NOT_ENOUGH_QUOTA;

    {
        CInCritSec ics(&m_cs);

        //
        // Write all the data into the staging area
        //
    
        lRes = pInst->Write(m_lFirstFreeOffset);
        if(lRes)
            return lRes;
    
        //
        // Write the new offset into the offset file
        //
    
        m_lFirstFreeOffset += dwSpaceNeeded - A51_TAIL_SIZE;
    
        lRes = AddInstruction(pInst);
    }
    return lRes;
}

long CRealStagingFile::RemoveDirectory(LPCWSTR wszFileName)
{
    long lRes;
    CFileName wszKey;
    if (wszKey == NULL)
        return ERROR_OUTOFMEMORY;

    ComputeKey(wszFileName, wszKey);

    CRemoveDirectory* pInst = new CRemoveDirectory(this);
    if(pInst == NULL)
        return ERROR_OUTOFMEMORY;
    pInst->AddRef();
    CTemplateReleaseMe<CFileInstruction> rm1(pInst);

    lRes = pInst->Initialize(wszKey);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    DWORD dwSpaceNeeded = pInst->ComputeNeededSpace();

    if(!CanWriteInTransaction(dwSpaceNeeded))
        return ERROR_NOT_ENOUGH_QUOTA;

    {
        CInCritSec ics(&m_cs);

        //
        // Write all the data into the staging area
        //
    
        lRes = pInst->Write(m_lFirstFreeOffset);
        if(lRes)
        {
            m_cs.Leave();
            return lRes;
        }
    
        //
        // Write the new offset into the offset file
        //
    
        m_lFirstFreeOffset += dwSpaceNeeded - A51_TAIL_SIZE;
    
        lRes = AddInstruction(pInst);
    }

    return lRes;
}


// assumes: locked
long CRealStagingFile::AddInstruction(CFileInstruction* pInst)
{
    //
    // Add the instruction to the transaction queue.  It will be moved into 
    // flushable queue when transaction commits
    //

    pInst->AddRef();
    m_qTransaction.push(pInst);

    //
    // Now, add the structure to the map for lookup
    //

    pInst->AddRef();

    TIterator it = m_map.find(pInst->GetFilePath());
    if(it != m_map.end())
	{
        //
        // It is already there.  We need to replace that instruction with our
        // own.  However, if that instruction was committed, we should remember
        // it in case our transaction aborts.
		// Note: we cannot just replace the pointer, since we are using its
		// member as the key!
        //
        // The extra quirk here is that we should not be doing this if the 
        // instruction being replaced came from our own transaction.  This is
        // not an empty optimization --- if we do and the transaction aborts,
        // we may end up attempting to execute this one even though its body
        // is in the garbaged area of the staging file
        //

        if(it->second->IsCommitted())
        {
            m_stReplacedInstructions.push(it->second); // transferred ref-count
        }
        else
        {
            it->second->Release();
        }
        EraseIterator(it);
	}

    m_map[pInst->GetFilePath()] = pInst;

    //
    // Now, if we are not transacted, commit!
    //

    if(!m_bInTransaction)
    {
        long lRes = CommitTransaction();
        if(lRes != ERROR_SUCCESS)
            return lRes;
    }

    return ERROR_SUCCESS;
}

long CRealStagingFile::WaitForSpaceForTransaction()
{
    while(1) // TBD: consider timing out
    {
        {
            CInCritSec ics(&m_cs);

            long lRes = CanStartNewTransaction();
            if(lRes == ERROR_SUCCESS)
                return ERROR_SUCCESS;
            else if(lRes != ERROR_IO_PENDING)
                return lRes;
        }
        Sleep(100);
    }

    // Can't happen for now
    return ERROR_INTERNAL_ERROR;
}

long CRealStagingFile::ReadFile(LPCWSTR wszFileName, DWORD* pdwLen, 
                                BYTE** ppBuffer, bool bMustBeThere)
{
    CInCritSec ics(&m_cs);

    // 
    // Search for the file
    //

    CFileName wszKey;
	if (wszKey == NULL)
		return ERROR_OUTOFMEMORY;
    ComputeKey(wszFileName, wszKey);

    TIterator it = m_map.find(wszKey);
    if(it == m_map.end())
    {
        return ERROR_NO_INFORMATION;
    }
    else
    {
        CFileInstruction* pInstruction = it->second;
        if(pInstruction->IsDeletion())
        {
            if(bMustBeThere)
            {
                Dump();
                _ASSERT(false, L"Must-be-present file is not there. Dumped");
            }
            return ERROR_FILE_NOT_FOUND;
        }
        else
        {
            long lRes = ((CCreateFile*)pInstruction)->GetData(m_hFile, pdwLen, 
                                                                ppBuffer);
            return lRes;
        }
    }
}

void CRealStagingFile::Dump()
{
    FILE* f = fopen("c:\\a.dmp", "a");
    fprintf(f, "MAP:\n");
    TIterator it = m_map.begin();
    while(it != m_map.end())
    {
        CFileInstruction* pInstruction = it->second;
        if(pInstruction->IsDeletion())
            fprintf(f, "Delete ");
        else
            fprintf(f, "Create ");

        fprintf(f, "%S\n", pInstruction->GetFilePath());
        it++;
    }

    fprintf(f, "LIST:\n");

    int nSize = m_qToWrite.size();
    for(int i = 0; i < nSize; i++)
    {
        CFileInstruction* pInstruction = m_qToWrite.front();
        if(pInstruction->IsDeletion())
            fprintf(f, "Delete ");
        else
            fprintf(f, "Create ");

        fprintf(f, "%S\n", pInstruction->GetFilePath());

        m_qToWrite.pop();
        m_qToWrite.push(pInstruction);
    }

    fclose(f);
}

long CRealStagingFile::IsDeleted(LPCWSTR wszFilePath)
{
    CInCritSec ics(&m_cs);

    // 
    // Search for the file
    //

    CFileName wszKey;
	if (wszKey == NULL)
		return ERROR_OUTOFMEMORY;
    ComputeKey(wszFilePath, wszKey);

    TIterator it = m_map.find(wszKey);
    if(it == m_map.end())
    {
        return S_FALSE;
    }
    else
    {
        CFileInstruction* pInstruction = it->second;
        if(pInstruction->IsDeletion())
            return S_OK;
        else
            return S_FALSE;
    }
}
    

long CRealStagingFile::FindFirst(LPCWSTR wszFilePrefix, WIN32_FIND_DATAW* pfd,
                            void** ppHandle)
{
    CInCritSec ics(&m_cs);

    //
    // Compute the key for the prefix --- key computation is such that the 
    // keys come in the same lexicographic order as the names, so this will 
    // give us the lower bound for the search
    //

    CFileName wszKey;
	if (wszKey == NULL)
		return ERROR_OUTOFMEMORY;
    ComputeKey(wszFilePrefix, wszKey);

    //
    // Find this spot in the map
    //

    TIterator it = m_map.lower_bound(wszKey);
    if(it == m_map.end())
        return ERROR_FILE_NOT_FOUND;

    //
    // Retrieve the first element
    // 

    CIterationHandle* pHandle = new CIterationHandle(m_map, it, wszKey);
    if(pHandle == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    long lRes = pHandle->GetNext(pfd);
    if(lRes != ERROR_SUCCESS)
    {
        delete pHandle;
        if(lRes == ERROR_NO_MORE_FILES)
            lRes = ERROR_FILE_NOT_FOUND;

        return lRes;
    }

    m_apIterators.Add(pHandle);
    *ppHandle = pHandle;

    return ERROR_SUCCESS;
}

long CRealStagingFile::FindNext(void* pHandle, WIN32_FIND_DATAW* pfd)
{
    CInCritSec ics(&m_cs);

    //
    // The "handle" is really an iteration handle pointer
    //

    CIterationHandle* pIterationHandle = (CIterationHandle*)pHandle;

    //
    // Get the thing pointed to by the iterator, unless it is past the end
    //

    return pIterationHandle->GetNext(pfd);
}

void CRealStagingFile::FindClose(void* pHandle)
{
    CInCritSec ics(&m_cs);

    //
    // The "handle" is really an iteration handle pointer
    //

    CIterationHandle* pIterationHandle = (CIterationHandle*)pHandle;
    for(int i = 0; i < m_apIterators.GetSize(); i++)
    {
        if(m_apIterators[i] == pIterationHandle)
        {
            m_apIterators.RemoveAt(i);
            delete pIterationHandle;
            return;
        }
    }


    _ASSERT(false, L"Non-existent iteration handle is closed");
}

int CRealStagingFile::GetStagingFileHeaderSize()
{
    return sizeof(m_nTransactionIndex);
}

bool CRealStagingFile::IsFullyFlushed()
{
    CInCritSec ics(&m_cs);

    return (m_lFirstFreeOffset == GetStagingFileHeaderSize());
}

bool CRealStagingFile::CanWriteInTransaction(DWORD dwNeeded)
{
    if(m_lFirstFreeOffset + dwNeeded > m_lAbortTransactionFileSize)
        return false;
    else
        return true;
}

long CRealStagingFile::CanStartNewTransaction()
{
    //
    // Check if the staging file is currently in trouble --- failing to execute
    // an instruction.  If so, refuse to start this transaction
    //

    if(m_lStatus != ERROR_SUCCESS)
        return m_lStatus;
    if(m_lFirstFreeOffset < m_lMaxFileSize)
        return ERROR_SUCCESS;
    else
        return ERROR_IO_PENDING;
}

void CRealStagingFile::SetMaxFileSize(long lMaxFileSize,
                                            long lAbortTransactionFileSize)
{
    m_lMaxFileSize = lMaxFileSize;
    m_lAbortTransactionFileSize = lAbortTransactionFileSize;
}


long CRealStagingFile::RecoverStage(HANDLE hFile)
{
    long lRes;
    DWORD dwRead;

    //
    // Read the starting transaction index
    //

    if(!::ReadFile(hFile, &m_nTransactionIndex, 
                    sizeof m_nTransactionIndex, &dwRead, NULL))
    {
        return GetLastError();
    }

    if(dwRead == 0)
    {
        // 
        // Empty file.  Write the trailer and we are done
        //

        m_nTransactionIndex = 1;

        lRes = WriteEmpty();
        if(lRes != ERROR_SUCCESS)
            return lRes;
        return lRes;
    }

    m_lFirstFreeOffset = GetStagingFileHeaderSize();

    //
    // Read complete transactions from the file until the end or until a 
    // corruption is found
    //

    lRes = ProcessBegin();
    if(lRes != ERROR_SUCCESS)
        return lRes;

    while((lRes = RecoverTransaction(hFile)) == ERROR_SUCCESS)
    {
        lRes = ProcessCommit();
        if(lRes != ERROR_SUCCESS)
            return lRes;

        lRes = ProcessBegin();
        if(lRes != ERROR_SUCCESS)
            return lRes;
    }

    if(lRes != ERROR_NO_MORE_ITEMS)
    {
        AbortTransaction();
        ERRORTRACE((LOG_WBEMCORE, "Incomplete or invalid transaction is "
            "found in the journal.  It and all subsequent transactions "
            "will be rolled back\n"));
        return ERROR_SUCCESS;
    }

    return ERROR_SUCCESS;
}
        
BYTE CRealStagingFile::ReadNextInstructionType(HANDLE hFile)
{
    BYTE nType;
    DWORD dwLen;
    if(!::ReadFile(hFile, &nType, sizeof nType, &dwLen, NULL))
        return -1;
    if(dwLen != sizeof nType)
        return -1;
    return nType;
}
    
long CRealStagingFile::RecoverTransaction(HANDLE hFile)
{
    long lRes;

    //
    // Remember the current file position to be able to go back
    //

    LARGE_INTEGER liStart;
    LARGE_INTEGER liZero;
    liZero.QuadPart = 0;
    if(!SetFilePointerEx(hFile, liZero, &liStart, FILE_CURRENT))
        return GetLastError();

    LARGE_INTEGER liInstructionStart = liStart;

    //
    // Read instructions until the end of transaction or an invalid instruction
    //

    int nNumInstructions = 0;

    BYTE nInstructionType;
    while((nInstructionType = ReadNextInstructionType(hFile)) != 
            A51_INSTRUCTION_TYPE_ENDTRANSACTION)
    {
        //
        // Create an instruction of the appropriate type
        //

        CFileInstruction* pInst = NULL;
        switch(nInstructionType)
        {
            case A51_INSTRUCTION_TYPE_CREATEFILE:
                pInst = new CCreateFile(this);
                break;
            case A51_INSTRUCTION_TYPE_DELETEFILE:
                pInst = new CDeleteFile(this);
                break;
            case A51_INSTRUCTION_TYPE_REMOVEDIRECTORY:
                pInst = new CRemoveDirectory(this);
                break;
            default:
                if(nNumInstructions == 0)
                    return ERROR_NO_MORE_ITEMS;
                else
                    return ERROR_RXACT_INVALID_STATE;
        }

        if(pInst == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        pInst->AddRef();
        CTemplateReleaseMe<CFileInstruction> rm1(pInst);
        
        //
        // Get it to read its data from the file
        //

        lRes = pInst->RecoverData(hFile);
        if(lRes != ERROR_SUCCESS)
            return lRes;

        lRes = AddInstruction(pInst);
        if(lRes != ERROR_SUCCESS)
            return lRes;

        //
        // Hash its body into the transaction
        //

        LARGE_INTEGER liInstructionEnd;
        if(!SetFilePointerEx(hFile, liZero, &liInstructionEnd, FILE_CURRENT))
            return GetLastError();

        if(!SetFilePointerEx(hFile, liInstructionStart, NULL, FILE_BEGIN))
            return GetLastError();

        DWORD dwBufferLen = (DWORD)(liInstructionEnd.QuadPart - 
                                            liInstructionStart.QuadPart);
        
        BYTE* pBuffer = (BYTE*)TempAlloc(dwBufferLen);
        if(pBuffer == NULL)
            return ERROR_OUTOFMEMORY;
        CTempFreeMe tfm(pBuffer, dwBufferLen);

        DWORD dwSizeRead;
        if(!::ReadFile(hFile, pBuffer, dwBufferLen, &dwSizeRead, NULL))
            return GetLastError();
    
        if(dwSizeRead != dwBufferLen)
            return ERROR_HANDLE_EOF;

        MD5::ContinueTransform(pBuffer, dwBufferLen, m_TransactionHash);

        liInstructionStart = liInstructionEnd;
        nNumInstructions++;
    }

    //
    // Read the hash that the end-of-transaction marker thinks we should have
    // gotten
    //

    BYTE DesiredHash[16];
    DWORD dwSizeRead;
    if(!::ReadFile(hFile, DesiredHash, sizeof DesiredHash, &dwSizeRead, NULL))
        return GetLastError();

    if(dwSizeRead != sizeof DesiredHash)
        return ERROR_HANDLE_EOF; 
    
    //
    // Compare them
    //

    if(memcmp(DesiredHash, m_TransactionHash, sizeof DesiredHash))
        return ERROR_RXACT_INVALID_STATE;

    //
    // Everything checked out --- set member variables for end of transaction
    //

    m_lFirstFreeOffset = (LONG)liInstructionStart.QuadPart;
    return ERROR_SUCCESS;
}

long CRealStagingFile::Create(LPCWSTR wszFileName)
{
    long lRes;

    //
    // Open the file itself
    //

    m_hFile = CreateFileW(wszFileName, GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 
                FILE_FLAG_OVERLAPPED, 
                NULL);

    if(m_hFile == INVALID_HANDLE_VALUE)
        return GetLastError();

    m_hFlushFile = m_hFile;

    m_lFirstFreeOffset = 0;

    //
    // Open a special synchronous handle to the same file for convenience
    //

    HANDLE hRecoveryFile = CreateFileW(wszFileName, 
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, 
                NULL);

    if(hRecoveryFile == INVALID_HANDLE_VALUE)
        return GetLastError();
    CCloseMe cm(hRecoveryFile);

    lRes = RecoverStage(hRecoveryFile);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    return ERROR_SUCCESS;
}

long CRealStagingFile::WriteEmpty()
{
    //
    // Construct a buffer consisting of the transaction index and a 0 for the
    // end-instruction
    //

    DWORD dwBufferSize = sizeof m_nTransactionIndex + A51_TAIL_SIZE;
    BYTE* pBuffer = (BYTE*)_alloca(dwBufferSize);

    memset(pBuffer, 0, dwBufferSize);
    memcpy(pBuffer, &m_nTransactionIndex, sizeof m_nTransactionIndex);

    long lRes = A51WriteToFileSync(m_hFile, 0, pBuffer, dwBufferSize);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Have to flush it to make sure that old instructions are not replayed
    //

/*
    if(!FlushFileBuffers(m_hFile))
        return GetLastError();
*/

    m_lFirstFreeOffset = GetStagingFileHeaderSize();
    m_lTransactionStartOffset = m_lFirstFreeOffset;

    return ERROR_SUCCESS;
}

CRealStagingFile::TIterator CRealStagingFile::EraseIterator(
                                    CRealStagingFile::TIterator it)
{
    //
    // In order to safely remove an iterator, we need to make sure that
    // no iteration handle is standing on it
    //

    for(int i = 0; i < m_apIterators.GetSize(); i++)
    {
        CIterationHandle* pHandle = m_apIterators[i];
        if(pHandle->m_it == it)
        {
            //
            // Advance it to the next position, since this one is dead
            //

            pHandle->m_it++;
        }
    }

    //
    // It is now safe to remove the element
    //
     
    return m_map.erase(it);
}

CRealStagingFile::CIterationHandle::CIterationHandle(
                    CRealStagingFile::TMap& rMap,
                    const CRealStagingFile::TIterator& rIt,
                    LPCWSTR wszPrefix)
    : m_rMap(rMap), m_it(rIt)
{
    wcscpy(m_wszPrefix, wszPrefix);
    m_dwPrefixLen = wcslen(wszPrefix);

    //
    // Compute the length of the directory portion of the prefix
    //

    WCHAR* pwcLastSlash = wcsrchr(wszPrefix, L'\\');
    if(pwcLastSlash == NULL)
        m_dwPrefixDirLen = 0;
    else
        m_dwPrefixDirLen = pwcLastSlash - wszPrefix + 1;
}

long CRealStagingFile::CIterationHandle::GetNext(WIN32_FIND_DATAW* pfd)
{
    //
    // Repeat while we are not at the end of the list or past the prefix
    //

    while(m_it != m_rMap.end() && 
            !wcsncmp(m_it->first, m_wszPrefix, m_dwPrefixLen))
    {
        CFileInstruction* pInst = m_it->second;
        
        //
        // Ignore deletioin requests
        //

        if(!m_it->second->IsDeletion())
        {
            //
            // Copy the file name (ignoring dir) into the variable
            //

            wcscpy(pfd->cFileName, 
                    m_it->second->GetFilePath() + m_dwPrefixDirLen);
            pfd->dwFileAttributes = 0;
			m_it++;
            return ERROR_SUCCESS;
        }
		m_it++;
    }

    return ERROR_NO_MORE_FILES;
}

//******************************************************************************
//******************************************************************************
//                      EXECUTABLE FILE
//******************************************************************************
//******************************************************************************

CExecutableStagingFile::CExecutableStagingFile(CFileCache* pCache, 
                            LPCWSTR wszBaseName, 
                            long lMaxFileSize, long lAbortTransactionFileSize)
    : CRealStagingFile(pCache, wszBaseName, lMaxFileSize, 
                        lAbortTransactionFileSize),
        m_bExitNow(false), m_hEvent(NULL), m_hThread(NULL)
{
}

CExecutableStagingFile::~CExecutableStagingFile()
{
    m_bExitNow = true;
    SetEvent(m_hEvent);
    WaitForSingleObject(m_hThread, INFINITE);
    CloseHandle(m_hEvent);
    CloseHandle(m_hThread);
}

long CExecutableStagingFile::Create(LPCWSTR wszFileName)
{
    long lRes = CRealStagingFile::Create(wszFileName);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Create a reading thread
    //

    m_hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(m_hEvent == NULL)
        return GetLastError();

    if(!m_qToWrite.empty())
        SignalPresense();

    DWORD dwId;
    m_hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)staticFlusher, 
                                (void*)this, 0, &dwId);
    if(m_hThread == NULL)
        return GetLastError();

    SetThreadPriority(m_hThread, THREAD_PRIORITY_IDLE);

    return ERROR_SUCCESS;
}


void CExecutableStagingFile::SignalPresense()
{
    SetEvent(m_hEvent);
}

long CExecutableStagingFile::WriteEmpty()
{
    ResetEvent(m_hEvent);

    return CRealStagingFile::WriteEmpty();
}

    
DWORD CExecutableStagingFile::staticFlusher(void* pArg)
{
    // Sleep(20000);
    return ((CExecutableStagingFile*)pArg)->Flusher();
}

DWORD CExecutableStagingFile::Flusher()
{
    while(!m_bExitNow)
    {
        WaitForSingleObject(m_hEvent, INFINITE);
        
        Flush();
    }
    return 0;
}

long CExecutableStagingFile::Flush()
{
    long lRes;

    //
    // Must flash when starting a new transaction
    //

    long lFlushLevel = m_lTransactionStartOffset;
/*
    if(!FlushFileBuffers(m_hFlushFile))
        DebugBreak();
*/

    while(1)
    {
        if(m_bExitNow)
            return ERROR_SUCCESS;

        //
        // Get the next instruction from the queue
        //

        CFileInstruction* pInst = NULL;

        {
            CInCritSec ics(&m_cs);
        
            if(m_qToWrite.empty())
            {
                //
                // Reset generation only if there are no instructions on the
                // transaction queue!
                //

                if(m_lTransactionStartOffset == m_lFirstFreeOffset)
                {
                    WriteEmpty();
                }
                return ERROR_SUCCESS;
            }

            pInst = m_qToWrite.front();

            //  
            // Check if it is in the map.  The reason it might not be there
            // is if it was superceeded by some later instruction over the same 
            // file.  In that case, we should not execute it, but rather simply 
            // skip it.
            //
            
            TIterator it = m_map.find(pInst->GetFilePath()); // Make KEY
            _ASSERT(it != m_map.end(), L"Instruction in queue not in map");

            if(it->second != pInst && it->second->IsCommitted())
            {
				pInst->Release();
                m_qToWrite.pop();
                continue;
            }
        }
            
        //
        // Flush if needed
        //
    
        if(pInst->GetFileOffset() > lFlushLevel)
        {
            lFlushLevel = m_lTransactionStartOffset;
/*
            if(!FlushFileBuffers(m_hFlushFile))
                DebugBreak();
*/
        }

        //
        // Execute it
        //

        lRes = pInst->Execute();
        if(lRes != ERROR_SUCCESS)
        {
            //
            // We cannot continue until we succeed in executing this
            // instruction.  Therefore, we keep it on the queue and keep 
            // re-executing it.  If an instruction fails twice in a row, we 
            // enter a "failed state" and refuse all new transactions until the
            // condition is cleared
            //

            if(m_bFailedBefore)
            {
                ERRORTRACE((LOG_WBEMCORE, "Repository driver repeatedly failed "
                            "to execute an instruction with error code %d.\n"
                            "Further processing is suspended until the problem "
                            "is corrected\n", lRes));
                m_lStatus = lRes;
            }
            else
            {
                ERRORTRACE((LOG_WBEMCORE, "Repository driver failed "
                            "to execute an instruction with error code %d.\n",
                            lRes));
                m_bFailedBefore = true;
            }

            //
            // Wait a bit before retrying
            //
    
            Sleep(100);
            continue;
        }
        else
        {
            m_bFailedBefore = false;
            m_lStatus = ERROR_SUCCESS;
        }
        
        //  
        // Remove it from the map, if there.  The reason it might not be there
        // is if it was superceeded by some later instruction over the same 
        // file.  We could check this before we executed it, but it wouldn't 
        // help much since the overriding instruction could have come in while
        // we were executing.  Also, there might be issues with instructions
        // constantly overriding each other and us never writing anything 
        // because of that...
        //
            
        {
            //
            // Here, we are going to be removing the instruction from the 
            // map.  We must lock the entire file cache to prevent the reader
            // from missing both the side effects (we executed without locking)
            // and the instruction itself if it is removed before the reader
            // gets a chance to lock the stage in IsDeleted.
            //

            CInCritSec ics(m_pCache->GetLock());
            {
                CInCritSec ics(&m_cs);
    
                TIterator it = m_map.find(pInst->GetFilePath()); // Make KEY
                _ASSERT(it != m_map.end(), L"Instruction in queue not in map");
    
                if(it->second == pInst)
                {
                    EraseIterator(it);
                    pInst->Release();
                }

                //
                // Remove it from the queue
                //

                m_qToWrite.pop();
                pInst->Release();

                if(m_qToWrite.empty())
                {
                    //
                    // Reset generation only if there are no instructions on the
                    // transaction queue!
                    //

                    if(m_lTransactionStartOffset == m_lFirstFreeOffset)
                    {
                        WriteEmpty();
                    }
                    return ERROR_SUCCESS;
                }
            }
        }
    }

    _ASSERT(false, L"Out of an infinite loop!");
    return ERROR_INTERNAL_ERROR;
}
                
//******************************************************************************
//******************************************************************************
//                     PERMANENT FILE
//******************************************************************************
//******************************************************************************

CPermanentStagingFile::CPermanentStagingFile(CFileCache* pCache, 
                                                LPCWSTR wszBaseName)
    : CRealStagingFile(pCache, wszBaseName, 0x7FFFFFFF, 0x7FFFFFFF)
{
}

CPermanentStagingFile::~CPermanentStagingFile()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\adapelem.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADAPELEM.H

Abstract:

History:

--*/

#ifndef __ADAPELEM_H__
#define __ADAPELEM_H__

class CAdapElement
////////////////////////////////////////////////////////////////////////////////
//
//	The base class for all addref'd AMI ADAP objects
//
////////////////////////////////////////////////////////////////////////////////
{
private:
	long	m_lRefCount;

public:
	CAdapElement( void );
	virtual ~CAdapElement(void);

	long AddRef( void );
	long Release( void );
};

class CAdapReleaseMe
{
protected:
    CAdapElement* m_pEl;

public:
    CAdapReleaseMe(CAdapElement* pEl) : m_pEl(pEl){}
    ~CAdapReleaseMe() {if(m_pEl) m_pEl->Release();}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a512rosw\stage.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __WMI_A51_STAGE__H_
#define __WMI_A51_STAGE__H_

#include <queue>
#include <map>
#include <list>
#include <sync.h>
#include "a51tools.h"

namespace a51converter
{

#define ERROR_NO_INFORMATION -1


class CFileCache;
class CStagingFile
{
public:
    virtual ~CStagingFile(){}
    virtual long ReadFile(LPCWSTR wszFilePath, DWORD* pdwLen,
                            DELETE_ME BYTE** ppBuffer, bool bMustBeThere) = 0;
    virtual long IsDeleted(LPCWSTR wszFilePath) = 0;
    virtual long WriteFile(LPCWSTR wszFilePath, DWORD dwLen,
                            BYTE* pBuffer) = 0;
    virtual long DeleteFile(LPCWSTR wszFilePath) = 0;
    virtual long RemoveDirectory(LPCWSTR wszFilePath) = 0;
    virtual long FindFirst(LPCWSTR wszFilePrefix, WIN32_FIND_DATAW* pfd,
                            void** ppHandle) = 0;
    virtual long FindNext(void* pHandle, WIN32_FIND_DATAW* pfd) = 0;
    virtual void FindClose(void* pHandle) = 0;
    virtual long BeginTransaction() = 0;
    virtual long CommitTransaction() = 0;
    virtual long AbortTransaction() = 0;

    virtual bool IsFullyFlushed() = 0;
    virtual void Dump() = 0;
};

class CRealStagingFile;

class CFileInstruction
{
protected:
    long m_lRef;
    CRealStagingFile* m_pFile;
    WCHAR* m_wszFilePath;
    TFileOffset m_lFileOffset;
    bool m_bCommitted;

public:
    CFileInstruction(CRealStagingFile* pFile);
    long Initialize(LPCWSTR wszFilePath);
    virtual ~CFileInstruction();

    void AddRef() {m_lRef++;}
    void Release() {if(--m_lRef == 0) delete this;}

    LPCWSTR GetFilePath() {return m_wszFilePath;}
    long GetFileOffset() {return m_lFileOffset;}
    void SetCommitted() {m_bCommitted = true;}
    bool IsCommitted() {return m_bCommitted;}

    virtual long Execute() = 0;
    virtual long RecoverData(HANDLE hFile) = 0;
    virtual bool IsDeletion() = 0;

protected:
    DWORD ComputeSpaceForName();
    BYTE* WriteFileName(BYTE* pStart);
    long RecoverFileName(HANDLE hFile);
    void ComputeFullPath(wchar_t *wszFullPath);
};

class CCreateFile : public CFileInstruction
{
protected:
    DWORD m_dwFileLen;
    DWORD m_dwFileStart;

public:
    CCreateFile(CRealStagingFile* pFile);
    long Initialize(LPCWSTR wszFilePath, DWORD dwFileLen);

    DWORD ComputeNeededSpace();
    long Write(TFileOffset lOffset, BYTE* pBuffer);
    long RecoverData(HANDLE hFile);
    long Execute();

    long GetData(HANDLE hFile, DWORD* pdwLen, BYTE** ppBuffer);
    virtual bool IsDeletion(){return false;}

    void* operator new(size_t);
    void operator delete(void* p);
};

class CDeleteFile : public CFileInstruction
{
public:
    CDeleteFile(CRealStagingFile* pFile);
    long Initialize(LPCWSTR wszFilePath);

    DWORD ComputeNeededSpace();
    long Write(TFileOffset lOffset);
    long RecoverData(HANDLE hFile);
    long Execute();
    virtual bool IsDeletion(){return true;}

    void* operator new(size_t);
    void operator delete(void* p);
};

class CRemoveDirectory : public CFileInstruction
{
public:
    CRemoveDirectory(CRealStagingFile* pFile);
    long Initialize(LPCWSTR wszFilePath);

    DWORD ComputeNeededSpace();
    long Write(TFileOffset lOffset);
    long RecoverData(HANDLE hFile);
    long Execute();
    virtual bool IsDeletion(){return false;}

    void* operator new(size_t);
    void operator delete(void* p);
};

class CFileCache;
class CRealStagingFile : public CStagingFile
{
    class wcscless : public binary_function<LPCWSTR, LPCWSTR, bool>
    {
    public:
        bool operator()(const LPCWSTR& wcs1, const LPCWSTR& wcs2) const
            {return wcscmp(wcs1, wcs2) < 0;}
    };

protected:
    wchar_t m_wszBaseName[MAX_PATH+1];

    HANDLE m_hFile;
    HANDLE m_hFlushFile;
    long m_lFirstFreeOffset;

    typedef std::map<LPCWSTR, CFileInstruction*, wcscless, 
                     CPrivateTempAllocator<CFileInstruction*> > TMap;
    typedef TMap::iterator TIterator;
    typedef std::queue<CFileInstruction*, std::list<CFileInstruction*, 
                                    CPrivateTempAllocator<CFileInstruction*> > 
              > TQueue;
    typedef std::stack<CFileInstruction*, std::list<CFileInstruction*, 
                                    CPrivateTempAllocator<CFileInstruction*> > 
              > TStack;

    CCritSec m_cs;
    TMap m_map;
    TQueue m_qToWrite;

    TStack m_stReplacedInstructions;
    TQueue m_qTransaction;

    __int64 m_nTransactionIndex;
    long m_lTransactionStartOffset;
    BYTE m_TransactionHash[16];

    bool m_bInTransaction;

    long m_lMaxFileSize;
    long m_lAbortTransactionFileSize;
    CFileCache* m_pCache;

    bool m_bFailedBefore;
    long m_lStatus;

public:
    CRealStagingFile(CFileCache* pCache, LPCWSTR wszBaseName, 
                            long lMaxFileSize, long lAbortTransactionFileSize);
    virtual ~CRealStagingFile();

    virtual long Create(LPCWSTR wszStagingFileName);
    void SetMaxFileSize(long lMaxFileSize, long lAbortTransactionFileSize);
    long ReadFile(LPCWSTR wszFilePath, DWORD* pdwLen,
                            DELETE_ME BYTE** ppBuffer, bool bMustBeThere);
    long WriteFile(LPCWSTR wszFilePath, DWORD dwLen,
                            BYTE* pBuffer);
    long DeleteFile(LPCWSTR wszFilePath);
    long RemoveDirectory(LPCWSTR wszFilePath);
    long FindFirst(LPCWSTR wszFilePrefix, WIN32_FIND_DATAW* pfd,
                            void** ppHandle);
    long FindNext(void* pHandle, WIN32_FIND_DATAW* pfd);
    void FindClose(void* pHandle);
    long IsDeleted(LPCWSTR wszFilePath);

    bool IsFullyFlushed();

    INTERNAL HANDLE GetHandle() {return m_hFile;}
    INTERNAL HANDLE GetFlushHandle() {return m_hFlushFile;}
    INTERNAL LPCWSTR GetBase() {return m_wszBaseName;}

    long WriteInstruction(long lStartingOffset, 
                            BYTE* pBuffer, DWORD dwBufferLen);

    long BeginTransaction();
    long CommitTransaction();
    long AbortTransaction();
    void Dump();

protected:
    long WaitForSpaceForTransaction();
    virtual void SignalPresense(){}

    virtual long CanStartNewTransaction();
    virtual bool CanWriteInTransaction(DWORD dwSpaceNeeded);
    long RecoverStage(HANDLE hFile);
    long RecoverTransaction(HANDLE hFile);
    BYTE ReadNextInstructionType(HANDLE hFile);
    virtual long WriteEmpty();

    long ProcessCommit();
    long ProcessBegin();
    INTERNAL CCritSec* GetLock() {return &m_cs;}
    int GetStagingFileHeaderSize();

protected:
    void ComputeKey(LPCWSTR wszFileName, LPWSTR wszKey);
    long AddInstruction(CFileInstruction* pInst);

    class CIterationHandle
    {
    protected:
        TMap& m_rMap;
        TIterator m_it;
        wchar_t m_wszPrefix[MAX_PATH+1];
        DWORD m_dwPrefixLen;
        DWORD m_dwPrefixDirLen;

    public:
        CIterationHandle(CRealStagingFile::TMap& rMap,
                    const CRealStagingFile::TIterator& rIt,
                    LPCWSTR wszPrefix);

        long GetNext(WIN32_FIND_DATAW* pfd);

        void* operator new(size_t) 
            {return TempAlloc(sizeof(CIterationHandle));}
        void operator delete(void* p) 
            {return TempFree(p, sizeof(CIterationHandle));}

        friend class CRealStagingFile;
    };
	friend class CCreateFile;
protected:
    CPointerArray<CIterationHandle> m_apIterators;
    TIterator EraseIterator(TIterator it);
};

class CExecutableStagingFile : public CRealStagingFile
{
protected:
    HANDLE m_hEvent;
    HANDLE m_hThread;
    bool m_bExitNow;

public:
    CExecutableStagingFile(CFileCache* pCache, LPCWSTR wszBaseName, 
                            long lMaxFileSize, long lAbortTransactionFileSize);
    ~CExecutableStagingFile();

    virtual long Create(LPCWSTR wszStagingFileName);

protected:
    static DWORD staticFlusher(void* pArg);

    virtual long WriteEmpty();
    virtual void SignalPresense();
    DWORD Flusher();
    long Flush();
};

class CPermanentStagingFile : public CRealStagingFile
{
public:
    CPermanentStagingFile(CFileCache* pCache, LPCWSTR wszBaseName);
    ~CPermanentStagingFile();
};
    
} //namespace

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a512rosw\main.cpp ===
#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include "filecach.h"

#define A51_MAX_SLEEPS 1000
#define A51_ONE_SLEEP 100

long FlushOldCache(LPCWSTR wszRepDir)
{
    long lRes;

    //
    // Instantiate the old staging file and flush it
    //

    a51converter::CFileCache OldCache; 
    lRes = OldCache.Initialize(wszRepDir);
    if(lRes != ERROR_SUCCESS)
        return lRes;
    
    int n = 0;
    while(!OldCache.IsFullyFlushed() && n++ < A51_MAX_SLEEPS)
        Sleep(A51_ONE_SLEEP);

    if(!OldCache.IsFullyFlushed())
    {
        ERRORTRACE((LOG_WBEMCORE, "Upgrade waited for the old cache to flush "
                        "for %d seconds, but with no success. Aborting "
                        "upgrade\n", A51_MAX_SLEEPS * A51_ONE_SLEEP));

        return ERROR_TIMEOUT;
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\a512rosw\stage.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <wbemcomn.h>
#include <sync.h>
#include <malloc.h>
#include "stage.h"
#include "filecach.h"

using namespace a51converter;

#define A51_TAIL_SIZE sizeof(DWORD)

#define A51_INSTRUCTION_TYPE_TAIL 0
#define A51_INSTRUCTION_TYPE_CREATEFILE 1
#define A51_INSTRUCTION_TYPE_DELETEFILE 2
#define A51_INSTRUCTION_TYPE_REMOVEDIRECTORY 3
#define A51_INSTRUCTION_TYPE_ENDTRANSACTION 10 

static int g_nNumRecords;
static int g_nTotalMemory;
static int g_nNumRecordsMax = 0;
static int g_nTotalMemoryMax = 0;

static CTempMemoryManager g_FileCacheManager;

CFileInstruction::CFileInstruction(CRealStagingFile* pFile)
    : m_pFile(pFile), m_lRef(0), m_wszFilePath(NULL), m_lFileOffset(-1),
        m_bCommitted(false)
{
    g_nNumRecords++;
    if(g_nNumRecords > g_nNumRecordsMax)
        g_nNumRecordsMax = g_nNumRecords;
}
    
long CFileInstruction::Initialize(LPCWSTR wszFilePath)
{
    int nFilePathLen = wcslen(wszFilePath);
    m_wszFilePath = (WCHAR*)TempAlloc(g_FileCacheManager, (nFilePathLen+1) * sizeof(WCHAR));
    if(m_wszFilePath == NULL)
        return ERROR_OUTOFMEMORY;
    wcscpy(m_wszFilePath, wszFilePath);

    g_nTotalMemory += (nFilePathLen+1) * sizeof(WCHAR);
    if(g_nTotalMemory > g_nTotalMemoryMax)
        g_nTotalMemoryMax = g_nTotalMemory;
    
    return ERROR_SUCCESS;
}

CFileInstruction::~CFileInstruction()
{
    g_nNumRecords--;
    if (m_wszFilePath)
    {
        int nFilePathLen = wcslen(m_wszFilePath);
        g_nTotalMemory -= (nFilePathLen+1) * sizeof(WCHAR);
        TempFree(g_FileCacheManager, m_wszFilePath, (nFilePathLen+1)*sizeof(WCHAR));
    }
}


DWORD CFileInstruction::ComputeSpaceForName()
{
    return sizeof(DWORD) + wcslen(m_wszFilePath) * sizeof(WCHAR);
}

BYTE* CFileInstruction::WriteFileName(BYTE* pStart)
{
    DWORD dwStringLen = wcslen(m_wszFilePath);
    memcpy(pStart, (void*)&dwStringLen, sizeof(DWORD));
    pStart += sizeof(DWORD);
    memcpy(pStart, m_wszFilePath, dwStringLen * sizeof(WCHAR));

    return pStart + dwStringLen * sizeof(WCHAR);
}

long CFileInstruction::RecoverFileName(HANDLE hFile)
{
    _ASSERT(m_wszFilePath == NULL, 
            L"Double initialization of a file instruction!");
    //
    // Read the length
    //

    DWORD dwStringLen = 0;
    DWORD dwRead;

    if(!ReadFile(hFile, (BYTE*)&dwStringLen, sizeof(DWORD), &dwRead, NULL))
        return GetLastError();

    if(dwRead != sizeof(DWORD))
        return ERROR_HANDLE_EOF;

    //
    // Read the file name
    //

    m_wszFilePath = (WCHAR*)TempAlloc(g_FileCacheManager,
                                        (dwStringLen+1) * sizeof(WCHAR));
    if(m_wszFilePath == NULL)
        return ERROR_OUTOFMEMORY;
    
    if(!ReadFile(hFile, (BYTE*)m_wszFilePath, dwStringLen * sizeof(WCHAR),
                    &dwRead, NULL))
    {
        TempFree(m_wszFilePath, (dwStringLen+1) * sizeof(WCHAR));
        return GetLastError();
    }

    if(dwRead != dwStringLen * sizeof(WCHAR))
    {
        TempFree(m_wszFilePath, (dwStringLen+1) * sizeof(WCHAR));
        return ERROR_HANDLE_EOF;
    }

    m_wszFilePath[dwStringLen] = 0;

    g_nTotalMemory += (wcslen(m_wszFilePath)+1) * sizeof(WCHAR);
    if(g_nTotalMemory > g_nTotalMemoryMax)
        g_nTotalMemoryMax = g_nTotalMemory;

    return ERROR_SUCCESS;
}
        
    

void CFileInstruction::ComputeFullPath(wchar_t *wszFullPath)
{
    wcscpy(wszFullPath, m_pFile->GetBase());
    wcscat(wszFullPath, m_wszFilePath);
}



CCreateFile::CCreateFile(CRealStagingFile* pFile)
    : CFileInstruction(pFile), m_dwFileLen(0), m_dwFileStart(0)
{
}

void* CCreateFile::operator new(size_t) 
{
    return TempAlloc(g_FileCacheManager, sizeof(CCreateFile));
}

void CCreateFile::operator delete(void* p) 
{
    return TempFree(g_FileCacheManager, p, sizeof(CCreateFile));
}

long CCreateFile::Initialize(LPCWSTR wszFilePath, DWORD dwFileLen)
{
    long lRes = CFileInstruction::Initialize(wszFilePath);
    if(lRes != ERROR_SUCCESS)
        return lRes;
    m_dwFileLen = dwFileLen;
    return ERROR_SUCCESS;
}

DWORD CCreateFile::ComputeNeededSpace()
{
    return sizeof(BYTE) + // for the type
                ComputeSpaceForName() + // for the file name
                sizeof(DWORD) + // for the length of data
                m_dwFileLen + // for the data
                A51_TAIL_SIZE; // for the trailer
}
                    
long CCreateFile::Write(TFileOffset lOffset, BYTE* pBuffer)
{
    if(pBuffer)
        memcpy(&m_dwFileStart, pBuffer, sizeof(DWORD));
    else
        m_dwFileStart = 0;

    //
    // Construct an in-memory buffer large enough for the whole thing
    //

    DWORD dwNeededSpace = ComputeNeededSpace();
    BYTE* pWholeBuffer = (BYTE*)TempAlloc(dwNeededSpace);
    if(pWholeBuffer == NULL)
        return ERROR_OUTOFMEMORY;
    CTempFreeMe vdm(pWholeBuffer, dwNeededSpace);

    BYTE* pCurrent = pWholeBuffer;

    //
    // Write instruction type
    //

    *pCurrent = A51_INSTRUCTION_TYPE_CREATEFILE;
    pCurrent++;

    // 
    // Write the name of the file
    //

    pCurrent = WriteFileName(pCurrent);
    
    //
    // Write the length of the data for the file
    //

    memcpy(pCurrent, (void*)&m_dwFileLen, sizeof(DWORD));
    pCurrent += sizeof(DWORD);

    //
    // Write the data itself and record its offset
    //

    memcpy(pCurrent, pBuffer, m_dwFileLen);
    m_lFileOffset = lOffset + (pCurrent - pWholeBuffer);

    //
    // Write the trailer
    //

    memset(pCurrent + m_dwFileLen, 0, sizeof(DWORD));
    
    // 
    // Write it 
    //

    return m_pFile->WriteInstruction(lOffset, pWholeBuffer, dwNeededSpace);
}

long CCreateFile::RecoverData(HANDLE hFile)
{
    //
    // Recover the file name first
    //

    long lRes = CFileInstruction::RecoverFileName(hFile);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Read the length of the data from the file
    //

    DWORD dwRead;

    if(!ReadFile(hFile, (BYTE*)&m_dwFileLen, sizeof(DWORD), &dwRead, NULL))
        return GetLastError();

    if(dwRead != sizeof(DWORD))
        return ERROR_HANDLE_EOF;

    //
    // We do not need to actually read the data from the file --- we keep it
    // there until it is time to flush.  But we do need to skip it.  At the same
    // time, we need to record the position in the file where this data resides
    //

    LARGE_INTEGER liFileLen;
    liFileLen.QuadPart = m_dwFileLen;
    
    LARGE_INTEGER liNewPosition;
    if(!SetFilePointerEx(hFile, liFileLen, &liNewPosition, FILE_CURRENT))
        return GetLastError();

    _ASSERT(liNewPosition.HighPart == 0, L"Staging file too long!");

    m_lFileOffset = (long)(liNewPosition.QuadPart - m_dwFileLen);
    return ERROR_SUCCESS;
}

long CCreateFile::GetData(HANDLE hFile, DWORD* pdwLen, BYTE** ppBuffer)
{
	//
	// Lock the file
	//

	CInCritSec ics(m_pFile->GetLock());

	_ASSERT(m_pFile->m_lFirstFreeOffset >= m_lFileOffset, 
            L"Instruction points to empty space in stage file");

    if(pdwLen)
        *pdwLen = m_dwFileLen;

    if(ppBuffer == NULL)
        return ERROR_SUCCESS;

    //
    // Allocate the buffer
    //

    *ppBuffer = (BYTE*)TempAlloc(m_dwFileLen);
    if(*ppBuffer == NULL)
        return ERROR_OUTOFMEMORY;

    long lRes = A51ReadFromFileSync(hFile, m_lFileOffset, *ppBuffer, m_dwFileLen);
    if(lRes != ERROR_SUCCESS)
    {
        delete *ppBuffer;
        return lRes;
    }

    if(m_dwFileLen && m_dwFileStart && memcmp(*ppBuffer, &m_dwFileStart, sizeof(DWORD)))
    {
        _ASSERT(false, L"Stage file overwritten");
        TempFree(*ppBuffer, m_dwFileLen);
        return ERROR_OUTOFMEMORY;
    }

    return ERROR_SUCCESS;
}

    
long CCreateFile::Execute()
{
    //
    // Construct full path
    //

    CFileName wszFullPath;
	if (wszFullPath == NULL)
		return ERROR_OUTOFMEMORY;
    ComputeFullPath(wszFullPath);

    long lRes;

    //
    // Read the data from the staging file
    //

    BYTE* pBuffer = NULL;
    lRes = GetData(m_pFile->GetHandle(), NULL, &pBuffer);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    CTempFreeMe vdm(pBuffer, m_dwFileLen);
    
    return A51WriteFile(wszFullPath, m_dwFileLen, pBuffer);
}


CDeleteFile::CDeleteFile(CRealStagingFile* pFile)
    : CFileInstruction(pFile)
{
}

void* CDeleteFile::operator new(size_t) 
{
    return TempAlloc(g_FileCacheManager, sizeof(CDeleteFile));
}

void CDeleteFile::operator delete(void* p) 
{
    return TempFree(g_FileCacheManager, p, sizeof(CDeleteFile));
}

long CDeleteFile::Initialize(LPCWSTR wszFileName)
{
    return CFileInstruction::Initialize(wszFileName);
}

DWORD CDeleteFile::ComputeNeededSpace()
{
    return sizeof(BYTE) + // for instruction type
            ComputeSpaceForName() + // for the file name
            A51_TAIL_SIZE; // for the trailer
}

long CDeleteFile::Write(TFileOffset lOffset)
{
    //
    // Construct an in-memory buffer large enough for the whole thing
    //

    DWORD dwNeededSpace = ComputeNeededSpace();
    BYTE* pWholeBuffer = (BYTE*)TempAlloc(dwNeededSpace);
    if(pWholeBuffer == NULL)
        return ERROR_OUTOFMEMORY;
    CTempFreeMe vdm(pWholeBuffer, dwNeededSpace);

    BYTE* pCurrent = pWholeBuffer;

    //
    // Write the instruction type
    //
    
    *pCurrent = A51_INSTRUCTION_TYPE_DELETEFILE;
    pCurrent++;
    
    //
    // Write the file name
    //

    pCurrent = WriteFileName(pCurrent);
    m_lFileOffset = lOffset + (pCurrent - pWholeBuffer);

    //
    // Write the trailer
    //

    memset(pCurrent, 0, sizeof(DWORD));

    // 
    // Write it 
    //

    return m_pFile->WriteInstruction(lOffset, pWholeBuffer, dwNeededSpace);
}

long CDeleteFile::RecoverData(HANDLE hFile)
{
    //
    // Recover the file name 
    //

    long lRes = CFileInstruction::RecoverFileName(hFile);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    LARGE_INTEGER liZero;
    liZero.QuadPart = 0;
    LARGE_INTEGER liPosition;
    if(!SetFilePointerEx(hFile, liZero, &liPosition, FILE_CURRENT))
        return GetLastError();

    _ASSERT(liPosition.HighPart == 0, L"Staging file too long!");

    m_lFileOffset = (long)(liPosition.QuadPart);
    return ERROR_SUCCESS;
}
    
long CDeleteFile::Execute()
{
    //
    // Construct full path
    //

    CFileName wszFullPath;
	if (wszFullPath == NULL)
		return ERROR_OUTOFMEMORY;
    ComputeFullPath(wszFullPath);

    //
    // Delete the right file
    //

    if(!DeleteFileW(wszFullPath))
    {
        long lRes = GetLastError();
        if(lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_PATH_NOT_FOUND)
            return lRes;
        else
            return ERROR_SUCCESS;
    }

    return ERROR_SUCCESS;
}


CRemoveDirectory::CRemoveDirectory(CRealStagingFile* pFile)
    : CFileInstruction(pFile)
{
}

void* CRemoveDirectory::operator new(size_t) 
{
    return TempAlloc(g_FileCacheManager, sizeof(CRemoveDirectory));
}

void CRemoveDirectory::operator delete(void* p) 
{
    return TempFree(g_FileCacheManager, p, sizeof(CRemoveDirectory));
}

long CRemoveDirectory::Initialize(LPCWSTR wszFileName)
{
    return CFileInstruction::Initialize(wszFileName);
}

DWORD CRemoveDirectory::ComputeNeededSpace()
{
    return sizeof(BYTE) + // for the instruction type
            ComputeSpaceForName() + // for the file name
            A51_TAIL_SIZE; // for the trailer
}

long CRemoveDirectory::Write(TFileOffset lOffset)
{
    //
    // Construct an in-memory buffer large enough for the whole thing
    //

    DWORD dwNeededSpace = ComputeNeededSpace();
    BYTE* pWholeBuffer = (BYTE*)TempAlloc(dwNeededSpace);
    if(pWholeBuffer == NULL)
        return ERROR_OUTOFMEMORY;
    CTempFreeMe vdm(pWholeBuffer, dwNeededSpace);

    BYTE* pCurrent = pWholeBuffer;

    //
    // Write instruction type
    //

    *pCurrent = A51_INSTRUCTION_TYPE_REMOVEDIRECTORY;
    pCurrent++;

    //
    // Write the file name
    //

    pCurrent = WriteFileName(pCurrent);
    m_lFileOffset = lOffset + (pCurrent - pWholeBuffer);

    //
    // Write the trailer
    //

    memset(pCurrent, 0, sizeof(DWORD));

    // 
    // Write it 
    //

    return m_pFile->WriteInstruction(lOffset, pWholeBuffer, dwNeededSpace);
}

long CRemoveDirectory::RecoverData(HANDLE hFile)
{
    //
    // Recover the file name 
    //

    long lRes = CFileInstruction::RecoverFileName(hFile);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    LARGE_INTEGER liZero;
    liZero.QuadPart = 0;
    LARGE_INTEGER liPosition;
    if(!SetFilePointerEx(hFile, liZero, &liPosition, FILE_CURRENT))
        return GetLastError();

    _ASSERT(liPosition.HighPart == 0, L"Staging file too long!");

    m_lFileOffset = (long)(liPosition.QuadPart);
    return ERROR_SUCCESS;
}
    
long CRemoveDirectory::Execute()
{
    //
    // Construct full path
    //

    CFileName wszFullPath;
	if (wszFullPath == NULL)
		return ERROR_OUTOFMEMORY;
    ComputeFullPath(wszFullPath);

    //
    // Remove the directory
    //

    long lRes = A51RemoveDirectory(wszFullPath);
    if(lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_PATH_NOT_FOUND &&
        lRes != ERROR_DIR_NOT_EMPTY)
    {
        return lRes;
    }
    else
    {
        return ERROR_SUCCESS;
    }
}



CRealStagingFile::CRealStagingFile(CFileCache* pCache,
                                                LPCWSTR wszBaseName,
                                                long lMaxFileSize,
                                                long lAbortTransactionFileSize)
    : m_hFile(NULL), m_lFirstFreeOffset(-1), m_nTransactionIndex(0),
        m_bInTransaction(false), 
        m_map(TMap::key_compare(), TMap::allocator_type(&g_FileCacheManager)),
        m_qTransaction(TQueue::allocator_type(&g_FileCacheManager)),
        m_qToWrite(TQueue::allocator_type(&g_FileCacheManager)),
        m_stReplacedInstructions(TStack::allocator_type(&g_FileCacheManager)),
        m_lMaxFileSize(lMaxFileSize),
        m_lAbortTransactionFileSize(lAbortTransactionFileSize),
        m_bFailedBefore(false), m_lStatus(ERROR_SUCCESS),
        m_pCache(pCache)
{
    wcscpy(m_wszBaseName, wszBaseName);
}

CRealStagingFile::~CRealStagingFile()
{
    CloseHandle(m_hFile);
}

void CRealStagingFile::ComputeKey(LPCWSTR wszFileName, LPWSTR wszKey)
{
    wbem_wcsupr(wszKey, wszFileName);
}

long CRealStagingFile::WriteInstruction(long lStartingOffset, 
                            BYTE* pBuffer, DWORD dwBufferLen)
{
    long lRes = A51WriteToFileSync(m_hFile, lStartingOffset, pBuffer,
                                dwBufferLen);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Add the data to the currently running transaction hash.  Disregard the
    // trailer since it is going to be overwritten
    //

    MD5::ContinueTransform(pBuffer, dwBufferLen - A51_TAIL_SIZE, 
                            m_TransactionHash);

    return ERROR_SUCCESS;
}
    
long CRealStagingFile::BeginTransaction()
{    
    //
    // Wait for space in the staging file
    //

    long lRes = WaitForSpaceForTransaction();
    if(lRes != ERROR_SUCCESS)
        return lRes;

    return ProcessBegin();
}

long CRealStagingFile::ProcessBegin()
{
    CInCritSec ics(&m_cs);

    //
    // Reset the digest
    //

    MD5::Transform(&m_nTransactionIndex, sizeof m_nTransactionIndex,
                    m_TransactionHash);

    m_bInTransaction = true;


    return ERROR_SUCCESS;
}

long CRealStagingFile::CommitTransaction()
{
    CInCritSec ics(&m_cs);

    m_bInTransaction = false;

    //
    // Check if there is even anything to commit
    //

    if(m_qTransaction.empty())
        return ERROR_SUCCESS;

    //
    // Write transaction trailer "instruction"
    //

    DWORD dwBufferSize = sizeof(BYTE) + // instruction type
                        sizeof m_TransactionHash // transaction hash
                        + A51_TAIL_SIZE; // trailer
    BYTE* pBuffer = (BYTE*)TempAlloc(dwBufferSize);
    if(pBuffer == NULL)
        return ERROR_OUTOFMEMORY;
    CTempFreeMe tfm(pBuffer, dwBufferSize);

    memset(pBuffer, 0, dwBufferSize);
    *(DWORD*)pBuffer = A51_INSTRUCTION_TYPE_ENDTRANSACTION;
    memcpy(pBuffer + sizeof(BYTE), m_TransactionHash, 
            sizeof m_TransactionHash);

    //
    // Write it out
    //

    long lRes = A51WriteToFileSync(m_hFile, m_lFirstFreeOffset, pBuffer, 
                                dwBufferSize);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    m_lFirstFreeOffset += dwBufferSize - A51_TAIL_SIZE;

    return ProcessCommit();
}

long CRealStagingFile::ProcessCommit()
{
    //
    // Now, transfer all instructions from the transaction queue to the main
    // queue for flushing.  Wake up the flushing thread if the main queue is 
    // empty
    //

    if(m_qToWrite.empty() && !m_qTransaction.empty())
        SignalPresense();

    while(!m_qTransaction.empty())
    {
        CFileInstruction* pInst = m_qTransaction.front();
        pInst->SetCommitted();
        m_qToWrite.push(pInst);
        m_qTransaction.pop();
    }

    //
    // Erase the stack of replaced instructions --- they are replaced for good
    //

    while(!m_stReplacedInstructions.empty())
    {
        m_stReplacedInstructions.top()->Release();
        m_stReplacedInstructions.pop();
    }

    //
    // Move transaction start pointer to the next free location
    //

    m_lTransactionStartOffset = m_lFirstFreeOffset;
    m_nTransactionIndex++;

    //
    // Reset the digest
    //

    MD5::Transform(&m_nTransactionIndex, sizeof m_nTransactionIndex,
                    m_TransactionHash);

    return ERROR_SUCCESS;
}

long CRealStagingFile::AbortTransaction()
{
    CInCritSec ics(&m_cs);

    m_bInTransaction = false;

    //
    // Check if there is even anything to abort
    //

    if(m_qTransaction.empty())
        return ERROR_SUCCESS;

    ERRORTRACE((LOG_WBEMCORE, "Repository driver aborting transaction!\n"));

    //
    // Reset the first free pointer to the beginning of the transaction
    //

    m_lFirstFreeOffset = m_lTransactionStartOffset;

    //
    // Write termination marker there to simplify recovery.  It might not
    // be flushed, so recovery process does not rely on it, but still.
    //

    BYTE nType = A51_INSTRUCTION_TYPE_TAIL;
    long lRes = A51WriteToFileSync(m_hFile, m_lFirstFreeOffset, &nType, 
                                    sizeof nType);
    // ignore return

    //
    // Discard all instructions in the transaction queue
    //

    while(!m_qTransaction.empty())
    {
        CFileInstruction* pInst = m_qTransaction.front();
        TIterator it = m_map.find(pInst->GetFilePath());
        if(it != m_map.end() && it->second == pInst)
        {
            // 
            // This instruction is currently in the map. Remove it, since
            // it has been cancelled. Of course, it may have replaced something
            // else originally, but that will be fixed shortly when we put back
            // all the replaced instructions
            //

            it->second->Release();
            EraseIterator(it);
        }

        m_qTransaction.front()->Release();
        m_qTransaction.pop();
    }

    //
    // Move all the records we have displaced from the map back into the map
    //

    while(!m_stReplacedInstructions.empty())
    {
        CFileInstruction* pInst = m_stReplacedInstructions.top();
        TIterator it = m_map.find(pInst->GetFilePath());
        if(it != m_map.end())
        {
            //
            // Note: we cannot just replace the pointer, since we are using its
            // member as the key!
            //
    
            it->second->Release();
            EraseIterator(it);
        }
    
        m_map[pInst->GetFilePath()] = pInst;
    
        //
        // We need to also postpend it onto the flushing queue, since it may
        // have been skipped by the flusher.  Event if it was not, postpending
        // it is no big deal --- we know that nobody had overwritten it in the
        // interleaving time because it was in the map (and therefore current)
        // when we started the transaction
        //

        m_qToWrite.push(pInst);
        pInst->AddRef();

        m_stReplacedInstructions.pop();
    }

    //
    // Reset the digest
    //

    MD5::Transform(&m_nTransactionIndex, sizeof m_nTransactionIndex,
                    m_TransactionHash);

    //
    // Check if the flushing thread caught up with us, but could not reset the
    // staging file because we had some things on the queue.
    //

    if(m_qToWrite.empty() && m_lFirstFreeOffset != sizeof(__int64))
    {
        ERRORTRACE((LOG_WBEMCORE, "Resetting first free offset in abort"));
        WriteEmpty();
    }

    return ERROR_SUCCESS;
}
    

long CRealStagingFile::WriteFile(LPCWSTR wszFileName, DWORD dwLen, 
                                        BYTE* pBuffer)
{
    long lRes;
    CFileName wszKey;
    if (wszKey == NULL)
	return ERROR_OUTOFMEMORY;
    ComputeKey(wszFileName, wszKey);

    CCreateFile* pInst = new CCreateFile(this);
    if(pInst == NULL)
        return ERROR_OUTOFMEMORY;
    pInst->AddRef();
    CTemplateReleaseMe<CFileInstruction> rm1(pInst);

    lRes = pInst->Initialize(wszKey, dwLen);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    DWORD dwSpaceNeeded = pInst->ComputeNeededSpace();

    if(!CanWriteInTransaction(dwSpaceNeeded))
        return ERROR_NOT_ENOUGH_QUOTA;

    {
        CInCritSec ics(&m_cs);

        //
        // Write all the data into the staging area
        //
    
        lRes = pInst->Write(m_lFirstFreeOffset, pBuffer);
        if(lRes)
            return lRes;
    
        m_lFirstFreeOffset += dwSpaceNeeded - A51_TAIL_SIZE;
    
        lRes = AddInstruction(pInst);
    }
    return lRes;
}

long CRealStagingFile::DeleteFile(LPCWSTR wszFileName)
{
    long lRes;
    CFileName wszKey;
    if (wszKey == NULL)
        return ERROR_OUTOFMEMORY;
    ComputeKey(wszFileName, wszKey);

    CDeleteFile* pInst = new CDeleteFile(this);
    if(pInst == NULL)
        return ERROR_OUTOFMEMORY;
    pInst->AddRef();
    CTemplateReleaseMe<CFileInstruction> rm1(pInst);

    lRes = pInst->Initialize(wszKey);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    DWORD dwSpaceNeeded = pInst->ComputeNeededSpace();

    if(!CanWriteInTransaction(dwSpaceNeeded))
        return ERROR_NOT_ENOUGH_QUOTA;

    {
        CInCritSec ics(&m_cs);

        //
        // Write all the data into the staging area
        //
    
        lRes = pInst->Write(m_lFirstFreeOffset);
        if(lRes)
            return lRes;
    
        //
        // Write the new offset into the offset file
        //
    
        m_lFirstFreeOffset += dwSpaceNeeded - A51_TAIL_SIZE;
    
        lRes = AddInstruction(pInst);
    }
    return lRes;
}

long CRealStagingFile::RemoveDirectory(LPCWSTR wszFileName)
{
    long lRes;
    CFileName wszKey;
    if (wszKey == NULL)
        return ERROR_OUTOFMEMORY;

    ComputeKey(wszFileName, wszKey);

    CRemoveDirectory* pInst = new CRemoveDirectory(this);
    if(pInst == NULL)
        return ERROR_OUTOFMEMORY;
    pInst->AddRef();
    CTemplateReleaseMe<CFileInstruction> rm1(pInst);

    lRes = pInst->Initialize(wszKey);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    DWORD dwSpaceNeeded = pInst->ComputeNeededSpace();

    if(!CanWriteInTransaction(dwSpaceNeeded))
        return ERROR_NOT_ENOUGH_QUOTA;

    {
        CInCritSec ics(&m_cs);

        //
        // Write all the data into the staging area
        //
    
        lRes = pInst->Write(m_lFirstFreeOffset);
        if(lRes)
        {
            m_cs.Leave();
            return lRes;
        }
    
        //
        // Write the new offset into the offset file
        //
    
        m_lFirstFreeOffset += dwSpaceNeeded - A51_TAIL_SIZE;
    
        lRes = AddInstruction(pInst);
    }

    return lRes;
}


// assumes: locked
long CRealStagingFile::AddInstruction(CFileInstruction* pInst)
{
    //
    // Add the instruction to the transaction queue.  It will be moved into 
    // flushable queue when transaction commits
    //

    pInst->AddRef();
    m_qTransaction.push(pInst);

    //
    // Now, add the structure to the map for lookup
    //

    pInst->AddRef();

    TIterator it = m_map.find(pInst->GetFilePath());
    if(it != m_map.end())
	{
        //
        // It is already there.  We need to replace that instruction with our
        // own.  However, if that instruction was committed, we should remember
        // it in case our transaction aborts.
		// Note: we cannot just replace the pointer, since we are using its
		// member as the key!
        //
        // The extra quirk here is that we should not be doing this if the 
        // instruction being replaced came from our own transaction.  This is
        // not an empty optimization --- if we do and the transaction aborts,
        // we may end up attempting to execute this one even though its body
        // is in the garbaged area of the staging file
        //

        if(it->second->IsCommitted())
        {
            m_stReplacedInstructions.push(it->second); // transferred ref-count
        }
        else
        {
            it->second->Release();
        }
        EraseIterator(it);
	}

    m_map[pInst->GetFilePath()] = pInst;

    //
    // Now, if we are not transacted, commit!
    //

    if(!m_bInTransaction)
    {
        long lRes = CommitTransaction();
        if(lRes != ERROR_SUCCESS)
            return lRes;
    }

    return ERROR_SUCCESS;
}

long CRealStagingFile::WaitForSpaceForTransaction()
{
    while(1) // TBD: consider timing out
    {
        {
            CInCritSec ics(&m_cs);

            long lRes = CanStartNewTransaction();
            if(lRes == ERROR_SUCCESS)
                return ERROR_SUCCESS;
            else if(lRes != ERROR_IO_PENDING)
                return lRes;
        }
        Sleep(100);
    }

    // Can't happen for now
    return ERROR_INTERNAL_ERROR;
}

long CRealStagingFile::ReadFile(LPCWSTR wszFileName, DWORD* pdwLen, 
                                BYTE** ppBuffer, bool bMustBeThere)
{
    CInCritSec ics(&m_cs);

    // 
    // Search for the file
    //

    CFileName wszKey;
	if (wszKey == NULL)
		return ERROR_OUTOFMEMORY;
    ComputeKey(wszFileName, wszKey);

    TIterator it = m_map.find(wszKey);
    if(it == m_map.end())
    {
        return ERROR_NO_INFORMATION;
    }
    else
    {
        CFileInstruction* pInstruction = it->second;
        if(pInstruction->IsDeletion())
        {
            if(bMustBeThere)
            {
                Dump();
                _ASSERT(false, L"Must-be-present file is not there. Dumped");
            }
            return ERROR_FILE_NOT_FOUND;
        }
        else
        {
            long lRes = ((CCreateFile*)pInstruction)->GetData(m_hFile, pdwLen, 
                                                                ppBuffer);
            return lRes;
        }
    }
}

void CRealStagingFile::Dump()
{
    FILE* f = fopen("c:\\a.dmp", "a");
    if(f == NULL)
        return;
    fprintf(f, "MAP:\n");
    TIterator it = m_map.begin();
    while(it != m_map.end())
    {
        CFileInstruction* pInstruction = it->second;
        if(pInstruction->IsDeletion())
            fprintf(f, "Delete ");
        else
            fprintf(f, "Create ");

        fprintf(f, "%S\n", pInstruction->GetFilePath());
        it++;
    }

    fprintf(f, "LIST:\n");

    int nSize = m_qToWrite.size();
    for(int i = 0; i < nSize; i++)
    {
        CFileInstruction* pInstruction = m_qToWrite.front();
        if(pInstruction->IsDeletion())
            fprintf(f, "Delete ");
        else
            fprintf(f, "Create ");

        fprintf(f, "%S\n", pInstruction->GetFilePath());

        m_qToWrite.pop();
        m_qToWrite.push(pInstruction);
    }

    fclose(f);
}

long CRealStagingFile::IsDeleted(LPCWSTR wszFilePath)
{
    CInCritSec ics(&m_cs);

    // 
    // Search for the file
    //

    CFileName wszKey;
	if (wszKey == NULL)
		return ERROR_OUTOFMEMORY;
    ComputeKey(wszFilePath, wszKey);

    TIterator it = m_map.find(wszKey);
    if(it == m_map.end())
    {
        return S_FALSE;
    }
    else
    {
        CFileInstruction* pInstruction = it->second;
        if(pInstruction->IsDeletion())
            return S_OK;
        else
            return S_FALSE;
    }
}
    

long CRealStagingFile::FindFirst(LPCWSTR wszFilePrefix, WIN32_FIND_DATAW* pfd,
                            void** ppHandle)
{
    CInCritSec ics(&m_cs);

    //
    // Compute the key for the prefix --- key computation is such that the 
    // keys come in the same lexicographic order as the names, so this will 
    // give us the lower bound for the search
    //

    CFileName wszKey;
	if (wszKey == NULL)
		return ERROR_OUTOFMEMORY;
    ComputeKey(wszFilePrefix, wszKey);

    //
    // Find this spot in the map
    //

    TIterator it = m_map.lower_bound(wszKey);
    if(it == m_map.end())
        return ERROR_FILE_NOT_FOUND;

    //
    // Retrieve the first element
    // 

    CIterationHandle* pHandle = new CIterationHandle(m_map, it, wszKey);
    if(pHandle == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    long lRes = pHandle->GetNext(pfd);
    if(lRes != ERROR_SUCCESS)
    {
        delete pHandle;
        if(lRes == ERROR_NO_MORE_FILES)
            lRes = ERROR_FILE_NOT_FOUND;

        return lRes;
    }

    m_apIterators.Add(pHandle);
    *ppHandle = pHandle;

    return ERROR_SUCCESS;
}

long CRealStagingFile::FindNext(void* pHandle, WIN32_FIND_DATAW* pfd)
{
    CInCritSec ics(&m_cs);

    //
    // The "handle" is really an iteration handle pointer
    //

    CIterationHandle* pIterationHandle = (CIterationHandle*)pHandle;

    //
    // Get the thing pointed to by the iterator, unless it is past the end
    //

    return pIterationHandle->GetNext(pfd);
}

void CRealStagingFile::FindClose(void* pHandle)
{
    CInCritSec ics(&m_cs);

    //
    // The "handle" is really an iteration handle pointer
    //

    CIterationHandle* pIterationHandle = (CIterationHandle*)pHandle;
    for(int i = 0; i < m_apIterators.GetSize(); i++)
    {
        if(m_apIterators[i] == pIterationHandle)
        {
            m_apIterators.RemoveAt(i);
            delete pIterationHandle;
            return;
        }
    }


    _ASSERT(false, L"Non-existent iteration handle is closed");
}

int CRealStagingFile::GetStagingFileHeaderSize()
{
    return sizeof(m_nTransactionIndex);
}

bool CRealStagingFile::IsFullyFlushed()
{
    CInCritSec ics(&m_cs);

    return (m_lFirstFreeOffset == GetStagingFileHeaderSize());
}

bool CRealStagingFile::CanWriteInTransaction(DWORD dwNeeded)
{
    if(m_lFirstFreeOffset + dwNeeded > m_lAbortTransactionFileSize)
        return false;
    else
        return true;
}

long CRealStagingFile::CanStartNewTransaction()
{
    //
    // Check if the staging file is currently in trouble --- failing to execute
    // an instruction.  If so, refuse to start this transaction
    //

    if(m_lStatus != ERROR_SUCCESS)
        return m_lStatus;
    if(m_lFirstFreeOffset < m_lMaxFileSize)
        return ERROR_SUCCESS;
    else
        return ERROR_IO_PENDING;
}

void CRealStagingFile::SetMaxFileSize(long lMaxFileSize,
                                            long lAbortTransactionFileSize)
{
    m_lMaxFileSize = lMaxFileSize;
    m_lAbortTransactionFileSize = lAbortTransactionFileSize;
}


long CRealStagingFile::RecoverStage(HANDLE hFile)
{
    long lRes;
    DWORD dwRead;

    //
    // Read the starting transaction index
    //

    if(!::ReadFile(hFile, &m_nTransactionIndex, 
                    sizeof m_nTransactionIndex, &dwRead, NULL))
    {
        return GetLastError();
    }

    if(dwRead == 0)
    {
        // 
        // Empty file.  Write the trailer and we are done
        //

        m_nTransactionIndex = 1;

        lRes = WriteEmpty();
        if(lRes != ERROR_SUCCESS)
            return lRes;
        return lRes;
    }

    m_lFirstFreeOffset = GetStagingFileHeaderSize();

    //
    // Read complete transactions from the file until the end or until a 
    // corruption is found
    //

    lRes = ProcessBegin();
    if(lRes != ERROR_SUCCESS)
        return lRes;

    while((lRes = RecoverTransaction(hFile)) == ERROR_SUCCESS)
    {
        lRes = ProcessCommit();
        if(lRes != ERROR_SUCCESS)
            return lRes;

        lRes = ProcessBegin();
        if(lRes != ERROR_SUCCESS)
            return lRes;
    }

    if(lRes != ERROR_NO_MORE_ITEMS)
    {
        AbortTransaction();
        ERRORTRACE((LOG_WBEMCORE, "Incomplete or invalid transaction is "
            "found in the journal.  It and all subsequent transactions "
            "will be rolled back\n"));
        return ERROR_SUCCESS;
    }

    return ERROR_SUCCESS;
}
        
BYTE CRealStagingFile::ReadNextInstructionType(HANDLE hFile)
{
    BYTE nType;
    DWORD dwLen;
    if(!::ReadFile(hFile, &nType, sizeof nType, &dwLen, NULL))
        return -1;
    if(dwLen != sizeof nType)
        return -1;
    return nType;
}
    
long CRealStagingFile::RecoverTransaction(HANDLE hFile)
{
    long lRes;

    //
    // Remember the current file position to be able to go back
    //

    LARGE_INTEGER liStart;
    LARGE_INTEGER liZero;
    liZero.QuadPart = 0;
    if(!SetFilePointerEx(hFile, liZero, &liStart, FILE_CURRENT))
        return GetLastError();

    LARGE_INTEGER liInstructionStart = liStart;

    //
    // Read instructions until the end of transaction or an invalid instruction
    //

    int nNumInstructions = 0;

    BYTE nInstructionType;
    while((nInstructionType = ReadNextInstructionType(hFile)) != 
            A51_INSTRUCTION_TYPE_ENDTRANSACTION)
    {
        //
        // Create an instruction of the appropriate type
        //

        CFileInstruction* pInst = NULL;
        switch(nInstructionType)
        {
            case A51_INSTRUCTION_TYPE_CREATEFILE:
                pInst = new CCreateFile(this);
                break;
            case A51_INSTRUCTION_TYPE_DELETEFILE:
                pInst = new CDeleteFile(this);
                break;
            case A51_INSTRUCTION_TYPE_REMOVEDIRECTORY:
                pInst = new CRemoveDirectory(this);
                break;
            default:
                if(nNumInstructions == 0)
                    return ERROR_NO_MORE_ITEMS;
                else
                    return ERROR_RXACT_INVALID_STATE;
        }

        if(pInst == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        pInst->AddRef();
        CTemplateReleaseMe<CFileInstruction> rm1(pInst);
        
        //
        // Get it to read its data from the file
        //

        lRes = pInst->RecoverData(hFile);
        if(lRes != ERROR_SUCCESS)
            return lRes;

        lRes = AddInstruction(pInst);
        if(lRes != ERROR_SUCCESS)
            return lRes;

        //
        // Hash its body into the transaction
        //

        LARGE_INTEGER liInstructionEnd;
        if(!SetFilePointerEx(hFile, liZero, &liInstructionEnd, FILE_CURRENT))
            return GetLastError();

        if(!SetFilePointerEx(hFile, liInstructionStart, NULL, FILE_BEGIN))
            return GetLastError();

        DWORD dwBufferLen = (DWORD)(liInstructionEnd.QuadPart - 
                                            liInstructionStart.QuadPart);
        
        BYTE* pBuffer = (BYTE*)TempAlloc(dwBufferLen);
        if(pBuffer == NULL)
            return ERROR_OUTOFMEMORY;
        CTempFreeMe tfm(pBuffer, dwBufferLen);

        DWORD dwSizeRead;
        if(!::ReadFile(hFile, pBuffer, dwBufferLen, &dwSizeRead, NULL))
            return GetLastError();
    
        if(dwSizeRead != dwBufferLen)
            return ERROR_HANDLE_EOF;

        MD5::ContinueTransform(pBuffer, dwBufferLen, m_TransactionHash);

        liInstructionStart = liInstructionEnd;
        nNumInstructions++;
    }

    //
    // Read the hash that the end-of-transaction marker thinks we should have
    // gotten
    //

    BYTE DesiredHash[16];
    DWORD dwSizeRead;
    if(!::ReadFile(hFile, DesiredHash, sizeof DesiredHash, &dwSizeRead, NULL))
        return GetLastError();

    if(dwSizeRead != sizeof DesiredHash)
        return ERROR_HANDLE_EOF; 
    
    //
    // Compare them
    //

    if(memcmp(DesiredHash, m_TransactionHash, sizeof DesiredHash))
        return ERROR_RXACT_INVALID_STATE;

    //
    // Everything checked out --- set member variables for end of transaction
    //

    m_lFirstFreeOffset = (LONG)liInstructionStart.QuadPart;
    return ERROR_SUCCESS;
}

long CRealStagingFile::Create(LPCWSTR wszFileName)
{
    long lRes;

    //
    // Open the file itself
    //

    m_hFile = CreateFileW(wszFileName, GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 
                FILE_FLAG_OVERLAPPED, 
                NULL);

    if(m_hFile == INVALID_HANDLE_VALUE)
        return GetLastError();

    m_hFlushFile = m_hFile;

    m_lFirstFreeOffset = 0;

    //
    // Open a special synchronous handle to the same file for convenience
    //

    HANDLE hRecoveryFile = CreateFileW(wszFileName, 
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, 
                NULL);

    if(hRecoveryFile == INVALID_HANDLE_VALUE)
        return GetLastError();
    CCloseMe cm(hRecoveryFile);

    lRes = RecoverStage(hRecoveryFile);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    return ERROR_SUCCESS;
}

long CRealStagingFile::WriteEmpty()
{
    //
    // Construct a buffer consisting of the transaction index and a 0 for the
    // end-instruction
    //

    DWORD dwBufferSize = sizeof m_nTransactionIndex + A51_TAIL_SIZE;
    BYTE* pBuffer = (BYTE*)_alloca(dwBufferSize);

    memset(pBuffer, 0, dwBufferSize);
    memcpy(pBuffer, &m_nTransactionIndex, sizeof m_nTransactionIndex);

    long lRes = A51WriteToFileSync(m_hFile, 0, pBuffer, dwBufferSize);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Have to flush it to make sure that old instructions are not replayed
    //

/*
    if(!FlushFileBuffers(m_hFile))
        return GetLastError();
*/

    m_lFirstFreeOffset = GetStagingFileHeaderSize();
    m_lTransactionStartOffset = m_lFirstFreeOffset;

    return ERROR_SUCCESS;
}

CRealStagingFile::TIterator CRealStagingFile::EraseIterator(
                                    CRealStagingFile::TIterator it)
{
    //
    // In order to safely remove an iterator, we need to make sure that
    // no iteration handle is standing on it
    //

    for(int i = 0; i < m_apIterators.GetSize(); i++)
    {
        CIterationHandle* pHandle = m_apIterators[i];
        if(pHandle->m_it == it)
        {
            //
            // Advance it to the next position, since this one is dead
            //

            pHandle->m_it++;
        }
    }

    //
    // It is now safe to remove the element
    //
     
    return m_map.erase(it);
}

CRealStagingFile::CIterationHandle::CIterationHandle(
                    CRealStagingFile::TMap& rMap,
                    const CRealStagingFile::TIterator& rIt,
                    LPCWSTR wszPrefix)
    : m_rMap(rMap), m_it(rIt)
{
    wcscpy(m_wszPrefix, wszPrefix);
    m_dwPrefixLen = wcslen(wszPrefix);

    //
    // Compute the length of the directory portion of the prefix
    //

    WCHAR* pwcLastSlash = wcsrchr(wszPrefix, L'\\');
    if(pwcLastSlash == NULL)
        m_dwPrefixDirLen = 0;
    else
        m_dwPrefixDirLen = pwcLastSlash - wszPrefix + 1;
}

long CRealStagingFile::CIterationHandle::GetNext(WIN32_FIND_DATAW* pfd)
{
    //
    // Repeat while we are not at the end of the list or past the prefix
    //

    while(m_it != m_rMap.end() && 
            !wcsncmp(m_it->first, m_wszPrefix, m_dwPrefixLen))
    {
        CFileInstruction* pInst = m_it->second;
        
        //
        // Ignore deletioin requests
        //

        if(!m_it->second->IsDeletion())
        {
            //
            // Copy the file name (ignoring dir) into the variable
            //

            wcscpy(pfd->cFileName, 
                    m_it->second->GetFilePath() + m_dwPrefixDirLen);
            pfd->dwFileAttributes = 0;
			m_it++;
            return ERROR_SUCCESS;
        }
		m_it++;
    }

    return ERROR_NO_MORE_FILES;
}

//******************************************************************************
//******************************************************************************
//                      EXECUTABLE FILE
//******************************************************************************
//******************************************************************************

CExecutableStagingFile::CExecutableStagingFile(CFileCache* pCache, 
                            LPCWSTR wszBaseName, 
                            long lMaxFileSize, long lAbortTransactionFileSize)
    : CRealStagingFile(pCache, wszBaseName, lMaxFileSize, 
                        lAbortTransactionFileSize),
        m_bExitNow(false), m_hEvent(NULL), m_hThread(NULL)
{
}

CExecutableStagingFile::~CExecutableStagingFile()
{
    m_bExitNow = true;
    SetEvent(m_hEvent);
    WaitForSingleObject(m_hThread, INFINITE);
    CloseHandle(m_hEvent);
    CloseHandle(m_hThread);
}

long CExecutableStagingFile::Create(LPCWSTR wszFileName)
{
    long lRes = CRealStagingFile::Create(wszFileName);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Create a reading thread
    //

    m_hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(m_hEvent == NULL)
        return GetLastError();

    if(!m_qToWrite.empty())
        SignalPresense();

    DWORD dwId;
    m_hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)staticFlusher, 
                                (void*)this, 0, &dwId);
    if(m_hThread == NULL)
        return GetLastError();

    SetThreadPriority(m_hThread, THREAD_PRIORITY_IDLE);

    return ERROR_SUCCESS;
}


void CExecutableStagingFile::SignalPresense()
{
    SetEvent(m_hEvent);
}

long CExecutableStagingFile::WriteEmpty()
{
    ResetEvent(m_hEvent);

    return CRealStagingFile::WriteEmpty();
}

    
DWORD CExecutableStagingFile::staticFlusher(void* pArg)
{
    // Sleep(20000);
    return ((CExecutableStagingFile*)pArg)->Flusher();
}

DWORD CExecutableStagingFile::Flusher()
{
    while(!m_bExitNow)
    {
        WaitForSingleObject(m_hEvent, INFINITE);
        
        Flush();
    }
    return 0;
}

long CExecutableStagingFile::Flush()
{
    long lRes;

    //
    // Must flash when starting a new transaction
    //

    long lFlushLevel = m_lTransactionStartOffset;
/*
    if(!FlushFileBuffers(m_hFlushFile))
        DebugBreak();
*/

    while(1)
    {
        if(m_bExitNow)
            return ERROR_SUCCESS;

        //
        // Get the next instruction from the queue
        //

        CFileInstruction* pInst = NULL;

        {
            CInCritSec ics(&m_cs);
        
            if(m_qToWrite.empty())
            {
                //
                // Reset generation only if there are no instructions on the
                // transaction queue!
                //

                if(m_lTransactionStartOffset == m_lFirstFreeOffset)
                {
                    WriteEmpty();
                }
                return ERROR_SUCCESS;
            }

            pInst = m_qToWrite.front();

            //  
            // Check if it is in the map.  The reason it might not be there
            // is if it was superceeded by some later instruction over the same 
            // file.  In that case, we should not execute it, but rather simply 
            // skip it.
            //
            
            TIterator it = m_map.find(pInst->GetFilePath()); // Make KEY
            _ASSERT(it != m_map.end(), L"Instruction in queue not in map");

            if(it->second != pInst)
            {
				pInst->Release();
                m_qToWrite.pop();
                continue;
            }
        }
            
        //
        // Flush if needed
        //
    
        if(pInst->GetFileOffset() > lFlushLevel)
        {
            lFlushLevel = m_lTransactionStartOffset;
/*
            if(!FlushFileBuffers(m_hFlushFile))
                DebugBreak();
*/
        }

        //
        // Execute it
        //

        lRes = pInst->Execute();
        if(lRes != ERROR_SUCCESS)
        {
            //
            // We cannot continue until we succeed in executing this
            // instruction.  Therefore, we keep it on the queue and keep 
            // re-executing it.  If an instruction fails twice in a row, we 
            // enter a "failed state" and refuse all new transactions until the
            // condition is cleared
            //

            if(m_bFailedBefore)
            {
                ERRORTRACE((LOG_WBEMCORE, "Repository driver repeatedly failed "
                            "to execute an instruction with error code %d.\n"
                            "Further processing is suspended until the problem "
                            "is corrected\n", lRes));
                m_lStatus = lRes;
            }
            else
            {
                ERRORTRACE((LOG_WBEMCORE, "Repository driver failed "
                            "to execute an instruction with error code %d.\n",
                            lRes));
                m_bFailedBefore = true;
            }

            //
            // Wait a bit before retrying
            //
    
            Sleep(100);
            continue;
        }
        else
        {
            m_bFailedBefore = false;
            m_lStatus = ERROR_SUCCESS;
        }
        
        //  
        // Remove it from the map, if there.  The reason it might not be there
        // is if it was superceeded by some later instruction over the same 
        // file.  We could check this before we executed it, but it wouldn't 
        // help much since the overriding instruction could have come in while
        // we were executing.  Also, there might be issues with instructions
        // constantly overriding each other and us never writing anything 
        // because of that...
        //
            
        {
            //
            // Here, we are going to be removing the instruction from the 
            // map.  We must lock the entire file cache to prevent the reader
            // from missing both the side effects (we executed without locking)
            // and the instruction itself if it is removed before the reader
            // gets a chance to lock the stage in IsDeleted.
            //

            CInCritSec ics(m_pCache->GetLock());
            {
                CInCritSec ics(&m_cs);
    
                TIterator it = m_map.find(pInst->GetFilePath()); // Make KEY
                _ASSERT(it != m_map.end(), L"Instruction in queue not in map");
    
                if(it->second == pInst)
                {
                    EraseIterator(it);
                    pInst->Release();
                }

                //
                // Remove it from the queue
                //

                m_qToWrite.pop();
                pInst->Release();

                if(m_qToWrite.empty())
                {
                    //
                    // Reset generation only if there are no instructions on the
                    // transaction queue!
                    //

                    if(m_lTransactionStartOffset == m_lFirstFreeOffset)
                    {
                        WriteEmpty();
                    }
                    return ERROR_SUCCESS;
                }
            }
        }
    }

    _ASSERT(false, L"Out of an infinite loop!");
    return ERROR_INTERNAL_ERROR;
}
                
//******************************************************************************
//******************************************************************************
//                     PERMANENT FILE
//******************************************************************************
//******************************************************************************

CPermanentStagingFile::CPermanentStagingFile(CFileCache* pCache, 
                                                LPCWSTR wszBaseName)
    : CRealStagingFile(pCache, wszBaseName, 0x7FFFFFFF, 0x7FFFFFFF)
{
}

CPermanentStagingFile::~CPermanentStagingFile()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\adapelem.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADAPELEM.CPP

Abstract:

    Implementation File

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "adapelem.h"

CAdapElement::CAdapElement( void )
: m_lRefCount(1)
{
}

CAdapElement::~CAdapElement( void )
{
}

long CAdapElement::AddRef( void )
{
    return InterlockedIncrement( &m_lRefCount );
}

long CAdapElement::Release( void )
{
    long    lRef = InterlockedDecrement( &m_lRefCount );

    if ( 0 == lRef )
    {
        delete this;
    }

    return lRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\adapcls.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADAPCLS.H

Abstract:

History:

--*/


#ifndef __ADAPCLS_H__
#define __ADAPCLS_H__

#include <windows.h>
#include <wbemcomn.h>
#include <wbemcli.h>
#include <wbemint.h>
#include <winperf.h>
#include <wstlallc.h>
#include "adapelem.h"
#include "perfndb.h"

#include <comdef.h>
#include <map>

// Global constants
// ================

#define ADAP_DEFAULT_OBJECT				238L
#define ADAP_DEFAULT_NDB				L"009"
#define ADAP_DEFAULT_LANGID				0x0409L
#define ADAP_ROOT_NAMESPACE				L"\\\\.\\root\\cimv2"

#define ADAP_PERF_CIM_STAT_INFO			L"CIM_StatisticalInformation"
#define ADAP_PERF_BASE_CLASS			L"Win32_Perf"
#define ADAP_PERF_RAW_BASE_CLASS		L"Win32_PerfRawData"
#define ADAP_PERF_COOKED_BASE_CLASS		L"Win32_PerfFormattedData"

enum ClassTypes
{
	WMI_ADAP_RAW_CLASS,
	WMI_ADAP_COOKED_CLASS,
	WMI_ADAP_NUM_TYPES
};

// Class list element states
// =========================

#define ADAP_OBJECT_IS_REGISTERED		0x0001L		// Object is in WMI
#define ADAP_OBJECT_IS_DELETED			0x0002L		// Object is marked for deletion
#define ADAP_OBJECT_IS_INACTIVE			0x0004L		// Perflib did not respond
#define ADAP_OBJECT_IS_NOT_IN_PERFLIB	0x0008L		// Object is from an unloaded perflib
#define ADAP_OBJECT_IS_TO_BE_CLEARED	0x0010L		// Need to clear registry


class CLocaleDefn : public CAdapElement
///////////////////////////////////////////////////////////////////////////////
//
//	Contains all of the locale information
//
///////////////////////////////////////////////////////////////////////////////
{
protected:

// Localization values
// ===================

	WString				m_wstrLangId;		// "009"
	WString				m_wstrLocaleId;		// "0x0409"
	WString				m_wstrSubNameSpace;	// "MS_409"
	LANGID				m_LangId;			// 0x0409
	LCID				m_LocaleId;			// 0x0409

// WMI Locale data members
// =======================

	IWbemServices*		m_pNamespace;
	IWbemClassObject*	m_apBaseClass[WMI_ADAP_NUM_TYPES];


// Localized Names' Database
// =========================

	CPerfNameDb*		m_pNameDb;

// Operational members
// ===================

	BOOL			m_bOK;
	HRESULT         m_hRes;

// Protected Methods
// =================

	HRESULT Initialize();
	HRESULT InitializeWMI();
	HRESULT InitializeLID();

public:
	CLocaleDefn( WCHAR* pwcsLangId, 
	             HKEY hKey );
	virtual ~CLocaleDefn();

	HRESULT GetLID( int* pnLID );
	HRESULT GetNamespaceName( WString & wstrNamespaceName );
	HRESULT GetNamespace( IWbemServices** ppNamespace );
	HRESULT GetNameDb( CPerfNameDb** ppNameDb );
	HRESULT GetBaseClass( DWORD dwType, IWbemClassObject** pObject );
	HRESULT GetCookedBaseClass( IWbemClassObject** pObject );

	BOOL	IsOK(){ return m_bOK; }
	HRESULT GetHRESULT(){ return m_hRes; };
};


class CLocaleCache : public CAdapElement 
///////////////////////////////////////////////////////////////////////////////
//
//	The cache used to manage locale definitions
//
///////////////////////////////////////////////////////////////////////////////
{
protected:

	// The enumeration index
	// =====================
	int		m_nEnumIndex;

	// The array of locale definition structures
	// =========================================
	CRefedPointerArray<CLocaleDefn>	m_apLocaleDefn;

public:
	CLocaleCache( );
	virtual ~CLocaleCache();

	HRESULT Initialize();
	HRESULT Reset();

	HRESULT GetDefaultDefn( CLocaleDefn** ppDefn );

	HRESULT BeginEnum();
	HRESULT Next( CLocaleDefn** ppLocaleDefn );
	HRESULT EndEnum();
};

// forward
class CKnownSvcs;

class CClassElem : public CAdapElement
////////////////////////////////////////////////////////////////////////////////
//
//	CClassElem
//
////////////////////////////////////////////////////////////////////////////////
{
protected:

// Class properties
// ================

	WString				m_wstrClassName;		// The class name

	DWORD				m_dwIndex;				// The class perf index
	WString				m_wstrServiceName;		// The service name for which the class is a member
	BOOL				m_bCostly;				// The performance type
	BOOL                m_bReportEventCalled;    // did we log something about this in the past

// WMI related
// ===========

	IWbemClassObject*	m_pDefaultObject;		// The WMI class definition

// Operational members
// ===================

	CLocaleCache*		m_pLocaleCache;			// Pointer to the list of locales

	DWORD				m_dwStatus;				// The state of the element
	BOOL				m_bOk;					// The initialization state of this object
	CKnownSvcs *        m_pKnownSvcs;

// Methods 
// =======

	HRESULT VerifyLocales();

	HRESULT InitializeMembers();
	BOOL IsPerfLibUnloaded();

	HRESULT Remove(BOOL CleanRegistry);
	HRESULT Insert();
	HRESULT InsertLocale( CLocaleDefn* pLocaleDefn );
	HRESULT CompareLocale( CLocaleDefn* pLocaleDefn, IWbemClassObject* pObj );
	
public:
	CClassElem(IWbemClassObject* pObj, 
	           CLocaleCache* pLocaleCache, 
	           CKnownSvcs * pKnownSvcs = NULL );
	           
	CClassElem(PERF_OBJECT_TYPE* pPerfObj, 
	           DWORD dwType, BOOL bCostly, 
	           WString wstrServiceName, 
	           CLocaleCache* pLocaleCache, 
	           CKnownSvcs * pKnownSvcs = NULL );
	           
	virtual ~CClassElem();

	HRESULT UpdateObj( CClassElem* pEl );

	HRESULT Commit();

	HRESULT GetClassName( WString& wstr );
	HRESULT GetClassName( BSTR* pbStr );
	HRESULT GetObject( IWbemClassObject** ppObj );
	HRESULT GetServiceName( WString & wstrServiceName );

	BOOL SameName( CClassElem* pEl );
	BOOL SameObject( CClassElem* pEl );

    DWORD   GetStatus(void){ return m_dwStatus; };
	HRESULT SetStatus( DWORD dwStatus );
	HRESULT ClearStatus( DWORD dwStatus );
	BOOL	CheckStatus( DWORD dwStatus );

	BOOL IsOk( void ) {	return m_bOk; }
	VOID SetKnownSvcs(CKnownSvcs * pKnownSvcs);
};

class CClassList : public CAdapElement
///////////////////////////////////////////////////////////////////////////////
//
//	The base class for caches which manage either the Master class list 
//	currently in WMI, or the classes found within a given perflib.  The 
//	classes are managed as class information elements.
//
///////////////////////////////////////////////////////////////////////////////
{
protected:

	// The array of class elements
	// ===========================

	CRefedPointerArray<CClassElem>	m_array;

	// Pointer to the list of locales
	// ==============================

	CLocaleCache*	m_pLocaleCache;

	// Operational members
	// ===================

	int				m_nEnumIndex;
	BOOL			m_fOK;

	HRESULT AddElement( CClassElem* pEl );
	HRESULT	RemoveAt( int nIndex );

	long GetSize( void ) { return m_array.GetSize(); }

public:
	CClassList( CLocaleCache* pLocaleCache );
	virtual ~CClassList();

	BOOL	IsOK(){ return m_fOK; }

	HRESULT BeginEnum();
	HRESULT Next( CClassElem** ppEl );
	HRESULT EndEnum();
};


class CPerfClassList : public CClassList
///////////////////////////////////////////////////////////////////////////////
//
//	The class cache for classes found in performance libraries
//
///////////////////////////////////////////////////////////////////////////////
{
protected:

	// The service name for which this list belongs
	// ============================================

	WString			m_wstrServiceName;

	HRESULT AddElement( CClassElem *pEl );

public:
	CPerfClassList( CLocaleCache* pLocaleCache, WCHAR* pwcsServiceName );
	HRESULT AddPerfObject( PERF_OBJECT_TYPE* pObj, DWORD dwType, BOOL bCostly );
};


class ServiceRec
{
friend class CKnownSvcs;
    
private:
    bool    m_IsServiceThere;
    bool    m_bReportEventCalled;
public:
    ServiceRec(bool IsThere = false,bool EventCalled = false):m_IsServiceThere(IsThere),m_bReportEventCalled(false){};
    bool IsThere(){ return m_IsServiceThere; };
    bool IsELCalled(){ return m_bReportEventCalled; };
    void SetELCalled(){ m_bReportEventCalled = true;};
};    

typedef wbem_allocator<bool> BoolAlloc;

class WCmp{
public:
	bool operator()(WString pFirst,WString pSec) const;
};

typedef std::map<WString,ServiceRec,WCmp, BoolAlloc > MapSvc;

class CKnownSvcs
{
public:
    CKnownSvcs();
    ~CKnownSvcs();
    DWORD Load();
    DWORD Save();
    DWORD Add(WCHAR * pService);
    DWORD Remove(WCHAR * pService);
    DWORD Get(WCHAR * pService,ServiceRec ** ppServiceRec);
    
    LONG AddRef(){
        return InterlockedIncrement(&m_cRef);
    };
    LONG Release(){
        LONG lRet = InterlockedDecrement(&m_cRef);
        if (0 == lRet){
            delete this;
        }
        return lRet;
    }
private:
    LONG m_cRef;
    MapSvc m_SetServices; 
};


class CMasterClassList : public CClassList
///////////////////////////////////////////////////////////////////////////////
//
//	The class cache for classes found in the WMI repository
//
///////////////////////////////////////////////////////////////////////////////
{
protected:

    CKnownSvcs * m_pKnownSvcs;

	HRESULT AddElement( CClassElem *pEl, BOOL bDelta );
	HRESULT AddClassObject( IWbemClassObject* pObj, BOOL bSourceWMI, BOOL bDelta );

public:
	CMasterClassList( CLocaleCache* pLocaleCache, CKnownSvcs * pCKnownSvcs );
	~CMasterClassList();

	HRESULT	BuildList( WCHAR* wszBaseClass, BOOL bDelta, BOOL bThrottle );
	HRESULT Merge( CClassList* pClassList, BOOL bDelta );
	HRESULT Commit(BOOL bThrottle);
	HRESULT ForceStatus(WCHAR* pServiceName,BOOL bSet,DWORD dwStatus);
	
#ifdef _DUMP_LIST	
	HRESULT Dump();
#endif	

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\adapcls.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADAPCLS.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <wbemcli.h>
#include <throttle.h>
#include <cominit.h>
#include <winmgmtr.h>
#include "perfndb.h"
#include "adaputil.h"
#include "adapreg.h"
#include "ntreg.h"
#include "WMIBroker.h"
#include "ClassBroker.h"
#include "adapcls.h"

#include <comdef.h>

extern HANDLE g_hAbort;

struct _BaseClassTypes
{
	WCHAR	m_wszBaseClassName[128];
} 
g_aBaseClass[WMI_ADAP_NUM_TYPES] =
{
	ADAP_PERF_RAW_BASE_CLASS,
	ADAP_PERF_COOKED_BASE_CLASS
};

CLocaleDefn::CLocaleDefn( WCHAR* pwcsLangId, 
                          HKEY hKey ) 
: m_wstrLangId( pwcsLangId ), 
  m_LangId( 0 ),
  m_LocaleId( 0 ),
  m_pNamespace( NULL ), 
  m_pNameDb( NULL ),
  m_bOK( FALSE ),
  m_hRes(WBEM_E_FAILED)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	// Initialize the base class array
	// ===============================

	memset( m_apBaseClass, NULL, WMI_ADAP_NUM_TYPES * sizeof( IWbemClassObject* ) );

    // A NULL means it is the default locale
    // =====================================

    if ( NULL != pwcsLangId )
    {
        hr = InitializeLID();
    }

    // Initialize the namespace and base class and verify their schema
    // ===============================================================

    if ( SUCCEEDED( hr ) )
    {
        hr = InitializeWMI();
    }

    // Create the names' database for the locale
    // =========================================

    if ( SUCCEEDED( hr ) )
    {
        m_pNameDb = new CPerfNameDb( hKey );

        if ( ( NULL == m_pNameDb ) || ( !m_pNameDb->IsOk() ) )
        {
            if ( NULL != m_pNameDb )
            {
                m_pNameDb->Release();
                m_pNameDb = NULL;
            }
            
            ERRORTRACE((LOG_WMIADAP,"failure in loading HKEY %p for locale %S err: %d\n",hKey,(LPCWSTR)pwcsLangId,GetLastError()));
            
            hr = WBEM_E_FAILED;
        }
    }

    // If every thing work out, then set the initialization flag
    // =========================================================

    if ( SUCCEEDED( hr ) )
    {
        m_bOK = TRUE;
    }
    else
    {
        m_hRes = hr;
    }
}

CLocaleDefn::~CLocaleDefn()
{
    if ( NULL != m_pNamespace )
        m_pNamespace->Release();

	for ( DWORD dw = 0; dw < WMI_ADAP_NUM_TYPES; dw++ )
	{
		if ( NULL != m_apBaseClass[dw] )
			m_apBaseClass[dw]->Release();
	}

    if ( NULL != m_pNameDb )
        m_pNameDb->Release();
}

HRESULT CLocaleDefn::InitializeLID()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    LPCWSTR pwstrLangId = (LPWSTR) m_wstrLangId;

    // Get the length of the text LID
    // ==============================

    DWORD   dwLangIdLen = m_wstrLangId.Length();

    // Ensure that all characters are numeric
    // ======================================

    for ( DWORD dwCtr = 0; dwCtr < dwLangIdLen && iswxdigit( pwstrLangId[dwCtr] ); dwCtr++ );

    if ( dwCtr >= dwLangIdLen )
    {
        // Now look for the first non-zero character
        // =========================================

        LPCWSTR pwcsNumStart = pwstrLangId;

        for ( dwCtr = 0; dwCtr < dwLangIdLen && *pwcsNumStart == L'0'; dwCtr++, pwcsNumStart++ );

        // As long as the LID was not all zeros and the LID is 
        // 3 digits or less convert the LID to a number
        // ===================================================

        if ( dwCtr < dwLangIdLen && wcslen( pwcsNumStart ) <= 3 )
        {
            // Convert the LID to a hex value
            // ==============================

            WORD    wPrimaryLangId = (WORD) wcstoul( pwcsNumStart, NULL, 16 );

			// If we are reading the default system id, ensure that we have
			// the proper sublanguage and then convert to the member types
			// ============================================================

			LANGID wSysLID = GetSystemDefaultUILanguage();

			if ( ( wSysLID & 0x03FF ) == wPrimaryLangId )
			{
				m_LangId = wSysLID;
			}
			else
			{
				m_LangId = MAKELANGID( wPrimaryLangId, SUBLANG_DEFAULT );
			}

            m_LocaleId = MAKELCID( m_LangId, SORT_DEFAULT );

            WCHAR   wcsTemp[32];

            swprintf( wcsTemp, L"0x%.4X", m_LangId );
            m_wstrLocaleId = wcsTemp;

            swprintf( wcsTemp, L"MS_%hX", m_LangId );
            m_wstrSubNameSpace = wcsTemp;
        }
        else
        {
            hr = WBEM_E_FAILED;
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}

HRESULT CLocaleDefn::InitializeWMI()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Initialize the namespace name
    // =============================

    WString wstrNamespace;

    try
    {
        wstrNamespace = ADAP_ROOT_NAMESPACE;

        if ( 0 != m_LangId )
        {
            wstrNamespace += L"\\";
            wstrNamespace += m_wstrSubNameSpace;
        }
    }
    catch(CX_MemoryException)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    // Initialize the localization namespace
    // =====================================

    if ( SUCCEEDED( hr ) )
    {
        hr = CWMIBroker::GetNamespace( wstrNamespace, &m_pNamespace );       
    }

    // Initialize the base classes
    // ===========================

	for ( DWORD dwBase = 0; ( dwBase < WMI_ADAP_NUM_TYPES ) && SUCCEEDED( hr ); dwBase++ )
	{
        BSTR        bstrBaseClass = SysAllocString( g_aBaseClass[dwBase].m_wszBaseClassName );
        CSysFreeMe  sfmBaseClass( bstrBaseClass );

        hr = m_pNamespace->GetObject( bstrBaseClass, 0L, NULL, (IWbemClassObject**)&m_apBaseClass[dwBase], NULL );
    }

    return hr;
}

HRESULT CLocaleDefn::GetLID( int* pnLID )
{
    *pnLID = m_LangId;

    return WBEM_S_NO_ERROR;
}

HRESULT CLocaleDefn::GetNamespaceName( WString & wstrNamespaceName )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    try
    {
        wstrNamespaceName = ADAP_ROOT_NAMESPACE;

        if ( 0 != m_LangId )
        {
            wstrNamespaceName += L"\\";
            wstrNamespaceName += m_wstrSubNameSpace;
        }
     }
    catch(CX_MemoryException)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CLocaleDefn::GetNamespace( IWbemServices** ppNamespace )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    *ppNamespace = m_pNamespace;

    if ( NULL != *ppNamespace )
    {
        (*ppNamespace)->AddRef();
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}

HRESULT CLocaleDefn::GetNameDb( CPerfNameDb** ppNameDb )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    *ppNameDb = m_pNameDb;

    if ( NULL != *ppNameDb )
    {
        (*ppNameDb)->AddRef();
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}

HRESULT CLocaleDefn::GetBaseClass( DWORD dwType, IWbemClassObject** ppObject )
{
    HRESULT hr = WBEM_S_NO_ERROR;

	if ( dwType < WMI_ADAP_NUM_TYPES )
	{
		if ( NULL != m_apBaseClass[ dwType ] )
		{
			*ppObject = m_apBaseClass[ dwType ];
			(*ppObject)->AddRef();
		}
		else
		{
			hr = WBEM_E_FAILED;
		}
	}

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
//  CLocaleCache
//
////////////////////////////////////////////////////////////////////////////////

CLocaleCache::CLocaleCache( )
: m_nEnumIndex( -1 )
{
}

CLocaleCache::~CLocaleCache()
{
}

HRESULT CLocaleCache::Reset()
{
	HRESULT hr = WBEM_NO_ERROR;

	m_apLocaleDefn.RemoveAll();
	Initialize();

	return hr;
}

HRESULT CLocaleCache::Initialize()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CNTRegistry     reg;
    CLocaleDefn*    pDefn = NULL;
    DWORD           dwIndex = 0;
    long            lError = 0;

    // Setup the default defn
    // ======================

    pDefn = new CLocaleDefn( NULL, HKEY_PERFORMANCE_TEXT );
    CAdapReleaseMe  arm( pDefn );
    if ( ( NULL != pDefn ) && ( pDefn->IsOK() ) )
    {
        m_apLocaleDefn.Add( pDefn );

        LANGID wSysLID = GetSystemDefaultUILanguage();
        WCHAR pLang[8];
        wsprintfW(pLang,L"%03x",0x3FF & wSysLID);

        pDefn = new CLocaleDefn( pLang, HKEY_PERFORMANCE_NLSTEXT );
        CAdapReleaseMe  armDefn( pDefn );

        if ( ( NULL != pDefn ) && ( pDefn->IsOK() ) )
        {
            m_apLocaleDefn.Add( pDefn );
        }
        else // this is likely to be the NLSTEXT bug
        {
            CLocaleDefn* pDefn2 = new CLocaleDefn( pLang, HKEY_PERFORMANCE_TEXT );
            CAdapReleaseMe  armDefn2( pDefn2 );

            if ( ( NULL != pDefn2 ) && ( pDefn2->IsOK() ) )
            {
                m_apLocaleDefn.Add( pDefn2 );
            }
        }
    } 
    else 
    {
        
        ERRORTRACE((LOG_WMIADAP,"CLocaleDefn failed hr = %08x\n",pDefn->GetHRESULT()));
        hr = WBEM_E_FAILED;
    }

    return hr;
}

HRESULT CLocaleCache::GetDefaultDefn( CLocaleDefn** ppDefn )
{
    HRESULT hr = WBEM_E_FAILED;

    // Get the definition at location 0
    // ================================

    int nLID = -1;

    if ( 0 < m_apLocaleDefn.GetSize() )
    {
        CLocaleDefn*    pDefn = m_apLocaleDefn[0];

        // And verify that it has a locale of 0
        // ====================================

        if ( NULL != pDefn )
        {
            hr = pDefn->GetLID( &nLID );
        }

        if ( SUCCEEDED( hr ) && ( 0 == nLID ) )
        {
            *ppDefn = pDefn;
            (*ppDefn)->AddRef();
        }
    }

    return hr;
}

HRESULT CLocaleCache::BeginEnum( )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // 1 is the first localized defnintion
    // ===================================

    m_nEnumIndex = 1;

    return hr;
}

HRESULT CLocaleCache::Next( CLocaleDefn** ppDefn )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CLocaleDefn*    pDefn = NULL;
    int             nSize = m_apLocaleDefn.GetSize();

    if ( ( -1 < m_nEnumIndex ) && ( nSize > m_nEnumIndex ) )
    {
        pDefn = m_apLocaleDefn[m_nEnumIndex++];
    }
    else
    {
        m_nEnumIndex = -1;
        hr = WBEM_E_FAILED;
    }

    if ( SUCCEEDED( hr ) )
    {
        *ppDefn = pDefn;

        if ( NULL != *ppDefn )
            (*ppDefn)->AddRef();
        else
            hr = WBEM_E_FAILED;
    }

    return hr;
}

HRESULT CLocaleCache::EndEnum()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    m_nEnumIndex = -1;

    return hr;
}

//
//
//   Known Service
//
///////////////////////////////////////////////////////////

//
//
//

bool
WCmp::operator()(WString pFirst,WString pSec) const
{

	int res = _wcsicmp(pFirst,pSec);

	return (res<0);
}



CKnownSvcs::CKnownSvcs():
    m_cRef(1)
{
}

CKnownSvcs::~CKnownSvcs()
{
}

DWORD 
CKnownSvcs::Add(WCHAR * pService)
{
    if (pService)
    {
        MapSvc::iterator it = m_SetServices.find(pService);
        if (it == m_SetServices.end())
        {
            try 
			{	
                m_SetServices.insert(MapSvc::value_type(pService,ServiceRec(true)));
            } 
			catch (CX_MemoryException) 
			{
                return ERROR_OUTOFMEMORY;
            }
        }
        return 0;
    }
    else
        return ERROR_INVALID_PARAMETER;
}

DWORD
CKnownSvcs::Get(WCHAR * pService, ServiceRec ** ppServiceRec)
{
    if (pService && ppServiceRec)
    {
        MapSvc::iterator it = m_SetServices.find(pService);
        if (it == m_SetServices.end())
        {
            *ppServiceRec = NULL;
            return ERROR_OBJECT_NOT_FOUND;
        }
        else
        {
            *ppServiceRec = &(it->second);
            return 0;
        }
    }
    else
        return ERROR_INVALID_PARAMETER;
}


DWORD 
CKnownSvcs::Remove(WCHAR * pService)
{
    if (pService)
    {
        MapSvc::iterator it = m_SetServices.find(pService);
        if (it != m_SetServices.end())
        {
            try {
                m_SetServices.erase(it);
            } catch (CX_MemoryException) {
                return ERROR_OUTOFMEMORY;
            }
        }
        return 0;
    }
    else
        return ERROR_INVALID_PARAMETER;
}

DWORD 
CKnownSvcs::Load()
{
    // get the MULTI_SZ key
    LONG lRet;
    HKEY hKey;
    
    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        WBEM_REG_WINMGMT,
                        NULL,
                        KEY_READ,
                        &hKey);
                        
    if (ERROR_SUCCESS == lRet)
    {
        DWORD dwSize = 0;
        DWORD dwType = REG_MULTI_SZ;

        lRet = RegQueryValueEx(hKey,
                               KNOWN_SERVICES,
                               NULL,
                               &dwType,
                               NULL,
                               &dwSize);
                               
        if (ERROR_SUCCESS == lRet && (dwSize > 0))
        {
            TCHAR * pStr = new TCHAR[dwSize];

            if (pStr)
            {
                CVectorDeleteMe<TCHAR>  vdm(pStr);
	            lRet = RegQueryValueEx(hKey,
	                               KNOWN_SERVICES,
	                               NULL,
	                               &dwType,
	                               (BYTE *)pStr,
	                               &dwSize);
	            if (ERROR_SUCCESS == lRet)
	            {
	                DWORD dwLen = 0;
	                while(dwLen = lstrlen(pStr))
	                {
	                    try 
	                    {
	                        m_SetServices.insert(MapSvc::value_type(pStr,ServiceRec(true)));
	                        pStr += (dwLen+1);
	                    } 
	                    catch (CX_MemoryException) 
	                    {
	                        lRet = ERROR_OUTOFMEMORY;
	                        break;
	                    }
	                }
	            }
            }
            else
            {
                lRet = ERROR_OUTOFMEMORY;
            }
        }

        RegCloseKey(hKey);
    }

    return lRet;
}

DWORD 
CKnownSvcs::Save()
{
    // Write the MULTI_SZ key
    
    MapSvc::iterator it;
    DWORD dwAllocSize = 1; // the trailing \0
    
    for (it = m_SetServices.begin();it != m_SetServices.end();++it)
    {
        dwAllocSize += (1+lstrlenW( (*it).first ));
    }

    WCHAR * pMultiSz = new WCHAR[dwAllocSize];

    if (!pMultiSz)
        return ERROR_NOT_ENOUGH_MEMORY;
        
    WCHAR * pTmp = pMultiSz;
    for (it = m_SetServices.begin();it != m_SetServices.end();++it)
    {
        const WCHAR * pSrc = (const wchar_t *)it->first;
        DWORD i;
        for (i=0;pSrc[i];i++){
            *pTmp = pSrc[i];
             pTmp++;
        };
        *pTmp = L'\0';
        pTmp++;
    };
    // last char
    *pTmp = L'\0';
    
    DWORD dwSize;
    LONG lRet;
    HKEY hKey;
    
    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        WBEM_REG_WINMGMT,
                        NULL,
                        KEY_WRITE,
                        &hKey);
                        
    if (ERROR_SUCCESS == lRet)
    {
        lRet = RegSetValueEx(hKey,
                             KNOWN_SERVICES,
                             NULL,
                             REG_MULTI_SZ,
                             (BYTE*)pMultiSz,
                             dwAllocSize * sizeof(WCHAR));
        
        RegCloseKey(hKey);    
    }

    if (pMultiSz)
        delete [] pMultiSz;

    return lRet;

}

////////////////////////////////////////////////////////////////////////////////
//
//  CClassElem
//
////////////////////////////////////////////////////////////////////////////////

CClassElem::CClassElem( IWbemClassObject* pObj, 
                        CLocaleCache* pLocaleCache, 
                        CKnownSvcs * pKnownSvcs) 
: m_pLocaleCache( pLocaleCache ), 
  m_pDefaultObject( pObj ), 
  m_dwIndex( 0 ), 
  m_bCostly( FALSE ),
  m_dwStatus( 0 ),
  m_bOk( FALSE ),
  m_pKnownSvcs(pKnownSvcs),
  m_bReportEventCalled(FALSE)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( NULL != m_pKnownSvcs)
        m_pKnownSvcs->AddRef();

    if ( NULL != m_pLocaleCache )
    {
        m_pLocaleCache->AddRef();
    }

    if ( NULL != m_pDefaultObject )
    {
        m_pDefaultObject->AddRef();
        hr = InitializeMembers();
    }

    if ( SUCCEEDED( hr )  && ( NULL != m_pLocaleCache ) && ( NULL != m_pDefaultObject ) )
    {
        m_bOk = TRUE;
    }    
}

CClassElem::CClassElem( PERF_OBJECT_TYPE* pPerfObj, 
					    DWORD dwType,
					    BOOL bCostly, 
						WString wstrServiceName, 
						CLocaleCache* pLocaleCache,
						CKnownSvcs * pKnownSvcs)
: m_pLocaleCache( pLocaleCache ), 
  m_pDefaultObject( NULL ), 
  m_dwIndex( 0 ), 
  m_bCostly( bCostly ),
  m_dwStatus( 0 ),
  m_bOk( FALSE ),
  m_wstrServiceName( wstrServiceName ),
  m_pKnownSvcs(pKnownSvcs),
  m_bReportEventCalled(FALSE)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CLocaleDefn*		pDefn = NULL;
    IWbemClassObject*   pBaseClass = NULL;
    CPerfNameDb*		pNameDb = NULL;

    if ( NULL != m_pKnownSvcs)
        m_pKnownSvcs->AddRef();

    if ( NULL != m_pLocaleCache )
    {
        m_pLocaleCache->AddRef();

        // Get the default locale record
        // =============================
        hr = m_pLocaleCache->GetDefaultDefn( &pDefn );
        CAdapReleaseMe  rmDefn( pDefn );

        // Get the names' database
        // =======================
        if ( SUCCEEDED( hr ) )
        {
            hr = pDefn->GetNameDb( &pNameDb );
        }
        CAdapReleaseMe  rmNameDb( pNameDb );

		// Create the requested class
		// ==========================
        if ( SUCCEEDED( hr ) )
        {
            hr = pDefn->GetBaseClass( dwType, &pBaseClass );
        }
        CReleaseMe  rmBaseClass( pBaseClass );

        if ( SUCCEEDED( hr ) )
        {
            hr = CDefaultClassBroker::GenPerfClass( pPerfObj, 
													dwType,
                                                    m_bCostly, 
                                                    pBaseClass, 
                                                    pNameDb, 
                                                    m_wstrServiceName, 
                                                    &m_pDefaultObject );
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    // Initialize the class members
    // ============================

    if ( SUCCEEDED( hr ) )
    {
        hr = InitializeMembers();
    }

    if ( SUCCEEDED( hr ) )
    {
        m_bOk = TRUE;
    }
}

VOID
CClassElem::SetKnownSvcs(CKnownSvcs * pKnownSvcs)
{
    if (m_pKnownSvcs)
        return;
        
    m_pKnownSvcs = pKnownSvcs;
    
    if (m_pKnownSvcs)
        m_pKnownSvcs->AddRef();
}

CClassElem::~CClassElem()
{
    if ( NULL != m_pLocaleCache )
        m_pLocaleCache->Release();

    if ( NULL != m_pDefaultObject )
        m_pDefaultObject->Release();

    if (m_pKnownSvcs)
        m_pKnownSvcs->Release();
}

HRESULT CClassElem::InitializeMembers()
// If the class name is unavaiable, then the initialization fails.  It is not a fatal error if a qualifier is unavailable
{
    HRESULT hr = WBEM_NO_ERROR;
	VARIANT var;

    try
    {
        // Get the object's name
        // =====================
        if ( SUCCEEDED( hr ) )
        {
            hr = m_pDefaultObject->Get(L"__CLASS", 0L, &var, NULL, NULL );

            if ( SUCCEEDED( hr ) )
            {
                m_wstrClassName = var.bstrVal;
                VariantClear( &var );
            }
        }

        if ( SUCCEEDED( hr ) )
        {
			IWbemQualifierSet* pQualSet = NULL;
			hr = m_pDefaultObject->GetQualifierSet( &pQualSet );
			CReleaseMe	rmQualSet( pQualSet );

	        // Get the service name
		    // ====================
			if ( SUCCEEDED( hr ) )
			{
				hr =  pQualSet->Get( L"registrykey", 0L, &var, NULL );

				if ( SUCCEEDED( hr ) )
				{
					m_wstrServiceName = var.bstrVal;
					VariantClear( &var );
				}
				else
				{
					m_wstrServiceName.Empty();
					hr = WBEM_S_FALSE;
				}
			}

			// Get the perf index
			// ==================

			if ( SUCCEEDED( hr ) )
			{
				hr = pQualSet->Get( L"perfindex", 0L, &var, NULL );

				if ( SUCCEEDED( hr ) )
				{
					m_dwIndex = var.lVal;
					VariantClear( &var );
				}   
				else
				{
					m_dwIndex = 0;
					hr = WBEM_S_FALSE;
				}
			}

			// Get the costly qualifier
			// ========================

			if ( SUCCEEDED( hr ) )
			{
				hr = pQualSet->Get( L"costly", 0L, &var, NULL );

				if ( SUCCEEDED( hr ) )
				{
					m_bCostly = ( var.boolVal == VARIANT_TRUE );
					VariantClear( &var );
				}
				else
				{
					VariantClear( &var );
					m_bCostly = FALSE;
					hr = WBEM_NO_ERROR;
				}
			}
		}
    }
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CClassElem::UpdateObj( CClassElem* pEl )
// Replaces the WMI object in this element.  The commit will do a CompareTo to compare the 
// original object (if it exists) and replace it with the updated version
{
    HRESULT hr = WBEM_S_NO_ERROR;

    IWbemClassObject* pObj = NULL;

    hr = pEl->GetObject( &pObj );

    if ( SUCCEEDED( hr ) )
    {
        if ( NULL != pObj )
        {
            // Release the old object
            // ======================

            m_pDefaultObject->Release();

            // Initialize the new object - already addref'd by GetObject
            // =========================================================

            m_pDefaultObject = pObj;
        }
        else
        {
            hr = WBEM_E_FAILED;
        }
    }

    return hr;
}

HRESULT CClassElem::Remove(BOOL CleanRegistry)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    IWbemServices* pNamespace = NULL;
    BSTR        bstrClassName = SysAllocString( m_wstrClassName );
    CSysFreeMe  sfmClassName( bstrClassName );

    // Delete the localized objects
    // ============================

    CLocaleDefn* pDefn = NULL;

    m_pLocaleCache->BeginEnum();

    while ( ( SUCCEEDED( hr ) ) && ( WBEM_S_NO_ERROR == m_pLocaleCache->Next( &pDefn ) ) ) 
    {
        CAdapReleaseMe  rmDefn( pDefn );

        // Get the localization namespace
        // ==============================

        hr = pDefn->GetNamespace( &pNamespace );

        CReleaseMe  rmNamespace( pNamespace );

        // And delete it
        // =============

        if ( SUCCEEDED( hr ) )
        {
            IWbemClassObject * pObj = NULL;
            
            hr = pNamespace->GetObject(bstrClassName,WBEM_FLAG_RETURN_WBEM_COMPLETE,NULL,&pObj,NULL);

            if(pObj) {  // release the object before deleting
                pObj->Release();
                pObj=NULL;
            }

            if (SUCCEEDED(hr)){
            
                hr = pNamespace->DeleteClass( bstrClassName, 0, NULL, NULL );

                if ( FAILED( hr ) )
                {
                    try
                    {
                        // Write on the trace
                        // ============

                        WString wstrNamespaceName;

                        pDefn->GetNamespaceName( wstrNamespaceName );


			    	    LPSTR pClass = m_wstrClassName.GetLPSTR();
			    	    LPSTR pNames = wstrNamespaceName.GetLPSTR();

			    	    CDeleteMe<CHAR> a(pClass);
                        CDeleteMe<CHAR> b(pNames);

                        ERRORTRACE( ( LOG_WMIADAP,"DeleteClass %s from %s 0x%08x",pClass,pNames,hr));


				    }
                    catch(...)
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                }

            } else {
                // class not found
                // nothing to delete
            }
        
        }
    }

    m_pLocaleCache->EndEnum();

    // Delete the default object
    // =========================

    if ( SUCCEEDED( hr ) )
    {
        hr = m_pLocaleCache->GetDefaultDefn( &pDefn );

        CAdapReleaseMe  rmDefn( pDefn );
        
        if ( SUCCEEDED( hr ) )
        {
            hr = pDefn->GetNamespace( &pNamespace );

            CReleaseMe  rmNamespace( pNamespace );

            if ( SUCCEEDED( hr ) )
            {
                hr = pNamespace->DeleteClass( bstrClassName, 0, NULL, NULL );

                if ( FAILED( hr ) )
                {
                    // Log an event
                    // ============

                    ServiceRec * pSvcRec = NULL;
                    if (0 == m_pKnownSvcs->Get(m_wstrServiceName,&pSvcRec))
                    {
	                    if (!pSvcRec->IsELCalled() && !m_bReportEventCalled)
	                    {
		                    try
		                    {
		                        WString wstrNamespaceName;
		    
		                        pDefn->GetNamespaceName( wstrNamespaceName );

		                        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
														  WBEM_MC_ADAP_PERFLIB_REMOVECLASS_FAILURE,
														  (LPCWSTR) m_wstrClassName,
														  (LPCWSTR) wstrNamespaceName,
														  CHex( hr ) );
		                        pSvcRec->SetELCalled();
		                        m_bReportEventCalled = TRUE;
		                    }
		                    catch(...)
		                    {
		                        hr = WBEM_E_OUT_OF_MEMORY;
		                    }
	                    }
                    }
                    else
                    {
                        if (!m_bReportEventCalled)
                        {
		                    try
		                    {
		                        WString wstrNamespaceName;
		    
		                        pDefn->GetNamespaceName( wstrNamespaceName );

		                        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
														  WBEM_MC_ADAP_PERFLIB_REMOVECLASS_FAILURE,
														  (LPCWSTR) m_wstrClassName,
														  (LPCWSTR) wstrNamespaceName,
														  CHex( hr ) );
		                        m_bReportEventCalled = TRUE;
		                    }
		                    catch(...)
		                    {
		                        hr = WBEM_E_OUT_OF_MEMORY;
		                    }                        
                        }
                    }
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        if (m_pKnownSvcs)
            m_pKnownSvcs->Remove((WCHAR *)m_wstrServiceName);
    }

    if (CleanRegistry && SUCCEEDED(hr))
    {

	    WString wszRegPath = L"SYSTEM\\CurrentControlSet\\Services\\";
    	wszRegPath += m_wstrServiceName;
	    wszRegPath += L"\\Performance";

	    CNTRegistry reg;
    	int         nRet = 0;
                
	    nRet = reg.Open( HKEY_LOCAL_MACHINE, wszRegPath );

    	switch( nRet )
	    {
	    case CNTRegistry::no_error:
    	    {
    	        reg.DeleteValue(ADAP_PERFLIB_STATUS_KEY);
    	        reg.DeleteValue(ADAP_PERFLIB_SIGNATURE);
    	        reg.DeleteValue(ADAP_PERFLIB_SIZE);
    	        reg.DeleteValue(ADAP_PERFLIB_TIME);
        	} 
        	break;
	    case CNTRegistry::not_found:
    	    {
            	hr = WBEM_E_FAILED;
	        }
	        break;
    	case CNTRegistry::access_denied:
        	{
                ServiceRec * pSvcRec = NULL;
                if (0 == m_pKnownSvcs->Get(m_wstrServiceName,&pSvcRec))
                {
	                if (!pSvcRec->IsELCalled() && !m_bReportEventCalled)
        	    	{
            	    	CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
     				    					  WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
	    				    				  (LPWSTR)wszRegPath, nRet );
                    	pSvcRec->SetELCalled();
                    	m_bReportEventCalled = TRUE;
	            	}
	            }
	            else
	            {
	                if (!m_bReportEventCalled)
        	    	{
            	    	CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
     				    					  WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
	    				    				  (LPWSTR)wszRegPath, nRet );
                    	m_bReportEventCalled = TRUE;
	            	}	            
	            }
	        }
	        break;
    	}
        
    }

    return hr;
}

HRESULT CClassElem::Insert()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CLocaleDefn*    pDefaultDefn = NULL;
    IWbemServices*  pNamespace = NULL;

    // perform object validation
    _IWmiObject * pInternal = NULL;
    hr = m_pDefaultObject->QueryInterface(IID__IWmiObject,(void **)&pInternal);
    if (SUCCEEDED(hr))
    {
        CReleaseMe rmi(pInternal);
        hr = pInternal->ValidateObject(WMIOBJECT_VALIDATEOBJECT_FLAG_FORCE);        
        if (FAILED(hr))
        {
            DebugBreak();
            ERRORTRACE((LOG_WMIADAP,"ValidateObject(%S) %08x\n",(LPWSTR)m_wstrClassName,hr));
            return hr;
        }
    }

    // Add the object to the default namespace
    // =======================================

    hr = m_pLocaleCache->GetDefaultDefn( &pDefaultDefn );

    CAdapReleaseMe  rmDefaultDefn( pDefaultDefn );
        
    if ( SUCCEEDED( hr ) )
    {
        hr = pDefaultDefn->GetNamespace( &pNamespace );

        CReleaseMe  rmNamespace( pNamespace );

        if ( SUCCEEDED( hr ) )
        {
            hr = pNamespace->PutClass( m_pDefaultObject, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );

            if ( FAILED( hr ) )
            {
                ServiceRec * pSvcRec = NULL;
                if (0 == m_pKnownSvcs->Get(m_wstrServiceName,&pSvcRec))
                {
	                if (!pSvcRec->IsELCalled() && !m_bReportEventCalled)
	                {
		                try
		                {
		                    WString wstrNamespace; 

		                    pDefaultDefn->GetNamespaceName( wstrNamespace );

		                    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
													  WBEM_MC_ADAP_PERFLIB_PUTCLASS_FAILURE, 
													  (LPCWSTR)m_wstrClassName, 
													  (LPCWSTR) wstrNamespace, 
													  CHex( hr ) );													  
							m_bReportEventCalled = TRUE;
							pSvcRec->SetELCalled();
		                }
		                catch(...)
		                {
		                    hr = WBEM_E_OUT_OF_MEMORY;
		                }
	                }
                
                }
                else
                {
	                if (!m_bReportEventCalled)
	                {
		                try
		                {
		                    WString wstrNamespace; 

		                    pDefaultDefn->GetNamespaceName( wstrNamespace );

		                    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
													  WBEM_MC_ADAP_PERFLIB_PUTCLASS_FAILURE, 
													  (LPCWSTR)m_wstrClassName, 
													  (LPCWSTR) wstrNamespace, 
													  CHex( hr ) );
							m_bReportEventCalled = TRUE;
		                }
		                catch(...)
		                {
		                    hr = WBEM_E_OUT_OF_MEMORY;
		                }
	                }
                }
            }

            //ERRORTRACE( ( LOG_WMIADAP, "PutClass(%S) %08x\n",(LPWSTR)m_wstrClassName,hr) );

        }
    }

    if ( SUCCEEDED( hr ) )
    {
        //
        //   Add the servicename to the MultiSz Key
        //

        if (m_pKnownSvcs)
            m_pKnownSvcs->Add((WCHAR *)m_wstrServiceName);            
        
        hr = VerifyLocales();
    }

    if ( SUCCEEDED( hr ) )
    {
        SetStatus( ADAP_OBJECT_IS_REGISTERED );
    }

    return hr;
}

HRESULT CClassElem::GetClassName( WString& wstr )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    try
    {
        wstr = m_wstrClassName;
    }
    catch(CX_MemoryException)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CClassElem::GetClassName( BSTR* pbStr )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    try 
    {
        *pbStr = SysAllocString( (LPCWSTR) m_wstrClassName );
    }
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CClassElem::GetObject( IWbemClassObject** ppObj )
{ 
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( NULL != m_pDefaultObject ) 
    {
        *ppObj = m_pDefaultObject; 
        (*ppObj)->AddRef();
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}

HRESULT CClassElem::GetServiceName( WString& wstrServiceName )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    try 
    {
        wstrServiceName = m_wstrServiceName;
    }
    catch(CX_MemoryException)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

BOOL CClassElem::SameName( CClassElem* pEl )
{
    WString wstrOtherName;

    try
    {
        if ( FAILED ( pEl->GetClassName( wstrOtherName ) ) )
            return FALSE;
    }
    catch(...)
    {
        return FALSE;
    }

    return m_wstrClassName.Equal( wstrOtherName );
}

BOOL CClassElem::SameObject( CClassElem* pEl )
{
    BOOL	bRes = FALSE;

    IWbemClassObject*    pObj = NULL;

    pEl->GetObject( &pObj );

    CReleaseMe  rmObj( pObj );

    bRes = ( m_pDefaultObject->CompareTo( WBEM_FLAG_IGNORE_OBJECT_SOURCE, pObj ) == WBEM_S_SAME );

    return bRes;
}

HRESULT CClassElem::Commit()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Ensure that object is in default namespace
    // ==========================================

    if ( CheckStatus( ADAP_OBJECT_IS_DELETED ) )
    {
        hr = Remove( CheckStatus(ADAP_OBJECT_IS_TO_BE_CLEARED) );
    }
    else if ( CheckStatus( ADAP_OBJECT_IS_REGISTERED | ADAP_OBJECT_IS_NOT_IN_PERFLIB ) && !CheckStatus( ADAP_OBJECT_IS_INACTIVE ) )
    {
        if ( IsPerfLibUnloaded() )
        {
            hr = Remove( TRUE );
        }
        else // the object is there 
        {
	        if (m_pKnownSvcs)
	            m_pKnownSvcs->Add((WCHAR *)m_wstrServiceName);
        }
    }
    else if ( !CheckStatus( ADAP_OBJECT_IS_REGISTERED ) )
    {
        hr = Insert();
    }
    else
    {
        if (m_pKnownSvcs)
            m_pKnownSvcs->Add((WCHAR *)m_wstrServiceName);

        VerifyLocales();
    }

    return hr;
}


BOOL CClassElem::IsPerfLibUnloaded()
{
    // Unless we can specifically prove that the perflib has been unloaded, then we assume that it is still loaded
    BOOL bLoaded = TRUE;

    HRESULT hr = WBEM_S_FALSE;

    WCHAR       wszRegPath[256];
    DWORD       dwFirstCtr = 0, 
                dwLastCtr = 0;
    WCHAR*      wszObjList = NULL;
    CNTRegistry reg;

    int nRet = 0;

    if ( 0 == m_wstrServiceName.Length() )
    {
        bLoaded = FALSE;
    }
    else if ( m_wstrServiceName.EqualNoCase( L"PERFOS" ) ||
              m_wstrServiceName.EqualNoCase( L"TCPIP" ) || 
              m_wstrServiceName.EqualNoCase( L"PERFPROC" ) ||
              m_wstrServiceName.EqualNoCase( L"PERFDISK" ) ||
              m_wstrServiceName.EqualNoCase( L"PERFNET" ) ||
              m_wstrServiceName.EqualNoCase( L"TAPISRV" ) ||
              m_wstrServiceName.EqualNoCase( L"SPOOLER" ) ||
              m_wstrServiceName.EqualNoCase( L"MSFTPSvc" ) ||
              m_wstrServiceName.EqualNoCase( L"RemoteAccess" ) ||
              m_wstrServiceName.EqualNoCase( L"WINS" ) ||
              m_wstrServiceName.EqualNoCase( L"MacSrv" ) ||
              m_wstrServiceName.EqualNoCase( L"AppleTalk" ) ||
              m_wstrServiceName.EqualNoCase( L"NM" ) ||
              m_wstrServiceName.EqualNoCase( L"RSVP" ))
    {
        // This is the list of the hardcoded perflibs - according 
        // to BobW, they are always considered to be loaded
        // ======================================================

        bLoaded = TRUE;
    }
    else
    {
        // Try to open the service's registry key and read the object list or the first/last counter values
        // ================================================================================================

        swprintf( wszRegPath, L"SYSTEM\\CurrentControlSet\\Services\\%s\\Performance", (WCHAR *)m_wstrServiceName );
            
        nRet = reg.Open( HKEY_LOCAL_MACHINE, wszRegPath );

        switch( nRet )
        {
        case CNTRegistry::not_found:
            {
                bLoaded = FALSE;
            }break;

        case CNTRegistry::no_error:
            {
                bLoaded =   ( reg.GetStr( L"Object List", &wszObjList ) == CNTRegistry::no_error ) ||
                            ( ( reg.GetDWORD( L"First Counter", &dwFirstCtr ) == CNTRegistry::no_error ) &&
                            ( reg.GetDWORD( L"Last Counter", &dwLastCtr ) == CNTRegistry::no_error ) 
                            );
            }break;

        case CNTRegistry::access_denied:
            {

                ServiceRec * pSvcRec = NULL;
                if (0 == m_pKnownSvcs->Get(m_wstrServiceName,&pSvcRec))
                {
                    if (!pSvcRec->IsELCalled() && !m_bReportEventCalled)
                    {
	                	CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
												  WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
												  wszRegPath, nRet );                    
 					    m_bReportEventCalled = TRUE;
 					    pSvcRec->SetELCalled();
                    }
                }
                else 
                {
	                if (!m_bReportEventCalled)
	                {
	                	CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
												  WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
												  wszRegPath, nRet );
					    m_bReportEventCalled = TRUE;
					}
				}
            }break;
        }
    }

    return !bLoaded;
}

HRESULT CClassElem::CompareLocale( CLocaleDefn* pLocaleDefn, IWbemClassObject* pObj )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CLocaleDefn*		pDefaultDefn = NULL;
    IWbemClassObject*	pLocaleObj = NULL;

    m_pLocaleCache->GetDefaultDefn( &pDefaultDefn );
    CAdapReleaseMe  armDefaultDefn( pDefaultDefn );

    hr = CLocaleClassBroker::ConvertToLocale( m_pDefaultObject, pLocaleDefn, pDefaultDefn, &pLocaleObj);

    CReleaseMe  rmLocaleObj( pLocaleObj );

    if ( SUCCEEDED( hr ) )
    {
        hr = pObj->CompareTo( WBEM_FLAG_IGNORE_OBJECT_SOURCE, pLocaleObj );
    }

    return hr;
}

HRESULT CClassElem::InsertLocale( CLocaleDefn* pLocaleDefn )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CLocaleDefn*		pDefaultDefn = NULL;
    IWbemClassObject*	pLocaleObj = NULL;
    IWbemServices*		pNamespace = NULL;

    m_pLocaleCache->GetDefaultDefn( &pDefaultDefn );
    CAdapReleaseMe  armDefaultDefn( pDefaultDefn );

    hr = CLocaleClassBroker::ConvertToLocale( m_pDefaultObject, pLocaleDefn, pDefaultDefn, &pLocaleObj);

    CReleaseMe  rmLocaleObj( pLocaleObj );

    if (SUCCEEDED(hr))
    {
	    // perform object validation
	    _IWmiObject * pInternal = NULL;
	    hr = pLocaleObj->QueryInterface(IID__IWmiObject,(void **)&pInternal);
	    if (SUCCEEDED(hr))
	    {	    
	        CReleaseMe rmi(pInternal);
	        hr = pInternal->ValidateObject(WMIOBJECT_VALIDATEOBJECT_FLAG_FORCE);
	        if (FAILED(hr))
	        {
                    DebugBreak();
	            ERRORTRACE((LOG_WMIADAP,"ValidateObject(%S) %08x\n",(LPWSTR)m_wstrClassName,hr));
	            return hr;
	        }
	    }
    }
    
    // And add it to the localized namespace
    // =====================================

    if ( SUCCEEDED( hr ) )
    {
        hr = pLocaleDefn->GetNamespace( &pNamespace );

        CReleaseMe  rmNamespace( pNamespace );

        if ( SUCCEEDED( hr ) )
        {
            hr = pNamespace->PutClass( pLocaleObj, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );

            if ( FAILED( hr ) )
            {
                ServiceRec * pSvcRec = NULL;
                if (0 == m_pKnownSvcs->Get(m_wstrServiceName,&pSvcRec))
                {
                    if (!pSvcRec->IsELCalled() && !m_bReportEventCalled)
                    {
		                try
		                {
		                    WString wstrNamespace; 

		                    pLocaleDefn->GetNamespaceName( wstrNamespace );

		                    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
													  WBEM_MC_ADAP_PERFLIB_PUTCLASS_FAILURE, 
													  (LPCWSTR)m_wstrClassName, (LPCWSTR) wstrNamespace, CHex( hr ) ); 
						    m_bReportEventCalled = TRUE;
 						    pSvcRec->SetELCalled();					
		                }
		                catch(...)
		                {
		                    hr = WBEM_E_OUT_OF_MEMORY;
		                }
                    }
                }
                else 
                {
	                if (!m_bReportEventCalled)
	                {
		                try
		                {
		                    WString wstrNamespace; 

		                    pLocaleDefn->GetNamespaceName( wstrNamespace );

		                    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
													  WBEM_MC_ADAP_PERFLIB_PUTCLASS_FAILURE, 
													  (LPCWSTR)m_wstrClassName, (LPCWSTR) wstrNamespace, CHex( hr ) ); 
							m_bReportEventCalled = TRUE;
		                }
		                catch(...)
		                {
		                    hr = WBEM_E_OUT_OF_MEMORY;
		                }
					}
				}                
            }
        }
    }
    else 
    {
        // no localized class
        ERRORTRACE( ( LOG_WMIADAP, "InsertLocale PutClass(%S) %08x\n",(LPWSTR)m_wstrClassName,hr) );
    }

    return hr;
}

HRESULT CClassElem::VerifyLocales()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CLocaleDefn*		pLocaleDefn = NULL;
    IWbemClassObject*	pLocaleObj = NULL;
    IWbemServices*		pNamespace = NULL;

    // Get the localized objects
    // =========================

    hr = m_pLocaleCache->BeginEnum();

    while ( ( SUCCEEDED( hr ) ) && ( WBEM_S_NO_ERROR == m_pLocaleCache->Next( &pLocaleDefn ) ) )
    {
        CAdapReleaseMe  rmLocaleDefn( pLocaleDefn );

        // Get the localization namespace
        // ==============================

        hr = pLocaleDefn->GetNamespace( &pNamespace );

        CReleaseMe  rmNamespace( pNamespace );

        // Get the localized object
        // ========================

        if ( SUCCEEDED( hr ) )
        {
            BSTR        bstrClassName = SysAllocString( m_wstrClassName );
            CSysFreeMe  sfmClassName( bstrClassName );

            hr = pNamespace->GetObject( bstrClassName, 0L, NULL, &pLocaleObj, NULL );

            CReleaseMe  rmLocaleObj( pLocaleObj );

            if ( SUCCEEDED( hr ) )
            {
                if ( CompareLocale( pLocaleDefn, pLocaleObj ) != WBEM_S_SAME )
                {
                    hr = InsertLocale( pLocaleDefn );
                }
            }
            else
            {
                hr = InsertLocale( pLocaleDefn );
            }
        }

        pLocaleObj = NULL;
    }

    m_pLocaleCache->EndEnum();

    return hr;
}

HRESULT CClassElem::SetStatus( DWORD dwStatus )
{
    m_dwStatus |= dwStatus;

    return WBEM_NO_ERROR;
}

HRESULT CClassElem::ClearStatus( DWORD dwStatus )
{
    m_dwStatus &= ~dwStatus;

    return WBEM_NO_ERROR;
}

BOOL CClassElem::CheckStatus( DWORD dwStatus )
{
    return ( ( m_dwStatus & dwStatus ) == dwStatus );
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//                              CClassList
//
////////////////////////////////////////////////////////////////////////////////////////////


CClassList::CClassList( CLocaleCache* pLocaleCache )
: m_pLocaleCache( pLocaleCache ),
  m_nEnumIndex( -1 ),
  m_fOK( FALSE )
{
    if ( NULL != m_pLocaleCache )
        m_pLocaleCache->AddRef();
}

CClassList::~CClassList( void )
{
    if ( NULL != m_pLocaleCache )
        m_pLocaleCache->Release();
}

HRESULT CClassList::BeginEnum()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    m_nEnumIndex = 0;

    return hr;
}

HRESULT CClassList::Next( CClassElem** ppEl )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    int nSize = m_array.GetSize();
    CClassElem* pEl = NULL;

    do 
    {
        if ( ( -1 < m_nEnumIndex ) && ( nSize > m_nEnumIndex ) )
        {
            pEl = m_array[m_nEnumIndex++];
        }
        else
        {
            m_nEnumIndex = -1;
            hr = WBEM_E_FAILED;
        }
    }
    while ( ( SUCCEEDED( hr ) ) && ( pEl->CheckStatus( ADAP_OBJECT_IS_DELETED ) ) );

    if ( SUCCEEDED( hr ) )
    {
        *ppEl = pEl; 
        
        if ( NULL != *ppEl )
        {
            (*ppEl)->AddRef();
        }
        else
        {
            hr = WBEM_E_FAILED;
        }
    }

    return hr;
}

HRESULT CClassList::EndEnum()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    m_nEnumIndex = -1;

    return hr;
}

HRESULT CClassList::AddElement( CClassElem* pElem )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( ( NULL != pElem ) &&  ( pElem->IsOk() ) )
    {
        if ( -1 == m_array.Add( pElem ) )
            {
            // Add failed
            // ==========
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}

// Removes the object at the index
HRESULT CClassList::RemoveAt( int nIndex )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Should auto release the object

    m_array.RemoveAt( nIndex );

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
//  CPerfClassList
//
////////////////////////////////////////////////////////////////////////////////

CPerfClassList::CPerfClassList( CLocaleCache* pLocaleCache, WCHAR* pwcsServiceName )
: CClassList( pLocaleCache ), 
  m_wstrServiceName( pwcsServiceName )
{
}

HRESULT CPerfClassList::AddPerfObject( PERF_OBJECT_TYPE* pObj, DWORD dwType, BOOL bCostly )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Create the WMI object
    // =====================

    CClassElem* pElem = new CClassElem( pObj, dwType, bCostly, m_wstrServiceName, m_pLocaleCache );
    CAdapReleaseMe  armElem( pElem );

    if ( ( NULL != pElem ) && ( pElem->IsOk() ) )
    {
        AddElement( pElem );
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}

HRESULT CPerfClassList::AddElement( CClassElem *pEl )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CClassElem* pCurrEl = NULL;
    BOOL bFound = FALSE;

    hr = BeginEnum();

    while ( ( WBEM_S_NO_ERROR == Next( &pCurrEl ) ) && ( SUCCEEDED( hr ) ) )
    {
        CAdapReleaseMe rmCurEl( pCurrEl );

        if ( pCurrEl->SameName( pEl ) )
        {
            bFound = TRUE;
            break;
        }
    }

    EndEnum();

    if ( bFound )
    {
        WString wstrClassName;
        WString wstrServiceName;

        hr = pEl->GetClassName( wstrClassName );
        if(FAILED(hr))
            return hr;

        hr = pEl->GetServiceName( wstrServiceName );
        if(FAILED(hr))
            return hr;

        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
								  WBEM_MC_ADAP_DUPLICATE_CLASS, 
								  (LPCWSTR)wstrClassName, (LPCWSTR)wstrServiceName );
    }
    else
    {
        m_array.Add( pEl );
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
//  CMasterClassList
//
////////////////////////////////////////////////////////////////////////////////

CMasterClassList::CMasterClassList( CLocaleCache* pLocaleCache,
                                    CKnownSvcs * pCKnownSvcs)
: CClassList( pLocaleCache ),
 m_pKnownSvcs(pCKnownSvcs)
{
    if (m_pKnownSvcs)
        m_pKnownSvcs->AddRef();
}

CMasterClassList::~CMasterClassList()
{
    if (m_pKnownSvcs)
        m_pKnownSvcs->Release();

}

// Adds an element to the classlist
HRESULT CMasterClassList::AddClassObject( IWbemClassObject* pObj, BOOL bSourceWMI, BOOL bDelta )
{
    HRESULT hr = WBEM_NO_ERROR;

    // Create a new class list element
    // ===============================

    CClassElem* pElem = new CClassElem( pObj, m_pLocaleCache );
    CAdapReleaseMe  armElem( pElem );

    if ( ( NULL != pElem ) &&  ( pElem->IsOk() ) )
    {
        if ( bSourceWMI )
        {
            pElem->SetStatus( ADAP_OBJECT_IS_REGISTERED | ADAP_OBJECT_IS_NOT_IN_PERFLIB );
        }

        if ( -1 == m_array.Add( pElem ) )
        {
            // Add failed
            // ==========
            hr = WBEM_E_OUT_OF_MEMORY;
        } 
        else
        {
            pElem->SetKnownSvcs(m_pKnownSvcs);
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    if ( FAILED( hr ) )
    {
        if ( NULL != pElem )
        {
            delete pElem;
        }
    }

    return hr;
}

// Builds a list of class objects that can be located by name
HRESULT CMasterClassList::BuildList( WCHAR* wszBaseClass, 
                                     BOOL bDelta, 
                                     BOOL bThrottle )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CLocaleDefn*    pDefn = NULL;
    IWbemServices*  pNamespace = NULL;

    // Create the class enumerator
    // ===========================

    hr = m_pLocaleCache->GetDefaultDefn( &pDefn );
    CAdapReleaseMe  rmDefn( pDefn );

    if ( SUCCEEDED( hr ) )
    {
        hr = pDefn->GetNamespace( &pNamespace );
    }

    CReleaseMe  rmNamespace( pNamespace );

    if ( SUCCEEDED( hr ) )
    {
        BSTR        bstrClass = SysAllocString( wszBaseClass );
        CSysFreeMe  sfmClass(bstrClass);

        if ( NULL != bstrClass )
        {
            IEnumWbemClassObject*   pEnum = NULL;
            hr = pNamespace->CreateClassEnum( bstrClass,
                                              WBEM_FLAG_SHALLOW,
                                              NULL,
                                              &pEnum );
            // Walk the enumerator
            // ===================

            if ( SUCCEEDED( hr ) )
            {
                // Set Interface security
                // ======================

                hr = WbemSetProxyBlanket( pEnum, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                    RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

                // Walk the object list in blocks of 100
                // =====================================

                while ( SUCCEEDED( hr ) && WBEM_S_FALSE != hr)
                {
                    ULONG   ulNumReturned = 0;

                    IWbemClassObject*   apObjectArray[100];

                    ZeroMemory( apObjectArray, sizeof(apObjectArray) );

                    // Fetch the objects from the enumerator in blocks of 100
                    // ======================================================

                    hr = pEnum->Next( WBEM_INFINITE,
                                    100,
                                    apObjectArray,
                                    &ulNumReturned );

                    // For each object, add it to the class list array
                    // ===============================================

                    if ( SUCCEEDED( hr ) && ulNumReturned > 0 )
                    {
                        // Add the objects
                        // ===============

                        for ( int x = 0; SUCCEEDED( hr ) && x < ulNumReturned; x++ )
                        {
                            if (bThrottle )
                            {
                                HRESULT hrThr = Throttle(THROTTLE_USER|THROTTLE_IO,
                                         ADAP_IDLE_USER,
                                         ADAP_IDLE_IO,
                                         ADAP_LOOP_SLEEP,
                                         ADAP_MAX_WAIT);
                                if (THROTTLE_FORCE_EXIT == hrThr)
                                {
                                    //OutputDebugStringA("(ADAP) Unthrottle command received\n");
                                    bThrottle = FALSE;
                                    UNICODE_STRING BaseUnicodeCommandLine = NtCurrentPeb()->ProcessParameters->CommandLine;
                                    WCHAR * pT = wcschr(BaseUnicodeCommandLine.Buffer,L't');
                                    if (0 == pT)
                                    	pT = wcschr(BaseUnicodeCommandLine.Buffer,L'T');
                                    if (pT)
                                    {
                                        *pT = L' ';
                                        pT--;
                                        *pT = L' ';                                       
                                    }
                                }                                
                            }
                        
                            HRESULT temphr = WBEM_S_NO_ERROR;
                            _variant_t    var;
                            IWbemClassObject* pObject = apObjectArray[x];

                            // Only add generic perf counter objects
                            // =====================================

							IWbemQualifierSet*	pQualSet = NULL;
							hr = pObject->GetQualifierSet( &pQualSet );
							CReleaseMe	rmQualSet( pQualSet );
							
							if ( SUCCEEDED( hr ) )
							{
								var = bool(true);								
								temphr = pQualSet->Get( L"genericperfctr", 0L, &var, NULL );

								if ( SUCCEEDED( temphr ) && 
								     ( V_VT(&var) == VT_BOOL ) &&
								     ( V_BOOL(&var) == VARIANT_TRUE ) )
								{
									hr = AddClassObject( pObject, TRUE, bDelta );
								}
							}

                            pObject->Release();
                        }

                        // If an add operation failed, release the rest of the pointers
                        // ============================================================

                        if ( FAILED( hr ) )
                        {
                            for ( ; x < ulNumReturned; x++ )
                            {
                                apObjectArray[x]->Release();
                            }

                        }   // IF FAILED( hr ) )

                    }   // IF Next

                }   // WHILE enuming

                if ( WBEM_S_FALSE == hr )
                {
                    hr = WBEM_S_NO_ERROR;
                }

                pEnum->Release();

            }   // IF CreateClassEnum
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hr;
}

HRESULT CMasterClassList::Merge( CClassList* pClassList, BOOL bDelta )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CClassElem* pEl = NULL;

    hr = pClassList->BeginEnum();

    // Does not return objects marked for deletion

    while ( ( WBEM_S_NO_ERROR == pClassList->Next( &pEl ) ) && ( SUCCEEDED( hr ) ) )
    {    
        CAdapReleaseMe  rmEl( pEl );

        hr = AddElement( pEl, bDelta ); 
    }

    pClassList->EndEnum();

    return hr;
}


// Cycle through all of the objects and set the inactive status for any object
// with an index between the library's counter index range


HRESULT CMasterClassList::Commit(BOOL bThrottle)
{
    HRESULT hr = WBEM_NO_ERROR;

    int nEl,
        nNumEl = m_array.GetSize();

    DWORD   dwWait;

    dwWait = WaitForSingleObject( g_hAbort, 0 );

    if ( WAIT_OBJECT_0 != dwWait )
    {
        // Validate object's uniqueness in list
        // ====================================

        for ( nEl = 0; SUCCEEDED( hr ) && nEl < nNumEl; nEl++ )
        {

            if (bThrottle)
            {
                HRESULT hrThr = Throttle(THROTTLE_USER|THROTTLE_IO,
                             ADAP_IDLE_USER,
                             ADAP_IDLE_IO,
                             ADAP_LOOP_SLEEP,
                             ADAP_MAX_WAIT);
                if (THROTTLE_FORCE_EXIT == hrThr)
                {
                    //OutputDebugStringA("(ADAP) Unthrottle command received\n");
                    bThrottle = FALSE;
                    UNICODE_STRING BaseUnicodeCommandLine = NtCurrentPeb()->ProcessParameters->CommandLine;
                    WCHAR * pT = wcschr(BaseUnicodeCommandLine.Buffer,L't');
                    if (0 == pT)
                    	pT = wcschr(BaseUnicodeCommandLine.Buffer,L'T');
                    if (pT)
                    {
                        *pT = L' ';
                        pT--;
                        *pT = L' ';                                       
                    }                    
                }
            }
            
            CClassElem* pCurrElem = (CClassElem*)m_array[nEl];

            pCurrElem->Commit();
        }
    }
    else
    {
        hr = WBEM_E_CRITICAL_ERROR;
    }

    return hr;
}



HRESULT CMasterClassList::AddElement( CClassElem *pEl, BOOL bDelta )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CClassElem* pCurrEl = NULL;
    BOOL bFound = FALSE;

    hr = BeginEnum();

    while ( ( WBEM_S_NO_ERROR == Next( &pCurrEl ) ) && ( SUCCEEDED( hr ) ) )
    {
        CAdapReleaseMe rmCurrEl( pCurrEl );

        if ( pCurrEl->SameName( pEl ) )
        {
            bFound = TRUE;

            if ( pCurrEl->SameObject( pEl ) )
            {
                // Set the satus as found
                // ======================
                pCurrEl->ClearStatus( ADAP_OBJECT_IS_NOT_IN_PERFLIB );                
            }
            else
            {
                // Replace the current perflib
                // ===========================
                pCurrEl->UpdateObj( pEl );
                pCurrEl->ClearStatus( ADAP_OBJECT_IS_NOT_IN_PERFLIB | ADAP_OBJECT_IS_REGISTERED );
            }

            break;
        }
    }

    EndEnum();

    if ( !bFound )
    {
        pEl->SetKnownSvcs(m_pKnownSvcs);
        m_array.Add( pEl );
    }

    return hr;
}

HRESULT 
CMasterClassList::ForceStatus(WCHAR* pServiceName,BOOL bSet,DWORD dwStatus)
{

    if (!pServiceName){
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr = WBEM_S_NO_ERROR;
    CClassElem* pCurrEl = NULL;
    BOOL bFound = FALSE;

    hr = BeginEnum();

    while ( ( WBEM_S_NO_ERROR == Next( &pCurrEl ) ) && ( SUCCEEDED( hr ) ) )
    {
        CAdapReleaseMe rmCurrEl( pCurrEl );
        WString wstr;
        hr = pCurrEl->GetServiceName(wstr);
        if(FAILED(hr))
            return hr;

        if (0==_wcsicmp((LPWSTR)wstr,pServiceName))
        {
            DEBUGTRACE((LOG_WMIADAP,"ForeceStatus %S %08x\n",(LPWSTR)wstr,pCurrEl->GetStatus()));
            
            if (bSet){
                pCurrEl->SetStatus(dwStatus);
            } else {
                pCurrEl->ClearStatus(dwStatus);
            }
        }
    }

    EndEnum();

    return hr;

}

#ifdef _DUMP_LIST

HRESULT 
CMasterClassList::Dump()
{

    HRESULT hr = WBEM_S_NO_ERROR;
    CClassElem* pCurrEl = NULL;
    BOOL bFound = FALSE;

    hr = BeginEnum();

    while ( ( WBEM_S_NO_ERROR == Next( &pCurrEl ) ) && ( SUCCEEDED( hr ) ) )
    {
        CAdapReleaseMe rmCurrEl( pCurrEl );
        WString wstr;
        hr = pCurrEl->GetServiceName(wstr);
        if(FAILED(hr))
            return hr;

        WString wstr2;
        hr = pCurrEl->GetClassName(wstr2);
        if(FAILED(hr))
            return hr;

        DEBUGTRACE((LOG_WMIADAP,"_DUMP_LIST %S %S\n",(LPWSTR)wstr,(LPWSTR)wstr2));
    }

    EndEnum();

    return hr;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\adapperf.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADAPPERF.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcli.h>
#include <cominit.h>
#include <WinMgmtR.h>
#include "ntreg.h"
#include "adapperf.h"
#include "adaputil.h"

#define PL_TIMEOUT  100000      // The timeout value for waiting on a function mutex
#define GUARD_BLOCK "WMIADAP_WMIADAP_WMIADAP_WMIADAP_WMIADAP_WMIADAP_WMIADAP_WMIADAP"

////////////////////////////////////////////////////////////////////////////////////////////
//
//                              CAdapSafeDataBlock
//
////////////////////////////////////////////////////////////////////////////////////////////

CAdapSafeBuffer::CAdapSafeBuffer(  WString wstrServiceName  )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Constructor
//
////////////////////////////////////////////////////////////////////////////////////////////
:   m_dwGuardSize       ( 0 ),
    m_hPerfLibHeap      ( NULL ),
    m_pRawBuffer        ( NULL ),
    m_pSafeBuffer       ( NULL ),
    m_dwSafeBufferSize  ( 0 ),
    m_pCurrentPtr       ( NULL ),
    m_dwNumObjects      ( 0 ),
    m_wstrServiceName   ( wstrServiceName )
{
    // Initialize the guard byte pattern
    // =================================

    m_dwGuardSize = sizeof( GUARD_BLOCK );
    m_pGuardBytes = new CHAR[m_dwGuardSize];
    strcpy(m_pGuardBytes, GUARD_BLOCK);

    // Create the private heap
    // =======================

    m_hPerfLibHeap = HeapCreate( HEAP_GENERATE_EXCEPTIONS, 0x100000, 0 );

    // If the private heap could not be created, then use the process heap
    // ===================================================================
    
    if ( NULL == m_hPerfLibHeap )
    {
        m_hPerfLibHeap = GetProcessHeap();
    }
}

CAdapSafeBuffer::~CAdapSafeBuffer()
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Destructor
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    // Delete the guard block
    // ======================

    delete [] m_pGuardBytes;

    // Deallocate the raw buffer 
    // =========================

    if ( NULL != m_pRawBuffer )
    {
         HeapFree( m_hPerfLibHeap, 0, m_pRawBuffer );
    }

    // Destroy the private heap
    // ========================

    if ( ( NULL != m_hPerfLibHeap ) && ( GetProcessHeap() != m_hPerfLibHeap ) )
    {
        HeapDestroy( m_hPerfLibHeap );
    }
}

HRESULT CAdapSafeBuffer::SetSize( DWORD dwNumBytes )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Sets the size of the safe buffer.  Memory is actually allocated for the raw buffer, and
//  the safe buffer just sits in the raw buffer between the set of guard bytes
//
//  Parameters:
//      dwNumBytes  - the number of bytes requested for the safe buffer
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_NO_ERROR;

    DWORD   dwRawBufferSize = 0;

    // Check for roll-over
    // ===================

    if ( dwNumBytes > ( 0xFFFFFFFF - ( 2 * m_dwGuardSize ) ) )
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    if ( SUCCEEDED ( hr ) )
    {
        // Set the total size of the buffer
        // ================================

        m_dwSafeBufferSize = dwNumBytes;
        dwRawBufferSize = dwNumBytes + ( 2 * m_dwGuardSize );

        // Allocate the memory
        // ===================

        try
        {
            if ( NULL == m_pRawBuffer )
            {
            // First time allocation
            // =====================
                m_pRawBuffer = (BYTE*) HeapAlloc( m_hPerfLibHeap, 
                                                  HEAP_ZERO_MEMORY | HEAP_GENERATE_EXCEPTIONS, 
                                                  dwRawBufferSize ); 
            }
            else
            {
                m_pRawBuffer = (BYTE*) HeapReAlloc( m_hPerfLibHeap, 
                                                    HEAP_ZERO_MEMORY | HEAP_GENERATE_EXCEPTIONS, 
                                                    m_pRawBuffer, 
                                                    dwRawBufferSize );
            }
        }
        catch(...)
        {
            m_pRawBuffer = NULL;
            m_pSafeBuffer = NULL;
            m_pCurrentPtr = NULL;
            m_dwSafeBufferSize = 0;
            hr = WBEM_E_OUT_OF_MEMORY;
        }

        if ( NULL != m_pRawBuffer )
        {
            // Set the safe buffer pointer
            // ===========================

            m_pSafeBuffer = m_pRawBuffer + m_dwGuardSize;

            // Set the prefix guard bytes
            // =========================

            memcpy( m_pRawBuffer, m_pGuardBytes, m_dwGuardSize );

            // Set the suffix guard bytes
            // ==========================

            memcpy( m_pSafeBuffer + m_dwSafeBufferSize, m_pGuardBytes, m_dwGuardSize );
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hr;
}

HRESULT CAdapSafeBuffer::Validate(BOOL * pSentToEventLog)
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Validate will compare the size of the pointer displacement matches the byte size 
//  returned from the collection, validates the guard bytes and walks the blob, verifying 
//  that all of the pointers are within the boundary of the blob
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_NO_ERROR;

    try 
    {
        PERF_OBJECT_TYPE* pObject = (PERF_OBJECT_TYPE*) m_pSafeBuffer;

        // Validate that if we have objects, then we have mass
        // ===================================================

        if ( ( 0 < m_dwNumObjects ) && ( 0 == m_dwDataBlobSize ) )
        {
            hr = WBEM_E_FAILED;
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
									  WBEM_MC_ADAP_BLOB_HAS_NO_SIZE, 
									  (LPCWSTR)m_wstrServiceName );
			if (pSentToEventLog) {
			    *pSentToEventLog = TRUE;
			}
        }

        // Validate that that number of bytes returned is the same as the pointer displacement
        // ===================================================================================

        if ( SUCCEEDED( hr ) && ( ( m_pCurrentPtr - m_pSafeBuffer ) != m_dwDataBlobSize ) )
        {
            hr = WBEM_E_FAILED;
                        
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
									  WBEM_MC_ADAP_BAD_PERFLIB_INVALID_DATA, 
									  (LPCWSTR)m_wstrServiceName, CHex( hr ) );
            if (pSentToEventLog) {
			    *pSentToEventLog = TRUE;
			}
        }

        if ( SUCCEEDED ( hr ) )
        {
            // Validate the guard bytes
            // ========================

            if ( 0 != memcmp( m_pRawBuffer, m_pGuardBytes, m_dwGuardSize) )
            {
                hr = WBEM_E_FAILED;
                
                CAdapUtility::NTLogEvent( EVENTLOG_ERROR_TYPE, 
										  WBEM_MC_ADAP_BAD_PERFLIB_MEMORY, 
										  (LPCWSTR)m_wstrServiceName, CHex( hr ) );
				if (pSentToEventLog) {
			        *pSentToEventLog = TRUE;
			    }
            }
            else
            {
                if ( 0 != memcmp( m_pSafeBuffer + m_dwSafeBufferSize, m_pGuardBytes, m_dwGuardSize) )
                {
                    hr = WBEM_E_FAILED;
                    CAdapUtility::NTLogEvent( EVENTLOG_ERROR_TYPE, 
											  WBEM_MC_ADAP_BAD_PERFLIB_MEMORY, 
											  (LPCWSTR)m_wstrServiceName, CHex( hr ) );
				    if (pSentToEventLog) {
    		    	    *pSentToEventLog = TRUE;
	        		}
                }
            }
        }

        // Validate the blob
        // =================

        if ( SUCCEEDED( hr ) )
        {
            for ( int nObject = 0; SUCCEEDED( hr ) && nObject < m_dwNumObjects; nObject++ )
            {
                PERF_COUNTER_DEFINITION* pCtr = NULL;
                DWORD dwCtrBlockSize = 0;

                // Validate the object pointer
                // ===========================

                hr = ValidateSafePointer( (BYTE*) pObject );

                if ( SUCCEEDED( hr ) )
                {
                    // Validate the counter definitions
                    // ================================

                    if ( 0 == pObject->HeaderLength )
                    {
                        hr = WBEM_E_FAILED;
                    }
                    else
                    {
                        pCtr = ( PERF_COUNTER_DEFINITION* ) ( ( ( BYTE* ) pObject ) + pObject->HeaderLength );
                    }
                }

                for( int nCtr = 0; SUCCEEDED( hr ) && nCtr < pObject->NumCounters; nCtr++) 
                {
                    hr = ValidateSafePointer( ( BYTE* ) pCtr );

                    if ( SUCCEEDED( hr ) )
                    {
                        dwCtrBlockSize += pCtr->CounterSize;

                        if ( nCtr < ( pObject->NumCounters - 1 ) )
                        {
                            if ( 0 == pCtr->ByteLength )
                            {
                                hr = WBEM_E_FAILED;
                            }
                            else
                            {
                                pCtr = ( PERF_COUNTER_DEFINITION* ) ( ( ( BYTE* ) pCtr ) + pCtr->ByteLength );
                            }
                        }
                    }
                }

                // Validate the data
                // =================

                if ( pObject->NumInstances >= 0 )
                {
                    // Blob has instances
                    // ==================

                    PERF_INSTANCE_DEFINITION* pInstance = NULL;

                    if ( 0 == pObject->DefinitionLength )
                    {
                        hr = WBEM_E_FAILED;
                    }
                    else
                    {
                        pInstance = ( PERF_INSTANCE_DEFINITION* ) ( ( ( BYTE* ) pObject ) + pObject->DefinitionLength );
                    }
                    
                    // Validate the instances
                    // ======================

                    for ( int nInst = 0; SUCCEEDED( hr ) && nInst < pObject->NumInstances; nInst++ )
                    {
                        hr = ValidateSafePointer( ( BYTE* ) pInstance );

                        if ( SUCCEEDED( hr ) )
                        {
                            PERF_COUNTER_BLOCK* pCounterBlock = NULL;

                            // Validate the counter blocks
                            // ===========================

                            if ( 0 == pInstance->ByteLength )
                            {
                                hr = WBEM_E_FAILED;
                            }
                            else
                            {
                                pCounterBlock = ( PERF_COUNTER_BLOCK* ) ( ( ( BYTE* ) pInstance ) + pInstance->ByteLength );

                                hr = ValidateSafePointer( ( BYTE* ) pCounterBlock );
                            }
                            
                            if ( SUCCEEDED( hr ) )
                            {
                                // Is the counter block the same size as the aggregation of the counter sizes?
                                // ===========================================================================

                                if ( ( nInst < pObject->NumInstances - 1 ) && SUCCEEDED( hr ) )
                                {
                                    pInstance = ( PERF_INSTANCE_DEFINITION* ) ( ( ( BYTE* ) pCounterBlock ) + pCounterBlock->ByteLength );
                                    hr = ValidateSafePointer( (BYTE*) pInstance );
                                }
                                //
                                // validate the size of the last object against
                                // the 'aperture' of the buffer
                                //
                                /*
                                if (SUCCEEDED(hr) && (nInst == (pObject->NumInstances - 1)))
                                {
                                    BYTE * pLast = ( ( ( BYTE* ) pCounterBlock ) + pCounterBlock->ByteLength );
                                    // now pLast is 1 byte over the "end" of the buffer
                                    if (pLast > m_pCurrentPtr)
                                    {
                                        hr = WBEM_E_FAILED;
                                    }
                                }
                                */
                            }
                        }
                    }
                }
                else
                {
                    // Blob is a singleton. Validate the counter blocks
                    // ================================================

                    if ( 0 == pObject->DefinitionLength )
                    {
                        hr = WBEM_E_FAILED;
                    }
                    else
                    {
                        PERF_COUNTER_BLOCK* pCounterBlock = ( PERF_COUNTER_BLOCK* ) ( ( ( BYTE* ) pObject ) + pObject->DefinitionLength );
                        hr = ValidateSafePointer( ( BYTE* ) pCounterBlock );
                    }
                }

                // Get the next object as long as one exists
                // =========================================

                if ( nObject < ( m_dwNumObjects - 1 ) )
                {
                    pObject = (PERF_OBJECT_TYPE*)((BYTE*)pObject + pObject->TotalByteLength);
                    hr = ValidateSafePointer( ( BYTE* ) pObject );
                }
            }
        }
    }
    catch(...)
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}

HRESULT CAdapSafeBuffer::ValidateSafePointer( BYTE* pPtr )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Verifys that the pointer is within the blob.  The blob occupies the memory starting at 
//  the beginning of the safe buffer, and termintes at an offset equal to m_dwDataBlobSize
//
//  Parameters:
//      pPtr    - a pointer to be verified
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_NO_ERROR;

    //  NOTE: The upper limit of the safe buffer is 1 byte less the blob pointer plus the blob size since
    //  the first byte of the blob is also the first byte.  Imagine he case with a blob of size 1. 
    //  =================================================================================================

    if ( ( pPtr < m_pSafeBuffer ) || ( pPtr > ( m_pSafeBuffer + m_dwDataBlobSize - 1 ) ) )
    {
        hr = WBEM_E_FAILED;
    }

    if ( FAILED ( hr ) )
    {
        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
								  WBEM_MC_ADAP_BAD_PERFLIB_INVALID_DATA, 
								  (LPCWSTR)m_wstrServiceName, CHex( hr ) );
    }

    return hr;
}

HRESULT CAdapSafeBuffer::CopyData( BYTE** ppData, DWORD* pdwNumBytes, DWORD* pdwNumObjects )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copies the blob data from the private heap into the process heap.  The method will 
//  allocate memory in the process heap.
//
//  Parameters:
//      ppData  - a pointer to an unallocated byte array
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_NO_ERROR;

    *ppData = new BYTE[m_dwDataBlobSize];

    if ( NULL == *ppData )
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        memcpy( *ppData, m_pSafeBuffer, m_dwDataBlobSize );
    }
    
    *pdwNumBytes = m_dwDataBlobSize;
    *pdwNumObjects = m_dwNumObjects;

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//                              CAdapPerfLib
//
////////////////////////////////////////////////////////////////////////////////////////////

CAdapPerfLib::CAdapPerfLib( LPCWSTR pwcsServiceName, DWORD * pLoadStatus )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Constructor
//
//  Initializes all member variables, sets the library and function names, opens the library, 
//  sets the entry point addresses, creates the perflib processing mutex, and opens the 
//  processing thread.
//
//  Parameters:
//      pwcsServiceName - A Unicode string specifying the name of the perflib service.
//
////////////////////////////////////////////////////////////////////////////////////////////
:   m_wstrServiceName( pwcsServiceName ),
    m_pfnOpenProc( NULL ),
    m_pfnCollectProc( NULL ),
    m_pfnCloseProc( NULL ),
    m_pwcsLibrary( NULL ),
    m_pwcsOpenProc( NULL ),
    m_pwcsCollectProc( NULL ),
    m_pwcsCloseProc( NULL ),
    m_hLib( NULL ),
    m_fOpen( FALSE ),
    m_dwStatus( 0 ),
    m_pPerfThread( NULL ), 
    m_hPLMutex( NULL ),
	m_fOK( FALSE ),
	m_EventLogCalled( FALSE ),
	m_CollectOK( TRUE )
	
{
    DEBUGTRACE( ( LOG_WMIADAP, "Constructing the %S performance library wrapper.\n", pwcsServiceName ) );

	HRESULT hr = WBEM_NO_ERROR;

    // Verify that the perflib is loaded
    // Initialize the performance library name and entry point names
    // =============================================================

    hr = VerifyLoaded();

    if (FAILED(hr))
    {        
        ERRORTRACE( ( LOG_WMIADAP, "VerifyLoaded for %S hr = %08x.\n", pwcsServiceName, hr ) );
    }


    // Set the processing status information for this attempt
    // ======================================================

    if ( SUCCEEDED ( hr ) )
    {
        if (pLoadStatus)
        {
            (*pLoadStatus) |= EX_STATUS_LOADABLE;
        }
        
        hr = BeginProcessingStatus();

		if ( hr == WBEM_S_ALREADY_EXISTS )
		{
			SetStatus( ADAP_PERFLIB_PREVIOUSLY_PROCESSED );
		}
    }

	m_fOK = SUCCEEDED( hr );

    if ( !m_fOK )
    {
        ERRORTRACE( ( LOG_WMIADAP, "Construction of the %S perflib wrapper failed hr = %08x.\n", pwcsServiceName, hr ) );
    }
}

CAdapPerfLib::~CAdapPerfLib( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Destructor
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    DEBUGTRACE( ( LOG_WMIADAP, "Destructing the %S performance library wrapper.\n", (LPWSTR)m_wstrServiceName) );

    if ( NULL != m_pPerfThread )
    {
        delete m_pPerfThread;
    }

    // Delete the library and entry point names
    // ========================================

    if ( NULL != m_pwcsLibrary )
    {
        delete [] m_pwcsLibrary;
    }

    if ( NULL != m_pwcsOpenProc )
    {
        delete [] m_pwcsOpenProc;
    }

    if ( NULL != m_pwcsCollectProc )
    {
        delete [] m_pwcsCollectProc;
    }

    if ( NULL != m_pwcsCloseProc )
    {
        delete [] m_pwcsCloseProc;
    }

    // Free the library
    // ================

    if ( NULL != m_hLib )
    {
        try
        {
            FreeLibrary( m_hLib );
        }
        catch(...)
        {
            ERRORTRACE( (LOG_WMIADAP, "Exception thrown when freeing the %S service perflib",(LPWSTR)m_wstrServiceName ) );
        }
        DEBUGTRACE( ( LOG_WMIADAP, "*** %S Library Freed.\n",(LPWSTR)m_wstrServiceName ) );
    }
    else
    {
        DEBUGTRACE( ( LOG_WMIADAP, "*** !!!!!!!! Skipped Freeing the %S Library.\n",(LPWSTR)m_wstrServiceName ) );
    }
}

HRESULT CAdapPerfLib::VerifyLoaded()
{
    HRESULT hr = WBEM_E_FAILED;

    WString wszRegPath = L"SYSTEM\\CurrentControlSet\\Services\\";
    wszRegPath += m_wstrServiceName;
    wszRegPath += L"\\Performance";

    CNTRegistry reg;
    int         nRet = 0;

    nRet = reg.Open( HKEY_LOCAL_MACHINE, wszRegPath );

    switch( nRet )
    {
    case CNTRegistry::no_error:
        {
            DWORD       dwFirstCtr = 0, 
                        dwLastCtr = 0;
            WCHAR*      wszObjList = NULL;

            if ( ( reg.GetStr( L"Object List", &wszObjList ) == CNTRegistry::no_error ) ||
                 ( ( reg.GetDWORD( L"First Counter", &dwFirstCtr ) == CNTRegistry::no_error ) &&
                   ( reg.GetDWORD( L"Last Counter", &dwLastCtr ) == CNTRegistry::no_error ))){

                hr = InitializeEntryPoints(reg,wszRegPath);   

                if (wszObjList) 
                {
                    delete [] wszObjList;
                }
                   
            } else { // more special cases


                if ( m_wstrServiceName.EqualNoCase( L"TCPIP" ) || 
                     m_wstrServiceName.EqualNoCase( L"TAPISRV") || 
                     m_wstrServiceName.EqualNoCase( L"PERFOS" ) ||
                     m_wstrServiceName.EqualNoCase( L"PERFPROC" ) ||
                     m_wstrServiceName.EqualNoCase( L"PERFDISK" ) ||
                     m_wstrServiceName.EqualNoCase( L"PERFNET" ) ||
                     m_wstrServiceName.EqualNoCase( L"SPOOLER" ) ||
                     m_wstrServiceName.EqualNoCase( L"MSFTPSvc" ) ||
                     m_wstrServiceName.EqualNoCase( L"RemoteAccess" ) ||
                     m_wstrServiceName.EqualNoCase( L"WINS" ) ||
                     m_wstrServiceName.EqualNoCase( L"MacSrv" ) ||
                     m_wstrServiceName.EqualNoCase( L"AppleTalk" ) ||
                     m_wstrServiceName.EqualNoCase( L"NM" ) ||
                     m_wstrServiceName.EqualNoCase( L"RSVP" ) ){
                     
                    hr = InitializeEntryPoints(reg,wszRegPath);     
                
                } else {            
                
                    hr = WBEM_E_FAILED;
                  
                }
            }                
        }break;
    case CNTRegistry::not_found:
        {
            // This shouldn't happen since this is how a perflib is defined
            hr = WBEM_E_FAILED;
        }break;
    case CNTRegistry::access_denied:
        {
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
     								  WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
	    							  (LPWSTR)wszRegPath, nRet );
        }break;
    }

    return hr;
}

HRESULT CAdapPerfLib::InitializeEntryPoints(CNTRegistry & reg,WString & wszRegPath){

    HRESULT hr = WBEM_S_NO_ERROR;

    // see if someone disabled this library
    DWORD dwDisable = 0;
    if ( CNTRegistry::no_error == reg.GetDWORD( L"Disable Performance Counters", &dwDisable ) && 
         (dwDisable != 0) ){
        hr = WBEM_E_FAILED;
    } else {
        hr = WBEM_S_NO_ERROR;
    }
    // the perflib is OK for the world, see if it os OK for US
                
    if (SUCCEEDED(hr)){
            
        if (!(( reg.GetStr( L"Library", &m_pwcsLibrary ) == CNTRegistry::no_error ) &&
              ( reg.GetStr( L"Open", &m_pwcsOpenProc ) == CNTRegistry::no_error)&&
              ( reg.GetStr( L"Collect", &m_pwcsCollectProc ) == CNTRegistry::no_error) &&
              ( reg.GetStr( L"Close", &m_pwcsCloseProc ) == CNTRegistry::no_error ) )) {

            WString wstrPath(wszRegPath);
            
            if (m_pwcsLibrary == NULL){
                wstrPath += L"\\Library";
            } else if (m_pwcsCollectProc == NULL) {
                wstrPath += L"\\Collect";
            }
            
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
						    					  WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
							    				  (LPWSTR)wstrPath, CHex( WBEM_E_NOT_AVAILABLE ) );
                         
            hr = WBEM_E_FAILED;
                        
        } else {

            hr = WBEM_S_NO_ERROR;
        }                    
    }

    return hr;

}


HRESULT CAdapPerfLib::Initialize() 
{   
    HRESULT hr = WBEM_S_NO_ERROR;

    // Load the perflib and initialize the procedure addresses
    // =======================================================

    if ( SUCCEEDED( hr ) )
    {
        hr = Load();
    }

    // Initialize the named function mutex (see WbemPerf for syntax of Mutex name)
    // ===========================================================================

    if ( SUCCEEDED( hr ) )
    {
   
        WCHAR* wcsMutexName = new WCHAR[m_wstrServiceName.Length() + 256];
        CDeleteMe<WCHAR>    dmMutexName( wcsMutexName );

        swprintf( wcsMutexName, L"%s_Perf_Library_Lock_PID_%x", (WCHAR *)m_wstrServiceName, GetCurrentProcessId() );
        m_hPLMutex = CreateMutexW( 0, FALSE, wcsMutexName);

        if ( NULL == m_hPLMutex )
        {
            hr = WBEM_E_FAILED;
        }
    }

    // Create the worker thread
    // ========================

    if ( SUCCEEDED( hr ) )
    {
        m_pPerfThread = new CPerfThread( this );

        if ( ( NULL == m_pPerfThread) || ( !m_pPerfThread->IsOk() ) )
        {
            hr = WBEM_E_FAILED;
        }
		else
		{
		    hr = m_pPerfThread->Open( this ); 
		}
    }

    if ( FAILED( hr ) )
    {
        SetStatus( ADAP_PERFLIB_IS_INACTIVE );
    }

    return hr;
}


HRESULT CAdapPerfLib::GetFileSignature( CheckLibStruct * pCheckLib )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (!pCheckLib){
        return WBEM_E_INVALID_PARAMETER;
    }

    // Get the current library's file time
    // ===================================

    HANDLE hFile = NULL;

    DWORD   dwRet = 0;
    WCHAR   wszFullPath[MAX_PATH];
    WCHAR*  pwcsTemp = NULL;

    if ( 0 != SearchPathW( NULL, m_pwcsLibrary, NULL, MAX_PATH, wszFullPath, &pwcsTemp ) )
    {
        hFile = CreateFileW( wszFullPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

        if ( INVALID_HANDLE_VALUE != hFile )
        {
			DWORD	dwFileSizeLow = 0;
			DWORD	dwFileSizeHigh = 0;
			__int32	nFileSize = 0;
			DWORD	dwNumRead = 0;
			BYTE*	aBuffer = NULL;

			dwFileSizeLow = GetFileSize( hFile, &dwFileSizeHigh );
			nFileSize = ( dwFileSizeHigh << 32 ) + dwFileSizeLow;

			FILETIME ft;
			if (GetFileTime(hFile,&ft,NULL,NULL))
			{
				aBuffer = new BYTE[nFileSize];
				CDeleteMe<BYTE> dmBuffer( aBuffer );

				if ( NULL != aBuffer )
				{
					if ( ReadFile( hFile, aBuffer, nFileSize, &dwNumRead, FALSE ) )
					{
						MD5	md5;
						BYTE aSignature[16];
						md5.Transform( aBuffer, dwNumRead, aSignature );

						// return our data
						memcpy(pCheckLib->Signature,aSignature,sizeof(aSignature));
						pCheckLib->FileTime = ft;
						pCheckLib->FileSize = nFileSize;
					}
					else
					{
						hr = WBEM_E_TOO_MUCH_DATA;
					}
				}
				else
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}			
			} 
			else 
			{
			    hr = WBEM_E_FAILED;
			}

        }
        else
        {
            DWORD dwError = GetLastError();
            hr = WBEM_E_FAILED;
        }

		CloseHandle( hFile );
    }
    else
    {
        hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}


HRESULT CAdapPerfLib::SetFileSignature()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CNTRegistry reg;
    int         nRet = 0;
    CheckLibStruct CheckLib;

	// Clear the signature buffer
	// ==========================

	memset( &CheckLib, 0, sizeof(CheckLib) );

    // Get the current file time stamp
    // ===============================

    hr = GetFileSignature( &CheckLib );

    // And write it into the registry key
    // ==================================

    if ( SUCCEEDED( hr ) )
    {

        WString wstr;

        try
        {
            wstr = L"SYSTEM\\CurrentControlSet\\Services\\";
            wstr += m_wstrServiceName;
            wstr += L"\\Performance";
        }
        catch(...)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

        if ( SUCCEEDED( hr ) )
        {
            nRet = reg.Open( HKEY_LOCAL_MACHINE , wstr );

            switch ( nRet )
            {
            case CNTRegistry::no_error:
                {
                }break;
            case CNTRegistry::access_denied:
                {
                    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
											  WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
											  (LPCWSTR)wstr, nRet );
                }
            default:
                hr = WBEM_E_FAILED; 
            }
        }

        if ( SUCCEEDED( hr ) )
        {
            int nRet1 = reg.SetBinary( ADAP_PERFLIB_SIGNATURE, (PBYTE)&CheckLib.Signature, sizeof( BYTE[16] ) );
            int nRet2 = reg.SetBinary( ADAP_PERFLIB_TIME, (PBYTE)&CheckLib.FileTime, sizeof( FILETIME ) );
            int nRet3 = reg.SetDWORD( ADAP_PERFLIB_SIZE, CheckLib.FileSize );

            if ( (CNTRegistry::no_error == nRet1) &&
                 (CNTRegistry::no_error == nRet2) &&
                 (CNTRegistry::no_error == nRet3))
            {
                // everything OK
            } 
            else if ((CNTRegistry::access_denied == nRet1) ||
                     (CNTRegistry::access_denied == nRet2) ||
                     (CNTRegistry::access_denied == nRet3))
            {                
                WString wstrPath = wstr;
                wstrPath += ADAP_PERFLIB_SIGNATURE;
                CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
			 						      WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
									      (LPCWSTR)wstrPath, CNTRegistry::access_denied );
            }
            else 
            {
                hr = WBEM_E_FAILED;
            }
        }
    }

    return hr;
}


HRESULT CAdapPerfLib::CheckFileSignature()
{
    HRESULT hr = WBEM_S_SAME;

    CNTRegistry reg;
    int         nRet = 0;
	BYTE	cCurrentMD5[16];
	BYTE*	cStoredMD5 = NULL;

    // Set the performance key path
    // ============================

    WString wstr;

    try
    {
        wstr = L"SYSTEM\\CurrentControlSet\\Services\\";
        wstr += m_wstrServiceName;
        wstr += L"\\Performance";
    }
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    if ( SUCCEEDED( hr ) )
    {
        // Open the performance key
        // ========================

        nRet = reg.Open( HKEY_LOCAL_MACHINE , wstr );

        switch ( nRet )
        {
        case CNTRegistry::no_error:
            {
            }break;
        case CNTRegistry::access_denied:
            {
                CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
										  WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
										  (LPCWSTR)wstr, nRet );
                hr = WBEM_E_FAILED;
            }break;
        default:
            {
                hr = WBEM_E_FAILED; 
            }break;
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        // Get the stored file signature
        // =============================
        CheckLibStruct StoredLibStruct;
        int nRet1;
        int nRet2;
        int nRet3;

        nRet1 = reg.GetBinary( ADAP_PERFLIB_SIGNATURE, (PBYTE*)&cStoredMD5 );
		CDeleteMe<BYTE>	dmStoredMD5( cStoredMD5 );
		if (cStoredMD5)
		{
		    memcpy(&StoredLibStruct.Signature,cStoredMD5,sizeof(StoredLibStruct.Signature));
		}

		BYTE * pFileTime = NULL;
		nRet2 = reg.GetBinary( ADAP_PERFLIB_TIME, (PBYTE*)&pFileTime );
        CDeleteMe<BYTE>	dmFileTime( pFileTime );
        if (pFileTime)
        {
            memcpy(&StoredLibStruct.FileTime,pFileTime,sizeof(FILETIME));
        }

        nRet3 = reg.GetDWORD(ADAP_PERFLIB_SIZE,&StoredLibStruct.FileSize);

        if ((CNTRegistry::access_denied == nRet1) ||
            (CNTRegistry::access_denied == nRet2) ||
            (CNTRegistry::access_denied == nRet3))
        {
            WString wstrPath = wstr;
            wstrPath += ADAP_PERFLIB_SIGNATURE;
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
									  WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
									  (LPCWSTR)wstrPath, nRet );
            hr = WBEM_E_FAILED;
        } else if ((CNTRegistry::not_found == nRet1) ||
        	       (CNTRegistry::not_found == nRet2) ||
    		       (CNTRegistry::not_found == nRet3)){
    		hr = WBEM_S_FALSE;   
        } else if((CNTRegistry::out_of_memory == nRet1) ||
        	       (CNTRegistry::out_of_memory == nRet2) ||
    		       (CNTRegistry::out_of_memory == nRet3) ||
    		       (CNTRegistry::failed == nRet1) ||
        	       (CNTRegistry::failed == nRet2) ||
    		       (CNTRegistry::failed == nRet3)) 
        {
            hr = WBEM_E_FAILED; 
        }

		if ( SUCCEEDED( hr ) && ( WBEM_S_FALSE != hr ) )
		{
			// Get the current library's signature
			// ===================================
			CheckLibStruct CurrentLibStruct;
			memset(&CurrentLibStruct,0,sizeof(CheckLibStruct));

			hr = GetFileSignature( &CurrentLibStruct );
        
			if ( SUCCEEDED( hr ) )
			{
				if ( (StoredLibStruct.FileSize == CurrentLibStruct.FileSize) &&
				     (0 == memcmp( &StoredLibStruct.Signature, &CurrentLibStruct.Signature, sizeof(CurrentLibStruct.Signature) )) &&
				     (0 == memcmp( &StoredLibStruct.FileTime, &CurrentLibStruct.FileTime, sizeof(FILETIME))) )
				{
					hr = WBEM_S_ALREADY_EXISTS;
				}
				else
				{
					hr = WBEM_S_FALSE;
				}
			}
		}
	}
    return hr;
}


HRESULT CAdapPerfLib::BeginProcessingStatus()
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Opens the registry key, reads the ADAP_PERFLIB_STATUS_KEY, and processes the value as 
//  follows:
//
//      ADAP_PERFLIB_OK:            The perflib has been successfully accessed before. Set 
//                                  the status flag to ADAP_PERFLIB_PROCESSING
//
//      ADAP_PERFLIB_PROCESSING:    The perflib caused the process to fail.  It is corrupt,
//                                  set the status flag to ADAP_PERFLIB_CORRUPT.
//      
//      ADAP_PERFLIB_CORRUPT:       The perflib is known to be corrupt.  Status flag retains
//                                  its value.
//
//      No Value:                   The perflib has not been accessed before. Set the 
//                                  status flag to ADAP_PERFLIB_PROCESSING.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    DEBUGTRACE( ( LOG_WMIADAP, "CAdapPerfLib::BeginProcessingStatus()...\n") );

    HRESULT     hr = WBEM_S_NO_ERROR;
    CNTRegistry reg;

    // Set the registry path
    // =====================

    WString wstr;

    try
    {
        wstr = L"SYSTEM\\CurrentControlSet\\Services\\";
        wstr += m_wstrServiceName;
        wstr += L"\\Performance";
    }
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    if ( SUCCEEDED( hr ) )
    {
        // Open the services key
        // =====================

        int nRet = reg.Open( HKEY_LOCAL_MACHINE, wstr );

        switch ( nRet )
        {
        case CNTRegistry::access_denied:
            {
                CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
										  WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
										  (LPCWSTR)wstr, nRet );
            } break;
        case CNTRegistry::no_error:
            {
                DWORD dwVal;

                // Check perflib status
                // ====================

                hr = CheckFileSignature();

                if ( SUCCEEDED( hr ) )
                {
                    if ( WBEM_S_FALSE == hr )
                    {
                        // We've got a new perflib, reset the status
                        // =========================================

                        hr = SetFileSignature();

                        if ( SUCCEEDED( hr ) )
                        {
                            hr = reg.SetDWORD( ADAP_PERFLIB_STATUS_KEY, ADAP_PERFLIB_PROCESSING );
                        }

                    }
                    else // WBEM_S_ALREADY_EXISTS
                    {
                        // It's the same perflib, check the status
                        // =======================================
                
                        nRet = reg.GetDWORD( ADAP_PERFLIB_STATUS_KEY, &dwVal );

                        if ( nRet == CNTRegistry::no_error )
                        {
                            switch ( dwVal )
                            {
                            case ADAP_PERFLIB_OK:           // 0
                            case ADAP_PERFLIB_PROCESSING:   // 1
                            case ADAP_PERFLIB_BOOBOO:       // 2                           
                                {
                                    // So far, perflib has behaved within reason. Set it to processing state
                                    // =====================================================================

                                    reg.SetDWORD( ADAP_PERFLIB_STATUS_KEY, dwVal + 1 );

                                    //ERRORTRACE( ( LOG_WMIADAP, "Performance library %S status %d\n",(LPWSTR)m_wstrServiceName,dwVal + 1));
                                    

                                }break;
                            case ADAP_PERFLIB_LASTCHANCE:   // 3                                 
                                {
                                    // Perflib failed in the last access attempt before processing ended. Set as bad perflib
                                    // =====================================================================================

                                    reg.SetDWORD( ADAP_PERFLIB_STATUS_KEY, ADAP_PERFLIB_CORRUPT );

                                    ERRORTRACE( ( LOG_WMIADAP, "Performance library %S status was left in the \"Processing\" state.\n",(LPWSTR)m_pwcsLibrary) );
                                    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
															  WBEM_MC_ADAP_BAD_PERFLIB_BAD_LIBRARY, 
															  m_pwcsLibrary, CHex( (DWORD)-1 ) );
                                    hr = WBEM_E_FAILED;															  
                                }break;
                            case ADAP_PERFLIB_CORRUPT:      // -1
                                {
                                    // Sign of a bad perflib. Do not open
                                    // ==================================

                                    ERRORTRACE( ( LOG_WMIADAP, "Performance library for %S has previously been disabled.\n",(LPWSTR)m_wstrServiceName) );
                                    
                                    //CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_BAD_PERFLIB_BAD_LIBRARY, m_pwcsLibrary, CHex( ADAP_PERFLIB_CORRUPT ) );

                                    hr = WBEM_E_FAILED;

                                }break;
                            }
                        }
                        else if ( nRet == CNTRegistry::not_found )
                        {
                            // The status does not exist
                            // =========================

                            hr = reg.SetDWORD( ADAP_PERFLIB_STATUS_KEY, ADAP_PERFLIB_PROCESSING );
                        }
                    }
                } else {

                    DEBUGTRACE( ( LOG_WMIADAP, "CheckFileSignature for %S %08x\n",(LPWSTR)m_wstrServiceName,hr ) );

                }
            }break;
        default:
            {
                hr = WBEM_E_FAILED;
            }break;
        }
    }

    return hr;
}

HRESULT CAdapPerfLib::EndProcessingStatus()
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Opens the service registry key, reads the ADAP_PERFLIB_STATUS_KEY, and processes the 
//  value as follows:
//
//      ADAP_PERFLIB_PROCESSING:    Valid state. Set status flag to ADAP_PERFLIB_OK.
//
//      ADAP_PERFLIB_CORRUPT:       Valid state (may have been set during processing). 
//                                  Leave status flag as is.
//
//      ADAP_PERFLIB_OK:            Invalid state. Return an error and log an event.
//
//      No Value:                   Invalid state. Return an error and log an event.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    DEBUGTRACE( ( LOG_WMIADAP, "CAdapPerfLib::EndProcessingStatus()...\n") );

    HRESULT     hr = WBEM_S_NO_ERROR;
    CNTRegistry reg;

    WString wstr;

    try
    {
        wstr = L"SYSTEM\\CurrentControlSet\\Services\\";
        wstr += m_wstrServiceName;
        wstr += L"\\Performance";
    }
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    if (SUCCEEDED(hr)){
    // Open the services key
    // =====================

        int nRet = reg.Open( HKEY_LOCAL_MACHINE, wstr );

        if ( CNTRegistry::access_denied == nRet )
        {
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
									  WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
									  (LPCWSTR)wstr, nRet );
            hr = WBEM_E_FAILED;
        }
        else if ( CNTRegistry::no_error == nRet )
        {
            DWORD   dwVal = 0;

            // Check perflib status
            // ====================

            if ( CheckStatus( ADAP_PERFLIB_FAILED ) )
            {
                // If we have a failure, then immediately mark the perflib as corrupt
                // ==================================================================

                hr = reg.SetDWORD( ADAP_PERFLIB_STATUS_KEY, ADAP_PERFLIB_CORRUPT );

                if (!m_EventLogCalled){
                    m_EventLogCalled = TRUE;
                    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_BAD_PERFLIB_EXCEPTION, (LPCWSTR)m_wstrServiceName, CHex( hr ) );
                    
                }

            }
            else if ( reg.GetDWORD( ADAP_PERFLIB_STATUS_KEY, &dwVal) == CNTRegistry::no_error )
            {
                switch ( dwVal )
                {
                case ADAP_PERFLIB_PROCESSING:
                case ADAP_PERFLIB_BOOBOO:
                case ADAP_PERFLIB_LASTCHANCE:
                    {
                        // Perflib is in expected state, reset as long as nothing bad has happened
                        // =======================================================================

                        hr = reg.SetDWORD( ADAP_PERFLIB_STATUS_KEY, ADAP_PERFLIB_OK );

                        //ERRORTRACE( ( LOG_WMIADAP, "Performance library %S EndProcessing\n",(LPWSTR)m_wstrServiceName) );


                    }break;

                case ADAP_PERFLIB_CORRUPT:
                    {
                        // Valid state.  Leave as is.
                        // ==========================

                        ERRORTRACE( ( LOG_WMIADAP, "Performance library for %S: status is corrupt.\n",(LPWSTR)m_wstrServiceName) );
                        hr = WBEM_E_FAILED;

                    }break;

                case ADAP_PERFLIB_OK:
                    {
                        if (CheckStatus(ADAP_PERFLIB_IS_INACTIVE))
                        {
                            hr = reg.SetDWORD( ADAP_PERFLIB_STATUS_KEY, ADAP_PERFLIB_OK );
                        } 
                        else 
                        {
                            // Invalid state
                            ERRORTRACE( ( LOG_WMIADAP, "Performance library %S: status is still ADAP_PERFLIB_OK.\n",(LPWSTR)m_wstrServiceName) );
                            hr = WBEM_E_FAILED;
                        }

                    }break;
                
                default:
                    {
                        // Really bad state
                        // ================

                        ERRORTRACE( ( LOG_WMIADAP, "Performance library %S: status is in an unknown state.\n",(LPWSTR)m_wstrServiceName) );
                        hr = WBEM_E_FAILED;
                    }
                }
            }
            else 
            {
                // There is no status key. Something wacky has happened
                // ====================================================

                hr = WBEM_E_FAILED;
            }
        }
    }

    return hr;
}

HRESULT CAdapPerfLib::Load()
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Loads the library and resolves the addresses for the Open, Collect and Close entry 
//  points.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    // Redundant, but it's a failsafe in case some perflib shuts this off on us
    // during processing
    // ========================================================================

    SetErrorMode( SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX );

    HRESULT hr = WBEM_S_NO_ERROR;

    // Free the library if it has been previously loaded
    // =================================================

    if ( NULL != m_hLib )
    {
        try
        {
            FreeLibrary( m_hLib );
        }
        catch(...)
        {
            hr = WBEM_E_CRITICAL_ERROR;
        }
    }

    // Load the predefined library
    // ===========================

    if ( SUCCEEDED( hr ) )
    {
        try
        {
            m_hLib = LoadLibraryExW( m_pwcsLibrary, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );
        }
        catch(...)
        {
            hr = WBEM_E_CRITICAL_ERROR;
        }
    }

    if ( SUCCEEDED( hr ) && ( NULL != m_hLib ) )
    {
    
        DEBUGTRACE( ( LOG_WMIADAP, "** %S Library Loaded.\n", m_wstrServiceName ) );

        char    szName[256];
        DWORD Last1 = 0;
        DWORD Last2 = 0;
        DWORD Last3 = 0;


        // Get the entry point addresses. No Wide version of GetProcAddress?  sigh... 
        // ==========================================================================

        if ( NULL != m_pwcsOpenProc )
        {
            WideCharToMultiByte( CP_ACP, 0L, m_pwcsOpenProc, lstrlenW( m_pwcsOpenProc ) + 1,
                szName, sizeof(szName), NULL, NULL );
            m_pfnOpenProc = (PM_OPEN_PROC*) GetProcAddress( m_hLib, szName );
            Last1 = GetLastError();
        }

        WideCharToMultiByte( CP_ACP, 0L, m_pwcsCollectProc, lstrlenW( m_pwcsCollectProc ) + 1,
            szName, sizeof(szName), NULL, NULL );
        m_pfnCollectProc = (PM_COLLECT_PROC*) GetProcAddress( m_hLib, szName );
        Last2 = GetLastError();

        if ( NULL != m_pwcsCloseProc )
        {
            WideCharToMultiByte( CP_ACP, 0L, m_pwcsCloseProc, lstrlenW( m_pwcsCloseProc ) + 1,
                szName, sizeof(szName), NULL, NULL );
            m_pfnCloseProc = (PM_CLOSE_PROC*) GetProcAddress( m_hLib, szName );
            Last3 = GetLastError();
        }

        if ( ( ( ( NULL != m_pwcsOpenProc ) && ( NULL != m_pfnOpenProc) ) || ( NULL == m_pwcsOpenProc ) ) &&
                 ( NULL != m_pfnCollectProc ) &&
             ( ( ( NULL != m_pwcsCloseProc ) && ( NULL != m_pfnCloseProc ) ) || ( NULL == m_pwcsCloseProc ) ) )
        {
            hr = WBEM_S_NO_ERROR;
        }
        else
        {
            ERRORTRACE( ( LOG_WMIADAP, "A performance library function in %S failed to load.\n",(LPWSTR)m_wstrServiceName) );

            WString wstr;
            wstr += L"HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\";
            wstr += m_wstrServiceName;
            
            if ( ( NULL != m_pwcsOpenProc ) && ( NULL == m_pfnOpenProc ) )
            {
                CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
				        				   WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
						 			       (LPCWSTR)wstr, Last1 );
                
            }
            else if ( NULL == m_pfnCollectProc )
            {
                CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
				        				   WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
						 			       (LPCWSTR)wstr, Last2 );
                
            }
            else if (( NULL != m_pwcsCloseProc ) && ( NULL == m_pfnCloseProc ))
            {
                CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
				        				   WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
						 			       (LPCWSTR)wstr, Last3 );
                
            }

            SetStatus( ADAP_PERFLIB_FAILED );

            hr = WBEM_E_FAILED;
        }
    }
    else
    {
        // If the library fails to load, then send an event, but do not charge a strike
        // ============================================================================

        ERRORTRACE( ( LOG_WMIADAP, "The performance library for %S failed to load.\n",(LPWSTR)m_wstrServiceName ) );
        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_BAD_PERFLIB_BAD_LIBRARY, m_pwcsLibrary, CHex( hr ) );

        hr = WBEM_E_FAILED;
    }

    return hr;
}

HRESULT CAdapPerfLib::GetBlob( PERF_OBJECT_TYPE** ppPerfBlock, DWORD* pdwNumBytes, DWORD* pdwNumObjects, BOOL fCostly )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( m_fOpen )
    {
        hr = m_pPerfThread->GetPerfBlock( this, ppPerfBlock, pdwNumBytes, pdwNumObjects, fCostly );
    }

	if ( FAILED( hr ) ) {

        // this statement will be moved inside GetPerfBlock
		//SetStatus( ADAP_PERFLIB_FAILED );

        if (!m_EventLogCalled){
            //
		    //
		    //WBEM_MC_ADAP_BAD_PERFLIB_BAD_RETURN
		    //
		    m_EventLogCalled = TRUE;
		    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_BAD_PERFLIB_BAD_RETURN , (LPCWSTR)m_wstrServiceName, CHex( hr ) );
		    
		}

    }

    return hr;
}

HRESULT CAdapPerfLib::Close()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( m_fOpen )
    {
        m_pPerfThread->Close( this ); 
    }

    return hr;
}

HRESULT CAdapPerfLib::Cleanup()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Terminate the worker thread
    // ===========================

    if ( NULL != m_pPerfThread )
        m_pPerfThread->Shutdown();

    // Adjust the status
    // =================

    EndProcessingStatus();

    return hr;
}

HRESULT CAdapPerfLib::_Open( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Wraps a call to the perflib's open function.  Fetches and passes an exports parameter
//  to the open function if it exists.
//
//  Note: We should use the named mutex to guard around the calls to Open/Collect/Close
//  
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Check to ensure that the library has not yet been opened
    // ========================================================

    if ( ( !m_fOpen ) && SUCCEEDED ( hr ) )
    {
        CNTRegistry reg;    // The registry wrapper class

        // Build the service path
        // ======================

        WString     wstr = L"SYSTEM\\CurrentControlSet\\Services\\";
        wstr += m_wstrServiceName;

        // Open the registry
        // =================

        if ( reg.Open( HKEY_LOCAL_MACHINE, wstr ) == CNTRegistry::no_error )
        {
            WCHAR*  pwcsExports = NULL;

            // Get Exports if they are available.  I think this is correct...
            // ==============================================================

            if ( reg.MoveToSubkey( L"Linkage" ) == CNTRegistry::no_error )
            {
                DWORD   dwNumBytes = 0;

                reg.GetMultiStr( L"Export", &pwcsExports, dwNumBytes );
            }

            // Call the Open function for the perflib
            // ======================================

            switch ( WaitForSingleObject( m_hPLMutex, PL_TIMEOUT ) )
            {
            case WAIT_OBJECT_0:
                {
                    try 
                    {
                        if ( NULL != m_pfnOpenProc )
                        {
                            LONG lRes = m_pfnOpenProc( pwcsExports );
                            if (lRes == ERROR_SUCCESS )
                            {
                                hr = WBEM_S_NO_ERROR;
                                m_fOpen = TRUE;
                            }
                            else
                            {
                                SetStatus( ADAP_PERFLIB_IS_INACTIVE );
                                hr = WBEM_E_NOT_AVAILABLE;
                            }

                            DEBUGTRACE( ( LOG_WMIADAP, "Open called for %S returned %d\n", (LPCWSTR)m_wstrServiceName, lRes ) );
                        }
                        else
                        {
                            hr = WBEM_S_NO_ERROR;
                            m_fOpen = TRUE;
                        }
                    }
                    catch (...)
                    {
                        SetStatus( ADAP_PERFLIB_FAILED );
                        hr = WBEM_E_FAILED;
                        ERRORTRACE( ( LOG_WMIADAP, "Perflib Open function has thrown an exception in %S.\n",(LPWSTR)m_wstrServiceName) );
                        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_BAD_PERFLIB_EXCEPTION, (LPCWSTR)m_wstrServiceName, CHex( hr ) );
                    }
                } break;
            case WAIT_TIMEOUT:
                {
                    hr = WBEM_E_NOT_AVAILABLE;
                    ERRORTRACE( ( LOG_WMIADAP, "Perflib access mutex timed out in %S.\n",(LPWSTR)m_wstrServiceName) );
                }break;
            case WAIT_ABANDONED:
                {
                    hr = WBEM_E_FAILED;
                    ERRORTRACE( ( LOG_WMIADAP, "Perflib access mutex was abandoned in %S.\n",(LPWSTR)m_wstrServiceName) );
                }break;
            default:
                {
                    hr = WBEM_E_FAILED;
                    ERRORTRACE( ( LOG_WMIADAP, "Unknown error with perflib access mutex in %S.\n",(LPWSTR)m_wstrServiceName) );
                }
            } // switch

            ReleaseMutex( m_hPLMutex );

            if ( NULL != pwcsExports )
            {
                delete [] pwcsExports;
            }

        }   // IF reg.Open
        else
        {
            hr = WBEM_E_FAILED;
            ERRORTRACE( ( LOG_WMIADAP, "Could not open the %S registry key.\n", wstr ) );
        }
    }
    else
    {
        ERRORTRACE( ( LOG_WMIADAP, "Performance library %S has not been loaded.\n",(LPWSTR)m_wstrServiceName) );
    }

    return hr;
}

HRESULT CAdapPerfLib::_GetPerfBlock( PERF_OBJECT_TYPE** ppData, DWORD* pdwBytes, DWORD* pdwNumObjTypes, BOOL fCostly )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Wraps a call to the perflib's collect function.  Will create progressively larger buffers
//  in a private heap to attempt to fetch the performance data block.
//
//  Parameters:
//      ppData          - a pointer to a buffer pointer for the data blob
//      pdwBytes        - a pointer to the byte-size of the data blob
//      pdwNumObjTypes  - a pointer to the number of objects in the data blob
//      fCostly         - a flag to determine what type of data to collect (costly or global)
//
//  NOTE: This should always return perf object type data, since we cannot specify a 
//  foreign computer, which would cause the collect function to return a PERF_DATA_BLOCK 
//  structure.
//  
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CAdapSafeBuffer SafeBuffer( m_wstrServiceName );    // The safe buffer
    DWORD   dwNumBytes = 0;                             // Byte counter for the buffer size
    DWORD   dwError = ERROR_MORE_DATA;                  // The return value for the collect function
    DWORD   Increment = 0x10000;

    // this is a workaround for perfproc.dll
    if (0 == _wcsicmp(m_wstrServiceName,L"perfproc"))
	{
        Increment = 0x100000;    
    }



    // Verify provider status 
    // ======================

    if ( m_fOpen )
    {
        // Sets the data-to-fetch parameter
        // ================================

        WCHAR*  pwcsValue = ( fCostly ? L"Costly" : L"Global" );
        
        // Start buffer at 64k (the guarded (safe) buffer is 2 * GUARD_BLOCK bytes smaller) 
        // ==================================================================================

        dwNumBytes = Increment;

        // Repeatedly attempt to collect the data until successful (buffer is sufficiently 
        // large), or the attempt fails for a reason other than buffer size
        // ===============================================================================

        while  ( (ERROR_MORE_DATA == dwError ) && ( SUCCEEDED( hr ) ) )
        {
            // Allocate a raw buffer of size dwNumBytes
            // ========================================

            hr = SafeBuffer.SetSize( dwNumBytes );

            // Collect the data from the perflib
            // =================================

            switch ( WaitForSingleObject( m_hPLMutex, PL_TIMEOUT ) )
            {
            case WAIT_OBJECT_0:
                {
                    try 
                    {
                        dwError = m_pfnCollectProc( pwcsValue,                                  
                                    SafeBuffer.GetSafeBufferPtrPtr(), 
                                    SafeBuffer.GetDataBlobSizePtr(), 
                                    SafeBuffer.GetNumObjTypesPtr() );

                        DEBUGTRACE( ( LOG_WMIADAP, "Collect called for %S returned %d\n", (LPCWSTR)m_wstrServiceName, dwError ) );
                    }
                    catch (...) 
                    {
                        SetStatus( ADAP_PERFLIB_FAILED );
                        hr = WBEM_E_FAILED;
                        
                        ERRORTRACE( ( LOG_WMIADAP, "Perflib Collection function has thrown an exception in %S.\n",(LPCWSTR)m_wstrServiceName) );
                        if (!m_EventLogCalled){
                            m_EventLogCalled = TRUE;
                            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_BAD_PERFLIB_EXCEPTION, (LPCWSTR)m_wstrServiceName, CHex( dwError ) );
                            
                        }
                    }
                }break;
            case WAIT_TIMEOUT:
                {
                    hr = WBEM_E_NOT_AVAILABLE;
                    ERRORTRACE( ( LOG_WMIADAP, "Perflib access mutex timed out in %S.\n",(LPCWSTR)m_wstrServiceName) );
                }break;
            case WAIT_ABANDONED:
                {
                    hr = WBEM_E_FAILED;
                    ERRORTRACE( ( LOG_WMIADAP, "Perflib access mutex was abandoned in %S.\n",(LPCWSTR)m_wstrServiceName) );
                }break;
            default:
                {
                    hr = WBEM_E_FAILED;
                    ERRORTRACE( ( LOG_WMIADAP, "Unknown error with perflib access mutex in %S.\n",(LPCWSTR)m_wstrServiceName) );
                }
            } // switch

            ReleaseMutex( m_hPLMutex );

            if ( SUCCEEDED( hr ) )
            {
                switch (dwError)
                {
                case ERROR_SUCCESS:
                    {
                        //
                        //  the Validate function can call ReportEvent 
                        //  by itself, and we don't want to bother user too much
                        //
                        hr = SafeBuffer.Validate(&m_EventLogCalled);

                        if ( SUCCEEDED( hr ) )
                        {
                            hr = SafeBuffer.CopyData( (BYTE**) ppData, pdwBytes, pdwNumObjTypes );
                        }
                        else
                        {
                            // Catastrophic error has occured
                            // ==============================

                            SetStatus( ADAP_PERFLIB_FAILED );

                            if (!m_EventLogCalled)
                            {
                                m_EventLogCalled = TRUE;
                                CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                                          WBEM_MC_ADAP_BAD_PERFLIB_INVALID_DATA,
									                      (LPCWSTR)m_wstrServiceName,
									                      CHex(hr));
								
                            }
                        }
                    } break;
                case ERROR_MORE_DATA:
                    {
                        dwNumBytes += Increment;
                    } break;
                default:
                    {
                        hr = WBEM_E_FAILED;
                        
                        m_CollectOK = FALSE;
                        
                        ERRORTRACE( ( LOG_WMIADAP, "Perflib Collection function has returned an unknown error(%d) in %S.\n", dwError,(LPCWSTR)m_wstrServiceName ) );
                        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_BAD_PERFLIB_BAD_RETURN, (LPCWSTR)m_wstrServiceName, CHex( dwError ) );
                    }
                } // switch
            } // IF SUCCEEDED()
        } // WHILE

        // Clean up the buffer
        // ===================
    } // IF CheckStatus
    else
    {
        ERRORTRACE( ( LOG_WMIADAP, "Performance library %S has not been loaded.\n",(LPCWSTR)m_wstrServiceName) );
    }

    return hr;
}

HRESULT CAdapPerfLib::_Close( void )
////////////////////////////////////////////////////////////////////////////////////////////
// 
//  Wraps a call to the perflib's close function.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Verify that the perflib is actually open
    // ========================================

    if ( m_fOpen )
    {
        // Get the mutex
        // =============

        switch ( WaitForSingleObject( m_hPLMutex, PL_TIMEOUT ) )
        {
        case WAIT_OBJECT_0:
            {
                try
                {
                    // And call the function
                    // =====================

                    if ( NULL != m_pfnCloseProc )
                    {
                        LONG lRet = m_pfnCloseProc();

                        DEBUGTRACE( ( LOG_WMIADAP, "Close called for %S returned %d\n", (LPCWSTR)m_wstrServiceName, lRet ) );
                    }

                    m_fOpen = FALSE;
                }
                catch (...)
                {
                    // Ooops... something blew, return error code
                    // ==========================================

                    SetStatus( ADAP_PERFLIB_FAILED );
                    hr = WBEM_E_FAILED;
                    ERRORTRACE( ( LOG_WMIADAP, "Perflib Close function has thrown an exception in %S.\n",(LPCWSTR)m_wstrServiceName) );
                    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_BAD_PERFLIB_EXCEPTION, (LPCWSTR)m_wstrServiceName, CHex( hr ) );
                }
            }break;
            case WAIT_TIMEOUT:
                {
                    hr = WBEM_E_NOT_AVAILABLE;
                    ERRORTRACE( ( LOG_WMIADAP, "Perflib access mutex timed out in %S.\n",(LPCWSTR)m_wstrServiceName) );
                }break;
            case WAIT_ABANDONED:
                {
                    hr = WBEM_E_FAILED;
                    ERRORTRACE( ( LOG_WMIADAP, "Perflib access mutex was abandoned in %S.\n",(LPCWSTR)m_wstrServiceName) );
                }break;
            default:
                {
                    hr = WBEM_E_FAILED;
                    ERRORTRACE( ( LOG_WMIADAP, "Unknown error with perflib access mutex in %S.\n",(LPCWSTR)m_wstrServiceName) );
                }       }

        ReleaseMutex( m_hPLMutex );
    }

    return hr;
}

HRESULT CAdapPerfLib::SetStatus(DWORD dwStatus)
{
    HRESULT hr = WBEM_NO_ERROR;

    m_dwStatus |= dwStatus;

    return hr;
}

HRESULT CAdapPerfLib::ClearStatus(DWORD dwStatus)
{
    HRESULT hr = WBEM_NO_ERROR;

    m_dwStatus &= ~dwStatus;

    return hr;
}

BOOL CAdapPerfLib::CheckStatus(DWORD dwStatus)
{
    return ((m_dwStatus & dwStatus) == dwStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\adapperf.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADAPPERF.H

Abstract:

History:

--*/

// Use this guy to build a map of index to display name from a localized
// Name Database  At this time, it just brute forces a class and a flex
// array, but could be modified to use an STL map just as easily.

#ifndef __ADAPPERF_H__
#define __ADAPPERF_H__

#include <wbemcomn.h>
#include "adapelem.h"
#include "ntreg.h"
#include "perfthrd.h"
#include "perflibschema.h"

// Registry definitions
// ====================

#define ADAP_PERFLIB_STATUS_KEY		L"WbemAdapStatus"
#define ADAP_PERFLIB_SIGNATURE		L"WbemAdapFileSignature"
#define ADAP_PERFLIB_SIZE           L"WbemAdapFileSize"
#define ADAP_PERFLIB_TIME           L"WbemAdapFileTime"

#define KNOWN_SERVICES              L"KnownSvcs"
#define ADAP_TIMESTAMP_FULL         L"LastFullDredgeTimestamp"

#define ADAP_PERFLIB_LASTCHANCE    3L
#define ADAP_PERFLIB_BOOBOO		   2L
#define ADAP_PERFLIB_PROCESSING	   1L
#define	ADAP_PERFLIB_OK			   0L
#define ADAP_PERFLIB_CORRUPT	  -1L

// Run time definitions
// ====================

#define ADAP_PERFLIB_IS_OK					0x0000L
#define ADAP_PERFLIB_IS_CORRUPT				0x0001L
#define ADAP_PERFLIB_IS_INACTIVE			0x0002L
#define ADAP_PERFLIB_FAILED					0x0004L
#define ADAP_PERFLIB_PREVIOUSLY_PROCESSED	0x0008L
#define ADAP_PERFLIB_IS_LOADED              0x0010L
#define ADAP_PERFLIB_IS_UNAVAILABLE	ADAP_PERFLIB_IS_CORRUPT | ADAP_PERFLIB_IS_INACTIVE // | ADAP_PERFLIB_IS_UNLOADED

// others
// the library has NO FirstCounter/LastCounter key
#define EX_STATUS_UNLOADED      0 
// the library has al least FirstCounter/LastCounter key
#define EX_STATUS_LOADABLE      1 
// the library has a Collect Function that fails
#define EX_STATUS_COLLECTFAIL   2 

typedef struct tagCheckLibStruct {
    BYTE Signature[16];
    FILETIME FileTime;
    DWORD FileSize;
} CheckLibStruct;

class CAdapSafeBuffer
{
	HANDLE	m_hPerfLibHeap;		// A handle to the private heap for the data block

	CHAR*	m_pGuardBytes;
	DWORD	m_dwGuardSize;

	BYTE*	m_pRawBuffer;

	BYTE*	m_pSafeBuffer;
	DWORD	m_dwSafeBufferSize;

	BYTE*	m_pCurrentPtr;
	DWORD	m_dwDataBlobSize;
	DWORD	m_dwNumObjects;

	HRESULT ValidateSafePointer( BYTE* pPtr );

	WString m_wstrServiceName;

public:
	CAdapSafeBuffer( WString wstrServiceName );
	virtual ~CAdapSafeBuffer();

	HRESULT SetSize( DWORD dwNumBytes );
	HRESULT Validate(BOOL * pSentToEventLog);
	HRESULT CopyData( BYTE** ppData, DWORD* pdwNumBytes, DWORD* pdwNumObjects );

	void** GetSafeBufferPtrPtr() { m_pCurrentPtr = m_pSafeBuffer; return (void**) &m_pCurrentPtr; }
	DWORD* GetDataBlobSizePtr() { m_dwDataBlobSize = m_dwSafeBufferSize; return &m_dwDataBlobSize; }
	DWORD* GetNumObjTypesPtr() {m_dwNumObjects = 0; return &m_dwNumObjects; }
};

class CPerfThread;
class CPerfLibSchema;

class CAdapPerfLib : public CAdapElement
{
private:

	CPerfThread*		m_pPerfThread;
	BOOL                m_EventLogCalled;
	BOOL                m_CollectOK;

	WString				m_wstrServiceName;	// The service name of the perflib
	WCHAR*				m_pwcsLibrary;		// The file name of the perflib
	WCHAR*				m_pwcsOpenProc;		// The name of the perflib's open function
	WCHAR*				m_pwcsCollectProc;	// The name of the perflib's collect function
	WCHAR*				m_pwcsCloseProc;	// The name of the perflib's close function

	PM_OPEN_PROC*		m_pfnOpenProc;		// The function pointer to the perflib's open function
	PM_COLLECT_PROC*	m_pfnCollectProc;	// The function pointer to the perflib's collect function
	PM_CLOSE_PROC*		m_pfnCloseProc;		// The function pointer to the perflib's close function
	HANDLE				m_hPLMutex;			// Used for serializing the calls to open/collect/close

	HRESULT				m_dwStatus;			// The status of the perflib
	BOOL				m_fOK;
	BOOL				m_fOpen;			// Flags whether the perflib's open function has been called

	HINSTANCE			m_hLib;				// The handle to the perflib

	HRESULT	Load(void);

protected:
	HRESULT InitializeEntryPoints(CNTRegistry & reg,WString & wszRegPath);

	HRESULT BeginProcessingStatus();
	HRESULT EndProcessingStatus();

	HRESULT GetFileSignature( CheckLibStruct * pCheckLib );
	HRESULT SetFileSignature();
	HRESULT CheckFileSignature();


	HRESULT VerifyLoaded();

public:
	CAdapPerfLib( LPCWSTR pwcsServiceName, DWORD * pLoadStatus );
	~CAdapPerfLib();

	HRESULT _Open( void );
	HRESULT	_Close( void );
	HRESULT	_GetPerfBlock( PERF_OBJECT_TYPE** ppData, DWORD* pdwBytes, DWORD* pdwNumObjTypes, BOOL fCostly );

	HRESULT Initialize(); 
	HRESULT Close();
	HRESULT Cleanup();

	BOOL IsOK( void )
	{
		return m_fOK;
	}

	LPCWSTR GetServiceName( void )
	{
		return m_wstrServiceName;
	}

	LPCWSTR GetLibraryName( void )
	{
		return m_pwcsLibrary;
	}

	HRESULT GetBlob( PERF_OBJECT_TYPE** ppPerfBlock, DWORD* pdwNumBytes, DWORD* pdwNumObjects, BOOL fCostly );

	HRESULT SetStatus( DWORD dwStatus );
	HRESULT ClearStatus( DWORD dwStatus );
	BOOL CheckStatus( DWORD dwStatus );
	BOOL IsCollectOK( void ){ return m_CollectOK; };
	BOOL GetEventLogCalled(){ return m_EventLogCalled; };
	void SetEventLogCalled(BOOL bVal){ m_EventLogCalled = bVal; };
	
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\adapthrd.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADAPTHRD.H

Abstract:

History:

--*/


#ifndef __ADAPTHRD_H__
#define __ADAPTHRD_H__

#include <wbemcomn.h>
#include <sync.h>
#include <execq.h>
#include <wbemint.h>
#include "adapelem.h"

///////////////////////////////////////////////////////////////////////////
//
//	Forward Declarations
//
///////////////////////////////////////////////////////////////////////////

class CAdapPerfLib;

///////////////////////////////////////////////////////////////////////////
//
//	CAdapThreadRequest
//
///////////////////////////////////////////////////////////////////////////

class CAdapThreadRequest : public CAdapElement
{
protected:
	HANDLE	m_hWhenDone;
	HRESULT	m_hrReturn;

public:
    CAdapThreadRequest();
    virtual ~CAdapThreadRequest();

    void SetWhenDoneHandle(HANDLE h) 
	{
		m_hWhenDone = h;
	}
    
	HANDLE GetWhenDoneHandle()
	{
		return m_hWhenDone;
	}

	HRESULT GetHRESULT( void )
	{
		return m_hrReturn;
	}

    virtual HRESULT Execute( CAdapPerfLib* pPerfLib ) = 0;
	virtual HRESULT EventLogError();
};

///////////////////////////////////////////////////////////////////////////
//
//	CAdapThread
//
///////////////////////////////////////////////////////////////////////////

class CAdapThread
{
private:

	CAdapPerfLib*	m_pPerfLib;		// The perflib being processed
	HANDLE			m_hThreadReady;	// The event to signal that the thread is ready

	HANDLE		m_hThread;			// The thread handle	
	DWORD		m_dwThreadId;		// The thread ID
	HANDLE		m_hEventQuit;		// Thread termination event

	CFlexArray	m_RequestQueue;		// The queue
	HANDLE		m_hSemReqPending;	// The queue counter

	BOOL		m_fOk;				// Initialization flag
	CCritSec	m_cs;

	static unsigned __stdcall ThreadProc( void * pVoid );

	unsigned RealEntry( void );

protected:

	BOOL Init( void );
	virtual BOOL Clear( BOOL fClose = TRUE );

	HRESULT Begin( void );
	HRESULT Reset( void );

public:
	CAdapThread( CAdapPerfLib* pPerfLib );
	virtual ~CAdapThread();


	// Assigns us work to do.
	HRESULT Enqueue( CAdapThreadRequest* pRequest );

	// Gently closes the thread
	HRESULT Shutdown( DWORD dwTimeout = 60000 );

	BOOL IsOk( void )
	{
		return m_fOk;
	}
};

#include "adapperf.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\adapthrd.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADAPTHRD.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <process.h>
#include <wbemcli.h>
#include <cominit.h>
#include "ntreg.h"
#include "adapthrd.h"

//  IMPORTANT!!!!

//  This code MUST be revisited to do the following:
//  A>>>>>  Exception Handling around the outside calls
//  B>>>>>  Use a named mutex around the calls
//  C>>>>>  Make the calls on another thread
//  D>>>>>  Place and handle registry entries that indicate a bad DLL!

////////////////////////////////////////////////////////////////////////////////////////////
//
//                              CAdapThreadRequest
//
////////////////////////////////////////////////////////////////////////////////////////////

CAdapThreadRequest::CAdapThreadRequest( void )
:   m_hWhenDone( NULL ),
    m_hrReturn( WBEM_S_NO_ERROR )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Constructor
//
////////////////////////////////////////////////////////////////////////////////////////////
{
}

CAdapThreadRequest::~CAdapThreadRequest( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Destructor
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    if ( NULL != m_hWhenDone )
    {
        CloseHandle( m_hWhenDone );
    }
}

HRESULT CAdapThreadRequest::EventLogError( void )
{
    return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//                              CAdapThread
//
////////////////////////////////////////////////////////////////////////////////////////////

CAdapThread::CAdapThread( CAdapPerfLib* pPerfLib )
:   m_pPerfLib( pPerfLib ),
    m_hEventQuit( NULL ),
    m_hSemReqPending( NULL ),
    m_hThread( NULL ),
    m_fOk( FALSE )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Constructor
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    // Initialize the control members
    // ==============================

    Init();
}

CAdapThread::~CAdapThread()
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Destructor
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    if ( NULL != m_hThread )
    {
        Shutdown();
    }

    Clear();

    // Clean up the queue
    // ==================

    while ( m_RequestQueue.Size() > 0 )
    {
        CAdapThreadRequest* pRequest = (CAdapThreadRequest*) m_RequestQueue.GetAt( 0 );
