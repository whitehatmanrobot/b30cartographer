net;
    NDIS_OID IpxOid;
    ULONG MacOptions;
    ULONG PacketFilter;
    PNDIS_STRING AdapterString = &ConfigBinding->AdapterName;

    //
    // Initialize this adapter for IPX use through NDIS
    //

    //
    // This event is used in case any of the NDIS requests
    // pend; we wait until it is set by the completion
    // routine, which also sets NdisRequestStatus.
    //

    KeInitializeEvent(
        &Adapter->NdisRequestEvent,
        NotificationEvent,
        FALSE
    );

    Adapter->NdisBindingHandle = NULL;

    OpenErrorStatus = 0;

    NdisOpenAdapter (
        &NdisStatus,
        &OpenErrorStatus,
        &Adapter->NdisBindingHandle,
        &SelectedMedium,
        IpxSupportedMedia,
        sizeof (IpxSupportedMedia) / sizeof(NDIS_MEDIUM),
        IpxNdisProtocolHandle,
        (NDIS_HANDLE)Adapter,
        &ConfigBinding->AdapterName,
        0,
        NULL);

    if (NdisStatus == NDIS_STATUS_PENDING) {

        //
        // The completion routine will set NdisRequestStatus.
        //

        KeWaitForSingleObject(
            &Adapter->NdisRequestEvent,
            Executive,
            KernelMode,
            TRUE,
            (PLARGE_INTEGER)NULL
            );

        NdisStatus = Adapter->NdisRequestStatus;
        OpenErrorStatus = Adapter->OpenErrorStatus;

        KeResetEvent(
            &Adapter->NdisRequestEvent
            );

    }

    if (NdisStatus != NDIS_STATUS_SUCCESS) {

        IPX_DEBUG (NDIS, ("Open %ws failed %lx\n", ConfigBinding->AdapterName.Buffer, NdisStatus));

        IpxWriteGeneralErrorLog(
            Adapter->Device->DeviceObject,
            EVENT_TRANSPORT_ADAPTER_NOT_FOUND,
            807,
            NdisStatus,
            AdapterString->Buffer,
            1,
            &OpenErrorStatus);
        return STATUS_INSUFFICIENT_RESOURCES;

    } else {

        IPX_DEBUG (NDIS, ("Open %ws succeeded\n", ConfigBinding->AdapterName.Buffer));
    }


    //
    // Get the information we need about the adapter, based on
    // the media type.
    //

    MacInitializeMacInfo(
        IpxSupportedMedia[SelectedMedium],
        &Adapter->MacInfo);


    switch (Adapter->MacInfo.RealMediumType) {

    case NdisMedium802_3:

        IpxOid = OID_802_3_CURRENT_ADDRESS;
        break;

    case NdisMedium802_5:

        IpxOid = OID_802_5_CURRENT_ADDRESS;
        break;

    case NdisMediumFddi:

        IpxOid = OID_FDDI_LONG_CURRENT_ADDR;
        break;

    case NdisMediumArcnet878_2:

        IpxOid = OID_ARCNET_CURRENT_ADDRESS;
        break;

    case NdisMediumWan:

        IpxOid = OID_WAN_CURRENT_ADDRESS;
        break;

    default:
       
       // 301870
       return NDIS_STATUS_FAILURE;
    
    }

    IpxRequest.RequestType = NdisRequestQueryInformation;
    IpxRequest.DATA.QUERY_INFORMATION.Oid = IpxOid;

    if (IpxOid != OID_ARCNET_CURRENT_ADDRESS) {

        IpxRequest.DATA.QUERY_INFORMATION.InformationBuffer = Adapter->LocalMacAddress.Address;
        IpxRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 6;

    } else {

        //
        // We take the arcnet single-byte address and right-justify
        // it in a field of zeros.
        //

        RtlZeroMemory (Adapter->LocalMacAddress.Address, 5);
        IpxRequest.DATA.QUERY_INFORMATION.InformationBuffer = &Adapter->LocalMacAddress.Address[5];
        IpxRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 1;

    }

    NdisStatus = IpxSubmitNdisRequest (Adapter, &IpxRequest, AdapterString);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        IpxCloseNdis (Adapter);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Now query the maximum packet sizes.
    //

    IpxRequest.RequestType = NdisRequestQueryInformation;
    IpxRequest.DATA.QUERY_INFORMATION.Oid = OID_GEN_MAXIMUM_FRAME_SIZE;
    IpxRequest.DATA.QUERY_INFORMATION.InformationBuffer = &(Adapter->MaxReceivePacketSize);
    IpxRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 4;

    NdisStatus = IpxSubmitNdisRequest (Adapter, &IpxRequest, AdapterString);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        IpxCloseNdis (Adapter);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    IpxRequest.RequestType = NdisRequestQueryInformation;
    IpxRequest.DATA.QUERY_INFORMATION.Oid = OID_GEN_MAXIMUM_TOTAL_SIZE;
    IpxRequest.DATA.QUERY_INFORMATION.InformationBuffer = &(Adapter->MaxSendPacketSize);
    IpxRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 4;

    NdisStatus = IpxSubmitNdisRequest (Adapter, &IpxRequest, AdapterString);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        IpxCloseNdis (Adapter);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Query the receive buffer space.
    //

    IpxRequest.RequestType = NdisRequestQueryInformation;
    IpxRequest.DATA.QUERY_INFORMATION.Oid = OID_GEN_RECEIVE_BUFFER_SPACE;
    IpxRequest.DATA.QUERY_INFORMATION.InformationBuffer = &(Adapter->ReceiveBufferSpace);
    IpxRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 4;

    NdisStatus = IpxSubmitNdisRequest (Adapter, &IpxRequest, AdapterString);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        IpxCloseNdis (Adapter);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Now set the minimum lookahead size. The value we choose
    // here is the 128 needed for TDI indications, plus the size
    // of the IPX header, plus the largest extra header possible
    // (a SNAP header, 8 bytes), plus the largest higher-level
    // header (I think it is a Netbios datagram, 34 bytes).
    //
    // Adapt this based on higher-level bindings and
    // configured frame types.
    //

    MinimumLookahead = 128 + sizeof(IPX_HEADER) + 8 + 34;
    IpxRequest.RequestType = NdisRequestSetInformation;
    IpxRequest.DATA.QUERY_INFORMATION.Oid = OID_GEN_CURRENT_LOOKAHEAD;
    IpxRequest.DATA.QUERY_INFORMATION.InformationBuffer = &MinimumLookahead;
    IpxRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 4;

    NdisStatus = IpxSubmitNdisRequest (Adapter, &IpxRequest, AdapterString);
#define HACK 
    if (NdisStatus != NDIS_STATUS_SUCCESS) {
#if defined HACK
       KdPrint(("IPX: OID_GEN_CURRENT_LOOKAHEAD FAiled\n"));
       MinimumLookahead = 200;
#else //!HACK
        IpxCloseNdis (Adapter);
        return STATUS_INSUFFICIENT_RESOURCES;
#endif //HACK
        // The above hack is to deal with NDIS's incorrect handling on 
        // the LOOKAHEAD request. 
    }


    //
    // Now query the link speed
    //

    IpxRequest.RequestType = NdisRequestQueryInformation;
    IpxRequest.DATA.QUERY_INFORMATION.Oid = OID_GEN_LINK_SPEED;
    IpxRequest.DATA.QUERY_INFORMATION.InformationBuffer = &(Adapter->MediumSpeed);
    IpxRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 4;

    NdisStatus = IpxSubmitNdisRequest (Adapter, &IpxRequest, AdapterString);

    if (NdisStatus != NDIS_STATUS_SUCCESS || Adapter->MediumSpeed == 0) {
        IpxCloseNdis (Adapter);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // For wan, specify our protocol ID and header format.
    // We don't query the medium subtype because we don't
    // case (since we require ethernet emulation).
    //

    if (Adapter->MacInfo.MediumAsync) {

        if (Adapter->BindSap != 0x8137) {
            *(UNALIGNED USHORT *)(&WanProtocolId[4]) = Adapter->BindSapNetworkOrder;
        }
        IpxRequest.RequestType = NdisRequestSetInformation;
        IpxRequest.DATA.QUERY_INFORMATION.Oid = OID_WAN_PROTOCOL_TYPE;
        IpxRequest.DATA.QUERY_INFORMATION.InformationBuffer = WanProtocolId;
        IpxRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 6;

        NdisStatus = IpxSubmitNdisRequest (Adapter, &IpxRequest, AdapterString);

        if (NdisStatus != NDIS_STATUS_SUCCESS) {
            IpxCloseNdis (Adapter);
            return STATUS_INSUFFICIENT_RESOURCES;
        }


        IpxRequest.RequestType = NdisRequestSetInformation;
        IpxRequest.DATA.QUERY_INFORMATION.Oid = OID_WAN_HEADER_FORMAT;
        IpxRequest.DATA.QUERY_INFORMATION.InformationBuffer = &WanHeaderFormat;
        IpxRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 4;

        NdisStatus = IpxSubmitNdisRequest (Adapter, &IpxRequest, AdapterString);

        if (NdisStatus != NDIS_STATUS_SUCCESS) {
            IpxCloseNdis (Adapter);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Now query the line count.
        //
	// NDIS returns 252
	
        IpxRequest.RequestType = NdisRequestQueryInformation;
        IpxRequest.DATA.QUERY_INFORMATION.Oid = OID_WAN_LINE_COUNT;
        IpxRequest.DATA.QUERY_INFORMATION.InformationBuffer = &Adapter->WanNicIdCount;
        IpxRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 4;

        NdisStatus = IpxSubmitNdisRequest (Adapter, &IpxRequest, AdapterString);

        if (NdisStatus != NDIS_STATUS_SUCCESS) {
	    DbgPrint("NdisRequest WAN_LINE_COUNT failed with status (%x)\n",NdisStatus); 
	    Adapter->WanNicIdCount = 1;
        }

        //
        // We dont need static info anymore. We just do it on demand...
        // 
	// Allocating WAN line on demand is not done yet, the comment above
	// is BS. 

        // Adapter->WanNicIdCount = 1;

        if (Adapter->WanNicIdCount == 0) {

            IPX_DEBUG (NDIS, ("OID_WAN_LINE_COUNT returned 0 lines\n"));

            IpxWriteOidErrorLog(
                Adapter->Device->DeviceObject,
                EVENT_TRANSPORT_QUERY_OID_FAILED,
                NDIS_STATUS_INVALID_DATA,
                AdapterString->Buffer,
                OID_WAN_LINE_COUNT);

            IpxCloseNdis (Adapter);
            return STATUS_INSUFFICIENT_RESOURCES;

        }
    }


    //
    // For 802.5 adapter's configured that way, we enable the
    // functional address (C0-00-00-80-00-00).
    //

    if ((Adapter->MacInfo.MediumType == NdisMedium802_5) &&
        (Adapter->EnableFunctionalAddress)) {

        //
        // For token-ring, we pass the last four bytes of the
        // Netbios functional address.
        //

        IpxRequest.RequestType = NdisRequestSetInformation;
        IpxRequest.DATA.QUERY_INFORMATION.Oid = OID_802_5_CURRENT_FUNCTIONAL;
        IpxRequest.DATA.QUERY_INFORMATION.InformationBuffer = FunctionalAddress;
        IpxRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 4;

        NdisStatus = IpxSubmitNdisRequest (Adapter, &IpxRequest, AdapterString);

        if (NdisStatus != NDIS_STATUS_SUCCESS) {
            IpxCloseNdis (Adapter);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }


    //
    // Now query the MAC's optional characteristics.
    //

    IpxRequest.RequestType = NdisRequestQueryInformation;
    IpxRequest.DATA.QUERY_INFORMATION.Oid = OID_GEN_MAC_OPTIONS;
    IpxRequest.DATA.QUERY_INFORMATION.InformationBuffer = &MacOptions;
    IpxRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 4;

    NdisStatus = IpxSubmitNdisRequest (Adapter, &IpxRequest, AdapterString);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        IpxCloseNdis (Adapter);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Adapter->MacInfo.CopyLookahead =
        ((MacOptions & NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA) != 0) ?
            TDI_RECEIVE_COPY_LOOKAHEAD : 0;
    Adapter->MacInfo.MacOptions = MacOptions;


    switch (Adapter->MacInfo.MediumType) {

    case NdisMedium802_3:
        Adapter->DefHeaderSizes[ISN_FRAME_TYPE_802_2] = 17;
        Adapter->DefHeaderSizes[ISN_FRAME_TYPE_802_3] = 14;
        Adapter->DefHeaderSizes[ISN_FRAME_TYPE_ETHERNET_II] = 14;
        Adapter->DefHeaderSizes[ISN_FRAME_TYPE_SNAP] = 22;
        Adapter->BcMcHeaderSizes[ISN_FRAME_TYPE_802_2] = 17;
        Adapter->BcMcHeaderSizes[ISN_FRAME_TYPE_802_3] = 14;
        Adapter->BcMcHeaderSizes[ISN_FRAME_TYPE_ETHERNET_II] = 14;
        Adapter->BcMcHeaderSizes[ISN_FRAME_TYPE_SNAP] = 22;
        break;

    case NdisMedium802_5:
        Adapter->DefHeaderSizes[ISN_FRAME_TYPE_802_2] = 17;
        Adapter->DefHeaderSizes[ISN_FRAME_TYPE_802_3] = 17;
        Adapter->DefHeaderSizes[ISN_FRAME_TYPE_ETHERNET_II] = 17;
        Adapter->DefHeaderSizes[ISN_FRAME_TYPE_SNAP] = 22;
        Adapter->BcMcHeaderSizes[ISN_FRAME_TYPE_802_2] = 17;
        Adapter->BcMcHeaderSizes[ISN_FRAME_TYPE_802_3] = 17;
        Adapter->BcMcHeaderSizes[ISN_FRAME_TYPE_ETHERNET_II] = 17;
        Adapter->BcMcHeaderSizes[ISN_FRAME_TYPE_SNAP] = 22;
        break;

    case NdisMediumFddi:
        Adapter->DefHeaderSizes[ISN_FRAME_TYPE_802_2] = 16;
        Adapter->DefHeaderSizes[ISN_FRAME_TYPE_802_3] = 13;
        Adapter->DefHeaderSizes[ISN_FRAME_TYPE_ETHERNET_II] = 16;
        Adapter->DefHeaderSizes[ISN_FRAME_TYPE_SNAP] = 21;
        Adapter->BcMcHeaderSizes[ISN_FRAME_TYPE_802_2] = 16;
        Adapter->BcMcHeaderSizes[ISN_FRAME_TYPE_802_3] = 13;
        Adapter->BcMcHeaderSizes[ISN_FRAME_TYPE_ETHERNET_II] = 16;
        Adapter->BcMcHeaderSizes[ISN_FRAME_TYPE_SNAP] = 21;
        break;

    case NdisMediumArcnet878_2:
        Adapter->DefHeaderSizes[ISN_FRAME_TYPE_802_2] = 3;
        Adapter->DefHeaderSizes[ISN_FRAME_TYPE_802_3] = 3;
        Adapter->DefHeaderSizes[ISN_FRAME_TYPE_ETHERNET_II] = 3;
        Adapter->DefHeaderSizes[ISN_FRAME_TYPE_SNAP] = 3;
        Adapter->BcMcHeaderSizes[ISN_FRAME_TYPE_802_2] = 3;
        Adapter->BcMcHeaderSizes[ISN_FRAME_TYPE_802_3] = 3;
        Adapter->BcMcHeaderSizes[ISN_FRAME_TYPE_ETHERNET_II] = 3;
        Adapter->BcMcHeaderSizes[ISN_FRAME_TYPE_SNAP] = 3;
        break;

    }

    //
    // If functional filtering is set, set the address
    // for the appropriate binding.
    //

    //
    // Now that everything is set up, we enable the filter
    // for packet reception.
    //

    switch (Adapter->MacInfo.MediumType) {

    case NdisMedium802_3:
    case NdisMediumFddi:
    case NdisMedium802_5:
    case NdisMediumArcnet878_2:

        //
        // If we have a virtual network number we need to receive
        // broadcasts (either the router will be bound in which
        // case we want them, or we need to respond to rip requests
        // ourselves).
        //

        PacketFilter = NDIS_PACKET_TYPE_DIRECTED;

        if (Adapter->Device->VirtualNetworkNumber != 0) {

            Adapter->BroadcastEnabled = TRUE;
            
            // [MS]
            // New scheme: EnableBroadcastCount incremented for every client who
            //             is interested in BCAST. Decrement this when someone 
            //             doesnt want it. If the count goes to 0, we remove this 
            //             quality in the adapter. At IPXDevice creation, we set it
            //             to 0.
            //
            // Adapter->Device->EnableBroadcastCount = 1; 
            PacketFilter |= NDIS_PACKET_TYPE_BROADCAST;

            if ((Adapter->MacInfo.MediumType == NdisMedium802_5) && (Adapter->EnableFunctionalAddress)) {
                PacketFilter |= NDIS_PACKET_TYPE_FUNCTIONAL;
            }

        } else {

            Adapter->BroadcastEnabled = FALSE;
            Adapter->Device->EnableBroadcastCount = 0;

        }

        break;

    default:

        CTEAssert (FALSE);
        break;

    }

    //
    // Now fill in the NDIS_REQUEST.
    //

    IpxRequest.RequestType = NdisRequestSetInformation;
    IpxRequest.DATA.SET_INFORMATION.Oid = OID_GEN_CURRENT_PACKET_FILTER;
    IpxRequest.DATA.SET_INFORMATION.InformationBuffer = &PacketFilter;
    IpxRequest.DATA.SET_INFORMATION.InformationBufferLength = sizeof(ULONG);

    NdisStatus = IpxSubmitNdisRequest (Adapter, &IpxRequest, AdapterString);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        IpxCloseNdis (Adapter);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    return STATUS_SUCCESS;

}   /* IpxInitializeNdis */


VOID
IpxAddBroadcast(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine is called when another reason for enabling
    broadcast reception is added. If it is the first, then
    reception on the card is enabled by queueing a call to
    IpxBroadcastOperation.

    THIS ROUTINE IS CALLED WITH THE DEVICE LOCK HELD.

Arguments:

    Device - The IPX device.

Return Value:

    None.

--*/

{

    ++Device->EnableBroadcastCount;

    if (Device->EnableBroadcastCount == 1) {

        //
        // Broadcasts should be enabled.
        //

        if (!Device->EnableBroadcastPending) {

            if (Device->DisableBroadcastPending) {
                Device->ReverseBroadcastOperation = TRUE;
            } else {
                Device->EnableBroadcastPending = TRUE;
                IpxBroadcastOperation((PVOID)TRUE);
            }
        }
    }

}   /* IpxAddBroadcast */


VOID
IpxRemoveBroadcast(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine is called when a reason for enabling
    broadcast reception is removed. If it is the last, then
    reception on the card is disabled by queueing a call to
    IpxBroadcastOperation.

    THIS ROUTINE IS CALLED WITH THE DEVICE LOCK HELD.

Arguments:

    Device - The IPX device.

Return Value:

    None.

--*/

{

    --Device->EnableBroadcastCount;

    if (Device->EnableBroadcastCount <= 0) {

        //
        // Broadcasts should be disabled.
        //

        if (!Device->DisableBroadcastPending) {

            if (Device->EnableBroadcastPending) {
                Device->ReverseBroadcastOperation = TRUE;
            } else {
                Device->DisableBroadcastPending = TRUE;
                IpxBroadcastOperation((PVOID)FALSE);
            }
        }
    }

}   /* IpxRemoveBroadcast */


VOID
IpxBroadcastOperation(
    IN PVOID Parameter
    )

/*++

Routine Description:

    This routine is used to change whether broadcast reception
    is enabled or disabled. It performs the requested operation
    on every adapter bound to by IPX.

    This routine is called by a worker thread queued when a
    bind/unbind operation changes the broadcast state.

    [ShreeM] New scheme: EnableBroadcastCount incremented for every client who
    is interested in BCAST. Decrement this when someone 
    doesnt want it. If the count goes to 0, we remove this 
    quality in the adapter. At IPXDevice creation, we set it
    to 0.

Arguments:

    Parameter - TRUE if broadcasts should be enabled, FALSE
        if  they should be disabled.

Return Value:

    None.

--*/

{
    PDEVICE Device = IpxDevice;
    BOOLEAN Enable = (BOOLEAN)Parameter;
    UINT i;
    PBINDING Binding;
    PADAPTER Adapter;
    ULONG PacketFilter;
    NDIS_REQUEST IpxRequest;
    NDIS_STRING AdapterName;
    CTELockHandle LockHandle;

	IPX_DEFINE_LOCK_HANDLE(LockHandle1)
	IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

	IPX_DEBUG (NDIS, ("%s operation started\n", Enable ? "Enable" : "Disable"));

    {
    ULONG   Index = MIN (Device->MaxBindings, Device->ValidBindings);

    for (i = FIRST_REAL_BINDING; i <= Index; i++) {

        Binding = NIC_ID_TO_BINDING(Device, i);
        if (Binding == NULL) {
            continue;
        }

        Adapter = Binding->Adapter;
        if (Adapter->BroadcastEnabled == Enable) {
            continue;
        }

        if (Enable) {
            if ((Adapter->MacInfo.MediumType == NdisMedium802_5) && (Adapter->EnableFunctionalAddress)) {
                PacketFilter = (NDIS_PACKET_TYPE_DIRECTED | NDIS_PACKET_TYPE_BROADCAST | NDIS_PACKET_TYPE_FUNCTIONAL);
            } else {
                PacketFilter = (NDIS_PACKET_TYPE_DIRECTED | NDIS_PACKET_TYPE_BROADCAST);
            }
        } else {
            PacketFilter = NDIS_PACKET_TYPE_DIRECTED;
        }

        //
        // Now fill in the NDIS_REQUEST.
        //
        
        RtlZeroMemory(&IpxRequest, sizeof(NDIS_REQUEST));

        IpxRequest.RequestType = NdisRequestSetInformation;
        IpxRequest.DATA.SET_INFORMATION.Oid = OID_GEN_CURRENT_PACKET_FILTER;
        IpxRequest.DATA.SET_INFORMATION.InformationBuffer = &PacketFilter;
        IpxRequest.DATA.SET_INFORMATION.InformationBufferLength = sizeof(ULONG);

        AdapterName.Buffer = Adapter->AdapterName;
        AdapterName.Length = (USHORT)Adapter->AdapterNameLength;
        AdapterName.MaximumLength = (USHORT)(Adapter->AdapterNameLength + sizeof(WCHAR));

    	IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

        (VOID)IpxSubmitNdisRequest (Adapter, &IpxRequest, &AdapterName);

    	IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

        Adapter->BroadcastEnabled = Enable;

    }
    }
	IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

    CTEGetLock (&Device->Lock, &LockHandle);

    if (Enable) {

        CTEAssert (Device->EnableBroadcastPending);
        Device->EnableBroadcastPending = FALSE;

        if (Device->ReverseBroadcastOperation) {
            Device->ReverseBroadcastOperation = FALSE;
            Device->DisableBroadcastPending = TRUE;
            ExInitializeWorkItem(
                &Device->BroadcastOperationQueueItem,
                IpxBroadcastOperation,
                (PVOID)FALSE);
            ExQueueWorkItem(&Device->BroadcastOperationQueueItem, DelayedWorkQueue);
        }

    } else {

        CTEAssert (Device->DisableBroadcastPending);
        Device->DisableBroadcastPending = FALSE;

        if (Device->ReverseBroadcastOperation) {
            Device->ReverseBroadcastOperation = FALSE;
            Device->EnableBroadcastPending = TRUE;
            ExInitializeWorkItem(
                &Device->BroadcastOperationQueueItem,
                IpxBroadcastOperation,
                (PVOID)TRUE);
            ExQueueWorkItem(&Device->BroadcastOperationQueueItem, DelayedWorkQueue);
        }

    }
    
    CTEFreeLock (&Device->Lock, LockHandle);

}/* IpxBroadcastOperation */


VOID
IpxCloseNdis(
    IN PADAPTER Adapter
    )

/*++

Routine Description:

    This routine unbinds the transport from the NDIS interface and does
    any other work required to undo what was done in IpxInitializeNdis.
    It is written so that it can be called from within IpxInitializeNdis
    if it fails partway through.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

Return Value:

    The function value is the status of the operation.

--*/

{
    NDIS_STATUS ndisStatus;

    //
    // Close the NDIS binding.
    //

    if (Adapter->NdisBindingHandle != (NDIS_HANDLE)NULL) {

        //
        // This event is used in case any of the NDIS requests
        // pend; we wait until it is set by the completion
        // routine, which also sets NdisRequestStatus.
        //

        KeInitializeEvent(
            &Adapter->NdisRequestEvent,
            NotificationEvent,
            FALSE
        );

        NdisCloseAdapter(
            &ndisStatus,
            Adapter->NdisBindingHandle);

 	Adapter->NdisBindingHandle = (NDIS_HANDLE)NULL;

        if (ndisStatus == NDIS_STATUS_PENDING) {

            //
            // The completion routine will set NdisRequestStatus.
            //

            KeWaitForSingleObject(
                &Adapter->NdisRequestEvent,
                Executive,
                KernelMode,
                TRUE,
                (PLARGE_INTEGER)NULL
                );

            ndisStatus = Adapter->NdisRequestStatus;

            KeResetEvent(
                &Adapter->NdisRequestEvent
                );

        }

       
        //
        // We ignore ndisStatus.
        //

    }

#if 0
    if (Adapter->SendPacketPoolHandle != NULL) {
        NdisFreePacketPool (Adapter->SendPacketPoolHandle);
    }

    if (Adapter->ReceivePacketPoolHandle != NULL) {
        NdisFreePacketPool (Adapter->ReceivePacketPoolHandle);
    }

    if (Adapter->NdisBufferPoolHandle != NULL) {
        NdisFreeBufferPool (Adapter->NdisBufferPoolHandle);
    }
#endif

}   /* IpxCloseNdis */


VOID
IpxOpenAdapterComplete(
    IN NDIS_HANDLE BindingContext,
    IN NDIS_STATUS NdisStatus,
    IN NDIS_STATUS OpenErrorStatus
    )

/*++

Routine Description:

    This routine is called by NDIS to indicate that an open adapter
    is complete. Since we only ever have one outstanding, and then only
    during initialization, all we do is record the status and set
    the event to signalled to unblock the initialization thread.

Arguments:

    BindingContext - Pointer to the device object for this driver.

    NdisStatus - The request completion code.

    OpenErrorStatus - More status information.

Return Value:

    None.

--*/

{
    PADAPTER Adapter = (PADAPTER)BindingContext;

    Adapter->NdisRequestStatus = NdisStatus;
    Adapter->OpenErrorStatus = OpenErrorStatus;

    KeSetEvent(
        &Adapter->NdisRequestEvent,
        0L,
        FALSE);

}   /* IpxOpenAdapterComplete */

VOID
IpxCloseAdapterComplete(
    IN NDIS_HANDLE BindingContext,
    IN NDIS_STATUS NdisStatus
    )

/*++

Routine Description:

    This routine is called by NDIS to indicate that a close adapter
    is complete. Currently we don't close adapters, so this is not
    a problem.

Arguments:

    BindingContext - Pointer to the device object for this driver.

    NdisStatus - The request completion code.

Return Value:

    None.

--*/

{
    PADAPTER Adapter = (PADAPTER)BindingContext;

    Adapter->NdisRequestStatus = NdisStatus;

    KeSetEvent(
        &Adapter->NdisRequestEvent,
        0L,
        FALSE);

}   /* IpxCloseAdapterComplete */


VOID
IpxResetComplete(
    IN NDIS_HANDLE BindingContext,
    IN NDIS_STATUS NdisStatus
    )

/*++

Routine Description:

    This routine is called by NDIS to indicate that a reset adapter
    is complete. Currently we don't reset adapters, so this is not
    a problem.

Arguments:

    BindingContext - Pointer to the device object for this driver.

    NdisStatus - The request completion code.

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER(BindingContext);
    UNREFERENCED_PARAMETER(NdisStatus);

}   /* IpxResetComplete */


VOID
IpxRequestComplete(
    IN NDIS_HANDLE BindingContext,
    IN PNDIS_REQUEST NdisRequest,
    IN NDIS_STATUS NdisStatus
    )

/*++

Routine Description:

    This routine is called by NDIS to indicate that a request is complete.
    Since we only ever have one request outstanding, and then only
    during initialization, all we do is record the status and set
    the event to signalled to unblock the initialization thread.

Arguments:

    BindingContext - Pointer to the device object for this driver.

    NdisRequest - The object describing the request.

    NdisStatus - The request completion code.

Return Value:

    None.

--*/

{
    PADAPTER Adapter = (PADAPTER)BindingContext;
    PIPX_NDIS_REQUEST IpxRequest = (PIPX_NDIS_REQUEST) NdisRequest; 

    IpxRequest->Status = NdisStatus; 

    KeSetEvent(
        &IpxRequest->NdisRequestEvent,
        0L,
        FALSE);

}   /* IpxRequestComplete */


VOID
IpxStatus(
    IN NDIS_HANDLE NdisBindingContext,
    IN NDIS_STATUS NdisStatus,
    IN PVOID StatusBuffer,
    IN UINT StatusBufferSize
    )
{
    PADAPTER Adapter, TmpAdapter;

	PNDIS_WAN_LINE_UP	LineUp;
	PNDIS_WAN_LINE_DOWN	LineDown;
    PIPXCP_CONFIGURATION Configuration;     // contains ipx net and node

    BOOLEAN UpdateLineUp;
    PBINDING Binding, TmpBinding;
    PDEVICE Device;
    PADDRESS Address;
    ULONG CurrentHash;
    PIPX_ROUTE_ENTRY RouteEntry;
    PNDIS_BUFFER NdisBuffer;
    PNWLINK_ACTION NwlinkAction;
    PIPX_ADDRESS_DATA IpxAddressData;
    PREQUEST Request;
    UINT BufferLength;
    IPX_LINE_INFO LineInfo;
    ULONG Segment;
    ULONG LinkSpeed;
    PLIST_ENTRY p;
    NTSTATUS Status;
#ifdef SUNDOWN
    // To avoid a warning when Binding->NicId = i;    
    // Assume we have no more than 16-bit number of binding. 
    USHORT i, j;
#else
    UINT i, j;
#endif
    IPX_DEFINE_LOCK_HANDLE (LockHandle)
    IPX_DEFINE_LOCK_HANDLE (OldIrq)
    NTSTATUS    ntStatus;
    CTEEvent                *Event;
    KIRQL irql;

    IPX_DEFINE_LOCK_HANDLE(LockHandle1)
    Adapter = (PADAPTER)NdisBindingContext;

	IpxReferenceAdapter(Adapter);

    Device = Adapter->Device;
    
    switch (NdisStatus) {

    case NDIS_STATUS_WAN_LINE_UP:


        //
        // If the line is already up, then we are just getting
        // a change in line conditions, and the IPXCP_CONFIGURATION
        // information is not included. If it turns out we need
        // all the info, we check the size again later.
        //

        if (StatusBufferSize < sizeof(NDIS_WAN_LINE_UP)) {
            IPX_DEBUG (WAN, ("Line up, status buffer size wrong %d/%d\n", StatusBufferSize, sizeof(NDIS_WAN_LINE_UP)));
			goto error_no_lock;
        }

        LineUp = (PNDIS_WAN_LINE_UP)StatusBuffer;

        //
        // We scan through the adapter's NIC ID range looking
        // for an active binding with the same remote address.
        //

        UpdateLineUp = FALSE;

		//
		// See if this is a new lineup or not
		//
		*((ULONG UNALIGNED *)(&Binding)) =
		*((ULONG UNALIGNED *)(&LineUp->LocalAddress[2]));

        IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
 
		if (Binding != NULL) {
			UpdateLineUp = TRUE;
		}

		if (LineUp->ProtocolType != Adapter->BindSap) {
            IPX_DEBUG (WAN, ("Line up, wrong protocol type %lx\n", LineUp->ProtocolType));

			IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
 			goto	error_no_lock;
		}

		Configuration = (PIPXCP_CONFIGURATION)LineUp->ProtocolBuffer;

		//
		// PNP_POWER - We hold the exclusive lock to the binding array (thru both the device and adapter)
		// and the reference to the adapter at this point.
		//

        //
        // If this line was previously down, create a new binding
        // if needed.
        //

        if (!UpdateLineUp) {

            //
            // We look for a binding that is allocated but down, if
            // we can't find that then we look for any empty spot in
            // the adapter's NIC ID range and allocate a binding in it.
            // Since we always allocate this way, the allocated
            // bindings are all clumped at the beginning and once
            // we find a NULL spot we know there are no more
            // allocated ones.
            //
            // We keep track of the first binding on this adapter
            // in TmpBinding in case we need config info from it.
            //

            TmpBinding = NULL;

            IPX_GET_LOCK (&Device->Lock, &LockHandle);

            for (i = Adapter->FirstWanNicId;
                 i <= Adapter->LastWanNicId;
                 i++) {
                Binding = NIC_ID_TO_BINDING(Device, i);
                if (TmpBinding == NULL) {
                    TmpBinding = Binding;
                }

                if ((Binding == NULL) ||
                    (!Binding->LineUp)) {
                    break;
                }
            }

            if (i > Adapter->LastWanNicId) {
                IPX_FREE_LOCK (&Device->Lock, LockHandle);
                IPX_DEBUG (WAN, ("Line up, no WAN binding available\n"));
                return;
            }

            if (Binding == NULL) {

                //
                // We need to allocate one.
                //

                CTEAssert (TmpBinding != NULL);

                //
                // CreateBinding does an InterLockedPop with the DeviceLock.
                // So, release the lock here.
                //
                IPX_FREE_LOCK (&Device->Lock, LockHandle);
                Status = IpxCreateBinding(
                    Device,
                    NULL,
                    0,
                    Adapter->AdapterName,
                    &Binding);

                if (Status != STATUS_SUCCESS) {
		   IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
		   IpxWriteGeneralErrorLog(
		      (PVOID)IpxDevice->DeviceObject,
		      EVENT_TRANSPORT_RESOURCE_POOL,
		      816,
		      Status,
		      L"IpxStatus: failed to create wan binding",
		      0,
		      NULL);
		   DbgPrint("IPX: IpxCreateBinding on wan binding failed with status %x\n.",Status);  
		   IPX_DEBUG (WAN, ("Line up, could not create WAN binding\n"));
		   goto error_no_lock;
                }

                IPX_GET_LOCK (&Device->Lock, &LockHandle);
                //
                // Binding->AllRouteXXX doesn't matter for WAN.
                //

                Binding->FrameType = ISN_FRAME_TYPE_ETHERNET_II;
                Binding->SendFrameHandler = IpxSendFrameWanEthernetII;
                ++Adapter->BindingCount;
                Binding->Adapter = Adapter;

                Binding->NicId = i;
                
                /*
                Abandoning this fix in favor of checking for null binding all over.
                
                // 
                // Nt5.0 NDISWAN tells us that there are 1000 ports configured, we 
                // take it one line up at a time... [ShreeM]
                // 
                Device->HighestExternalNicId += 1; 
                Device->ValidBindings += 1; 
                Device->BindingCount += 1;  
                Device->SapNicCount++;
                */
                INSERT_BINDING(Device, i, Binding);

                //
                // Other fields are filled in below.
                //

            }

            //
            // This is not an update, so note that the line is active.
            //
            // [FW] Binding->LineUp = TRUE;
            Binding->LineUp = LINE_UP;

            if (Configuration->ConnectionClient == 1) {
                Binding->DialOutAsync = TRUE;
            } else {
                Binding->DialOutAsync = FALSE;
            }

            //
            // Keep track of the highest NIC ID that we should
            // send type 20s out on.
            //

            if (i > (UINT)MIN (Device->MaxBindings, Device->HighestType20NicId)) {

                if ((Binding->DialOutAsync) ||
                    ((Device->DisableDialinNetbios & 0x01) == 0)) {

                    Device->HighestType20NicId = i;
                }
            }

            //
            // We could error out below, trying to insert this network number. In RipShortTimeout
            // we dont check for LineUp when calculating the tick counts; set this before the insert
            // attempt.
            //
            Binding->MediumSpeed = LineUp->LinkSpeed;

            IPX_FREE_LOCK (&Device->Lock, LockHandle);

            //
            // [FW] No need to update these if this flag is on since these values will be
            // provided with IPX_WAN_CONFIG_DONE ioctl; instead we zero out the fields so that
            // IPXWAN packets have proper source addresses.
            //
            if (Device->ForwarderBound &&
                Configuration->IpxwanConfigRequired) {
                Binding->LocalAddress.NetworkAddress = 0;
                RtlZeroMemory (Binding->LocalAddress.NodeAddress, 6);

            } else {

                //
                // Add a router entry for this net if there is no router.
                // We want the number of ticks for a 576-byte frame,
                // given the link speed in 100 bps units, so we calculate
                // as:
                //
                //        seconds          18.21 ticks   4608 bits
                // --------------------- * ----------- * ---------
                // link_speed * 100 bits     second        frame
                //
                // to get the formula
                //
                // ticks/frame = 839 / link_speed.
                //
                // We add link_speed to the numerator also to ensure
                // that the value is at least 1.
                //

    			if ((!Device->UpperDriverBound[IDENTIFIER_RIP]) &&
                    (*(UNALIGNED ULONG *)Configuration->Network != 0)) {
                    if (RipInsertLocalNetwork(
                             *(UNALIGNED ULONG *)Configuration->Network,
                             Binding->NicId,
                             Adapter->NdisBindingHandle,
                             (USHORT)((839 + LineUp->LinkSpeed) / LineUp->LinkSpeed)) != STATUS_SUCCESS) {
                        //
                        // This means we couldn't allocate memory, or
                        // the entry already existed. If it already
                        // exists we can ignore it for the moment.
                        //
                        // Now it will succeed if the network exists.
                        //

                        IPX_DEBUG (WAN, ("Line up, could not insert local network\n"));
                        // [FW] Binding->LineUp = FALSE;
                        Binding->LineUp = LINE_DOWN;

    					IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
    					goto error_no_lock;
                    }
                }


                //
                // Update our addresses.
                //
                Binding->LocalAddress.NetworkAddress = *(UNALIGNED ULONG *)Configuration->Network;
                RtlCopyMemory (Binding->LocalAddress.NodeAddress, Configuration->LocalNode, 6);
                RtlCopyMemory (Binding->WanRemoteNode, Configuration->RemoteNode, 6);

                //
                // Update the device node and all the address
                // nodes if we have only one bound, or this is
                // binding one.
                //

                if (!Device->VirtualNetwork) {

                    if ((!Device->MultiCardZeroVirtual) || (Binding->NicId == 1)) {
                        Device->SourceAddress.NetworkAddress = *(UNALIGNED ULONG *)(Configuration->Network);
                        RtlCopyMemory (Device->SourceAddress.NodeAddress, Configuration->LocalNode, 6);
                    }

                    //
                    // Scan through all the addresses that exist and modify
                    // their pre-constructed local IPX address to reflect
                    // the new local net and node.
                    //

                    IPX_GET_LOCK (&Device->Lock, &LockHandle);

                    for (CurrentHash = 0; CurrentHash < IPX_ADDRESS_HASH_COUNT; CurrentHash++) {

                        for (p = Device->AddressDatabases[CurrentHash].Flink;
                             p != &Device->AddressDatabases[CurrentHash];
                             p = p->Flink) {

                             Address = CONTAINING_RECORD (p, ADDRESS, Linkage);

                             Address->LocalAddress.NetworkAddress = *(UNALIGNED ULONG *)Configuration->Network;
                             RtlCopyMemory (Address->LocalAddress.NodeAddress, Configuration->LocalNode, 6);
                        }
                    }
                    IPX_FREE_LOCK (&Device->Lock, LockHandle);
                }
            }

			//
			// Return the binding context for this puppy!
			//
			*((ULONG UNALIGNED *)(&LineUp->LocalAddress[2])) =
			*((ULONG UNALIGNED *)(&Binding));

            RtlCopyMemory (Binding->LocalMacAddress.Address, LineUp->LocalAddress, 6);
            RtlCopyMemory (Binding->RemoteMacAddress.Address, LineUp->RemoteAddress, 6);

            //
            // Reset this since the line just came up.
            //

            Binding->WanInactivityCounter = 0;

            //
            // [FW] Update the InterfaceIndex and ConnectionId.
            //
            Binding->InterfaceIndex = Configuration->InterfaceIndex;
            Binding->ConnectionId = Configuration->ConnectionId;
            Binding->IpxwanConfigRequired = Configuration->IpxwanConfigRequired;

            //
            // [FW] We need to keep track of WAN inactivity counters ourselves.
            // Every minute, the wan inactivity counters are incremented for all
            // UP WAN lines.
            //
            IPX_GET_LOCK (&Device->Lock, &LockHandle);
            if (Device->UpWanLineCount == 0) {
            }

            Device->UpWanLineCount++;
            IPX_FREE_LOCK (&Device->Lock, LockHandle);
        }

        LinkSpeed = LineUp->LinkSpeed;

        //
        // Scan through bindings to update Device->LinkSpeed.
        // If SingleNetworkActive is set, we only count WAN
        // bindings when doing this (although it is unlikely
        // a LAN binding would be the winner).
        //
        // Update other device information?
        //

        for (i = FIRST_REAL_BINDING; i <= Device->ValidBindings; i++) {
			if (TmpBinding = NIC_ID_TO_BINDING(Device, i)) {
                TmpAdapter = TmpBinding->Adapter;
                if (TmpBinding->LineUp &&
                    (!Device->SingleNetworkActive || TmpAdapter->MacInfo.MediumAsync) &&
                    (TmpBinding->MediumSpeed < LinkSpeed)) {
                    LinkSpeed = TmpBinding->MediumSpeed;
                }
            }
        }

  		//
		// Release the lock after incrementing the reference count
		//
		IpxReferenceBinding1(Binding, BREF_DEVICE_ACCESS);

		IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

		Device->LinkSpeed = LinkSpeed;

        if ((Adapter->ConfigMaxPacketSize == 0) ||
            (LineUp->MaximumTotalSize < Adapter->ConfigMaxPacketSize)) {
            Binding->MaxSendPacketSize = LineUp->MaximumTotalSize;
        } else {
            Binding->MaxSendPacketSize = Adapter->ConfigMaxPacketSize;
        }
        MacInitializeBindingInfo (Binding, Adapter);

        //
        // [FW] If the IpxwanConfigRequired flag is true, we don't inform
        // the upper layers until IPXWAN sends down the ioctl to do so.
        //
        // Inform IpxWan only if this is not an Update; it will be an update in
        // the case of multilink. In fact, do not access the Configuration param in
        // case UpdateLineUp is TRUE.
        //
        if (!UpdateLineUp &&
            Configuration->IpxwanConfigRequired) {

            IPX_DEBUG(WAN, ("IPXWAN configuration required on LineUp: %lx\n", LineUp));
            CTEAssert(!UpdateLineUp);
            Binding->LineUp = LINE_CONFIG;
            goto InformIpxWan;
        }

        //
        // Tell FWD if it wants to know [Shreem]
        //
        Binding->PastAutoDetection = TRUE;

        //
        // We dont give lineups; instead indicate only if the PnP reserved address
        // changed to SPX. NB gets all PnP indications with the reserved address case
        // marked out.
        //
        Event = CTEAllocMem( sizeof(CTEEvent) );
        if ( Event ) {
           CTEInitEvent(Event, LineUpOnWorkerThread); 
           CTEScheduleEvent(Event, Binding);
           ntStatus = STATUS_PENDING;
        
        } else {
           
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }


/*
        {
            IPX_PNP_INFO    NBPnPInfo;

            if ((!Device->MultiCardZeroVirtual) || (Binding->NicId == FIRST_REAL_BINDING)) {

                //
                // NB's reserved address changed.
                //
                NBPnPInfo.NewReservedAddress = TRUE;

                if (!Device->VirtualNetwork) {
                    //
                    // Let SPX know because it fills in its own headers.
                    //
                    if (Device->UpperDriverBound[IDENTIFIER_SPX]) {
                        IPX_DEFINE_LOCK_HANDLE(LockHandle1)
                        IPX_PNP_INFO    IpxPnPInfo;

                        IpxPnPInfo.NewReservedAddress = TRUE;
                        IpxPnPInfo.NetworkAddress = Binding->LocalAddress.NetworkAddress;
                        IpxPnPInfo.FirstORLastDevice = FALSE;

                        IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                        RtlCopyMemory(IpxPnPInfo.NodeAddress, Binding->LocalAddress.NodeAddress, 6);
                        NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, Binding->NicId);
                        IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

                        //
                        // give the PnP indication
                        //
                        (*Device->UpperDrivers[IDENTIFIER_SPX].PnPHandler) (
                            IPX_PNP_ADDRESS_CHANGE,
                            &IpxPnPInfo);

                        IPX_DEBUG(AUTO_DETECT, ("IPX_PNP_ADDRESS_CHANGED to SPX: net addr: %lx\n", Binding->LocalAddress.NetworkAddress));
                    }
                }
            } else {
                    NBPnPInfo.NewReservedAddress = FALSE;
            }

            if (Device->UpperDriverBound[IDENTIFIER_NB]) {
                IPX_DEFINE_LOCK_HANDLE(LockHandle1)

                Binding->IsnInformed[IDENTIFIER_NB] = TRUE;

            	NBPnPInfo.LineInfo.LinkSpeed = Device->LinkSpeed;
            	NBPnPInfo.LineInfo.MaximumPacketSize =
            		Device->Information.MaximumLookaheadData + sizeof(IPX_HEADER);
            	NBPnPInfo.LineInfo.MaximumSendSize =
            		Device->Information.MaxDatagramSize + sizeof(IPX_HEADER);
            	NBPnPInfo.LineInfo.MacOptions = Device->MacOptions;

                NBPnPInfo.NetworkAddress = Binding->LocalAddress.NetworkAddress;
                NBPnPInfo.FirstORLastDevice = FALSE;

                IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                RtlCopyMemory(NBPnPInfo.NodeAddress, Binding->LocalAddress.NodeAddress, 6);
                NIC_HANDLE_FROM_NIC(NBPnPInfo.NicHandle, Binding->NicId);
                IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

                //
                // give the PnP indication
                //
                (*Device->UpperDrivers[IDENTIFIER_NB].PnPHandler) (
                    IPX_PNP_ADD_DEVICE,
                    &NBPnPInfo);

                IPX_DEBUG(AUTO_DETECT, ("IPX_PNP_ADD_DEVICE (lineup) to NB: net addr: %lx\n", Binding->LocalAddress.NetworkAddress));
            }

            //
            // Register this address with the TDI clients.
            //
            RtlCopyMemory (Device->TdiRegistrationAddress->Address, &Binding->LocalAddress, sizeof(TDI_ADDRESS_IPX));

            if ((ntStatus = TdiRegisterNetAddress(
                            Device->TdiRegistrationAddress,
#if     defined(_PNP_POWER_)
                                NULL,
                                NULL,
#endif _PNP_POWER_
                            &Binding->TdiRegistrationHandle)) != STATUS_SUCCESS) {

                IPX_DEBUG(PNP, ("TdiRegisterNetAddress failed: %lx", ntStatus));
            }
        }
*/
        //
        // Indicate to the upper drivers.
        //
        LineInfo.LinkSpeed = LineUp->LinkSpeed;
        LineInfo.MaximumPacketSize = LineUp->MaximumTotalSize - 14;
        LineInfo.MaximumSendSize = LineUp->MaximumTotalSize - 14;
        LineInfo.MacOptions = Adapter->MacInfo.MacOptions;

        //
        // Give line up to RIP as it is not PnP aware.
        // Give lineup to FWD only if it opened this adapter first.
        //
        if (Device->UpperDriverBound[IDENTIFIER_RIP]) {

            //
            // Line status, after lineup.
            //
            if (UpdateLineUp) {
                //
                // was the lineup given earlier? if not, then dont send this up.
                //
                if (Binding->IsnInformed[IDENTIFIER_RIP]) {
                    CTEAssert(Binding->FwdAdapterContext);

                    (*Device->UpperDrivers[IDENTIFIER_RIP].LineUpHandler)(
                        Binding->NicId,
                        &LineInfo,
                        NdisMediumWan,
                        NULL);
                }

            } else {
                Binding->IsnInformed[IDENTIFIER_RIP] = TRUE;
                (*Device->UpperDrivers[IDENTIFIER_RIP].LineUpHandler)(
                    Binding->NicId,
                    &LineInfo,
                    NdisMediumWan,
                    Configuration);
            }
        }
        if (!UpdateLineUp) {
	   
            if ((Device->SingleNetworkActive) &&
                (Configuration->ConnectionClient == 1)) {
                //
                // Drop all entries in the database if rip is not bound.
                //

                if (!Device->UpperDriverBound[IDENTIFIER_RIP]) {
                    RipDropRemoteEntries();
                }

                Device->ActiveNetworkWan = TRUE;

                //
                // Find a queued line change and complete it.
                //


                if ((p = ExInterlockedRemoveHeadList(
                               &Device->LineChangeQueue,
                               &Device->Lock)) != NULL) {

                    Request = LIST_ENTRY_TO_REQUEST(p);

		    IoAcquireCancelSpinLock( &irql );
		    IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);
		    IoReleaseCancelSpinLock( irql );	
		    REQUEST_STATUS(Request) = STATUS_SUCCESS;
                    IpxCompleteRequest (Request);
                    IpxFreeRequest (Device, Request);

                    IpxDereferenceDevice (Device, DREF_LINE_CHANGE);

                }
            }

	    //
	    // If we have a virtual net, do a broadcast now so
	    // the router on the other end will know about us.
	    //
	    // Use RipSendResponse, and do it even
	    // if SingleNetworkActive is FALSE??
	    //

	    if (Device->RipResponder && (Configuration->ConnectionClient == 1)) {
		DbgPrint("IPX:Sending RIP Response for Virtual Net %x\n",Device->VirtualNetworkNumber); 
		(VOID)RipQueueRequest (Device->VirtualNetworkNumber, RIP_RESPONSE);
	    }


            //
            // Find a queued address notify and complete it.
            // If WanGlobalNetworkNumber is TRUE, we only do
            // this when the first dialin line comes up.
            //


            if ((!Device->WanGlobalNetworkNumber ||
                 (!Device->GlobalNetworkIndicated && !Binding->DialOutAsync))
                                &&
                ((p = ExInterlockedRemoveHeadList(
                           &Device->AddressNotifyQueue,
                           &Device->Lock)) != NULL)) {

                if (Device->WanGlobalNetworkNumber) {
                    Device->GlobalWanNetwork = Binding->LocalAddress.NetworkAddress;
                    Device->GlobalNetworkIndicated = TRUE;
                }

                Request = LIST_ENTRY_TO_REQUEST(p);
                NdisBuffer = REQUEST_NDIS_BUFFER(Request);
                NdisQueryBufferSafe (REQUEST_NDIS_BUFFER(Request), (PVOID *)&NwlinkAction, &BufferLength, HighPagePriority);
		
		if (NwlinkAction != NULL) {

		   IpxAddressData = (PIPX_ADDRESS_DATA)(NwlinkAction->Data);

		   if (Device->WanGlobalNetworkNumber) {
		      IpxAddressData->adapternum = Device->SapNicCount - 1;
		   } else {
		      IpxAddressData->adapternum = Binding->NicId - 1;
		   }
		   *(UNALIGNED ULONG *)IpxAddressData->netnum = Binding->LocalAddress.NetworkAddress;
		   RtlCopyMemory(IpxAddressData->nodenum, Binding->LocalAddress.NodeAddress, 6);
		   IpxAddressData->wan = TRUE;
		   IpxAddressData->status = TRUE;
		   IpxAddressData->maxpkt = Binding->AnnouncedMaxDatagramSize;
		   IpxAddressData->linkspeed = Binding->MediumSpeed;

		   REQUEST_STATUS(Request) = STATUS_SUCCESS;
		} else {
		   REQUEST_STATUS(Request) = STATUS_INSUFFICIENT_RESOURCES; 
		}

		IoAcquireCancelSpinLock( &irql );
		IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);
		IoReleaseCancelSpinLock( irql );
                IpxCompleteRequest (Request);
                IpxFreeRequest (Device, Request);

                IpxDereferenceDevice (Device, DREF_ADDRESS_NOTIFY);
            }

InformIpxWan:
            Binding->fInfoIndicated = FALSE;
            //
            // Tell FWD if it wants to know [Shreem]
            //
            Binding->PastAutoDetection = TRUE;
            
            if ((p = ExInterlockedRemoveHeadList(
                    &Device->NicNtfQueue,
                    &Device->Lock)) != NULL)
            {
                Request = LIST_ENTRY_TO_REQUEST(p);

                IPX_DEBUG(WAN, ("IpxStatus: WAN LINE UP\n"));
                Status = GetNewNics(Device, Request, FALSE, NULL, 0, TRUE);
                if (Status == STATUS_PENDING)
                {
                    IPX_DEBUG(WAN, ("WANLineUp may not be responding properly\n"));
                }
                else
                {
                    IoAcquireCancelSpinLock(&OldIrq);
                    IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);
                    IoReleaseCancelSpinLock(OldIrq);

                    REQUEST_STATUS(Request) = Status;
                    IpxCompleteRequest (Request);
                    IpxFreeRequest (Device, Request);
                    IpxDereferenceDevice (Device, DREF_NIC_NOTIFY);
                }

            }
        }

    	IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
        {
            int kk;
            PBINDING pb = NULL;
            for (kk= LOOPBACK_NIC_ID; kk < Device->ValidBindings; kk++) {
                pb = NIC_ID_TO_BINDING(Device, kk);
                if (pb) {
                    if (pb->NicId != kk) {
                        DbgBreakPoint();
                    }
                }
                
            }
        }

        break;

    case NDIS_STATUS_WAN_LINE_DOWN:

        if (StatusBufferSize < sizeof(NDIS_WAN_LINE_DOWN)) {
            IPX_DEBUG (WAN, ("Line down, status buffer size wrong %d/%d\n", StatusBufferSize, sizeof(NDIS_WAN_LINE_DOWN)));
            return;
        }

        LineDown = (PNDIS_WAN_LINE_DOWN)StatusBuffer;

		*((ULONG UNALIGNED*)(&Binding)) = *((ULONG UNALIGNED*)(&LineDown->LocalAddress[2]));

		CTEAssert(Binding != NULL);

        //
        // Note that the WAN line is down.
        //
        IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

        // [FW] Binding->LineUp = FALSE;
        Binding->LineUp = LINE_DOWN;

		//
		// PNP_POWER - we hold the exclusive lock to the binding
		// and reference to the adapter at this point.
		//

        //
        // Keep track of the highest NIC ID that we should
        // send type 20s out on.
        //

        IPX_GET_LOCK (&Device->Lock, &LockHandle);

        if (Binding->NicId == MIN (Device->MaxBindings, Device->HighestType20NicId)) {

            //
            // This was the old limit, so we have to scan
            // backwards to update it -- we stop when we hit
            // a non-WAN binding, or a wan binding that is up and
            // dialout, or any wan binding if bit 1 in
            // DisableDialinNetbios is off.
            //

            for (i = Binding->NicId-1; i >= FIRST_REAL_BINDING; i--) {
                TmpBinding = NIC_ID_TO_BINDING(Device, i);

                if ((TmpBinding != NULL) &&
                    ((!TmpBinding->Adapter->MacInfo.MediumAsync) ||
                     (TmpBinding->LineUp &&
                      ((Binding->DialOutAsync) ||
                       ((Device->DisableDialinNetbios & 0x01) == 0))))) {

                    break;
                }
            }

            Device->HighestType20NicId = i;

        }


        //
        // Scan through bindings to update Device->LinkSpeed.
        // If SingleNetworkActive is set, we only count LAN
        // bindings when doing this.
        //
        // Update other device information?
        //

        LinkSpeed = 0xffffffff;
        for (i = FIRST_REAL_BINDING; i <= Device->ValidBindings; i++) {
            if (TmpBinding = NIC_ID_TO_BINDING(Device, i)) {
                TmpAdapter = TmpBinding->Adapter;
                if (TmpBinding->LineUp &&
                    (!Device->SingleNetworkActive || !TmpAdapter->MacInfo.MediumAsync) &&
                    (TmpBinding->MediumSpeed < LinkSpeed)) {
                    LinkSpeed = TmpBinding->MediumSpeed;
                }
            }
        }

        if (LinkSpeed != 0xffffffff) {
            Device->LinkSpeed = LinkSpeed;
        }

        IPX_FREE_LOCK (&Device->Lock, LockHandle);

		IpxReferenceBinding1(Binding, BREF_DEVICE_ACCESS);
		IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

        //
        // Remove our router entry for this net.
        //

        //
        // [FW] if this was a line on which IPXWAN config was happening, then we dont do this.
        //
        if (!Binding->IpxwanConfigRequired  &&
            !Device->UpperDriverBound[IDENTIFIER_RIP]) {

            Segment = RipGetSegment ((PUCHAR)&Binding->LocalAddress.NetworkAddress);
            IPX_GET_LOCK (&Device->SegmentLocks[Segment], &LockHandle);

            RouteEntry = RipGetRoute (Segment, (PUCHAR)&Binding->LocalAddress.NetworkAddress);

            if (RouteEntry != (PIPX_ROUTE_ENTRY)NULL) {

                RipDeleteRoute (Segment, RouteEntry);
                IPX_FREE_LOCK (&Device->SegmentLocks[Segment], LockHandle);
                IpxFreeMemory (RouteEntry, sizeof(IPX_ROUTE_ENTRY), MEMORY_RIP, "RouteEntry");

            } else {

                IPX_FREE_LOCK (&Device->SegmentLocks[Segment], LockHandle);
            }

            RipAdjustForBindingChange (Binding->NicId, 0, IpxBindingDown);

        }

        //
        // [FW] If this was the last UpWanLine, cancel the inactivity timer.
        //
        /*
        IPX_GET_LOCK (&Device->Lock, &LockHandle);
        if (--Device->UpWanLineCount == 0) {
            if (!CTEStopTimer (&IpxDevice->WanInactivityTimer)) {
                 DbgPrint("Could not stop the WanInactivityTimer\n");
                 DbgBreakPoint();
            }
        }
        IPX_FREE_LOCK (&Device->Lock, LockHandle);
        */

        //
        // If this was a line on which IPXWAN config was going on, then we need to tell only the
        // IPXWAN layer that the line went down since none of the other clients were informed of
        // the line up in the first place.
        //
        if (Binding->IpxwanConfigRequired) {
            goto InformIpxWan1;
        }

        //
        // Indicate to the upper drivers.
        //

        //
        // DeRegister this address with the TDI clients.
        //
        
        //
        // Since the IRQL is too high, we will do this now on a worker thread. [Shreem]
        //


        Event = CTEAllocMem( sizeof(CTEEvent) );
        if ( Event ) {
           CTEInitEvent(Event, LineDownOnWorkerThread); 
           CTEScheduleEvent(Event, Binding);
           ntStatus = STATUS_PENDING;
        
        } else {
           
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Tell FWD if it wants to know [Shreem]
        //
        Binding->PastAutoDetection = FALSE;


        //
        // Indicate to the Fwd only if it opened this adapter first.
        //
        if (Device->UpperDriverBound[IDENTIFIER_RIP] &&
            (!Device->ForwarderBound || Binding->FwdAdapterContext)) {

            (*Device->UpperDrivers[IDENTIFIER_RIP].LineDownHandler)(
                Binding->NicId,
                Binding->FwdAdapterContext);

            CTEAssert(Binding->IsnInformed[IDENTIFIER_RIP]);

            Binding->IsnInformed[IDENTIFIER_RIP] = FALSE;
        }

        if ((Device->SingleNetworkActive) &&
            (Binding->DialOutAsync)) {

            //
            // Drop all entries in the database if rip is not bound.
            //

            if (!Device->UpperDriverBound[IDENTIFIER_RIP]) {
                RipDropRemoteEntries();
            }

            Device->ActiveNetworkWan = FALSE;

            //
            // Find a queued line change and complete it.
            //

            if ((p = ExInterlockedRemoveHeadList(
                           &Device->LineChangeQueue,
                           &Device->Lock)) != NULL) {

                Request = LIST_ENTRY_TO_REQUEST(p);

		IoAcquireCancelSpinLock( &irql );
		IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);
		IoReleaseCancelSpinLock( irql );
		REQUEST_STATUS(Request) = STATUS_SUCCESS;
                IpxCompleteRequest (Request);
                IpxFreeRequest (Device, Request);

                IpxDereferenceDevice (Device, DREF_LINE_CHANGE);

            }
        }

        //
        // Find a queued address notify and complete it.
        //

        if ((!Device->WanGlobalNetworkNumber) &&
            ((p = ExInterlockedRemoveHeadList(
                       &Device->AddressNotifyQueue,
                       &Device->Lock)) != NULL)) {

            Request = LIST_ENTRY_TO_REQUEST(p);
            NdisBuffer = REQUEST_NDIS_BUFFER(Request);
            NdisQueryBufferSafe (REQUEST_NDIS_BUFFER(Request), (PVOID *)&NwlinkAction, &BufferLength, HighPagePriority);

	    if (NwlinkAction != NULL) {

	       IpxAddressData = (PIPX_ADDRESS_DATA)(NwlinkAction->Data);

	       IpxAddressData->adapternum = Binding->NicId - 1;
	       *(UNALIGNED ULONG *)IpxAddressData->netnum = Binding->LocalAddress.NetworkAddress;
	       RtlCopyMemory(IpxAddressData->nodenum, Binding->LocalAddress.NodeAddress, 6);
	       IpxAddressData->wan = TRUE;
	       IpxAddressData->status = FALSE;
	       IpxAddressData->maxpkt = Binding->AnnouncedMaxDatagramSize;  // Use real?
	       IpxAddressData->linkspeed = Binding->MediumSpeed;
	       REQUEST_STATUS(Request) = STATUS_SUCCESS;
	    } else {
	       REQUEST_STATUS(Request) = STATUS_INSUFFICIENT_RESOURCES;
	    }

            IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);

	    IoAcquireCancelSpinLock( &irql );
	    IpxCompleteRequest (Request);
	    IoReleaseCancelSpinLock( irql );
	    IpxFreeRequest (Device, Request);

            IpxDereferenceDevice (Device, DREF_ADDRESS_NOTIFY);
        }

InformIpxWan1:
        Binding->fInfoIndicated = FALSE;
        if ((p = ExInterlockedRemoveHeadList(
                           &Device->NicNtfQueue,
                           &Device->Lock)) != NULL)
        {

            Request = LIST_ENTRY_TO_REQUEST(p);
            IPX_DEBUG(WAN, ("IpxStatus: WAN LINE DOWN\n"));

            Status = GetNewNics(Device, Request, FALSE, NULL, 0, TRUE);
            if (Status == STATUS_PENDING)
            {
                 IPX_DEBUG(WAN, ("WANLineDown may not be responding properly\n"));
            }
            else
            {
                IoAcquireCancelSpinLock(&OldIrq);
                IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);
                IoReleaseCancelSpinLock(OldIrq);

                REQUEST_STATUS(Request) = Status;
                IpxCompleteRequest (Request);
                IpxFreeRequest (Device, Request);  //noop
                IpxDereferenceDevice (Device, DREF_NIC_NOTIFY);
            }
        }

    	IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
        
        {
            int kk;
            PBINDING pb = NULL;
            for (kk = LOOPBACK_NIC_ID; kk < Device->ValidBindings; kk++) {
                pb = NIC_ID_TO_BINDING(Device, kk);
                if (pb) {
                    if (pb->NicId != kk) {
                        DbgBreakPoint();
                    }
                }
                
            }
        }


        break;

    case NDIS_STATUS_WAN_FRAGMENT:

        //
        // No response needed, IPX is a datagram service.
        //
        // What about telling Netbios/SPX?
        //

        break;

    case NDIS_STATUS_MEDIA_CONNECT:

       //
       //   We bind to the new adapter and compare if the characteristics of any of 
       //   the previously disabled adapters matches with the characteristics of this new one. 
       //   
       //   if we find a match then we must be on the same LAN/WAN as the disabled adapter.
       //   We just enable this adapter and Unbind the new one. If we cant find a match, we
       //   unbind/free one of these disbled adapters.
       //
       //   IpxUnbindAdapter() sends the upper drivers a IPX_PNP_DELETE messages 
       //   and they purge their addresses, caches etc.
       {

#ifdef _NDIS_MEDIA_SENSE_

          CTEEvent                *Event;
          
          // IPX_DEBUG(PNP, ("Ndis_Media_Sense: CONNECT for %ws. Queueing WorkerThread\n", Adapter->AdapterName));

          Event = CTEAllocMem( sizeof(CTEEvent) );
          if ( Event ) {
             CTEInitEvent(Event, IpxMediaSenseHandler);
             CTEScheduleEvent(Event, Adapter);
             ntStatus = STATUS_PENDING;
          } else {
             ntStatus = STATUS_INSUFFICIENT_RESOURCES;
          }
#endif // _NDIS_MEDIA_SENSE_
          
          break;
       }

    case NDIS_STATUS_MEDIA_DISCONNECT:

        //
        //  It must fail all datagram sends. It must fail all
        //  connects right away but not disconnect sessions in progress.
        //  These must timeout the way they do today. The router
        //  must age out routes on this interface and not propagate them.
        //
        //  All of the above can be achieved by setting Bindings->Lineup = DOWN;
        //
#ifdef _NDIS_MEDIA_SENSE_
        
       {
           int j;

           //IPX_DEBUG(PNP, ("Ndis_Status_Media_Sense: DISCONNECT for %ws\n", Adapter->AdapterName));

           for ( j = 0; j< ISN_FRAME_TYPE_MAX; j++ ) {
              if (Adapter->Bindings[j]) {
                 Adapter->Bindings[j]->Disabled = DISABLED;
              }
              Adapter->Disabled = DISABLED;

           }
        }
#endif // _NDIS_MEDIA_SENSE_
        
        break;


    default:

        break;

    }

error_no_lock:
	IpxDereferenceAdapter(Adapter);

}   /* IpxStatus */


//
// Since IPXStatus is called by NDIS at DISPATCH_LEVEL irql and TDIRegisterNetAddress 
// needs to be called at PASSIVE_LEVEL, We now do this TDI and PnpNotifications on a
// worker thread launched from IpxStatus. Hopefully there arent any repercussions of this.
// [ShreeM]

void 
LineUpOnWorkerThread(
                       IN CTEEvent *WorkerThreadEvent,
                       IN PVOID Context)
{
    PBINDING Binding =  (PBINDING) Context;
    NTSTATUS            ntStatus;
    IPX_PNP_INFO        NBPnPInfo;
    PDEVICE             Device = IpxDevice;
    
    //
    // Qos changes
    //
    int             count, i;
    int             size;
    NTSTATUS        NdisStatus = STATUS_SUCCESS;
    UNICODE_STRING  AdapterName;
    NDIS_REQUEST            IpxRequest;
    PNETWORK_ADDRESS_LIST   AddrList;
    PNETWORK_ADDRESS        Address;
    NETWORK_ADDRESS_IPX         *TdiAddress;
    PBINDING                TempBinding;

    IPX_DEFINE_LOCK_HANDLE (LockHandle)
    IPX_DEFINE_LOCK_HANDLE(LockHandle1)    
    
    
    ASSERT(Context != NULL);
	
    CTEFreeMem(WorkerThreadEvent);

    IPX_DEBUG(WAN, ("TDIRegisterNetAddress etc. on worker thread.\n"));

        if ((!Device->MultiCardZeroVirtual) || (Binding->NicId == FIRST_REAL_BINDING)) {

            //
            // NB's reserved address changed.
            //
            NBPnPInfo.NewReservedAddress = TRUE;

            if (!Device->VirtualNetwork) {
                //
                // Let SPX know because it fills in its own headers.
                //
                if (Device->UpperDriverBound[IDENTIFIER_SPX]) {
                    IPX_DEFINE_LOCK_HANDLE(LockHandle1)
                    IPX_PNP_INFO    IpxPnPInfo;

                    IpxPnPInfo.NewReservedAddress = TRUE;
                    IpxPnPInfo.NetworkAddress = Binding->LocalAddress.NetworkAddress;
                    IpxPnPInfo.FirstORLastDevice = FALSE;

                    IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                    RtlCopyMemory(IpxPnPInfo.NodeAddress, Binding->LocalAddress.NodeAddress, 6);
                    NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, Binding->NicId);
                    IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

                    //
                    // give the PnP indication
                    //
                    (*Device->UpperDrivers[IDENTIFIER_SPX].PnPHandler) (
                        IPX_PNP_ADDRESS_CHANGE,
                        &IpxPnPInfo);

                    IPX_DEBUG(AUTO_DETECT, ("IPX_PNP_ADDRESS_CHANGED to SPX: net addr: %lx\n", Binding->LocalAddress.NetworkAddress));
                }
            }
        } else {
            NBPnPInfo.NewReservedAddress = FALSE;
        }

        if (Device->UpperDriverBound[IDENTIFIER_NB]) {
            IPX_DEFINE_LOCK_HANDLE(LockHandle1)

            Binding->IsnInformed[IDENTIFIER_NB] = TRUE;

            NBPnPInfo.LineInfo.LinkSpeed = Device->LinkSpeed;
            NBPnPInfo.LineInfo.MaximumPacketSize =
                Device->Information.MaximumLookaheadData + sizeof(IPX_HEADER);
            NBPnPInfo.LineInfo.MaximumSendSize =
                Device->Information.MaxDatagramSize + sizeof(IPX_HEADER);
            NBPnPInfo.LineInfo.MacOptions = Device->MacOptions;

            NBPnPInfo.NetworkAddress = Binding->LocalAddress.NetworkAddress;
            NBPnPInfo.FirstORLastDevice = FALSE;

            IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
            RtlCopyMemory(NBPnPInfo.NodeAddress, Binding->LocalAddress.NodeAddress, 6);
            NIC_HANDLE_FROM_NIC(NBPnPInfo.NicHandle, Binding->NicId);
            IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

            //
            // give the PnP indication
            //

            ASSERT(Binding->NicId != LOOPBACK_NIC_ID); 
            ASSERT(IpxHasInformedNbLoopback()); 
            ASSERT(NBPnPInfo.FirstORLastDevice == FALSE);

            (*Device->UpperDrivers[IDENTIFIER_NB].PnPHandler) (
                IPX_PNP_ADD_DEVICE,
                &NBPnPInfo);

            IPX_DEBUG(AUTO_DETECT, ("IPX_PNP_ADD_DEVICE (lineup) to NB: net addr: %lx\n", Binding->LocalAddress.NetworkAddress));
        }

        //
        // Register this address with the TDI clients.
        //
        RtlCopyMemory (Device->TdiRegistrationAddress->Address, &Binding->LocalAddress, sizeof(TDI_ADDRESS_IPX));

        if ((ntStatus = TdiRegisterNetAddress(
                        Device->TdiRegistrationAddress,
#if     defined(_PNP_POWER_)
                            &IpxDeviceName,
                            NULL,
#endif _PNP_POWER_
                        &Binding->TdiRegistrationHandle)) != STATUS_SUCCESS) {

            DbgPrint("TdiRegisterNetAddress failed with %lx. (0xC000009A is STATUS_INSUFFICIENT_RESOURCES)", ntStatus);
    }

#if 0
	//
    // Register with QoS
    //
    IPX_DEBUG(PNP, ("Register a new address with QoS over here\n"));
    
    for (count=0, i=IpxDevice->HighestLanNicId+1; i < IpxDevice->ValidBindings; i++) {
        if (NIC_ID_TO_BINDING(IpxDevice, i)) {
            count++;
        }
    }
    
    
    IPX_DEBUG(PNP, ("This adapter has %d valid WAN bindings\n", count));
    size =  FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address) + count * (FIELD_OFFSET(NETWORK_ADDRESS, Address) + sizeof(NETWORK_ADDRESS_IPX));
    
    AddrList = IpxAllocateMemory(
                                 size,
                                 MEMORY_ADAPTER,
                                 "QoS specific stuff");
    
    // 270344
    if (AddrList == NULL) {
        DbgPrint("IpxAllocateMemory returned NULL. Skip QoS registration.\n"); 
        return; 
    } 

    RtlZeroMemory(AddrList, size);
    AddrList->AddressCount  = count;
    AddrList->AddressType    = NDIS_PROTOCOL_ID_IPX;
        
    count                   = 0;
    Address                 = &AddrList->Address[0];
    
    for (i=IpxDevice->HighestLanNicId+1; i < IpxDevice->ValidBindings; i++) {
    
        if (TempBinding = NIC_ID_TO_BINDING(IpxDevice, i)) {
    
            Address->AddressLength  = sizeof(NETWORK_ADDRESS_IPX);
            Address->AddressType    = NDIS_PROTOCOL_ID_IPX;
            TdiAddress              = (NETWORK_ADDRESS_IPX *) &Address->Address[0];
    
            TdiAddress->NetworkAddress = TempBinding->LocalAddress.NetworkAddress;
            RtlCopyMemory (TdiAddress->NodeAddress, TempBinding->LocalAddress.NodeAddress, 6);
    
            TdiAddress->Socket = 0;
    
            IPX_DEBUG(PNP, ("Node is %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x, ",
                            TdiAddress->NodeAddress[0], TdiAddress->NodeAddress[1],
                            TdiAddress->NodeAddress[2], TdiAddress->NodeAddress[3],
                            TdiAddress->NodeAddress[4], TdiAddress->NodeAddress[5]));
            IPX_DEBUG(PNP, ("Network is %lx\n", REORDER_ULONG (TdiAddress->NetworkAddress)));
            count++;
	    Address                = (PNETWORK_ADDRESS) (((PUCHAR)(&AddrList->Address[0])) + count * (FIELD_OFFSET(NETWORK_ADDRESS, Address) + sizeof(NETWORK_ADDRESS_IPX)));
        }
    }
    
    IpxRequest.RequestType = NdisRequestSetInformation;
    
    IpxRequest.DATA.SET_INFORMATION.Oid = OID_GEN_NETWORK_LAYER_ADDRESSES;
    IpxRequest.DATA.SET_INFORMATION.InformationBuffer = AddrList;
    IpxRequest.DATA.SET_INFORMATION.InformationBufferLength = size;
    
    TempBinding = NIC_ID_TO_BINDING(IpxDevice, IpxDevice->HighestLanNicId+1);
    
    if (TempBinding) {
    
        RtlInitUnicodeString(&AdapterName, TempBinding->Adapter->AdapterName);
    
        NdisStatus = IpxSubmitNdisRequest (TempBinding->Adapter, &IpxRequest, &AdapterName);
    
        IPX_DEBUG(PNP, ("Returned from NDISRequest :%lx\n", NdisStatus));
    
    } else {
            
        DbgPrint("IpxDevice->Binding[highestlannicid+1] is NULL!!\n");
        CTEAssert(TempBinding != NULL);
        
    }
    
    if (NdisStatus != NDIS_STATUS_SUCCESS) {
    
        IPX_DEBUG(PNP, ("Setting the QoS OID failed - Error %lx\n", NdisStatus));
    
    } else {
    
        IPX_DEBUG(PNP, ("Setting the QoS OID was successful\n"));
    
    }
       
    IpxFreeMemory(AddrList,
		  size,
                  MEMORY_ADAPTER,
                  "QoS specific stuff");
#endif

} /* LineUpOnWorkerThread */ 
 
//
// Since IPXStatus is called by NDIS at DISPATCH_LEVEL irql and TDIDeregisterNetAddress 
// needs to be called at PASSIVE_LEVEL, We now do this TDI and PnpNotifications on a
// worker thread launched from IpxStatus. Hopefully there arent any repercussions of this.
// [ShreeM]

void 
LineDownOnWorkerThread(
                       IN CTEEvent *WorkerThreadEvent,
                       IN PVOID Context)
{
    PBINDING Binding =  (PBINDING) Context;
    NTSTATUS            ntStatus;
    IPX_PNP_INFO        NBPnPInfo;
    PDEVICE             Device = IpxDevice;
    IPX_DEFINE_LOCK_HANDLE (LockHandle)
    IPX_DEFINE_LOCK_HANDLE(LockHandle1)    
    
    
    ASSERT(Context != NULL);
	
    CTEFreeMem(WorkerThreadEvent);

    IPX_DEBUG(WAN, ("TDIDeregister etc. on worker thread.\n"));

    //
    // DeRegister this address with the TDI clients.
    //


    IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

    // CTEAssert(Binding->TdiRegistrationHandle);
    // TdiRegisterNetAddress could fail due to insufficient resources. In which case, 
    // TdiRegistrationHandle could be null. Removed assertion failure, added check. [TC]
    if (Binding->TdiRegistrationHandle != NULL) {

        if ((ntStatus = TdiDeregisterNetAddress(Binding->TdiRegistrationHandle)) != STATUS_SUCCESS) {
            DbgPrint("TdiDeRegisterNetAddress failed: %lx", ntStatus);
        } else {
                
            //
            //  118187: Dont deregister twice! [ShreeM]
            //
            Binding->TdiRegistrationHandle = NULL;
    
        }
    }

    IPX_GET_LOCK(&Device->Lock, &LockHandle);

    if (Device->UpperDriverBound[IDENTIFIER_NB]) {

        IPX_FREE_LOCK(&Device->Lock, LockHandle);            
        
        // CTEAssert(Binding->IsnInformed[IDENTIFIER_NB]);
        if (Binding->IsnInformed[IDENTIFIER_NB]) {

            NBPnPInfo.LineInfo.LinkSpeed = Device->LinkSpeed;
            NBPnPInfo.LineInfo.MaximumPacketSize =
                Device->Information.MaximumLookaheadData + sizeof(IPX_HEADER);
            NBPnPInfo.LineInfo.MaximumSendSize =
                Device->Information.MaxDatagramSize + sizeof(IPX_HEADER);
            NBPnPInfo.LineInfo.MacOptions = Device->MacOptions;

            NBPnPInfo.NewReservedAddress = FALSE;
            NBPnPInfo.FirstORLastDevice = FALSE;

            NBPnPInfo.NetworkAddress = Binding->LocalAddress.NetworkAddress;

            RtlCopyMemory(NBPnPInfo.NodeAddress, Binding->LocalAddress.NodeAddress, 6);
            NIC_HANDLE_FROM_NIC(NBPnPInfo.NicHandle, Binding->NicId);
            IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

            //
            // give the PnP indication
            //

            CTEAssert(Binding->NicId != LOOPBACK_NIC_ID); 

            (*Device->UpperDrivers[IDENTIFIER_NB].PnPHandler) (
                                                               IPX_PNP_DELETE_DEVICE,
                                                               &NBPnPInfo);

            Binding->IsnInformed[IDENTIFIER_NB] = FALSE; 

            IPX_DEBUG(PNP,("Indicate to NB IPX_PNP_DELETE_DEVICE with FirstORLastDevice = (%d)",NBPnPInfo.FirstORLastDevice));  
            IPX_DEBUG(AUTO_DETECT, ("IPX_PNP_DELETE_DEVICE (linedown) to NB: addr: %lx\n", Binding->LocalAddress.NetworkAddress));
        } else {
            DbgPrint("LineDownOnWorkerThread: Binding (%p) ->IsnInformed[IDENTIFIER_NB] is FALSE",Binding);
        }
    } else {
        IPX_FREE_LOCK(&Device->Lock, LockHandle);            
        IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
    }

} /* LineDownOnWorkerThread      */


VOID
IpxStatusComplete(
    IN NDIS_HANDLE NdisBindingContext
    )
{
    UNREFERENCED_PARAMETER (NdisBindingContext);

}   /* IpxStatusComplete */


#ifdef _NDIS_MEDIA_SENSE_
//
// CompareBindingCharacteristics
// 
// Inputs: Binding1, Binding2
//
// Output:
//    COMPLETE_MATCH :  They match completely
//    PARTIAL_MATCH  :  They match partially
//    zero otherwise
//

UINT
CompareBindingCharacteristics(
                              PBINDING Binding1, 
                              PBINDING Binding2
                              )
{
   UINT  Match = 0; // we return this if nothing matches.

   //
   // if the mac address happens to be the same, it must be 
   // the same card on a different net.
   //

   if (IPX_NODE_EQUAL(Binding1->LocalMacAddress.Address, Binding2->LocalMacAddress.Address)) {
      Match = PARTIAL_MATCH;
   }

   if ((Binding1->FrameType == Binding2->FrameType) &&
       (Binding1->LocalAddress.NetworkAddress == Binding2->LocalAddress.NetworkAddress) && 
       (IPX_NODE_EQUAL(Binding1->LocalAddress.NodeAddress, Binding2->LocalAddress.NodeAddress))) {
    
       /*if ((LINE_UP == Binding1->LineUp) && (LINE_UP == Binding2->LineUp) &&
           (Binding1->MaxSendPacketSize == Binding2->MaxSendPacketSize) &&
           (Binding1->MediumSpeed == Binding2->MediumSpeed) &&
           (IPX_NODE_EQUAL(Binding1->RemoteMacAddress, Binding2->RemoteMacAddress))) {
         */ 
          return COMPLETE_MATCH;
   //    }
   }
   
   return Match;

}

//** IpxMediaSenseWorker - Handles Media Sense work on a CTE worker 
//  because NdisProtocolStatus runs at DPC.
//
//  Called from the worker thread event scheduled by IPXStatus.
//
//  Entry:
//       NdisProtocolBindingContext == AdapterName
//
//  Exit:
//      None.
//
void
IpxMediaSenseHandler(
    IN CTEEvent *WorkerThreadEvent,
    IN PVOID Context)
{

    PADAPTER Adapter =  (PADAPTER) Context;
    UNICODE_STRING      DeviceName;
    BOOLEAN             MatchFound[ISN_FRAME_TYPE_MAX], AdapterMatched;
    PADAPTER            DisabledAdapter = NULL;
    int                 j, MatchLevel;
    ULONG               Index, i;
    NDIS_STRING         AdapterName;
    NTSTATUS            Status;
    PDEVICE             Device = IpxDevice;
    PBINDING            Binding;
    IPX_DEFINE_LOCK_HANDLE (LockHandle)
    
    ASSERT(Context != NULL);
	
    IpxReferenceAdapter(Adapter);

    CTEFreeMem(WorkerThreadEvent);

    IPX_DEBUG(PNP, ("Ndis_Status_Media_Sense: CONNECT for %ws\n", Adapter->AdapterName));

    RtlInitUnicodeString(&AdapterName, Adapter->AdapterName);

    for (j = 0; j < ISN_FRAME_TYPE_MAX; j++) {
       MatchFound[j] = FALSE;
    }
    AdapterMatched = FALSE;

    IpxBindAdapter(
                   &Status,
                   NULL, //Adapter,
                   &AdapterName,    // \\Device\IEEPRO1
                   NULL,         
                   NULL
                   );

    if (STATUS_SUCCESS != Status) {
        IPX_DEBUG(PNP, ("IpxBindAdapter returned : %x\n", Status));
    }

    // new Adapter's characteristics with in the list of previously disabled adapters.
    Index = MIN (Device->MaxBindings, Device->HighestExternalNicId);

    IPX_GET_LOCK1(&Device->BindAccessLock, LockHandle);

    for (i = FIRST_REAL_BINDING; i <= Index; i++) {

       Binding = NIC_ID_TO_BINDING(Device, i);

       if (!Binding) {
          continue;
       }
       
       if (Binding->Disabled == DISABLED) {

          for (j = 0; j < ISN_FRAME_TYPE_MAX; j++) {
             if (!Adapter->Bindings[j]) {
                continue;   // NULL Binding
             }

             if (!MatchFound[j]) {
                MatchLevel = CompareBindingCharacteristics(Binding, Adapter->Bindings[j]);
                if (COMPLETE_MATCH == MatchLevel) {
                   MatchFound[j] = TRUE;
                   DisabledAdapter = Binding->Adapter;
                } else if (PARTIAL_MATCH == MatchLevel) {
                   // if we had more than one disabled adapters, this is
                   // most probably the one which is changed
                   DisabledAdapter = Binding->Adapter; // Free this puppy later
                }
             }
             // Try another
          }
       }
    }

    for (j = 0; j < ISN_FRAME_TYPE_MAX; j++) {
       if (MatchFound[j]) {
          AdapterMatched = TRUE;
          IPX_DEBUG(PNP, ("Found a matching adapter !\n"));
          break;
       }

    }
    
    IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle);

    if (AdapterMatched) {

       IPX_DEBUG(PNP, ("Freeing the newly created adapter since we found a match !\n"));

       IpxUnbindAdapter(
                        &Status,
                        Adapter,
                        NULL
                        );
       
       if (STATUS_SUCCESS != Status) {
           IPX_DEBUG(PNP, ("IpxUnBindAdapter returned : %x\n", Status));
       } else {
          for ( j = 0; j< ISN_FRAME_TYPE_MAX; j++ ) {
             if (DisabledAdapter->Bindings[j]) {
                DisabledAdapter->Bindings[j]->Disabled = ENABLED;
             }

          }
          Adapter->Disabled = ENABLED;
       }

    } else if (DisabledAdapter != NULL) {
       
       IPX_DEBUG(PNP, ("Freeing the previously disabled adapter since we have new characteristics...!\n"));
       
       ASSERT(DisabledAdapter != NULL);

       IpxUnbindAdapter(
                        &Status,
                        DisabledAdapter,
                        NULL
                        );
       
       if (STATUS_SUCCESS != Status) {
          IPX_DEBUG(PNP, ("IpxBindAdapter returned : %x\n", Status));
       }

    } else {

        IPX_DEBUG(PNP, ("NULL Disabled Adapter. Ndis is probably giving random notifications.\n"));

    }

    IpxDereferenceAdapter(Adapter);
        

}
#endif // _NDIS_MEDIA_SENSE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\precomp.h ===
/*++

Copyright (c) 1993-1995  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Precompilation header file.

Author:

    Adam Barr (adamba) 08-Sep-1993

Revision History:

--*/


#define ISN_NT 1

//
// These are needed for CTE
//

#if DBG
#define DEBUG 1
#endif

#define NT 1
#define _HIPX_SUBAGNT

#include <ntosp.h>
#include <tdikrnl.h>
#include <ndis.h>
#include <cxport.h>
#include <bind.h>
#include "isnipx.h"
#include "config.h"
#include "mac.h"
#include "ipxtypes.h"
#include "ipxprocs.h"
#include <wsnwlink.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\reconfig.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    reconfig.h

Abstract:

    Private include file for the ISN IPX module.
    file defines all constants and structures necessary for support of
    the dynamic configuration of ST.

Revision History:

--*/


//
// These are used to index into the Parameters array in CONFIG.
//

#define CONFIG_DEDICATED_ROUTER  0
#define CONFIG_INIT_DATAGRAMS    1
#define CONFIG_MAX_DATAGRAMS     2
#define CONFIG_RIP_AGE_TIME      3
#define CONFIG_RIP_COUNT         4
#define CONFIG_RIP_TIMEOUT       5
#define CONFIG_RIP_USAGE_TIME    6
#define CONFIG_ROUTE_USAGE_TIME  7
#define CONFIG_SOCKET_UNIQUENESS 8
#define CONFIG_SOCKET_START      9
#define CONFIG_SOCKET_END       10
#define CONFIG_VIRTUAL_NETWORK  11
#define CONFIG_MAX_MEMORY_USAGE 12
#define CONFIG_RIP_TABLE_SIZE   13
#define CONFIG_VIRTUAL_OPTIONAL 14
#define CONFIG_ETHERNET_PAD     15
#define CONFIG_ETHERNET_LENGTH  16
#define CONFIG_SINGLE_NETWORK   17
#define CONFIG_DISABLE_DIALOUT_SAP 18
#define CONFIG_DISABLE_DIALIN_NB 19
#define CONFIG_VERIFY_SOURCE_ADDRESS 20

#define CONFIG_PARAMETERS       21

//
// Main configuration structure.
//

typedef struct _CONFIG {

    ULONG Parameters[CONFIG_PARAMETERS];  // index defined above
    NDIS_STRING DeviceName;               // device name exported
    PWSTR RegistryPathBuffer;             // path to config info
    ULONG BindCount;                      // entries in BindingList
    LIST_ENTRY BindingList;               // one per binding
    PDRIVER_OBJECT DriverObject;          // used for logging errors

} CONFIG, * PCONFIG;


//
// These are used to index into the Parameters array in BINDING_CONFIG.
//

#define BINDING_MAX_PKT_SIZE        0
#define BINDING_BIND_SAP            1
#define BINDING_DEFAULT_AUTO_DETECT 2
#define BINDING_SOURCE_ROUTE        3
#define BINDING_ALL_ROUTE_DEF       4
#define BINDING_ALL_ROUTE_BC        5
#define BINDING_ALL_ROUTE_MC        6
#define BINDING_ENABLE_FUNC_ADDR    7
#define BINDING_ENABLE_WAN          8

#define BINDING_PARAMETERS          9


//
// One of these is allocated per adapter we are to bind to.
//

typedef struct _BINDING_CONFIG {

    LIST_ENTRY Linkage;                   // for chaining on BindingList
    NDIS_STRING AdapterName;              // NDIS adapter to bind to
    ULONG FrameTypeCount;                 // number of frame types defined (max. 4)
                                          //  == number of valid entries in arrays:
    ULONG FrameType[ISN_FRAME_TYPE_MAX];  // ISN_FRAME_TYPE_XXX
    ULONG NetworkNumber[ISN_FRAME_TYPE_MAX]; // may be 0
    BOOLEAN AutoDetect[ISN_FRAME_TYPE_MAX]; // remove if net number can't be found
    BOOLEAN DefaultAutoDetect[ISN_FRAME_TYPE_MAX]; // use this if multiple or none found
    ULONG Parameters[BINDING_PARAMETERS]; // index defined above
    PDRIVER_OBJECT DriverObject;          // used for logging errors

} BINDING_CONFIG, * PBINDING_CONFIG;


NTSTATUS
IpxGetConfiguration (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath,
    OUT PCONFIG * ConfigPtr
    );

VOID
IpxFreeConfiguration (
    IN PCONFIG Config
    );

VOID
IpxWriteDefaultAutoDetectType(
    IN PUNICODE_STRING RegistryPath,
    IN struct _ADAPTER * Adapter,
    IN ULONG FrameType
    );

NTSTATUS
IpxPnPGetVirtualNetworkNumber (
    IN	PCONFIG	Config
    );

NTSTATUS
IpxPnPGetAdapterParameters(
	IN		PCONFIG			Config,
	IN		PNDIS_STRING	DeviceName,
	IN OUT	PBINDING_CONFIG	Binding
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\packet.c ===
/*++
Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    packet.c

Abstract:

    This module contains code that implements the SEND_PACKET and
    RECEIVE_PACKET objects, which describe NDIS packets used
    by the transport.

Environment:

    Kernel mode

Revision History:

	Sanjay Anand (SanjayAn) - 22-Sept-1995
	BackFill optimization changes added under #if BACK_FILL

--*/

#include "precomp.h"
#pragma hdrstop


NTSTATUS
IpxInitializeSendPacket(
    IN PDEVICE Device,
    IN PIPX_SEND_PACKET Packet,
    IN PUCHAR Header
    )

/*++

Routine Description:

    This routine initializes a send packet by chaining the
    buffer for the header on it.

Arguments:

    Device - The device.

    Packet - The packet to initialize.

    Header - Points to storage for the header.

Return Value:

    None.

--*/

{

    NDIS_STATUS NdisStatus;
    NTSTATUS Status;
    PNDIS_BUFFER NdisMacBuffer;
    PNDIS_BUFFER NdisIpxBuffer;
    PIPX_SEND_RESERVED Reserved;

    IpxAllocateSendPacket (Device, Packet, &Status);

    if (Status != STATUS_SUCCESS) {
        // ERROR LOG
        return Status;
    }

    NdisAllocateBuffer(
        &NdisStatus,
        &NdisMacBuffer,
        Device->NdisBufferPoolHandle,
        Header,
        MAC_HEADER_SIZE);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        IpxFreeSendPacket (Device, Packet);
        // ERROR LOG
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NdisAllocateBuffer(
        &NdisStatus,
        &NdisIpxBuffer,
        Device->NdisBufferPoolHandle,
        Header + MAC_HEADER_SIZE,
        IPX_HEADER_SIZE + RIP_PACKET_SIZE);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        IpxFreeSendPacket (Device, Packet);
        // ERROR LOG
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NdisChainBufferAtFront (PACKET(Packet), NdisMacBuffer);
    NdisChainBufferAtBack (PACKET(Packet), NdisIpxBuffer);

	//
	// This flag optimizes the virtual to physical address X-ln
	// in the MAC drivers on x86
	//
    NdisMacBuffer->MdlFlags|=MDL_NETWORK_HEADER;
    NdisIpxBuffer->MdlFlags|=MDL_NETWORK_HEADER;

    Reserved = SEND_RESERVED(Packet);
    Reserved->Identifier = IDENTIFIER_IPX;
    Reserved->SendInProgress = FALSE;
    Reserved->Header = Header;
    Reserved->HeaderBuffer = NdisMacBuffer;
    Reserved->PaddingBuffer = NULL;
#if BACK_FILL
    Reserved->BackFill = FALSE;
#endif

    ExInterlockedInsertHeadList(
        &Device->GlobalSendPacketList,
        &Reserved->GlobalLinkage,
        &Device->Lock);

    return STATUS_SUCCESS;

}   /* IpxInitializeSendPacket */

#if BACK_FILL
NTSTATUS
IpxInitializeBackFillPacket(
    IN PDEVICE Device,
    IN PIPX_SEND_PACKET Packet,
    IN PUCHAR Header
    )

/*++

Routine Description:

    This routine initializes a send packet by chaining the
    buffer for the header on it.

Arguments:

    Device - The device.

    Packet - The packet to initialize.

    Header - Points to storage for the header.

Return Value:

    None.

--*/

{

    NDIS_STATUS NdisStatus;
    NTSTATUS Status;
    PNDIS_BUFFER NdisMacBuffer;
    PNDIS_BUFFER NdisIpxBuffer;
    PIPX_SEND_RESERVED Reserved;


    IPX_DEBUG (PACKET, ("Initializing backfill packet\n"));
    IpxAllocateSendPacket (Device, Packet, &Status);

    if (Status != STATUS_SUCCESS) {
        // ERROR LOG
        return Status;
    }


    Reserved = SEND_RESERVED(Packet);
    Reserved->Identifier = IDENTIFIER_IPX;
    Reserved->SendInProgress = FALSE;
    Reserved->Header = NULL;
    Reserved->HeaderBuffer = NULL;
    Reserved->PaddingBuffer = NULL;
    Reserved->BackFill = TRUE;

    ExInterlockedInsertHeadList(
        &Device->GlobalBackFillPacketList,
        &Reserved->GlobalLinkage,
        &Device->Lock);

    IPX_DEBUG (PACKET, ("Initializing backfill packet Done\n"));
    return STATUS_SUCCESS;

}   /* IpxInitializeBackFillPacket */
#endif


NTSTATUS
IpxInitializeReceivePacket(
    IN PDEVICE Device,
    IN PIPX_RECEIVE_PACKET Packet
    )

/*++

Routine Description:

    This routine initializes a receive packet.

Arguments:

    Device - The device.

    Packet - The packet to initialize.

Return Value:

    None.

--*/

{

    NTSTATUS Status;
    PIPX_RECEIVE_RESERVED Reserved;

    IpxAllocateReceivePacket (Device, Packet, &Status);

    if (Status != STATUS_SUCCESS) {
        // ERROR LOG
        return Status;
    }

    Reserved = RECEIVE_RESERVED(Packet);
    Reserved->Identifier = IDENTIFIER_IPX;
    Reserved->TransferInProgress = FALSE;
    Reserved->SingleRequest = NULL;
    Reserved->ReceiveBuffer = NULL;
    InitializeListHead (&Reserved->Requests);

    ExInterlockedInsertHeadList(
        &Device->GlobalReceivePacketList,
        &Reserved->GlobalLinkage,
        &Device->Lock);

    return STATUS_SUCCESS;

}   /* IpxInitializeReceivePacket */


NTSTATUS
IpxInitializeReceiveBuffer(
    IN PADAPTER Adapter,
    IN PIPX_RECEIVE_BUFFER ReceiveBuffer,
    IN PUCHAR DataBuffer,
    IN ULONG DataBufferLength
    )

/*++

Routine Description:

    This routine initializes a receive buffer by allocating
    an NDIS_BUFFER to describe the data buffer.

Arguments:

    Adapter - The adapter.

    ReceiveBuffer - The receive buffer to initialize.

    DataBuffer - The data buffer.

    DataBufferLength - The length of the data buffer.

Return Value:

    None.

--*/

{

    NDIS_STATUS NdisStatus;
    PNDIS_BUFFER NdisBuffer;
    PDEVICE Device = Adapter->Device;


    NdisAllocateBuffer(
        &NdisStatus,
        &NdisBuffer,
        Device->NdisBufferPoolHandle,
        DataBuffer,
        DataBufferLength);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        // ERROR LOG
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ReceiveBuffer->NdisBuffer = NdisBuffer;
    ReceiveBuffer->Data = DataBuffer;
    ReceiveBuffer->DataLength = 0;

    ExInterlockedInsertHeadList(
        &Device->GlobalReceiveBufferList,
        &ReceiveBuffer->GlobalLinkage,
        &Device->Lock);

    return STATUS_SUCCESS;

}   /* IpxInitializeReceiveBuffer */


NTSTATUS
IpxInitializePaddingBuffer(
    IN PDEVICE Device,
    IN PIPX_PADDING_BUFFER PaddingBuffer,
    IN ULONG DataBufferLength
    )

/*++

Routine Description:

    This routine initializes a padding buffer by allocating
    an NDIS_BUFFER to describe the data buffer.

Arguments:

    Adapter - The adapter.

    PaddingBuffer - The receive buffer to initialize.

    DataBufferLength - The length of the data buffer.

Return Value:

    None.

--*/

{

    NDIS_STATUS NdisStatus;
    PNDIS_BUFFER NdisBuffer;

    NdisAllocateBuffer(
        &NdisStatus,
        &NdisBuffer,
        Device->NdisBufferPoolHandle,
        PaddingBuffer->Data,
        DataBufferLength);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        // ERROR LOG
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NDIS_BUFFER_LINKAGE(NdisBuffer) = (PNDIS_BUFFER)NULL;
    PaddingBuffer->NdisBuffer = NdisBuffer;
    PaddingBuffer->DataLength = DataBufferLength;
    RtlZeroMemory (PaddingBuffer->Data, DataBufferLength);

    return STATUS_SUCCESS;

}   /* IpxInitializePaddingBuffer */


VOID
IpxDeinitializeSendPacket(
    IN PDEVICE Device,
    IN PIPX_SEND_PACKET Packet
    )

/*++

Routine Description:

    This routine deinitializes a send packet.

Arguments:

    Device - The device.

    Packet - The packet to deinitialize.

Return Value:

    None.

--*/

{

    PNDIS_BUFFER NdisBuffer;
    PNDIS_BUFFER NdisIpxBuffer;
    PIPX_SEND_RESERVED Reserved;
    CTELockHandle LockHandle;


    Reserved = SEND_RESERVED(Packet);

    CTEGetLock (&Device->Lock, &LockHandle);
    RemoveEntryList (&Reserved->GlobalLinkage);
    CTEFreeLock (&Device->Lock, LockHandle);

    //
    // Free the packet in a slightly unconventional way; this
    // allows us to not have to NULL out HeaderBuffer's linkage
    // field during normal operations when we put it back in
    // the free pool.
    //

    NdisBuffer = Reserved->HeaderBuffer;
    NdisIpxBuffer = NDIS_BUFFER_LINKAGE(NdisBuffer);
    NDIS_BUFFER_LINKAGE (NdisBuffer) = NULL;
    NDIS_BUFFER_LINKAGE (NdisIpxBuffer) = NULL;

#if 0
    NdisAdjustBufferLength (NdisBuffer, PACKET_HEADER_SIZE);
#endif
    NdisAdjustBufferLength (NdisBuffer, MAC_HEADER_SIZE);
    NdisAdjustBufferLength (NdisIpxBuffer, IPX_HEADER_SIZE + RIP_PACKET_SIZE);

    NdisFreeBuffer (NdisBuffer);
    NdisFreeBuffer (NdisIpxBuffer);

    NdisReinitializePacket (PACKET(Packet));
    IpxFreeSendPacket (Device, Packet);

}   /* IpxDeinitializeSendPacket */

#if BACK_FILL
VOID
IpxDeinitializeBackFillPacket(
    IN PDEVICE Device,
    IN PIPX_SEND_PACKET Packet
    )

/*++

Routine Description:

    This routine deinitializes a back fill packet.

Arguments:

    Device - The device.

    Packet - The packet to deinitialize.

Return Value:

    None.

--*/

{

    PNDIS_BUFFER NdisBuffer;
    PNDIS_BUFFER NdisIpxBuffer;
    PIPX_SEND_RESERVED Reserved;
    CTELockHandle LockHandle;

    IPX_DEBUG (PACKET, ("DeInitializing backfill packet\n"));

    Reserved = SEND_RESERVED(Packet);

    CTEGetLock (&Device->Lock, &LockHandle);
    RemoveEntryList (&Reserved->GlobalLinkage);
    CTEFreeLock (&Device->Lock, LockHandle);



    NdisReinitializePacket (PACKET(Packet));
    IpxFreeSendPacket (Device, Packet);
    IPX_DEBUG (PACKET, ("DeInitializing backfill packet Done\n"));


}   /* IpxDeinitializeBackFillPacket */
#endif


VOID
IpxDeinitializeReceivePacket(
    IN PDEVICE Device,
    IN PIPX_RECEIVE_PACKET Packet
    )

/*++

Routine Description:

    This routine initializes a receive packet.

Arguments:

    Device - The device.

    Packet - The packet to initialize.

Return Value:

    None.

--*/

{

    PIPX_RECEIVE_RESERVED Reserved;
    CTELockHandle LockHandle;

    Reserved = RECEIVE_RESERVED(Packet);

    CTEGetLock (&Device->Lock, &LockHandle);
    RemoveEntryList (&Reserved->GlobalLinkage);
    CTEFreeLock (&Device->Lock, LockHandle);

    IpxFreeReceivePacket (Device, Packet);

}   /* IpxDeinitializeReceivePacket */


VOID
IpxDeinitializeReceiveBuffer(
    IN PADAPTER Adapter,
    IN PIPX_RECEIVE_BUFFER ReceiveBuffer,
    IN ULONG DataBufferLength
    )

/*++

Routine Description:

    This routine deinitializes a receive buffer.

Arguments:

    Device - The device.

    ReceiveBuffer - The receive buffer.

    DataBufferLength - The allocated length of the receive buffer.

Return Value:

    None.

--*/

{
    CTELockHandle LockHandle;
    PDEVICE Device = Adapter->Device;

    CTEGetLock (&Device->Lock, &LockHandle);
    RemoveEntryList (&ReceiveBuffer->GlobalLinkage);
    CTEFreeLock (&Device->Lock, LockHandle);

    NdisAdjustBufferLength (ReceiveBuffer->NdisBuffer, DataBufferLength);
    NdisFreeBuffer (ReceiveBuffer->NdisBuffer);

}   /* IpxDeinitializeReceiveBuffer */


VOID
IpxDeinitializePaddingBuffer(
    IN PDEVICE Device,
    IN PIPX_PADDING_BUFFER PaddingBuffer,
    IN ULONG DataBufferLength
    )

/*++

Routine Description:

    This routine deinitializes a padding buffer.

Arguments:

    Device - The device.

    PaddingBuffer - The padding buffer.

    DataBufferLength - The allocated length of the padding buffer.

Return Value:

    None.

--*/

{

    NdisAdjustBufferLength (PaddingBuffer->NdisBuffer, DataBufferLength);
    NdisFreeBuffer (PaddingBuffer->NdisBuffer);

}   /* IpxDeinitializePaddingBuffer */


VOID
IpxAllocateSendPool(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine adds 10 packets to the pool for this device.

Arguments:

    Device - The device.

Return Value:

    None.

--*/

{
    PIPX_SEND_POOL SendPool;
    UINT HeaderSize;
    UINT PacketNum;
    IPX_SEND_PACKET Packet;
    PIPX_SEND_RESERVED Reserved;
    PUCHAR Header;
    NDIS_STATUS Status;

    CTELockHandle LockHandle;

    SendPool = (PIPX_SEND_POOL)IpxAllocateMemory (sizeof(IPX_SEND_POOL), MEMORY_PACKET, "SendPool");

    if (SendPool == NULL) {
        IPX_DEBUG (PACKET, ("Could not allocate send pool memory\n"));
        return;
    }

    HeaderSize = PACKET_HEADER_SIZE * Device->InitDatagrams;

    Header = (PUCHAR)IpxAllocateMemory (HeaderSize, MEMORY_PACKET, "SendPool");

    if (Header == NULL) {
        IPX_DEBUG (PACKET, ("Could not allocate header memory\n"));
	//290901
	IpxFreeMemory(SendPool, sizeof(IPX_SEND_POOL), MEMORY_PACKET, "SendPool");
        return;
    }

    SendPool->PoolHandle = (void *) NDIS_PACKET_POOL_TAG_FOR_NWLNKIPX;

    NdisAllocatePacketPoolEx(
                             &Status, 
                             &SendPool->PoolHandle, 
                             Device->InitDatagrams, 
                             0,
                             sizeof(IPX_SEND_RESERVED)
                             );

    if (Status == NDIS_STATUS_RESOURCES) {
        IPX_DEBUG (PACKET, ("Could not allocate Ndis pool memory\n"));
	//290901
        IpxFreeMemory(SendPool, sizeof(IPX_SEND_POOL), MEMORY_PACKET, "SendPool");
	IpxFreeMemory(Header, HeaderSize, MEMORY_PACKET, "SendPool");
        return;
    }

    NdisSetPacketPoolProtocolId(SendPool->PoolHandle, NDIS_PROTOCOL_ID_IPX);

    Device->MemoryUsage += Device->InitDatagrams * sizeof(IPX_SEND_RESERVED);

    IPX_DEBUG (PACKET, ("Initializing send pool %lx, %d packets\n",
                             SendPool, Device->InitDatagrams));

    SendPool->Header = Header;

    for (PacketNum = 0; PacketNum < Device->InitDatagrams; PacketNum++) {

        NdisAllocatePacket(&Status, &PACKET(&Packet), SendPool->PoolHandle);

        if (IpxInitializeSendPacket (Device, &Packet, Header) != STATUS_SUCCESS) {
            IPX_DEBUG (PACKET, ("Could not initialize packet %lx\n", Packet));
            break;
        }

        Reserved = SEND_RESERVED(&Packet);
        Reserved->Address = NULL;
        Reserved->OwnedByAddress = FALSE;
#ifdef IPX_TRACK_POOL
        Reserved->Pool = SendPool;
#endif

        IPX_PUSH_ENTRY_LIST (&Device->SendPacketList, &Reserved->PoolLinkage, &Device->SListsLock);

        Header += PACKET_HEADER_SIZE;

    }

    CTEGetLock (&Device->Lock, &LockHandle);

    Device->AllocatedDatagrams += PacketNum;
    InsertTailList (&Device->SendPoolList, &SendPool->Linkage);

    CTEFreeLock (&Device->Lock, LockHandle);
}   /* IpxAllocateSendPool */


#if BACK_FILL

VOID
IpxAllocateBackFillPool(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine adds 10 packets to the pool for this device.

Arguments:

    Device - The device.

Return Value:

    None.

--*/

{
    UINT PacketNum;
    IPX_SEND_PACKET Packet;
    PIPX_SEND_RESERVED Reserved;
    CTELockHandle LockHandle;
    PIPX_SEND_POOL BackFillPool;
    NDIS_STATUS Status;

    IPX_DEBUG (PACKET, ("Allocating backfill pool\n"));

    // Allocate pool for back fillable packets

    BackFillPool = (PIPX_SEND_POOL)IpxAllocateMemory (sizeof(IPX_SEND_POOL), MEMORY_PACKET, "BafiPool");

    if (BackFillPool == NULL) {
        IPX_DEBUG (PACKET, ("Could not allocate backfill pool memory\n"));
        return;
    }
    
    BackFillPool->PoolHandle = (void *) NDIS_PACKET_POOL_TAG_FOR_NWLNKIPX;

    NdisAllocatePacketPoolEx(
                             &Status, 
                             &BackFillPool->PoolHandle, 
                             Device->InitDatagrams, 
                             0,
                             sizeof(IPX_SEND_RESERVED)
                             );

    if (Status == NDIS_STATUS_RESOURCES) {
        IPX_DEBUG (PACKET, ("Could not allocate Ndis pool memory\n"));
        return;
    }
    
    NdisSetPacketPoolProtocolId(BackFillPool->PoolHandle, NDIS_PROTOCOL_ID_IPX);
    
    Device->MemoryUsage += Device->InitDatagrams * sizeof(IPX_SEND_RESERVED);

    for (PacketNum = 0; PacketNum < Device->InitDatagrams; PacketNum++) {

        NdisAllocatePacket(&Status, &PACKET(&Packet), BackFillPool->PoolHandle);

        if (IpxInitializeBackFillPacket (Device, &Packet, NULL) != STATUS_SUCCESS) {
            IPX_DEBUG (PACKET, ("Could not initialize packet %lx\n", Packet));
            break;
        }

        Reserved = SEND_RESERVED(&Packet);
        Reserved->Address = NULL;
        Reserved->OwnedByAddress = FALSE;
#ifdef IPX_TRACK_POOL
        Reserved->Pool = BackFillPool;
#endif

        IPX_PUSH_ENTRY_LIST (&Device->BackFillPacketList, &Reserved->PoolLinkage, &Device->SListsLock);
    }

    CTEGetLock (&Device->Lock, &LockHandle);

    InsertTailList (&Device->BackFillPoolList, &BackFillPool->Linkage);

    CTEFreeLock (&Device->Lock, LockHandle);
}   /* IpxAllocateBackFillPool */

#endif


VOID
IpxAllocateReceivePool(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine adds receive packets to the pool for this device.

Arguments:

    Device - The device.

Return Value:

    None.

--*/

{
    PIPX_RECEIVE_POOL ReceivePool;
    UINT PacketNum;
    IPX_RECEIVE_PACKET Packet;
    PIPX_RECEIVE_RESERVED Reserved;
    CTELockHandle LockHandle;
    NDIS_STATUS Status;

    ReceivePool = (PIPX_SEND_POOL)IpxAllocateMemory (sizeof(IPX_RECEIVE_POOL), MEMORY_PACKET, "ReceivePool");

    if (ReceivePool == NULL) {
        IPX_DEBUG (PACKET, ("Could not allocate receive pool memory\n"));
        return;
    }

    ReceivePool->PoolHandle = (void *) NDIS_PACKET_POOL_TAG_FOR_NWLNKIPX;

    NdisAllocatePacketPoolEx(
                             &Status, 
                             &ReceivePool->PoolHandle, 
                             Device->InitDatagrams, 
                             0,
                             sizeof(IPX_SEND_RESERVED)
                             );

    if (Status == NDIS_STATUS_RESOURCES) {
        IPX_DEBUG (PACKET, ("Could not allocate receive pool memory\n"));
        return;
    }
    
    NdisSetPacketPoolProtocolId(ReceivePool->PoolHandle, NDIS_PROTOCOL_ID_IPX);

    IPX_DEBUG (PACKET, ("Initializing receive pool %lx, %d packets\n",
                             ReceivePool, Device->InitReceivePackets));

    Device->MemoryUsage += Device->InitDatagrams * sizeof(IPX_SEND_RESERVED);

    for (PacketNum = 0; PacketNum < Device->InitReceivePackets; PacketNum++) {

        NdisAllocatePacket(&Status, &PACKET(&Packet), ReceivePool->PoolHandle);

        if (IpxInitializeReceivePacket (Device, &Packet) != STATUS_SUCCESS) {
            IPX_DEBUG (PACKET, ("Could not initialize packet %lx\n", Packet));
            break;
        }

        Reserved = RECEIVE_RESERVED(&Packet);
        Reserved->Address = NULL;
        Reserved->OwnedByAddress = FALSE;
#ifdef IPX_TRACK_POOL
        Reserved->Pool = ReceivePool;
#endif

        IPX_PUSH_ENTRY_LIST (&Device->ReceivePacketList, &Reserved->PoolLinkage, &Device->SListsLock);

    }

    CTEGetLock (&Device->Lock, &LockHandle);

    Device->AllocatedReceivePackets += PacketNum;

    InsertTailList (&Device->ReceivePoolList, &ReceivePool->Linkage);

    CTEFreeLock (&Device->Lock, LockHandle);
}   /* IpxAllocateReceivePool */

VOID
IpxAllocateReceiveBufferPool(
    IN PADAPTER Adapter
    )

/*++

Routine Description:

    This routine adds receive buffers to the pool for this adapter.

Arguments:

    Adapter - The adapter.

Return Value:

    None.

--*/

{
    PIPX_RECEIVE_BUFFER ReceiveBuffer;
    UINT ReceiveBufferPoolSize;
    UINT BufferNum;
    PIPX_RECEIVE_BUFFER_POOL ReceiveBufferPool;
    PDEVICE Device = Adapter->Device;
    UINT DataLength;
    PUCHAR Data;
    CTELockHandle LockHandle;

    DataLength = Adapter->MaxReceivePacketSize;

    ReceiveBufferPoolSize = FIELD_OFFSET (IPX_RECEIVE_BUFFER_POOL, Buffers[0]) +
                       (sizeof(IPX_RECEIVE_BUFFER) * Device->InitReceiveBuffers) +
                       (DataLength * Device->InitReceiveBuffers);

    ReceiveBufferPool = (PIPX_RECEIVE_BUFFER_POOL)IpxAllocateMemory (ReceiveBufferPoolSize, MEMORY_PACKET, "ReceiveBufferPool");
    if (ReceiveBufferPool == NULL) {
        IPX_DEBUG (PACKET, ("Could not allocate receive buffer pool memory\n"));
        return;
    }

    IPX_DEBUG (PACKET, ("Init recv buffer pool %lx, %d buffers, data %d\n",
                             ReceiveBufferPool, Device->InitReceiveBuffers, DataLength));

    Data = (PUCHAR)(&ReceiveBufferPool->Buffers[Device->InitReceiveBuffers]);


    for (BufferNum = 0; BufferNum < Device->InitReceiveBuffers; BufferNum++) {

        ReceiveBuffer = &ReceiveBufferPool->Buffers[BufferNum];

        if (IpxInitializeReceiveBuffer (Adapter, ReceiveBuffer, Data, DataLength) != STATUS_SUCCESS) {
            IPX_DEBUG (PACKET, ("Could not initialize buffer %lx\n", ReceiveBuffer));
            break;
        }

#ifdef IPX_TRACK_POOL
        ReceiveBuffer->Pool = ReceiveBufferPool;
#endif

        Data += DataLength;

    }

    ReceiveBufferPool->BufferCount = BufferNum;
    ReceiveBufferPool->BufferFree = BufferNum;

    CTEGetLock (&Device->Lock, &LockHandle);

    for (BufferNum = 0; BufferNum < ReceiveBufferPool->BufferCount; BufferNum++) {

        ReceiveBuffer = &ReceiveBufferPool->Buffers[BufferNum];
        IPX_PUSH_ENTRY_LIST (&Adapter->ReceiveBufferList, &ReceiveBuffer->PoolLinkage, &Device->SListsLock);

    }

    InsertTailList (&Adapter->ReceiveBufferPoolList, &ReceiveBufferPool->Linkage);

    Adapter->AllocatedReceiveBuffers += ReceiveBufferPool->BufferCount;

    CTEFreeLock (&Device->Lock, LockHandle);

}   /* IpxAllocateReceiveBufferPool */


PSLIST_ENTRY
IpxPopSendPacket(
    PDEVICE Device
    )

/*++

Routine Description:

    This routine allocates a packet from the device context's pool.
    If there are no packets in the pool, it allocates one up to
    the configured limit.

Arguments:

    Device - Pointer to our device to charge the packet to.

Return Value:

    The pointer to the Linkage field in the allocated packet.

--*/

{
    PSLIST_ENTRY s;

    s = IPX_POP_ENTRY_LIST(
            &Device->SendPacketList,
            &Device->SListsLock);

    if (s != NULL) {
        return s;
    }

    //
    // No packets in the pool, see if we can allocate more.
    //

    if (Device->AllocatedDatagrams < Device->MaxDatagrams) {

        //
        // Allocate a pool and try again.
        //

        IpxAllocateSendPool (Device);
        s = IPX_POP_ENTRY_LIST(
                &Device->SendPacketList,
                &Device->SListsLock);

        return s;

    } else {

        return NULL;

    }

}   /* IpxPopSendPacket */

#if BACK_FILL

PSLIST_ENTRY
IpxPopBackFillPacket(
    PDEVICE Device
    )

/*++

Routine Description:

    This routine allocates a packet from the device context's pool.
    If there are no packets in the pool, it allocates one up to
    the configured limit.

Arguments:

    Device - Pointer to our device to charge the packet to.

Return Value:

    The pointer to the Linkage field in the allocated packet.

--*/

{
    PSLIST_ENTRY s;

    IPX_DEBUG (PACKET, ("Popping backfill packet\n"));


    s = IPX_POP_ENTRY_LIST(
            &Device->BackFillPacketList,
            &Device->SListsLock);

    if (s != NULL) {
        return s;
    }

    //
    // No packets in the pool, see if we can allocate more.
    //

    if (Device->AllocatedDatagrams < Device->MaxDatagrams) {

        //
        // Allocate a pool and try again.
        //

        IpxAllocateBackFillPool (Device);
        s = IPX_POP_ENTRY_LIST(
                &Device->BackFillPacketList,
                &Device->SListsLock);


    IPX_DEBUG (PACKET, ("Popping backfill packet done\n"));
        return s;

    } else {

        return NULL;

    }

}   /* IpxPopBackFillPacket */
#endif //BackFill


PSLIST_ENTRY
IpxPopReceivePacket(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine allocates a packet from the device context's pool.
    If there are no packets in the pool, it allocates one up to
    the configured limit.

Arguments:

    Device - Pointer to our device to charge the packet to.

Return Value:

    The pointer to the Linkage field in the allocated packet.

--*/

{
    PSLIST_ENTRY s;

    s = IPX_POP_ENTRY_LIST(
            &Device->ReceivePacketList,
            &Device->SListsLock);

    if (s != NULL) {
        return s;
    }

    //
    // No packets in the pool, see if we can allocate more.
    //

    if (Device->AllocatedReceivePackets < Device->MaxReceivePackets) {

        //
        // Allocate a pool and try again.
        //

        IpxAllocateReceivePool (Device);
        s = IPX_POP_ENTRY_LIST(
                &Device->ReceivePacketList,
                &Device->SListsLock);

        return s;

    } else {

        return NULL;

    }

}   /* IpxPopReceivePacket */


PSLIST_ENTRY
IpxPopReceiveBuffer(
    IN PADAPTER Adapter
    )

/*++

Routine Description:

    This routine allocates a receive buffer from the adapter's pool.
    If there are no buffers in the pool, it allocates one up to
    the configured limit.

Arguments:

    Adapter - Pointer to our adapter to charge the buffer to.

Return Value:

    The pointer to the Linkage field in the allocated receive buffer.

--*/

{
    PSLIST_ENTRY s;
    PDEVICE Device = Adapter->Device;

    s = IPX_POP_ENTRY_LIST(
            &Adapter->ReceiveBufferList,
            &Device->SListsLock);

    if (s != NULL) {
        return s;
    }

    //
    // No buffer in the pool, see if we can allocate more.
    //

    if (Adapter->AllocatedReceiveBuffers < Device->MaxReceiveBuffers) {

        //
        // Allocate a pool and try again.
        //

        IpxAllocateReceiveBufferPool (Adapter);
        s = IPX_POP_ENTRY_LIST(
                &Adapter->ReceiveBufferList,
                &Device->SListsLock);

        return s;

    } else {

        return NULL;

    }

}   /* IpxPopReceiveBuffer */


PIPX_PADDING_BUFFER
IpxAllocatePaddingBuffer(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine allocates a padding buffer for use by all devices.

Arguments:

    Device - Pointer to our device to charge the packet to.

Return Value:

    The pointer to the allocated padding buffer.

--*/

{
    PIPX_PADDING_BUFFER PaddingBuffer;
    ULONG PaddingBufferSize;

    //
    // We are assuming that we can use 1 global padding buffer for ALL
    // transmits! We must therefore test to make sure that EthernetExtraPadding
    // is not greater than 1. Otherwise, we must assume that the extra padding
    // is being used for something and we therefore cannot share across all
    // transmit requests.
    //

    //
    // We cannot support more than 1 byte padding space, since we allocate only
    // one buffer for all transmit requests.
    //

    if ( Device->EthernetExtraPadding > 1 ) {
        IPX_DEBUG (PACKET, ("Padding buffer cannot be more than 1 byte\n"));
        DbgBreakPoint();
    }

    //
    // Allocate a padding buffer if possible.
    //

    PaddingBufferSize = FIELD_OFFSET (IPX_PADDING_BUFFER, Data[0]) + Device->EthernetExtraPadding;

    PaddingBuffer = IpxAllocateMemory (PaddingBufferSize, MEMORY_PACKET, "PaddingBuffer");

    if (PaddingBuffer != NULL) {

        if (IpxInitializePaddingBuffer (Device, PaddingBuffer, Device->EthernetExtraPadding) !=
                STATUS_SUCCESS) {
            IpxFreeMemory (PaddingBuffer, PaddingBufferSize, MEMORY_PACKET, "Padding Buffer");
        } else {
            IPX_DEBUG (PACKET, ("Allocate padding buffer %lx\n", PaddingBuffer));
            return PaddingBuffer;
        }
    }

    return NULL;

}   /* IpxAllocatePaddingBuffer */


VOID
IpxFreePaddingBuffer(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine deallocates the padding buffer.

Arguments:

    Device - Pointer to our device to charge the packet to.

Return Value:

    None

--*/

{
    ULONG PaddingBufferSize;

    if ( IpxPaddingBuffer == (PIPX_PADDING_BUFFER)NULL ) {
        return;
    }

    PaddingBufferSize = FIELD_OFFSET (IPX_PADDING_BUFFER, Data[0]) + Device->EthernetExtraPadding;
    IpxFreeMemory( IpxPaddingBuffer, PaddingBufferSize, MEMORY_PACKET, "Padding Buffer" );
    IpxPaddingBuffer = (PIPX_PADDING_BUFFER)NULL;

}   /* IpxFreePaddingBuffer */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\query.c ===
/*++

Copyright (c) 1989-1993 Microsoft Corporation

Module Name:

    query.c

Abstract:

    This module contains code which performs the following TDI services:

        o   TdiQueryInformation

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// Useful macro to obtain the total length of an MDL chain.
//

#define IpxGetMdlChainLength(Mdl, Length) { \
    PMDL _Mdl = (Mdl); \
    *(Length) = 0; \
    while (_Mdl) { \
        *(Length) += MmGetMdlByteCount(_Mdl); \
        _Mdl = _Mdl->Next; \
    } \
}



NTSTATUS
IpxTdiQueryInformation(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine performs the TdiQueryInformation request for the transport
    provider.

Arguments:

    Request - the request for the operation.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS status;
    PTDI_REQUEST_KERNEL_QUERY_INFORMATION query;
    PADDRESS_FILE AddressFile;
    ULONG ElementSize, TransportAddressSize;
    PTRANSPORT_ADDRESS TransportAddress;
    TA_ADDRESS * CurAddress;
    PBINDING Binding;
    union {
        struct {
            ULONG ActivityCount;
            TA_IPX_ADDRESS IpxAddress;
        } AddressInfo;
        TDI_DATAGRAM_INFO DatagramInfo;
        TDI_ADDRESS_IPX IpxAddress;
    } TempBuffer;
    UINT i;

	IPX_DEFINE_LOCK_HANDLE(LockHandle1)

	//
    // what type of status do we want?
    //

    query = (PTDI_REQUEST_KERNEL_QUERY_INFORMATION)REQUEST_PARAMETERS(Request);

    switch (query->QueryType) {

    case TDI_QUERY_ADDRESS_INFO:

        //
        // The caller wants the exact address value.
        //

        AddressFile = (PADDRESS_FILE)REQUEST_OPEN_CONTEXT(Request);

        status = IpxVerifyAddressFile (AddressFile);

        if (status == STATUS_SUCCESS) {

            TempBuffer.AddressInfo.ActivityCount = 0;

            IpxBuildTdiAddress(
                &TempBuffer.AddressInfo.IpxAddress,
                Device->SourceAddress.NetworkAddress,
                Device->SourceAddress.NodeAddress,
                AddressFile->Address->Socket);
#ifdef SUNDOWN

            status = TdiCopyBufferToMdl(
                &TempBuffer.AddressInfo,
                0,
                sizeof(TempBuffer.AddressInfo),
                REQUEST_NDIS_BUFFER(Request),
                0,
                (PULONG)&REQUEST_INFORMATION(Request));
#else

            status = TdiCopyBufferToMdl(
                &TempBuffer.AddressInfo,
                0,
                sizeof(TempBuffer.AddressInfo),
                REQUEST_NDIS_BUFFER(Request),
                0,
                &REQUEST_INFORMATION(Request));
#endif


            IpxDereferenceAddressFile (AddressFile, AFREF_VERIFY);

        }

        break;

    case TDI_QUERY_PROVIDER_INFO:
#ifdef SUNDOWN
        status = TdiCopyBufferToMdl (
                    &(Device->Information),
                    0,
                    sizeof (TDI_PROVIDER_INFO),
                    REQUEST_NDIS_BUFFER(Request),
                    0,
                    (PULONG)&REQUEST_INFORMATION(Request));
#else
        status = TdiCopyBufferToMdl (
                    &(Device->Information),
                    0,
                    sizeof (TDI_PROVIDER_INFO),
                    REQUEST_NDIS_BUFFER(Request),
                    0,
                    &REQUEST_INFORMATION(Request));
#endif


        break;

    case TDI_QUERY_PROVIDER_STATISTICS:
#ifdef SUNDOWN
        status = TdiCopyBufferToMdl (
                    &Device->Statistics,
                    0,
                    FIELD_OFFSET (TDI_PROVIDER_STATISTICS, ResourceStats[0]),
                    REQUEST_NDIS_BUFFER(Request),
                    0,
                    (PULONG)&REQUEST_INFORMATION(Request));
#else
        status = TdiCopyBufferToMdl (
                    &Device->Statistics,
                    0,
                    FIELD_OFFSET (TDI_PROVIDER_STATISTICS, ResourceStats[0]),
                    REQUEST_NDIS_BUFFER(Request),
                    0,
                    &REQUEST_INFORMATION(Request));
#endif


        break;

    case TDI_QUERY_DATAGRAM_INFO:

        TempBuffer.DatagramInfo.MaximumDatagramBytes = 0;
        TempBuffer.DatagramInfo.MaximumDatagramCount = 0;
#ifdef SUNDOWN
        status = TdiCopyBufferToMdl (
                    &TempBuffer.DatagramInfo,
                    0,
                    sizeof(TempBuffer.DatagramInfo),
                    REQUEST_NDIS_BUFFER(Request),
                    0,
                    (PULONG)&REQUEST_INFORMATION(Request));
#else
        status = TdiCopyBufferToMdl (
                    &TempBuffer.DatagramInfo,
                    0,
                    sizeof(TempBuffer.DatagramInfo),
                    REQUEST_NDIS_BUFFER(Request),
                    0,
                    &REQUEST_INFORMATION(Request));
#endif


        break;

    case TDI_QUERY_DATA_LINK_ADDRESS:
    case TDI_QUERY_NETWORK_ADDRESS:

        if (query->QueryType == TDI_QUERY_DATA_LINK_ADDRESS) {
            ElementSize = (2 * sizeof(USHORT)) + 6;
        } else {
            ElementSize = (2 * sizeof(USHORT)) + sizeof(TDI_ADDRESS_IPX);
        }

        TransportAddress = IpxAllocateMemory(sizeof(int) + (ElementSize * MIN (Device->MaxBindings, Device->ValidBindings)), MEMORY_QUERY, "NetworkAddress");

        if (TransportAddress == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            TransportAddress->TAAddressCount = 0;
            TransportAddressSize = sizeof(int);
            CurAddress = (TA_ADDRESS *)TransportAddress->Address;
			IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
            {
                ULONG   Index = MIN (Device->MaxBindings, Device->ValidBindings);

                for (i = FIRST_REAL_BINDING; i <= Index; i++) {

                    Binding = NIC_ID_TO_BINDING(Device, i);
                    if ((Binding == NULL) ||
                        (!Binding->LineUp)) {
                        continue;
                    }

                    if (query->QueryType == TDI_QUERY_DATA_LINK_ADDRESS) {
                        CurAddress->AddressLength = 6;
			#ifdef SUNDOWN
			CurAddress->AddressType = (USHORT)Binding->Adapter->MacInfo.RealMediumType;
			#else
			CurAddress->AddressType = Binding->Adapter->MacInfo.RealMediumType;
			#endif
			

                        RtlCopyMemory (CurAddress->Address, Binding->LocalAddress.NodeAddress, 6);
                    } else {
                        CurAddress->AddressLength = sizeof(TDI_ADDRESS_IPX);
                        CurAddress->AddressType = TDI_ADDRESS_TYPE_IPX;
                        RtlCopyMemory (CurAddress->Address, &Binding->LocalAddress, sizeof(TDI_ADDRESS_IPX));
                    }
                    ++TransportAddress->TAAddressCount;
                    TransportAddressSize += ElementSize;
                    CurAddress = (TA_ADDRESS *)(((PUCHAR)CurAddress) + ElementSize);

                }
            }

			IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

#ifdef SUNDOWN
            status = TdiCopyBufferToMdl (
                        TransportAddress,
                        0,
                        TransportAddressSize,
                        REQUEST_NDIS_BUFFER(Request),
                        0,
                        (PULONG)&REQUEST_INFORMATION(Request));
			
#else
            status = TdiCopyBufferToMdl (
                        TransportAddress,
                        0,
                        TransportAddressSize,
                        REQUEST_NDIS_BUFFER(Request),
                        0,
                        &REQUEST_INFORMATION(Request));
#endif
			


            CTEFreeMem (TransportAddress);

        }

        break;

    default:

        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    return status;

}   /* IpxTdiQueryInformation */


NTSTATUS
IpxTdiSetInformation(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine performs the TdiSetInformation request for the transport
    provider.

Arguments:

    Device - the device.

    Request - the request for the operation.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    UNREFERENCED_PARAMETER (Device);
    UNREFERENCED_PARAMETER (Request);

    return STATUS_NOT_IMPLEMENTED;

}   /* IpxTdiSetInformation */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\receive.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    receive.c

Abstract:

    This module contains code which performs the following TDI services:

        o   TdiReceiveDatagram

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop



VOID
IpxTransferDataComplete(
    IN NDIS_HANDLE BindingContext,
    IN PNDIS_PACKET NdisPacket,
    IN NDIS_STATUS NdisStatus,
    IN UINT BytesTransferred
    )

/*++

Routine Description:

    This routine receives control from the physical provider as an
    indication that an NdisTransferData has completed. We use this indication
    to complete any pended requests to our clients.

Arguments:

    BindingContext - The Adapter Binding specified at initialization time.

    NdisPacket/RequestHandle - An identifier for the request that completed.

    NdisStatus - The completion status for the request.

    BytesTransferred - Number of bytes actually transferred.


Return Value:

    None.

--*/

{
    PADAPTER Adapter = (PADAPTER)BindingContext;
    PIPX_RECEIVE_RESERVED Reserved = (PIPX_RECEIVE_RESERVED)(NdisPacket->ProtocolReserved);
    PREQUEST Request, LastRequest;
    PADDRESS_FILE AddressFile;
    ULONG ByteOffset;
    PLIST_ENTRY p;
    PDEVICE Device;


    switch (Reserved->Identifier) {

    case IDENTIFIER_IPX:

        if (!Reserved->pContext) {

            if (Reserved->SingleRequest) {

                //
                // The transfer was directly into the client buffer,
                // so simply complete the request.
                //

                Request = Reserved->SingleRequest;

                if (NdisStatus == NDIS_STATUS_SUCCESS) {

                    IPX_DEBUG (RECEIVE, ("Transferred %d bytes\n", BytesTransferred));
                    REQUEST_INFORMATION(Request) = BytesTransferred;
                    REQUEST_STATUS(Request) = STATUS_SUCCESS;

                } else {

                    IPX_DEBUG (RECEIVE, ("Transfer failed\n"));
                    REQUEST_INFORMATION(Request) = 0;
                    REQUEST_STATUS(Request) = STATUS_ADAPTER_HARDWARE_ERROR;

                }

                LastRequest = Request;
                Reserved->SingleRequest = NULL;

            } else {

                //
                // Multiple clients requested this datagram. Save
                // the last one to delay queueing it for completion.
                //

                LastRequest = LIST_ENTRY_TO_REQUEST (Reserved->Requests.Blink);

                while (TRUE) {

                    p = RemoveHeadList (&Reserved->Requests);
                    if (p == &Reserved->Requests) {
                        break;
                    }

                    Request = LIST_ENTRY_TO_REQUEST(p);
                    AddressFile = REQUEST_OPEN_CONTEXT(Request);

                    if (AddressFile->ReceiveIpxHeader) {
                        ByteOffset = 0;
                    } else {
                        ByteOffset = sizeof(IPX_HEADER);
                    }

                    if (NdisStatus == NDIS_STATUS_SUCCESS) {
                       UINT BytesToTransfer = ((PTDI_REQUEST_KERNEL_RECEIVEDG)(REQUEST_PARAMETERS(Request)))->ReceiveLength; 

		       if (BytesToTransfer == 0) {
			  BytesToTransfer= IpxGetChainedMDLLength(REQUEST_NDIS_BUFFER(Request)); 
		       }
#ifdef SUNDOWN
		       // assume offset will not exceed 2^32. 
		       // REQUEST_INFORMATION(Request) is a ULONG_PTR
		       // we are save to cast its address to PULONG.
		       
		       REQUEST_STATUS(Request) =
			  TdiCopyBufferToMdl(
					     Reserved->ReceiveBuffer->Data,
					     (ULONG) (ByteOffset + REQUEST_INFORMATION(Request)),
					     BytesToTransfer,
					     REQUEST_NDIS_BUFFER(Request),
					     0,
					     (PULONG) &REQUEST_INFORMATION(Request));

#else

		       REQUEST_STATUS(Request) =
			   TdiCopyBufferToMdl(
					   Reserved->ReceiveBuffer->Data,
					   ByteOffset + REQUEST_INFORMATION(Request),
					   BytesToTransfer,
					   REQUEST_NDIS_BUFFER(Request),
					   0,
					   &REQUEST_INFORMATION(Request));

#endif

                    } else {

                        REQUEST_INFORMATION(Request) = 0;
                        REQUEST_STATUS(Request) = STATUS_ADAPTER_HARDWARE_ERROR;

                    }

                    if (Request != LastRequest) {

                        IPX_INSERT_TAIL_LIST(
                            &Adapter->RequestCompletionQueue,
                            REQUEST_LINKAGE(Request),
                            Adapter->DeviceLock);

                    }

                }

                //
                // Now free the receive buffer back.
                //

                IPX_PUSH_ENTRY_LIST(
                    &Adapter->ReceiveBufferList,
                    &Reserved->ReceiveBuffer->PoolLinkage,
                    &Adapter->Device->SListsLock);

                Reserved->ReceiveBuffer = NULL;

            }

        } else {
           //IpxPrint0("IpxTransferDataComplete: Calling PassDgToRt\n");
           //ByteOffset = sizeof(IPX_HEADER);
           ByteOffset = 0;
           PassDgToRt(IpxDevice, Reserved->pContext, Reserved->Index,
                   &Reserved->ReceiveBuffer->Data[ByteOffset],
                                 BytesTransferred);

           //
           // Free the memory allocated for options.
           //
           IpxFreeMemory(Reserved->pContext, sizeof(IPX_DATAGRAM_OPTIONS2),
                   MEMORY_PACKET, "RT OPTIONS");
           //
           // Now free the receive buffer back.
           //

           IPX_PUSH_ENTRY_LIST(
            &Adapter->ReceiveBufferList,
            &Reserved->ReceiveBuffer->PoolLinkage,
            Adapter->DeviceLock);

           Reserved->ReceiveBuffer = NULL;
        }

        //
        // Now free the packet.
        //

        NdisReinitializePacket (NdisPacket);

        if (Reserved->OwnedByAddress) {

            // Reserved->Address->ReceivePacketInUse = FALSE;
            InterlockedDecrement(&Reserved->Address->ReceivePacketInUse);

        } else {

            Device = Adapter->Device;

            IPX_PUSH_ENTRY_LIST(
                &Device->ReceivePacketList,
                &Reserved->PoolLinkage,
                &Device->SListsLock);

        }

        if (!Reserved->pContext) {
            //
            // We Delay inserting the last request (or the only one)
            // until after we have put the packet back, to keep the
            // address around if needed (the address won't go away
            // until the last address file does, and the address file
            // won't go away until the datagram is completed).
            //

            IPX_INSERT_TAIL_LIST(
                &Adapter->RequestCompletionQueue,
                REQUEST_LINKAGE(LastRequest),
                Adapter->DeviceLock);
        }

        IpxReceiveComplete ((NDIS_HANDLE)Adapter);

        break;

    default:

        Device = Adapter->Device;

        (*Device->UpperDrivers[Reserved->Identifier].TransferDataCompleteHandler)(
            NdisPacket,
            NdisStatus,
            BytesTransferred);

        break;

    }

}   /* IpxTransferDataComplete */


VOID
IpxTransferData(
	OUT PNDIS_STATUS Status,
	IN NDIS_HANDLE NdisBindingHandle,
	IN NDIS_HANDLE MacReceiveContext,
	IN UINT ByteOffset,
	IN UINT BytesToTransfer,
	IN OUT PNDIS_PACKET Packet,
	OUT PUINT BytesTransferred
    )

/*++

Routine Description:

    This routine is called by all tightly bound clients instead of NdisTransferData.
    If this is a loopback packet, the transfer is done directly here, else NdisTransferData
    is called.

Arguments:

    Status - status of operation
	NdisBindingHandle - Loopback cookie or Ndis context
	MacReceiveContext - Loopback packet or Mac context
	ByteOffset - Source offset
	BytesToTransfer - length of the transfer desired
	Packet - dest packet
	BytesTransferred - length of successful transfer

Return Value:

    NTSTATUS - status of operation.

--*/

{
    //
    // If this is a loopback packet, copy the data directly
    //
    if (NdisBindingHandle == (PVOID)IPX_LOOPBACK_COOKIE) {

        IPX_DEBUG (LOOPB, ("LoopbXfer: src: %lx, dest: %lx, bytestoxfer: %lx\n",
                        MacReceiveContext, Packet, BytesToTransfer));

        NdisCopyFromPacketToPacketSafe(
            Packet,             // Destination
            0,                  // DestinationOffset
            BytesToTransfer,    // BytesToCopy
            (PNDIS_PACKET)MacReceiveContext,        // Source
            ByteOffset,  // SourceOffset
            BytesTransferred,   // BytesCopied
            NormalPagePriority);

        *Status = ((*BytesTransferred == BytesToTransfer)? NDIS_STATUS_SUCCESS : NDIS_STATUS_RESOURCES);
    } else {
        NdisTransferData(
            Status,
            NdisBindingHandle,
            MacReceiveContext,
            ByteOffset,
            BytesToTransfer,
            Packet,
            BytesTransferred);
    }
}



NTSTATUS
IpxTdiReceiveDatagram(
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine performs the TdiReceiveDatagram request for the transport
    provider. Receive datagrams just get queued up to an address, and are
    completed when a DATAGRAM or DATAGRAM_BROADCAST frame is received at
    the address.

Arguments:

    Irp - I/O Request Packet for this request.

Return Value:

    NTSTATUS - status of operation.

--*/

{

    PADDRESS Address;
    PADDRESS_FILE AddressFile;
    IPX_DEFINE_SYNC_CONTEXT (SyncContext)
    IPX_DEFINE_LOCK_HANDLE (LockHandle)


    //
    // Do a quick check of the validity of the address.
    //

    AddressFile = (PADDRESS_FILE)REQUEST_OPEN_CONTEXT(Request);

    if ((AddressFile->Size != sizeof (ADDRESS_FILE)) ||
        (AddressFile->Type != IPX_ADDRESSFILE_SIGNATURE)) {

        return STATUS_INVALID_HANDLE;
    }

    Address = AddressFile->Address;

    if ((Address == NULL) ||
        (Address->Size != sizeof (ADDRESS)) ||
        (Address->Type != IPX_ADDRESS_SIGNATURE)) {

        return STATUS_INVALID_HANDLE;
    }

    IPX_BEGIN_SYNC (&SyncContext);

    IPX_GET_LOCK (&Address->Lock, &LockHandle);

    if (AddressFile->State != ADDRESSFILE_STATE_OPEN) {

        IPX_FREE_LOCK (&Address->Lock, LockHandle);
        IPX_END_SYNC (&SyncContext);
        return STATUS_INVALID_HANDLE;
    }


    InsertTailList (&AddressFile->ReceiveDatagramQueue, REQUEST_LINKAGE(Request));

    IoSetCancelRoutine (Request, IpxCancelReceiveDatagram);

    if (Request->Cancel) {

        (VOID)RemoveTailList (&AddressFile->ReceiveDatagramQueue);
        IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);
        IPX_FREE_LOCK (&Address->Lock, LockHandle);
        IPX_END_SYNC (&SyncContext);
        return STATUS_CANCELLED;
    }

    IPX_DEBUG (RECEIVE, ("RDG posted on %lx\n", AddressFile));

    IpxReferenceAddressFileLock (AddressFile, AFREF_RCV_DGRAM);

    IPX_FREE_LOCK (&Address->Lock, LockHandle);

    IPX_END_SYNC (&SyncContext);

    return STATUS_PENDING;

}   /* IpxTdiReceiveDatagram */


VOID
IpxCancelReceiveDatagram(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to cancel a receive
    datagram. The datagram is found on the address file's receive
    datagram queue.

    NOTE: This routine is called with the CancelSpinLock held and
    is responsible for releasing it.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    none.

--*/

{

    PLIST_ENTRY p;
    PADDRESS_FILE AddressFile;
    PADDRESS Address;
    PREQUEST Request = (PREQUEST)Irp;
    BOOLEAN Found;
    IPX_DEFINE_LOCK_HANDLE (LockHandle)


    CTEAssert ((REQUEST_MAJOR_FUNCTION(Request) == IRP_MJ_INTERNAL_DEVICE_CONTROL) &&
               (REQUEST_MINOR_FUNCTION(Request) == TDI_RECEIVE_DATAGRAM));

    CTEAssert (REQUEST_OPEN_TYPE(Request) == (PVOID)TDI_TRANSPORT_ADDRESS_FILE);

    AddressFile = (PADDRESS_FILE)REQUEST_OPEN_CONTEXT(Request);
    Address = AddressFile->Address;

    Found = FALSE;

    IPX_GET_LOCK (&Address->Lock, &LockHandle);

    for (p = AddressFile->ReceiveDatagramQueue.Flink;
         p != &AddressFile->ReceiveDatagramQueue;
         p = p->Flink) {

        if (LIST_ENTRY_TO_REQUEST(p) == Request) {

            RemoveEntryList (p);
            Found = TRUE;
            break;
        }
    }

    IPX_FREE_LOCK (&Address->Lock, LockHandle);
    IoReleaseCancelSpinLock (Irp->CancelIrql);

    if (Found) {

        IPX_DEBUG(RECEIVE, ("Cancelled datagram on %lx\n", AddressFile));

        REQUEST_INFORMATION(Request) = 0;
        REQUEST_STATUS(Request) = STATUS_CANCELLED;

        IpxCompleteRequest (Request);
        ASSERT( DeviceObject->DeviceExtension == IpxDevice );
        IpxFreeRequest(IpxDevice, Request);

        IpxDereferenceAddressFile (AddressFile, AFREF_RCV_DGRAM);

    }

}   /* IpxCancelReceiveDatagram */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\rip.c ===
/*++


Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    rip.c

Abstract:

    This module contains code that implements the client-side
    RIP support and simple router table support.

Environment:

    Kernel mode

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

UCHAR BroadcastAddress[6] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };


NTSTATUS
RipGetLocalTarget(
    IN ULONG Segment,
    IN TDI_ADDRESS_IPX UNALIGNED * RemoteAddress,
    IN UCHAR Type,
    OUT PIPX_LOCAL_TARGET LocalTarget,
    OUT USHORT Counts[2] OPTIONAL
    )

/*++

Routine Description:

    This routine looks up the proper route for the specified remote
    address. If a RIP request needs to be generated it does so.

    NOTE: THIS REQUEST IS CALLED WITH THE SEGMENT LOCK HELD.
	NOTE: IN THE CASE OF PnP, THIS COMES WITH THE BIND LOCK SHARED.

Arguments:

    Segment - The segment associate with the remote address.

    RemoteAddress - The IPX address of the remote.

    Type - One of IPX_FIND_ROUTE_NO_RIP, IPX_FIND_ROUTE_RIP_IF_NEEDED,
        or IPX_FIND_ROUTE_FORCE_RIP.

    LocalTarget - Returns the next router information.

    Counts - If specified, used to return the tick and hop count.

Return Value:

    STATUS_SUCCESS if a route is found, STATUS_PENDING if a
    RIP request needs to be generated, failure status if a
    RIP request packet cannot be allocated.

--*/

{
    PDEVICE Device = IpxDevice;
    PIPX_ROUTE_ENTRY RouteEntry;
    PBINDING Binding;
    UINT i;


    //
    // Packets sent to network 0 go on the first adapter also.
    //

    if (Device->RealAdapters && (RemoteAddress->NetworkAddress == 0)) {
		FILL_LOCAL_TARGET(LocalTarget, FIRST_REAL_BINDING);

        RtlCopyMemory (LocalTarget->MacAddress, RemoteAddress->NodeAddress, 6);
        if (ARGUMENT_PRESENT(Counts)) {
            Counts[0] = (USHORT)((839 + NIC_ID_TO_BINDING(Device, FIRST_REAL_BINDING)->MediumSpeed) /
                                     NIC_ID_TO_BINDING(Device, FIRST_REAL_BINDING)->MediumSpeed);  // tick count
            Counts[1] = 1;  // hop count
        }
        return STATUS_SUCCESS;
    }

    //
    // See if this is a packet sent to our virtual network.
    //

    if (Device->VirtualNetwork &&
        (RemoteAddress->NetworkAddress == Device->SourceAddress.NetworkAddress)) {

        //
        // Send it through adapter 1.
        // Do real loopback.
        //
		FILL_LOCAL_TARGET(LocalTarget, LOOPBACK_NIC_ID);
        RtlCopyMemory (LocalTarget->MacAddress, NIC_ID_TO_BINDING(Device, LOOPBACK_NIC_ID)->LocalMacAddress.Address, 6);

        IPX_DEBUG (LOOPB, ("Loopback Nic returned for net: %lx\n", RemoteAddress->NetworkAddress));
        if (ARGUMENT_PRESENT(Counts)) {
            Counts[0] = 1;  // tick count
            Counts[1] = 1;  // hop count
        }
        return STATUS_SUCCESS;

    }

    //
    // Look up the route in the table. If the net is one
    // of the ones we are directly attached to, this will
    // return an entry with the correct flag set.
    //

    RouteEntry = RipGetRoute(Segment, (PUCHAR)&(RemoteAddress->NetworkAddress));

    if (RouteEntry != NULL) {

        RouteEntry->Timer = 0;
		FILL_LOCAL_TARGET(LocalTarget, RouteEntry->NicId);
        if (RouteEntry->Flags & IPX_ROUTER_LOCAL_NET) {

            //
            // The machine is on the same net, so send it directly.
            //

            RtlCopyMemory (LocalTarget->MacAddress, RemoteAddress->NodeAddress, 6);

            if (RouteEntry->Flags & IPX_ROUTER_GLOBAL_WAN_NET) {

                //
                // The NicId here is bogus, we have to scan through
                // our bindings until we find one whose indicated
                // IPX remote node matches the destination node of
                // this frame. We don't scan into the duplicate
                // binding set members since they won't be WANs.
                //
                {
                ULONG   Index = MIN (Device->MaxBindings, Device->HighestExternalNicId);

                for (i = FIRST_REAL_BINDING; i <= Index; i++) {
                    Binding = NIC_ID_TO_BINDING(Device, i);
                    if ((Binding != (PBINDING)NULL) &&
                        (Binding->Adapter->MacInfo.MediumAsync) &&
                        (RtlEqualMemory(
                             Binding->WanRemoteNode,
                             RemoteAddress->NodeAddress,
                             6))) {
                         FILL_LOCAL_TARGET(LocalTarget, MIN( Device->MaxBindings, Binding->NicId));
                         break;

                    }
                }
                }

                if (i > (UINT)MIN (Device->MaxBindings, Device->HighestExternalNicId)) {
                    //
                    // Bug #17273 return proper error message
                    //

                    // return STATUS_DEVICE_DOES_NOT_EXIST;
                    return STATUS_NETWORK_UNREACHABLE;
                }

            } else {
                //
                // Find out if this is a loopback packet. If so, return NicId 0
                //
                {
                ULONG   Index = MIN (Device->MaxBindings, Device->HighestExternalNicId);

                for (i = FIRST_REAL_BINDING; i <= Index; i++) {
                    Binding = NIC_ID_TO_BINDING(Device, i);
                    //
                    // Self-directed - loopback
                    //
                    if ((Binding != (PBINDING)NULL) &&
                        (RtlEqualMemory(
                            Binding->LocalAddress.NodeAddress,
                            RemoteAddress->NodeAddress,
                            6))) {
                        FILL_LOCAL_TARGET(LocalTarget, LOOPBACK_NIC_ID);

                        IPX_DEBUG (LOOPB, ("2.Loopback Nic returned for net: %lx\n", RemoteAddress->NetworkAddress));
                        break;

                    }
                }
                }
            }

        } else {

            CTEAssert ((RouteEntry->Flags & IPX_ROUTER_PERMANENT_ENTRY) == 0);

            //
            // This is not a locally attached net, so if the caller
            // is forcing a re-RIP then do that.
            //

            if (Type == IPX_FIND_ROUTE_FORCE_RIP) {
                goto QueueUpRequest;
            }

            //
            // Fill in the address of the next router in the route.
            //

            RtlCopyMemory (LocalTarget->MacAddress, RouteEntry->NextRouter, 6);

        }

        if (ARGUMENT_PRESENT(Counts)) {
            Counts[0] = RouteEntry->TickCount;
            Counts[1] = RouteEntry->HopCount;
        }

        return STATUS_SUCCESS;

    }

QueueUpRequest:

    if (Type == IPX_FIND_ROUTE_NO_RIP) {

        //
        // Bug #17273 return proper error message
        //

        // return STATUS_DEVICE_DOES_NOT_EXIST;
        return STATUS_NETWORK_UNREACHABLE;

    } else {

        return RipQueueRequest (RemoteAddress->NetworkAddress, RIP_REQUEST);

    }

}   /* RipGetLocalTarget */


NTSTATUS
RipQueueRequest(
    IN ULONG Network,
    IN USHORT Operation
    )

/*++

Routine Description:

    This routine queues up a request for a RIP route. It can be
    used to find a specific route or to discover the locally
    attached network (if Network is 0). It can also be used
    to do a periodic announcement of the virtual net, which
    we do once a minute if the router is not bound.

    NOTE: THIS REQUEST IS CALLED WITH THE SEGMENT LOCK HELD
    IF IT IS A REQUEST AND THE NETWORK IS NOT 0xffffffff.

Arguments:

    Network - The network to discover.

    Operation - One of RIP_REQUEST, RIP_RESPONSE, or RIP_DOWN.

Return Value:

    STATUS_PENDING if the request is queued, failure status
    if it could not be.

--*/

{
    PDEVICE Device = IpxDevice;
    PIPX_SEND_RESERVED Reserved;
    PSLIST_ENTRY s;
    PLIST_ENTRY p;
    PRIP_PACKET RipPacket;
    TDI_ADDRESS_IPX RemoteAddress;
    TDI_ADDRESS_IPX LocalAddress;
    IPX_DEFINE_LOCK_HANDLE (LockHandle)
    PNDIS_BUFFER pNdisIpxBuff;


    //
    // Make sure we only queue a request for net 0xffffffff if we
    // are auto-detecting, because we assume that in other places.
    //

    if ((Network == 0xffffffff) &&
        (Device->AutoDetectState != AUTO_DETECT_STATE_RUNNING)) {

        return STATUS_BAD_NETWORK_PATH;

    }

    //
    // Try to get a packet to use for the RIP request. We
    // allocate this now, but check if it succeeded later,
    // to make the locking work better (we need to keep
    // the lock between when we check for an existing
    // request on this network and when we queue this
    // request).
    //

    s = IpxPopSendPacket (Device);

    //
    // There was no router table entry for this network, first see
    // if there is already a pending request for this route.
    //

    IPX_GET_LOCK (&Device->Lock, &LockHandle);

    if (Operation == RIP_REQUEST) {

        for (p = Device->WaitingRipPackets.Flink;
             p != &Device->WaitingRipPackets;
             p = p->Flink) {

             Reserved = CONTAINING_RECORD (p, IPX_SEND_RESERVED, WaitLinkage);

             //
             // Skip responses.
             //

             if (Reserved->u.SR_RIP.RetryCount >= 0xfe) {
                 continue;
             }

             if (Reserved->u.SR_RIP.Network == Network &&
                 !Reserved->u.SR_RIP.RouteFound) {

                 //
                 // There is already one pending, put back the packet if
                 // we got one (we hold the lock already).
                 //

                 if (s != NULL) {
                     IPX_PUSH_ENTRY_LIST (&Device->SendPacketList, s, &Device->SListsLock);
                 }
                 IPX_FREE_LOCK (&Device->Lock, LockHandle);
                 return STATUS_PENDING;
             }
        }

    }


    if (s == NULL) {
        IPX_FREE_LOCK (&Device->Lock, LockHandle);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Reserved = CONTAINING_RECORD (s, IPX_SEND_RESERVED, PoolLinkage);

    //
    // We have the packet, fill it in for this request.
    //

    Reserved->Identifier = IDENTIFIER_RIP_INTERNAL;
    Reserved->SendInProgress = FALSE;
    Reserved->DestinationType = DESTINATION_BCAST;
    Reserved->u.SR_RIP.CurrentNicId = 0;
    Reserved->u.SR_RIP.NoIdAdvance = FALSE;
    switch (Operation) {
    case RIP_REQUEST: Reserved->u.SR_RIP.RetryCount = 0; break;
    case RIP_RESPONSE: Reserved->u.SR_RIP.RetryCount = 0xfe; break;
    case RIP_DOWN: Reserved->u.SR_RIP.RetryCount = 0xff; break;
    }
    Reserved->u.SR_RIP.RouteFound = FALSE;
    Reserved->u.SR_RIP.Network = Network;
    Reserved->u.SR_RIP.SendTime = Device->RipSendTime;

    //
    // We aren't guaranteed that this is the case for packets
    // on the free list.
    //

    pNdisIpxBuff = NDIS_BUFFER_LINKAGE (Reserved->HeaderBuffer);
    NDIS_BUFFER_LINKAGE (pNdisIpxBuff) = NULL;

    //
    // Fill in the IPX header at the standard offset (for sending
    // to actual bindings it will be moved around if needed). We
    // have to construct the local and remote addresses so they
    // are in the format that IpxConstructHeader expects.
    //

    RemoteAddress.NetworkAddress = Network;
    RtlCopyMemory (RemoteAddress.NodeAddress, BroadcastAddress, 6);
    RemoteAddress.Socket = RIP_SOCKET;

    RtlCopyMemory (&LocalAddress, &Device->SourceAddress, FIELD_OFFSET(TDI_ADDRESS_IPX,Socket));
    LocalAddress.Socket = RIP_SOCKET;

    IpxConstructHeader(
//        &Reserved->Header[Device->IncludedHeaderOffset],
        &Reserved->Header[MAC_HEADER_SIZE],
        sizeof(IPX_HEADER) + sizeof (RIP_PACKET),
        RIP_PACKET_TYPE,
        &RemoteAddress,
        &LocalAddress);

    //
    // Fill in the RIP request also.
    //

#if 0
    RipPacket = (PRIP_PACKET)(&Reserved->Header[Device->IncludedHeaderOffset + sizeof(IPX_HEADER)]);
#endif
    RipPacket = (PRIP_PACKET)(&Reserved->Header[MAC_HEADER_SIZE + sizeof(IPX_HEADER)]);
    RipPacket->Operation = Operation & 0x7fff;
    RipPacket->NetworkEntry.NetworkNumber = Network;

    if (Operation == RIP_REQUEST) {
        RipPacket->NetworkEntry.HopCount = REORDER_USHORT(0xffff);
        RipPacket->NetworkEntry.TickCount = REORDER_USHORT(0xffff);
    } else if (Operation == RIP_RESPONSE) {
        RipPacket->NetworkEntry.HopCount = REORDER_USHORT(1);
        RipPacket->NetworkEntry.TickCount = REORDER_USHORT(2); // will be modified when sent
    } else {
        RipPacket->NetworkEntry.HopCount = REORDER_USHORT(16);
        RipPacket->NetworkEntry.TickCount = REORDER_USHORT(16);
    }

    NdisAdjustBufferLength(pNdisIpxBuff, sizeof(IPX_HEADER) + sizeof(RIP_PACKET));
    //
    // Now insert this packet in the queue of pending RIP
    // requests and start the timer if needed (this is done
    // to ensure the RIP_GRANULARITY milliseconds inter-RIP-packet
    // delay).
    //

    IPX_DEBUG (RIP, ("RIP %s for network %lx\n",
        (Operation == RIP_REQUEST) ? "request" : ((Operation == RIP_RESPONSE) ? "announce" : "down"),
        REORDER_ULONG(Network)));

    InsertHeadList(
        &Device->WaitingRipPackets,
        &Reserved->WaitLinkage);

    ++Device->RipPacketCount;

    if (!Device->RipShortTimerActive) {

        Device->RipShortTimerActive = TRUE;
        IpxReferenceDevice (Device, DREF_RIP_TIMER);

        CTEStartTimer(
            &Device->RipShortTimer,
            1,          // 1 ms, i.e. expire immediately
            RipShortTimeout,
            (PVOID)Device);
    }

    IpxReferenceDevice (Device, DREF_RIP_PACKET);

    IPX_FREE_LOCK (&Device->Lock, LockHandle);
    return STATUS_PENDING;

}   /* RipQueueRequest */


VOID
RipSendResponse(
    IN PBINDING Binding,
    IN TDI_ADDRESS_IPX UNALIGNED * RemoteAddress,
    IN PIPX_LOCAL_TARGET LocalTarget
    )

/*++

Routine Description:

    This routine sends a respond to a RIP request from a client --
    this is only used if we have a virtual network and the router
    is not bound, and somebody queries on the virtual network.

Arguments:

    Binding - The binding on which the request was received.

    RemoteAddress - The IPX source address of the request.

    LocalTarget - The local target of the received packet.

Return Value:

    STATUS_PENDING if the request is queued, failure status
    if it could not be.

--*/

{
    PSLIST_ENTRY s;
    PIPX_SEND_RESERVED Reserved;
    TDI_ADDRESS_IPX LocalAddress;
    PNDIS_PACKET Packet;
    PIPX_HEADER IpxHeader;
    PRIP_PACKET RipPacket;
    PDEVICE Device = IpxDevice;
    PBINDING MasterBinding;
    NDIS_STATUS NdisStatus;
    USHORT TickCount;
    PNDIS_BUFFER pNdisIpxBuff;

    //
    // Get a packet to use for the RIP response.
    //

    s = IpxPopSendPacket (Device);

    if (s == NULL) {
        return;
    }

    IpxReferenceDevice (Device, DREF_RIP_PACKET);

    Reserved = CONTAINING_RECORD (s, IPX_SEND_RESERVED, PoolLinkage);

    //
    // We have the packet, fill it in for this request.
    //

    Reserved->Identifier = IDENTIFIER_RIP_RESPONSE;
    Reserved->DestinationType = DESTINATION_DEF;
    CTEAssert (!Reserved->SendInProgress);
    Reserved->SendInProgress = TRUE;

    //
    // We aren't guaranteed that this is the case for packets
    // on the free list.
    //

    pNdisIpxBuff = NDIS_BUFFER_LINKAGE (Reserved->HeaderBuffer);
    NDIS_BUFFER_LINKAGE (pNdisIpxBuff) = NULL;

    //
    // If this binding is a binding set member, round-robin through
    // the various bindings when responding. We will get some natural
    // round-robinning because broadcast requests are received on
    // binding set members in turn, but they are only rotated once
    // a second.
    //

    if (Binding->BindingSetMember) {

        //
        // It's a binding set member, we round-robin the
        // responses across all the cards to distribute
        // the traffic.
        //

        MasterBinding = Binding->MasterBinding;
        Binding = MasterBinding->CurrentSendBinding;
        MasterBinding->CurrentSendBinding = Binding->NextBinding;

        IpxReferenceBinding1(Binding, BREF_DEVICE_ACCESS);
    }

    //
    // Fill in the IPX header at the correct offset.
    //

    LocalAddress.NetworkAddress = Binding->LocalAddress.NetworkAddress;
    RtlCopyMemory (LocalAddress.NodeAddress, Binding->LocalAddress.NodeAddress, 6);
    LocalAddress.Socket = RIP_SOCKET;
#if 0
    IpxHeader = (PIPX_HEADER)(&Reserved->Header[Binding->DefHeaderSize]);
#endif
    IpxHeader = (PIPX_HEADER)(&Reserved->Header[MAC_HEADER_SIZE]);

    IpxConstructHeader(
        (PUCHAR)IpxHeader,
        sizeof(IPX_HEADER) + sizeof (RIP_PACKET),
        RIP_PACKET_TYPE,
        RemoteAddress,
        &LocalAddress);

    //
    // In case the request comes from net 0, fill that in too.
    //

    *(UNALIGNED ULONG *)IpxHeader->DestinationNetwork = Binding->LocalAddress.NetworkAddress;


    //
    // Fill in the RIP request.
    //

    RipPacket = (PRIP_PACKET)(IpxHeader+1);

    RipPacket->Operation = RIP_RESPONSE;
    RipPacket->NetworkEntry.NetworkNumber = Device->VirtualNetworkNumber;

    RipPacket->NetworkEntry.HopCount = REORDER_USHORT(1);
    TickCount = (USHORT)(((839 + Binding->MediumSpeed) / Binding->MediumSpeed) + 1);
    RipPacket->NetworkEntry.TickCount = REORDER_USHORT(TickCount);

    IPX_DEBUG (RIP, ("RIP response for virtual network %lx\n",
                            REORDER_ULONG(Device->VirtualNetworkNumber)));

    NdisAdjustBufferLength(pNdisIpxBuff, sizeof(IPX_HEADER) + sizeof(RIP_PACKET));
    //
    // Now submit the packet to NDIS.
    //

    Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);

    if ((NdisStatus = IpxSendFrame(
            LocalTarget,
            Packet,
            sizeof(RIP_PACKET) + sizeof(IPX_HEADER),
            sizeof(RIP_PACKET) + sizeof(IPX_HEADER))) != NDIS_STATUS_PENDING) {

        IpxSendComplete(
            (NDIS_HANDLE)Binding->Adapter,
            Packet,
            NdisStatus);
    }

    if (Binding->BindingSetMember) {
        IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
    }
    return;

}   /* RipSendResponse */


VOID
RipShortTimeout(
    CTEEvent * Event,
    PVOID Context
    )

/*++

Routine Description:

    This routine is called when the RIP short timer expires.
    It is called every RIP_GRANULARITY milliseconds unless there
    is nothing to do.

Arguments:

    Event - The event used to queue the timer.

    Context - The context, which is the device pointer.

Return Value:

    None.

--*/

{
    PDEVICE Device = (PDEVICE)Context;
    PLIST_ENTRY p;
    PIPX_SEND_RESERVED Reserved;
    PNDIS_PACKET Packet;
    USHORT OldNicId, NewNicId;
    ULONG OldOffset, NewOffset;
    PIPX_HEADER IpxHeader;
    PBINDING Binding, MasterBinding;
    NDIS_STATUS NdisStatus;
    IPX_DEFINE_LOCK_HANDLE (LockHandle)

#ifdef  _PNP_LATER
    static IPX_LOCAL_TARGET BroadcastTarget = { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }, {0, 0, 0} };
#else
    static IPX_LOCAL_TARGET BroadcastTarget = { 0, { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } };
#endif

    static ULONG ZeroNetwork = 0;
	IPX_DEFINE_LOCK_HANDLE(LockHandle1)
    IPX_GET_LOCK (&Device->Lock, &LockHandle);

    ++Device->RipSendTime;

    if (Device->RipPacketCount == 0) {

        Device->RipShortTimerActive = FALSE;
        IPX_FREE_LOCK (&Device->Lock, LockHandle);
        IpxDereferenceDevice (Device, DREF_RIP_TIMER);

        return;
    }

    //
    // Check what is on the queue; this is set up as a
    // loop but in fact it rarely does (under no
    // circumstances can we send more than one packet
    // each time this function executes).
    //

    while (TRUE) {

        p = Device->WaitingRipPackets.Flink;
        if (p == &Device->WaitingRipPackets) {
            IPX_FREE_LOCK (&Device->Lock, LockHandle);
            break;
        }

        Reserved = CONTAINING_RECORD (p, IPX_SEND_RESERVED, WaitLinkage);

        if ((Reserved->u.SR_RIP.RouteFound) && (!Reserved->SendInProgress)) {

            (VOID)RemoveHeadList (&Device->WaitingRipPackets);
            Reserved->Identifier = IDENTIFIER_IPX;
            IPX_PUSH_ENTRY_LIST (&Device->SendPacketList, &Reserved->PoolLinkage, &Device->SListsLock);
            --Device->RipPacketCount;

            //
            // It is OK to do this with the lock held because
            // it won't be the last one (we have the RIP_TIMER ref).
            //

            IpxDereferenceDevice (Device, DREF_RIP_PACKET);
            continue;
        }

        if ((((SHORT)(Device->RipSendTime - Reserved->u.SR_RIP.SendTime)) < 0) ||
            Reserved->SendInProgress) {
            IPX_FREE_LOCK (&Device->Lock, LockHandle);
            break;
        }

        (VOID)RemoveHeadList (&Device->WaitingRipPackets);

        //
        // Find the right binding to send to. If NoIdAdvance
        // is set, then the binding doesn't need to be changed
        // this time (this means we wrapped last time).
        //

        OldNicId = Reserved->u.SR_RIP.CurrentNicId;

        if (!Reserved->u.SR_RIP.NoIdAdvance) {

            BOOLEAN FoundNext = FALSE;

//
// To maintain the lock order, release Device lock here and re-acquire later
//
            USHORT StartId;

            if (Device->ValidBindings == 0) {
                IPX_DEBUG(PNP, ("ValidBindings 0 in RipShortTimeOut\n"));

                Device->RipShortTimerActive = FALSE;
                IPX_FREE_LOCK (&Device->Lock, LockHandle);
                IpxDereferenceDevice (Device, DREF_RIP_TIMER);
                return;
            }

            StartId = (USHORT)((OldNicId % MIN (Device->MaxBindings, Device->ValidBindings)) + 1);

            NewNicId = StartId;
			IPX_FREE_LOCK (&Device->Lock, LockHandle);
			IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
            do {

                Binding = NIC_ID_TO_BINDING(Device, NewNicId);
                if (Reserved->u.SR_RIP.Network != 0xffffffff) {

                    //
                    // We are looking for a real net; check that
                    // the next binding is valid. If it is a WAN
                    // binding, we don't send queries if the router
                    // is bound. If it is a LAN binding, we don't
                    // send queries if we are configured for
                    // SingleNetworkActive and the WAN is up.
                    // We also don't send queries on binding set
                    // members which aren't masters.
                    //

                    if ((Binding != NULL)
                                &&
                        ((!Binding->Adapter->MacInfo.MediumAsync) ||
                         (!Device->UpperDriverBound[IDENTIFIER_RIP]))
                                &&
                        ((Binding->Adapter->MacInfo.MediumAsync) ||
                         (!Device->SingleNetworkActive) ||
                         (!Device->ActiveNetworkWan))
                                &&
                        ((!Binding->BindingSetMember) ||
                         (Binding->CurrentSendBinding))) {

                        FoundNext = TRUE;
                        break;
                    }

                } else {

                    //
                    // We are sending out the initial request to net
                    // 0xffffffff, to generate traffic so we can figure
                    // out our real network number. We don't do this
                    // to nets that already have a number and we don't
                    // do it on WAN links. We also don't do it on
                    // auto-detect nets if we have found the default.
                    //


                    if ((Binding != NULL) &&
                        (Binding->TentativeNetworkAddress == 0) &&
                        (!Binding->Adapter->MacInfo.MediumAsync) &&
                        (!Binding->AutoDetect || !Binding->Adapter->DefaultAutoDetected)) {
                        FoundNext = TRUE;
                        break;
                    }
                }
				//
				// Why cycle thru the entire list?
				//
                NewNicId = (USHORT)((NewNicId % MIN (Device->MaxBindings, Device->ValidBindings)) + 1);
			} while (NewNicId != StartId);

            if (!FoundNext) {

                //
                // Nothing more needs to be done with this packet,
                // leave it off the queue and since we didn't send
                // a packet we can check for more.
                //
                RipCleanupPacket(Device, Reserved);
    			IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
                IPX_GET_LOCK (&Device->Lock, &LockHandle);

                IPX_PUSH_ENTRY_LIST (&Device->SendPacketList, &Reserved->PoolLinkage, &Device->SListsLock);
                --Device->RipPacketCount;
                IpxDereferenceDevice (Device, DREF_RIP_PACKET);
                continue;

            }


			IPX_DEBUG(RIP, ("RIP: FoundNext: %lx, StartId: %lx, OldNicId: %lx, NewNicId: %lx\n", FoundNext, StartId, OldNicId, NewNicId));
			IpxReferenceBinding1(Binding, BREF_DEVICE_ACCESS);
			IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

			//
			// Re-acquire the Device lock
			//
			IPX_GET_LOCK (&Device->Lock, &LockHandle);

            Reserved->u.SR_RIP.CurrentNicId = NewNicId;

            //
            // Move the data around if needed.
            //

#if 0
            if (OldNicId != NewNicId) {

                if (OldNicId == 0) {
                    OldOffset = Device->IncludedHeaderOffset;
                } else {
                    OldOffset = Device->Bindings[OldNicId]->BcMcHeaderSize;
                }

                NewOffset = Binding->BcMcHeaderSize;

                if (OldOffset != NewOffset) {

                    RtlMoveMemory(
                        &Reserved->Header[NewOffset],
                        &Reserved->Header[OldOffset],
                        sizeof(IPX_HEADER) + sizeof(RIP_PACKET));

                }

            }
#endif

            if (NewNicId <= OldNicId) {

                //
                // We found a new binding but we wrapped, so increment
                // the counter. If we have done all the resends, or
                // this is a response (indicated by retry count of 0xff;
                // they are only sent once) then clean up.
                //

                if ((Reserved->u.SR_RIP.RetryCount >= 0xfe) ||
                    ((++Reserved->u.SR_RIP.RetryCount) == Device->RipCount)) {
                   
                    //
                    // This packet is stale, clean it up and continue.
                    //

                    IPX_FREE_LOCK (&Device->Lock, LockHandle);
					IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
                    RipCleanupPacket(Device, Reserved);
                    IPX_GET_LOCK (&Device->Lock, &LockHandle);

                    IPX_PUSH_ENTRY_LIST (&Device->SendPacketList, &Reserved->PoolLinkage, &Device->SListsLock);
                    --Device->RipPacketCount;
                    IpxDereferenceDevice (Device, DREF_RIP_PACKET);

                } else {

                    //
                    // We wrapped, so put ourselves back in the queue
                    // at the end.
                    //
                   
                    Reserved->u.SR_RIP.SendTime = (USHORT)(Device->RipSendTime + Device->RipTimeout - 1);
                    Reserved->u.SR_RIP.NoIdAdvance = TRUE;
                    InsertTailList (&Device->WaitingRipPackets, &Reserved->WaitLinkage);

					//
					// Free the Device lock before deref'ing the Binding so we maintain
					// the lock order: BindingAccess > GlobalInterLock > Device
					//
					IPX_FREE_LOCK (&Device->Lock, LockHandle);
					IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
                    IPX_GET_LOCK (&Device->Lock, &LockHandle);
                }

                continue;

            }
//
// To prevent the re-acquire of the device lock, this is moved up...
//
			//
			// Send it again as soon as possible (it we just wrapped, then
			// we will have put ourselves at the tail and won't get here).
			//
	
			InsertHeadList (&Device->WaitingRipPackets, &Reserved->WaitLinkage);
	
			CTEAssert (Reserved->Identifier == IDENTIFIER_RIP_INTERNAL);
			CTEAssert (!Reserved->SendInProgress);
			Reserved->SendInProgress = TRUE;
	
			IPX_FREE_LOCK (&Device->Lock, LockHandle);

        } else {

            //
            // Next time we need to advance the binding.
            //

            Reserved->u.SR_RIP.NoIdAdvance = FALSE;
            NewNicId = OldNicId;
			//
			// Send it again as soon as possible (it we just wrapped, then
			// we will have put ourselves at the tail and won't get here).
			//
	
			InsertHeadList (&Device->WaitingRipPackets, &Reserved->WaitLinkage);
	
			CTEAssert (Reserved->Identifier == IDENTIFIER_RIP_INTERNAL);
			CTEAssert (!Reserved->SendInProgress);
			Reserved->SendInProgress = TRUE;
	
			IPX_FREE_LOCK (&Device->Lock, LockHandle);

			IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
            Binding = NIC_ID_TO_BINDING(Device, NewNicId);
			IpxReferenceBinding1(Binding, BREF_DEVICE_ACCESS);
			IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

        }
        //
        // This packet should be sent on binding NewNicId; first
        // move the data to the right location for the current
        // binding.
        //
        CTEAssert (Binding == NIC_ID_TO_BINDING(Device, NewNicId));  // temp, just to make sure
        // NewOffset = Binding->BcMcHeaderSize;

        //
        // Now submit the packet to NDIS.
        //

        Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);
		FILL_LOCAL_TARGET(&BroadcastTarget, NewNicId);

        //
        // Modify the header so the packet comes from this
        // specific adapter, not the virtual network.
        //

        // IpxHeader = (PIPX_HEADER)(&Reserved->Header[NewOffset]);
        IpxHeader = (PIPX_HEADER)(&Reserved->Header[MAC_HEADER_SIZE]);

        if (Reserved->u.SR_RIP.Network == 0xffffffff) {
            *(UNALIGNED ULONG *)IpxHeader->SourceNetwork = 0;
        } else {
            *(UNALIGNED ULONG *)IpxHeader->SourceNetwork = Binding->LocalAddress.NetworkAddress;
        }

        if (Reserved->u.SR_RIP.RetryCount < 0xfe) {

            //
            // This is an outgoing query. We round-robin these through
            // binding sets.
            //

            if (Binding->BindingSetMember) {

                //
                // Shouldn't have any binding sets during initial
                // discovery.
                //

	        // 303606 
	        // If we have three lan cards on the same lan with the same fram types,
	        // then the first two could be in the binding set, while auto detect rip
	        // packet is outstanding for the third card. So the assertion is not 
	        // necessarily true. 

                // CTEAssert (Reserved->u.SR_RIP.Network != 0xffffffff);

                //
                // If we are in a binding set, then use the current binding
                // in the set for this send, and advance the current binding.
                // The places we have used Binding before here will be fine
                // since the binding set members all have the same media
                // and frame type.
                //
	       
	        // 303606 not necessarily a master binding
                MasterBinding = Binding->MasterBinding;
                Binding = MasterBinding->CurrentSendBinding;
                MasterBinding->CurrentSendBinding = Binding->NextBinding;
                //
                // We dont have a lock here - the masterbinding could be bogus
                //
				IpxDereferenceBinding1(MasterBinding, BREF_DEVICE_ACCESS);
				IpxReferenceBinding1(Binding, BREF_DEVICE_ACCESS);
            }
        }


        RtlCopyMemory (IpxHeader->SourceNode, Binding->LocalAddress.NodeAddress, 6);

        //
        // Bug# 6485
        // Rip request, general or specific, is putting the network of the
        // node to which the route has to be found in the ipx header remote
        // network field.  Some novell routers don't like that.  This network
        // field should be 0.
        //
        {
            PRIP_PACKET RipPacket = (PRIP_PACKET)(&Reserved->Header[MAC_HEADER_SIZE + sizeof(IPX_HEADER)]);

            if (RipPacket->Operation != RIP_REQUEST) {
                *(UNALIGNED ULONG *)IpxHeader->DestinationNetwork = Binding->LocalAddress.NetworkAddress;
            } else {
                *(UNALIGNED ULONG *)IpxHeader->DestinationNetwork = 0;
            }
        }

        //
        // If this is a RIP_RESPONSE, set the tick count for this
        // binding.
        //

        if (Reserved->u.SR_RIP.RetryCount == 0xfe) {

            PRIP_PACKET RipPacket = (PRIP_PACKET)(IpxHeader+1);
            USHORT TickCount = (USHORT)
                (((839 + Binding->MediumSpeed) / Binding->MediumSpeed) + 1);

            RipPacket->NetworkEntry.TickCount = REORDER_USHORT(TickCount);

        }

        if ((NdisStatus = IpxSendFrame(
                &BroadcastTarget,
                Packet,
                sizeof(RIP_PACKET) + sizeof(IPX_HEADER),
                sizeof(RIP_PACKET) + sizeof(IPX_HEADER))) != NDIS_STATUS_PENDING) {

            IpxSendComplete(
                (NDIS_HANDLE)Binding->Adapter,
                Packet,
                NdisStatus);
        }
		IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);

        break;

    }

    CTEStartTimer(
        &Device->RipShortTimer,
        RIP_GRANULARITY,
        RipShortTimeout,
        (PVOID)Device);

}   /* RipShortTimeout */


VOID
RipLongTimeout(
    CTEEvent * Event,
    PVOID Context
    )

/*++

Routine Description:

    This routine is called when the RIP long timer expires.
    It is called every minute and handles periodic re-RIPping
    to ensure that entries are accurate, as well as aging out
    of entries if the rip router is not bound.

Arguments:

    Event - The event used to queue the timer.

    Context - The context, which is the device pointer.

Return Value:

    None.

--*/

{
    PDEVICE Device = (PDEVICE)Context;
    PROUTER_SEGMENT RouterSegment;
    PIPX_ROUTE_ENTRY RouteEntry;
    UINT Segment;
    UINT i;
    PBINDING Binding;
    IPX_DEFINE_LOCK_HANDLE(LockHandle)

    //
    // [FW] TRUE if there are no more entries to age out.
    //
    BOOLEAN fMoreToAge=FALSE;

    //
    // Rotate the broadcast receiver on all binding sets.
    // We can loop up to HighestExternal only since we
    // are only interested in finding binding set masters.
    //
    IPX_DEFINE_LOCK_HANDLE(LockHandle1)
	IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
    {
    ULONG   Index = MIN (Device->MaxBindings, Device->HighestExternalNicId);

    for (i = FIRST_REAL_BINDING; i <= Index; i++) {

        Binding = NIC_ID_TO_BINDING(Device, i);
        if ((Binding != NULL) &&
            (Binding->CurrentSendBinding)) {

            //
            // It is a master, so find the current broadcast
            // receiver, then advance it.
            //

            while (TRUE) {
                if (Binding->ReceiveBroadcast) {
                    Binding->ReceiveBroadcast = FALSE;
                    IPX_DEBUG(RIP, (" %x set to FALSE\n", Binding));
                    if (Binding == Binding->NextBinding) {
                       DbgBreakPoint();
                    }
                    Binding->NextBinding->ReceiveBroadcast = TRUE;
                    IPX_DEBUG(RIP, (" %x set to TRUE\n", Binding->NextBinding));
                    
                    break;
                } else {
                    Binding = Binding->NextBinding;
                }
            }
        }
    }
    }
	IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);


    //
    // If RIP is bound, we don't do any of this, and
    // we stop the timer from running.
    //

    if (Device->UpperDriverBound[IDENTIFIER_RIP]) {
        //
        // [FW] For the case when the Forwarder appears after our table has
        // been primed, we need to age out these entries....
        //
        if (Device->ForwarderBound) {
            goto ageout;
        }

        IpxDereferenceDevice (Device, DREF_LONG_TIMER);
        return;
    }


    //
    // If we have a virtual net, do our periodic broadcast.
    //

    if (Device->RipResponder) {
        (VOID)RipQueueRequest (Device->VirtualNetworkNumber, RIP_RESPONSE);
    }


    //
    // We need to scan each hash bucket to see if there
    // are any active entries which need to be re-RIPped
    // for. We also scan for entries that should be timed
    // out.
    //

ageout:
    for (Segment = 0; Segment < Device->SegmentCount; Segment++) {

        RouterSegment = &IpxDevice->Segments[Segment];

        //
        // Don't take the lock if the bucket is empty.
        //

        if (RouterSegment->Entries.Flink == &RouterSegment->Entries) {
            continue;
        }

        IPX_GET_LOCK (&Device->SegmentLocks[Segment], &LockHandle);

        //
        // Scan through each entry looking for ones to age.
        //

        for (RouteEntry = RipGetFirstRoute (Segment);
             RouteEntry != (PIPX_ROUTE_ENTRY)NULL;
             RouteEntry = RipGetNextRoute (Segment)) {

            if (RouteEntry->Flags & IPX_ROUTER_PERMANENT_ENTRY) {
                continue;
            }

            //
            // [FW] There are more entries to age
            //
            fMoreToAge = TRUE;

            ++RouteEntry->Timer;
            if (RouteEntry->Timer >= Device->RipUsageTime) {

                RipDeleteRoute (Segment, RouteEntry);
                IpxFreeMemory(RouteEntry, sizeof(IPX_ROUTE_ENTRY), MEMORY_RIP, "RouteEntry");
                continue;

            }

            //
            // See if we should re-RIP for this segment. It has
            // to have been around for RipAgeTime, and we also
            // make sure that the Timer is not too high to
            // prevent us from re-RIPping on unused routes.
            //

            ++RouteEntry->PRIVATE.Reserved[0];

            if ((RouteEntry->PRIVATE.Reserved[0] >= Device->RipAgeTime) &&
                (RouteEntry->Timer <= Device->RipAgeTime) &&
                !Device->ForwarderBound) {

                //
                // If we successfully queue a request, then reset
                // Reserved[0] so we don't re-RIP for a while.
                //

                if (RipQueueRequest (*(UNALIGNED ULONG *)RouteEntry->Network, RIP_REQUEST) == STATUS_PENDING) {
                    RouteEntry->PRIVATE.Reserved[0] = 0;
                }
            }
        }

        IPX_FREE_LOCK (&Device->SegmentLocks[Segment], LockHandle);

    }


    //
    // [FW] If RIP installed, restart the timer only if there was at least
    // one entry which could be aged.
    //

    if (Device->ForwarderBound) {

       if (fMoreToAge) {

          IPX_DEBUG(RIP, ("More entries to age - restarting long timer\n"));
          CTEStartTimer(
             &Device->RipLongTimer,
             60000,                     // one minute timeout
             RipLongTimeout,
             (PVOID)Device);

       } else {

          //
          // Else, dont restart the timer and deref the device
          //

          IPX_DEBUG(RIP, ("No more entries to age - derefing the device\n"));
          IpxDereferenceDevice (Device, DREF_LONG_TIMER);
       }
    } else {
        //
        // Now restart the timer for the next timeout.
        //

        if (Device->State == DEVICE_STATE_OPEN) {

            CTEStartTimer(
                &Device->RipLongTimer,
                60000,                     // one minute timeout
                RipLongTimeout,
                (PVOID)Device);

        } else {

            //
            // Send a DOWN packet if needed, then stop ourselves.
            //

            if (Device->RipResponder) {

                if (RipQueueRequest (Device->VirtualNetworkNumber, RIP_DOWN) != STATUS_PENDING) {

                    //
                    // We need to kick this event because the packet completion
                    // won't.
                    //

                    KeSetEvent(
                        &Device->UnloadEvent,
                        0L,
                        FALSE);
                }
            }

            IpxDereferenceDevice (Device, DREF_LONG_TIMER);
        }
    }

}   /* RipLongTimeout */


VOID
RipCleanupPacket(
    IN PDEVICE Device,
    IN PIPX_SEND_RESERVED RipReserved
    )

/*++

Routine Description:

    This routine cleans up when a RIP packet times out.

Arguments:

    Device - The device.

    RipReserved - The ProtocolReserved section of the RIP packet.

Return Value:

    None.

--*/

{
    ULONG Segment;
    IPX_DEFINE_LOCK_HANDLE_PARAM (LockHandle)

    if (RipReserved->u.SR_RIP.RetryCount < 0xfe) {

        if (RipReserved->u.SR_RIP.Network != 0xffffffff) {

            IPX_DEBUG (RIP, ("Timing out RIP for network %lx\n",
                                 REORDER_ULONG(RipReserved->u.SR_RIP.Network)));

            Segment = RipGetSegment ((PUCHAR)&RipReserved->u.SR_RIP.Network);
            IPX_GET_LOCK (&Device->SegmentLocks[Segment], &LockHandle);

            //
            // Fail all datagrams, etc. that were waiting for
            // this route. This call releases the lock.
            //

            RipHandleRoutePending(
                Device,
                (PUCHAR)&(RipReserved->u.SR_RIP.Network),
                LockHandle,
                FALSE,
                NULL,
                0,
                0);

        } else {

            //
            // This was the initial query looking for networks --
            // signal the init thread which is waiting.
            //

            IPX_DEBUG (AUTO_DETECT, ("Signalling auto-detect event\n"));
            KeSetEvent(
                &Device->AutoDetectEvent,
                0L,
                FALSE);

        }

    } else if (RipReserved->u.SR_RIP.RetryCount == 0xff) {

        //
        // This is a DOWN message, set the device event that
        // is waiting for it to complete.
        //

        KeSetEvent(
            &Device->UnloadEvent,
            0L,
            FALSE);
    }

    //
    // Put the RIP packet back in the pool.
    //

    RipReserved->Identifier = IDENTIFIER_IPX;

}   /* RipCleanupPacket */


VOID
RipProcessResponse(
    IN PDEVICE Device,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN RIP_PACKET UNALIGNED * RipPacket
    )

/*++

Routine Description:

    This routine processes a RIP response from the specified
    local target, indicating a route to the network in the RIP
    header.

Arguments:

    Device - The device.

    LocalTarget - The router that the frame was received from.

    RipPacket - The RIP response header.

Return Value:

    None.

--*/

{
    PIPX_SEND_RESERVED RipReserved;    // ProtocolReserved of RIP packet
    ULONG Segment;
    PIPX_ROUTE_ENTRY RouteEntry, OldRouteEntry;
    PLIST_ENTRY p;
    IPX_DEFINE_LOCK_HANDLE_PARAM (LockHandle)

    //
    // Since we have received a RIP response for this network.
    // kill the waiting RIP packets for it if it exists.
    //

    IPX_GET_LOCK (&Device->Lock, &LockHandle);

    for (p = Device->WaitingRipPackets.Flink;
         p != &Device->WaitingRipPackets;
         p = p->Flink) {

        RipReserved = CONTAINING_RECORD (p, IPX_SEND_RESERVED, WaitLinkage);

        if (RipReserved->u.SR_RIP.RetryCount >= 0xfe) {
            continue;
        }

        if (RipReserved->u.SR_RIP.Network ==
                 RipPacket->NetworkEntry.NetworkNumber) {
            break;
        }

    }

    if (p == &Device->WaitingRipPackets) {

        //
        // No packets pending on this, return.
        //

        IPX_FREE_LOCK (&Device->Lock, LockHandle);
        return;
    }


    //
    // Put the RIP packet back in the pool.
    //

    IPX_DEBUG (RIP, ("Got RIP response for network %lx\n",
                        REORDER_ULONG(RipPacket->NetworkEntry.NetworkNumber)));

    RipReserved->u.SR_RIP.RouteFound = TRUE;
    if (!RipReserved->SendInProgress) {

        //
        // If the send is done destroy it now, otherwise
        // when it pops up in RipShortTimeout it will get
        // destroyed because RouteFound is TRUE.
        //

        RemoveEntryList (p);
        RipReserved->Identifier = IDENTIFIER_IPX;
        IPX_PUSH_ENTRY_LIST (&Device->SendPacketList, &RipReserved->PoolLinkage, &Device->SListsLock);
        --Device->RipPacketCount;
        IPX_FREE_LOCK (&Device->Lock, LockHandle);

        IpxDereferenceDevice (Device, DREF_RIP_PACKET);

    } else {

        IPX_FREE_LOCK (&Device->Lock, LockHandle);
    }


    //
    // Try to allocate and add a router segment unless the
    // RIP router is active...if we don't that is fine, we'll
    // just re-RIP later.
    //

    Segment = RipGetSegment ((PUCHAR)&RipPacket->NetworkEntry.NetworkNumber);

    if (!Device->UpperDriverBound[IDENTIFIER_RIP]) {

        RouteEntry = IpxAllocateMemory(sizeof(IPX_ROUTE_ENTRY), MEMORY_RIP, "RouteEntry");
        if (RouteEntry != (PIPX_ROUTE_ENTRY)NULL) {

            *(UNALIGNED LONG *)RouteEntry->Network = RipPacket->NetworkEntry.NetworkNumber;
            RouteEntry->NicId = NIC_FROM_LOCAL_TARGET(LocalTarget);
            RouteEntry->NdisBindingContext = NIC_ID_TO_BINDING(Device, RouteEntry->NicId)->Adapter->NdisBindingHandle;
			// What if this is NULL?? -> make sure not null before calling this routine. 
            RouteEntry->Flags = 0;
            RouteEntry->Timer = 0;
            RouteEntry->PRIVATE.Reserved[0] = 0;
            RouteEntry->Segment = Segment;
            RouteEntry->HopCount = REORDER_USHORT(RipPacket->NetworkEntry.HopCount);
            RouteEntry->TickCount = REORDER_USHORT(RipPacket->NetworkEntry.TickCount);
            InitializeListHead (&RouteEntry->AlternateRoute);
            InitializeListHead (&RouteEntry->NicLinkage);
            RtlCopyMemory (RouteEntry->NextRouter, LocalTarget->MacAddress, 6);

            IPX_GET_LOCK (&Device->SegmentLocks[Segment], &LockHandle);

            //
            // Replace any existing routes. This is OK because once
            // we get the first response to a RIP packet on a given
            // route, we will take the packet out of the queue and
            // ignore further responses. We will only get a bad route
            // if we do two requests really quickly and there
            // are two routes, and the second response to the first
            // request is picked up as the first response to the second
            // request.
            //

            if ((OldRouteEntry = RipGetRoute (Segment, (PUCHAR)&(RipPacket->NetworkEntry.NetworkNumber))) != NULL) {

                //
                // These are saved so timeouts etc. happen right.
                //

                RouteEntry->Flags = OldRouteEntry->Flags;
                RouteEntry->Timer = OldRouteEntry->Timer;

                RipDeleteRoute (Segment, OldRouteEntry);
                IpxFreeMemory(OldRouteEntry, sizeof(IPX_ROUTE_ENTRY), MEMORY_RIP, "RouteEntry");

            }

            RipAddRoute (Segment, RouteEntry);

        } else {

            IPX_GET_LOCK (&Device->SegmentLocks[Segment], &LockHandle);
        }

    } else {

        IPX_GET_LOCK (&Device->SegmentLocks[Segment], &LockHandle);
    }

    //
    // Complete all datagrams etc. that were waiting
    // for this route. This call releases the lock.
    //

    RipHandleRoutePending(
        Device,
        (PUCHAR)&(RipPacket->NetworkEntry.NetworkNumber),
        LockHandle,
        TRUE,
        LocalTarget,
        (USHORT)(REORDER_USHORT(RipPacket->NetworkEntry.HopCount)),
        (USHORT)(REORDER_USHORT(RipPacket->NetworkEntry.TickCount))
        );

}   /* RipProcessResponse */

VOID
RipHandleRoutePending(
    IN PDEVICE Device,
    IN UCHAR Network[4],
    IN CTELockHandle LockHandle,
    IN BOOLEAN Success,
    IN OPTIONAL PIPX_LOCAL_TARGET LocalTarget,
    IN OPTIONAL USHORT HopCount,
    IN OPTIONAL USHORT TickCount
    )

/*++

Routine Description:

    This routine cleans up pending datagrams, find route
    requests, and GET_LOCAL_TARGET ioctls that were
    waiting for a route to be found.

    THIS ROUTINE IS CALLED WITH THE SEGMENT LOCK HELD AND
    RETURNS WITH IT RELEASED.

Arguments:

    Device - The device.

    Network - The network in question.

    LockHandle - The handle used to acquire the lock.

    Success - TRUE if the route was successfully found.

    LocalTarget - If Success is TRUE, the local target for the route.

    HopCount - If Success is TRUE, the hop count for the route,
        in machine order.

    TickCount - If Success is TRUE, the tick count for the route,
        in machine order.

Return Value:

    None.

--*/

{

    LIST_ENTRY DatagramList;
    LIST_ENTRY FindRouteList;
    LIST_ENTRY GetLocalTargetList;
    LIST_ENTRY ReripNetnumList;
    PIPX_SEND_RESERVED WaitReserved;   // ProtocolReserved of waiting packet
    PIPX_FIND_ROUTE_REQUEST FindRouteRequest;
    PREQUEST GetLocalTargetRequest;
    PREQUEST ReripNetnumRequest;
    PISN_ACTION_GET_LOCAL_TARGET GetLocalTarget;
    PIPX_NETNUM_DATA NetnumData;
    ULONG Segment;
    PBINDING Binding, SendBinding;
    PLIST_ENTRY p;
    PNDIS_PACKET Packet;
    PIPX_HEADER IpxHeader;
    ULONG HeaderSize;
    NDIS_STATUS NdisStatus;
    ULONG NetworkUlong = *(UNALIGNED ULONG *)Network;


    InitializeListHead (&DatagramList);
    InitializeListHead (&FindRouteList);
    InitializeListHead (&GetLocalTargetList);
    InitializeListHead (&ReripNetnumList);


    //
    // Put all packets that were waiting for a route to
    // this network on DatagramList. They will be sent
    // or failed later in the routine.
    //

    Segment = RipGetSegment (Network);

    p = Device->Segments[Segment].WaitingForRoute.Flink;

    while (p != &Device->Segments[Segment].WaitingForRoute) {

        WaitReserved = CONTAINING_RECORD (p, IPX_SEND_RESERVED, WaitLinkage);
        p = p->Flink;
#if 0
        if (*(UNALIGNED ULONG *)(((PIPX_HEADER)(&WaitReserved->Header[Device->IncludedHeaderOffset]))->DestinationNetwork) ==
                NetworkUlong) {
#endif
        if (*(UNALIGNED ULONG *)(((PIPX_HEADER)(&WaitReserved->Header[MAC_HEADER_SIZE]))->DestinationNetwork) ==
                NetworkUlong) {

            RemoveEntryList (&WaitReserved->WaitLinkage);
            InsertTailList (&DatagramList, &WaitReserved->WaitLinkage);
        }

    }

    //
    // Put all find route requests for this network on
    // FindRouteList. They will be completed later in the
    // routine.
    //

    p = Device->Segments[Segment].FindWaitingForRoute.Flink;

    while (p != &Device->Segments[Segment].FindWaitingForRoute) {

        FindRouteRequest = CONTAINING_RECORD (p, IPX_FIND_ROUTE_REQUEST, Linkage);
        p = p->Flink;
        if (*(UNALIGNED ULONG *)(FindRouteRequest->Network) ==
                NetworkUlong) {

            RemoveEntryList (&FindRouteRequest->Linkage);
            InsertTailList (&FindRouteList, &FindRouteRequest->Linkage);
        }

    }

    //
    // Put all get local target action requests for this
    // network on GetLocalTargetList. They will be completed
    // later in the routine.
    //

    p = Device->Segments[Segment].WaitingLocalTarget.Flink;

    while (p != &Device->Segments[Segment].WaitingLocalTarget) {

        GetLocalTargetRequest = LIST_ENTRY_TO_REQUEST(p);
        p = p->Flink;
        GetLocalTarget = (PISN_ACTION_GET_LOCAL_TARGET)REQUEST_INFORMATION(GetLocalTargetRequest);
        if (GetLocalTarget->IpxAddress.NetworkAddress == NetworkUlong) {

            RemoveEntryList (REQUEST_LINKAGE(GetLocalTargetRequest));
            InsertTailList (&GetLocalTargetList, REQUEST_LINKAGE(GetLocalTargetRequest));
        }

    }

    //
    // Put all MIPX_RERIPNETNUM action requests for this
    // network on ReripNetnumList. They will be completed
    // later in the routine.
    //

    p = Device->Segments[Segment].WaitingReripNetnum.Flink;

    while (p != &Device->Segments[Segment].WaitingReripNetnum) {

        ReripNetnumRequest = LIST_ENTRY_TO_REQUEST(p);
        p = p->Flink;
        NetnumData = (PIPX_NETNUM_DATA)REQUEST_INFORMATION(ReripNetnumRequest);
        if (*(UNALIGNED ULONG *)NetnumData->netnum == NetworkUlong) {

            RemoveEntryList (REQUEST_LINKAGE(ReripNetnumRequest));
            InsertTailList (&ReripNetnumList, REQUEST_LINKAGE(ReripNetnumRequest));
        }

    }


    IPX_FREE_LOCK (&Device->SegmentLocks[Segment], LockHandle);

    //
    // For sends we will use the master binding of a binding
    // set, but we'll return the real NicId for people who
    // want that.
    //

    if (Success) {
        Binding = NIC_ID_TO_BINDING(Device, NIC_FROM_LOCAL_TARGET(LocalTarget));

        if (Binding->BindingSetMember) {
            SendBinding = Binding->MasterBinding;
            FILL_LOCAL_TARGET(LocalTarget, MIN( Device->MaxBindings, SendBinding->NicId));
        } else {
            SendBinding = Binding;
        }
    }


    //
    // Now that the lock is free, process all packets on
    // DatagramList.
    //
    // NOTE: May misorder packets if they come in right now...
    //

    for (p = DatagramList.Flink; p != &DatagramList ; ) {

        WaitReserved = CONTAINING_RECORD (p, IPX_SEND_RESERVED, WaitLinkage);
        p = p->Flink;
        Packet = CONTAINING_RECORD (WaitReserved, NDIS_PACKET, ProtocolReserved[0]);

#if DBG
        CTEAssert (!WaitReserved->SendInProgress);
        WaitReserved->SendInProgress = TRUE;
#endif

        if (Success) {

            IPX_DEBUG (RIP, ("Found queued packet %lx\n", WaitReserved));

            if (REQUEST_INFORMATION(WaitReserved->u.SR_DG.Request) >
                    SendBinding->RealMaxDatagramSize) {

                IPX_DEBUG (SEND, ("Queued send %d bytes too large (%d)\n",
                    REQUEST_INFORMATION(WaitReserved->u.SR_DG.Request),
                    SendBinding->RealMaxDatagramSize));

                IpxSendComplete(
                    (NDIS_HANDLE)NULL,
                    Packet,
                    STATUS_INVALID_BUFFER_SIZE);

            } else {

#if 0
                if (WaitReserved->DestinationType == DESTINATION_DEF) {
                    HeaderSize = SendBinding->DefHeaderSize;
                } else {
                    HeaderSize = SendBinding->BcMcHeaderSize;
                }

                IpxHeader = (PIPX_HEADER)
                    (&WaitReserved->Header[HeaderSize]);
#endif
                IpxHeader = (PIPX_HEADER)
                    (&WaitReserved->Header[MAC_HEADER_SIZE]);

                //
                // Move the header to the correct location now that
                // we know the NIC ID to send to.
                //
#if 0
                if (HeaderSize != Device->IncludedHeaderOffset) {

                    RtlMoveMemory(
                        IpxHeader,
                        &WaitReserved->Header[Device->IncludedHeaderOffset],
                        sizeof(IPX_HEADER));

                }
#endif

                if (Device->MultiCardZeroVirtual ||
                    (IpxHeader->DestinationSocket == SAP_SOCKET)) {

                    //
                    // These frames need to look like they come from the
                    // local network, not the virtual one.
                    //

                    *(UNALIGNED ULONG *)IpxHeader->SourceNetwork = SendBinding->LocalAddress.NetworkAddress;
                    RtlCopyMemory (IpxHeader->SourceNode, SendBinding->LocalAddress.NodeAddress, 6);
                }

                //
                // Fill in the MAC header and submit the frame to NDIS.
                //
#ifdef SUNDOWN
                if ((NdisStatus = IpxSendFrame(
                        LocalTarget,
                        Packet,
                        (ULONG) REQUEST_INFORMATION(WaitReserved->u.SR_DG.Request) + sizeof(IPX_HEADER),
                        sizeof(IPX_HEADER))) != NDIS_STATUS_PENDING) {

#else
		if ((NdisStatus = IpxSendFrame(
			   LocalTarget,
			   Packet,
			   REQUEST_INFORMATION(WaitReserved->u.SR_DG.Request) + sizeof(IPX_HEADER),
			   sizeof(IPX_HEADER))) != NDIS_STATUS_PENDING) {

#endif


                    IpxSendComplete(
                        (NDIS_HANDLE)SendBinding->Adapter,
                        Packet,
                        NdisStatus);
                }

            }

        } else {

            IPX_DEBUG (RIP, ("Timing out packet %lx\n", WaitReserved));

            IpxSendComplete(
                (NDIS_HANDLE)NULL,
                Packet,
                STATUS_BAD_NETWORK_PATH);

        }

    }


    //
    // Since we round-robin outgoing rip packets, we just use the
    // real NicId here for find route and get local target requests.
    // We changed LocalTarget->NicId to be the master above.
    //

    if (Success) {
        FILL_LOCAL_TARGET(LocalTarget, MIN( Device->MaxBindings, Binding->NicId));
    }

    for (p = FindRouteList.Flink; p != &FindRouteList ; ) {

        FindRouteRequest = CONTAINING_RECORD (p, IPX_FIND_ROUTE_REQUEST, Linkage);
        p = p->Flink;

        if (Success) {

            PUSHORT Counts;

            IPX_DEBUG (RIP, ("Found queued find route %lx\n", FindRouteRequest));
            FindRouteRequest->LocalTarget = *LocalTarget;

            Counts = (PUSHORT)&FindRouteRequest->Reserved2;
            Counts[0] = TickCount;
            Counts[1] = HopCount;

        } else {

            IPX_DEBUG (RIP, ("Timing out find route %lx\n", FindRouteRequest));

        }

        (*Device->UpperDrivers[FindRouteRequest->Identifier].FindRouteCompleteHandler)(
            FindRouteRequest,
            Success);

    }

    for (p = GetLocalTargetList.Flink; p != &GetLocalTargetList ; ) {

        GetLocalTargetRequest = LIST_ENTRY_TO_REQUEST(p);
        p = p->Flink;
        GetLocalTarget = (PISN_ACTION_GET_LOCAL_TARGET)REQUEST_INFORMATION(GetLocalTargetRequest);

        if (Success) {

            IPX_DEBUG (RIP, ("Found queued LOCAL_TARGET action %lx\n", GetLocalTargetRequest));
            GetLocalTarget->LocalTarget = *LocalTarget;
            REQUEST_INFORMATION(GetLocalTargetRequest) = sizeof(ISN_ACTION_GET_LOCAL_TARGET);
            REQUEST_STATUS(GetLocalTargetRequest) = STATUS_SUCCESS;

        } else {

            IPX_DEBUG (RIP, ("Timing out LOCAL_TARGET action %lx\n", GetLocalTargetRequest));
            REQUEST_INFORMATION(GetLocalTargetRequest) = 0;
            REQUEST_STATUS(GetLocalTargetRequest) = STATUS_BAD_NETWORK_PATH;
        }

        IpxCompleteRequest(GetLocalTargetRequest);
        IpxFreeRequest(Device, GetLocalTargetRequest);

    }

    //
    // NOTE: LocalTarget->NicId now points to the real binding
    // not the master, so we use SendBinding->NicId below.
    //

    for (p = ReripNetnumList.Flink; p != &ReripNetnumList ; ) {

        ReripNetnumRequest = LIST_ENTRY_TO_REQUEST(p);
        p = p->Flink;
        NetnumData = (PIPX_NETNUM_DATA)REQUEST_INFORMATION(ReripNetnumRequest);

        if (Success) {

            IPX_DEBUG (RIP, ("Found queued MIPX_RERIPNETNUM action %lx\n", ReripNetnumRequest));
            NetnumData->hopcount = HopCount;
            NetnumData->netdelay = TickCount;
            NetnumData->cardnum = (INT)(MIN( Device->MaxBindings, SendBinding->NicId) - 1);
            RtlMoveMemory (NetnumData->router, LocalTarget->MacAddress, 6);

            REQUEST_INFORMATION(ReripNetnumRequest) =
                FIELD_OFFSET(NWLINK_ACTION, Data[0]) + sizeof(IPX_NETNUM_DATA);
            REQUEST_STATUS(ReripNetnumRequest) = STATUS_SUCCESS;

        } else {

            IPX_DEBUG (RIP, ("Timing out MIPX_RERIPNETNUM action %lx\n", ReripNetnumRequest));
            REQUEST_INFORMATION(ReripNetnumRequest) = 0;
            REQUEST_STATUS(ReripNetnumRequest) = STATUS_BAD_NETWORK_PATH;
        }

        IpxCompleteRequest(ReripNetnumRequest);
        IpxFreeRequest(Device, ReripNetnumRequest);

    }

}   /* RipHandleRoutePending */


NTSTATUS
RipInsertLocalNetwork(
    IN ULONG Network,
    IN USHORT NicId,
    IN NDIS_HANDLE NdisBindingContext,
    IN USHORT Count
    )

/*++

Routine Description:

    This routine creates a router entry for a local network
    and inserts it in the table.

Arguments:

    Network - The network.

    NicId - The NIC ID used to route packets

    NdisBindingHandle - The binding handle used for NdisSend

    Count - The tick and hop count for this network (will be
                0 for the virtual net and 1 for attached nets)

Return Value:

    The status of the operation.

--*/

{
    PIPX_ROUTE_ENTRY RouteEntry;
    PDEVICE Device = IpxDevice;
    ULONG Segment;
    IPX_DEFINE_LOCK_HANDLE (LockHandle)

    //
    // We should allocate the memory in the binding/device
    // structure itself.
    //

    RouteEntry = IpxAllocateMemory(sizeof(IPX_ROUTE_ENTRY), MEMORY_RIP, "RouteEntry");
    if (RouteEntry == (PIPX_ROUTE_ENTRY)NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Segment = RipGetSegment ((PUCHAR)&Network);

    *(UNALIGNED LONG *)RouteEntry->Network = Network;
    RouteEntry->NicId = NicId;
    RouteEntry->NdisBindingContext = NdisBindingContext;

    if (NicId == 0) {
        RouteEntry->Flags = IPX_ROUTER_PERMANENT_ENTRY;
    } else {
        RouteEntry->Flags = IPX_ROUTER_PERMANENT_ENTRY | IPX_ROUTER_LOCAL_NET;
    }
    RouteEntry->Segment = Segment;
    RouteEntry->TickCount = Count;
    RouteEntry->HopCount = 1;
    InitializeListHead (&RouteEntry->AlternateRoute);
    InitializeListHead (&RouteEntry->NicLinkage);

    //
    // RouteEntry->NextRouter is not used for the virtual net or
    // when LOCAL_NET is set (i.e. every net that we will add here).
    //

    RtlZeroMemory (RouteEntry->NextRouter, 6);

    IPX_GET_LOCK (&Device->SegmentLocks[Segment], &LockHandle);

    //
    // Make sure one doesn't exist.
    //

    if (RipGetRoute(Segment, (PUCHAR)&Network) != NULL) {
        IPX_FREE_LOCK (&Device->SegmentLocks[Segment], LockHandle);
        IpxFreeMemory (RouteEntry, sizeof(IPX_ROUTE_ENTRY), MEMORY_RIP, "RouteEntry");
        return STATUS_DUPLICATE_NAME;
    }

    //
    // Add this new entry.
    //

    if (RipAddRoute (Segment, RouteEntry)) {

        IPX_FREE_LOCK (&Device->SegmentLocks[Segment], LockHandle);
        return STATUS_SUCCESS;

    } else {

        IPX_FREE_LOCK (&Device->SegmentLocks[Segment], LockHandle);
        IpxFreeMemory (RouteEntry, sizeof(IPX_ROUTE_ENTRY), MEMORY_RIP, "RouteEntry");
        return STATUS_INSUFFICIENT_RESOURCES;

    }

}   /* RipInsertLocalNetwork */


VOID
RipAdjustForBindingChange(
    IN USHORT NicId,
    IN USHORT NewNicId,
    IN IPX_BINDING_CHANGE_TYPE ChangeType
    )

/*++

Routine Description:

    This routine is called when an auto-detect binding is
    deleted or moved, or a WAN line goes down.

    It scans the RIP database for routes equal to this NIC ID
    and modifies them appropriately. If ChangeType is
    IpxBindingDeleted it will subract one from any NIC IDs
    in the database that are higher than NicId. It is assumed
    that other code is readjusting the Device->Bindings
    array.

Arguments:

    NicId - The NIC ID of the deleted binding.

    NewNicId - The new NIC ID, for IpxBindingMoved changes.

    ChangeType - Either IpxBindingDeleted, IpxBindingMoved,
        or IpxBindingDown.

Return Value:

    None.

--*/

{
    PDEVICE Device = IpxDevice;
    PIPX_ROUTE_ENTRY RouteEntry;
    UINT Segment;
    CTELockHandle LockHandle;

    for (Segment = 0; Segment < Device->SegmentCount; Segment++) {

        CTEGetLock (&Device->SegmentLocks[Segment], &LockHandle);

        //
        // Scan through each entry comparing the NIC ID.
        //

        for (RouteEntry = RipGetFirstRoute (Segment);
             RouteEntry != (PIPX_ROUTE_ENTRY)NULL;
             RouteEntry = RipGetNextRoute (Segment)) {

            if (RouteEntry->NicId == NicId) {

                if (ChangeType != IpxBindingMoved) {

                    IPX_DEBUG (AUTO_DETECT, ("Deleting route entry %lx, binding deleted\n", RouteEntry));
                    RipDeleteRoute (Segment, RouteEntry);

                } else {

                    IPX_DEBUG (AUTO_DETECT, ("Changing NIC ID for route entry %lx\n", RouteEntry));
                    RouteEntry->NicId = NewNicId;

                }
            //
            // If the NicId is 0, we dont adjust the other entries' NicId's - this is to support the removal
            // of the Virtual Net # which resides at NicId=0.
            //
            } else if (NicId && (ChangeType != IpxBindingDown) && (RouteEntry->NicId > NicId)) {
                IPX_DEBUG (AUTO_DETECT, ("Decrementing NIC ID for route entry %lx\n", RouteEntry));
                --RouteEntry->NicId;

            }
        }

        CTEFreeLock (&Device->SegmentLocks[Segment], LockHandle);

    }

}   /* RipAdjustForBindingChange */


UINT
RipGetSegment(
    IN UCHAR Network[4]
    )

/*++

Routine Description:

    This routine returns the correct segment for the specified
    network.

Arguments:

    Network - The network.

Return Value:

    The segment.

--*/

{

    ULONG Total;

    Total = Network[0] ^ Network[1] ^ Network[2] ^ Network[3];
    return (Total % IpxDevice->SegmentCount);

}   /* RipGetSegment */


PIPX_ROUTE_ENTRY
RipGetRoute(
    IN UINT Segment,
    IN UCHAR Network[4]
    )

/*++

Routine Description:

    This routine returns the router table entry for the given
    network, which is in the specified segment of the table.
    THE SEGMENT LOCK MUST BE HELD. The returned data is valid
    until the segment lock is released or other operations
    (add/delete) are performed on the segment.

Arguments:

    Segment - The segment corresponding to the network.

    Network - The network.

Return Value:

    The router table entry, or NULL if none exists for this network.

--*/

{
    PLIST_ENTRY p;
    PROUTER_SEGMENT RouterSegment;
    PIPX_ROUTE_ENTRY RouteEntry;

    RouterSegment = &IpxDevice->Segments[Segment];

    for (p = RouterSegment->Entries.Flink;
         p != &RouterSegment->Entries;
         p = p->Flink) {

         RouteEntry = CONTAINING_RECORD(
                          p,
                          IPX_ROUTE_ENTRY,
                          PRIVATE.Linkage);

         if ((*(UNALIGNED LONG *)RouteEntry->Network) ==
                 (*(UNALIGNED LONG *)Network)) {
             return RouteEntry;
         }
    }

    return NULL;

}   /* RipGetRoute */


BOOLEAN
RipAddRoute(
    IN UINT Segment,
    IN PIPX_ROUTE_ENTRY RouteEntry
    )

/*++

Routine Description:

    This routine stores a router table entry in the
    table, which must belong in the specified segment.
    THE SEGMENT LOCK MUST BE HELD. Storage for the entry
    is allocated and filled in by the caller.

Arguments:

    Segment - The segment corresponding to the network.

    RouteEntry - The router table entry.

Return Value:

    TRUE if the entry was successfully inserted.

--*/

{

    IPX_DEBUG (RIP, ("Adding route for network %lx (%d)\n",
        REORDER_ULONG(*(UNALIGNED ULONG *)RouteEntry->Network), Segment));
    InsertTailList(
        &IpxDevice->Segments[Segment].Entries,
        &RouteEntry->PRIVATE.Linkage);

    return TRUE;

}   /* RipAddRoute */


BOOLEAN
RipDeleteRoute(
    IN UINT Segment,
    IN PIPX_ROUTE_ENTRY RouteEntry
    )

/*++

Routine Description:

    This routine deletes a router table entry in the
    table, which must belong in the specified segment.
    THE SEGMENT LOCK MUST BE HELD. Storage for the entry
    is freed by the caller.

Arguments:

    Segment - The segment corresponding to the network.

    RouteEntry - The router table entry.

Return Value:

    TRUE if the entry was successfully deleted.

--*/

{

    PROUTER_SEGMENT RouterSegment = &IpxDevice->Segments[Segment];

    IPX_DEBUG (RIP, ("Deleting route for network %lx (%d)\n",
        REORDER_ULONG(*(UNALIGNED ULONG *)RouteEntry->Network), Segment));

    //
    // If the current enumeration point for this segment is here,
    // adjust the pointer before deleting the entry. We make it
    // point to the previous entry so GetNextRoute will work.
    //

    if (RouterSegment->EnumerateLocation == &RouteEntry->PRIVATE.Linkage) {
        RouterSegment->EnumerateLocation = RouterSegment->EnumerateLocation->Blink;
    }

    RemoveEntryList (&RouteEntry->PRIVATE.Linkage);

    return TRUE;

}   /* RipDeleteRoute */


PIPX_ROUTE_ENTRY
RipGetFirstRoute(
    IN UINT Segment
    )

/*++

Routine Description:

    This routine returns the first router table entry in the
    segment. THE SEGMENT LOCK MUST BE HELD. It is used in
    conjunction with RipGetNextRoute to enumerate all the
    entries in a segment.

Arguments:

    Segment - The segment being enumerated.

Return Value:

    The first router table entry, or NULL if the segment is empty.

--*/

{
    PIPX_ROUTE_ENTRY FirstEntry;
    PROUTER_SEGMENT RouterSegment = &IpxDevice->Segments[Segment];

    RouterSegment->EnumerateLocation = RouterSegment->Entries.Flink;

    if (RouterSegment->EnumerateLocation == &RouterSegment->Entries) {

        return NULL;

    } else {

        FirstEntry = CONTAINING_RECORD(
                         RouterSegment->EnumerateLocation,
                         IPX_ROUTE_ENTRY,
                         PRIVATE.Linkage);

        return FirstEntry;

    }

}   /* RipGetFirstRoute */


PIPX_ROUTE_ENTRY
RipGetNextRoute(
    IN UINT Segment
    )

/*++

Routine Description:

    This routine returns the next router table entry in the
    segment. THE SEGMENT LOCK MUST BE HELD. It is used in
    conjunction with RipGetFirstRoute to enumerate all the
    entries in a segment.

    It is illegal to call RipGetNextRoute on a segment
    without first calling RipGetFirstRoute. The segment
    lock must be held for the duration of the enumeration
    of a single segment. It is legal to stop enumerating
    the segment in the middle.

Arguments:

    Segment - The segment being enumerated.

Return Value:

    The next router table entry, or NULL if the end of the
    segment is reached.

--*/

{
    PIPX_ROUTE_ENTRY NextEntry;
    PROUTER_SEGMENT RouterSegment = &IpxDevice->Segments[Segment];

    RouterSegment->EnumerateLocation = RouterSegment->EnumerateLocation->Flink;

    if (RouterSegment->EnumerateLocation == &RouterSegment->Entries) {

        return NULL;

    } else {

        NextEntry = CONTAINING_RECORD(
                        RouterSegment->EnumerateLocation,
                        IPX_ROUTE_ENTRY,
                        PRIVATE.Linkage);

        return NextEntry;

    }

}   /* RipGetNextRoute */


VOID
RipDropRemoteEntries(
    VOID
    )

/*++

Routine Description:

    This routine deletes all non-local entries from the
    RIP database. It is called when the WAN line goes up
    or down and we want to remove all existing entries.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PDEVICE Device = IpxDevice;
    PIPX_ROUTE_ENTRY RouteEntry;
    UINT Segment;
    CTELockHandle LockHandle;

    for (Segment = 0; Segment < Device->SegmentCount; Segment++) {

        CTEGetLock (&Device->SegmentLocks[Segment], &LockHandle);

        //
        // Scan through, deleting everything but local entries.
        //

        for (RouteEntry = RipGetFirstRoute (Segment);
             RouteEntry != (PIPX_ROUTE_ENTRY)NULL;
             RouteEntry = RipGetNextRoute (Segment)) {

            if ((RouteEntry->Flags & IPX_ROUTER_PERMANENT_ENTRY) == 0) {

                IPX_DEBUG (AUTO_DETECT, ("Deleting route entry %lx, dropping remote entries\n", RouteEntry));
                RipDeleteRoute (Segment, RouteEntry);

            }
        }

        CTEFreeLock (&Device->SegmentLocks[Segment], LockHandle);

    }

}   /* RipDropRemoteEntries */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\rt.c ===
/*++

Copyright (c) 1989-1994  Microsoft Corporation

Module Name;

    Rt.c

Abstract;


Author;


Revision History;

TODO:  Get rid of ref/Deref since the RTINFO structure will not be destroyed
       Use a common alloc/free function (with the rest of ipx)
       Allocate tagged memory
       Optimize code more
--*/

#include "precomp.h"
#pragma hdrstop

//
// function prototypes
//

VOID
RtIrpCancel(
    IN PDEVICE_OBJECT Device,
    IN PIRP pIrp
    );


PVOID
RtAllocMem(
    IN  ULONG   Size
    );

VOID
RtFreeMem(
    IN  PVOID   pBuffer,
    IN  ULONG   Size
    );

NTSTATUS
NTCheckSetCancelRoutine(
    IN  PIRP            pIrp,
    IN  PVOID           CancelRoutine,
    IN  PDEVICE  pDevice
    );
VOID
NTIoComplete(
    IN  PIRP            pIrp,
    IN  NTSTATUS        Status,
    IN  ULONG           SentLength);

NTSTATUS
CleanupRtAddress(
    IN  PDEVICE  pDevice,
    IN  PIRP            pIrp);

NTSTATUS
CloseRtAddress(
    IN  PDEVICE  pDevice,
    IN  PIRP            pIrp);

NTSTATUS
SendIrpFromRt (
    IN  PDEVICE  pDevice,
    IN  PIRP        pIrp
    );

NTSTATUS
RcvIrpFromRt (
    IN  PDEVICE  pDevice,
    IN  PIRP        pIrp
    );
NTSTATUS
PassDgToRt (
    IN PDEVICE                  pDevice,
    IN PIPX_DATAGRAM_OPTIONS2   pContext,
    IN ULONG                    Index,
    IN VOID UNALIGNED           *pDgrm,
    IN ULONG                    uNumBytes
    );

VOID
IpxDerefRt(
     PRT_INFO pRt
    );

VOID
IpxRefRt(
     PRT_INFO pRt
    );

VOID
IpxDestroyRt(
    IN PRT_INFO pRt
    );

#define ALLOC_PRAGMA 1
#define CTEMakePageable(x, y)  alloc_text(x,y)

#define AllocMem(_BytesToAlloc) IpxAllocateMemory(_BytesToAlloc, MEMORY_PACKET, "RT MEMORY")

#define FreeMem(_Memory, _BytesAllocated) IpxFreeMemory(_Memory, _BytesAllocated, MEMORY_PACKET, "RT MEMORY")


#define IpxVerifyRt(pRt)  // \
                   // if ((pRt->Type != IPX_RT_SIGNATURE) || (pRt->Size != sizeof(RT_INFO))) { return STATUS_INVALID_ADDRESS; }


//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGERT, CloseRtAddress)
#pragma CTEMakePageable(PAGERT, CleanupRtAddress)
#pragma CTEMakePageable(PAGERT, RcvIrpFromRt)
#pragma CTEMakePageable(PAGERT, SendIrpFromRt)
#pragma CTEMakePageable(PAGERT, PassDgToRt)
#pragma CTEMakePageable(PAGERT, RtIrpCancel)
#pragma CTEMakePageable(PAGERT, NTCheckSetCancelRoutine)
#pragma CTEMakePageable(PAGERT, NTIoComplete)
#pragma CTEMakePageable(PAGERT, RtFreeMem)
#pragma CTEMakePageable(PAGERT, RtAllocMem)
#pragma CTEMakePageable(PAGERT, IpxRefRt)
#pragma CTEMakePageable(PAGERT, IpxDerefRt)
#pragma CTEMakePageable(PAGERT, IpxDestroyRt)
#endif
//*******************  Pageable Routine Declarations ****************


HANDLE       IpxRtDiscardableCodeHandle={0};

PRT_INFO pRtInfo;   //contains info about all rt opened end points


NTSTATUS
OpenRtAddress(
    IN PDEVICE pDevice,
    IN PREQUEST pIrp
    )
{
   PRT_INFO pRt;
   CTELockHandle OldIrq;
   NTSTATUS status;
   ULONG SaveReqCode;


   IpxPrint0("OpenRtAddress - entered\n");

   //
   // if the RTINFO endpoint structure is not allocated, then allocate it
   // and initialize it. But first get the device lock.  This gurantees that
   // we can not have two irps doing the creation at the same time
   //
   CTEGetLock(&pDevice->Lock, &OldIrq);
   if (!pRtInfo)
   {

     pRt = AllocMem(sizeof(RT_INFO));

     //
     // Do this after locking the pagable rtns.
     //
     // pRtInfo = pRt;       //store it in pRtInfo.  When irps come down from RM,
                          // we can compare pRt passed in them with pRtInfo
     if (pRt)
     {
       RtlZeroMemory(pRt,sizeof(RT_INFO));
       IpxPrint1("OpenRtAddress: Initializing CompletedIrps for pRt=(%lx)\n", pRt);
       pRt->RcvMemoryMax  = RT_MAX_BUFF_MEM;    // max. memory we can allocate
       pRt->Type      = IPX_RT_SIGNATURE;
       pRt->Size      = sizeof(RT_INFO);
       pRt->pDevice   = pDevice;
       IpxPrint1("OpenRtAddress: pRtInfo=(%lx)\n", pRt);
       IpxPrint1("Completed Irp list is (%lx)\n", IsListEmpty(&pRt->CompletedIrps));

#if DBG
       RtlCopyMemory(pRt->Signature, "RTIF", sizeof("RTIF") - 1);
#endif
       InitializeListHead(&pRt->CompletedIrps);
       InitializeListHead(&pRt->HolderIrpsList);
     }
     CTEFreeLock(&pDevice->Lock, OldIrq);
   }
   else
   {
     pRt = pRtInfo;
     CTEFreeLock(&pDevice->Lock, OldIrq);
     IpxPrint1("OpenRtAddress: RTINFO found = (%lx)\n", pRtInfo);
   }

   if (pRt)
   {

         // Page in the Rt Code, if it hasn't already been paged in.
         //
         if (!IpxRtDiscardableCodeHandle)
         {
             IpxRtDiscardableCodeHandle = MmLockPagableCodeSection( CloseRtAddress );

             pRtInfo = pRt;       //store it in pRtInfo.  When irps come down from RM,
                          // we can compare pRt passed in them with pRtInfo
         }

         //
         // it could fail to lock the pages so check for that
         //
         if (IpxRtDiscardableCodeHandle)
         {

            ULONG i;
            status = STATUS_SUCCESS;

            IpxReferenceRt(pRtInfo, RT_CREATE);

             //
             // Find an empty slot and mark it open
             //
             CTEGetLock(&pRt->Lock, &OldIrq);
             for (i=0; i<IPX_RT_MAX_ADDRESSES; i++)
             {
                 if (pRt->AddFl[i].State == RT_EMPTY)
                 {
                     break;
                 }
             }
             if (i < IPX_RT_MAX_ADDRESSES)
             {
               pRt->AddFl[i].State       = RT_OPEN;
               pRt->NoOfAdds++;
               pRt->AddFl[i].NoOfRcvIrps          = 0; //Why wasn't this initialized before?
               InitializeListHead(&pRt->AddFl[i].RcvList);
               InitializeListHead(&pRt->AddFl[i].RcvIrpList);

             }
             else
             {
               CTEFreeLock(&pRt->Lock, OldIrq);
               IpxPrint1("OpenRtAddress; All %d  slots used up\n", IPX_RT_MAX_ADDRESSES);
               IpxDereferenceRt(pRtInfo, RT_CREATE);
               status = STATUS_INSUFFICIENT_RESOURCES;
               goto RET;
             }
             CTEFreeLock(&pRt->Lock, OldIrq);

             //
             // Found an empty slot.  Initialize all relevant info. and then
             // open an address object.
             //
             SaveReqCode        = REQUEST_CODE(pIrp);
             REQUEST_CODE(pIrp) = MIPX_RT_CREATE;
             status             = IpxOpenAddressM(pDevice, pIrp, i);
             REQUEST_CODE(pIrp) = SaveReqCode;

             IpxPrint1("After IpxOpenAddressM: Completed Irp list is (%lx)\n", IsListEmpty(&pRtInfo->CompletedIrps));
             if (status != STATUS_SUCCESS)
             {
                 IpxPrint0("OpenRtAddress; Access Denied due to OpenAddress\n");
                 IpxDereferenceRt(pRtInfo, RT_CREATE);
                 CTEGetLock(&pRt->Lock, &OldIrq);
                 pRt->AddFl[i].State       = RT_EMPTY;
                 pRt->NoOfAdds--;
                 CTEFreeLock(&pRt->Lock, OldIrq);
             }
             else
             {
                 CTEGetLock(&pRt->Lock, &OldIrq);
                 pRt->AddFl[i].AddressFile = REQUEST_OPEN_CONTEXT(pIrp);
                 CTEFreeLock(&pRt->Lock, OldIrq);

                 //
                 // No need to put pRt since it is global. We stick with the addressfile here.
                 //

                 // REQUEST_OPEN_CONTEXT(pIrp) = (PVOID)pRt;
                 REQUEST_OPEN_TYPE(pIrp)    = UlongToPtr(ROUTER_ADDRESS_FILE + i);
                 IpxPrint1("OpenRtAdd: Index = (%d)\n", RT_ADDRESS_INDEX(pIrp));
              }
           }
           else
           {
                 IpxPrint1("OpenRtAddress; All %d  slots used up\n", IPX_RT_MAX_ADDRESSES);

                 status = STATUS_INSUFFICIENT_RESOURCES;
            }
     }
     else
     {
       IpxPrint0("OpenRtCreate; Couldn't allocate a RT_INFO structure\n");
       CTEAssert(FALSE);       //should never happen unless system is running
                               //out of non-paged pool
       status = STATUS_INSUFFICIENT_RESOURCES;

     }
RET:
     IpxPrint1("OpenRtAddress status prior to return= %X\n",status);
     return(status);
}


NTSTATUS
CleanupRtAddress(
    IN  PDEVICE  pDevice,
    IN  PIRP     pIrp)

/*++
Routine Description;

    This Routine handles closing the Rt Object that is used by
    by RT to send and receive name service datagrams on port 137.


Arguments;

    pIrp - a  ptr to an IRP

Return Value;

    NTSTATUS - status of the request

--*/

{
    NTSTATUS                   status;
    PRT_INFO                   pRt;
    CTELockHandle              OldIrq;
    PLIST_ENTRY                pHead;

#ifdef SUNDOWN
    ULONG_PTR                  Index;
#else
    ULONG                      Index;
#endif

    PLIST_ENTRY                pLE;
    PIRP                       pTmpIrp;

    IpxPrint0("CleanupRtAddress - entered\n");

    //
    // if the endpoint structure is allocated, then deallocate it
    //
    // pRt   = REQUEST_OPEN_CONTEXT(pIrp);
    pRt = pRtInfo;

    Index = RT_ADDRESS_INDEX(pIrp);
    IpxPrint1("CleanupRtAdd: Index = (%d)\n", Index);

    IpxVerifyRt(pRt);
    CTEAssert(pRt  && (pRt == pRtInfo));
    CTEAssert(Index < IPX_RT_MAX_ADDRESSES);

    do
    {
        PLIST_ENTRY          pRcvEntry;
        PRTRCV_BUFFER        pRcv;
        PRT_IRP pRtAddFl   = &pRt->AddFl[Index];

        CTEAssert(pRtAddFl->State == RT_OPEN);
        IpxPrint1("CleanupRtAddress: Got AF handle = (%lx)\n", pRtAddFl);
        IpxReferenceRt(pRt, RT_CLEANUP);
        status = STATUS_SUCCESS;

        CTEGetLock (&pRt->Lock, &OldIrq);

        //
        // prevent any more dgram getting queued up
        //
        pRtAddFl->State = RT_CLOSING;
        CTEFreeLock (&pRt->Lock, OldIrq);

        //
        // free any rcv buffers that may be queued up
        //
        pHead = &pRtAddFl->RcvList;
        while (pRcvEntry = ExInterlockedRemoveHeadList(pHead, &pRt->Lock))
        {
           pRcv = CONTAINING_RECORD(pRcvEntry,RTRCV_BUFFER,Linkage);

           CTEAssert(pRcv);
           IpxPrint1("CleanupRtAddress:Freeing buffer = (%lx)\n", pRcv);
           RtFreeMem(pRcv,pRcv->TotalAllocSize);
        }

        //
        // Complete all irps that are queued
        //
        while (pLE = ExInterlockedRemoveHeadList(&pRtAddFl->RcvIrpList, &pRt->Lock)) {

           //
           // The recv irp is here so copy the data to its buffer and
           // pass it up to RT
           //
           pTmpIrp = CONTAINING_RECORD(pLE, IRP, Tail.Overlay.ListEntry);
           IpxPrint1("CleanupRtAddress: Completing Rt rcv Irp from AdFl queue pIrp=%X\n" ,pTmpIrp);
           pTmpIrp->IoStatus.Information = 0;
           pTmpIrp->IoStatus.Status      = STATUS_CANCELLED;

           NTIoComplete(pTmpIrp, (NTSTATUS)-1, (ULONG)-1);

        } //end of while

       //
       // dequeue and complete any irps on the complete queue.
       //

       while (pLE = ExInterlockedRemoveHeadList(&pRt->CompletedIrps, &pRt->Lock))
       {
           pTmpIrp = CONTAINING_RECORD(pLE, IRP, Tail.Overlay.ListEntry);
           if (RT_ADDRESS_INDEX(pTmpIrp) == Index)
           {
              IpxPrint1("CleanupRtAddress:Completing Rt rcv Irp from CompleteIrps queue pIrp=%X\n" ,pTmpIrp);

               pTmpIrp->IoStatus.Information = 0;
               pTmpIrp->IoStatus.Status = STATUS_CANCELLED;
               NTIoComplete(pTmpIrp, (NTSTATUS)-1, (ULONG)-1);
           }
           else
           {
                ExInterlockedInsertHeadList(&pRt->HolderIrpsList, pLE, &pRt->Lock);
           }
       }
       CTEGetLock(&pRt->Lock, &OldIrq);
       while(!IsListEmpty(&pRt->HolderIrpsList))
       {
          pLE = RemoveHeadList(&pRt->HolderIrpsList);
          InsertHeadList(&pRt->CompletedIrps, pLE);
       }
       CTEFreeLock(&pRt->Lock, OldIrq);

       //
       // Store AF pointer in Irp since we will now be freeing the address file
       // (in driver.c).
       //

       //
       // We always have addressfile in the Irp
       //

       // REQUEST_OPEN_CONTEXT(pIrp) = (PVOID)(pRtAddFl->AddressFile);

       IpxDereferenceRt(pRt, RT_CLEANUP);
  } while (FALSE);

   IpxPrint0("CleanupRtAddress: Return\n");
   return(status);
}

NTSTATUS
CloseRtAddress(
    IN  PDEVICE  pDevice,
    IN  PIRP            pIrp)
{

    NTSTATUS                    status;
    PRT_INFO                  pRt;
    CTELockHandle               OldIrq;
    PLIST_ENTRY                 pHead;

#ifdef SUNDOWN
    ULONG_PTR Index;
#else
    ULONG Index;
#endif

    IpxPrint0("CloseRtAddress - entered\n");

    // pRt = REQUEST_OPEN_CONTEXT(pIrp);
    pRt = pRtInfo;

    Index = RT_ADDRESS_INDEX(pIrp);
    IpxPrint1("CloseRtAdd: Index = (%d)\n", Index);

    IpxVerifyRt(pRt);
    CTEAssert(pRt && (pRt == pRtInfo));
    CTEAssert(Index < IPX_RT_MAX_ADDRESSES);
    CTEAssert(pRt->AddFl[Index].State == RT_CLOSING);

    // REQUEST_OPEN_CONTEXT(pIrp) = (PVOID)(pRt->AddFl[Index].AddressFile);
    //REQUEST_OPEN_TYPE(pIrp)    = (PVOID)TDI_TRANSPORT_ADDRESS_FILE;

    CTEGetLock(&pRt->Lock, &OldIrq);
    pRt->AddFl[Index].State = RT_EMPTY;
    pRt->NoOfAdds--;
    CTEFreeLock(&pRt->Lock, OldIrq);

    //
    // THis is a counter to the RT_CREATE
    //
    IpxDereferenceRt(pRt, RT_CLOSE);

    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
SendIrpFromRt (
    IN  PDEVICE  pDevice,
    IN  PIRP        pIrp
    )
{
    CTELockHandle OldIrq;
    NTSTATUS      Status;

#ifdef SUNDOWN
    ULONG_PTR     Index;
#else
    ULONG         Index;
#endif

    PRT_INFO      pRt;

    IpxPrint0("SendIrpfromRt - entered\n");
    // pRt = REQUEST_OPEN_CONTEXT(pIrp);
    pRt = pRtInfo;

    Index = RT_ADDRESS_INDEX(pIrp);
    IpxVerifyRt(pRt);
    CTEAssert(pRt && (pRt == pRtInfo));
    do {
      //
      // Check if the add. file slot indicates that it is OPEN.  If it is
      // not open, then we should return STATUS_INVALID_HANDLE.  The
      // reason why it may not be open is if we got a cleanup/close before
      // this irp.
      //
      CTEGetLock(&pRt->Lock, &OldIrq);
      if (pRt->AddFl[Index].State != RT_OPEN)
      {

         //
         // free the lock, set the status and break out
         //
         CTEFreeLock (&pRt->Lock, OldIrq);
         Status = STATUS_INVALID_HANDLE;
         break;
      }
      //
      // Let us reference the RtInfo structure so that it does not dissapear
      // and also for some accounting
      //
      IpxReferenceRt(pRt, RT_SEND);


      IpxPrint1("SendIrpFromRt: Index = (%d)\n", Index);

      //
      // Store the AF pointer since IpxTdiSendDatagram will use it. Free
      // the device lock since we have nothing more to do with our structures
      // here.
      //
      // REQUEST_OPEN_CONTEXT(pIrp) = (PVOID)(pRtInfo->AddFl[Index].AddressFile);
      CTEFreeLock (&pRt->Lock, OldIrq);

      Status = IpxTdiSendDatagram(pDevice->DeviceObject, pIrp);

      //
      // All done with this send.  Derefernce the RtInfo structure.
      //
      IpxDereferenceRt(pRtInfo, RT_SEND);
   } while(FALSE);

    IpxPrint0("SendIrpfromRt - leaving\n");
    return(Status);
}

NTSTATUS
RcvIrpFromRt (
    IN  PDEVICE  pDevice,
    IN  PIRP        pIrp
    )
/*++

Routine Description;

    This function takes the rcv irp posted by RT and decides if there are
    any datagram queued waiting to go up to RT.  If so then the datagram
    is copied to the RT buffer and passed back up.  Otherwise the irp is
    held by Netbt until a datagram does come in.

Arguments;

    pDevice  - not used
    pIrp            - Rt Rcv Irp

Return Value;

    STATUS_PENDING if the buffer is to be held on to , the normal case.

Notes;


--*/

{
    NTSTATUS                status;
    PRTRCV_BUFFER            pBuffer;
    PLIST_ENTRY             pEntry;
    CTELockHandle           OldIrq;
    PRT_INFO                pRt;
    PIPX_DATAGRAM_OPTIONS2  pRtBuffer;
    PRT_IRP pRtAF;

#ifdef SUNDOWN
        ULONG_PTR Index;
#else
        ULONG Index;
#endif
    

#if DBG
    ULONG NoOfRcvIrp;
#endif

   IpxPrint0("RcvIrpfromRt - Entered\n");

   // pRt = REQUEST_OPEN_CONTEXT(pIrp);
   pRt = pRtInfo;

   Index = RT_ADDRESS_INDEX(pIrp);

   IpxPrint1("RcvIrpFromRt: Index = (%d)\n", Index);

   IpxVerifyRt(pRt);
   CTEAssert(pRt && (pRt == pRtInfo));
   CTEAssert(Index < IPX_RT_MAX_ADDRESSES);

   CTEGetLock (&pRt->Lock, &OldIrq);
   do
   {
        pRtAF = &pRt->AddFl[Index];
        if (pRtAF->State != RT_OPEN)
        {
             status = STATUS_INVALID_HANDLE;
             CTEFreeLock (&pRt->Lock, OldIrq);
             break;
        }
        IpxReferenceRt(pRt, RT_IRPIN);

        if (!IsListEmpty(&pRtAF->RcvList))
        {
            PMDL    pMdl;
            ULONG   CopyLength;
            ULONG   UserBufferLengthToPass;
            ULONG   MdlLength;

            //
            // There is at least one datagram waiting to be received
            //
            pEntry = RemoveHeadList(&pRtAF->RcvList);

            pBuffer = (PRTRCV_BUFFER)CONTAINING_RECORD(pEntry,RTRCV_BUFFER,
                                                                  Linkage);

            IpxPrint0("RcvIrpFromRt: Buffer dequeued\n");
            //
            // Copy the datagram and the source address to RT buffer and
            // return to RT
            //
            pMdl = pIrp->MdlAddress;
            IpxPrint2("RcvIrpFromRt: Irp=(%lx); Mdl=(%lx)\n", pIrp, pMdl);
            CTEAssert(pMdl);
            if (!pMdl)
            {
                status = STATUS_BUFFER_TOO_SMALL;
                CTEFreeLock (&pRt->Lock, OldIrq);
                IpxDereferenceRt(pRtInfo, RT_IRPIN);
                break;

            }
            pRtBuffer = MmGetSystemAddressForMdlSafe(pMdl, NormalPagePriority);
	    if (!pRtBuffer) {
	       status = STATUS_INSUFFICIENT_RESOURCES;
	       CTEFreeLock (&pRt->Lock, OldIrq);
	       IpxDereferenceRt(pRtInfo, RT_IRPIN);
	       break;
	    }
            
	    MdlLength = MmGetMdlByteCount(pMdl);

            UserBufferLengthToPass = pBuffer->UserBufferLengthToPass;

            CopyLength = (UserBufferLengthToPass <= MdlLength) ? UserBufferLengthToPass : MdlLength;
            IpxPrint0("RcvIrpFromRt: Copying Options\n");
            RtlCopyMemory((PVOID)pRtBuffer,
                       (PVOID)&pBuffer->Options,
                       CopyLength);

            //
            // subtract from the total amount buffered for RT since we are
            // passing a datagram up to RT now.
            //
            pRtInfo->RcvMemoryAllocated -= pBuffer->TotalAllocSize;
            RtFreeMem(pBuffer, pBuffer->TotalAllocSize);

            CTEAssert(pRtBuffer->DgrmOptions.LocalTarget.NicId);

            //
            // pass the irp up to RT
            //
            if (CopyLength < UserBufferLengthToPass)
            {
                status = STATUS_BUFFER_OVERFLOW;
            }
            else
            {
                status = STATUS_SUCCESS;
            }
#if DBG
            NoOfRcvIrp = pRtAF->NoOfRcvIrps;
#endif

            CTEFreeLock (&pRt->Lock, OldIrq);


            IpxPrint3("Returning Rt rcv Irp immediately with queued dgram, status=%X,pIrp=%X. NoOfRcvIrp=(%d)\n" ,status,pIrp, NoOfRcvIrp);

            pIrp->IoStatus.Information = CopyLength;
            pIrp->IoStatus.Status      = status;
        }
        else
        {

            status = NTCheckSetCancelRoutine(pIrp,RtIrpCancel,pDevice);

            if (!NT_SUCCESS(status))
            {
                CTEFreeLock (&pRt->Lock, OldIrq);
            }
            else
            {
                if (pRtAF->NoOfRcvIrps++ > RT_IRP_MAX)
                {
                     IpxPrint1("RcvIrpFromRt; REACHED LIMIT OF IRPS. NoOfRcvIrp=(%d)\n", pRtAF->NoOfRcvIrps);
                     status = STATUS_INSUFFICIENT_RESOURCES;
                     pRtAF->NoOfRcvIrps--;
                     CTEFreeLock (&pRt->Lock, OldIrq);

                }
                else
                {
                  InsertTailList(&pRtAF->RcvIrpList,REQUEST_LINKAGE(pIrp));
                  IpxPrint2("IpxRt;Holding onto Rt Rcv Irp, pIrp =%Xstatus=%X\n",   status,pIrp);

                  status = STATUS_PENDING;
                  CTEFreeLock(&pRt->Lock,OldIrq);
               }
            }


        }
        IpxDereferenceRt(pRtInfo, RT_IRPIN);
   } while(FALSE);

    IpxPrint0("RcvIrpfromRt - Leaving\n");
    return(status);

}

//----------------------------------------------------------------------------
NTSTATUS
PassDgToRt (
    IN PDEVICE                  pDevice,
    IN PIPX_DATAGRAM_OPTIONS2   pContext,
    IN ULONG                    Index,
    IN VOID UNALIGNED           *pDgrm,
    IN ULONG                    uNumBytes
    )
/*++

Routine Description;

    This function is used to allow NBT to pass name query service Pdu's to
    RT.  Rt posts a Rcv irp to Netbt.  If the Irp is here then simply
    copy the data to the irp and return it, otherwise buffer the data up
    to a maximum # of bytes. Beyond that limit the datagrams are discarded.

    If Retstatus is not success then the pdu will also be processed by
    nbt. This allows nbt to process packets when wins pauses and
    its list of queued buffers is exceeded.

Arguments;

    pDevice  - card that the request can in on
    pSrcAddress     - source address
    pDgrm        - ptr to the datagram
    uNumBytes       - length of datagram

Return Value;

    STATUS_PENDING if the buffer is to be held on to , the normal case.

Notes;


--*/

{
    NTSTATUS                status;
    PIPX_DATAGRAM_OPTIONS2  pRtBuffer;
    PIRP                    pIrp;
    CTELockHandle           OldIrq;


    IpxPrint0("PassDgToRt - Entered\n");

    //
    // Get the source port and ip address, since RT needs this information.
    //
    IpxPrint1("PassDgToRt: Index = (%d)\n", Index);
    CTEGetLock(&pRtInfo->Lock,&OldIrq);

    do
    {
        PRT_IRP pRtAF = &pRtInfo->AddFl[Index];
        if (pRtAF->State != RT_OPEN)
        {
          CTEFreeLock(&pRtInfo->Lock,OldIrq);
	  // 301920
	  status = STATUS_UNSUCCESSFUL; 
          break;
        }
        IpxReferenceRt(pRtInfo, RT_BUFF);
        if (IsListEmpty(&pRtAF->RcvIrpList))
        {
            IpxPrint0("PassDgToRt: No Rcv Irp\n");
            if (pRtInfo->RcvMemoryAllocated < pRtInfo->RcvMemoryMax)
            {
                PRTRCV_BUFFER    pBuffer;

                pBuffer = RtAllocMem(uNumBytes + sizeof(RTRCV_BUFFER));
                if (pBuffer)
                {
                    pBuffer->TotalAllocSize = uNumBytes + sizeof(RTRCV_BUFFER);

                    //
                    // Copy the user data
                    //
                    RtlCopyMemory(
                      (PUCHAR)((PUCHAR)pBuffer + OFFSET_PKT_IN_RCVBUFF),
                                (PVOID)pDgrm,uNumBytes);


                    pBuffer->Options.DgrmOptions.LocalTarget.NicId =
                             pContext->DgrmOptions.LocalTarget.NicId;
                    pBuffer->Options.LengthOfExtraOpInfo = 0;

                    //
                    // total amount allocated for user
                    //
                    pBuffer->UserBufferLengthToPass = uNumBytes + OFFSET_PKT_IN_OPTIONS;

                    CTEAssert(pContext->DgrmOptions.LocalTarget.NicId);
                    IpxPrint2("PassDgToRt: Nic Id is (%d). BufferLength is (%lx)\n", pContext->DgrmOptions.LocalTarget.NicId, uNumBytes);



                    //
                    // Keep track of the total amount buffered so that we don't
                    // eat up all non-paged pool buffering for RT
                    //
                    pRtInfo->RcvMemoryAllocated += pBuffer->TotalAllocSize;

                    IpxPrint0("IpxRt;Buffering Rt Rcv - no Irp, status=%X\n");
                    InsertTailList(&pRtAF->RcvList,&pBuffer->Linkage);
                    IpxPrint0("PassDgToRt: Buffer Queued\n");
                    status = STATUS_SUCCESS;
                }
                else
                {
                  IpxPrint0("PassDgToRt; Could not allocate buffer\n");
                  status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            else
            {
                // this ret status will allow netbt to process the packet.
                //
                IpxPrint0("PassDgToRt; Dropping Pkt\n");
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
            CTEFreeLock(&pRtInfo->Lock,OldIrq);
        }
        else
        {
            PMDL    pMdl;
            ULONG   CopyLength;
            ULONG   DgrmLength;
            ULONG   MdlBufferLength;
            ULONG   BytesToCopy;
            PLIST_ENTRY pLE;

            //
            // The recv irp is here so copy the data to its buffer and
            // pass it up to RT
            //
            pLE = RemoveHeadList(&pRtAF->RcvIrpList);
            pIrp = CONTAINING_RECORD(pLE, IRP, Tail.Overlay.ListEntry);

            (*(REQUEST_LINKAGE(pIrp))).Flink = NULL;
            (*(REQUEST_LINKAGE(pIrp))).Blink = NULL;

            //
            // Copy the datagram and the source address to RT buffer and
            // return to RT
            //
            pMdl = pIrp->MdlAddress;
            IpxPrint2("PassDgToRt: Irp=(%lx); Mdl=(%lx)\n", pIrp, pMdl);
            CTEAssert(pMdl);

            pRtBuffer = MmGetSystemAddressForMdlSafe(pIrp->MdlAddress, NormalPagePriority);
	    if (!pRtBuffer) {
	       CopyLength = 0; 
	       status = STATUS_INSUFFICIENT_RESOURCES; 
	    } else {

	       MdlBufferLength = MmGetMdlByteCount(pMdl);
	       DgrmLength  = uNumBytes;
	       BytesToCopy = DgrmLength + OFFSET_PKT_IN_OPTIONS;

	       CopyLength = (BytesToCopy <= MdlBufferLength) ? BytesToCopy : MdlBufferLength;
	       IpxPrint2("PassDgToRt: Copy Length = (%d); Mdl Buffer Length is (%d)\n", CopyLength, MdlBufferLength);

	       //
	       // Copy user datagram into pRtBuffer
	       //
	       RtlCopyMemory((PVOID)((PUCHAR)pRtBuffer + OFFSET_PKT_IN_OPTIONS),
			     (PVOID)pDgrm,
			     CopyLength-OFFSET_PKT_IN_OPTIONS);

	       IpxPrint1("Data copied is (%.12s)\n", (PUCHAR)((PUCHAR)pRtBuffer + OFFSET_PKT_IN_OPTIONS + sizeof(IPX_HEADER)));

	       pRtBuffer->DgrmOptions.LocalTarget.NicId       = pContext->DgrmOptions.LocalTarget.NicId;
	       pRtBuffer->LengthOfExtraOpInfo       = 0;

	       IpxPrint3("PassDgToRt: Copy to RcvIrp;Nic Id is (%d/%d). BufferLength is (%lx)\n", pContext->DgrmOptions.LocalTarget.NicId, pRtBuffer->DgrmOptions.LocalTarget.NicId, uNumBytes);


	       // CTEAssert(pContext->DgrmOptions.LocalTarget.NicId);

	       //
	       // pass the irp up to RT
	       //
	       if (CopyLength < BytesToCopy)
	       {
		  status = STATUS_BUFFER_OVERFLOW;
	       }
	       else
	       {
		  status = STATUS_SUCCESS;
	       }
	    }

	    InsertTailList(&pRtInfo->CompletedIrps, REQUEST_LINKAGE(pIrp));
	    pRtAF->NoOfRcvIrps--;
	    IpxPrint4("PassDgToRt;Returning Rt Rcv Irp - data from net, Length=%X,pIrp=%X; status = (%d). NoOfRcvIrp = (%d)\n"  ,uNumBytes,pIrp, status, pRtAF->NoOfRcvIrps);

	    pIrp->IoStatus.Status      = status;
	    pIrp->IoStatus.Information = CopyLength;
	    CTEFreeLock(&pRtInfo->Lock,OldIrq);

        }
        IpxDereferenceRt(pRtInfo, RT_BUFF);
  } while (FALSE);


    IpxPrint0("PassDgToRt - Entered\n");
    return(status);

}

//----------------------------------------------------------------------------
VOID
RtIrpCancel(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
/*++

Routine Description;

    This routine handles the cancelling a RtRcv Irp. It must release the
    cancel spin lock before returning re; IoCancelIrp().

Arguments;


Return Value;

    The final status from the operation.

--*/
{
    KIRQL                OldIrq;
    PRT_INFO           pRt;
    PDEVICE  pDevice = IpxDevice;

#ifdef SUNDOWN
    ULONG_PTR Index;
#else
    ULONG    Index;
#endif

    PIRP pTmpIrp;

    IpxPrint0("RtIrpCancel;Got a Rt Irp Cancel !!! *****************\n");

    Index = RT_ADDRESS_INDEX(pIrp);
    IpxPrint1("RtIrpCancel: Index = (%d)\n", Index);
    // pRt = (PRT_INFO)REQUEST_OPEN_CONTEXT(pIrp);
    pRt = pRtInfo;

    IoReleaseCancelSpinLock(pIrp->CancelIrql);
    if ((pRt->Type != IPX_RT_SIGNATURE) || (pRt->Size != sizeof(RT_INFO))) {
        return;
    }


    //
    // Be sure that PassNamePduToRt has not taken the RcvIrp for a
    // Rcv just now.
    //
    CTEGetLock(&pRt->Lock,&OldIrq);
    if (pRt && (pRt == pRtInfo) && (*(REQUEST_LINKAGE(pIrp))).Flink != NULL)
    {

        PRT_IRP pRtAF = &pRt->AddFl[Index];

        RemoveEntryList(REQUEST_LINKAGE(pIrp));

        pIrp->IoStatus.Status = STATUS_CANCELLED;
        pRtAF->NoOfRcvIrps--;
        CTEFreeLock(&pRt->Lock,OldIrq);
        IpxPrint1("RtIrpCancel;Completing Request. NoOfRcvIrp = (%d)\n", pRtAF->NoOfRcvIrps);
        IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);
    } else {
        CTEFreeLock(&pRt->Lock,OldIrq);
    }
}
//----------------------------------------------------------------------------
PVOID
RtAllocMem(
    IN  ULONG   Size
    )

/*++
Routine Description;

    This Routine handles allocating memory and keeping track of how
    much has been allocated.

Arguments;

    Size    - number of bytes to allocate
    Rcv     - boolean that indicates if it is rcv or send buffering

Return Value;

    ptr to the memory allocated

--*/

{
        if (pRtInfo->RcvMemoryAllocated > pRtInfo->RcvMemoryMax)
        {
            return NULL;
        }
        else
        {
            pRtInfo->RcvMemoryAllocated += Size;
            return (AllocMem(Size));
        }
}
//----------------------------------------------------------------------------
VOID
RtFreeMem(
    IN  PVOID   pBuffer,
    IN  ULONG   Size
    )

/*++
Routine Description;

    This Routine handles freeing memory and keeping track of how
    much has been allocated.

Arguments;

    pBuffer - buffer to free
    Size    - number of bytes to allocate
    Rcv     - boolean that indicates if it is rcv or send buffering

Return Value;

    none

--*/

{
    if (pRtInfo)
    {
            pRtInfo->RcvMemoryAllocated -= Size;
    }

    FreeMem(pBuffer, Size);
}



//----------------------------------------------------------------------------

VOID
NTIoComplete(
    IN  PIRP            pIrp,
    IN  NTSTATUS        Status,
    IN  ULONG           SentLength)

/*++
Routine Description;

    This Routine handles calling the NT I/O system to complete an I/O.

Arguments;

    status - a completion status for the Irp

Return Value;

    NTSTATUS - status of the request

--*/

{
    KIRQL   OldIrq;

   if (Status != -1)
   {
       pIrp->IoStatus.Status = Status;
   }
    // use -1 as a flag to mean do not adjust the sent length since it is
    // already set
    if (SentLength != -1)
    {
        pIrp->IoStatus.Information = SentLength;
    }

#if DBG
    if (SentLength != -1)
    {
    if ( (Status != STATUS_SUCCESS) &&
         (Status != STATUS_PENDING) &&
         (Status != STATUS_INVALID_DEVICE_REQUEST) &&
         (Status != STATUS_INVALID_PARAMETER) &&
         (Status != STATUS_IO_TIMEOUT) &&
         (Status != STATUS_BUFFER_OVERFLOW) &&
         (Status != STATUS_BUFFER_TOO_SMALL) &&
         (Status != STATUS_INVALID_HANDLE) &&
         (Status != STATUS_INSUFFICIENT_RESOURCES) &&
         (Status != STATUS_CANCELLED) &&
         (Status != STATUS_DUPLICATE_NAME) &&
         (Status != STATUS_TOO_MANY_NAMES) &&
         (Status != STATUS_TOO_MANY_SESSIONS) &&
         (Status != STATUS_REMOTE_NOT_LISTENING) &&
         (Status != STATUS_BAD_NETWORK_PATH) &&
         (Status != STATUS_HOST_UNREACHABLE) &&
         (Status != STATUS_CONNECTION_REFUSED) &&
         (Status != STATUS_WORKING_SET_QUOTA) &&
         (Status != STATUS_REMOTE_DISCONNECT) &&
         (Status != STATUS_LOCAL_DISCONNECT) &&
         (Status != STATUS_LINK_FAILED) &&
         (Status != STATUS_SHARING_VIOLATION) &&
         (Status != STATUS_UNSUCCESSFUL) &&
         (Status != STATUS_ACCESS_VIOLATION) &&
         (Status != STATUS_NONEXISTENT_EA_ENTRY) )
    {
        IpxPrint1("returning unusual status = %X\n",Status);
    }
   }
#endif
    IpxPrint1("Irp Status is %d\n", pIrp->IoStatus.Status);

    //
    // set the Irps cancel routine to null or the system may bugcheck
    // with a bug code of CANCEL_STATE_IN_COMPLETED_IRP
    //
    // refer to IoCancelIrp()  ..\ntos\io\iosubs.c
    //
    IoAcquireCancelSpinLock(&OldIrq);
    IoSetCancelRoutine(pIrp,NULL);
    IoReleaseCancelSpinLock(OldIrq);

    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
}


//----------------------------------------------------------------------------
NTSTATUS
NTCheckSetCancelRoutine(
    IN  PIRP            pIrp,
    IN  PVOID           CancelRoutine,
    IN  PDEVICE  pDevice
    )

/*++
Routine Description;

    This Routine sets the cancel routine for an Irp.

Arguments;

    status - a completion status for the Irp

Return Value;

    NTSTATUS - status of the request

--*/

{
    NTSTATUS status;

    IpxPrint1("CheckSetCancelRoutine: Entered. Irp = (%lx)\n", pIrp);
    //
    // Check if the irp was cancelled yet and if not, then set the
    // irp cancel routine.
    //
    IoAcquireCancelSpinLock(&pIrp->CancelIrql);
    if (pIrp->Cancel)
    {
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        status = STATUS_CANCELLED;

    }
    else
    {
        // setup the cancel routine
        IoMarkIrpPending(pIrp);
        IoSetCancelRoutine(pIrp,CancelRoutine);
        status = STATUS_SUCCESS;
    }

    IoReleaseCancelSpinLock(pIrp->CancelIrql);
    return(status);

}




VOID
IpxRefRt(
     PRT_INFO pRt
    )

/*++

Routine Description;

    This routine increments the reference count on a device context.

Arguments;

    Binding - Pointer to a transport device context object.

Return Value;

    none.

--*/

{

    (VOID)InterlockedIncrement (&pRt->ReferenceCount);
//    CTEAssert (pRt->ReferenceCount > 0);    // not perfect, but...
//    IpxPrint1("RefRt: RefCount is (%d)\n", pRt->ReferenceCount);

}   /* IpxRefRt */


VOID
IpxDerefRt(
     PRT_INFO pRt
    )

/*++

Routine Description;

    This routine dereferences a device context by decrementing the
    reference count contained in the structure.  Currently, we don't
    do anything special when the reference count drops to zero, but
    we could dynamically unload stuff then.

Arguments;

    Binding - Pointer to a transport device context object.

Return Value;

    none.

--*/

{
    LONG result;

    result = InterlockedDecrement (&pRt->ReferenceCount);
//    IpxPrint1("DerefRt: RefCount is (%d)\n", pRt->ReferenceCount);

//    CTEAssert (result >= 0);

#if 0
    if (result == 0) {
        IpxDestroyRt (pRt);
    }
#endif

}   /* IpxDerefRt */




VOID
IpxDestroyRt(
    IN PRT_INFO pRt
    )

/*++

Routine Description;

    This routine destroys a binding structure.

Arguments;

    Binding - Pointer to a transport binding structure.

Return Value;

    None.

--*/

{
    IpxPrint0("Destroying Rt\n");
    FreeMem (pRt, sizeof(RT_INFO));
    pRtInfo = NULL;
    return;
}   /* IpxDestroyRt */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipxroute\utils.h ===
/*******************************************************************/
/*	      Copyright(c)  1993 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	utils.h
//
// Description: Contains miscellaneous utilities
//
// Author:	Stefan Solomon (stefans)    October 4, 1993.
//
// Revision History:
//
//***

#ifndef _UTILS_
#define _UTILS_

/*
 * The following macros deal with on-the-wire short and long values
 *
 * On the wire format is big-endian i.e. a long value of 0x01020304 is
 * represented as 01 02 03 04.
 * Similarly a short value of 0x0102 is represented as 01 02.
 *
 * The host format is not assumed since it will vary from processor to
 * processor.
 */

// Get a short from on-the-wire format to a USHORT in the host format
#define GETSHORT2USHORT(DstPtr, SrcPtr)	\
		*(PUSHORT)(DstPtr) = ((*((PUCHAR)(SrcPtr)+0) << 8) +	\
					  (*((PUCHAR)(SrcPtr)+1)		))

// Get a long from on-the-wire format to a ULONG in the host format
#define GETLONG2ULONG(DstPtr, SrcPtr)	\
		*(PULONG)(DstPtr) = ((*((PUCHAR)(SrcPtr)+0) << 24) + \
					  (*((PUCHAR)(SrcPtr)+1) << 16) + \
					  (*((PUCHAR)(SrcPtr)+2) << 8)	+ \
					  (*((PUCHAR)(SrcPtr)+3)	))

// Put a USHORT from the host format to a short to on-the-wire format
#define PUTUSHORT2SHORT(DstPtr, Src)   \
		*((PUCHAR)(DstPtr)+0) = (UCHAR) ((USHORT)(Src) >> 8), \
		*((PUCHAR)(DstPtr)+1) = (UCHAR)(Src)

// Put a ULONG from the host format to an array of 4 UCHARs on-the-wire format
#define PUTULONG2LONG(DstPtr, Src)   \
		*((PUCHAR)(DstPtr)+0) = (UCHAR) ((ULONG)(Src) >> 24), \
		*((PUCHAR)(DstPtr)+1) = (UCHAR) ((ULONG)(Src) >> 16), \
		*((PUCHAR)(DstPtr)+2) = (UCHAR) ((ULONG)(Src) >>	8), \
		*((PUCHAR)(DstPtr)+3) = (UCHAR) (Src)

#endif	// _UTILS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipxroute\makefile.inc ===
IPX_BASENAME = $(TARGETNAME).exe

NLINKEXENAME = obj\$(TARGET_DIRECTORY)\$(IPX_BASENAME)

NLINKBINNAME = $(SDK_LIB_PATH)\$(IPX_BASENAME)

$(NLINKBINNAME): $(NLINKEXENAME)
    copy $(NLINKEXENAME) $(NLINKBINNAME)

ipxroute.rc: ipxrtmsg.rc msg00001.bin

ipxrtmsg.h ipxrtmsg.rc msg00001.bin: ipxrtmsg.mc
    mc -v ipxrtmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\kdext\cteext.h ===
#if !defined( _INCLUDED_CTEEXT_H_ )
#define _INCLUDED_CTEEXT_H_ 

VOID
DumpCTELock
( 
    ULONG LockToDump,
    VERBOSITY Verbosity
);

VOID 
DumpCTETimer
(
    ULONG TimerToDump,
    VERBOSITY Verbosity
);

VOID 
DumpWorkQueueItem
(
    ULONG ItemToDump,
    VERBOSITY Verbosity
);


VOID
DumpMdlChain
( 
    ULONG MdlToDump,
    VERBOSITY Verbosity
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipx\send.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    send.c

Abstract:

    This module contains code that implements the send engine for the
    IPX transport provider.

Environment:

    Kernel mode

Revision History:

	Sanjay Anand (SanjayAn) - August-25-1995
	Bug Fixes - tagged [SA]
	Sanjay Anand (SanjayAn) - 22-Sept-1995
	BackFill optimization changes added under #if BACK_FILL

--*/

#include "precomp.h"
#pragma hdrstop

//
// Using the macro for performance reasons.  Should be taken out
// when NdisQueryPacket is optimized. In the near future (after PPC release)
// move this to a header file and use it at other places.
//
#define IPX_PACKET_HEAD(Pkt)     (Pkt)->Private.Head

#if 0
#define IpxGetMdlChainLength(Mdl, Length) { \
    PMDL _Mdl = (Mdl); \
    *(Length) = 0; \
    while (_Mdl) { \
        *(Length) += MmGetMdlByteCount(_Mdl); \
        _Mdl = _Mdl->Next; \
    } \
}
#endif


VOID
IpxSendComplete(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_PACKET NdisPacket,
    IN NDIS_STATUS NdisStatus
    )

/*++

Routine Description:

    This routine is called by the I/O system to indicate that a connection-
    oriented packet has been shipped and is no longer needed by the Physical
    Provider.

Arguments:

    ProtocolBindingContext - The ADAPTER structure for this binding.

    NdisPacket/RequestHandle - A pointer to the NDIS_PACKET that we sent.

    NdisStatus - the completion status of the send.

Return Value:

    none.

--*/

{

    PIPX_SEND_RESERVED Reserved = (PIPX_SEND_RESERVED)(NdisPacket->ProtocolReserved);
    PADAPTER Adapter = (PADAPTER)ProtocolBindingContext;
    PREQUEST Request;
    PADDRESS_FILE AddressFile;
    PDEVICE Device = IpxDevice;
    PBINDING Binding, pBinding= NULL;
    USHORT NewId, OldId;
    ULONG NewOffset, OldOffset;
    PIPX_HEADER IpxHeader, pIpxHeader;
    IPX_LOCAL_TARGET LocalTarget;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN         IsLoopback= FALSE;
	IPX_DEFINE_LOCK_HANDLE(LockHandle1)

#if DBG
    if (Adapter != NULL) {
        ASSERT_ADAPTER(Adapter);
    }
#endif

    //
    // See if this send was padded.
    //
RealFunctionStart:;
    if (Reserved->PaddingBuffer) {

        UINT  Offset;
        //
        // Check if we simply need to re-adjust the buffer length. This will
        // happen if we incremented the buffer length in MAC.C.
        //

        if (Reserved->PreviousTail) {
            CTEAssert (NDIS_BUFFER_LINKAGE(Reserved->PaddingBuffer->NdisBuffer) == NULL);
            NDIS_BUFFER_LINKAGE (Reserved->PreviousTail) = (PNDIS_BUFFER)NULL;
        } else {
            PNDIS_BUFFER LastBuffer = (PNDIS_BUFFER)Reserved->PaddingBuffer;
            UINT BufferLength;

            NdisQueryBufferOffset( LastBuffer, &Offset, &BufferLength );
            NdisAdjustBufferLength( LastBuffer, (BufferLength - 1) );
        }

        Reserved->PaddingBuffer = NULL;

        if (Reserved->Identifier < IDENTIFIER_IPX) {
            NdisRecalculatePacketCounts (NdisPacket);
        }
    }

FunctionStart:;

    switch (Reserved->Identifier) {

    case IDENTIFIER_IPX:

// #if DBG
        CTEAssert (Reserved->SendInProgress);
        Reserved->SendInProgress = FALSE;
// #endif

        //
        // Check if this packet should be sent to all
        // networks.
        //

        if (Reserved->u.SR_DG.CurrentNicId) {

            if (NdisStatus == NDIS_STATUS_SUCCESS) {
                Reserved->u.SR_DG.Net0SendSucceeded = TRUE;
            }

            OldId = Reserved->u.SR_DG.CurrentNicId;

			IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
            {
            ULONG   Index = MIN (Device->MaxBindings, Device->HighestExternalNicId);

            Binding = NULL; 

            for (NewId = OldId+1; NewId <= Index; NewId++) {
                if ((Binding = NIC_ID_TO_BINDING(Device, NewId))
                                &&
                    ((!Device->SingleNetworkActive) ||
                     (Device->ActiveNetworkWan == Binding->Adapter->MacInfo.MediumAsync))
                                &&
                    (Device->ForwarderBound ||
                     (!Device->DisableDialoutSap) ||
                     (!Binding->DialOutAsync) ||
                     (!Reserved->u.SR_DG.OutgoingSap))) {

                    //
                    // The binding exists, and we either are not configured
                    // for "SingleNetworkActive", or we are and this binding
                    // is the right type (i.e. the active network is wan and
                    // this is a wan binding, or the active network is not
                    // wan and this is not a wan binding), and if the FWD is
                    // not bound; and this is not an outgoing sap that we are
                    // trying to send with "DisableDialoutSap" set.
                    //

                    //
                    // 179436 - If forwarder is bound then ensure that we are picking a Binding that
                    // the forwarder has an open context on. Otherwise, go to the next good binding
                    //
                    if (Device->ForwarderBound) {
                        
                        if (GET_LONG_VALUE(Binding->ReferenceCount) == 2) {
                        
                            break;
                        }
                    } else {

                        break;

                    }

                }
            }
            }

            if (Binding != NULL && NewId <= MIN (Device->MaxBindings, Device->HighestExternalNicId)) {
				IpxReferenceBinding1(Binding, BREF_DEVICE_ACCESS);
				IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

                //
                // Yes, we found another net to send it on, so
                // move the header around if needed and do so.
                //

                Reserved->u.SR_DG.CurrentNicId = NewId;
                CTEAssert ((Reserved->DestinationType == DESTINATION_BCAST) ||
                           (Reserved->DestinationType == DESTINATION_MCAST));

#if 0
                NewOffset = Binding->BcMcHeaderSize;
                OldOffset = Device->Bindings[OldId]->BcMcHeaderSize;

                if (OldOffset != NewOffset) {

                    RtlMoveMemory(
                        &Reserved->Header[NewOffset],
                        &Reserved->Header[OldOffset],
                        sizeof(IPX_HEADER));

                }

                IpxHeader = (PIPX_HEADER)(&Reserved->Header[NewOffset]);
#endif



#if BACK_FILL
                // This should be a normal packet. Backfill packet is never used for
                // reserved other than IPX type

                CTEAssert(!Reserved->BackFill);

                // Check if this is backfilled. If so restore users Mdl back to its original shape
                // Also, push the packet on to backfillpacket queue if the packet is not owned by the address

                if (Reserved->BackFill) {

                    IPX_DEBUG(SEND, ("MSVa:%lx, UL:%d\n", Reserved->MappedSystemVa, Reserved->UserLength));

                    Reserved->HeaderBuffer->MappedSystemVa = Reserved->MappedSystemVa;
                    Reserved->HeaderBuffer->ByteCount = Reserved->UserLength;
#ifdef SUNDOWN
		    Reserved->HeaderBuffer->StartVa = (PCHAR)((ULONG_PTR)Reserved->HeaderBuffer->MappedSystemVa & ~(PAGE_SIZE-1));
		    // ByteOffset is & with 0xfff. PAGE_SIZE is unlikely to > 0x100000000, so we are save to convert to ulong.
		    Reserved->HeaderBuffer->ByteOffset = (ULONG) ((ULONG_PTR)Reserved->HeaderBuffer->MappedSystemVa & (PAGE_SIZE-1));
#else
		    Reserved->HeaderBuffer->StartVa = (PCHAR)((ULONG)Reserved->HeaderBuffer->MappedSystemVa & ~(PAGE_SIZE-1));
		    Reserved->HeaderBuffer->ByteOffset = (ULONG)Reserved->HeaderBuffer->MappedSystemVa & (PAGE_SIZE-1);
#endif

                    IPX_DEBUG(SEND, ("completeing back filled userMdl %x\n",Reserved->HeaderBuffer));

                    Reserved->HeaderBuffer->ByteOffset -= sizeof(IPX_HEADER);
#ifdef SUNDOWN
		    (ULONG_PTR)Reserved->HeaderBuffer->MappedSystemVa-= sizeof(IPX_HEADER);
#else
		    (ULONG)Reserved->HeaderBuffer->MappedSystemVa-= sizeof(IPX_HEADER);
#endif

            ASSERT((LONG)Reserved->HeaderBuffer->ByteOffset >= 0); 

                    NdisAdjustBufferLength(Reserved->HeaderBuffer, (Reserved->HeaderBuffer->ByteCount+sizeof(IPX_HEADER)));
                    
                    IPX_DEBUG(SEND, ("Adjusting backfill userMdl Ipxheader %x RESD : %x\n",Reserved->HeaderBuffer, Reserved));

                }
#endif

                IpxHeader = (PIPX_HEADER)(&Reserved->Header[MAC_HEADER_SIZE]);

				FILL_LOCAL_TARGET(&LocalTarget, NewId);
                RtlCopyMemory(LocalTarget.MacAddress, IpxHeader->DestinationNode, 6);

                if (Device->MultiCardZeroVirtual ||
                    (IpxHeader->DestinationSocket == SAP_SOCKET)) {

                    //
                    // SAP frames need to look like they come from the
                    // local network, not the virtual one. The same is
                    // true if we are running multiple nets without
                    // a virtual net.
                    //

                    *(UNALIGNED ULONG *)IpxHeader->SourceNetwork = Binding->LocalAddress.NetworkAddress;
                    RtlCopyMemory (IpxHeader->SourceNode, Binding->LocalAddress.NodeAddress, 6);
                }

                //
                // Fill in the MAC header and submit the frame to NDIS.
                //

// #if DBG
                CTEAssert (!Reserved->SendInProgress);
                Reserved->SendInProgress = TRUE;
// #endif

                //
                // [FW] Call the InternalSendHandler of the Forwarder
                //

                if (Device->ForwarderBound) {

                    //
                    // Call the InternalSend to filter the packet and get to know
                    // the correct adapter context
                    //

                    NTSTATUS  ret;
                    PUCHAR IpxHeader;
                    PUCHAR Data;
                    PNDIS_BUFFER HeaderBuffer;
                    UINT TempHeaderBufferLength;
                    UINT DataLength;
		    #ifdef SUNDOWN
		      ULONG_PTR   FwdAdapterCtx = INVALID_CONTEXT_VALUE;
		    #else
		      ULONG   FwdAdapterCtx = INVALID_CONTEXT_VALUE;
		    #endif
		    


                    if (GET_LONG_VALUE(Binding->ReferenceCount) == 2) {
                        FwdAdapterCtx = Binding->FwdAdapterContext;
                    }

                    //
                    // Figure out the IpxHeader - it is always at the top of the second MDL.
                    //
                    NdisQueryPacket (NdisPacket, NULL, NULL, &HeaderBuffer, NULL);
                    NdisQueryBufferSafe (NDIS_BUFFER_LINKAGE(HeaderBuffer), &IpxHeader, &TempHeaderBufferLength, HighPagePriority);

                    //
                    // Data is always at the top of the third MDL.
                    //
                    NdisQueryBufferSafe (NDIS_BUFFER_LINKAGE(NDIS_BUFFER_LINKAGE(HeaderBuffer)), &Data, &DataLength, HighPagePriority);

		    if (IpxHeader != NULL && Data != NULL) {
#ifdef SUNDOWN
		       // upper driver interface needs ULONG
		       ret = (*Device->UpperDrivers[IDENTIFIER_RIP].InternalSendHandler)(
			      &LocalTarget,
                              FwdAdapterCtx,
                              NdisPacket,
                              IpxHeader,
                              Data,
                              (ULONG) (REQUEST_INFORMATION(Reserved->u.SR_DG.Request)) + sizeof(IPX_HEADER),
                              FALSE);
#else
		       ret = (*Device->UpperDrivers[IDENTIFIER_RIP].InternalSendHandler)(
                              &LocalTarget,
                              FwdAdapterCtx,
                              NdisPacket,
                              IpxHeader,
                              Data,
                              REQUEST_INFORMATION(Reserved->u.SR_DG.Request) + sizeof(IPX_HEADER),
                              FALSE);
#endif

 

		     //
		     // The return shd not be a silent drop - we dont broadcast keepalives.
		     //
		       CTEAssert(ret != STATUS_DROP_SILENTLY);

		       if (ret == STATUS_SUCCESS) {
                        //
                        // The adapter could have gone away and we have indicated to the Forwarder
                        // but the Forwarder has not yet closed the adapter.
                        // [ZZ] adapters do not go away now.
                        //
                        // what if the binding is NULL here? Can we trust the Forwarder to
                        // give us a non-NULL binding?
                        //
			  Binding = NIC_ID_TO_BINDING(Device, NIC_FROM_LOCAL_TARGET(&LocalTarget));

              NewId = NIC_FROM_LOCAL_TARGET(&LocalTarget);
			  if (Binding == NULL || GET_LONG_VALUE(Binding->ReferenceCount) == 1) {
			     Adapter = Binding->Adapter;
			     IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
                 FILL_LOCAL_TARGET(&Reserved->LocalTarget, NewId);
			     goto FunctionStart;
			  } else {
			     goto send_packet;
			  }

		       } else if (ret == STATUS_PENDING) {
			  //
			  // LocalTarget will get filled up in InternalSendComplete
			  //
			  return;
		       }
		    }
                    //
                    // else DISCARD
                    //
                    Adapter = Binding->Adapter;
                    IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
                    goto FunctionStart;

                } else {
send_packet:
                    //
                    // [FW] Use the frametype specific send handler
                    //

                    // if ((NdisStatus = IpxSendFrame(
                    //         &LocalTarget,
                    //         NdisPacket,
                    //         REQUEST_INFORMATION(Reserved->u.SR_DG.Request) + sizeof(IPX_HEADER),
                    //         sizeof(IPX_HEADER))) != NDIS_STATUS_PENDING) {
                    //
                    //       Adapter = Binding->Adapter;
                    //       goto FunctionStart;
                    // }
                    //
                    // return;


                    if ((IPX_NODE_EQUAL(IpxHeader->SourceNode, IpxHeader->DestinationNode)) && 
                        (*(UNALIGNED ULONG *)IpxHeader->SourceNetwork == *(UNALIGNED ULONG *)IpxHeader->DestinationNetwork)) {
                
                        IPX_DEBUG(TEMP, ("It is self-directed. Loop it back ourselves (tdisenddatagram)\n"));
                        IsLoopback = TRUE;
            
                    }

                    pBinding = NIC_ID_TO_BINDING(Device, Reserved->LocalTarget.NicId);

                    if (pBinding) {
             
                        if ((IPX_NODE_EQUAL(Reserved->LocalTarget.MacAddress, pBinding->LocalAddress.NodeAddress)) ||
                            (IPX_NODE_EQUAL(pBinding->LocalAddress.NodeAddress, IpxHeader->DestinationNode))) {
            
                            IPX_DEBUG(TEMP, ("Source Net:%lx, Source Address: %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x\n",
                                             *(UNALIGNED ULONG *)IpxHeader->SourceNetwork, 
                                             IpxHeader->SourceNode[0], 
                                             IpxHeader->SourceNode[1], 
                                             IpxHeader->SourceNode[2], 
                                             IpxHeader->SourceNode[3], 
                                             IpxHeader->SourceNode[4], 
                                             IpxHeader->SourceNode[5]));
                
                            IPX_DEBUG(TEMP, ("Dest Net:%lx, DestAddress: %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x \n", 
                                             *(UNALIGNED ULONG *)IpxHeader->DestinationNetwork,
                                             IpxHeader->DestinationNode[0],
                                             IpxHeader->DestinationNode[1],
                                             IpxHeader->DestinationNode[2],
                                             IpxHeader->DestinationNode[3],
                                             IpxHeader->DestinationNode[4],
                                             IpxHeader->DestinationNode[5]
                                             ));

                            IPX_DEBUG(TEMP, ("Well, It is self-directed. Loop it back ourselves (TDISENDDATAGRAM - NIC_HANDLE is the same!)\n"));
                            IsLoopback = TRUE;
            
                        } 
                    }

                    IPX_DEBUG(TEMP, ("Sending a packet now Loopback - %x\n", IsLoopback));
                    
                    if (IsLoopback) {
                        //
                        // Enque this packet to the LoopbackQueue on the binding.
                        // If the LoopbackRtn is not already scheduled, schedule it.
                        //

                        IPX_DEBUG(LOOPB, ("Packet: %lx\n", NdisPacket));

                        //
                        // Recalculate packet counts here.
                        //
                        // NdisAdjustBufferLength (Reserved->HeaderBuffer, 17);
#if BACK_FILL

                        if (Reserved->BackFill) {
                            //
                            // Set the Header pointer and chain the first MDL
                            //
                            Reserved->Header = (PCHAR)Reserved->HeaderBuffer->MappedSystemVa;
                            NdisChainBufferAtFront(NdisPacket,(PNDIS_BUFFER)Reserved->HeaderBuffer);
                        }
#endif
                        NdisRecalculatePacketCounts (NdisPacket);
                        IpxLoopbackEnque(NdisPacket, NIC_ID_TO_BINDING(Device, 1)->Adapter);
                        
                        IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
                        return;

                    } else {
#ifdef SUNDOWN

                        if ((NdisStatus = (*Binding->SendFrameHandler)(
                                                                       Binding->Adapter,
                                                                       &LocalTarget,
                                                                       NdisPacket,
                                                                       (ULONG) (REQUEST_INFORMATION(Reserved->u.SR_DG.Request)) + sizeof(IPX_HEADER),
                                                                       sizeof(IPX_HEADER))) != NDIS_STATUS_PENDING) 
#else

                        if ((NdisStatus = (*Binding->SendFrameHandler)(
                                                                       Binding->Adapter,
                                                                       &LocalTarget,
                                                                       NdisPacket,
                                                                       REQUEST_INFORMATION(Reserved->u.SR_DG.Request) + sizeof(IPX_HEADER),
                                                                       sizeof(IPX_HEADER))) != NDIS_STATUS_PENDING) 
#endif

						{
                            Adapter = Binding->Adapter;
                            IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
                            goto RealFunctionStart;
                        }
                        IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
                        return;
                    }
                }
            } else {
	     		
                IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
                //
                // If any of the sends succeeded then return
                // success on the datagram send, otherwise
                // use the most recent failure status.
                //
                
                if (Reserved->u.SR_DG.Net0SendSucceeded) {
                    NdisStatus = NDIS_STATUS_SUCCESS;
                }
                
            }

        }

#if 0
        //
        // NOTE: We don't NULL out the linkage field of the
        // HeaderBuffer, which will leave the old buffer chain
        // hanging off it; but that is OK because if we reuse
        // this packet we will replace that chain with the new
        // one, and before we free it we NULL it out.
        //
        // I.e. we don't do this:
        //

        NDIS_BUFFER_LINKAGE (Reserved->HeaderBuffer) = NULL;
        NdisRecalculatePacketCounts (NdisPacket);
#endif

#if 0
        {
            ULONG ActualLength;
            IpxGetMdlChainLength(NDIS_BUFFER_LINKAGE(Reserved->HeaderBuffer), &ActualLength);
            if (ActualLength != REQUEST_INFORMATION(Reserved->u.SR_DG.Request)) {
                DbgPrint ("IPX: At completion, IRP %lx has parameter length %d, buffer chain length %d\n",
                        Reserved->u.SR_DG.Request, REQUEST_INFORMATION(Reserved->u.SR_DG.Request), ActualLength);
                DbgBreakPoint();
            }
        }
#endif

        //
        // Save these so we can free the packet.
        //

        Request = Reserved->u.SR_DG.Request;
        AddressFile = Reserved->u.SR_DG.AddressFile;


#if BACK_FILL
        // Check if this is backfilled. If so restore users Mdl back to its original shape
        // Also, push the packet on to backfillpacket queue if the packet is not owned by the address


        if (Reserved->BackFill) {

                                
            IPX_DEBUG(SEND, ("MSVa:%lx, UL:%d\n", Reserved->MappedSystemVa, Reserved->UserLength));
            
            Reserved->HeaderBuffer->MappedSystemVa = Reserved->MappedSystemVa;
            Reserved->HeaderBuffer->ByteCount = Reserved->UserLength;
#ifdef SUNDOWN
	    Reserved->HeaderBuffer->StartVa = (PCHAR)((ULONG_PTR)Reserved->HeaderBuffer->MappedSystemVa & ~(PAGE_SIZE-1));
	    Reserved->HeaderBuffer->ByteOffset = (ULONG) ((ULONG_PTR)Reserved->HeaderBuffer->MappedSystemVa & (PAGE_SIZE-1));
#else
	    Reserved->HeaderBuffer->StartVa = (PCHAR)((ULONG)Reserved->HeaderBuffer->MappedSystemVa & ~(PAGE_SIZE-1));
	    Reserved->HeaderBuffer->ByteOffset = (ULONG)Reserved->HeaderBuffer->MappedSystemVa & (PAGE_SIZE-1);
#endif

            ASSERT((LONG)Reserved->HeaderBuffer->ByteOffset >= 0); 

            IPX_DEBUG(SEND, ("completeing back filled userMdl %x\n",Reserved->HeaderBuffer));



            NdisPacket->Private.ValidCounts = FALSE;
            
            NdisPacket->Private.Head = NULL;
            NdisPacket->Private.Tail = NULL;
            Reserved->HeaderBuffer = NULL;

            if (Reserved->OwnedByAddress) {

                // Reserved->Address->BackFillPacketInUse = FALSE;
                InterlockedDecrement(&Reserved->Address->BackFillPacketInUse);

                IPX_DEBUG(SEND, ("Freeing owned backfill %x\n", Reserved));

            } else {

                IPX_PUSH_ENTRY_LIST(
                                    &Device->BackFillPacketList,
                                    &Reserved->PoolLinkage,
                                    &Device->SListsLock);
            }
        }
        // not a back fill packet. Push it on sendpacket pool
        else {

            if (Reserved->OwnedByAddress) {

                // Reserved->Address->SendPacketInUse = FALSE;
                InterlockedDecrement(&Reserved->Address->SendPacketInUse);

            } else {

                IPX_PUSH_ENTRY_LIST(
                                    &Device->SendPacketList,
                                    &Reserved->PoolLinkage,
                                    &Device->SListsLock);

            }


        }

#else

        if (Reserved->OwnedByAddress) {


            Reserved->Address->SendPacketInUse = FALSE;

        } else {

            IPX_PUSH_ENTRY_LIST(
                &Device->SendPacketList,
                &Reserved->PoolLinkage,
                &Device->SListsLock);

        }
#endif

        ++Device->Statistics.PacketsSent;

        //
        // If this is a fast send irp, we bypass the file system and
        // call the completion routine directly.
        //

        REQUEST_STATUS(Request) = NdisStatus;
        irpSp = IoGetCurrentIrpStackLocation( Request );

        if ( irpSp->MinorFunction == TDI_DIRECT_SEND_DATAGRAM ) {

            Request->CurrentLocation++,
            Request->Tail.Overlay.CurrentStackLocation++;

            (VOID) irpSp->CompletionRoutine(
                                        NULL,
                                        Request,
                                        irpSp->Context
                                        );

        } else {
            IpxCompleteRequest (Request);
        }

        IpxFreeRequest(Device, Request);

        IpxDereferenceAddressFileSync (AddressFile, AFREF_SEND_DGRAM);

        break;

    case IDENTIFIER_RIP_INTERNAL:

        CTEAssert (Reserved->SendInProgress);
        Reserved->SendInProgress = FALSE;
        break;

    case IDENTIFIER_RIP_RESPONSE:

        CTEAssert (Reserved->SendInProgress);
        Reserved->SendInProgress = FALSE;

        Reserved->Identifier = IDENTIFIER_IPX;
        IPX_PUSH_ENTRY_LIST(
            &Device->SendPacketList,
            &Reserved->PoolLinkage,
            &Device->SListsLock);

        IpxDereferenceDevice (Device, DREF_RIP_PACKET);
        break;

	case IDENTIFIER_NB:
	case IDENTIFIER_SPX:

		//
		// See if this is an iterative send
		//
	 if (OldId = Reserved->CurrentNicId) {

	    PNDIS_BUFFER HeaderBuffer;
	    UINT TempHeaderBufferLength;
	    PUCHAR Header;
	    PIPX_HEADER IpxHeader;
	    BOOLEAN     fFwdDecides=FALSE;

            
	    if (NdisStatus == NDIS_STATUS_SUCCESS) {
	       Reserved->Net0SendSucceeded = TRUE;
	    }

            //
            // Figure out the IpxHeader - it is always at the top of the second MDL.
            //
            NdisQueryPacket (NdisPacket, NULL, NULL, &HeaderBuffer, NULL);
            NdisQueryBufferSafe (NDIS_BUFFER_LINKAGE(HeaderBuffer), &IpxHeader, &TempHeaderBufferLength, HighPagePriority);

	    if (IpxHeader == NULL) {
	       DbgPrint("IpxSendComplete: NdisQuerryBufferSafe failed. Stop iterative send\n");
	       goto NoMoreSends; 
	    }
            //
            // For Type 20 pkts, we let the Fwd decide the next Nic to send on, so we pass
            // the old Nic itself and let the Fwd change it for us.
            //
            if ((Device->ForwarderBound) &&
                (IpxHeader->PacketType == 0x14)) {
                NewId = NIC_FROM_LOCAL_TARGET(&Reserved->LocalTarget);
                fFwdDecides=TRUE;

                Binding = NIC_ID_TO_BINDING(Device, NewId);

                //
                // 206647: It is likely that after we sent the previous packet, the binding on which we
                // sent it is gone (due to an unbindadapter or whatever). if it is Null, get the previous 
                // good NICID and pass it to the forwarder to get the next one. We should be in sync 
                // with the forwarder and so it will tell us the next logical one it thinks is right.
                // 
                //
                if (!Binding) {
                    USHORT Index = NewId;

                    while (Index-- > 0) { //using 0, since we should atleast have Loopback - nicid 1
                        if( Binding = NIC_ID_TO_BINDING(Device, Index)) {
                            //
                            // So we found something good. Let's set newid to this Index and we should
                            // be all set.
                            // 
                            NewId = Index;
                            break;
                        }
                    }
                }
                IPX_DEBUG(SEND, ("SendComplete: IpxHeader has Type20: %lx\n", IpxHeader));

            } else {

                IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                {
                ULONG   Index = MIN (Device->MaxBindings, Device->HighestExternalNicId);

                Binding = NULL; 

                for (NewId = OldId+1; NewId <= Index; NewId++) {
                    if (Binding = NIC_ID_TO_BINDING(Device, NewId)) {
    					//
    					// Found next NIC to send on
    					//
                        //
                        // 179436 - If forwarder is bound then ensure that we are picking a Binding that
                        // the forwarder has an open context on. Otherwise, go to the next good binding
                        //
                        if (Device->ForwarderBound) {
                            if (GET_LONG_VALUE(Binding->ReferenceCount) == 2) {

                                break;
                            }

                        } else {

                            break;

                        }

                    }
    			}
                }
            }

			if (Binding != NULL && NewId <= MIN (Device->MaxBindings, Device->HighestExternalNicId)) {

				IpxReferenceBinding1(Binding, BREF_DEVICE_ACCESS);
				IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

                //
                // Yes, we found another net to send it on, so
                // move the header around if needed and do so.
                //
				IPX_DEBUG(SEND, ("ISN iteration: OldId: %lx, NewId: %lx\n", OldId, NewId));
                Reserved->CurrentNicId = NewId;

				FILL_LOCAL_TARGET(&LocalTarget, NewId);
                RtlCopyMemory(LocalTarget.MacAddress, IpxHeader->DestinationNode, 6);

                //
                // [FW] Call the InternalSendHandler of the Forwarder
                //

                if (Device->ForwarderBound) {

                    //
                    // Call the InternalSend to filter the packet and get to know
                    // the correct adapter context
                    //

                    NTSTATUS  ret;
                    PUCHAR Data;
                    UINT DataLength;
		    #ifdef SUNDOWN
		       ULONG_PTR   FwdAdapterCtx = INVALID_CONTEXT_VALUE;
		    #else
		       ULONG   FwdAdapterCtx = INVALID_CONTEXT_VALUE;
		    #endif
		    


                    if (GET_LONG_VALUE(Binding->ReferenceCount) == 2) {
                        FwdAdapterCtx = Binding->FwdAdapterContext;
                    }

                    ret = (*Device->UpperDrivers[IDENTIFIER_RIP].InternalSendHandler)(
                              &LocalTarget,
                              FwdAdapterCtx,
                              NdisPacket,
                              (PUCHAR)IpxHeader,
                              ((PUCHAR)IpxHeader)+sizeof(IPX_HEADER),    // the data starts after the IPX Header.
                              Reserved->PacketLength,
                              TRUE);    // iterate is true

                    //
                    // The return shd not be a silent drop - we dont broadcast keepalives.
                    //
                    CTEAssert(ret != STATUS_DROP_SILENTLY);

                    if (ret == STATUS_SUCCESS) {
                        //
                        // The adapter could have gone away and we have indicated to the Forwarder
                        // but the Forwarder has not yet closed the adapter.
                        // [ZZ] adapters do not go away now.
                        //
                        // what if the binding is NULL here? Can we trust the Forwarder to
                        // give us a non-NULL binding?
                        //
                        Binding = NIC_ID_TO_BINDING(Device, NIC_FROM_LOCAL_TARGET(&LocalTarget));

                        NewId = NIC_FROM_LOCAL_TARGET(&LocalTarget);
                        if (Binding == NULL || GET_LONG_VALUE(Binding->ReferenceCount) == 1) {
                            if (Binding != NULL) {
                                Adapter = Binding->Adapter;
                                IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
                            }
                            FILL_LOCAL_TARGET(&Reserved->LocalTarget, NewId);
                            DbgPrint("IPX: FWD returns an invalid nic id %d, no more sends\n", NewId); 
                            goto NoMoreSends;
                        } else {
                            goto send_packet1;
                        }

                    } else if (ret == STATUS_PENDING) {
                        //
                        // LocalTarget will get filled up in InternalSendComplete
                        //
                        return;
                    }
                    //
                    // else DISCARD
                    //
                    Adapter = Binding->Adapter;
                    IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);

                    //
                    // If Fwd decides, then this is end of Nic list - complete the send.
                    //
                    if (fFwdDecides) {
                        goto NoMoreSends;
                    } else {
                        goto FunctionStart;
                    }

                } else {
#if DBG
    				NdisQueryPacket (NdisPacket, NULL, NULL, &HeaderBuffer, NULL);
    				NdisQueryBufferSafe(HeaderBuffer, &Header, &TempHeaderBufferLength, LowPagePriority);

				if (Header != NULL) {
				   IpxHeader = (PIPX_HEADER)(&Header[Device->IncludedHeaderOffset]);

				   IPX_DEBUG(SEND, ("SendComplete: IpxHeader: %lx\n", IpxHeader));
				}
#endif

send_packet1:

    				FILL_LOCAL_TARGET(&Reserved->LocalTarget, NewId);

                    if ((IPX_NODE_EQUAL(IpxHeader->SourceNode, IpxHeader->DestinationNode)) && 
                        (*(UNALIGNED ULONG *)IpxHeader->SourceNetwork == *(UNALIGNED ULONG *)IpxHeader->DestinationNetwork)) {
                
                        IPX_DEBUG(TEMP, ("It is self-directed. Loop it back ourselves (tdisenddatagram)\n"));
                        IsLoopback = TRUE;
            
                    }

                    pBinding = NIC_ID_TO_BINDING(Device, Reserved->LocalTarget.NicId);

                    if (pBinding) {
             
                        if ((IPX_NODE_EQUAL(Reserved->LocalTarget.MacAddress, pBinding->LocalAddress.NodeAddress)) ||
                            (IPX_NODE_EQUAL(pBinding->LocalAddress.NodeAddress, IpxHeader->DestinationNode))) {
            
                            IPX_DEBUG(TEMP, ("Source Net:%lx, Source Address: %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x\n",
                                             *(UNALIGNED ULONG *)IpxHeader->SourceNetwork, 
                                             IpxHeader->SourceNode[0], 
                                             IpxHeader->SourceNode[1], 
                                             IpxHeader->SourceNode[2], 
                                             IpxHeader->SourceNode[3], 
                                             IpxHeader->SourceNode[4], 
                                             IpxHeader->SourceNode[5]));
                
                            IPX_DEBUG(TEMP, ("Dest Net:%lx, DestAddress: %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x \n", 
                                             *(UNALIGNED ULONG *)IpxHeader->DestinationNetwork,
                                             IpxHeader->DestinationNode[0],
                                             IpxHeader->DestinationNode[1],
                                             IpxHeader->DestinationNode[2],
                                             IpxHeader->DestinationNode[3],
                                             IpxHeader->DestinationNode[4],
                                             IpxHeader->DestinationNode[5]
                                             ));

                            IPX_DEBUG(TEMP, ("Well, It is self-directed. Loop it back ourselves (TDISENDDATAGRAM - NIC_HANDLE is the same!)\n"));
                            IsLoopback = TRUE;
            
                        } 
                    }

                    IPX_DEBUG(TEMP, ("Sending a packet now.  Loopback?:%x\n", IsLoopback));
                    
                    if (IsLoopback) {
                        //
                        // Enque this packet to the LoopbackQueue on the binding.
                        // If the LoopbackRtn is not already scheduled, schedule it.
                        //

                        IPX_DEBUG(LOOPB, ("Packet: %lx\n", NdisPacket));

                        //
                        // Recalculate packet counts here.
                        //
                        // NdisAdjustBufferLength (Reserved->HeaderBuffer, 17);
                        NdisRecalculatePacketCounts (NdisPacket);
                        IpxLoopbackEnque(NdisPacket, NIC_ID_TO_BINDING(Device, 1)->Adapter);

                        IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
                        return;

                    } else {


                    //
                    // We don't need to so this since the macaddress is replaced in
                    // IpxSendFrame anyway. The LocalTarget is the same as the one on
                    // the original send - this is passed down for further sends.
                    //
                    // RtlCopyMemory(LocalTarget.MacAddress, IpxHeader->DestinationNode, 6);

    				//
                    // Fill in the MAC header and submit the frame to NDIS.
                    //

                    if ((NdisStatus = IpxSendFrame(
                            &Reserved->LocalTarget,
                            NdisPacket,
                            Reserved->PacketLength,
                            sizeof(IPX_HEADER))) != NDIS_STATUS_PENDING) {

                          Adapter = Binding->Adapter;
    					  IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
                          goto FunctionStart;
                    }
    				IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);

                    return;
                    }
                }
            } else {
                IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
NoMoreSends:
                //
                // If any of the sends succeeded then return
                // success on the datagram send, otherwise
                // use the most recent failure status.
                //
                if (Reserved->Net0SendSucceeded) {
                    NdisStatus = NDIS_STATUS_SUCCESS;
                }

            }
		}

		//
		// fall thru'
		//
    default:
		ASSERT((*Device->UpperDrivers[Reserved->Identifier].SendCompleteHandler) != NULL); 
		(*Device->UpperDrivers[Reserved->Identifier].SendCompleteHandler)(
			NdisPacket,
			NdisStatus);
		break;		
    }

}   /* IpxSendComplete */


NTSTATUS
IpxTdiSendDatagram(
    IN PDEVICE_OBJECT DeviceObject,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine performs the TdiSendDatagram request for the transport
    provider.

Arguments:

    Request - Pointer to the request.

Return Value:

    NTSTATUS - status of operation.

--*/

{

    PADDRESS_FILE AddressFile;
    PADDRESS Address;
    PNDIS_PACKET Packet;
    PIPX_SEND_RESERVED Reserved;
    PSLIST_ENTRY s;
    TDI_ADDRESS_IPX UNALIGNED * RemoteAddress;
    TDI_ADDRESS_IPX TempAddress;
    TA_ADDRESS * AddressName;
    PTDI_CONNECTION_INFORMATION Information;
    PTDI_REQUEST_KERNEL_SENDDG Parameters;
    PBINDING Binding, pBinding = NULL;
    IPX_LOCAL_TARGET TempLocalTarget;
    PIPX_LOCAL_TARGET LocalTarget;
    PDEVICE Device = IpxDevice;
    UCHAR PacketType;
    NTSTATUS Status;
    PIPX_HEADER IpxHeader, pIpxHeader;
    NDIS_STATUS NdisStatus;
    USHORT LengthIncludingHeader;
    IPX_DEFINE_SYNC_CONTEXT (SyncContext)
    IPX_DEFINE_LOCK_HANDLE (LockHandle)
    PIO_STACK_LOCATION irpSp;                                       \
    BOOLEAN IsLoopback = FALSE;
    IPX_FIND_ROUTE_REQUEST   routeEntry;
    PIPX_DATAGRAM_OPTIONS2 Options;
    KPROCESSOR_MODE PreviousMode;

    IPX_DEFINE_LOCK_HANDLE(LockHandle1)

#ifdef  SNMP
    ++IPX_MIB_ENTRY(Device, SysOutRequests);
#endif  SNMP



    //
    // Do a quick check of the validity of the address.
    //

    AddressFile = (PADDRESS_FILE)REQUEST_OPEN_CONTEXT(Request);

    IPX_BEGIN_SYNC (&SyncContext);

    if ((AddressFile->Size == sizeof (ADDRESS_FILE)) &&
        (AddressFile->Type == IPX_ADDRESSFILE_SIGNATURE) &&
        ((Address = AddressFile->Address) != NULL)) {

        IPX_GET_LOCK (&Address->Lock, &LockHandle);

        if (AddressFile->State != ADDRESSFILE_STATE_CLOSING) {
            
            Parameters = (PTDI_REQUEST_KERNEL_SENDDG)REQUEST_PARAMETERS(Request);

                //
                // Previously it was kmode, so things are trusted.
                //
                Information = Parameters->SendDatagramInformation;

                if (!REQUEST_SPECIAL_SEND(Request)) {
                    AddressName = &((TRANSPORT_ADDRESS UNALIGNED *)(Information->RemoteAddress))->Address[0];

                    if ((AddressName->AddressType == TDI_ADDRESS_TYPE_IPX) &&
                        (AddressName->AddressLength >= sizeof(TDI_ADDRESS_IPX))) {

                        RemoteAddress = (TDI_ADDRESS_IPX UNALIGNED *)(AddressName->Address);

                    } else if ((RemoteAddress = IpxParseTdiAddress (Information->RemoteAddress)) == NULL) {

                        IPX_FREE_LOCK (&Address->Lock, LockHandle);
                        Status = STATUS_INVALID_ADDRESS;
#ifdef  SNMP
                        ++IPX_MIB_ENTRY(Device, SysOutDiscards);
#endif  SNMP
                        goto error_send_no_packet;
                    }
                } else {
                    ASSERT(OPEN_REQUEST_EA_LENGTH(Request) == sizeof(IPX_DATAGRAM_OPTIONS2));
                    Options =  ((PIPX_DATAGRAM_OPTIONS2)(OPEN_REQUEST_EA_INFORMATION(Request)));
                    RemoteAddress = (TDI_ADDRESS_IPX UNALIGNED *)(&Options->RemoteAddress);
                    IPX_DEBUG(SEND, ("IpxTdiSendDatagram: Options buffer supplied as input buffer\n"));
                }

            IPX_DEBUG (SEND, ("Send on %lx, network %lx socket %lx\n",
                                   Address, RemoteAddress->NetworkAddress, RemoteAddress->Socket));

#if 0
             if (Parameters->SendLength > IpxDevice->RealMaxDatagramSize) {

                   IPX_DEBUG (SEND, ("Send %d bytes too large (%d)\n",
                              Parameters->SendLength,
                               IpxDevice->RealMaxDatagramSize));

                   REQUEST_INFORMATION(Request) = 0;
                   IPX_FREE_LOCK (&Address->Lock, LockHandle);
                   Status = STATUS_INVALID_BUFFER_SIZE;
                   goto error_send_no_packet;
                 }
#endif
            //
            // Every address has one packet committed to it, use that
            // if possible, otherwise take one out of the pool.
            //


#if BACK_FILL

            // If the request is coming from the server, which resrves transport header space
            // build the header in its space. Allocate a special packet to which does not contain
            // mac and ipx headers in its reserved space.

            if ((PMDL)REQUEST_NDIS_BUFFER(Request) &&
               (((PMDL)REQUEST_NDIS_BUFFER(Request))->MdlFlags & MDL_NETWORK_HEADER) &&
               (!(Information->OptionsLength < sizeof(IPX_DATAGRAM_OPTIONS))) &&
               (RemoteAddress->NodeAddress[0] != 0xff)) {

                //if (!Address->BackFillPacketInUse) {
                if (InterlockedExchangeAdd(&Address->BackFillPacketInUse, 0) == 0) {
                  //Address->BackFillPacketInUse = TRUE;
                  InterlockedIncrement(&Address->BackFillPacketInUse);

                  Packet = PACKET(&Address->BackFillPacket);
                  Reserved = (PIPX_SEND_RESERVED)(Packet->ProtocolReserved);
                  IPX_DEBUG(SEND, ("Getting owned backfill %x %x \n", Packet,Reserved));

                }else {

                     s = IPX_POP_ENTRY_LIST(
                            &Device->BackFillPacketList,
                            &Device->SListsLock);

                     if (s != NULL) {
                         goto GotBackFillPacket;
                     }

                     //
                     // This function tries to allocate another packet pool.
                     //

                     s = IpxPopBackFillPacket(Device);

                     //
                     // Possibly we should queue the packet up to wait
                     // for one to become free.
                     //

                     if (s == NULL) {
                         IPX_FREE_LOCK (&Address->Lock, LockHandle);
                         Status = STATUS_INSUFFICIENT_RESOURCES;
#ifdef  SNMP
                        ++IPX_MIB_ENTRY(Device, SysOutDiscards);
#endif  SNMP
                         goto error_send_no_packet;
                     }

GotBackFillPacket:

                     Reserved = CONTAINING_RECORD (s, IPX_SEND_RESERVED, PoolLinkage);
                     Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);
                     IPX_DEBUG(SEND, ("getting backfill packet %x %x %x\n", s, Reserved, RemoteAddress->NodeAddress));
                     if(!Reserved->BackFill)DbgBreakPoint();

                }

             }else {

                // if (!Address->SendPacketInUse) {
                if (InterlockedExchangeAdd(&Address->SendPacketInUse, 0) == 0) {
                  // Address->SendPacketInUse = TRUE;
                  InterlockedIncrement(&Address->SendPacketInUse);

                  Packet = PACKET(&Address->SendPacket);
                  Reserved = (PIPX_SEND_RESERVED)(Packet->ProtocolReserved);

                } else {

                   s = IPX_POP_ENTRY_LIST(
                        &Device->SendPacketList,
                        &Device->SListsLock);

                   if (s != NULL) {
                         goto GotPacket;
                   }

                   //
                   // This function tries to allocate another packet pool.
                   //

                   s = IpxPopSendPacket(Device);

                   //
                   // Possibly we should queue the packet up to wait
                   // for one to become free.
                   //

                   if (s == NULL) {
                    IPX_FREE_LOCK (&Address->Lock, LockHandle);
                    Status = STATUS_INSUFFICIENT_RESOURCES;
#ifdef  SNMP
                    ++IPX_MIB_ENTRY(Device, SysOutDiscards);
#endif  SNMP
                    goto error_send_no_packet;
                   }

GotPacket:

                   Reserved = CONTAINING_RECORD (s, IPX_SEND_RESERVED, PoolLinkage);
                   Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);
                   Reserved->BackFill = FALSE;

                }

             }


#else

            if (!Address->SendPacketInUse) {

                Address->SendPacketInUse = TRUE;
                Packet = PACKET(&Address->SendPacket);
                Reserved = (PIPX_SEND_RESERVED)(Packet->ProtocolReserved);

            } else {

                s = IPX_POP_ENTRY_LIST(
                        &Device->SendPacketList,
                        &Device->SListsLock);

                if (s != NULL) {
                    goto GotPacket;
                }

                //
                // This function tries to allocate another packet pool.
                //

                s = IpxPopSendPacket(Device);

                //
                // Possibly we should queue the packet up to wait
                // for one to become free.
                //

                if (s == NULL) {
                    IPX_FREE_LOCK (&Address->Lock, LockHandle);
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto error_send_no_packet;
                }

GotPacket:

                Reserved = CONTAINING_RECORD (s, IPX_SEND_RESERVED, PoolLinkage);
                Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);

            }


#endif

            IpxReferenceAddressFileLock (AddressFile, AFREF_SEND_DGRAM);

            IPX_FREE_LOCK (&Address->Lock, LockHandle);

            //
            // Save this now while we have Parameters available.
            //

            REQUEST_INFORMATION(Request) = Parameters->SendLength;
            LengthIncludingHeader = (USHORT)(Parameters->SendLength + sizeof(IPX_HEADER));

#if 0
            {
                ULONG ActualLength;
                IpxGetMdlChainLength(REQUEST_NDIS_BUFFER(Request), &ActualLength);
                if (ActualLength != Parameters->SendLength) {
                    DbgPrint ("IPX: IRP %lx has parameter length %d, buffer chain length %d\n",
                            Request, Parameters->SendLength, ActualLength);
                    DbgBreakPoint();
                }
            }
#endif

            Reserved->u.SR_DG.AddressFile = AddressFile;
            Reserved->u.SR_DG.Request = Request;
            CTEAssert (Reserved->Identifier == IDENTIFIER_IPX);


            //
            // Set this to 0; this means the packet is not one that
            // should be broadcast on all nets. We will change it
            // later if it turns out this is the case.
            //

            Reserved->u.SR_DG.CurrentNicId = 0;

            //
            // We need this to track these packets specially.
            //

            Reserved->u.SR_DG.OutgoingSap = AddressFile->IsSapSocket;

            //
            // Add the MDL chain after the pre-allocated header buffer.
            // NOTE: THIS WILL ONLY WORK IF WE EVENTUALLY CALL
            // NDISRECALCULATEPACKETCOUNTS (which we do in IpxSendFrame).
            //
            //
#if BACK_FILL

            if (Reserved->BackFill) {
               Reserved->HeaderBuffer = REQUEST_NDIS_BUFFER(Request);

               //remove the ipx mdl from the packet.
               Reserved->UserLength = Reserved->HeaderBuffer->ByteCount;

               IPX_DEBUG(SEND, ("back filling userMdl Reserved %x %x\n", Reserved->HeaderBuffer, Reserved));
            } else {
               NDIS_BUFFER_LINKAGE (NDIS_BUFFER_LINKAGE(Reserved->HeaderBuffer)) = REQUEST_NDIS_BUFFER(Request);
            }
#else
            NDIS_BUFFER_LINKAGE (NDIS_BUFFER_LINKAGE(Reserved->HeaderBuffer)) = REQUEST_NDIS_BUFFER(Request);
#endif


            //
            // If IrpSp does not have a buffer for the right size for
            // datagram options and there is no input buffer
            //
            if (!REQUEST_SPECIAL_SEND(Request) &&
                (Information->OptionsLength < sizeof(IPX_DATAGRAM_OPTIONS))) {

                //
                // The caller did not supply the local target for this
                // send, so we look it up ourselves.
                //

                UINT Segment;

                //
                // We calculate this now since we need to know
                // if it is directed below.
                //
                if (RemoteAddress->NodeAddress[0] == 0xff) {
                    // What about multicast?
                    if ((*(UNALIGNED ULONG *)(RemoteAddress->NodeAddress) != 0xffffffff) ||
                        (*(UNALIGNED USHORT *)(RemoteAddress->NodeAddress+4) != 0xffff)) {
                        Reserved->DestinationType = DESTINATION_MCAST;
                    } else {
                        Reserved->DestinationType = DESTINATION_BCAST;
                    }
                } else {
                    Reserved->DestinationType = DESTINATION_DEF;   // directed send
                }

                //
                // If there are no options, then check if the
                // caller is passing the packet type as a final byte
                // in the remote address; if not use the default.
                //

                if (Information->OptionsLength == 0) {
                    if (AddressFile->ExtendedAddressing) {
                        PacketType = ((PUCHAR)(RemoteAddress+1))[0];
                    } else {
                        PacketType = AddressFile->DefaultPacketType;
                    }
                } else {
                    PacketType = ((PUCHAR)(Information->Options))[0];
                }

                if ((Reserved->DestinationType != DESTINATION_DEF) &&
                    ((RemoteAddress->NetworkAddress == 0) ||
                     (Device->VirtualNetwork &&
                      (RemoteAddress->NetworkAddress == Device->SourceAddress.NetworkAddress)))) {


                    //
                    // Do we have any REAL adapters? If not, just get out now.
                    //
                    if (!Device->RealAdapters) {
                        
                        IPX_END_SYNC (&SyncContext);
                        
                        irpSp = IoGetCurrentIrpStackLocation( Request );
        
                        if ( irpSp->MinorFunction == TDI_DIRECT_SEND_DATAGRAM ) {

                            REQUEST_STATUS(Request) = STATUS_SUCCESS;
                            Request->CurrentLocation++,
                                Request->Tail.Overlay.CurrentStackLocation++;

                            (VOID) irpSp->CompletionRoutine(
                                                            NULL,
                                                            Request,
                                                            irpSp->Context
                                                            );

                            IpxFreeRequest (DeviceObject, Request);
                        }
                        
                        IpxDereferenceAddressFileSync (AddressFile, AFREF_SEND_DGRAM);

                        return STATUS_SUCCESS;

                    }

                    //
                    // This packet needs to be broadcast to all networks.    
                    // Make sure it is not too big for any of them.
                    //

                    if (Parameters->SendLength > Device->RealMaxDatagramSize) {
                        IPX_DEBUG (SEND, ("Send %d bytes too large (%d)\n",
                            Parameters->SendLength, Device->RealMaxDatagramSize));
                        Status = STATUS_INVALID_BUFFER_SIZE;
#ifdef  SNMP
                        ++IPX_MIB_ENTRY(Device, SysOutMalformedRequests);
#endif  SNMP
                        goto error_send_with_packet;
                    }

                    //
                    // If this is a broadcast to the virtual net, we
                    // need to construct a fake remote address which
                    // has network 0 in there instead.
                    //

                    if (Device->VirtualNetwork &&
                        (RemoteAddress->NetworkAddress == Device->SourceAddress.NetworkAddress)) {

                        RtlCopyMemory (&TempAddress, (PVOID)RemoteAddress, sizeof(TDI_ADDRESS_IPX));
                        TempAddress.NetworkAddress = 0;
                        RemoteAddress = (TDI_ADDRESS_IPX UNALIGNED *)&TempAddress;
                    
                    }

                    //
                    // If someone is sending to the SAP socket and
                    // we are running with multiple cards without a
                    // virtual network, AND this packet is a SAP response,
                    // then we log an error to warn them that the
                    // system may not work as they like (since there
                    // is no virtual network to advertise, we use
                    // the first card's net/node as our local address).
                    // We only do this once per boot, using the
                    // SapWarningLogged variable to control that.
                    //

                    if ((RemoteAddress->Socket == SAP_SOCKET) &&
                        (!Device->SapWarningLogged) &&
                        (Device->MultiCardZeroVirtual)) {

                        PNDIS_BUFFER FirstBuffer;
                        UINT FirstBufferLength;
                        USHORT UNALIGNED * FirstBufferData;

                        if ((FirstBuffer = REQUEST_NDIS_BUFFER(Request)) != NULL) {

                            NdisQueryBufferSafe (
                                FirstBuffer,
                                (PVOID *)&FirstBufferData,
                                &FirstBufferLength, NormalPagePriority);

			    if (FirstBufferData != NULL) {

			      //
			      // The first two bytes of a SAP packet are the
			      // operation, 0x2 (in network order) is response.
			      //

			       if ((FirstBufferLength >= sizeof(USHORT)) &&
				   (*FirstBufferData == 0x0200)) {

				  Device->SapWarningLogged = TRUE;

				  IpxWriteGeneralErrorLog(
				     Device->DeviceObject,
				     EVENT_IPX_SAP_ANNOUNCE,
				     777,
				     STATUS_NOT_SUPPORTED,
				     NULL,
				     0,
				     NULL);
			       }
			    }
                        }
                    }


                    //
                    // In this case we do not RIP but instead set the
                    // packet up so it is sent to each network in turn.
                    //
                    // Special case: If this packet is from the SAP
                    // socket and we are running with multiple cards
                    // without a virtual network, we only send this
                    // on the card with NIC ID 1, so we leave
                    // CurrentNicId set to 0.
                    //

                    //
                    // What if NicId 1 is invalid? Should scan
                    // for first valid one, fail send if none.
                    //

                    if ((Address->Socket != SAP_SOCKET) ||
                        (!Device->MultiCardZeroVirtual)) {

                        if (Device->SingleNetworkActive) {

                            if (Device->ActiveNetworkWan) {
                                Reserved->u.SR_DG.CurrentNicId = Device->FirstWanNicId;
                            } else {
                                Reserved->u.SR_DG.CurrentNicId = Device->FirstLanNicId;
                            }

                        } else {

                            //
                            // Is this the change I need to make?
                            //

                            Reserved->u.SR_DG.CurrentNicId = FIRST_REAL_BINDING;

                        }

                        Reserved->u.SR_DG.Net0SendSucceeded = FALSE;

                        //
                        // In this case, we need to scan for the first
                        // non-dialout wan socket.
                        //

                        if ((Device->DisableDialoutSap) &&
                            (Address->Socket == SAP_SOCKET)) {

                            PBINDING TempBinding;

                            CTEAssert (Reserved->u.SR_DG.CurrentNicId <= Device->ValidBindings);
                            while (Reserved->u.SR_DG.CurrentNicId <= MIN (Device->MaxBindings, Device->ValidBindings)) {
// No need to lock the access path since he just looks at it
//
                                TempBinding = NIC_ID_TO_BINDING(Device, Reserved->u.SR_DG.CurrentNicId);
                                if ((TempBinding != NULL) &&
                                    (!TempBinding->DialOutAsync)) {
                                    
                                    break;

                                }
                                ++Reserved->u.SR_DG.CurrentNicId;
                            }
                            if (Reserved->u.SR_DG.CurrentNicId > MIN (Device->MaxBindings, Device->ValidBindings)) {
                                //
                                // [SA] Bug #17273 return proper error mesg.
                                //

                                // Status = STATUS_DEVICE_DOES_NOT_EXIST;
                                Status = STATUS_NETWORK_UNREACHABLE;

                                goto error_send_with_packet;
                            }
                        }                             

                        FILL_LOCAL_TARGET(&TempLocalTarget, Reserved->u.SR_DG.CurrentNicId);

                    } else {
                        FILL_LOCAL_TARGET(&TempLocalTarget, FIRST_REAL_BINDING);
                    }

                    RtlCopyMemory(TempLocalTarget.MacAddress, RemoteAddress->NodeAddress, 6);
					IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
					Binding = NIC_ID_TO_BINDING(Device, NIC_FROM_LOCAL_TARGET(&TempLocalTarget));
					IpxReferenceBinding1(Binding, BREF_DEVICE_ACCESS);
					IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

                    //
                    // [FW] the localtarget shd be in the packet's reserved section
                    //
                    LocalTarget = &Reserved->LocalTarget;
                    Reserved->LocalTarget = TempLocalTarget;
                } else {

                    //
                    // [FW] If router installed, call the Forwarder's FindRouteHandler.
                    // This returns a STATUS_SUCCESS if a route is available
                    //
                    if (Device->ForwarderBound) {

                        Status = (*Device->UpperDrivers[IDENTIFIER_RIP].FindRouteHandler) (
                                             (PUCHAR)&RemoteAddress->NetworkAddress,
                                             RemoteAddress->NodeAddress,
                                             &routeEntry);

                        if (Status != STATUS_SUCCESS) {

                           IPX_DEBUG (SEND, ("RouteHandler failed, network: %lx\n",
                                        REORDER_ULONG(RemoteAddress->NetworkAddress)));
                           goto error_send_with_packet;

                        } else {

                           //
                           // Fill in the LocalTarget from the RouteEntry
                           //

                           LocalTarget = &Reserved->LocalTarget;

                           Reserved->LocalTarget = routeEntry.LocalTarget;

                           IPX_DEBUG(SEND, ("IPX: SendFramePreFwd: LocalTarget is: %lx\n", Reserved->LocalTarget));

                           if (NIC_ID_TO_BINDING(Device, LocalTarget->NicId) == NULL || GET_LONG_VALUE(NIC_ID_TO_BINDING(Device, LocalTarget->NicId)->ReferenceCount) == 1) {
                              IPX_DEBUG(SEND, ("IPX: SendFramePreFwd: FWD returned SUCCESS, Ref count is 1\n"));
                              Status = NDIS_STATUS_SUCCESS;
                              goto error_send_with_packet;
                           }

                           if (Parameters->SendLength >
                                   NIC_ID_TO_BINDING(Device, LocalTarget->NicId)->RealMaxDatagramSize) {

                               IPX_DEBUG (SEND, ("Send %d bytes too large (%d)\n",
                                   Parameters->SendLength,
                                   NIC_ID_TO_BINDING(Device, LocalTarget->NicId)->RealMaxDatagramSize));

                               REQUEST_INFORMATION(Request) = 0;
                               Status = STATUS_INVALID_BUFFER_SIZE;

                               goto error_send_with_packet;
                           }

                           //
                           // [FW] we dont need to check this since the FWD does it for us.
                           //

                           /*
                           if ((Device->DisableDialoutSap) &&
                               (Address->Socket == SAP_SOCKET) &&
                               (NIC_ID_TO_BINDING(Device, LocalTarget->NicId)->DialOutAsync)) {

                               REQUEST_INFORMATION(Request) = 0;
                               Status = STATUS_NETWORK_UNREACHABLE;
                               goto error_send_with_packet;
                           }
                           */

                            IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                            Binding = NIC_ID_TO_BINDING(Device, NIC_FROM_LOCAL_TARGET(LocalTarget));
                            IpxReferenceBinding1(Binding, BREF_DEVICE_ACCESS);
                            IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
                            IPX_DEBUG(SEND, ("FindRoute for %02x-%02x-%02x-%02x-%02x-%02x returned %lx\n",
                                            LocalTarget->MacAddress[0],
                                            LocalTarget->MacAddress[1],
                                            LocalTarget->MacAddress[2],
                                            LocalTarget->MacAddress[3],
                                            LocalTarget->MacAddress[4],
                                            LocalTarget->MacAddress[5],
                                            Status));

                        }

                    } else {
                        Segment = RipGetSegment((PUCHAR)&RemoteAddress->NetworkAddress);


                        IPX_GET_LOCK (&Device->SegmentLocks[Segment], &LockHandle);

                        //
                        // This call will return STATUS_PENDING if we need to
                        // RIP for the packet.
                        //

                        Status = RipGetLocalTarget(
                                     Segment,
                                     RemoteAddress,
                                     IPX_FIND_ROUTE_RIP_IF_NEEDED,
                                     &TempLocalTarget,
                                     NULL);

                        if (Status == STATUS_SUCCESS) {

                            //
                            // We found the route, TempLocalTarget is filled in.
                            //

                            IPX_FREE_LOCK (&Device->SegmentLocks[Segment], LockHandle);
    						IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                            if (NIC_FROM_LOCAL_TARGET(&TempLocalTarget) == (USHORT)LOOPBACK_NIC_ID) {
                                IPX_DEBUG(LOOPB, ("Loopback TDI packet: remoteaddr: %lx\n", RemoteAddress));
                                IsLoopback = TRUE;
                                //FILL_LOCAL_TARGET(&TempLocalTarget, FIRST_REAL_BINDING);
                                //DbgPrint("Real Adapters?:%lx\n", Device->RealAdapters);
                            }
    						Binding = NIC_ID_TO_BINDING(Device, NIC_FROM_LOCAL_TARGET(&TempLocalTarget));
    						IpxReferenceBinding1(Binding, BREF_DEVICE_ACCESS);
    						IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);


                            if (Binding == NULL || Parameters->SendLength >
                                    Binding->RealMaxDatagramSize) {
                                IPX_DEBUG (SEND, ("Send %d bytes too large (%d)\n",
                                    Parameters->SendLength,
                                    Binding->RealMaxDatagramSize));

                                REQUEST_INFORMATION(Request) = 0;
                                Status = STATUS_INVALID_BUFFER_SIZE;
#ifdef  SNMP
                                ++IPX_MIB_ENTRY(Device, SysOutMalformedRequests);
#endif  SNMP
                                goto error_send_with_packet;
                            }

                            if (!Device->ForwarderBound &&
                                (Device->DisableDialoutSap) &&
                                (Address->Socket == SAP_SOCKET) &&
                                (Binding->DialOutAsync)) {

                                REQUEST_INFORMATION(Request) = 0;
                                //
                                // [SA] Bug #17273 return proper error mesg.
                                //

                                // Status = STATUS_DEVICE_DOES_NOT_EXIST;
                                Status = STATUS_NETWORK_UNREACHABLE;
    							IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
#ifdef  SNMP
                                ++IPX_MIB_ENTRY(Device, SysOutDiscards);
#endif  SNMP
                                goto error_send_with_packet;
                            }

                        } else if (Status == STATUS_PENDING) {

                            //
                            // A RIP request went out on the network; we queue
                            // this packet for transmission when the RIP
                            // response arrives. First we fill in the IPX
                            // header; the only thing we don't know is where
                            // exactly to fill it in, so we choose
                            // the most common location.
                            //

                            IpxConstructHeader(
                                &Reserved->Header[Device->IncludedHeaderOffset],
                                LengthIncludingHeader,
                                PacketType,
                                RemoteAddress,
                                &Address->LocalAddress);

                            //
                            // Adjust the 2nd mdl's size
                            //
                            NdisAdjustBufferLength(NDIS_BUFFER_LINKAGE(IPX_PACKET_HEAD(Packet)), sizeof(IPX_HEADER));

                            IPX_DEBUG (RIP, ("Queueing packet %lx\n", Reserved));

                            InsertTailList(
                                &Device->Segments[Segment].WaitingForRoute,
                                &Reserved->WaitLinkage);

                            IPX_FREE_LOCK (&Device->SegmentLocks[Segment], LockHandle);
                            IPX_END_SYNC (&SyncContext);

                            return STATUS_PENDING;

                        } else {

                            IPX_FREE_LOCK (&Device->SegmentLocks[Segment], LockHandle);
#ifdef  SNMP
                            ++IPX_MIB_ENTRY(Device, SysOutDiscards);
#endif  SNMP
                            goto error_send_with_packet;

                        }

                        //
                        // [FW] The localtarget shd be in the reserved section.
                        //
                        LocalTarget = &Reserved->LocalTarget;
                        Reserved->LocalTarget = TempLocalTarget;
                    }
                }

                //
                // [FW] moved to the conditions above so we save a copy in the RIP case
                //

                // LocalTarget = &TempLocalTarget;

                //
                // Now we know the local target, we can figure out
                // the offset for the IPX header.
                //


// Remember that we have got the binding with ref above....

                IpxHeader = (PIPX_HEADER)&Reserved->Header[MAC_HEADER_SIZE];
#if 0
                if (Reserved->DestinationType == DESTINATION_DEF) {
                    IpxHeader = (PIPX_HEADER)&Reserved->Header[Binding->DefHeaderSize];
                } else {
                   IpxHeader = (PIPX_HEADER)&Reserved->Header[Binding->BcMcHeaderSize];
                }
#endif

            } else {

                if (!REQUEST_SPECIAL_SEND(Request)) {
                    PacketType = ((PUCHAR)(Information->Options))[0];
                    LocalTarget = &((PIPX_DATAGRAM_OPTIONS)(Information->Options))->LocalTarget;
                } else {
                    ASSERT(OPEN_REQUEST_EA_LENGTH(Request) == sizeof(IPX_DATAGRAM_OPTIONS2));
                    if (OPEN_REQUEST_EA_LENGTH(Request) == sizeof(IPX_DATAGRAM_OPTIONS2)) {
                      //IpxPrint0("IpxTdiSendDatagram: We have an input buffer of the right size\n");
                    } else {
                      //IpxPrint1("IpxTdiSendDatagram: Wrong sized buffer. Buff size is =(%d)\n", OPEN_REQUEST_EA_LENGTH(Request));
                       Status = STATUS_INVALID_BUFFER_SIZE;
                       goto error_send_with_packet;
                    }

                    PacketType = Options->DgrmOptions.PacketType;
                    LocalTarget = &Options->DgrmOptions.LocalTarget;
                }

                //
                // Calculate the binding and the correct location
                // for the IPX header. We can do this at the same
                // time as we calculate the DestinationType which
                // saves an if like the one 15 lines up.
                //

	        // Get lock to ref.
		IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                //
                // If a loopback packet, use the first binding as place holder
                //
                if (NIC_FROM_LOCAL_TARGET(LocalTarget) == (USHORT)LOOPBACK_NIC_ID) {
                    IsLoopback = TRUE;
		}

		Binding = NIC_ID_TO_BINDING(Device, NIC_FROM_LOCAL_TARGET(LocalTarget));

		IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

		if (Binding == NULL) {
		   DbgPrint("Binding %d does not exist.\n",NIC_FROM_LOCAL_TARGET(LocalTarget)); 
		   Status = STATUS_NOT_FOUND;
		   goto error_send_with_packet;
		}

		IpxReferenceBinding1(Binding, BREF_DEVICE_ACCESS);
		
		if (Parameters->SendLength > Binding->RealMaxDatagramSize) {

                   IPX_DEBUG (SEND, ("Send %d bytes too large (%d)\n",
                              Parameters->SendLength,
                               Binding->RealMaxDatagramSize));

                   REQUEST_INFORMATION(Request) = 0;
                   Status = STATUS_INVALID_BUFFER_SIZE;
#ifdef  SNMP
                    ++IPX_MIB_ENTRY(Device, SysOutMalformedRequests);
#endif  SNMP
                   goto error_send_with_packet;
                 }

#if 0
                //
                // This shouldn't be needed because even WAN bindings
                // don't go away once they are added.
                //

                if (Binding == NULL) {
                    Status = STATUS_DEVICE_DOES_NOT_EXIST;
                    goto error_send_with_packet;
                }
#endif

                if (RemoteAddress->NodeAddress[0] == 0xff) {
                    // What about multicast?
                    if ((*(UNALIGNED ULONG *)(RemoteAddress->NodeAddress) != 0xffffffff) ||
                        (*(UNALIGNED USHORT *)(RemoteAddress->NodeAddress+4) != 0xffff)) {
                        Reserved->DestinationType = DESTINATION_MCAST;
                    } else {
                        Reserved->DestinationType = DESTINATION_BCAST;
                    }
//                    IpxHeader = (PIPX_HEADER)&Reserved->Header[Binding->BcMcHeaderSize];
                } else {
                    Reserved->DestinationType = DESTINATION_DEF;   // directed send
//                   IpxHeader = (PIPX_HEADER)&Reserved->Header[Binding->DefHeaderSize];
                }
                IpxHeader = (PIPX_HEADER)&Reserved->Header[MAC_HEADER_SIZE];

            }

	    
            // ++Device->TempDatagramsSent;
            // Device->TempDatagramBytesSent += Parameters->SendLength;
	    ADD_TO_LARGE_INTEGER(&Device->Statistics.DatagramBytesSent,
				 Parameters->SendLength);
	    Device->Statistics.DatagramsSent++; 


#if BACK_FILL

            if (Reserved->BackFill) {
                  Reserved->MappedSystemVa = Reserved->HeaderBuffer->MappedSystemVa;
                  IpxHeader = (PIPX_HEADER)((PCHAR)Reserved->HeaderBuffer->MappedSystemVa - sizeof(IPX_HEADER));
                  Reserved->HeaderBuffer->ByteOffset -= sizeof(IPX_HEADER);

                  ASSERT((LONG)Reserved->HeaderBuffer->ByteOffset >= 0); 
#ifdef SUNDOWN
                  (ULONG_PTR)Reserved->HeaderBuffer->MappedSystemVa-= sizeof(IPX_HEADER);
#else
                  (ULONG)Reserved->HeaderBuffer->MappedSystemVa-= sizeof(IPX_HEADER);
#endif


                  IPX_DEBUG(SEND, ("Adjusting backfill userMdl Ipxheader %x %x \n",Reserved->HeaderBuffer,IpxHeader));
           }
#endif

            //
            // In case the packet is being sent to a SAP socket or
            // we have multiple cards and a zero virtual net or
            // it is a special send (on a nic), we need to use
            // the binding's address instead of the virtual address.
            //
            if (Device->MultiCardZeroVirtual ||
                (Address->LocalAddress.Socket == SAP_SOCKET) ||
                (RemoteAddress->Socket == SAP_SOCKET) ||
                (REQUEST_SPECIAL_SEND(Request))) {

                //
                // SAP frames need to look like they come from the
                // local network, not the virtual one. The same is
                // true if we are running multiple nets without
                // a virtual network number.
                //
                // If this is a binding set member and a local target
                // was provided we will send using the real node of
                // the binding, even if it was a slave. This is
                // intentional. If no local target was provided then
                // this will not be a binding slave.
                //

                IpxConstructHeader(
                    (PUCHAR)IpxHeader,
                    LengthIncludingHeader,
                    PacketType,
                    RemoteAddress,
                    &Binding->LocalAddress);

                IpxHeader->SourceSocket = Address->SendSourceSocket;

            } else {

                IpxConstructHeader(
                    (PUCHAR)IpxHeader,
                    LengthIncludingHeader,
                    PacketType,
                    RemoteAddress,
                    &Address->LocalAddress);

            }


            //
            // Fill in the MAC header and submit the frame to NDIS.
            //

// #if DBG
            CTEAssert (!Reserved->SendInProgress);
            Reserved->SendInProgress = TRUE;
// #endif
            
            //
            // Adjust the 2nd mdl's size
            //
#if BACK_FILL
            if (Reserved->BackFill) {
                 NdisAdjustBufferLength(Reserved->HeaderBuffer, (Reserved->HeaderBuffer->ByteCount+sizeof(IPX_HEADER)));
            } else {
                 NdisAdjustBufferLength(NDIS_BUFFER_LINKAGE(IPX_PACKET_HEAD(Packet)), sizeof(IPX_HEADER));
            }
#else
            NdisAdjustBufferLength(NDIS_BUFFER_LINKAGE(IPX_PACKET_HEAD(Packet)), sizeof(IPX_HEADER));
#endif

            IPX_DEBUG(SEND, ("Packet Head %x\n",IPX_PACKET_HEAD(Packet)));

            /*
            if (Address->RtAdd)
            {
                REQUEST_OPEN_CONTEXT(Request) = (PVOID)(pRtInfo);
            }
            */

            //
            // [FW] If Forwarder installed, send the packet out for filtering
            //
            // STEFAN: 3/28/96:
            // Dont filter IPXWAN config packets since the FWD does not have this adapter opened yet.
            //

            IPX_DEBUG(SEND, ("LocalAddress.Socket %x, IPXWAN_SOCKET\n", Address->LocalAddress.Socket, IPXWAN_SOCKET));
            if (Address->LocalAddress.Socket != IPXWAN_SOCKET &&
                Device->ForwarderBound) {

                //
                // Call the InternalSend to filter the packet and get to know
                // the correct adapter context
                //

                NTSTATUS  ret;

		#ifdef SUNDOWN
		ULONG_PTR   FwdAdapterCtx = INVALID_CONTEXT_VALUE;
	        #else
                ULONG   FwdAdapterCtx = INVALID_CONTEXT_VALUE;
		#endif
		

                PUCHAR  Data;
                UINT    DataLength;

                if (GET_LONG_VALUE(Binding->ReferenceCount) == 2) {
                    FwdAdapterCtx = Binding->FwdAdapterContext;
                }

                //
                // Figure out the location of the data in the packet
                // For BackFill packets, the data is in the first (and only) MDL.
                // For others, it is in the third MDL.
                //

                if (Reserved->BackFill) {
                    Data = (PUCHAR)(IpxHeader+sizeof(IPX_HEADER));
                } else {
                    NdisQueryBufferSafe(NDIS_BUFFER_LINKAGE(NDIS_BUFFER_LINKAGE(Reserved->HeaderBuffer)), &Data, &DataLength, HighPagePriority);
                }

		if (Data != NULL) {

		   ret = (*Device->UpperDrivers[IDENTIFIER_RIP].InternalSendHandler)(
                           LocalTarget,
                           FwdAdapterCtx,
                           Packet,
                           (PUCHAR)IpxHeader,
                           Data,
                           LengthIncludingHeader,
                           FALSE);


		   if (ret == STATUS_SUCCESS) {
                    //
                    // The adapter could have gone away and we have indicated to the Forwarder
                    // but the Forwarder has not yet closed the adapter.
                    //
                    // what if the binding is NULL here? Can we trust the Forwarder to
                    // give us a non-NULL binding?
                    //

                    Binding = NIC_ID_TO_BINDING(Device, NIC_FROM_LOCAL_TARGET(LocalTarget));
		    
		    // 302384

		    if (Binding == NULL) {
		       DbgPrint("IPX:nwlnkfwd has returned invalid nic id (%d) in LocalTarget (%p).\n",NIC_FROM_LOCAL_TARGET(LocalTarget), LocalTarget); 
		       Status = STATUS_UNSUCCESSFUL;
               CTEAssert (Reserved->SendInProgress);
               Reserved->SendInProgress = FALSE;
		       goto error_send_with_packet; 
		    }

                    if (GET_LONG_VALUE(Binding->ReferenceCount) == 1) {
                        Status = NDIS_STATUS_SUCCESS;
// #if DBG
                        CTEAssert (Reserved->SendInProgress);
                        Reserved->SendInProgress = FALSE;
// #endif
                        goto error_send_with_packet;
                    } else {
                        IsLoopback = (NIC_FROM_LOCAL_TARGET(LocalTarget) == (USHORT)LOOPBACK_NIC_ID);
                        goto send_packet;
                    }
		   } else if (ret == STATUS_PENDING) {
                    //
                    // LocalTarget will get filled up in InternalSendComplete
                    //

                    //
                    // this is a NULL macro - include this?
                    //
                    IPX_END_SYNC (&SyncContext);

                    return STATUS_PENDING;
		   } else if (ret == STATUS_DROP_SILENTLY) {
                    IPX_DEBUG(SEND, ("IPX: SendFramePreFwd: FWD returned STATUS_DROP_SILENTLY - dropping pkt.\n"));
                    Status = NDIS_STATUS_SUCCESS;

// #if DBG
                    CTEAssert (Reserved->SendInProgress);
                    Reserved->SendInProgress = FALSE;
// #endif
                    goto error_send_with_packet;
		   }

		}
                //
                // else DISCARD
                //

                //
                // 179436 - If forwarder is bound then its likely that we still wanna send.
                //
                if (Device->ForwarderBound && (GET_LONG_VALUE(NIC_ID_TO_BINDING(Device, NIC_FROM_LOCAL_TARGET(LocalTarget))->ReferenceCount) == 1)) {
                    
                    goto send_packet;

                }

// #if DBG
                CTEAssert (Reserved->SendInProgress);
                Reserved->SendInProgress = FALSE;
// #endif
                Status = STATUS_NETWORK_UNREACHABLE;
                goto error_send_with_packet;

            } else {

                //
                // [FW] Jump here if the Forwarder gave us the go ahead on this send.
                // We also come here to send if the Forwarder is not installed.
                //

send_packet:
                
            //
            // The workaround what is a NdisMSendX bug -
            // IPX checks if it is the same network.
            //
            if (Reserved->BackFill) {

                pIpxHeader = (PIPX_HEADER)((PCHAR)Reserved->HeaderBuffer->MappedSystemVa);

            } else {

                pIpxHeader = IpxHeader;

            }

            if ((IPX_NODE_EQUAL(pIpxHeader->SourceNode, pIpxHeader->DestinationNode)) && 
                (*(UNALIGNED ULONG *)pIpxHeader->SourceNetwork == *(UNALIGNED ULONG *)pIpxHeader->DestinationNetwork)) {
                
                IPX_DEBUG(TEMP, ("It is self-directed. Loop it back ourselves (tdisenddatagram)\n"));
                IsLoopback = TRUE;
            
            }

            pBinding = NIC_ID_TO_BINDING(Device, Reserved->LocalTarget.NicId);

            if (pBinding) {
             
                if ((IPX_NODE_EQUAL(Reserved->LocalTarget.MacAddress, pBinding->LocalAddress.NodeAddress)) ||
                    (IPX_NODE_EQUAL(pBinding->LocalAddress.NodeAddress, pIpxHeader->DestinationNode))) {
            
                    IPX_DEBUG(TEMP, ("Source Net:%lx, Source Address: %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x\n",
                                     *(UNALIGNED ULONG *)pIpxHeader->SourceNetwork, 
                                     pIpxHeader->SourceNode[0], 
                                     pIpxHeader->SourceNode[1], 
                                     pIpxHeader->SourceNode[2], 
                                     pIpxHeader->SourceNode[3], 
                                     pIpxHeader->SourceNode[4], 
                                     pIpxHeader->SourceNode[5]));
                
                    IPX_DEBUG(TEMP, ("Dest Net:%lx, DestAddress: %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x \n", 
                                     *(UNALIGNED ULONG *)pIpxHeader->DestinationNetwork,
                                     pIpxHeader->DestinationNode[0],
                                     pIpxHeader->DestinationNode[1],
                                     pIpxHeader->DestinationNode[2],
                                     pIpxHeader->DestinationNode[3],
                                     pIpxHeader->DestinationNode[4],
                                     pIpxHeader->DestinationNode[5]
                                     ));

                    IPX_DEBUG(TEMP, ("Well, It is self-directed. Loop it back ourselves (TDISENDDATAGRAM - NIC_HANDLE is the same!)\n"));
                    IsLoopback = TRUE;
            
                } 
            }

            IPX_DEBUG(TEMP, ("Sending a packet now\n"));
            IPX_DEBUG(TEMP, ("**** RemoteAddress: %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x LocalAddress: %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x \n", 
                             RemoteAddress->NodeAddress[0], 
                             RemoteAddress->NodeAddress[1], 
                             RemoteAddress->NodeAddress[2], 
                             RemoteAddress->NodeAddress[3], 
                             RemoteAddress->NodeAddress[4], 
                             RemoteAddress->NodeAddress[5], 
                             Reserved->LocalTarget.MacAddress[0],
                             Reserved->LocalTarget.MacAddress[1],
                             Reserved->LocalTarget.MacAddress[2],
                             Reserved->LocalTarget.MacAddress[3],
                             Reserved->LocalTarget.MacAddress[4],
                             Reserved->LocalTarget.MacAddress[5]
                             ));

            if (IsLoopback) {
                //
                // Enque this packet to the LoopbackQueue on the binding.
                // If the LoopbackRtn is not already scheduled, schedule it.
                //
                
                IPX_DEBUG(LOOPB, ("Packet: %lx, Addr: %lx, Addr->SendPacket: %lx\n", Packet, Address, Address->SendPacket));
                
                //
                // Recalculate packet counts here.
                //
                // NdisAdjustBufferLength (Reserved->HeaderBuffer, 17);
#if BACK_FILL   

                if (Reserved->BackFill) {
                    //
                    // Set the Header pointer and chain the first MDL
                    //
                    Reserved->Header = (PCHAR)Reserved->HeaderBuffer->MappedSystemVa;
                    NdisChainBufferAtFront(Packet,(PNDIS_BUFFER)Reserved->HeaderBuffer);
                }
#endif
                NdisRecalculatePacketCounts (Packet);
                IpxLoopbackEnque(Packet, NIC_ID_TO_BINDING(Device, 1)->Adapter);

            } else {

                
                if ((NdisStatus = (*Binding->SendFrameHandler)(
                                                               Binding->Adapter,
                                                               LocalTarget,    
                                                               Packet,
                                                               Parameters->SendLength + sizeof(IPX_HEADER),
                                                               sizeof(IPX_HEADER))) != NDIS_STATUS_PENDING) {

                    IpxSendComplete(
                                    (NDIS_HANDLE)Binding->Adapter,
                                    Packet,
                                    NdisStatus);
                }
            }

            IPX_END_SYNC (&SyncContext);
            IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
            return STATUS_PENDING;
            
            }

            } else {

                //
                // The address file state was closing.
                //

                IPX_FREE_LOCK (&Address->Lock, LockHandle);
                Status = STATUS_INVALID_HANDLE;
#ifdef  SNMP
                ++IPX_MIB_ENTRY(Device, SysOutDiscards);
#endif  SNMP
                goto error_send_no_packet;

            }

     } else {

        //
        // The address file didn't look like one.
        //

        Status = STATUS_INVALID_HANDLE;
#ifdef  SNMP
        ++IPX_MIB_ENTRY(Device, SysOutDiscards);
#endif  SNMP
        goto error_send_no_packet;
    }

    //
    // Jump here if we want to fail the send and we have already
    // allocated the packet and ref'ed the address file.
    //

error_send_with_packet:

#if BACK_FILL
    //
    // Check if this is backfilled. If so, set the headerbuffer to NULL. Note that we dont need
    // restore to restore the user's MDL since it was never touched when this error occurred.
    // Also, push the packet on to backfillpacket queue if the packet is not owned by the address
    //
    if (Reserved->BackFill) {

       Reserved->HeaderBuffer = NULL;

       if (Reserved->OwnedByAddress) {
           // Reserved->Address->BackFillPacketInUse = FALSE;
           InterlockedDecrement(&Reserved->Address->BackFillPacketInUse);

           IPX_DEBUG(SEND, ("Freeing owned backfill %x\n", Reserved));
       } else {
           IPX_PUSH_ENTRY_LIST(
               &Device->BackFillPacketList,
               &Reserved->PoolLinkage,
               &Device->SListsLock);
       }
    } else {
        // not a back fill packet. Push it on sendpacket pool
        if (Reserved->OwnedByAddress) {
           // Reserved->Address->SendPacketInUse = FALSE;
           InterlockedDecrement(&Reserved->Address->SendPacketInUse);

        } else {
           IPX_PUSH_ENTRY_LIST(
               &Device->SendPacketList,
               &Reserved->PoolLinkage,
               &Device->SListsLock);

        }
    }
#else
    if (Reserved->OwnedByAddress) {
        Reserved->Address->SendPacketInUse = FALSE;
    } else {
        IPX_PUSH_ENTRY_LIST(
            &Device->SendPacketList,
            &Reserved->PoolLinkage,
            &Device->SListsLock);
    }
#endif

    IpxDereferenceAddressFileSync (AddressFile, AFREF_SEND_DGRAM);

error_send_no_packet:

    //
    // Jump here if we fail before doing any of that.
    //

    IPX_END_SYNC (&SyncContext);

    irpSp = IoGetCurrentIrpStackLocation( Request );
    if ( irpSp->MinorFunction == TDI_DIRECT_SEND_DATAGRAM ) {

        REQUEST_STATUS(Request) = Status;
        Request->CurrentLocation++,
        Request->Tail.Overlay.CurrentStackLocation++;

        (VOID) irpSp->CompletionRoutine(
                                    NULL,
                                    Request,
                                    irpSp->Context
                                    );

        IpxFreeRequest (DeviceObject, Request);
    }

    return Status;

}   /* IpxTdiSendDatagram */


#if DBG
VOID
IpxConstructHeader(
    IN PUCHAR Header,
    IN USHORT PacketLength,
    IN UCHAR PacketType,
    IN TDI_ADDRESS_IPX UNALIGNED * RemoteAddress,
    IN PTDI_ADDRESS_IPX LocalAddress
    )

/*++

Routine Description:

    This routine constructs an IPX header in a packet.

Arguments:

    Header - The location at which the header should be built.

    PacketLength - The length of the packet, including the IPX header.

    PacketType - The packet type of the frame.

    RemoteAddress - The remote IPX address.

    LocalAddress - The local IPX address.

Return Value:

    None.

--*/

{

    PIPX_HEADER IpxHeader = (PIPX_HEADER)Header;

    IpxHeader->CheckSum = 0xffff;
    IpxHeader->PacketLength[0] = (UCHAR)(PacketLength / 256);
    IpxHeader->PacketLength[1] = (UCHAR)(PacketLength % 256);
    IpxHeader->TransportControl = 0;
    IpxHeader->PacketType = PacketType;

    //
    // These copies depend on the fact that the destination
    // network is the first field in the 12-byte address.
    //

    RtlCopyMemory(IpxHeader->DestinationNetwork, (PVOID)RemoteAddress, 12);
    RtlCopyMemory(IpxHeader->SourceNetwork, LocalAddress, 12);

}   /* IpxConstructHeader */
#endif



//
// [FW]
//

VOID
IpxInternalSendComplete(
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN PNDIS_PACKET      Packet,
    IN ULONG             PacketLength,
    IN NTSTATUS          Status
    )
/*++

Routine Description:

    This routine is called by the Kernel Forwarder to indicate that a pending
    internal send to it has completed.

Arguments:

    LocalTarget - if Status is OK, this has the local target for the send.

    Packet - A pointer to the NDIS_PACKET that we sent.

    PacketLength - length of the packet (including the IPX header)

    Can IpxSendFrame use the local var. PktLength instead? What about IpxSendFrameXXX (frame specific)

    Status - the completion status of the send - STATUS_SUCCESS or STATUS_NETWORK_UNREACHABLE

Return Value:

    none.

--*/
{
    PDEVICE Device=IpxDevice;
    PIPX_SEND_RESERVED Reserved = (PIPX_SEND_RESERVED)(Packet->ProtocolReserved);
    PBINDING   Binding;
    NDIS_STATUS   NdisStatus;
    PIO_STACK_LOCATION irpSp;
    PREQUEST Request;
    PADDRESS_FILE AddressFile;

    switch (Reserved->Identifier)
    {
    case IDENTIFIER_IPX:

        //
        // datagrams can be sent to the frame-specific handlers directly
        //
        // Make this change in SendComplete too
        //

        if ((Status == STATUS_SUCCESS) &&
            (Binding = NIC_ID_TO_BINDING(Device, NIC_FROM_LOCAL_TARGET(LocalTarget))) &&
            (GET_LONG_VALUE(Binding->ReferenceCount) == 2)) {

            if (NIC_FROM_LOCAL_TARGET(LocalTarget) == (USHORT)LOOPBACK_NIC_ID) {

                //
                // Enque this packet to the LoopbackQueue on the binding.
                // If the LoopbackRtn is not already scheduled, schedule it.
                //

                IPX_DEBUG(LOOPB, ("Packet: %lx \n", Packet));

                //
                // Recalculate packet counts here.
                //
                // NdisAdjustBufferLength (Reserved->HeaderBuffer, 17);
#if BACK_FILL

                if (Reserved->BackFill) {
                    //
                    // Set the Header pointer and chain the first MDL
                    //
                    Reserved->Header = (PCHAR)Reserved->HeaderBuffer->MappedSystemVa;
                    NdisChainBufferAtFront(Packet,(PNDIS_BUFFER)Reserved->HeaderBuffer);
                }
#endif
                NdisRecalculatePacketCounts (Packet);
                IpxLoopbackEnque(Packet, NIC_ID_TO_BINDING(Device, 1)->Adapter);

            } else {
                if ((NdisStatus = (*Binding->SendFrameHandler)(
                                    Binding->Adapter,
                                    LocalTarget,
                                    Packet,
                                    PacketLength,
                                    sizeof(IPX_HEADER))) != NDIS_STATUS_PENDING) {
                    //
                    // Call SendComplete here so it can send broadcasts over other
                    // Nic's and remove any padding if used.
                    //

                    IpxSendComplete((NDIS_HANDLE)Binding->Adapter,
                                    Packet,
                                    NdisStatus);
                }
            }
        } else {
            //
            // DISCARD was returned - complete the IRP
            //
            NdisStatus = STATUS_NETWORK_UNREACHABLE;


            //
            // We need to free the packet and deref the addressfile...
            //

            // #if DBG
            CTEAssert (Reserved->SendInProgress);
            Reserved->SendInProgress = FALSE;
            // #endif

            if (Reserved->OwnedByAddress) {
                Reserved->Address->SendPacketInUse = FALSE;
            } else {
                IPX_PUSH_ENTRY_LIST(
                        &Device->SendPacketList,
                        &Reserved->PoolLinkage,
                        &Device->Lock);
            }

            AddressFile = Reserved->u.SR_DG.AddressFile;
            IpxDereferenceAddressFileSync (AddressFile, AFREF_SEND_DGRAM);

            Request = Reserved->u.SR_DG.Request;
            REQUEST_STATUS(Request) = NdisStatus;
            irpSp = IoGetCurrentIrpStackLocation( Request );

            //
            // If this is a fast send irp, we bypass the file system and
            // call the completion routine directly.
            //

            if ( irpSp->MinorFunction == TDI_DIRECT_SEND_DATAGRAM ) {
                Request->CurrentLocation++,
                Request->Tail.Overlay.CurrentStackLocation++;

                (VOID) irpSp->CompletionRoutine(
                            NULL,
                            Request,
                            irpSp->Context
                            );

            } else {
                IpxCompleteRequest (Request);
            }
            IpxFreeRequest(Device, Request);
        }

        break;

    default:
        //
        // for all other packet types
        //

        if ((Status == STATUS_SUCCESS) &&
            (Binding = NIC_ID_TO_BINDING(Device, NIC_FROM_LOCAL_TARGET(LocalTarget))) &&
            (GET_LONG_VALUE(Binding->ReferenceCount) == 2)) {
            //
            // IncludedHeaderLength is only used to check for RIP packets (==0)
            // so IPX_HEADER size is OK. Should finally remove this parameter.
            //

            if (NIC_FROM_LOCAL_TARGET(LocalTarget) == (USHORT)LOOPBACK_NIC_ID) {

                //
                // Enque this packet to the LoopbackQueue on the binding.
                // If the LoopbackRtn is not already scheduled, schedule it.
                //

                IPX_DEBUG(LOOPB, ("Packet: %lx\n", Packet));

                //
                // Recalculate packet counts here.
                //
                // NdisAdjustBufferLength (Reserved->HeaderBuffer, 17);
#if BACK_FILL

                if (Reserved->BackFill) {
                    //
                    // Set the Header pointer and chain the first MDL
                    //
                    Reserved->Header = (PCHAR)Reserved->HeaderBuffer->MappedSystemVa;
                    NdisChainBufferAtFront(Packet,(PNDIS_BUFFER)Reserved->HeaderBuffer);
                }
#endif
                NdisRecalculatePacketCounts (Packet);
                IpxLoopbackEnque(Packet, NIC_ID_TO_BINDING(Device, 1)->Adapter);

            } else {
                NdisStatus = IpxSendFrame(LocalTarget, Packet, PacketLength, sizeof(IPX_HEADER));

                if (NdisStatus != NDIS_STATUS_PENDING) {
                    IPX_DEBUG (SEND, ("IpxSendFrame status %lx on NICid %lx, packet %lx \n",
                                NdisStatus, LocalTarget->NicId, Packet));
                    goto error_complete;
                }
            }
        } else {

            //
            // DISCARD was returned - call the upper driver's sendcomplete with error
            //

            //
            // Else return STATUS_NETWORK_UNREACHABLE
            //

            NdisStatus = STATUS_NETWORK_UNREACHABLE;

            error_complete:

            IPX_DEBUG (SEND, ("Calling the SendCompleteHandler of tightly bound driver with status: %lx\n", NdisStatus));
            (*Device->UpperDrivers[Reserved->Identifier].SendCompleteHandler)(
            Packet,
            NdisStatus);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\kdext\cteext.c ===
#include "precomp.h"
#pragma hdrstop


#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        Mdl
#define _objAddr    MdlToDump
#define _objType    MDL

VOID
DumpMdlChain
( 
    ULONG _objAddr,
    VERBOSITY Verbosity
)
{
    _objType _obj;
    ULONG result;

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read MDL structure\n", _objAddr );
        return;
    }

    PrintStartStruct();
    PrintPtr( Next );
    PrintUShort( Size );
    PrintXUShort( MdlFlags );
    PrintPtr( Process );
    PrintPtr( MappedSystemVa );
    PrintPtr( StartVa );
    PrintULong( ByteCount );
    PrintULong( ByteOffset );
    return;
}

VOID
DumpCTELock
( 
    ULONG LockToDump,
    VERBOSITY Verbosity
)
{
    CTELock Lock;
    CTELock *pLock;
    ULONG result;
    
    pLock = ( CTELock * )LockToDump;

    if ( !ReadMemory( LockToDump,
                      &Lock,
                      sizeof( Lock ),
                      &result ))
    {
        dprintf("%08lx: Could not read CTELock structure\n", LockToDump );
        return;
    }

    dprintf( "{ Lock = %d }", Lock );
    return;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        Timer
#define _objAddr    pItem
#define _objType    CTETimer

VOID 
DumpCTETimer
(
    ULONG TimerToDump,
    VERBOSITY Verbosity
)
{
    CTETimer Timer;
    CTETimer *prTimer;
    ULONG result;

    prTimer = ( CTETimer * )TimerToDump;

    if ( !ReadMemory( TimerToDump,
                      &Timer,
                      sizeof( Timer ),
                      &result ))
    {
        dprintf("%08lx: Could not read CTETimer structure\n", TimerToDump );
        return;
    }

    PrintStart;
    PrintULong( t_running );
    PrintLock( t_lock );
    PrintSymbolPtr( t_handler );
    PrintXULong( t_arg );
    // DPC
    // KTIMER
    PrintEnd;
    return;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        QItem
#define _objAddr    prQItem
#define _objType    WORK_QUEUE_ITEM

VOID 
DumpWorkQueueItem
(
    ULONG ItemToDump,
    VERBOSITY Verbosity
)
{
    _objType _obj;
    _objType *_objAddr;
    ULONG result;

    _objAddr = ( _objType * )ItemToDump;

    if ( !ReadMemory( ItemToDump,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf( "%08lx: Could not read %s structure\n", 
                 ItemToDump,
                 "WORK_QUEUE_ITEM" );
        return;
    }

    PrintStart;
    PrintLL( List );
    PrintSymbolPtr( WorkerRoutine );
    PrintXULong( Parameter );
    PrintEnd;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipxroute\driver.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    driver.h

Abstract:


Environment:

    kernel & User mode

Notes:


Revision History:

--*/


//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define FILE_DEVICE_IPXROUTER	0x00008000



//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define IPXROUTER_IOCTL_INDEX	(ULONG)0x00000800


//
// Define our own private IOCTLs
//

#define IOCTL_IPXROUTER_SNAPROUTES		CTL_CODE(FILE_DEVICE_IPXROUTER,	\
							 IPXROUTER_IOCTL_INDEX+1,\
                                                         METHOD_BUFFERED,     \
							 FILE_ANY_ACCESS)

#define IOCTL_IPXROUTER_GETNEXTROUTE		CTL_CODE(FILE_DEVICE_IPXROUTER,	\
							 IPXROUTER_IOCTL_INDEX+2,\
                                                         METHOD_BUFFERED,     \
                                                         FILE_ANY_ACCESS)

#define IOCTL_IPXROUTER_CHECKNETNUMBER		CTL_CODE(FILE_DEVICE_IPXROUTER,	\
							 IPXROUTER_IOCTL_INDEX+3,\
                                                         METHOD_BUFFERED,     \
                                                         FILE_ANY_ACCESS)

#define IOCTL_IPXROUTER_SHOWNICINFO		CTL_CODE(FILE_DEVICE_IPXROUTER,	\
							 IPXROUTER_IOCTL_INDEX+4,\
                                                         METHOD_BUFFERED,     \
                                                         FILE_ANY_ACCESS)

#define IOCTL_IPXROUTER_ZERONICSTATISTICS	CTL_CODE(FILE_DEVICE_IPXROUTER,	\
							 IPXROUTER_IOCTL_INDEX+5,\
                                                         METHOD_BUFFERED,     \
                                                         FILE_ANY_ACCESS)

#define IOCTL_IPXROUTER_SHOWMEMSTATISTICS	CTL_CODE(FILE_DEVICE_IPXROUTER,	\
							 IPXROUTER_IOCTL_INDEX+6,\
                                                         METHOD_BUFFERED,     \
                                                         FILE_ANY_ACCESS)

#define IOCTL_IPXROUTER_GETWANINNACTIVITY	CTL_CODE(FILE_DEVICE_IPXROUTER,	\
							 IPXROUTER_IOCTL_INDEX+7,\
                                                         METHOD_BUFFERED,     \
                                                         FILE_ANY_ACCESS)

#define IOCTL_IPXROUTER_SETWANGLOBALADDRESS	CTL_CODE(FILE_DEVICE_IPXROUTER,	\
							 IPXROUTER_IOCTL_INDEX+8,\
                                                         METHOD_BUFFERED,     \
							 FILE_ANY_ACCESS)

#define IOCTL_IPXROUTER_DELETEWANGLOBALADDRESS	CTL_CODE(FILE_DEVICE_IPXROUTER,	\
							 IPXROUTER_IOCTL_INDEX+9,\
                                                         METHOD_BUFFERED,     \
                                                         FILE_ANY_ACCESS)


//*** Nic Info Ioctl Data ***

#define     SHOW_NIC_LAN	    0
#define     SHOW_NIC_WAN	    1

#define     SHOW_NIC_CLOSED	    0
#define     SHOW_NIC_CLOSING	    1
#define     SHOW_NIC_ACTIVE	    2
#define     SHOW_NIC_PENDING_OPEN   3

typedef struct _SHOW_NIC_INFO {

    USHORT	NicId;
    USHORT	DeviceType;
    USHORT	NicState;
    UCHAR	Network[4];
    UCHAR	Node[6];
    USHORT	TickCount;
    ULONG	StatBadReceived;
    ULONG	StatRipReceived;
    ULONG	StatRipSent;
    ULONG	StatRoutedReceived;
    ULONG	StatRoutedSent;
    ULONG	StatType20Received;
    ULONG	StatType20Sent;
    } SHOW_NIC_INFO, *PSHOW_NIC_INFO;

//*** Memory Statistics Data ***

typedef struct _SHOW_MEM_STAT {

    ULONG	PeakPktAllocCount;
    ULONG	CurrentPktAllocCount;
    ULONG	CurrentPktPoolCount;
    ULONG	PacketSize;
    } SHOW_MEM_STAT, *PSHOW_MEM_STAT;

//*** Wan Innactivity Data ***
// For the first call the NicId is set to 0xffff. The router will associate
// the remote node with a valid nic id, which will be used in subsequent calls.

typedef struct	_GET_WAN_INNACTIVITY {

    USHORT	NicId;
    UCHAR	RemoteNode[6];
    ULONG	WanInnactivityCount;
    } GET_WAN_INNACTIVITY, *PGET_WAN_INNACTIVITY;

//*** Wan Global Address Data ***

#define ERROR_IPXCP_NETWORK_NUMBER_IN_USE	 1
#define ERROR_IPXCP_MEMORY_ALLOCATION_FAILURE	 2

typedef struct	_SET_WAN_GLOBAL_ADDRESS {

    UCHAR	WanGlobalNetwork[4];
    ULONG	ErrorCode;
    } SET_WAN_GLOBAL_ADDRESS, *PSET_WAN_GLOBAL_ADDRESS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\ipxroute\ipxroute.c ===
/****************************************************************************
* (c) Copyright 1990, 1993 Micro Computer Systems, Inc. All rights reserved.
*****************************************************************************
*
*   Title:    IPX/SPX Compatible Source Routing Daemon for Windows NT
*
*   Module:   ipx/route/ipxroute.c
*
*   Version:  1.00.00
*
*   Date:     04-08-93
*
*   Author:   Brian Walker
*
*****************************************************************************
*
*   Change Log:
*
*   Date     DevSFC   Comment
*   -------- ------   -------------------------------------------------------
*   02-14-95 RamC     Added command line options to support displaying
*                     Router Table, Router Statistics and SAP information.
*                     Basically a merge of ipxroute and Stefan's rttest.
*   03-12-98 Pmay     Added translation of if name to version int the 
                      connections folder.
*****************************************************************************
*
*   Functional Description:
*
*
****************************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <winnls.h>
#include <winuser.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntstapi.h>
#include <nwsap.h>
#include <stropts.h>
#include <mprapi.h>
#include <winnlsp.h>
#include "errno.h"
#include "tdi.h"
#include "isnkrnl.h"
#include "ipxrtmsg.h"
#include "driver.h"
#include "utils.h"


typedef struct _IPX_ROUTE_ENTRY {
    UCHAR Network[4];
    USHORT NicId;
    UCHAR NextRouter[6];
    PVOID NdisBindingContext;
    USHORT Flags;
    USHORT Timer;
    UINT Segment;
    USHORT TickCount;
    USHORT HopCount;
    PVOID AlternateRoute[2];
    PVOID NicLinkage[2];
    struct {
	PVOID Linkage[2];
	ULONG Reserved[1];
    } PRIVATE;
} IPX_ROUTE_ENTRY, * PIPX_ROUTE_ENTRY;




IPX_ROUTE_ENTRY      rte;

/** Global Variables **/

int sr_def      = 0;
int sr_bcast    = 0;
int sr_multi    = 0;
int boardnum    = 0;
int clear       = 0;
int config      = 0;
int showtable   = 0;
int showservers = 0;
int showstats   = 0;
int clearstats  = 0;
int ripout      = 0;
int resolveguid = 0;
int resolvename = 0;
int servertype;
unsigned long netnum;
char nodeaddr[6];               /* Node address to remove */
HANDLE nwlinkfd;
HANDLE isnipxfd;
HANDLE isnripfd;
char ebuffer[128];

char nwlinkname[] = "\\Device\\Streams\\NWLinkIpx";
wchar_t isnipxname[] = L"\\Device\\NwlnkIpx";
wchar_t isnripname[] = L"\\Device\\Ipxroute";
char pgmname[] = "IPXROUTE";
#define SHOW_ALL_SERVERS 0XFFFF

/** **/

#define INVALID_HANDLE  (HANDLE)(-1)

/** Structure to send REMOVE with **/

typedef struct rterem {
    int  rterem_bnum;           /* Board number */
    char rterem_node[6];        /* Node to remove */
} rterem;

typedef int (__cdecl * PQSORT_COMPARE)(const void * p0, const void * p1);

/** Internal Function Prototypes **/

extern void print_table(int);
extern void usage(void);
extern void print_version(void);
extern char *print_type(int);
extern int my_strncmp(char *, char *, int);
extern int get_board_num(char *, int *);
extern int get_node_num(char *, char *);
extern int get_server_type(char *, int *);
extern unsigned char get_hex_byte(char *);
extern int get_driver_parms(void);
extern int set_driver_parms(void);
extern int do_strioctl(HANDLE, int, char *, int, int);
extern void remove_address(char *);
extern void clear_table(void);
extern void print_config(void);
extern unsigned long get_emsg(int);
int do_isnipxioctl(HANDLE fd, int cmd, char *datap, int dlen);
unsigned long put_msg(BOOLEAN error, unsigned long MsgNum, ... );
char *load_msg( unsigned long MsgNum, ... );
extern void show_router_table(PHANDLE, PIO_STATUS_BLOCK);
extern void show_stats(HANDLE, PIO_STATUS_BLOCK);
extern void clear_stats(HANDLE, PIO_STATUS_BLOCK);
extern void show_servers(int);
extern void show_ripout(unsigned long); 
extern void resolve_guid(char *);
extern void resolve_name(char *);
extern int __cdecl CompareServerNames( void * p0, void * p1);
extern int __cdecl CompareNetNumber( void * p0, void * p1);

/*page*************************************************************
        m a i n

        This is the main routine that gets executed when a NET START
        happens.

        Arguments - None

        Returns - Nothing
********************************************************************/
void __cdecl main(int argc, char **argv)
{
    char *p;
    int todo;
    int remove_flag;
    UNICODE_STRING FileString;
    OBJECT_ATTRIBUTES ObjectAttributes, RouterObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock, RouterIoStatusBlock;
    NTSTATUS Status;

    // Set language code page to system locale.
    SetThreadUILanguage(0);

    /** **/

    print_version();

    /** Open the nwlink driver **/

    nwlinkfd = s_open(nwlinkname, 0, 0);

    /** Open the isnipx driver **/

    RtlInitUnicodeString (&FileString, isnipxname);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    Status = NtOpenFile(
                 &isnipxfd,
                 SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                 &ObjectAttributes,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_SYNCHRONOUS_IO_ALERT);

    if (!NT_SUCCESS(Status)) {
        isnipxfd = INVALID_HANDLE;
        put_msg (TRUE, MSG_OPEN_FAILED, "\\Device\\NwlnkIpx");
    }

    /** Open the isnrip driver **/

    RtlInitUnicodeString (&FileString, isnripname);

    InitializeObjectAttributes(
        &RouterObjectAttributes,
        &FileString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    Status = NtOpenFile(
                 &isnripfd,
                 SYNCHRONIZE | GENERIC_READ,
                 &RouterObjectAttributes,
                 &RouterIoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_SYNCHRONOUS_IO_NONALERT);

    if (!NT_SUCCESS(Status)) {
        isnripfd = INVALID_HANDLE;
        // don't display any error message, but display the
        // message that the IPX router is not started when
        // the user actually tries to look at the router.
    }

    if ((nwlinkfd == INVALID_HANDLE) &&
        (isnipxfd == INVALID_HANDLE) &&
        (isnripfd == INVALID_HANDLE))
    {
        exit(1);
    }    

    /** Go thru the command line and set it up **/

    argc--;
    argv++;

    /** Parse the command line **/

    todo = 0;
    remove_flag = 0;
    while (argc--) {

        /** Uppercase the arg **/

        p = *argv;
        _strupr(p);

        /** Parse the argument **/

        //if (!strcmp(p, "CLEAR")) {
        //    todo  = 1;
        //    clear = 1;
        // }
        /*else*/ if (!strcmp(p, "DEF")) {
            todo   = 1;
            sr_def = 1;
        }
        else if (!strcmp(p, "GBR")) {
            todo     = 1;
            sr_bcast = 1;
        }
        else if (!strcmp(p, "MBR")) {
            todo     = 1;
            sr_multi = 1;
        }
        else if (!strcmp(p, "CONFIG")) {
            todo   = 1;
            config = 1;
        }
        else if (!my_strncmp(p, "BOARD=", 6))
            get_board_num(p + 6, &boardnum);
        else if (!my_strncmp(p, "REMOVE=", 7)) {
            remove_flag = 1;
            get_node_num(p + 7, nodeaddr);
        }
        //else if (!strcmp(p, "TABLE")) {
        //   todo = 1;
        //   showtable = 1;
        // }
        else if (!strcmp(p, "SERVERS")) {
           todo = 1;
           showservers = 1;
           /** default is to show all server types **/
           servertype = SHOW_ALL_SERVERS;
           argv++;
           if(argc--) {
               p = *argv;
               _strupr(p);
               if (!my_strncmp(p, "/TYPE=", 6)) {
                  get_server_type(p + 6, &servertype);
               }
               else
                  usage();
           }
           /** no more arguments - break out of while lop **/
           else
              break;
        }
        else if (!strcmp(p, "RIPOUT")) {
           todo = 1;
           ripout = 1;
           /** default look for local network **/
           netnum = 0L;
           argv++;
           if(argc--) {
               p = *argv;
               netnum = strtoul (p, NULL, 16);
               if (netnum == 0)
                  usage();
           }
           /** no more arguments - break out of while lop **/
           else
              break;
        }
        else if (!strcmp(p, "RESOLVE")) {
           argv++;
           if(argc--) {
               p = *argv;
               if (!strcmp(p, "guid")) {
                   todo = 1;
                   resolveguid = 1;
                   argc--;
                   argv++;
                   p = *argv;
               }
               else if (!strcmp(p, "name")) {
                   todo = 1;
                   resolvename = 1;
                   argc--;
                   argv++;
                   p = *argv;
               }
               else
                  usage();
           }
           /** no more arguments - break out of while lop **/
           else
              break;
        }
        //else if (!strcmp(p, "STATS")) {
        //   todo = 1;
        //   /** default is to show the router statistics **/
        //   showstats = 1;
        //   argv++;
        //   if(argc--) {
        //       p = *argv;
        //       _strupr(p);
        //       if (!strcmp(p, "/CLEAR")) {
        //          clearstats = 1;
        //          showstats = 0;
        //       }
        //       else if (!strcmp(p, "/SHOW")) {
        //          showstats = 1;
        //       }
        //       else
        //          usage;
        //   }
        //   /** no more arguments - break out of while lop **/
        //   else
        //      break;
        // }
        else
            usage();

        /** Goto the next entry **/

        argv++;
    }

    /** Go update the driver **/

#if 0
    printf("todo       = %d\n", todo);
    printf("remove_flag= %d\n", remove_flag);
    printf("Clear flag = %d\n", clear);
    printf("Config flag = %d\n", config);
    printf("SR_DEF     = %d\n", sr_def);
    printf("SR_BCAST   = %d\n", sr_bcast);
    printf("SR_MULTI   = %d\n", sr_multi);
    printf("Board      = %d\n", boardnum);
    printf("Node       = %02x:%02x:%02x:%02x:%02x:%02x\n",
        (unsigned char)nodeaddr[0],
        (unsigned char)nodeaddr[1],
        (unsigned char)nodeaddr[2],
        (unsigned char)nodeaddr[3],
        (unsigned char)nodeaddr[4],
        (unsigned char)nodeaddr[5]);
#endif

    /** If we have a remove - go remove it and leave **/

    if (remove_flag)
        remove_address(nodeaddr);       /* Does not return */

    /** If clear - go clear the source routing table **/

    if (clear)
        clear_table();          /* Does not return */

    /** If config - print out config **/

    if (config)
        print_config();         /* Does not return */

    /** If showtable - print out routing table **/

    if (showtable)
        show_router_table(&isnripfd, &RouterIoStatusBlock); /* Does not return */

    /** If showservers - print out selected servers list **/

    if (showservers)
        show_servers(servertype);         /* Does not return */

    /** If ripout - rip out and print results **/

    if (ripout)
        show_ripout(netnum);         /* Does not return */

    /** If resolveguid - resolve a guid name **/

    if (resolveguid)
        resolve_guid(p);         /* Does not return */
        
    /** If resolvename - resolve a friendly name **/

    if (resolvename)
        resolve_name(p);         /* Does not return */
        
    /** If showstats - print out statistics **/

    if (showstats)
        show_stats(&isnripfd, &RouterIoStatusBlock);    /* Does not return */

    /** If clearstats - go clear statistics **/

    if (clearstats)
        clear_stats(&isnripfd, &RouterIoStatusBlock);  /* Does not return */

    /** If there is nothing to do - just print out everything **/

    if (!todo) {

        /** Get the driver parms **/

        if (get_driver_parms()) {
            if (isnipxfd != INVALID_HANDLE) NtClose(isnipxfd);
            if (nwlinkfd != INVALID_HANDLE) NtClose(nwlinkfd);
            if (isnripfd != INVALID_HANDLE) NtClose(isnripfd);
            exit(1);
        }

        /** Print out the table (Never comes back) **/

        print_table(1);
    }

    /** Go set the parameters **/

    set_driver_parms();

    /** Print the table out **/

    print_table(0);

    /** All Done **/

    if (isnipxfd != INVALID_HANDLE) NtClose(isnipxfd);
    if (nwlinkfd != INVALID_HANDLE) NtClose(nwlinkfd);
    if (isnripfd != INVALID_HANDLE) NtClose(isnripfd);
    exit(0);
}

/*page*************************************************************
        p r i n t _ t a b l e

        Print out the status of the source routing.

        Arguments - flag = 0 - Do NOT print the table
                           1 - Do print the table (Never returns)

        Returns - Nothing
********************************************************************/
void print_table(int flag)
{
    /** Print the information **/

    char * ptype;

    printf("\n");
    ptype = print_type(sr_def);
    put_msg (FALSE, MSG_DEFAULT_NODE, ptype);
    LocalFree (ptype);
    printf("\n");

    ptype = print_type(sr_bcast);
    put_msg (FALSE, MSG_BROADCAST, ptype);
    LocalFree (ptype);
    printf("\n");

    ptype = print_type(sr_multi);
    put_msg (FALSE, MSG_MULTICAST, ptype);
    LocalFree (ptype);
    printf("\n");

    if (!flag)
        return;

#if 0
    printf("\n");
    printf("        Node Address    Source Route\n");
    printf("\n");
#endif

    /** All Done **/

    if (isnipxfd != INVALID_HANDLE) NtClose(isnipxfd);
    if (nwlinkfd != INVALID_HANDLE) NtClose(nwlinkfd);
    if (isnripfd != INVALID_HANDLE) NtClose(isnripfd);
    exit(0);
}

/*page*************************************************************
        u s a g e

        Print the usage message.

        Arguments - None

        Returns - Nothing
********************************************************************/
void usage(void)
{
    put_msg( FALSE, MSG_USAGE, pgmname );

    /** All Done **/

    if (isnipxfd != INVALID_HANDLE) NtClose(isnipxfd);
    if (nwlinkfd != INVALID_HANDLE) NtClose(nwlinkfd);
    if (isnripfd != INVALID_HANDLE) NtClose(isnripfd);
    exit(0);
}

/*page*************************************************************
        p r i n t _ v e r s i o n

        Print the version number

        Arguments - None

        Returns - Nothing
********************************************************************/
void print_version(void)
{
    printf("\n");
    put_msg (FALSE, MSG_VERSION);
    return;
}

/*page*************************************************************
        p r i n t _ t y p e

        Returns the broadcast type given in a string, the caller
        must free the string.

        Arguments - 0 = SINGLE ROUTE
                    Else = ALL ROUTES

        Returns - Nothing
********************************************************************/
char *print_type(int flag)
{
    if (flag)
        return load_msg (MSG_ALL_ROUTE);
    else
        return load_msg (MSG_SINGLE_ROUTE);

}

/*page*************************************************************
        m y _ s t r n c m p

        Given a string (p), see if the first len chars are the same
        as those of the 2nd string (s).

        Arguments - p = Ptr to first string
                    s = Ptr to 2nd string
                    len = Length to check

        Returns - 0 = Matched
                  Else = Not matched
********************************************************************/
int my_strncmp(char *p, char *s, int len)
{
    /** **/

    while (len--) {
        if (*p++ != *s++)
            return 1;
    }

    /** They matched **/

    return 0;
}

/*page*************************************************************
        g e t _ b o a r d _ n u m

        Get the decimal number from the command line

        Arguments - p = Ptr to the ASCII number
                    nump = Store the number here

        Returns - 0 = Got the number OK
                  Else = Bad number
********************************************************************/
int get_board_num(char *p, int *nump)
{
    *nump = atoi(p);
    return 0;
}

/*page*************************************************************
        g e t _ n o d e _ n u m

        Get a node address from the command line

        Arguments - p = Ptr to the ASCII number
                    nodep = Store the node number here

        Returns - 0 = Got the number OK
                  Else = Bad number
********************************************************************/
int get_node_num(char *p, char *nodep)
{
    int i;
    unsigned char c1;
    unsigned char c2;

    /** **/

    if (strlen(p) != 12) {
        put_msg (TRUE, MSG_INVALID_REMOVE);
        exit(1);
    }

    /** Get the number **/

    for (i = 0 ; i < 6 ; i++) {

        /** Get the next 2 digits **/

        c1 = get_hex_byte(p++);
        c2 = get_hex_byte(p++);

        /** If we got a bad number - return error **/

        if ((c1 == 0xFF) || (c2 == 0xFF)) {
            put_msg (TRUE, MSG_INVALID_REMOVE);
            exit(1);
        }

        /** Set the next byte **/

        *nodep++ = (c1 << 4) + c2;
    }

    /** Return OK **/

    return 0;
}

/*page*************************************************************
        g e t _ s e r v e r _ t y p e

        Get the decimal number from the command line

        Arguments - p = Ptr to the ASCII number
                    nump = Store the number here

        Returns - 0 = Got the number OK
                  Else = Bad number
********************************************************************/
int get_server_type(char *p, int *nump)
{
    *nump = atoi(p);
    return 0;
}

/*page*************************************************************
        g e t _ h e x _ b y t e

        Take 1 ascii hex chars and convert to a hex byte

        Arguments - p = Ptr to the ASCII number

        Returns - The number
                  (0xFF = Error)
********************************************************************/
unsigned char get_hex_byte(char *p)
{
    unsigned char c;

    /** Get the char **/

    c = *(unsigned char *)p;

    /** If 0-9 handle it **/

    if ((c >= '0') && (c <= '9')) {
        c -= '0';
        return c;
    }

    /** If A-F handle it **/

    if ((c >= 'A') && (c <= 'F')) {
        c -= ('A' - 10);
        return c;
    }

    /** This is a bad number **/

    return 0xFF;
}


/*page***************************************************************
        g e t _ d r i v e r _ p a r m s

        Get the parameters from the driver

        Arguments - None

        Returns - 0 = OK
                  else = Error
********************************************************************/
int get_driver_parms()
{
    int rc;
    int buffer[4];

    /** Set the board number **/

    buffer[0] = boardnum;
    sr_def   = 0;
    sr_bcast = 0;
    sr_multi = 0;

    /** Get the parms **/

    if (nwlinkfd != INVALID_HANDLE) {
        rc = do_strioctl(nwlinkfd, MIPX_SRGETPARMS, (char *)buffer, 4*sizeof(int), 0);
        if (rc) {

            /** Get the error code **/

            rc = GetLastError();
            put_msg (TRUE, MSG_BAD_PARAMETERS, "nwlink");
            put_msg (TRUE, get_emsg(rc));

            /** Return the error **/

            return rc;
        }
    }

    if (isnipxfd != INVALID_HANDLE) {
        rc = do_isnipxioctl(isnipxfd, MIPX_SRGETPARMS, (char *)buffer, 4*sizeof(int));
        if (rc) {

            put_msg (TRUE, MSG_BAD_PARAMETERS, "nwlnkipx");
            put_msg (TRUE, get_emsg(rc));

            /** Return the error **/

            return rc;
        }
    }

    /** Get the variables **/

    sr_def   = buffer[1];
    sr_bcast = buffer[2];
    sr_multi = buffer[3];

    /** Return OK **/

    return 0;
}

/*page***************************************************************
        s e t _ d r i v e r _ p a r m s

        Set the parameters for the driver

        Arguments - None

        Returns - 0 = OK
                  else = Error
********************************************************************/
int set_driver_parms()
{
    int rc;
    int buffer[2];

    /** Set the DEFAULT parm **/

    buffer[0] = boardnum;
    buffer[1] = sr_def;

    if (nwlinkfd != INVALID_HANDLE) {
        rc = do_strioctl(nwlinkfd, MIPX_SRDEF, (char *)buffer, 2 * sizeof(int), 0);
        if (rc) {
            rc = GetLastError();
            put_msg (TRUE, MSG_SET_DEFAULT_ERROR, "nwlink");
            put_msg (TRUE, get_emsg(rc));
            return rc;
        }
    }
    if (isnipxfd != INVALID_HANDLE) {
        rc = do_isnipxioctl(isnipxfd, MIPX_SRDEF, (char *)buffer, 2 * sizeof(int));
        if (rc) {
            put_msg (TRUE, MSG_SET_DEFAULT_ERROR, "nwlnkipx");
            put_msg (TRUE, get_emsg(rc));
            return rc;
        }
    }

    /** Set the BROADCAST parm **/

    buffer[0] = boardnum;
    buffer[1] = sr_bcast;

    if (nwlinkfd != INVALID_HANDLE) {
        rc = do_strioctl(nwlinkfd, MIPX_SRBCAST, (char *)buffer, 2 * sizeof(int), 0);
        if (rc) {
            rc = GetLastError();
            put_msg (TRUE, MSG_SET_BROADCAST_ERROR, "nwlink");
            put_msg (TRUE, get_emsg(rc));
            return rc;
        }
    }
    if (isnipxfd != INVALID_HANDLE) {
        rc = do_isnipxioctl(isnipxfd, MIPX_SRBCAST, (char *)buffer, 2 * sizeof(int));
        if (rc) {
            put_msg (TRUE, MSG_SET_BROADCAST_ERROR, "nwlnkipx");
            put_msg (TRUE, get_emsg(rc));
            return rc;
        }
    }

    /** Set the MULTICAST parm **/

    buffer[0] = boardnum;
    buffer[1] = sr_multi;

    if (nwlinkfd != INVALID_HANDLE) {
        rc = do_strioctl(nwlinkfd, MIPX_SRMULTI, (char *)buffer, 2 * sizeof(int), 0);
        if (rc) {
            rc = GetLastError();
            put_msg (TRUE, MSG_SET_MULTICAST_ERROR, "nwlink");
            put_msg (TRUE, get_emsg(rc));
            return rc;
        }
    }
    if (isnipxfd != INVALID_HANDLE) {
        rc = do_isnipxioctl(isnipxfd, MIPX_SRMULTI, (char *)buffer, 2 * sizeof(int));
        if (rc) {
            put_msg (TRUE, MSG_SET_MULTICAST_ERROR, "nwlnkipx");
            put_msg (TRUE, get_emsg(rc));
            return rc;
        }
    }

    /** Return OK **/

    return 0;
}

/*page***************************************************************
        d o _ s t r i o c t l

        Do a stream ioctl

        Arguments - fd     = Handle to put on
                    cmd    = Command to send
                    datap  = Ptr to ctrl buffer
                    dlen   = Ptr to len of data buffer
                    timout = Timeout value

        Returns - 0 = OK
                  else = Error
********************************************************************/
int do_strioctl(HANDLE fd, int cmd, char *datap, int dlen, int timout)
{
    int rc;
    struct strioctl io;

    /** Fill out the structure **/

    io.ic_cmd    = cmd;
    io.ic_dp     = datap;
    io.ic_len    = dlen;
    io.ic_timout = timout;

    /** Issue the ioctl **/

    rc = s_ioctl(fd, I_STR, &io);

    /** All Done **/

    return rc;
}

/*page***************************************************************
        r e m o v e _ a d d r e s s

        Remove an address from the source routing table.

        Arguments - nodep = Ptr to node address to remove

        Returns - Does not return
********************************************************************/
void remove_address(char *nodep)
{
    int rc;
    int len;
    rterem buf;

    /** Build the area to send down to the driver **/

    buf.rterem_bnum = boardnum;
    memcpy(buf.rterem_node, nodep, 6);
    len = sizeof(int) + 6;

    /** Send the ioctl to remove the address **/

    if (nwlinkfd != INVALID_HANDLE) {
        rc = do_strioctl(nwlinkfd, MIPX_SRREMOVE, (char *)&buf, len, 0);
        if (rc) {
            rc = GetLastError();
            put_msg (TRUE, MSG_REMOVE_ADDRESS_ERROR, "nwlink");
            put_msg (TRUE, get_emsg(rc));
        }
    }
    if (isnipxfd != INVALID_HANDLE) {
        rc = do_isnipxioctl(isnipxfd, MIPX_SRREMOVE, (char *)&buf, len);
        if (rc) {
            put_msg (TRUE, MSG_REMOVE_ADDRESS_ERROR, "nwlnkipx");
            if (rc == EINVAL) {
                put_msg (TRUE, MSG_ADDRESS_NOT_FOUND);
            } else {
                put_msg (TRUE, get_emsg(rc));
            }
        }
    }

    /** Close up and exit **/

    if (isnipxfd != INVALID_HANDLE) NtClose(isnipxfd);
    if (nwlinkfd != INVALID_HANDLE) NtClose(nwlinkfd);
    if (isnripfd != INVALID_HANDLE) NtClose(isnripfd);
    exit(0);
}

/*page***************************************************************
        c l e a r _ t a b l e

        Clear out the routing table

        Arguments - None

        Returns - Does not return
********************************************************************/
void clear_table(void)
{
    int rc;

    /** Send the ioctl to clear the table **/

    if (nwlinkfd != INVALID_HANDLE) {
        rc = do_strioctl(nwlinkfd, MIPX_SRCLEAR, (char *)&boardnum, sizeof(int), 0);
        if (rc) {
            rc= GetLastError();
            put_msg (TRUE, MSG_CLEAR_TABLE_ERROR, "nwlink");
            put_msg (TRUE, get_emsg(rc));
        }
    }
    if (isnipxfd != INVALID_HANDLE) {
        rc = do_isnipxioctl(isnipxfd, MIPX_SRCLEAR, (char *)&boardnum, sizeof(int));
        if (rc) {
            put_msg (TRUE, MSG_CLEAR_TABLE_ERROR, "nwlnkipx");
            put_msg (TRUE, get_emsg(rc));
        }
    }

    /** Close up and exit **/

    if (isnipxfd != INVALID_HANDLE) NtClose(isnipxfd);
    if (nwlinkfd != INVALID_HANDLE) NtClose(nwlinkfd);
    if (isnripfd != INVALID_HANDLE) NtClose(isnripfd);
    exit(0);
}

/*
typedef struct _ISN_ACTION_GET_DETAILS {
    USHORT NicId;          // passed by caller
    BOOLEAN BindingSet;    // returns TRUE if in set
    UCHAR Type;            // 1 = lan, 2 = up wan, 3 = down wan
    ULONG FrameType;       // returns 0 through 3
    ULONG NetworkNumber;   // returns virtual net if NicId is 0
    UCHAR Node[6];         // adapter's MAC address.
    WCHAR AdapterName[64]; // terminated with Unicode NULL
} ISN_ACTION_GET_DETAILS, *PISN_ACTION_GET_DETAILS;
*/

#define REORDER_ULONG(_Ulong) \
    ((((_Ulong) & 0xff000000) >> 24) | \
     (((_Ulong) & 0x00ff0000) >> 8) | \
     (((_Ulong) & 0x0000ff00) << 8) | \
     (((_Ulong) & 0x000000ff) << 24))


void show_ripout(unsigned long netnum) {
    int rc;
	ISN_ACTION_GET_LOCAL_TARGET Target;

    if (isnipxfd != INVALID_HANDLE) {
        ZeroMemory (&Target, sizeof (Target));
        Target.IpxAddress.NetworkAddress = REORDER_ULONG(netnum);

        rc = do_isnipxioctl(isnipxfd, MIPX_LOCALTARGET, (char *)&Target, sizeof(Target));
        if (rc)
            put_msg (TRUE, MSG_RIPOUT_NOTFOUND);
        else
            put_msg (TRUE, MSG_RIPOUT_FOUND);
    }        

    exit(0);    
}

#define mbtowc(wname, aname) MultiByteToWideChar(CP_ACP,0,aname,-1,wname,1024)

void resolve_guid(char * guidname) {
    WCHAR pszName[512], pszGuidName[1024];
    char * psz;
    HANDLE hMpr;
    DWORD dwErr;
    
    if (MprConfigServerConnect(NULL, &hMpr) != NO_ERROR)
        return;

    mbtowc(pszGuidName, guidname);
    dwErr = MprConfigGetFriendlyName(hMpr, pszGuidName, pszName, sizeof(pszName));

    if (dwErr == NO_ERROR) 
        put_msg (TRUE, MSG_RESOLVEGUID_OK, pszName);
    else 
        put_msg (TRUE, MSG_RESOLVEGUID_NO, guidname);

    MprConfigServerDisconnect(hMpr);
    
    exit(0);    
}

void resolve_name(char * name) {
    WCHAR pszName[1024], pszGuidName[1024];
    char * pszGuid;
    DWORD dwErr;
    HANDLE hMpr;

    if (MprConfigServerConnect(NULL, &hMpr) != NO_ERROR)
        return;

    // Convert to wc and look up the name
    mbtowc (pszName, name);

    dwErr = MprConfigGetGuidName(hMpr, pszName, pszGuidName, sizeof(pszGuidName));
    if (dwErr == NO_ERROR)
        put_msg (TRUE, MSG_RESOLVENAME_OK, pszGuidName);
    else        
        put_msg (TRUE, MSG_RESOLVENAME_NO);

    // Cleanup interface map
    MprConfigServerDisconnect(hMpr);
    
    exit(0);    
}


/*page***************************************************************
        p r i n t _ c o n f i g

        Prints out the current config

        Arguments - None

        Returns - Does not return
********************************************************************/
void print_config(void)
{
    int rc;
    int nicidcount;
    USHORT nicid; 
    int showlegend = 0;
    char nicidbuf[6];
    char network[9];
    char * frametype;
    char node[13];
    char special[2];
    char adaptername[64];
    ISN_ACTION_GET_DETAILS getdetails;
    HANDLE hMpr;
    DWORD dwErr;

    // Initialize the map from guid to interface name
    MprConfigServerConnect(NULL, &hMpr);

    if (isnipxfd != INVALID_HANDLE) {

        /** First query nicid 0 **/

        getdetails.NicId = 0;

        rc = do_isnipxioctl(isnipxfd, MIPX_CONFIG, (char *)&getdetails, sizeof(getdetails));
        if (rc) {
            put_msg (TRUE, MSG_QUERY_CONFIG_ERROR, "nwlnkipx");
            put_msg (TRUE, get_emsg(rc));
            goto errorexit;
        }

        printf("\n");

        put_msg (FALSE, MSG_NET_NUMBER_HDR);
        
        if (getdetails.NetworkNumber != 0) {
            sprintf (network, "%.8x", REORDER_ULONG(getdetails.NetworkNumber));
            put_msg(FALSE, MSG_SHOW_INTERNAL_NET, network);
        }

        //
        // The NicId 0 query returns the total number.
        //

        nicidcount = getdetails.NicId;

        for (nicid = 1; nicid <= nicidcount; nicid++) {

            getdetails.NicId = nicid;

            rc = do_isnipxioctl(isnipxfd, MIPX_CONFIG, (char *)&getdetails, sizeof(getdetails));
            if (rc) {
                continue;
            }

            sprintf (nicidbuf, "%d.", nicid);
            sprintf (network, "%.8x", REORDER_ULONG(getdetails.NetworkNumber));

            switch (getdetails.FrameType) {
                case 0: frametype = load_msg (MSG_ETHERNET_II); break;
                case 1: frametype = load_msg (MSG_802_3); break;
                case 2: frametype = load_msg (MSG_802_2); break;
                case 3: frametype = load_msg (MSG_SNAP); break;
                case 4: frametype = load_msg (MSG_ARCNET); break;
                default: frametype = load_msg (MSG_UNKNOWN); break;
            }

            // Translate the adapter name
            if (getdetails.Type == 1) {     // lan
                WCHAR pszName[512];
                PWCHAR pszGuid = &(getdetails.AdapterName[0]);

                dwErr = MprConfigGetFriendlyName(hMpr, pszGuid, pszName, sizeof(pszName));
    			if (dwErr == NO_ERROR)
        			sprintf (adaptername, "%ws", pszName);
        	    else
                    sprintf (adaptername, "%ws", getdetails.AdapterName);
            }
            else
                sprintf (adaptername, "%ws", getdetails.AdapterName);

            sprintf (node, "%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x",
                getdetails.Node[0],
                getdetails.Node[1],
                getdetails.Node[2],
                getdetails.Node[3],
                getdetails.Node[4],
                getdetails.Node[5]);

            special[1] = '\0';
            if (getdetails.BindingSet) {
                special[0] = '*';
                showlegend |= 1;
            } else if (getdetails.Type == 2) {
                special[0] = '+';
                showlegend |= 2;
            } else if (getdetails.Type == 3) {
                special[0] = '-';
                showlegend |= 4;
            } else {
                special[0] = '\0';
            }

            put_msg (FALSE, MSG_SHOW_NET_NUMBER,
                nicidbuf,
                network,
                frametype,
                adaptername,
                node,
                special);

            LocalFree (frametype);

        }

        if (showlegend) {
            put_msg (FALSE, MSG_NET_NUMBER_LEGEND_HDR);
            if (showlegend & 1) {
                put_msg (FALSE, MSG_LEGEND_BINDING_SET);
            }
            if (showlegend & 2) {
                put_msg (FALSE, MSG_LEGEND_ACTIVE_WAN);
            }
            if (showlegend & 4) {
                put_msg (FALSE, MSG_LEGEND_DOWN_WAN);
            }
            printf("\n");
        }

    }

errorexit:

    /** Close up and exit **/

    // Cleanup interface map
    MprConfigServerDisconnect(hMpr);

    if (isnipxfd != INVALID_HANDLE) NtClose(isnipxfd);
    if (nwlinkfd != INVALID_HANDLE) NtClose(nwlinkfd);
    if (isnripfd != INVALID_HANDLE) NtClose(isnripfd);
    exit(0);
}

/*page***************************************************************
        g e t _ e m s g

        Get an error message for an error

        Arguments - None

        Returns - Does not return
********************************************************************/
unsigned long get_emsg(int rc)
{
    /**
        We have 3 defined error codes that can come back.

        1 - EINVAL means that we sent down parameters wrong
                   (SHOULD NEVER HAPPEN)

        2 - ERANGE means that the board number is invalid
                   (CAN HAPPEN IF USER ENTERS BAD BOARD)

        3 - ENOENT means that on remove - the address given
                   is not in the source routing table.
    **/

    switch (rc) {

    case EINVAL:
        return MSG_INTERNAL_ERROR;

    case ERANGE:
        return MSG_INVALID_BOARD;

    case ENOENT:
        return MSG_ADDRESS_NOT_FOUND;

    default:
        return MSG_UNKNOWN_ERROR;
    }

}

/*page***************************************************************
        d o _ i s n i p x i o c t l

        Do the equivalent of a stream ioctl to isnipx

        Arguments - fd     = Handle to put on
                    cmd    = Command to send
                    datap  = Ptr to ctrl buffer
                    dlen   = Ptr to len of data buffer

        Returns - 0 = OK
                  else = Error
********************************************************************/
int do_isnipxioctl(HANDLE fd, int cmd, char *datap, int dlen)
{
    NTSTATUS Status;
    UCHAR buffer[sizeof(NWLINK_ACTION) + sizeof(ISN_ACTION_GET_DETAILS) - 1];
    PNWLINK_ACTION action;
    IO_STATUS_BLOCK IoStatusBlock;
    int rc;

    /** Fill out the structure **/

    action = (PNWLINK_ACTION)buffer;

    action->Header.TransportId = ISN_ACTION_TRANSPORT_ID;
    action->OptionType = NWLINK_OPTION_CONTROL;
    action->BufferLength = sizeof(ULONG) + dlen;
    action->Option = cmd;
    RtlMoveMemory(action->Data, datap, dlen);

    /** Issue the ioctl **/

    Status = NtDeviceIoControlFile(
                 fd,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 IOCTL_TDI_ACTION,
                 NULL,
                 0,
                 action,
                 FIELD_OFFSET(NWLINK_ACTION,Data) + dlen);

    if (Status != STATUS_SUCCESS) {
        if (Status == STATUS_INVALID_PARAMETER) {
            rc = ERANGE;
        } else {
            rc = EINVAL;
        }
    } else {
        if (dlen > 0) {
            RtlMoveMemory (datap, action->Data, dlen);
        }
        rc = 0;
    }

    return rc;

}


//*****************************************************************************
//
// Name:        put_msg
//
// Description: Reads a message resource, formats it in the current language
//              and displays the message.
//
// NOTE: This routine was stolen from net\sockets\tcpcmd\common2\util.c.
//
// Parameters:  error - TRUE if this is an error message.
//              unsigned long MsgNum: ID of the message resource.
//
// Returns:     unsigned long: number of characters displayed.
//
// History:
//  01/05/93  JayPh     Created.
//
//*****************************************************************************

unsigned long put_msg(BOOLEAN error, unsigned long MsgNum, ... )
{
    unsigned long     msglen;
    char    *vp;
    char    *oemp;  
    va_list   arglist;

    va_start( arglist, MsgNum );
    msglen = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_FROM_HMODULE,
                            NULL,
                            MsgNum,
                            0L,         // Default country ID.
                            (LPTSTR)&vp,
                            0,
                            &arglist );
    if ( (msglen == 0) || (vp == NULL))
    {
        return ( 0 );
    }

    oemp = (char *) malloc(msglen*sizeof(char) + 1); 
    if (oemp != NULL) {

       CharToOem(vp, oemp); 

       fprintf( error ? stderr : stdout, "%s", oemp );
       free(oemp); 
    } else {
       printf("Failed to allocate memory of %d bytes\n",msglen*sizeof(char)); 
    }

    LocalFree( vp );

    return ( msglen );
}


//*****************************************************************************
//
// Name:        load_msg
//
// Description: Reads and formats a message resource and returns a pointer
//              to the buffer containing the formatted message.  It is the
//              responsibility of the caller to free the buffer.
//
// NOTE: This routine was stolen from net\sockets\tcpcmd\common2\util.c.
//
// Parameters:  unsigned long MsgNum: ID of the message resource.
//
// Returns:     char *: pointer to the message buffer, NULL if error.
//
// History:
//  01/05/93  JayPh     Created.
//
//*****************************************************************************

char *load_msg( unsigned long MsgNum, ... )
{
    unsigned long     msglen;
    char    *vp;
    va_list   arglist;

    va_start( arglist, MsgNum );
    msglen = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_FROM_HMODULE,
                            NULL,
                            MsgNum,
                            0L,         // Default country ID.
                            (LPTSTR)&vp,
                            0,
                            &arglist );
    if ( msglen == 0 )
    {
        return(0);
    }

    return ( vp );
}


#define MAX_NETWORK_INTERFACES 255

typedef struct router_info
{
   ULONG  NetNumber;
   USHORT TickCount;
   USHORT HopCount;
   USHORT NicId;
   UCHAR  InterfaceNumber[10];
} ROUTER_INFO, *PROUTER_INFO;

/*page***************************************************************
        s h o w _ r o u t e r _ t a b l e

        Display the IPX routing table

        Arguments - FileHandle = Router File Handle
                    IoStatusBlock = Device IO Status Block

        Returns - Does not return
********************************************************************/
VOID
show_router_table(
    PHANDLE		    FileHandle,
    PIO_STATUS_BLOCK    IoStatusBlock
)
{
    SHOW_NIC_INFO   nis[MAX_NETWORK_INTERFACES];
    ULONG	    NetNumber;
    char            InterfaceNumber[10];
    NTSTATUS Status;
    USHORT index, i, NumEntries, count;
    char router_entry[128];
    char buffer[32];
    PROUTER_INFO RouterInfo = NULL;

    if (*FileHandle == INVALID_HANDLE) {
       put_msg(TRUE, MSG_IPXROUTER_NOT_STARTED );
       goto exit_show_table;
    }
    /** First get the Network numbers for all interfaces **/

    index = 0;
    while(TRUE) {

	Status = NtDeviceIoControlFile(
		 *FileHandle,		    // HANDLE to File
		 NULL,			    // HANDLE to Event
		 NULL,			    // ApcRoutine
		 NULL,			    // ApcContext
		 IoStatusBlock,		    // IO_STATUS_BLOCK
		 IOCTL_IPXROUTER_SHOWNICINFO,	 // IoControlCode
		 &index,			    // Input Buffer
		 sizeof(USHORT),	    // Input Buffer Length
		 &nis[index],		    // Output Buffer
		 sizeof(SHOW_NIC_INFO));    // Output Buffer Length

	if(IoStatusBlock->Status == STATUS_NO_MORE_ENTRIES) {
            break;
	}

        index ++;

	if(Status != STATUS_SUCCESS) {
            sprintf(buffer, "%x", Status);
	    put_msg(TRUE, MSG_SHOWSTATS_FAILED, buffer);
            goto exit_show_table;
	}

        if (index >= MAX_NETWORK_INTERFACES) {
           // break out of this loop if there are more than 255 network
           // interfaces because we only have storage for 255.

           break;
        }

    }

    Status = NtDeviceIoControlFile(
		 *FileHandle,		    // HANDLE to File
		 NULL,			    // HANDLE to Event
		 NULL,			    // ApcRoutine
		 NULL,			    // ApcContext
		 IoStatusBlock,		    // IO_STATUS_BLOCK
		 IOCTL_IPXROUTER_SNAPROUTES,	 // IoControlCode
		 NULL,			    // Input Buffer
		 0,			    // Input Buffer Length
		 NULL,			    // Output Buffer
		 0);			    // Output Buffer Length

    if (IoStatusBlock->Status != STATUS_SUCCESS) {
            sprintf(buffer, "%x", Status);
            put_msg(TRUE, MSG_SNAPROUTES_FAILED, buffer);
            goto exit_show_table;
    }

    // first determine the number of router table entries to
    // allocate sufficient storage

    NumEntries = 0;
    while(TRUE) {

      	Status = NtDeviceIoControlFile(
      		 *FileHandle,		    // HANDLE to File
      		 NULL,			    // HANDLE to Event
      		 NULL,			    // ApcRoutine
      		 NULL,			    // ApcContext
      		 IoStatusBlock,		    // IO_STATUS_BLOCK
      		 IOCTL_IPXROUTER_GETNEXTROUTE,	 // IoControlCode
      		 NULL,			    // Input Buffer
      		 0,			    // Input Buffer Length
      		 &rte,			    // Output Buffer
      		 sizeof(IPX_ROUTE_ENTRY));  // Output Buffer Length

      	if(IoStatusBlock->Status == STATUS_NO_MORE_ENTRIES) {
      	    break;
      	}

      	if(Status != STATUS_SUCCESS) {
            sprintf(buffer,"%x",Status);
      	    put_msg(TRUE, MSG_GETNEXTROUTE_FAILED, buffer);
      	    goto exit_show_table;
      	}

        NumEntries ++;
    }

    RouterInfo = (PROUTER_INFO) LocalAlloc(LPTR, sizeof(ROUTER_INFO) * NumEntries);
    if(!RouterInfo) {
        put_msg(FALSE, MSG_INSUFFICIENT_MEMORY);
        goto exit_show_table;
    }

    Status = NtDeviceIoControlFile(
		 *FileHandle,		    // HANDLE to File
		 NULL,			    // HANDLE to Event
		 NULL,			    // ApcRoutine
		 NULL,			    // ApcContext
		 IoStatusBlock,		    // IO_STATUS_BLOCK
		 IOCTL_IPXROUTER_SNAPROUTES,	 // IoControlCode
		 NULL,			    // Input Buffer
		 0,			    // Input Buffer Length
		 NULL,			    // Output Buffer
		 0);			    // Output Buffer Length

    if (IoStatusBlock->Status != STATUS_SUCCESS) {
            sprintf(buffer, "%x", Status);
            put_msg(TRUE, MSG_SNAPROUTES_FAILED, buffer);
            goto exit_show_table;
    }

    index = 0;

    while(TRUE) {

      	Status = NtDeviceIoControlFile(
      		 *FileHandle,		    // HANDLE to File
      		 NULL,			    // HANDLE to Event
      		 NULL,			    // ApcRoutine
      		 NULL,			    // ApcContext
      		 IoStatusBlock,		    // IO_STATUS_BLOCK
      		 IOCTL_IPXROUTER_GETNEXTROUTE,	 // IoControlCode
      		 NULL,			    // Input Buffer
      		 0,			    // Input Buffer Length
      		 &rte,			    // Output Buffer
      		 sizeof(IPX_ROUTE_ENTRY));  // Output Buffer Length

      	if(IoStatusBlock->Status == STATUS_NO_MORE_ENTRIES) {
      	    break;
      	}

      	if(Status != STATUS_SUCCESS) {
            sprintf(buffer,"%x",Status);
      	    put_msg(TRUE, MSG_GETNEXTROUTE_FAILED, buffer);
      	    goto exit_show_table;
      	}

        // make sure we don't exceed the number of entries
        if (index > NumEntries) {
           break;
        }

      	// get net nr in "on the wire" order

        GETLONG2ULONG(&(RouterInfo[index].NetNumber), rte.Network);

        // find out the matching Network number based on NIC ID
        for(i=0; i < MAX_NETWORK_INTERFACES; i++) {
            if(rte.NicId == nis[i].NicId) {
               sprintf(RouterInfo[index].InterfaceNumber, "%.2x%.2x%.2x%.2x",
                       nis[i].Network[0],
                       nis[i].Network[1],
                       nis[i].Network[2],
                       nis[i].Network[3]);
               break;
            }
        }
        RouterInfo[index].TickCount = rte.TickCount;
        RouterInfo[index].HopCount  = rte.HopCount;
        RouterInfo[index].NicId     = rte.NicId;

        index++;
   }

    // Now sort the entries by net number
    qsort( (void*) RouterInfo,
           NumEntries,
           sizeof(ROUTER_INFO),
           (PQSORT_COMPARE)CompareNetNumber );

   put_msg(FALSE, MSG_ROUTER_TABLE_HEADER);
   for(index =0, count = 0; index < NumEntries; index++, count++)
   {
        if (count > 50) {
            count = 0;
            // display router table header every 25 entries
            // to make reading the table easier.
            put_msg(FALSE, MSG_ROUTER_TABLE_HEADER);
        }
        printf("%.8x          %6d        %2d        %-16s        %d\n",
                RouterInfo[index].NetNumber,
                RouterInfo[index].TickCount,
                RouterInfo[index].HopCount,
                RouterInfo[index].InterfaceNumber,
                RouterInfo[index].NicId );
    }
    /** Close up and exit **/
exit_show_table:
    if (RouterInfo) LocalFree(RouterInfo);
    if (isnipxfd != INVALID_HANDLE) NtClose(isnipxfd);
    if (nwlinkfd != INVALID_HANDLE) NtClose(nwlinkfd);
    if (isnripfd != INVALID_HANDLE) NtClose(isnripfd);
    exit(0);
}

int __cdecl CompareNetNumber( void * p0, void * p1)
{
   PROUTER_INFO pLeft = (PROUTER_INFO) p0;
   PROUTER_INFO pRight = (PROUTER_INFO) p1;

   if(pLeft->NetNumber == pRight->NetNumber)
      return(0);
   if(pLeft->NetNumber > pRight->NetNumber)
      return(1);
   else
      return(-1);
}

PUCHAR	DeviceType[2] = { "LAN", "WAN" };
PUCHAR	NicState[4] = { "CLOSED", "CLOSING", "ACTIVE", "PENDING_OPEN" };

/*page***************************************************************
        s h o w _ s t a t s

        Displays IPX internal routing statistics

        Arguments - FileHandle = Router File Handle
                    IoStatusBlock = Device IO Status Block

        Returns - Does not return
********************************************************************/
VOID
show_stats(
    PHANDLE	    FileHandle,
    PIO_STATUS_BLOCK    IoStatusBlock
)
{
    SHOW_NIC_INFO   nis;
    USHORT	    index, i;
    char            NicId[4];
    char            NetworkNumber[10];
    char            RipRcvd[32], RipSent[32];
    char            RoutedRcvd[32], RoutedSent[32];
    char            Type20Rcvd[32], Type20Sent[32];
    char            BadRcvd[32];
    char            buffer[32];

    NTSTATUS Status;

    if (*FileHandle == INVALID_HANDLE) {
       put_msg(TRUE, MSG_IPXROUTER_NOT_STARTED );
       goto end_stats;
    }

    index = 0;

    while(TRUE) {

	Status = NtDeviceIoControlFile(
		 *FileHandle,		    // HANDLE to File
		 NULL,			    // HANDLE to Event
		 NULL,			    // ApcRoutine
		 NULL,			    // ApcContext
		 IoStatusBlock,		    // IO_STATUS_BLOCK
		 IOCTL_IPXROUTER_SHOWNICINFO,	 // IoControlCode
		 &index,			    // Input Buffer
		 sizeof(USHORT),	    // Input Buffer Length
		 &nis,			    // Output Buffer
		 sizeof(nis));	// Output Buffer Length

	if(IoStatusBlock->Status == STATUS_NO_MORE_ENTRIES) {
            goto end_stats;
	}

        index ++;

	if(Status != STATUS_SUCCESS) {
            sprintf(buffer, "%x", Status);
	    put_msg(TRUE, MSG_SHOWSTATS_FAILED, buffer);
            goto end_stats;
	}

	sprintf(NicId, "%d", nis.NicId);

	sprintf(NetworkNumber,
                "%.2x%.2x%.2x%.2x",
                nis.Network[0],
                nis.Network[1],
                nis.Network[2],
                nis.Network[3]);

	sprintf(RipRcvd, "%-8d", nis.StatRipReceived);

	sprintf(RipSent, "%-8d", nis.StatRipSent);

	sprintf(RoutedRcvd, "%-8d", nis.StatRoutedReceived);

	sprintf(RoutedSent, "%-8d", nis.StatRoutedSent);

  	sprintf(Type20Rcvd, "%-8d", nis.StatType20Received);

	sprintf(Type20Sent, "%-8d", nis.StatType20Sent);

	sprintf(BadRcvd, "%-8d", nis.StatBadReceived);

        put_msg(FALSE,
                MSG_SHOW_STATISTICS,
                NicId,
                NetworkNumber,
                RipRcvd,
                RipSent,
                Type20Rcvd,
                Type20Sent,
                RoutedRcvd,
                RoutedSent,
                BadRcvd);

    }

    /** Close up and exit **/

end_stats:
    if (isnipxfd != INVALID_HANDLE) NtClose(isnipxfd);
    if (nwlinkfd != INVALID_HANDLE) NtClose(nwlinkfd);
    if (isnripfd != INVALID_HANDLE) NtClose(isnripfd);
    exit(0);
}

/*page***************************************************************
        c l e a r _ s t a t s

        Clears the IPX internal routing statistics

        Arguments - FileHandle = Router File Handle
                    IoStatusBlock = Device IO Status Block

        Returns - Does not return
********************************************************************/
VOID
clear_stats(
    PHANDLE	        FileHandle,
    PIO_STATUS_BLOCK    IoStatusBlock
)
{
    NTSTATUS Status;
    char     buffer[32];

    if (*FileHandle == INVALID_HANDLE) {
       put_msg(TRUE, MSG_IPXROUTER_NOT_STARTED );
       goto end_clearstats;
    }

    Status = NtDeviceIoControlFile(
		 *FileHandle,		    // HANDLE to File
		 NULL,			    // HANDLE to Event
		 NULL,			    // ApcRoutine
		 NULL,			    // ApcContext
		 IoStatusBlock,		    // IO_STATUS_BLOCK
		 IOCTL_IPXROUTER_ZERONICSTATISTICS,	 // IoControlCode
		 NULL,			    // Input Buffer
		 0,			    // Input Buffer Length
		 NULL,			    // Output Buffer
		 0);			    // Output Buffer Length

    if(Status != STATUS_SUCCESS) {
        sprintf(buffer, "%x", Status);
        put_msg(TRUE, MSG_CLEAR_STATS_FAILED, buffer);
    }
    /** Close up and exit **/
end_clearstats:
    if (isnipxfd != INVALID_HANDLE) NtClose(isnipxfd);
    if (nwlinkfd != INVALID_HANDLE) NtClose(nwlinkfd);
    if (isnripfd != INVALID_HANDLE) NtClose(isnripfd);
    exit(0);
}

typedef struct server_info
{
   USHORT ObjectType;
   UCHAR ObjectName[100];
   UCHAR IpxAddress[12];
} SERVER_INFO, *PSERVER_INFO;

/*page***************************************************************
        s h o w _ s e r v e r s

        Display the servers from the SAP table

        Arguments - servertype = Type of servers to display
                                 Defaults to show all server types

        Returns - Does not return
********************************************************************/
VOID
show_servers(int servertype)
{
    INT     rc;
    ULONG   ObjectID = 0xFFFFFFFF;
    UCHAR   ObjectName[100];
    USHORT  ObjectType;
    USHORT  ScanType = (USHORT) servertype;
    UCHAR   IpxAddress[12];
    USHORT  i;
    USHORT  index, count, NumServers;

    PSERVER_INFO ServerInfo = NULL;

    if(rc = SapLibInit() != SAPRETURN_SUCCESS) {
       put_msg(TRUE, MSG_SAP_NOT_STARTED);
       goto show_servers_end;
    }

    memset(&ObjectName, 0, 100);

     // find out how many servers are there so that we can allocate
     // sufficient storage
     NumServers = 0;

     while((rc =  SapScanObject(&ObjectID,
                  ObjectName,
                       &ObjectType,
                       ScanType)) == SAPRETURN_SUCCESS)
     {
        NumServers++;
     }

     ServerInfo = (PSERVER_INFO) LocalAlloc(LPTR, sizeof(SERVER_INFO) * NumServers);
     if(!ServerInfo)
     {
        put_msg(FALSE, MSG_INSUFFICIENT_MEMORY);
        goto show_servers_end;
     }

     index = 0;
     ObjectID = 0xFFFFFFFF;

     while((rc =  SapScanObject(&ObjectID,
                  ObjectName,
                       &ObjectType,
                       ScanType)) == SAPRETURN_SUCCESS)
     {
         if (index >= NumServers) {
            break;
         }

         // get object address
         SapGetObjectName(ObjectID,
                           ObjectName,
                          &ObjectType,
                          IpxAddress);

         ServerInfo[index].ObjectType = ObjectType;
         strcpy(ServerInfo[index].ObjectName, ObjectName);
         CopyMemory(ServerInfo[index].IpxAddress, IpxAddress, 12);

         index++;
     }

     // Now sort the entries by server name
     qsort( (void*) ServerInfo,
            NumServers,
            sizeof(SERVER_INFO),
            (PQSORT_COMPARE)CompareServerNames );

     if(servertype == SHOW_ALL_SERVERS)
        put_msg(FALSE, MSG_SHOW_ALL_SERVERS_HEADER);
     else
        put_msg(FALSE, MSG_SHOW_SPECIFIC_SERVER_HEADER);

     for(index = 0, count = 0; index < NumServers; index++, count++)
     {
         if (count > 50) {
            // write the table header for every 50 entries
            // to make this more readable.
            count = 0;

         if(servertype == SHOW_ALL_SERVERS)
            put_msg(FALSE, MSG_SHOW_ALL_SERVERS_HEADER);
         else
            put_msg(FALSE, MSG_SHOW_SPECIFIC_SERVER_HEADER);
         }

         for(i=0; i<4; i++) {
              printf("%.2x", ServerInfo[index].IpxAddress[i]);
         }
         printf(".");
         for(i=4; i<10; i++) {
             printf("%.2x", ServerInfo[index].IpxAddress[i]);
         }

         if(servertype == SHOW_ALL_SERVERS) {
             printf("        %-6d", ServerInfo[index].ObjectType);
         }

         printf("        %s\n", ServerInfo[index].ObjectName);
    }

    /** Close up and exit **/
show_servers_end:
    if (ServerInfo) LocalFree(ServerInfo);
    if (isnipxfd != INVALID_HANDLE) NtClose(isnipxfd);
    if (nwlinkfd != INVALID_HANDLE) NtClose(nwlinkfd);
    if (isnripfd != INVALID_HANDLE) NtClose(isnripfd);
    exit(0);
}

int __cdecl CompareServerNames( void * p0, void * p1)
{
   PSERVER_INFO pLeft = (PSERVER_INFO) p0;
   PSERVER_INFO pRight = (PSERVER_INFO) p1;

   return(strcmp(pLeft->ObjectName, pRight->ObjectName));
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\kdext\ipxext.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    ipxext.c

Abstract:

    This file contains kernel debugger extensions for examining the
    IPX structures.

Author:

    Heath Hunnicutt (T-HeathH) 3-Aug-1995

Environment:

    User Mode

--*/
#include "precomp.h"
#pragma hdrstop

#include "config.h"
#include "mac.h"
#include "ipxtypes.h"

#define LIMIT_BINDINGS 25

//
// Local function prototypes
//
VOID DumpDeviceObject
(
    ULONG DevObjToDump,
    VERBOSITY Verbosity
);

VOID
DumpIpxDevice
(
    ULONG     DeviceToDump,
    VERBOSITY Verbosity
);

VOID
DumpIpxSend
(
    ULONG     IpxSendToDump,
    VERBOSITY Verbosity
);

VOID
DumpIpxReceive
(
    ULONG     IpxReceiveToDump,
    VERBOSITY Verbosity
);

VOID
DumpIpxAddress
(
    ULONG AddressToDump,
    VERBOSITY Verbosity
);

VOID
DumpIpxAddressFile
(
    ULONG AddressFileToDump,
    VERBOSITY Verbosity
);

VOID
DumpIpxBinding
(
    ULONG BindingToDump,
    VERBOSITY Verbosity
);

VOID
DumpIpxRouterSegment
(
    ULONG SegmentToDump,
    VERBOSITY Verbosity
);

VOID
DumpIpxRequest
(
    ULONG RequestToDump,
    VERBOSITY Verbosity
);

VOID
DumpIpxAdapter
(
    ULONG AdapterToDump,
    VERBOSITY Verbosity
);

VOID
DumpIpxIrpStack
(
    PREQUEST pRequest,
    VERBOSITY Verbosity
);


ENUM_INFO EnumIrpMajorFunction[] =
{
    EnumString( IRP_MJ_CREATE                   ),
    EnumString( IRP_MJ_CREATE_NAMED_PIPE        ),
    EnumString( IRP_MJ_CLOSE                    ),
    EnumString( IRP_MJ_READ                     ),
    EnumString( IRP_MJ_WRITE                    ),
    EnumString( IRP_MJ_QUERY_INFORMATION        ),
    EnumString( IRP_MJ_SET_INFORMATION          ),
    EnumString( IRP_MJ_QUERY_EA                 ),
    EnumString( IRP_MJ_SET_EA                   ),
    EnumString( IRP_MJ_FLUSH_BUFFERS            ),
    EnumString( IRP_MJ_QUERY_VOLUME_INFORMATION ),
    EnumString( IRP_MJ_SET_VOLUME_INFORMATION   ),
    EnumString( IRP_MJ_DIRECTORY_CONTROL        ),
    EnumString( IRP_MJ_FILE_SYSTEM_CONTROL      ),
    EnumString( IRP_MJ_DEVICE_CONTROL           ),
    EnumString( IRP_MJ_INTERNAL_DEVICE_CONTROL  ),
    EnumString( IRP_MJ_SHUTDOWN                 ),
    EnumString( IRP_MJ_LOCK_CONTROL             ),
    EnumString( IRP_MJ_CLEANUP                  ),
    EnumString( IRP_MJ_CREATE_MAILSLOT          ),
    EnumString( IRP_MJ_QUERY_SECURITY           ),
    EnumString( IRP_MJ_SET_SECURITY             ),
    EnumString( IRP_MJ_POWER                    ),
//    EnumString( IRP_MJ_SYSTEM_CONTROL           ),
    EnumString( IRP_MJ_DEVICE_CHANGE            ),
    EnumString( IRP_MJ_QUERY_QUOTA              ),
    EnumString( IRP_MJ_SET_QUOTA                ),
    { 0, NULL }
};

ENUM_INFO EnumIrpMinorFunction[ IRP_MJ_MAXIMUM_FUNCTION + 1 ][ 18 ] =
{
    {{ 0, NULL}}, // IRP_MJ_CREATE
    {{ 0, NULL}}, // IRP_MJ_CREATE_NAMED_PIPE
    {{ 0, NULL}}, // IRP_MJ_CLOSE
    {{ 0, NULL}}, // IRP_MJ_READ
    {{ 0, NULL}}, // IRP_MJ_WRITE
    {{ 0, NULL}}, // IRP_MJ_QUERY_INFORMATION
    {{ 0, NULL}}, // IRP_MJ_SET_INFORMATION
    {{ 0, NULL}}, // IRP_MJ_QUERY_EA
    {{ 0, NULL}}, // IRP_MJ_SET_EA
    {{ 0, NULL}}, // IRP_MJ_FLUSH_BUFFERS
    {{ 0, NULL}}, // IRP_MJ_QUERY_VOLUME_INFORMATION
    {{ 0, NULL}}, // IRP_MJ_SET_VOLUME_INFORMATION
    {{ 0, NULL}}, // IRP_MJ_DIRECTORY_CONTROL
    {{ 0, NULL}}, // IRP_MJ_FILE_SYSTEM_CONTROL
    {{ 0, NULL}}, // IRP_MJ_DEVICE_CONTROL
    {   // IRP_MJ_INTERNAL_DEVICE_CONTROL
        EnumString( TDI_ASSOCIATE_ADDRESS    ),
        EnumString( TDI_DISASSOCIATE_ADDRESS ),
        EnumString( TDI_CONNECT              ),
        EnumString( TDI_LISTEN               ),
        EnumString( TDI_ACCEPT               ),
        EnumString( TDI_DISCONNECT           ),
        EnumString( TDI_SEND                 ),
        EnumString( TDI_RECEIVE              ),
        EnumString( TDI_SEND_DATAGRAM        ),
        EnumString( TDI_RECEIVE_DATAGRAM     ),
        EnumString( TDI_SET_EVENT_HANDLER    ),
        EnumString( TDI_QUERY_INFORMATION    ),
        EnumString( TDI_SET_INFORMATION      ),
        EnumString( TDI_ACTION               ),
        EnumString( TDI_DIRECT_SEND          ),
        EnumString( TDI_DIRECT_SEND_DATAGRAM ),
        { 0, NULL }
    },
    {{ 0, NULL}}, // IRP_MJ_SHUTDOWN
    {{ 0, NULL}}, // IRP_MJ_LOCK_CONTROL
    {{ 0, NULL}}, // IRP_MJ_CLEANUP
    {{ 0, NULL}}, // IRP_MJ_CREATE_MAILSLOT
    {{ 0, NULL}}, // IRP_MJ_QUERY_SECURITY
    {{ 0, NULL}}, // IRP_MJ_SET_SECURITY
    {{ 0, NULL}}, // IRP_MJ_QUERY_POWER
    {{ 0, NULL}}, // IRP_MJ_SET_POWER
    {{ 0, NULL}}, // IRP_MJ_DEVICE_CHANGE
    {{ 0, NULL}}, // IRP_MJ_QUERY_QUOTA
    {{ 0, NULL}}, // IRP_MJ_SET_QUOTA
};


ENUM_INFO EnumAddressFileState[] =
{
    EnumString( ADDRESSFILE_STATE_OPENING   ),
    EnumString( ADDRESSFILE_STATE_OPEN      ),
    EnumString( ADDRESSFILE_STATE_CLOSING   ),
    { 0, NULL }
};


ENUM_INFO EnumBindingFrameType[] =
{
    EnumString( ISN_FRAME_TYPE_802_2 ),
    EnumString( ISN_FRAME_TYPE_802_3 ),
    EnumString( ISN_FRAME_TYPE_ETHERNET_II ),
    EnumString( ISN_FRAME_TYPE_SNAP ),
    { 0, NULL }
};

ENUM_INFO EnumSendReservedIdentifier[] =
{
    EnumString( IDENTIFIER_NB ),
    EnumString( IDENTIFIER_SPX ),
    EnumString( IDENTIFIER_RIP ),
    EnumString( IDENTIFIER_IPX ),
    EnumString( IDENTIFIER_RIP_INTERNAL ),
    EnumString( IDENTIFIER_RIP_RESPONSE ),

    { 0, NULL }
};

ENUM_INFO EnumSendReservedDestinationType[] =
{
    EnumString( DESTINATION_DEF ),
    EnumString( DESTINATION_BCAST ),
    EnumString( DESTINATION_MCAST ),
    { 0, NULL }
};

FLAG_INFO FlagsRouteEntry[] =
{
   {IPX_ROUTER_PERMANENT_ENTRY,"Permanent"},
   {IPX_ROUTER_LOCAL_NET,"Local Net"},
   {IPX_ROUTER_SCHEDULE_ROUTE, "Call Schedule Route"},
   {IPX_ROUTER_GLOBAL_WAN_NET,"Global Wan Net"},
   {0, NULL}
};

MEMBER_TABLE IpxDeviceMembers[] =
{
    {   "GlobalSendPacketList",
        FIELD_OFFSET( DEVICE, GlobalSendPacketList ),
        DumpIpxSend,
        NextListEntry,
        PrevListEntry,
        FIELD_OFFSET( NDIS_PACKET, ProtocolReserved ) + FIELD_OFFSET( IPX_SEND_RESERVED, GlobalLinkage )
    },

    {   "GlobalReceivePacketList",
        FIELD_OFFSET( DEVICE, GlobalReceivePacketList ),
        DumpIpxReceive,
        NextListEntry,
        PrevListEntry,
        FIELD_OFFSET( NDIS_PACKET, ProtocolReserved ) + FIELD_OFFSET( IPX_RECEIVE_RESERVED, GlobalLinkage )
    },

    { NULL }
};


///////////////////////////////////////////////////////////////////////
//                      DEVICE
//////////////////////////////////////////////////////////////////////


//
// Exported functions
//



VOID ipxdev_usage( VOID )
{
    dprintf( "Use me!\n" );
}

DECLARE_API( ipxdev )

/*++

Routine Description:

    Dumps the most important fields of the specified DEVICE_CONTEXT object

Arguments:

    args - Address

Return Value:

    None

--*/

{
    ULONG  deviceToDump = 0;
    ULONG  pDevice = 0;
    ULONG  result;
    char VarName[ MAX_LIST_VARIABLE_NAME_LENGTH + 1 ];
    MEMBER_VARIABLE_INFO MemberInfo;
    BOOL bFocusOnMemberVariable = FALSE;

    if ( *args )
    {
        bFocusOnMemberVariable = ReadArgsForTraverse( args, VarName );
    }

    if ( *args && *args!='-' )
    {
        if (!sscanf(args, "%lx", &deviceToDump))
		{
			return;
		}
    }

    if ( deviceToDump == 0 ) {

        pDevice    =   GetExpression( "nwlnkipx!IpxDevice" );

        if ( !pDevice ) {
            dprintf("Could not get nwlnkipx!IpxDevice, Try !reload\n");
            return;
        } else {

            if (!ReadMemory(pDevice,
                     &deviceToDump,
                     sizeof(deviceToDump),
                     &result
                     )
               )
            {
                dprintf("%08lx: Could not read device address\n", pDevice);
                return;
            }
        }

    }

    if ( bFocusOnMemberVariable )
    {
        if ( !LocateMemberVariable( "IpxDevice", VarName, ( PVOID )deviceToDump, &MemberInfo ))
        {
            return;
        }

        WriteMemberInfo( &MemberInfo );
        next( hCurrentProcess, hCurrentThread, dwCurrentPc, dwProcessor, "" );
        return;
    }

    DumpIpxDevice(deviceToDump, VERBOSITY_NORMAL );

    return;
}



#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        Device
#define _objAddr    DeviceToDump
#define _objType    DEVICE
//
// Local functions
//

VOID
DumpIpxDevice
(
    ULONG     DeviceToDump,
    VERBOSITY Verbosity
)

/*++

Routine Description:

    Dumps the fields of the specified DEVICE_CONTEXT structure

Arguments:

    DeviceToDump  - The device context object to display
    Full          - Display a partial listing if 0, full listing otherwise.

Return Value:

    None

--*/

{
    DEVICE         Device;
    ULONG          result;
    unsigned int index;
    BIND_ARRAY_ELEM Bindings[ LIMIT_BINDINGS ];
    WCHAR Buffer[ 1000 ];
    PWCHAR pDeviceName = NULL;

    if (!ReadMemory(
             DeviceToDump,
             &Device,
             sizeof(Device),
             &result
             )
       )
    {
        dprintf("%08lx: Could not read device context\n", DeviceToDump);
        return;
    }
    if (Device.Type != IPX_DEVICE_SIGNATURE)
    {
        dprintf( "Signature does not match, probably not a device object %lx\n", DeviceToDump);
        dprintf( "Device.Type == %04X, and I think it should be %04X\n", Device.Type, IPX_DEVICE_SIGNATURE );
        dprintf( "DeviceToDump = %08X\n", DeviceToDump );
        dprintf( "Offset to Device.Type = %d\n", FIELD_OFFSET( DEVICE, Type ) );
        return;
    }

    if ( !ReadMemory( ( ULONG )Device.DeviceName,
                      Buffer,
                      sizeof( WCHAR ) * Device.DeviceNameLength,
                      &result ))
    {
        dprintf("%08lx: Could not read device name buffer\n", Device.DeviceName );
    }
    else
    {
        pDeviceName = Buffer;
    }

    if ( Verbosity == VERBOSITY_ONE_LINER )
    {
        dprintf( "\"%S\"", pDeviceName );
        return;
    }

    dprintf("Device General Info ");
    PrintStartStruct();

#if DBG
#   if DREF_TOTAL != 13
#       error The DREF_TOTAL constant has changed, and so must ipxext.c
#   endif

    PrintULong( RefTypes[ DREF_CREATE ] );
    PrintULong( RefTypes[ DREF_LOADED ] );
    PrintULong( RefTypes[ DREF_ADAPTER ] );
    PrintULong( RefTypes[ DREF_ADDRESS ] );
    PrintULong( RefTypes[ DREF_SR_TIMER ] );
    PrintULong( RefTypes[ DREF_RIP_TIMER ] );
    PrintULong( RefTypes[ DREF_LONG_TIMER ] );
    PrintULong( RefTypes[ DREF_RIP_PACKET ] );
    PrintULong( RefTypes[ DREF_ADDRESS_NOTIFY ] );
    PrintULong( RefTypes[ DREF_LINE_CHANGE ] );
    PrintULong( RefTypes[ DREF_NIC_NOTIFY ] );
    PrintULong( RefTypes[ DREF_BINDING ] );
    PrintULong( RefTypes[ DREF_PNP ] );
#endif

    PrintEnum( Type, EnumStructureType );
    PrintUShort( Size );

#if DBG
    PrintNChar( Signature1, sizeof( Device.Signature1 ));
#endif

    PrintLock( Interlock );

    PrintULong( TempDatagramBytesSent );
    PrintULong( TempDatagramsSent );
    PrintULong( TempDatagramBytesReceived );
    PrintULong( TempDatagramsReceived );

    PrintBool( EthernetPadToEven );
    PrintBool( SingleNetworkActive );
    PrintBool( DisableDialoutSap );
    PrintBool( MultiCardZeroVirtual );

    PrintLock( Lock );
    PrintULong( ReferenceCount );

    PrintStartStruct();
    dprintf( "  ( We are assumed not to be at init time )\n" );
    PrintUShort( MaxBindings );
    
    if ( Device.MaxBindings > LIMIT_BINDINGS )
    {
        dprintf(" isnext can only display the first %d bindings, because malloc() always crashed under the kernel debugger.\n", LIMIT_BINDINGS );
        dprintf(" This device struct has more bindings than that, but you're only going to see some of them.\n" );
        dprintf(" You could always change LIMIT_BINDINGS in ipxext.c and recompile isnext\n" );

        Device.MaxBindings = LIMIT_BINDINGS;
    }
    

    if ( !ReadMemory( ( ULONG )Device.Bindings,
                      Bindings,
                      ((sizeof( PBIND_ARRAY_ELEM )) * Device.MaxBindings),
                      &result ) )
    {
        dprintf( "Could not read Bindings array.\n" );
    }
    else
    {
        for( index = LOOPBACK_NIC_ID; index <= Device.MaxBindings; index ++ )
        {
            if ( Bindings[ index ].Binding != NULL )
            {
                dprintf( "   Bindings[ %d ] = %-10X", index, Bindings[ index ].Binding );
                DumpIpxBinding( ( ULONG )Bindings[ index ].Binding, VERBOSITY_ONE_LINER );
                dprintf( "\n" );
	    }
        }
    }

    PrintEndStruct();

    PrintUShort( ValidBindings );
    PrintUShort( HighestExternalNicId );
    PrintUShort( SapNicCount );
    PrintUShort( HighestType20NicId );
    PrintUShort( HighestLanNicId); 

    PrintLL( GlobalSendPacketList );
    PrintLL( GlobalReceivePacketList );
    PrintLL( GlobalReceiveBufferList );

    PrintLL( AddressNotifyQueue );

    PrintLL( LineChangeQueue );
    PrintLL( SendPoolList );
    PrintLL( ReceivePoolList );

    PrintL( SendPacketList );
    PrintL( ReceivePacketList );

    PrintUChar( State );
    PrintUChar( FrameTypeDefault );

    PrintBool( ActiveNetworkWan );
    PrintBool( VirtualNetwork );
    PrintUShort( FirstLanNicId );
    PrintUShort( FirstWanNicId );
    PrintULong( MemoryUsage );
    PrintULong( MemoryLimit );
    PrintULong( AllocatedDatagrams );
    PrintULong( AllocatedReceivePackets );
    PrintULong( AllocatedPaddingBuffers );
    PrintULong( InitDatagrams );
    PrintULong( MaxDatagrams );
    PrintULong( RipAgeTime );
    PrintULong( RipCount );
    PrintULong( RipTimeout );
    PrintULong( RipUsageTime );
    PrintULong( SourceRouteUsageTime );
    PrintUShort( SocketStart );
    PrintUShort( SocketEnd );
    PrintULong( SocketUniqueness );
    PrintULong( VirtualNetworkNumber );
    PrintULong( EthernetExtraPadding );
    PrintBool( DedicatedRouter );
    PrintBool( VirtualNetworkOptional );
    PrintUChar( DisableDialinNetbios );
    PrintULong( InitReceivePackets );
    PrintULong( InitReceiveBuffers );
    PrintULong( MaxReceivePackets );
    PrintULong( MaxReceiveBuffers );
    PrintUShort( ControlChannelIdentifier );
    PrintUShort( CurrentSocket );
    PrintULong( SegmentCount );

    // MORE - dump actual locks
    PrintPtr( SegmentLocks );
    PrintPtr(Segments); 

    
    for( index = 0; index < Device.SegmentCount; index++ ) {

       DumpIpxRouterSegment((ULONG)&Device.Segments[index], VERBOSITY_NORMAL); 

    }

    PrintLL( WaitingRipPackets );
    PrintULong( RipPacketCount );
    PrintBool( RipShortTimerActive );
    PrintUShort( RipSendTime );

    PrintCTETimer( RipShortTimer );
    PrintCTETimer( RipLongTimer );

    PrintBool( SourceRoutingUsed );    // TRUE if any 802.5 bindings exist.
    PrintUChar( SourceRoutingTime );       // incremented each time timer fires.
    PrintCTETimer( SourceRoutingTimer );
    PrintULong( LinkSpeed );
    PrintULong( MacOptions );
    PrintULong( IncludedHeaderOffset );
    PrintTDIAddress( SourceAddress );

#if IPX_ADDRESS_HASH_COUNT != 16
#   error An assumption is made here concerning the value of IPX_ADDRESS_HASH_COUNT
#endif

    PrintLL( AddressDatabases[ 0 ] );
    PrintLL( AddressDatabases[ 1 ] );
    PrintLL( AddressDatabases[ 2 ] );
    PrintLL( AddressDatabases[ 3 ] );
    PrintLL( AddressDatabases[ 4 ] );
    PrintLL( AddressDatabases[ 5 ] );
    PrintLL( AddressDatabases[ 6 ] );
    PrintLL( AddressDatabases[ 7 ] );
    PrintLL( AddressDatabases[ 8 ] );
    PrintLL( AddressDatabases[ 9 ] );
    PrintLL( AddressDatabases[ 10 ] );
    PrintLL( AddressDatabases[ 11 ] );
    PrintLL( AddressDatabases[ 12 ] );
    PrintLL( AddressDatabases[ 13 ] );
    PrintLL( AddressDatabases[ 14 ] );
    PrintLL( AddressDatabases[ 15 ] );

    PrintPtr( LastAddress );

    PrintPtr( NdisBufferPoolHandle );
    PrintAddr( Information );
    PrintULong( RealMaxDatagramSize );

#if DBG
    PrintNChar( Signature2, sizeof( Device.Signature2 ));
#endif

    PrintFlushLeft();
    PrintBool( AnyUpperDriverBound );
    PrintBool( ForwarderBound );

    if ( Device.AnyUpperDriverBound )
    {
        for ( index = 0; index < UPPER_DRIVER_COUNT; index ++ )
        {
            PrintFlushLeft();

            dprintf( "UpperDriver...[ %d ] = ", index );
            PrintStartStruct();

            PrintFieldName( "UpperDriverBound" );
            PrintRawBool( UpperDriverBound[ index ] );

            if ( !Device.UpperDriverBound[ index ] )
            {
                PrintEndStruct();
                continue;
            }

            PrintFieldName( "ReceiveCompletePending" );
            PrintRawBool( ReceiveCompletePending[ index ] );
            PrintPtr( UpperDriverControlChannel[ index ] );

            PrintSymbolPtr( UpperDrivers[ index ].ReceiveHandler );

            PrintEndStruct();
        }
    }

    PrintFlushLeft();

    PrintULong( EnableBroadcastCount );
    PrintBool( EnableBroadcastPending );
    PrintBool( DisableBroadcastPending );
    PrintBool( ReverseBroadcastOperation );
    PrintBool( WanGlobalNetworkNumber );
    PrintULong( GlobalWanNetwork );
    PrintBool( GlobalNetworkIndicated );
    PrintBool( RipResponder );
    PrintBool( SapWarningLogged );

    PrintWorkQueueItem( BroadcastOperationQueueItem );
    PrintAddr( UnloadEvent );
    PrintBool( UnloadWaiting );
    PrintAddr( Statistics );
    PrintBool( AutoDetect );
    PrintBool( DefaultAutoDetected );
    PrintUChar( AutoDetectState );

    PrintAddr( AutoDetectEvent );
    PrintAddr( IpxStartTime );
    PrintAddr( AddressResource );
    PrintPtr( DeviceObject );

    PrintJoin();
    PrintPtr( DeviceName );
    dprintf( "\"%S\"\n", pDeviceName );

    PrintULong( DeviceNameLength );


    PrintEndStruct();
    PrintEnd

    return;
}


#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        Reserved
#define _objAddr    pReserved
#define _objType    IPX_SEND_RESERVED

VOID
DumpIpxSend
(
    ULONG     IpxSendToDump,
    VERBOSITY Verbosity
)
{
    PIPX_SEND_RESERVED pReserved;
    IPX_SEND_RESERVED Reserved;
    ULONG result;


    pReserved = SEND_RESERVED(( PIPX_SEND_PACKET )IpxSendToDump );

    if ( !ReadMemory( ( ULONG )pReserved,
                      &Reserved,
                      sizeof( Reserved ),
                      &result ))
    {
        dprintf("%08lx: Could not read IPX_SEND_RESERVED structure\n", pReserved );
        return;
    }

    dprintf( "NDIS_PACKET @(0x%08X) ", IpxSendToDump );

    if ( Verbosity == VERBOSITY_ONE_LINER )
    {
        dprintf( "{ " );
        if ( Reserved.Address != NULL )
        {
            DumpIpxAddress( ( ULONG )( Reserved.Address ), VERBOSITY_ONE_LINER );
        }
        else
        {
            dprintf( "(NULL Address)" );
        }

        dprintf( " (" );
        dprint_enum_name( (ULONG) _obj.Identifier, EnumSendReservedIdentifier );
        dprintf( ") }" );
        return;
    }


    PrintStart;
    PrintStartStruct();

    PrintEnum( Identifier, EnumSendReservedIdentifier );

    PrintBool( SendInProgress );
    PrintBool( OwnedByAddress );

    PrintEnum( DestinationType, EnumSendReservedDestinationType );

    PrintPtr( PaddingBuffer );
    PrintPtr( PreviousTail );
    PrintL( PoolLinkage );

    PrintLL( GlobalLinkage );
    PrintLL( WaitLinkage );
#ifdef IPX_TRACK_POOL
    PrintPtr( Pool );
#endif
    PrintJoin();
    PrintPtr( Address );

    if ( Reserved.Address != NULL )
    {
        DumpIpxAddress( ( ULONG )( Reserved.Address ), VERBOSITY_ONE_LINER );
    }

    dprintf( "\n" );

    PrintFlushLeft();

    switch ( Reserved.Identifier )
    {
    case IDENTIFIER_NB:
    case IDENTIFIER_IPX:
    case IDENTIFIER_SPX:
        dprintf( " --- SR_DG part of union ---------------------------\n");
        PrintPtr( u.SR_DG.Request );
        PrintJoin();
        PrintPtr( u.SR_DG.AddressFile );
        if ( Reserved.u.SR_DG.AddressFile != NULL )
        {
            DumpIpxAddressFile( ( ULONG )( Reserved.u.SR_DG.AddressFile ), VERBOSITY_ONE_LINER );
        }

        dprintf( "\n" );

        PrintUShort( u.SR_DG.CurrentNicId );
        PrintBool( u.SR_DG.Net0SendSucceeded );
        PrintBool( u.SR_DG.OutgoingSap );
        break;
    case IDENTIFIER_RIP:
    case IDENTIFIER_RIP_INTERNAL:
    case IDENTIFIER_RIP_RESPONSE:
        PrintStartStruct();
        dprintf( " --- SR_RIP part of union ---------------------------\n");
        PrintULong( u.SR_RIP.Network );
        PrintUShort( u.SR_RIP.CurrentNicId );
        PrintUChar( u.SR_RIP.RetryCount );
        PrintBool( u.SR_RIP.RouteFound );
        PrintUShort( u.SR_RIP.SendTime );
        PrintBool( u.SR_RIP.NoIdAdvance );
        break;
    default:
        dprintf( "*** Couldn't determine which part of union to display.\n" );
    }

    PrintFlushLeft();

    PrintPtr( Header );

    PrintJoin();
    PrintPtr( HeaderBuffer );
    DumpMdlChain( ( ULONG )_obj.HeaderBuffer, VERBOSITY_ONE_LINER );
    dprintf( "\n" );

    PrintEndStruct();

    PrintEnd;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        Reserved
#define _objAddr    pReserved
#define _objType    IPX_RECEIVE_RESERVED

VOID
DumpIpxReceive
(
    ULONG     IpxReceiveToDump,
    VERBOSITY Verbosity
)
{
    _objType *_objAddr;
    _objType _obj;
    ULONG result;

    dprintf( "NDIS_PACKET at 0x%08X\n", IpxReceiveToDump );

    pReserved = RECEIVE_RESERVED(( PIPX_SEND_PACKET )IpxReceiveToDump );

    if ( !ReadMemory( IpxReceiveToDump,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read IPX_SEND_RESERVED structure\n", _objAddr );
        return;
    }

    PrintStartStruct();

    PrintEnum( Identifier, EnumSendReservedIdentifier );

    PrintBool( TransferInProgress );
    PrintBool( OwnedByAddress );

#ifdef IPX_TRACK_POOL
    PrintPtr( Pool );
#endif
    PrintJoin();
    PrintPtr( Address );
    if ( Reserved.Address != NULL )
    {
        DumpIpxAddress( ( ULONG )( Reserved.Address ), VERBOSITY_ONE_LINER );
    }
    dprintf( "\n" );

    PrintPtr( SingleRequest );
    PrintPtr( ReceiveBuffer );

    PrintL( PoolLinkage );

    PrintLL( GlobalLinkage );
    PrintLL( Requests );

    PrintEndStruct();
}


DECLARE_API( ipxaddrfile )
{
    ULONG  AddressFileToDump = 0;
    ULONG  result;
    char VarName[ MAX_LIST_VARIABLE_NAME_LENGTH + 1 ];
    MEMBER_VARIABLE_INFO MemberInfo;
    BOOL bFocusOnMemberVariable = FALSE;

    if ( *args )
    {
        bFocusOnMemberVariable = ReadArgsForTraverse( args, VarName );
    }

    if ( *args && *args!='-' )
    {
        if (!sscanf(args, "%lx", &AddressFileToDump))
		{
			return;
		}
    }

    if ( AddressFileToDump == 0 )
    {
        dprintf( "Please specify an address.\n" );
    }

    if ( bFocusOnMemberVariable )
    {
        if ( !LocateMemberVariable( "IpxAddressFile", VarName, ( PVOID )AddressFileToDump, &MemberInfo ))
        {
            return;
        }

        WriteMemberInfo( &MemberInfo );
        next( hCurrentProcess, hCurrentThread, dwCurrentPc, dwProcessor, "" );
        return;
    }

    DumpIpxAddressFile( AddressFileToDump, VERBOSITY_FULL );

    return;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        AddressFile
#define _objAddr    prAddressFile
#define _objType    ADDRESS_FILE

VOID
DumpIpxAddressFile
(
    ULONG AddressFileToDump,
    VERBOSITY Verbosity
)
{
    _objType _obj;
    _objType *_objAddr;
    ULONG result;

    _objAddr = ( _objType * )AddressFileToDump;

    if ( !ReadMemory( AddressFileToDump,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf( "%08lx: Could not read %s structure\n",
                 AddressFileToDump,
                 "ADDRESS_FILE" );
        return;
    }

    if ( Verbosity == VERBOSITY_ONE_LINER )
    {
        switch ( _obj.State )
        {
        case ADDRESSFILE_STATE_OPENING:
            dprintf( "OPENING " );
            break;
        case ADDRESSFILE_STATE_OPEN:
            dprintf( "OPEN " );
            break;
        case ADDRESSFILE_STATE_CLOSING:
            dprintf( "CLOSING " );
            break;
        default:
            dprintf( "Bogus state " );
            break;
        }
        DumpIpxAddress( ( ULONG )( AddressFile.Address ), VERBOSITY_ONE_LINER );
        return;
    }

    PrintStartStruct();

#if DBG
#   if AFREF_TOTAL != 8
#       error AFREF_TOTAL was assumed to equal 8
#   endif

    PrintULong( RefTypes[ AFREF_CREATE ] );
    PrintULong( RefTypes[ AFREF_RCV_DGRAM ] );
    PrintULong( RefTypes[ AFREF_SEND_DGRAM ] );
    PrintULong( RefTypes[ AFREF_VERIFY ] );
    PrintULong( RefTypes[ AFREF_INDICATION ] );
    PrintULong( RefTypes[ 5 ] );
    PrintULong( RefTypes[ 6 ] );
    PrintULong( RefTypes[ 7 ] );
#endif

    PrintEnum( Type, EnumStructureType );
    PrintUShort( Size );

    PrintLL( Linkage );

    PrintULong( ReferenceCount );

    PrintEnum( State, EnumAddressFileState );

    PrintPtr( AddressLock );

    PrintPtr( Request );

    PrintJoin();
    PrintPtr( Address );
    if ( AddressFile.Address != NULL )
    {
        dprintf( "(" );
        DumpIpxAddress( ( ULONG )( AddressFile.Address ), VERBOSITY_ONE_LINER );
        dprintf( ")" );
    }
    dprintf( "\n" );

#ifdef ISN_NT
    PrintPtr( FileObject );
#endif

    PrintJoin();
    PrintPtr( Device );
    if ( AddressFile.Device != NULL )
    {
        DumpIpxDevice( ( ULONG )( AddressFile.Device ), VERBOSITY_ONE_LINER );
    }
    dprintf( "\n" );

    PrintBool( SpecialReceiveProcessing );

    PrintBool( ExtendedAddressing );
    PrintBool( ReceiveFlagsAddressing );

    PrintBool( ReceiveIpxHeader );

    PrintUChar( DefaultPacketType );

    PrintBool( FilterOnPacketType );

    PrintUChar( FilteredType );

    PrintBool( EnableBroadcast );

    PrintBool( IsSapSocket );

    PrintLL( ReceiveDatagramQueue );

    PrintPtr( CloseRequest );

    PrintBool( RegisteredReceiveDatagramHandler );
    PrintBool( RegisteredErrorHandler );

    PrintSymbolPtr( ReceiveDatagramHandler );
    PrintXULong( ReceiveDatagramHandlerContext );

    PrintSymbolPtr( ErrorHandler );
    PrintXULong( ErrorHandlerContext );
    PrintEndStruct();
}

DECLARE_API( ipxaddr )
{
    ULONG  AddressToDump = 0;
    ULONG  result;
    char VarName[ MAX_LIST_VARIABLE_NAME_LENGTH + 1 ];
    MEMBER_VARIABLE_INFO MemberInfo;
    BOOL bFocusOnMemberVariable = FALSE;

    if ( *args )
    {
        bFocusOnMemberVariable = ReadArgsForTraverse( args, VarName );
    }

    if ( *args && *args!='-' )
    {
        if (!sscanf(args, "%lx", &AddressToDump))
		{
			return;
		}
    }

    if ( AddressToDump == 0 )
    {
        dprintf( "Please specify an address.\n" );
    }

    if ( bFocusOnMemberVariable )
    {
        if ( !LocateMemberVariable( "IpxBinding", VarName, ( PVOID )AddressToDump, &MemberInfo ))
        {
            return;
        }

        WriteMemberInfo( &MemberInfo );
        next( hCurrentProcess, hCurrentThread, dwCurrentPc, dwProcessor, "" );
        return;
    }

    DumpIpxAddress( AddressToDump, VERBOSITY_FULL );

    return;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        Address
#define _objAddr    prAddress
#define _objType    ADDRESS

VOID
DumpIpxAddress
(
    ULONG AddressToDump,
    VERBOSITY Verbosity
)
{
    _objType _obj;
    _objType *_objAddr;
    ULONG result;

    _objAddr = ( _objType * )AddressToDump;

    if ( !ReadMemory( AddressToDump,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf( "%08lx: Could not read %s structure\n",
                 AddressToDump,
                 "ADDRESS" );
        return;
    }

    if ( Verbosity == VERBOSITY_ONE_LINER )
    {
        dprint_hardware_address( _obj.LocalAddress.NodeAddress );
        dprintf( ".%d", Address.LocalAddress.Socket );
        return;
    }

    PrintStartStruct();
#if DBG
#   if AREF_TOTAL != 4
#       error AREF_TOTAL was assumed to equal 4
#   endif

    PrintULong( RefTypes[ AREF_ADDRESS_FILE ] );
    PrintULong( RefTypes[ AREF_LOOKUP ] );
    PrintULong( RefTypes[ AREF_RECEIVE ] );
    PrintULong( RefTypes[ 3 ] );
#endif

    PrintEnum( Type, EnumStructureType );
    PrintUShort( Size );

    PrintLL( Linkage );
    PrintULong( ReferenceCount );
    PrintLock( Lock );

    PrintPtr( Request );

    PrintUShort( Socket );
    PrintUShort( SendSourceSocket );


    PrintBool( Stopping );
    PrintULong( Flags );

    PrintJoin();
    PrintPtr( Device );
    if ( Address.Device != NULL )
    {
        DumpIpxDevice( ( ULONG )( Address.Device ), VERBOSITY_ONE_LINER );
    }
    dprintf( "\n" );

    PrintPtr( DeviceLock );

    PrintLL( AddressFileDatabase );

    PrintTDIAddress( LocalAddress );

    PrintAddr( SendPacket );
    PrintAddr( ReceivePacket );

    PrintAddr( SendPacketHeader );

#ifdef ISN_NT
    PrintStartStruct();

    if ( Address.ReferenceCount )
    {
        PrintULong( u.ShareAccess.OpenCount );
        PrintULong( u.ShareAccess.Readers );
        PrintULong( u.ShareAccess.Writers );
        PrintULong( u.ShareAccess.Deleters );
        PrintULong( u.ShareAccess.SharedRead );
        PrintULong( u.ShareAccess.SharedWrite );
        PrintULong( u.ShareAccess.SharedDelete );
    }
    else
    {
        PrintWorkQueueItem( u.DestroyAddressQueueItem );
    }

    PrintEndStruct();

    PrintPtr( SecurityDescriptor );
#endif

    PrintEndStruct();
}


DECLARE_API( ipxadapter )
{
    ULONG  AdapterToDump = 0;
    ULONG  result;
    char VarName[ MAX_LIST_VARIABLE_NAME_LENGTH + 1 ];
    MEMBER_VARIABLE_INFO MemberInfo;
    BOOL bFocusOnMemberVariable = FALSE;

    if ( *args )
    {
        bFocusOnMemberVariable = ReadArgsForTraverse( args, VarName );
    }

    if ( *args && *args!='-' )
    {
        if (!sscanf(args, "%lx", &AdapterToDump ))
		{
			return;
		}
    }

    if ( AdapterToDump == 0 )
    {
        dprintf( "Please specify an address.\n" );
    }

    if ( bFocusOnMemberVariable )
    {
        if ( !LocateMemberVariable( "IpxAdapter", VarName, ( PVOID )AdapterToDump, &MemberInfo ))
        {
            return;
        }

        WriteMemberInfo( &MemberInfo );
        next( hCurrentProcess, hCurrentThread, dwCurrentPc, dwProcessor, "" );
        return;
    }

    DumpIpxAdapter( AdapterToDump, VERBOSITY_FULL );

    return;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        Adapter
#define _objAddr    prAdapter
#define _objType    ADAPTER

VOID
DumpIpxAdapter
(
    ULONG AdapterToDump,
    VERBOSITY Verbosity
)
{
    _objType _obj;
    _objType *_objAddr;
    ULONG result;
    WCHAR Buffer[ 1000 ];
    PWCHAR pAdapterName = NULL;

    _objAddr = ( _objType * )AdapterToDump;

    if ( !ReadMemory( AdapterToDump,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf( "%08lx: Could not read %s structure\n",
                 AdapterToDump,
                 "ADAPTER" );
        return;
    }

    if ( !ReadMemory( ( ULONG )Adapter.AdapterName,
                      Buffer,
                      sizeof( WCHAR ) * Adapter.AdapterNameLength,
                      &result ))
    {
        dprintf("%08lx: Could not read adapter name structure\n", Adapter.AdapterName );
    }
    else
    {
        pAdapterName = Buffer;
    }

    if ( Verbosity == VERBOSITY_ONE_LINER )
    {
        dprintf( "\"%S\"", pAdapterName );
        return;
    }

    dprintf( "Adapter at 0x%08X\n", AdapterToDump );

    PrintStart;

    PrintEnum( Type, EnumStructureType );
    PrintUShort( Size );
#if DBG
    PrintNChar( Signature1, sizeof( Adapter.Signature1 ));
#endif

    PrintULong( BindingCount );
    PrintPtr( NdisBindingHandle );
    PrintLL( RequestCompletionQueue );

#if ISN_FRAME_TYPE_MAX !=4
#   error ISN_FRAME_TYPE_MAX is no longer 4.
#endif

    PrintULong( DefHeaderSizes[ ISN_FRAME_TYPE_ETHERNET_II ] );
    PrintULong( BcMcHeaderSizes[ ISN_FRAME_TYPE_ETHERNET_II ] );
    PrintPtr( Bindings[ ISN_FRAME_TYPE_ETHERNET_II ] );

    PrintULong( DefHeaderSizes[ ISN_FRAME_TYPE_802_3 ] );
    PrintULong( BcMcHeaderSizes[ ISN_FRAME_TYPE_802_3 ] );
    PrintPtr( Bindings[ ISN_FRAME_TYPE_802_3 ] );

    PrintULong( DefHeaderSizes[ ISN_FRAME_TYPE_802_2 ] );
    PrintULong( BcMcHeaderSizes[ ISN_FRAME_TYPE_802_2 ] );
    PrintPtr( Bindings[ ISN_FRAME_TYPE_802_2 ] );

    PrintULong( DefHeaderSizes[ ISN_FRAME_TYPE_SNAP ] );
    PrintULong( BcMcHeaderSizes[ ISN_FRAME_TYPE_SNAP ] );
    PrintPtr( Bindings[ ISN_FRAME_TYPE_SNAP ] );

    PrintULong( AllocatedReceiveBuffers );
    PrintLL( ReceiveBufferPoolList );
    PrintL( ReceiveBufferList );
    PrintULong( AllocatedPaddingBuffers );
    PrintL( PaddingBufferList );

    PrintBool( BroadcastEnabled );
    PrintPtr( AutoDetectFoundOnBinding );
    PrintBool( AutoDetectResponse );
    PrintBool( DefaultAutoDetected );
    PrintUShort( FirstWanNicId );
    PrintUShort( LastWanNicId );
    PrintULong( WanNicIdCount );
    PrintUShort( BindSap );
    PrintUShort( BindSapNetworkOrder );
    PrintBool( SourceRouting );
    PrintBool( EnableFunctionalAddress );
    PrintBool( EnableWanRouter );
    PrintULong( ConfigMaxPacketSize );

    PrintJoin();
    PrintPtr( AdapterName );
    if ( pAdapterName != NULL )
    {
        dprintf( "\"%S\"", pAdapterName );
    }
    dprintf( "\n" );
    PrintULong( AdapterNameLength );

    PrintJoin();
    PrintPtr( Device );
    if ( Adapter.Device != NULL )
    {
        DumpIpxDevice( ( ULONG )( Adapter.Device ), VERBOSITY_ONE_LINER );
    }
    dprintf( "\n" );

    PrintLock( Lock );
    PrintPtr( DeviceLock );
    PrintHardwareAddress( LocalMacAddress );
    PrintUChar( LastSourceRoutingTime );

    PrintAddr( NdisRequestEvent );
    PrintXULong( NdisRequestStatus );
    PrintXULong( OpenErrorStatus );

    PrintStartStruct();

    PrintULong( MacInfo.MediumType );
    PrintULong( MacInfo.RealMediumType );
    PrintBool( MacInfo.SourceRouting );
    PrintBool( MacInfo.MediumAsync );
    PrintUChar( MacInfo.BroadcastMask );
    PrintULong( MacInfo.CopyLookahead );
    PrintULong( MacInfo.MacOptions );
    PrintULong( MacInfo.MinHeaderLength );
    PrintULong( MacInfo.MaxHeaderLength );

    PrintEndStruct();

    PrintULong( MaxReceivePacketSize );
    PrintULong( MaxSendPacketSize );
    PrintULong( ReceiveBufferSpace );
    PrintULong( MediumSpeed );

#if IDENTIFIER_TOTAL != 4
#   error IDENTIFIER_TOTAL is assumed to equal 4
#endif

    PrintBool( SourceRoutingEmpty[IDENTIFIER_NB] );
    PrintPtr( SourceRoutingHeads[IDENTIFIER_NB] );

    PrintBool( SourceRoutingEmpty[IDENTIFIER_IPX] );
    PrintPtr( SourceRoutingHeads[IDENTIFIER_IPX] );

    PrintBool( SourceRoutingEmpty[IDENTIFIER_SPX] );
    PrintPtr( SourceRoutingHeads[IDENTIFIER_SPX] );

    PrintBool( SourceRoutingEmpty[IDENTIFIER_RIP] );
    PrintPtr( SourceRoutingHeads[IDENTIFIER_RIP] );

    PrintEnd;
}

DECLARE_API( ipxbinding )
{
    ULONG  BindingToDump = 0;
    ULONG  result;
    char VarName[ MAX_LIST_VARIABLE_NAME_LENGTH + 1 ];
    MEMBER_VARIABLE_INFO MemberInfo;
    BOOL bFocusOnMemberVariable = FALSE;

    if ( *args )
    {
        bFocusOnMemberVariable = ReadArgsForTraverse( args, VarName );
    }

    if ( *args && *args!='-' )
    {
        if (!sscanf(args, "%lx", &BindingToDump))
		{
			return;
		}
    }

    if ( BindingToDump == 0 )
    {
        dprintf( "Please specify an address.\n" );
    }

    if ( bFocusOnMemberVariable )
    {
        if ( !LocateMemberVariable( "IpxBinding", VarName, ( PVOID )BindingToDump, &MemberInfo ))
        {
            return;
        }

        WriteMemberInfo( &MemberInfo );
        next( hCurrentProcess, hCurrentThread, dwCurrentPc, dwProcessor, "" );
        return;
    }

    DumpIpxBinding( BindingToDump, VERBOSITY_FULL );

    return;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        Binding
#define _objAddr    pBinding
#define _objType    BINDING

VOID
DumpIpxBinding
(
    ULONG BindingToDump,
    VERBOSITY Verbosity
)
{
    BINDING Binding;
    PBINDING pBinding;
    ULONG result;

    pBinding = ( PBINDING )BindingToDump;

    if ( !ReadMemory( BindingToDump,
                      &Binding,
                      sizeof( Binding ),
                      &result ))
    {
        dprintf("%08lx: Could not read BINDING structure\n", BindingToDump );
        return;
    }

    if ( Verbosity == VERBOSITY_ONE_LINER )
    {
        if ( Binding.Adapter != NULL )
        {
            DumpIpxAdapter( ( ULONG )( Binding.Adapter ), VERBOSITY_ONE_LINER );
        }

        dprintf( " %s\n", Binding.LineUp ? "UP" : "DOWN" );
        return;
    }

    dprintf( "Binding at 0x%08X\n", BindingToDump );

    PrintStart;
    PrintStartStruct();

#if DBG
#   if BREF_TOTAL != 5
#       error The BREF_TOTAL constant has changed, and so must ipxext.c
#   endif

    PrintULong( RefTypes[ 0 ] );
    PrintULong( RefTypes[ BREF_BOUND ] );
    PrintULong( RefTypes[ 2 ] );
    PrintULong( RefTypes[ 3 ] );
    PrintULong( RefTypes[ 4 ] );
#endif

    PrintEnum( Type, EnumStructureType );
    PrintUShort( Size );

#if DBG
    PrintNChar( Signature1, sizeof( Binding.Signature1 ));
#endif

    PrintULong( ReferenceCount );
    PrintJoin();
    PrintPtr( Adapter );

    if ( Binding.Adapter != NULL )
    {
        DumpIpxAdapter( ( ULONG )( Binding.Adapter ), VERBOSITY_ONE_LINER );
    }
    dprintf( "\n" );

    PrintUShort( NicId );

    PrintULong( MaxSendPacketSize );

    PrintJoin();
    PrintULong( MediumSpeed );                    // in units of 100 bytes/sec
    dprintf( "(In units of 100 bytes/sec)\n" );

    PrintHardwareAddress( LocalMacAddress );
    PrintHardwareAddress( RemoteMacAddress );

    PrintFieldName( "WanRemoteNode" );
    dprint_hardware_address( Binding.WanRemoteNode );
    dprintf( "\n" );

    PrintBool( AutoDetect );

    PrintBool( DefaultAutoDetect );

    PrintUShort( MatchingResponses );
    PrintUShort( NonMatchingResponses );
    PrintXULong( TentativeNetworkAddress );
    PrintBool( BindingSetMember );
    PrintBool( ReceiveBroadcast );
    PrintBool( LineUp );
    PrintBool( DialOutAsync );

    if ( Binding.BindingSetMember )
    {
        PrintPtr( NextBinding );
        PrintPtr( CurrentSendBinding );
        PrintPtr( MasterBinding );
    }

    PrintULong( WanInactivityCounter );

    PrintTDIAddress( LocalAddress );

    PrintSymbolPtr( SendFrameHandler );

    PrintPtr( Device );

    PrintJoin();
    PrintPtr( DeviceLock );
    if ( Binding.DeviceLock != NULL )
    {
        DumpCTELock( ( ULONG )Binding.DeviceLock, VERBOSITY_ONE_LINER );
    }
    dprintf( "\n" );

    PrintULong( DefHeaderSize );
    PrintULong( BcMcHeaderSize );

    PrintULong( AnnouncedMaxDatagramSize );
    PrintULong( RealMaxDatagramSize );
    PrintULong( MaxLookaheadData );
    PrintULong( FwdAdapterContext );
    PrintULong( InterfaceIndex );
    PrintULong( ConnectionId );
    PrintULong( IpxwanConfigRequired );

    {
        ULONG i;

        for (i=0; i<UPPER_DRIVER_COUNT; i++) {
            PrintBool( IsnInformed[i] );
        }
    }

    PrintEnum( FrameType, EnumBindingFrameType );

    PrintWorkQueueItem( WanDelayedQueueItem );
    PrintEndStruct();
    PrintEnd;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        RouteEntry
#define _objAddr    pRouteEntry
#define _objType    IPX_ROUTE_ENTRY

VOID 
DumpIpxRouteEntry
(
 ULONG EntryToDump, 
 VERBOSITY Verbosity
) {
   PIPX_ROUTE_ENTRY pRouteEntry;
   IPX_ROUTE_ENTRY RouteEntry;
   ULONG result; 

   pRouteEntry = ( PIPX_ROUTE_ENTRY )EntryToDump;

   if ( !ReadMemory( EntryToDump,
		     &RouteEntry,
		     sizeof( IPX_ROUTE_ENTRY ),
		     &result ))
   {
      dprintf("%08lx: Could not read IPX_ROUTE_ENTRY structure\n", EntryToDump );
      return;
   }


   PrintStart;
   PrintStartStruct();
   
   dprintf( "\tRoute Entry at 0x%08X\n", EntryToDump );
   
   PrintNetworkAddress(Network);
   PrintUShort(NicId);
   PrintMacAddress(NextRouter);
   PrintPtr(NdisBindingContext); 
   PrintFlags(Flags,FlagsRouteEntry); 
   PrintUShort(Timer); 
   PrintUShort(TickCount); 
   PrintUShort(HopCount); 

   PrintEndStruct();
   PrintEnd;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        RouterSegment
#define _objAddr    pRouterSegment
#define _objType    ROUTER_SEGMENT

VOID 
DumpIpxRouterSegment
(
 ULONG SegmentToDump, 
 VERBOSITY Verbosity
) {
   PROUTER_SEGMENT pRouterSegment;
   ROUTER_SEGMENT RouterSegment;
   ULONG result;   
   
   PLIST_ENTRY p; 
   LIST_ENTRY temp; 

   PIPX_ROUTE_ENTRY pRouteEntry; 

   pRouterSegment = ( PROUTER_SEGMENT )SegmentToDump;

   if ( !ReadMemory( SegmentToDump,
		     &RouterSegment,
		     sizeof( ROUTER_SEGMENT ),
		     &result ))
   {
      dprintf("%08lx: Could not read ROUTER_SEGMENT structure\n", SegmentToDump );
      return;
   }
   

   if ( Verbosity == VERBOSITY_ONE_LINER )
   {
      PrintLL(Entries); 
      return;
   }

   PrintStart;
   PrintStartStruct();
   
   dprintf( "\tSegment Entry at 0x%08X\n", SegmentToDump );
   
   PrintLL(WaitingForRoute);
   PrintLL(FindWaitingForRoute); 
   PrintLL(WaitingLocalTarget); 
   PrintLL(WaitingReripNetnum); 
   PrintLL(Entries); 
   PrintPtr(EnumerateLocation); 


   for (p = RouterSegment.Entries.Flink;
	p != &(pRouterSegment->Entries);) {
	  
      pRouteEntry = CONTAINING_RECORD(p,
				      IPX_ROUTE_ENTRY,
				      PRIVATE.Linkage);
				      
      DumpIpxRouteEntry((ULONG)pRouteEntry,VERBOSITY_ONE_LINER); 

      if ( !ReadMemory( (ULONG) p,
			&temp,
			sizeof( LIST_ENTRY ),
			&result ))
      {
	 dprintf("%08lx: Could not read LIST_ENTRY structure\n", p);
	 break; 
      } else {
	 p = temp.Flink; 
      }


   }			
	  
   PrintEnd;
   PrintEndStruct(); 
   return; 
}


DECLARE_API( ipxrequest )
{
    ULONG RequestToDump = 0;
    ULONG result;
    char VarName[ MAX_LIST_VARIABLE_NAME_LENGTH + 1 ];
    MEMBER_VARIABLE_INFO MemberInfo;
    BOOL bFocusOnMemberVariable = FALSE;

    if ( *args )
    {
        bFocusOnMemberVariable = ReadArgsForTraverse( args, VarName );
    }

    if ( *args && *args!='-' )
    {
        if (!sscanf(args, "%lx", &RequestToDump))
		{
			return;
		}
    }

    if ( RequestToDump == 0 )
    {
        dprintf( "Please specify an address.\n" );
    }

    if ( bFocusOnMemberVariable )
    {
        if ( !LocateMemberVariable( "IpxRequest", VarName, ( PVOID )RequestToDump, &MemberInfo ))
        {
            return;
        }

        WriteMemberInfo( &MemberInfo );
        next( hCurrentProcess, hCurrentThread, dwCurrentPc, dwProcessor, "" );
        return;
    }

    DumpIpxRequest( RequestToDump, VERBOSITY_FULL );

    return;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        Request
#define _objAddr    prRequest
#define _objType    REQUEST

VOID
DumpIpxRequest
(
    ULONG RequestToDump,
    VERBOSITY Verbosity
)
{
    _objType _obj;
    _objType *_objAddr;
    ULONG result;

    _objAddr = ( _objType * )RequestToDump;

    if ( !ReadMemory( RequestToDump,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf( "%08lx: Could not read %s structure\n",
                 RequestToDump,
                 "REQUEST" );
        return;
    }

    PrintStartStruct();

    DumpIpxIrpStack( &Request, VERBOSITY_FULL );

    PrintEndStruct();
}


PDEVICE_OBJECT GetIpxDeviceObject( VOID )
{
    ULONG  deviceToDump = 0;
    ULONG  prDevice = 0;
    ULONG  result;
    DEVICE Device;

    prDevice = GetExpression( "nwlnkipx!IpxDevice" );

    if ( !prDevice )
    {
        dprintf("Could not get nwlnkipx!IpxDevice, Try !reload\n");
        return( NULL );
    }

    if (!ReadMemory( prDevice,
                     &deviceToDump,
                     sizeof(deviceToDump),
                     &result ))
    {
        dprintf("%08lx: Could not read device address\n", prDevice);
        return( NULL );
    }

    if ( !ReadMemory( deviceToDump,
                      &Device,
                      sizeof(Device),
                      &result ))
    {
        dprintf("%08lx: Could not read device context\n", deviceToDump);
        return( NULL );
    }

    return( Device.DeviceObject );
}

#ifdef _obj

#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        ConnInfo
#define _objAddr    prConnInfo
#define _objType    TDI_CONNECTION_INFORMATION

VOID
DumpTdiConnectionInformation
(
    ULONG InformationToDump,
    VERBOSITY Verbosity
)
{
    _objType _obj;
    _objType *_objAddr;
    ULONG result;

    _objAddr = ( _objType * )InformationToDump;

    if ( !ReadMemory( InformationToDump,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf( "%08lx: Could not read %s structure\n",
                 InformationToDump,
                 "TDI_CONNECTION_INFORMATION" );
        return;
    }

    PrintStartStruct();
    PrintULong( UserDataLength );        // length of user data buffer
    PrintPtr( UserData );             // pointer to user data buffer
    PrintULong( OptionsLength );         // length of follwoing buffer
    PrintPtr( Options );              // pointer to buffer containing options
    PrintULong( RemoteAddressLength );   // length of following buffer
    PrintPtr( RemoteAddress );        // buffer containing the remote address
    PrintEndStruct();
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        Parameters
#define _objAddr    prParameters
#define _objType    TDI_REQUEST_KERNEL_SENDDG

VOID
DumpTdiSendParameters
(
    ULONG ParametersToDump,
    VERBOSITY Verbosity
)
{
    _objType _obj;
    _objType *_objAddr;
    ULONG result;

    _objAddr = ( _objType * )ParametersToDump;

    if ( !ReadMemory( ParametersToDump,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf( "%08lx: Could not read %s structure\n",
                 ParametersToDump,
                 "TDI_REQUEST_KERNEL_SENDDG" );
        return;
    }

    PrintStartStruct();
    PrintULong( SendLength );
    PrintPtr( SendDatagramInformation );
    DumpTdiConnectionInformation(( ULONG )_obj.SendDatagramInformation, Verbosity );

    PrintEndStruct();
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        Stack
#define _objAddr    prStack
#define _objType    IO_STACK_LOCATION


VOID
DumpIpxIrpStack
(
    PREQUEST pRequest,
    VERBOSITY Verbosity
)
/*++

Routine Description:

    Given an IRP of interest to the debugger, this routine will search that IRP's
    stacks for the stack location that involves IPX.  This stack location will be
    dumped, and the file object contained in it will be followed.  The file object
    will then be used to ....

    Matching the IRP stack locations to IPX requires finding the IPX device object
    pointer from the ipxdev structure, and looking in the devobjects referred to
    by the IRP to see if they refer to ipx.

--*/
{
    _objType _obj;
    _objType *_objAddr;
    ULONG result;
    PIO_STACK_LOCATION pStack;
    ULONG StackToDump;
    PDEVICE_OBJECT IpxDeviceObject;

    CHAR idxStack;

    IpxDeviceObject = GetIpxDeviceObject();

    if ( IpxDeviceObject == NULL )
    {
        return;
    }

    prStack = pRequest->Tail.Overlay.CurrentStackLocation;

    for ( idxStack = 0; idxStack < pRequest->StackCount; idxStack ++ )
    {
        StackToDump = ( ULONG )prStack;

        if ( !ReadMemory( StackToDump,
                          &Stack,
                          sizeof( Stack ),
                          &result ))
        {
            dprintf( "%08lx: Could not read %s structure\n",
                     StackToDump,
                     "STACK" );
            return;
        }

        if ( Stack.DeviceObject == IpxDeviceObject )
        {
            break;
        }

        prStack --;
    }

    if ( Stack.DeviceObject != IpxDeviceObject )
    {
        dprintf( "None of the device objects in this IRP's stacks seem to match the IPX device object.\n ");
        return;
    }

    PrintStartStruct();

    PrintXEnum( MajorFunction, EnumIrpMajorFunction );
    PrintXEnum( MinorFunction, EnumIrpMinorFunction[ _obj.MajorFunction ] );

    // Send?  Dump Parameters

    PrintAddr( Parameters );
    DumpTdiSendParameters( AddressOf( Parameters ), VERBOSITY_FULL );

    PrintXULong( Flags );
    PrintXULong( Control );

    PrintJoin();
    PrintPtr( DeviceObject );
    DumpDeviceObject(( ULONG ) Stack.DeviceObject, VERBOSITY_ONE_LINER );

    PrintJoin();
    PrintPtr( FileObject );

    if ( Stack.FileObject != NULL )
    {
        FILE_OBJECT FileObject;
        if ( !ReadMemory( ( ULONG )Stack.FileObject,
                          &FileObject,
                          sizeof( FileObject ),
                          &result ))
        {
            dprintf( "%08lx: Could not read FileObject", Stack.FileObject );
        }
        else
        {
            dprintf( "Addressfile at %8X: ", ( ULONG )FileObject.FsContext );
            DumpIpxAddressFile( ( ULONG )FileObject.FsContext, VERBOSITY_ONE_LINER );
        }
    }
    dprintf( "\n" );

    PrintSymbolPtr( CompletionRoutine );
    PrintXULong( Context );

    PrintEndStruct();
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        DevObj
#define _objAddr    prDevObj
#define _objType    DEVICE_OBJECT

VOID DumpDeviceObject
(
    ULONG DevObjToDump,
    VERBOSITY Verbosity
)
{
    _objType _obj;
    _objType *_objAddr;
    ULONG result;
    PIO_STACK_LOCATION pStack;

    _objAddr = ( _objType * )DevObjToDump;

    if ( !ReadMemory( DevObjToDump,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf( "%08lx: Could not read %s structure\n",
                 DevObjToDump,
                 "DEVICE_OBJECT" );
        return;
    }

    if ( Verbosity != VERBOSITY_ONE_LINER )
    {
        dprintf( "DumpDeviceObject only support VERBOSITY_ONE_LINER.\n" );
    }

    dprintf( "Ref = %d, Driver = %08X, CurrentIrp = %08X\n",
             _obj.ReferenceCount,
             _obj.DriverObject,
             _obj.CurrentIrp );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\kdext\ipxext.h ===
#if !defined( INCLUDED_IPXEXT_H )
#define INCLUDED_IPXEXT_H

extern MEMBER_TABLE IpxDeviceMembers[];

VOID
DumpIpxDevice
(
    ULONG     DeviceToDump,
    VERBOSITY Verbosity
);

#define IPX_MAJOR_STRUCTURES                        \
{ "IpxDevice", IpxDeviceMembers, DumpIpxDevice }   

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\kdext\traverse.h ===
#if !defined( INCLUDED_TRAVERSE_H )
#define INCLUDED_TRAVERSE_H 

#define MAX_LIST_VARIABLE_NAME_LENGTH 200

typedef struct
{
    int StructureIndex;
    int MemberIndex;
    
    ULONG prHeadContainingObject;
    ULONG prHeadLinkage;
    ULONG prCurrentLinkage;
    int   cCurrentElement;
} MEMBER_VARIABLE_INFO, *PMEMBER_VARIABLE_INFO;

typedef VOID (*pfDumpStructure)( ULONG , VERBOSITY );
typedef BOOL (*pfNextStructure)( ULONG Current, PULONG Next );
typedef BOOL (*pfPrevStructure)( ULONG Current, PULONG Prev );

typedef struct
{
    PCHAR pchMemberName;

    LONG  cbOffsetToHead;

    pfDumpStructure DumpStructure;
    pfNextStructure Next;
    pfPrevStructure Prev;
    LONG  cbOffsetToLink;
    
} MEMBER_TABLE, *PMEMBER_TABLE;

typedef struct
{
    PCHAR pchStructName;
    PMEMBER_TABLE pMemberTable;

    pfDumpStructure DumpStructure;
} STRUCTURE_TABLE, *PSTRUCTURE_TABLE;

BOOL ReadArgsForTraverse( const char *args, char *VarName );
BOOL ReadMemberInfo( PMEMBER_VARIABLE_INFO pMemberInfo );
BOOL WriteMemberInfo( PMEMBER_VARIABLE_INFO pMemberInfo );
BOOL LocateMemberVariable( PCHAR pchStructName, PCHAR pchMemberName, PVOID pvStructure, PMEMBER_VARIABLE_INFO pMemberInfo );


DECLARE_API( next );
DECLARE_API( prev );

extern BOOL NextListEntry( ULONG Current, PULONG Next );
extern BOOL PrevListEntry( ULONG Current, PULONG Prev );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\kdext\isnext.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    isnext.h

Abstract:

    This file is a common header file for isnext.dll

Author:

    Munil Shah (munils) 18-May-1995

Environment:

    User Mode

--*/

#define ITEMSIZE    25

typedef struct 
{
    ULONG Value;
    PCHAR pszDescription;
} ENUM_INFO, *PENUM_INFO, FLAG_INFO, *PFLAG_INFO;

#define EnumString( Value ) { Value, #Value }

extern ENUM_INFO EnumStructureType[];

//#define EOL ( (Item++ & 1) ? "\n":"" )
typedef enum 
{
    VERBOSITY_ONE_LINER = 0,
    VERBOSITY_NORMAL,
    VERBOSITY_FULL 
} VERBOSITY;

#define PrintStart Item = 0;

extern int _Indent;
extern char IndentBuf[ 80 ];

#define IndentChange( cch ) { IndentBuf[_Indent]=' '; _Indent += ( cch ); IndentBuf[_Indent]='\0';}
#define Indent( cch ) IndentChange( cch )
#define Outdent( cch ) IndentChange( -( cch ) )

#define PrintStartStruct()  { PrintStart; dprintf( "%s{\n", IndentBuf ); Indent( 2 );  }

#define PrintStartNamedStruct( _name )  { PrintStart; dprintf( "%s%s {\n", IndentBuf, _name ); Indent( 2 );  }

static PCHAR pchEol = "\n";
static PCHAR pchBlank = "";
static PCHAR * ppchCurrentEol = &pchEol;
static PCHAR * ppchTempEol = &pchEol;

#define PrintJoin() { ppchCurrentEol = &pchBlank; }

#define EOL (( ppchTempEol = ppchCurrentEol ), ( ppchCurrentEol = &pchEol ), ( *ppchTempEol ))

VOID
dprintSymbolPtr
( 
    PVOID Pointer, 
    PCHAR EndOfLine 
);

VOID
dprint_nchar
( 
    PCHAR pch,
    int cch
);

VOID
dprint_hardware_address
(
    PUCHAR Address
);

VOID
dprint_network_address
(
    PUCHAR Address
);

BOOL 
dprint_enum_name
( 
    ULONG Value, 
    PENUM_INFO pEnumInfo 
);


BOOL 
dprint_flag_names
( 
    ULONG Value, 
    PFLAG_INFO pFlagInfo 
);

BOOL 
dprint_masked_value
( 
    ULONG Value, 
    ULONG Mask
);

/*
#define PrintEnd   \
        dprintf( "%s", EOL ); \
        Item = 0;
*/

#define PrintEnd   \
        Item = 0;

#define PrintEndStruct()  { Outdent( 2 ); PrintEnd; dprintf( "%s}\n", IndentBuf ); }

#define PrintFlushLeft() PrintEnd

#define PRINTBOOL(var)  ( (var) ? "True" : "False")

#define PrintFieldName(_fieldName) \
        if ( strlen(_fieldName) > 35 ) {                                                \
            dprintf("%s%-.25s..%s = ",IndentBuf,_fieldName, &(_fieldName[strlen(_fieldName)-8]));   \
        }else {                                                                         \
            dprintf("%s%-35.35s = ",IndentBuf,_fieldName );                                        \
        }

#define PrintFieldNameAt(_fieldName) \
        if ( strlen(_fieldName) > 35 ) {                                                \
            dprintf("%s%-.25s..%s @ ",IndentBuf,_fieldName, &(_fieldName[strlen(_fieldName)-8]));   \
        }else {                                                                         \
            dprintf("%s%-35.35s @ ",IndentBuf,_fieldName );                                        \
        }

#define PrintListFieldName(_fieldName) \
        if ( strlen(_fieldName) > 40 ) {                                                \
            dprintf("%s%-.30s...%s Flink = ",IndentBuf,_fieldName, &(_fieldName[strlen(_fieldName)-7]));   \
        }else {                                                                        \
            dprintf("%s%-40.40s Flink = ",IndentBuf,_fieldName );                                        \
        }

#define PrintIndent()   dprintf( "%s", IndentBuf );
/* #define PrintFieldName(_fieldName) \
        dprintf(" %-25.25s = ",_fieldName );*/

#define PrintRawBool( _bValue ) \
            dprintf("%-10s%s", (_obj._bValue) ? "True" : "False", EOL)

#define PrintBool(_field) \
            PrintFieldName(#_field)  \
            dprintf("%-10s%s", (_obj._field) ? "True" : "False", EOL)

#define PrintULong(_field) \
            PrintFieldName(#_field)  \
            dprintf("%-10lu%s", _obj._field, EOL)

#define PrintXULong(_field)     \
            PrintFieldName(#_field)  \
            dprintf("0x%08lx%s", _obj._field, EOL)

#define PrintUShort(_field) \
            PrintFieldName(#_field)  \
            dprintf("%-10hu%s", _obj._field, EOL)

#define PrintXUShort(_field)     \
            PrintFieldName(#_field)  \
            dprintf("0x%04hx%s", _obj._field, EOL)

#define PrintNChar( _field, count )        \
            PrintFieldName(#_field)  \
            dprint_nchar( ( PCHAR )_obj._field, count ); \
            dprintf("%s", EOL)

#define PrintUChar(_field)        \
            PrintFieldName(#_field)  \
            dprintf("%-10lu%s", (ULONG) _obj._field, EOL)

#define PrintXUChar(_field)        \
            PrintFieldName(#_field)  \
            dprintf("0x%-8lx%s", (ULONG) _obj._field, EOL)

#define PrintPtr(_field)            \
            PrintFieldName(#_field)  \
            dprintf("%-10lx%s", _obj._field, EOL)

#define PrintSymbolPtr( _field )    \
            PrintFieldName(#_field)  \
            dprintSymbolPtr( (( PVOID )_obj._field), EOL );    

#define AddressOf( _field ) ((( ULONG )_objAddr) + FIELD_OFFSET( _objType, _field ))

#define PrintAddr(_field)               \
            PrintFieldNameAt(#_field)   \
            dprintf("%-10lx%s", AddressOf( _field ), EOL)

#define PrintL(_field) \
            PrintFieldName(#_field##".Next")  \
            dprintf("%-10lx%s",  _obj._field.Next, EOL )

#define PrintLL(_field)                                     \
            PrintEnd;                                       \
            PrintListFieldName(#_field );                  \
            dprintf("%-10lx",  _obj._field.Flink );         \
            dprintf("Blink = %-10lx",  _obj._field.Blink );         \
            dprintf("%s\n", ( _obj._field.Flink == _obj._field.Blink ) ? " (Empty)" : "" );

#define PrintIrpQ(_field) \
            PrintEnd;   \
            PrintFieldName(#_field##".Head");                 \
            dprintf("%-10lx",  _obj._field.Head );            \
            PrintFieldName(#_field##".Tail");                 \
            dprintf("%-10lx\n",  _obj._field.Tail );

#define PrintFlags( _field, _pFlagStruct )                  \
            PrintEnd;                                       \
            PrintFieldName(#_field);                        \
            dprintf("0x%08lx (", (ULONG) _obj._field );     \
            dprint_flag_names( (ULONG) _obj._field, _pFlagStruct );  \
            dprintf( ")\n" );

#define PrintFlagsMask( _field, _pFlagStruct, _Mask )       \
            PrintEnd;                                       \
            PrintFieldName(" & " ## #_Mask );               \
            dprintf("0x");                                  \
            dprint_masked_value((ULONG) _obj._field, _Mask );    \
            dprintf("(");                                   \
            dprint_flag_names( (ULONG) _obj._field, _pFlagStruct );  \
            dprintf( ")\n" );

#define PrintEnum( _field, _pEnumStruct )                   \
            PrintEnd;                                       \
            PrintFieldName(#_field);                        \
            dprintf("%lu (", (ULONG) _obj._field );         \
            dprint_enum_name( (ULONG) _obj._field, _pEnumStruct );  \
            dprintf( ")\n" );

#define PrintXEnum( _field, _pEnumStruct )                  \
            PrintEnd;                                       \
            PrintFieldName(#_field);                        \
            dprintf("0x%08lx (", (ULONG) _obj._field );    \
            dprint_enum_name( (ULONG) _obj._field, _pEnumStruct );  \
            dprintf( ")\n" );

#define PrintXEnumMask( _field, _pEnumStruct, _Mask )       \
            PrintEnd;                                       \
            PrintFieldName(" & " ## #_Mask );               \
            dprintf("0x");                                  \
            dprint_masked_value((ULONG) _obj._field, _Mask );    \
            dprintf("(");                                   \
            dprint_enum_name((ULONG) _obj._field & _Mask, _pEnumStruct );  \
            dprintf( ")\n" );

	    
#define PrintNetworkAddress( _field )  PrintFieldName(#_field);  dprint_network_address( _obj._field); dprintf( "%s", EOL );

#define PrintMacAddress( _field ) PrintFieldName(#_field); dprint_hardware_address( _obj._field); dprintf( "%s", EOL );

#define PrintHardwareAddress( _field )                      \
            PrintFieldName(#_field);                        \
            dprint_hardware_address( _obj._field.Address ); \
            dprintf( "%s", EOL );

#define PrintIpxLocalTarget( _field )                       \
            PrintStartNamedStruct( #_field );               \
            PrintFieldName( "NicId" );                      \
            dprintf("%-10u%s", _obj._field.NicId, EOL);    \
            PrintFieldName( "MacAddress" );                 \
            dprint_hardware_address( _obj._field.MacAddress ); \
            dprintf( "%s", EOL );                           \
            PrintEndStruct();


#define PrintLock( _field )                                 \
            PrintULong( _field )

#define PrintTDIAddress( _field )                           \
            PrintFieldName( #_field );                      \
            dprintf( "{ NetworkAddress = %X, NodeAddress = ", _obj._field.NetworkAddress );\
            dprint_hardware_address( _obj._field.NodeAddress );\
            dprintf( ", Socket = %d }%s", _obj._field.Socket, EOL );

#define PrintCTETimer( _field )                             \
            dprintf( "%s", #_field );                       \
            PrintStartStruct();                             \
            DumpCTETimer ( ((ULONG)_objAddr) +FIELD_OFFSET( _objType, _field ), VERBOSITY_NORMAL );\
            PrintEndStruct();

#define PrintWorkQueueItem( _field )                        \
            dprintf( "%s", #_field );                       \
            PrintStartStruct();                             \
            DumpWorkQueueItem ( ((ULONG)_objAddr) +FIELD_OFFSET( _objType, _field ), VERBOSITY_NORMAL );\
            PrintEndStruct();


extern  BOOLEAN ChkTarget;
extern  INT     Item;

#define CHECK_SIGNATURE( _field, _signature )   \
    if ( _obj._field != _signature )            \
    {                                           \
        dprintf( "Object at %08X doesn't have signature %s at %08X\n",   \
                 _objAddr,                                              \
                 #_signature,                                           \
                 (( ULONG )_objAddr) + FIELD_OFFSET( _objType, _field ));\
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\kdext\isnext.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    isnext.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Munil Shah

Environment:

    User Mode

--*/
#include "precomp.h"
#pragma hdrstop

//
// globals
//

#include "isnspx.h"

ENUM_INFO EnumStructureType[] =
{
    EnumString( IPX_DEVICE_SIGNATURE ),
    EnumString( IPX_ADAPTER_SIGNATURE ),
    EnumString( IPX_BINDING_SIGNATURE ),
    EnumString( IPX_ADDRESS_SIGNATURE ),
    EnumString( IPX_ADDRESSFILE_SIGNATURE ),
    { 0x4453, "SPX_DEVICE_SIGNATURE" },
    { 0x4441, "SPX_ADDRESS_SIGNATURE" },
    { 0x4641, "SPX_ADDRESSFILE_SIGNATURE" },
    { 0x4643, "SPX_CONNFILE_SIGNATURE" },
    { 0, NULL }
};

EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
BOOLEAN                 ChkTarget;
INT                     Item;

HANDLE _hInstance;
HANDLE _hAdditionalReference;
HANDLE _hProcessHeap;

int _Indent = 0;
char IndentBuf[ 80 ]={"\0                                                                      "};

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            _hInstance = hModule;
            _hAdditionalReference = NULL;
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{

    return;

#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

//
// Exported functions
//
DECLARE_API( help )

/*++

Routine Description:

    Command help for ISN debugger extensions.

Arguments:

    None

Return Value:

    None

--*/

{
    dprintf("NB debugger extension commands:\n\n");
    dprintf("\tnbaddr <ptr>                 - Dump an NB ADDRESS object\n");
    dprintf("\tnbaddrfile <ptr>             - Dump an NB ADDRESS_FILE object\n");
    dprintf("\tnbconn <ptr>                 - Dump key fields of an NB CONNECTION object\n");
    dprintf("\tnbconnfull <ptr>             - Dump all fields of an NB CONNECTION object\n");
    dprintf("\tnbdev [ptr]                  - Dump key fields of an NB DEVICE object\n");
    dprintf("\tnbdevfull [ptr]              - Dump all fields of an NB DEVICE object\n");
    dprintf("\tnbspacketlist [ptr] [-l Max] - Dump SEND_PACKET list upto Max count\n");
    dprintf("\tnbcache\n");
    dprintf("\n");

    dprintf("SPX debugger extension commands:\n\n");
    dprintf("\tspxdev [ptr] [-l var]        - Dump all fields of an IPX DEVICE object\n" );
    dprintf("\tspxaddr <ptr>\n" );
    dprintf("\tspxaddrfile <ptr>\n" );
    dprintf("\tspxconnfile <ptr>\n" );
    dprintf("\n");

    dprintf("IPX debugger extension commands:\n\n");
    dprintf("\tipxdev [ptr] [-l var]        - Dump all fields of an IPX DEVICE object\n" );
    dprintf("\tipxaddr <ptr>\n" );
    dprintf("\tipxaddrfile <ptr>\n" );
    dprintf("\tipxbinding <ptr>\n" );
    dprintf("\tipxadapter <ptr>\n" );
    dprintf("\tipxrequest <ptr>             - Turn an IRP into an IPX_ADDRESS_FILE\n" );
    dprintf("\n");

    dprintf("\tnext                         - Advance to next element in currently focused list.\n\n" );
    dprintf("\tprev                         - Advance to previous element in currently focused list.\n\n" );

    dprintf( "Compiled on " __DATE__ " at " __TIME__ "\n" );
    return;
}



VOID
dprintSymbolPtr
(
    PVOID Pointer,
    PCHAR EndOfLine
)
{
    UCHAR SymbolName[ 80 ];
    ULONG Displacement;

    dprintf("%-10lx", ( ULONG )Pointer );

    GetSymbol( Pointer, SymbolName, &Displacement );

    if ( Displacement == 0 )
    {
        dprintf( "(%s)%s", SymbolName, EndOfLine );
    }
    else
    {
        dprintf( "(%s + 0x%X)%s", SymbolName, Displacement, EndOfLine );
    }
}

VOID
dprint_nchar
(
    PCHAR pch,
    int cch
)
{
    CHAR ch;
    int index;

    for ( index = 0; index < cch; index ++ )
    {
        ch = pch[ index ];
        dprintf( "%c", ( ch >= 32 ) ? ch : '.' );
    }
}

VOID
dprint_hardware_address
(
    PUCHAR Address
)
{
    dprintf( "%02x-%02x-%02x-%02x-%02x-%02x",
             Address[ 0 ],
             Address[ 1 ],
             Address[ 2 ],
             Address[ 3 ],
             Address[ 4 ],
             Address[ 5 ] );
}

VOID
dprint_network_address
(
    PUCHAR Address
)
{
    dprintf( "%02x-%02x-%02x-%02x",
             Address[ 0 ],
             Address[ 1 ],
             Address[ 2 ],
             Address[ 3 ]);
}

BOOL
dprint_enum_name
(
    ULONG Value,
    PENUM_INFO pEnumInfo
)
{
    while ( pEnumInfo->pszDescription != NULL )
    {
        if ( pEnumInfo->Value == Value )
        {
            dprintf( "%.40s", pEnumInfo->pszDescription );
            return( TRUE );
        }
        pEnumInfo ++;
    }

    dprintf( "Unknown enumeration value." );
    return( FALSE );
}

BOOL
dprint_flag_names
(
    ULONG Value,
    PFLAG_INFO pFlagInfo
)
{
    BOOL bFoundOne = FALSE;

    while ( pFlagInfo->pszDescription != NULL )
    {
        if ( pFlagInfo->Value & Value )
        {
            if ( bFoundOne )
            {
                dprintf( " | " );
            }
            bFoundOne = TRUE;

            dprintf( "%.15s", pFlagInfo->pszDescription );
        }
        pFlagInfo ++;
    }

    return( bFoundOne );
}

BOOL
dprint_masked_value
(
    ULONG Value,
    ULONG Mask
)
{
    CHAR Buf[ 9 ];
    ULONG nibble;
    int index;

    for ( index = 0; index < 8; index ++ )
    {
        nibble = ( Mask & 0xF0000000 );
/*
        dprintf( "#%d: nibble == %08X\n"
                 "      Mask == %08X\n"
                 "     Value == %08X\n", index, nibble, Mask, Value );

*/
        if ( nibble )
        {
            Buf[ index ] = "0123456789abcdef"[ (( nibble & Value ) >> 28) & 0xF ];
        }
        else
        {
            Buf[ index ] = ' ';
        }

        Mask <<= 4;
        Value <<= 4;
    }

    Buf[ 8 ] = '\0';

    dprintf( "%s", Buf );

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\kdext\spxext.h ===
#if !defined( INCLUDED_SPXEXT_H )
#define INCLUDED_SPXEXT_H

extern MEMBER_TABLE SpxConnFileMembers[];

VOID
DumpSpxConnFile
(
    ULONG     DeviceToDump,
    VERBOSITY Verbosity
);

#define SPX_MAJOR_STRUCTURES                        \
{ "SpxConnFile", SpxConnFileMembers, DumpSpxConnFile }   

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\kdext\precomp.h ===
#define ISN_NT 1

//
// These are needed for CTE
//

#if DBG
#define DEBUG 1
#endif

#define NT 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>
#include <windef.h>
#include <winbase.h>
#include <ntosp.h>

#include <wdbgexts.h>

#include <stdio.h>
#include <stdlib.h>
#include <nb30.h>
#include <ndis.h>
#include <tdikrnl.h>
#include <isnipx.h>
#include <isnext.h>
#include <wsnwlink.h>
#include <bind.h>

#include <traverse.h>
#include <ipxext.h>
#include <spxext.h>
#include <cxport.h>
#include <cteext.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\kdext\nbext.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nbext.c

Abstract:

    This file contains kernel debugger extensions for examining the
    NB structure.

Author:

    Munil Shah (munils) 18-May-1995

Environment:

    User Mode

--*/
#include "precomp.h"
#pragma hdrstop
#pragma warning(disable:244)
#include "isn.h"
#include "isnnb.h"
#include "zwapi.h"
#include "config.h"
#include "nbitypes.h"


PCHAR   HandlerNames[] = { "Connection", "Disconnect", "Error", "Receive", "ReceiveDatagram", "ExpeditedData" };

INT     NumArgsRead = 0;

//
// Local function prototypes
//
VOID
DumpAddrFile(
    ULONG     AddrFileToDump
    );


VOID
DumpAddrObj(
    ULONG     AddrObjToDump
    );

VOID
DumpConn(
    ULONG     ConnToDump,
    BOOLEAN   Full
    );

VOID
Dumpdevice(
    ULONG     deviceToDump,
    BOOLEAN   Full
    );

VOID
DumpSPacketList(
    ULONG     _objAddr,
    ULONG     MaxCount,
    BOOLEAN   Full
    );

///////////////////////////////////////////////////////////////////////
//                      ADDRESS_FILE
//////////////////////////////////////////////////////////////////////

#define _obj    addrfile
#define _objAddr    AddrFileToDump
#define _objType    ADDRESS_FILE

//
// Exported functions
//

DECLARE_API( nbaddrfile )

/*++

Routine Description:

    Dumps the most important fields of the specified ADDRESS_FILE object

Arguments:

    args - Address of args string

Return Value:

    None

--*/

{
    ULONG  addrFileToDump = 0;

    if (!*args) {
        dprintf("No address_file object specified\n");
    }
    else {
        NumArgsRead = sscanf(args, "%lx", &addrFileToDump);
        if (NumArgsRead) {
            DumpAddrFile(addrFileToDump);
        }
        else {
            dprintf("Bad argument for address_file object <%s>\n", args);
        }
    }

    return;
}


//
// Local functions
//

VOID
DumpAddrFile(
    ULONG     AddrFileToDump
    )

/*++

Routine Description:

    Dumps the fields of the specified ADDRESS_FILE object

Arguments:

    AddrFileToDump    - The ADDRESS_FILE object to display
    Full              - Display a partial listing if 0, full listing otherwise.

Return Value:

    None

--*/

{
    ADDRESS_FILE  addrfile;
    ULONG            result;
    UCHAR           i;

    if (!ReadMemory(
             AddrFileToDump,
             &addrfile,
             sizeof(addrfile),
             &result
             )
       )
    {
        dprintf("%08lx: Could not read address object\n", AddrFileToDump);
        return;
    }

    if (addrfile.Type != NB_ADDRESSFILE_SIGNATURE) {
        dprintf("Signature does not match, probably not an address object\n");
        return;
    }

    dprintf("NBI AddressFile:\n");

    PrintStart
    PrintXUChar(State);
    PrintXULong(ReferenceCount);
    PrintPtr(FileObject);
    PrintPtr(Address);
    PrintPtr(OpenRequest);
    PrintPtr(CloseRequest);
    PrintLL(Linkage);
    PrintLL(ConnectionDatabase);
    PrintLL(ReceiveDatagramQueue);
    PrintEnd

    for ( i= TDI_EVENT_CONNECT; i < TDI_EVENT_SEND_POSSIBLE ; i++ ) {
        dprintf(" %sHandler = %lx, Registered = %s, Context = %lx\n",
                HandlerNames[i], addrfile.Handlers[i], PRINTBOOL(addrfile.RegisteredHandler[i]),addrfile.HandlerContexts[i] );
    }
    return;
}

///////////////////////////////////////////////////////////////////////
//                          ADDRESS
//////////////////////////////////////////////////////////////////////

#undef _obj
#undef _objAddr
#undef _objType
#define _obj        addrobj
#define _objAddr    AddrObjToDump
#define _objType    ADDRESS

DECLARE_API( nbaddr )

/*++

Routine Description:

    Dumps the most important fields of the specified ADDRESS object

Arguments:

    args - Address of args string

Return Value:

    None

--*/

{
    ULONG  addrobjToDump = 0;

    if (!*args) {
        dprintf("No address object specified\n");
    }
    else {
        NumArgsRead = sscanf(args, "%lx", &addrobjToDump);
        if (NumArgsRead)  {
            DumpAddrObj(addrobjToDump);
        }
        else {
            dprintf("Bad argument for address object <%s>\n", args);
        }
    }

    return;
}


//
// Local functions
//

VOID
PrintNetbiosName(
    PUCHAR Name
    )
/*++

Routine Description:

    Prints out a Netbios name.

Arguments:

    Name    - The array containing the name to print.

Return Value:

    None

--*/

{
    ULONG i;

    for (i=0; i<16; i++) {
        dprintf("%c", Name[i]);
    }
    return;
}


VOID
DumpAddrObj(
    ULONG     AddrObjToDump
    )

/*++

Routine Description:

    Dumps the fields of the specified ADDRESS object

Arguments:

    AddrObjToDump    - The address object to display
    Full          - Display a partial listing if 0, full listing otherwise.

Return Value:

    None

--*/

{
    ADDRESS           addrobj;
    ULONG                result;
    NBI_NETBIOS_ADDRESS  nbaddr;


    if (!ReadMemory(
             AddrObjToDump,
             &addrobj,
             sizeof(addrobj),
             &result
             )
       )
    {
        dprintf("%08lx: Could not read address object\n", AddrObjToDump);
        return;
    }

    if (addrobj.Type != NB_ADDRESS_SIGNATURE) {
        dprintf("Signature does not match, probably not an address object\n");
        return;
    }

    dprintf("NB Address:\n");
    PrintStart
    PrintXULong(State);
    PrintXULong(Flags);
    PrintULong(ReferenceCount);
    PrintLL(Linkage);
    PrintEnd

    // Print the netbiosname info.
    PrintFieldName("NetbiosName");
    PrintNetbiosName(addrobj.NetbiosAddress.NetbiosName);    dprintf("\n");
    dprintf(" %25s = 0x%8x %25s = %10s\n", "NetbiosNameType",addrobj.NetbiosAddress.NetbiosNameType,"Broadcast",PRINTBOOL(addrobj.NetbiosAddress.Broadcast));

    PrintStart
    PrintLL(AddressFileDatabase);
    PrintAddr(RegistrationTimer);
    PrintXULong(RegistrationCount);
    PrintPtr(SecurityDescriptor);
    PrintEnd
    return;
}


///////////////////////////////////////////////////////////////////////
//                      CONNECTION_FILE
//////////////////////////////////////////////////////////////////////
#undef _obj
#undef _objAddr
#undef _objType
#define _obj        conn
#define _objAddr    ConnToDump
#define _objType    CONNECTION


DECLARE_API( nbconn )

/*++

Routine Description:

    Dumps the most important fields of the specified CONNECTION object

Arguments:

    args - Address

Return Value:

    None

--*/

{
    ULONG  connToDump = 0;

    if (!*args) {
        dprintf("No conn specified\n");
    }
    else {
        NumArgsRead = sscanf(args, "%lx", &connToDump);
        if (NumArgsRead)  {
            DumpConn(connToDump, FALSE);
        }
        else {
            dprintf("Bad argument for conn object <%s>\n", args);
        }
    }

    return;
}


DECLARE_API( nbconnfull )

/*++

Routine Description:

    Dumps all of the fields of the specified CONNECTION object

Arguments:

    args - Address

Return Value:

    None

--*/

{
    ULONG  connToDump = 0;

    if (!*args) {
        dprintf("No conn specified\n");
    }
    else {
        NumArgsRead = sscanf(args, "%lx", &connToDump);
        if (NumArgsRead)  {
            DumpConn(connToDump, TRUE);
        }
        else {
            dprintf("Bad argument for conn object <%s>\n", args);
        }
    }

    return;
}


//
// Local functions
//
VOID
printSendPtr(
    PSEND_POINTER   SendPtr,
    PSEND_POINTER   UnAckedPtr
    )
{
    dprintf("                  CurrentSend     UnackedSend\n");
    dprintf(" MessageOffset    0x%-8lx             0x%-8lx\n",         SendPtr->MessageOffset,UnAckedPtr->MessageOffset);
    dprintf(" Request          0x%-8lx             0x%-8lx\n",         SendPtr->Request,UnAckedPtr->Request);
   dprintf(" Buffer           0x%-8lx             0x%-8lx\n",         SendPtr->Buffer,UnAckedPtr->Buffer);
    dprintf(" BufferOffset     0x%-8lx             0x%-8lx\n",         SendPtr->BufferOffset,UnAckedPtr->BufferOffset);
    dprintf(" SendSequence     0x%-8x            0x%-8x\n",        SendPtr->SendSequence,UnAckedPtr->SendSequence);
}

VOID
printRcvPtr(
    PRECEIVE_POINTER   CurrentPtr,
    PRECEIVE_POINTER   PreviousPtr
    )
{
    dprintf("                  CurrentReceive  PreviousReceive\n");
    dprintf(" MessageOffset    0x%-8lx             0x%-8lx\n",         CurrentPtr->MessageOffset,PreviousPtr->MessageOffset);
    dprintf(" Offset           0x%-8lx             0x%-8lx\n",         CurrentPtr->Offset,PreviousPtr->Offset);
    dprintf(" Buffer           0x%-8lx             0x%-8lx\n",         CurrentPtr->Buffer,PreviousPtr->Buffer);
    dprintf(" BufferOffset     0x%-8lx             0x%-8lx\n",         CurrentPtr->BufferOffset,PreviousPtr->BufferOffset);
}

VOID
DumpConn(
    ULONG     ConnToDump,
    BOOLEAN   Full
    )

/*++

Routine Description:

    Dumps the fields of the specified CONNECTION object

Arguments:

    ConnToDump    - The conn object to display
    Full          - Display a partial listing if 0, full listing otherwise.

Return Value:

    None

--*/

{
    CONNECTION  conn;
    ULONG          result;


    if (!ReadMemory(
             ConnToDump,
             &conn,
             sizeof(conn),
             &result
             )
       )
    {
        dprintf("%08lx: Could not read conn\n", ConnToDump);
        return;
    }

    if (conn.Type != NB_CONNECTION_SIGNATURE) {
        dprintf("Signature does not match, probably not a conn\n");
        return;
    }

    dprintf("NBI Connection General:\n");
    PrintStart
    PrintXULong(State);
    PrintXULong(SubState);
    PrintXULong(ReceiveState);
    PrintXULong(ReferenceCount);
    PrintXUShort(LocalConnectionId);
    PrintXUShort(RemoteConnectionId);
    PrintAddr(LocalTarget);
    PrintAddr(RemoteHeader);
    PrintPtr(Context);
    PrintPtr(AddressFile);
    PrintXULong(AddressFileLinked);
    PrintPtr(NextConnection);

    PrintEnd

    dprintf(" RemoteName = ");PrintNetbiosName((PUCHAR)conn.RemoteName);dprintf("\n");

    dprintf("\n\nConnection Send Info:\n");

    PrintStart
    PrintIrpQ(SendQueue);
    PrintXUShort(SendWindowSequenceLimit);
    PrintXUShort(SendWindowSize);
    PrintEnd

    printSendPtr( &conn.CurrentSend, &conn.UnAckedSend );

    if( Full ) {
        PrintStart
        PrintXUShort(MaxSendWindowSize);
        PrintBool(RetransmitThisWindow);
        PrintBool(SendWindowIncrease);
        PrintBool(ResponseTimeout);
        PrintBool(SendBufferInUse);
        PrintPtr(FirstMessageRequest);
        PrintPtr(LastMessageRequest);
        PrintXULong(MaximumPacketSize);
        PrintXULong(CurrentMessageLength);
        PrintEnd
    }

    dprintf("\n\nConnection Receive Info:\n");
    PrintStart
    PrintIrpQ(ReceiveQueue);
    PrintXUShort(ReceiveSequence);
    PrintXUShort(ReceiveWindowSize);
    PrintXUShort(LocalRcvSequenceMax);
    PrintXUShort(RemoteRcvSequenceMax);
    PrintPtr(ReceiveRequest);
    PrintXULong(ReceiveLength);
    PrintEnd

    printRcvPtr( &conn.CurrentReceive, &conn.PreviousReceive );

    if( Full ) {
        PrintStart
        PrintXULong(ReceiveUnaccepted);
        PrintXULong(CurrentIndicateOffset);
        PrintBool(NoPiggybackHeuristic);
        PrintBool(PiggybackAckTimeout);
        PrintBool(CurrentReceiveNoPiggyback);
        PrintBool(DataAckPending);
        PrintEnd
    }

    if( Full ) {
        PrintStart
        PrintPtr(ListenRequest);
        PrintPtr(AcceptRequest);
        PrintPtr(ClosePending);
        PrintPtr(DisassociatePending);
        PrintPtr(DisconnectWaitRequest);
        PrintPtr(DisconnectRequest);
        PrintPtr(ConnectRequest);
        PrintEnd

        PrintStart
        PrintLL(PacketizeLinkage);
        PrintBool(OnPacketizeQueue);
        PrintLL(WaitPacketLinkage);
        PrintBool(OnWaitPacketQueue);
        PrintLL(DataAckLinkage);
        PrintBool(OnDataAckQueue);
        PrintBool(IgnoreNextDosProbe);
        PrintXULong(NdisSendsInProgress);
        PrintLL(NdisSendQueue);
        PrintPtr(NdisSendReference);
        PrintXULong(Retries);
        PrintXULong(Status);
        PrintBool(FindRouteInProgress);
        PrintXULong(CanBeDestroyed);
        PrintBool(OnShortList);
        PrintLL(ShortList);
        PrintLL(LongList);
        PrintBool(OnLongList);
        PrintXULong(BaseRetransmitTimeout);
        PrintXULong(CurrentRetransmitTimeout);
        PrintXULong(WatchdogTimeout);
        PrintXULong(Retransmit);
        PrintXULong(Watchdog);


        PrintEnd

        PrintStart
        PrintAddr(ConnectionInfo);
        PrintAddr(Timer);
        PrintAddr(FindRouteRequest);
        PrintPtr(NextConnection);
        PrintAddr(SessionInitAckData);
        PrintXULong(SessionInitAckDataLength);
        PrintAddr(SendPacket);
        PrintAddr(SendPacketHeader);
        PrintBool(SendPacketInUse);
        PrintAddr(LineInfo);

#ifdef  RSRC_TIMEOUT_DBG
        PrintXULong(FirstMessageRequestTime.HighPart);
        PrintXULong(FirstMessageRequestTime.LowPart);
#endif  RSRC_TIMEOUT_DBG
    }
    return;
}

///////////////////////////////////////////////////////////////////////
//                      DEVICE
//////////////////////////////////////////////////////////////////////


#undef _obj
#undef _objAddr
#undef _objType
#define _obj        device
#define _objAddr    deviceToDump
#define _objType    DEVICE

//
// Exported functions
//

DECLARE_API( nbdev )

/*++

Routine Description:

    Dumps the most important fields of the specified DEVICE_CONTEXT object

Arguments:

    args - Address

Return Value:

    None

--*/

{
    ULONG  deviceToDump = 0;
    ULONG  pDevice = 0;
    ULONG   result;

    if (!*args) {

        pDevice    =   GetExpression( "nwlnknb!NbiDevice" );

        if ( !pDevice ) {
            dprintf("Could not get NbiDevice, Try !reload\n");
            return;
        } else {

            if (!ReadMemory(pDevice,
                     &deviceToDump,
                     sizeof(deviceToDump),
                     &result
                     )
               )
            {
                dprintf("%08lx: Could not read device address\n", pDevice);
                return;
            }
        }

    }
    else {
        NumArgsRead = sscanf(args, "%lx", &deviceToDump);
        if (0 == NumArgsRead)  {
            dprintf("Bad argument for NbiDevice <%s>\n", args);
            return;
        }
    }


    Dumpdevice(deviceToDump, FALSE);

    return;
}


DECLARE_API( nbdevfull )

/*++

Routine Description:

    Dumps all of the fields of the specified DEVICE_CONTEXT object

Arguments:

    args - Address

Return Value:

    None

--*/

{
    ULONG  deviceToDump = 0;
    ULONG  pDevice = 0;
    ULONG   result;

    if (!*args) {

        pDevice    =   GetExpression( "nwlnknb!NbiDevice" );

        if ( !pDevice ) {
            dprintf("Could not get NbiDevice, Try !reload\n");
            return;
        } else {

            if (!ReadMemory(pDevice,
                     &deviceToDump,
                     sizeof(deviceToDump),
                     &result
                     )
               )
            {
                dprintf("%08lx: Could not read device address\n", pDevice);
                return;
            }
        }

    }
    else {
        NumArgsRead = sscanf(args, "%lx", &deviceToDump);
        if (0 == NumArgsRead)  {
            dprintf("Bad argument for NbiDevice <%s>\n", args);
            return;
        }
    }


    Dumpdevice(deviceToDump, TRUE);

    return;
}

//
// Local functions
//

VOID
Dumpdevice(
    ULONG     deviceToDump,
    BOOLEAN   Full
    )

/*++

Routine Description:

    Dumps the fields of the specified DEVICE_CONTEXT structure

Arguments:

    deviceToDump  - The device context object to display
    Full          - Display a partial listing if 0, full listing otherwise.

Return Value:

    None

--*/

{
    DEVICE         device;
    ULONG          result;

    if (!ReadMemory(
             deviceToDump,
             &device,
             sizeof(device),
             &result
             )
       )
    {
        dprintf("%08lx: Could not read device context\n", deviceToDump);
        return;
    }

    if (device.Type != NB_DEVICE_SIGNATURE) {
        dprintf("Signature does not match, probably not a device object %lx\n",deviceToDump);
        return;
    }

    dprintf("Device General Info:\n");
    PrintStart
    PrintXUChar(State);
    PrintXULong(ReferenceCount);
    PrintXUShort(MaximumNicId);
    PrintXULong(MemoryUsage);
    PrintXULong(MemoryLimit);
    PrintXULong(AddressCount);
    PrintXULong(AllocatedSendPackets);
    PrintXULong(AllocatedReceivePackets);
    PrintXULong(AllocatedReceiveBuffers);
    PrintXULong(MaxReceiveBuffers);
    PrintLL(AddressDatabase);
    PrintL(SendPacketList);
    PrintL(ReceivePacketList);
    PrintLL(GlobalReceiveBufferList);
    PrintLL(GlobalSendPacketList);
    PrintLL(GlobalReceivePacketList);
    PrintLL(GlobalReceiveBufferList);
    PrintLL(SendPoolList);
    PrintLL(ReceivePoolList);
    PrintLL(ReceiveBufferPoolList);
    PrintLL(ReceiveCompletionQueue);
    PrintLL(WaitPacketConnections);
    PrintLL(PacketizeConnections);
    PrintLL(WaitingConnects);
    PrintLL(WaitingDatagrams);
    PrintLL(WaitingAdapterStatus);
    PrintLL(WaitingNetbiosFindName);
    PrintLL(ActiveAdapterStatus);
    PrintLL(ReceiveDatagrams);
    PrintLL(ConnectIndicationInProgress);
    PrintLL(ListenQueue);
    PrintLL(WaitingFindNames);
    if ( Full ) {
        PrintStart
        PrintBool(UnloadWaiting);
        PrintBool(DataAckQueueChanged);
        PrintBool(ShortListActive);
        PrintBool(DataAckActive);
        PrintBool(TimersInitialized);
        PrintBool(ProcessingShortTimer);
        PrintAddr(ShortTimerStart);
        PrintAddr(ShortTimer);
        PrintXULong(ShortAbsoluteTime);
        PrintAddr(LongTimer);
        PrintXULong(LongAbsoluteTime);
        PrintLL(ShortList);
        PrintLL(LongList);
        PrintAddr(TimerLock);
        PrintEnd
    }

    if ( Full ) {
        PrintStart
        PrintXUShort(FindNameTime);
        PrintBool(FindNameTimerActive);
        PrintAddr(FindNameTimer);
        PrintXULong(FindNameTimeout);
        PrintXULong(FindNamePacketCount);
        PrintLL(WaitingFindNames);
        PrintEnd

        PrintStart
        PrintXULong(AckDelayTime       );
        PrintXULong(AckWindow               );
        PrintXULong(AckWindowThreshold      );
        PrintXULong(EnablePiggyBackAck      );
        PrintXULong(Extensions              );
        PrintXULong(RcvWindowMax            );
        PrintXULong(BroadcastCount          );
        PrintXULong(BroadcastTimeout        );
        PrintXULong(ConnectionCount         );
        PrintXULong(ConnectionTimeout       );
        PrintXULong(InitPackets             );
        PrintXULong(MaxPackets              );
        PrintXULong(InitialRetransmissionTime);
        PrintXULong(Internet                );
        PrintXULong(KeepAliveCount          );
        PrintXULong(KeepAliveTimeout        );
        PrintXULong(RetransmitMax           );
        PrintXULong(RouterMtu);
        PrintEnd
    }

    PrintPtr(NameCache);
    PrintXUShort(CacheTimeStamp);
    PrintAddr(Bind);
    PrintAddr( ConnectionHash);
    PrintAddr( ConnectionlessHeader );
    PrintAddr( UnloadEvent );
    PrintAddr(Information);
    PrintAddr(Statistics);

    PrintEnd

    return;
}

//////////////Send Packet////////////

#undef _obj
#undef _objAddr
#undef _objType
#define _obj        spacket
#define _objAddr    spacketToDump
#define _objType    NB_SEND_RESERVED

//
// Exported functions
//

DECLARE_API( nbspacketlist )

/*++

Routine Description:


Arguments:

    args - Address

Return Value:

    None

--*/

{
    DEVICE              NbiDevice;
    DEVICE              *pDevice;
    PNB_SEND_RESERVED   pFirstPacket;
    ULONG               result;
    char                szPacketCount[MAX_LIST_VARIABLE_NAME_LENGTH + 1];
    ULONG               MaxCount = 0;   // default value means dump all packets!

    if ((!*args) || (*args && *args == '-'))
    {
        //
        // No initial packet has been defined, so set the initial packet
        // from the global pool list
        //
        if (!(pDevice = (DEVICE *) GetExpression("nwlnknb!NbiDevice")))
        {
            dprintf("Could not get NbiDevice, Try !reload\n");
            return;
        }

        if (!ReadMemory((ULONG) pDevice, &pDevice, sizeof(DEVICE *), &result))
        {
            dprintf("%08lx: Could not read device address\n", pDevice);
            return;
        }

        if (!ReadMemory((ULONG) pDevice, &NbiDevice, sizeof(DEVICE), &result))
        {
            dprintf("%08lx: Could not read device information\n", pDevice);
            return;
        }

        //
        // Now, compute the address of the first packet from the GlobalSendPacketList field
        //
        if (NbiDevice.GlobalSendPacketList.Flink == &pDevice->GlobalSendPacketList)
        {
            dprintf("%08lx: Device GlobalSendPacketList @%08lx is empty\n", &pDevice->GlobalSendPacketList);
            return;
        }

        pFirstPacket = CONTAINING_RECORD (NbiDevice.GlobalSendPacketList.Flink, NB_SEND_RESERVED, GlobalLinkage);
    }
    else
    {
        //
        // Read in the address for the first packet
        //
        NumArgsRead = sscanf(args, "%lx", &pFirstPacket);
        if (0 == NumArgsRead)  {
            dprintf("Bad argument for FirstPacket <%s>\n", args);
            return;
        }
    }

    if (ReadArgsForTraverse (args, szPacketCount))
    {
        NumArgsRead = sscanf(szPacketCount, "%lx", &MaxCount);
        if (0 == NumArgsRead)  {
            dprintf("Bad argument for PacketCount <%s>\n", szPacketCount);
            return;
        }
    }

    DumpSPacketList((ULONG) pFirstPacket, MaxCount, FALSE);

    return;
}



//
// Local functions
//
ULONG
DumpSPacket(
    ULONG   _objAddr,
    BOOLEAN Full
    )
{
    _objType _obj;
    ULONG result;
    ULONG next;

    if (!ReadMemory(
             _objAddr,
             &_obj,
             sizeof(_obj),
             &result
             )
       )
    {
        dprintf("%08lx: Could not read spacket\n", spacketToDump);
        return 0;
    }

    dprintf( "%s @ %08lx\n", "Send Packet", _objAddr );

    PrintStartStruct();
    PrintBool(SendInProgress);
    PrintXUChar(Type);
    PrintBool(OwnedByConnection);
    PrintPtr(Header);
    switch(_obj.Type) {
    case SEND_TYPE_DATAGRAM:
        PrintPtr(u.SR_DG.DatagramRequest);
        PrintPtr(u.SR_DG.AddressFile);
        PrintPtr(u.SR_DG.Cache);
        break;
    case SEND_TYPE_NAME_FRAME:
        PrintPtr(u.SR_NF.Address);
        PrintPtr(u.SR_NF.Request);
        PrintPtr(u.SR_NF.AddressFile);
        break;
    case SEND_TYPE_FIND_NAME:
        PrintAddr(u.SR_FN.NetbiosName);
        break;
    case SEND_TYPE_SESSION_NO_DATA:
        PrintPtr(u.SR_CO.Connection);
        break;
    case SEND_TYPE_SESSION_DATA:
        PrintPtr(u.SR_CO.Connection);
        PrintPtr(u.SR_CO.Request);
        break;
    case SEND_TYPE_SESSION_INIT:
        break;
    case SEND_TYPE_STATUS_QUERY:
    case SEND_TYPE_STATUS_RESPONSE:
        break;
    }
    PrintEndStruct();
    return( (ULONG) CONTAINING_RECORD( _obj.GlobalLinkage.Flink, _objType, GlobalLinkage));

}

VOID
DumpSPacketList(
    ULONG           pFirstPacket,
    ULONG           MaxCount,
    BOOLEAN         Full
    )

/*++

Routine Description:

    Dumps the fields of the specified DEVICE_CONTEXT structure

Arguments:

    deviceToDump  - The device context object to display
    Full          - Display a partial listing if 0, full listing otherwise.

Return Value:

    None

--*/

{
    ULONG         nextSPacket;
    ULONG         count = 0;

    nextSPacket = pFirstPacket;
    do
    {
        nextSPacket = DumpSPacket( nextSPacket, Full );
        if (++count == MaxCount)
        {
            break;
        }
    } while( nextSPacket && (nextSPacket != pFirstPacket ));

    dprintf("\nDumped %d Packets (%s)\n", count, (MaxCount ? "MaxCount specified" : "all packets"));

    return;
}


///////////////////////////////////////////////////////////////////////
//                      CACHE
//////////////////////////////////////////////////////////////////////

VOID
DumpLocalAddresses(
    PLIST_ENTRY     pHead
    )

/*++

Routine Description:

    Dumps the fields of the specified DEVICE_CONTEXT structure

Arguments:

    deviceToDump  - The device context object to display
    Full          - Display a partial listing if 0, full listing otherwise.

Return Value:

    None

--*/

{
    PLIST_ENTRY     pEntry;
    ADDRESS         *pAddress;
    ADDRESS         Address;
    ULONG           Result;
    ULONG           Count = 0;

    dprintf("\nDumping Local Address Names:\n");
    dprintf("----------------------------\n");

    if (!ReadMemory ((ULONG) pHead, &pEntry, sizeof(PLIST_ENTRY), &Result))
    {
        dprintf("%p: Could not read pHead info\n", pHead);
        return;
    }

    dprintf("RefC    <Address>  => <Name              > |    State |NTFlag|    Flags | BCast\n");
    dprintf("-------------------------------------------------------------------------------\n");

    while (pEntry != pHead)
    {
        pAddress = CONTAINING_RECORD (pEntry, ADDRESS, Linkage);
        if (!ReadMemory((ULONG) pAddress, &Address, sizeof(ADDRESS), &Result))
        {
            dprintf("%p: Could not read Address information\n", pAddress);
            return;
        }

        Count++;
        pEntry = Address.Linkage.Flink;

        dprintf("[%d]\t<%p> => ", Address.ReferenceCount, pAddress);
        dprintf("<%-15.15s:%2x> | %8x |   %2x | %8x |    %s\n",
            Address.NetbiosAddress.NetbiosName,
            Address.NetbiosAddress.NetbiosName[15],
            Address.State,
            Address.NameTypeFlag,
            Address.Flags,
            (Address.NetbiosAddress.Broadcast ? "Y" : "N"));
    }

    dprintf("\nDumped %d Addresses\n", Count);

    return;
}

VOID
DumpRemoteCache(
    NETBIOS_CACHE_TABLE *pNameCacheTable,
    USHORT              CacheTimeStamp
    )

/*++

Routine Description:

    Dumps the fields of the specified DEVICE_CONTEXT structure

Arguments:

    deviceToDump  - The device context object to display
    Full          - Display a partial listing if 0, full listing otherwise.

Return Value:

    None

--*/

{
    NETBIOS_CACHE_TABLE     NameCacheTable;
    NETBIOS_CACHE           CacheEntry;
    NETBIOS_CACHE           *pCacheEntry;
    PLIST_ENTRY             pHead, pEntry;
    ULONG                   HashIndex;
    ULONG                   Result;
    ULONG                   Count = 0;

    if (!ReadMemory ((ULONG) pNameCacheTable, &NameCacheTable, sizeof(NETBIOS_CACHE_TABLE), &Result))
    {
        dprintf("%p: Could not read Remote Name Cache\n", pNameCacheTable);
        return;
    }

    dprintf("Dumping Remote Names (%3d entries, %3d buckets), TimeStamp = %4d, AgeLimit = %4d:\n",
        NameCacheTable.CurrentEntries, NameCacheTable.MaxHashIndex, CacheTimeStamp, (600000 / LONG_TIMER_DELTA));
    dprintf("-----------------------------------------------------------------------------------\n");

    dprintf("[Bkt#]  <Address>  => <Name              > | TimeSt | NetsU | NetsA | RefC | U | FailedOnDownWan\n");
    dprintf("------------------------------------------------------------------------------------------------\n");

    for (HashIndex = 0; HashIndex < NameCacheTable.MaxHashIndex; HashIndex++)
    {
        pHead = &pNameCacheTable->Bucket[HashIndex];

        if (!ReadMemory ((ULONG) pHead, &pEntry, sizeof(PLIST_ENTRY), &Result))
        {
            dprintf("%p: Could not Entry ptr\n", pHead);
            return;
        }

        while (pEntry != pHead)
        {
            pCacheEntry = CONTAINING_RECORD (pEntry, NETBIOS_CACHE, Linkage);
            if (!ReadMemory((ULONG) pCacheEntry, &CacheEntry, sizeof(NETBIOS_CACHE), &Result))
            {
                dprintf("%p: Could not read Remote Name information\n", pCacheEntry);
                return;
            }

            Count++;
            pEntry = CacheEntry.Linkage.Flink;

            dprintf("[%d]\t<%p> => ", HashIndex, pCacheEntry);
            dprintf("<%-15.15s:%2x> |   %4d |  %4d |  %4d |   %2d | %s | %s\n",
                CacheEntry.NetbiosName,
                CacheEntry.NetbiosName[15],
                CacheEntry.TimeStamp,
                CacheEntry.NetworksUsed,
                CacheEntry.NetworksAllocated,
                CacheEntry.ReferenceCount,
                (CacheEntry.Unique ? "U" : "G"),
                (CacheEntry.FailedOnDownWan ? "Y" : "N"));
        }
    }

    dprintf("\nDumped %d Remote names\n", Count);

    return;
}

//
// Exported function
//

DECLARE_API( nbcache )

/*++

Routine Description:

    Dumps the most important fields of the specified ADDRESS_FILE object

Arguments:

    args - Address of args string

Return Value:

    None

--*/

{
    DEVICE              *pDevice;
    ULONG               Result;
    NETBIOS_CACHE_TABLE *pNameCache;
    USHORT              CacheTimeStamp;

    if (!*args)
    {
        //
        // No initial packet has been defined, so set the initial packet
        // from the global pool list
        //
        if (!(pDevice = (DEVICE *) GetExpression("nwlnknb!NbiDevice")))
        {
            dprintf("Could not get NbiDevice, Try !reload\n");
            return;
        }

        if (!ReadMemory ((ULONG) pDevice, &pDevice, sizeof(DEVICE *), &Result))
        {
            dprintf("%p: Could not read device address\n", pDevice);
            return;
        }
    }
    else
    {
        NumArgsRead = sscanf(args, "%p", &pDevice);
        if (0 == NumArgsRead)  {
            dprintf("Bad argument for NbiDevice <%s>\n", args);
            return;
        }
    }

    DumpLocalAddresses (&pDevice->AddressDatabase);

    dprintf ("\n\n");
    if (!ReadMemory ((ULONG) &pDevice->NameCache, &pNameCache, sizeof(NETBIOS_CACHE_TABLE *), &Result))
    {
        dprintf("%p: Could not read NameCache ptr from Device\n", &pDevice->NameCache);
        return;
    }

    if (!ReadMemory ((ULONG) &pDevice->CacheTimeStamp, &CacheTimeStamp, sizeof(USHORT), &Result))
    {
        dprintf("%p: Could not read CacheTimeStamp value from Device\n", &pDevice->CacheTimeStamp);
        return;
    }

    DumpRemoteCache (pNameCache, CacheTimeStamp);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\kdext\spxext.c ===
#include "precomp.h"
#pragma hdrstop


#ifndef __PREFAST__
#pragma warning(disable:4068)
#endif
#pragma prefast(disable:276, "This is only debugging tool")

#include <isnspx.h>

VOID
DumpSpxDevice
(
    ULONG     DeviceToDump,
    VERBOSITY Verbosity
);

VOID
DumpSpxAddress
(
    ULONG     _objAddr,
    VERBOSITY Verbosity
);

VOID
DumpSpxAddressFile
(
    ULONG     _objAddr,
    VERBOSITY Verbosity
);

VOID
DumpSpxConnFile
(
    ULONG     _objAddr,
    VERBOSITY Verbosity
);

PSPX_ADDR
NextSpxAddr
(
    PSPX_ADDR pAddr
);

ENUM_INFO EnumConnFileMain[] =
{
    { SPX_CONNFILE_ACTIVE, "Active" },
    { SPX_CONNFILE_CONNECTING, "Connecting" },
    { SPX_CONNFILE_LISTENING, "Listening" },
    { SPX_CONNFILE_DISCONN, "Disconn" },
    { 0, NULL }
};

ENUM_INFO EnumConnFileConnecting[] =
{
    { SPX_CONNECT_SENTREQ, "SentReq" },
    { SPX_CONNECT_NEG, "Neg" },
    { SPX_CONNECT_W_SETUP, "W_Setup" },
    { 0, NULL }
};

ENUM_INFO EnumConnFileListening[] =
{
    { SPX_LISTEN_RECDREQ, "RecdReq" },
    { SPX_LISTEN_SENTACK, "SentAck" },
    { SPX_LISTEN_NEGACK, "NegAck" },
    { SPX_LISTEN_SETUP, "Setup" },
    { 0, NULL }
};

ENUM_INFO EnumConnFileSend[] =
{
    { SPX_SEND_IDLE, "Idle" },
    { SPX_SEND_PACKETIZE, "Packetize" },
    { SPX_SEND_RETRY, "Retry" },
    { SPX_SEND_RETRYWD, "RetryWd" },
    { SPX_SEND_RENEG, "Reneg" },
    { SPX_SEND_RETRY2, "Retry2" },
    { SPX_SEND_RETRY3, "Retry3" },
    { SPX_SEND_WD, "Wd" },
    { SPX_SEND_NAK_RECD, "Nak_Recd" },
    { 0, NULL }
};

ENUM_INFO EnumConnFileReceive[] =
{
    { SPX_RECV_IDLE, "Idle" },
    { SPX_RECV_POSTED, "Posted" },
    { SPX_RECV_PROCESS_PKTS, "Process_Pkts" },
    { 0, NULL }
};

ENUM_INFO EnumConnFileDisconnect[] =
{
    { SPX_DISC_IDLE, "Idle" },
    { SPX_DISC_ABORT, "Abort" },
    { SPX_DISC_SENT_IDISC, "Sent_IDisc" },
    { SPX_DISC_POST_ORDREL, "Post_OrdRel" },
    { SPX_DISC_SENT_ORDREL, "Sent_OrdRel" },
    { SPX_DISC_ORDREL_ACKED, "OrdRel_Acked" },
    { SPX_DISC_POST_IDISC, "Post_IDisc" },
    { SPX_DISC_INACTIVATED, "Inactivated" },
    { 0, NULL }
};

FLAG_INFO FlagsConnFile[] =
{
    { SPX_CONNFILE_RECVQ, "RecvQ" },
    { SPX_CONNFILE_RENEG_SIZE, "Reneg_Size" },
    { SPX_CONNFILE_ACKQ, "AckQ" },
    { SPX_CONNFILE_PKTQ, "PktQ" },
    { SPX_CONNFILE_ASSOC, "Assoc" },
    { SPX_CONNFILE_NEG, "Neg" },
    { SPX_CONNFILE_SPX2, "SPX2" },
    { SPX_CONNFILE_STREAM, "Stream" },
    { SPX_CONNFILE_R_TIMER, "R_Timer" },
    { SPX_CONNFILE_C_TIMER, "C_Timer" },
    { SPX_CONNFILE_W_TIMER, "W_Timer" },
    { SPX_CONNFILE_T_TIMER, "T_Timer" },
    { SPX_CONNFILE_RENEG_PKT, "Reneg_Pkt" },
    { SPX_CONNFILE_IND_IDISC, "Ind_IDisc" },
    { SPX_CONNFILE_IND_ODISC, "Ind_ODisc" },
    { SPX_CONNFILE_STOPPING, "Stopping" },
    { SPX_CONNFILE_CLOSING, "Closing" },
    { 0, NULL }
};

FLAG_INFO Flags2ConnFile[] =
{
    { SPX_CONNFILE2_PKT_NOIND, "Pkt_Noind" },
    { SPX_CONNFILE2_RENEGRECD, "RenegRecd" },
    { SPX_CONNFILE2_PKT, "Pkt" },
    { SPX_CONNFILE2_FINDROUTE, "FindRoute" },
    { SPX_CONNFILE2_NOACKWAIT, "NoAckWait" },
    { SPX_CONNFILE2_IMMED_ACK, "Immed_Ack" },
    { SPX_CONNFILE2_IPXHDR, "IpxHdr" },
    { 0, NULL }
};

MEMBER_TABLE SpxConnFileMembers[] =
{
    /*
    {   "scf_DiscLinkage",
        FIELD_OFFSET( SPX_CONN_FILE, scf_DiscLinkage ),
        xxxxxxx,
        FIELD_OFFSET( NDIS_PACKET, ProtocolReserved ) + FIELD_OFFSET( IPX_SEND_RESERVED, GlobalLinkage )
    },
    */
    { NULL }
};

ENUM_INFO EnumSpxSendReqType[] =
{
    EnumString( SPX_REQ_DATA ),
    EnumString( SPX_REQ_ORDREL ),
    EnumString( SPX_REQ_DISC ),
    { 0, NULL }
};

VOID dprint_addr_list( ULONG FirstAddress, ULONG OffsetToNextPtr )
{
    ULONG Address;
    ULONG result;
    int index;

    Address = FirstAddress;

    if ( Address == (ULONG)NULL )
    {
        dprintf( "%08X (Empty)\n", Address );
        return;
    }

    dprintf( "{ " );

    for ( index = 0; Address != (ULONG)NULL; index ++ )
    {
        if ( index != 0 )
        {
            dprintf( ", ");
        }
        dprintf( "%08X", Address );

        if ( !ReadMemory( Address + OffsetToNextPtr,
                          &Address,
                          sizeof( Address ),
                          &result ))
        {
            dprintf( "ReadMemory() failed." );
            Address = (ULONG)NULL;
        }
    }
    dprintf( " }\n" );
}

DECLARE_API( spxdev )
/*++

Routine Description:

    Dumps the most important fields of the specified DEVICE_CONTEXT object

Arguments:

    args - Address

Return Value:

    None

--*/
{
    ULONG  deviceToDump = 0;
    ULONG  pDevice = 0;
    ULONG  result;
    char VarName[ MAX_LIST_VARIABLE_NAME_LENGTH + 1 ];
    MEMBER_VARIABLE_INFO MemberInfo;
    BOOL bFocusOnMemberVariable = FALSE;

    if ( *args )
    {
        bFocusOnMemberVariable = ReadArgsForTraverse( args, VarName );
    }

    if ( *args && *args!='-' )
    {
        if (!sscanf(args, "%lx", &deviceToDump))
		{
			return;
		}
    }

    if ( deviceToDump == 0 ) {

        pDevice    =   GetExpression( "nwlnkspx!SpxDevice" );

        if ( !pDevice ) {
            dprintf("Could not get nwlnkspx!SpxDevice, Try !reload\n");
            return;
        } else {

            if ( !ReadMemory( pDevice,
                              &deviceToDump,
                              sizeof(deviceToDump),
                              &result ))
            {
                dprintf("%08lx: Could not read device address\n", pDevice);
                return;
            }
        }
    }

    if ( bFocusOnMemberVariable )
    {
//        if ( !LocateMemberVariable( "IpxDevice", VarName, ( PVOID )deviceToDump, &MemberInfo ))
        {
            return;
        }

        WriteMemberInfo( &MemberInfo );
        next( hCurrentProcess, hCurrentThread, dwCurrentPc, dwProcessor, "" );
        return;
    }

    DumpSpxDevice( deviceToDump, VERBOSITY_NORMAL );

    return;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#   undef _objTypeName
#endif

#define _obj            Device
#define _objAddr        DeviceToDump
#define _objType        DEVICE
#define _objTypeName    "DEVICE"

VOID
DumpSpxDevice
(
    ULONG     DeviceToDump,
    VERBOSITY Verbosity
)
/*++

Routine Description:

    Dumps the fields of the specified DEVICE_CONTEXT structure

Arguments:

    DeviceToDump  - The device context object to display
    Full          - Display a partial listing if 0, full listing otherwise.

Return Value:

    None

--*/
{
    _objType _obj;
    ULONG result;
    unsigned int index;
    WCHAR Buffer[ 1000 ];
    PWCHAR pDeviceName = NULL;
    PSPX_ADDR pAddr;

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read %s structure.\n", _objAddr, _objTypeName );
        return;
    }

    if (Device.dev_Type != SPX_DEVICE_SIGNATURE)

    {

        dprintf( "Signature does not match, probably not a device object %lx\n", DeviceToDump);
        dprintf( "Device.Type == %04X, and I think it should be %04X\n", Device.dev_Type, SPX_DEVICE_SIGNATURE );
        dprintf( "DeviceToDump = %08X\n", DeviceToDump );
        dprintf( "Offset to Device.Type = %d\n", FIELD_OFFSET( DEVICE, dev_Type ) );
        return;
    }

    if ( !ReadMemory( ( ULONG )_obj.dev_DeviceName,
                      Buffer,
                      sizeof( WCHAR ) * _obj.dev_DeviceNameLen,
                      &result ))
    {
        dprintf("%08lx: Could not read device name buffer\n", _obj.dev_DeviceName );
    }
    else
    {
        pDeviceName = Buffer;
    }

    if ( Verbosity == VERBOSITY_ONE_LINER )
    {
        dprintf( "\"%S\"", pDeviceName );
        return;
    }

    PrintStartStruct();

    PrintPtr( dev_DevObj );

#if DBG
#   if DREF_TOTAL != 5
#       error DREF_TOTAL is assumed to equal 5
#   endif
    PrintULong( dev_RefTypes[ DREF_CREATE ] );
    PrintULong( dev_RefTypes[ DREF_LOADED ] );
    PrintULong( dev_RefTypes[ DREF_ADAPTER ] );
    PrintULong( dev_RefTypes[ DREF_ADDRESS ] );
    PrintULong( dev_RefTypes[ DREF_ORPHAN ] );
#endif

    PrintUShort( dev_Type );
    PrintUShort( dev_Size );

#if DBG
    PrintNChar( dev_Signature1, sizeof( _obj.dev_Signature1 ));
#endif

    PrintULong( dev_RefCount );
    PrintUChar( dev_State );

    PrintUShort( dev_Adapters );

    PrintLock( dev_Interlock );
    PrintLock( dev_Lock );

    for ( index = 0; index < NUM_SPXADDR_HASH_BUCKETS; index ++ )
    {
        PrintIndent();
        dprintf( "dev_AddrHashTable[ %d ] = ", index );

        dprint_addr_list( ( ULONG )_obj.dev_AddrHashTable[ index ],
                             FIELD_OFFSET( SPX_ADDR, sa_Next ));
    }

    for ( index = 0; index < NUM_SPXCONN_HASH_BUCKETS; index ++ )
    {
        PrintIndent();
        dprintf( "dev_GlobalActiveConnList[ %d ] = ", index );

        dprint_addr_list( ( ULONG )_obj.dev_GlobalActiveConnList[ index ],
                             FIELD_OFFSET( SPX_CONN_FILE, scf_Next ));
    }

    PrintUShort( dev_NextConnId );

    PrintUShort( dev_CurrentSocket );

    PrintFieldName( "dev_Network" );
    dprintf("0x%-8hx%s", *(( ULONG *)_obj.dev_Network ), EOL);

    PrintFieldName( "dev_Node" );
    dprint_hardware_address( _obj.dev_Node );
    dprintf( "%s", EOL );

    PrintPtr( dev_ConfigInfo );

    PrintULong( dev_CcId );

    PrintJoin();
    PrintPtr( dev_DeviceName );
    dprintf( "\"%S\"\n", pDeviceName );

    PrintULong( dev_DeviceNameLen );

#if DBG
    PrintNChar( dev_Signature2, sizeof( _obj.dev_Signature2 ));
#endif

    PrintAddr( dev_NdisBufferPoolHandle );

    PrintAddr( dev_StatInterlock );
    PrintAddr( dev_StatSpinLock );

    PrintAddr( dev_Stat );
    PrintAddr( dev_AddrResource );

    PrintAddr( dev_ProviderInfo );

    PrintEndStruct();
}

DECLARE_API( spxaddr )
/*++

Routine Description:

    Dumps the most important fields of the specified DEVICE_CONTEXT object

Arguments:

    args - Address

Return Value:

    None

--*/
{
    ULONG  addressToDump = 0;
    ULONG  result;
    char VarName[ MAX_LIST_VARIABLE_NAME_LENGTH + 1 ];
    MEMBER_VARIABLE_INFO MemberInfo;
    BOOL bFocusOnMemberVariable = FALSE;

    if ( *args )
    {
        bFocusOnMemberVariable = ReadArgsForTraverse( args, VarName );
    }

    if ( *args && *args!='-' )
    {
        if(!sscanf(args, "%lx", &addressToDump))
        {
            return;
        }
    }

    if ( bFocusOnMemberVariable )
    {
//        if ( !LocateMemberVariable( "IpxDevice", VarName, ( PVOID )deviceToDump, &MemberInfo ))
        {
            return;
        }

        WriteMemberInfo( &MemberInfo );
        next( hCurrentProcess, hCurrentThread, dwCurrentPc, dwProcessor, "" );
        return;
    }

    DumpSpxAddress( addressToDump, VERBOSITY_NORMAL );

    return;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#   undef _objTypeName
#endif

#define _obj            Address
#define _objAddr        AddressToDump
#define _objType        SPX_ADDR
#define _objTypeName    "SPX_ADDR"

VOID
DumpSpxAddress
(
    ULONG     _objAddr,
    VERBOSITY Verbosity
)
/*++

Routine Description:

    Dumps the fields of the specified DEVICE_CONTEXT structure

Arguments:

    DeviceToDump  - The device context object to display
    Full          - Display a partial listing if 0, full listing otherwise.

Return Value:

    None

--*/
{
    _objType _obj;
    ULONG result;
    unsigned int index;

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read %s structure.\n", _objAddr, _objTypeName );
        return;
    }

    CHECK_SIGNATURE( sa_Type, SPX_ADDRESS_SIGNATURE );

    if ( Verbosity == VERBOSITY_ONE_LINER )
    {
        dprintf( "Socket = %d", _obj.sa_Socket );
        if ( _obj.sa_Flags & SPX_ADDR_CLOSING )
        {
            dprintf(" (CLOSING)");
        }
        return;
    }

    PrintStartStruct();

#if DBG
#   if AREF_TOTAL !=4
#       error AREF_TOTAL is assumed to equal 4
#   endif

    PrintULong( sa_RefTypes[ AREF_ADDR_FILE ] );
    PrintULong( sa_RefTypes[ AREF_LOOKUP ] );
    PrintULong( sa_RefTypes[ AREF_RECEIVE ] );
    PrintULong( sa_RefTypes[ 3 ] );
#endif

    PrintUShort( sa_Size );
    PrintXEnum( sa_Type, EnumStructureType );

    PrintULong( sa_RefCount );

    PrintPtr( sa_Next );
    PrintXULong( sa_Flags );

    PrintFieldName( "sa_AddrFileList" );
    dprint_addr_list( ( ULONG )_obj.sa_AddrFileList,
                         FIELD_OFFSET( SPX_ADDR_FILE, saf_Next ));

    PrintFieldName( "sa_InactiveConnList" );
    dprint_addr_list( ( ULONG )_obj.sa_InactiveConnList,
                      FIELD_OFFSET( SPX_CONN_FILE, scf_Next ));

    PrintFieldName( "sa_ActiveConnList" );
    dprint_addr_list( ( ULONG )_obj.sa_ActiveConnList,
                      FIELD_OFFSET( SPX_CONN_FILE, scf_Next ));

    PrintFieldName( "sa_ListenConnList" );
    dprint_addr_list( ( ULONG )_obj.sa_ListenConnList,
                      FIELD_OFFSET( SPX_CONN_FILE, scf_Next ));

    PrintLock( sa_Lock );
    PrintUShort( sa_Socket );
    PrintPtr( sa_Device );
    PrintPtr( sa_DeviceLock );

    PrintStartNamedStruct( "union" );

    PrintAddr( u.sa_ShareAccess );
    PrintAddr( u.sa_DestroyAddrQueueItem );

    PrintEndStruct();

    PrintPtr( sa_SecurityDescriptor );
    PrintEndStruct();
}

DECLARE_API( spxaddrfile )
{
    ULONG  addressToDump = 0;
    ULONG  result;
    char VarName[ MAX_LIST_VARIABLE_NAME_LENGTH + 1 ];
    MEMBER_VARIABLE_INFO MemberInfo;
    BOOL bFocusOnMemberVariable = FALSE;

    if ( *args )
    {
        bFocusOnMemberVariable = ReadArgsForTraverse( args, VarName );
    }

    if ( *args && *args!='-' )
    {
        if (!sscanf(args, "%lx", &addressToDump))
		{
			return;
		}
    }

    if ( bFocusOnMemberVariable )
    {
//        if ( !LocateMemberVariable( "IpxDevice", VarName, ( PVOID )deviceToDump, &MemberInfo ))
        {
            return;
        }

        WriteMemberInfo( &MemberInfo );
        next( hCurrentProcess, hCurrentThread, dwCurrentPc, dwProcessor, "" );
        return;
    }

    DumpSpxAddressFile( addressToDump, VERBOSITY_NORMAL );

    return;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#   undef _objTypeName
#endif

#define _obj            AddressFile
#define _objAddr        AddressFileToDump
#define _objType        SPX_ADDR_FILE
#define _objTypeName    "SPX_ADDR_FILE"

VOID
DumpSpxAddressFile
(
    ULONG     _objAddr,
    VERBOSITY Verbosity
)
/*++

Routine Description:

    Dumps the fields of the specified DEVICE_CONTEXT structure

Arguments:

    DeviceToDump  - The device context object to display
    Full          - Display a partial listing if 0, full listing otherwise.

Return Value:

    None

--*/
{
    _objType _obj;
    ULONG result;
    unsigned int index;

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read %s structure.\n", _objAddr, _objTypeName );
        return;
    }

    CHECK_SIGNATURE( saf_Type, SPX_ADDRESSFILE_SIGNATURE );

    if ( Verbosity == VERBOSITY_ONE_LINER )
    {
        switch ( _obj.saf_Flags & 0x03 )
        {
        case SPX_ADDRFILE_OPENING:
            dprintf( "OPENING " );
            break;
        case SPX_ADDRFILE_OPEN:
            dprintf( "OPEN " );
            break;
        case SPX_ADDRFILE_CLOSING:
            dprintf( "CLOSING " );
            break;
        }
        DumpSpxAddress( ( ULONG )_obj.saf_Addr, VERBOSITY_ONE_LINER );
        return;
    }

    PrintStartStruct();
#if DBG
#   if AFREF_TOTAL !=4
#       error AFREF_TOTAL is assumed equal to 4.
#   endif

    PrintULong( saf_RefTypes[ AFREF_CREATE ] );
    PrintULong( saf_RefTypes[ AFREF_VERIFY ] );
    PrintULong( saf_RefTypes[ AFREF_INDICATION ] );
    PrintULong( saf_RefTypes[ AFREF_CONN_ASSOC ] );
#endif

    PrintXEnum( saf_Type, EnumStructureType );
    PrintUShort( saf_Size );

    PrintULong( saf_RefCount );
    PrintFieldName( "saf_Next" );
    dprint_addr_list( ( ULONG )_obj.saf_Next,
                         FIELD_OFFSET( SPX_ADDR_FILE, saf_Next ));

    PrintFieldName( "saf_GlobalNext" );
    dprint_addr_list( ( ULONG )_obj.saf_GlobalNext,
                       FIELD_OFFSET( SPX_ADDR_FILE, saf_GlobalNext));

    PrintFieldName( "saf_AssocConnList" );
    dprint_addr_list( ( ULONG )_obj.saf_AssocConnList,
                       FIELD_OFFSET( SPX_CONN_FILE, scf_AssocNext ));

    PrintXUShort( saf_Flags );
    PrintPtr( saf_Addr );
    PrintPtr( saf_AddrLock );

    PrintPtr( saf_FileObject );
    PrintPtr( saf_Device );
    PrintPtr( saf_CloseReq );

    PrintSymbolPtr( saf_ConnHandler );
    PrintXULong( saf_ConnHandlerCtx );

    PrintSymbolPtr( saf_DiscHandler );
    PrintXULong( saf_DiscHandlerCtx );

    PrintSymbolPtr( saf_RecvHandler );
    PrintXULong( saf_RecvHandlerCtx );

    PrintSymbolPtr( saf_SendPossibleHandler );
    PrintXULong( saf_SendPossibleHandlerCtx );

    PrintSymbolPtr( saf_ErrHandler );
    PrintXULong( saf_ErrHandlerCtx );

    PrintPtr( saf_ErrHandlerOwner );

    PrintEndStruct();
}

DECLARE_API( spxconnfile )
{
    ULONG  addressToDump = 0;
    ULONG  result;
    char VarName[ MAX_LIST_VARIABLE_NAME_LENGTH + 1 ];
    MEMBER_VARIABLE_INFO MemberInfo;
    BOOL bFocusOnMemberVariable = FALSE;

    if ( *args )
    {
        bFocusOnMemberVariable = ReadArgsForTraverse( args, VarName );
    }

    if ( *args && *args!='-' )
    {
        if (!sscanf(args, "%lx", &addressToDump))
		{
			return;
		}
    }

    if ( bFocusOnMemberVariable )
    {
        if ( !LocateMemberVariable( "SpxConnFile", VarName, ( PVOID )addressToDump, &MemberInfo ))
        {
            return;
        }

        WriteMemberInfo( &MemberInfo );
        next( hCurrentProcess, hCurrentThread, dwCurrentPc, dwProcessor, "" );
        return;
    }

    DumpSpxConnFile( addressToDump, VERBOSITY_NORMAL );

    return;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#   undef _objTypeName
#endif

#define _obj            ConnFile
#define _objAddr        ConnFileToDump
#define _objType        SPX_CONN_FILE
#define _objTypeName    "SPX_CONN_FILE"

VOID
DumpSpxConnFile
(
    ULONG     _objAddr,
    VERBOSITY Verbosity
)
/*++

Routine Description:

    Dumps the fields of the specified DEVICE_CONTEXT structure

Arguments:

    DeviceToDump  - The device context object to display
    Full          - Display a partial listing if 0, full listing otherwise.

Return Value:

    None

--*/
{
    _objType _obj;
    ULONG result;
    unsigned int index;
    BOOL bActive;

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read %s structure.\n", _objAddr, _objTypeName );
        return;
    }

    CHECK_SIGNATURE( scf_Type, SPX_CONNFILE_SIGNATURE );

    if ( Verbosity == VERBOSITY_ONE_LINER )
    {
        dprintf( "NOT IMPLEMENTED" );
        return;
    }

    PrintStartStruct();

#if DBG
#   if CFREF_TOTAL != 14
#       error CFREF_TOTAL is assumed equal to 13.
#   endif

    PrintULong( scf_RefTypes[ CFREF_CREATE ] );
    PrintULong( scf_RefTypes[ CFREF_VERIFY ] );
    PrintULong( scf_RefTypes[ CFREF_INDICATION ] );
    PrintULong( scf_RefTypes[ CFREF_BYCTX ] );
    PrintULong( scf_RefTypes[ CFREF_BYID ] );
    PrintULong( scf_RefTypes[ CFREF_ADDR ] );
    PrintULong( scf_RefTypes[ CFREF_REQ ] );
    PrintULong( scf_RefTypes[ CFREF_TIMER ] );
    PrintULong( scf_RefTypes[ CFREF_PKTIZE ] );
    PrintULong( scf_RefTypes[ CFREF_RECV ] );
    PrintULong( scf_RefTypes[ CFREF_ABORTPKT ] );
    PrintULong( scf_RefTypes[ CFREF_ERRORSTATE ] );
    PrintULong( scf_RefTypes[ CFREF_FINDROUTE ] );
    PrintULong( scf_RefTypes[ CFREF_DISCWAITSPX ] );
#endif

    PrintXEnum( scf_Type, EnumStructureType );
    PrintUShort( scf_Size );

    PrintULong( scf_RefCount );

    PrintFieldName( "scf_Next" );
    dprint_addr_list( ( ULONG )_obj.scf_Next,
                         FIELD_OFFSET( SPX_CONN_FILE, scf_Next ));

    PrintFieldName( "scf_AssocNext" );
    dprint_addr_list( ( ULONG )_obj.scf_AssocNext,
                         FIELD_OFFSET( SPX_CONN_FILE, scf_AssocNext ));

    PrintFieldName( "scf_GlobalActiveNext" );
    dprint_addr_list( ( ULONG )_obj.scf_GlobalActiveNext,
                         FIELD_OFFSET( SPX_CONN_FILE, scf_GlobalActiveNext ));

    PrintFieldName( "scf_GlobalNext" );
    dprint_addr_list( ( ULONG )_obj.scf_GlobalNext,
                         FIELD_OFFSET( SPX_CONN_FILE, scf_GlobalNext ));

    PrintFieldName( "scf_PktNext" );
    dprint_addr_list( ( ULONG )_obj.scf_PktNext,
                         FIELD_OFFSET( SPX_CONN_FILE, scf_PktNext ));

    PrintFieldName( "scf_ProcessRcvNext" );
    dprint_addr_list( ( ULONG )_obj.scf_ProcessRecvNext,
                         FIELD_OFFSET( SPX_CONN_FILE, scf_ProcessRecvNext ));

    bActive = ( _obj.scf_Flags & SPX_CONNFILE_MAINMASK ) == SPX_CONNFILE_ACTIVE;

    PrintXULong( scf_Flags );
    PrintXEnumMask( scf_Flags, EnumConnFileMain, SPX_CONNFILE_MAINMASK );

    if (( _obj.scf_Flags & SPX_CONNFILE_MAINMASK ) == SPX_CONNFILE_LISTENING )
    {
        PrintXEnumMask( scf_Flags, EnumConnFileListening, SPX_LISTEN_MASK );
    }

    if (( _obj.scf_Flags & SPX_CONNFILE_MAINMASK ) == SPX_CONNFILE_CONNECTING )
    {
        PrintXEnumMask( scf_Flags, EnumConnFileConnecting, SPX_CONNECT_MASK );
    }

    if ( bActive )
    {
        PrintXEnumMask( scf_Flags, EnumConnFileSend, SPX_SEND_MASK );
        PrintXEnumMask( scf_Flags, EnumConnFileReceive, SPX_RECV_MASK );
    }

    if ( (( _obj.scf_Flags & SPX_CONNFILE_MAINMASK ) == SPX_CONNFILE_LISTENING ) ||
         bActive )
    {
        PrintXEnumMask( scf_Flags, EnumConnFileDisconnect, SPX_DISC_MASK );
    }

    PrintFlagsMask( scf_Flags, FlagsConnFile, 0xFFFF0000 );

    PrintFlags( scf_Flags2, Flags2ConnFile );

#if DBG
    PrintXULong( scf_GhostFlags );
    PrintXULong( scf_GhostFlags2 );
    PrintULong( scf_GhostRefCount );
    PrintPtr( scf_GhostDiscReq );
#endif

    if ( bActive )
    {
        PrintULong( scf_WRetryCount );
    }
    else
    {
        PrintULong( scf_CRetryCount );
    }

    PrintULong( scf_RRetryCount );
    PrintXUShort( scf_RRetrySeqNum );

    if ( bActive )
    {
        PrintULong( scf_RTimerId );
    }
    else
    {
        PrintULong( scf_CTimerId );
    }


    PrintULong( scf_WTimerId );
    PrintULong( scf_TTimerId );
    PrintULong( scf_ATimerId );

    PrintULong( scf_BaseT1 );
    PrintULong( scf_AveT1 );
    PrintULong( scf_DevT1 );

    PrintUShort( scf_LocalConnId );
    PrintUShort( scf_SendSeqNum );
    PrintUShort( scf_SentAllocNum );
    PrintUShort( scf_RecvSeqNum );
    PrintUShort( scf_RecdAckNum );
    PrintUShort( scf_RecdAllocNum );
    PrintUShort( scf_RetrySeqNum );

    PrintUShort( scf_RenegAckAckNum );

    PrintNChar( scf_RemAddr, sizeof( _obj.scf_RemAddr ));
    PrintNChar( scf_RemAckAddr, sizeof( _obj.scf_RemAckAddr ));

    PrintUShort( scf_RemConnId );
    PrintUShort( scf_RenegMaxPktSize );

    PrintIpxLocalTarget( scf_AckLocalTarget );

    PrintUShort( scf_MaxPktSize );
    PrintUChar( scf_DataType );

    PrintIpxLocalTarget( scf_LocalTarget );
    PrintLock( scf_Lock );

    PrintJoin();
    PrintPtr( scf_AddrFile );
    dprintf( "(" );
    DumpSpxAddressFile( ( ULONG )_obj.scf_AddrFile, VERBOSITY_ONE_LINER );
    dprintf( ")\n" );

    PrintPtr( scf_ConnCtx );

    PrintPtr( scf_FileObject );

    PrintLL( scf_DiscLinkage );
    PrintLL( scf_ReqLinkage );
    PrintLL( scf_ReqDoneLinkage );
    PrintLL( scf_RecvDoneLinkage );
    PrintLL( scf_RecvLinkage );
    PrintPtr( scf_CurRecvReq );
    PrintULong( scf_CurRecvOffset );
    PrintULong( scf_CurRecvSize );
    PrintPtr( scf_ReqPkt );
    PrintULong( scf_ReqPktOffset );
    PrintULong( scf_ReqPktSize );
    PrintULong( scf_ReqPktFlags );
    PrintEnum( scf_ReqPktType, EnumSpxSendReqType );
    PrintPtr( scf_SendSeqListHead );
    PrintPtr( scf_SendSeqListTail );
    PrintPtr( scf_SendListHead );
    PrintPtr( scf_SendListTail );
    PrintPtr( scf_RecvListHead );
    PrintPtr( scf_RecvListTail );
    PrintPtr( scf_ConnectReq );
    PrintPtr( scf_CleanupReq );
    PrintPtr( scf_CloseReq );

#if DBG
    PrintUShort( scf_PktSeqNum );
    PrintXULong( scf_PktFlags );
    PrintXULong( scf_PktFlags2 );

    PrintULong( scf_IndBytes );
    PrintULong( scf_IndLine );
#endif

#if DBG_WDW_CLOSE
    PrintULong( scf_WdwCloseAve );
    PrintAddr( scf_WdwCloseTime );
#endif

    PrintPtr( scf_Device );

    PrintEndStruct();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\kdext\traverse.c ===
#include "precomp.h"
#pragma hdrstop

MEMBER_VARIABLE_INFO _MemberInfo;


#define STATE_FILENAME "isnext.state"

STRUCTURE_TABLE StructureTable[] = 
{
    IPX_MAJOR_STRUCTURES,
    SPX_MAJOR_STRUCTURES,
    { NULL }
};

BOOL NextListEntry( ULONG Current, PULONG Next );
BOOL PrevListEntry( ULONG Current, PULONG Prev );

VOID NextElement( PMEMBER_VARIABLE_INFO pMemberInfo );
VOID PrevElement( PMEMBER_VARIABLE_INFO pMemberInfo );
VOID DumpListItem( PMEMBER_VARIABLE_INFO pMemberInfo );


BOOL 
LocateMemberVariable
( 
    PCHAR pchStructName, 
    PCHAR pchMemberName,
    PVOID pvStructure,
    PMEMBER_VARIABLE_INFO pMemberInfo
)
{
    BOOL bMatch;
    int index;
    PMEMBER_TABLE pMemberTable;
    CHAR pchCurrent[ MAX_LIST_VARIABLE_NAME_LENGTH + 1 ];
    CHAR _pchStructName[ MAX_LIST_VARIABLE_NAME_LENGTH + 1 ];
    CHAR _pchMemberName[ MAX_LIST_VARIABLE_NAME_LENGTH + 1 ];
    
    dprintf( "LocateMemberVariable( \"%s\", \"%s\", 0x%08X )\n", pchStructName, pchMemberName, pMemberInfo );

    strcpy( _pchStructName, pchStructName );
    strcpy( _pchMemberName, pchMemberName );
    
    _strupr( _pchStructName );
    _strupr( _pchMemberName );

    pMemberInfo->StructureIndex = 0;
    pMemberInfo->MemberIndex = 0;
    
    bMatch = FALSE;
        
    for ( index = 0; StructureTable[ index ].pchStructName != NULL; index ++ )
    {
        strcpy( pchCurrent, StructureTable[ index ].pchStructName );
        _strupr( pchCurrent );
        
        if ( strstr( pchCurrent, _pchStructName ))
        {
            if ( bMatch )
            {
                dprintf( "The specified structure name is ambiguous.\n" );
                return( FALSE );
            }
            
            pMemberInfo->StructureIndex = index;
            
            bMatch = TRUE;
        }
    }
    
    if ( !bMatch )
    {
        dprintf( "No matching structure name was found.\n" );
        return( FALSE );    
    }
    
    pMemberTable = StructureTable[ pMemberInfo->StructureIndex ].pMemberTable;
    
    bMatch = FALSE;

    for ( index = 0; pMemberTable[ index ].pchMemberName != NULL; index ++ )
    {
        strcpy( pchCurrent, pMemberTable[ index ].pchMemberName );
        _strupr( pchCurrent );

        if ( strstr( pchCurrent, _pchMemberName ))
        {
            if ( bMatch )
            {
                dprintf( "The variable specified is ambiguous.\n" );
                return( FALSE );
            }
            
            pMemberInfo->MemberIndex = index;
            
            bMatch = TRUE;
        }
    }

    if ( !bMatch )
    {
        dprintf( "No matching member name was found in the %s structure.\n", pchStructName );
        return( FALSE );    
    }

    pMemberInfo->prHeadContainingObject = ( ULONG )pvStructure;
    pMemberInfo->prHeadLinkage = (( ULONG )pvStructure ) + pMemberTable[ pMemberInfo->MemberIndex ].cbOffsetToHead;
    pMemberInfo->prCurrentLinkage = pMemberInfo->prHeadLinkage;
    pMemberInfo->cCurrentElement = 0;

    return( TRUE );
}

BOOL WriteMemberInfo( PMEMBER_VARIABLE_INFO pMemberInfo )
{
    HANDLE hStateFile;
    DWORD dwWritten;

    hStateFile = CreateFile( STATE_FILENAME,
                             GENERIC_WRITE,
                             0,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL );

    if ( hStateFile == INVALID_HANDLE_VALUE )
    {
        dprintf( "Can't create state file\n" );
        return( FALSE );
    }

    if ( !WriteFile( hStateFile, 
                     pMemberInfo,
                     sizeof( MEMBER_VARIABLE_INFO ),
                     &dwWritten,
                     NULL ) || ( dwWritten != sizeof( MEMBER_VARIABLE_INFO )))
    {
        dprintf( "Can't write to state file\n" );
        CloseHandle( hStateFile );
        return( FALSE );
    }
    
    CloseHandle( hStateFile );

    return( TRUE );
}

BOOL ReadMemberInfo( PMEMBER_VARIABLE_INFO pMemberInfo )
{
    HANDLE hStateFile;
    DWORD dwRead;
    
    hStateFile = CreateFile( STATE_FILENAME,
                             GENERIC_READ,
                             0,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL );
    if ( hStateFile == INVALID_HANDLE_VALUE )
    {
        dprintf( "Can't open state file\n" );
        return( FALSE );
    }
    
    if ( !ReadFile( hStateFile, 
                     pMemberInfo,
                     sizeof( MEMBER_VARIABLE_INFO ),
                     &dwRead,
                     NULL ) || ( dwRead != sizeof( MEMBER_VARIABLE_INFO )))
    {
        dprintf( "Can't read from state file\n" );
        CloseHandle( hStateFile );
        return( FALSE );
    }
    
    CloseHandle( hStateFile );
    return( TRUE );
}


DECLARE_API( next )
{
    MEMBER_VARIABLE_INFO MemberInfo;
    
    if ( !ReadMemberInfo( &MemberInfo ) )
    {
        return;
    }
    
    NextElement( &MemberInfo );
    DumpListItem( &MemberInfo );
    WriteMemberInfo( &MemberInfo );
}

DECLARE_API( prev )
{
    MEMBER_VARIABLE_INFO MemberInfo;
    
    if ( !ReadMemberInfo( &MemberInfo ) )
    {
        return;
    }
    
    PrevElement( &MemberInfo );
    DumpListItem( &MemberInfo );
    WriteMemberInfo( &MemberInfo );
}


VOID DumpListItem( PMEMBER_VARIABLE_INFO pMemberInfo )
{
    PBYTE pbObject;
    PMEMBER_TABLE pMemberTable;    
    
    dprintf( "Focus is on: %s.%s, element # %d\n", 
             StructureTable[ pMemberInfo->StructureIndex ].pchStructName,
             StructureTable[ pMemberInfo->StructureIndex ].pMemberTable[ pMemberInfo->MemberIndex ].pchMemberName,
             pMemberInfo->cCurrentElement );

    pMemberTable = &StructureTable[ pMemberInfo->StructureIndex ].pMemberTable[ pMemberInfo->MemberIndex ];

    if ( pMemberInfo->prCurrentLinkage == pMemberInfo->prHeadLinkage )
    {
        //
        // Rather than dumping the head list item, dump all the items on the list,
        // in summary form.
        //
        
        do
        {
            NextElement( pMemberInfo );
            
            if ( pMemberInfo->prCurrentLinkage != pMemberInfo->prHeadLinkage )
            {
                pbObject =   (( PBYTE )pMemberInfo->prCurrentLinkage )
                           - pMemberTable->cbOffsetToLink;
        
                pMemberTable->DumpStructure( ( ULONG )pbObject, VERBOSITY_ONE_LINER );
                dprintf( "\n" );
            }
        } while ( pMemberInfo->prCurrentLinkage != pMemberInfo->prHeadLinkage );
    }
    else
    {
        pbObject =   (( PBYTE )pMemberInfo->prCurrentLinkage )
                   - pMemberTable->cbOffsetToLink;
        
        pMemberTable->DumpStructure( ( ULONG )pbObject, VERBOSITY_NORMAL );
    }
}


VOID NextElement( PMEMBER_VARIABLE_INFO pMemberInfo )
{
    ULONG NextLinkage;
    PMEMBER_TABLE pMember;

    pMember = &StructureTable[ pMemberInfo->StructureIndex ].pMemberTable[ pMemberInfo->MemberIndex ];

    if ( !pMember->Next( pMemberInfo->prCurrentLinkage, &NextLinkage ))
    {
        dprintf( "Command failed.\n" );
        return;
    }

    pMemberInfo->prCurrentLinkage = NextLinkage;
    pMemberInfo->cCurrentElement++;
    
    if ( pMemberInfo->prCurrentLinkage == pMemberInfo->prHeadLinkage )
    {
        pMemberInfo->cCurrentElement = 0;
    }
}

BOOL NextListEntry( ULONG Current, PULONG Next )
{
    ULONG result;
    ULONG prNextEntry;
    LIST_ENTRY Entry;
    LIST_ENTRY NextEntry;

    if ( !ReadMemory( Current,
                      &Entry,
                      sizeof( Entry ),
                      &result ))
    {
        dprintf( "Couldn't read current list entry at 0x%08X.\n", Current );
        return( FALSE );
    }

    prNextEntry = ( ULONG )Entry.Flink;
                   
    if ( !ReadMemory( prNextEntry,
                      &NextEntry,
                      sizeof( NextEntry ),
                      &result ))
    {
        dprintf( "Couldn't read next list entry at 0x%08X.\n", prNextEntry );
        return( FALSE );
    }
    
    if ( ( ULONG )NextEntry.Blink != Current )
    {
        dprintf( "Next entry's Blink doesn't match current entry's address.\n" );
        dprintf( "The list might be corrupt, or you may be using traversal state saved before the list changed.\n" );
        return( FALSE );
    }

    *Next = prNextEntry;
    return( TRUE );
}

VOID PrevElement( PMEMBER_VARIABLE_INFO pMemberInfo )
{
    ULONG PrevLinkage;
    PMEMBER_TABLE pMember;

    pMember = &StructureTable[ pMemberInfo->StructureIndex ].pMemberTable[ pMemberInfo->MemberIndex ];

    if ( !pMember->Prev( pMemberInfo->prCurrentLinkage, &PrevLinkage ))
    {
        dprintf( "Command failed.\n" );
        return;
    }

    pMemberInfo->prCurrentLinkage = PrevLinkage;
    pMemberInfo->cCurrentElement++;
    
    if ( pMemberInfo->prCurrentLinkage == pMemberInfo->prHeadLinkage )
    {
        pMemberInfo->cCurrentElement = 0;
    }
}

BOOL PrevListEntry( ULONG Current, PULONG Prev )
{
    ULONG result;
    ULONG prPrevEntry;
    LIST_ENTRY Entry;
    LIST_ENTRY PrevEntry;

    if ( !ReadMemory( Current,
                      &Entry,
                      sizeof( Entry ),
                      &result ))
    {
        dprintf( "Couldn't read current list entry at 0x%08X.\n", Current );
        return( FALSE );
    }

    prPrevEntry = ( ULONG )Entry.Blink;
                   
    if ( !ReadMemory( prPrevEntry,
                      &PrevEntry,
                      sizeof( PrevEntry ),
                      &result ))
    {
        dprintf( "Couldn't read previous list entry at 0x%08X.\n", prPrevEntry );
        return( FALSE );
    }
    
    if ( ( ULONG )PrevEntry.Blink != Current )
    {
        dprintf( "Previous entry's Blink doesn't match current entry's address.\n" );
        dprintf( "The list might be corrupt, or you may be using traversal state saved before the list changed.\n" );
        return( FALSE );
    }

    *Prev = prPrevEntry;
    return( TRUE );
}

BOOL ReadArgsForTraverse( const char *args, char *VarName )
{
    PCHAR pchListVar;
    int index;
    BOOL bRetval = FALSE;

    pchListVar = strstr( args, "-l" );
    
    if ( pchListVar )
    {
        pchListVar += 2;
        
        while ( *pchListVar == ' ' )
        {
            pchListVar ++;
        }
        
        if ( *pchListVar == '\0' )
        {
            dprintf( "NOT IMPLEMENTED: usage on -l\n" );
//            ipxdev_usage();
            return( bRetval );
        }

        for ( index = 0; index < MAX_LIST_VARIABLE_NAME_LENGTH; index ++ )
        {
            VarName[ index ] = *pchListVar;

            if ( *pchListVar == ' ' || *pchListVar == '\0' )
            {
                VarName[ index ] = '\0';
                break;
            }
            
            VarName[ index + 1 ] = '\0';
            
            pchListVar ++;
        }

        bRetval = TRUE;
    }

    return( bRetval );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\nb\action.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    action.c

Abstract:

    This module contains code which implements the TDI action
    dispatch routines.

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


typedef struct _NB_ACTION_GET_COUNTS {
    USHORT MaximumNicId;     // returns maximum NIC ID
    USHORT NicIdCounts[32];  // session counts for first 32 NIC IDs
} NB_ACTION_GET_COUNTS, *PNB_ACTION_GET_COUNTS;


NTSTATUS
NbiTdiAction(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine handles action requests.

Arguments:

    Device - The netbios device.

    Request - The request describing the action.

Return Value:

    NTSTATUS - status of operation.

--*/

{

    NTSTATUS Status;
    PADDRESS_FILE AddressFile;
    PCONNECTION Connection;
    UINT BufferLength;
    UINT DataLength;
    PNDIS_BUFFER NdisBuffer;
    CTELockHandle LockHandle;
    union {
        PNB_ACTION_GET_COUNTS GetCounts;
    } u;
    PNWLINK_ACTION NwlinkAction = NULL;
    UINT i;
    static UCHAR BogusId[4] = { 0x01, 0x00, 0x00, 0x00 };   // old nwrdr uses this


    //
    // To maintain some compatibility with the NWLINK streams-
    // based transport, we use the streams header format for
    // our actions. The old transport expected the action header
    // to be in InputBuffer and the output to go in OutputBuffer.
    // We follow the TDI spec, which states that OutputBuffer
    // is used for both input and output. Since IOCTL_TDI_ACTION
    // is method out direct, this means that the output buffer
    // is mapped by the MDL chain; for action the chain will
    // only have one piece so we use it for input and output.
    //

    NdisBuffer = REQUEST_NDIS_BUFFER(Request);
    if (NdisBuffer == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    NdisQueryBufferSafe (REQUEST_NDIS_BUFFER(Request),(PVOID *)&NwlinkAction,&BufferLength,HighPagePriority);
    if (!NwlinkAction)
    {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Make sure we have enough room for just the header not
    // including the data.
    // (This will also include verification of buffer space for the TransportId) Bug# 171837
    //
    if (BufferLength < (UINT)(FIELD_OFFSET(NWLINK_ACTION, Data[0]))) {
        NB_DEBUG (QUERY, ("Nwlink action failed, buffer too small\n"));
        return STATUS_BUFFER_TOO_SMALL;
    }
    DataLength = BufferLength - FIELD_OFFSET(NWLINK_ACTION, Data[0]);


    if ((!RtlEqualMemory ((PVOID)(&NwlinkAction->Header.TransportId), "MISN", 4)) &&
        (!RtlEqualMemory ((PVOID)(&NwlinkAction->Header.TransportId), "MIPX", 4)) &&
        (!RtlEqualMemory ((PVOID)(&NwlinkAction->Header.TransportId), "XPIM", 4)) &&
        (!RtlEqualMemory ((PVOID)(&NwlinkAction->Header.TransportId), BogusId, 4))) {

        return STATUS_NOT_SUPPORTED;
    }



    //
    // Make sure that the correct file object is being used.
    //

    if (NwlinkAction->OptionType == NWLINK_OPTION_ADDRESS) {

        if (REQUEST_OPEN_TYPE(Request) != (PVOID)TDI_TRANSPORT_ADDRESS_FILE) {
            NB_DEBUG (QUERY, ("Nwlink action failed, not address file\n"));
            return STATUS_INVALID_HANDLE;
        }

        AddressFile = (PADDRESS_FILE)REQUEST_OPEN_CONTEXT(Request);

        if ((AddressFile->Size != sizeof (ADDRESS_FILE)) ||
            (AddressFile->Type != NB_ADDRESSFILE_SIGNATURE)) {

            NB_DEBUG (QUERY, ("Nwlink action failed, bad address file\n"));
            return STATUS_INVALID_HANDLE;
        }

    } else if (NwlinkAction->OptionType != NWLINK_OPTION_CONTROL) {

        NB_DEBUG (QUERY, ("Nwlink action failed, option type %d\n", NwlinkAction->OptionType));
        return STATUS_NOT_SUPPORTED;
    }


    //
    // Handle the requests based on the action code. For these
    // requests ActionHeader->ActionCode is 0, we use the
    // Option field in the streams header instead.
    //


    Status = STATUS_SUCCESS;

    switch (NwlinkAction->Option) {

    case (I_MIPX | 351):

        //
        // A request for details on every binding.
        //

        if (DataLength < sizeof(NB_ACTION_GET_COUNTS)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        u.GetCounts = (PNB_ACTION_GET_COUNTS)(NwlinkAction->Data);

        u.GetCounts->MaximumNicId = NbiDevice->MaximumNicId;

        for (i = 0; i < 32 ; i++) {
            u.GetCounts->NicIdCounts[i] = 0;
        }

        for (i = 0; i < CONNECTION_HASH_COUNT; i++) {

            NB_GET_LOCK (&Device->Lock, &LockHandle);

            Connection = Device->ConnectionHash[i].Connections;

            while (Connection != NULL) {
#if defined(_PNP_POWER)
                if ((Connection->State == CONNECTION_STATE_ACTIVE) &&
                    (Connection->LocalTarget.NicHandle.NicId < 32)) {

                    ++u.GetCounts->NicIdCounts[Connection->LocalTarget.NicHandle.NicId];
                }
#else
                if ((Connection->State == CONNECTION_STATE_ACTIVE) &&
                    (Connection->LocalTarget.NicId < 32)) {

                    ++u.GetCounts->NicIdCounts[Connection->LocalTarget.NicId];
                }
#endif _PNP_POWER
                Connection = Connection->NextConnection;
            }

            NB_FREE_LOCK (&Device->Lock, LockHandle);

        }

        break;

    //
    // The Option was not supported, so fail.
    //

    default:

        Status = STATUS_NOT_SUPPORTED;
        break;


    }   // end of the long switch on NwlinkAction->Option


#if DBG
    if (!NT_SUCCESS(Status)) {
        NB_DEBUG (QUERY, ("Nwlink action %lx failed, status %lx\n", NwlinkAction->Option, Status));
    }
#endif

    return Status;

}   /* NbiTdiAction */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\nb\address.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    address.c

Abstract:

    This module contains code which implements the ADDRESS object.
    Routines are provided to create, destroy, reference, and dereference,
    transport address objects.

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// Map all generic accesses to the same one.
//

static GENERIC_MAPPING AddressGenericMapping =
       { READ_CONTROL, READ_CONTROL, READ_CONTROL, READ_CONTROL };



TDI_ADDRESS_NETBIOS *
NbiParseTdiAddress(
    IN TRANSPORT_ADDRESS UNALIGNED  *TransportAddress,
    IN ULONG                        MaxBufferLength,
    IN BOOLEAN                      BroadcastAddressOk
    )

/*++

Routine Description:

    This routine scans a TRANSPORT_ADDRESS, looking for an address
    of type TDI_ADDRESS_TYPE_NETBIOS.

Arguments:

    Transport - The generic TDI address.

    BroadcastAddressOk - TRUE if we should return the broadcast
        address if found. If so, a value of (PVOID)-1 indicates
        the broadcast address.

Return Value:

    A pointer to the Netbios address, or NULL if none is found,
    or (PVOID)-1 if the broadcast address is found.

--*/

{
    TA_ADDRESS * addressName;
    INT     i;
    ULONG   LastBufferLength;

    //
    // At least 1 Netbios address should be present
    //
    if (MaxBufferLength < sizeof(TA_NETBIOS_ADDRESS))
    {
        return NULL;
    }

    addressName = &TransportAddress->Address[0];
    //
    // The name can be passed with multiple entries; we'll take and use only
    // the Netbios one.
    //
    LastBufferLength = FIELD_OFFSET(TRANSPORT_ADDRESS,Address);  // Just before Address[0]
    for (i=0;i<TransportAddress->TAAddressCount;i++)
    {
        if (addressName->AddressType == TDI_ADDRESS_TYPE_NETBIOS)
        {
            if ((addressName->AddressLength == 0) && BroadcastAddressOk)
            {
                return (PVOID)-1;
            }
            else if (addressName->AddressLength == sizeof(TDI_ADDRESS_NETBIOS))
            {
                return ((TDI_ADDRESS_NETBIOS *)(addressName->Address));
            }
        }

        //
        // Update LastBufferLength + check for space for at least one
        // Netbios address beyond this
        //
        LastBufferLength += FIELD_OFFSET(TA_ADDRESS,Address) + addressName->AddressLength;
        if (MaxBufferLength < (LastBufferLength +
                              (sizeof(TA_NETBIOS_ADDRESS)-FIELD_OFFSET(TRANSPORT_ADDRESS,Address))))
        {
            NbiPrint0 ("NbiParseTdiAddress: No valid Netbios address to register!\n");
            return (NULL);
        }

        addressName = (TA_ADDRESS *)(addressName->Address + addressName->AddressLength);
    }

    return NULL;
}   /* NbiParseTdiAddress */


BOOLEAN
NbiValidateTdiAddress(
    IN TRANSPORT_ADDRESS UNALIGNED * TransportAddress,
    IN ULONG TransportAddressLength
    )

/*++

Routine Description:

    This routine scans a TRANSPORT_ADDRESS, verifying that the
    components of the address do not extend past the specified
    length.

Arguments:

    TransportAddress - The generic TDI address.

    TransportAddressLength - The specific length of TransportAddress.

Return Value:

    TRUE if the address is valid, FALSE otherwise.

--*/

{
    PUCHAR AddressEnd = ((PUCHAR)TransportAddress) + TransportAddressLength;
    TA_ADDRESS * addressName;
    INT i;

    if (TransportAddressLength < sizeof(TransportAddress->TAAddressCount)) {
        NbiPrint0 ("NbfValidateTdiAddress: runt address\n");
        return FALSE;
    }

    addressName = &TransportAddress->Address[0];

    for (i=0;i<TransportAddress->TAAddressCount;i++) {
        if (addressName->Address > AddressEnd) {
            NbiPrint0 ("NbiValidateTdiAddress: address too short\n");
            return FALSE;
        }
        addressName = (TA_ADDRESS *)(addressName->Address +
                                                addressName->AddressLength);
    }

    if ((PUCHAR)addressName > AddressEnd) {
        NbiPrint0 ("NbiValidateTdiAddress: address too short\n");
        return FALSE;
    }
    return TRUE;

}   /* NbiValidateTdiAddress */


NTSTATUS
NbiOpenAddress(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine opens a file that points to an existing address object, or, if
    the object doesn't exist, creates it (note that creation of the address
    object includes registering the address, and may take many seconds to
    complete, depending upon system configuration).

    If the address already exists, and it has an ACL associated with it, the
    ACL is checked for access rights before allowing creation of the address.

Arguments:

    Device - pointer to the device describing the Netbios transport.

    Request - a pointer to the request used for the creation of the address.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS status;
    PADDRESS Address;
    PADDRESS_FILE AddressFile;
    PFILE_FULL_EA_INFORMATION ea;
    TRANSPORT_ADDRESS UNALIGNED *name;
    TDI_ADDRESS_NETBIOS * NetbiosAddress;
    ULONG DesiredShareAccess;
    CTELockHandle LockHandle;
    PACCESS_STATE AccessState;
    ACCESS_MASK GrantedAccess;
    BOOLEAN AccessAllowed;
    BOOLEAN found = FALSE;
    ULONG   AddressLength = 0;
#ifdef ISN_NT
    PIRP Irp = (PIRP)Request;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
#endif
#if 0
    TA_NETBIOS_ADDRESS FakeAddress;
#endif


    //
    // The network name is in the EA, passed in the request.
    //

    ea = OPEN_REQUEST_EA_INFORMATION(Request);
    if (ea == NULL) {
        NbiPrint1("OpenAddress: REQUEST %lx has no EA\n", Request);
        return STATUS_INVALID_ADDRESS_COMPONENT;
    }

    //
    // this may be a valid name; parse the name from the EA and use it if OK.
    //

    name = (PTRANSPORT_ADDRESS)&ea->EaName[ea->EaNameLength+1];
    AddressLength = (ULONG) ea->EaValueLength;
#if 0
    TdiBuildNetbiosAddress(
        "ADAMBA67        ",
        FALSE,
        &FakeAddress);
    name = (PTRANSPORT_ADDRESS)&FakeAddress;
#endif

    //
    // The name can be passed with multiple entries; we'll take and use only
    // the first one of type Netbios. This call returns (PVOID)-1 if the
    // address is the broadcast address.
    //

    NetbiosAddress = NbiParseTdiAddress (name, AddressLength, TRUE);

    if (NetbiosAddress == NULL) {
        NbiPrint1("OpenAddress: REQUEST %lx has no Netbios Address\n", Request);
        return STATUS_INVALID_ADDRESS_COMPONENT;
    }

    //
    // get an address file structure to represent this address.
    //

    AddressFile = NbiCreateAddressFile (Device);

    if (AddressFile == (PADDRESS_FILE)NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // See if this address is already established.  This call automatically
    // increments the reference count on the address so that it won't disappear
    // from underneath us after this call but before we have a chance to use it.
    //
    // To ensure that we don't create two address objects for the
    // same address, we hold the device context addressResource until
    // we have found the address or created a new one.
    //

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite (&Device->AddressResource, TRUE);

    Address = NbiFindAddress(Device, (NetbiosAddress == (PVOID)-1 ) ? (PVOID)-1:NetbiosAddress->NetbiosName);
    if (Address == NULL) {

        //
        // This address doesn't exist. Create it.
        // This initializes the address with a ref
        // of type ADDRESS_FILE, so if we fail here
        // we need to remove that.
        //
        if (NT_SUCCESS (status = NbiCreateAddress (Request, AddressFile, IrpSp, Device, NetbiosAddress, &Address))) {

            ExReleaseResourceLite (&Device->AddressResource);
            KeLeaveCriticalRegion();

            ASSERT (Address);
            if (status == STATUS_PENDING) {
                NbiStartRegistration (Address);
            }

            NbiDereferenceAddress (Address, AREF_ADDRESS_FILE); // We had 1 extra ref in NbiCreateAddress
        } else {

            ExReleaseResourceLite (&Device->AddressResource);
            KeLeaveCriticalRegion();

            //
            // If the address could not be created, and is not in the
            // process of being created, then we can't open up an address.
            // Since we can't use the AddressLock to deref, we just destroy
            // the address file.
            //

            NbiDestroyAddressFile (AddressFile);
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        NB_DEBUG2 (ADDRESS, ("Add to address %lx\n", Address));

        //
        // Set this now in case we have to deref.
        //

        AddressFile->AddressLock = &Address->Lock;

        //
        // Make sure the types do not conflict.
        //

        if ((NetbiosAddress != (PVOID)-1) &&
                (NetbiosAddress->NetbiosNameType != Address->NetbiosAddress.NetbiosNameType)) {

            NB_DEBUG (ADDRESS, ("Address types conflict %lx\n", Address));
            ExReleaseResourceLite (&Device->AddressResource);
            KeLeaveCriticalRegion();
            NbiDereferenceAddressFile (AddressFile, AFREF_CREATE);
            status = STATUS_DUPLICATE_NAME;

        } else {

            //
            // The address already exists.  Check the ACL and see if we
            // can access it.  If so, simply use this address as our address.
            //

            AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;

            AccessAllowed = SeAccessCheck(
                                Address->SecurityDescriptor,
                                &AccessState->SubjectSecurityContext,
                                FALSE,                   // tokens locked
                                IrpSp->Parameters.Create.SecurityContext->DesiredAccess,
                                (ACCESS_MASK)0,             // previously granted
                                NULL,                    // privileges
                                &AddressGenericMapping,
                                (KPROCESSOR_MODE)((IrpSp->Flags&SL_FORCE_ACCESS_CHECK) ? UserMode : Irp->RequestorMode),
                                &GrantedAccess,
                                &status);

            if (!AccessAllowed) {

                NB_DEBUG (ADDRESS, ("Address access not allowed %lx\n", Address));
                ExReleaseResourceLite (&Device->AddressResource);
                KeLeaveCriticalRegion();
                NbiDereferenceAddressFile (AddressFile, AFREF_CREATE);

            } else {

                //
                // Now check that we can obtain the desired share
                // access. We use read access to control all access.
                //

                DesiredShareAccess = (ULONG)
                    (((IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ) ||
                      (IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE)) ?
                            FILE_SHARE_READ : 0);

                status = IoCheckShareAccess(
                             FILE_READ_DATA,
                             DesiredShareAccess,
                             IrpSp->FileObject,
                             &Address->u.ShareAccess,
                             TRUE);


                if (!NT_SUCCESS (status)) {

                    NB_DEBUG (ADDRESS, ("Address share access wrong %lx\n", Address));
                    ExReleaseResourceLite (&Device->AddressResource);
                    KeLeaveCriticalRegion();
                    NbiDereferenceAddressFile (AddressFile, AFREF_CREATE);

                } else {

                    ExReleaseResourceLite (&Device->AddressResource);
                    KeLeaveCriticalRegion();

                    NB_GET_LOCK (&Address->Lock, &LockHandle);

                    //
                    // Insert the address file on the address
                    // list; we will pend this open if the address
                    // is still registering. If the address has
                    // already failed as duplicate, then we
                    // fail the open.
                    //

                    if (Address->Flags & ADDRESS_FLAGS_DUPLICATE_NAME) {

                        NB_DEBUG (ADDRESS, ("Address duplicated %lx\n", Address));
                        NB_FREE_LOCK (&Address->Lock, LockHandle);

                        NbiDereferenceAddressFile (AddressFile, AFREF_CREATE);
                        status = STATUS_DUPLICATE_NAME;

                    } else {

                        InsertTailList (
                            &Address->AddressFileDatabase,
                            &AddressFile->Linkage);

                        //
                        // Start registration unless it is registered or
                        // it is the broadcast address.
                        //

                        if ((Address->State == ADDRESS_STATE_REGISTERING) &&
                            (NetbiosAddress != (PVOID)-1)) {

                            AddressFile->OpenRequest = Request;
                            AddressFile->State = ADDRESSFILE_STATE_OPENING;
                            status = STATUS_PENDING;

                        } else {

                            AddressFile->OpenRequest = NULL;
                            AddressFile->State = ADDRESSFILE_STATE_OPEN;
                            status = STATUS_SUCCESS;
                        }

                        AddressFile->Address = Address;
#ifdef ISN_NT
                        AddressFile->FileObject = IrpSp->FileObject;
#endif

                        NbiReferenceAddress (Address, AREF_ADDRESS_FILE);

                        REQUEST_OPEN_CONTEXT(Request) = (PVOID)AddressFile;
                        REQUEST_OPEN_TYPE(Request) = (PVOID)TDI_TRANSPORT_ADDRESS_FILE;

                        NB_FREE_LOCK (&Address->Lock, LockHandle);

                    }

                }
            }
        }

        //
        // Remove the reference from NbiLookupAddress.
        //

        NbiDereferenceAddress (Address, AREF_LOOKUP);
    }

    return status;

}   /* NbiOpenAddress */


VOID
NbiStartRegistration(
    IN PADDRESS Address
    )

/*++

Routine Description:

    This routine starts the registration process for a netbios name
    by sending out the first add name packet and starting the timer
    so that NbiRegistrationTimeout is called after the correct timeout.

Arguments:

    Address - The address which is to be registered.

Return Value:

    NTSTATUS - status of operation.

--*/

{

    NB_DEBUG2 (ADDRESS, ("StartRegistration of %lx\n", Address));

    //
    // First send out an add name packet.
    //

    NbiSendNameFrame(
        Address,
        (UCHAR)(Address->NameTypeFlag | NB_NAME_USED),
        NB_CMD_ADD_NAME,
        NULL,
        NULL);

    Address->RegistrationCount = 0;

    //
    // Now start the timer.
    //

    NbiReferenceAddress (Address, AREF_TIMER);

    CTEInitTimer (&Address->RegistrationTimer);
    CTEStartTimer(
        &Address->RegistrationTimer,
        Address->Device->BroadcastTimeout,
        NbiRegistrationTimeout,
        (PVOID)Address);

}   /* NbiStartRegistration */


VOID
NbiRegistrationTimeout(
    IN CTEEvent * Event,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called when the address registration
    timer expires. It sends another add name if needed, or
    checks the result if the correct number have been sent.

Arguments:

    Event - The event used to queue the timer.

    Context - The context, which is the address pointer.

Return Value:

    None.

--*/

{
    PADDRESS Address = (PADDRESS)Context;
    CTELockHandle LockHandle;
    PADDRESS_FILE AddressFile, ReferencedAddressFile;
    PLIST_ENTRY p;

    ++Address->RegistrationCount;

    if ((Address->RegistrationCount < Address->Device->BroadcastCount) &&
        ((Address->Flags & ADDRESS_FLAGS_DUPLICATE_NAME) == 0)) {

        NB_DEBUG2 (ADDRESS, ("Send add name %d for %lx\n", Address->RegistrationCount+1, Address));

        NbiSendNameFrame(
            Address,
            (UCHAR)(Address->NameTypeFlag | NB_NAME_USED),
            NB_CMD_ADD_NAME,
            NULL,
            NULL);

        CTEStartTimer(
            &Address->RegistrationTimer,
            Address->Device->BroadcastTimeout,
            NbiRegistrationTimeout,
            (PVOID)Address);

    } else {

        //
        // The correct number of frames have been sent, see what
        // happened.
        //

        NB_DEBUG2 (ADDRESS, ("Done with add names for %lx\n", Address));

        ReferencedAddressFile = NULL;

        NB_GET_LOCK (&Address->Lock, &LockHandle);

        for (p = Address->AddressFileDatabase.Flink;
             p != &Address->AddressFileDatabase;
             p = p->Flink) {

            AddressFile = CONTAINING_RECORD (p, ADDRESS_FILE, Linkage);
            CTEAssert (AddressFile->State == ADDRESSFILE_STATE_OPENING);
            CTEAssert (AddressFile->OpenRequest != NULL);

            NbiReferenceAddressFileLock (AddressFile, AFREF_TIMEOUT);

            NB_FREE_LOCK (&Address->Lock, LockHandle);

            if (ReferencedAddressFile) {
                NbiDereferenceAddressFile (ReferencedAddressFile, AFREF_TIMEOUT);
            }

            //
            // Now see what to do with this address file.
            //

            REQUEST_INFORMATION(AddressFile->OpenRequest) = 0;

            if (Address->Flags & ADDRESS_FLAGS_DUPLICATE_NAME) {

                NB_DEBUG (ADDRESS, ("Open of address file %lx failed, duplicate\n", AddressFile));
                REQUEST_STATUS(AddressFile->OpenRequest) = STATUS_DUPLICATE_NAME;
                NbiDereferenceAddressFile (AddressFile, AFREF_CREATE);

            } else {

                NB_DEBUG2 (ADDRESS, ("Complete open of address file %lx\n", AddressFile));
                REQUEST_STATUS(AddressFile->OpenRequest) = STATUS_SUCCESS;
                AddressFile->State = ADDRESSFILE_STATE_OPEN;

            }

            NbiCompleteRequest (AddressFile->OpenRequest);
            NbiFreeRequest (Address->Device, AddressFile->OpenRequest);

            NB_GET_LOCK (&Address->Lock, &LockHandle);

            ReferencedAddressFile = AddressFile;

        }

        //
        // Set the Address Flag here since in the loop above, we are constantly
        // releasing and reacquiring the lock -- hence we could have a new
        // client added to this address, but there there would be no OpenRequest
        // value since he would think that the registration process had already completed.
        //
        if ((Address->Flags & ADDRESS_FLAGS_DUPLICATE_NAME) == 0) {
            Address->State = ADDRESS_STATE_OPEN;
        } else {
            Address->State = ADDRESS_STATE_STOPPING;
        }

        NB_FREE_LOCK (&Address->Lock, LockHandle);

        if (ReferencedAddressFile) {
            NbiDereferenceAddressFile (ReferencedAddressFile, AFREF_TIMEOUT);
        }

        NbiDereferenceAddress (Address, AREF_TIMER);

    }

}   /* NbiRegistrationTimeout */


VOID
NbiProcessFindName(
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR PacketBuffer,
    IN UINT PacketSize
    )

/*++

Routine Description:

    This routine handles NB_CMD_FIND_NAME frames.

Arguments:

    RemoteAddress - The local target this packet was received from.

    MacOptions - The MAC options for the underlying NDIS binding.

    LookaheadBuffer - The packet data, starting at the IPX
        header.

    PacketSize - The total length of the packet, starting at the
        IPX header.

Return Value:

    None.

--*/

{
    PADDRESS Address;
    NB_CONNECTIONLESS UNALIGNED * NbConnectionless =
                        (NB_CONNECTIONLESS UNALIGNED *)PacketBuffer;
    PDEVICE Device = NbiDevice;

    if (PacketSize != sizeof(IPX_HEADER) + sizeof(NB_NAME_FRAME)) {
        return;
    }

    //
    // Quick check for any names starting with this character.
    //

    if (Device->AddressCounts[NbConnectionless->NameFrame.Name[0]] == 0) {
        return;
    }

    //
    // Always respond to broadcast requests.
    //
#if defined(_PNP_POWER)
    if (RtlEqualMemory (NetbiosBroadcastName, NbConnectionless->NameFrame.Name, 16)) {

        NbiSendNameFrame(
            NULL,
            NB_NAME_DUPLICATED,     // this is what Novell machines use
            NB_CMD_NAME_RECOGNIZED,
            RemoteAddress,
            NbConnectionless);

    } else if (Address = NbiFindAddress(Device, (PUCHAR)NbConnectionless->NameFrame.Name)) {

        NbiSendNameFrame(
            Address,
            (UCHAR)(Address->NameTypeFlag | NB_NAME_USED | NB_NAME_REGISTERED),
            NB_CMD_NAME_RECOGNIZED,
            RemoteAddress,
            NbConnectionless);

        NbiDereferenceAddress (Address, AREF_FIND);

    } else if ( NbiFindAdapterAddress( NbConnectionless->NameFrame.Name, LOCK_NOT_ACQUIRED ) ) {

        NbiSendNameFrame(
            NULL,
            (UCHAR)(NB_NAME_UNIQUE | NB_NAME_USED | NB_NAME_REGISTERED),
            NB_CMD_NAME_RECOGNIZED,
            RemoteAddress,
            NbConnectionless);
    }
#else
    if (RtlEqualMemory (NetbiosBroadcastName, NbConnectionless->NameFrame.Name, 16)) {

        NbiSendNameFrame(
            NULL,
            NB_NAME_DUPLICATED,     // this is what Novell machines use
            NB_CMD_NAME_RECOGNIZED,
            RemoteAddress,
            (PTDI_ADDRESS_IPX)(NbConnectionless->IpxHeader.SourceNetwork));

    } else if (Address = NbiFindAddress(Device, (PUCHAR)NbConnectionless->NameFrame.Name)) {

        NbiSendNameFrame(
            Address,
            (UCHAR)(Address->NameTypeFlag | NB_NAME_USED | NB_NAME_REGISTERED),
            NB_CMD_NAME_RECOGNIZED,
            RemoteAddress,
            (PTDI_ADDRESS_IPX)(NbConnectionless->IpxHeader.SourceNetwork));

        NbiDereferenceAddress (Address, AREF_FIND);

    }
#endif  _PNP_POWER
}   /* NbiProcessFindName */


VOID
NbiProcessAddName(
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR PacketBuffer,
    IN UINT PacketSize
    )

/*++

Routine Description:

    This routine handles NB_CMD_ADD_NAME frames.

Arguments:

    RemoteAddress - The local target this packet was received from.

    MacOptions - The MAC options for the underlying NDIS binding.

    LookaheadBuffer - The packet data, starting at the IPX
        header.

    PacketSize - The total length of the packet, starting at the
        IPX header.

Return Value:

    None.

--*/

{
    PADDRESS Address;
    NB_CONNECTIONLESS UNALIGNED * NbConnectionless =
                        (NB_CONNECTIONLESS UNALIGNED *)PacketBuffer;
    PDEVICE Device = NbiDevice;
    CTELockHandle LockHandle;
    BOOLEAN LocalFrame;


    if (PacketSize != sizeof(IPX_HEADER) + sizeof(NB_NAME_FRAME)) {
        return;
    }

    //
    // Ignore any frame that came from us, except for the purpose
    // of updating the cache.
    //

    if ((Device->Bind.QueryHandler)(
            IPX_QUERY_IS_ADDRESS_LOCAL,
#if     defined(_PNP_POWER)
            &RemoteAddress->NicHandle,
#else
            RemoteAddress->NicId,
#endif  _PNP_POWER
            NbConnectionless->IpxHeader.SourceNetwork,
            sizeof(TDI_ADDRESS_IPX),
            NULL) == STATUS_SUCCESS) {

        LocalFrame = TRUE;

    } else {

        LocalFrame = FALSE;

    }

    if (!LocalFrame) {

        if ((Device->AddressCounts[NbConnectionless->NameFrame.Name[0]] != 0) &&
            (Address = NbiFindAddress(Device, (PUCHAR)NbConnectionless->NameFrame.Name))) {

            if (NB_NODE_BROADCAST(NbConnectionless->IpxHeader.DestinationNode)) {

                //
                // If this frame is an add name (identified because it is a
                // broadcast frame) then respond if we have it registered
                // unique, or we have it group and someone is trying to add
                // it unique.
                //

                if ((Address->NetbiosAddress.NetbiosNameType == TDI_ADDRESS_NETBIOS_TYPE_UNIQUE) ||
                    ((Address->NetbiosAddress.NetbiosNameType == TDI_ADDRESS_NETBIOS_TYPE_GROUP) &&
                     ((NbConnectionless->NameFrame.NameTypeFlag & NB_NAME_GROUP) == 0))) {

                    //
                    // According to GeorgeJ's doc, on a name in use we just
                    // echo back the name type flags from the request.
                    //

                    NbiSendNameFrame(
                        Address,
                        NbConnectionless->NameFrame.NameTypeFlag,
                        NB_CMD_NAME_IN_USE,
                        RemoteAddress,
#if     defined(_PNP_POWER)
                        NbConnectionless);
#else
                        (PTDI_ADDRESS_IPX)(NbConnectionless->IpxHeader.SourceNetwork));
#endif  _PNP_POWER
                }

            } else if ((*(UNALIGNED ULONG *)NbConnectionless->IpxHeader.DestinationNetwork ==
                            *(UNALIGNED ULONG *)Device->Bind.Network) &&
                        NB_NODE_EQUAL(NbConnectionless->IpxHeader.DestinationNode, Device->Bind.Node)) {

                //
                // If this is an add name response (which will be sent
                // directly to us) then we need to mark the address
                // as such.
                //

                NB_GET_LOCK (&Address->Lock, &LockHandle);
                Address->Flags |= ADDRESS_FLAGS_DUPLICATE_NAME;
                NB_FREE_LOCK (&Address->Lock, LockHandle);
            }

            NbiDereferenceAddress (Address, AREF_FIND);

        }

    }


    //
    // Pass this frame over to the netbios cache management
    // routines to check if they need to update their cache.
    //

    CacheUpdateFromAddName (RemoteAddress, NbConnectionless, LocalFrame);

}   /* NbiProcessAddName */

NTSTATUS
SetAddressSecurityInfo(
    IN PADDRESS             Address,
    IN PIO_STACK_LOCATION   IrpSp
    )
{
    ULONG           DesiredShareAccess;
    PACCESS_STATE   AccessState;
    NTSTATUS        status;

    //
    // Initialize the shared access now. We use read access
    // to control all access.
    //
    DesiredShareAccess = (ULONG) (((IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ) ||
                                  (IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE)) ?
                                  FILE_SHARE_READ : 0);

    IoSetShareAccess(FILE_READ_DATA, DesiredShareAccess, IrpSp->FileObject, &Address->u.ShareAccess);

    //
    // Assign the security descriptor (need to do this with
    // the spinlock released because the descriptor is not
    // mapped).
    //
    AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;
    status = SeAssignSecurity(
                 NULL,                       // parent descriptor
                 AccessState->SecurityDescriptor,
                 &Address->SecurityDescriptor,
                 FALSE,                      // is directory
                 &AccessState->SubjectSecurityContext,
                 &AddressGenericMapping,
                 NonPagedPool);

    if (!NT_SUCCESS (status)) {
        IoRemoveShareAccess (IrpSp->FileObject, &Address->u.ShareAccess);
    }

    return status;
}



NTSTATUS
NbiCreateAddress(
    IN  PREQUEST                        Request,
    IN  PADDRESS_FILE                   AddressFile,
    IN  PIO_STACK_LOCATION              IrpSp,
    IN  PDEVICE                         Device,
    IN  TDI_ADDRESS_NETBIOS             *NetbiosAddress,
    OUT PADDRESS                        *pAddress
    )

/*++

Routine Description:

    This routine creates a transport address and associates it with
    the specified transport device context.  The reference count in the
    address is initialized to 2, and the reference count of the
    device context is incremented.

Arguments:

    Device - Pointer to the device context (which is really just
        the device object with its extension) to be associated with the
        address.

    NetbiosAddress - The name to assign to this address, or -1 if it
        is the broadcast address.

Return Value:

    The newly created address, or NULL if none can be allocated.

--*/

{
    PADDRESS Address;
    CTELockHandle LockHandle;
    NTSTATUS status;

    //
    // if the adapter isn't ready, we can't do any of this; get out
    //
    if (Device->State != DEVICE_STATE_OPEN) {
        return STATUS_DEVICE_NOT_READY;
    }

    if (!(Address = (PADDRESS)NbiAllocateMemory (sizeof(ADDRESS), MEMORY_ADDRESS, "Address"))) {
        NB_DEBUG (ADDRESS, ("Create address %.16s failed\n",
            (NetbiosAddress == (PVOID)-1) ? "<broadcast>" : NetbiosAddress->NetbiosName));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NB_DEBUG2 (ADDRESS, ("Create address %lx (%.16s)\n", Address,
            (NetbiosAddress == (PVOID)-1) ? "<broadcast>" : NetbiosAddress->NetbiosName));
    RtlZeroMemory (Address, sizeof(ADDRESS));

    if (!NT_SUCCESS (status = SetAddressSecurityInfo(Address, IrpSp))) {
        //
        // Error, return status.
        //
        NbiFreeMemory (Address, sizeof(ADDRESS), MEMORY_ADDRESS, "Address");
        return status;
    }

    Address->Type = NB_ADDRESS_SIGNATURE;
    Address->Size = sizeof (ADDRESS);
    Address->State = ADDRESS_STATE_REGISTERING;
    Address->Flags = 0;

    Address->Device = Device;
    Address->DeviceLock = &Device->Lock;
    CTEInitLock (&Address->Lock.Lock);

    InitializeListHead (&Address->AddressFileDatabase);

    Address->ReferenceCount = 2;        // Initialize it to 2 -- it will be Deref'ed by the caller
#if DBG
    Address->RefTypes[AREF_ADDRESS_FILE] = 1;
#endif

    if (NetbiosAddress == (PVOID)-1) {
        Address->NetbiosAddress.Broadcast = TRUE;
    } else {
        Address->NetbiosAddress.Broadcast = FALSE;
        Address->NetbiosAddress.NetbiosNameType = NetbiosAddress->NetbiosNameType;
        RtlCopyMemory (Address->NetbiosAddress.NetbiosName, NetbiosAddress->NetbiosName, 16);
        ++Device->AddressCounts[NetbiosAddress->NetbiosName[0]];
    }

    if (Address->NetbiosAddress.NetbiosNameType == TDI_ADDRESS_NETBIOS_TYPE_UNIQUE) {
        Address->NameTypeFlag = NB_NAME_UNIQUE;
    } else {
        Address->NameTypeFlag = NB_NAME_GROUP;
    }

    //
    // Set this now in case we have to deref.
    //
    AddressFile->AddressLock = &Address->Lock;

    REQUEST_OPEN_CONTEXT(Request) = (PVOID)AddressFile;
    REQUEST_OPEN_TYPE(Request) = (PVOID)TDI_TRANSPORT_ADDRESS_FILE;
    AddressFile->FileObject = IrpSp->FileObject;
    AddressFile->Address = Address;

    NB_INSERT_TAIL_LIST (&Address->AddressFileDatabase, &AddressFile->Linkage, &Address->Lock);

    if (NetbiosAddress == (PVOID)-1) {
        AddressFile->OpenRequest = NULL;
        AddressFile->State = ADDRESSFILE_STATE_OPEN;
        status = STATUS_SUCCESS;
    } else {
        AddressFile->OpenRequest = Request;
        AddressFile->State = ADDRESSFILE_STATE_OPENING;
        status = STATUS_PENDING;
    }

    //
    // Now link this address into the specified device context's
    // address database.  To do this, we need to acquire the spin lock
    // on the device context.
    //
    NB_GET_LOCK (&Device->Lock, &LockHandle);

    InsertTailList (&Device->AddressDatabase, &Address->Linkage);
    ++Device->AddressCount;

    NB_FREE_LOCK (&Device->Lock, LockHandle);

    NbiReferenceDevice (Device, DREF_ADDRESS);

    *pAddress = Address;
    return status;
}   /* NbiCreateAddress */


NTSTATUS
NbiVerifyAddressFile (
#if     defined(_PNP_POWER)
    IN PADDRESS_FILE AddressFile,
    IN BOOLEAN       ConflictIsOk
#else
    IN PADDRESS_FILE AddressFile
#endif  _PNP_POWER
    )

/*++

Routine Description:

    This routine is called to verify that the pointer given us in a file
    object is in fact a valid address file object. We also verify that the
    address object pointed to by it is a valid address object, and reference
    it to keep it from disappearing while we use it.

Arguments:

    AddressFile - potential pointer to a ADDRESS_FILE object

    ConflictIsOk -  TRUE if we should succeed the verify even if the
                    corresponding address is in CONFLICT. ( For Close and
                    cleanup we return STATUS_SUCCESS even if we are in conflict
                    so that the addressfile can be destroyed)

Return Value:

    STATUS_SUCCESS if all is well; STATUS_INVALID_ADDRESS otherwise

--*/

{
    CTELockHandle LockHandle;
    NTSTATUS status = STATUS_SUCCESS;
    PADDRESS Address;
    BOOLEAN LockHeld = FALSE;

    //
    // try to verify the address file signature. If the signature is valid,
    // verify the address pointed to by it and get the address spinlock.
    // check the address's state, and increment the reference count if it's
    // ok to use it. Note that the only time we return an error for state is
    // if the address is closing.
    //

    try {

        if ((AddressFile->Size == sizeof (ADDRESS_FILE)) &&
            (AddressFile->Type == NB_ADDRESSFILE_SIGNATURE) ) {
//            (AddressFile->State != ADDRESSFILE_STATE_CLOSING) ) {

            Address = AddressFile->Address;

            if ((Address->Size == sizeof (ADDRESS)) &&
                (Address->Type == NB_ADDRESS_SIGNATURE)    ) {

                NB_GET_LOCK (&Address->Lock, &LockHandle);

                LockHeld = TRUE;

#if     defined(_PNP_POWER)
                if (Address->State != ADDRESS_STATE_STOPPING &&
                    ( ConflictIsOk || ( !(Address->Flags & ADDRESS_FLAGS_CONFLICT) )) ) {
#else
                    if (Address->State != ADDRESS_STATE_STOPPING) {
#endif  _PNP_POWER

                    NbiReferenceAddressFileLock (AddressFile, AFREF_VERIFY);

                } else {

                    NbiPrint1("NbiVerifyAddressFile: A %lx closing\n", Address);
                    status = STATUS_INVALID_ADDRESS;
                }

                NB_FREE_LOCK (&Address->Lock, LockHandle);

            } else {

                NbiPrint1("NbiVerifyAddressFile: A %lx bad signature\n", Address);
                status = STATUS_INVALID_ADDRESS;
            }

        } else {

            NbiPrint1("NbiVerifyAddressFile: AF %lx bad signature\n", AddressFile);
            status = STATUS_INVALID_ADDRESS;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

         NbiPrint1("NbiVerifyAddressFile: AF %lx exception\n", Address);
         if (LockHeld) {
            NB_FREE_LOCK (&Address->Lock, LockHandle);
         }
         return GetExceptionCode();
    }

    return status;

}   /* NbiVerifyAddressFile */


VOID
NbiDestroyAddress(
    IN PVOID Parameter
    )

/*++

Routine Description:

    This routine destroys a transport address and removes all references
    made by it to other objects in the transport.  The address structure
    is returned to nonpaged system pool. It is assumed
    that the caller has already removed all addressfile structures associated
    with this address.

    It is called from a worker thread queue by NbiDerefAddress when
    the reference count goes to 0.

    This thread is only queued by NbiDerefAddress.  The reason for
    this is that there may be multiple streams of execution which are
    simultaneously referencing the same address object, and it should
    not be deleted out from under an interested stream of execution.

Arguments:

    Address - Pointer to a transport address structure to be destroyed.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PADDRESS Address = (PADDRESS)Parameter;
    PDEVICE Device = Address->Device;
    CTELockHandle LockHandle;

    NB_DEBUG2 (ADDRESS, ("Destroy address %lx <%.16s>\n", Address,
        Address->NetbiosAddress.Broadcast ? "<broadcast>" : Address->NetbiosAddress.NetbiosName));

    SeDeassignSecurity (&Address->SecurityDescriptor);

    //
    // Delink this address from its associated device context's address
    // database.  To do this we must spin lock on the device context object,
    // not on the address.
    //

    NB_GET_LOCK (&Device->Lock, &LockHandle);

    if (!Address->NetbiosAddress.Broadcast) {
        --Device->AddressCounts[Address->NetbiosAddress.NetbiosName[0]];
    }
    --Device->AddressCount;
    RemoveEntryList (&Address->Linkage);
    NB_FREE_LOCK (&Device->Lock, LockHandle);

    NbiFreeMemory (Address, sizeof(ADDRESS), MEMORY_ADDRESS, "Address");

    NbiDereferenceDevice (Device, DREF_ADDRESS);

}   /* NbiDestroyAddress */


#if DBG
VOID
NbiRefAddress(
    IN PADDRESS Address
    )

/*++

Routine Description:

    This routine increments the reference count on a transport address.

Arguments:

    Address - Pointer to a transport address object.

Return Value:

    none.

--*/

{

    CTEAssert (Address->ReferenceCount > 0);    // not perfect, but...

    InterlockedIncrement( &Address->ReferenceCount );
}   /* NbiRefAddress */


VOID
NbiRefAddressLock(
    IN PADDRESS Address
    )

/*++

Routine Description:

    This routine increments the reference count on a transport address
    when the device lock is already held.

Arguments:

    Address - Pointer to a transport address object.

Return Value:

    none.

--*/

{

    CTEAssert (Address->ReferenceCount > 0);    // not perfect, but...

    InterlockedIncrement( &Address->ReferenceCount );

}   /* NbiRefAddressLock */
#endif


VOID
NbiDerefAddress(
    IN PADDRESS Address
    )

/*++

Routine Description:

    This routine dereferences a transport address by decrementing the
    reference count contained in the structure.  If, after being
    decremented, the reference count is zero, then this routine calls
    NbiDestroyAddress to remove it from the system.

Arguments:

    Address - Pointer to a transport address object.

Return Value:

    none.

--*/

{
    ULONG newvalue;

    newvalue = InterlockedDecrement( &Address->ReferenceCount );
    //
    // If we have deleted all references to this address, then we can
    // destroy the object.  It is okay to have already released the spin
    // lock at this point because there is no possible way that another
    // stream of execution has access to the address any longer.
    //

    CTEAssert ((LONG)newvalue >= 0);

    if (newvalue == 0) {

#if ISN_NT
        ExInitializeWorkItem(
            &Address->u.DestroyAddressQueueItem,
            NbiDestroyAddress,
            (PVOID)Address);
        ExQueueWorkItem(&Address->u.DestroyAddressQueueItem, DelayedWorkQueue);
#else
        NbiDestroyAddress(Address);
#endif

    }

}   /* NbiDerefAddress */


PADDRESS_FILE
NbiCreateAddressFile(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine creates an address file from the pool of ther
    specified device context. The reference count in the
    address is automatically set to 1.

Arguments:

    Device - Pointer to the device context (which is really just
        the device object with its extension) to be associated with the
        address.

Return Value:

    The allocate address file or NULL.

--*/

{
    CTELockHandle LockHandle;
    PADDRESS_FILE AddressFile;
    UINT i;

    NB_GET_LOCK (&Device->Lock, &LockHandle);

    AddressFile = (PADDRESS_FILE)NbiAllocateMemory (sizeof(ADDRESS_FILE), MEMORY_ADDRESS, "AddressFile");
    if (AddressFile == NULL) {
        NB_DEBUG (ADDRESS, ("Create address file failed\n"));
        NB_FREE_LOCK (&Device->Lock, LockHandle);
        return NULL;
    }

    NB_DEBUG2 (ADDRESS, ("Create address file %lx\n", AddressFile));

    RtlZeroMemory (AddressFile, sizeof(ADDRESS_FILE));

    AddressFile->Type = NB_ADDRESSFILE_SIGNATURE;
    AddressFile->Size = sizeof (ADDRESS_FILE);

    InitializeListHead (&AddressFile->ReceiveDatagramQueue);
    InitializeListHead (&AddressFile->ConnectionDatabase);

    NB_FREE_LOCK (&Device->Lock, LockHandle);

    AddressFile->Address = NULL;
#ifdef ISN_NT
    AddressFile->FileObject = NULL;
#endif
    AddressFile->Device = Device;
    AddressFile->State = ADDRESSFILE_STATE_OPENING;
    AddressFile->ReferenceCount = 1;
#if DBG
    AddressFile->RefTypes[AFREF_CREATE] = 1;
#endif
    AddressFile->CloseRequest = (PREQUEST)NULL;

    //
    // Initialize the request handlers.
    //

    for (i = 0; i < 6; i++) {
        AddressFile->RegisteredHandler[i] = FALSE;
        AddressFile->HandlerContexts[i] = NULL;
        AddressFile->Handlers[i] = TdiDefaultHandlers[i];
    }

    CTEAssert (AddressFile->ConnectionHandler == TdiDefaultConnectHandler);
    CTEAssert (AddressFile->DisconnectHandler == TdiDefaultDisconnectHandler);
    CTEAssert (AddressFile->ErrorHandler == TdiDefaultErrorHandler);
    CTEAssert (AddressFile->ReceiveHandler == TdiDefaultReceiveHandler);
    CTEAssert (AddressFile->ReceiveDatagramHandler == TdiDefaultRcvDatagramHandler);
    CTEAssert (AddressFile->ExpeditedDataHandler == TdiDefaultRcvExpeditedHandler);

    return AddressFile;

}   /* NbiCreateAddressFile */


NTSTATUS
NbiDestroyAddressFile(
    IN PADDRESS_FILE AddressFile
    )

/*++

Routine Description:

    This routine destroys an address file and removes all references
    made by it to other objects in the transport.

    This routine is only called by NbiDereferenceAddressFile. The reason
    for this is that there may be multiple streams of execution which are
    simultaneously referencing the same address file object, and it should
    not be deleted out from under an interested stream of execution.

Arguments:

    AddressFile Pointer to a transport address file structure to be destroyed.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    CTELockHandle LockHandle, LockHandle1;
    PADDRESS Address;
    PDEVICE Device;
    PREQUEST CloseRequest;
    BOOLEAN StopAddress;

    NB_DEBUG2 (ADDRESS, ("Destroy address file %lx\n", AddressFile));

    Address = AddressFile->Address;
    Device = AddressFile->Device;

    if (Address) {

        //
        // This addressfile was associated with an address.
        //

        NB_GET_LOCK (&Address->Lock, &LockHandle);

        //
        // remove this addressfile from the address list and disassociate it from
        // the file handle.
        //

        RemoveEntryList (&AddressFile->Linkage);
        InitializeListHead (&AddressFile->Linkage);

        if (Address->AddressFileDatabase.Flink == &Address->AddressFileDatabase) {

            //
            // This is the last open of this address, it will close
            // due to normal dereferencing but we have to set the
            // CLOSING flag too to stop further references.
            //

            NB_GET_LOCK (&Device->Lock, &LockHandle1);
            Address->State = ADDRESS_STATE_STOPPING;
            NB_FREE_LOCK (&Device->Lock, LockHandle1);

            StopAddress = TRUE;

        } else {

            StopAddress = FALSE;
        }

        AddressFile->Address = NULL;

#ifdef ISN_NT
        AddressFile->FileObject->FsContext = NULL;
        AddressFile->FileObject->FsContext2 = NULL;
#endif

        NB_FREE_LOCK (&Address->Lock, LockHandle);

        //
        // We will already have been removed from the ShareAccess
        // of the owning address.
        //

        if (StopAddress && (!Address->NetbiosAddress.Broadcast)) {

            NbiSendNameFrame(
                Address,
                (UCHAR)(Address->NameTypeFlag |
                    NB_NAME_USED | NB_NAME_REGISTERED | NB_NAME_DEREGISTERED),
                NB_CMD_DELETE_NAME,
                NULL,
                NULL);
        }

        //
        // Now dereference the owning address.
        //

        NbiDereferenceAddress (Address, AREF_ADDRESS_FILE);

    }

    //
    // Save this for later completion.
    //

    CloseRequest = AddressFile->CloseRequest;

    //
    // return the addressFile to the pool of address files
    //

    NbiFreeMemory (AddressFile, sizeof(ADDRESS_FILE), MEMORY_ADDRESS, "AddressFile");

    if (CloseRequest != (PREQUEST)NULL) {
        REQUEST_INFORMATION(CloseRequest) = 0;
        REQUEST_STATUS(CloseRequest) = STATUS_SUCCESS;
        NbiCompleteRequest (CloseRequest);
        NbiFreeRequest (Device, CloseRequest);
    }

    return STATUS_SUCCESS;

}   /* NbiDestroyAddressFile */


#if DBG
VOID
NbiRefAddressFile(
    IN PADDRESS_FILE AddressFile
    )

/*++

Routine Description:

    This routine increments the reference count on an address file.

Arguments:

    AddressFile - Pointer to a transport address file object.

Return Value:

    none.

--*/

{

    CTEAssert (AddressFile->ReferenceCount > 0);   // not perfect, but...


    InterlockedIncrement( &AddressFile->ReferenceCount );
}   /* NbiRefAddressFile */


VOID
NbiRefAddressFileLock(
    IN PADDRESS_FILE AddressFile
    )

/*++

Routine Description:

    This routine increments the reference count on an address file.
    IT IS CALLED WITH THE ADDRESS LOCK HELD.

Arguments:

    AddressFile - Pointer to a transport address file object.

Return Value:

    none.

--*/

{

    CTEAssert (AddressFile->ReferenceCount > 0);   // not perfect, but...


    InterlockedIncrement( &AddressFile->ReferenceCount );

}   /* NbiRefAddressFileLock */

#endif


VOID
NbiDerefAddressFile(
    IN PADDRESS_FILE AddressFile
    )

/*++

Routine Description:

    This routine dereferences an address file by decrementing the
    reference count contained in the structure.  If, after being
    decremented, the reference count is zero, then this routine calls
    NbiDestroyAddressFile to remove it from the system.

Arguments:

    AddressFile - Pointer to a transport address file object.

Return Value:

    none.

--*/

{
    ULONG newvalue;

    newvalue = InterlockedDecrement( &AddressFile->ReferenceCount );

    //
    // If we have deleted all references to this address file, then we can
    // destroy the object.  It is okay to have already released the spin
    // lock at this point because there is no possible way that another
    // stream of execution has access to the address any longer.
    //

    CTEAssert ((LONG)newvalue >= 0);

    if (newvalue == 0) {
        NbiDestroyAddressFile (AddressFile);
    }

}   /* NbiDerefAddressFile */

#if      !defined(_PNP_POWER)

PADDRESS
NbiLookupAddress(
    IN PDEVICE Device,
    IN TDI_ADDRESS_NETBIOS UNALIGNED * NetbiosAddress
    )

/*++

Routine Description:

    This routine scans the transport addresses defined for the given
    device context and compares them with the specified NETWORK
    NAME values.  If an exact match is found, then a pointer to the
    ADDRESS object is returned, and as a side effect, the reference
    count to the address object is incremented.  If the address is not
    found, then NULL is returned.

    NOTE: This routine must be called with the Device
    spinlock held.

Arguments:

    Device - Pointer to the device object and its extension.

    NetbiosAddress - The name to look up, or -1 if the broadcast
        address is being searched for.

Return Value:

    Pointer to the ADDRESS object found, or NULL if not found.

--*/

{
    PADDRESS Address;
    PLIST_ENTRY p;

    p = Device->AddressDatabase.Flink;

    for (p = Device->AddressDatabase.Flink;
         p != &Device->AddressDatabase;
         p = p->Flink) {

        Address = CONTAINING_RECORD (p, ADDRESS, Linkage);

        if (Address->State == ADDRESS_STATE_STOPPING) {
            continue;
        }

        if (Address->NetbiosAddress.Broadcast) {

            //
            // This address is the broadcast one, so no match
            // unless we are looking for that.
            //

            if (NetbiosAddress != (PVOID)-1) {
                continue;
            }

        } else {

            //
            // This address is not the broadcast, so if we are
            // looking for that then no match, else compare the
            // two names.
            //

            if (NetbiosAddress == (PVOID)-1) {
                continue;
            }

            if (!RtlEqualMemory(
                    Address->NetbiosAddress.NetbiosName,
                    NetbiosAddress->NetbiosName,
                    16)) {
                continue;
            }
        }

        //
        // We found the match.  Bump the reference count on the address, and
        // return a pointer to the address object for the caller to use.
        //

        NbiReferenceAddressLock (Address, AREF_LOOKUP);
        return Address;

    } /* for */

    //
    // The specified address was not found.
    //

    return NULL;

}   /* NbiLookupAddress */
#endif  !_PNP_POWER


PADDRESS
NbiFindAddress(
    IN PDEVICE Device,
    IN PUCHAR NetbiosName
    )

/*++

Routine Description:

    This routine scans the transport addresses defined for the given
    device context and compares them with the specified NetbiosName
    values. If a match is found, the address is referenced and the
    pointer is returned.

    We ignore any addresses which are either STOPPING or are under
    CONFLICT state.

    A name in CONFLICT is dead for all practical purposes
    except Close. This routine is called by various name service,
    datagram and session sevice routines. We hide any names in CONFLICT
    from these routines.

    This routine is also called by NbiTdiOpenAddress().
    A name could have been marked in CONFLICT ages ago(but is not closed
    yet). We must allow another open of the same name as that might
    succeed now.

Arguments:

    Device - Pointer to the device object and its extension.

    NetbiosName - The name to look up, or -1 for the broadcast name.

Return Value:

    Pointer to the ADDRESS object found, or NULL if not found.

--*/

{
    PADDRESS Address;
    PLIST_ENTRY p;
    CTELockHandle LockHandle;


    NB_GET_LOCK (&Device->Lock, &LockHandle);

    p = Device->AddressDatabase.Flink;

    for (p = Device->AddressDatabase.Flink;
         p != &Device->AddressDatabase;
         p = p->Flink) {

        Address = CONTAINING_RECORD (p, ADDRESS, Linkage);

#if     defined(_PNP_POWER)
        if ( ( Address->State == ADDRESS_STATE_STOPPING ) ||
             (  Address->Flags & ADDRESS_FLAGS_CONFLICT ) ) {
#else
        if (Address->State == ADDRESS_STATE_STOPPING) {
#endif  _PNP_POWER
            continue;
        }

        if (Address->NetbiosAddress.Broadcast) {

            //
            // This address is the broadcast one, so no match
            // unless we are looking for that.
            //

            if (NetbiosName != (PVOID)-1) {
                continue;
            }

        } else {

            //
            // This address is not the broadcast, so if we are
            // looking for that then no match, else compare the
            // two names.
            //

            if ((NetbiosName == (PVOID)-1) ||
                (!RtlEqualMemory(
                     Address->NetbiosAddress.NetbiosName,
                     NetbiosName,
                     16))) {
                continue;
            }
        }


        //
        // We found the match.  Bump the reference count on the address, and
        // return a pointer to the address object for the caller to use.
        //

        NbiReferenceAddressLock (Address, AREF_FIND);
        NB_FREE_LOCK (&Device->Lock, LockHandle);
        return Address;

    } /* for */

    //
    // The specified address was not found.
    //

    NB_FREE_LOCK (&Device->Lock, LockHandle);
    return NULL;

}   /* NbiFindAddress */


NTSTATUS
NbiStopAddressFile(
    IN PADDRESS_FILE AddressFile,
    IN PADDRESS Address
    )

/*++

Routine Description:

    This routine is called to terminate all activity on an AddressFile and
    destroy the object.  We remove every connection and datagram associated
    with this addressfile from the address database and terminate their
    activity. Then, if there are no other outstanding addressfiles open on
    this address, the address will go away.

Arguments:

    AddressFile - pointer to the addressFile to be stopped

    Address - the owning address for this addressFile (we do not depend upon
        the pointer in the addressFile because we want this routine to be safe)

Return Value:

    STATUS_SUCCESS if all is well, STATUS_INVALID_HANDLE if the request
    is not for a real address.

--*/

{
    PLIST_ENTRY p;
    PCONNECTION Connection;
    PREQUEST Request;
    PDEVICE Device = Address->Device;
    CTELockHandle LockHandle1, LockHandle2;
    LIST_ENTRY SendDatagramList;
    PNB_SEND_RESERVED Reserved;
    PREQUEST DatagramRequest;
    NB_DEFINE_LOCK_HANDLE (LockHandle3)
    CTELockHandle CancelLH;
    NB_DEFINE_SYNC_CONTEXT (SyncContext)
    LIST_ENTRY  DatagramQ;



    NB_GET_LOCK (&Address->Lock, &LockHandle1);

    if (AddressFile->State == ADDRESSFILE_STATE_CLOSING) {
        NB_FREE_LOCK (&Address->Lock, LockHandle1);
        return STATUS_SUCCESS;
    }


    //
    // This prevents anybody else from being put on the
    // ConnectionDatabase.
    //

    AddressFile->State = ADDRESSFILE_STATE_CLOSING;

    while (!IsListEmpty (&AddressFile->ConnectionDatabase)) {

        p = RemoveHeadList (&AddressFile->ConnectionDatabase);
        Connection = CONTAINING_RECORD (p, CONNECTION, AddressFileLinkage);

        CTEAssert (Connection->AddressFile == AddressFile);
        Connection->AddressFileLinked = FALSE;

        NB_GET_LOCK (&Device->Lock, &LockHandle2);

        if (Connection->ReferenceCount == 0) {

            //
            // The refcount is already 0, so we can just
            // NULL out this field to complete the disassociate.
            //

            Connection->AddressFile = NULL;
            NB_FREE_LOCK (&Device->Lock, LockHandle2);
            NB_FREE_LOCK (&Address->Lock, LockHandle1);

            NbiDereferenceAddressFile (AddressFile, AFREF_CONNECTION);

        } else {

            //
            // Mark this so we know to disassociate when the
            // count goes to 0, but that there is no specific
            // request pending on it. We also stop the connection
            // to shut it down.
            //

            Connection->DisassociatePending = (PVOID)-1;
            NbiReferenceConnectionLock (Connection, CREF_DISASSOC);

            NB_FREE_LOCK (&Device->Lock, LockHandle2);
            NB_FREE_LOCK (&Address->Lock, LockHandle1);

            NB_BEGIN_SYNC (&SyncContext);
            NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle3);

            //
            // This call frees the connection lock.
            //

            NbiStopConnection(
                Connection,
                STATUS_INVALID_ADDRESS
                NB_LOCK_HANDLE_ARG (LockHandle3));

            NB_END_SYNC (&SyncContext);

            NbiDereferenceConnection (Connection, CREF_DISASSOC);

        }

        NB_GET_LOCK (&Address->Lock, &LockHandle1);
    }

    NB_FREE_LOCK (&Address->Lock, LockHandle1);


    //
    // Abort all pending send datagrams.
    //

    InitializeListHead (&SendDatagramList);

    NB_GET_LOCK (&Device->Lock, &LockHandle2);

    p = Device->WaitingDatagrams.Flink;

    while (p != &Device->WaitingDatagrams) {

        Reserved = CONTAINING_RECORD (p, NB_SEND_RESERVED, WaitLinkage);

        p = p->Flink;

        if (Reserved->u.SR_DG.AddressFile == AddressFile) {

            RemoveEntryList (&Reserved->WaitLinkage);
            InsertTailList (&SendDatagramList, &Reserved->WaitLinkage);

        }

    }

    NB_FREE_LOCK (&Device->Lock, LockHandle2);

    for (p = SendDatagramList.Flink; p != &SendDatagramList; ) {

        Reserved = CONTAINING_RECORD (p, NB_SEND_RESERVED, WaitLinkage);
        p = p->Flink;

        DatagramRequest = Reserved->u.SR_DG.DatagramRequest;

        NB_DEBUG2 (DATAGRAM, ("Aborting datagram %lx on %lx\n", DatagramRequest, AddressFile));

        REQUEST_STATUS(DatagramRequest) = STATUS_SUCCESS;

        NbiCompleteRequest(DatagramRequest);
        NbiFreeRequest (Device, DatagramRequest);

        NbiDereferenceAddressFile (AddressFile, AFREF_SEND_DGRAM);

        ExInterlockedPushEntrySList(
            &Device->SendPacketList,
            &Reserved->PoolLinkage,
            &NbiGlobalPoolInterlock);

    }


    //
    // Abort all pending receive datagrams.
    //

    InitializeListHead( &DatagramQ );

    NB_GET_CANCEL_LOCK(&CancelLH);
    NB_GET_LOCK (&Address->Lock, &LockHandle1);

    while (!IsListEmpty(&AddressFile->ReceiveDatagramQueue)) {

        p = RemoveHeadList (&AddressFile->ReceiveDatagramQueue);
        Request = LIST_ENTRY_TO_REQUEST (p);

        // Insert it on a private Q, so it can be completed later.
        InsertTailList( &DatagramQ, p);

        REQUEST_INFORMATION(Request) = 0;
        REQUEST_STATUS(Request) = STATUS_NETWORK_NAME_DELETED;

        IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);



        NbiDereferenceAddressFile (AddressFile, AFREF_RCV_DGRAM);

    }

    NB_FREE_LOCK (&Address->Lock, LockHandle1);
    NB_FREE_CANCEL_LOCK(CancelLH);

    for( p = DatagramQ.Flink; p != &DatagramQ;  ) {
        Request = LIST_ENTRY_TO_REQUEST ( p );

        p = p->Flink;

        NbiCompleteRequest (Request);
        NbiFreeRequest (Device, Request);

    }


    return STATUS_SUCCESS;

}   /* NbiStopAddressFile */


NTSTATUS
NbiCloseAddressFile(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine is called to close the addressfile pointed to by a file
    object. If there is any activity to be run down, we will run it down
    before we terminate the addressfile. We remove every connection and
    datagram associated with this addressfile from the address database
    and terminate their activity. Then, if there are no other outstanding
    addressfiles open on this address, the address will go away.

Arguments:

    Request - the close request.

Return Value:

    STATUS_SUCCESS if all is well, STATUS_INVALID_HANDLE if the
    request does not point to a real address.

--*/

{
    PADDRESS Address;
    PADDRESS_FILE AddressFile;

    AddressFile = (PADDRESS_FILE)REQUEST_OPEN_CONTEXT(Request);
    AddressFile->CloseRequest = Request;

    //
    // We assume that addressFile has already been verified
    // at this point.
    //

    Address = AddressFile->Address;
    CTEAssert (Address);

    //
    // Remove us from the access info for this address.
    //

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite (&Device->AddressResource, TRUE);
#ifdef ISN_NT
    IoRemoveShareAccess (AddressFile->FileObject, &Address->u.ShareAccess);
#endif
    ExReleaseResourceLite (&Device->AddressResource);
    KeLeaveCriticalRegion();

    NbiStopAddressFile (AddressFile, Address);
    NbiDereferenceAddressFile (AddressFile, AFREF_CREATE);

    return STATUS_PENDING;

}   /* NbiCloseAddressFile */

#if     defined(_PNP_POWER)


PADAPTER_ADDRESS
NbiCreateAdapterAddress(
    IN PCHAR    AdapterMacAddress
    )

/*++

Routine Description:

    This routine creates an adapter address sttuctures which stores
    the netbios name of an adapter. the netbios name has 12 0's
    followed by the mac address of the adapter.

Arguments:

    Device - Pointer to the device context (which is really just
        the device object with its extension) to be associated with the
        address.

    AdapterMacAddress - pointer to the adapter mac address given to us
        by IPX.

Return Value:

    The newly created address, or NULL if none can be allocated.
    THIS ROUTINE MUST BE CALLED WITH THE DEVICE LOCK HELD.

--*/

{
    PADAPTER_ADDRESS    AdapterAddress;
    CTELockHandle       LockHandle;
    PDEVICE             Device          =   NbiDevice;

    AdapterAddress = (PADAPTER_ADDRESS)NbiAllocateMemory (sizeof(ADAPTER_ADDRESS), MEMORY_ADAPTER_ADDRESS, "Adapter Address");
    if (AdapterAddress == NULL) {
        CTEAssert (AdapterMacAddress);
        NB_DEBUG (ADDRESS, ("Create Adapter Address <%2.2x><%2.2x><%2.2x><%2.2x><%2.2x><%2.2x> failed\n",
            (UCHAR) AdapterMacAddress[0],
            (UCHAR) AdapterMacAddress[1],
            (UCHAR) AdapterMacAddress[2],
            (UCHAR) AdapterMacAddress[3],
            (UCHAR) AdapterMacAddress[4],
            (UCHAR) AdapterMacAddress[5]
            ));
        return NULL;
    }

    AdapterAddress->Type = NB_ADAPTER_ADDRESS_SIGNATURE;
    AdapterAddress->Size = sizeof (ADDRESS);

    RtlZeroMemory(AdapterAddress->NetbiosName, 10);
    RtlCopyMemory(&AdapterAddress->NetbiosName[10], AdapterMacAddress, 6);


    InsertTailList (&Device->AdapterAddressDatabase, &AdapterAddress->Linkage);
    ++Device->AddressCounts[AdapterAddress->NetbiosName[0]];

    return AdapterAddress;

}   /* NbiCreateAdapterAddress */


NTSTATUS
NbiDestroyAdapterAddress(
    IN PADAPTER_ADDRESS AdapterAddress OPTIONAL,
    IN PCHAR            AdapterMacAddress OPTIONAL
    )

/*++

Routine Description:

    This routine destroys the adapter address structure and removes it
    from the list.

Arguments:

    AdapterAddress - Pointer to an adapter address structure to be destroyed
                     NULL if AdapterMacAddress is given.

    AdapterMacAddress - Mac Address of the adapter which just got deleted. so find
                    the corresponding adapter address structure and remove it.
                    NULL if AdapterAddress is supplied.

Return Value:

    STATUS_SUCCESS or STATUS_UNSUCCESSFUL if address not found.

    THIS ROUTINE ASSUMES THE THE DEVICE IS LOCK IS HELD BY THE CALLER

--*/

{
    PDEVICE       Device          =   NbiDevice;
    CTELockHandle LockHandle;
    UCHAR               NetbiosName[NB_NETBIOS_NAME_SIZE];


    //

    CTEAssert( AdapterAddress || AdapterMacAddress );
    if ( !AdapterAddress ) {
        RtlZeroMemory( NetbiosName, 10);
        RtlCopyMemory( &NetbiosName[10], AdapterMacAddress, 6 );

        AdapterAddress = NbiFindAdapterAddress( NetbiosName, LOCK_ACQUIRED );

        if ( !AdapterAddress ) {
            return STATUS_UNSUCCESSFUL;
        }
    }

    NB_DEBUG2 (ADDRESS, ("Destroy Adapter address %lx <%.16s>\n", AdapterAddress,AdapterAddress->NetbiosName));
    RemoveEntryList (&AdapterAddress->Linkage);
    ++Device->AddressCounts[AdapterAddress->NetbiosName[0]];

    NbiFreeMemory (AdapterAddress, sizeof(ADAPTER_ADDRESS), MEMORY_ADAPTER_ADDRESS, "AdapterAddress");

    return STATUS_SUCCESS;
}   /* NbiDestroyAdapterAddress */


PADAPTER_ADDRESS
NbiFindAdapterAddress(
    IN PCHAR            NetbiosName,
    IN BOOLEAN          LockHeld
    )

/*++

Routine Description:

    This routine finds an adapter address ( netbios name ) for the given
    AdapterMacAddress and returns a pointer to it. Note that no reference
    is done on this address, so if this routine is called without the device
    lock, the caller must not use this pointer directly.

Arguments:

    NetbiosName - NetbiosName to be found.

    LockHeld    - is device lock already held or not.

Return Value:

    Pointer to the adapter address if found, NULL otherwise.

--*/

{

    PLIST_ENTRY         p;
    CTELockHandle       LockHandle;
    PADAPTER_ADDRESS    AdapterAddress;
    PDEVICE             Device    =   NbiDevice;


    if ( !LockHeld ) {
        NB_GET_LOCK( &Device->Lock, &LockHandle );
    }
    for ( p = Device->AdapterAddressDatabase.Flink;
          p != &Device->AdapterAddressDatabase;
          p =   p->Flink ) {

        AdapterAddress  =   CONTAINING_RECORD( p, ADAPTER_ADDRESS, Linkage );
        if ( RtlEqualMemory(
                NetbiosName,
                AdapterAddress->NetbiosName,
                NB_NETBIOS_NAME_SIZE ) ) {
            break;
        }
    }


    if ( !LockHeld ) {
        NB_FREE_LOCK( &Device->Lock, LockHandle );
    }

    if ( p == &Device->AdapterAddressDatabase ) {
        return NULL;
    } else {
        return AdapterAddress;
    }

} /* NbiFindAdapterAddress */

#endif  _PNP_POWER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\nb\autodial.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    autodial.c

Abstract:

    NT specific routines for interfacing with the
    RAS AutoDial driver (rasacd.sys).

Author:

    Anthony Discolo (adiscolo)     Aug 30, 1995

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    adiscolo    08-30-95    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef RASAUTODIAL

#include <acd.h>
#include <acdapi.h>

//
// Global variables
//
BOOLEAN fAcdLoadedG;
ACD_DRIVER AcdDriverG;
ULONG ulDriverIdG = 'Nbi ';



VOID
NbiRetryTdiConnect(
    IN BOOLEAN fSuccess,
    IN PVOID *pArgs
    )

/*++

Routine Description:

    This routine is called indirectly by the automatic
    connection driver to continue the connection process
    after an automatic connection has been made.

Arguments:

    fSuccess - TRUE if the connection attempt was successful.

    pArgs - a pointer to the argument vector

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PDEVICE pDevice = pArgs[0];
    PCONNECTION pConnection = pArgs[1];
    PREQUEST pRequest = pArgs[2];
    CTELockHandle ConnectionLH, DeviceLH;
    CTELockHandle CancelLH;
    BOOLEAN bLockFreed = FALSE;

    //
    // Check that the connection is valid. This references
    // the connection.
    //
#if notdef // DBG
    DbgPrint("NbiRetryTdiConnect: fSuccess=%d, pConnection=0x%x\n", fSuccess, pConnection);
#endif

    status = NbiVerifyConnection(pConnection);
    if (!NT_SUCCESS(status)) {
        DbgPrint(
          "NbiRetryTdiConnect: NbiVerifyConnection failed on connection 0x%x (status=0x%x)\n",
          pConnection,
          status);
        return;
    }

    NB_GET_CANCEL_LOCK( &CancelLH );
    NB_GET_LOCK (&pConnection->Lock, &ConnectionLH);
    NB_GET_LOCK (&pDevice->Lock, &DeviceLH);

#if notdef // DBG
    DbgPrint(
      "NbiRetryTdiConnect: AddressFile=0x%x, DisassociatePending=0x%x, ClosePending=0x%x\n",
      pConnection->AddressFile,
      pConnection->DisassociatePending,
      pConnection->ClosePending);
#endif

    if ((pConnection->AddressFile != NULL) &&
        (pConnection->AddressFile != (PVOID)-1) &&
        (pConnection->DisassociatePending == NULL) &&
        (pConnection->ClosePending == NULL))
    {
        NbiReferenceConnectionLock(pConnection, CREF_CONNECT);
        //
        // Clear the AUTOCONNECTING flag since we
        // done with the automatic connection attempt.
        // Set the AUTOCONNECTED flag to prevent us
        // from attempting an automatic connection
        // for this connection again.
        //
        pConnection->Flags &= ~CONNECTION_FLAGS_AUTOCONNECTING;
        pConnection->Flags |= CONNECTION_FLAGS_AUTOCONNECTED;

        pConnection->State = CONNECTION_STATE_CONNECTING;
        pConnection->Retries = pDevice->ConnectionCount;
        status = NbiTdiConnectFindName(
                   pDevice,
                   pRequest,
                   pConnection,
                   CancelLH,
                   ConnectionLH,
                   DeviceLH,
                   &bLockFreed);
    }
    else {
        DbgPrint("NbiRetryTdiConnect: Connect on invalid connection 0x%x\n", pConnection);

        pConnection->SubState = CONNECTION_SUBSTATE_C_DISCONN;
        NB_FREE_LOCK (&pDevice->Lock, DeviceLH);
        status = STATUS_INVALID_CONNECTION;
    }
    if (!bLockFreed) {
        NB_FREE_LOCK (&pConnection->Lock, ConnectionLH);
        NB_FREE_CANCEL_LOCK(CancelLH);
    }
    //
    // Complete the irp if necessary.
    //
    if (status != STATUS_PENDING) {
        REQUEST_INFORMATION(pRequest) = 0;
        REQUEST_STATUS(pRequest) = status;

        NbiCompleteRequest(pRequest);
        NbiFreeRequest(pDevice, pRequest);
    }
    NbiDereferenceConnection(pConnection, CREF_VERIFY);
} /* NbiRetryTdiConnect */



BOOLEAN
NbiCancelAutoDialRequest(
    IN PVOID pArg,
    IN ULONG ulFlags,
    IN ACD_CONNECT_CALLBACK pProc,
    IN USHORT nArgs,
    IN PVOID *pArgs
    )
{
#if notdef // DBG
    DbgPrint("NbiCancelAutodialRequest: pArg=0x%x\n", pArg);
#endif
    if (nArgs != 2)
        return FALSE;

    return (pArgs[1] == pArg);
} // NbiCancelAutoDialRequest



BOOLEAN
NbiCancelTdiConnect(
    IN PDEVICE pDevice,
    IN PREQUEST pRequest,
    IN PCONNECTION pConnection
    )

/*++

DESCRIPTION
    This routine is called by the I/O system to cancel a connection
    when we are attempting to restore an automatic connection.

ARGUMENTS
    pDevice: a pointer to the device object for this driver

    pRequest: a pointer to the irp to be cancelled

    pConnection: a pointer to the connnection to be cancelled

RETURN VALUE
    TRUE if the request was canceled; FALSE otherwise.

--*/

{
    ACD_ADDR addr;

    //
    // Get the address of the connection.
    //
    addr.fType = ACD_ADDR_NB;
    RtlCopyMemory(&addr.cNetbios, pConnection->RemoteName, 16);
#ifdef notdef // DBG
    DbgPrint(
      "NbiCancelTdiConnect: pIrp=0x%x, RemoteName=%-15.15s, pConnection=0x%x\n",
      pRequest,
      addr.cNetbios,
      pConnection);
#endif
    //
    // Cancel the autodial request.
    //
    return (*AcdDriverG.lpfnCancelConnection)(
              ulDriverIdG,
              &addr,
              NbiCancelAutoDialRequest,
              pConnection);
} // NbiCancelTdiConnect



BOOLEAN
NbiAttemptAutoDial(
    IN PDEVICE pDevice,
    IN PCONNECTION pConnection,
    IN ULONG ulFlags,
    IN ACD_CONNECT_CALLBACK pProc,
    IN PREQUEST pRequest
    )

/*++

Routine Description:

    Call the automatic connection driver to attempt an
    automatic connection.

Arguments:

    pDevice - a pointer to the DEVICE structure for this connection

    pConnection - a pointer to the CONNECTION block for this connection

    ulFlags - connection flags to pass to the automatic
        connection driver

    pProc - a callback procedure when the automatic connection completes

    pRequest - a pointer to the request irp

Return Value:

    TRUE if the automatic connection was started successfully,
    FALSE otherwise.

--*/

{
    ACD_ADDR addr;
    PVOID pArgs[3];
    BOOLEAN bSuccess;

    //
    // If we've already attempted an automatic connection
    // on this connection, don't try it again.
    //
    if (pConnection->Flags & CONNECTION_FLAGS_AUTOCONNECTED)
        return FALSE;
    //
    // Get the address of the connection.
    //
    addr.fType = ACD_ADDR_NB;
    RtlCopyMemory(&addr.cNetbios, pConnection->RemoteName, 16);
#ifdef notdef // DBG
    DbgPrint("NbiAttemptAutoDial: szAddr=%15.15s\n", addr.cNetbios);
#endif
    //
    // Attempt to start the connection.
    // NbiRetryTdiConnect() will be called
    // when the connection process has completed.
    //
    pArgs[0] = pDevice;
    pArgs[1] = pConnection;
    pArgs[2] = pRequest;
    bSuccess = (*AcdDriverG.lpfnStartConnection)(
                  ulDriverIdG,
                  &addr,
                  ulFlags,
                  pProc,
                  3,
                  pArgs);
    if (bSuccess) {
        //
        // Set the AUTOCONNECTING flag so we know
        // to also cancel the connection in the
        // automatic connection driver if this
        // request gets canceled.
        //
        pConnection->Flags |= CONNECTION_FLAGS_AUTOCONNECTING;
    }

    return bSuccess;

} // NbiAttemptAutoDial



VOID
NbiNoteNewConnection(
    IN PCONNECTION pConnection
    )
{
    NTSTATUS status;
    ACD_ADDR addr;
    ACD_ADAPTER adapter;
    ULONG i;
    TDI_ADDRESS_IPX tdiIpxAddress;

    addr.fType = ACD_ADDR_NB;
    RtlCopyMemory(&addr.cNetbios, pConnection->RemoteName, 16);
    //
    // Determine the mac address of the adapter
    // over which the connection has been made.
    //
    status = (pConnection->Device->Bind.QueryHandler)(
               IPX_QUERY_IPX_ADDRESS,
#if defined(_PNP_POWER)
               &pConnection->LocalTarget.NicHandle,
#else
               pConnection->LocalTarget.NicId,
#endif _PNP_POWER
               &tdiIpxAddress,
               sizeof(TDI_ADDRESS_IPX),
               NULL);
    if (status != STATUS_SUCCESS) {
#if notdef // DBG
        DbgPrint("NbiNoteNewConnection: QueryHandler(IPX_QUERY_IPX_ADDRESS) failed (status=0x%x)\n", status);
        return;
#endif
    }
    //
    // Copy the source mac address to identify
    // the adapter.
    //
    adapter.fType = ACD_ADAPTER_MAC;
    for (i = 0; i < 6; i++)
        adapter.cMac[i] = tdiIpxAddress.NodeAddress[i];
#if notdef // DBG
    DbgPrint(
      "NbiNoteNewConnection: address=%-15.15s, remote mac=%02x:%02x:%02x:%02x:%02x:%02x\n",
      addr.cNetbios,
      adapter.cMac[0],
      adapter.cMac[1],
      adapter.cMac[2],
      adapter.cMac[3],
      adapter.cMac[4],
      adapter.cMac[5]);
#endif
    //
    // Simply notify the automatic connection driver
    // that a successful connection has been made.
    //
    (*AcdDriverG.lpfnNewConnection)(
        &addr,
        &adapter);
} // NbiNoteNewConnection



VOID
NbiAcdBind()
{
    NTSTATUS status;
    UNICODE_STRING nameString;
    IO_STATUS_BLOCK ioStatusBlock;
    PIRP pIrp;
    PFILE_OBJECT pAcdFileObject;
    PDEVICE_OBJECT pAcdDeviceObject;
    PACD_DRIVER pDriver = &AcdDriverG;

    //
    // Initialize the name of the automatic
    // connection device.
    //
    RtlInitUnicodeString(&nameString, ACD_DEVICE_NAME);
    //
    // Get the file and device objects for the
    // device.
    //
    status = IoGetDeviceObjectPointer(
               &nameString,
               SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE,
               &pAcdFileObject,
               &pAcdDeviceObject);
    if (status != STATUS_SUCCESS)
        return;
    //
    // Reference the device object.
    //
    ObReferenceObject(pAcdDeviceObject);
    //
    // Remove the reference IoGetDeviceObjectPointer()
    // put on the file object.
    //
    ObDereferenceObject(pAcdFileObject);
    //
    // Initialize our part of the ACD_DRIVER
    // structure.
    //
    KeInitializeSpinLock(&AcdDriverG.SpinLock);
    AcdDriverG.ulDriverId = ulDriverIdG;
    AcdDriverG.fEnabled = FALSE;
    //
    // Build a request to get the automatic
    // connection driver entry points.
    //
    pIrp = IoBuildDeviceIoControlRequest(
             IOCTL_INTERNAL_ACD_BIND,
             pAcdDeviceObject,
             (PVOID)&pDriver,
             sizeof (pDriver),
             NULL,
             0,
             TRUE,
             NULL,
             &ioStatusBlock);
    if (pIrp == NULL) {
        ObDereferenceObject(pAcdDeviceObject);
        return;
    }
    //
    // Submit the request to the
    // automatic connection driver.
    //
    status = IoCallDriver(pAcdDeviceObject, pIrp);
    fAcdLoadedG = (status == STATUS_SUCCESS);
    //
    // Close the device.
    //
    ObDereferenceObject(pAcdDeviceObject);
} // NbiAcdBind



VOID
NbiAcdUnbind()
{
    NTSTATUS status;
    UNICODE_STRING nameString;
    IO_STATUS_BLOCK ioStatusBlock;
    PIRP pIrp;
    PFILE_OBJECT pAcdFileObject;
    PDEVICE_OBJECT pAcdDeviceObject;
    PACD_DRIVER pDriver = &AcdDriverG;

    //
    // Don't bother to unbind if we
    // didn't successfully bind in the
    // first place.
    //
    if (!fAcdLoadedG)
        return;
    //
    // Initialize the name of the automatic
    // connection device.
    //
    RtlInitUnicodeString(&nameString, ACD_DEVICE_NAME);
    //
    // Get the file and device objects for the
    // device.
    //
    status = IoGetDeviceObjectPointer(
               &nameString,
               SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE,
               &pAcdFileObject,
               &pAcdDeviceObject);
    if (status != STATUS_SUCCESS)
        return;
    //
    // Reference the device object.
    //
    ObReferenceObject(pAcdDeviceObject);
    //
    // Remove the reference IoGetDeviceObjectPointer()
    // put on the file object.
    //
    ObDereferenceObject(pAcdFileObject);
    //
    // Build a request to unbind from
    // the automatic connection driver.
    //
    pIrp = IoBuildDeviceIoControlRequest(
             IOCTL_INTERNAL_ACD_UNBIND,
             pAcdDeviceObject,
             (PVOID)&pDriver,
             sizeof (pDriver),
             NULL,
             0,
             TRUE,
             NULL,
             &ioStatusBlock);
    if (pIrp == NULL) {
        ObDereferenceObject(pAcdDeviceObject);
        return;
    }
    //
    // Submit the request to the
    // automatic connection driver.
    //
    status = IoCallDriver(pAcdDeviceObject, pIrp);
    //
    // Close the device.
    //
    ObDereferenceObject(pAcdDeviceObject);
} // NbiAcdUnbind

#endif // RASAUTODIAL

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\nb\cache.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    cache.c

Abstract:

    This module contains the name cache routines for the Netbios
    module of the ISN transport.

Author:

    Adam Barr (adamba) 20-December-1993

Environment:

    Kernel mode

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CreateNetbiosCacheTable)
#endif

#ifdef RASAUTODIAL
#include <acd.h>
#include <acdapi.h>

extern BOOLEAN fAcdLoadedG;
extern ACD_DRIVER AcdDriverG;

BOOLEAN
NbiAttemptAutoDial(
    IN PDEVICE pDevice,
    IN PCONNECTION pConnection,
    IN ULONG ulFlags,
    IN ACD_CONNECT_CALLBACK pProc,
    IN PREQUEST pRequest
    );

VOID
NbiRetryTdiConnect(
    IN BOOLEAN fSuccess,
    IN PVOID *pArgs
    );
#endif // RASAUTODIAL

//
// We should change to monitor add name packets better,
// so if we get an add for a different place we attempt to determine
// if it is real or bogus and update if possible.
//


NTSTATUS
CacheFindName(
    IN PDEVICE Device,
    IN FIND_NAME_TYPE Type,
    IN PUCHAR RemoteName OPTIONAL,
    OUT PNETBIOS_CACHE * CacheName
)

/*++

Routine Description:

    This routine looks up a particular remote name in the
    Netbios name cache. If it cannot find it, a find name
    request is queued up.

    THIS REQUEST IS CALLED WITH THE DEVICE LOCK HELD AND
    RETURNS WITH IT HELD.

Arguments:

    Device - The netbios device.

    Type - Defines the type. The effect this has is:
        FindNameConnect - On connects we will ignore an existing
            cache entry if it got no response before.
        FindNameNetbiosFindName - For these we ignore an existing
            cache entry if it is for a group name -- this is
            because the find name wants the address of every
            machine, not just the network list.
        FindNameOther - Normal handling is done.

    RemoteName - The name to be discovered -- will be NULL if it
        is the broadcast address.

    CacheName - Returns the cache entry that was discovered.

Return Value:

    None.

--*/

{
    PLIST_ENTRY p;
    PSLIST_ENTRY s;
    PNETBIOS_CACHE FoundCacheName;
    PNB_SEND_RESERVED Reserved;
    PUCHAR RealRemoteName;      // RemoteName or NetbiosBroadcastName

    //
    // First scan the netbios name cache to see if we know
    // about this remote.
    //

    if (RemoteName) {
        RealRemoteName = RemoteName;
    } else {
        RealRemoteName = NetbiosBroadcastName;
    }

    if ( FindInNetbiosCacheTable ( Device->NameCache,
                                   RealRemoteName,
                                   &FoundCacheName ) == STATUS_SUCCESS ) {

        //
        // If this is a netbios find name, we only can use unique
        // names in the cache; for the group ones we need to requery
        // because the cache only lists networks, not individual machines.
        // For connect requests, if we find an empty cache entry we
        // remove it and requery.
        //

        if ( FoundCacheName->Unique || (Type != FindNameNetbiosFindName) ) {

            if (FoundCacheName->NetworksUsed > 0) {

                *CacheName = FoundCacheName;
                NB_DEBUG2 (CACHE, ("Found cache name <%.16s>\n", RemoteName ? RemoteName : "<broadcast>"));
                return STATUS_SUCCESS;

            } else {

                if (Type != FindNameConnect) {

                    if (FoundCacheName->FailedOnDownWan) {
                        NB_DEBUG2 (CACHE, ("Found cache name, but down wan <%.16s>\n", RemoteName ? RemoteName : "<broadcast>"));
                        return STATUS_DEVICE_DOES_NOT_EXIST;
                    } else {
                        NB_DEBUG2 (CACHE, ("Found cache name, but no nets <%.16s>\n", RemoteName ? RemoteName : "<broadcast>"));
                        return STATUS_BAD_NETWORK_PATH;
                    }

                } else {

                    //
                    // This is a connect and the current cache entry
                    // has zero names; delete it.
                    //

                    RemoveFromNetbiosCacheTable ( Device->NameCache, FoundCacheName );
                    CTEAssert (FoundCacheName->ReferenceCount == 1);
                    if (--FoundCacheName->ReferenceCount == 0) {

                        NB_DEBUG2 (CACHE, ("Free unneeded empty cache entry %lx\n", FoundCacheName));
                        NbiFreeMemory(
                            FoundCacheName,
                            sizeof(NETBIOS_CACHE) + ((FoundCacheName->NetworksAllocated-1) * sizeof(NETBIOS_NETWORK)),
                            MEMORY_CACHE,
                            "Free due to replacement");
                    }

                }
            }
        }
    }


    //
    // There was no suitable cache entry for this network, first see
    // if there is one pending.
    //

    for (p = Device->WaitingFindNames.Flink;
         p != &Device->WaitingFindNames;
         p = p->Flink) {

        Reserved = CONTAINING_RECORD (p, NB_SEND_RESERVED, WaitLinkage);

        //
        // For this purpose we ignore a packet if a route
        // has been found and it was for a unique name. This
        // is because the cache information has already been
        // inserted for this name. Otherwise if the name has
        // since been deleted from the cache, the request
        // that is looking for this name will starve because
        // FindNameTimeout will just destroy the packet.
        //

        if (NB_GET_SR_FN_STATUS(Reserved) == FNStatusResponseUnique) {
            continue;
        }

        if (RtlEqualMemory(
            Reserved->u.SR_FN.NetbiosName,
            RealRemoteName, 16)) {

            NB_DEBUG2 (CACHE, ("Cache name already pending <%.16s>\n", RemoteName ? RemoteName : "<broadcast>"));

            //
            // There is already one pending. If it is for a group
            // name and this is a netbios find name, we make sure
            // the retry count is such that at least one more
            // query will be sent, so the netbios find name
            // buffer can be filled with the responses from this.
            //

            if ((Type == FindNameNetbiosFindName) &&
                (NB_GET_SR_FN_STATUS(Reserved) == FNStatusResponseGroup) &&
                (Reserved->u.SR_FN.RetryCount == Device->BroadcastCount)) {

                --Reserved->u.SR_FN.RetryCount;
            }

            return STATUS_PENDING;
        }
    }

    s = NbiPopSendPacket(Device, TRUE);

    if (s == NULL) {
        NB_DEBUG (CACHE, ("Couldn't get packet to find <%.16s>\n", RemoteName ? RemoteName : "<broadcast>"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Reserved = CONTAINING_RECORD (s, NB_SEND_RESERVED, PoolLinkage);

    //
    // We have the packet, fill it in for this request.
    //

    CTEAssert (Reserved->SendInProgress == FALSE);
    Reserved->SendInProgress = FALSE;
    Reserved->Type = SEND_TYPE_FIND_NAME;
    RtlCopyMemory (Reserved->u.SR_FN.NetbiosName, RealRemoteName, 16);
    Reserved->u.SR_FN.StatusAndSentOnUpLine = FNStatusNoResponse;   // SentOnUpLine is FALSE
    Reserved->u.SR_FN.RetryCount = 0;
    Reserved->u.SR_FN.NewCache = NULL;
    Reserved->u.SR_FN.SendTime = Device->FindNameTime;
#if      !defined(_PNP_POWER)
    Reserved->u.SR_FN.CurrentNicId = 1;

    (VOID)(*Device->Bind.QueryHandler)(      // Check return code ?
               IPX_QUERY_MAX_TYPE_20_NIC_ID,
               (USHORT)0,
               &Reserved->u.SR_FN.MaximumNicId,
               sizeof(USHORT),
               NULL);

    if (Reserved->u.SR_FN.MaximumNicId == 0) {
        Reserved->u.SR_FN.MaximumNicId = 1;  // code assumes at least one
    }
#endif  !_PNP_POWER
    NB_DEBUG2 (CACHE, ("Queued FIND_NAME %lx for <%.16s>\n",
                          Reserved, RemoteName ? RemoteName : "<broadcast>"));


    InsertHeadList(
        &Device->WaitingFindNames,
        &Reserved->WaitLinkage);

    ++Device->FindNamePacketCount;

    if (!Device->FindNameTimerActive) {

        Device->FindNameTimerActive = TRUE;
        NbiReferenceDevice (Device, DREF_FN_TIMER);

        CTEStartTimer(
            &Device->FindNameTimer,
            1,        // 1 ms, i.e. expire immediately
            FindNameTimeout,
            (PVOID)Device);
    }

    NbiReferenceDevice (Device, DREF_FIND_NAME);

    return STATUS_PENDING;

}   /* CacheFindName */


VOID
FindNameTimeout(
    CTEEvent * Event,
    PVOID Context
    )

/*++

Routine Description:

    This routine is called when the find name timer expires.
    It is called every FIND_NAME_GRANULARITY milliseconds unless there
    is nothing to do.

Arguments:

    Event - The event used to queue the timer.

    Context - The context, which is the device pointer.

Return Value:

    None.

--*/

{
    PDEVICE Device = (PDEVICE)Context;
    PLIST_ENTRY p, q;
    PNB_SEND_RESERVED Reserved;
    PNDIS_PACKET Packet;
    NB_CONNECTIONLESS UNALIGNED * Header;
    PNETBIOS_CACHE FoundCacheName;
    NDIS_STATUS NdisStatus;
#if      !defined(_PNP_POWER)
    static IPX_LOCAL_TARGET BroadcastTarget = { 0, { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } };
#endif  !_PNP_POWER
    NB_DEFINE_LOCK_HANDLE (LockHandle)

    NB_SYNC_GET_LOCK (&Device->Lock, &LockHandle);

    ++Device->FindNameTime;

    if (Device->FindNamePacketCount == 0) {

        NB_DEBUG2 (CACHE, ("FindNameTimeout exiting\n"));

        Device->FindNameTimerActive = FALSE;
        NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);
        NbiDereferenceDevice (Device, DREF_FN_TIMER);

        return;
    }

    //
    // Check what is on the queue; this is set up as a
    // loop but in fact it rarely does (under no
    // circumstances can we send more than one packet
    // each time this function executes).
    //
    while (TRUE) {

        p = Device->WaitingFindNames.Flink;
        if (p == &Device->WaitingFindNames) {
            NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);
            break;
        }

        Reserved = CONTAINING_RECORD (p, NB_SEND_RESERVED, WaitLinkage);

        if (Reserved->SendInProgress) {
            NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);
            break;
        }

        if (NB_GET_SR_FN_STATUS(Reserved) == FNStatusResponseUnique) {

            //
            // This was a find name for a unique name which got a
            // response but was not freed at the time (because
            // SendInProgress was still TRUE) so we free it now.
            //

            (VOID)RemoveHeadList (&Device->WaitingFindNames);
            ExInterlockedPushEntrySList(
                &Device->SendPacketList,
                &Reserved->PoolLinkage,
                &NbiGlobalPoolInterlock);
            --Device->FindNamePacketCount;

            //
            // It is OK to do this with the lock held because
            // it won't be the last one (we have the RIP_TIMER ref).
            //

            NbiDereferenceDevice (Device, DREF_FIND_NAME);
            continue;
        }

        if (((SHORT) (Device->FindNameTime - Reserved->u.SR_FN.SendTime)) < 0) {
            NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);
            break;
        }

        (VOID)RemoveHeadList (&Device->WaitingFindNames);


            //
            // Increment the counter and see if we have sent
            // all the frames we need to (we will age out
            // here if we got no response for a unique query,
            // or if we are doing a global name or broadcast
            // search). We also kill the query right now if
            // we have not found anything but down wan lines
            // to send it on.
            //

            if ((++Reserved->u.SR_FN.RetryCount > Device->BroadcastCount) ||
                ((Reserved->u.SR_FN.RetryCount > 1) && (!NB_GET_SR_FN_SENT_ON_UP_LINE(Reserved)))) {

#if DBG
                if (Reserved->u.SR_FN.RetryCount > Device->BroadcastCount) {
                    NB_DEBUG2 (CACHE, ("FindNameTimeout aging out %lx\n", Reserved));
                } else {
                    NB_DEBUG2 (CACHE, ("FindNameTimeout no active nets %lx\n", Reserved));
                }
#endif

                //
                // This packet is stale, clean it up and continue.
                //

                if (NB_GET_SR_FN_STATUS(Reserved) == FNStatusResponseGroup) {

                    CTEAssert (Reserved->u.SR_FN.NewCache != NULL);

                    //
                    // If this was a group name and we have a new
                    // cache entry that we have been building for it,
                    // then insert that in the queue and use it
                    // to succeed any pending connects. Because
                    // netbios find name requests can cause cache
                    // requests for group names to be queued even
                    // if we already have on in the database, we
                    // first scan for old ones and remove them.
                    //

                    if ( FindInNetbiosCacheTable( Device->NameCache,
                                                  Reserved->u.SR_FN.NetbiosName,
                                                  &FoundCacheName ) == STATUS_SUCCESS ) {

                        NB_DEBUG2 (CACHE, ("Found old group cache name <%.16s>\n", FoundCacheName->NetbiosName));

                        RemoveFromNetbiosCacheTable ( Device->NameCache, FoundCacheName );

                        if (--FoundCacheName->ReferenceCount == 0) {

                            NB_DEBUG2 (CACHE, ("Free replaced cache entry %lx\n", FoundCacheName));
                            NbiFreeMemory(
                                FoundCacheName,
                                sizeof(NETBIOS_CACHE) + ((FoundCacheName->NetworksAllocated-1) * sizeof(NETBIOS_NETWORK)),
                                MEMORY_CACHE,
                                "Free due to replacement");

                        }

                    }

                    Reserved->u.SR_FN.NewCache->TimeStamp = Device->CacheTimeStamp;

                    InsertInNetbiosCacheTable(
                        Device->NameCache,
                        Reserved->u.SR_FN.NewCache);

                    //
                    // Reference it for the moment since CacheHandlePending
                    // uses it after releasing the lock. CacheHandlePending
                    // will dereference it.
                    //

                    ++Reserved->u.SR_FN.NewCache->ReferenceCount;

                    //
                    // This call releases the locks
                    //

                    CacheHandlePending(
                        Device,
                        Reserved->u.SR_FN.NetbiosName,
                        NetbiosNameFound,
                        Reserved->u.SR_FN.NewCache
                        NB_LOCK_HANDLE_ARG(LockHandle));

                } else {

                    CTEAssert (Reserved->u.SR_FN.NewCache == NULL);

                    //
                    // Allocate an empty cache entry to record the
                    // fact that we could not find this name, unless
                    // there is already an entry for this name.
                    //

                    if ( FindInNetbiosCacheTable( Device->NameCache,
                                                  Reserved->u.SR_FN.NetbiosName,
                                                  &FoundCacheName ) == STATUS_SUCCESS ) {

                        NB_DEBUG2 (CACHE, ("Don't replace old group cache name with empty <%16.16s>\n", FoundCacheName->NetbiosName));
                    } else {

                        PNETBIOS_CACHE EmptyCache;

                        //
                        // Nothing found.
                        //

                        EmptyCache = NbiAllocateMemory (sizeof(NETBIOS_CACHE), MEMORY_CACHE, "Cache Entry");
                        if (EmptyCache != NULL) {

                            RtlZeroMemory (EmptyCache, sizeof(NETBIOS_CACHE));

                            NB_DEBUG2 (CACHE, ("Allocate new empty cache %lx for <%.16s>\n",
                                                    EmptyCache, Reserved->u.SR_FN.NetbiosName));

                            RtlCopyMemory (EmptyCache->NetbiosName, Reserved->u.SR_FN.NetbiosName, 16);
                            EmptyCache->Unique = TRUE;     // so we'll delete it if we see an add name
                            EmptyCache->ReferenceCount = 1;
                            EmptyCache->NetworksAllocated = 1;
                            EmptyCache->TimeStamp = Device->CacheTimeStamp;
                            EmptyCache->NetworksUsed = 0;
                            EmptyCache->FailedOnDownWan = (BOOLEAN)
                                !NB_GET_SR_FN_SENT_ON_UP_LINE(Reserved);

                            InsertInNetbiosCacheTable (
                                Device->NameCache,
                                EmptyCache);
                        }
                    }

                    //
                    // Fail all datagrams, etc. that were waiting for
                    // this route. This call releases the lock.
                    //

                    CacheHandlePending(
                        Device,
                        Reserved->u.SR_FN.NetbiosName,
                        NB_GET_SR_FN_SENT_ON_UP_LINE(Reserved) ?
                            NetbiosNameNotFoundNormal :
                            NetbiosNameNotFoundWanDown,
                        NULL
                        NB_LOCK_HANDLE_ARG(LockHandle));

                }

                ExInterlockedPushEntrySList(
                    &Device->SendPacketList,
                    &Reserved->PoolLinkage,
                    &NbiGlobalPoolInterlock);

                NB_SYNC_GET_LOCK (&Device->Lock, &LockHandle);

                --Device->FindNamePacketCount;
                NbiDereferenceDevice (Device, DREF_FIND_NAME);
                continue;
            }



        //
        // Send the packet out again. We first set the time so
        // it won't be sent again until the appropriate timeout.
        //

        Reserved->u.SR_FN.SendTime = (USHORT)(Device->FindNameTime + Device->FindNameTimeout);

        InsertTailList (&Device->WaitingFindNames, &Reserved->WaitLinkage);

        CTEAssert (Reserved->Identifier == IDENTIFIER_NB);
        CTEAssert (!Reserved->SendInProgress);
        Reserved->SendInProgress = TRUE;

        NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);

        //
        // If this is the first retry, we need to initialize the packet
        //
        if ( Reserved->u.SR_FN.RetryCount == 1 ) {
            //
            // Fill in the IPX header -- the default header has the broadcast
            // address on net 0 as the destination IPX address, which is
            // what we want.
            //

            Header = (NB_CONNECTIONLESS UNALIGNED *)(&Reserved->Header[Device->Bind.IncludedHeaderOffset]);
            RtlCopyMemory((PVOID)&Header->IpxHeader, &Device->ConnectionlessHeader, sizeof(IPX_HEADER));
            Header->IpxHeader.PacketLength[0] = (sizeof(IPX_HEADER)+sizeof(NB_NAME_FRAME)) / 256;
            Header->IpxHeader.PacketLength[1] = (sizeof(IPX_HEADER)+sizeof(NB_NAME_FRAME)) % 256;

            Header->IpxHeader.PacketType = (UCHAR)(Device->Internet ? 0x014 : 0x04);

            //
            // Now fill in the Netbios header.
            //

            RtlZeroMemory (Header->NameFrame.RoutingInfo, 32);
            Header->NameFrame.ConnectionControlFlag = 0x00;
//            Header->NameFrame.DataStreamType = NB_CMD_FIND_NAME;
            Header->NameFrame.DataStreamType2 = NB_CMD_FIND_NAME;
            Header->NameFrame.NameTypeFlag = 0x00;

            RtlCopyMemory(
                Header->NameFrame.Name,
                Reserved->u.SR_FN.NetbiosName,
                16);


        }
        //
        // Now submit the packet to IPX.
        //

        Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);

        NB_DEBUG2 (CACHE, ("FindNameTimeout sending %lx\n", Reserved));

        NdisAdjustBufferLength(NB_GET_NBHDR_BUFF(Packet), sizeof(IPX_HEADER) +
                         sizeof(NB_NAME_FRAME));
        if ((NdisStatus =
            (*Device->Bind.SendHandler)(
                &BroadcastTarget,
                Packet,
                sizeof(IPX_HEADER) + sizeof(NB_NAME_FRAME),
                sizeof(IPX_HEADER) + sizeof(NB_NAME_FRAME))) != STATUS_PENDING) {

            NbiSendComplete(
                Packet,
                NdisStatus);

        }


        break;

    }

    //
    // Since we did something this time, we restart the timer.
    //

    CTEStartTimer(
        &Device->FindNameTimer,
        FIND_NAME_GRANULARITY,
        FindNameTimeout,
        (PVOID)Device);

}   /* FindNameTimeout */


VOID
CacheHandlePending(
    IN PDEVICE Device,
    IN PUCHAR RemoteName,
    IN NETBIOS_NAME_RESULT Result,
    IN PNETBIOS_CACHE CacheName OPTIONAL
    IN NB_LOCK_HANDLE_PARAM(LockHandle)
    )

/*++

Routine Description:

    This routine cleans up pending datagrams and connects
    that were waiting for a route to be discovered to a
    given Netbios NAME. THIS ROUTINE IS CALLED WITH
    DEVICE->LOCK ACQUIRED AND RETURNS WITH IT RELEASED.

Arguments:

    Device - The device.

    RemoteName - The netbios name that was being searched for.

    Result - Indicates if the name was found, or not found due
        to no response or wan lines being down.

    CacheName - If Result is NetbiosNameFound, the cache entry for this name.
        This entry has been referenced and this routine will deref it.

    LockHandle - The handle used to acquire the lock.

Return Value:

    None.

--*/

{

    LIST_ENTRY DatagramList;
    LIST_ENTRY ConnectList;
    LIST_ENTRY AdapterStatusList;
    LIST_ENTRY NetbiosFindNameList;
    PNB_SEND_RESERVED Reserved;
    PNDIS_PACKET Packet;
    PLIST_ENTRY p;
    PREQUEST ConnectRequest, DatagramRequest, AdapterStatusRequest, NetbiosFindNameRequest;
    PCONNECTION Connection;
    PADDRESS_FILE AddressFile;
    TDI_ADDRESS_NETBIOS * RemoteAddress;
    CTELockHandle  CancelLH;
    NB_DEFINE_LOCK_HANDLE (LockHandle1)


    InitializeListHead (&DatagramList);
    InitializeListHead (&ConnectList);
    InitializeListHead (&AdapterStatusList);
    InitializeListHead (&NetbiosFindNameList);

    //
    // Put all connect requests on ConnectList. They will
    // be continued or failed later.
    //

    p = Device->WaitingConnects.Flink;

    while (p != &Device->WaitingConnects) {

        ConnectRequest = LIST_ENTRY_TO_REQUEST(p);
        Connection = (PCONNECTION)REQUEST_OPEN_CONTEXT(ConnectRequest);
        p = p->Flink;

        if (RtlEqualMemory (Connection->RemoteName, RemoteName, 16)) {

            RemoveEntryList (REQUEST_LINKAGE(ConnectRequest));
            InsertTailList (&ConnectList, REQUEST_LINKAGE(ConnectRequest));

            Connection->SubState = CONNECTION_SUBSTATE_C_W_ACK;
        }

    }


    //
    // Put all the datagrams on Datagram list. They will be
    // sent or failed later.
    //

    p = Device->WaitingDatagrams.Flink;

    while (p != &Device->WaitingDatagrams) {

        Reserved = CONTAINING_RECORD (p, NB_SEND_RESERVED, WaitLinkage);

        p = p->Flink;

        //
        // Check differently based on whether we were looking for
        // the broadcast address or not.
        //

        if (Reserved->u.SR_DG.RemoteName == (PVOID)-1) {
            if (!RtlEqualMemory (RemoteName, NetbiosBroadcastName, 16)) {
                continue;
            }
        } else {

            if (!RtlEqualMemory (RemoteName, Reserved->u.SR_DG.RemoteName->NetbiosName, 16)) {
                continue;
            }
        }

        RemoveEntryList (&Reserved->WaitLinkage);
        InsertTailList (&DatagramList, &Reserved->WaitLinkage);

        //
        // Reference this here with the lock held.
        //

        if (Result == NetbiosNameFound) {
            ++CacheName->ReferenceCount;
        }

    }


    //
    // Put all the adapter status requests on AdapterStatus
    // list. They will be sent or failed later.
    //

    p = Device->WaitingAdapterStatus.Flink;

    while (p != &Device->WaitingAdapterStatus) {

        AdapterStatusRequest = LIST_ENTRY_TO_REQUEST(p);

        p = p->Flink;

        RemoteAddress = (TDI_ADDRESS_NETBIOS *)REQUEST_INFORMATION(AdapterStatusRequest);

        if (!RtlEqualMemory(
                RemoteName,
                RemoteAddress->NetbiosName,
                16)) {
            continue;
        }

        RemoveEntryList (REQUEST_LINKAGE(AdapterStatusRequest));
        InsertTailList (&AdapterStatusList, REQUEST_LINKAGE(AdapterStatusRequest));

        //
        // Reference this here with the lock held.
        //

        if (Result == NetbiosNameFound) {
            ++CacheName->ReferenceCount;
        }

    }


    //
    // Put all the netbios find name requests on NetbiosFindName
    // list. They will be completed later.
    //

    p = Device->WaitingNetbiosFindName.Flink;

    while (p != &Device->WaitingNetbiosFindName) {

        NetbiosFindNameRequest = LIST_ENTRY_TO_REQUEST(p);

        p = p->Flink;

        RemoteAddress = (TDI_ADDRESS_NETBIOS *)REQUEST_INFORMATION(NetbiosFindNameRequest);

        if (!RtlEqualMemory(
                RemoteName,
                RemoteAddress->NetbiosName,
                16)) {
            continue;
        }

        RemoveEntryList (REQUEST_LINKAGE(NetbiosFindNameRequest));
        InsertTailList (&NetbiosFindNameList, REQUEST_LINKAGE(NetbiosFindNameRequest));

    }


    NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);


    //
    // Now that the lock is free, process all the packets on
    // the various lists.
    //

    for (p = ConnectList.Flink; p != &ConnectList; ) {

        ConnectRequest = LIST_ENTRY_TO_REQUEST(p);
        p = p->Flink;

        Connection = (PCONNECTION)REQUEST_OPEN_CONTEXT(ConnectRequest);

        NB_GET_CANCEL_LOCK( &CancelLH );
        NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle1);

        if ((Connection->State == CONNECTION_STATE_CONNECTING) &&
            (Connection->SubState != CONNECTION_SUBSTATE_C_DISCONN)) {

            if (Result == NetbiosNameFound) {

                NB_DEBUG2 (CONNECTION, ("Found queued connect %lx on %lx\n", ConnectRequest, Connection));

                //
                // Continue with the connection sequence.
                //

                Connection->SubState = CONNECTION_SUBSTATE_C_W_ROUTE;
            }


            if ((Result == NetbiosNameFound) && (!ConnectRequest->Cancel)) {

                IoSetCancelRoutine (ConnectRequest, NbiCancelConnectWaitResponse);

                NB_SYNC_SWAP_IRQL( CancelLH, LockHandle1 );
                NB_FREE_CANCEL_LOCK ( CancelLH );

                Connection->LocalTarget = CacheName->Networks[0].LocalTarget;
                RtlCopyMemory(&Connection->RemoteHeader.DestinationNetwork, &CacheName->FirstResponse, 12);
                NbiReferenceConnectionSync (Connection, CREF_FIND_ROUTE);

                NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle1);

                *(UNALIGNED ULONG *)Connection->FindRouteRequest.Network = CacheName->FirstResponse.NetworkAddress;
                RtlCopyMemory(Connection->FindRouteRequest.Node,CacheName->FirstResponse.NodeAddress,6);
                Connection->FindRouteRequest.Identifier = IDENTIFIER_NB;
                Connection->FindRouteRequest.Type = IPX_FIND_ROUTE_RIP_IF_NEEDED;

                //
                // When this completes, we will send the session init.
                // We don't call it if the client is for network 0,
                // instead just fake as if no route could be found
                // and we will use the local target we got here.
                //

                if (CacheName->FirstResponse.NetworkAddress != 0) {
                    (*Device->Bind.FindRouteHandler) (&Connection->FindRouteRequest);
                } else {
                    NbiFindRouteComplete( &Connection->FindRouteRequest, FALSE);
                }

            } else {
                BOOLEAN bAutodialAttempt = FALSE;

                if (ConnectRequest->Cancel) {
                    NB_DEBUG2 (CONNECTION, ("Cancelling connect %lx on %lx\n", ConnectRequest, Connection));
                }
                else
                {
                    NB_DEBUG2 (CONNECTION, ("Timing out connect %lx on %lx\n", ConnectRequest, Connection));
                }

                ASSERT (Connection->ConnectRequest == ConnectRequest);

#ifdef RASAUTODIAL
                if (fAcdLoadedG) {
                    CTELockHandle adirql;
                    BOOLEAN fEnabled;

                    //
                    // See if the automatic connection driver knows
                    // about this address before we search the
                    // network.  If it does, we return STATUS_PENDING,
                    // and we will come back here via NbfRetryTdiConnect().
                    //
                    CTEGetLock(&AcdDriverG.SpinLock, &adirql);
                    fEnabled = AcdDriverG.fEnabled;
                    CTEFreeLock(&AcdDriverG.SpinLock, adirql);
                    if (fEnabled && NbiAttemptAutoDial(
                                      Device,
                                      Connection,
                                      0,
                                      NbiRetryTdiConnect,
                                      ConnectRequest))
                    {
                        NB_SYNC_FREE_LOCK(&Connection->Lock, LockHandle1);
                        NB_FREE_CANCEL_LOCK(CancelLH);

                        bAutodialAttempt = TRUE;
                    }
                }
#endif // RASAUTODIAL

                if (!bAutodialAttempt) {
                    Connection->ConnectRequest = NULL;
                    Connection->SubState = CONNECTION_SUBSTATE_C_DISCONN;

                    NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle1);

                    IoSetCancelRoutine( ConnectRequest, (PDRIVER_CANCEL)NULL );
                    NB_FREE_CANCEL_LOCK( CancelLH );

                    REQUEST_STATUS(ConnectRequest) = STATUS_BAD_NETWORK_PATH;

                    NbiCompleteRequest(ConnectRequest);
                    NbiFreeRequest (Device, ConnectRequest);
                }

                NbiDereferenceConnection (Connection, CREF_CONNECT);

            }

        } else {

            CTEAssert (0);  // What happens to the IRP? Who completes it?

            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle1);
            NB_FREE_CANCEL_LOCK( CancelLH );

        }

        NbiDereferenceConnection (Connection, CREF_WAIT_CACHE);

    }


    for (p = DatagramList.Flink; p != &DatagramList; ) {

        Reserved = CONTAINING_RECORD (p, NB_SEND_RESERVED, WaitLinkage);
        p = p->Flink;

        if (Result == NetbiosNameFound) {

            NB_DEBUG2 (DATAGRAM, ("Found queued datagram %lx on %lx\n", Reserved->u.SR_DG.DatagramRequest, Reserved->u.SR_DG.AddressFile));

            Reserved->u.SR_DG.Cache = CacheName;
            Reserved->u.SR_DG.CurrentNetwork = 0;

            //
            // CacheName was referenced above.
            //

            Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);
            if ( REQUEST_NDIS_BUFFER( Reserved->u.SR_DG.DatagramRequest )) {
                NdisChainBufferAtBack (Packet, REQUEST_NDIS_BUFFER(Reserved->u.SR_DG.DatagramRequest));
            }

            NbiTransmitDatagram (Reserved);

        } else {

            //
            // Should we send it once as a broadcast
            // on net 0, just in case??
            //

            AddressFile = Reserved->u.SR_DG.AddressFile;
            DatagramRequest = Reserved->u.SR_DG.DatagramRequest;

            NB_DEBUG2 (DATAGRAM, ("Timing out datagram %lx on %lx\n", DatagramRequest, AddressFile));

            //
            // If the failure was due to a down wan line indicate
            // that, otherwise return success (so the browser won't
            // confuse this with a down wan line).
            //

            if (Result == NetbiosNameNotFoundWanDown) {
                REQUEST_STATUS(DatagramRequest) = STATUS_DEVICE_DOES_NOT_EXIST;
            } else {
                REQUEST_STATUS(DatagramRequest) = STATUS_BAD_NETWORK_PATH;
            }
            REQUEST_INFORMATION(DatagramRequest) = 0;

            NbiCompleteRequest(DatagramRequest);
            NbiFreeRequest (Device, DatagramRequest);

            NbiDereferenceAddressFile (AddressFile, AFREF_SEND_DGRAM);

            ExInterlockedPushEntrySList(
                &Device->SendPacketList,
                &Reserved->PoolLinkage,
                &NbiGlobalPoolInterlock);
        }

    }


    for (p = AdapterStatusList.Flink; p != &AdapterStatusList; ) {

        AdapterStatusRequest = LIST_ENTRY_TO_REQUEST(p);
        p = p->Flink;

        if (Result == NetbiosNameFound) {

            NB_DEBUG2 (QUERY, ("Found queued AdapterStatus %lx\n", AdapterStatusRequest));

            //
            // Continue with the AdapterStatus sequence. We put
            // it in ActiveAdapterStatus, it will either get
            // completed when a response is received or timed
            // out by the long timeout.
            //

            REQUEST_STATUSPTR(AdapterStatusRequest) = (PVOID)CacheName;

            //
            // CacheName was referenced above.
            //

            REQUEST_INFORMATION (AdapterStatusRequest) = 0;

            NB_INSERT_TAIL_LIST(
                &Device->ActiveAdapterStatus,
                REQUEST_LINKAGE (AdapterStatusRequest),
                &Device->Lock);

            NbiSendStatusQuery (AdapterStatusRequest);

        } else {

            NB_DEBUG2 (QUERY, ("Timing out AdapterStatus %lx\n", AdapterStatusRequest));

            REQUEST_STATUS(AdapterStatusRequest) = STATUS_IO_TIMEOUT;

            NbiCompleteRequest(AdapterStatusRequest);
            NbiFreeRequest (Device, AdapterStatusRequest);

            NbiDereferenceDevice (Device, DREF_STATUS_QUERY);

        }

    }


    for (p = NetbiosFindNameList.Flink; p != &NetbiosFindNameList; ) {

        NetbiosFindNameRequest = LIST_ENTRY_TO_REQUEST(p);
        p = p->Flink;

        //
        // In fact there is not much difference between success or
        // failure, since in the successful case the information
        // will already have been written to the buffer. Just
        // complete the request with the appropriate status,
        // which will already be stored in the request.
        //

        if (Result == NetbiosNameFound) {

            if (CacheName->Unique) {

                NB_DEBUG2 (QUERY, ("Found queued unique NetbiosFindName %lx\n", NetbiosFindNameRequest));

            } else {

                NB_DEBUG2 (QUERY, ("Found queued group NetbiosFindName %lx\n", NetbiosFindNameRequest));

            }

        } else {

            CTEAssert (REQUEST_STATUS(NetbiosFindNameRequest) == STATUS_IO_TIMEOUT);
            NB_DEBUG2 (QUERY, ("Timed out NetbiosFindName %lx\n", NetbiosFindNameRequest));

        }

        //
        // This sets REQUEST_INFORMATION(Request) to the correct value.
        //

        NbiSetNetbiosFindNameInformation (NetbiosFindNameRequest);

        NbiCompleteRequest(NetbiosFindNameRequest);
        NbiFreeRequest (Device, NetbiosFindNameRequest);

        NbiDereferenceDevice (Device, DREF_NB_FIND_NAME);

    }


    //
    // We referenced this temporarily so we could use it in here,
    // deref and check if we need to delete it.
    //

    if (Result == NetbiosNameFound) {

        NB_SYNC_GET_LOCK (&Device->Lock, &LockHandle1);

        if (--CacheName->ReferenceCount == 0) {

            NB_DEBUG2 (CACHE, ("Free newly allocated cache entry %lx\n", CacheName));
            NbiFreeMemory(
                CacheName,
                sizeof(NETBIOS_CACHE) + ((CacheName->NetworksAllocated-1) * sizeof(NETBIOS_NETWORK)),
                MEMORY_CACHE,
                "Free in CacheHandlePending");

        }

        NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle1);

    }

}   /* CacheHandlePending */


VOID
NbiProcessNameRecognized(
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR PacketBuffer,
    IN UINT PacketSize
    )

/*++

Routine Description:

    This routine handles NB_CMD_NAME_RECOGNIZED frames.

Arguments:

    RemoteAddress - The local target this packet was received from.

    MacOptions - The MAC options for the underlying NDIS binding.

    LookaheadBuffer - The packet data, starting at the IPX
        header.

    PacketSize - The total length of the packet, starting at the
        IPX header.

Return Value:

    None.

--*/

{
    PLIST_ENTRY p;
    PDEVICE Device = NbiDevice;
    PNETBIOS_CACHE NameCache;
    PREQUEST NetbiosFindNameRequest;
    PNB_SEND_RESERVED Reserved;
    TDI_ADDRESS_NETBIOS * RemoteNetbiosAddress;
    NB_CONNECTIONLESS UNALIGNED * Connectionless =
                        (NB_CONNECTIONLESS UNALIGNED *)PacketBuffer;
    NB_DEFINE_LOCK_HANDLE(LockHandle)


#if 0
    //
    // We should handle responses from network 0
    // differently -- if they are for a group name, we should
    // keep them around but only until we get a non-zero
    // response from the same card.
    //

    if (*(UNALIGNED ULONG *)(Connectionless->IpxHeader.SourceNetwork) == 0) {
        return;
    }
#endif


    //
    // We need to scan our queue of pending find name packets
    // to see if someone is waiting for this name.
    //

    NB_SYNC_GET_LOCK (&Device->Lock, &LockHandle);

    for (p = Device->WaitingFindNames.Flink;
         p != &Device->WaitingFindNames;
         p = p->Flink) {

        Reserved = CONTAINING_RECORD (p, NB_SEND_RESERVED, WaitLinkage);

        //
        // Find names which have already found unique names are
        // "dead", waiting for FindNameTimeout to remove them,
        // and should be ignored when scanning the list.
        //

        if (NB_GET_SR_FN_STATUS(Reserved) == FNStatusResponseUnique) {

            continue;
        }

        if (RtlEqualMemory (Reserved->u.SR_FN.NetbiosName, Connectionless->NameFrame.Name, 16)) {
            break;
        }
    }

    if (p == &Device->WaitingFindNames)
    {
        if ((FindInNetbiosCacheTable (Device->NameCache,
                                      Connectionless->NameFrame.Name,
                                      &NameCache ) == STATUS_SUCCESS) &&
            (NameCache->NetworksUsed == 0))
        {
            //
            // Update our information about this network if needed.
            //
            NameCache->Unique = (BOOLEAN)((Connectionless->NameFrame.NameTypeFlag & NB_NAME_GROUP) == 0);
            if (RtlEqualMemory (Connectionless->NameFrame.Name, NetbiosBroadcastName, 16))
            {
                NameCache->Unique = FALSE;
            }

            RtlCopyMemory (&NameCache->FirstResponse, Connectionless->IpxHeader.SourceNetwork, 12);
            NameCache->NetworksUsed = 1;
            NameCache->Networks[0].Network = *(UNALIGNED ULONG*)(Connectionless->IpxHeader.SourceNetwork);

            //
            // If this packet was not routed to us and is for a group name,
            // rather than use whatever local target it happened to come
            // from we set it up so that it is broadcast on that net.
            //

            if ((RtlEqualMemory (RemoteAddress->MacAddress, Connectionless->IpxHeader.SourceNode, 6)) &&
                (!NameCache->Unique))
            {
                NameCache->Networks[0].LocalTarget.NicHandle = RemoteAddress->NicHandle;
                RtlCopyMemory (NameCache->Networks[0].LocalTarget.MacAddress, BroadcastAddress, 6);
                RtlCopyMemory (NameCache->FirstResponse.NodeAddress, BroadcastAddress, 6);
            }
            else
            {
                NameCache->Networks[0].LocalTarget = *RemoteAddress;
            }
        }

        NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);
        return;
    }

    //
    // Scan for any netbios find name requests on the queue, and
    // inform them about this remote. We need to do this on every
    // response because group names need every computer recorded,
    // but the normal cache only includes one entry per network.
    //

    for (p = Device->WaitingNetbiosFindName.Flink;
         p != &Device->WaitingNetbiosFindName;
         p = p->Flink) {

        NetbiosFindNameRequest = LIST_ENTRY_TO_REQUEST(p);

        RemoteNetbiosAddress = (TDI_ADDRESS_NETBIOS *)REQUEST_INFORMATION(NetbiosFindNameRequest);

        if (!RtlEqualMemory(
                Connectionless->NameFrame.Name,
                RemoteNetbiosAddress->NetbiosName,
                16)) {
            continue;
        }

        //
        // This will update the request status if needed.
        //

        NbiUpdateNetbiosFindName(
            NetbiosFindNameRequest,
#if     defined(_PNP_POWER)
            &RemoteAddress->NicHandle,
#else
            RemoteAddress->NicId,
#endif  _PNP_POWER
            (TDI_ADDRESS_IPX UNALIGNED *)Connectionless->IpxHeader.SourceNetwork,
            (BOOLEAN)((Connectionless->NameFrame.NameTypeFlag & NB_NAME_GROUP) == 0));

    }


    //
    // See what is up with this pending find name packet.
    //

    if (Reserved->u.SR_FN.NewCache == NULL) {
        //
        // This is the first response we have received, so we
        // allocate the initial entry with room for a single
        // entry.
        //

        NameCache = NbiAllocateMemory (sizeof(NETBIOS_CACHE), MEMORY_CACHE, "Cache Entry");
        if (NameCache == NULL) {
            NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);
            return;
        }

        NB_DEBUG2 (CACHE, ("Alloc new cache %lx for <%.16s>, net %lx\n",
                                NameCache, Reserved->u.SR_FN.NetbiosName,
                                *(UNALIGNED ULONG *)(Connectionless->IpxHeader.SourceNetwork)));

        RtlCopyMemory (NameCache->NetbiosName, Connectionless->NameFrame.Name, 16);
        NameCache->Unique = (BOOLEAN)((Connectionless->NameFrame.NameTypeFlag & NB_NAME_GROUP) == 0);
        NameCache->ReferenceCount = 1;
        RtlCopyMemory (&NameCache->FirstResponse, Connectionless->IpxHeader.SourceNetwork, 12);
        NameCache->NetworksAllocated = 1;
        NameCache->NetworksUsed = 1;
        NameCache->Networks[0].Network = *(UNALIGNED ULONG *)(Connectionless->IpxHeader.SourceNetwork);

        if (RtlEqualMemory (Connectionless->NameFrame.Name, NetbiosBroadcastName, 16)) {

            NB_SET_SR_FN_STATUS (Reserved, FNStatusResponseGroup);
            NameCache->Unique = FALSE;

        } else {

            NB_SET_SR_FN_STATUS(
                Reserved,
                NameCache->Unique ? FNStatusResponseUnique : FNStatusResponseGroup);

        }

        Reserved->u.SR_FN.NewCache = NameCache;

        //
        // If this packet was not routed to us and is for a group name,
        // rather than use whatever local target it happened to come
        // from we set it up so that it is broadcast on that net.
        //

        if ((RtlEqualMemory (RemoteAddress->MacAddress, Connectionless->IpxHeader.SourceNode, 6)) &&
            (NB_GET_SR_FN_STATUS(Reserved) == FNStatusResponseGroup)) {
#if     defined(_PNP_POWER)
            NameCache->Networks[0].LocalTarget.NicHandle = RemoteAddress->NicHandle;
#else
            NameCache->Networks[0].LocalTarget.NicId = RemoteAddress->NicId;
#endif  _PNP_POWER
            RtlCopyMemory (NameCache->Networks[0].LocalTarget.MacAddress, BroadcastAddress, 6);
            RtlCopyMemory (NameCache->FirstResponse.NodeAddress, BroadcastAddress, 6);
        } else {
            NameCache->Networks[0].LocalTarget = *RemoteAddress;
        }

        if (NB_GET_SR_FN_STATUS(Reserved) == FNStatusResponseUnique) {

            //
            // Complete pending requests now, since it is a unique
            // name we have all the information we will get.
            //

            NameCache->TimeStamp = Device->CacheTimeStamp;

            InsertInNetbiosCacheTable(
                Device->NameCache,
                NameCache);

            //
            // Reference it since CacheHandlePending uses it
            // with the lock released. CacheHandlePending
            // will dereference it.
            //

            ++NameCache->ReferenceCount;

            //
            // This call releases the lock.
            //

            CacheHandlePending(
                Device,
                Reserved->u.SR_FN.NetbiosName,
                NetbiosNameFound,
                NameCache
                NB_LOCK_HANDLE_ARG(LockHandle));

        } else {

            NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);

        }

    } else {

        //
        // We already have a response to this frame.
        //

        if (NB_GET_SR_FN_STATUS(Reserved) == FNStatusResponseUnique) {

            //
            // Should we check that the response is also
            // unique? Not much to do since I don't know of an
            // equivalent to the netbeui NAME_IN_CONFLICT.
            //

        } else {

            //
            // This is a group name.
            //

            if (Connectionless->NameFrame.NameTypeFlag & NB_NAME_GROUP) {

                //
                // Update our information about this network if needed.
                // This may free the existing cache and allocate a new one.
                //

                Reserved->u.SR_FN.NewCache =
                    CacheUpdateNameCache(
                        Reserved->u.SR_FN.NewCache,
                        RemoteAddress,
                        (TDI_ADDRESS_IPX UNALIGNED *)
                            Connectionless->IpxHeader.SourceNetwork,
                        FALSE);

            } else {

                //
                // Hmmm... This respondent thinks it is a unique name
                // but we think it is group, should we do something?
                //

            }
        }

        NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);

    }

}   /* NbiProcessNameRecognized */


PNETBIOS_CACHE
CacheUpdateNameCache(
    IN PNETBIOS_CACHE NameCache,
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN TDI_ADDRESS_IPX UNALIGNED * SourceAddress,
    IN BOOLEAN ModifyQueue
    )

/*++

Routine Description:

    This routine is called to update a netbios cache entry
    with a new network, if it is does not already contain
    information about the network. It is called when a frame
    is received advertising the appropriate cache entry, which
    is either a group name or the broadcast name.

    THIS ROUTINE IS CALLED WITH THE DEVICE LOCK HELD AND RETURNS
    WITH IT HELD.

Arguments:

    NameCache - The name cache entry to update.

    RemoteAddress - The remote address on which a frame was received.

    IpxAddress - The source IPX address of the frame.

    ModifyQueue - TRUE if we should update the queue which this
        cache entry is in, if we reallocate it.

Return Value:

    The netbios cache entry, either the original or a reallocated one.

--*/

{

    PDEVICE Device = NbiDevice;
    USHORT NewNetworks;
    PNETBIOS_CACHE NewNameCache;
    PLIST_ENTRY OldPrevious;
    UINT i;

    //
    // See if we already know about this network.
    //

    for (i = 0; i < NameCache->NetworksUsed; i++) {
        if (NameCache->Networks[i].Network == SourceAddress->NetworkAddress) {
            return NameCache;
        }
    }

    //
    // We need to add information about this network
    // to the name cache entry. If we have to allocate
    // a new one we do that.
    //

    NB_DEBUG2 (CACHE, ("Got new net %lx for <%.16s>\n",
                SourceAddress->NetworkAddress,
                NameCache->NetbiosName));

    if (NameCache->NetworksUsed == NameCache->NetworksAllocated) {

        //
        // We double the number of entries allocated until
        // we hit 16, then add 8 at a time.
        //

        if (NameCache->NetworksAllocated < 16) {
            NewNetworks = NameCache->NetworksAllocated * 2;
        } else {
            NewNetworks = NameCache->NetworksAllocated + 8;
        }


        NewNameCache = NbiAllocateMemory(
            sizeof(NETBIOS_CACHE) + ((NewNetworks-1) * sizeof(NETBIOS_NETWORK)),
            MEMORY_CACHE,
            "Enlarge cache entry");

        if (NewNameCache == NULL) {
            return NameCache;
        }

        NB_DEBUG2 (CACHE, ("Expand cache %lx to %lx for <%.16s>\n",
                NameCache, NewNameCache, NameCache->NetbiosName));

        //
        // Copy the new current data to the new one.
        //

        RtlCopyMemory(
            NewNameCache,
            NameCache,
            sizeof(NETBIOS_CACHE) + ((NameCache->NetworksAllocated-1) * sizeof(NETBIOS_NETWORK)));

        NewNameCache->NetworksAllocated = NewNetworks;
        NewNameCache->ReferenceCount = 1;

        if (ModifyQueue) {

            //
            // Insert at the same place as the old one. The time
            // stamp is the same as the old one.
            //


            ReinsertInNetbiosCacheTable( Device->NameCache, NameCache, NewNameCache );

        }

        if (--NameCache->ReferenceCount == 0) {

            NB_DEBUG2 (CACHE, ("Free replaced cache entry %lx\n", NameCache));
            NbiFreeMemory(
                NameCache,
                sizeof(NETBIOS_CACHE) + ((NameCache->NetworksAllocated-1) * sizeof(NETBIOS_NETWORK)),
                MEMORY_CACHE,
                "Enlarge existing");

        }

        NameCache = NewNameCache;

    }

    NameCache->Networks[NameCache->NetworksUsed].Network =
                                        SourceAddress->NetworkAddress;

    //
    // If this packet was not routed to us, then store the local
    // target for a correct broadcast.
    //

    if (RtlEqualMemory (RemoteAddress->MacAddress, SourceAddress->NodeAddress, 6)) {
#if     defined(_PNP_POWER)
        NameCache->Networks[NameCache->NetworksUsed].LocalTarget.NicHandle = RemoteAddress->NicHandle;
#else
        NameCache->Networks[NameCache->NetworksUsed].LocalTarget.NicId = RemoteAddress->NicId;
#endif  _PNP_POWER
        RtlCopyMemory (NameCache->Networks[NameCache->NetworksUsed].LocalTarget.MacAddress, BroadcastAddress, 6);
    } else {
        NameCache->Networks[NameCache->NetworksUsed].LocalTarget = *RemoteAddress;
    }

    ++NameCache->NetworksUsed;
    return NameCache;

}   /* CacheUpdateNameCache */


VOID
CacheUpdateFromAddName(
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN NB_CONNECTIONLESS UNALIGNED * Connectionless,
    IN BOOLEAN LocalFrame
    )

/*++

Routine Description:

    This routine is called when an add name frame is received.
    If it is for a group name it checks if our cache entry for
    that group name needs to be updated to include a new network;
    for all frames it checks if our broadcast cache entry needs
    to be updated to include a new network.

Arguments:

    RemoteAddress - The address the frame was received from.

    Connectionless - The header of the received add name.

    LocalFrame - TRUE if the frame was sent locally.

Return Value:

    None.

--*/

{
    PUCHAR NetbiosName;
    PNETBIOS_CACHE NameCache;
    PLIST_ENTRY p;
    PDEVICE Device = NbiDevice;
    NB_DEFINE_LOCK_HANDLE (LockHandle)


    NetbiosName = (PUCHAR)Connectionless->NameFrame.Name;

    //
    // First look up the broadcast name.
    //

    NB_SYNC_GET_LOCK (&Device->Lock, &LockHandle);

    if (!LocalFrame) {

        if ( FindInNetbiosCacheTable( Device->NameCache,
                                      NetbiosBroadcastName,
                                      &NameCache ) == STATUS_SUCCESS ) {
            //
            // This will reallocate a cache entry and update the
            // queue if necessary.
            //

            (VOID)CacheUpdateNameCache(
                      NameCache,
                      RemoteAddress,
                      (TDI_ADDRESS_IPX UNALIGNED *)(Connectionless->IpxHeader.SourceNetwork),
                      TRUE);
        }

    }


    //
    // Now see if our database needs to be updated based on this.
    //

    if ( FindInNetbiosCacheTable( Device->NameCache,
                                  Connectionless->NameFrame.Name,
                                  &NameCache ) == STATUS_SUCCESS ) {


            if (!NameCache->Unique) {

                if (!LocalFrame) {

                    //
                    // This will reallocate a cache entry and update the
                    // queue if necessary.
                    //

                    (VOID)CacheUpdateNameCache(
                              NameCache,
                              RemoteAddress,
                              (TDI_ADDRESS_IPX UNALIGNED *)(Connectionless->IpxHeader.SourceNetwork),
                              TRUE);

                }

            } else {

                //
                // To be safe, delete any unique names we get add
                // names for (we will requery next time we need it).
                //

                RemoveFromNetbiosCacheTable ( Device->NameCache, NameCache );

                if (--NameCache->ReferenceCount == 0) {

                    NB_DEBUG2 (CACHE, ("Free add named cache entry %lx\n", NameCache));
                    NbiFreeMemory(
                        NameCache,
                        sizeof(NETBIOS_CACHE) + ((NameCache->NetworksAllocated-1) * sizeof(NETBIOS_NETWORK)),
                        MEMORY_CACHE,
                        "Enlarge existing");

                }

            }

    }

    NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);

}   /* CacheUpdateFromAddName */


VOID
NbiProcessDeleteName(
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR PacketBuffer,
    IN UINT PacketSize
    )

/*++

Routine Description:

    This routine handles NB_CMD_DELETE_NAME frames.

Arguments:

    RemoteAddress - The local target this packet was received from.

    MacOptions - The MAC options for the underlying NDIS binding.

    LookaheadBuffer - The packet data, starting at the IPX
        header.

    PacketSize - The total length of the packet, starting at the
        IPX header.

Return Value:

    None.

--*/

{
    NB_CONNECTIONLESS UNALIGNED * Connectionless =
                        (NB_CONNECTIONLESS UNALIGNED *)PacketBuffer;
    PUCHAR NetbiosName;
    PNETBIOS_CACHE CacheName;
    PDEVICE Device = NbiDevice;
    NB_DEFINE_LOCK_HANDLE (LockHandle)


    if (PacketSize != sizeof(IPX_HEADER) + sizeof(NB_NAME_FRAME)) {
        return;
    }

    //
    // We want to update our netbios cache to reflect the
    // fact that this name is no longer valid.
    //

    NetbiosName = (PUCHAR)Connectionless->NameFrame.Name;

    NB_SYNC_GET_LOCK (&Device->Lock, &LockHandle);

    if ( FindInNetbiosCacheTable( Device->NameCache,
                                  NetbiosName,
                                  &CacheName ) == STATUS_SUCCESS ) {

        //
        // We don't track group names since we don't know if
        // this is the last person that owns it. We also drop
        // the frame if does not come from the person we think
        // owns this name.
        //

        if ((!CacheName->Unique) ||
            (CacheName->NetworksUsed == 0) ||
            (!RtlEqualMemory (&CacheName->FirstResponse, Connectionless->IpxHeader.SourceNetwork, 12))) {
            NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);
            return;
        }

        NB_DEBUG2 (CACHE, ("Found cache name to delete <%.16s>\n", NetbiosName));

    }else {
        NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);
        return;
    }


    //
    // We have a cache entry, take it out of the list. If no
    // one else is using it, delete it; if not, they will delete
    // it when they are done.
    //


    RemoveFromNetbiosCacheTable ( Device->NameCache, CacheName);

    if (--CacheName->ReferenceCount == 0) {

        NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);

        NB_DEBUG2 (CACHE, ("Free delete name cache entry %lx\n", CacheName));
        NbiFreeMemory(
            CacheName,
            sizeof(NETBIOS_CACHE) + ((CacheName->NetworksAllocated-1) * sizeof(NETBIOS_NETWORK)),
            MEMORY_CACHE,
            "Name deleted");

    } else {

        NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);

    }

}   /* NbiProcessDeleteName */

VOID
InsertInNetbiosCacheTable(
    IN PNETBIOS_CACHE_TABLE CacheTable,
    IN PNETBIOS_CACHE       CacheEntry
    )

/*++

Routine Description:

    This routine inserts a new cache entry in the hash table

    THIS ROUTINE IS CALLED WITH THE DEVICE LOCK HELD AND RETURNS
    WITH THE LOCK HELD.


Arguments:

    CacheTable - The pointer of the Hash Table.

    CacheEntry - Entry to be inserted.

Return Value:

    None

--*/

{
    USHORT  HashIndex;

    //
    // Keep a threshold of how many entries do we keep in the table.
    // If it crosses the threshold, just remove the oldest entry
    //
    if ( CacheTable->CurrentEntries >= CacheTable->MaxHashIndex * NB_MAX_AVG_CACHE_ENTRIES_PER_BUCKET ) {
        PNETBIOS_CACHE  OldestCacheEntry = NULL;
        PNETBIOS_CACHE  NextEntry;
        PLIST_ENTRY p;

        for ( HashIndex = 0; HashIndex < CacheTable->MaxHashIndex; HashIndex++) {
            if ( (p = CacheTable->Bucket[ HashIndex ].Blink ) != &CacheTable->Bucket[ HashIndex ] ) {
                NextEntry = CONTAINING_RECORD (p, NETBIOS_CACHE, Linkage);

                if ( OldestCacheEntry ) {
                    if ( NextEntry->TimeStamp < OldestCacheEntry->TimeStamp ) {
                        OldestCacheEntry = NextEntry;
                    }
                } else {
                    OldestCacheEntry = NextEntry;
                }
            }
        }

        CTEAssert( OldestCacheEntry );

        NB_DEBUG2 (CACHE, ("Threshold exceeded, removing oldest cache entry %lx\n", OldestCacheEntry));
        RemoveEntryList (&OldestCacheEntry->Linkage);
        CacheTable->CurrentEntries--;

        if (--OldestCacheEntry->ReferenceCount == 0) {

            NB_DEBUG2 (CACHE, ("Freed cache entry %lx\n", OldestCacheEntry));

            NbiFreeMemory(
                OldestCacheEntry,
                sizeof(NETBIOS_CACHE) + ((OldestCacheEntry->NetworksAllocated-1) * sizeof(NETBIOS_NETWORK)),
                MEMORY_CACHE,
                "Aged out");

        }

    }
    HashIndex = ( ( CacheEntry->NetbiosName[0] & 0x0f ) << 4 ) + ( CacheEntry->NetbiosName[1] & 0x0f );
    HashIndex = HashIndex % CacheTable->MaxHashIndex;

    InsertHeadList( &CacheTable->Bucket[HashIndex], &CacheEntry->Linkage );
    CacheTable->CurrentEntries++;
} /* InsertInNetbiosCacheTable */


__inline
VOID
ReinsertInNetbiosCacheTable(
    IN PNETBIOS_CACHE_TABLE CacheTable,
    IN PNETBIOS_CACHE       OldEntry,
    IN PNETBIOS_CACHE       NewEntry
    )

/*++

Routine Description:

    This routine inserts a new cache entry at the same place where
    the old entry was.

    THIS ROUTINE IS CALLED WITH THE DEVICE LOCK HELD AND RETURNS
    WITH THE LOCK HELD.


Arguments:

    CacheTable - The pointer of the Hash Table.

    CacheEntry - Entry to be inserted.

Return Value:

    None

--*/

{
    PLIST_ENTRY OldPrevious;

    OldPrevious = OldEntry->Linkage.Blink;
    RemoveEntryList (&OldEntry->Linkage);
    InsertHeadList (OldPrevious, &NewEntry->Linkage);
} /* ReinsertInNetbiosCacheTable */

__inline
VOID
RemoveFromNetbiosCacheTable(
    IN PNETBIOS_CACHE_TABLE CacheTable,
    IN PNETBIOS_CACHE       CacheEntry
    )

/*++

Routine Description:

    This routine removes an entry from the cache table.

Arguments:

    CacheTable - The pointer of the Hash Table.

    CacheEntry - Entry to be removed.

    THIS ROUTINE IS CALLED WITH THE DEVICE LOCK HELD AND RETURNS
    WITH THE LOCK HELD.

Return Value:

    None.
--*/

{
    RemoveEntryList( &CacheEntry->Linkage );
    CacheTable->CurrentEntries--;
} /* RemoveFromNetbiosCacheTable */



VOID
FlushOldFromNetbiosCacheTable(
    IN PNETBIOS_CACHE_TABLE CacheTable,
    IN USHORT               AgeLimit
    )

/*++

Routine Description:

    This routine removes all the old entries from the hash table.

Arguments:

    CacheTable - The pointer of the Hash Table.

    AgeLimit   - All the entries older than AgeLimit will be removed.

    THIS ROUTINE IS CALLED WITH THE DEVICE LOCK HELD AND RETURNS
    WITH THE LOCK HELD.

Return Value:

    None.
--*/

{
    USHORT  HashIndex;
    PLIST_ENTRY p;
    PNETBIOS_CACHE  CacheName;

    //
    // run the hash table looking for old entries. Since new entries
    // are stored at the head and all entries are time stamped when
    // they are inserted, we scan backwards and stop once we find
    // an entry which does not need to be aged.
    // we repeat this for each bucket.

    for ( HashIndex = 0; HashIndex < CacheTable->MaxHashIndex; HashIndex++) {
        for (p = CacheTable->Bucket[ HashIndex ].Blink;
             p != &CacheTable->Bucket[ HashIndex ];
             ) {

            CacheName = CONTAINING_RECORD (p, NETBIOS_CACHE, Linkage);
            p = p->Blink;

            //
            // see if any entries have been around for more than agelimit
            //

            if ((USHORT)(NbiDevice->CacheTimeStamp - CacheName->TimeStamp) >= AgeLimit ) {

                RemoveEntryList (&CacheName->Linkage);
                CacheTable->CurrentEntries--;

                if (--CacheName->ReferenceCount == 0) {

                    NB_DEBUG2 (CACHE, ("Aging out name cache entry %lx\n", CacheName));

                    NbiFreeMemory(
                        CacheName,
                        sizeof(NETBIOS_CACHE) + ((CacheName->NetworksAllocated-1) * sizeof(NETBIOS_NETWORK)),
                        MEMORY_CACHE,
                        "Aged out");

                }

            } else {

                break;

            }
        }   // for loop
    }   // for loop
} /* FlushOldFromNetbiosCacheTable */

VOID
FlushFailedNetbiosCacheEntries(
    IN PNETBIOS_CACHE_TABLE CacheTable
    )

/*++

Routine Description:

    This routine removes all the failed entries from the hash table.

Arguments:

    CacheTable - The pointer of the Hash Table.

    THIS ROUTINE IS CALLED WITH THE DEVICE LOCK HELD AND RETURNS
    WITH THE LOCK HELD.

Return Value:

    None.
--*/

{
    USHORT  HashIndex;
    PLIST_ENTRY p;
    PNETBIOS_CACHE  CacheName;

    if (NULL == CacheTable) {
        return;
    }

    //
    // run the hash table looking for old entries. Since new entries
    // are stored at the head and all entries are time stamped when
    // they are inserted, we scan backwards and stop once we find
    // an entry which does not need to be aged.
    // we repeat this for each bucket.

    for ( HashIndex = 0; HashIndex < CacheTable->MaxHashIndex; HashIndex++) {
        for (p = CacheTable->Bucket[ HashIndex ].Blink;
             p != &CacheTable->Bucket[ HashIndex ];
             ) {

            CacheName = CONTAINING_RECORD (p, NETBIOS_CACHE, Linkage);
            p = p->Blink;

            //
            // flush all the failed cache entries.
            // We do this when a new adapter appears, and there's a possiblity that
            // the failed entries might succeed now on the new adapter.
            //

            if (CacheName->NetworksUsed == 0) {
                RemoveEntryList (&CacheName->Linkage);
                CacheTable->CurrentEntries--;
                CTEAssert( CacheName->ReferenceCount == 1 );
                CTEAssert( CacheName->NetworksAllocated == 1 );

                NB_DEBUG2 (CACHE, ("Flushing out failed name cache entry %lx\n", CacheName));

                NbiFreeMemory(
                    CacheName,
                    sizeof(NETBIOS_CACHE),
                    MEMORY_CACHE,
                    "Aged out");

            }
        }   // for loop
    }   // for loop
} /* FlushFailedNetbiosCacheEntries */

VOID
RemoveInvalidRoutesFromNetbiosCacheTable(
    IN PNETBIOS_CACHE_TABLE CacheTable,
    IN NIC_HANDLE UNALIGNED *InvalidNicHandle
    )

/*++

Routine Description:

    This routine removes all invalid route entries from the hash table.
    Routes become invalid when the binding is deleted in Ipx due to PnP
    event.

Arguments:

    CacheTable - The pointer of the Hash Table.

    InvalidRouteNicId - NicId of the invalid routes.

    THIS ROUTINE IS CALLED WITH THE DEVICE LOCK HELD AND RETURNS
    WITH THE LOCK HELD.

Return Value:

    None.
--*/

{
    PLIST_ENTRY     p;
    PNETBIOS_CACHE  CacheName;
    USHORT          i,j,NetworksRemoved;
    USHORT          HashIndex;
    PDEVICE         Device  =   NbiDevice;

    //
    // Flush all the cache entries that are using this NicId in the local
    // target.
    //

    for ( HashIndex = 0; HashIndex < Device->NameCache->MaxHashIndex; HashIndex++) {
        for (p = Device->NameCache->Bucket[ HashIndex ].Flink;
             p != &Device->NameCache->Bucket[ HashIndex ];
             ) {

            CacheName = CONTAINING_RECORD (p, NETBIOS_CACHE, Linkage);
            p = p->Flink;


            //
            // Remove each of those routes which is using this NicId.
            // if no routes left, then flush the cache entry also.
            // ( unique names have only one route anyways )
            //
            for ( i = 0, NetworksRemoved = 0; i < CacheName->NetworksUsed; i++ ) {
                if ( CacheName->Networks[i].LocalTarget.NicHandle.NicId == InvalidNicHandle->NicId ) {
                    CTEAssert( RtlEqualMemory( &CacheName->Networks[i].LocalTarget.NicHandle, InvalidNicHandle, sizeof(NIC_HANDLE)));
                    for ( j = i+1; j < CacheName->NetworksUsed; j++ ) {
                        CacheName->Networks[j-1] = CacheName->Networks[j];
                    }
                    NetworksRemoved++;
                } else if ( CacheName->Networks[i].LocalTarget.NicHandle.NicId > InvalidNicHandle->NicId ) {
                    CacheName->Networks[i].LocalTarget.NicHandle.NicId--;
                }
            }
            CTEAssert( NetworksRemoved <= CacheName->NetworksUsed );
            if ( ! ( CacheName->NetworksUsed -= NetworksRemoved ) ) {
                RemoveEntryList (&CacheName->Linkage);
                CacheTable->CurrentEntries--;

                NB_DEBUG2 (CACHE, ("Removed cache entry %lx bcoz route(NicId %d) deleted\n", CacheName, InvalidNicHandle->NicId ));
                if (--CacheName->ReferenceCount == 0) {

                    NB_DEBUG2 (CACHE, ("Freed name cache entry %lx\n", CacheName));

                    NbiFreeMemory(
                        CacheName,
                        sizeof(NETBIOS_CACHE) + ((CacheName->NetworksAllocated-1) * sizeof(NETBIOS_NETWORK)),
                        MEMORY_CACHE,
                        "Aged out");

                }
            }
        } // for loop
    } // for loop
} /* RemoveInvalidRoutesFromNetbiosCacheTable */


NTSTATUS
FindInNetbiosCacheTable(
    IN PNETBIOS_CACHE_TABLE CacheTable,
    IN PUCHAR               NameToBeFound,
    OUT PNETBIOS_CACHE       *CacheEntry
    )

/*++

Routine Description:

    This routine finds a netbios name in the Hash Table and returns
    the corresponding cache entry.

    THIS ROUTINE IS CALLED WITH THE DEVICE LOCK HELD AND RETURNS
    WITH THE LOCK HELD.

Arguments:

    CacheTable - The pointer of the Hash Table.

    CacheEntry - Pointer to the netbios cache entry if found.

Return Value:

    STATUS_SUCCESS - if successful.

    STATUS_UNSUCCESSFUL - otherwise.

--*/

{
    USHORT  HashIndex;
    PLIST_ENTRY p;
    PNETBIOS_CACHE FoundCacheName;


    HashIndex = ( ( NameToBeFound[0] & 0x0f ) << 4 ) + ( NameToBeFound[1] & 0x0f );
    HashIndex = HashIndex % CacheTable->MaxHashIndex;

    for (p = ( CacheTable->Bucket[ HashIndex ] ).Flink;
         p != &CacheTable->Bucket[ HashIndex ];
         p = p->Flink) {

        FoundCacheName = CONTAINING_RECORD (p, NETBIOS_CACHE, Linkage);

        //
        // See if this entry is for the same name we are looking for.

        if ( RtlEqualMemory (FoundCacheName->NetbiosName, NameToBeFound, 16)  ) {
            *CacheEntry = FoundCacheName;
            return STATUS_SUCCESS;
        }
    }

    return STATUS_UNSUCCESSFUL;
} /* FindInNetbiosCacheTable */

NTSTATUS
CreateNetbiosCacheTable(
    IN OUT PNETBIOS_CACHE_TABLE *NewTable,
    IN USHORT   MaxHashIndex
    )

/*++

Routine Description:

    This routine creates a new hash table for netbios cache
    and initializes it.

    THIS ROUTINE IS CALLED WITH THE DEVICE LOCK HELD AND RETURNS
    WITH THE LOCK HELD.

Arguments:

    NewTable - The pointer of the table to be created.

    MaxHashIndex - Number of buckets in the hash table.

Return Value:

    STATUS_SUCCESS - if successful.

    STATUS_INSUFFICIENT_RESOURCES - If cannot allocate memory.

--*/

{
    USHORT  i;

    *NewTable = NbiAllocateMemory (sizeof(NETBIOS_CACHE_TABLE) + sizeof(LIST_ENTRY) * ( MaxHashIndex - 1) ,
                                    MEMORY_CACHE, "Cache Table");

    if ( *NewTable ) {
        for ( i = 0; i < MaxHashIndex; i++ ) {
            InitializeListHead(& (*NewTable)->Bucket[i] );
        }

        (*NewTable)->MaxHashIndex = MaxHashIndex;
        (*NewTable)->CurrentEntries = 0;
        return STATUS_SUCCESS;
    }
    else {
        NB_DEBUG( CACHE, ("Cannot create Netbios Cache Table\n") );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

} /* CreateNetbiosCacheTable */


VOID
DestroyNetbiosCacheTable(
    IN PNETBIOS_CACHE_TABLE CacheTable
    )

/*++

Routine Description:

    This routine removes all  entries from the hash table.
    and free up the hash table.

Arguments:

    CacheTable - The pointer of the Hash Table.

Return Value:

    None.
--*/

{
    USHORT  HashIndex;
    PLIST_ENTRY p;
    PNETBIOS_CACHE  CacheName;


    for ( HashIndex = 0; HashIndex < CacheTable->MaxHashIndex; HashIndex++) {
        while (!IsListEmpty ( &( CacheTable->Bucket[ HashIndex ] ) ) ) {

            p = RemoveHeadList ( &( CacheTable->Bucket[ HashIndex ] ));
            CacheTable->CurrentEntries--;
            CacheName = CONTAINING_RECORD (p, NETBIOS_CACHE, Linkage);

            NB_DEBUG2 (CACHE, ("Free cache entry %lx\n", CacheName));

            NbiFreeMemory(
                CacheName,
                sizeof(NETBIOS_CACHE) + ((CacheName->NetworksAllocated-1) * sizeof(NETBIOS_NETWORK)),
                MEMORY_CACHE,
                "Free entries");

        }
    }   // for loop

    CTEAssert( CacheTable->CurrentEntries == 0 );

    NbiFreeMemory (CacheTable, sizeof(NETBIOS_CACHE_TABLE) + sizeof(LIST_ENTRY) * ( CacheTable->MaxHashIndex - 1) ,
                                MEMORY_CACHE, "Free Cache Table");

} /* DestroyNetbiosCacheTable */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\nb\bind.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    driver.c

Abstract:

    This module contains the DriverEntry and other initialization
    code for the Netbios module of the ISN transport.

Author:

    Adam Barr (adamba) 16-November-1993

Environment:

    Kernel mode

Revision History:


--*/

#include "precomp.h"

#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NbiBind)
#endif

//
// local functions.
//
NTSTATUS
NbiPnPNotification(
    IN IPX_PNP_OPCODE OpCode,
    IN PVOID          PnPData
    );

extern HANDLE           TdiProviderHandle;
BOOLEAN                 fNbiTdiProviderReady = FALSE;


#ifdef BIND_FIX
extern PDRIVER_OBJECT   NbiDriverObject;
extern UNICODE_STRING   NbiRegistryPath;
extern PEPROCESS        NbiFspProcess;

DEFINE_LOCK_STRUCTURE(NbiTdiRequestInterlock);
ULONG                   NbiBindState = 0;
extern  UNICODE_STRING  NbiBindString;
BOOLEAN                 fNbiTdiRequestQueued = FALSE;

typedef struct{
    WORK_QUEUE_ITEM     WorkItem;
    LIST_ENTRY          NbiRequestLinkage;
    ULONG               Data;
} NBI_TDI_REQUEST_CONTEXT;

LIST_ENTRY NbiTdiRequestList;



#ifdef RASAUTODIAL
VOID
NbiAcdBind();

VOID
NbiAcdUnbind();
#endif
#endif  // BIND_FIX


NTSTATUS
NbiBind(
    IN PDEVICE Device,
    IN PCONFIG Config
    )

/*++

Routine Description:

    This routine binds the Netbios module of ISN to the IPX
    module, which provides the NDIS binding services.

Arguments:

    Device - Pointer to the Netbios device.

    Config - Pointer to the configuration information.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
/*    union {
        IPX_INTERNAL_BIND_INPUT Input;
        IPX_INTERNAL_BIND_OUTPUT Output;
    } Bind;
*/
    InitializeObjectAttributes(
        &ObjectAttributes,
        &Config->BindName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL);

    Status = ZwCreateFile(
                &Device->BindHandle,
                SYNCHRONIZE | GENERIC_READ,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0L);

    if (!NT_SUCCESS(Status)) {

        NB_DEBUG (BIND, ("Could not open IPX (%ws) %lx\n",
                    Config->BindName.Buffer, Status));
        NbiWriteGeneralErrorLog(
            Device,
            EVENT_TRANSPORT_ADAPTER_NOT_FOUND,
            1,
            Status,
            Config->BindName.Buffer,
            0,
            NULL);
        return Status;
    }

    //
    // Fill in our bind data.
    //

    Device->BindInput.Version = ISN_VERSION;
    Device->BindInput.Identifier = IDENTIFIER_NB;
    Device->BindInput.BroadcastEnable = TRUE;
    Device->BindInput.LookaheadRequired = 192;
    Device->BindInput.ProtocolOptions = 0;
    Device->BindInput.ReceiveHandler = NbiReceive;
    Device->BindInput.ReceiveCompleteHandler = NbiReceiveComplete;
    Device->BindInput.StatusHandler = NbiStatus;
    Device->BindInput.SendCompleteHandler = NbiSendComplete;
    Device->BindInput.TransferDataCompleteHandler = NbiTransferDataComplete;
    Device->BindInput.FindRouteCompleteHandler = NbiFindRouteComplete;
    Device->BindInput.LineUpHandler = NbiLineUp;
    Device->BindInput.LineDownHandler = NbiLineDown;
    Device->BindInput.ScheduleRouteHandler = NULL;
    Device->BindInput.PnPHandler = NbiPnPNotification;


    Status = ZwDeviceIoControlFile(
                Device->BindHandle,         // HANDLE to File
                NULL,                       // HANDLE to Event
                NULL,                       // ApcRoutine
                NULL,                       // ApcContext
                &IoStatusBlock,             // IO_STATUS_BLOCK
                IOCTL_IPX_INTERNAL_BIND,    // IoControlCode
                &Device->BindInput,                      // Input Buffer
                sizeof(Device->BindInput),               // Input Buffer Length
                &Device->Bind,                      // OutputBuffer
                sizeof(Device->Bind));              // OutputBufferLength

    //
    // We open synchronous, so this shouldn't happen.
    //

    CTEAssert (Status != STATUS_PENDING);

    //
    // Save the bind data.
    //

    if (Status == STATUS_SUCCESS) {

        NB_DEBUG2 (BIND, ("Successfully bound to IPX (%ws)\n",
                    Config->BindName.Buffer));
    } else {

        NB_DEBUG (BIND, ("Could not bind to IPX (%ws) %lx\n",
                    Config->BindName.Buffer, Status));
        NbiWriteGeneralErrorLog(
            Device,
            EVENT_TRANSPORT_BINDING_FAILED,
            1,
            Status,
            Config->BindName.Buffer,
            0,
            NULL);
        ZwClose(Device->BindHandle);
    }

    return Status;

}   /* NbiBind */


VOID
NbiUnbind(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This function closes the binding between the Netbios over
    IPX module and the IPX module previously established by
    NbiBind.

Arguments:

    Device - The netbios device object.

Return Value:

    None.

--*/

{
    ZwClose (Device->BindHandle);
}   /* NbiUnbind */


#ifdef BIND_FIX

NTSTATUS
NbiBindToIpx(
    )
{
    NTSTATUS status;
    PDEVICE Device;
    PIPX_HEADER IpxHeader;
    CTELockHandle LockHandle;
    WCHAR               wcNwlnkNbProviderName[60]   = L"\\Device\\NwlnkNb";
    UNICODE_STRING      ucNwlnkNbProviderName;
    PCONFIG Config = NULL;

    //
    // This allocates the CONFIG structure and returns
    // it in Config.
    //
    status = NbiGetConfiguration(NbiDriverObject, &NbiRegistryPath, &Config);
    if (!NT_SUCCESS (status)) {

        //
        // If it failed it logged an error.
        //
        PANIC (" Failed to initialize transport, ISN Netbios initialization failed.\n");
        return status;
    }


    //
    // Create the device object which exports our name.
    //
    status = NbiCreateDevice (NbiDriverObject, &Config->DeviceName, &Device);
    if (!NT_SUCCESS (status)) {
        NbiWriteGeneralErrorLog(
            (PVOID)NbiDriverObject,
            EVENT_IPX_CREATE_DEVICE,
            801,
            status,
            NULL,
            0,
            NULL);

        NbiFreeConfiguration(Config);
        return status;
    }

    NbiDevice = Device;

    //
    // Initialize the global pool interlock
    //
    CTEInitLock (&NbiGlobalPoolInterlock);

    //
    // Save the relevant configuration parameters.
    //
    Device->AckDelayTime                = (Config->Parameters[CONFIG_ACK_DELAY_TIME] / SHORT_TIMER_DELTA) + 1;
    Device->AckWindow                   = Config->Parameters[CONFIG_ACK_WINDOW];
    Device->AckWindowThreshold          = Config->Parameters[CONFIG_ACK_WINDOW_THRESHOLD];
    Device->EnablePiggyBackAck          = Config->Parameters[CONFIG_ENABLE_PIGGYBACK_ACK];
    Device->Extensions                  = Config->Parameters[CONFIG_EXTENSIONS];
    Device->RcvWindowMax                = Config->Parameters[CONFIG_RCV_WINDOW_MAX];
    Device->BroadcastCount              = Config->Parameters[CONFIG_BROADCAST_COUNT];
    Device->BroadcastTimeout            = Config->Parameters[CONFIG_BROADCAST_TIMEOUT];
    Device->ConnectionCount             = Config->Parameters[CONFIG_CONNECTION_COUNT];
    Device->ConnectionTimeout           = Config->Parameters[CONFIG_CONNECTION_TIMEOUT] * 500;
    Device->InitPackets                 = Config->Parameters[CONFIG_INIT_PACKETS];
    Device->MaxPackets                  = Config->Parameters[CONFIG_MAX_PACKETS];
    Device->InitialRetransmissionTime   = Config->Parameters[CONFIG_INIT_RETRANSMIT_TIME];
    Device->Internet                    = Config->Parameters[CONFIG_INTERNET];
    Device->KeepAliveCount              = Config->Parameters[CONFIG_KEEP_ALIVE_COUNT];
    Device->KeepAliveTimeout            = Config->Parameters[CONFIG_KEEP_ALIVE_TIMEOUT];
    Device->RetransmitMax               = Config->Parameters[CONFIG_RETRANSMIT_MAX];
    Device->RouterMtu                   = Config->Parameters[CONFIG_ROUTER_MTU];
    Device->MaxReceiveBuffers           = 20;     // Make it configurable?
    Device->NameCache                   = NULL;   // MP bug:  IPX tries to Flush it before it's initialized!
    Device->FindNameTimeout = ((Config->Parameters[CONFIG_BROADCAST_TIMEOUT]) + (FIND_NAME_GRANULARITY/2)) /
                                FIND_NAME_GRANULARITY;
    //
    // Initialize the BindReady Event to False
    //
    KeInitializeEvent (&Device->BindReadyEvent, NotificationEvent, FALSE);

    //
    // Create Hash Table to store netbios cache entries
    // For server create a big table, for workstation a small one
    //
    if (MmIsThisAnNtAsSystem())
    {
        status = CreateNetbiosCacheTable( &Device->NameCache,  NB_NETBIOS_CACHE_TABLE_LARGE );
    }
    else
    {
        status = CreateNetbiosCacheTable( &Device->NameCache,  NB_NETBIOS_CACHE_TABLE_SMALL );
    }

    if (!NT_SUCCESS (status))
    {
        //
        // If it failed it logged an error.
        //
        NbiFreeConfiguration(Config);
        NbiDereferenceDevice (Device, DREF_LOADED);
        return status;
    }

    //  Initialize the timer system. This should be done before
    //  binding to ipx because we should have timers intialized
    //  before ipx calls our pnp indications.
    NbiInitializeTimers (Device);

    //
    // Register us as a provider with Tdi
    //
    RtlInitUnicodeString(&ucNwlnkNbProviderName, wcNwlnkNbProviderName);
    ucNwlnkNbProviderName.MaximumLength = sizeof (wcNwlnkNbProviderName);
    if (!NT_SUCCESS (TdiRegisterProvider (&ucNwlnkNbProviderName, &TdiProviderHandle)))
    {
        TdiProviderHandle = NULL;
        DbgPrint("Nbi.DriverEntry:  FAILed to Register NwlnkNb as Provider!\n");
    }

    //
    // Now bind to IPX via the internal interface.
    //
    status = NbiBind (Device, Config);
    if (!NT_SUCCESS (status)) {

        //
        // If it failed it logged an error.
        //
        if (TdiProviderHandle)
        {
            TdiDeregisterProvider (TdiProviderHandle);
        }
        NbiFreeConfiguration(Config);
        NbiDereferenceDevice (Device, DREF_LOADED);
        return status;
    }

#ifdef  RSRC_TIMEOUT_DBG
    NbiInitDeathPacket();
    // NbiGlobalMaxResTimeout.QuadPart = 50; // 1*1000*10000;
    NbiGlobalMaxResTimeout.QuadPart = 20*60*1000;
    NbiGlobalMaxResTimeout.QuadPart *= 10000;
#endif  // RSRC_TIMEOUT_DBG

    NB_GET_LOCK (&Device->Lock, &LockHandle);

    //
    // Allocate our initial connectionless packet pool.
    //

    NbiAllocateSendPool (Device);

    //
    // Allocate our initial receive packet pool.
    //

    NbiAllocateReceivePool (Device);

    //
    // Allocate our initial receive buffer pool.
    //
    //
    if ( DEVICE_STATE_CLOSED == Device->State ) {
        Device->State = DEVICE_STATE_LOADED;
    }

    NB_FREE_LOCK (&Device->Lock, LockHandle);

    //
    // Fill in the default connnectionless header.
    //
    IpxHeader = &Device->ConnectionlessHeader;
    IpxHeader->CheckSum = 0xffff;
    IpxHeader->PacketLength[0] = 0;
    IpxHeader->PacketLength[1] = 0;
    IpxHeader->TransportControl = 0;
    IpxHeader->PacketType = 0;
    *(UNALIGNED ULONG *)(IpxHeader->DestinationNetwork) = 0;
    RtlCopyMemory(IpxHeader->DestinationNode, BroadcastAddress, 6);
    IpxHeader->DestinationSocket = NB_SOCKET;
    IpxHeader->SourceSocket = NB_SOCKET;

#ifdef RASAUTODIAL
    //
    // Get the automatic connection
    // driver entry points.
    //
    NbiAcdBind();
#endif

    NbiFreeConfiguration(Config);

    NbiBindState |= NBI_BOUND_TO_IPX;
    Device->DeviceObject.Flags &= ~DO_DEVICE_INITIALIZING;

    KeSetEvent(&Device->BindReadyEvent, 0, FALSE);

    return STATUS_SUCCESS;
}


VOID
NbiUnbindFromIpx(
    )

/*++

Routine Description:

    This unbinds from any NDIS drivers that are open and frees all resources
    associated with the transport. The I/O system will not call us until
    nobody above has Netbios open.

Arguments:

Return Value:

    None.

--*/

{
    PDEVICE Device = NbiDevice;

    NbiBindState &= (~NBI_BOUND_TO_IPX);

#ifdef RASAUTODIAL
    //
    // Unbind from the
    // automatic connection driver.
    //
    NbiAcdUnbind();
#endif

    Device->State = DEVICE_STATE_STOPPING;

    //
    // Cancel the long timer.
    //
    if (CTEStopTimer (&Device->LongTimer))
    {
        NbiDereferenceDevice (Device, DREF_LONG_TIMER);
    }

    //
    // Unbind from the IPX driver.
    //
    NbiUnbind (Device);

    //
    // This event will get set when the reference count
    // drops to 0.
    //
    KeInitializeEvent (&Device->UnloadEvent, NotificationEvent, FALSE);
    Device->UnloadWaiting = TRUE;

    //
    // Remove the reference for us being loaded.
    //
    NbiDereferenceDevice (Device, DREF_LOADED);

    //
    // Wait for our count to drop to zero.
    //
    KeWaitForSingleObject (&Device->UnloadEvent, Executive, KernelMode, TRUE, (PLARGE_INTEGER)NULL);

    //
    // Free the cache of netbios names.
    //
    DestroyNetbiosCacheTable (Device->NameCache);

    //
    // Do the cleanup that has to happen at IRQL 0.
    //
    ExDeleteResourceLite (&Device->AddressResource);
    IoDeleteDevice ((PDEVICE_OBJECT)Device);
}


UCHAR           AdapterName[NB_NETBIOS_NAME_SIZE];

VOID
NbiNotifyTdiClients(
    IN PWORK_QUEUE_ITEM    WorkItem
    )
{
    NTSTATUS            Status;
    TA_NETBIOS_ADDRESS  PermAddress;
    HANDLE              TdiRegistrationHandle, NetAddressRegistrationHandle;
    CTELockHandle       LockHandle;
    PLIST_ENTRY         p;
    PDEVICE             Device = NbiDevice;
    NBI_TDI_REQUEST_CONTEXT *pNbiTdiRequest = (NBI_TDI_REQUEST_CONTEXT *) WorkItem;
    ULONG               RequestFlag;
    BOOLEAN             fRegisterWithTdi, fDeregisterWithTdi;

    do
    {
        RequestFlag = pNbiTdiRequest->Data;
        fRegisterWithTdi = fDeregisterWithTdi = FALSE;

        switch (RequestFlag)
        {
            case NBI_IPX_REGISTER:
            {
                if (NbiBindState & TDI_HAS_NOTIFIED)
                {
                    fRegisterWithTdi = TRUE;
                }
                NbiBindState |= IPX_HAS_DEVICES;

                break;
            }
            case NBI_TDI_REGISTER:
            {
                if (NbiBindState & IPX_HAS_DEVICES)
                {
                    fRegisterWithTdi = TRUE;
                }
                NbiBindState |= TDI_HAS_NOTIFIED;

                break;
            }

            case NBI_TDI_DEREGISTER:
            {
                fDeregisterWithTdi = TRUE;
                NbiBindState &= (~TDI_HAS_NOTIFIED);

                break;
            }
            case NBI_IPX_DEREGISTER:
            {
                fDeregisterWithTdi = TRUE;
                NbiBindState &= (~IPX_HAS_DEVICES);

                break;
            }
            default:
            {
                break;
            }
        }

        if (fRegisterWithTdi)
        {
            NB_GET_LOCK (&Device->Lock, &LockHandle);
            Device->State   =   DEVICE_STATE_OPEN;
            NB_FREE_LOCK (&Device->Lock, LockHandle);

            if (!(Device->TdiRegistrationHandle))
            {
                Status = TdiRegisterDeviceObject (&Device->DeviceString, &Device->TdiRegistrationHandle);
                if (!NT_SUCCESS(Status))
                {
                    Device->TdiRegistrationHandle = NULL;
                    DbgPrint ("Nbi.NbiNotifyTdiClients: ERROR -- TdiRegisterDeviceObject = <%x>\n", Status);
                }
            }

            //
            // If there is already an address Registered, Deregister it (since Adapter address could change)
            //
            if (Device->NetAddressRegistrationHandle)
            {
                DbgPrint ("Nbi!NbiNotifyTdiClients[REGISTER]: NetAddress exists!  Calling TdiDeregisterNetAddress\n");
                Status = TdiDeregisterNetAddress (Device->NetAddressRegistrationHandle);
                Device->NetAddressRegistrationHandle = NULL;
            }
            //
            // Register the permanent NetAddress!
            //
            PermAddress.Address[0].AddressLength = sizeof(TDI_ADDRESS_NETBIOS);
            PermAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
            PermAddress.Address[0].Address[0].NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
            CTEMemCopy (PermAddress.Address[0].Address[0].NetbiosName, AdapterName, NB_NETBIOS_NAME_SIZE);

            if (!NT_SUCCESS(Status = TdiRegisterNetAddress((PTA_ADDRESS) PermAddress.Address,
                                                           &Device->DeviceString,
                                                           NULL,
                                                           &Device->NetAddressRegistrationHandle)) )
            {
                Device->NetAddressRegistrationHandle = NULL;
                DbgPrint ("Nbi.NbiNotifyTdiClients[REGISTER]: ERROR -- TdiRegisterNetAddress=<%x>\n",Status);
            }
        }
        else if (fDeregisterWithTdi)
        {
            NB_GET_LOCK (&Device->Lock, &LockHandle);

            TdiRegistrationHandle = Device->TdiRegistrationHandle;
            Device->TdiRegistrationHandle = NULL;
            NetAddressRegistrationHandle = Device->NetAddressRegistrationHandle;
            Device->NetAddressRegistrationHandle = NULL;

            Device->State   =   DEVICE_STATE_LOADED;

            NB_FREE_LOCK (&Device->Lock, LockHandle);


            //
            // DeRegister the NetAddress!
            //
            if (NetAddressRegistrationHandle)
            {
                if (!NT_SUCCESS (Status = TdiDeregisterNetAddress (NetAddressRegistrationHandle)))
                {
                    DbgPrint ("NwlnkNb.NbiPnPNotification: ERROR -- TdiDeregisterNetAddress=<%x>\n", Status);
                }
            }
            //
            // Deregister the Device
            //
            if (TdiRegistrationHandle)
            {
                if (!NT_SUCCESS (Status = TdiDeregisterDeviceObject(TdiRegistrationHandle)))
                {
                    DbgPrint ("NwlnkNb.NbiPnPNotification: ERROR -- TdiDeregisterDeviceObject=<%x>\n",Status);
                }
            }
        }

        NbiFreeMemory (pNbiTdiRequest, sizeof(NBI_TDI_REQUEST_CONTEXT), MEMORY_WORK_ITEM, "TdiRequest");

        CTEGetLock (&NbiTdiRequestInterlock, &LockHandle);

        if (IsListEmpty(&NbiTdiRequestList))
        {
            fNbiTdiRequestQueued = FALSE;
            CTEFreeLock (&NbiTdiRequestInterlock, LockHandle);
            break;
        }

        p = RemoveHeadList (&NbiTdiRequestList);
        CTEFreeLock (&NbiTdiRequestInterlock, LockHandle);

        pNbiTdiRequest = CONTAINING_RECORD (p, NBI_TDI_REQUEST_CONTEXT, NbiRequestLinkage);
    } while (1);
}


NTSTATUS
NbiQueueTdiRequest(
    enum eTDI_ACTION    RequestFlag
    )
{
    NBI_TDI_REQUEST_CONTEXT *pNbiTdiRequest;
    CTELockHandle           LockHandle;
    NTSTATUS                Status = STATUS_SUCCESS;

    CTEGetLock (&NbiTdiRequestInterlock, &LockHandle);

    if (pNbiTdiRequest = NbiAllocateMemory (sizeof(NBI_TDI_REQUEST_CONTEXT), MEMORY_WORK_ITEM, "TdiRequest"))
    {
        pNbiTdiRequest->Data = RequestFlag;

        if (fNbiTdiRequestQueued)
        {
            InsertTailList (&NbiTdiRequestList, &pNbiTdiRequest->NbiRequestLinkage);
        }
        else
        {
            fNbiTdiRequestQueued = TRUE;
            ExInitializeWorkItem (&pNbiTdiRequest->WorkItem, NbiNotifyTdiClients, (PVOID)pNbiTdiRequest);
            ExQueueWorkItem (&pNbiTdiRequest->WorkItem, DelayedWorkQueue);
        }
    }
    else
    {
        NB_DEBUG( DEVICE, ("Cannt schdule work item to Notify Tdi clients\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    CTEFreeLock (&NbiTdiRequestInterlock, LockHandle);

    return (Status);
}



VOID
TdiBindHandler(
    TDI_PNP_OPCODE  PnPOpCode,
    PUNICODE_STRING pDeviceName,
    PWSTR           MultiSZBindList)
{
    NTSTATUS        Status;
    BOOLEAN         Attached;

    if ((!pDeviceName) ||
        (RtlCompareUnicodeString(pDeviceName, &NbiBindString, TRUE)))
    {
        return;
    }

    switch (PnPOpCode)
    {
        case (TDI_PNP_OP_ADD):
        {
            if (!(NbiBindState & NBI_BOUND_TO_IPX))
            {
                if (PsGetCurrentProcess() != NbiFspProcess)
                {
                    KeAttachProcess((PRKPROCESS)NbiFspProcess);
                    Attached = TRUE;
                }
                else
                {
                    Attached = FALSE;
                }

                Status = NbiBindToIpx();

                if (Attached)
                {
                    KeDetachProcess();
                }
            }
            NbiQueueTdiRequest ((ULONG) NBI_TDI_REGISTER);

            break;
        }

        case (TDI_PNP_OP_DEL):
        {
            if (NbiBindState & NBI_BOUND_TO_IPX)
            {
                NbiQueueTdiRequest ((ULONG) NBI_TDI_DEREGISTER);
            }

            break;
        }

        default:
        {
            break;
        }
    }
}
#endif  // BIND_FIX




VOID
NbiStatus(
    IN USHORT NicId,
    IN NDIS_STATUS GeneralStatus,
    IN PVOID StatusBuffer,
    IN UINT StatusBufferLength
    )

/*++

Routine Description:

    This function receives a status indication from IPX,
    corresponding to a status indication from an underlying
    NDIS driver.

Arguments:

    NicId - The NIC ID of the underlying adapter.

    GeneralStatus - The general status code.

    StatusBuffer - The status buffer.

    StatusBufferLength - The length of the status buffer.

Return Value:

    None.

--*/

{

}   /* NbiStatus */


VOID
NbiLineUp(
    IN USHORT NicId,
    IN PIPX_LINE_INFO LineInfo,
    IN NDIS_MEDIUM DeviceType,
    IN PVOID ConfigurationData
    )


/*++

Routine Description:

    This function receives line up indications from IPX,
    indicating that the specified adapter is now up with
    the characteristics shown.

Arguments:

    NicId - The NIC ID of the underlying adapter.

    LineInfo - Information about the adapter's medium.

    DeviceType - The type of the adapter.

    ConfigurationData - IPX-specific configuration data.

Return Value:

    None.

--*/

{
    PIPXCP_CONFIGURATION Configuration = (PIPXCP_CONFIGURATION)ConfigurationData;
}   /* NbiLineUp */


VOID
NbiLineDown(
    IN USHORT       NicId,
    IN ULONG_PTR    FwdAdapterContext
    )


/*++

Routine Description:

    This function receives line down indications from IPX,
    indicating that the specified adapter is no longer
    up.

Arguments:

    NicId - The NIC ID of the underlying adapter.

Return Value:

    None.

--*/

{
}   /* NbiLineDown */




NTSTATUS
NbiPnPNotification(
    IN IPX_PNP_OPCODE OpCode,
    IN PVOID          PnPData
    )

/*++

Routine Description:

    This function receives the notification about PnP events from IPX.

Arguments:

    OpCode  -   Type of the PnP event

    PnPData -   Data associated with this event.

Return Value:

    None.

--*/

{

    CTELockHandle           LockHandle;
    PADAPTER_ADDRESS        AdapterAddress;
    USHORT                  MaximumNicId = 0;
    PDEVICE                 Device  =   NbiDevice;
    NTSTATUS                Status = STATUS_SUCCESS;
    PNET_PNP_EVENT          NetPnpEvent = (PNET_PNP_EVENT) PnPData;
    IPX_PNP_INFO UNALIGNED  *PnPInfo = (IPX_PNP_INFO UNALIGNED *)PnPData;

    NB_DEBUG2( DEVICE, ("Received a pnp notification, opcode %d\n",OpCode ));

#ifdef BIND_FIX
    if (!(NbiBindState & NBI_BOUND_TO_IPX))
    {
        KeWaitForSingleObject (&Device->BindReadyEvent,  // Object to wait on.
                               Executive,            // Reason for waiting
                               KernelMode,           // Processor mode
                               FALSE,                // Alertable
                               NULL);                // Timeout
    }
#endif  // BIND_FIX

    switch( OpCode ) {
    case IPX_PNP_ADD_DEVICE : {
        BOOLEAN        ReallocReceiveBuffers = FALSE;

        NB_GET_LOCK( &Device->Lock, &LockHandle );

        if ( PnPInfo->NewReservedAddress ) {

            *(UNALIGNED ULONG *)Device->Bind.Network    =   PnPInfo->NetworkAddress;
            RtlCopyMemory( Device->Bind.Node, PnPInfo->NodeAddress, 6);

            *(UNALIGNED ULONG *)Device->ConnectionlessHeader.SourceNetwork =
                *(UNALIGNED ULONG *)Device->Bind.Network;
            RtlCopyMemory(Device->ConnectionlessHeader.SourceNode, Device->Bind.Node, 6);
        }

        if ( PnPInfo->FirstORLastDevice ) {
// Comment out the ASSERTS until Ting can check in his fix!
//            CTEAssert( PnPInfo->NewReservedAddress );
//            CTEAssert( Device->State != DEVICE_STATE_OPEN );
//            CTEAssert( !Device->MaximumNicId );

            //
            // we must do this while we still have the device lock.
            //
            if ( !Device->LongTimerRunning ) {
                Device->LongTimerRunning    =   TRUE;
                NbiReferenceDevice (Device, DREF_LONG_TIMER);

                CTEStartTimer( &Device->LongTimer, LONG_TIMER_DELTA, NbiLongTimeout, (PVOID)Device);
            }

            Device->Bind.LineInfo.MaximumSendSize = PnPInfo->LineInfo.MaximumSendSize;
            Device->Bind.LineInfo.MaximumPacketSize = PnPInfo->LineInfo.MaximumSendSize;
            ReallocReceiveBuffers   = TRUE;
        } else {
            if ( PnPInfo->LineInfo.MaximumPacketSize > Device->CurMaxReceiveBufferSize ) {
                Device->Bind.LineInfo.MaximumPacketSize = PnPInfo->LineInfo.MaximumSendSize;
                ReallocReceiveBuffers =  TRUE;
            }
            //
            // MaxSendSize could become smaller.
            //
            Device->Bind.LineInfo.MaximumSendSize = PnPInfo->LineInfo.MaximumSendSize;
        }

        Device->MaximumNicId++;

        //
        //
        RtlZeroMemory(AdapterName, 10);
        RtlCopyMemory(&AdapterName[10], PnPInfo->NodeAddress, 6);
        AdapterAddress = NbiCreateAdapterAddress (PnPInfo->NodeAddress);

        //
        // And finally remove all the failed cache entries since we might
        // find those routes using this new adapter
        //
        FlushFailedNetbiosCacheEntries(Device->NameCache);

        NB_FREE_LOCK( &Device->Lock, LockHandle );


        if ( ReallocReceiveBuffers ) {
            PWORK_QUEUE_ITEM    WorkItem;

            WorkItem = NbiAllocateMemory( sizeof(WORK_QUEUE_ITEM), MEMORY_WORK_ITEM, "Alloc Rcv Buffer work item");

            if ( WorkItem ) {
                ExInitializeWorkItem( WorkItem, NbiReAllocateReceiveBufferPool, (PVOID) WorkItem );
                ExQueueWorkItem( WorkItem, DelayedWorkQueue );
            } else {
                NB_DEBUG( DEVICE, ("Cannt schdule work item to realloc receive buffer pool\n"));
            }
        }

        //
        // Notify the TDI clients about the device creation
        //
        if (PnPInfo->FirstORLastDevice)
        {
            NbiQueueTdiRequest ((ULONG) NBI_IPX_REGISTER);

            if ((TdiProviderHandle) && (!fNbiTdiProviderReady))
            {
                fNbiTdiProviderReady = TRUE;
                TdiProviderReady (TdiProviderHandle);
            }
        }

        break;
    }
    case IPX_PNP_DELETE_DEVICE : {

        PLIST_ENTRY     p;
        PNETBIOS_CACHE  CacheName;
        USHORT          i,j,NetworksRemoved;

        NB_GET_LOCK( &Device->Lock, &LockHandle );

        CTEAssert (Device->MaximumNicId);
        Device->MaximumNicId--;

        //
        // MaximumSendSize could change if the card with the smallest send size just
        // got removed. MaximumPacketSize could only become smaller and we ignore that
        // since we dont need to(want to) realloc ReceiveBuffers.
        //

        Device->Bind.LineInfo.MaximumSendSize   =   PnPInfo->LineInfo.MaximumSendSize;

        //
        // Flush all the cache entries that are using this NicId in the local
        // target.
        //
        RemoveInvalidRoutesFromNetbiosCacheTable( Device->NameCache, &PnPInfo->NicHandle );

        NbiDestroyAdapterAddress (NULL, PnPInfo->NodeAddress);

        //
        // inform tdi clients about the device deletion
        //
        if (PnPInfo->FirstORLastDevice)
        {
            Device->State = DEVICE_STATE_LOADED;    // Set this now even though it will be set again later
            NB_FREE_LOCK (&Device->Lock, LockHandle);

            NbiQueueTdiRequest ((ULONG) NBI_IPX_DEREGISTER);
        }
        else
        {
            NB_FREE_LOCK (&Device->Lock, LockHandle);
        }

        break;
    }

    case IPX_PNP_ADDRESS_CHANGE: {
        PADDRESS        Address;
        BOOLEAN ReservedNameClosing = FALSE;

        CTEAssert( PnPInfo->NewReservedAddress );

        NB_GET_LOCK( &Device->Lock, &LockHandle );
        *(UNALIGNED ULONG *)Device->Bind.Network    =   PnPInfo->NetworkAddress;
        RtlCopyMemory( Device->Bind.Node, PnPInfo->NodeAddress, 6);

        *(UNALIGNED ULONG *)Device->ConnectionlessHeader.SourceNetwork = *(UNALIGNED ULONG *)Device->Bind.Network;
        RtlCopyMemory(Device->ConnectionlessHeader.SourceNode, Device->Bind.Node, 6);

        NB_FREE_LOCK( &Device->Lock, LockHandle );


        break;
    }
    case IPX_PNP_TRANSLATE_DEVICE:
        break;
    case IPX_PNP_TRANSLATE_ADDRESS:
        break;


    case IPX_PNP_QUERY_POWER:
    case IPX_PNP_QUERY_REMOVE:

        //
        // IPX wants to know if we can power off or remove an apapter.
        // We DONT look if there are any open connections before deciding.
        // We merely ask our TDI Clients, if they are OK with it, so are we.
        //
        // Via TDI to our Clients.
        Status = TdiPnPPowerRequest(
                    &Device->DeviceString,
                    NetPnpEvent,
                    NULL,
                    NULL,
                    Device->Bind.PnPCompleteHandler
                    );
        break;

    case IPX_PNP_SET_POWER:
    case IPX_PNP_CANCEL_REMOVE:

        //
        // IPX is telling us that the power is going off.
        // We tell our TDI Clients about it.
        //
        Status = TdiPnPPowerRequest(
                    &Device->DeviceString,
                    NetPnpEvent,
                    NULL,
                    NULL,
                    Device->Bind.PnPCompleteHandler
                    );

        break;

    default:
        CTEAssert( FALSE );
    }

    return Status;

}   /* NbiPnPNotification */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\nb\config.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    config.c

Abstract:

    This contains all routines necessary for the support of the dynamic
    configuration of the ISN Netbios module.

Author:

    Adam Barr (adamba) 16-November-1993

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// Local functions used to access the registry.
//

NTSTATUS
NbiGetConfigValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
NbiAddBind(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
NbiAddExport(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
NbiReadLinkageInformation(
    IN PCONFIG Config
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NbiGetConfiguration)
#pragma alloc_text(PAGE,NbiFreeConfiguration)
#pragma alloc_text(PAGE,NbiGetConfigValue)
#pragma alloc_text(PAGE,NbiAddBind)
#pragma alloc_text(PAGE,NbiAddExport)
#pragma alloc_text(PAGE,NbiReadLinkageInformation)
#endif



NTSTATUS
NbiGetConfiguration (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath,
    OUT PCONFIG * ConfigPtr
    )

/*++

Routine Description:

    This routine is called by Netbios to get information from the configuration
    management routines. We read the registry, starting at RegistryPath,
    to get the parameters. If they don't exist, we use the defaults
    set in ipxcnfg.h file. A list of adapters to bind to is chained
    on to the config information.

Arguments:

    DriverObject - Used for logging errors.

    RegistryPath - The name of Netbios' node in the registry.

    ConfigPtr - Returns the configuration information.

Return Value:

    Status - STATUS_SUCCESS if everything OK, STATUS_INSUFFICIENT_RESOURCES
            otherwise.

--*/
{
    PCONFIG Config;
    RTL_QUERY_REGISTRY_TABLE QueryTable[CONFIG_PARAMETERS+2];
    NTSTATUS Status;
    ULONG One = 1;
    ULONG Two = 2;
    ULONG Three = 3;
    ULONG Four = 4;
    ULONG Five = 5;
    ULONG Eight = 8;
    ULONG FortyEight = 48;
    ULONG Sixty = 60;
    ULONG TwoFifty = 250;
    ULONG FiveHundred = 500;
    ULONG SevenFifty = 750;
    ULONG MaxMTU      = 0xffffffff;

    PWSTR Parameters = L"Parameters";
    struct {
        PWSTR KeyName;
        PULONG DefaultValue;
    } ParameterValues[CONFIG_PARAMETERS] = {
        { L"AckDelayTime",         &TwoFifty } ,    // milliseconds
        { L"AckWindow",            &Two } ,
        { L"AckWindowThreshold",   &FiveHundred } , // milliseconds
        { L"EnablePiggyBackAck",   &One } ,
        { L"Extensions",           &One } ,
        { L"RcvWindowMax",         &Four } ,
        { L"BroadcastCount",       &Three } ,
        { L"BroadcastTimeout",     &SevenFifty} ,   // milliseconds
        { L"ConnectionCount",      &Five } ,
        { L"ConnectionTimeout",    &Two } ,         // half-seconds
        { L"InitPackets",          &Eight } ,
        { L"MaxPackets",           &FortyEight } ,
        { L"InitialRetransmissionTime", &FiveHundred } ,  // milliseconds
        { L"Internet",             &One } ,
        { L"KeepAliveCount",       &Eight } ,
        { L"KeepAliveTimeout",     &Sixty } ,       // half-seconds
        { L"RetransmitMax",        &Eight } , 
        { L"RouterMTU",            &MaxMTU } };
    UINT i;


    //
    // Allocate memory for the main config structure.
    //

    Config = NbiAllocateMemory (sizeof(CONFIG), MEMORY_CONFIG, "Config");
    if (Config == NULL) {
        NbiWriteResourceErrorLog ((PVOID)DriverObject, sizeof(CONFIG), MEMORY_CONFIG);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Config->DeviceName.Buffer = NULL;
    Config->BindName.Buffer = NULL;
    Config->RegistryPath.Buffer = NULL;
    Config->DriverObject = DriverObject;   // save this to log errors

    //
    // Read in the NDIS binding information (if none is present
    // the array will be filled with all known drivers).
    //
    // NbiReadLinkageInformation expects a null-terminated path,
    // so we have to create one from the UNICODE_STRING.
    //

    Config->RegistryPath.Length = RegistryPath->Length + sizeof(WCHAR);
    Config->RegistryPath.Buffer = (PWSTR)NbiAllocateMemory(Config->RegistryPath.Length,
                                                      MEMORY_CONFIG, "RegistryPathBuffer");
    if (Config->RegistryPath.Buffer == NULL) {
        NbiWriteResourceErrorLog ((PVOID)DriverObject, RegistryPath->Length + sizeof(WCHAR), MEMORY_CONFIG);
        NbiFreeConfiguration(Config);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlCopyMemory (Config->RegistryPath.Buffer, RegistryPath->Buffer, RegistryPath->Length);
    *(PWCHAR)(((PUCHAR)Config->RegistryPath.Buffer)+RegistryPath->Length) = (WCHAR)'\0';

    //
    // Determine what name to export and who to bind to.
    //

    Status = NbiReadLinkageInformation (Config);

    if (Status != STATUS_SUCCESS) {

        //
        // If it failed it logged an error.
        //

        NbiFreeConfiguration(Config);
        return Status;
    }

    //
    // Read the per-transport (as opposed to per-binding)
    // parameters.
    //

    //
    // Set up QueryTable to do the following:
    //

    //
    // 1) Switch to the Parameters key below Netbios
    //

    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    QueryTable[0].Name = Parameters;

    //
    // 2-18) Call NbiSetBindingValue for each of the keys we
    // care about.
    //

    for (i = 0; i < CONFIG_PARAMETERS; i++) {

        QueryTable[i+1].QueryRoutine = NbiGetConfigValue;
        QueryTable[i+1].Flags = 0;
        QueryTable[i+1].Name = ParameterValues[i].KeyName;
        QueryTable[i+1].EntryContext = UlongToPtr(i);
        QueryTable[i+1].DefaultType = REG_DWORD;
        QueryTable[i+1].DefaultData = (PVOID)(ParameterValues[i].DefaultValue);
        QueryTable[i+1].DefaultLength = sizeof(ULONG);

    }

    //
    // 19) Stop
    //

    QueryTable[CONFIG_PARAMETERS+1].QueryRoutine = NULL;
    QueryTable[CONFIG_PARAMETERS+1].Flags = 0;
    QueryTable[CONFIG_PARAMETERS+1].Name = NULL;


    Status = RtlQueryRegistryValues(
                 RTL_REGISTRY_ABSOLUTE,
                 Config->RegistryPath.Buffer,
                 QueryTable,
                 (PVOID)Config,
                 NULL);

    if (Status != STATUS_SUCCESS) {

        NbiFreeConfiguration(Config);
        NbiWriteGeneralErrorLog(
            (PVOID)DriverObject,
            EVENT_IPX_ILLEGAL_CONFIG,
            701,
            Status,
            Parameters,
            0,
            NULL);
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    *ConfigPtr = Config;

// #if DBG
    //
    // Due to previous Registry entries not being cleanedup properly,
    // we can have stale entries for BroadcastTimeout -- if so, handle
    // it accordingly
    if (Config->Parameters[CONFIG_BROADCAST_TIMEOUT] < 10)
    {
        Config->Parameters[CONFIG_BROADCAST_TIMEOUT] = SevenFifty;
    }
// #endif

    return STATUS_SUCCESS;

}   /* NbiGetConfiguration */


VOID
NbiFreeConfiguration (
    IN PCONFIG Config
    )

/*++

Routine Description:

    This routine is called by Netbios to get free any storage that was allocated
    by NbiGetConfiguration in producing the specified CONFIG structure.

Arguments:

    Config - A pointer to the configuration information structure.

Return Value:

    None.

--*/
{
    if (Config->BindName.Buffer) {
        NbiFreeMemory (Config->BindName.Buffer, Config->BindName.MaximumLength, MEMORY_CONFIG, "BindName");
    }

    if (Config->DeviceName.Buffer) {
        NbiFreeMemory (Config->DeviceName.Buffer, Config->DeviceName.MaximumLength, MEMORY_CONFIG, "DeviceName");
    }

    if (Config->RegistryPath.Buffer)
    {
        NbiFreeMemory (Config->RegistryPath.Buffer, Config->RegistryPath.Length,MEMORY_CONFIG,"RegistryPathBuffer");
    }

    NbiFreeMemory (Config, sizeof(CONFIG), MEMORY_CONFIG, "Config");

}   /* NbiFreeConfig */


NTSTATUS
NbiGetConfigValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each entry in the Parameters
    node to set the config values. The table is set up
    so that this function will be called with correct default
    values for keys that are not present.

Arguments:

    ValueName - The name of the value (ignored).

    ValueType - The type of the value (REG_DWORD -- ignored).

    ValueData - The data for the value.

    ValueLength - The length of ValueData (ignored).

    Context - A pointer to the CONFIG structure.

    EntryContext - The index in Config->Parameters to save the value.

Return Value:

    STATUS_SUCCESS

--*/

{
    PCONFIG Config = (PCONFIG)Context;
    ULONG   Data    = *(UNALIGNED ULONG *)ValueData;
    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(ValueType);
    UNREFERENCED_PARAMETER(ValueLength);

    if ((ValueType != REG_DWORD) || (ValueLength != sizeof(ULONG))) {
        return STATUS_INVALID_PARAMETER;
    }


    switch ( (ULONG_PTR) EntryContext ) {
    case CONFIG_ROUTER_MTU:
        if ( ( Data - sizeof(NB_CONNECTION) - sizeof(IPX_HEADER) ) <= 0 ) {
            Config->Parameters[CONFIG_ROUTER_MTU] = 0xffffffff;
            NbiWriteGeneralErrorLog(
                (PVOID)Config->DriverObject,
                EVENT_IPX_ILLEGAL_CONFIG,
                704,
                STATUS_INVALID_PARAMETER,
                ValueName,
                0,
                NULL);
                return STATUS_SUCCESS;
        }
        break;
    default:
        break;
    }

    NB_DEBUG2 (CONFIG, ("Config parameter %d, value %lx\n", (ULONG_PTR)EntryContext, Data));
    Config->Parameters[(ULONG_PTR)EntryContext] = Data;

    return STATUS_SUCCESS;

}   /* NbiGetConfigValue */


NTSTATUS
NbiAddBind(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each piece of the "Bind" multi-string and
    saves the information in a Config structure.

Arguments:

    ValueName - The name of the value ("Bind" -- ignored).

    ValueType - The type of the value (REG_SZ -- ignored).

    ValueData - The null-terminated data for the value.

    ValueLength - The length of ValueData.

    Context - A pointer to the Config structure.

    EntryContext - A pointer to a count of binds that is incremented.

Return Value:

    STATUS_SUCCESS

--*/

{
    PCONFIG Config = (PCONFIG)Context;
    PULONG ValueReadOk = ((PULONG)EntryContext);
    PWCHAR NameBuffer;

    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(ValueType);

    if (*ValueReadOk == 0) {

        NB_DEBUG2 (CONFIG, ("Read bind value %ws\n", ValueData));

        NameBuffer = (PWCHAR)NbiAllocateMemory (ValueLength, MEMORY_CONFIG, "BindName");
        if (NameBuffer == NULL) {
            NbiWriteResourceErrorLog ((PVOID)Config->DriverObject, ValueLength, MEMORY_CONFIG);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory (NameBuffer, ValueData, ValueLength);
        Config->BindName.Buffer = NameBuffer;
        Config->BindName.Length = (USHORT)(ValueLength - sizeof(WCHAR));
        Config->BindName.MaximumLength = (USHORT)ValueLength;

        //
        // Set this to ignore any other callbacks and let the
        // caller know we read something.
        //

        *ValueReadOk = 1;

    }

    return STATUS_SUCCESS;

}   /* NbiAddBind */


NTSTATUS
NbiAddExport(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each piece of the "Export" multi-string. It
    saves the first callback string in the Config structure.

Arguments:

    ValueName - The name of the value ("Export" -- ignored).

    ValueType - The type of the value (REG_SZ -- ignored).

    ValueData - The null-terminated data for the value.

    ValueLength - The length of ValueData.

    Context - A pointer to the Config structure.

    EntryContext - A pointer to a ULONG that goes to 1 after the
       first call to this routine (so we know to ignore other ones).

Return Value:

    STATUS_SUCCESS

--*/

{
    PCONFIG Config = (PCONFIG)Context;
    PULONG ValueReadOk = ((PULONG)EntryContext);
    PWCHAR NameBuffer;

    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(ValueType);

    if (*ValueReadOk == 0) {

        NB_DEBUG2 (CONFIG, ("Read export value %ws\n", ValueData));

        NameBuffer = (PWCHAR)NbiAllocateMemory (ValueLength, MEMORY_CONFIG, "DeviceName");
        if (NameBuffer == NULL) {
            NbiWriteResourceErrorLog ((PVOID)Config->DriverObject, ValueLength, MEMORY_CONFIG);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory (NameBuffer, ValueData, ValueLength);
        Config->DeviceName.Buffer = NameBuffer;
        Config->DeviceName.Length = (USHORT)(ValueLength - sizeof(WCHAR));
        Config->DeviceName.MaximumLength = (USHORT)ValueLength;

        //
        // Set this to ignore any other callbacks and let the
        // caller know we read something.
        //

        *ValueReadOk = 1;

    }

    return STATUS_SUCCESS;

}   /* NbiAddExport */


NTSTATUS
NbiReadLinkageInformation(
    IN PCONFIG Config
    )

/*++

Routine Description:

    This routine is called by Netbios to read its linkage information
    from the registry.

Arguments:

    Config - The config structure which will have per-binding information
        linked on to it.

Return Value:

    The status of the operation.

--*/

{

    NTSTATUS Status;
    RTL_QUERY_REGISTRY_TABLE QueryTable[3];
    PWSTR Subkey = L"Linkage";
    PWSTR Bind = L"Bind";
    PWSTR Export = L"Export";
    ULONG ValueReadOk;        // set to TRUE when a value is read correctly

    //
    // Set up QueryTable to do the following:
    //

    //
    // 1) Switch to the Linkage key below Netbios
    //

    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    QueryTable[0].Name = Subkey;

    //
    // 1) Call NbiAddExport for each string in "Export"
    //

    QueryTable[1].QueryRoutine = NbiAddExport;
    QueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[1].Name = Export;
    QueryTable[1].EntryContext = (PVOID)&ValueReadOk;
    QueryTable[1].DefaultType = REG_NONE;

    //
    // 2) Stop
    //

    QueryTable[2].QueryRoutine = NULL;
    QueryTable[2].Flags = 0;
    QueryTable[2].Name = NULL;


    ValueReadOk = 0;

    Status = RtlQueryRegistryValues(
                 RTL_REGISTRY_ABSOLUTE,
                 Config->RegistryPath.Buffer,
                 QueryTable,
                 (PVOID)Config,
                 NULL);

    if ((Status != STATUS_SUCCESS) || (ValueReadOk == 0)) {

        NbiWriteGeneralErrorLog(
            (PVOID)Config->DriverObject,
            EVENT_IPX_ILLEGAL_CONFIG,
            702,
            Status,
            Export,
            0,
            NULL);
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }


    //
    // 1) Change to call NbiAddBind for each string in "Bind"
    //

    QueryTable[1].QueryRoutine = NbiAddBind;
    QueryTable[1].Flags = 0;           // not required
    QueryTable[1].Name = Bind;
    QueryTable[1].EntryContext = (PVOID)&ValueReadOk;
    QueryTable[1].DefaultType = REG_NONE;

    ValueReadOk = 0;

    Status = RtlQueryRegistryValues(
                 RTL_REGISTRY_ABSOLUTE,
                 Config->RegistryPath.Buffer,
                 QueryTable,
                 (PVOID)Config,
                 NULL);

    if ((Status != STATUS_SUCCESS) || (ValueReadOk == 0)) {

        NbiWriteGeneralErrorLog(
            (PVOID)Config->DriverObject,
            EVENT_IPX_ILLEGAL_CONFIG,
            703,
            Status,
            Bind,
            0,
            NULL);
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    return STATUS_SUCCESS;

}   /* NbiReadLinkageInformation */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\nb\config.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    config.h

Abstract:

    Private include file for the ISN Netbios module.
    file defines all constants and structures necessary for support of
    the dynamic configuration of ST.

Revision History:

--*/


//
// These are used to index into the Parameters array in CONFIG.
//

#define CONFIG_ACK_DELAY_TIME        0
#define CONFIG_ACK_WINDOW            1
#define CONFIG_ACK_WINDOW_THRESHOLD  2
#define CONFIG_ENABLE_PIGGYBACK_ACK  3
#define CONFIG_EXTENSIONS            4
#define CONFIG_RCV_WINDOW_MAX        5
#define CONFIG_BROADCAST_COUNT       6
#define CONFIG_BROADCAST_TIMEOUT     7
#define CONFIG_CONNECTION_COUNT      8
#define CONFIG_CONNECTION_TIMEOUT    9
#define CONFIG_INIT_PACKETS          10
#define CONFIG_MAX_PACKETS           11
#define CONFIG_INIT_RETRANSMIT_TIME  12
#define CONFIG_INTERNET              13
#define CONFIG_KEEP_ALIVE_COUNT      14
#define CONFIG_KEEP_ALIVE_TIMEOUT    15
#define CONFIG_RETRANSMIT_MAX        16
#define CONFIG_ROUTER_MTU            17
#define CONFIG_PARAMETERS            18

//
// Main configuration structure.
//

typedef struct _CONFIG {

    ULONG Parameters[CONFIG_PARAMETERS];  // index defined above
    NDIS_STRING DeviceName;               // device name exported
    NDIS_STRING BindName;                 // device to bind to
    NDIS_STRING RegistryPath;             // RegistryPath
    PDRIVER_OBJECT DriverObject;          // used for logging errors

} CONFIG, * PCONFIG;


NTSTATUS
NbiGetConfiguration (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath,
    OUT PCONFIG * ConfigPtr
    );

VOID
NbiFreeConfiguration (
    IN PCONFIG Config
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\nb\connect.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    connect.c

Abstract:

    This routine contains the code to handle connect requests
    for the Netbios module of the ISN transport.

Author:

    Adam Barr (adamba) 22-November-1993

Environment:

    Kernel mode

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop


#ifdef RASAUTODIAL
#include <acd.h>
#include <acdapi.h>

BOOLEAN
NbiCancelTdiConnect(
    IN PDEVICE pDevice,
    IN PREQUEST pRequest,
    IN PCONNECTION pConnection
    );
#endif // RASAUTODIAL


extern POBJECT_TYPE *IoFileObjectType;



VOID
NbiFindRouteComplete(
    IN PIPX_FIND_ROUTE_REQUEST FindRouteRequest,
    IN BOOLEAN FoundRoute
    )

/*++

Routine Description:

    This routine is called when a find route request
    previously issued to IPX completes.

Arguments:

    FindRouteRequest - The find route request that was issued.

    FoundRoute - TRUE if the route was found.

Return Value:

    None.

--*/

{
    PCONNECTION Connection;
    PDEVICE Device = NbiDevice;
    UINT i;
    BOOLEAN LocalRoute;
    USHORT TickCount;
    PREQUEST RequestToComplete;
    PUSHORT Counts;
    CTELockHandle LockHandle1, LockHandle2;
    CTELockHandle CancelLH;

    Connection = CONTAINING_RECORD (FindRouteRequest, CONNECTION, FindRouteRequest);

    NB_GET_CANCEL_LOCK(&CancelLH);
    NB_GET_LOCK (&Connection->Lock, &LockHandle1);
    NB_GET_LOCK (&Device->Lock, &LockHandle2);

    Connection->FindRouteInProgress = FALSE;

    if (FoundRoute) {

        //
        // See if the route is local or not (for local routes
        // we use the real MAC address in the local target, but
        // the NIC ID may not be what we expect.
        //

        LocalRoute = TRUE;

        for (i = 0; i < 6; i++) {
            if (FindRouteRequest->LocalTarget.MacAddress[i] != 0x00) {
                LocalRoute = FALSE;
            }
        }

        if (LocalRoute) {

#if     defined(_PNP_POWER)
            Connection->LocalTarget.NicHandle = FindRouteRequest->LocalTarget.NicHandle;
#else
            Connection->LocalTarget.NicId = FindRouteRequest->LocalTarget.NicId;
#endif  _PNP_POWER

        } else {

            Connection->LocalTarget = FindRouteRequest->LocalTarget;

        }

        Counts = (PUSHORT)(&FindRouteRequest->Reserved2);
        TickCount = Counts[0];

        if (TickCount > 1) {

            //
            // Each tick is 55 ms, and for our timeout we use 10 ticks
            // worth (this makes tick count of 1 be about 500 ms, the
            // default).
            //
            // We get 55 milliseconds from
            //
            // 1 second    *  1000 milliseconds    55 ms
            // --------       -----------------  = -----
            // 18.21 ticks      1 second           tick
            //

            Connection->TickCount = TickCount;
            Connection->BaseRetransmitTimeout = (TickCount * 550) / SHORT_TIMER_DELTA;
            if (Connection->State != CONNECTION_STATE_ACTIVE) {
                Connection->CurrentRetransmitTimeout = Connection->BaseRetransmitTimeout;
            }
        }

        Connection->HopCount = Counts[1];

    }

    //
    // If the call failed we just use whatever route we had before
    // (on a connect it will be from the name query response, on
    // a listen from whatever the incoming connect frame had).
    //

    if ((Connection->State == CONNECTION_STATE_CONNECTING) &&
        (Connection->SubState == CONNECTION_SUBSTATE_C_W_ROUTE)) {

        // we dont need to hold CancelSpinLock so release it,
        // since we are releasing the locks out of order, we must
        // swap the irql to get the priorities right.

        NB_SWAP_IRQL( CancelLH, LockHandle1);
        NB_FREE_CANCEL_LOCK( CancelLH );

        //
        // Continue on with the session init frame.
        //

        (VOID)(*Device->Bind.QueryHandler)(   // We should check return code
            IPX_QUERY_LINE_INFO,

#if     defined(_PNP_POWER)
            &Connection->LocalTarget.NicHandle,
#else
            Connection->LocalTarget.NicId,
#endif  _PNP_POWER
            &Connection->LineInfo,
            sizeof(IPX_LINE_INFO),
            NULL);

        // Maximum packet size is the lower of RouterMtu and MaximumSendSize.
        Connection->MaximumPacketSize = NB_MIN( Device->RouterMtu - sizeof(IPX_HEADER) , Connection->LineInfo.MaximumSendSize ) - sizeof(NB_CONNECTION) ;

        Connection->ReceiveWindowSize = 6;
        Connection->SendWindowSize = 2;
        Connection->MaxSendWindowSize = 6;  // Base on what he sent ?

        //
        // Don't set RcvSequenceMax yet because we don't know
        // if the connection is old or new netbios.
        //

        Connection->SubState = CONNECTION_SUBSTATE_C_W_ACK;

        //
        // We found a route, we need to start the connect
        // process by sending out the session initialize
        // frame. We start the timer to handle retries.
        //
        // CTEStartTimer doesn't deal with changing the
        // expiration time of a running timer, so we have
        // to stop it first.  If we succeed in stopping the
        // timer, then the CREF_TIMER reference from the
        // previous starting of the timer remains, so we
        // don't need to reference the connection again.
        //

        if (!CTEStopTimer (&Connection->Timer)) {
            NbiReferenceConnectionLock (Connection, CREF_TIMER);
        }

        NB_FREE_LOCK (&Device->Lock, LockHandle2);

        CTEStartTimer(
            &Connection->Timer,
            Device->ConnectionTimeout,
            NbiConnectionTimeout,
            (PVOID)Connection);

        NB_FREE_LOCK (&Connection->Lock, LockHandle1);

        NbiSendSessionInitialize (Connection);

    } else if ((Connection->State == CONNECTION_STATE_LISTENING) &&
               (Connection->SubState == CONNECTION_SUBSTATE_L_W_ROUTE)) {

        if (Connection->ListenRequest != NULL) {

            NbiTransferReferenceConnection (Connection, CREF_LISTEN, CREF_ACTIVE);
            RequestToComplete = Connection->ListenRequest;
            Connection->ListenRequest = NULL;
            IoSetCancelRoutine (RequestToComplete, (PDRIVER_CANCEL)NULL);

        } else if (Connection->AcceptRequest != NULL) {

            NbiTransferReferenceConnection (Connection, CREF_ACCEPT, CREF_ACTIVE);
            RequestToComplete = Connection->AcceptRequest;
            Connection->AcceptRequest = NULL;

        } else {

            CTEAssert (FALSE);
            RequestToComplete = NULL;

        }

        // we dont need to hold CancelSpinLock so release it,
        // since we are releasing the locks out of order, we must
        // swap the irql to get the priorities right.

        NB_SWAP_IRQL( CancelLH, LockHandle1);
        NB_FREE_CANCEL_LOCK( CancelLH );

        (VOID)(*Device->Bind.QueryHandler)(   // We should check return code
            IPX_QUERY_LINE_INFO,
#if     defined(_PNP_POWER)
            &Connection->LocalTarget.NicHandle,
#else
            Connection->LocalTarget.NicId,
#endif  _PNP_POWER
            &Connection->LineInfo,
            sizeof(IPX_LINE_INFO),
            NULL);


        // Take the lowest of MaximumPacketSize ( set from the sessionInit
        // frame ), MaximumSendSize and RouterMtu.

        if (Connection->MaximumPacketSize > Connection->LineInfo.MaximumSendSize - sizeof(NB_CONNECTION)) {

            Connection->MaximumPacketSize = NB_MIN( Device->RouterMtu - sizeof(IPX_HEADER), Connection->LineInfo.MaximumSendSize ) - sizeof(NB_CONNECTION);

        } else {

            // Connection->MaximumPacketSize is what was set by the sender so already
            // accounts for the header.
            Connection->MaximumPacketSize = NB_MIN( Device->RouterMtu - sizeof(NB_CONNECTION) - sizeof(IPX_HEADER), Connection->MaximumPacketSize ) ;

        }

        Connection->ReceiveWindowSize = 6;
        Connection->SendWindowSize = 2;
        Connection->MaxSendWindowSize = 6;  // Base on what he sent ?

        if (Connection->NewNetbios) {
            CTEAssert (Connection->LocalRcvSequenceMax == 4);   // should have been set
            Connection->LocalRcvSequenceMax = Connection->ReceiveWindowSize;
        }

        Connection->State = CONNECTION_STATE_ACTIVE;
        Connection->SubState = CONNECTION_SUBSTATE_A_IDLE;
        Connection->ReceiveState = CONNECTION_RECEIVE_IDLE;

        ++Device->Statistics.OpenConnections;


        NB_FREE_LOCK (&Device->Lock, LockHandle2);

        //
        // StartWatchdog acquires TimerLock, so we have to
        // free Lock first.
        //


        NbiStartWatchdog (Connection);

        //
        // This releases the connection lock, so that SessionInitAckData
        // can't be freed before it is copied.
        //

        NbiSendSessionInitAck(
            Connection,
            Connection->SessionInitAckData,
            Connection->SessionInitAckDataLength,
            &LockHandle1);

        if (RequestToComplete != NULL) {

            REQUEST_STATUS(RequestToComplete) = STATUS_SUCCESS;

            NbiCompleteRequest (RequestToComplete);
            NbiFreeRequest (Device, RequestToComplete);

        }

    } else {

        NB_FREE_LOCK (&Device->Lock, LockHandle2);
        NB_FREE_LOCK (&Connection->Lock, LockHandle1);
        NB_FREE_CANCEL_LOCK( CancelLH );

    }

    NbiDereferenceConnection (Connection, CREF_FIND_ROUTE);

}   /* NbiFindRouteComplete */


NTSTATUS
NbiOpenConnection(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine is called to open a connection. Note that the connection that
    is open is of little use until associated with an address; until then,
    the only thing that can be done with it is close it.

Arguments:

    Device - Pointer to the device for this driver.

    Request - Pointer to the request representing the open.

Return Value:

    The function value is the status of the operation.

--*/

{
    PCONNECTION Connection;
    PFILE_FULL_EA_INFORMATION ea;
#ifdef ISN_NT
    PIRP Irp = (PIRP)Request;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
#endif

    //
    // Verify Minimum Buffer length!
    // Bug#: 203814
    //
    ea = (PFILE_FULL_EA_INFORMATION)Irp->AssociatedIrp.SystemBuffer;
    if (ea->EaValueLength < sizeof(PVOID))
    {
        NbiPrint2("NbiOpenConnection: ERROR -- (EaValueLength=%d < Min=%d)\n",
            ea->EaValueLength, sizeof(PVOID));
        CTEAssert(FALSE);
        return (STATUS_INVALID_ADDRESS_COMPONENT);
    }

    //
    // First, try to make a connection object to represent this pending
    // connection.  Then fill in the relevant fields.
    // In addition to the creation, if successful NbfCreateConnection
    // will create a second reference which is removed once the request
    // references the connection, or if the function exits before that.

    if (!(Connection = NbiCreateConnection (Device))) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // set the connection context so we can connect the user to this data
    // structure
    //
    RtlCopyMemory ( &Connection->Context, &ea->EaName[ea->EaNameLength+1], sizeof (PVOID));

    //
    // let file object point at connection and connection at file object
    //

    REQUEST_OPEN_CONTEXT(Request) = (PVOID)Connection;
    REQUEST_OPEN_TYPE(Request) = (PVOID)TDI_CONNECTION_FILE;
#ifdef ISN_NT
    Connection->FileObject = IrpSp->FileObject;
#endif

    return STATUS_SUCCESS;

}   /* NbiOpenConnection */


VOID
NbiStopConnection(
    IN PCONNECTION Connection,
    IN NTSTATUS DisconnectStatus
    IN NB_LOCK_HANDLE_PARAM(LockHandle)
    )

/*++

Routine Description:

    This routine is called to stop an active connection.

    THIS ROUTINE IS CALLED WITH THE CONNECTION LOCK HELD
    AND RETURNS WITH IT RELEASED.

Arguments:

    Connection - The connection to be stopped.

    DisconnectStatus - The reason for the disconnect. One of:
        STATUS_LINK_FAILED: We timed out trying to probe the remote.
        STATUS_REMOTE_DISCONNECT: The remote sent a session end.
        STATUS_LOCAL_DISCONNECT: The local side disconnected.
        STATUS_CANCELLED: A send or receive on this connection was cancelled.
        STATUS_INVALID_CONNECTION: The local side closed the connection.
        STATUS_INVALID_ADDRESS: The local side closed the address.

    LockHandle - The handle which the connection lock was acquired with.

Return Value:

    None.

--*/

{
    PREQUEST ListenRequest, AcceptRequest, SendRequest, ReceiveRequest,
                DisconnectWaitRequest, ConnectRequest;
    PREQUEST Request, TmpRequest;
    BOOLEAN DerefForPacketize;
    BOOLEAN DerefForWaitPacket;
    BOOLEAN DerefForActive;
    BOOLEAN DerefForWaitCache;
    BOOLEAN SendSessionEnd;
    BOOLEAN ActiveReceive;
    BOOLEAN IndicateToClient;
    BOOLEAN ConnectionWasActive;
    PDEVICE Device = NbiDevice;
    PADDRESS_FILE AddressFile;
    NB_DEFINE_LOCK_HANDLE (LockHandle2)
    NB_DEFINE_LOCK_HANDLE (LockHandle3)
    CTELockHandle   CancelLH;


    NB_DEBUG2 (CONNECTION, ("Stop connection %lx (%lx)\n", Connection, DisconnectStatus));

    //
    // These flags control our actions after we set the state to
    // DISCONNECT.
    //

    DerefForPacketize = FALSE;
    DerefForWaitPacket = FALSE;
    DerefForActive = FALSE;
    DerefForWaitCache = FALSE;
    SendSessionEnd = FALSE;
    ActiveReceive = FALSE;
    IndicateToClient = FALSE;
    ConnectionWasActive = FALSE;

    //
    // These contain requests or queues of request to complete.
    //

    ListenRequest = NULL;
    AcceptRequest = NULL;
    SendRequest = NULL;
    ReceiveRequest = NULL;
    DisconnectWaitRequest = NULL;
    ConnectRequest = NULL;

    NB_SYNC_GET_LOCK (&Device->Lock, &LockHandle2);

    if (Connection->State == CONNECTION_STATE_ACTIVE) {

        --Device->Statistics.OpenConnections;

        ConnectionWasActive = TRUE;

        Connection->Status = DisconnectStatus;

        if ((DisconnectStatus == STATUS_LINK_FAILED) ||
            (DisconnectStatus == STATUS_LOCAL_DISCONNECT)) {

            //
            // Send out session end frames, but fewer if
            // we timed out.
            //
            // What about STATUS_CANCELLED?
            //

            Connection->Retries = (DisconnectStatus == STATUS_LOCAL_DISCONNECT) ?
                                      Device->ConnectionCount :
                                      (Device->ConnectionCount / 2);

            SendSessionEnd = TRUE;
            Connection->SubState = CONNECTION_SUBSTATE_D_W_ACK;

            //
            // CTEStartTimer doesn't deal with changing the
            // expiration time of a running timer, so we have
            // to stop it first.  If we succeed in stopping the
            // timer, then the CREF_TIMER reference from the
            // previous starting of the timer remains, so we
            // don't need to reference the connection again.
            //

            if (!CTEStopTimer (&Connection->Timer)) {
                NbiReferenceConnectionLock (Connection, CREF_TIMER);
            }

            CTEStartTimer(
                &Connection->Timer,
                Device->ConnectionTimeout,
                NbiConnectionTimeout,
                (PVOID)Connection);

        }

        if (Connection->ReceiveState == CONNECTION_RECEIVE_TRANSFER) {
            ActiveReceive = TRUE;
        }

        Connection->State = CONNECTION_STATE_DISCONNECT;
        DerefForActive = TRUE;

        if (Connection->DisconnectWaitRequest != NULL) {
            DisconnectWaitRequest = Connection->DisconnectWaitRequest;
            Connection->DisconnectWaitRequest = NULL;
        }

        if ((DisconnectStatus == STATUS_LINK_FAILED) ||
            (DisconnectStatus == STATUS_REMOTE_DISCONNECT) ||
            (DisconnectStatus == STATUS_CANCELLED)) {

            IndicateToClient = TRUE;

        }

        //
        // If we are inside NbiAssignSequenceAndSend, add
        // a reference so the connection won't go away during it.
        //

        if (Connection->NdisSendsInProgress > 0) {
            *(Connection->NdisSendReference) = TRUE;
            NB_DEBUG2 (SEND, ("Adding CREF_NDIS_SEND to %lx\n", Connection));
            NbiReferenceConnectionLock (Connection, CREF_NDIS_SEND);
        }

        //
        // Clean up some other stuff.
        //

        Connection->ReceiveUnaccepted = 0;
        Connection->CurrentIndicateOffset = 0;

        //
        // Update our counters. Some of these we never use.
        //

        switch (DisconnectStatus) {

        case STATUS_LOCAL_DISCONNECT:
            ++Device->Statistics.LocalDisconnects;
            break;
        case STATUS_REMOTE_DISCONNECT:
            ++Device->Statistics.RemoteDisconnects;
            break;
        case STATUS_LINK_FAILED:
            ++Device->Statistics.LinkFailures;
            break;
        case STATUS_IO_TIMEOUT:
            ++Device->Statistics.SessionTimeouts;
            break;
        case STATUS_CANCELLED:
            ++Device->Statistics.CancelledConnections;
            break;
        case STATUS_REMOTE_RESOURCES:
            ++Device->Statistics.RemoteResourceFailures;
            break;
        case STATUS_INVALID_CONNECTION:
        case STATUS_INVALID_ADDRESS:
        case STATUS_INSUFFICIENT_RESOURCES:
            ++Device->Statistics.LocalResourceFailures;
            break;
        case STATUS_BAD_NETWORK_PATH:
        case STATUS_REMOTE_NOT_LISTENING:
            ++Device->Statistics.NotFoundFailures;
            break;
        default:
            CTEAssert(FALSE);
            break;
        }

    } else if (Connection->State == CONNECTION_STATE_CONNECTING) {

        //
        // There is a connect in progress. We have to find ourselves
        // in the pending connect queue if we are there.
        //

        if (Connection->SubState == CONNECTION_SUBSTATE_C_FIND_NAME) {
            RemoveEntryList (REQUEST_LINKAGE(Connection->ConnectRequest));
            DerefForWaitCache = TRUE;
        }

        if (Connection->SubState != CONNECTION_SUBSTATE_C_DISCONN) {

            ConnectRequest = Connection->ConnectRequest;
            Connection->ConnectRequest = NULL;

            Connection->SubState = CONNECTION_SUBSTATE_C_DISCONN;

        }

    }


    //
    // If we allocated this memory, free it.
    //

    if (Connection->SessionInitAckDataLength > 0) {

        NbiFreeMemory(
            Connection->SessionInitAckData,
            Connection->SessionInitAckDataLength,
            MEMORY_CONNECTION,
            "SessionInitAckData");
        Connection->SessionInitAckData = NULL;
        Connection->SessionInitAckDataLength = 0;

    }


    if (Connection->ListenRequest != NULL) {

        ListenRequest = Connection->ListenRequest;
        Connection->ListenRequest = NULL;
        RemoveEntryList (REQUEST_LINKAGE(ListenRequest));   // take out of Device->ListenQueue

    }

    if (Connection->AcceptRequest != NULL) {

        AcceptRequest = Connection->AcceptRequest;
        Connection->AcceptRequest = NULL;

    }


    //
    // Do we need to stop the connection timer?
    // I don't think so.
    //



    //
    // A lot of this we only have to tear down if we were
    // active before this, because once we are stopping nothing
    // new will get started.  Some of the other stuff
    // can be put inside this if also.
    //

    if (ConnectionWasActive) {

        //
        // Stop any receives. If there is one that is actively
        // transferring we leave it and just run down the rest
        // of the queue. If not, we queue the rest of the
        // queue on the back of the current one and run
        // down them all.
        //

        if (ActiveReceive) {

            ReceiveRequest = Connection->ReceiveQueue.Head;

            //
            // Connection->ReceiveRequest will get set to NULL
            // when the transfer completes.
            //

        } else {

            ReceiveRequest = Connection->ReceiveRequest;
            if (ReceiveRequest) {
                REQUEST_SINGLE_LINKAGE (ReceiveRequest) = Connection->ReceiveQueue.Head;
            } else {
                ReceiveRequest = Connection->ReceiveQueue.Head;
            }
            Connection->ReceiveRequest = NULL;

        }

        Connection->ReceiveQueue.Head = NULL;


        if ((Request = Connection->FirstMessageRequest) != NULL) {

            //
            // If the current request has some sends outstanding, then
            // we dequeue it from the queue to let it complete when
            // the sends complete. In that case we set SendRequest
            // to be the rest of the queue, which will be aborted.
            // If the current request has no sends, then we put
            // queue everything to SendRequest to be aborted below.
            //

#if DBG
            if (REQUEST_REFCOUNT(Request) > 100) {
                DbgPrint ("Request %lx (%lx) has high refcount\n",
                    Connection, Request);
                DbgBreakPoint();
            }
#endif
            if (--REQUEST_REFCOUNT(Request) == 0) {

                //
                // NOTE: If this is a multi-request message, then
                // the linkage of Request will already point to the
                // send queue head, but we don't bother checking.
                //

                SendRequest = Request;
                REQUEST_SINGLE_LINKAGE (Request) = Connection->SendQueue.Head;

            } else {

                if (Connection->FirstMessageRequest == Connection->LastMessageRequest) {

                    REQUEST_SINGLE_LINKAGE (Request) = NULL;

                } else {

                    Connection->SendQueue.Head = REQUEST_SINGLE_LINKAGE (Connection->LastMessageRequest);
                    REQUEST_SINGLE_LINKAGE (Connection->LastMessageRequest) = NULL;

                }

                SendRequest = Connection->SendQueue.Head;

            }

            Connection->FirstMessageRequest = NULL;

        } else {

            //
            // This may happen if we were sending a probe when a
            // send was submitted, and the probe timed out.
            //

            SendRequest = Connection->SendQueue.Head;

        }

        Connection->SendQueue.Head = NULL;

    }


    if (Connection->OnWaitPacketQueue) {
        Connection->OnWaitPacketQueue = FALSE;
        RemoveEntryList (&Connection->WaitPacketLinkage);
        DerefForWaitPacket = TRUE;
    }

    if (Connection->OnPacketizeQueue) {
        Connection->OnPacketizeQueue = FALSE;
        RemoveEntryList (&Connection->PacketizeLinkage);
        DerefForPacketize = TRUE;
    }

    //
    // Should we check if DataAckPending is TRUE and send an ack??
    //

    Connection->DataAckPending = FALSE;
    Connection->PiggybackAckTimeout = FALSE;
    Connection->ReceivesWithoutAck = 0;

    NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle2);

    //
    // We can't acquire TimerLock with Lock held, since
    // we sometimes call ReferenceConnection (which does an
    // interlocked add using Lock) with TimerLock held.
    //

    NB_SYNC_GET_LOCK (&Device->TimerLock, &LockHandle3);

    if (Connection->OnShortList) {
        Connection->OnShortList = FALSE;
        RemoveEntryList (&Connection->ShortList);
    }

    if (Connection->OnLongList) {
        Connection->OnLongList = FALSE;
        RemoveEntryList (&Connection->LongList);
    }

    if (Connection->OnDataAckQueue) {
        Connection->OnDataAckQueue = FALSE;
        RemoveEntryList (&Connection->DataAckLinkage);
        Device->DataAckQueueChanged = TRUE;
    }

    NB_SYNC_FREE_LOCK (&Device->TimerLock, LockHandle3);

    NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);


    if (IndicateToClient) {

        AddressFile = Connection->AddressFile;

        if (AddressFile->RegisteredHandler[TDI_EVENT_DISCONNECT]) {

            NB_DEBUG2 (CONNECTION, ("Session end indicated on connection %lx\n", Connection));

            (*AddressFile->DisconnectHandler)(
                AddressFile->HandlerContexts[TDI_EVENT_DISCONNECT],
                Connection->Context,
                0,                        // DisconnectData
                NULL,
                0,                        // DisconnectInformation
                NULL,
                TDI_DISCONNECT_RELEASE);  // DisconnectReason.

        }

    }


    if (DisconnectWaitRequest != NULL) {

        //
        // Make the TDI tester happy by returning CONNECTION_RESET
        // here.
        //

        if (DisconnectStatus == STATUS_REMOTE_DISCONNECT) {
            REQUEST_STATUS(DisconnectWaitRequest) = STATUS_CONNECTION_RESET;
        } else {
            REQUEST_STATUS(DisconnectWaitRequest) = DisconnectStatus;
        }

        NB_GET_CANCEL_LOCK( &CancelLH );
        IoSetCancelRoutine (DisconnectWaitRequest, (PDRIVER_CANCEL)NULL);
        NB_FREE_CANCEL_LOCK ( CancelLH );

        NbiCompleteRequest (DisconnectWaitRequest);
        NbiFreeRequest (Device, DisconnectWaitRequest);

    }

    if (ConnectRequest != NULL) {

        REQUEST_STATUS (ConnectRequest) = STATUS_LOCAL_DISCONNECT;

        NB_GET_CANCEL_LOCK( &CancelLH );
        IoSetCancelRoutine (ConnectRequest, (PDRIVER_CANCEL)NULL);
        NB_FREE_CANCEL_LOCK ( CancelLH );

        NbiCompleteRequest(ConnectRequest);
        NbiFreeRequest (Device, ConnectRequest);

        NbiDereferenceConnection (Connection, CREF_CONNECT);

    }

    if (ListenRequest != NULL) {

        REQUEST_INFORMATION(ListenRequest) = 0;
        REQUEST_STATUS(ListenRequest) = STATUS_LOCAL_DISCONNECT;

        NB_GET_CANCEL_LOCK( &CancelLH );
        IoSetCancelRoutine (ListenRequest, (PDRIVER_CANCEL)NULL);
        NB_FREE_CANCEL_LOCK ( CancelLH );

        NbiCompleteRequest (ListenRequest);
        NbiFreeRequest(Device, ListenRequest);

        NbiDereferenceConnection (Connection, CREF_LISTEN);

    }

    if (AcceptRequest != NULL) {

        REQUEST_INFORMATION(AcceptRequest) = 0;
        REQUEST_STATUS(AcceptRequest) = STATUS_LOCAL_DISCONNECT;

        NbiCompleteRequest (AcceptRequest);
        NbiFreeRequest(Device, AcceptRequest);

        NbiDereferenceConnection (Connection, CREF_ACCEPT);

    }

    while (ReceiveRequest != NULL) {

        TmpRequest = REQUEST_SINGLE_LINKAGE (ReceiveRequest);

        REQUEST_STATUS (ReceiveRequest) = DisconnectStatus;
        REQUEST_INFORMATION (ReceiveRequest) = 0;

        NB_DEBUG2 (RECEIVE, ("StopConnection aborting receive %lx\n", ReceiveRequest));

        NB_GET_CANCEL_LOCK( &CancelLH );
        IoSetCancelRoutine (ReceiveRequest, (PDRIVER_CANCEL)NULL);
        NB_FREE_CANCEL_LOCK ( CancelLH );

        NbiCompleteRequest (ReceiveRequest);
        NbiFreeRequest (Device, ReceiveRequest);

        ++Connection->ConnectionInfo.ReceiveErrors;

        ReceiveRequest = TmpRequest;

        NbiDereferenceConnection (Connection, CREF_RECEIVE);

    }

    while (SendRequest != NULL) {

        TmpRequest = REQUEST_SINGLE_LINKAGE (SendRequest);

        REQUEST_STATUS (SendRequest) = DisconnectStatus;
        REQUEST_INFORMATION (SendRequest) = 0;

        NB_DEBUG2 (SEND, ("StopConnection aborting send %lx\n", SendRequest));

        NB_GET_CANCEL_LOCK( &CancelLH );
        IoSetCancelRoutine (SendRequest, (PDRIVER_CANCEL)NULL);
        NB_FREE_CANCEL_LOCK ( CancelLH );

        NbiCompleteRequest (SendRequest);
        NbiFreeRequest (Device, SendRequest);

        ++Connection->ConnectionInfo.TransmissionErrors;

        SendRequest = TmpRequest;

        NbiDereferenceConnection (Connection, CREF_SEND);

    }

    if (SendSessionEnd) {
        NbiSendSessionEnd (Connection);
    }

    if (DerefForWaitCache) {
        NbiDereferenceConnection (Connection, CREF_WAIT_CACHE);
    }

    if (DerefForPacketize) {
        NbiDereferenceConnection (Connection, CREF_PACKETIZE);
    }

    if (DerefForWaitPacket) {
        NbiDereferenceConnection (Connection, CREF_W_PACKET);
    }

    if (DerefForActive) {
        NbiDereferenceConnection (Connection, CREF_ACTIVE);
    }

}   /* NbiStopConnection */


NTSTATUS
NbiCloseConnection(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine is called to close a connection.

Arguments:

    Device - Pointer to the device for this driver.

    Request - Pointer to the request representing the open.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    PCONNECTION Connection;
    PADDRESS_FILE AddressFile;
    PADDRESS Address;
    CTELockHandle LockHandle;

    Connection = (PCONNECTION)REQUEST_OPEN_CONTEXT(Request);

    NB_DEBUG2 (CONNECTION, ("Close connection %lx\n", Connection));

    NB_GET_LOCK (&Device->Lock, &LockHandle);

    if (Connection->ReferenceCount == 0) {

        //
        // If we are associated with an address, we need
        // to simulate a disassociate at this point.
        //

        if ((Connection->AddressFile != NULL) &&
            (Connection->AddressFile != (PVOID)-1)) {

            AddressFile = Connection->AddressFile;
            Connection->AddressFile = (PVOID)-1;

            NB_FREE_LOCK (&Device->Lock, LockHandle);

            //
            // Take this connection out of the address file's list.
            //

            Address = AddressFile->Address;
            NB_GET_LOCK (&Address->Lock, &LockHandle);

            if (Connection->AddressFileLinked) {
                Connection->AddressFileLinked = FALSE;
                RemoveEntryList (&Connection->AddressFileLinkage);
            }

            //
            // We are done.
            //

            NB_FREE_LOCK (&Address->Lock, LockHandle);

            Connection->AddressFile = NULL;

            //
            // Clean up the reference counts and complete any
            // disassociate requests that pended.
            //

            NbiDereferenceAddressFile (AddressFile, AFREF_CONNECTION);

            NB_GET_LOCK (&Device->Lock, &LockHandle);

        }

        //
        // Even if the ref count is zero and some thread has already done cleanup,
        // we can not destroy the connection bcoz some other thread might still be
        // in HandleConnectionZero routine. This could happen when 2 threads call into
        // HandleConnectionZero, one thread runs thru completion, close comes along
        // and the other thread is still in HandleConnectionZero routine.
        //

        if ( Connection->CanBeDestroyed && ( Connection->ThreadsInHandleConnectionZero == 0 ) ) {

            NB_FREE_LOCK (&Device->Lock, LockHandle);
            NbiDestroyConnection(Connection);
            Status = STATUS_SUCCESS;

        } else {

            Connection->ClosePending = Request;
            NB_FREE_LOCK (&Device->Lock, LockHandle);
            Status = STATUS_PENDING;

        }

    } else {

        Connection->ClosePending = Request;
        NB_FREE_LOCK (&Device->Lock, LockHandle);
        Status = STATUS_PENDING;

    }

    return Status;

}   /* NbiCloseConnection */


NTSTATUS
NbiTdiAssociateAddress(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine performs the association of the connection and
    the address for the user.

Arguments:

    Device - The netbios device.

    Request - The request describing the associate.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS Status;
    PCONNECTION Connection;
#ifdef ISN_NT
    PFILE_OBJECT FileObject;
#endif
    PADDRESS_FILE AddressFile;
    PADDRESS Address;
    PTDI_REQUEST_KERNEL_ASSOCIATE Parameters;
    CTELockHandle LockHandle;

    //
    // Check that the file type is valid (Bug# 203827)
    //
    if (REQUEST_OPEN_TYPE(Request) != (PVOID)TDI_CONNECTION_FILE)
    {
        CTEAssert(FALSE);
        return (STATUS_INVALID_ADDRESS_COMPONENT);
    }

    //
    // This references the connection.
    //
    Connection = (PCONNECTION)REQUEST_OPEN_CONTEXT(Request);
    Status = NbiVerifyConnection (Connection);
    if (!NT_SUCCESS (Status))
    {
        return Status;
    }

    //
    // The request request parameters hold
    // get a pointer to the address FileObject, which points us to the
    // transport's address object, which is where we want to put the
    // connection.
    //
    Parameters = (PTDI_REQUEST_KERNEL_ASSOCIATE)REQUEST_PARAMETERS(Request);

    Status = ObReferenceObjectByHandle (
                Parameters->AddressHandle,
                FILE_READ_DATA,
                *IoFileObjectType,
                Request->RequestorMode,
                (PVOID *)&FileObject,
                NULL);

    if ((!NT_SUCCESS(Status)) ||
        (FileObject->DeviceObject != &(NbiDevice->DeviceObject)) ||   // Bug# 171836
        (PtrToUlong(FileObject->FsContext2) != TDI_TRANSPORT_ADDRESS_FILE))
    {
        NbiDereferenceConnection (Connection, CREF_VERIFY);
        return STATUS_INVALID_HANDLE;
    }

    AddressFile = (PADDRESS_FILE)(FileObject->FsContext);

    //
    // Make sure the address file is valid, and reference it.
    //

#if     defined(_PNP_POWER)
    Status = NbiVerifyAddressFile (AddressFile, CONFLICT_IS_NOT_OK);
#else
    Status = NbiVerifyAddressFile (AddressFile);
#endif  _PNP_POWER

    if (!NT_SUCCESS(Status)) {

#ifdef ISN_NT
        ObDereferenceObject (FileObject);
#endif
        NbiDereferenceConnection (Connection, CREF_VERIFY);
        return Status;
    }

    NB_DEBUG2 (CONNECTION, ("Associate connection %lx with address file %lx\n",
                                Connection, AddressFile));


    //
    // Now insert the connection into the database of the address.
    //

    Address = AddressFile->Address;

    NB_GET_LOCK (&Address->Lock, &LockHandle);

    if (Connection->AddressFile != NULL) {

        //
        // The connection is already associated with
        // an address file.
        //

        NB_FREE_LOCK (&Address->Lock, LockHandle);
        NbiDereferenceAddressFile (AddressFile, AFREF_VERIFY);
        Status = STATUS_INVALID_CONNECTION;

    } else {

        if (AddressFile->State == ADDRESSFILE_STATE_OPEN) {

            Connection->AddressFile = AddressFile;
            Connection->AddressFileLinked = TRUE;
            InsertHeadList (&AddressFile->ConnectionDatabase, &Connection->AddressFileLinkage);
            NB_FREE_LOCK (&Address->Lock, LockHandle);

            NbiTransferReferenceAddressFile (AddressFile, AFREF_VERIFY, AFREF_CONNECTION);
            Status = STATUS_SUCCESS;

        } else {

            NB_FREE_LOCK (&Address->Lock, LockHandle);
            NbiDereferenceAddressFile (AddressFile, AFREF_VERIFY);
            Status = STATUS_INVALID_ADDRESS;
        }

    }

#ifdef ISN_NT

    //
    // We don't need the reference to the file object, we just
    // used it to get from the handle to the object.
    //

    ObDereferenceObject (FileObject);

#endif

    NbiDereferenceConnection (Connection, CREF_VERIFY);

    return Status;

}   /* NbiTdiAssociateAddress */


NTSTATUS
NbiTdiDisassociateAddress(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine performs the disassociation of the connection
    and the address for the user.

Arguments:

    Device - The netbios device.

    Request - The request describing the associate.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PCONNECTION Connection;
    NTSTATUS Status;
    PADDRESS_FILE AddressFile;
    PADDRESS Address;
    CTELockHandle LockHandle;
    NB_DEFINE_LOCK_HANDLE (LockHandle1)
    NB_DEFINE_SYNC_CONTEXT (SyncContext)

    //
    // Check that the file type is valid
    //
    if (REQUEST_OPEN_TYPE(Request) != (PVOID)TDI_CONNECTION_FILE)
    {
        CTEAssert(FALSE);
        return (STATUS_INVALID_ADDRESS_COMPONENT);
    }

    //
    // Check that the connection is valid. This references
    // the connection.
    //
    Connection = (PCONNECTION)REQUEST_OPEN_CONTEXT(Request);
    Status = NbiVerifyConnection (Connection);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    NB_DEBUG2 (CONNECTION, ("Disassociate connection %lx\n", Connection));


    //
    // First check if the connection is still active.
    //

    NB_BEGIN_SYNC (&SyncContext);

    NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle1);

    if (Connection->State != CONNECTION_STATE_INACTIVE) {

        //
        // This releases the lock.
        //

        NbiStopConnection(
            Connection,
            STATUS_INVALID_ADDRESS
            NB_LOCK_HANDLE_ARG (LockHandle1));

    } else {

        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle1);

    }

    //
    // Keep the sync through the function??
    //

    NB_END_SYNC (&SyncContext);


    NB_GET_LOCK (&Device->Lock, &LockHandle);

    //
    // Make sure the connection is associated and is not in the
    // middle of disassociating.
    //

    if ((Connection->AddressFile != NULL) &&
        (Connection->AddressFile != (PVOID)-1) &&
        (Connection->DisassociatePending == NULL)) {

        if (Connection->ReferenceCount == 0) {

            //
            // Because the connection still has a reference to
            // the address file, we know it is still valid. We
            // set the connection address file to the temporary
            // value of -1, which prevents somebody else from
            // disassociating it and also prevents a new association.
            //

            AddressFile = Connection->AddressFile;
            Connection->AddressFile = (PVOID)-1;

            NB_FREE_LOCK (&Device->Lock, LockHandle);

            Address = AddressFile->Address;
            NB_GET_LOCK (&Address->Lock, &LockHandle);

            if (Connection->AddressFileLinked) {
                Connection->AddressFileLinked = FALSE;
                RemoveEntryList (&Connection->AddressFileLinkage);
            }
            NB_FREE_LOCK (&Address->Lock, LockHandle);

            Connection->AddressFile = NULL;

            NbiDereferenceAddressFile (AddressFile, AFREF_CONNECTION);
            Status = STATUS_SUCCESS;

        } else {

            //
            // Set this so when the count goes to 0 it will
            // be disassociated and the request completed.
            //

            Connection->DisassociatePending = Request;
            NB_FREE_LOCK (&Device->Lock, LockHandle);
            Status = STATUS_PENDING;

        }

    } else {

        NB_FREE_LOCK (&Device->Lock, LockHandle);
        Status = STATUS_INVALID_CONNECTION;

    }

    NbiDereferenceConnection (Connection, CREF_VERIFY);

    return Status;

}   /* NbiTdiDisassociateAddress */


NTSTATUS
NbiTdiListen(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine posts a listen on a connection.

Arguments:

    Device - The netbios device.

    Request - The request describing the listen.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS Status;
    PCONNECTION Connection;
    CTELockHandle LockHandle1, LockHandle2;
    CTELockHandle CancelLH;

    //
    // Check that the file type is valid
    //
    if (REQUEST_OPEN_TYPE(Request) != (PVOID)TDI_CONNECTION_FILE)
    {
        CTEAssert(FALSE);
        return (STATUS_INVALID_ADDRESS_COMPONENT);
    }

    //
    // Check that the connection is valid. This references
    // the connection.
    //
    Connection = (PCONNECTION)REQUEST_OPEN_CONTEXT(Request);
    Status = NbiVerifyConnection (Connection);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    NB_GET_CANCEL_LOCK( &CancelLH );
    NB_GET_LOCK (&Connection->Lock, &LockHandle1);
    NB_GET_LOCK (&Device->Lock, &LockHandle2);

    //
    // The connection must be inactive, but associated and
    // with no disassociate or close pending.
    //

    if ((Connection->State == CONNECTION_STATE_INACTIVE) &&
        (Connection->AddressFile != NULL) &&
        (Connection->AddressFile != (PVOID)-1) &&
        (Connection->DisassociatePending == NULL) &&
        (Connection->ClosePending == NULL)) {

        Connection->State = CONNECTION_STATE_LISTENING;
        Connection->SubState = CONNECTION_SUBSTATE_L_WAITING;

        (VOID)NbiAssignConnectionId (Device, Connection);   // Check return code.


        if (!Request->Cancel) {

            NB_DEBUG2 (CONNECTION, ("Queued listen %lx on %lx\n", Request, Connection));
            InsertTailList (&Device->ListenQueue, REQUEST_LINKAGE(Request));
            IoSetCancelRoutine (Request, NbiCancelListen);
            Connection->ListenRequest = Request;
            NbiReferenceConnectionLock (Connection, CREF_LISTEN);
            Status = STATUS_PENDING;

        } else {

            NB_DEBUG2 (CONNECTION, ("Cancelled listen %lx on %lx\n", Request, Connection));
            Connection->State = CONNECTION_STATE_INACTIVE;
            Status = STATUS_CANCELLED;
        }

        NB_FREE_LOCK (&Device->Lock, LockHandle2);

    } else {

        NB_FREE_LOCK (&Device->Lock, LockHandle2);
        Status = STATUS_INVALID_CONNECTION;

    }

    NB_FREE_LOCK (&Connection->Lock, LockHandle1);
    NB_FREE_CANCEL_LOCK( CancelLH );

    NbiDereferenceConnection (Connection, CREF_VERIFY);

    return Status;

}   /* NbiTdiListen */


NTSTATUS
NbiTdiAccept(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine accepts a connection to a remote machine. The
    connection must previously have completed a listen with
    the TDI_QUERY_ACCEPT flag on.

Arguments:

    Device - The netbios device.

    Request - The request describing the accept.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS Status;
    PCONNECTION Connection;
    CTELockHandle LockHandle1, LockHandle2;

    //
    // Check that the file type is valid
    //
    if (REQUEST_OPEN_TYPE(Request) != (PVOID)TDI_CONNECTION_FILE)
    {
        CTEAssert(FALSE);
        return (STATUS_INVALID_ADDRESS_COMPONENT);
    }

    //
    // Check that the connection is valid. This references
    // the connection.
    //
    Connection = (PCONNECTION)REQUEST_OPEN_CONTEXT(Request);
    Status = NbiVerifyConnection (Connection);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    NB_GET_LOCK (&Connection->Lock, &LockHandle1);
    NB_GET_LOCK (&Device->Lock, &LockHandle2);

    if ((Connection->State == CONNECTION_STATE_LISTENING) &&
        (Connection->SubState == CONNECTION_SUBSTATE_L_W_ACCEPT)) {

        Connection->SubState = CONNECTION_SUBSTATE_L_W_ROUTE;

        NbiTransferReferenceConnection (Connection, CREF_W_ACCEPT, CREF_ACCEPT);
        Connection->AcceptRequest = Request;

        NbiReferenceConnectionLock (Connection, CREF_FIND_ROUTE);

        NB_FREE_LOCK (&Device->Lock, LockHandle2);

        Connection->Retries = NbiDevice->KeepAliveCount;

        NB_FREE_LOCK (&Connection->Lock, LockHandle1);

        *(UNALIGNED ULONG *)Connection->FindRouteRequest.Network =
            *(UNALIGNED ULONG *)Connection->RemoteHeader.DestinationNetwork;
        RtlCopyMemory(Connection->FindRouteRequest.Node,Connection->RemoteHeader.DestinationNode,6);
        Connection->FindRouteRequest.Identifier = IDENTIFIER_NB;
        Connection->FindRouteRequest.Type = IPX_FIND_ROUTE_NO_RIP;

        //
        // When this completes, we will send the session init
        // ack. We don't call it if the client is for network 0,
        // instead just fake as if no route could be found
        // and we will use the local target we got here.
        // The accept is completed when this completes.
        //

        if (*(UNALIGNED ULONG *)Connection->RemoteHeader.DestinationNetwork != 0) {

            (*Device->Bind.FindRouteHandler)(
                &Connection->FindRouteRequest);

        } else {

            NbiFindRouteComplete(
                &Connection->FindRouteRequest,
                FALSE);

        }

        NB_DEBUG2 (CONNECTION, ("Accept received on %lx\n", Connection));

        Status = STATUS_PENDING;

    } else {

        NB_DEBUG (CONNECTION, ("Accept received on invalid connection %lx\n", Connection));

        NB_FREE_LOCK (&Device->Lock, LockHandle2);
        NB_FREE_LOCK (&Connection->Lock, LockHandle1);
        Status = STATUS_INVALID_CONNECTION;

    }

    NbiDereferenceConnection (Connection, CREF_VERIFY);

    return Status;

}   /* NbiTdiAccept */


NTSTATUS
NbiTdiConnect(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine connects to a remote machine.

Arguments:

    Device - The netbios device.

    Request - The request describing the connect.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS Status;
    PCONNECTION Connection;
    TDI_ADDRESS_NETBIOS * RemoteName;
    PTDI_REQUEST_KERNEL_CONNECT Parameters;
#if 0
    PLARGE_INTEGER RequestedTimeout;
    LARGE_INTEGER RealTimeout;
#endif
    PNETBIOS_CACHE CacheName;
    CTELockHandle LockHandle1, LockHandle2;
    CTELockHandle CancelLH;
    BOOLEAN bLockFreed = FALSE;

    //
    // Check that the file type is valid
    //
    if (REQUEST_OPEN_TYPE(Request) != (PVOID)TDI_CONNECTION_FILE)
    {
        CTEAssert(FALSE);
        return (STATUS_INVALID_ADDRESS_COMPONENT);
    }

    //
    // Check that the connection is valid. This references
    // the connection.
    //
    Connection = (PCONNECTION)REQUEST_OPEN_CONTEXT(Request);
    Status = NbiVerifyConnection (Connection);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    NB_GET_CANCEL_LOCK( &CancelLH );
    NB_GET_LOCK (&Connection->Lock, &LockHandle1);
    NB_GET_LOCK (&Device->Lock, &LockHandle2);

    //
    // The connection must be inactive, but associated and
    // with no disassociate or close pending.
    //

    if ((Connection->State == CONNECTION_STATE_INACTIVE) &&
        (Connection->AddressFile != NULL) &&
        (Connection->AddressFile != (PVOID)-1) &&
        (Connection->DisassociatePending == NULL) &&
        (Connection->ClosePending == NULL)) {

        try
        {
            Parameters = (PTDI_REQUEST_KERNEL_CONNECT)REQUEST_PARAMETERS(Request);
            RemoteName = NbiParseTdiAddress(
                            (PTRANSPORT_ADDRESS)(Parameters->RequestConnectionInformation->RemoteAddress),
                            Parameters->RequestConnectionInformation->RemoteAddressLength,
                            FALSE);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            NbiPrint1("NbiTdiConnect: Exception <0x%x> accessing connect info\n", GetExceptionCode());
            RemoteName = NULL;
        }

        if (RemoteName == NULL) {

            //
            // There is no netbios remote address specified.
            //

            NB_FREE_LOCK (&Device->Lock, LockHandle2);
            Status = STATUS_BAD_NETWORK_PATH;

        } else {

            NbiReferenceConnectionLock (Connection, CREF_CONNECT);
            Connection->State = CONNECTION_STATE_CONNECTING;
            RtlCopyMemory (Connection->RemoteName, RemoteName->NetbiosName, 16);

            Connection->Retries = Device->ConnectionCount;

            (VOID)NbiAssignConnectionId (Device, Connection);     // Check return code.

            Status = NbiTdiConnectFindName(
                       Device,
                       Request,
                       Connection,
                       CancelLH,
                       LockHandle1,
                       LockHandle2,
                       &bLockFreed);

        }

    } else {

        NB_DEBUG (CONNECTION, ("Connect on invalid connection %lx\n", Connection));

        NB_FREE_LOCK (&Device->Lock, LockHandle2);
        Status = STATUS_INVALID_CONNECTION;

    }

    if (!bLockFreed) {
        NB_FREE_LOCK (&Connection->Lock, LockHandle1);
        NB_FREE_CANCEL_LOCK( CancelLH );
    }

    NbiDereferenceConnection (Connection, CREF_VERIFY);

    return Status;

}   /* NbiTdiConnect */


NTSTATUS
NbiTdiConnectFindName(
    IN PDEVICE Device,
    IN PREQUEST Request,
    IN PCONNECTION Connection,
    IN CTELockHandle CancelLH,
    IN CTELockHandle ConnectionLH,
    IN CTELockHandle DeviceLH,
    IN PBOOLEAN pbLockFreed
    )
{
    NTSTATUS Status;
    PNETBIOS_CACHE CacheName;

    //
    // See what is up with this Netbios name.
    //

    Status = CacheFindName(
                 Device,
                 FindNameConnect,
                 Connection->RemoteName,
                 &CacheName);

    if (Status == STATUS_PENDING) {

        //
        // A request for routes to this name has been
        // sent out on the net, we queue up this connect
        // request and processing will be resumed when
        // we get a response.
        //

        Connection->SubState = CONNECTION_SUBSTATE_C_FIND_NAME;


        if (!Request->Cancel) {

            InsertTailList( &Device->WaitingConnects, REQUEST_LINKAGE(Request));
            IoSetCancelRoutine (Request, NbiCancelConnectFindName);
            Connection->ConnectRequest = Request;
            NbiReferenceConnectionLock (Connection, CREF_WAIT_CACHE);
            NB_DEBUG2 (CONNECTION, ("Queueing up connect %lx on %lx\n",
                                        Request, Connection));

            NB_FREE_LOCK (&Device->Lock, DeviceLH);

        } else {

            NB_DEBUG2 (CONNECTION, ("Cancelled connect %lx on %lx\n", Request, Connection));
            Connection->SubState = CONNECTION_SUBSTATE_C_DISCONN;

            NB_FREE_LOCK (&Device->Lock, DeviceLH);
            NbiDereferenceConnection (Connection, CREF_CONNECT);

            Status = STATUS_CANCELLED;
        }

    } else if (Status == STATUS_SUCCESS) {

        //
        // We don't need to worry about referencing CacheName
        // because we stop using it before we release the lock.
        //

        Connection->SubState = CONNECTION_SUBSTATE_C_W_ROUTE;


        if (!Request->Cancel) {

            IoSetCancelRoutine (Request, NbiCancelConnectWaitResponse);

            // we dont need to hold CancelSpinLock so release it,
            // since we are releasing the locks out of order, we must
            // swap the irql to get the priorities right.

            NB_SWAP_IRQL( CancelLH, ConnectionLH);
            NB_FREE_CANCEL_LOCK( CancelLH );

            Connection->LocalTarget = CacheName->Networks[0].LocalTarget;
            RtlCopyMemory(&Connection->RemoteHeader.DestinationNetwork, &CacheName->FirstResponse, 12);

            Connection->ConnectRequest = Request;
            NbiReferenceConnectionLock (Connection, CREF_FIND_ROUTE);

            NB_DEBUG2 (CONNECTION, ("Found connect cached %lx on %lx\n",
                                        Request, Connection));

            NB_FREE_LOCK (&Device->Lock, DeviceLH);
            NB_FREE_LOCK (&Connection->Lock, ConnectionLH);

            *(UNALIGNED ULONG *)Connection->FindRouteRequest.Network = CacheName->FirstResponse.NetworkAddress;
            RtlCopyMemory(Connection->FindRouteRequest.Node,CacheName->FirstResponse.NodeAddress,6);
            Connection->FindRouteRequest.Identifier = IDENTIFIER_NB;
            Connection->FindRouteRequest.Type = IPX_FIND_ROUTE_RIP_IF_NEEDED;

            //
            // When this completes, we will send the session init.
            // We don't call it if the client is for network 0,
            // instead just fake as if no route could be found
            // and we will use the local target we got here.
            //

            if (CacheName->FirstResponse.NetworkAddress != 0) {

                (*Device->Bind.FindRouteHandler)(
                    &Connection->FindRouteRequest);

            } else {

                NbiFindRouteComplete(
                    &Connection->FindRouteRequest,
                    FALSE);

            }

            Status = STATUS_PENDING;

            //
            // This jump is like falling out of the if, except
            // it skips over freeing the connection lock since
            // we just did that.
            //

            *pbLockFreed = TRUE;

        } else {

            NB_DEBUG2 (CONNECTION, ("Cancelled connect %lx on %lx\n", Request, Connection));
            Connection->SubState = CONNECTION_SUBSTATE_C_DISCONN;
            NB_FREE_LOCK (&Device->Lock, DeviceLH);

            NbiDereferenceConnection (Connection, CREF_CONNECT);

            Status = STATUS_CANCELLED;
        }

    } else {

        //
        // We could not find or queue a request for
        // this remote, fail it. When the refcount
        // drops the state will go to INACTIVE and
        // the connection ID will be deassigned.
        //

        if (Status == STATUS_DEVICE_DOES_NOT_EXIST) {
            Status = STATUS_BAD_NETWORK_PATH;
        }

        NB_FREE_LOCK (&Device->Lock, DeviceLH);

        NbiDereferenceConnection (Connection, CREF_CONNECT);
    }

    return Status;
}   /* NbiTdiConnectFindName */


NTSTATUS
NbiTdiDisconnect(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine connects to a remote machine.

Arguments:

    Device - The netbios device.

    Request - The request describing the connect.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS Status;
    PCONNECTION Connection;
    BOOLEAN DisconnectWait;
    NB_DEFINE_LOCK_HANDLE (LockHandle1)
    NB_DEFINE_LOCK_HANDLE (LockHandle2)
    NB_DEFINE_SYNC_CONTEXT (SyncContext)
    CTELockHandle   CancelLH;

    //
    // Check that the file type is valid
    //
    if (REQUEST_OPEN_TYPE(Request) != (PVOID)TDI_CONNECTION_FILE)
    {
        CTEAssert(FALSE);
        return (STATUS_INVALID_ADDRESS_COMPONENT);
    }

    //
    // Check that the connection is valid. This references
    // the connection.
    //
    Connection = (PCONNECTION)REQUEST_OPEN_CONTEXT(Request);
    Status = NbiVerifyConnection (Connection);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    DisconnectWait = (BOOLEAN)
        ((((PTDI_REQUEST_KERNEL_DISCONNECT)(REQUEST_PARAMETERS(Request)))->RequestFlags &
            TDI_DISCONNECT_WAIT) != 0);

    NB_GET_CANCEL_LOCK( &CancelLH );

    //
    // We need to be inside a sync because NbiStopConnection
    // expects that.
    //
    NB_BEGIN_SYNC (&SyncContext);

    NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle1);
    NB_SYNC_GET_LOCK (&Device->Lock, &LockHandle2);

    if (DisconnectWait) {

        if (Connection->State == CONNECTION_STATE_ACTIVE) {

            //
            // This disconnect wait will get completed by
            // NbiStopConnection.
            //

            if (Connection->DisconnectWaitRequest == NULL) {


                if (!Request->Cancel) {

                    IoSetCancelRoutine (Request, NbiCancelDisconnectWait);
                    NB_DEBUG2 (CONNECTION, ("Disconnect wait queued on connection %lx\n", Connection));
                    Connection->DisconnectWaitRequest = Request;
                    Status = STATUS_PENDING;

                } else {

                    NB_DEBUG2 (CONNECTION, ("Cancelled disconnect wait on connection %lx\n", Connection));
                    Status = STATUS_CANCELLED;
                }

            } else {

                //
                // We got a second disconnect request and we already
                // have one pending.
                //

                NB_DEBUG (CONNECTION, ("Disconnect wait failed, already queued on connection %lx\n", Connection));
                Status = STATUS_INVALID_CONNECTION;

            }

        } else if (Connection->State == CONNECTION_STATE_DISCONNECT) {

            NB_DEBUG (CONNECTION, ("Disconnect wait submitted on disconnected connection %lx\n", Connection));
            Status = Connection->Status;

        } else {

            NB_DEBUG (CONNECTION, ("Disconnect wait failed, bad state on connection %lx\n", Connection));
            Status = STATUS_INVALID_CONNECTION;

        }

        NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle2);
        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle1);
        NB_FREE_CANCEL_LOCK( CancelLH );

    } else {

        if (Connection->State == CONNECTION_STATE_ACTIVE) {

            // we dont need to hold CancelSpinLock so release it,
            // since we are releasing the locks out of order, we must
            // swap the irql to get the priorities right.

            NB_SYNC_SWAP_IRQL( CancelLH, LockHandle1);
            NB_FREE_CANCEL_LOCK( CancelLH );

            Connection->DisconnectRequest = Request;
            Status = STATUS_PENDING;

            NB_DEBUG2 (CONNECTION, ("Disconnect of active connection %lx\n", Connection));

            NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle2);


            //
            // This call releases the connection lock, sets
            // the state to DISCONNECTING, and sends out
            // the first session end.
            //

            NbiStopConnection(
                Connection,
                STATUS_LOCAL_DISCONNECT
                NB_LOCK_HANDLE_ARG (LockHandle1));

        } else if (Connection->State == CONNECTION_STATE_DISCONNECT) {

            //
            // There is already a disconnect pending. Queue
            // this one up so it completes when the refcount
            // goes to zero.
            //

            NB_DEBUG2 (CONNECTION, ("Disconnect of disconnecting connection %lx\n", Connection));

            if (Connection->DisconnectRequest == NULL) {
                Connection->DisconnectRequest = Request;
                Status = STATUS_PENDING;
            } else {
                Status = STATUS_SUCCESS;
            }

            NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle2);
            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle1);
            NB_FREE_CANCEL_LOCK ( CancelLH );

        } else if ((Connection->State == CONNECTION_STATE_LISTENING) &&
                   (Connection->SubState == CONNECTION_SUBSTATE_L_W_ACCEPT)) {

            //
            // We were waiting for an accept, but instead we got
            // a disconnect. Remove the reference and the teardown
            // will proceed. The disconnect will complete when the
            // refcount goes to zero.
            //

            NB_DEBUG2 (CONNECTION, ("Disconnect of accept pending connection %lx\n", Connection));

            if (Connection->DisconnectRequest == NULL) {
                Connection->DisconnectRequest = Request;
                Status = STATUS_PENDING;
            } else {
                Status = STATUS_SUCCESS;
            }
            NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle2);
            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle1);
            NB_FREE_CANCEL_LOCK ( CancelLH );

            NbiDereferenceConnection (Connection, CREF_W_ACCEPT);

        } else if (Connection->State == CONNECTION_STATE_CONNECTING) {

            // we dont need to hold CancelSpinLock so release it,
            // since we are releasing the locks out of order, we must
            // swap the irql to get the priorities right.

            NB_SYNC_SWAP_IRQL( CancelLH, LockHandle1);
            NB_FREE_CANCEL_LOCK( CancelLH );

            //
            // We are connecting, and got a disconnect. We call
            // NbiStopConnection which will handle this case
            // and abort the connect.
            //

            NB_DEBUG2 (CONNECTION, ("Disconnect of connecting connection %lx\n", Connection));

            if (Connection->DisconnectRequest == NULL) {
                Connection->DisconnectRequest = Request;
                Status = STATUS_PENDING;
            } else {
                Status = STATUS_SUCCESS;
            }

            NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle2);

            //
            // This call releases the connection lock and
            // aborts the connect request.
            //

            NbiStopConnection(
                Connection,
                STATUS_LOCAL_DISCONNECT
                NB_LOCK_HANDLE_ARG (LockHandle1));

        } else {

            NB_DEBUG2 (CONNECTION, ("Disconnect of invalid connection (%d) %lx\n",
                        Connection->State, Connection));

            NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle2);
            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle1);
            NB_FREE_CANCEL_LOCK( CancelLH );

            Status = STATUS_INVALID_CONNECTION;

        }

    }

    NB_END_SYNC (&SyncContext);

    NbiDereferenceConnection (Connection, CREF_VERIFY);

    return Status;

}   /* NbiTdiDisconnect */


BOOLEAN
NbiAssignConnectionId(
    IN PDEVICE Device,
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This routine is called to assign a connection ID. It picks
    one whose hash table has the fewest entries.

    THIS ROUTINE IS CALLED WITH THE LOCK HELD AND RETURNS WITH
    IT HELD. THE CONNECTION IS INSERTED INTO THE CORRECT HASH
    ENTRY BY THIS CALL.

Arguments:

    Device - The netbios device.

    Connection - The connection that needs an ID assigned.

Return Value:

    TRUE if it could be successfully assigned.

--*/

{
    UINT Hash;
    UINT i;
    USHORT ConnectionId, HashId;
    PCONNECTION CurConnection;


    CTEAssert (Connection->LocalConnectionId == 0xffff);

    //
    // Find the hash bucket with the fewest entries.
    //

    Hash = 0;
    for (i = 1; i < CONNECTION_HASH_COUNT; i++) {
        if (Device->ConnectionHash[i].ConnectionCount < Device->ConnectionHash[Hash].ConnectionCount) {
            Hash = i;
        }
    }


    //
    // Now find a valid connection ID within that bucket.
    //

    ConnectionId = Device->ConnectionHash[Hash].NextConnectionId;

    while (TRUE) {

        //
        // Scan through the list to see if this ID is in use.
        //

        HashId = (USHORT)(ConnectionId | (Hash << CONNECTION_HASH_SHIFT));

        CurConnection = Device->ConnectionHash[Hash].Connections;

        while (CurConnection != NULL) {
            if (CurConnection->LocalConnectionId != HashId) {
                CurConnection = CurConnection->NextConnection;
            } else {
                break;
            }
        }

        if (CurConnection == NULL) {
            break;
        }

        if (ConnectionId >= CONNECTION_MAXIMUM_ID) {
            ConnectionId = 1;
        } else {
            ++ConnectionId;
        }

        //
        //  What if we have 64K-1 sessions and loop forever?
        //
    }

    if (Device->ConnectionHash[Hash].NextConnectionId >= CONNECTION_MAXIMUM_ID) {
        Device->ConnectionHash[Hash].NextConnectionId = 1;
    } else {
        ++Device->ConnectionHash[Hash].NextConnectionId;
    }

    Connection->LocalConnectionId = HashId;
    Connection->RemoteConnectionId = 0xffff;
    NB_DEBUG2 (CONNECTION, ("Assigned ID %lx to %x\n", Connection->LocalConnectionId, Connection));

    Connection->NextConnection = Device->ConnectionHash[Hash].Connections;
    Device->ConnectionHash[Hash].Connections = Connection;
    ++Device->ConnectionHash[Hash].ConnectionCount;

    return TRUE;

}   /* NbiAssignConnectionId */


VOID
NbiDeassignConnectionId(
    IN PDEVICE Device,
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This routine is called to deassign a connection ID. It removes
    the connection from the hash bucket for its ID.

    THIS ROUTINE IS CALLED WITH THE LOCK HELD AND RETURNS WITH
    IT HELD.

Arguments:

    Device - The netbios device.

    Connection - The connection that needs an ID assigned.

Return Value:

    None.

--*/

{
    UINT Hash;
    PCONNECTION CurConnection;
    PCONNECTION * PrevConnection;

    //
    // Make sure the connection has a valid ID.
    //

    CTEAssert (Connection->LocalConnectionId != 0xffff);

    Hash = (Connection->LocalConnectionId & CONNECTION_HASH_MASK) >> CONNECTION_HASH_SHIFT;

    CurConnection = Device->ConnectionHash[Hash].Connections;
    PrevConnection = &Device->ConnectionHash[Hash].Connections;

    while (TRUE) {

        CTEAssert (CurConnection != NULL);

        //
        // We can loop until we find it because it should be
        // on here.
        //

        if (CurConnection == Connection) {
            *PrevConnection = Connection->NextConnection;
            --Device->ConnectionHash[Hash].ConnectionCount;
            break;
        }

        PrevConnection = &CurConnection->NextConnection;
        CurConnection = CurConnection->NextConnection;

    }

    Connection->LocalConnectionId = 0xffff;

}   /* NbiDeassignConnectionId */


VOID
NbiConnectionTimeout(
    IN CTEEvent * Event,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called when the connection timer expires.
    This is either because we need to send the next session
    initialize, or because our listen has timed out.

Arguments:

    Event - The event used to queue the timer.

    Context - The context, which is the connection.

Return Value:

    None.

--*/

{
    PCONNECTION Connection = (PCONNECTION)Context;
    PDEVICE Device = NbiDevice;
    PREQUEST Request;
    NB_DEFINE_LOCK_HANDLE (LockHandle)
    NB_DEFINE_LOCK_HANDLE (CancelLH)

    //
    // Take the lock and see what we need to do.
    //
    NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);

    if ((Connection->State == CONNECTION_STATE_CONNECTING) &&
        (Connection->SubState != CONNECTION_SUBSTATE_C_DISCONN)) {

        if (--Connection->Retries == 0) {

            NB_DEBUG2 (CONNECTION, ("Timing out session initializes on %lx\n", Connection));

            //
            // We have just timed out this connect, we fail the
            // request. When the reference count goes to 0 we
            // will set the state to INACTIVE and deassign
            // the connection ID.
            //

            Request = Connection->ConnectRequest;
            Connection->ConnectRequest = NULL;

            Connection->SubState = CONNECTION_SUBSTATE_C_DISCONN;

            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

            NB_GET_CANCEL_LOCK( &CancelLH );
            IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);
            NB_FREE_CANCEL_LOCK( CancelLH );

            REQUEST_STATUS (Request) = STATUS_REMOTE_NOT_LISTENING;
            NbiCompleteRequest (Request);
            NbiFreeRequest (Device, Request);

            NbiDereferenceConnection (Connection, CREF_CONNECT);
            NbiDereferenceConnection (Connection, CREF_TIMER);

        } else {

            //
            // Send the next session initialize.
            //

            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

            NbiSendSessionInitialize (Connection);

            CTEStartTimer(
                &Connection->Timer,
                Device->ConnectionTimeout,
                NbiConnectionTimeout,
                (PVOID)Connection);
        }

    } else if (Connection->State == CONNECTION_STATE_DISCONNECT) {

        if ((Connection->SubState != CONNECTION_SUBSTATE_D_W_ACK) ||
            (--Connection->Retries == 0)) {

            NB_DEBUG2 (CONNECTION, ("Timing out disconnect of %lx\n", Connection));

            //
            // Just dereference the connection, that will cause the
            // disconnect to be completed, the state to be set
            // to INACTIVE, and our connection ID deassigned.
            //

            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

            NbiDereferenceConnection (Connection, CREF_TIMER);

        } else {

            //
            // Send the next session end.
            //

            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

            NbiSendSessionEnd(Connection);

            CTEStartTimer(
                &Connection->Timer,
                Device->ConnectionTimeout,
                NbiConnectionTimeout,
                (PVOID)Connection);

        }

    } else {

        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
        NbiDereferenceConnection (Connection, CREF_TIMER);

    }

}   /* NbiConnectionTimeout */


VOID
NbiCancelListen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to cancel a posted
    listen.

    NOTE: This routine is called with the CancelSpinLock held and
    is responsible for releasing it.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    none.

--*/

{

    PCONNECTION Connection;
    CTELockHandle LockHandle1, LockHandle2;
    PDEVICE Device = (PDEVICE)DeviceObject;
    PREQUEST Request = (PREQUEST)Irp;


    CTEAssert ((REQUEST_MAJOR_FUNCTION(Request) == IRP_MJ_INTERNAL_DEVICE_CONTROL) &&
               (REQUEST_MINOR_FUNCTION(Request) == TDI_LISTEN));

    CTEAssert (REQUEST_OPEN_TYPE(Request) == (PVOID)TDI_CONNECTION_FILE);

    Connection = (PCONNECTION)REQUEST_OPEN_CONTEXT(Request);

    NB_GET_LOCK (&Connection->Lock, &LockHandle1);

    if ((Connection->State == CONNECTION_STATE_LISTENING) &&
        (Connection->SubState == CONNECTION_SUBSTATE_L_WAITING) &&
        (Connection->ListenRequest == Request)) {

        //
        // When the reference count goes to 0, we will set the
        // state to INACTIVE and deassign the connection ID.
        //

        NB_DEBUG2 (CONNECTION, ("Cancelled listen on %lx\n", Connection));

        NB_GET_LOCK (&Device->Lock, &LockHandle2);
        Connection->ListenRequest = NULL;
        RemoveEntryList (REQUEST_LINKAGE(Request));
        NB_FREE_LOCK (&Device->Lock, LockHandle2);

        NB_FREE_LOCK (&Connection->Lock, LockHandle1);
        IoReleaseCancelSpinLock (Irp->CancelIrql);

        REQUEST_INFORMATION(Request) = 0;
        REQUEST_STATUS(Request) = STATUS_CANCELLED;

        NbiCompleteRequest (Request);
        NbiFreeRequest(Device, Request);

        NbiDereferenceConnection (Connection, CREF_LISTEN);

    } else {

        NB_DEBUG (CONNECTION, ("Cancel listen on invalid connection %lx\n", Connection));
        NB_FREE_LOCK (&Connection->Lock, LockHandle1);
        IoReleaseCancelSpinLock (Irp->CancelIrql);

    }

}   /* NbiCancelListen */


VOID
NbiCancelConnectFindName(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to cancel a connect
    request which is waiting for the name to be found.

    NOTE: This routine is called with the CancelSpinLock held and
    is responsible for releasing it.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    none.

--*/

{

    PCONNECTION Connection;
    CTELockHandle LockHandle1, LockHandle2;
    PDEVICE Device = (PDEVICE)DeviceObject;
    PREQUEST Request = (PREQUEST)Irp;
    PLIST_ENTRY p;
    BOOLEAN fCanceled = TRUE;


    CTEAssert ((REQUEST_MAJOR_FUNCTION(Request) == IRP_MJ_INTERNAL_DEVICE_CONTROL) &&
               (REQUEST_MINOR_FUNCTION(Request) == TDI_CONNECT));

    CTEAssert (REQUEST_OPEN_TYPE(Request) == (PVOID)TDI_CONNECTION_FILE);

    Connection = (PCONNECTION)REQUEST_OPEN_CONTEXT(Request);

    NB_GET_LOCK (&Connection->Lock, &LockHandle1);

    if ((Connection->State == CONNECTION_STATE_CONNECTING) &&
        (Connection->SubState == CONNECTION_SUBSTATE_C_FIND_NAME) &&
        (Connection->ConnectRequest == Request)) {

        //
        // Make sure the request is still on the queue
        // before cancelling it.
        //

        NB_GET_LOCK (&Device->Lock, &LockHandle2);

        for (p = Device->WaitingConnects.Flink;
             p != &Device->WaitingConnects;
             p = p->Flink) {

            if (LIST_ENTRY_TO_REQUEST(p) == Request) {
                break;
            }
        }

        if (p != &Device->WaitingConnects) {

            NB_DEBUG2 (CONNECTION, ("Cancelled find name connect on %lx\n", Connection));

            //
            // When the reference count goes to 0, we will set the
            // state to INACTIVE and deassign the connection ID.
            //

            Connection->ConnectRequest = NULL;
            RemoveEntryList (REQUEST_LINKAGE(Request));
            NB_FREE_LOCK (&Device->Lock, LockHandle2);

            Connection->SubState = CONNECTION_SUBSTATE_C_DISCONN;

            NB_FREE_LOCK (&Connection->Lock, LockHandle1);
            IoReleaseCancelSpinLock (Irp->CancelIrql);

            REQUEST_STATUS(Request) = STATUS_CANCELLED;

#ifdef RASAUTODIAL
            if (Connection->Flags & CONNECTION_FLAGS_AUTOCONNECTING)
                fCanceled = NbiCancelTdiConnect(Device, Request, Connection);
#endif // RASAUTODIAL

            if (fCanceled) {
                NbiCompleteRequest (Request);
                NbiFreeRequest(Device, Request);
            }

            NbiDereferenceConnection (Connection, CREF_WAIT_CACHE);
            NbiDereferenceConnection (Connection, CREF_CONNECT);

        } else {

            NB_DEBUG (CONNECTION, ("Cancel connect not found on queue %lx\n", Connection));

            NB_FREE_LOCK (&Device->Lock, LockHandle2);
            NB_FREE_LOCK (&Connection->Lock, LockHandle1);
            IoReleaseCancelSpinLock (Irp->CancelIrql);

        }

    } else {

        NB_DEBUG (CONNECTION, ("Cancel connect on invalid connection %lx\n", Connection));
        NB_FREE_LOCK (&Connection->Lock, LockHandle1);
        IoReleaseCancelSpinLock (Irp->CancelIrql);

    }

}   /* NbiCancelConnectFindName */


VOID
NbiCancelConnectWaitResponse(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to cancel a connect
    request which is waiting for a rip or session init response
    from the remote.

    NOTE: This routine is called with the CancelSpinLock held and
    is responsible for releasing it.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    none.

--*/

{

    PCONNECTION Connection;
    CTELockHandle LockHandle1;
    PDEVICE Device = (PDEVICE)DeviceObject;
    PREQUEST Request = (PREQUEST)Irp;
    BOOLEAN TimerWasStopped = FALSE;


    CTEAssert ((REQUEST_MAJOR_FUNCTION(Request) == IRP_MJ_INTERNAL_DEVICE_CONTROL) &&
               (REQUEST_MINOR_FUNCTION(Request) == TDI_CONNECT));

    CTEAssert (REQUEST_OPEN_TYPE(Request) == (PVOID)TDI_CONNECTION_FILE);

    Connection = (PCONNECTION)REQUEST_OPEN_CONTEXT(Request);

    NB_GET_LOCK (&Connection->Lock, &LockHandle1);

    if ((Connection->State == CONNECTION_STATE_CONNECTING) &&
        (Connection->SubState != CONNECTION_SUBSTATE_C_DISCONN) &&
        (Connection->ConnectRequest == Request)) {

        //
        // When the reference count goes to 0, we will set the
        // state to INACTIVE and deassign the connection ID.
        //

        NB_DEBUG2 (CONNECTION, ("Cancelled wait response connect on %lx\n", Connection));

        Connection->ConnectRequest = NULL;
        Connection->SubState = CONNECTION_SUBSTATE_C_DISCONN;

        if (CTEStopTimer (&Connection->Timer)) {
            TimerWasStopped = TRUE;
        }

        NB_FREE_LOCK (&Connection->Lock, LockHandle1);
        IoReleaseCancelSpinLock (Irp->CancelIrql);

        REQUEST_STATUS(Request) = STATUS_CANCELLED;

        NbiCompleteRequest (Request);
        NbiFreeRequest(Device, Request);

        NbiDereferenceConnection (Connection, CREF_CONNECT);

        if (TimerWasStopped) {
            NbiDereferenceConnection (Connection, CREF_TIMER);
        }

    } else {

        NB_DEBUG (CONNECTION, ("Cancel connect on invalid connection %lx\n", Connection));
        NB_FREE_LOCK (&Connection->Lock, LockHandle1);
        IoReleaseCancelSpinLock (Irp->CancelIrql);

    }

}   /* NbiCancelConnectWaitResponse */


VOID
NbiCancelDisconnectWait(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to cancel a posted
    disconnect wait.

    NOTE: This routine is called with the CancelSpinLock held and
    is responsible for releasing it.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    none.

--*/

{

    PCONNECTION Connection;
    CTELockHandle LockHandle1, LockHandle2;
    PDEVICE Device = (PDEVICE)DeviceObject;
    PREQUEST Request = (PREQUEST)Irp;


    CTEAssert ((REQUEST_MAJOR_FUNCTION(Request) == IRP_MJ_INTERNAL_DEVICE_CONTROL) &&
               (REQUEST_MINOR_FUNCTION(Request) == TDI_DISCONNECT));

    CTEAssert (REQUEST_OPEN_TYPE(Request) == (PVOID)TDI_CONNECTION_FILE);

    Connection = (PCONNECTION)REQUEST_OPEN_CONTEXT(Request);

    NB_GET_LOCK (&Connection->Lock, &LockHandle1);
    NB_GET_LOCK (&Device->Lock, &LockHandle2);

    if (Connection->DisconnectWaitRequest == Request) {

        Connection->DisconnectWaitRequest = NULL;

        NB_FREE_LOCK (&Device->Lock, LockHandle2);
        NB_FREE_LOCK (&Connection->Lock, LockHandle1);
        IoReleaseCancelSpinLock (Irp->CancelIrql);

        REQUEST_INFORMATION(Request) = 0;
        REQUEST_STATUS(Request) = STATUS_CANCELLED;

        NbiCompleteRequest (Request);
        NbiFreeRequest(Device, Request);

    } else {

        NB_FREE_LOCK (&Device->Lock, LockHandle2);
        NB_FREE_LOCK (&Connection->Lock, LockHandle1);
        IoReleaseCancelSpinLock (Irp->CancelIrql);

    }

}   /* NbiCancelDisconnectWait */


PCONNECTION
NbiLookupConnectionByContext(
    IN PADDRESS_FILE AddressFile,
    IN CONNECTION_CONTEXT ConnectionContext
    )

/*++

Routine Description:

    This routine looks up a connection based on the context.
    The connection is assumed to be associated with the
    specified address file.

Arguments:

    AddressFile - Pointer to an address file.

    ConnectionContext - Connection context to find.

Return Value:

    A pointer to the connection we found

--*/

{
    CTELockHandle LockHandle1, LockHandle2;
    PLIST_ENTRY p;
    PADDRESS Address = AddressFile->Address;
    PCONNECTION Connection;

    NB_GET_LOCK (&Address->Lock, &LockHandle1);

    for (p=AddressFile->ConnectionDatabase.Flink;
         p != &AddressFile->ConnectionDatabase;
         p=p->Flink) {

        Connection = CONTAINING_RECORD (p, CONNECTION, AddressFileLinkage);

        NB_GET_LOCK (&Connection->Lock, &LockHandle2);

        //
        // Does this spinlock ordering hurt us somewhere else?
        //

        if (Connection->Context == ConnectionContext) {

            NbiReferenceConnection (Connection, CREF_BY_CONTEXT);
            NB_FREE_LOCK (&Connection->Lock, LockHandle2);
            NB_FREE_LOCK (&Address->Lock, LockHandle1);

            return Connection;
        }

        NB_FREE_LOCK (&Connection->Lock, LockHandle2);

    }

    NB_FREE_LOCK (&Address->Lock, LockHandle1);

    return NULL;

} /* NbiLookupConnectionByContext */


PCONNECTION
NbiCreateConnection(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine creates a transport connection and associates it with
    the specified transport device context.  The reference count in the
    connection is automatically set to 1, and the reference count of the
    device context is incremented.

Arguments:

    Device - Pointer to the device context (which is really just
        the device object with its extension) to be associated with the
        connection.

Return Value:

    The newly created connection, or NULL if none can be allocated.

--*/

{
    PCONNECTION Connection;
    PNB_SEND_RESERVED SendReserved;
    ULONG ConnectionSize;
    ULONG HeaderLength;
    NTSTATUS    Status;
    CTELockHandle LockHandle;

    HeaderLength = Device->Bind.MacHeaderNeeded + sizeof(NB_CONNECTION);
    ConnectionSize = FIELD_OFFSET (CONNECTION, SendPacketHeader[0]) + HeaderLength;

    Connection = (PCONNECTION)NbiAllocateMemory (ConnectionSize, MEMORY_CONNECTION, "Connection");
    if (Connection == NULL) {
        NB_DEBUG (CONNECTION, ("Create connection failed\n"));
        return NULL;
    }

    NB_DEBUG2 (CONNECTION, ("Create connection %lx\n", Connection));
    RtlZeroMemory (Connection, ConnectionSize);


#if defined(NB_OWN_PACKETS)

    NB_GET_LOCK (&Device->Lock, &LockHandle);

    if (NbiInitializeSendPacket(
            Device,
            Connection->SendPacketPoolHandle,
            &Connection->SendPacket,
            Connection->SendPacketHeader,
            HeaderLength) != STATUS_SUCCESS) {

        NB_FREE_LOCK (&Device->Lock, LockHandle);
        NB_DEBUG (CONNECTION, ("Could not initialize connection packet %lx\n", &Connection->SendPacket));
        Connection->SendPacketInUse = TRUE;

    } else {

        NB_FREE_LOCK (&Device->Lock, LockHandle);
        SendReserved = SEND_RESERVED(&Connection->SendPacket);
        SendReserved->u.SR_CO.Connection = Connection;
        SendReserved->OwnedByConnection = TRUE;
#ifdef NB_TRACK_POOL
        SendReserved->Pool = NULL;
#endif
    }

#else // !NB_OWN_PACKETS

    //
    // if we are using ndis packets, first create packet pool for 1 packet descriptor
    //
    Connection->SendPacketPoolHandle = (NDIS_HANDLE) NDIS_PACKET_POOL_TAG_FOR_NWLNKNB;  // Dbg info for Ndis!
    NdisAllocatePacketPoolEx (&Status, &Connection->SendPacketPoolHandle, 1, 0, sizeof(NB_SEND_RESERVED));
    if (!NT_SUCCESS(Status)){
        NB_DEBUG (CONNECTION, ("Could not allocatee connection packet %lx\n", Status));
        Connection->SendPacketInUse = TRUE;
    } else {

        NdisSetPacketPoolProtocolId (Connection->SendPacketPoolHandle, NDIS_PROTOCOL_ID_IPX);

        NB_GET_LOCK (&Device->Lock, &LockHandle);

        if (NbiInitializeSendPacket(
                Device,
                Connection->SendPacketPoolHandle,
                &Connection->SendPacket,
                Connection->SendPacketHeader,
                HeaderLength) != STATUS_SUCCESS) {

            NB_FREE_LOCK (&Device->Lock, LockHandle);
            NB_DEBUG (CONNECTION, ("Could not initialize connection packet %lx\n", &Connection->SendPacket));
            Connection->SendPacketInUse = TRUE;

            //
            // Also free up the pool which we allocated above.
            //
            NdisFreePacketPool(Connection->SendPacketPoolHandle);

        } else {

            NB_FREE_LOCK (&Device->Lock, LockHandle);
            SendReserved = SEND_RESERVED(&Connection->SendPacket);
            SendReserved->u.SR_CO.Connection = Connection;
            SendReserved->OwnedByConnection = TRUE;
#ifdef NB_TRACK_POOL
            SendReserved->Pool = NULL;
#endif
        }
    }

#endif NB_OWN_PACKETS

    Connection->Type = NB_CONNECTION_SIGNATURE;
    Connection->Size = (USHORT)ConnectionSize;

#if 0
    Connection->AddressFileLinked = FALSE;
    Connection->AddressFile = NULL;
#endif

    Connection->State = CONNECTION_STATE_INACTIVE;
#if 0
    Connection->SubState = 0;
    Connection->ReferenceCount = 0;
#endif

    Connection->CanBeDestroyed = TRUE;

    Connection->TickCount = 1;
    Connection->HopCount = 1;

    //
    // Device->InitialRetransmissionTime is in milliseconds, as is
    // SHORT_TIMER_DELTA.
    //

    Connection->BaseRetransmitTimeout = Device->InitialRetransmissionTime / SHORT_TIMER_DELTA;
    Connection->CurrentRetransmitTimeout = Connection->BaseRetransmitTimeout;

    //
    // Device->KeepAliveTimeout is in half-seconds, while LONG_TIMER_DELTA
    // is in milliseconds.
    //

    Connection->WatchdogTimeout = (Device->KeepAliveTimeout * 500) / LONG_TIMER_DELTA;


    Connection->LocalConnectionId = 0xffff;

    //
    // When the connection becomes active we will replace the
    // destination address of this header with the correct
    // information.
    //

    RtlCopyMemory(&Connection->RemoteHeader, &Device->ConnectionlessHeader, sizeof(IPX_HEADER));

    Connection->Device = Device;
    Connection->DeviceLock = &Device->Lock;
    CTEInitLock (&Connection->Lock.Lock);

    CTEInitTimer (&Connection->Timer);

    InitializeListHead (&Connection->NdisSendQueue);
#if 0
    Connection->NdisSendsInProgress = 0;
    Connection->DisassociatePending = NULL;
    Connection->ClosePending = NULL;
    Connection->SessionInitAckData = NULL;
    Connection->SessionInitAckDataLength = 0;
    Connection->PiggybackAckTimeout = FALSE;
    Connection->ReceivesWithoutAck = 0;
#endif
    Connection->Flags = 0;

    NbiReferenceDevice (Device, DREF_CONNECTION);

    return Connection;

}   /* NbiCreateConnection */


NTSTATUS
NbiVerifyConnection (
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This routine is called to verify that the pointer given us in a file
    object is in fact a valid connection object. We reference
    it to keep it from disappearing while we use it.

Arguments:

    Connection - potential pointer to a CONNECTION object

Return Value:

    STATUS_SUCCESS if all is well; STATUS_INVALID_CONNECTION otherwise

--*/

{
    CTELockHandle LockHandle;
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE Device = NbiDevice;
    BOOLEAN LockHeld = FALSE;

    try
    {
        if ((Connection->Size == FIELD_OFFSET (CONNECTION, SendPacketHeader[0]) +
                                 NbiDevice->Bind.MacHeaderNeeded + sizeof(NB_CONNECTION)) &&
            (Connection->Type == NB_CONNECTION_SIGNATURE))
        {
            NB_GET_LOCK (&Device->Lock, &LockHandle);
            LockHeld = TRUE;

            if (Connection->State != CONNECTION_STATE_CLOSING)
            {
                NbiReferenceConnectionLock (Connection, CREF_VERIFY);
            }
            else
            {
                NbiPrint1("NbiVerifyConnection: C %lx closing\n", Connection);
                status = STATUS_INVALID_CONNECTION;
            }

            NB_FREE_LOCK (&Device->Lock, LockHandle);
        }
        else
        {
            NbiPrint1("NbiVerifyConnection: C %lx bad signature\n", Connection);
            status = STATUS_INVALID_CONNECTION;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        NbiPrint1("NbiVerifyConnection: C %lx exception\n", Connection);
        if (LockHeld)
        {
            NB_FREE_LOCK (&Device->Lock, LockHandle);
        }
        return GetExceptionCode();
    }

    return status;
}   /* NbiVerifyConnection */


VOID
NbiDestroyConnection(
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This routine destroys a transport connection and removes all references
    made by it to other objects in the transport.  The connection structure
    is returned to nonpaged system pool.

Arguments:

    Connection - Pointer to a transport connection structure to be destroyed.

Return Value:

    None.

--*/

{
    PDEVICE Device = Connection->Device;
#if 0
    CTELockHandle LockHandle;
#endif

    NB_DEBUG2 (CONNECTION, ("Destroy connection %lx\n", Connection));

    if (!Connection->SendPacketInUse) {
        NbiDeinitializeSendPacket (Device, &Connection->SendPacket, Device->Bind.MacHeaderNeeded + sizeof(NB_CONNECTION));
#if !defined(NB_OWN_PACKETS)
        NdisFreePacketPool(Connection->SendPacketPoolHandle);
#endif
    }

    NbiFreeMemory (Connection, (ULONG)Connection->Size, MEMORY_CONNECTION, "Connection");

    NbiDereferenceDevice (Device, DREF_CONNECTION);

}   /* NbiDestroyConnection */


#if DBG
VOID
NbiRefConnection(
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This routine increments the reference count on a transport connection.

Arguments:

    Connection - Pointer to a transport connection object.

Return Value:

    none.

--*/

{

    (VOID)ExInterlockedAddUlong (
            &Connection->ReferenceCount,
            1,
            &Connection->DeviceLock->Lock);

    Connection->CanBeDestroyed = FALSE;

    CTEAssert (Connection->ReferenceCount > 0);

}   /* NbiRefConnection */


VOID
NbiRefConnectionLock(
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This routine increments the reference count on a transport connection
    when the device lock is already held.

Arguments:

    Connection - Pointer to a transport connection object.

Return Value:

    none.

--*/

{

    ++Connection->ReferenceCount;
    Connection->CanBeDestroyed = FALSE;

    CTEAssert (Connection->ReferenceCount > 0);

}   /* NbiRefConnectionLock */


VOID
NbiRefConnectionSync(
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This routine increments the reference count on a transport connection
    when we are in a sync routine.

Arguments:

    Connection - Pointer to a transport connection object.

Return Value:

    none.

--*/

{
    (VOID)NB_ADD_ULONG (
            &Connection->ReferenceCount,
            1,
            Connection->DeviceLock);

    Connection->CanBeDestroyed = FALSE;

    CTEAssert (Connection->ReferenceCount > 0);

}   /* NbiRefConnectionSync */


VOID
NbiDerefConnection(
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This routine dereferences a transport connection by decrementing the
    reference count contained in the structure.  If, after being
    decremented, the reference count is zero, then this routine calls
    NbiHandleConnectionZero to complete any disconnect, disassociate,
    or close requests that have pended on the connection.

Arguments:

    Connection - Pointer to a transport connection object.

Return Value:

    none.

--*/

{
    ULONG oldvalue;
    CTELockHandle LockHandle;

    NB_GET_LOCK( Connection->DeviceLock, &LockHandle );
    CTEAssert( Connection->ReferenceCount );
    if ( !(--Connection->ReferenceCount) ) {

        Connection->ThreadsInHandleConnectionZero++;

        NB_FREE_LOCK( Connection->DeviceLock, LockHandle );

        //
        // If the refcount has dropped to 0, then the connection can
        // become inactive. We reacquire the spinlock and if it has not
        // jumped back up then we handle any disassociates and closes
        // that have pended.
        //

        NbiHandleConnectionZero (Connection);
    } else {

        NB_FREE_LOCK( Connection->DeviceLock, LockHandle );
    }


}   /* NbiDerefConnection */


#endif


VOID
NbiHandleConnectionZero(
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This routine handles a connection's refcount going to 0.

        If two threads are in this at the same time and
        the close has already come through, one of them might
        destroy the connection while the other one is looking
        at it. We minimize the chance of this by not derefing
        the connection after calling CloseConnection.

Arguments:

    Connection - Pointer to a transport connection object.

Return Value:

    none.

--*/

{
    CTELockHandle LockHandle;
    PDEVICE Device;
    PADDRESS_FILE AddressFile;
    PADDRESS Address;
    PREQUEST DisconnectPending;
    PREQUEST DisassociatePending;
    PREQUEST ClosePending;


    Device = Connection->Device;

    NB_GET_LOCK (&Device->Lock, &LockHandle);

#if DBG
    //
    // Make sure if our reference count is zero, all the
    // sub-reference counts are also zero.
    //

    if (Connection->ReferenceCount == 0) {

        UINT i;
        for (i = 0; i < CREF_TOTAL; i++) {
            if (Connection->RefTypes[i] != 0) {
                DbgPrint ("NBI: Connection reftype mismatch on %lx\n", Connection);
                DbgBreakPoint();
            }
        }
    }
#endif

    //
    // If the connection was assigned an ID, then remove it
    // (it is assigned one when it leaves INACTIVE).
    //

    if (Connection->LocalConnectionId != 0xffff) {
        NbiDeassignConnectionId (Device, Connection);
    }

    //
    // Complete any pending disconnects.
    //

    if (Connection->DisconnectRequest != NULL) {

        DisconnectPending = Connection->DisconnectRequest;
        Connection->DisconnectRequest = NULL;

        NB_FREE_LOCK (&Device->Lock, LockHandle);

        REQUEST_STATUS(DisconnectPending) = STATUS_SUCCESS;
        NbiCompleteRequest (DisconnectPending);
        NbiFreeRequest (Device, DisconnectPending);

        NB_GET_LOCK (&Device->Lock, &LockHandle);

    }

    //
    // This should have been completed by NbiStopConnection,
    // or else not allowed to be queued.
    //

    CTEAssert (Connection->DisconnectWaitRequest == NULL);


    Connection->State = CONNECTION_STATE_INACTIVE;

    RtlZeroMemory (&Connection->ConnectionInfo, sizeof(TDI_CONNECTION_INFO));
    Connection->TickCount = 1;
    Connection->HopCount = 1;
    Connection->BaseRetransmitTimeout = Device->InitialRetransmissionTime / SHORT_TIMER_DELTA;

    Connection->ConnectionInfo.TransmittedTsdus = 0;
    Connection->ConnectionInfo.TransmissionErrors = 0;
    Connection->ConnectionInfo.ReceivedTsdus = 0;
    Connection->ConnectionInfo.ReceiveErrors = 0;

    //
    // See if we need to do a disassociate now.
    //

    if ((Connection->ReferenceCount == 0) &&
        (Connection->DisassociatePending != NULL)) {

        //
        // A disassociate pended, now we complete it.
        //

        DisassociatePending = Connection->DisassociatePending;
        Connection->DisassociatePending = NULL;

        if (AddressFile = Connection->AddressFile) {

            //
            // Set this so nobody else tries to disassociate.
            //
            Connection->AddressFile = (PVOID)-1;

            NB_FREE_LOCK (&Device->Lock, LockHandle);

            //
            // Take this connection out of the address file's list.
            //

            Address = AddressFile->Address;
            NB_GET_LOCK (&Address->Lock, &LockHandle);

            if (Connection->AddressFileLinked) {
                Connection->AddressFileLinked = FALSE;
                RemoveEntryList (&Connection->AddressFileLinkage);
            }

            //
            // We are done.
            //

            Connection->AddressFile = NULL;

            NB_FREE_LOCK (&Address->Lock, LockHandle);

            //
            // Clean up the reference counts and complete any
            // disassociate requests that pended.
            //

            NbiDereferenceAddressFile (AddressFile, AFREF_CONNECTION);
        }
        else {
            NB_FREE_LOCK (&Device->Lock, LockHandle);
        }

        if (DisassociatePending != (PVOID)-1) {
            REQUEST_STATUS(DisassociatePending) = STATUS_SUCCESS;
            NbiCompleteRequest (DisassociatePending);
            NbiFreeRequest (Device, DisassociatePending);
        }

    } else {

        NB_FREE_LOCK (&Device->Lock, LockHandle);

    }


    //
    // If a close was pending, complete that.
    //

    NB_GET_LOCK (&Device->Lock, &LockHandle);

    if ((Connection->ReferenceCount == 0) &&
        (Connection->ClosePending)) {

        ClosePending = Connection->ClosePending;
        Connection->ClosePending = NULL;

        //
        // If we are associated with an address, we need
        // to simulate a disassociate at this point.
        //

        if ((Connection->AddressFile != NULL) &&
            (Connection->AddressFile != (PVOID)-1)) {

            AddressFile = Connection->AddressFile;
            Connection->AddressFile = (PVOID)-1;

            NB_FREE_LOCK (&Device->Lock, LockHandle);

            //
            // Take this connection out of the address file's list.
            //

            Address = AddressFile->Address;
            NB_GET_LOCK (&Address->Lock, &LockHandle);

            if (Connection->AddressFileLinked) {
                Connection->AddressFileLinked = FALSE;
                RemoveEntryList (&Connection->AddressFileLinkage);
            }

            //
            // We are done.
            //

            NB_FREE_LOCK (&Address->Lock, LockHandle);

            Connection->AddressFile = NULL;

            //
            // Clean up the reference counts and complete any
            // disassociate requests that pended.
            //

            NbiDereferenceAddressFile (AddressFile, AFREF_CONNECTION);

        } else {

            NB_FREE_LOCK (&Device->Lock, LockHandle);

        }

        //
        // Even if the ref count is zero and we just cleaned up everything,
        // we can not destroy the connection bcoz some other thread might still be
        // in HandleConnectionZero routine. This could happen when 2 threads call into
        // HandleConnectionZero, one thread runs thru completion, close comes along
        // and the other thread is still in HandleConnectionZero routine.
        //

        CTEAssert( Connection->ThreadsInHandleConnectionZero );
        if (ExInterlockedAddUlong ( &Connection->ThreadsInHandleConnectionZero, (ULONG)-1, &Device->Lock.Lock) == 1) {
            NbiDestroyConnection(Connection);
        }

        REQUEST_STATUS(ClosePending) = STATUS_SUCCESS;
        NbiCompleteRequest (ClosePending);
        NbiFreeRequest (Device, ClosePending);

    } else {

        if ( Connection->ReferenceCount == 0 ) {
            Connection->CanBeDestroyed = TRUE;
        }

        CTEAssert( Connection->ThreadsInHandleConnectionZero );
        Connection->ThreadsInHandleConnectionZero--;
        NB_FREE_LOCK (&Device->Lock, LockHandle);

    }

}   /* NbiHandleConnectionZero */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\nb\datagram.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    datagram.c

Abstract:

    This module contains the code to handle datagram reception
    for the Netbios module of the ISN transport.

Author:

    Adam Barr (adamba) 28-November-1993

Environment:

    Kernel mode

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop



VOID
NbiProcessDatagram(
    IN NDIS_HANDLE MacBindingHandle,
    IN NDIS_HANDLE MacReceiveContext,
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR LookaheadBuffer,
    IN UINT LookaheadBufferSize,
    IN UINT LookaheadBufferOffset,
    IN UINT PacketSize,
    IN BOOLEAN Broadcast
    )

/*++

Routine Description:

    This routine handles datagram indications.

Arguments:

    MacBindingHandle - A handle to use when calling NdisTransferData.

    MacReceiveContext - A context to use when calling NdisTransferData.

    RemoteAddress - The local target this packet was received from.

    MacOptions - The MAC options for the underlying NDIS binding.

    LookaheadBuffer - The lookahead buffer, starting at the IPX
        header.

    LookaheadBufferSize - The length of the lookahead data.

    LookaheadBufferOffset - The offset to add when calling
        NdisTransferData.

    PacketSize - The total length of the packet, starting at the
        IPX header.

    Broadcast - TRUE if the frame was a broadcast datagram.

Return Value:

    None.

--*/

{

    PADDRESS Address;
    NDIS_STATUS NdisStatus;
    PUCHAR NetbiosName;
    NB_CONNECTIONLESS UNALIGNED * Connectionless =
                        (NB_CONNECTIONLESS UNALIGNED *)LookaheadBuffer;
    PDEVICE Device = NbiDevice;
    PSINGLE_LIST_ENTRY sl;
    PSLIST_ENTRY s;
    PNB_RECEIVE_RESERVED ReceiveReserved;
    PNB_RECEIVE_BUFFER ReceiveBuffer;
    ULONG DataOffset;
    UINT BytesTransferred;
    PNDIS_PACKET Packet;
    CTELockHandle   LockHandle;
    ULONG           MediaType = -1;


    //
    // See if there is an address that might want this.
    //

    if (Broadcast) {
        NetbiosName = (PVOID)-1;
    } else {
        NetbiosName = (PUCHAR)Connectionless->Datagram.DestinationName;
        if (Device->AddressCounts[NetbiosName[0]] == 0) {
            return;
        }
    }

    DataOffset = sizeof(IPX_HEADER) + sizeof(NB_DATAGRAM);

#if     defined(_PNP_POWER)
    if ((PacketSize < DataOffset) ||
        (PacketSize > DataOffset + Device->CurMaxReceiveBufferSize)) {
#else
        if ((PacketSize < DataOffset) ||
            (PacketSize > DataOffset + Device->Bind.LineInfo.MaximumPacketSize)) {
#endif  _PNP_POWER

        NB_DEBUG (DATAGRAM, ("Datagram length %d discarded\n", PacketSize));
        return;
    }

    Address = NbiFindAddress (Device, NetbiosName);

    if (Address == NULL) {
        return;
    }

    //
    // We need to cache the remote name if the packet came across the router.
    // This allows this machine to get back to the RAS client which might
    // have sent this datagram. We currently dont allow broadcasts to go out
    // on the dial-in line.
    // Dont cache some of the widely used group names, that would be too much
    // to store in cache.
    //

#if 0
    if ( Connectionless->IpxHeader.TransportControl &&
         !( (Address->NetbiosAddress.NetbiosName[15] == 0x0 ) &&
            (Address->NetbiosAddress.NetbiosNameType & TDI_ADDRESS_NETBIOS_TYPE_GROUP))  &&
         !( (Address->NetbiosAddress.NetbiosName[15] == 0x01 ) &&
            (Address->NetbiosAddress.NetbiosNameType & TDI_ADDRESS_NETBIOS_TYPE_GROUP))  &&
         !( (Address->NetbiosAddress.NetbiosName[15] == 0x1E ) &&
            (Address->NetbiosAddress.NetbiosNameType & TDI_ADDRESS_NETBIOS_TYPE_GROUP))  ) {
#endif

    //
    // Bug#s 219325, 221483
    //
    if (((Address->NetbiosAddress.NetbiosName[15] == 0x1c) &&
         (Address->NetbiosAddress.NetbiosNameType & TDI_ADDRESS_NETBIOS_TYPE_GROUP)) ||
        (Address->NetbiosAddress.NetbiosName[15] == 0x1b) )
    {
        //
        // Cache this name only if it either came over a router or,
        // it came over an NdisWan line (Bug# 38221)
        //
        NdisStatus = (*Device->Bind.QueryHandler) ( IPX_QUERY_MEDIA_TYPE,
                                                    &RemoteAddress->NicHandle,
                                                    &MediaType,
                                                    sizeof(MediaType),
                                                    NULL);

        if (Connectionless->IpxHeader.TransportControl || (MediaType == (ULONG) NdisMediumWan)) {

            PNETBIOS_CACHE CacheName;

            NB_GET_LOCK (&Device->Lock, &LockHandle);
            if ( FindInNetbiosCacheTable ( Device->NameCache,
                                           Connectionless->Datagram.SourceName,
                                           &CacheName ) != STATUS_SUCCESS ) {

                CacheName = NbiAllocateMemory (sizeof(NETBIOS_CACHE), MEMORY_CACHE, "Cache Entry");
                if (CacheName ) {

                    RtlCopyMemory (CacheName->NetbiosName, Connectionless->Datagram.SourceName, 16);
                    CacheName->Unique = TRUE;
                    CacheName->ReferenceCount = 1;
                    RtlCopyMemory (&CacheName->FirstResponse, Connectionless->IpxHeader.SourceNetwork, 12);
                    CacheName->NetworksAllocated = 1;
                    CacheName->NetworksUsed = 1;
                    CacheName->Networks[0].Network = *(UNALIGNED ULONG *)(Connectionless->IpxHeader.SourceNetwork);
                    CacheName->Networks[0].LocalTarget = *RemoteAddress;
                    NB_DEBUG2 (CACHE, ("Alloc new cache from Datagram %lx for <%.16s>\n",
                                        CacheName, CacheName->NetbiosName));

                    CacheName->TimeStamp = Device->CacheTimeStamp;

                    InsertInNetbiosCacheTable(
                        Device->NameCache,
                        CacheName);

                }
            }  else if ( CacheName->Unique ) {

                //
                // We already have an entry for this remote. We should update
                // the address. This is so that if the ras client dials-out
                // then dials-in again and gets a new address, we dont end up
                // caching the old address.
                //
                if ( !RtlEqualMemory( &CacheName->FirstResponse, Connectionless->IpxHeader.SourceNetwork, 12) ) {

                    RtlCopyMemory (&CacheName->FirstResponse, Connectionless->IpxHeader.SourceNetwork, 12);
                    CacheName->Networks[0].Network = *(UNALIGNED ULONG *)(Connectionless->IpxHeader.SourceNetwork);
                    CacheName->Networks[0].LocalTarget = *RemoteAddress;

                }
            }
            NB_FREE_LOCK (&Device->Lock, LockHandle);
        }
    }

    //
    // We need to allocate a packet and buffer for the transfer.
    //

    s = NbiPopReceivePacket (Device);
    if (s == NULL) {
        NbiDereferenceAddress (Address, AREF_FIND);
        return;
    }

    ReceiveReserved = CONTAINING_RECORD (s, NB_RECEIVE_RESERVED, PoolLinkage);


    sl = NbiPopReceiveBuffer (Device);
    if (sl == NULL) {
        ExInterlockedPushEntrySList(
            &Device->ReceivePacketList,
            &ReceiveReserved->PoolLinkage,
            &NbiGlobalPoolInterlock);
        NbiDereferenceAddress (Address, AREF_FIND);
        return;
    }

    ReceiveBuffer = CONTAINING_RECORD (sl, NB_RECEIVE_BUFFER, PoolLinkage);

    Packet = CONTAINING_RECORD (ReceiveReserved, NDIS_PACKET, ProtocolReserved[0]);
    ReceiveReserved->u.RR_DG.ReceiveBuffer = ReceiveBuffer;


    //
    // Now that we have a packet and a buffer, set up the transfer.
    // The indication to the TDI clients will happen at receive
    // complete time.
    //

    NdisChainBufferAtFront (Packet, ReceiveBuffer->NdisBuffer);
    ReceiveBuffer->Address = Address;

    ReceiveReserved->Type = RECEIVE_TYPE_DATAGRAM;
    CTEAssert (!ReceiveReserved->TransferInProgress);
    ReceiveReserved->TransferInProgress = TRUE;

    TdiCopyLookaheadData(
        &ReceiveBuffer->RemoteName,
        Connectionless->Datagram.SourceName,
        16,
        (MacOptions & NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA) ? TDI_RECEIVE_COPY_LOOKAHEAD : 0);

    (*Device->Bind.TransferDataHandler) (
        &NdisStatus,
        MacBindingHandle,
        MacReceiveContext,
        LookaheadBufferOffset + DataOffset,
        PacketSize - DataOffset,
        Packet,
        &BytesTransferred);

    if (NdisStatus != NDIS_STATUS_PENDING) {
#if DBG
        if (NdisStatus == STATUS_SUCCESS) {
            CTEAssert (BytesTransferred == PacketSize - DataOffset);
        }
#endif

        NbiTransferDataComplete(
            Packet,
            NdisStatus,
            BytesTransferred);

    }

}   /* NbiProcessDatagram */


VOID
NbiIndicateDatagram(
    IN PADDRESS Address,
    IN PUCHAR RemoteName,
    IN PUCHAR Data,
    IN ULONG DataLength
    )

/*++

Routine Description:

    This routine indicates a datagram to clients on the specified
    address. It is called from NbiReceiveComplete.

Arguments:

    Address - The address the datagram was sent to.

    RemoteName - The source netbios address of the datagram.

    Data - The data.

    DataLength - The length of the data.

Return Value:

    None.

--*/

{
    PLIST_ENTRY p, q;
    PIRP Irp;
    ULONG IndicateBytesCopied, ActualBytesCopied;
    PREQUEST Request;
    TA_NETBIOS_ADDRESS SourceName;
    PTDI_CONNECTION_INFORMATION RemoteInformation;
    PADDRESS_FILE AddressFile, ReferencedAddressFile;
    PTDI_CONNECTION_INFORMATION DatagramInformation;
    TDI_ADDRESS_NETBIOS * DatagramAddress;
    PDEVICE Device = NbiDevice;
    NB_DEFINE_LOCK_HANDLE (LockHandle)
    CTELockHandle   CancelLH;

    //
    // Update our statistics.
    //

    ++Device->Statistics.DatagramsReceived;
    ADD_TO_LARGE_INTEGER(
        &Device->Statistics.DatagramBytesReceived,
        DataLength);

    //
    // Call the client's ReceiveDatagram indication handler.  He may
    // want to accept the datagram that way.
    //

    TdiBuildNetbiosAddress (RemoteName, FALSE, &SourceName);
    ReferencedAddressFile = NULL;

    NB_SYNC_GET_LOCK (&Address->Lock, &LockHandle);

    for (p = Address->AddressFileDatabase.Flink;
         p != &Address->AddressFileDatabase;
         p = p->Flink) {

        //
        // Find the next open address file in the list.
        //

        AddressFile = CONTAINING_RECORD (p, ADDRESS_FILE, Linkage);
        if (AddressFile->State != ADDRESSFILE_STATE_OPEN) {
            continue;
        }

        NbiReferenceAddressFileLock (AddressFile, AFREF_INDICATION);

        //
        // do we have a datagram receive request outstanding? If so, we will
        // satisfy it first. We run through the receive datagram queue
        // until we find a datagram with no remote address or with
        // this sender's address as its remote address.
        //

        for (q = AddressFile->ReceiveDatagramQueue.Flink;
             q != &AddressFile->ReceiveDatagramQueue;
             q = q->Flink) {

            Request = LIST_ENTRY_TO_REQUEST (q);
            DatagramInformation = ((PTDI_REQUEST_KERNEL_RECEIVEDG)
                REQUEST_PARAMETERS(Request))->ReceiveDatagramInformation;

            if (DatagramInformation &&
                (DatagramInformation->RemoteAddress) &&
                (DatagramAddress = NbiParseTdiAddress(DatagramInformation->RemoteAddress, DatagramInformation->RemoteAddressLength, FALSE)) &&
                (!RtlEqualMemory(
                    RemoteName,
                    DatagramAddress->NetbiosName,
                    16))) {
                continue;
            }
            break;
        }

        if (q != &AddressFile->ReceiveDatagramQueue) {

            RemoveEntryList (q);
            NB_SYNC_FREE_LOCK (&Address->Lock, LockHandle);

            if (ReferencedAddressFile != NULL) {
                NbiDereferenceAddressFile (ReferencedAddressFile, AFREF_INDICATION);
            }
            ReferencedAddressFile = AddressFile;

            //
            // Do this deref now, we hold another one so it
            // will stick around.
            //

            NbiDereferenceAddressFile (AddressFile, AFREF_RCV_DGRAM);

            IndicateBytesCopied = 0;

            //
            // Fall past the else to copy the data.
            //

        } else {

            NB_SYNC_FREE_LOCK (&Address->Lock, LockHandle);

            if (ReferencedAddressFile != NULL) {
                NbiDereferenceAddressFile (ReferencedAddressFile, AFREF_INDICATION);
            }
            ReferencedAddressFile = AddressFile;

            //
            // No receive datagram requests; is there a kernel client?
            //

            if (AddressFile->RegisteredHandler[TDI_EVENT_RECEIVE_DATAGRAM]) {

                IndicateBytesCopied = 0;

                if ((*AddressFile->ReceiveDatagramHandler)(
                         AddressFile->HandlerContexts[TDI_EVENT_RECEIVE_DATAGRAM],
                         sizeof (TA_NETBIOS_ADDRESS),
                         &SourceName,
                         0,
                         NULL,
                         TDI_RECEIVE_COPY_LOOKAHEAD,
                         DataLength,      // indicated
                         DataLength,     // available
                         &IndicateBytesCopied,
                         Data,
                         &Irp) != STATUS_MORE_PROCESSING_REQUIRED) {

                    //
                    // The client did not return a request, go to the
                    // next address file.
                    //

                    NB_SYNC_GET_LOCK (&Address->Lock, &LockHandle);
                    continue;

                }

                Request = NbiAllocateRequest (Device, Irp);

                IF_NOT_ALLOCATED(Request) {
                    Irp->IoStatus.Information = 0;
                    Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                    IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);


                    NB_SYNC_GET_LOCK (&Address->Lock, &LockHandle);
                    continue;
                }

            } else {

                //
                // The client has nothing posted and no handler,
                // go on to the next address file.
                //

                NB_SYNC_GET_LOCK (&Address->Lock, &LockHandle);
                continue;

            }

        }

        //
        // We have a request; copy the actual user data.
        //
        if ( REQUEST_NDIS_BUFFER (Request) ) {

            REQUEST_STATUS(Request) =
                TdiCopyBufferToMdl (
                         Data,
                         IndicateBytesCopied,
                         DataLength - IndicateBytesCopied,
                         REQUEST_NDIS_BUFFER (Request),
                         0,
                         &ActualBytesCopied);

            REQUEST_INFORMATION (Request) = ActualBytesCopied;
        } else {
            //
            // No buffer specified in the request
            //
            REQUEST_INFORMATION (Request) = 0;
            //
            // If there was any data to be copied, return error o/w success
            //
            REQUEST_STATUS(Request) = ( (DataLength - IndicateBytesCopied) ? STATUS_BUFFER_OVERFLOW : STATUS_SUCCESS );
        }

        //
        // Copy the addressing information.
        //

        RemoteInformation = ((PTDI_REQUEST_KERNEL_RECEIVEDG)
                REQUEST_PARAMETERS(Request))->ReturnDatagramInformation;

        if (RemoteInformation != NULL) {

            RtlCopyMemory(
                (PTA_NETBIOS_ADDRESS)RemoteInformation->RemoteAddress,
                &SourceName,
                (RemoteInformation->RemoteAddressLength < sizeof(TA_NETBIOS_ADDRESS)) ?
                    RemoteInformation->RemoteAddressLength : sizeof(TA_NETBIOS_ADDRESS));
        }


        NB_GET_CANCEL_LOCK( &CancelLH );
        IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);
        NB_FREE_CANCEL_LOCK( CancelLH );

        NbiCompleteRequest (Request);
        NbiFreeRequest (Device, Request);

        NB_SYNC_GET_LOCK (&Address->Lock, &LockHandle);

    }    // end of for loop through the address files

    NB_SYNC_FREE_LOCK (&Address->Lock, LockHandle);


    if (ReferencedAddressFile != NULL) {
        NbiDereferenceAddressFile (ReferencedAddressFile, AFREF_INDICATION);
    }

}   /* NbiIndicateDatagram */


NTSTATUS
NbiTdiSendDatagram(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine sends a datagram on an address.

Arguments:

    Device - The netbios device.

    Request - The request describing the datagram send.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PADDRESS_FILE AddressFile;
    PNB_SEND_RESERVED Reserved;
    PNDIS_PACKET Packet;
    TDI_ADDRESS_NETBIOS * RemoteName;
    PTDI_REQUEST_KERNEL_SENDDG Parameters;
    PSLIST_ENTRY s;
    PNETBIOS_CACHE CacheName;
    CTELockHandle LockHandle;
    NTSTATUS Status;

    //
    // Check that the file type is valid
    //
    if (REQUEST_OPEN_TYPE(Request) != (PVOID)TDI_TRANSPORT_ADDRESS_FILE)
    {
        CTEAssert(FALSE);
        return (STATUS_INVALID_ADDRESS_COMPONENT);
    }

    //
    // Make sure that the address is valid.
    //
    AddressFile = (PADDRESS_FILE)REQUEST_OPEN_CONTEXT(Request);

#if     defined(_PNP_POWER)
    Status = NbiVerifyAddressFile (AddressFile, CONFLICT_IS_NOT_OK);
#else
    Status = NbiVerifyAddressFile (AddressFile);
#endif  _PNP_POWER

    if (Status == STATUS_SUCCESS) {

        Parameters = (PTDI_REQUEST_KERNEL_SENDDG)REQUEST_PARAMETERS(Request);
        RemoteName = NbiParseTdiAddress((PTRANSPORT_ADDRESS)(Parameters->SendDatagramInformation->RemoteAddress), Parameters->SendDatagramInformation->RemoteAddressLength, TRUE);


        //
        // Check that datagram size is less than the maximum allowable
        // by the adapters. In the worst case this would be
        // 576 - 64 = 512.
        //

#if     defined(_PNP_POWER)
        if ( ( Parameters->SendLength + sizeof(NB_DATAGRAM) ) > Device->Bind.LineInfo.MaximumSendSize ) {
            NbiDereferenceAddressFile (AddressFile, AFREF_VERIFY);
            NB_DEBUG(DATAGRAM, ("Datagram too large %d, Max allowed %d\n", Parameters->SendLength + sizeof(NB_DATAGRAM), Device->Bind.LineInfo.MaximumSendSize ));
            return STATUS_INVALID_PARAMETER;
        }
#else
        if ( ( Parameters->SendLength + sizeof(NB_DATAGRAM) ) > Device->Bind.LineInfo.MaximumPacketSize ) {
            NbiDereferenceAddressFile (AddressFile, AFREF_VERIFY);
            NB_DEBUG(DATAGRAM, ("Datagram too large %d, Max allowed %d\n", Parameters->SendLength + sizeof(NB_DATAGRAM), Device->Bind.LineInfo.MaximumPacketSize ));
            return STATUS_INVALID_PARAMETER;
        }
#endif  _PNP_POWER

        if (RemoteName != NULL) {

            //
            // Get a packet to use in this send.
            //

            s = NbiPopSendPacket (Device, FALSE);

            if (s != NULL) {

                Reserved = CONTAINING_RECORD (s, NB_SEND_RESERVED, PoolLinkage);
                Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);

                //
                // Check on the cache status of this name.
                //

                Reserved->u.SR_DG.DatagramRequest = Request;
                Reserved->u.SR_DG.AddressFile = AddressFile;
                Reserved->u.SR_DG.RemoteName = RemoteName;

                REQUEST_INFORMATION (Request) = Parameters->SendLength;

                ++Device->Statistics.DatagramsSent;
                ADD_TO_LARGE_INTEGER(
                    &Device->Statistics.DatagramBytesSent,
                    Parameters->SendLength);

                if (Device->Internet) {

                    NB_GET_LOCK (&Device->Lock, &LockHandle);

                    Status = CacheFindName(
                                 Device,
                                 FindNameOther,
                                 (RemoteName == (PVOID)-1) ? NULL : (PUCHAR)RemoteName->NetbiosName,
                                 &CacheName);

                    if (Status == STATUS_PENDING) {

                        //
                        // A request for routes to this name has been
                        // sent out on the net, we queue up this datagram
                        // request and processing will be resumed when
                        // we get a response.
                        //

                        NB_DEBUG2 (CONNECTION, ("Queueing up datagram %lx on %lx\n",
                                                    Request, AddressFile));

                        NbiReferenceAddressFileLock (AddressFile, AFREF_SEND_DGRAM);

                        InsertTailList(
                            &Device->WaitingDatagrams,
                            &Reserved->WaitLinkage);

                        NB_FREE_LOCK (&Device->Lock, LockHandle);

                    } else if (Status == STATUS_SUCCESS) {

                        NB_DEBUG2 (CONNECTION, ("Found datagram cached %lx on %lx\n",
                                                    Request, AddressFile));

                        //
                        // We reference the cache name entry so it won't
                        // go away while we are using it.
                        //

                        Reserved->u.SR_DG.Cache = CacheName;
                        Reserved->u.SR_DG.CurrentNetwork = 0;
                        ++CacheName->ReferenceCount;

                        NbiReferenceAddressFileLock (AddressFile, AFREF_SEND_DGRAM);

                        NB_FREE_LOCK (&Device->Lock, LockHandle);

                        Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);
                        if ( REQUEST_NDIS_BUFFER(Request) ) {
                            NdisChainBufferAtBack (Packet, REQUEST_NDIS_BUFFER(Request));
                        }

                        NbiTransmitDatagram(
                            Reserved);

                        Status = STATUS_PENDING;

                    } else {

                        REQUEST_INFORMATION (Request) = 0;
                        NB_FREE_LOCK (&Device->Lock, LockHandle);

                        ExInterlockedPushEntrySList( &Device->SendPacketList, s, &NbiGlobalPoolInterlock);
                    }

                } else {

                    //
                    // We are not in internet mode, so we do not
                    // need to do the name discovery.
                    //

                    NB_DEBUG2 (CONNECTION, ("Sending datagram direct %lx on %lx\n",
                                                Request, AddressFile));

                    Reserved->u.SR_DG.Cache = NULL;

                    NbiReferenceAddressFileLock (AddressFile, AFREF_SEND_DGRAM);

                    Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);

                    if ( REQUEST_NDIS_BUFFER(Request) ) {
                        NdisChainBufferAtBack (Packet, REQUEST_NDIS_BUFFER(Request));
                    }
                    NbiTransmitDatagram(
                        Reserved);

                    Status = STATUS_PENDING;

                }

            } else {

                //
                // Could not allocate a packet for the datagram.
                //

                NB_DEBUG (DATAGRAM, ("Couldn't get packet to send DG %lx\n", Request));

                Status = STATUS_INSUFFICIENT_RESOURCES;

            }

        } else {

            //
            // There is no netbios remote address specified.
            //

            NB_DEBUG (DATAGRAM, ("No netbios address in DG %lx\n", Request));
            Status = STATUS_BAD_NETWORK_PATH;

        }

        NbiDereferenceAddressFile (AddressFile, AFREF_VERIFY);

    } else {

        NB_DEBUG (DATAGRAM, ("Invalid address file for DG %lx\n", Request));

    }

    return Status;

}   /* NbiTdiSendDatagram */


VOID
NbiTransmitDatagram(
    IN PNB_SEND_RESERVED Reserved
    )

/*++

Routine Description:

    This routine sends a datagram to the next net in the
    cache entry for the remote name.

Arguments:

    Reserved - The reserved section of the packet that has
        been allocated for this send. Reserved->u.SR_DG.Cache
        will be NULL if Internet mode is off, otherwise it
        will contain the cache entry to use when sending
        this datagram.

Return Value:

    None.

--*/

{

    PNDIS_PACKET Packet;
    PNETBIOS_CACHE CacheName;
    NB_CONNECTIONLESS UNALIGNED * Header;
    ULONG HeaderLength;
    ULONG PacketLength;
    NDIS_STATUS NdisStatus;
    IPX_LOCAL_TARGET TempLocalTarget;
    PIPX_LOCAL_TARGET LocalTarget;
    PDEVICE Device = NbiDevice;


    Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);


    CTEAssert (Reserved->SendInProgress == FALSE);
    Reserved->SendInProgress = TRUE;
    Reserved->Type = SEND_TYPE_DATAGRAM;

    CacheName = Reserved->u.SR_DG.Cache;


    //
    // Fill in the IPX header -- the default header has the broadcast
    // address on net 0 as the destination IPX address, so we modify
    // that for the current netbios cache entry if needed.
    //

    Header = (NB_CONNECTIONLESS UNALIGNED *)
                (&Reserved->Header[Device->Bind.IncludedHeaderOffset]);
    RtlCopyMemory((PVOID)&Header->IpxHeader, &Device->ConnectionlessHeader, sizeof(IPX_HEADER));

    if (CacheName == NULL) {

#if     defined(_PNP_POWER)
        //
        // IPX will send this on all the Nics.
        //
        TempLocalTarget.NicHandle.NicId = (USHORT)ITERATIVE_NIC_ID;
#else
        TempLocalTarget.NicId = 1;
#endif  _PNP_POWER
        RtlCopyMemory (TempLocalTarget.MacAddress, BroadcastAddress, 6);
        LocalTarget = &TempLocalTarget;

    } else {

        if (CacheName->Unique) {
            RtlCopyMemory (Header->IpxHeader.DestinationNetwork, &CacheName->FirstResponse, 12);
        } else {
            *(UNALIGNED ULONG *)Header->IpxHeader.DestinationNetwork = CacheName->Networks[Reserved->u.SR_DG.CurrentNetwork].Network;
            RtlCopyMemory (&Header->IpxHeader.DestinationNode, BroadcastAddress, 6);
        }

        LocalTarget = &CacheName->Networks[Reserved->u.SR_DG.CurrentNetwork].LocalTarget;

    }

    HeaderLength = sizeof(IPX_HEADER) + sizeof(NB_DATAGRAM);

    PacketLength = HeaderLength + (ULONG) REQUEST_INFORMATION(Reserved->u.SR_DG.DatagramRequest);

    Header->IpxHeader.PacketLength[0] = (UCHAR)(PacketLength / 256);
    Header->IpxHeader.PacketLength[1] = (UCHAR)(PacketLength % 256);
    Header->IpxHeader.PacketType = 0x04;


    //
    // Now fill in the Netbios header.
    //

    Header->Datagram.ConnectionControlFlag = 0x00;
    RtlCopyMemory(
        Header->Datagram.SourceName,
        Reserved->u.SR_DG.AddressFile->Address->NetbiosAddress.NetbiosName,
        16);

    if (Reserved->u.SR_DG.RemoteName != (PVOID)-1) {

        //
        // This is a directed, as opposed to broadcast, datagram.
        //

        Header->Datagram.DataStreamType = NB_CMD_DATAGRAM;
        RtlCopyMemory(
            Header->Datagram.DestinationName,
            Reserved->u.SR_DG.RemoteName->NetbiosName,
            16);

    } else {

        Header->Datagram.DataStreamType = NB_CMD_BROADCAST_DATAGRAM;
        RtlZeroMemory(
            Header->Datagram.DestinationName,
            16);

    }


    //
    // Now send the frame (IPX will adjust the length of the
    // first buffer and the whole frame correctly).
    //

    NdisAdjustBufferLength(NB_GET_NBHDR_BUFF(Packet), HeaderLength);
    if ((NdisStatus =
        (*Device->Bind.SendHandler)(
            LocalTarget,
            Packet,
            PacketLength,
            HeaderLength)) != STATUS_PENDING) {

        NbiSendComplete(
            Packet,
            NdisStatus);

    }

}   /* NbiTransmitDatagram */


NTSTATUS
NbiTdiReceiveDatagram(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine performs the TdiReceiveDatagram request for the transport
    provider. Receive datagrams just get queued up to an address, and are
    completed when a DATAGRAM or DATAGRAM_BROADCAST frame is received at
    the address.

Arguments:

    Request - Describes this request.

Return Value:

    NTSTATUS - status of operation.

--*/

{

    NTSTATUS Status;
    PADDRESS Address;
    PADDRESS_FILE AddressFile;
    CTELockHandle LockHandle;
    CTELockHandle CancelLH;

    //
    // Check that the file type is valid
    //
    if (REQUEST_OPEN_TYPE(Request) != (PVOID)TDI_TRANSPORT_ADDRESS_FILE)
    {
        CTEAssert(FALSE);
        return (STATUS_INVALID_ADDRESS_COMPONENT);
    }

    AddressFile = (PADDRESS_FILE)REQUEST_OPEN_CONTEXT(Request);

#if     defined(_PNP_POWER)
    Status = NbiVerifyAddressFile (AddressFile, CONFLICT_IS_NOT_OK);
#else
    Status = NbiVerifyAddressFile (AddressFile);
#endif  _PNP_POWER

    if (Status != STATUS_SUCCESS) {
        return Status;
    }

    Address = AddressFile->Address;

    NB_GET_CANCEL_LOCK( &CancelLH );
    NB_GET_LOCK (&Address->Lock, &LockHandle);

    if (AddressFile->State != ADDRESSFILE_STATE_OPEN) {

        NB_FREE_LOCK (&Address->Lock, LockHandle);
        NB_FREE_CANCEL_LOCK( CancelLH );
        NbiDereferenceAddressFile (AddressFile, AFREF_VERIFY);
        return STATUS_INVALID_HANDLE;
    }


    if (Request->Cancel) {

        NB_FREE_LOCK (&Address->Lock, LockHandle);
        NB_FREE_CANCEL_LOCK( CancelLH );
        NbiDereferenceAddressFile (AddressFile, AFREF_VERIFY);
        return STATUS_CANCELLED;
    }

    InsertTailList (&AddressFile->ReceiveDatagramQueue, REQUEST_LINKAGE(Request));

    IoSetCancelRoutine (Request, NbiCancelReceiveDatagram);

    NB_DEBUG2 (DATAGRAM, ("RDG posted on %lx\n", AddressFile));

    NbiTransferReferenceAddressFile (AddressFile, AFREF_VERIFY, AFREF_RCV_DGRAM);

    NB_FREE_LOCK (&Address->Lock, LockHandle);
    NB_FREE_CANCEL_LOCK( CancelLH );

    return STATUS_PENDING;

}   /* NbiTdiReceiveDatagram */


VOID
NbiCancelReceiveDatagram(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to cancel a receive
    datagram. The datagram is found on the address file's receive
    datagram queue.

    NOTE: This routine is called with the CancelSpinLock held and
    is responsible for releasing it.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    none.

--*/

{

    PLIST_ENTRY p;
    PADDRESS_FILE AddressFile;
    PADDRESS Address;
    PREQUEST Request = (PREQUEST)Irp;
    BOOLEAN Found;
    NB_DEFINE_LOCK_HANDLE(LockHandle)


    CTEAssert ((REQUEST_MAJOR_FUNCTION(Request) == IRP_MJ_INTERNAL_DEVICE_CONTROL) &&
               (REQUEST_MINOR_FUNCTION(Request) == TDI_RECEIVE_DATAGRAM));

    CTEAssert (REQUEST_OPEN_TYPE(Request) == (PVOID)TDI_TRANSPORT_ADDRESS_FILE);

    AddressFile = (PADDRESS_FILE)REQUEST_OPEN_CONTEXT(Request);
    Address = AddressFile->Address;

    Found = FALSE;

    NB_SYNC_GET_LOCK (&Address->Lock, &LockHandle);

    for (p = AddressFile->ReceiveDatagramQueue.Flink;
         p != &AddressFile->ReceiveDatagramQueue;
         p = p->Flink) {

        if (LIST_ENTRY_TO_REQUEST(p) == Request) {

            RemoveEntryList (p);
            Found = TRUE;
            break;
        }
    }

    NB_SYNC_FREE_LOCK (&Address->Lock, LockHandle);
    IoReleaseCancelSpinLock (Irp->CancelIrql);

    if (Found) {

        NB_DEBUG (DATAGRAM, ("Cancelled datagram on %lx\n", AddressFile));

        REQUEST_INFORMATION(Request) = 0;
        REQUEST_STATUS(Request) = STATUS_CANCELLED;

        NbiCompleteRequest (Request);
        NbiFreeRequest((PDEVICE)DeviceObject, Request);

        NbiDereferenceAddressFile (AddressFile, AFREF_RCV_DGRAM);

    }

}   /* NbiCancelReceiveDatagram */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\nb\device.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    device.c

Abstract:

    This module contains code which implements the DEVICE object.
    Routines are provided to reference, and dereference transport device
    context objects.

    The transport device context object is a structure which contains a
    system-defined DEVICE_OBJECT followed by information which is maintained
    by the transport provider, called the context.

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NbiCreateDevice)
#endif


VOID
NbiRefDevice(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine increments the reference count on a device context.

Arguments:

    Device - Pointer to a transport device context object.

Return Value:

    none.

--*/

{
    CTEAssert (Device->ReferenceCount > 0);    // not perfect, but...

    (VOID)InterlockedIncrement (&Device->ReferenceCount);

}   /* NbiRefDevice */


VOID
NbiDerefDevice(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine dereferences a device context by decrementing the
    reference count contained in the structure.  Currently, we don't
    do anything special when the reference count drops to zero, but
    we could dynamically unload stuff then.

Arguments:

    Device - Pointer to a transport device context object.

Return Value:

    none.

--*/

{
    LONG result;

    result = InterlockedDecrement (&Device->ReferenceCount);

    CTEAssert (result >= 0);

    if (result == 0) {
        NbiDestroyDevice (Device);
    }

}   /* NbiDerefDevice */


NTSTATUS
NbiCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING DeviceName,
    IN OUT PDEVICE *DevicePtr
    )

/*++

Routine Description:

    This routine creates and initializes a device context structure.

Arguments:


    DriverObject - pointer to the IO subsystem supplied driver object.

    Device - Pointer to a pointer to a transport device context object.

    DeviceName - pointer to the name of the device this device object points to.

Return Value:

    STATUS_SUCCESS if all is well; STATUS_INSUFFICIENT_RESOURCES otherwise.

--*/

{
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    PDEVICE Device;
    ULONG DeviceSize;
    UINT i;


    //
    // Create the device object for the sample transport, allowing
    // room at the end for the device name to be stored (for use
    // in logging errors) and the RIP fields.
    //

    DeviceSize = sizeof(DEVICE) - sizeof(DEVICE_OBJECT) +
                 DeviceName->Length + sizeof(UNICODE_NULL);

    status = IoCreateDevice(
                 DriverObject,
                 DeviceSize,
                 DeviceName,
                 FILE_DEVICE_TRANSPORT,
                 FILE_DEVICE_SECURE_OPEN,
                 FALSE,
                 &deviceObject);

    if (!NT_SUCCESS(status)) {
        NB_DEBUG(DEVICE, ("Create device %ws failed %lx\n", DeviceName->Buffer, status));
        return status;
    }

    deviceObject->Flags |= DO_DIRECT_IO;

    Device = (PDEVICE)deviceObject;

    NB_DEBUG2 (DEVICE, ("Create device %ws succeeded %lx\n", DeviceName->Buffer, Device));

    //
    // Initialize our part of the device context.
    //

    RtlZeroMemory(((PUCHAR)Device)+sizeof(DEVICE_OBJECT), sizeof(DEVICE)-sizeof(DEVICE_OBJECT));

    //
    // Copy over the device name.
    //
    Device->DeviceString.Length = DeviceName->Length;
    Device->DeviceString.MaximumLength = DeviceName->Length + sizeof(WCHAR);
    Device->DeviceString.Buffer = (PWCHAR)(Device+1);

    RtlCopyMemory (Device->DeviceString.Buffer, DeviceName->Buffer, DeviceName->Length);
    Device->DeviceString.Buffer[DeviceName->Length/sizeof(WCHAR)] = UNICODE_NULL;

    //
    // Initialize the reference count.
    //
    Device->ReferenceCount = 1;
#if DBG
    Device->RefTypes[DREF_CREATE] = 1;
#endif

#if DBG
    RtlCopyMemory(Device->Signature1, "NDC1", 4);
    RtlCopyMemory(Device->Signature2, "NDC2", 4);
#endif

    Device->Information.Version = 0x0100;
    Device->Information.MaxSendSize = 65535;
    Device->Information.MaxConnectionUserData = 0;
    Device->Information.MaxDatagramSize = 500;
    Device->Information.ServiceFlags =
        TDI_SERVICE_CONNECTION_MODE | TDI_SERVICE_ERROR_FREE_DELIVERY |
        TDI_SERVICE_MULTICAST_SUPPORTED | TDI_SERVICE_BROADCAST_SUPPORTED |
        TDI_SERVICE_DELAYED_ACCEPTANCE | TDI_SERVICE_CONNECTIONLESS_MODE |
        TDI_SERVICE_MESSAGE_MODE | TDI_SERVICE_FORCE_ACCESS_CHECK;
    Device->Information.MinimumLookaheadData = 128;
    Device->Information.MaximumLookaheadData = 1500;
    Device->Information.NumberOfResources = 0;
    KeQuerySystemTime (&Device->Information.StartTime);

    Device->Statistics.Version = 0x0100;
    Device->Statistics.MaximumSendWindow = 4;
    Device->Statistics.AverageSendWindow = 4;

#ifdef _PNP_POWER_
    Device->NetAddressRegistrationHandle = NULL;    // We have not yet registered the Net Address
#endif  // _PNP_POWER_

    //
    // Set this so we won't ignore the broadcast name.
    //

    Device->AddressCounts['*'] = 1;

    //
    // Initialize the resource that guards address ACLs.
    //

    ExInitializeResourceLite (&Device->AddressResource);

    //
    // initialize the various fields in the device context
    //

    CTEInitLock (&Device->Interlock.Lock);
    CTEInitLock (&Device->Lock.Lock);

    CTEInitTimer (&Device->FindNameTimer);

    Device->ControlChannelIdentifier = 1;

    InitializeListHead (&Device->GlobalSendPacketList);
    InitializeListHead (&Device->GlobalReceivePacketList);
    InitializeListHead (&Device->GlobalReceiveBufferList);

    InitializeListHead (&Device->AddressDatabase);
#if     defined(_PNP_POWER)
    InitializeListHead (&Device->AdapterAddressDatabase);
#endif  _PNP_POWER

    InitializeListHead (&Device->WaitingFindNames);

    InitializeListHead (&Device->WaitingConnects);
    InitializeListHead (&Device->WaitingDatagrams);

    InitializeListHead (&Device->WaitingAdapterStatus);
    InitializeListHead (&Device->ActiveAdapterStatus);

    InitializeListHead (&Device->WaitingNetbiosFindName);

    InitializeListHead (&Device->ReceiveDatagrams);
    InitializeListHead (&Device->ConnectIndicationInProgress);

    InitializeListHead (&Device->ListenQueue);

    InitializeListHead (&Device->ReceiveCompletionQueue);

    InitializeListHead (&Device->WaitPacketConnections);
    InitializeListHead (&Device->PacketizeConnections);
    InitializeListHead (&Device->DataAckConnections);

    Device->MemoryUsage = 0;

    InitializeListHead (&Device->SendPoolList);
    InitializeListHead (&Device->ReceivePoolList);
    InitializeListHead (&Device->ReceiveBufferPoolList);

    ExInitializeSListHead( &Device->SendPacketList );
    ExInitializeSListHead( &Device->ReceivePacketList );
    Device->ReceiveBufferList.Next = NULL;

    for (i = 0; i < CONNECTION_HASH_COUNT; i++) {
        Device->ConnectionHash[i].Connections = NULL;
        Device->ConnectionHash[i].ConnectionCount = 0;
        Device->ConnectionHash[i].NextConnectionId = 1;
    }

    KeQuerySystemTime (&Device->NbiStartTime);

    Device->State = DEVICE_STATE_CLOSED;

    Device->Type = NB_DEVICE_SIGNATURE;
    Device->Size = sizeof (DEVICE);

    *DevicePtr = Device;
    return STATUS_SUCCESS;

}   /* NbiCreateDevice */


VOID
NbiDestroyDevice(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine destroys a device context structure.

Arguments:

    Device - Pointer to a pointer to a transport device context object.

Return Value:

    None.

--*/

{
    PLIST_ENTRY p;
    PNB_SEND_POOL SendPool;
    PNB_SEND_PACKET SendPacket;
    UINT SendPoolSize;
    PNB_RECEIVE_POOL ReceivePool;
    PNB_RECEIVE_PACKET ReceivePacket;
    UINT ReceivePoolSize;
    PNB_RECEIVE_BUFFER_POOL ReceiveBufferPool;
    PNB_RECEIVE_BUFFER ReceiveBuffer;
    UINT ReceiveBufferPoolSize;
    ULONG HeaderLength;
    UINT i;

    NB_DEBUG2 (DEVICE, ("Destroy device %lx\n", Device));

    //
    // Take all the connectionless packets out of its pools.
    //

    HeaderLength = Device->Bind.MacHeaderNeeded + sizeof(NB_CONNECTIONLESS);

    SendPoolSize = FIELD_OFFSET (NB_SEND_POOL, Packets[0]) +
                       (sizeof(NB_SEND_PACKET) * Device->InitPackets) +
                       (HeaderLength * Device->InitPackets);

    while (!IsListEmpty (&Device->SendPoolList)) {

        p = RemoveHeadList (&Device->SendPoolList);
        SendPool = CONTAINING_RECORD (p, NB_SEND_POOL, Linkage);

        for (i = 0; i < SendPool->PacketCount; i++) {

            SendPacket = &SendPool->Packets[i];
            NbiDeinitializeSendPacket (Device, SendPacket, HeaderLength);

        }

        NB_DEBUG2 (PACKET, ("Free packet pool %lx\n", SendPool));

#if     !defined(NB_OWN_PACKETS)
        NdisFreePacketPool(SendPool->PoolHandle);
#endif

        NbiFreeMemory (SendPool, SendPoolSize, MEMORY_PACKET, "SendPool");
    }


    ReceivePoolSize = FIELD_OFFSET (NB_RECEIVE_POOL, Packets[0]) +
                         (sizeof(NB_RECEIVE_PACKET) * Device->InitPackets);

    while (!IsListEmpty (&Device->ReceivePoolList)) {

        p = RemoveHeadList (&Device->ReceivePoolList);
        ReceivePool = CONTAINING_RECORD (p, NB_RECEIVE_POOL, Linkage);

        for (i = 0; i < ReceivePool->PacketCount; i++) {

            ReceivePacket = &ReceivePool->Packets[i];
            NbiDeinitializeReceivePacket (Device, ReceivePacket);

        }

        NB_DEBUG2 (PACKET, ("Free packet pool %lx\n", ReceivePool));
#if     !defined(NB_OWN_PACKETS)
        NdisFreePacketPool(ReceivePool->PoolHandle);
#endif
        NbiFreeMemory (ReceivePool, ReceivePoolSize, MEMORY_PACKET, "ReceivePool");
    }

#if     defined(_PNP_POWER)
    NbiDestroyReceiveBufferPools( Device );

    //
    // Destroy adapter address list.
    //
    while(!IsListEmpty( &Device->AdapterAddressDatabase ) ){
        PADAPTER_ADDRESS    AdapterAddress;
        AdapterAddress  =   CONTAINING_RECORD( Device->AdapterAddressDatabase.Flink, ADAPTER_ADDRESS, Linkage );
        NbiDestroyAdapterAddress( AdapterAddress, NULL );
    }
#else
    ReceiveBufferPoolSize = FIELD_OFFSET (NB_RECEIVE_BUFFER_POOL, Buffers[0]) +
                       (sizeof(NB_RECEIVE_BUFFER) * Device->InitPackets) +
                       (Device->Bind.LineInfo.MaximumPacketSize * Device->InitPackets);

    while (!IsListEmpty (&Device->ReceiveBufferPoolList)) {

        p = RemoveHeadList (&Device->ReceiveBufferPoolList);
        ReceiveBufferPool = CONTAINING_RECORD (p, NB_RECEIVE_BUFFER_POOL, Linkage);

        for (i = 0; i < ReceiveBufferPool->BufferCount; i++) {

            ReceiveBuffer = &ReceiveBufferPool->Buffers[i];
            NbiDeinitializeReceiveBuffer (Device, ReceiveBuffer);

        }

        NB_DEBUG2 (PACKET, ("Free buffer pool %lx\n", ReceiveBufferPool));
        NbiFreeMemory (ReceiveBufferPool, ReceiveBufferPoolSize, MEMORY_PACKET, "ReceiveBufferPool");
    }
#endif  _PNP_POWER

    NB_DEBUG (DEVICE, ("Final memory use is %d\n", Device->MemoryUsage));

#if DBG
    for (i = 0; i < MEMORY_MAX; i++) {
        if (NbiMemoryTag[i].BytesAllocated != 0) {
            NB_DEBUG (DEVICE, ("Tag %d: %d bytes left\n", i, NbiMemoryTag[i].BytesAllocated));
        }
    }
#endif

    //
    // If we are being unloaded then someone is waiting for this
    // event to finish the cleanup, since we may be at DISPATCH_LEVEL;
    // otherwise it is during load and we can just kill ourselves here.
    //

    if (Device->UnloadWaiting) {

        KeSetEvent(
            &Device->UnloadEvent,
            0L,
            FALSE);

    } else {

        CTEAssert (KeGetCurrentIrql() < DISPATCH_LEVEL);
        ExDeleteResourceLite (&Device->AddressResource);
        IoDeleteDevice ((PDEVICE_OBJECT)Device);
    }

}   /* NbiDestroyDevice */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\nb\event.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    event.c

Abstract:

    This module contains code which performs the following TDI services:

        o   TdiSetEventHandler

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

PVOID TdiDefaultHandlers[6] = {
    TdiDefaultConnectHandler,
    TdiDefaultDisconnectHandler,
    TdiDefaultErrorHandler,
    TdiDefaultReceiveHandler,
    TdiDefaultRcvDatagramHandler,
    TdiDefaultRcvExpeditedHandler
    };


NTSTATUS
NbiTdiSetEventHandler(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine performs the TdiSetEventHandler request for the
    transport provider.  The caller (request dispatcher) verifies
    that this routine will not be executed on behalf of a user-mode
    client, as this request enables direct callouts at DISPATCH_LEVEL.

Arguments:

    Device - The netbios device object.

    Request - Pointer to the request.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS Status;
    CTELockHandle LockHandle;
    PTDI_REQUEST_KERNEL_SET_EVENT Parameters;
    PADDRESS_FILE AddressFile;
    UINT EventType;

    UNREFERENCED_PARAMETER (Device);

    //
    // Check that the file type is valid
    //
    if (REQUEST_OPEN_TYPE(Request) != (PVOID)TDI_TRANSPORT_ADDRESS_FILE)
    {
        CTEAssert(FALSE);
        return (STATUS_INVALID_ADDRESS_COMPONENT);
    }

    //
    // Get the Address this is associated with; if there is none, get out.
    //

    AddressFile  = REQUEST_OPEN_CONTEXT(Request);
#if     defined(_PNP_POWER)
    Status = NbiVerifyAddressFile (AddressFile, CONFLICT_IS_OK);
#else
    Status = NbiVerifyAddressFile (AddressFile);
#endif  _PNP_POWER

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    NB_GET_LOCK (&AddressFile->Address->Lock, &LockHandle);

    Parameters = (PTDI_REQUEST_KERNEL_SET_EVENT)REQUEST_PARAMETERS(Request);
    EventType = (UINT)(Parameters->EventType);

    if (Parameters->EventType > TDI_EVENT_RECEIVE_EXPEDITED) {

        Status = STATUS_INVALID_PARAMETER;

    } else {

        if (Parameters->EventHandler == NULL) {
            AddressFile->RegisteredHandler[EventType] = FALSE;
            AddressFile->Handlers[EventType] = TdiDefaultHandlers[EventType];
            AddressFile->HandlerContexts[EventType] = NULL;
        } else {
            AddressFile->Handlers[EventType] = Parameters->EventHandler;
            AddressFile->HandlerContexts[EventType] = Parameters->EventContext;
            AddressFile->RegisteredHandler[EventType] = TRUE;
        }

    }

    NB_FREE_LOCK (&AddressFile->Address->Lock, LockHandle);

    NbiDereferenceAddressFile (AddressFile, AFREF_VERIFY);

    return Status;

}   /* NbiTdiSetEventHandler */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\nb\frame.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    frame.c

Abstract:

    This module contains code which creates and sends various
    types of frames.

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


VOID
NbiSendNameFrame(
    IN PADDRESS Address OPTIONAL,
    IN UCHAR NameTypeFlag,
    IN UCHAR DataStreamType,
    IN PIPX_LOCAL_TARGET LocalTarget OPTIONAL,
    IN NB_CONNECTIONLESS UNALIGNED * ReqFrame OPTIONAL
    )

/*++

Routine Description:

    This routine allocates and sends a name frame on the
    specified address. It handles add name, name in use, and
    delete name frames.

Arguments:

    Address - The address on which the frame is sent. This will
        be NULL if we are responding to a request to the
        broadcast address.

    NameTypeFlag - The name type flag to use.

    DataStreamType - The type of the command.

    LocalTarget - If specified, the local target to use for the
        send (if not, it will be broadcast).

    ReqFrame    -   If specified, the request frame for which this
                response is being sent. The reqframe contains the
                destination ipx address and the netbios name.

Return Value:

    None.

--*/

{
    PSLIST_ENTRY s;
    PNB_SEND_RESERVED Reserved;
    PNDIS_PACKET Packet;
    NB_CONNECTIONLESS UNALIGNED * Header;
    NDIS_STATUS NdisStatus;
    IPX_LOCAL_TARGET TempLocalTarget;
    PDEVICE Device = NbiDevice;

    //
    // Allocate a packet from the pool.
    //

    s = NbiPopSendPacket(Device, FALSE);

    //
    // If we can't allocate a frame, that is OK, since
    // it is connectionless anyway.
    //

    if (s == NULL) {
        return;
    }

    Reserved = CONTAINING_RECORD (s, NB_SEND_RESERVED, PoolLinkage);
    Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);

    CTEAssert (Reserved->SendInProgress == FALSE);
    Reserved->SendInProgress = TRUE;
    Reserved->u.SR_NF.Address = Address;    // may be NULL
    Reserved->Type = SEND_TYPE_NAME_FRAME;

    //
    // Frame that are not sent to a specific address are
    // sent to all valid NIC IDs.
    //

    if (!ARGUMENT_PRESENT(LocalTarget)) {
        Reserved->u.SR_NF.NameTypeFlag = NameTypeFlag;
        Reserved->u.SR_NF.DataStreamType = DataStreamType;
    }

    //
    // Fill in the IPX header -- the default header has the broadcast
    // address on net 0 as the destination IPX address.
    //

    Header = (NB_CONNECTIONLESS UNALIGNED *)
                (&Reserved->Header[Device->Bind.IncludedHeaderOffset]);
    RtlCopyMemory((PVOID)&Header->IpxHeader, &Device->ConnectionlessHeader, sizeof(IPX_HEADER));
    if (ARGUMENT_PRESENT(ReqFrame)) {
        RtlCopyMemory((PVOID)&Header->IpxHeader.DestinationNetwork, (PVOID)ReqFrame->IpxHeader.SourceNetwork, 12);
    }
    Header->IpxHeader.PacketLength[0] = (sizeof(IPX_HEADER)+sizeof(NB_NAME_FRAME)) / 256;
    Header->IpxHeader.PacketLength[1] = (sizeof(IPX_HEADER)+sizeof(NB_NAME_FRAME)) % 256;

    if (ARGUMENT_PRESENT(LocalTarget)) {
        Header->IpxHeader.PacketType = 0x04;
    } else {
        Header->IpxHeader.PacketType = (UCHAR)(Device->Internet ? 0x014 : 0x04);
    }

    //
    // Now fill in the Netbios header.
    //

    RtlZeroMemory (Header->NameFrame.RoutingInfo, 32);
    Header->NameFrame.ConnectionControlFlag = 0x00;
    Header->NameFrame.DataStreamType = DataStreamType;
    Header->NameFrame.NameTypeFlag = NameTypeFlag;

    //
    // DataStreamType2 is the same as DataStreamType except for
    // name in use frames where it is set to the add name type.
    //

    Header->NameFrame.DataStreamType2 = (UCHAR)
        ((DataStreamType != NB_CMD_NAME_IN_USE) ? DataStreamType : NB_CMD_ADD_NAME);

    RtlCopyMemory(
        Header->NameFrame.Name,
        Address ? Address->NetbiosAddress.NetbiosName : ReqFrame->NameFrame.Name,
        16);

    if (Address) {
        NbiReferenceAddress (Address, AREF_NAME_FRAME);
    } else {
        NbiReferenceDevice (Device, DREF_NAME_FRAME);
    }

    //
    // Now send the frame (because it is all in the first segment,
    // IPX will adjust the length of the buffer correctly).
    //

    if (!ARGUMENT_PRESENT(LocalTarget)) {
        LocalTarget = &BroadcastTarget;
    }

    NdisAdjustBufferLength(NB_GET_NBHDR_BUFF(Packet), sizeof(IPX_HEADER) +
               sizeof(NB_NAME_FRAME));
    if ((NdisStatus =
        (*Device->Bind.SendHandler)(
            LocalTarget,
            Packet,
            sizeof(IPX_HEADER) + sizeof(NB_NAME_FRAME),
            sizeof(IPX_HEADER) + sizeof(NB_NAME_FRAME))) != STATUS_PENDING) {

        NbiSendComplete(
            Packet,
            NdisStatus);

    }

}   /* NbiSendNameFrame */


VOID
NbiSendSessionInitialize(
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This routine allocates and sends a session initialize
    frame for the specified connection.

Arguments:

    Connection - The connection on which the frame is sent.

Return Value:

    None.

--*/

{
    PSLIST_ENTRY s;
    PNB_SEND_RESERVED Reserved;
    PNDIS_PACKET Packet;
    NB_CONNECTION UNALIGNED * Header;
    NDIS_STATUS NdisStatus;
    PNB_SESSION_INIT SessionInitMemory;
    PNDIS_BUFFER SessionInitBuffer;
    PDEVICE Device = NbiDevice;

    //
    // Allocate a packet from the pool.
    //

    s = NbiPopSendPacket(Device, FALSE);

    //
    // If we can't allocate a frame, that is OK, since
    // it is connectionless anyway.
    //

    if (s == NULL) {
        return;
    }


    //
    // Allocate a buffer for the extra portion of the
    // session initialize.
    //

    SessionInitMemory = (PNB_SESSION_INIT)NbiAllocateMemory(sizeof(NB_SESSION_INIT), MEMORY_CONNECTION, "Session Initialize");
    if (!SessionInitMemory) {
        ExInterlockedPushEntrySList(
            &Device->SendPacketList,
            s,
            &NbiGlobalPoolInterlock);
        return;
    }

    //
    // Allocate an NDIS buffer to map the extra buffer.
    //

    NdisAllocateBuffer(
        &NdisStatus,
        &SessionInitBuffer,
        Device->NdisBufferPoolHandle,
        SessionInitMemory,
        sizeof(NB_SESSION_INIT));

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        NbiFreeMemory (SessionInitMemory, sizeof(NB_SESSION_INIT), MEMORY_CONNECTION, "Session Initialize");
        ExInterlockedPushEntrySList(
            &Device->SendPacketList,
            s,
            &NbiGlobalPoolInterlock);
        return;
    }

    Reserved = CONTAINING_RECORD (s, NB_SEND_RESERVED, PoolLinkage);
    Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);

    CTEAssert (Reserved->SendInProgress == FALSE);
    Reserved->SendInProgress = TRUE;
    Reserved->Type = SEND_TYPE_SESSION_INIT;

    //
    // Fill in the IPX header -- the default header has the broadcast
    // address on net 0 as the destination IPX address.
    //

    Header = (NB_CONNECTION UNALIGNED *)
                (&Reserved->Header[Device->Bind.IncludedHeaderOffset]);
    RtlCopyMemory((PVOID)&Header->IpxHeader, &Connection->RemoteHeader, sizeof(IPX_HEADER));

    Header->IpxHeader.PacketLength[0] = (sizeof(NB_CONNECTION)+sizeof(NB_SESSION_INIT)) / 256;
    Header->IpxHeader.PacketLength[1] = (sizeof(NB_CONNECTION)+sizeof(NB_SESSION_INIT)) % 256;

    Header->IpxHeader.PacketType = 0x04;

    //
    // Now fill in the Netbios header.
    //

    if (Device->Extensions) {
        Header->Session.ConnectionControlFlag = NB_CONTROL_SEND_ACK | NB_CONTROL_NEW_NB;
    } else {
        Header->Session.ConnectionControlFlag = NB_CONTROL_SEND_ACK;
    }
    Header->Session.DataStreamType = NB_CMD_SESSION_DATA;
    Header->Session.SourceConnectionId = Connection->LocalConnectionId;
    Header->Session.DestConnectionId = 0xffff;
    Header->Session.SendSequence = 0;
    Header->Session.TotalDataLength = sizeof(NB_SESSION_INIT);
    Header->Session.Offset = 0;
    Header->Session.DataLength = sizeof(NB_SESSION_INIT);
    Header->Session.ReceiveSequence = 0;
    if (Device->Extensions) {
        Header->Session.ReceiveSequenceMax = 1;  // low estimate for the moment
    } else {
        Header->Session.BytesReceived = 0;
    }

    RtlCopyMemory (SessionInitMemory->SourceName, Connection->AddressFile->Address->NetbiosAddress.NetbiosName, 16);
    RtlCopyMemory (SessionInitMemory->DestinationName, Connection->RemoteName, 16);

    SessionInitMemory->MaximumDataSize = (USHORT)Connection->MaximumPacketSize;
    SessionInitMemory->StartTripTime = (USHORT)
        ((Device->InitialRetransmissionTime * (Device->KeepAliveCount+1)) / 500);
    SessionInitMemory->MaximumPacketTime = SessionInitMemory->StartTripTime + 12;

    //
    // Should we ref the connection? It doesn't really matter which we do.
    //

    NbiReferenceDevice (Device, DREF_SESSION_INIT);

    NdisChainBufferAtBack (Packet, SessionInitBuffer);


    //
    // Now send the frame, IPX will adjust the length of the
    // first buffer correctly.
    //

    NdisAdjustBufferLength(NB_GET_NBHDR_BUFF(Packet), sizeof(NB_CONNECTION));

    if ((NdisStatus =
        (*Device->Bind.SendHandler)(
            &Connection->LocalTarget,
            Packet,
            sizeof(NB_CONNECTION) + sizeof(NB_SESSION_INIT),
            sizeof(NB_CONNECTION))) != STATUS_PENDING) {

        NbiSendComplete(
            Packet,
            NdisStatus);

    }

}   /* NbiSendSessionInitialize */


VOID
NbiSendSessionInitAck(
    IN PCONNECTION Connection,
    IN PUCHAR ExtraData,
    IN ULONG ExtraDataLength,
    IN CTELockHandle * LockHandle OPTIONAL
    )

/*++

Routine Description:

    This routine allocates and sends a session initialize ack
    frame for the specified connection. If extra data was
    specified in the session initialize frame it is echoed
    back to the remote.

Arguments:

    Connection - The connection on which the frame is sent.

    ExtraData - Any extra data (after the SESSION_INIT buffer)
        in the frame.

    ExtraDataLength - THe length of the extra data.

    LockHandle - If specified, indicates the connection lock
        is held and should be released. This is for cases
        where the ExtraData is in memory which may be freed
        once the connection lock is released.

Return Value:

    None.

--*/

{
    PSLIST_ENTRY s;
    PNB_SEND_RESERVED Reserved;
    PNDIS_PACKET Packet;
    NB_CONNECTION UNALIGNED * Header;
    NDIS_STATUS NdisStatus;
    ULONG SessionInitBufferLength;
    PNB_SESSION_INIT SessionInitMemory;
    PNDIS_BUFFER SessionInitBuffer;
    PDEVICE Device = NbiDevice;

    //
    // Allocate a packet from the pool.
    //

    s = NbiPopSendPacket(Device, FALSE);

    //
    // If we can't allocate a frame, that is OK, since
    // it is connectionless anyway.
    //

    if (s == NULL) {
        if (ARGUMENT_PRESENT(LockHandle)) {
            NB_FREE_LOCK (&Connection->Lock, *LockHandle);
        }
        return;
    }


    //
    // Allocate a buffer for the extra portion of the
    // session initialize.
    //

    SessionInitBufferLength = sizeof(NB_SESSION_INIT) + ExtraDataLength;
    SessionInitMemory = (PNB_SESSION_INIT)NbiAllocateMemory(SessionInitBufferLength, MEMORY_CONNECTION, "Session Initialize");
    if (!SessionInitMemory) {
        ExInterlockedPushEntrySList(
            &Device->SendPacketList,
            s,
            &NbiGlobalPoolInterlock);
        if (ARGUMENT_PRESENT(LockHandle)) {
            NB_FREE_LOCK (&Connection->Lock, *LockHandle);
        }
        return;
    }

    //
    // Save the extra data, now we can free the lock.
    //

    if (ExtraDataLength != 0) {
        RtlCopyMemory (SessionInitMemory+1, ExtraData, ExtraDataLength);
    }
    if (ARGUMENT_PRESENT(LockHandle)) {
        NB_FREE_LOCK (&Connection->Lock, *LockHandle);
    }

    //
    // Allocate an NDIS buffer to map the extra buffer.
    //

    NdisAllocateBuffer(
        &NdisStatus,
        &SessionInitBuffer,
        Device->NdisBufferPoolHandle,
        SessionInitMemory,
        SessionInitBufferLength);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        NbiFreeMemory (SessionInitMemory, SessionInitBufferLength, MEMORY_CONNECTION, "Session Initialize");
        ExInterlockedPushEntrySList(
            &Device->SendPacketList,
            s,
            &NbiGlobalPoolInterlock);
        return;
    }

    Reserved = CONTAINING_RECORD (s, NB_SEND_RESERVED, PoolLinkage);
    Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);

    CTEAssert (Reserved->SendInProgress == FALSE);
    Reserved->SendInProgress = TRUE;
    Reserved->Type = SEND_TYPE_SESSION_INIT;

    //
    // Fill in the IPX header -- the default header has the broadcast
    // address on net 0 as the destination IPX address.
    //

    Header = (NB_CONNECTION UNALIGNED *)
                (&Reserved->Header[Device->Bind.IncludedHeaderOffset]);
    RtlCopyMemory((PVOID)&Header->IpxHeader, &Connection->RemoteHeader, sizeof(IPX_HEADER));

    Header->IpxHeader.PacketLength[0] = (UCHAR)((sizeof(NB_CONNECTION)+SessionInitBufferLength) / 256);
    Header->IpxHeader.PacketLength[1] = (UCHAR)((sizeof(NB_CONNECTION)+SessionInitBufferLength) % 256);

    Header->IpxHeader.PacketType = 0x04;

    //
    // Now fill in the Netbios header.
    //

    if (Connection->NewNetbios) {
        Header->Session.ConnectionControlFlag = NB_CONTROL_SYSTEM | NB_CONTROL_NEW_NB;
    } else {
        Header->Session.ConnectionControlFlag = NB_CONTROL_SYSTEM;
    }
    // Bug#: 158998:  We can have a situation where the seqno wont be zero
    // if u get a (late) session init frame during active session
    // CTEAssert (Connection->CurrentSend.SendSequence == 0);
    // CTEAssert (Connection->ReceiveSequence == 1);
    if (Connection->ReceiveSequence != 1)
    {
        DbgPrint("NwlnkNb.NbiSendSessionInitAck: Connection=<%p>: ReceiveSequence=<%d> != 1\n",
            Connection, Connection->ReceiveSequence);
    }
    Header->Session.DataStreamType = NB_CMD_SESSION_DATA;
    Header->Session.SourceConnectionId = Connection->LocalConnectionId;
    Header->Session.DestConnectionId = Connection->RemoteConnectionId;
    Header->Session.SendSequence = 0;
    Header->Session.TotalDataLength = (USHORT)SessionInitBufferLength;
    Header->Session.Offset = 0;
    Header->Session.DataLength = (USHORT)SessionInitBufferLength;
    Header->Session.ReceiveSequence = 1;
    if (Connection->NewNetbios) {
        Header->Session.ReceiveSequenceMax = Connection->LocalRcvSequenceMax;
    } else {
        Header->Session.BytesReceived = 0;
    }

    RtlCopyMemory (SessionInitMemory->SourceName, Connection->AddressFile->Address->NetbiosAddress.NetbiosName, 16);
    RtlCopyMemory (SessionInitMemory->DestinationName, Connection->RemoteName, 16);

    SessionInitMemory->MaximumDataSize = (USHORT)Connection->MaximumPacketSize;
    SessionInitMemory->StartTripTime = (USHORT)
        ((Device->InitialRetransmissionTime * (Device->KeepAliveCount+1)) / 500);
    SessionInitMemory->MaximumPacketTime = SessionInitMemory->StartTripTime + 12;

    //
    // Should we ref the connection? It doesn't really matter which we do.
    //

    NbiReferenceDevice (Device, DREF_SESSION_INIT);

    NdisChainBufferAtBack (Packet, SessionInitBuffer);


    //
    // Now send the frame, IPX will adjust the length of the
    // first buffer correctly.
    //

    NdisAdjustBufferLength(NB_GET_NBHDR_BUFF(Packet), sizeof(NB_CONNECTION));
    if ((NdisStatus =
        (*Device->Bind.SendHandler)(
            &Connection->LocalTarget,
            Packet,
            sizeof(NB_CONNECTION) + SessionInitBufferLength,
            sizeof(NB_CONNECTION))) != STATUS_PENDING) {

        NbiSendComplete(
            Packet,
            NdisStatus);

    }

}   /* NbiSendSessionInitAck */


VOID
NbiSendDataAck(
    IN PCONNECTION Connection,
    IN NB_ACK_TYPE AckType
    IN NB_LOCK_HANDLE_PARAM (LockHandle)
    )

/*++

Routine Description:

    This routine allocates and sends a data ack frame.

    THIS ROUTINE IS CALLED WITH THE LOCK HANDLE HELD AND
    RETURNS WITH IT RELEASED.

Arguments:

    Connection - The connection on which the frame is sent.

    AckType - Indicates if this is a query to the remote,
        a response to a received probe, or a request to resend.

    LockHandle - The handle with which Connection->Lock was acquired.

Return Value:

    None.

--*/

{
    PSLIST_ENTRY s;
    PNB_SEND_RESERVED Reserved;
    PNDIS_PACKET Packet;
    NB_CONNECTION UNALIGNED * Header;
    PDEVICE Device = NbiDevice;

    //
    // Allocate a packet from the pool.
    //

    s = NbiPopSendPacket(Device, FALSE);

    //
    // If we can't allocate a frame, try for the connection
    // packet. If that's not available, that's OK since data
    // acks are connectionless anyway.
    //

    if (s == NULL) {

        if (!Connection->SendPacketInUse) {

            Connection->SendPacketInUse = TRUE;
            Packet = PACKET(&Connection->SendPacket);
            Reserved = (PNB_SEND_RESERVED)(Packet->ProtocolReserved);

        } else {

            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
            return;
        }

    } else {

        Reserved = CONTAINING_RECORD (s, NB_SEND_RESERVED, PoolLinkage);
        Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);

    }

    CTEAssert (Reserved->SendInProgress == FALSE);
    Reserved->SendInProgress = TRUE;
    Reserved->Type = SEND_TYPE_SESSION_NO_DATA;
    Reserved->u.SR_CO.Connection = Connection;
    Reserved->u.SR_CO.PacketLength = sizeof(NB_CONNECTION);

    //
    // Fill in the IPX header -- the default header has the broadcast
    // address on net 0 as the destination IPX address.
    //

    Header = (NB_CONNECTION UNALIGNED *)
                (&Reserved->Header[Device->Bind.IncludedHeaderOffset]);
    RtlCopyMemory((PVOID)&Header->IpxHeader, &Connection->RemoteHeader, sizeof(IPX_HEADER));

    Header->IpxHeader.PacketLength[0] = sizeof(NB_CONNECTION) / 256;
    Header->IpxHeader.PacketLength[1] = sizeof(NB_CONNECTION) % 256;

    Header->IpxHeader.PacketType = 0x04;

    //
    // Now fill in the Netbios header.
    //

    switch (AckType) {
        case NbiAckQuery: Header->Session.ConnectionControlFlag = NB_CONTROL_SYSTEM | NB_CONTROL_SEND_ACK; break;
        case NbiAckResponse: Header->Session.ConnectionControlFlag = NB_CONTROL_SYSTEM; break;
        case NbiAckResend: Header->Session.ConnectionControlFlag = NB_CONTROL_SYSTEM | NB_CONTROL_RESEND; break;
    }
    Header->Session.DataStreamType = NB_CMD_SESSION_DATA;
    Header->Session.SourceConnectionId = Connection->LocalConnectionId;
    Header->Session.DestConnectionId = Connection->RemoteConnectionId;
    Header->Session.SendSequence = Connection->CurrentSend.SendSequence;
    Header->Session.TotalDataLength = (USHORT)Connection->CurrentSend.MessageOffset;
    Header->Session.Offset = 0;
    Header->Session.DataLength = 0;

#if 0
    //
    // These are set by NbiAssignSequenceAndSend.
    //

    Header->Session.ReceiveSequence = Connection->ReceiveSequence;
    Header->Session.BytesReceived = (USHORT)Connection->CurrentReceive.MessageOffset;
#endif

    NbiReferenceConnectionSync(Connection, CREF_FRAME);

    //
    // Set this so we will accept a probe from a remote without
    // the send ack bit on. However if we receive such a request
    // we turn this flag off until we get something else from the
    // remote.
    //

    Connection->IgnoreNextDosProbe = FALSE;

    Connection->ReceivesWithoutAck = 0;

    //
    // This frees the lock. IPX will adjust the length of
    // the first buffer correctly.
    //

    NbiAssignSequenceAndSend(
        Connection,
        Packet
        NB_LOCK_HANDLE_ARG(LockHandle));

}   /* NbiSendDataAck */


VOID
NbiSendSessionEnd(
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This routine allocates and sends a session end
    frame for the specified connection.

Arguments:

    Connection - The connection on which the frame is sent.

Return Value:

    None.

--*/

{
    PSLIST_ENTRY s;
    PNB_SEND_RESERVED Reserved;
    PNDIS_PACKET Packet;
    NB_CONNECTION UNALIGNED * Header;
    NDIS_STATUS NdisStatus;
    PDEVICE Device = NbiDevice;

    //
    // Allocate a packet from the pool.
    //

    s = NbiPopSendPacket(Device, FALSE);

    //
    // If we can't allocate a frame, that is OK, since
    // it is connectionless anyway.
    //

    if (s == NULL) {
        return;
    }

    Reserved = CONTAINING_RECORD (s, NB_SEND_RESERVED, PoolLinkage);
    Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);

    CTEAssert (Reserved->SendInProgress == FALSE);
    Reserved->SendInProgress = TRUE;
    Reserved->Type = SEND_TYPE_SESSION_NO_DATA;
    Reserved->u.SR_CO.Connection = Connection;

    //
    // Fill in the IPX header -- the default header has the broadcast
    // address on net 0 as the destination IPX address.
    //

    Header = (NB_CONNECTION UNALIGNED *)
                (&Reserved->Header[Device->Bind.IncludedHeaderOffset]);
    RtlCopyMemory((PVOID)&Header->IpxHeader, &Connection->RemoteHeader, sizeof(IPX_HEADER));

    Header->IpxHeader.PacketLength[0] = sizeof(NB_CONNECTION) / 256;
    Header->IpxHeader.PacketLength[1] = sizeof(NB_CONNECTION) % 256;

    Header->IpxHeader.PacketType = 0x04;

    //
    // Now fill in the Netbios header. We don't advance the
    // send pointer, since it is the last frame of the session
    // and we want it to stay the same in the case of resends.
    //

    Header->Session.ConnectionControlFlag = NB_CONTROL_SEND_ACK;
    Header->Session.DataStreamType = NB_CMD_SESSION_END;
    Header->Session.SourceConnectionId = Connection->LocalConnectionId;
    Header->Session.DestConnectionId = Connection->RemoteConnectionId;
    Header->Session.SendSequence = Connection->CurrentSend.SendSequence;
    Header->Session.TotalDataLength = 0;
    Header->Session.Offset = 0;
    Header->Session.DataLength = 0;
    Header->Session.ReceiveSequence = Connection->ReceiveSequence;
    if (Connection->NewNetbios) {
        Header->Session.ReceiveSequenceMax = Connection->LocalRcvSequenceMax;
    } else {
        Header->Session.BytesReceived = 0;
    }

    NbiReferenceConnection (Connection, CREF_FRAME);

    //
    // Now send the frame, IPX will adjust the length of the
    // first buffer correctly.
    //

    NdisAdjustBufferLength(NB_GET_NBHDR_BUFF(Packet), sizeof(NB_CONNECTION));
    if ((NdisStatus =
        (*Device->Bind.SendHandler)(
            &Connection->LocalTarget,
            Packet,
            sizeof(NB_CONNECTION),
            sizeof(NB_CONNECTION))) != STATUS_PENDING) {

        NbiSendComplete(
            Packet,
            NdisStatus);

    }

}   /* NbiSendSessionEnd */


VOID
NbiSendSessionEndAck(
    IN TDI_ADDRESS_IPX UNALIGNED * RemoteAddress,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN NB_SESSION UNALIGNED * SessionEnd
    )

/*++

Routine Description:

    This routine allocates and sends a session end
    frame. Generally it is sent on a connection but we
    are not tied to that, to allow us to respond to
    session ends from unknown remotes.

Arguments:

    RemoteAddress - The remote IPX address.

    LocalTarget - The local target of the remote.

    SessionEnd - The received session end frame.

Return Value:

    None.

--*/

{
    PSLIST_ENTRY s;
    PNB_SEND_RESERVED Reserved;
    PNDIS_PACKET Packet;
    NB_CONNECTION UNALIGNED * Header;
    NDIS_STATUS NdisStatus;
    PDEVICE Device = NbiDevice;

    //
    // Allocate a packet from the pool.
    //

    s = NbiPopSendPacket(Device, FALSE);

    //
    // If we can't allocate a frame, that is OK, since
    // it is connectionless anyway.
    //

    if (s == NULL) {
        return;
    }

    Reserved = CONTAINING_RECORD (s, NB_SEND_RESERVED, PoolLinkage);
    Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);

    CTEAssert (Reserved->SendInProgress == FALSE);
    Reserved->SendInProgress = TRUE;
    Reserved->Type = SEND_TYPE_SESSION_NO_DATA;
    Reserved->u.SR_CO.Connection = NULL;

    //
    // Fill in the IPX header -- the default header has the broadcast
    // address on net 0 as the destination IPX address.
    //

    Header = (NB_CONNECTION UNALIGNED *)
                (&Reserved->Header[Device->Bind.IncludedHeaderOffset]);
    RtlCopyMemory((PVOID)&Header->IpxHeader, &Device->ConnectionlessHeader, sizeof(IPX_HEADER));
    RtlCopyMemory(&Header->IpxHeader.DestinationNetwork, (PVOID)RemoteAddress, 12);

    Header->IpxHeader.PacketLength[0] = (sizeof(NB_CONNECTION)) / 256;
    Header->IpxHeader.PacketLength[1] = (sizeof(NB_CONNECTION)) % 256;

    Header->IpxHeader.PacketType = 0x04;

    //
    // Now fill in the Netbios header.
    //

    Header->Session.ConnectionControlFlag = 0x00;
    Header->Session.DataStreamType = NB_CMD_SESSION_END_ACK;
    Header->Session.SourceConnectionId = SessionEnd->DestConnectionId;
    Header->Session.DestConnectionId = SessionEnd->SourceConnectionId;
    Header->Session.SendSequence = SessionEnd->ReceiveSequence;
    Header->Session.TotalDataLength = 0;
    Header->Session.Offset = 0;
    Header->Session.DataLength = 0;
    if (SessionEnd->BytesReceived != 0) {   // Will this detect new netbios?
        Header->Session.ReceiveSequence = SessionEnd->SendSequence + 1;
        Header->Session.ReceiveSequenceMax = SessionEnd->SendSequence + 3;
    } else {
        Header->Session.ReceiveSequence = SessionEnd->SendSequence;
        Header->Session.BytesReceived = 0;
    }

    NbiReferenceDevice (Device, DREF_FRAME);

    //
    // Now send the frame, IPX will adjust the length of the
    // first buffer correctly.
    //

    NdisAdjustBufferLength(NB_GET_NBHDR_BUFF(Packet), sizeof(NB_CONNECTION));
    if ((NdisStatus =
        (*Device->Bind.SendHandler)(
            LocalTarget,
            Packet,
            sizeof(NB_CONNECTION),
            sizeof(NB_CONNECTION))) != STATUS_PENDING) {

        NbiSendComplete(
            Packet,
            NdisStatus);

    }

}   /* NbiSendSessionEndAck */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\nb\nbiprocs.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    nbiprocs.h

Abstract:

    This module contains definitions specific to the
    Netbios module of the ISN transport.

Author:

    Adam Barr (adamba) 16-November-1993

Environment:

    Kernel mode

Revision History:


--*/


//
// MACROS.
//
//
// Debugging aids
//

//
//  VOID
//  PANIC(
//      IN PSZ Message
//      );
//

#if DBG
#define PANIC(Msg) \
    CTEPrint ((Msg))
#else
#define PANIC(Msg)
#endif


//
// These are define to allow CTEPrints that disappear when
// DBG is 0.
//

#if DBG
#define NbiPrint0(fmt) DbgPrint(fmt)
#define NbiPrint1(fmt,v0) DbgPrint(fmt,v0)
#define NbiPrint2(fmt,v0,v1) DbgPrint(fmt,v0,v1)
#define NbiPrint3(fmt,v0,v1,v2) DbgPrint(fmt,v0,v1,v2)
#define NbiPrint4(fmt,v0,v1,v2,v3) DbgPrint(fmt,v0,v1,v2,v3)
#define NbiPrint5(fmt,v0,v1,v2,v3,v4) DbgPrint(fmt,v0,v1,v2,v3,v4)
#define NbiPrint6(fmt,v0,v1,v2,v3,v4,v5) DbgPrint(fmt,v0,v1,v2,v3,v4,v5)
#else
#define NbiPrint0(fmt)
#define NbiPrint1(fmt,v0)
#define NbiPrint2(fmt,v0,v1)
#define NbiPrint3(fmt,v0,v1,v2)
#define NbiPrint4(fmt,v0,v1,v2,v3)
#define NbiPrint5(fmt,v0,v1,v2,v3,v4)
#define NbiPrint6(fmt,v0,v1,v2,v3,v4,v5)
#endif


//
// Routines to log packets to a buffer.
//

#if DBG
#define NB_PACKET_LOG 1
#endif

#ifdef NB_PACKET_LOG

//
// The size of this is 64 bytes for easy display.
//

typedef struct _NB_PACKET_LOG_ENTRY {
    UCHAR SendReceive;
    UCHAR TimeStamp[5];                  // low 5 digits of tick count.
    UCHAR DestMac[6];
    UCHAR SrcMac[6];
    UCHAR Length[2];
    IPX_HEADER NbiHeader;
    UCHAR Data[14];
} NB_PACKET_LOG_ENTRY, *PNB_PACKET_LOG_ENTRY;

#define NB_PACKET_LOG_LENGTH 128
extern ULONG NbiPacketLogDebug;
extern USHORT NbiPacketLogSocket;
EXTERNAL_LOCK(NbiPacketLogLock);
extern NB_PACKET_LOG_ENTRY NbiPacketLog[NB_PACKET_LOG_LENGTH];
extern PNB_PACKET_LOG_ENTRY NbiPacketLogLoc;
extern PNB_PACKET_LOG_ENTRY NbiPacketLogEnd;

//
// Bit fields in NbiPacketLogDebug
//

#define NB_PACKET_LOG_RCV_RIP      0x0001     // All RIP packets
#define NB_PACKET_LOG_RCV_SPX      0x0002     // All SPX packets
#define NB_PACKET_LOG_RCV_NB       0x0004     // All Netbios packets
#define NB_PACKET_LOG_RCV_OTHER    0x0008     // All TDI client packets
#define NB_PACKET_LOG_RCV_SOCKET   0x0010     // All packets to NbiPacketLogSocket
#define NB_PACKET_LOG_RCV_ALL      0x0020     // All packets (even non-NB)

#define NB_PACKET_LOG_SEND_RIP     0x0001     // All RIP packets
#define NB_PACKET_LOG_SEND_SPX     0x0002     // All SPX packets
#define NB_PACKET_LOG_SEND_NB      0x0004     // All Netbios packets
#define NB_PACKET_LOG_SEND_OTHER   0x0008     // All TDI client packets
#define NB_PACKET_LOG_SEND_SOCKET  0x0010     // All packets from NbiPacketLogSocket

VOID
NbiLogPacket(
    IN BOOLEAN Send,
    IN PUCHAR DestMac,
    IN PUCHAR SrcMac,
    IN USHORT Length,
    IN PVOID NbiHeader,
    IN PVOID Data
    );

#define PACKET_LOG(_Bit)   (NbiPacketLogDebug & (_Bit))

#else  // NB_PACKET_LOG

#define NbiLogPacket(_MacHeader,_Length,_NbiHeader,_Data)
#define PACKET_LOG(_Bit)    0

#endif // NB_PACKET_LOG


#if DBG

#define NbiReferenceDevice(_Device, _Type) \
    (VOID)ExInterlockedAddUlong ( \
        &(_Device)->RefTypes[_Type], \
        1, \
        &NbiGlobalInterlock); \
    NbiRefDevice (_Device)

#define NbiDereferenceDevice(_Device, _Type) \
    (VOID)ExInterlockedAddUlong ( \
        &(_Device)->RefTypes[_Type], \
        (ULONG)-1, \
        &NbiGlobalInterlock); \
    NbiDerefDevice (_Device)


#define NbiReferenceAddress(_Address, _Type) \
    (VOID)ExInterlockedAddUlong ( \
        &(_Address)->RefTypes[_Type], \
        1, \
        &NbiGlobalInterlock); \
    NbiRefAddress (_Address)

#define NbiReferenceAddressLock(_Address, _Type) \
    (VOID)ExInterlockedAddUlong ( \
        &(_Address)->RefTypes[_Type], \
        1, \
        &NbiGlobalInterlock); \
    NbiRefAddressLock (_Address)

#define NbiDereferenceAddress(_Address, _Type) \
    (VOID)ExInterlockedAddUlong ( \
        &(_Address)->RefTypes[_Type], \
        (ULONG)-1, \
        &NbiGlobalInterlock); \
    NbiDerefAddress (_Address)


#define NbiReferenceAddressFile(_AddressFile, _Type) \
    (VOID)ExInterlockedAddUlong ( \
        &(_AddressFile)->RefTypes[_Type], \
        1, \
        &NbiGlobalInterlock); \
    NbiRefAddressFile (_AddressFile)

#define NbiReferenceAddressFileLock(_AddressFile, _Type) \
    (VOID)ExInterlockedAddUlong ( \
        &(_AddressFile)->RefTypes[_Type], \
        1, \
        &NbiGlobalInterlock); \
    NbiRefAddressFileLock (_AddressFile)

#define NbiDereferenceAddressFile(_AddressFile, _Type) \
    (VOID)ExInterlockedAddUlong ( \
        &(_AddressFile)->RefTypes[_Type], \
        (ULONG)-1, \
        &NbiGlobalInterlock); \
    NbiDerefAddressFile (_AddressFile)

#define NbiTransferReferenceAddressFile(_AddressFile, _OldType, _NewType) \
    (VOID)ExInterlockedAddUlong ( \
        &(_AddressFile)->RefTypes[_NewType], \
        1, \
        &NbiGlobalInterlock); \
    (VOID)ExInterlockedAddUlong ( \
        &(_AddressFile)->RefTypes[_OldType], \
        (ULONG)-1, \
        &NbiGlobalInterlock);


#define NbiReferenceConnection(_Connection, _Type) \
    (VOID)ExInterlockedAddUlong ( \
        &(_Connection)->RefTypes[_Type], \
        1, \
        &NbiGlobalInterlock); \
    NbiRefConnection (_Connection)

#define NbiReferenceConnectionLock(_Connection, _Type) \
    (VOID)ExInterlockedAddUlong ( \
        &(_Connection)->RefTypes[_Type], \
        1, \
        &NbiGlobalInterlock); \
    NbiRefConnectionLock (_Connection)

#define NbiReferenceConnectionSync(_Connection, _Type) \
    (VOID)ExInterlockedAddUlong ( \
        &(_Connection)->RefTypes[_Type], \
        1, \
        &NbiGlobalInterlock); \
    NbiRefConnectionSync (_Connection)

#define NbiDereferenceConnection(_Connection, _Type) \
    (VOID)ExInterlockedAddUlong ( \
        &(_Connection)->RefTypes[_Type], \
        (ULONG)-1, \
        &NbiGlobalInterlock); \
    NbiDerefConnection (_Connection)

#define NbiTransferReferenceConnection(_Connection, _OldType, _NewType) \
    (VOID)ExInterlockedAddUlong ( \
        &(_Connection)->RefTypes[_NewType], \
        1, \
        &NbiGlobalInterlock); \
    (VOID)ExInterlockedAddUlong ( \
        &(_Connection)->RefTypes[_OldType], \
        (ULONG)-1, \
        &NbiGlobalInterlock);

#else  // DBG

#define NbiReferenceDevice(_Device, _Type) \
    InterlockedIncrement(&(_Device)->ReferenceCount)

#define NbiDereferenceDevice(_Device, _Type) \
    NbiDerefDevice (_Device)



#define NbiReferenceAddress(_Address, _Type) \
    InterlockedIncrement( &(_Address)->ReferenceCount )

#define NbiReferenceAddressLock(_Address, _Type) \
    InterlockedIncrement( &(_Address)->ReferenceCount )

#define NbiDereferenceAddress(_Address, _Type) \
    NbiDerefAddress (_Address)


#define NbiReferenceAddressFile(_AddressFile, _Type) \
    InterlockedIncrement( &(_AddressFile)->ReferenceCount )

#define NbiReferenceAddressFileLock(_AddressFile, _Type) \
    InterlockedIncrement( &(_AddressFile)->ReferenceCount )

#define NbiDereferenceAddressFile(_AddressFile, _Type) \
    if ( !InterlockedDecrement(&(_AddressFile)->ReferenceCount )) { \
        NbiDestroyAddressFile (_AddressFile); \
    }

#define NbiTransferReferenceAddressFile(_AddressFile, _OldType, _NewType)


#define NbiReferenceConnection(_Connection, _Type) { \
    (VOID)ExInterlockedAddUlong( \
        &(_Connection)->ReferenceCount, \
        1, \
        &(_Connection)->DeviceLock->Lock); \
    (_Connection)->CanBeDestroyed = FALSE; \
}

#define NbiReferenceConnectionLock(_Connection, _Type) { \
    ++(_Connection)->ReferenceCount; \
    (_Connection)->CanBeDestroyed = FALSE; \
}

#define NbiReferenceConnectionSync(_Connection, _Type) { \
    (VOID)NB_ADD_ULONG( \
        &(_Connection)->ReferenceCount, \
        1, \
        (_Connection)->DeviceLock); \
    (_Connection)->CanBeDestroyed = FALSE; \
}

#define NbiDereferenceConnection(_Connection, _Type) {                  \
    CTELockHandle   _LockHandle;                                        \
    NB_GET_LOCK( (_Connection)->DeviceLock, &_LockHandle );             \
    if ( !(--(_Connection)->ReferenceCount) ) {                         \
        (_Connection)->ThreadsInHandleConnectionZero++;                 \
        NB_FREE_LOCK( (_Connection)->DeviceLock, _LockHandle );         \
        NbiHandleConnectionZero (_Connection);                          \
    } else {                                                            \
        NB_FREE_LOCK( (_Connection)->DeviceLock, _LockHandle );         \
    }                                                                   \
}


#define NbiTransferReferenceConnection(_Connection, _OldType, _NewType)

#endif // DBG



#if DBG

#define NbiAllocateMemory(_BytesNeeded,_Tag,_Description) \
    NbipAllocateTaggedMemory(_BytesNeeded,_Tag,_Description)

#define NbiFreeMemory(_Memory,_BytesAllocated,_Tag,_Description) \
    NbipFreeTaggedMemory(_Memory,_BytesAllocated,_Tag,_Description)

#else // DBG

#define NbiAllocateMemory(_BytesNeeded,_Tag,_Description) \
    NbipAllocateMemory(_BytesNeeded,_Tag,(BOOLEAN)((_Tag) != MEMORY_CONFIG))

#define NbiFreeMemory(_Memory,_BytesAllocated,_Tag,_Description) \
    NbipFreeMemory(_Memory,_BytesAllocated,(BOOLEAN)((_Tag) != MEMORY_CONFIG))


#endif // DBG


VOID
TdiBindHandler(
    TDI_PNP_OPCODE  PnPOpCode,
    PUNICODE_STRING pDeviceName,
    PWSTR           MultiSZBindList);


//
// Definition of the callback routine where an NdisTransferData
// call is not needed.
//

typedef VOID
(*NB_CALLBACK_NO_TRANSFER) (
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR PacketBuffer,
    IN UINT PacketSize
    );



//
// This routine compares two node addresses.
//

#define NB_NODE_EQUAL(_A,_B) \
    ((*(UNALIGNED ULONG *)((PUCHAR)(_A)) == *(UNALIGNED ULONG *)((PUCHAR)(_B))) && \
     (*(UNALIGNED USHORT *)(((PUCHAR)(_A))+4) == *(UNALIGNED USHORT *)(((PUCHAR)(_B))+4)))

//
// This routine checks if an address is the broadcast address.
//

#define NB_NODE_BROADCAST(_A) \
    ((*(UNALIGNED ULONG *)((PUCHAR)(_A)) == 0xffffffff) && \
     (*(UNALIGNED USHORT *)(((PUCHAR)(_A))+4) == 0xffff))


//
// Definition of the routine to handler a particular minor
// code for an IOCTL_MJ_INTERNAL_DEVICE_CONTROL IRP.
//

typedef NTSTATUS
(*NB_TDI_DISPATCH_ROUTINE) (
    IN PDEVICE Device,
    IN PREQUEST Request
    );



//
// Routines in action.c
//

NTSTATUS
NbiTdiAction(
    IN PDEVICE Device,
    IN PREQUEST Request
    );


//
// Routines in address.c
//

TDI_ADDRESS_NETBIOS *
NbiParseTdiAddress(
    IN TRANSPORT_ADDRESS UNALIGNED  *TransportAddress,
    IN ULONG                        MaxBufferLength,
    IN BOOLEAN                      BroadcastAddressOk
    );

BOOLEAN
NbiValidateTdiAddress(
    IN TRANSPORT_ADDRESS UNALIGNED * TransportAddress,
    IN ULONG TransportAddressLength
    );

NTSTATUS
NbiOpenAddress(
    IN PDEVICE Device,
    IN PREQUEST Request
    );

VOID
NbiStartRegistration(
    IN PADDRESS Address
    );

VOID
NbiRegistrationTimeout(
    IN CTEEvent * Event,
    IN PVOID Context
    );

VOID
NbiProcessFindName(
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR PacketBuffer,
    IN UINT PacketSize
    );

VOID
NbiProcessAddName(
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR PacketBuffer,
    IN UINT PacketSize
    );

NTSTATUS
NbiOpenConnection(
    IN PDEVICE Device,
    IN PREQUEST Request
    );


NTSTATUS
NbiCreateAddress(
    IN  PREQUEST                        Request,
    IN  PADDRESS_FILE                   AddressFile,
    IN  PIO_STACK_LOCATION              IrpSp,
    IN  PDEVICE                         Device,
    IN  TDI_ADDRESS_NETBIOS             *NetbiosAddress,
    OUT PADDRESS                        *pAddress
    );

NTSTATUS
NbiVerifyAddressFile (
#if     defined(_PNP_POWER)
    IN PADDRESS_FILE AddressFile,
    IN BOOLEAN       ConflictIsOk
#else
    IN PADDRESS_FILE AddressFile
#endif  _PNP_POWER
    );

VOID
NbiDestroyAddress(
    IN PVOID Parameter
    );

#if DBG

VOID
NbiRefAddress(
    IN PADDRESS Address
    );

VOID
NbiRefAddressLock(
    IN PADDRESS Address
    );

#endif

VOID
NbiDerefAddress(
    IN PADDRESS Address
    );

PADDRESS_FILE
NbiCreateAddressFile(
    IN PDEVICE Device
    );

NTSTATUS
NbiDestroyAddressFile(
    IN PADDRESS_FILE AddressFile
    );

#if DBG

VOID
NbiRefAddressFile(
    IN PADDRESS_FILE AddressFile
    );

VOID
NbiRefAddressFileLock(
    IN PADDRESS_FILE AddressFile
    );

#endif

VOID
NbiDerefAddressFile(
    IN PADDRESS_FILE AddressFile
    );

#if      !defined(_PNP_POWER)
PADDRESS
NbiLookupAddress(
    IN PDEVICE Device,
    IN TDI_ADDRESS_NETBIOS UNALIGNED * NetbiosAddress
    );
#endif  !_PNP_POWER

PADDRESS
NbiFindAddress(
    IN PDEVICE Device,
    IN PUCHAR NetbiosName
    );

NTSTATUS
NbiStopAddressFile(
    IN PADDRESS_FILE AddressFile,
    IN PADDRESS Address
    );

NTSTATUS
NbiCloseAddressFile(
    IN PDEVICE Device,
    IN PREQUEST Request
    );

#if     defined(_PNP_POWER)
PADAPTER_ADDRESS
NbiCreateAdapterAddress(
    IN PCHAR    AdapterMacAddress
    );

NTSTATUS
NbiDestroyAdapterAddress(
    IN PADAPTER_ADDRESS AdapterAddress OPTIONAL,
    IN PCHAR            AdapterMacAddress OPTIONAL
    );

PADAPTER_ADDRESS
NbiFindAdapterAddress(
    IN PCHAR            NetbiosName,
    IN BOOLEAN          LockHeld
    );
#endif  _PNP_POWER


//
// Routines in bind.c
//

NTSTATUS
NbiBind(
    IN PDEVICE Device,
    IN PCONFIG Config
    );

VOID
NbiUnbind(
    IN PDEVICE Device
    );

VOID
NbiStatus(
    IN USHORT NicId,
    IN NDIS_STATUS GeneralStatus,
    IN PVOID StatusBuffer,
    IN UINT StatusBufferLength
    );

VOID
NbiLineUp(
    IN USHORT NicId,
    IN PIPX_LINE_INFO LineInfo,
    IN NDIS_MEDIUM DeviceType,
    IN PVOID ConfigurationData
    );

VOID
NbiLineDown(
    IN USHORT       NicId,
    IN ULONG_PTR    FwdAdapterCtx
    );


//
// Routines in cache.c
//

NTSTATUS
CacheFindName(
    IN PDEVICE Device,
    IN FIND_NAME_TYPE Type,
    IN PUCHAR RemoteName OPTIONAL,
    OUT PNETBIOS_CACHE * CacheName
);

VOID
FindNameTimeout(
    CTEEvent * Event,
    PVOID Context
    );

VOID
CacheHandlePending(
    IN PDEVICE Device,
    IN PUCHAR RemoteName,
    IN NETBIOS_NAME_RESULT Result,
    IN PNETBIOS_CACHE CacheName OPTIONAL
    IN NB_LOCK_HANDLE_PARAM(LockHandle)
    );

VOID
NbiProcessNameRecognized(
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR PacketBuffer,
    IN UINT PacketSize
    );

PNETBIOS_CACHE
CacheUpdateNameCache(
    IN PNETBIOS_CACHE NameCache,
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN TDI_ADDRESS_IPX UNALIGNED * SourceAddress,
    IN BOOLEAN ModifyQueue
    );

VOID
CacheUpdateFromAddName(
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN NB_CONNECTIONLESS UNALIGNED * Connectionless,
    IN BOOLEAN LocalFrame
    );

VOID
NbiProcessDeleteName(
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR PacketBuffer,
    IN UINT PacketSize
    );

VOID
InsertInNetbiosCacheTable(
    IN PNETBIOS_CACHE_TABLE CacheTable,
    IN PNETBIOS_CACHE       CacheEntry
    );

VOID
ReinsertInNetbiosCacheTable(
    IN PNETBIOS_CACHE_TABLE CacheTable,
    IN PNETBIOS_CACHE       OldEntry,
    IN PNETBIOS_CACHE       NewEntry
    );

VOID
RemoveFromNetbiosCacheTable(
    IN PNETBIOS_CACHE_TABLE CacheTable,
    IN PNETBIOS_CACHE       CacheEntry
    );

VOID
FlushOldFromNetbiosCacheTable(
    IN PNETBIOS_CACHE_TABLE CacheTable,
    IN USHORT               AgeLimit
    );

VOID
FlushFailedNetbiosCacheEntries(
    IN PNETBIOS_CACHE_TABLE CacheTable
    );

VOID
RemoveInvalidRoutesFromNetbiosCacheTable(
    IN PNETBIOS_CACHE_TABLE CacheTable,
    IN NIC_HANDLE UNALIGNED *InvalidNicHandle
    );

NTSTATUS
FindInNetbiosCacheTable(
    IN PNETBIOS_CACHE_TABLE CacheTable,
    IN PUCHAR               NameToBeFound,
    OUT PNETBIOS_CACHE       *CacheEntry
    );

NTSTATUS
CreateNetbiosCacheTable(
    IN OUT PNETBIOS_CACHE_TABLE *NewTable,
    IN USHORT   MaxHashIndex
    );

VOID
DestroyNetbiosCacheTable(
    IN PNETBIOS_CACHE_TABLE CacheTable
    );

//
// Routines in connect.c
//

VOID
NbiFindRouteComplete(
    IN PIPX_FIND_ROUTE_REQUEST FindRouteRequest,
    IN BOOLEAN FoundRoute
    );

NTSTATUS
NbiOpenConnection(
    IN PDEVICE Device,
    IN PREQUEST Request
    );

VOID
NbiStopConnection(
    IN PCONNECTION Connection,
    IN NTSTATUS DisconnectStatus
    IN NB_LOCK_HANDLE_PARAM(LockHandle)
    );

NTSTATUS
NbiCloseConnection(
    IN PDEVICE Device,
    IN PREQUEST Request
    );

NTSTATUS
NbiTdiAssociateAddress(
    IN PDEVICE Device,
    IN PREQUEST Request
    );

NTSTATUS
NbiTdiDisassociateAddress(
    IN PDEVICE Device,
    IN PREQUEST Request
    );

NTSTATUS
NbiTdiListen(
    IN PDEVICE Device,
    IN PREQUEST Request
    );

NTSTATUS
NbiTdiAccept(
    IN PDEVICE Device,
    IN PREQUEST Request
    );

NTSTATUS
NbiTdiConnect(
    IN PDEVICE Device,
    IN PREQUEST Request
    );

NTSTATUS
NbiTdiConnectFindName(
    IN PDEVICE Device,
    IN PREQUEST Request,
    IN PCONNECTION Connection,
    IN CTELockHandle CancelLH,
    IN CTELockHandle ConnectionLH,
    IN CTELockHandle DeviceLH,
    IN PBOOLEAN pbLockFreed
    );

NTSTATUS
NbiTdiDisconnect(
    IN PDEVICE Device,
    IN PREQUEST Request
    );

BOOLEAN
NbiAssignConnectionId(
    IN PDEVICE Device,
    IN PCONNECTION Connection
    );

VOID
NbiDeassignConnectionId(
    IN PDEVICE Device,
    IN PCONNECTION Connection
    );

VOID
NbiConnectionTimeout(
    IN CTEEvent * Event,
    IN PVOID Context
    );

VOID
NbiCancelListen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
NbiCancelConnectFindName(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
NbiCancelConnectWaitResponse(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
NbiCancelDisconnectWait(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

PCONNECTION
NbiLookupConnectionByContext(
    IN PADDRESS_FILE AddressFile,
    IN CONNECTION_CONTEXT ConnectionContext
    );

PCONNECTION
NbiCreateConnection(
    IN PDEVICE Device
    );

NTSTATUS
NbiVerifyConnection (
    IN PCONNECTION Connection
    );

VOID
NbiDestroyConnection(
    IN PCONNECTION Connection
    );

#if DBG
VOID
NbiRefConnection(
    IN PCONNECTION Connection
    );

VOID
NbiRefConnectionLock(
    IN PCONNECTION Connection
    );

VOID
NbiRefConnectionSync(
    IN PCONNECTION Connection
    );

VOID
NbiDerefConnection(
    IN PCONNECTION Connection
    );

VOID
NbiDerefConnectionSync(
    IN PCONNECTION Connection
    );
#endif

VOID
NbiHandleConnectionZero(
    IN PCONNECTION Connection
    );


//
// Routines in datagram.c
//

VOID
NbiProcessDatagram(
    IN NDIS_HANDLE MacBindingHandle,
    IN NDIS_HANDLE MacReceiveContext,
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR LookaheadBuffer,
    IN UINT LookaheadBufferSize,
    IN UINT LookaheadBufferOffset,
    IN UINT PacketSize,
    IN BOOLEAN Broadcast
    );

VOID
NbiIndicateDatagram(
    IN PADDRESS Address,
    IN PUCHAR RemoteName,
    IN PUCHAR Data,
    IN ULONG DataLength
    );

NTSTATUS
NbiTdiSendDatagram(
    IN PDEVICE Device,
    IN PREQUEST Request
    );

VOID
NbiTransmitDatagram(
    IN PNB_SEND_RESERVED Reserved
    );

NTSTATUS
NbiTdiReceiveDatagram(
    IN PDEVICE Device,
    IN PREQUEST Request
    );

VOID
NbiCancelReceiveDatagram(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


//
// Routines in device.c
//

VOID
NbiRefDevice(
    IN PDEVICE Device
    );

VOID
NbiDerefDevice(
    IN PDEVICE Device
    );

NTSTATUS
NbiCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING DeviceName,
    IN OUT PDEVICE *DevicePtr
    );

VOID
NbiDestroyDevice(
    IN PDEVICE Device
    );


//
// Routines in driver.c
//

PVOID
NbipAllocateMemory(
    IN ULONG BytesNeeded,
    IN ULONG Tag,
    IN BOOLEAN ChargeDevice
    );

VOID
NbipFreeMemory(
    IN PVOID Memory,
    IN ULONG BytesAllocated,
    IN BOOLEAN ChargeDevice
    );

#if DBG

PVOID
NbipAllocateTaggedMemory(
    IN ULONG BytesNeeded,
    IN ULONG Tag,
    IN PUCHAR Description
    );

VOID
NbipFreeTaggedMemory(
    IN PVOID Memory,
    IN ULONG BytesAllocated,
    IN ULONG Tag,
    IN PUCHAR Description
    );

#endif

VOID
NbiWriteResourceErrorLog(
    IN PDEVICE Device,
    IN ULONG BytesNeeded,
    IN ULONG UniqueErrorValue
    );

VOID
NbiWriteGeneralErrorLog(
    IN PDEVICE Device,
    IN NTSTATUS ErrorCode,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN PWSTR SecondString,
    IN ULONG DumpDataCount,
    IN ULONG DumpData[]
    );

VOID
NbiWriteOidErrorLog(
    IN PDEVICE Device,
    IN NTSTATUS ErrorCode,
    IN NTSTATUS FinalStatus,
    IN PWSTR AdapterString,
    IN ULONG OidValue
    );


//
// Routines in event.c
//

NTSTATUS
NbiTdiSetEventHandler(
    IN PDEVICE Device,
    IN PREQUEST Request
    );


//
// Routines in frame.c
//

VOID
NbiSendNameFrame(
    IN PADDRESS Address,
    IN UCHAR NameTypeFlag,
    IN UCHAR DataStreamType,
    IN PIPX_LOCAL_TARGET LocalTarget OPTIONAL,
#if     defined(_PNP_POWER)
    IN NB_CONNECTIONLESS UNALIGNED * ReqFrame OPTIONAL
#else
    IN TDI_ADDRESS_IPX UNALIGNED * DestAddress OPTIONAL
#endif  _PNP_POWER
    );

VOID
NbiSendSessionInitialize(
    IN PCONNECTION Connection
    );

VOID
NbiSendSessionInitAck(
    IN PCONNECTION Connection,
    IN PUCHAR ExtraData,
    IN ULONG ExtraDataLength,
    IN CTELockHandle * LockHandle OPTIONAL
    );

VOID
NbiSendDataAck(
    IN PCONNECTION Connection,
    IN NB_ACK_TYPE AckType
    IN NB_LOCK_HANDLE_PARAM (LockHandle)
    );

VOID
NbiSendSessionEnd(
    IN PCONNECTION Connection
    );

VOID
NbiSendSessionEndAck(
    IN TDI_ADDRESS_IPX UNALIGNED * RemoteAddress,
    IN PIPX_LOCAL_TARGET LocalTarget,
    IN NB_SESSION UNALIGNED * SessionEnd
    );


//
// Routines in packet.c
//

NTSTATUS
NbiInitializeSendPacket(
    IN PDEVICE Device,
    IN NDIS_HANDLE   PoolHandle OPTIONAL,
    IN PNB_SEND_PACKET Packet,
    IN PUCHAR Header,
    IN ULONG HeaderLength
    );

NTSTATUS
NbiInitializeReceivePacket(
    IN PDEVICE Device,
    IN NDIS_HANDLE   PoolHandle OPTIONAL,
    IN PNB_RECEIVE_PACKET Packet
    );

NTSTATUS
NbiInitializeReceiveBuffer(
    IN PDEVICE Device,
    IN PNB_RECEIVE_BUFFER ReceiveBuffer,
    IN PUCHAR DataBuffer,
    IN ULONG DataBufferLength
    );

VOID
NbiDeinitializeSendPacket(
    IN PDEVICE Device,
    IN PNB_SEND_PACKET Packet,
    IN ULONG HeaderLength
    );

VOID
NbiDeinitializeReceivePacket(
    IN PDEVICE Device,
    IN PNB_RECEIVE_PACKET Packet
    );

VOID
NbiDeinitializeReceiveBuffer(
    IN PDEVICE Device,
    IN PNB_RECEIVE_BUFFER ReceiveBuffer
    );

VOID
NbiAllocateSendPool(
    IN PDEVICE Device
    );

VOID
NbiAllocateReceivePool(
    IN PDEVICE Device
    );

#if     defined(_PNP_POWER)
VOID
NbiAllocateReceiveBufferPool(
    IN PDEVICE Device,
    IN UINT   DataLength
    );

VOID
NbiReAllocateReceiveBufferPool(
    IN PWORK_QUEUE_ITEM    WorkItem
    );

VOID
NbiDestroyReceiveBufferPools(
    IN  PDEVICE Device
    );

VOID
NbiPushReceiveBuffer (
    IN PNB_RECEIVE_BUFFER ReceiveBuffer
    );
#else
VOID
NbiAllocateReceiveBufferPool(
    IN PDEVICE Device
    );
#endif  _PNP_POWER

PSLIST_ENTRY
NbiPopSendPacket(
    IN PDEVICE Device,
    IN BOOLEAN LockAcquired
    );

VOID
NbiPushSendPacket(
    IN PNB_SEND_RESERVED Reserved
    );

VOID
NbiCheckForWaitPacket(
    IN PCONNECTION Connection
    );

PSLIST_ENTRY
NbiPopReceivePacket(
    IN PDEVICE Device
    );

PSINGLE_LIST_ENTRY
NbiPopReceiveBuffer(
    IN PDEVICE Device
    );


//
// Routines in query.c
//

NTSTATUS
NbiTdiQueryInformation(
    IN PDEVICE Device,
    IN PREQUEST Request
    );

NTSTATUS
NbiStoreAdapterStatus(
    IN ULONG MaximumLength,
    IN USHORT NicId,
    OUT PVOID * StatusBuffer,
    OUT ULONG * StatusBufferLength,
    OUT ULONG * ValidBufferLength
    );

VOID
NbiUpdateNetbiosFindName(
    IN PREQUEST Request,
#if     defined(_PNP_POWER)
    IN PNIC_HANDLE NicHandle,
#else
    IN USHORT NicId,
#endif  _PNP_POWER
    IN TDI_ADDRESS_IPX UNALIGNED * RemoteIpxAddress,
    IN BOOLEAN Unique
    );

VOID
NbiSetNetbiosFindNameInformation(
    IN PREQUEST Request
    );

NTSTATUS
NbiTdiSetInformation(
    IN PDEVICE Device,
    IN PREQUEST Request
    );

VOID
NbiProcessStatusQuery(
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR PacketBuffer,
    IN UINT PacketSize
    );

VOID
NbiSendStatusQuery(
    IN PREQUEST Request
    );

VOID
NbiProcessStatusResponse(
    IN NDIS_HANDLE MacBindingHandle,
    IN NDIS_HANDLE MacReceiveContext,
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR LookaheadBuffer,
    IN UINT LookaheadBufferSize,
    IN UINT LookaheadBufferOffset,
    IN UINT PacketSize
    );


//
// Routines in receive.c
//


BOOLEAN
NbiReceive(
    IN NDIS_HANDLE MacBindingHandle,
    IN NDIS_HANDLE MacReceiveContext,
    IN ULONG_PTR FwdAdapterCtx,
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR LookaheadBuffer,
    IN UINT LookaheadBufferSize,
    IN UINT LookaheadBufferOffset,
    IN UINT PacketSize,
    IN PMDL pMdl
    );

VOID
NbiReceiveComplete(
    IN USHORT NicId
    );

VOID
NbiTransferDataComplete(
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS Status,
    IN UINT BytesTransferred
    );

VOID
NbiAcknowledgeReceive(
    IN PCONNECTION Connection
    IN NB_LOCK_HANDLE_PARAM(LockHandle)
    );

VOID
NbiCompleteReceive(
    IN PCONNECTION Connection,
    IN BOOLEAN EndOfMessage,
    IN CTELockHandle    CancelLH
    IN NB_LOCK_HANDLE_PARAM(LockHandle)
    );

NTSTATUS
NbiTdiReceive(
    IN PDEVICE Device,
    IN PREQUEST Request
    );

VOID
NbiCancelReceive(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


//
// Routines in send.c
//


VOID
NbiSendComplete(
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS Status
    );

VOID
NbiAssignSequenceAndSend(
    IN PCONNECTION Connection,
    IN PNDIS_PACKET Packet
    IN NB_LOCK_HANDLE_PARAM(LockHandle)
    );

NTSTATUS
NbiTdiSend(
    IN PDEVICE Device,
    IN PREQUEST Request
    );

VOID
NbiPacketizeSend(
    IN PCONNECTION Connection
    IN NB_LOCK_HANDLE_PARAM(LockHandle)
    );

VOID
NbiReframeConnection(
    IN PCONNECTION Connection,
    IN USHORT ReceiveSequence,
    IN USHORT BytesReceived,
    IN BOOLEAN Resend
    IN NB_LOCK_HANDLE_PARAM(LockHandle)
    );

VOID
NbiRestartConnection(
    IN PCONNECTION Connection
    );

VOID
NbiAdvanceUnAckedByBytes(
    IN PCONNECTION Connection,
    IN ULONG BytesAcked
    );

VOID
NbiAdvanceUnAckedBySequence(
    IN PCONNECTION Connection,
    IN USHORT ReceiveSequence
    );

VOID
NbiCancelSend(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NbiBuildBufferChainFromBufferChain (
    IN NDIS_HANDLE BufferPoolHandle,
    IN PNDIS_BUFFER CurrentSourceBuffer,
    IN ULONG CurrentByteOffset,
    IN ULONG DesiredLength,
    OUT PNDIS_BUFFER *DestinationBuffer,
    OUT PNDIS_BUFFER *NewSourceBuffer,
    OUT ULONG *NewByteOffset,
    OUT ULONG *ActualLength
    );


//
// Routines in session.c
//

VOID
NbiProcessSessionData(
    IN NDIS_HANDLE MacBindingHandle,
    IN NDIS_HANDLE MacReceiveContext,
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR LookaheadBuffer,
    IN UINT LookaheadBufferSize,
    IN UINT LookaheadBufferOffset,
    IN UINT PacketSize
    );

VOID
NbiProcessDataAck(
    IN PCONNECTION Connection,
    IN NB_SESSION UNALIGNED * Sess,
    IN PIPX_LOCAL_TARGET RemoteAddress
    IN NB_LOCK_HANDLE_PARAM(LockHandle)
    );

VOID
NbiProcessSessionInitialize(
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR PacketBuffer,
    IN UINT PacketSize
    );

VOID
NbiProcessSessionInitAck(
    IN PCONNECTION Connection,
    IN NB_SESSION UNALIGNED * Sess
    IN NB_LOCK_HANDLE_PARAM(LockHandle)
    );

VOID
NbiProcessSessionEnd(
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR PacketBuffer,
    IN UINT PacketSize
    );

VOID
NbiProcessSessionEndAck(
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR PacketBuffer,
    IN UINT PacketSize
    );


//
// Routines in timer.c
//

VOID
NbiStartRetransmit(
    IN PCONNECTION Connection
    );

VOID
NbiStartWatchdog(
    IN PCONNECTION Connection
    );

#if DBG

VOID
NbiStopRetransmit(
    IN PCONNECTION Connection
    );

VOID
NbiStopWatchdog(
    IN PCONNECTION Connection
    );

#else

#define NbiStopRetransmit(_Connection) \
    (_Connection)->Retransmit = 0;

#define NbiStopWatchdog(_Connection) \
    (_Connection)->Watchdog = 0;

#endif

VOID
NbiExpireRetransmit(
    IN PCONNECTION Connection
    );

VOID
NbiExpireWatchdog(
    IN PCONNECTION Connection
    );

VOID
NbiShortTimeout(
    IN CTEEvent * Event,
    IN PVOID Context
    );

VOID
NbiLongTimeout(
    IN CTEEvent * Event,
    IN PVOID Context
    );

VOID
NbiStartShortTimer(
    IN PDEVICE Device
    );

VOID
NbiInitializeTimers(
    IN PDEVICE Device
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\nb\driver.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    driver.c

Abstract:

    This module contains the DriverEntry and other initialization
    code for the Netbios module of the ISN transport.

Author:

    Adam Barr (adamba) 16-November-1993

Environment:

    Kernel mode

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>


PDEVICE NbiDevice = NULL;
HANDLE  TdiProviderHandle = NULL;
#ifdef BIND_FIX
HANDLE  TdiClientHandle = NULL;

PDRIVER_OBJECT  NbiDriverObject = NULL;
UNICODE_STRING  NbiRegistryPath;
PEPROCESS   NbiFspProcess;
UNICODE_STRING  NbiBindString;
EXTERNAL_LOCK(NbiTdiRequestInterlock);
extern  LIST_ENTRY  NbiTdiRequestList;

WCHAR   BIND_STRING_NAME[50] = L"\\Device\\NwlnkIpx";

VOID
NbiUnbindFromIpx(
    );

#endif  // BIND_FIX

DEFINE_LOCK_STRUCTURE(NbiGlobalPoolInterlock);

#ifdef  RSRC_TIMEOUT_DBG

// RSRC_TIMEOUT_DBG is currently not defined!

ULONG   NbiGlobalDebugResTimeout = 1;
LARGE_INTEGER   NbiGlobalMaxResTimeout;
                                         // the packet is allocated from ndis pool.
NB_SEND_PACKET NbiGlobalDeathPacket;          // try to use this first for sends
UCHAR NbiGlobalDeathPacketHeader[100];

VOID
NbiInitDeathPacket()
{

    NDIS_HANDLE    PoolHandle; // poolhandle for sendpacket below when
    NTSTATUS    Status;

    //
    // if we are using ndis packets, first create packet pool for 1 packet descriptor
    //
    PoolHandle = (NDIS_HANDLE) NDIS_PACKET_POOL_TAG_FOR_NWLNKNB;      // Dbg info for Ndis!
    NdisAllocatePacketPoolEx (&Status, &PoolHandle, 1, 0, sizeof(NB_SEND_RESERVED));
    if (!NT_SUCCESS(Status)){
        DbgPrint("Could not allocatee death packet %lx\n", Status);
        NbiGlobalDebugResTimeout = 0;
    } else {
        NdisSetPacketPoolProtocolId (PoolHandle, NDIS_PROTOCOL_ID_IPX);

        if (NbiInitializeSendPacket(
                NbiDevice,
                PoolHandle,
                &NbiGlobalDeathPacket,
                NbiGlobalDeathPacketHeader,
                NbiDevice->Bind.MacHeaderNeeded + sizeof(NB_CONNECTION)) != STATUS_SUCCESS) {

            DbgPrint("Could not allocatee death packet %lx\n", Status);
            NbiGlobalDebugResTimeout = 0;

            //
            // Also free up the pool which we allocated above.
            //
            NdisFreePacketPool(PoolHandle);
        }
    }

}
#endif //RSRC_TIMEOUT_DBG

#if DBG

ULONG NbiDebug = 0xffffffff;
ULONG NbiDebug2 = 0x00000000;
ULONG NbiMemoryDebug = 0x0002482c;

UCHAR  NbiTempDebugBuffer[TEMP_BUF_LEN];

UCHAR  NbiDebugMemory [NB_MEMORY_LOG_SIZE][MAX_ARGLEN];
PUCHAR NbiDebugMemoryLoc = NbiDebugMemory[0];
PUCHAR NbiDebugMemoryEnd = NbiDebugMemory[NB_MEMORY_LOG_SIZE];

DEFINE_LOCK_STRUCTURE(NbiDebugLogLock);

VOID
NbiDebugMemoryLog(
    IN PUCHAR FormatString,
    ...
)
{
    INT             ArgLen;
    va_list         ArgumentPointer;
    PUCHAR          DebugMemoryLoc;
    CTELockHandle   LockHandle;

    va_start(ArgumentPointer, FormatString);

    //
    // To avoid any overflows, copy this in a temp buffer first.
    RtlZeroMemory (NbiTempDebugBuffer, TEMP_BUF_LEN);
    ArgLen = vsprintf(NbiTempDebugBuffer, FormatString, ArgumentPointer);
    va_end(ArgumentPointer);

    if (ArgLen > MAX_ARGLEN)
    {
        ArgLen = MAX_ARGLEN;
    }

    CTEGetLock (&NbiDebugLogLock, &LockHandle);
    DebugMemoryLoc = NbiDebugMemoryLoc;
    NbiDebugMemoryLoc += MAX_ARGLEN;
    if (NbiDebugMemoryLoc >= NbiDebugMemoryEnd)
    {
        NbiDebugMemoryLoc = NbiDebugMemory[0];
    }
    CTEFreeLock (&NbiDebugLogLock, LockHandle);

    RtlZeroMemory (NbiDebugMemoryLoc, MAX_ARGLEN);
    RtlCopyMemory( NbiDebugMemoryLoc, NbiTempDebugBuffer, ArgLen);
}   /* NbiDebugMemoryLog */


DEFINE_LOCK_STRUCTURE(NbiMemoryInterlock);
MEMORY_TAG NbiMemoryTag[MEMORY_MAX];

#endif
//
// This is used only for CHK build. For
// tracking the refcount problem on connection, this
// is moved here for now.
//
DEFINE_LOCK_STRUCTURE(NbiGlobalInterlock);


#ifdef RASAUTODIAL
VOID
NbiAcdBind();

VOID
NbiAcdUnbind();
#endif

#ifdef NB_PACKET_LOG

ULONG NbiPacketLogDebug = NB_PACKET_LOG_RCV_OTHER | NB_PACKET_LOG_SEND_OTHER;
USHORT NbiPacketLogSocket = 0;
DEFINE_LOCK_STRUCTURE(NbiPacketLogLock);
NB_PACKET_LOG_ENTRY NbiPacketLog[NB_PACKET_LOG_LENGTH];
PNB_PACKET_LOG_ENTRY NbiPacketLogLoc = NbiPacketLog;
PNB_PACKET_LOG_ENTRY NbiPacketLogEnd = &NbiPacketLog[NB_PACKET_LOG_LENGTH];

VOID
NbiLogPacket(
    IN BOOLEAN Send,
    IN PUCHAR DestMac,
    IN PUCHAR SrcMac,
    IN USHORT Length,
    IN PVOID NbiHeader,
    IN PVOID Data
    )

{

    CTELockHandle LockHandle;
    PNB_PACKET_LOG_ENTRY PacketLog;
    LARGE_INTEGER TickCount;
    ULONG DataLength;

    CTEGetLock (&NbiPacketLogLock, &LockHandle);

    PacketLog = NbiPacketLogLoc;

    ++NbiPacketLogLoc;
    if (NbiPacketLogLoc >= NbiPacketLogEnd) {
        NbiPacketLogLoc = NbiPacketLog;
    }
    *(UNALIGNED ULONG *)NbiPacketLogLoc->TimeStamp = 0x3e3d3d3d;    // "===>"

    CTEFreeLock (&NbiPacketLogLock, LockHandle);

    RtlZeroMemory (PacketLog, sizeof(NB_PACKET_LOG_ENTRY));

    PacketLog->SendReceive = Send ? '>' : '<';

    KeQueryTickCount(&TickCount);
    _itoa (TickCount.LowPart % 100000, PacketLog->TimeStamp, 10);

    RtlCopyMemory(PacketLog->DestMac, DestMac, 6);
    RtlCopyMemory(PacketLog->SrcMac, SrcMac, 6);
    PacketLog->Length[0] = Length / 256;
    PacketLog->Length[1] = Length % 256;

    if (Length < sizeof(IPX_HEADER)) {
        RtlCopyMemory(&PacketLog->NbiHeader, NbiHeader, Length);
    } else {
        RtlCopyMemory(&PacketLog->NbiHeader, NbiHeader, sizeof(IPX_HEADER));
    }

    DataLength = Length - sizeof(IPX_HEADER);
    if (DataLength < 14) {
        RtlCopyMemory(PacketLog->Data, Data, DataLength);
    } else {
        RtlCopyMemory(PacketLog->Data, Data, 14);
    }

}   /* NbiLogPacket */

#endif // NB_PACKET_LOG


//
// Forward declaration of various routines used in this module.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
NbiUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
NbiDispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NbiDispatchOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NbiDispatchInternal (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NbiDispatchPnP(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             pIrp
    );

VOID
NbiFreeResources (
    IN PVOID Adapter
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#endif

//
// This prevents us from having a bss section.
//

ULONG _setjmpexused = 0;


//
// These two are used in various places in the driver.
//

#if     defined(_PNP_POWER)
IPX_LOCAL_TARGET BroadcastTarget = { {ITERATIVE_NIC_ID}, { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } };
#endif  _PNP_POWER

UCHAR BroadcastAddress[6] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };

UCHAR NetbiosBroadcastName[16] = { '*', 0, 0, 0, 0, 0, 0, 0,
                                     0, 0, 0, 0, 0, 0, 0, 0 };

ULONG NbiFailLoad = FALSE;


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine performs initialization of the Netbios ISN module.
    It creates the device objects for the transport
    provider and performs other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

    RegistryPath - The name of Netbios's node in the registry.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS status;
#ifdef BIND_FIX
    WCHAR               wcNwlnkNbClientName[60]   = L"NwlnkNb";
    UNICODE_STRING      ucNwlnkNbClientName;
    TDI_CLIENT_INTERFACE_INFO   TdiClientInterface;
#else
    static const NDIS_STRING ProtocolName = NDIS_STRING_CONST("Netbios/IPX Transport");
    PDEVICE Device;
    PIPX_HEADER IpxHeader;
    CTELockHandle LockHandle;

    PCONFIG Config = NULL;
    WCHAR               wcNwlnkNbProviderName[60]   = L"\\Device\\NwlnkNb";
    UNICODE_STRING      ucNwlnkNbProviderName;
#endif  // !BIND_FIX

    //
    // Initialize the Common Transport Environment.
    //
    if (CTEInitialize() == 0) {
        NB_DEBUG (DEVICE, ("CTEInitialize() failed\n"));
        NbiWriteGeneralErrorLog(
            (PVOID)DriverObject,
            EVENT_TRANSPORT_REGISTER_FAILED,
            101,
            STATUS_UNSUCCESSFUL,
            NULL,
            0,
            NULL);
        return STATUS_UNSUCCESSFUL;
    }

#if DBG
    CTEInitLock (&NbiGlobalInterlock);
    CTEInitLock (&NbiMemoryInterlock);
    {
        UINT i;
        for (i = 0; i < MEMORY_MAX; i++) {
            NbiMemoryTag[i].Tag = i;
            NbiMemoryTag[i].BytesAllocated = 0;
        }
    }
#endif
#ifdef NB_PACKET_LOG
    CTEInitLock (&NbiPacketLogLock);
#endif
#if DBG
    CTEInitLock( &NbiDebugLogLock);
#endif

#if defined(NB_OWN_PACKETS)
    CTEAssert (NDIS_PACKET_SIZE == FIELD_OFFSET(NDIS_PACKET, ProtocolReserved[0]));
#endif

    NB_DEBUG2 (DEVICE, ("ISN Netbios loaded\n"));

#ifdef BIND_FIX
    //
    // Initialize the driver object with this driver's entry points.
    //
    DriverObject->MajorFunction [IRP_MJ_CREATE]                 = NbiDispatchOpenClose;
    DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL]         = NbiDispatchDeviceControl;
    DriverObject->MajorFunction [IRP_MJ_INTERNAL_DEVICE_CONTROL]= NbiDispatchInternal;
    DriverObject->MajorFunction [IRP_MJ_CLEANUP]                = NbiDispatchOpenClose;
    DriverObject->MajorFunction [IRP_MJ_CLOSE]                  = NbiDispatchOpenClose;
    DriverObject->MajorFunction [IRP_MJ_PNP]                    = NbiDispatchPnP;
    DriverObject->DriverUnload = NbiUnload;

    NbiDevice = NULL;
    NbiDriverObject = DriverObject;

    RtlInitUnicodeString(&NbiBindString, BIND_STRING_NAME);
    InitializeListHead(&NbiTdiRequestList);
    CTEInitLock (&NbiTdiRequestInterlock);

    //
    // Save the registry path
    //
    NbiRegistryPath.Buffer = (PWCHAR) NbiAllocateMemory (RegistryPath->Length + sizeof(WCHAR),
                                                         MEMORY_CONFIG, "RegistryPathBuffer");
    if (NbiRegistryPath.Buffer == NULL) {
        NbiWriteResourceErrorLog ((PVOID)DriverObject, RegistryPath->Length + sizeof(WCHAR), MEMORY_CONFIG);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory (NbiRegistryPath.Buffer, RegistryPath->Buffer, RegistryPath->Length);
    NbiRegistryPath.Buffer[RegistryPath->Length/sizeof(WCHAR)] = UNICODE_NULL;
    NbiRegistryPath.Length = RegistryPath->Length;
    NbiRegistryPath.MaximumLength = RegistryPath->Length + sizeof(WCHAR);

    NbiFspProcess =(PEPROCESS)PsGetCurrentProcess();

    //
    // Make Tdi ready for pnp notifications before binding to IPX
    //
    TdiInitialize();

    //
    // Register our Handlers with TDI
    //
    RtlInitUnicodeString(&ucNwlnkNbClientName, wcNwlnkNbClientName);
    ucNwlnkNbClientName.MaximumLength = sizeof (wcNwlnkNbClientName);
    RtlZeroMemory(&TdiClientInterface, sizeof(TdiClientInterface));

    TdiClientInterface.MajorTdiVersion      = MAJOR_TDI_VERSION;
    TdiClientInterface.MinorTdiVersion      = MINOR_TDI_VERSION;
    TdiClientInterface.ClientName           = &ucNwlnkNbClientName;
    TdiClientInterface.BindingHandler       = TdiBindHandler;
    if (!NT_SUCCESS(TdiRegisterPnPHandlers(&TdiClientInterface,sizeof(TdiClientInterface),&TdiClientHandle)))
    {
        TdiClientHandle = NULL;
        DbgPrint("Nbi.DriverEntry:  FAILed to Register NwlnkNb as Client!\n");
    }
#else
    //
    // This allocates the CONFIG structure and returns
    // it in Config.
    //
    status = NbiGetConfiguration(DriverObject, RegistryPath, &Config);
    if (!NT_SUCCESS (status)) {

        //
        // If it failed it logged an error.
        //
        PANIC (" Failed to initialize transport, ISN Netbios initialization failed.\n");
        return status;
    }


    //
    // Initialize the driver object with this driver's entry points.
    //
    DriverObject->MajorFunction [IRP_MJ_CREATE] = NbiDispatchOpenClose;
    DriverObject->MajorFunction [IRP_MJ_CLOSE] = NbiDispatchOpenClose;
    DriverObject->MajorFunction [IRP_MJ_CLEANUP] = NbiDispatchOpenClose;
    DriverObject->MajorFunction [IRP_MJ_INTERNAL_DEVICE_CONTROL] = NbiDispatchInternal;
    DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = NbiDispatchDeviceControl;
    DriverObject->DriverUnload = NbiUnload;

    //
    // Create the device object which exports our name.
    //
    status = NbiCreateDevice (DriverObject, &Config->DeviceName, &Device);
    if (!NT_SUCCESS (status)) {
        NbiWriteGeneralErrorLog(
            (PVOID)DriverObject,
            EVENT_IPX_CREATE_DEVICE,
            801,
            status,
            NULL,
            0,
            NULL);

        NbiFreeConfiguration(Config);
        return status;
    }

    NbiDevice = Device;

    //
    // Initialize the global pool interlock
    //
    CTEInitLock (&NbiGlobalPoolInterlock);

    //
    // Save the relevant configuration parameters.
    //
    Device->AckDelayTime = (Config->Parameters[CONFIG_ACK_DELAY_TIME] / SHORT_TIMER_DELTA) + 1;
    Device->AckWindow = Config->Parameters[CONFIG_ACK_WINDOW];
    Device->AckWindowThreshold = Config->Parameters[CONFIG_ACK_WINDOW_THRESHOLD];
    Device->EnablePiggyBackAck = Config->Parameters[CONFIG_ENABLE_PIGGYBACK_ACK];
    Device->Extensions = Config->Parameters[CONFIG_EXTENSIONS];
    Device->RcvWindowMax = Config->Parameters[CONFIG_RCV_WINDOW_MAX];
    Device->BroadcastCount = Config->Parameters[CONFIG_BROADCAST_COUNT];
    Device->BroadcastTimeout = Config->Parameters[CONFIG_BROADCAST_TIMEOUT];
    Device->ConnectionCount = Config->Parameters[CONFIG_CONNECTION_COUNT];
    Device->ConnectionTimeout = Config->Parameters[CONFIG_CONNECTION_TIMEOUT] * 500;
    Device->InitPackets = Config->Parameters[CONFIG_INIT_PACKETS];
    Device->MaxPackets = Config->Parameters[CONFIG_MAX_PACKETS];
    Device->InitialRetransmissionTime = Config->Parameters[CONFIG_INIT_RETRANSMIT_TIME];
    Device->Internet = Config->Parameters[CONFIG_INTERNET];
    Device->KeepAliveCount = Config->Parameters[CONFIG_KEEP_ALIVE_COUNT];
    Device->KeepAliveTimeout = Config->Parameters[CONFIG_KEEP_ALIVE_TIMEOUT];
    Device->RetransmitMax = Config->Parameters[CONFIG_RETRANSMIT_MAX];
    Device->RouterMtu     = Config->Parameters[CONFIG_ROUTER_MTU];
    Device->FindNameTimeout =
        ((Config->Parameters[CONFIG_BROADCAST_TIMEOUT]) + (FIND_NAME_GRANULARITY/2)) /
            FIND_NAME_GRANULARITY;

    Device->MaxReceiveBuffers = 20;   // Make it configurable?

    Device->NameCache = NULL;		// MP bug:  IPX tries to Flush it before it's initialized!

    //
    // Create Hash Table to store netbios cache entries
    // For server create a big table, for workstation a small one
    //
    if (MmIsThisAnNtAsSystem())
    {
        status = CreateNetbiosCacheTable( &Device->NameCache,  NB_NETBIOS_CACHE_TABLE_LARGE );
    }
    else
    {
        status = CreateNetbiosCacheTable( &Device->NameCache,  NB_NETBIOS_CACHE_TABLE_SMALL );
    }

    if (!NT_SUCCESS (status))
    {
        //
        // If it failed it logged an error.
        //
        NbiFreeConfiguration(Config);
        NbiDereferenceDevice (Device, DREF_LOADED);
        return status;
    }

    //
    // Make Tdi ready for pnp notifications before binding to IPX
    //
    TdiInitialize();

    //	Initialize the timer system. This should be done before
    //  binding to ipx because we should have timers intialized
    //  before ipx calls our pnp indications.
    NbiInitializeTimers (Device);

    //
    // Register us as a provider with Tdi
    //
    RtlInitUnicodeString(&ucNwlnkNbProviderName, wcNwlnkNbProviderName);
    ucNwlnkNbProviderName.MaximumLength = sizeof (wcNwlnkNbProviderName);
    if (!NT_SUCCESS (TdiRegisterProvider (&ucNwlnkNbProviderName, &TdiProviderHandle)))
    {
        TdiProviderHandle = NULL;
    }

    //
    // Now bind to IPX via the internal interface.
    //
    status = NbiBind (Device, Config);
    if (!NT_SUCCESS (status)) {

        //
        // If it failed it logged an error.
        //
        if (TdiProviderHandle)
        {
            TdiDeregisterProvider (TdiProviderHandle);
        }
        NbiFreeConfiguration(Config);
        NbiDereferenceDevice (Device, DREF_LOADED);
        return status;
    }

#ifdef  RSRC_TIMEOUT_DBG
    NbiInitDeathPacket();
    // NbiGlobalMaxResTimeout.QuadPart = 50; // 1*1000*10000;
    NbiGlobalMaxResTimeout.QuadPart = 20*60*1000;
    NbiGlobalMaxResTimeout.QuadPart *= 10000;
#endif  // RSRC_TIMEOUT_DBG

    NB_GET_LOCK (&Device->Lock, &LockHandle);

    //
    // Allocate our initial connectionless packet pool.
    //

    NbiAllocateSendPool (Device);

    //
    // Allocate our initial receive packet pool.
    //

    NbiAllocateReceivePool (Device);

    //
    // Allocate our initial receive buffer pool.
    //
    //
#if     defined(_PNP_POWER)
    if ( DEVICE_STATE_CLOSED == Device->State ) {
        Device->State = DEVICE_STATE_LOADED;
    }
#endif  _PNP_POWER

    NB_FREE_LOCK (&Device->Lock, LockHandle);

    //
    // Fill in the default connnectionless header.
    //
    IpxHeader = &Device->ConnectionlessHeader;
    IpxHeader->CheckSum = 0xffff;
    IpxHeader->PacketLength[0] = 0;
    IpxHeader->PacketLength[1] = 0;
    IpxHeader->TransportControl = 0;
    IpxHeader->PacketType = 0;
    *(UNALIGNED ULONG *)(IpxHeader->DestinationNetwork) = 0;
    RtlCopyMemory(IpxHeader->DestinationNode, BroadcastAddress, 6);
    IpxHeader->DestinationSocket = NB_SOCKET;
    IpxHeader->SourceSocket = NB_SOCKET;

#ifdef RASAUTODIAL
    //
    // Get the automatic connection
    // driver entry points.
    //
    NbiAcdBind();
#endif

    NbiFreeConfiguration(Config);
#endif  // BIND_FIX

    return STATUS_SUCCESS;

}   /* DriverEntry */




VOID
NbiUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine unloads the sample transport driver.
    It unbinds from any NDIS drivers that are open and frees all resources
    associated with the transport. The I/O system will not call us until
    nobody above has Netbios open.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    None. When the function returns, the driver is unloaded.

--*/

{
#ifdef BIND_FIX
    UNREFERENCED_PARAMETER (DriverObject);

    if (TdiClientHandle)
    {
        TdiDeregisterPnPHandlers (TdiClientHandle);
        TdiClientHandle = NULL;
    }

    if (TdiProviderHandle)
    {
        TdiDeregisterProvider (TdiProviderHandle);
    }

    if (NbiBindState & NBI_BOUND_TO_IPX)
    {
        NbiUnbindFromIpx();
    }

    NbiFreeMemory (NbiRegistryPath.Buffer, NbiRegistryPath.MaximumLength,MEMORY_CONFIG,"RegistryPathBuffer");
#else
    PNETBIOS_CACHE CacheName;
    PDEVICE Device = NbiDevice;
    PLIST_ENTRY p;
    UNREFERENCED_PARAMETER (DriverObject);

#ifdef RASAUTODIAL
    //
    // Unbind from the
    // automatic connection driver.
    //
    NbiAcdUnbind();
#endif

    Device->State = DEVICE_STATE_STOPPING;

    //
    // Cancel the long timer.
    //

    if (CTEStopTimer (&Device->LongTimer)) {
        NbiDereferenceDevice (Device, DREF_LONG_TIMER);
    }

    //
    // Unbind from the IPX driver.
    //

    NbiUnbind (Device);

    //
    // This event will get set when the reference count
    // drops to 0.
    //

    KeInitializeEvent(
        &Device->UnloadEvent,
        NotificationEvent,
        FALSE);
    Device->UnloadWaiting = TRUE;

    //
    // Remove the reference for us being loaded.
    //

    NbiDereferenceDevice (Device, DREF_LOADED);

    //
    // Wait for our count to drop to zero.
    //

    KeWaitForSingleObject(
        &Device->UnloadEvent,
        Executive,
        KernelMode,
        TRUE,
        (PLARGE_INTEGER)NULL
        );

    //
    // Free the cache of netbios names.
    //
    DestroyNetbiosCacheTable( Device->NameCache );

    //
    // Do the cleanup that has to happen at IRQL 0.
    //
    ExDeleteResource (&Device->AddressResource);
    IoDeleteDevice ((PDEVICE_OBJECT)Device);

    if (TdiProviderHandle)
    {
        TdiDeregisterProvider (TdiProviderHandle);
    }
#endif  // BIND_FIX
}   /* NbiUnload */


VOID
NbiFreeResources (
    IN PVOID Adapter
    )
/*++

Routine Description:

    This routine is called by Netbios to clean up the data structures associated
    with a given Device. When this routine exits, the Device
    should be deleted as it no longer has any assocaited resources.

Arguments:

    Device - Pointer to the Device we wish to clean up.

Return Value:

    None.

--*/
{
#if 0
    PLIST_ENTRY p;
    PSINGLE_LIST_ENTRY s;
    PTP_PACKET packet;
    PNDIS_PACKET ndisPacket;
    PBUFFER_TAG BufferTag;
#endif


#if 0
    //
    // Clean up packet pool.
    //

    while ( Device->PacketPool.Next != NULL ) {
        s = PopEntryList( &Device->PacketPool );
        packet = CONTAINING_RECORD( s, TP_PACKET, Linkage );

        NbiDeallocateSendPacket (Device, packet);
    }

    //
    // Clean up receive packet pool
    //

    while ( Device->ReceivePacketPool.Next != NULL) {
        s = PopEntryList (&Device->ReceivePacketPool);

        //
        // HACK: This works because Linkage is the first field in
        // ProtocolReserved for a receive packet.
        //

        ndisPacket = CONTAINING_RECORD (s, NDIS_PACKET, ProtocolReserved[0]);

        NbiDeallocateReceivePacket (Device, ndisPacket);
    }


    //
    // Clean up receive buffer pool.
    //

    while ( Device->ReceiveBufferPool.Next != NULL ) {
        s = PopEntryList( &Device->ReceiveBufferPool );
        BufferTag = CONTAINING_RECORD (s, BUFFER_TAG, Linkage );

        NbiDeallocateReceiveBuffer (Device, BufferTag);
    }

#endif

}   /* NbiFreeResources */


NTSTATUS
NbiDispatchOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the main dispatch routine for the IPXNB device driver.
    It accepts an I/O Request Packet, performs the request, and then
    returns with the appropriate status.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    CTELockHandle LockHandle;
    PDEVICE Device = (PDEVICE)DeviceObject;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PFILE_FULL_EA_INFORMATION openType;
    PADDRESS_FILE AddressFile;
    PCONNECTION Connection;
    PREQUEST Request;
    UINT i;
    NB_DEFINE_LOCK_HANDLE (LockHandle1)
    NB_DEFINE_SYNC_CONTEXT (SyncContext)

#if      !defined(_PNP_POWER)
    if (Device->State != DEVICE_STATE_OPEN) {
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        return STATUS_INVALID_DEVICE_STATE;
    }
#endif  !_PNP_POWER

    //
    // Allocate a request to track this IRP.
    //

    Request = NbiAllocateRequest (Device, Irp);
    IF_NOT_ALLOCATED(Request) {
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Make sure status information is consistent every time.
    //

    MARK_REQUEST_PENDING(Request);
    REQUEST_STATUS(Request) = STATUS_PENDING;
    REQUEST_INFORMATION(Request) = 0;

    //
    // Case on the function that is being performed by the requestor.  If the
    // operation is a valid one for this device, then make it look like it was
    // successfully completed, where possible.
    //


    switch (REQUEST_MAJOR_FUNCTION(Request)) {

    //
    // The Create function opens a transport object (either address or
    // connection).  Access checking is performed on the specified
    // address to ensure security of transport-layer addresses.
    //

    case IRP_MJ_CREATE:

#if     defined(_PNP_POWER)
        if (Device->State != DEVICE_STATE_OPEN) {
            Status = STATUS_INVALID_DEVICE_STATE;
            break;
        }
#endif  _PNP_POWER

        openType = OPEN_REQUEST_EA_INFORMATION(Request);
        if (openType != NULL) {

            if (strncmp(openType->EaName,TdiTransportAddress,openType->EaNameLength) == 0)
            {
                Status = NbiOpenAddress (Device, Request);
                break;
            }
            else if (strncmp(openType->EaName,TdiConnectionContext,openType->EaNameLength) == 0)
            {
                Status = NbiOpenConnection (Device, Request);
                break;
            }

        } else {

            NB_GET_LOCK (&Device->Lock, &LockHandle);

            REQUEST_OPEN_CONTEXT(Request) = (PVOID)(Device->ControlChannelIdentifier);
            ++Device->ControlChannelIdentifier;
            if (Device->ControlChannelIdentifier == 0) {
                Device->ControlChannelIdentifier = 1;
            }

            NB_FREE_LOCK (&Device->Lock, LockHandle);

            REQUEST_OPEN_TYPE(Request) = (PVOID)TDI_CONTROL_CHANNEL_FILE;
            Status = STATUS_SUCCESS;
        }

        break;

    case IRP_MJ_CLOSE:

#if     defined(_PNP_POWER)
        if ( (Device->State != DEVICE_STATE_OPEN) && (Device->State != DEVICE_STATE_LOADED) ) {
            Status = STATUS_INVALID_DEVICE_STATE;
            break;
        }
#endif  _PNP_POWER

        //
        // The Close function closes a transport endpoint, terminates
        // all outstanding transport activity on the endpoint, and unbinds
        // the endpoint from its transport address, if any.  If this
        // is the last transport endpoint bound to the address, then
        // the address is removed from the provider.
        //

        switch ((ULONG_PTR)REQUEST_OPEN_TYPE(Request)) {

        case TDI_TRANSPORT_ADDRESS_FILE:

            AddressFile = (PADDRESS_FILE)REQUEST_OPEN_CONTEXT(Request);

            //
            // This creates a reference to AddressFile.
            //

#if     defined(_PNP_POWER)
            Status = NbiVerifyAddressFile(AddressFile, CONFLICT_IS_OK);
#else
            Status = NbiVerifyAddressFile(AddressFile);
#endif  _PNP_POWER

            if (!NT_SUCCESS (Status)) {
                Status = STATUS_INVALID_HANDLE;
            } else {
                Status = NbiCloseAddressFile (Device, Request);
                NbiDereferenceAddressFile (AddressFile, AFREF_VERIFY);

            }

            break;

        case TDI_CONNECTION_FILE:

            Connection = (PCONNECTION)REQUEST_OPEN_CONTEXT(Request);

            //
            // We don't call VerifyConnection because the I/O
            // system should only give us one close and the file
            // object should be valid. This helps avoid a window
            // where two threads call HandleConnectionZero at the
            // same time.
            //

            Status = NbiCloseConnection (Device, Request);

            break;

        case TDI_CONTROL_CHANNEL_FILE:

            //
            // See if it is one of the upper driver's control channels.
            //

            Status = STATUS_SUCCESS;

            break;

        default:

            Status = STATUS_INVALID_HANDLE;

        }

        break;

    case IRP_MJ_CLEANUP:

#if     defined(_PNP_POWER)
        if ( (Device->State != DEVICE_STATE_OPEN) && (Device->State != DEVICE_STATE_LOADED) ) {
            Status = STATUS_INVALID_DEVICE_STATE;
            break;
        }
#endif  _PNP_POWER

        //
        // Handle the two stage IRP for a file close operation. When the first
        // stage hits, run down all activity on the object of interest. This
        // do everything to it but remove the creation hold. Then, when the
        // CLOSE irp hits, actually close the object.
        //

        switch ((ULONG_PTR)REQUEST_OPEN_TYPE(Request)) {

        case TDI_TRANSPORT_ADDRESS_FILE:

            AddressFile = (PADDRESS_FILE)REQUEST_OPEN_CONTEXT(Request);

#if     defined(_PNP_POWER)
            Status = NbiVerifyAddressFile(AddressFile, CONFLICT_IS_OK);
#else
            Status = NbiVerifyAddressFile(AddressFile);
#endif  _PNP_POWER

            if (!NT_SUCCESS (Status)) {

                Status = STATUS_INVALID_HANDLE;

            } else {

                NbiStopAddressFile (AddressFile, AddressFile->Address);
                NbiDereferenceAddressFile (AddressFile, AFREF_VERIFY);
                Status = STATUS_SUCCESS;
            }

            break;

        case TDI_CONNECTION_FILE:

            Connection = (PCONNECTION)REQUEST_OPEN_CONTEXT(Request);

            Status = NbiVerifyConnection(Connection);

            if (!NT_SUCCESS (Status)) {

                Status = STATUS_INVALID_HANDLE;

            } else {

                NB_BEGIN_SYNC (&SyncContext);
                NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle1);

                //
                // This call releases the lock.
                //

                NbiStopConnection(
                    Connection,
                    STATUS_INVALID_CONNECTION
                    NB_LOCK_HANDLE_ARG (LockHandle1));

                NB_END_SYNC (&SyncContext);

                NbiDereferenceConnection (Connection, CREF_VERIFY);
                Status = STATUS_SUCCESS;
            }

            break;

        case TDI_CONTROL_CHANNEL_FILE:

            Status = STATUS_SUCCESS;
            break;

        default:

            Status = STATUS_INVALID_HANDLE;

        }

        break;

    default:

        Status = STATUS_INVALID_DEVICE_REQUEST;

    } /* major function switch */

    if (Status != STATUS_PENDING) {
        UNMARK_REQUEST_PENDING(Request);
        REQUEST_STATUS(Request) = Status;
        NbiCompleteRequest (Request);
        NbiFreeRequest (Device, Request);
    }

    //
    // Return the immediate status code to the caller.
    //

    return Status;

}   /* NbiDispatchOpenClose */


NTSTATUS
NbiDispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine dispatches TDI request types to different handlers based
    on the minor IOCTL function code in the IRP's current stack location.
    In addition to cracking the minor function code, this routine also
    reaches into the IRP and passes the packetized parameters stored there
    as parameters to the various TDI request handlers so that they are
    not IRP-dependent.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS Status;
    PDEVICE Device = (PDEVICE)DeviceObject;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (Irp);

    //
    // Branch to the appropriate request handler.  Preliminary checking of
    // the size of the request block is performed here so that it is known
    // in the handlers that the minimum input parameters are readable.  It
    // is *not* determined here whether variable length input fields are
    // passed correctly; this is a check which must be made within each routine.
    //

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

        default:

            //
            // Convert the user call to the proper internal device call.
            //

            Status = TdiMapUserRequest (DeviceObject, Irp, IrpSp);

            if (Status == STATUS_SUCCESS) {

                //
                // If TdiMapUserRequest returns SUCCESS then the IRP
                // has been converted into an IRP_MJ_INTERNAL_DEVICE_CONTROL
                // IRP, so we dispatch it as usual. The IRP will
                // be completed by this call.
                //

                Status = NbiDispatchInternal (DeviceObject, Irp);

            } else {

                Irp->IoStatus.Status = Status;
                IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);

            }

            break;
    }

    return Status;

}   /* NbiDeviceControl */


NB_TDI_DISPATCH_ROUTINE NbiDispatchInternalTable[] = {
    NbiTdiAssociateAddress,
    NbiTdiDisassociateAddress,
    NbiTdiConnect,
    NbiTdiListen,
    NbiTdiAccept,
    NbiTdiDisconnect,
    NbiTdiSend,
    NbiTdiReceive,
    NbiTdiSendDatagram,
    NbiTdiReceiveDatagram,
    NbiTdiSetEventHandler,
    NbiTdiQueryInformation,
    NbiTdiSetInformation,
    NbiTdiAction
    };


NTSTATUS
NbiDispatchInternal(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine dispatches TDI request types to different handlers based
    on the minor IOCTL function code in the IRP's current stack location.
    In addition to cracking the minor function code, this routine also
    reaches into the IRP and passes the packetized parameters stored there
    as parameters to the various TDI request handlers so that they are
    not IRP-dependent.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS Status;
    PDEVICE Device = (PDEVICE)DeviceObject;
    PREQUEST Request;
    UCHAR MinorFunction;

    if (Device->State != DEVICE_STATE_OPEN) {
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        return STATUS_INVALID_DEVICE_STATE;
    }


    //
    // Allocate a request to track this IRP.
    //

    Request = NbiAllocateRequest (Device, Irp);
    IF_NOT_ALLOCATED(Request) {
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Make sure status information is consistent every time.
    //

    MARK_REQUEST_PENDING(Request);
    REQUEST_STATUS(Request) = STATUS_PENDING;
    REQUEST_INFORMATION(Request) = 0;


    //
    // Branch to the appropriate request handler.
    //

    MinorFunction = REQUEST_MINOR_FUNCTION(Request) - 1;

    if (MinorFunction <= (TDI_ACTION-1)) {

        Status = (*NbiDispatchInternalTable[MinorFunction]) (
                     Device,
                     Request);

    } else {

        NB_DEBUG (DRIVER, ("Unsupported minor code %d\n", MinorFunction+1));
        if ((MinorFunction+1) == TDI_DISCONNECT) {
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_INVALID_DEVICE_REQUEST;
        }
    }

    if (Status != STATUS_PENDING) {
        UNMARK_REQUEST_PENDING(Request);
        REQUEST_STATUS(Request) = Status;
        NbiCompleteRequest (Request);
        NbiFreeRequest (Device, Request);
    }

    //
    // Return the immediate status code to the caller.
    //

    return Status;

}   /* NbiDispatchInternal */


PVOID
NbipAllocateMemory(
    IN ULONG BytesNeeded,
    IN ULONG Tag,
    IN BOOLEAN ChargeDevice
    )

/*++

Routine Description:

    This routine allocates memory, making sure it is within
    the limit allowed by the device.

Arguments:

    BytesNeeded - The number of bytes to allocated.

    ChargeDevice - TRUE if the device should be charged.

Return Value:

    None.

--*/

{
    PVOID Memory;
    PDEVICE Device = NbiDevice;

    if (ChargeDevice) {
        if ((Device->MemoryLimit != 0) &&
                (((LONG)(Device->MemoryUsage + BytesNeeded) >
                    Device->MemoryLimit))) {

            NbiPrint1 ("Nbi: Could not allocate %d: limit\n", BytesNeeded);
            NbiWriteResourceErrorLog (Device, BytesNeeded, Tag);
            return NULL;
        }
    }

#if ISN_NT
    Memory = ExAllocatePoolWithTag (NonPagedPool, BytesNeeded, ' IBN');
#else
    Memory = CTEAllocMem (BytesNeeded);
#endif

    if (Memory == NULL) {

        NbiPrint1("Nbi: Could not allocate %d: no pool\n", BytesNeeded);

        if (ChargeDevice) {
            NbiWriteResourceErrorLog (Device, BytesNeeded, Tag);
        }

        return NULL;
    }

    if (ChargeDevice) {
        Device->MemoryUsage += BytesNeeded;
    }

    return Memory;

}   /* NbipAllocateMemory */


VOID
NbipFreeMemory(
    IN PVOID Memory,
    IN ULONG BytesAllocated,
    IN BOOLEAN ChargeDevice
    )

/*++

Routine Description:

    This routine frees memory allocated with NbipAllocateMemory.

Arguments:

    Memory - The memory allocated.

    BytesAllocated - The number of bytes to freed.

    ChargeDevice - TRUE if the device should be charged.

Return Value:

    None.

--*/

{
    PDEVICE Device = NbiDevice;

#if ISN_NT
    ExFreePool (Memory);
#else
    CTEFreeMem (Memory);
#endif

    if (ChargeDevice) {
        Device->MemoryUsage -= BytesAllocated;
    }

}   /* NbipFreeMemory */

#if DBG


PVOID
NbipAllocateTaggedMemory(
    IN ULONG BytesNeeded,
    IN ULONG Tag,
    IN PUCHAR Description
    )

/*++

Routine Description:

    This routine allocates memory, charging it to the device.
    If it cannot allocate memory it uses the Tag and Descriptor
    to log an error.

Arguments:

    BytesNeeded - The number of bytes to allocated.

    Tag - A unique ID used in the error log.

    Description - A text description of the allocation.

Return Value:

    None.

--*/

{
    PVOID Memory;

    UNREFERENCED_PARAMETER(Description);

    Memory = NbipAllocateMemory(BytesNeeded, Tag, (BOOLEAN)(Tag != MEMORY_CONFIG));

    if (Memory) {
        ExInterlockedAddUlong(
            &NbiMemoryTag[Tag].BytesAllocated,
            BytesNeeded,
            &NbiMemoryInterlock);
    }

    return Memory;

}   /* NbipAllocateTaggedMemory */


VOID
NbipFreeTaggedMemory(
    IN PVOID Memory,
    IN ULONG BytesAllocated,
    IN ULONG Tag,
    IN PUCHAR Description
    )

/*++

Routine Description:

    This routine frees memory allocated with NbipAllocateTaggedMemory.

Arguments:

    Memory - The memory allocated.

    BytesAllocated - The number of bytes to freed.

    Tag - A unique ID used in the error log.

    Description - A text description of the allocation.

Return Value:

    None.

--*/

{

    UNREFERENCED_PARAMETER(Description);

    ExInterlockedAddUlong(
        &NbiMemoryTag[Tag].BytesAllocated,
        (ULONG)(-(LONG)BytesAllocated),
        &NbiMemoryInterlock);

    NbipFreeMemory (Memory, BytesAllocated, (BOOLEAN)(Tag != MEMORY_CONFIG));

}   /* NbipFreeTaggedMemory */

#endif


VOID
NbiWriteResourceErrorLog(
    IN PDEVICE Device,
    IN ULONG BytesNeeded,
    IN ULONG UniqueErrorValue
    )

/*++

Routine Description:

    This routine allocates and writes an error log entry indicating
    an out of resources condition.

Arguments:

    Device - Pointer to the device context.

    BytesNeeded - If applicable, the number of bytes that could not
        be allocated.

    UniqueErrorValue - Used as the UniqueErrorValue in the error log
        packet.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    UCHAR EntrySize;
    PUCHAR StringLoc;
    ULONG TempUniqueError;
    static WCHAR UniqueErrorBuffer[4] = L"000";
    INT i;

    EntrySize = sizeof(IO_ERROR_LOG_PACKET) +
                Device->DeviceString.MaximumLength +
                sizeof(UniqueErrorBuffer);

    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
        (PDEVICE_OBJECT)Device,
        EntrySize
    );

    //
    // Convert the error value into a buffer.
    //

    TempUniqueError = UniqueErrorValue;
    for (i=1; i>=0; i--) {
        UniqueErrorBuffer[i] = (WCHAR)((TempUniqueError % 10) + L'0');
        TempUniqueError /= 10;
    }

    if (errorLogEntry != NULL) {

        errorLogEntry->MajorFunctionCode = (UCHAR)-1;
        errorLogEntry->RetryCount = (UCHAR)-1;
        errorLogEntry->DumpDataSize = sizeof(ULONG);
        errorLogEntry->NumberOfStrings = 2;
        errorLogEntry->StringOffset = sizeof(IO_ERROR_LOG_PACKET);
        errorLogEntry->EventCategory = 0;
        errorLogEntry->ErrorCode = EVENT_TRANSPORT_RESOURCE_POOL;
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;
        errorLogEntry->SequenceNumber = (ULONG)-1;
        errorLogEntry->IoControlCode = 0;
        errorLogEntry->DumpData[0] = BytesNeeded;

        StringLoc = ((PUCHAR)errorLogEntry) + errorLogEntry->StringOffset;
        RtlCopyMemory (StringLoc, Device->DeviceString.Buffer, Device->DeviceString.MaximumLength);
        StringLoc += Device->DeviceString.MaximumLength;

        RtlCopyMemory (StringLoc, UniqueErrorBuffer, sizeof(UniqueErrorBuffer));

        IoWriteErrorLogEntry(errorLogEntry);

    }

}   /* NbiWriteResourceErrorLog */


VOID
NbiWriteGeneralErrorLog(
    IN PDEVICE Device,
    IN NTSTATUS ErrorCode,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN PWSTR SecondString,
    IN ULONG DumpDataCount,
    IN ULONG DumpData[]
    )

/*++

Routine Description:

    This routine allocates and writes an error log entry indicating
    a general problem as indicated by the parameters. It handles
    event codes REGISTER_FAILED, BINDING_FAILED, ADAPTER_NOT_FOUND,
    TRANSFER_DATA, TOO_MANY_LINKS, and BAD_PROTOCOL. All these
    events have messages with one or two strings in them.

Arguments:

    Device - Pointer to the device context, or this may be
        a driver object instead.

    ErrorCode - The transport event code.

    UniqueErrorValue - Used as the UniqueErrorValue in the error log
        packet.

    FinalStatus - Used as the FinalStatus in the error log packet.

    SecondString - If not NULL, the string to use as the %3
        value in the error log packet.

    DumpDataCount - The number of ULONGs of dump data.

    DumpData - Dump data for the packet.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    UCHAR EntrySize;
    ULONG SecondStringSize;
    PUCHAR StringLoc;
    static WCHAR DriverName[8] = L"NwlnkNb";

    EntrySize = (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) +
                       (DumpDataCount * sizeof(ULONG)));

    if (Device->Type == IO_TYPE_DEVICE) {
        EntrySize += (UCHAR)Device->DeviceString.MaximumLength;
    } else {
        EntrySize += sizeof(DriverName);
    }

    if (SecondString) {
        SecondStringSize = (wcslen(SecondString)*sizeof(WCHAR)) + sizeof(UNICODE_NULL);
        EntrySize += (UCHAR)SecondStringSize;
    }

    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
        (PDEVICE_OBJECT)Device,
        EntrySize
    );

    if (errorLogEntry != NULL) {

        errorLogEntry->MajorFunctionCode = (UCHAR)-1;
        errorLogEntry->RetryCount = (UCHAR)-1;
        errorLogEntry->DumpDataSize = (USHORT)(DumpDataCount * sizeof(ULONG));
        errorLogEntry->NumberOfStrings = (SecondString == NULL) ? 1 : 2;
        errorLogEntry->StringOffset =
            (USHORT)(sizeof(IO_ERROR_LOG_PACKET) + ((DumpDataCount-1) * sizeof(ULONG)));
        errorLogEntry->EventCategory = 0;
        errorLogEntry->ErrorCode = ErrorCode;
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->FinalStatus = FinalStatus;
        errorLogEntry->SequenceNumber = (ULONG)-1;
        errorLogEntry->IoControlCode = 0;

        if (DumpDataCount) {
            RtlCopyMemory(errorLogEntry->DumpData, DumpData, DumpDataCount * sizeof(ULONG));
        }

        StringLoc = ((PUCHAR)errorLogEntry) + errorLogEntry->StringOffset;
        if (Device->Type == IO_TYPE_DEVICE) {
            RtlCopyMemory (StringLoc, Device->DeviceString.Buffer, Device->DeviceString.MaximumLength);
            StringLoc += Device->DeviceString.MaximumLength;
        } else {
            RtlCopyMemory (StringLoc, DriverName, sizeof(DriverName));
            StringLoc += sizeof(DriverName);
        }
        if (SecondString) {
            RtlCopyMemory (StringLoc, SecondString, SecondStringSize);
        }

        IoWriteErrorLogEntry(errorLogEntry);

    }

}   /* NbiWriteGeneralErrorLog */


VOID
NbiWriteOidErrorLog(
    IN PDEVICE Device,
    IN NTSTATUS ErrorCode,
    IN NTSTATUS FinalStatus,
    IN PWSTR AdapterString,
    IN ULONG OidValue
    )

/*++

Routine Description:

    This routine allocates and writes an error log entry indicating
    a problem querying or setting an OID on an adapter. It handles
    event codes SET_OID_FAILED and QUERY_OID_FAILED.

Arguments:

    Device - Pointer to the device context.

    ErrorCode - Used as the ErrorCode in the error log packet.

    FinalStatus - Used as the FinalStatus in the error log packet.

    AdapterString - The name of the adapter we were bound to.

    OidValue - The OID which could not be set or queried.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    UCHAR EntrySize;
    ULONG AdapterStringSize;
    PUCHAR StringLoc;
    static WCHAR OidBuffer[9] = L"00000000";
    INT i;
    UINT CurrentDigit;

    AdapterStringSize = (wcslen(AdapterString)*sizeof(WCHAR)) + sizeof(UNICODE_NULL);
    EntrySize = (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) -
                        sizeof(ULONG) +
                        Device->DeviceString.MaximumLength +
                        AdapterStringSize +
                        sizeof(OidBuffer));

    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
        (PDEVICE_OBJECT)Device,
        EntrySize
    );

    //
    // Convert the OID into a buffer.
    //

    for (i=7; i>=0; i--) {
        CurrentDigit = OidValue & 0xf;
        OidValue >>= 4;
        if (CurrentDigit >= 0xa) {
            OidBuffer[i] = (WCHAR)(CurrentDigit - 0xa + L'A');
        } else {
            OidBuffer[i] = (WCHAR)(CurrentDigit + L'0');
        }
    }

    if (errorLogEntry != NULL) {

        errorLogEntry->MajorFunctionCode = (UCHAR)-1;
        errorLogEntry->RetryCount = (UCHAR)-1;
        errorLogEntry->DumpDataSize = 0;
        errorLogEntry->NumberOfStrings = 3;
        errorLogEntry->StringOffset = sizeof(IO_ERROR_LOG_PACKET) - sizeof(ULONG);
        errorLogEntry->EventCategory = 0;
        errorLogEntry->ErrorCode = ErrorCode;
        errorLogEntry->UniqueErrorValue = 0;
        errorLogEntry->FinalStatus = FinalStatus;
        errorLogEntry->SequenceNumber = (ULONG)-1;
        errorLogEntry->IoControlCode = 0;

        StringLoc = ((PUCHAR)errorLogEntry) + errorLogEntry->StringOffset;
        RtlCopyMemory (StringLoc, Device->DeviceString.Buffer, Device->DeviceString.MaximumLength);
        StringLoc += Device->DeviceString.MaximumLength;

        RtlCopyMemory (StringLoc, OidBuffer, sizeof(OidBuffer));
        StringLoc += sizeof(OidBuffer);

        RtlCopyMemory (StringLoc, AdapterString, AdapterStringSize);

        IoWriteErrorLogEntry(errorLogEntry);

    }

}   /* NbiWriteOidErrorLog */


//----------------------------------------------------------------------------
NTSTATUS
NbiDispatchPnP(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp
    )
{
    PVOID               PDOInfo = NULL;
    PIO_STACK_LOCATION  pIrpSp;
    PREQUEST            Request;
    PCONNECTION         Connection;
    PDEVICE_RELATIONS   pDeviceRelations = NULL;
    PVOID               pnpDeviceContext = NULL;
    PDEVICE             Device = (PDEVICE)DeviceObject;
    NTSTATUS            Status = STATUS_INVALID_DEVICE_REQUEST;

    Request = NbiAllocateRequest (Device, pIrp);
    Connection = (PCONNECTION)REQUEST_OPEN_CONTEXT(Request);    // This references the connection.
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    switch (pIrpSp->MinorFunction)
    {
        case IRP_MN_QUERY_DEVICE_RELATIONS:
        {
            if (pIrpSp->Parameters.QueryDeviceRelations.Type == TargetDeviceRelation)
            {
                //
                // Check for a valid Connection file type and Connection Context itself
                //
                if ((REQUEST_OPEN_TYPE(Request) == (PVOID)TDI_CONNECTION_FILE) &&
                    (NT_SUCCESS (NbiVerifyConnection (Connection))))
                {
                    if (pDeviceRelations = (PDEVICE_RELATIONS) NbipAllocateMemory (sizeof (DEVICE_RELATIONS),
                                                                                  MEMORY_QUERY,
                                                                                  FALSE))
                    {
                        Status = (*Device->Bind.QueryHandler) (IPX_QUERY_DEVICE_RELATION,
                                                               &Connection->LocalTarget.NicHandle,
                                                               &pnpDeviceContext,
                                                               sizeof (PVOID),
                                                               NULL);
                        if (STATUS_SUCCESS == Status)
                        {
                            CTEAssert (pnpDeviceContext);
                            ObReferenceObject (pnpDeviceContext);

                            //
                            // TargetDeviceRelation allows exactly one PDO. fill it up.
                            //
                            pDeviceRelations->Count  =   1;
                            pDeviceRelations->Objects[0] = pnpDeviceContext;

                            //
                            // invoker of this irp will free the information buffer.
                            //
                        }
                        else
                        {
                            NbipFreeMemory (pDeviceRelations, sizeof (DEVICE_RELATIONS), FALSE);
                            pDeviceRelations = NULL;
                        }
                    }
                    else
                    {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }

                    NbiDereferenceConnection (Connection, CREF_VERIFY);
                }
                else if (REQUEST_OPEN_TYPE(Request) == (PVOID)TDI_TRANSPORT_ADDRESS_FILE)
                {
                    Status = STATUS_UNSUCCESSFUL;
                }
            }

            break;
        }

        default:
        {
            break;
        }
    }

    REQUEST_STATUS(Request) = Status;
    REQUEST_INFORMATION(Request) = (ULONG_PTR) pDeviceRelations;

    NbiCompleteRequest (Request);
    NbiFreeRequest (Device, Request);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\nb\nbitypes.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    nbitypes.h

Abstract:

    This module contains definitions specific to the
    Netbios module of the ISN transport.

Author:

    Adam Barr (adamba) 16-November-1993

Environment:

    Kernel mode

Revision History:


--*/


#define MAJOR_TDI_VERSION 2
#define MINOR_TDI_VERSION 0

#define BIND_FIX    1

extern  ULONG   NbiBindState;
#define NBI_BOUND_TO_IPX    0x01
#define IPX_HAS_DEVICES     0x02
#define TDI_HAS_NOTIFIED    0x04

enum eTDI_ACTION
{
    NBI_IPX_REGISTER,
    NBI_IPX_DEREGISTER,
    NBI_TDI_REGISTER,       // Register the Device and Net Address
    NBI_TDI_DEREGISTER      // DeRegister the Net Address and Device respectively
};


//
// For find name requests, defines the current status (SR_FN.Status).
//

typedef enum {
    FNStatusNoResponse,         // no response has been received
    FNStatusResponseUnique,     // response received, is a unique name
    FNStatusResponseGroup       // response received, is a group name
};

//
// Defines the results we can get from sending a series of find
// names to locate a netbios name.
//

typedef enum _NETBIOS_NAME_RESULT {
    NetbiosNameFound,           // name was located
    NetbiosNameNotFoundNormal,  // name not found, no response received
    NetbiosNameNotFoundWanDown  // name not found, all lines were down
} NETBIOS_NAME_RESULT, *PNETBIOS_NAME_RESULT;


//
// Definition of the protocol reserved field of a send packet.
//

typedef struct _NB_SEND_RESERVED {
    UCHAR Identifier;                  // 0 for NB packets
    BOOLEAN SendInProgress;            // used in an NdisSend
    UCHAR Type;                        // what to do on completion
    BOOLEAN OwnedByConnection;         // if this is a connection's one packet
#if     defined(_PNP_POWER)
    PVOID Reserved[SEND_RESERVED_COMMON_SIZE];                 // used by ipx for even-padding and local target etc.
#else
    PVOID Reserved[2];                 // used by ipx for even-padding
#endif  _PNP_POWER
    LIST_ENTRY GlobalLinkage;          // all packets are on this
    SLIST_ENTRY PoolLinkage;           // when on free queue
    LIST_ENTRY WaitLinkage;            // when waiting on other queues
#ifdef NB_TRACK_POOL
    PVOID Pool;                        // send pool it was allocated from
#endif
    union {
      struct {
        UCHAR NetbiosName[16];         // name being searched for
        UCHAR StatusAndSentOnUpLine;   // low nibble: look at FNStatusXXX enum
                                       // high nibble: TRUE if while sending, found lan or up wan line
        UCHAR RetryCount;              // number of times sent
        USHORT SendTime;               // based on Device->FindNameTime
#if      !defined(_PNP_POWER)
        USHORT CurrentNicId;           // current nic id it is being sent on
        USHORT MaximumNicId;           // highest one it will be sent on
#endif  !_PNP_POWER
        struct _NETBIOS_CACHE * NewCache;  // new cache entry for group names
      } SR_FN;
      struct {
        struct _ADDRESS * Address;     // that owns this packet, if one does
        PREQUEST Request;              // send datagram request
        struct _ADDRESS_FILE * AddressFile; // that this send is on
#if      !defined(_PNP_POWER)
        USHORT CurrentNicId;           // non-zero for frames that go to all
#endif  !_PNP_POWER
        UCHAR NameTypeFlag;            // save these two values for frames
        UCHAR DataStreamType;          //  that need to be sent to all nic id's
      } SR_NF;
      struct {
        PREQUEST DatagramRequest;      // holds the passed-in request
        TDI_ADDRESS_NETBIOS * RemoteName;  // will be -1 for broadcast
        struct _ADDRESS_FILE * AddressFile; // that the datagram was sent on
        struct _NETBIOS_CACHE * Cache; // how to route to the netbios address
        ULONG CurrentNetwork;          // within the cache entry
      } SR_DG;
      struct {
        struct _CONNECTION * Connection; // that this frame was sent on.
        PREQUEST Request;                // that this frame was sent for.
        ULONG PacketLength;              // total packet length.
        BOOLEAN NoNdisBuffer;            // none allocate for send
      } SR_CO;
      struct {
        ULONG ActualBufferLength;      // real length of allocated buffer.
      } SR_AS;
    } u;
    PUCHAR Header;                     // points to the MAC/IPX/NB header
    PNDIS_BUFFER HeaderBuffer;         // the NDIS_BUFFER describing Header
    ULONG   CurrentSendIteration;      // Iteration # for Send Completions so that we can avoid stack overflow
} NB_SEND_RESERVED, *PNB_SEND_RESERVED;

//
// Values for Type.
//

#define SEND_TYPE_NAME_FRAME       1
#define SEND_TYPE_SESSION_INIT     2
#define SEND_TYPE_FIND_NAME        3
#define SEND_TYPE_DATAGRAM         4
#define SEND_TYPE_SESSION_NO_DATA  5
#define SEND_TYPE_SESSION_DATA     6
#define SEND_TYPE_STATUS_QUERY     7
#define SEND_TYPE_STATUS_RESPONSE  8

#ifdef RSRC_TIMEOUT_DBG
#define SEND_TYPE_DEATH_PACKET     9
#endif //RSRC_TIMEOUT_DBG

//
// Macros to access StatusAndSentOnUpLine.
//

#define NB_GET_SR_FN_STATUS(_Reserved) \
    ((_Reserved)->u.SR_FN.StatusAndSentOnUpLine & 0x0f)

#define NB_SET_SR_FN_STATUS(_Reserved,_Value) \
    (_Reserved)->u.SR_FN.StatusAndSentOnUpLine = \
        (((_Reserved)->u.SR_FN.StatusAndSentOnUpLine & 0xf0) | (_Value));

#define NB_GET_SR_FN_SENT_ON_UP_LINE(_Reserved) \
    (((_Reserved)->u.SR_FN.StatusAndSentOnUpLine & 0xf0) != 0)

#define NB_SET_SR_FN_SENT_ON_UP_LINE(_Reserved,_Value) \
    (_Reserved)->u.SR_FN.StatusAndSentOnUpLine = (UCHAR) \
        (((_Reserved)->u.SR_FN.StatusAndSentOnUpLine & 0x0f) | ((_Value) << 4));


//
// Definition of the protocol reserved field of a receive packet.
//

typedef struct _NB_RECEIVE_RESERVED {
    UCHAR Identifier;                  // 0 for NB packets
    BOOLEAN TransferInProgress;        // used in an NdisTransferData
    UCHAR Type;                        // what to do on completion
#if      defined(_PNP_POWER)
    PVOID Pool;                        // send pool it was allocated from
#else

#ifdef IPX_TRACK_POOL
    PVOID Pool;                        // send pool it was allocated from
#endif

#endif  _PNP_POWER
    union {
      struct {
        struct _CONNECTION * Connection; // that the transfer is for
        BOOLEAN EndOfMessage;          // this was the last part of a message
        BOOLEAN CompleteReceive;       // receive should be completed
        BOOLEAN NoNdisBuffer;          // user's mdl chain was used
        BOOLEAN PartialReceive;        // (new nb) don't ack this packet
      } RR_CO;
      struct {
        struct _NB_RECEIVE_BUFFER * ReceiveBuffer; // datagram receive buffer
      } RR_DG;
      struct {
        PREQUEST Request;              // for this request
      } RR_AS;
    } u;
    LIST_ENTRY GlobalLinkage;          // all packets are on this
    SLIST_ENTRY PoolLinkage;           // when on free queue
} NB_RECEIVE_RESERVED, *PNB_RECEIVE_RESERVED;

//
// Values for Type.
//

#define RECEIVE_TYPE_DATAGRAM      1
#define RECEIVE_TYPE_DATA          2
#define RECEIVE_TYPE_ADAPTER_STATUS 3



typedef struct _NB_RECEIVE_BUFFER {
    LIST_ENTRY GlobalLinkage;          // all buffers are on this
#if     defined(_PNP_POWER)
    PVOID Pool;                        // receive buffer pool was allocated from
#else
#ifdef NB_TRACK_POOL
    PVOID Pool;                        // receive buffer pool was allocated from
#endif
#endif  _PNP_POWER
    struct _ADDRESS * Address;         // that the datagram is for
    SINGLE_LIST_ENTRY PoolLinkage;     // when in free pool
    LIST_ENTRY WaitLinkage;            // when in ReceiveDatagrams queue
    PNDIS_BUFFER NdisBuffer;           // describes the data
    UCHAR RemoteName[16];              // datagram was received from
    ULONG DataLength;                  // length for current one, not allocated
    PUCHAR Data;                       // points to data to hold packet
} NB_RECEIVE_BUFFER, *PNB_RECEIVE_BUFFER;


#define MAX_SEND_ITERATIONS 3

//
// Types to abstract NDIS packets. This is to allow us to
// switch from using our own memory for packets to using
// authentically allocated NDIS packets.
//

//#define NB_OWN_PACKETS 1

#ifdef NB_OWN_PACKETS

#define NDIS_PACKET_SIZE 48
// #define NDIS_PACKET_SIZE FIELD_OFFSET(NDIS_PACKET,ProtocolReserved[0])

typedef struct _NB_SEND_PACKET {
    UCHAR Data[NDIS_PACKET_SIZE+sizeof(NB_SEND_RESERVED)];
} NB_SEND_PACKET, *PNB_SEND_PACKET;

typedef struct _NB_RECEIVE_PACKET {
    UCHAR Data[NDIS_PACKET_SIZE+sizeof(NB_RECEIVE_RESERVED)];
} NB_RECEIVE_PACKET, *PNB_RECEIVE_PACKET;

typedef struct _NB_SEND_POOL {
    LIST_ENTRY Linkage;
    UINT PacketCount;
    UINT PacketFree;
    NB_SEND_PACKET Packets[1];
    // after the packets the header buffers are allocated also.
} NB_SEND_POOL, *PNB_SEND_POOL;

typedef struct _NB_RECEIVE_POOL {
    LIST_ENTRY Linkage;
    UINT PacketCount;
    UINT PacketFree;
    NB_RECEIVE_PACKET Packets[1];
} NB_RECEIVE_POOL, *PNB_RECEIVE_POOL;

#define PACKET(_Packet) ((PNDIS_PACKET)((_Packet)->Data))

#define NbiAllocateSendPacket(_Device,_PoolHandle, _SendPacket,_Status) { \
    NdisReinitializePacket((PNDIS_PACKET)((_SendPacket)->Data)); \
    *(_Status) = STATUS_SUCCESS; \
}

#define NbiAllocateReceivePacket(_Device,_PoolHandle, _ReceivePacket,_Status) { \
    NdisReinitializePacket((PNDIS_PACKET)((_ReceivePacket)->Data)); \
    *(_Status) = STATUS_SUCCESS; \
}

#define NbiFreeSendPacket(_Device,_Packet)

#define NbiFreeReceivePacket(_Device,_Packet)


#else  // NB_OWN_PACKETS

typedef struct _NB_SEND_PACKET {
    PNDIS_PACKET Packet;
} NB_SEND_PACKET, *PNB_SEND_PACKET;

typedef struct _NB_RECEIVE_PACKET {
    PNDIS_PACKET Packet;
} NB_RECEIVE_PACKET, *PNB_RECEIVE_PACKET;

typedef struct _NB_PACKET_POOL {
    LIST_ENTRY      Linkage;
    UINT            PacketCount;
    UINT            PacketFree;
    NDIS_HANDLE     PoolHandle;
    NB_SEND_PACKET    Packets[1];
    // after the packets the header buffers are allocated also.
} NB_SEND_POOL, *PNB_SEND_POOL;

typedef struct _NB_RECEIVE_POOL {
    LIST_ENTRY Linkage;
    UINT PacketCount;
    UINT PacketFree;
    NDIS_HANDLE     PoolHandle;
    NB_RECEIVE_PACKET Packets[1];
} NB_RECEIVE_POOL, *PNB_RECEIVE_POOL;

#define PACKET(_Packet) ((_Packet)->Packet)

#define NbiAllocateSendPacket(_Device,_PoolHandle, _SendPacket,_Status) { \
        NdisAllocatePacket(_Status, &(_SendPacket)->Packet, _PoolHandle); \
}

#define NbiAllocateReceivePacket(_Device, _PoolHandle, _ReceivePacket,_Status) { \
        NdisAllocatePacket(_Status, &(_ReceivePacket)->Packet, _PoolHandle); \
}

#define NbiFreeSendPacket(_Device,_Packet) { \
    NdisFreePacket(PACKET(_Packet)); \
}

#define NbiFreeReceivePacket(_Device,_Packet) { \
    NdisFreePacket(PACKET(_Packet)); \
}

#endif // NB_OWN_PACKETS

#define SEND_RESERVED(_Packet) ((PNB_SEND_RESERVED)((PACKET(_Packet))->ProtocolReserved))
#define RECEIVE_RESERVED(_Packet) ((PNB_RECEIVE_RESERVED)((PACKET(_Packet))->ProtocolReserved))



typedef struct _NB_RECEIVE_BUFFER_POOL {
    LIST_ENTRY Linkage;
    UINT BufferCount;
    UINT BufferFree;
#if     defined(_PNP_POWER)
    UINT BufferDataSize;                // allocation size of each buffer data
#endif  _PNP_POWER
    NB_RECEIVE_BUFFER Buffers[1];
    // after the packets the data buffers are allocated also.
} NB_RECEIVE_BUFFER_POOL, *PNB_RECEIVE_BUFFER_POOL;


//
// Tags for memory allocation.
//

#define MEMORY_CONFIG     0
#define MEMORY_ADAPTER    1
#define MEMORY_ADDRESS    2
#define MEMORY_PACKET     3
#define MEMORY_CACHE      4
#define MEMORY_CONNECTION 5
#define MEMORY_STATUS     6
#define MEMORY_QUERY      7
#if     defined(_PNP_POWER)
#define MEMORY_WORK_ITEM  8
#define MEMORY_ADAPTER_ADDRESS  9
#endif  _PNP_POWER

#if     defined(_PNP_POWER)
#define MEMORY_MAX        10
#else
#define MEMORY_MAX        8
#endif  _PNP_POWER

#if DBG

//
// Holds the allocations for a specific memory type.
//

typedef struct _MEMORY_TAG {
    ULONG Tag;
    ULONG BytesAllocated;
} MEMORY_TAG, *PMEMORY_TAG;

EXTERNAL_LOCK(NbiMemoryInterlock);
extern MEMORY_TAG NbiMemoryTag[MEMORY_MAX];

#endif



//
// This structure holds a single remote network which a
// Netbios name exists on.
//

typedef struct _NETBIOS_NETWORK {
    ULONG Network;
    IPX_LOCAL_TARGET LocalTarget;
} NETBIOS_NETWORK, *PNETBIOS_NETWORK;

//
// This defines a netbios cache entry for a given name.
//

typedef struct _NETBIOS_CACHE {
    UCHAR NetbiosName[16];
    BOOLEAN Unique;
    BOOLEAN FailedOnDownWan;         // if NetworksUsed == 0, was it due to down wan lines?
    USHORT TimeStamp;                // in seconds - CacheTimeStamp when inserted
    ULONG ReferenceCount;
    LIST_ENTRY Linkage;
    TDI_ADDRESS_IPX FirstResponse;
    USHORT NetworksAllocated;
    USHORT NetworksUsed;
    NETBIOS_NETWORK Networks[1];     // may be more than one of these
} NETBIOS_CACHE, *PNETBIOS_CACHE;

typedef struct  _NETBIOS_CACHE_TABLE {
    USHORT  MaxHashIndex;
    USHORT  CurrentEntries;
    LIST_ENTRY  Bucket[1];
} NETBIOS_CACHE_TABLE, *PNETBIOS_CACHE_TABLE;

#define NB_NETBIOS_CACHE_TABLE_LARGE    26  // for server
#define NB_NETBIOS_CACHE_TABLE_SMALL    8   // for workstation
#define NB_MAX_AVG_CACHE_ENTRIES_PER_BUCKET    8

//
// This defines the different kind of requests that can be made
// to CacheFindName().
//

typedef enum _FIND_NAME_TYPE {
    FindNameConnect,
    FindNameNetbiosFindName,
    FindNameOther
} FIND_NAME_TYPE, *PFIND_NAME_TYPE;


//
// The number of hash entries in the non-inactive connection
// database.
//

#define CONNECTION_HASH_COUNT   8

//
// Mask and shift to retrieve the hash number from a connection
// ID.
//

#define CONNECTION_HASH_MASK   0xe000
#define CONNECTION_HASH_SHIFT  13

//
// The maximum connection ID we can assign, not counting the
// shifted-over hash id (which occupies the top 3 bits of the
// real id we use on the wire). We can use all the bits except
// the top one, to prevent an ID of 0xffff being used.
//

#define CONNECTION_MAXIMUM_ID  (USHORT)(~CONNECTION_HASH_MASK & ~1)

//
// A single connection hash bucket.
//

typedef struct _CONNECTION_HASH {
    struct _CONNECTION * Connections;
    USHORT ConnectionCount;
    USHORT NextConnectionId;
} CONNECTION_HASH, *PCONNECTION_HASH;


//
// These are queued in the ConnectIndicationInProgress
// queue to track indications to TDI clients.
//

typedef struct _CONNECT_INDICATION {
    LIST_ENTRY Linkage;
    UCHAR NetbiosName[16];
    TDI_ADDRESS_IPX RemoteAddress;
    USHORT ConnectionId;
} CONNECT_INDICATION, *PCONNECT_INDICATION;

//
// This structure defines the per-device structure for NB
// (one of these is allocated globally).
//

#define DREF_CREATE       0
#define DREF_LOADED       1
#define DREF_ADAPTER      2
#define DREF_ADDRESS      3
#define DREF_CONNECTION   4
#define DREF_FN_TIMER     5
#define DREF_FIND_NAME    6
#define DREF_SESSION_INIT 7
#define DREF_NAME_FRAME   8
#define DREF_FRAME        9
#define DREF_SHORT_TIMER 10
#define DREF_LONG_TIMER  11
#define DREF_STATUS_QUERY 12
#define DREF_STATUS_RESPONSE 13
#define DREF_STATUS_FRAME 14
#define DREF_NB_FIND_NAME 15

#define DREF_TOTAL       16

typedef struct _DEVICE {

    DEVICE_OBJECT DeviceObject;         // the I/O system's device object.

#if DBG
    ULONG RefTypes[DREF_TOTAL];
#endif

    CSHORT Type;                          // type of this structure
    USHORT Size;                          // size of this structure

#if DBG
    UCHAR Signature1[4];                // contains "IDC1"
#endif

    NB_LOCK Interlock;                  // GLOBAL lock for reference count.
                                        //  (used in ExInterlockedXxx calls)
    NB_LOCK Lock;
    LONG ReferenceCount;                // activity count/this provider.

    //
    // These are kept around for error logging, and stored right
    // after this structure.
    //

    UNICODE_STRING  DeviceString;

    LIST_ENTRY GlobalSendPacketList;
    LIST_ENTRY GlobalReceivePacketList;
    LIST_ENTRY GlobalReceiveBufferList;

    //
    // All send packet pools are chained on this list.
    //

    LIST_ENTRY SendPoolList;
    LIST_ENTRY ReceivePoolList;
    LIST_ENTRY ReceiveBufferPoolList;

    SLIST_HEADER SendPacketList;
    SLIST_HEADER ReceivePacketList;
    SINGLE_LIST_ENTRY ReceiveBufferList;

    //
    // Receive requests waiting to be completed.
    //

    LIST_ENTRY ReceiveCompletionQueue;

    //
    // Connections waiting for send packets.
    //

    LIST_ENTRY WaitPacketConnections;

    //
    // Connections waiting to packetize.
    //

    LIST_ENTRY PacketizeConnections;

    //
    // Connections waiting to send a data ack.
    //

    LIST_ENTRY DataAckConnections;

    //
    // The list changed while we were processing it.
    //

    BOOLEAN DataAckQueueChanged;

    //
    // Information to manage the Netbios name cache.
    //

    LIST_ENTRY WaitingConnects;         // connect requests waiting for a name
    LIST_ENTRY WaitingDatagrams;        // datagram requests waiting for a name
    LIST_ENTRY WaitingAdapterStatus;    // adapter status requests waiting for a name
    LIST_ENTRY WaitingNetbiosFindName;  // netbios find name requests waiting for a name

    //
    // Holds adapter status request which have a name and
    // are waiting for a response. The long timeout aborts
    // these after a couple of expirations (currently we
    // do not do resends).
    //

    LIST_ENTRY ActiveAdapterStatus;

    //
    // Receive datagrams waiting to be indicated.
    //

    LIST_ENTRY ReceiveDatagrams;

    //
    // In-progress connect indications (used to make
    // sure we don't indicate the same packet twice).
    //

    LIST_ENTRY ConnectIndicationInProgress;

    //
    // Listens that have been posted to connections.
    //

    LIST_ENTRY ListenQueue;

    UCHAR State;

    //
    // The following fields control the timer system.
    // The short timer is used for retransmission and
    // delayed acks, and the long timer is used for
    // watchdog timeouts.
    //
    BOOLEAN ShortListActive;            // ShortList is not empty.
    BOOLEAN DataAckActive;              // DataAckConnections is not empty.
    BOOLEAN TimersInitialized;          // has the timer system been initialized.
    BOOLEAN ProcessingShortTimer;       // TRUE if we are in ScanShortTimer.
#if     defined(_PNP_POWER)
    BOOLEAN LongTimerRunning;           // True if the long timer is running.
#endif  _PNP_POWER
    LARGE_INTEGER ShortTimerStart;      // tick count when the short timer was set.
    CTETimer ShortTimer;                // controls the short timer.
    ULONG ShortAbsoluteTime;            // up-count timer ticks, short timer.
    CTETimer LongTimer;                 // kernel DPC object, long timer.
    ULONG LongAbsoluteTime;             // up-count timer ticks, long timer.
    NB_LOCK TimerLock;                  // lock for following timer queues
    LIST_ENTRY ShortList;               // list of waiting connections
    LIST_ENTRY LongList;                // list of waiting connections


    //
    // Hash table of non-inactive connections.
    //

    CONNECTION_HASH ConnectionHash[CONNECTION_HASH_COUNT];

    //
    // Control the queue of waiting find names.
    //

    USHORT FindNameTime;                // incremented each time the timer runs
    BOOLEAN FindNameTimerActive;        // TRUE if the timer is queued
    CTETimer FindNameTimer;             // runs every FIND_NAME_GRANULARITY
    ULONG FindNameTimeout;              // the retry count in timer ticks

    ULONG FindNamePacketCount;          // Count of packets on the queue
    LIST_ENTRY WaitingFindNames;        // FIND_NAME frames waiting to go out

    //
    // The cache of NETBIOS_CACHE entries.
    //

    PNETBIOS_CACHE_TABLE NameCache;

    //
    // The current time stamp, incremented every second.
    //

    USHORT CacheTimeStamp;

    //
    // Maximum valid NIC ID we can use.
    //

    USHORT MaximumNicId;


    //
    // Handle for our binding to the IPX driver.
    //

    HANDLE BindHandle;

    //
    // Holds the output from binding to IPX.
    //
    IPX_INTERNAL_BIND_OUTPUT Bind;
    IPX_INTERNAL_BIND_INPUT  BindInput;

    //
    // Holds our reserved netbios name, which is 10 bytes
    // of zeros followed by our node address.
    //
#if !defined(_PNP_POWER)
    UCHAR ReservedNetbiosName[16];
#endif  !_PNP_POWER

    //
    // This holds the total memory allocated for the above structures.
    //

    LONG MemoryUsage;
    LONG MemoryLimit;

    //
    // How many packets have been allocated.
    //

    ULONG AllocatedSendPackets;
    ULONG AllocatedReceivePackets;
    ULONG AllocatedReceiveBuffers;

#if     defined(_PNP_POWER)
    //
    // This is the size of  each buffer in the receive buffer pool.
    // We reallocate buffer pool when the LineInfo.MaxPacketSize changes(increases)
    // from IPX because of a new adapter. The LineInfo.MaxPacketSize could
    // also change(decrease) when a adapter disappears but our buffer pool size
    // will stay at this value.
    //
    ULONG CurMaxReceiveBufferSize;
#endif  _PNP_POWER

    //
    // Other configuration parameters.
    //

    ULONG AckDelayTime;        // converted to short timeouts, rounded up
    ULONG AckWindow;
    ULONG AckWindowThreshold;
    ULONG EnablePiggyBackAck;
    ULONG Extensions;
    ULONG RcvWindowMax;
    ULONG BroadcastCount;
    ULONG BroadcastTimeout;
    ULONG ConnectionCount;
    ULONG ConnectionTimeout;
    ULONG InitPackets;
    ULONG MaxPackets;
    ULONG InitialRetransmissionTime;
    ULONG Internet;
    ULONG KeepAliveCount;
    ULONG KeepAliveTimeout;
    ULONG RetransmitMax;
    ULONG RouterMtu;

    ULONG MaxReceiveBuffers;


    //
    // Where we tell upper drivers to put their headers.
    //

    ULONG IncludedHeaderOffset;

    //
    // The following field is a head of a list of ADDRESS objects that
    // are defined for this transport provider.  To edit the list, you must
    // hold the spinlock of the device context object.
    //

    LIST_ENTRY AddressDatabase;        // list of defined transport addresses.
#if defined(_PNP_POWER)
    LIST_ENTRY AdapterAddressDatabase; // list of netbios names made from adapter addresses.
#endif _PNP_POWER

    ULONG AddressCount;                // number of addresses in the database.

    NDIS_HANDLE NdisBufferPoolHandle;

#if DBG
    UCHAR Signature2[4];                // contains "IDC2"
#endif

    //
    // This structure holds a pre-built IPX header which is used
    // to quickly fill in common fields of outgoing connectionless
    // frames.
    //

    IPX_HEADER ConnectionlessHeader;

    //
    // This event is used when unloading to signal that
    // the reference count is now 0.
    //

    KEVENT UnloadEvent;
    BOOLEAN UnloadWaiting;

#if     defined(_PNP_POWER)
    HANDLE  TdiRegistrationHandle;
#endif  _PNP_POWER

    //
    // Counters for most of the statistics that NB maintains;
    // some of these are kept elsewhere. Including the structure
    // itself wastes a little space but ensures that the alignment
    // inside the structure is correct.
    //

    TDI_PROVIDER_STATISTICS Statistics;

    //
    // These are "temporary" versions of the other counters.
    // During normal operations we update these, then during
    // the short timer expiration we update the real ones.
    //

    ULONG TempFrameBytesSent;
    ULONG TempFramesSent;
    ULONG TempFrameBytesReceived;
    ULONG TempFramesReceived;


    //
    // This contains the next unique indentified to use as
    // the FsContext in the file object associated with an
    // open of the control channel.
    //

    USHORT ControlChannelIdentifier;

    //
    // Counters for "active" time.
    //

    LARGE_INTEGER NbiStartTime;

    //
    // This array is used to quickly dismiss connectionless frames
    // that are not destined for us. The count is the number
    // of addresses with that first letter that are registered
    // on this device.
    //

    UCHAR AddressCounts[256];

    //
    // This resource guards access to the ShareAccess
    // and SecurityDescriptor fields in addresses.
    //

    ERESOURCE AddressResource;

    //
    // The following structure contains statistics counters for use
    // by TdiQueryInformation and TdiSetInformation.  They should not
    // be used for maintenance of internal data structures.
    //

    TDI_PROVIDER_INFO Information;      // information about this provider.

#ifdef _PNP_POWER_
    HANDLE      NetAddressRegistrationHandle;   // Handle returned from TdiRegisterNetAddress.
#endif  // _PNP_POWER_
#ifdef BIND_FIX
    KEVENT          BindReadyEvent;
#endif  // BIND_FIX
} DEVICE, * PDEVICE;


extern PDEVICE NbiDevice;
EXTERNAL_LOCK(NbiGlobalPoolInterlock);

//
// This is used only for CHK build. For
// tracking the refcount problem on connection, this
// is moved here for now.
//

EXTERNAL_LOCK(NbiGlobalInterlock);


//
// device state definitions
//
#if     defined(_PNP_POWER)
#define DEVICE_STATE_CLOSED   0x00      // Initial state
#define DEVICE_STATE_LOADED   0x01      // Loaded and bound to IPX but no adapters
#define DEVICE_STATE_OPEN     0x02      // Fully operational
#define DEVICE_STATE_STOPPING 0x03      // Unload has been initiated, The I/O system
                                        // will not call us until nobody above has Netbios open.
#else
#define DEVICE_STATE_CLOSED   0x00
#define DEVICE_STATE_OPEN     0x01
#define DEVICE_STATE_STOPPING 0x02
#endif  _PNP_POWER


#define NB_TDI_RESOURCES     9


//
// This structure is pointed to by the FsContext field in the FILE_OBJECT
// for this Address.  This structure is the base for all activities on
// the open file object within the transport provider.  All active connections
// on the address point to this structure, although no queues exist here to do
// work from. This structure also maintains a reference to an ADDRESS
// structure, which describes the address that it is bound to.
//

#define AFREF_CREATE     0
#define AFREF_RCV_DGRAM  1
#define AFREF_SEND_DGRAM 2
#define AFREF_VERIFY     3
#define AFREF_INDICATION 4
#define AFREF_TIMEOUT    5
#define AFREF_CONNECTION 6

#define AFREF_TOTAL      8

typedef struct _ADDRESS_FILE {

#if DBG
    ULONG RefTypes[AFREF_TOTAL];
#endif

    CSHORT Type;
    CSHORT Size;

    LIST_ENTRY Linkage;                 // next address file on this address.
                                        // also used for linkage in the
                                        // look-aside list

    ULONG ReferenceCount;               // number of references to this object.

    //
    // the current state of the address file structure; this is either open or
    // closing
    //

    UCHAR State;

    PNB_LOCK AddressLock;

    //
    // The following fields are kept for housekeeping purposes.
    //

    PREQUEST OpenRequest;              // the request used for open
    struct _ADDRESS *Address;          // address to which we are bound.
#ifdef ISN_NT
    PFILE_OBJECT FileObject;           // easy backlink to file object.
#endif
    struct _DEVICE *Device;            // device to which we are attached.

    LIST_ENTRY ConnectionDatabase;     // associated with this address.

    LIST_ENTRY ReceiveDatagramQueue;   // posted by the client.

    //
    // This holds the request used to close this address file,
    // for pended completion.
    //

    PREQUEST CloseRequest;

    //
    // Handler for kernel event actions. First we have a set of booleans that
    // indicate whether or not this address has an event handler of the given
    // type registered.
    //

    BOOLEAN RegisteredHandler[6];

    //
    // This is a list of handlers for a given event. They can be
    // accessed using the explicit names for type-checking, or the
    // array (indexed by the event type) for speed.
    //

    union {
        struct {
            PTDI_IND_CONNECT ConnectionHandler;
            PTDI_IND_DISCONNECT DisconnectHandler;
            PTDI_IND_ERROR ErrorHandler;
            PTDI_IND_RECEIVE ReceiveHandler;
            PTDI_IND_RECEIVE_DATAGRAM ReceiveDatagramHandler;
            PTDI_IND_RECEIVE_EXPEDITED ExpeditedDataHandler;
        };
        PVOID Handlers[6];
    };

    PVOID HandlerContexts[6];

} ADDRESS_FILE, *PADDRESS_FILE;

#define ADDRESSFILE_STATE_OPENING   0x00    // not yet open for business
#define ADDRESSFILE_STATE_OPEN      0x01    // open for business
#define ADDRESSFILE_STATE_CLOSING   0x02    // closing


//
// This structure defines a NETBIOS name as a character array for use when
// passing preformatted NETBIOS names between internal routines.  It is
// not a part of the external interface to the transport provider.
//

typedef struct _NBI_NETBIOS_ADDRESS {
    UCHAR NetbiosName[16];
    USHORT NetbiosNameType;
    BOOLEAN Broadcast;
} NBI_NETBIOS_ADDRESS, *PNBI_NETBIOS_ADDRESS;

//
// This structure defines an ADDRESS, or active transport address,
// maintained by the transport provider.  It contains all the visible
// components of the address (such as the TSAP and network name components),
// and it also contains other maintenance parts, such as a reference count,
// ACL, and so on. All outstanding connection-oriented and connectionless
// data transfer requests are queued here.
//

#define AREF_ADDRESS_FILE 0
#define AREF_LOOKUP       1
#define AREF_RECEIVE      2
#define AREF_NAME_FRAME   3
#define AREF_TIMER        4
#define AREF_FIND         5

#define AREF_TOTAL        8


typedef struct _ADDRESS {

#if DBG
    ULONG RefTypes[AREF_TOTAL];
#endif

    USHORT Size;
    CSHORT Type;

    LIST_ENTRY Linkage;                 // next address/this device object.
    ULONG ReferenceCount;                // number of references to this object.

    NB_LOCK Lock;

    //
    // The following fields comprise the actual address itself.
    //

    PREQUEST Request;                   // pointer to address creation request.

    UCHAR NameTypeFlag;                 // NB_NAME_UNIQUE or NB_NAME_GROUP

    NBI_NETBIOS_ADDRESS NetbiosAddress; // our netbios name.

    //
    // The following fields are used to maintain state about this address.
    //

    ULONG Flags;                        // attributes of the address.
    ULONG State;                        // current state of the address.
    struct _DEVICE *Device;             // device context to which we are attached.
    PNB_LOCK DeviceLock;

    //
    // The following queues is used to hold send datagrams for this
    // address. Receive datagrams are queued to the address file. Requests are
    // processed in a first-in, first-out manner, so that the very next request
    // to be serviced is always at the head of its respective queue.  These
    // queues are managed by the EXECUTIVE interlocked list management routines.
    // The actual objects which get queued to this structure are request control
    // blocks (RCBs).
    //

    LIST_ENTRY AddressFileDatabase; // list of defined address file objects

    UCHAR SendPacketHeader[NB_MAXIMUM_MAC + sizeof(IPX_HEADER)];

    //
    // This timer is used for registering the name.
    //

    CTETimer RegistrationTimer;

    //
    // Number of times an add name frame has been sent.
    //

    ULONG RegistrationCount;

#ifdef ISN_NT

    //
    // These two can be a union because they are not used
    // concurrently.
    //

    union {

        //
        // This structure is used for checking share access.
        //

        SHARE_ACCESS ShareAccess;

        //
        // Used for delaying NbiDestroyAddress to a thread so
        // we can access the security descriptor.
        //

        WORK_QUEUE_ITEM DestroyAddressQueueItem;

    } u;

    //
    // This structure is used to hold ACLs on the address.

    PSECURITY_DESCRIPTOR SecurityDescriptor;

#endif
} ADDRESS, *PADDRESS;

//
// Values for Flags
//

#define ADDRESS_FLAGS_DUPLICATE_NAME   0x00000002
#if     defined(_PNP_POWER)
#define ADDRESS_FLAGS_CONFLICT         0x00000010
#endif  _PNP_POWER

#if     defined(_PNP_POWER)
//
// this booleans are passed to nbiverifyaddressfile calls.
//
#define CONFLICT_IS_OK      TRUE
#define CONFLICT_IS_NOT_OK  FALSE
#endif  _PNP_POWER

//
// Values for State
//

#define ADDRESS_STATE_REGISTERING      1
#define ADDRESS_STATE_OPEN             2
#define ADDRESS_STATE_STOPPING         3

#if     defined(_PNP_POWER)
//
// This holds the adapters names i.e netbios names which are
// created from adater node address to support adapter status
// queries using adapter node addresses.
//
typedef struct _ADAPTER_ADDRESS {

    USHORT Size;
    CSHORT Type;

    LIST_ENTRY Linkage;                 // next address/this device object.
    NIC_HANDLE  NicHandle;              // NicHandle corresponding to this address.
    UCHAR   NetbiosName[16];
} ADAPTER_ADDRESS, *PADAPTER_ADDRESS;
#endif  _PNP_POWER

//
// This defines the types of probe packets we can send.
//

typedef enum _NB_ACK_TYPE {
    NbiAckQuery,
    NbiAckResponse,
    NbiAckResend
} NB_ACK_TYPE, *PNB_ACK_TYPE;


//
// This defines the a packetizing location in a
// send.
//

typedef struct _SEND_POINTER {
    ULONG MessageOffset;              // up count, bytes sent this message.
    PREQUEST Request;                 // current send request in chain.
    PNDIS_BUFFER Buffer;              // current buffer in send chain.
    ULONG BufferOffset;               // current byte offset in current buffer.
    USHORT SendSequence;
} SEND_POINTER, *PSEND_POINTER;

//
// This defines the current location in a receive.
//

typedef struct _RECEIVE_POINTER {
    ULONG MessageOffset;              // up count, bytes received this message.
    ULONG Offset;                     // up count, bytes received this request.
    PNDIS_BUFFER Buffer;              // current buffer in receive request.
    ULONG BufferOffset;               // current byte offset in current buffer.
} RECEIVE_POINTER, *PRECEIVE_POINTER;


//
// This structure defines a connection, which controls a
// session with a remote.
//

#define CREF_VERIFY     0
#define CREF_LISTEN     1
#define CREF_CONNECT    2
#define CREF_WAIT_CACHE 3
#define CREF_TIMER      4
#define CREF_INDICATE   5
#define CREF_ACTIVE     6
#define CREF_FRAME      7
#define CREF_BY_CONTEXT 8
#define CREF_W_ACCEPT   9
#define CREF_SEND       10
#define CREF_RECEIVE    11
#define CREF_PACKETIZE  12
#define CREF_DISASSOC   13
#define CREF_W_PACKET   14
#define CREF_CANCEL     15
#define CREF_NDIS_SEND  16
#define CREF_SHORT_D_ACK 17
#define CREF_LONG_D_ACK 18
#define CREF_FIND_ROUTE 19
#define CREF_ACCEPT     20

#define CREF_TOTAL      24

typedef struct _CONNECTION {

#if DBG
    ULONG RefTypes[CREF_TOTAL];
#endif

    CSHORT Type;
    USHORT Size;

    NB_LOCK Lock;
    PNB_LOCK DeviceLock;

    ULONG ReferenceCount;                // number of references to this object.

    CONNECTION_CONTEXT Context;          // client-specified value.

    ULONG State;
    ULONG SubState;
    ULONG ReceiveState;                  // SubState tracks sends when active.
    ULONG NewNetbios;                    // 1 if we negotiated this.

    REQUEST_LIST_HEAD SendQueue;
    REQUEST_LIST_HEAD ReceiveQueue;

    USHORT ReceiveSequence;

    USHORT LocalRcvSequenceMax;          // we advertise to him (will be near SendSequence)
    USHORT RemoteRcvSequenceMax;         // he advertises to us (will be near ReceiveSequence)
    USHORT SendWindowSequenceLimit;      // when this send window ends (may send past it however)

    //
    // RemoteRcvSequenceMax is the largest frame number that he expects to
    // receive, while SendWindowSequenceLimit is one more than the max
    // we can send. I.e. if he is advertising a window of 4 and we think
    // the window should be 2, and the current send sequence is 7,
    // RemoteRcvSequenceMax is 10 and SendWindowSequenceLimit is 9.
    //

    USHORT ReceiveWindowSize;            // when it is open, how big to make it
    USHORT SendWindowSize;               // what we'll send, may be less than what he advertises
    USHORT MaxSendWindowSize;            // maximum we allow it to grow to

    USHORT IncreaseWindowFailures;       // how many windows after increase have had retransmits
    BOOLEAN RetransmitThisWindow;        // we had to retransmit in this send window
    BOOLEAN SendWindowIncrease;          // send window was just increased.
    BOOLEAN ResponseTimeout;             // we hit timeout in SEND_W or REMOTE_W

    BOOLEAN SendBufferInUse;             // current send's already queued on packet

    ULONG Retries;

    //
    // Tracks the current send.
    //

    SEND_POINTER CurrentSend;

    //
    // Tracks the unacked point in the send.
    //

    SEND_POINTER UnAckedSend;

    PREQUEST FirstMessageRequest;        // first one in the message.
    PREQUEST LastMessageRequest;         // last one in the message.

    ULONG CurrentMessageLength;          // total length of current message.

    //
    // Tracks the current receive.
    //

    RECEIVE_POINTER CurrentReceive;      // where to receive next data
    RECEIVE_POINTER PreviousReceive;     // stores it while transfer in progress

    PREQUEST ReceiveRequest;             // current one; not in ReceiveQueue
    ULONG ReceiveLength;                 // length of ReceiveRequest

    ULONG ReceiveUnaccepted;             // by client...only indicate when == 0

    ULONG CurrentIndicateOffset;         // if previous frame was partially accepted.

    IPX_LINE_INFO LineInfo;              // for the adapter this connect is on.
    ULONG MaximumPacketSize;             // as negotiated during session init/ack

    //
    // Links us in the non-inactive connection hash bucket.
    //

    struct _CONNECTION * NextConnection;

    //
    // These are used to determine when to piggyback and when not to.
    //

    BOOLEAN NoPiggybackHeuristic;        // we have reason to assume it would be bad.
    BOOLEAN PiggybackAckTimeout;         // we got a timeout last time we tried.
    ULONG ReceivesWithoutAck;            // used to do an auto ack.

    //
    // The following field is used as linkage in the device's
    // PacketizeConnections queue.
    //

    LIST_ENTRY PacketizeLinkage;

    //
    // The following field is used as linkage in the device's
    // WaitPacketConnections queue.
    //

    LIST_ENTRY WaitPacketLinkage;

    //
    // The following field is used as linkage in the device's
    // DataAckConnections queue.
    //

    LIST_ENTRY DataAckLinkage;

    //
    // TRUE if we are on these queues.
    //

    BOOLEAN OnPacketizeQueue;
    BOOLEAN OnWaitPacketQueue;
    BOOLEAN OnDataAckQueue;

    //
    // TRUE if we have a piggyback ack pending.
    //

    BOOLEAN DataAckPending;

    //
    // TRUE if the current receive does not allow piggyback acks.
    //

    BOOLEAN CurrentReceiveNoPiggyback;

    //
    // Number of short timer expirations with the data ack queued.
    //

    ULONG DataAckTimeouts;

    //
    // Used to queue sends so that no two are outstanding at once.
    //

    ULONG NdisSendsInProgress;
    LIST_ENTRY NdisSendQueue;

    //
    // This pointer is valid when NdisSendsInProgress is non-zero;
    // it holds a pointer to a location on the stack of the thread
    // which is inside NbiAssignSequenceAndSend. If this location
    // is set to TRUE, it means the connection was stopped by another
    // thread and a reference was added to keep the connection around.
    //

    PBOOLEAN NdisSendReference;

    //
    // These are used for timeouts.
    //

    ULONG BaseRetransmitTimeout;            // config # of short timeouts we wait.
    ULONG CurrentRetransmitTimeout;         // possibly backed-off number
    ULONG WatchdogTimeout;                  // how many long timeouts we wait.
    ULONG Retransmit;                       // timer; based on Device->ShortAbsoluteTime
    ULONG Watchdog;                         // timer; based on Device->LongAbsoluteTime
    USHORT TickCount;                       // 18.21/second, # for 576-byte packet.
    USHORT HopCount;                        // As returned by ipx on find route.
    BOOLEAN OnShortList;                    // are we inserted in the list
    BOOLEAN OnLongList;                     // are we inserted in the list
    LIST_ENTRY ShortList;                   // queues us on Device->ShortList
    LIST_ENTRY LongList;                    // queues us on Device->LongList

    //
    // These are valid when we have a connection established;
    //

    USHORT LocalConnectionId;
    USHORT RemoteConnectionId;

    PREQUEST DisassociatePending;           // guarded by device lock.
    PREQUEST ClosePending;

    PREQUEST ConnectRequest;
    PREQUEST ListenRequest;
    PREQUEST AcceptRequest;
    PREQUEST DisconnectRequest;
    PREQUEST DisconnectWaitRequest;

    ULONG CanBeDestroyed;                   // FALSE if reference is non-zero
    ULONG  ThreadsInHandleConnectionZero;   // # of threads in HandleConnectionZero

    //
    // These are used to hold extra data that was sent on a session
    // init, for use in sending the ack. Generally will be NULL and 0.
    //

    PUCHAR SessionInitAckData;
    ULONG SessionInitAckDataLength;

    IPX_LOCAL_TARGET LocalTarget;           // for the remote when active.
    IPX_HEADER RemoteHeader;

    CTETimer Timer;

    PADDRESS_FILE AddressFile;              // guarded by device lock if associated.
    LIST_ENTRY AddressFileLinkage;          // guarded by device lock
    ULONG AddressFileLinked;                // TRUE if queued using AddressFileLinkage

    PDEVICE Device;
#ifdef ISN_NT
    PFILE_OBJECT FileObject;                // easy backlink to file object.
#endif

    CHAR RemoteName[16];                // for an active connection.

    IPX_FIND_ROUTE_REQUEST FindRouteRequest; // use this to verify route.

    TDI_CONNECTION_INFO ConnectionInfo; // can be queried from above.

    BOOLEAN FindRouteInProgress;        // we have a request pending.

    BOOLEAN SendPacketInUse;            // put this here to align packet/header.
    BOOLEAN IgnoreNextDosProbe;

    NTSTATUS Status;                    // status code for connection rundown.

#ifdef  RSRC_TIMEOUT_DBG
    LARGE_INTEGER   FirstMessageRequestTime;
#endif  //RSRC_TIMEOUT_DBG

    NDIS_HANDLE    SendPacketPoolHandle; // poolhandle for sendpacket below when
                                         // the packet is allocated from ndis pool.

    NB_SEND_PACKET SendPacket;          // try to use this first for sends

    ULONG Flags;                        // miscellaneous connection flags

    UCHAR SendPacketHeader[1];          // connection is extended to include this

    //
    // NOTE: This is variable length structure!
    // Do not add fields below this comment.
    //
} CONNECTION, *PCONNECTION;


#define CONNECTION_STATE_INACTIVE    1
#define CONNECTION_STATE_CONNECTING  2
#define CONNECTION_STATE_LISTENING   3
#define CONNECTION_STATE_ACTIVE      4
#define CONNECTION_STATE_DISCONNECT  5
#define CONNECTION_STATE_CLOSING     6


#define CONNECTION_SUBSTATE_L_WAITING   1   // queued by a listen
#define CONNECTION_SUBSTATE_L_W_ACCEPT  2   // waiting for user to accept
#define CONNECTION_SUBSTATE_L_W_ROUTE   3   // waiting for rip response

#define CONNECTION_SUBSTATE_C_FIND_NAME 1   // waiting for cache response
#define CONNECTION_SUBSTATE_C_W_ACK     2   // waiting for session init ack
#define CONNECTION_SUBSTATE_C_W_ROUTE   3   // waiting for rip response
#define CONNECTION_SUBSTATE_C_DISCONN   4   // disconnect was issued

#define CONNECTION_SUBSTATE_A_IDLE      1   // no sends in progress
#define CONNECTION_SUBSTATE_A_PACKETIZE 2   // packetizing a send
#define CONNECTION_SUBSTATE_A_W_ACK     3   // waiting for an ack
#define CONNECTION_SUBSTATE_A_W_PACKET  4   // waiting for a packet
#define CONNECTION_SUBSTATE_A_W_EOR     5   // waiting for eor to start packetizing
#define CONNECTION_SUBSTATE_A_W_PROBE   6   // waiting for a keep-alive response
#define CONNECTION_SUBSTATE_A_REMOTE_W  7   // remote shut down our window

#define CONNECTION_RECEIVE_IDLE         1   // no receives queued
#define CONNECTION_RECEIVE_ACTIVE       2   // receive is queued
#define CONNECTION_RECEIVE_W_RCV        3   // waiting for receive to be posted
#define CONNECTION_RECEIVE_INDICATE     4   // indication in progress
#define CONNECTION_RECEIVE_TRANSFER     5   // transfer is in progress
#define CONNECTION_RECEIVE_PENDING      6   // last request is queued for completion

#define CONNECTION_SUBSTATE_D_W_ACK     1
#define CONNECTION_SUBSTATE_D_GOT_ACK   2

//
// Bit values for Flags field in
// the CONNECTION structure.
//
#define CONNECTION_FLAGS_AUTOCONNECTING    0x00000001 // RAS autodial in progress
#define CONNECTION_FLAGS_AUTOCONNECTED     0x00000002 // RAS autodial connected

#ifdef  RSRC_TIMEOUT_DBG
extern ULONG    NbiGlobalDebugResTimeout;
extern LARGE_INTEGER    NbiGlobalMaxResTimeout;
extern NB_SEND_PACKET NbiGlobalDeathPacket;          // try to use this first for sends
#endif  //RSRC_TIMEOUT_DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\nb\precomp.h ===
/*++

Copyright (c) 1993-1995  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Precompilation header file.

Author:

    Adam Barr (adamba) 08-Sep-1993

Revision History:

--*/

#define ISN_NT 1

//
// These are needed for CTE
//

#if DBG
#define DEBUG 1
#endif

#define NT 1

#include <ntosp.h>
#include <zwapi.h>
#include <ndis.h>
#include <tdikrnl.h>
#include <cxport.h>

#include <isnipx.h>
#include <bind.h>
#include "isnnb.h"
#include "config.h"
#include "nbitypes.h"
#include "nbiprocs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\nb\packet.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    packet.c

Abstract:

    This module contains code that implements the SEND_PACKET and
    RECEIVE_PACKET objects, which describe NDIS packets used
    by the transport.

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Local Function Protos
//
#if     defined(_PNP_POWER)
#if !defined(DBG)
__inline
#endif
VOID
NbiFreeReceiveBufferPool (
    IN PNB_RECEIVE_BUFFER_POOL ReceiveBufferPool
    );
#endif  _PNP_POWER


NTSTATUS
NbiInitializeSendPacket(
    IN PDEVICE Device,
    IN NDIS_HANDLE   PoolHandle OPTIONAL,
    IN PNB_SEND_PACKET Packet,
    IN PUCHAR Header,
    IN ULONG HeaderLength
    )

/*++

Routine Description:

    This routine initializes a send packet by chaining the
    buffer for the header on it.

    NOTE: THIS ROUTINE IS CALLED WITH THE DEVICE LOCK HELD,
    AND RETURNS WITH IT HELD.

Arguments:

    Device - The device.

    PoolHandle - Ndis  packet pool handle if !NB_OWN_PACKETS

    Packet - The packet to initialize.

    Header - Points to storage for the header.

    HeaderLength - The length of the header.

Return Value:

    None.

--*/

{

    NDIS_STATUS NdisStatus;
    NTSTATUS Status;
    PNDIS_BUFFER NdisBuffer;
    PNDIS_BUFFER NdisNbBuffer;
    PNB_SEND_RESERVED Reserved;
    ULONG  MacHeaderNeeded = NbiDevice->Bind.MacHeaderNeeded;

    NbiAllocateSendPacket (Device, PoolHandle, Packet, &Status);

    if (Status != STATUS_SUCCESS) {
        // ERROR LOG
        return Status;
    }
//    DbgPrint("NbiInitializeSendPacket: PACKET is (%x)\n", PACKET(Packet));

    //
    // allocate the mac header.
    //
    NdisAllocateBuffer(
        &NdisStatus,
        &NdisBuffer,
        Device->NdisBufferPoolHandle,
        Header,
        MacHeaderNeeded);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        NbiFreeSendPacket (Device, Packet);
        // ERROR LOG
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NdisChainBufferAtFront (PACKET(Packet), NdisBuffer);

//    DbgPrint("NbiInitializeSendPacket: MAC header address is (%x)\n", NdisBuffer);
    //
    // Allocate the nb header
    //
    NdisAllocateBuffer(
        &NdisStatus,
        &NdisNbBuffer,
        Device->NdisBufferPoolHandle,
        Header + MacHeaderNeeded,
        HeaderLength - MacHeaderNeeded);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        NdisBuffer = NULL;
        NdisUnchainBufferAtFront (PACKET(Packet), &NdisBuffer);
        CTEAssert (NdisBuffer);

        if (NdisBuffer)
        {
            NdisAdjustBufferLength (NdisBuffer, MacHeaderNeeded);
            NdisFreeBuffer (NdisBuffer);
        }
        NbiFreeSendPacket (Device, Packet);
        // ERROR LOG
        return STATUS_INSUFFICIENT_RESOURCES;
    }

   // DbgPrint("NbiInitializeSendPacket: IPX header address is (%x)\n", NdisNbBuffer);
    NdisChainBufferAtBack (PACKET(Packet), NdisNbBuffer);

    Reserved = SEND_RESERVED(Packet);
    Reserved->Identifier = IDENTIFIER_NB;
    Reserved->SendInProgress = FALSE;
    Reserved->OwnedByConnection = FALSE;
    Reserved->Header = Header;
    Reserved->HeaderBuffer = NdisBuffer;

    Reserved->Reserved[0] = NULL;
    Reserved->Reserved[1] = NULL;

    InsertHeadList(
        &Device->GlobalSendPacketList,
        &Reserved->GlobalLinkage);

    return STATUS_SUCCESS;

}   /* NbiInitializeSendPacket */


NTSTATUS
NbiInitializeReceivePacket(
    IN PDEVICE Device,
    IN NDIS_HANDLE   PoolHandle OPTIONAL,
    IN PNB_RECEIVE_PACKET Packet
    )

/*++

Routine Description:

    This routine initializes a receive packet.

    NOTE: THIS ROUTINE IS CALLED WITH THE DEVICE LOCK HELD,
    AND RETURNS WITH IT HELD.

Arguments:

    Device - The device.

    PoolHandle - Ndis  packet pool handle if !NB_OWN_PACKETS

    Packet - The packet to initialize.

Return Value:

    None.

--*/

{

    NTSTATUS Status;
    PNB_RECEIVE_RESERVED Reserved;

    NbiAllocateReceivePacket (Device, PoolHandle, Packet, &Status);

    if (Status != STATUS_SUCCESS) {
        // ERROR LOG
        return Status;
    }

    Reserved = RECEIVE_RESERVED(Packet);
    Reserved->Identifier = IDENTIFIER_NB;
    Reserved->TransferInProgress = FALSE;

    InsertHeadList(
        &Device->GlobalReceivePacketList,
        &Reserved->GlobalLinkage);

    return STATUS_SUCCESS;

}   /* NbiInitializeReceivePacket */


NTSTATUS
NbiInitializeReceiveBuffer(
    IN PDEVICE Device,
    IN PNB_RECEIVE_BUFFER ReceiveBuffer,
    IN PUCHAR DataBuffer,
    IN ULONG DataBufferLength
    )

/*++

Routine Description:

    This routine initializes a receive buffer by allocating
    an NDIS_BUFFER to describe the data buffer.

    NOTE: THIS ROUTINE IS CALLED WITH THE DEVICE LOCK HELD,
    AND RETURNS WITH IT HELD.

Arguments:

    Device - The device.

    ReceiveBuffer - The receive buffer to initialize.

    DataBuffer - The data buffer.

    DataBufferLength - The length of the data buffer.

Return Value:

    None.

--*/

{

    NDIS_STATUS NdisStatus;
    PNDIS_BUFFER NdisBuffer;


    NdisAllocateBuffer(
        &NdisStatus,
        &NdisBuffer,
        Device->NdisBufferPoolHandle,
        DataBuffer,
        DataBufferLength);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        // ERROR LOG
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ReceiveBuffer->NdisBuffer = NdisBuffer;
    ReceiveBuffer->Data = DataBuffer;
    ReceiveBuffer->DataLength = 0;

    InsertHeadList(
        &Device->GlobalReceiveBufferList,
        &ReceiveBuffer->GlobalLinkage);

    return STATUS_SUCCESS;

}   /* NbiInitializeReceiveBuffer */



VOID
NbiDeinitializeSendPacket(
    IN PDEVICE Device,
    IN PNB_SEND_PACKET Packet,
    IN ULONG HeaderLength
    )

/*++

Routine Description:

    This routine deinitializes a send packet.

Arguments:

    Device - The device.

    Packet - The packet to deinitialize.

    HeaderLength - The length of the first buffer on the packet.

Return Value:

    None.

--*/

{
    PNDIS_BUFFER NdisBuffer = NULL;
    PNB_SEND_RESERVED Reserved;
    CTELockHandle LockHandle;
    ULONG  MacHeaderNeeded = NbiDevice->Bind.MacHeaderNeeded;

    CTEAssert(HeaderLength > MacHeaderNeeded);
    Reserved = SEND_RESERVED(Packet);

    NB_GET_LOCK (&Device->Lock, &LockHandle);
    RemoveEntryList (&Reserved->GlobalLinkage);
    NB_FREE_LOCK (&Device->Lock, LockHandle);

    //
    // Free the mac header
    //
   // DbgPrint("NbiDeinitializeSendPacket: PACKET is (%x)\n", PACKET(Packet));
    NdisUnchainBufferAtFront (PACKET(Packet), &NdisBuffer);
    CTEAssert (NdisBuffer);
   // DbgPrint("NbiDeinitializeSendPacket: MAC header address is (%x)\n", NdisBuffer);

    if (NdisBuffer)
    {
        NdisAdjustBufferLength (NdisBuffer, MacHeaderNeeded);
        NdisFreeBuffer (NdisBuffer);
    }

    //
    // Free the nb header
    //
    NdisBuffer = NULL;
    NdisUnchainBufferAtFront (PACKET(Packet), &NdisBuffer);
   // DbgPrint("NbiDeinitializeSendPacket: IPX header address is (%x)\n", NdisBuffer);
    CTEAssert (NdisBuffer);

    if (NdisBuffer)
    {
        NdisAdjustBufferLength (NdisBuffer, HeaderLength - MacHeaderNeeded);
        NdisFreeBuffer (NdisBuffer);
    }

    //
    // free the packet
    //
    NbiFreeSendPacket (Device, Packet);

}   /* NbiDeinitializeSendPacket */


VOID
NbiDeinitializeReceivePacket(
    IN PDEVICE Device,
    IN PNB_RECEIVE_PACKET Packet
    )

/*++

Routine Description:

    This routine initializes a receive packet.

Arguments:

    Device - The device.

    Packet - The packet to initialize.

Return Value:

    None.

--*/

{

    PNB_RECEIVE_RESERVED Reserved;
    CTELockHandle LockHandle;

    Reserved = RECEIVE_RESERVED(Packet);

    NB_GET_LOCK (&Device->Lock, &LockHandle);
    RemoveEntryList (&Reserved->GlobalLinkage);
    NB_FREE_LOCK (&Device->Lock, LockHandle);

    NbiFreeReceivePacket (Device, Packet);

}   /* NbiDeinitializeReceivePacket */



VOID
NbiDeinitializeReceiveBuffer(
    IN PDEVICE Device,
    IN PNB_RECEIVE_BUFFER ReceiveBuffer
    )

/*++

Routine Description:

    This routine deinitializes a receive buffer.

Arguments:

    Device - The device.

    ReceiveBuffer - The receive buffer.

Return Value:

    None.

    THIS ROUTINE SHOULD BE CALLED WITH THE DEVICE LOCK HELD. If this
    routine also called from the DestroyDevice routine, it is not
    necessary to call this with the lock.

--*/

{
#if      defined(_PNP_POWER)
    RemoveEntryList (&ReceiveBuffer->GlobalLinkage);
#else
    CTELockHandle LockHandle;

    NB_GET_LOCK (&Device->Lock, &LockHandle);
    RemoveEntryList (&ReceiveBuffer->GlobalLinkage);
    NB_FREE_LOCK (&Device->Lock, LockHandle);
#endif  _PNP_POWER

    NdisFreeBuffer (ReceiveBuffer->NdisBuffer);

}   /* NbiDeinitializeReceiveBuffer */



VOID
NbiAllocateSendPool(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine adds 10 packets to the pool for this device.

    NOTE: THIS ROUTINE IS CALLED WITH THE DEVICE LOCK HELD AND
    RETURNS WITH IT HELD.

Arguments:

    Device - The device.

Return Value:

    None.

--*/

{
    PNB_SEND_POOL SendPool;
    UINT SendPoolSize;
    UINT PacketNum;
    PNB_SEND_PACKET Packet;
    PNB_SEND_RESERVED Reserved;
    PUCHAR Header;
    ULONG HeaderLength;
    NTSTATUS    Status;

    HeaderLength = Device->Bind.MacHeaderNeeded + sizeof(NB_CONNECTIONLESS);
    SendPoolSize = FIELD_OFFSET (NB_SEND_POOL, Packets[0]) +
                       (sizeof(NB_SEND_PACKET) * Device->InitPackets) +
                       (HeaderLength * Device->InitPackets);

    SendPool = (PNB_SEND_POOL)NbiAllocateMemory (SendPoolSize, MEMORY_PACKET, "SendPool");
    if (SendPool == NULL) {
        NB_DEBUG (PACKET, ("Could not allocate send pool memory\n"));
        return;
    }

    RtlZeroMemory (SendPool, SendPoolSize);


#if !defined(NB_OWN_PACKETS)
    //
    // Now allocate the ndis packet pool
    //
    SendPool->PoolHandle = (NDIS_HANDLE) NDIS_PACKET_POOL_TAG_FOR_NWLNKNB;    // Dbg info for Ndis!
    NdisAllocatePacketPoolEx (&Status, &SendPool->PoolHandle, Device->InitPackets, 0, sizeof(NB_SEND_RESERVED));
    if (!NT_SUCCESS(Status)){
        NB_DEBUG (PACKET, ("Could not allocate Ndis Packet Pool memory\n"));
        NbiFreeMemory( SendPool, SendPoolSize, MEMORY_PACKET, "Send Pool Freed");
        return;
    }

    NdisSetPacketPoolProtocolId (SendPool->PoolHandle, NDIS_PROTOCOL_ID_IPX);
#endif

    NB_DEBUG2 (PACKET, ("Initializing send pool %lx, %d packets, header %d\n",
                             SendPool, Device->InitPackets, HeaderLength));

    Header = (PUCHAR)(&SendPool->Packets[Device->InitPackets]);

    for (PacketNum = 0; PacketNum < Device->InitPackets; PacketNum++) {

        Packet = &SendPool->Packets[PacketNum];

        if (NbiInitializeSendPacket (
                Device,
#ifdef  NB_OWN_PACKETS
                NULL,
#else
                SendPool->PoolHandle,
#endif
                Packet,
                Header,
                HeaderLength) != STATUS_SUCCESS) {
            NB_DEBUG (PACKET, ("Could not initialize packet %lx\n", Packet));
            break;
        }

        Reserved = SEND_RESERVED(Packet);
        Reserved->u.SR_NF.Address = NULL;
#ifdef NB_TRACK_POOL
        Reserved->Pool = SendPool;
#endif

        Header += HeaderLength;

    }

    SendPool->PacketCount = PacketNum;
    SendPool->PacketFree = PacketNum;

    for (PacketNum = 0; PacketNum < SendPool->PacketCount; PacketNum++) {

        Packet = &SendPool->Packets[PacketNum];
        Reserved = SEND_RESERVED(Packet);
        ExInterlockedPushEntrySList(
            &Device->SendPacketList,
            &Reserved->PoolLinkage,
            &NbiGlobalPoolInterlock);

    }

    InsertTailList (&Device->SendPoolList, &SendPool->Linkage);

    Device->AllocatedSendPackets += SendPool->PacketCount;

}   /* NbiAllocateSendPool */


VOID
NbiAllocateReceivePool(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine adds 5 receive packets to the pool for this device.

    NOTE: THIS ROUTINE IS CALLED WITH THE DEVICE LOCK HELD AND
    RETURNS WITH IT HELD.

Arguments:

    Device - The device.

Return Value:

    None.

--*/

{
    PNB_RECEIVE_POOL ReceivePool;
    UINT ReceivePoolSize;
    UINT PacketNum;
    PNB_RECEIVE_PACKET Packet;
    PNB_RECEIVE_RESERVED Reserved;
    NTSTATUS    Status;

    ReceivePoolSize = FIELD_OFFSET (NB_RECEIVE_POOL, Packets[0]) +
                         (sizeof(NB_RECEIVE_PACKET) * Device->InitPackets);

    ReceivePool = (PNB_RECEIVE_POOL)NbiAllocateMemory (ReceivePoolSize, MEMORY_PACKET, "ReceivePool");
    if (ReceivePool == NULL) {
        NB_DEBUG (PACKET, ("Could not allocate receive pool memory\n"));
        return;
    }

    RtlZeroMemory (ReceivePool, ReceivePoolSize);

#if !defined(NB_OWN_PACKETS)
    //
    // Now allocate the ndis packet pool
    //
    ReceivePool->PoolHandle = (NDIS_HANDLE) NDIS_PACKET_POOL_TAG_FOR_NWLNKNB;    // Dbg info for Ndis!
    NdisAllocatePacketPoolEx (&Status, &ReceivePool->PoolHandle, Device->InitPackets, 0, sizeof(NB_RECEIVE_RESERVED));
    if (!NT_SUCCESS(Status)){
        NB_DEBUG (PACKET, ("Could not allocate Ndis Packet Pool memory\n"));
        NbiFreeMemory( ReceivePool, ReceivePoolSize, MEMORY_PACKET, "Receive Pool Freed");
        return;
    }

    NdisSetPacketPoolProtocolId (ReceivePool->PoolHandle, NDIS_PROTOCOL_ID_IPX);
#endif NB_OWN_PACKETS

    NB_DEBUG2 (PACKET, ("Initializing receive pool %lx, %d packets\n",
                             ReceivePool, Device->InitPackets));

    for (PacketNum = 0; PacketNum < Device->InitPackets; PacketNum++) {

        Packet = &ReceivePool->Packets[PacketNum];

        if (NbiInitializeReceivePacket (
                Device,
#ifdef  NB_OWN_PACKETS
                NULL,
#else
                ReceivePool->PoolHandle,
#endif
                Packet) != STATUS_SUCCESS) {
            NB_DEBUG (PACKET, ("Could not initialize packet %lx\n", Packet));
            break;
        }

        Reserved = RECEIVE_RESERVED(Packet);
#ifdef NB_TRACK_POOL
        Reserved->Pool = ReceivePool;
#endif

    }

    ReceivePool->PacketCount = PacketNum;
    ReceivePool->PacketFree = PacketNum;

    for (PacketNum = 0; PacketNum < ReceivePool->PacketCount; PacketNum++) {

        Packet = &ReceivePool->Packets[PacketNum];
        Reserved = RECEIVE_RESERVED(Packet);
        ExInterlockedPushEntrySList(
            &Device->ReceivePacketList,
            &Reserved->PoolLinkage,
            &NbiGlobalPoolInterlock);
//        PushEntryList (&Device->ReceivePacketList, &Reserved->PoolLinkage);

    }

    InsertTailList (&Device->ReceivePoolList, &ReceivePool->Linkage);

    Device->AllocatedReceivePackets += ReceivePool->PacketCount;

}   /* NbiAllocateReceivePool */


#if     defined(_PNP_POWER)

VOID
NbiAllocateReceiveBufferPool(
    IN PDEVICE Device,
    IN UINT    DataLength
    )

/*++

Routine Description:

    This routine adds receive buffers to the pool for this device.

    NOTE: THIS ROUTINE IS CALLED WITH THE DEVICE LOCK HELD AND
    RETURNS WITH IT HELD.

Arguments:

    Device - The device.

    DataLength - Max length of the data in each buffer.

Return Value:

    None.

--*/

{
    PNB_RECEIVE_BUFFER ReceiveBuffer;
    UINT ReceiveBufferPoolSize;
    UINT BufferNum;
    PNB_RECEIVE_BUFFER_POOL ReceiveBufferPool;
    PUCHAR Data;


    ReceiveBufferPoolSize = FIELD_OFFSET (NB_RECEIVE_BUFFER_POOL, Buffers[0]) +
                       (sizeof(NB_RECEIVE_BUFFER) * Device->InitPackets) +
                       (DataLength * Device->InitPackets);

    ReceiveBufferPool = (PNB_RECEIVE_BUFFER_POOL)NbiAllocateMemory (ReceiveBufferPoolSize, MEMORY_PACKET, "ReceiveBufferPool");
    if (ReceiveBufferPool == NULL) {
        NB_DEBUG (PACKET, ("Could not allocate receive buffer pool memory\n"));
        return;
    }

    RtlZeroMemory (ReceiveBufferPool, ReceiveBufferPoolSize);

    NB_DEBUG2 (PACKET, ("Initializing receive buffer pool %lx, %d buffers, data %d\n",
                             ReceiveBufferPool, Device->InitPackets, DataLength));

    Data = (PUCHAR)(&ReceiveBufferPool->Buffers[Device->InitPackets]);

    for (BufferNum = 0; BufferNum < Device->InitPackets; BufferNum++) {

        ReceiveBuffer = &ReceiveBufferPool->Buffers[BufferNum];

        if (NbiInitializeReceiveBuffer (Device, ReceiveBuffer, Data, DataLength) != STATUS_SUCCESS) {
            NB_DEBUG (PACKET, ("Could not initialize buffer %lx\n", ReceiveBuffer));
            break;
        }

        ReceiveBuffer->Pool = ReceiveBufferPool;

        Data += DataLength;

    }

    ReceiveBufferPool->BufferCount = BufferNum;
    ReceiveBufferPool->BufferFree = BufferNum;
    ReceiveBufferPool->BufferDataSize = DataLength;

    for (BufferNum = 0; BufferNum < ReceiveBufferPool->BufferCount; BufferNum++) {

        ReceiveBuffer = &ReceiveBufferPool->Buffers[BufferNum];
        PushEntryList (&Device->ReceiveBufferList, &ReceiveBuffer->PoolLinkage);

    }

    InsertTailList (&Device->ReceiveBufferPoolList, &ReceiveBufferPool->Linkage);

    Device->AllocatedReceiveBuffers += ReceiveBufferPool->BufferCount;
    Device->CurMaxReceiveBufferSize =  DataLength;

}   /* NbiAllocateReceiveBufferPool */
#else

VOID
NbiAllocateReceiveBufferPool(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine adds receive buffers to the pool for this device.

    NOTE: THIS ROUTINE IS CALLED WITH THE DEVICE LOCK HELD AND
    RETURNS WITH IT HELD.

Arguments:

    Device - The device.

Return Value:

    None.

--*/

{
    PNB_RECEIVE_BUFFER ReceiveBuffer;
    UINT ReceiveBufferPoolSize;
    UINT BufferNum;
    PNB_RECEIVE_BUFFER_POOL ReceiveBufferPool;
    UINT DataLength;
    PUCHAR Data;

    DataLength = Device->Bind.LineInfo.MaximumPacketSize;

    ReceiveBufferPoolSize = FIELD_OFFSET (NB_RECEIVE_BUFFER_POOL, Buffers[0]) +
                       (sizeof(NB_RECEIVE_BUFFER) * Device->InitPackets) +
                       (DataLength * Device->InitPackets);

    ReceiveBufferPool = (PNB_RECEIVE_BUFFER_POOL)NbiAllocateMemory (ReceiveBufferPoolSize, MEMORY_PACKET, "ReceiveBufferPool");
    if (ReceiveBufferPool == NULL) {
        NB_DEBUG (PACKET, ("Could not allocate receive buffer pool memory\n"));
        return;
    }

    RtlZeroMemory (ReceiveBufferPool, ReceiveBufferPoolSize);

    NB_DEBUG2 (PACKET, ("Initializing receive buffer pool %lx, %d buffers, data %d\n",
                             ReceiveBufferPool, Device->InitPackets, DataLength));

    Data = (PUCHAR)(&ReceiveBufferPool->Buffers[Device->InitPackets]);

    for (BufferNum = 0; BufferNum < Device->InitPackets; BufferNum++) {

        ReceiveBuffer = &ReceiveBufferPool->Buffers[BufferNum];

        if (NbiInitializeReceiveBuffer (Device, ReceiveBuffer, Data, DataLength) != STATUS_SUCCESS) {
            NB_DEBUG (PACKET, ("Could not initialize buffer %lx\n", ReceiveBuffer));
            break;
        }

#ifdef NB_TRACK_POOL
        ReceiveBuffer->Pool = ReceiveBufferPool;
#endif

        Data += DataLength;

    }

    ReceiveBufferPool->BufferCount = BufferNum;
    ReceiveBufferPool->BufferFree = BufferNum;

    for (BufferNum = 0; BufferNum < ReceiveBufferPool->BufferCount; BufferNum++) {

        ReceiveBuffer = &ReceiveBufferPool->Buffers[BufferNum];
        PushEntryList (&Device->ReceiveBufferList, &ReceiveBuffer->PoolLinkage);

    }

    InsertTailList (&Device->ReceiveBufferPoolList, &ReceiveBufferPool->Linkage);

    Device->AllocatedReceiveBuffers += ReceiveBufferPool->BufferCount;

}   /* NbiAllocateReceiveBufferPool */
#endif  _PNP_POWER

#if     defined(_PNP_POWER)

VOID
NbiReAllocateReceiveBufferPool(
    IN PWORK_QUEUE_ITEM    WorkItem
    )

/*++

Routine Description:

    This routines destroys all the existing Buffer Pools and creates
    new one using the larger packet size given to us by IPX because
    a new card was inserted with a larger packet size.

Arguments:

    WorkItem    - The work item that was allocated for this.

Return Value:

    None.

--*/
{
    PDEVICE Device  =   NbiDevice;
    CTELockHandle       LockHandle;

    NB_GET_LOCK ( &Device->Lock, &LockHandle );

    if ( Device->Bind.LineInfo.MaximumPacketSize > Device->CurMaxReceiveBufferSize ) {

#if DBG
        DbgPrint("Reallocating new pools due to new maxpacketsize\n");
#endif
        NbiDestroyReceiveBufferPools( Device );
        NbiAllocateReceiveBufferPool( Device, Device->Bind.LineInfo.MaximumPacketSize );

    }

    NB_FREE_LOCK( &Device->Lock, LockHandle );

    NbiFreeMemory( WorkItem, sizeof(WORK_QUEUE_ITEM), MEMORY_WORK_ITEM, "Alloc Rcv Buff Work Item freed");
}

#if !defined(DBG)
__inline
#endif
VOID
NbiFreeReceiveBufferPool (
    IN PNB_RECEIVE_BUFFER_POOL ReceiveBufferPool
    )

/*++

Routine Description:

    This routine frees the
Arguments:

    Device - Pointer to our device to charge the packet to.

Return Value:

    The pointer to the Linkage field in the allocated packet.

--*/
{
    PDEVICE Device  =   NbiDevice;
    PNB_RECEIVE_BUFFER      ReceiveBuffer;
    UINT                    ReceiveBufferPoolSize,i;

    CTEAssert( ReceiveBufferPool->BufferDataSize );

    ReceiveBufferPoolSize = FIELD_OFFSET (NB_RECEIVE_BUFFER_POOL, Buffers[0]) +
                       (sizeof(NB_RECEIVE_BUFFER) * Device->InitPackets) +
                       (ReceiveBufferPool->BufferDataSize * Device->InitPackets);

    //
    // Check if we can free this pool
    //
    CTEAssert(ReceiveBufferPool->BufferCount == ReceiveBufferPool->BufferFree );

    for (i = 0; i < ReceiveBufferPool->BufferCount; i++) {

        ReceiveBuffer = &ReceiveBufferPool->Buffers[i];
        NbiDeinitializeReceiveBuffer (Device, ReceiveBuffer);

    }

    RemoveEntryList( &ReceiveBufferPool->Linkage );

    NB_DEBUG2 (PACKET, ("Free buffer pool %lx\n", ReceiveBufferPool));

    NbiFreeMemory (ReceiveBufferPool, ReceiveBufferPoolSize, MEMORY_PACKET, "ReceiveBufferPool");

}


VOID
NbiDestroyReceiveBufferPools(
    IN  PDEVICE Device
    )

/*++

Routine Description:

    This routines walks the ReceiveBufferPoolList and destroys the
    pool which does not have any buffer in use.

Arguments:

Return Value:

    None.

    THIS ROUTINE COULD BE CALLED WITH THE DEVICE LOCK HELD. If this
    routine is also called from the DestroyDevice routine, it is not
    necessary to call this with the lock.

--*/
{
    PNB_RECEIVE_BUFFER_POOL ReceiveBufferPool;
    PLIST_ENTRY             p;
    PSINGLE_LIST_ENTRY  Unused;


    //
    // Clean up this list before we call NbiFreeReceiveBufferPool bcoz that will
    // simply destroy all the buffer which might be queue here on this list.
    // At the end of this routine we must start with a fresh ReceiveBufferList.
    //
    do {
        Unused = PopEntryList( &Device->ReceiveBufferList );
    } while( Unused );

    //
    // Now destroy each individual ReceiveBufferPool.
    //
    for ( p = Device->ReceiveBufferPoolList.Flink;
          p != &Device->ReceiveBufferPoolList;
        ) {


        ReceiveBufferPool = CONTAINING_RECORD (p, NB_RECEIVE_BUFFER_POOL, Linkage);
        p   =   p->Flink;

        //
        // This will destroy and unlink this Pool if none of its buffer is
        // in use currently.
        //

        if ( ReceiveBufferPool->BufferCount == ReceiveBufferPool->BufferFree ) {
            NbiFreeReceiveBufferPool( ReceiveBufferPool );
        } else {
            //
            // When the device is stopping we must succeed in freeing the pool.
            CTEAssert( Device->State != DEVICE_STATE_STOPPING );
        }

    }

}


VOID
NbiPushReceiveBuffer (
    IN PNB_RECEIVE_BUFFER ReceiveBuffer
    )

/*++

Routine Description:

    This routine returns the receive buffer back to the free list.
    It checks the size of this buffer. If it is smaller than the
    the CurMaxReceiveBufferSize, then it does not return this back
    to the free list, instead it destroys it and possibly also
    destroys the pool associated with it. O/w it simply returns this
    to the free list.

Arguments:

    ReceiveBuffer - Pointer to the buffer to be returned to the free list.

Return Value:

    The pointer to the Linkage field in the allocated packet.

--*/

{

    PNB_RECEIVE_BUFFER_POOL ReceiveBufferPool = (PNB_RECEIVE_BUFFER_POOL)ReceiveBuffer->Pool;
    PDEVICE                  Device            = NbiDevice;
    CTELockHandle           LockHandle;
#if defined(DBG)
    ULONG                   BufLen = 0;
#endif

    NB_GET_LOCK( &Device->Lock, &LockHandle );

#if defined(DBG)
    NdisQueryBufferSafe (ReceiveBuffer->NdisBuffer, NULL, &BufLen, HighPagePriority);
    CTEAssert( BufLen == ReceiveBufferPool->BufferDataSize );
#endif

    //
    // This is an old buffer which was in use when we changed
    // the CurMaxReceiveBufferSize due to new adapter. We must not
    // return this buffer back to free list. Infact, if the pool
    // associated with this buffer does not have any other buffers
    // in use, we should free the pool also.
    CTEAssert( ReceiveBufferPool->BufferFree < ReceiveBufferPool->BufferCount  );
    ReceiveBufferPool->BufferFree++;

    if ( ReceiveBufferPool->BufferDataSize < Device->CurMaxReceiveBufferSize ) {

#if DBG
        DbgPrint("ReceiveBuffer %lx, not returned to pool %lx( Free %d)\n", ReceiveBuffer, ReceiveBufferPool, ReceiveBufferPool->BufferFree);
#endif


        if ( ReceiveBufferPool->BufferFree == ReceiveBufferPool->BufferCount ) {
            NbiFreeReceiveBufferPool( ReceiveBufferPool );
        }
    } else {

        PushEntryList( &Device->ReceiveBufferList, &ReceiveBuffer->PoolLinkage );


    }

    NB_FREE_LOCK( &Device->Lock, LockHandle );
}
#endif  _PNP_POWER


PSLIST_ENTRY
NbiPopSendPacket(
    IN PDEVICE Device,
    IN BOOLEAN LockAcquired
    )

/*++

Routine Description:

    This routine allocates a packet from the device context's pool.
    If there are no packets in the pool, it allocates one up to
    the configured limit.

Arguments:

    Device - Pointer to our device to charge the packet to.

    LockAcquired - TRUE if Device->Lock is acquired.

Return Value:

    The pointer to the Linkage field in the allocated packet.

--*/

{
    PSLIST_ENTRY s;
    CTELockHandle LockHandle;

    s = ExInterlockedPopEntrySList(
            &Device->SendPacketList,
            &NbiGlobalPoolInterlock);

    if (s != NULL) {
        return s;
    }

    //
    // No packets in the pool, see if we can allocate more.
    //

    if (!LockAcquired) {
        NB_GET_LOCK (&Device->Lock, &LockHandle);
    }

    if (Device->AllocatedSendPackets < Device->MaxPackets) {

        //
        // Allocate a pool and try again.
        //


        NbiAllocateSendPool (Device);


        if (!LockAcquired) {
            NB_FREE_LOCK (&Device->Lock, LockHandle);
        }

        s = ExInterlockedPopEntrySList(
                &Device->SendPacketList,
                &NbiGlobalPoolInterlock);

        return s;
    } else {

        if (!LockAcquired) {
            NB_FREE_LOCK (&Device->Lock, LockHandle);
        }
        return NULL;
    }

}   /* NbiPopSendPacket */


VOID
NbiPushSendPacket(
    IN PNB_SEND_RESERVED Reserved
    )

/*++

Routine Description:

    This routine frees a packet back to the device context's pool.
    If there are connections waiting for packets, it removes
    one from the list and inserts it on the packetize queue.

Arguments:

    Device - Pointer to our device to charge the packet to.

Return Value:

    The pointer to the Linkage field in the allocated packet.

--*/

{
    PDEVICE Device = NbiDevice;
    PLIST_ENTRY p;
    PCONNECTION Connection;
    NB_DEFINE_LOCK_HANDLE (LockHandle)
    NB_DEFINE_LOCK_HANDLE (LockHandle1)

    Reserved->CurrentSendIteration = 0; // Re-initialize this field for next Send Request

    ExInterlockedPushEntrySList(
        &Device->SendPacketList,
        &Reserved->PoolLinkage,
        &NbiGlobalPoolInterlock);

    if (!IsListEmpty (&Device->WaitPacketConnections)) {

        NB_SYNC_GET_LOCK (&Device->Lock, &LockHandle);

        p = RemoveHeadList (&Device->WaitPacketConnections);

        //
        // Take a connection off the WaitPacketQueue and put it
        // on the PacketizeQueue. We don't worry about if the
        // connection has stopped, that will get checked when
        // the PacketizeQueue is run down.
        //
        // Since this is in send completion, we may not get
        // a receive complete. We guard against this by calling
        // NbiReceiveComplete from the long timer timeout.
        //

        if (p != &Device->WaitPacketConnections) {

            Connection = CONTAINING_RECORD (p, CONNECTION, WaitPacketLinkage);

            CTEAssert (Connection->OnWaitPacketQueue);
            Connection->OnWaitPacketQueue = FALSE;

            NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);

            NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle1);


            if (Connection->SubState == CONNECTION_SUBSTATE_A_W_PACKET) {

                CTEAssert (!Connection->OnPacketizeQueue);
                Connection->OnPacketizeQueue = TRUE;

                NbiTransferReferenceConnection (Connection, CREF_W_PACKET, CREF_PACKETIZE);

                NB_INSERT_TAIL_LIST(
                    &Device->PacketizeConnections,
                    &Connection->PacketizeLinkage,
                    &Device->Lock);

                Connection->SubState = CONNECTION_SUBSTATE_A_PACKETIZE;

            } else {

                NbiDereferenceConnection (Connection, CREF_W_PACKET);

            }

            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle1);

        } else {

            NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);

        }

    }

}   /* NbiPushSendPacket */


VOID
NbiCheckForWaitPacket(
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This routine checks if a connection is on the wait packet
    queue and if so takes it off and queues it to be packetized.
    It is meant to be called when the connection's packet has
    been freed.

Arguments:

    Connection - The connection to check.

Return Value:

    The pointer to the Linkage field in the allocated packet.

--*/

{
    PDEVICE Device = NbiDevice;
    NB_DEFINE_LOCK_HANDLE (LockHandle)
    NB_DEFINE_LOCK_HANDLE (LockHandle1)

    NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);
    NB_SYNC_GET_LOCK (&Device->Lock, &LockHandle1);

    if (Connection->OnWaitPacketQueue) {

        Connection->OnWaitPacketQueue = FALSE;
        RemoveEntryList (&Connection->WaitPacketLinkage);

        if (Connection->SubState == CONNECTION_SUBSTATE_A_W_PACKET) {

            CTEAssert (!Connection->OnPacketizeQueue);
            Connection->OnPacketizeQueue = TRUE;

            NbiTransferReferenceConnection (Connection, CREF_W_PACKET, CREF_PACKETIZE);

            InsertTailList(
                &Device->PacketizeConnections,
                &Connection->PacketizeLinkage);
            Connection->SubState = CONNECTION_SUBSTATE_A_PACKETIZE;

        } else {

            NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle1);
            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

            NbiDereferenceConnection (Connection, CREF_W_PACKET);

            return;
        }
    }

    NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle1);
    NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

}   /* NbiCheckForWaitPacket */


PSLIST_ENTRY
NbiPopReceivePacket(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine allocates a packet from the device context's pool.
    If there are no packets in the pool, it allocates one up to
    the configured limit.

Arguments:

    Device - Pointer to our device to charge the packet to.

Return Value:

    The pointer to the Linkage field in the allocated packet.

--*/

{
    PSLIST_ENTRY s;
    CTELockHandle LockHandle;

    s = ExInterlockedPopEntrySList(
            &Device->ReceivePacketList,
            &NbiGlobalPoolInterlock);

    if (s != NULL) {
        return s;
    }

    //
    // No packets in the pool, see if we can allocate more.
    //

    if (Device->AllocatedReceivePackets < Device->MaxPackets) {

        //
        // Allocate a pool and try again.
        //

        NB_GET_LOCK (&Device->Lock, &LockHandle);

        NbiAllocateReceivePool (Device);
        NB_FREE_LOCK (&Device->Lock, LockHandle);
        s = ExInterlockedPopEntrySList(
                &Device->ReceivePacketList,
                &NbiGlobalPoolInterlock);


        return s;

    } else {

        return NULL;

    }

}   /* NbiPopReceivePacket */


PSINGLE_LIST_ENTRY
NbiPopReceiveBuffer(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine allocates a receive buffer from the device context's pool.
    If there are no buffers in the pool, it allocates one up to
    the configured limit.

Arguments:

    Device - Pointer to our device to charge the buffer to.

Return Value:

    The pointer to the Linkage field in the allocated receive buffer.

--*/

{
#if     defined(_PNP_POWER)
    PSINGLE_LIST_ENTRY      s;
    PNB_RECEIVE_BUFFER      ReceiveBuffer;
    PNB_RECEIVE_BUFFER_POOL ReceiveBufferPool;
    CTELockHandle           LockHandle;

    NB_GET_LOCK( &Device->Lock, &LockHandle );

    s = PopEntryList( &Device->ReceiveBufferList );


    if ( !s ) {

        //
        // No buffer in the pool, see if we can allocate more.
        //
        if (Device->AllocatedReceiveBuffers < Device->MaxReceiveBuffers) {

            //
            // Allocate a pool and try again.
            //


            NbiAllocateReceiveBufferPool (Device, Device->CurMaxReceiveBufferSize );
            s = PopEntryList(&Device->ReceiveBufferList);
        }
    }

    if ( s ) {


        //
        // Decrement the BufferFree count on the corresponding ReceiveBufferPool.
        // so that we know that
        ReceiveBuffer     =   CONTAINING_RECORD( s, NB_RECEIVE_BUFFER, PoolLinkage );


        ReceiveBufferPool =  (PNB_RECEIVE_BUFFER_POOL)ReceiveBuffer->Pool;

        CTEAssert( ReceiveBufferPool->BufferFree && ( ReceiveBufferPool->BufferFree <= ReceiveBufferPool->BufferCount ) );
        CTEAssert( ReceiveBufferPool->BufferDataSize == Device->CurMaxReceiveBufferSize );

        ReceiveBufferPool->BufferFree--;

    }
    NB_FREE_LOCK (&Device->Lock, LockHandle);

    return s;
#else
    PSINGLE_LIST_ENTRY s;
    CTELockHandle LockHandle;

    s = ExInterlockedPopEntryList(
            &Device->ReceiveBufferList,
            &Device->Lock.Lock);

    if (s != NULL) {
        return s;
    }

    //
    // No buffer in the pool, see if we can allocate more.
    //

    if (Device->AllocatedReceiveBuffers < Device->MaxReceiveBuffers) {

        //
        // Allocate a pool and try again.
        //

        NB_GET_LOCK (&Device->Lock, &LockHandle);

        NbiAllocateReceiveBufferPool (Device);
        s = PopEntryList(&Device->ReceiveBufferList);

        NB_FREE_LOCK (&Device->Lock, LockHandle);

        return s;

    } else {

        return NULL;

    }
#endif  _PNP_POWER
}   /* NbiPopReceiveBuffer */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\nb\receive.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    receive.c

Abstract:

    This module contains the code to handle receive indication
    and posted receives for the Netbios module of the ISN transport.

Author:

    Adam Barr (adamba) 22-November-1993

Environment:

    Kernel mode

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop


//
// This routine is a no-op to put in the NbiCallbacks table so
// we can avoid checking for runt session frames (this is because
// of how the if is structure below).
//

VOID
NbiProcessSessionRunt(
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR PacketBuffer,
    IN UINT PacketSize
    )
{
    return;
}

NB_CALLBACK_NO_TRANSFER NbiCallbacksNoTransfer[] = {
    NbiProcessFindName,
    NbiProcessNameRecognized,
    NbiProcessAddName,
    NbiProcessAddName,      // processes name in use frames also
    NbiProcessDeleteName,
    NbiProcessSessionRunt,  // in case get a short session packet
    NbiProcessSessionEnd,
    NbiProcessSessionEndAck,
    NbiProcessStatusQuery
    };

#ifdef  RSRC_TIMEOUT_DBG
VOID
NbiProcessDeathPacket(
    IN NDIS_HANDLE MacBindingHandle,
    IN NDIS_HANDLE MacReceiveContext,
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR LookaheadBuffer,
    IN UINT LookaheadBufferSize,
    IN UINT LookaheadBufferOffset,
    IN UINT PacketSize
    )

/*++

Routine Description:

    This routine handles NB_CMD_SESSION_DATA frames.

Arguments:

    MacBindingHandle - A handle to use when calling NdisTransferData.

    MacReceiveContext - A context to use when calling NdisTransferData.

    RemoteAddress - The local target this packet was received from.

    MacOptions - The MAC options for the underlying NDIS binding.

    LookaheadBuffer - The lookahead buffer, starting at the IPX
        header.

    LookaheadBufferSize - The length of the lookahead data.

    LookaheadBufferOffset - The offset to add when calling
        NdisTransferData.

    PacketSize - The total length of the packet, starting at the
        IPX header.

Return Value:

    None.

--*/

{
    NB_CONNECTION UNALIGNED * Conn = (NB_CONNECTION UNALIGNED *)LookaheadBuffer;
    NB_SESSION UNALIGNED * Sess = (NB_SESSION UNALIGNED *)(&Conn->Session);
    PCONNECTION Connection;
    PDEVICE Device = NbiDevice;
    ULONG Hash;
    NB_DEFINE_LOCK_HANDLE (LockHandle)


    DbgPrint("******Received death packet - connid %x\n",Sess->DestConnectionId);

    if ( !NbiGlobalDebugResTimeout ) {
        return;
    }

    if (Sess->DestConnectionId != 0xffff) {

        //
        // This is an active connection, find it using
        // our session id.
        //

        Hash = (Sess->DestConnectionId & CONNECTION_HASH_MASK) >> CONNECTION_HASH_SHIFT;

        NB_SYNC_GET_LOCK (&Device->Lock, &LockHandle);

        Connection = Device->ConnectionHash[Hash].Connections;

        while (Connection != NULL) {

            if (Connection->LocalConnectionId == Sess->DestConnectionId) {
                break;
            }
            Connection = Connection->NextConnection;
        }

        if (Connection == NULL) {
            DbgPrint("********No Connection found with %x id\n",Sess->DestConnectionId);
            NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);
            return;
        }

        DbgPrint("******Received death packet on conn %lx from <%.16s>\n",Connection,Connection->RemoteName);
        DbgBreakPoint();
        NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);

    }
}
#endif  //RSRC_TIMEOUT_DBG


BOOLEAN
NbiReceive(
    IN NDIS_HANDLE MacBindingHandle,
    IN NDIS_HANDLE MacReceiveContext,
    IN ULONG_PTR FwdAdapterCtx,
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR LookaheadBuffer,
    IN UINT LookaheadBufferSize,
    IN UINT LookaheadBufferOffset,
    IN UINT PacketSize,
    IN PMDL pMdl
    )

/*++

Routine Description:

    This routine handles receive indications from IPX.

Arguments:

    MacBindingHandle - A handle to use when calling NdisTransferData.

    MacReceiveContext - A context to use when calling NdisTransferData.

    RemoteAddress - The local target this packet was received from.

    MacOptions - The MAC options for the underlying NDIS binding.

    LookaheadBuffer - The lookahead buffer, starting at the IPX
        header.

    LookaheadBufferSize - The length of the lookahead data.

    LookaheadBufferOffset - The offset to add when calling
        NdisTransferData.

    PacketSize - The total length of the packet, starting at the
        IPX header.

Return Value:

    TRUE - receivepacket taken, will return later with NdisReturnPacket.
    Currently, we always return FALSE.

--*/

{
    PNB_FRAME NbFrame = (PNB_FRAME)LookaheadBuffer;
    UCHAR DataStreamType;

    //
    // We know that this is a frame with a valid IPX header
    // because IPX would not give it to use otherwise. However,
    // it does not check the source socket.
    //

    if (NbFrame->Connectionless.IpxHeader.SourceSocket != NB_SOCKET) {
        return FALSE;
    }

    ++NbiDevice->Statistics.PacketsReceived;

    // First assume that the DataStreamType is at the normal place i.e 2nd byte
    //

    // Now see if this is a name frame.
    //
    if ( PacketSize == sizeof(IPX_HEADER) + sizeof(NB_NAME_FRAME) ) {
        // In the internet mode, the DataStreamType2 becomes DataStreamType
        if (NbFrame->Connectionless.IpxHeader.PacketType == 0x14 ) {
            DataStreamType = NbFrame->Connectionless.NameFrame.DataStreamType2;
        } else {
            DataStreamType = NbFrame->Connectionless.NameFrame.DataStreamType;
        }

        // Is this a name frame?
        // NB_CMD_FIND_NAME = 1 .... NB_CMD_DELETE_NAME = 5
        //
        if ((DataStreamType >= NB_CMD_FIND_NAME) && (DataStreamType <= NB_CMD_DELETE_NAME)) {
            if (LookaheadBufferSize == PacketSize) {
                (*NbiCallbacksNoTransfer[DataStreamType-1])(
                    RemoteAddress,
                    MacOptions,
                    LookaheadBuffer,
                    LookaheadBufferSize);
            }
            return FALSE;
        }

    }

#ifdef  RSRC_TIMEOUT_DBG
    if ((PacketSize >= sizeof(NB_CONNECTION)) &&
        (NbFrame->Connection.Session.DataStreamType == NB_CMD_DEATH_PACKET)) {

        NbiProcessDeathPacket(
            MacBindingHandle,
            MacReceiveContext,
            RemoteAddress,
            MacOptions,
            LookaheadBuffer,
            LookaheadBufferSize,
            LookaheadBufferOffset,
            PacketSize);
    }
#endif  //RSRC_TIMEOUT_DBG

    if ((PacketSize >= sizeof(NB_CONNECTION)) &&
        (NbFrame->Connection.Session.DataStreamType == NB_CMD_SESSION_DATA)) {

        NbiProcessSessionData(
            MacBindingHandle,
            MacReceiveContext,
            RemoteAddress,
            MacOptions,
            LookaheadBuffer,
            LookaheadBufferSize,
            LookaheadBufferOffset,
            PacketSize);

    } else {

        DataStreamType = NbFrame->Connectionless.NameFrame.DataStreamType;
        // Handle NB_CMD_SESSION_END = 7 ... NB_CMD_STATUS_QUERY = 9
        //
        if ((DataStreamType >= NB_CMD_SESSION_END ) && (DataStreamType <= NB_CMD_STATUS_QUERY)) {
            if (LookaheadBufferSize == PacketSize) {
                (*NbiCallbacksNoTransfer[DataStreamType-1])(
                    RemoteAddress,
                    MacOptions,
                    LookaheadBuffer,
                    LookaheadBufferSize);
            }

        } else if (DataStreamType == NB_CMD_STATUS_RESPONSE) {

            NbiProcessStatusResponse(
                MacBindingHandle,
                MacReceiveContext,
                RemoteAddress,
                MacOptions,
                LookaheadBuffer,
                LookaheadBufferSize,
                LookaheadBufferOffset,
                PacketSize);

        } else if ((DataStreamType == NB_CMD_DATAGRAM) ||
                   (DataStreamType == NB_CMD_BROADCAST_DATAGRAM)) {

            NbiProcessDatagram(
                MacBindingHandle,
                MacReceiveContext,
                RemoteAddress,
                MacOptions,
                LookaheadBuffer,
                LookaheadBufferSize,
                LookaheadBufferOffset,
                PacketSize,
                (BOOLEAN)(DataStreamType == NB_CMD_BROADCAST_DATAGRAM));

        }

    }

    return  FALSE;
}   /* NbiReceive */


VOID
NbiReceiveComplete(
    IN USHORT NicId
    )

/*++

Routine Description:

    This routine handles receive complete indications from IPX.

Arguments:

    NicId - The NIC ID on which a receive was previously indicated.

Return Value:

    None.

--*/

{

    PLIST_ENTRY p;
    PADDRESS Address;
    PREQUEST Request;
    PNB_RECEIVE_BUFFER ReceiveBuffer;
    PDEVICE Device = NbiDevice;
    LIST_ENTRY LocalList;
    PCONNECTION Connection;
    NB_DEFINE_LOCK_HANDLE (LockHandle);


    //
    // Complete any pending receive requests.
    //


    if (!IsListEmpty (&Device->ReceiveCompletionQueue)) {

        p = NB_REMOVE_HEAD_LIST(
                &Device->ReceiveCompletionQueue,
                &Device->Lock);

        while (!NB_LIST_WAS_EMPTY(&Device->ReceiveCompletionQueue, p)) {

            Request = LIST_ENTRY_TO_REQUEST (p);

            Connection = (PCONNECTION)REQUEST_OPEN_CONTEXT(Request);

            NB_DEBUG2 (RECEIVE, ("Completing receive %lx (%d), status %lx\n",
                    Request, REQUEST_INFORMATION(Request), REQUEST_STATUS(Request)));

            NbiCompleteRequest (Request);
            NbiFreeRequest (NbiDevice, Request);

            Connection->ReceiveState = CONNECTION_RECEIVE_IDLE;

            NbiDereferenceConnection (Connection, CREF_RECEIVE);

            p = NB_REMOVE_HEAD_LIST(
                    &Device->ReceiveCompletionQueue,
                    &Device->Lock);

        }

    }


    //
    // Indicate any datagrams to clients.
    //

    if (!IsListEmpty (&Device->ReceiveDatagrams)) {

        p = NB_REMOVE_HEAD_LIST(
                &Device->ReceiveDatagrams,
                &Device->Lock);

        while (!NB_LIST_WAS_EMPTY(&Device->ReceiveDatagrams, p)) {

            ReceiveBuffer = CONTAINING_RECORD (p, NB_RECEIVE_BUFFER, WaitLinkage);
            Address = ReceiveBuffer->Address;

            NbiIndicateDatagram(
                Address,
                ReceiveBuffer->RemoteName,
                ReceiveBuffer->Data,
                ReceiveBuffer->DataLength);

#if     defined(_PNP_POWER)
            NbiPushReceiveBuffer ( ReceiveBuffer );
#else
            NB_PUSH_ENTRY_LIST(
                &Device->ReceiveBufferList,
                &ReceiveBuffer->PoolLinkage,
                &Device->Lock);
#endif  _PNP_POWER

            NbiDereferenceAddress (Address, AREF_FIND);

            p = NB_REMOVE_HEAD_LIST(
                    &Device->ReceiveDatagrams,
                    &Device->Lock);

        }
    }


    //
    // Start packetizing connections.
    //

    if (!IsListEmpty (&Device->PacketizeConnections)) {

        NB_SYNC_GET_LOCK (&Device->Lock, &LockHandle);

        //
        // Check again because it may just have become
        // empty, and the code below depends on it being
        // non-empty.
        //

        if (!IsListEmpty (&Device->PacketizeConnections)) {

            //
            // We copy the list locally, in case someone gets
            // put back on it. We have to hack the end so
            // it points to LocalList instead of PacketizeConnections.
            //

            LocalList = Device->PacketizeConnections;
            LocalList.Flink->Blink = &LocalList;
            LocalList.Blink->Flink = &LocalList;

            InitializeListHead (&Device->PacketizeConnections);

            //
            // Set all these connections to not be on the list, so
            // NbiStopConnection won't try to take them off.
            //

            for (p = LocalList.Flink; p != &LocalList; p = p->Flink) {
                Connection = CONTAINING_RECORD (p, CONNECTION, PacketizeLinkage);
                CTEAssert (Connection->OnPacketizeQueue);
                Connection->OnPacketizeQueue = FALSE;
            }

            NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);

            while (TRUE) {

                p = RemoveHeadList (&LocalList);
                if (p == &LocalList) {
                    break;
                }

                Connection = CONTAINING_RECORD (p, CONNECTION, PacketizeLinkage);
                NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);

                if ((Connection->State == CONNECTION_STATE_ACTIVE) &&
                    (Connection->SubState == CONNECTION_SUBSTATE_A_PACKETIZE)) {

                    NbiPacketizeSend(
                        Connection
                        NB_LOCK_HANDLE_ARG (LockHandle)
                        );

                } else {

                    NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

                }

                NbiDereferenceConnection (Connection, CREF_PACKETIZE);

            }

        } else {

            NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);
        }
    }

}   /* NbiReceiveComplete */


VOID
NbiTransferDataComplete(
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS Status,
    IN UINT BytesTransferred
    )

/*++

Routine Description:

    This routine handles a transfer data complete indication from
    IPX, indicating that a previously issued NdisTransferData
    call has completed.

Arguments:

    Packet - The packet associated with the transfer.

    Status - The status of the transfer.

    BytesTransferred - The number of bytes transferred.

Return Value:

    None.

--*/

{
    PNB_RECEIVE_RESERVED ReceiveReserved;
    PNB_RECEIVE_BUFFER ReceiveBuffer;
    PADDRESS Address;
    PCONNECTION Connection;
    PNDIS_BUFFER CurBuffer, TmpBuffer;
    PREQUEST AdapterStatusRequest;
    PDEVICE Device = NbiDevice;
    CTELockHandle   CancelLH;
    NB_DEFINE_LOCK_HANDLE (LockHandle);


    ReceiveReserved = (PNB_RECEIVE_RESERVED)(Packet->ProtocolReserved);

    switch (ReceiveReserved->Type) {

    case RECEIVE_TYPE_DATA:

        CTEAssert (ReceiveReserved->TransferInProgress);
        ReceiveReserved->TransferInProgress = FALSE;

        Connection = ReceiveReserved->u.RR_CO.Connection;

        NB_GET_CANCEL_LOCK( &CancelLH );
        NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);

        if (Status != NDIS_STATUS_SUCCESS) {

            if (Connection->State == CONNECTION_STATE_ACTIVE) {

                Connection->CurrentReceive = Connection->PreviousReceive;
                Connection->ReceiveState = CONNECTION_RECEIVE_ACTIVE;
                NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
                NB_FREE_CANCEL_LOCK( CancelLH );

                //
                // Send a resend ack?
                //

            } else  {

                //
                // This aborts the current receive and
                // releases the connection lock.
                //

                NbiCompleteReceive(
                    Connection,
                    ReceiveReserved->u.RR_CO.EndOfMessage,
                    CancelLH
                    NB_LOCK_HANDLE_ARG(LockHandle));

            }

        } else {


            Connection->CurrentReceive.Offset += BytesTransferred;
            Connection->CurrentReceive.MessageOffset += BytesTransferred;

            if (ReceiveReserved->u.RR_CO.CompleteReceive ||
                (Connection->State != CONNECTION_STATE_ACTIVE)) {

                if (ReceiveReserved->u.RR_CO.EndOfMessage) {

                    CTEAssert (!ReceiveReserved->u.RR_CO.PartialReceive);

                    ++Connection->ReceiveSequence;
                    ++Connection->LocalRcvSequenceMax;    // harmless if NewNetbios is FALSE
                    Connection->CurrentReceive.MessageOffset = 0;
                    Connection->CurrentIndicateOffset = 0;

                } else if (Connection->NewNetbios) {

                    if (ReceiveReserved->u.RR_CO.PartialReceive) {
                        Connection->CurrentIndicateOffset += BytesTransferred;
                    } else {
                        ++Connection->ReceiveSequence;
                        ++Connection->LocalRcvSequenceMax;
                        Connection->CurrentIndicateOffset = 0;
                    }
                }

                //
                // This sends an ack and releases the connection lock.
                //

                NbiCompleteReceive(
                    Connection,
                    ReceiveReserved->u.RR_CO.EndOfMessage,
                    CancelLH
                    NB_LOCK_HANDLE_ARG(LockHandle));

            } else {

                NB_SYNC_SWAP_IRQL( CancelLH, LockHandle );
                NB_FREE_CANCEL_LOCK( CancelLH );

                Connection->ReceiveState = CONNECTION_RECEIVE_ACTIVE;

                if (Connection->NewNetbios) {

                    //
                    // A partial receive should only happen if we are
                    // completing the receive.
                    //

                    CTEAssert (!ReceiveReserved->u.RR_CO.PartialReceive);

                    ++Connection->ReceiveSequence;
                    ++Connection->LocalRcvSequenceMax;
                    Connection->CurrentIndicateOffset = 0;

                    if ((Connection->CurrentReceiveNoPiggyback) ||
                        ((Device->AckWindow != 0) &&
                         (++Connection->ReceivesWithoutAck >= Device->AckWindow))) {

                        NbiSendDataAck(
                            Connection,
                            NbiAckResponse
                            NB_LOCK_HANDLE_ARG(LockHandle));

                    } else {

                        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

                    }

                } else {

                    NbiSendDataAck(
                        Connection,
                        NbiAckResponse
                        NB_LOCK_HANDLE_ARG(LockHandle));

                }

            }

        }

        //
        // Free the NDIS buffer chain if we allocated one.
        //

        if (!ReceiveReserved->u.RR_CO.NoNdisBuffer) {

            NdisQueryPacket (Packet, NULL, NULL, &CurBuffer, NULL);

            while (CurBuffer) {
                TmpBuffer = NDIS_BUFFER_LINKAGE (CurBuffer);
                NdisFreeBuffer (CurBuffer);
                CurBuffer = TmpBuffer;
            }

        }

        NdisReinitializePacket (Packet);
        ExInterlockedPushEntrySList(
            &Device->ReceivePacketList,
            &ReceiveReserved->PoolLinkage,
            &NbiGlobalPoolInterlock);

        NbiDereferenceConnection (Connection, CREF_INDICATE);

        break;

    case RECEIVE_TYPE_DATAGRAM:

        CTEAssert (ReceiveReserved->TransferInProgress);
        ReceiveReserved->TransferInProgress = FALSE;

        ReceiveBuffer = ReceiveReserved->u.RR_DG.ReceiveBuffer;

        //
        // Free the packet used for the transfer.
        //

        ReceiveReserved->u.RR_DG.ReceiveBuffer = NULL;
        NdisReinitializePacket (Packet);
        ExInterlockedPushEntrySList(
            &Device->ReceivePacketList,
            &ReceiveReserved->PoolLinkage,
            &NbiGlobalPoolInterlock);

        //
        // If it succeeded then queue it for indication,
        // otherwise free the receive buffer also.
        //

        if (Status == STATUS_SUCCESS) {

            ReceiveBuffer->DataLength = BytesTransferred;
            NB_INSERT_HEAD_LIST(
                &Device->ReceiveDatagrams,
                &ReceiveBuffer->WaitLinkage,
                &Device->Lock);

        } else {

            Address = ReceiveBuffer->Address;

#if     defined(_PNP_POWER)
            NbiPushReceiveBuffer ( ReceiveBuffer );
#else
            NB_PUSH_ENTRY_LIST(
                &Device->ReceiveBufferList,
                &ReceiveBuffer->PoolLinkage,
                &Device->Lock);
#endif  _PNP_POWER

            NbiDereferenceAddress (Address, AREF_FIND);

        }

        break;

    case RECEIVE_TYPE_ADAPTER_STATUS:

        CTEAssert (ReceiveReserved->TransferInProgress);
        ReceiveReserved->TransferInProgress = FALSE;

        AdapterStatusRequest = ReceiveReserved->u.RR_AS.Request;

        //
        // Free the packet used for the transfer.
        //

        NdisReinitializePacket (Packet);
        ExInterlockedPushEntrySList(
            &Device->ReceivePacketList,
            &ReceiveReserved->PoolLinkage,
            &NbiGlobalPoolInterlock);

        //
        // Complete the request.
        //

        if (Status == STATUS_SUCCESS) {

            //
            // REQUEST_STATUS() is already to set to SUCCESS or
            // BUFFER_OVERFLOW based on whether the buffer was
            // big enough.
            //

            REQUEST_INFORMATION(AdapterStatusRequest) = BytesTransferred;

        } else {

            REQUEST_INFORMATION(AdapterStatusRequest) = 0;
            REQUEST_STATUS(AdapterStatusRequest) = STATUS_UNEXPECTED_NETWORK_ERROR;

        }

        NbiCompleteRequest (AdapterStatusRequest);
        NbiFreeRequest (Device, AdapterStatusRequest);

        NbiDereferenceDevice (Device, DREF_STATUS_QUERY);

        break;

    }

}   /* NbiTransferDataComplete */


VOID
NbiAcknowledgeReceive(
    IN PCONNECTION Connection
    IN NB_LOCK_HANDLE_PARAM(LockHandle)
    )

/*++

Routine Description:

    This routine is called when a receive needs to be acked to
    the remote. It either sends a data ack or queues up a piggyback
    ack request.

    NOTE: THIS FUNCTION IS CALLED WITH THE CONNECTION LOCK HELD
    AND RETURNS WITH IT RELEASED.

Arguments:

    Connection - Pointer to the connection.

    LockHandle - The handle with which Connection->Lock was acquired.

Return Value:

    None.

--*/

{
    PDEVICE Device = NbiDevice;

    if (Connection->NewNetbios) {

        //
        // CurrentReceiveNoPiggyback is based on the bits he
        // set in his frame, NoPiggybackHeuristic is based on
        // guesses about the traffic pattern, it is set to
        // TRUE if we think we should not piggyback.
        //

        if ((!Device->EnablePiggyBackAck) ||
            (Connection->CurrentReceiveNoPiggyback) ||
            (Connection->PiggybackAckTimeout) ||
            (Connection->NoPiggybackHeuristic)) {

            //
            // This releases the lock.
            //

            NbiSendDataAck(
                Connection,
                NbiAckResponse
                NB_LOCK_HANDLE_ARG(LockHandle));

        } else {

            if (!Connection->DataAckPending) {

                NB_DEFINE_LOCK_HANDLE (LockHandle1)

                //
                // Some stacks can have multiple messages
                // outstanding, so we may already have an
                // ack queued.
                //

                Connection->DataAckTimeouts = 0;
                Connection->DataAckPending = TRUE;

                ++Device->Statistics.PiggybackAckQueued;

                if (!Connection->OnDataAckQueue) {

                    NB_SYNC_GET_LOCK (&Device->TimerLock, &LockHandle1);

                    if (!Connection->OnDataAckQueue) {
                        Connection->OnDataAckQueue = TRUE;
                        InsertTailList (&Device->DataAckConnections, &Connection->DataAckLinkage);
                    }

                    if (!Device->DataAckActive) {
                        NbiStartShortTimer (Device);
                        Device->DataAckActive = TRUE;
                    }

                    NB_SYNC_FREE_LOCK (&Device->TimerLock, LockHandle1);
                }

                //
                // Clear this, since a message ack resets the count.
                //

                Connection->ReceivesWithoutAck = 0;

            }

            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
        }

    } else {

        //
        // This releases the lock.
        //

        NbiSendDataAck(
            Connection,
            NbiAckResponse
            NB_LOCK_HANDLE_ARG(LockHandle));

    }

}


VOID
NbiCompleteReceive(
    IN PCONNECTION Connection,
    IN BOOLEAN EndOfMessage,
    IN CTELockHandle    CancelLH
    IN NB_LOCK_HANDLE_PARAM(LockHandle)
    )

/*++

Routine Description:

    This routine is called when we have filled up a receive request
    and need to complete it.

    NOTE: THIS FUNCTION IS CALLED WITH THE CONNECTION LOCK HELD
    AND RETURNS WITH IT RELEASED.

    THIS ROUTINE ALSO HOLDS CANCEL SPIN LOCK WHEN IT IS CALLED
    AND RELEASES IT WHEN IT RETURNS.
Arguments:

    Connection - Pointer to the connection.

    EndOfMessage - BOOLEAN set to true if the message end was received.

    LockHandle - The handle with which Connection->Lock was acquired.

Return Value:

    None.

--*/

{
    PREQUEST Request;
    PDEVICE Device = NbiDevice;

    //
    // Complete the current receive request. If the connection
    // has shut down then we complete it right here, otherwise
    // we queue it for completion in the receive complete
    // handler.
    //

    Request = Connection->ReceiveRequest;
    IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);

    NB_SYNC_SWAP_IRQL( CancelLH, LockHandle );
    NB_FREE_CANCEL_LOCK( CancelLH );

    if (Connection->State != CONNECTION_STATE_ACTIVE) {

        Connection->ReceiveRequest = NULL;   // StopConnection won't do this

        REQUEST_STATUS(Request) = Connection->Status;
        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

        NB_DEBUG2 (RECEIVE, ("Completing receive %lx (%d), status %lx\n",
                Request, REQUEST_INFORMATION(Request), REQUEST_STATUS(Request)));

        NbiCompleteRequest (Request);
        NbiFreeRequest (NbiDevice, Request);

        ++Connection->ConnectionInfo.ReceiveErrors;

        NbiDereferenceConnection (Connection, CREF_RECEIVE);

    } else {

        REQUEST_INFORMATION (Request) = Connection->CurrentReceive.Offset;

        if (EndOfMessage) {

            REQUEST_STATUS(Request) = STATUS_SUCCESS;

        } else {

            REQUEST_STATUS(Request) = STATUS_BUFFER_OVERFLOW;

        }

        //
        // If we indicated to the client, adjust this down by the
        // amount of data taken, when it hits zero we can reindicate.
        //

        if (Connection->ReceiveUnaccepted) {
            NB_DEBUG2 (RECEIVE, ("Moving Unaccepted %d down by %d\n",
                            Connection->ReceiveUnaccepted, Connection->CurrentReceive.Offset));
            if (Connection->CurrentReceive.Offset >= Connection->ReceiveUnaccepted) {
                Connection->ReceiveUnaccepted = 0;
            } else {
                Connection->ReceiveUnaccepted -= Connection->CurrentReceive.Offset;
            }
        }

        //
        // Check whether to activate another receive?
        //

        Connection->ReceiveState = CONNECTION_RECEIVE_PENDING;
        Connection->ReceiveRequest = NULL;

        //
        // This releases the lock.
        //

        if (Connection->NewNetbios) {

            if (EndOfMessage) {

                NbiAcknowledgeReceive(
                    Connection
                    NB_LOCK_HANDLE_ARG(LockHandle));

            } else {

                if (Connection->CurrentIndicateOffset != 0) {

                    NbiSendDataAck(
                        Connection,
                        NbiAckResend
                        NB_LOCK_HANDLE_ARG(LockHandle));

                } else if ((Connection->CurrentReceiveNoPiggyback) ||
                           ((Device->AckWindow != 0) &&
                            (++Connection->ReceivesWithoutAck >= Device->AckWindow))) {

                    NbiSendDataAck(
                        Connection,
                        NbiAckResponse
                        NB_LOCK_HANDLE_ARG(LockHandle));

                } else {

                    NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

                }
            }

        } else {

            NbiSendDataAck(
                Connection,
                EndOfMessage ? NbiAckResponse : NbiAckResend
                NB_LOCK_HANDLE_ARG(LockHandle));

        }

        ++Connection->ConnectionInfo.ReceivedTsdus;

        //
        // This will complete the request inside ReceiveComplete,
        // dereference the connection, and set the state to IDLE.
        //

        if ( Request->Type != 0x6 ) {
            DbgPrint("NB: tracking pool corruption in rcv irp %lx \n", Request );
            DbgBreakPoint();
        }

        NB_INSERT_TAIL_LIST(
            &Device->ReceiveCompletionQueue,
            REQUEST_LINKAGE (Request),
            &Device->Lock);

    }

}   /* NbiCompleteReceive */


NTSTATUS
NbiTdiReceive(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine does a receive on an active connection.

Arguments:

    Device - The netbios device.

    Request - The request describing the receive.

Return Value:

    NTSTATUS - status of operation.

--*/

{

    PCONNECTION Connection;
    NB_DEFINE_SYNC_CONTEXT (SyncContext)
    NB_DEFINE_LOCK_HANDLE (LockHandle)
    CTELockHandle   CancelLH;

    //
    // Check that the file type is valid
    //
    if (REQUEST_OPEN_TYPE(Request) != (PVOID)TDI_CONNECTION_FILE)
    {
        CTEAssert(FALSE);
        return (STATUS_INVALID_ADDRESS_COMPONENT);
    }

    //
    // First make sure the connection is valid.
    //
    Connection = (PCONNECTION)REQUEST_OPEN_CONTEXT(Request);
    if (Connection->Type == NB_CONNECTION_SIGNATURE) {

        NB_GET_CANCEL_LOCK( &CancelLH );
        NB_BEGIN_SYNC (&SyncContext);
        NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);

        //
        // Make sure the connection is in a good state.
        //

        if (Connection->State == CONNECTION_STATE_ACTIVE) {

            //
            // If the connection is idle then send it now, otherwise
            // queue it.
            //


            if (!Request->Cancel) {

                IoSetCancelRoutine (Request, NbiCancelReceive);
                NB_SYNC_SWAP_IRQL( CancelLH, LockHandle );
                NB_FREE_CANCEL_LOCK( CancelLH );

                NbiReferenceConnectionSync (Connection, CREF_RECEIVE);

                //
                // Insert this in our queue, then see if we need
                // to wake up the remote.
                //

                REQUEST_SINGLE_LINKAGE(Request) = NULL;
                REQUEST_LIST_INSERT_TAIL(&Connection->ReceiveQueue, Request);

                if (Connection->ReceiveState != CONNECTION_RECEIVE_W_RCV) {

                    NB_DEBUG2 (RECEIVE, ("Receive %lx, connection %lx idle\n", Request, Connection));
                    NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

                } else {

                    NB_DEBUG2 (RECEIVE, ("Receive %lx, connection %lx awakened\n", Request, Connection));
                    Connection->ReceiveState = CONNECTION_RECEIVE_IDLE;

                    //
                    // This releases the lock.
                    //

                    if (Connection->NewNetbios) {

                        Connection->LocalRcvSequenceMax = (USHORT)
                            (Connection->ReceiveSequence + Connection->ReceiveWindowSize - 1);

                    }

                    NbiSendDataAck(
                        Connection,
                        NbiAckResend
                        NB_LOCK_HANDLE_ARG(LockHandle));

                }

                NB_END_SYNC (&SyncContext);
                return STATUS_PENDING;

            } else {

                NB_DEBUG2 (RECEIVE, ("Receive %lx, connection %lx cancelled\n", Request, Connection));
                NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
                NB_END_SYNC (&SyncContext);

                NB_FREE_CANCEL_LOCK( CancelLH );
                return STATUS_CANCELLED;

            }

        } else {

            NB_DEBUG2 (RECEIVE, ("Receive connection %lx state is %d\n", Connection, Connection->State));
            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
            NB_END_SYNC (&SyncContext);
            NB_FREE_CANCEL_LOCK( CancelLH );
            return STATUS_INVALID_CONNECTION;

        }

    } else {

        NB_DEBUG (RECEIVE, ("Receive connection %lx has bad signature\n", Connection));
        return STATUS_INVALID_CONNECTION;

    }

}   /* NbiTdiReceive */


VOID
NbiCancelReceive(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to cancel a receive.
    The request is found on the connection's receive queue.

    NOTE: This routine is called with the CancelSpinLock held and
    is responsible for releasing it.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    none.

--*/

{
    PCONNECTION Connection;
    PREQUEST Request = (PREQUEST)Irp;
    NB_DEFINE_LOCK_HANDLE (LockHandle)
    NB_DEFINE_SYNC_CONTEXT (SyncContext)

    CTEAssert ((REQUEST_MAJOR_FUNCTION(Request) == IRP_MJ_INTERNAL_DEVICE_CONTROL) &&
               (REQUEST_MINOR_FUNCTION(Request) == TDI_RECEIVE));

    CTEAssert (REQUEST_OPEN_TYPE(Request) == (PVOID)TDI_CONNECTION_FILE);

    Connection = (PCONNECTION)REQUEST_OPEN_CONTEXT(Request);


    //
    // Just stop the connection, that will tear down any
    // receives.
    //
    // Do we care about cancelling non-active
    // receives without stopping the connection??
    //
    // This routine is the same as NbiCancelSend,
    // so if we don't make it more specific, merge the two.
    //

    NbiReferenceConnectionSync (Connection, CREF_CANCEL);

    IoReleaseCancelSpinLock (Irp->CancelIrql);


    NB_BEGIN_SYNC (&SyncContext);

    NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);

    //
    // This frees the lock, cancels any sends, etc.
    //

    NbiStopConnection(
        Connection,
        STATUS_CANCELLED
        NB_LOCK_HANDLE_ARG (LockHandle));

    NbiDereferenceConnection (Connection, CREF_CANCEL);

    NB_END_SYNC (&SyncContext);

}   /* NbiCancelReceive */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\nb\query.c ===
/*++

Copyright (c) 1989-1993 Microsoft Corporation

Module Name:

    query.c

Abstract:

    This module contains code which performs the following TDI services:

        o   TdiQueryInformation
        o   TdiSetInformation

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Remove the warning -- this is defined in windef also.
//

#ifdef FAR
#undef FAR
#endif

#include <windef.h>
#include <nb30.h>


//
// Useful macro to obtain the total length of a buffer chain.
// Make this use NDIS macros ?
//

#define NbiGetBufferChainLength(Buffer, Length) { \
    PNDIS_BUFFER _Buffer = (Buffer); \
    *(Length) = 0; \
    while (_Buffer) { \
        *(Length) += MmGetMdlByteCount(_Buffer); \
        _Buffer = _Buffer->Next; \
    } \
}


NTSTATUS
NbiTdiQueryInformation(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine performs the TdiQueryInformation request for the transport
    provider.

Arguments:

    Request - the request for the operation.

Return Value:

    The status of operation.

--*/

{
    NTSTATUS Status;
    PTDI_REQUEST_KERNEL_QUERY_INFORMATION Query;
    PADDRESS_FILE AddressFile;
    PADDRESS Address;
    PCONNECTION Connection;
    union {
        struct {
            ULONG ActivityCount;
            TA_NETBIOS_ADDRESS NbiAddress;
        } AddressInfo;
        TA_NETBIOS_ADDRESS BroadcastAddress;
        TDI_ADDRESS_IPX IpxAddress;
        TDI_DATAGRAM_INFO DatagramInfo;
        struct {
            FIND_NAME_HEADER Header;
            FIND_NAME_BUFFER Buffer;
        } FindNameInfo;
    } TempBuffer;
    IPX_SOURCE_ROUTING_INFO SourceRoutingInfo;
    PADAPTER_STATUS AdapterStatus;
    BOOLEAN RemoteAdapterStatus;
    TDI_ADDRESS_NETBIOS * RemoteAddress;
    ULONG TargetBufferLength;
    ULONG ActualBytesCopied;
    ULONG AdapterStatusLength;
    ULONG ValidStatusLength;
    ULONG ElementSize, TransportAddressSize;
    PTRANSPORT_ADDRESS TransportAddress;
    TA_ADDRESS * CurAddress;
    PNETBIOS_CACHE CacheName;
    FIND_NAME_HEADER UNALIGNED * FindNameHeader = NULL;
    UINT FindNameBufferLength;
    NTSTATUS QueryStatus;
    CTELockHandle LockHandle;
    PLIST_ENTRY p;
    BOOLEAN UsedConnection;
    UINT i;


    //
    // what type of status do we want?
    //

    Query = (PTDI_REQUEST_KERNEL_QUERY_INFORMATION)REQUEST_PARAMETERS(Request);

    switch (Query->QueryType) {

    case TDI_QUERY_ADDRESS_INFO:

        //
        // The caller wants the exact address value.
        //

        if (REQUEST_OPEN_TYPE(Request) == (PVOID)TDI_TRANSPORT_ADDRESS_FILE) {

            AddressFile = (PADDRESS_FILE)REQUEST_OPEN_CONTEXT(Request);

#if     defined(_PNP_POWER)
            Status = NbiVerifyAddressFile (AddressFile, CONFLICT_IS_NOT_OK);
#else
            Status = NbiVerifyAddressFile (AddressFile);
#endif  _PNP_POWER

            if (!NT_SUCCESS(Status)) {
                break;
            }

            UsedConnection = FALSE;

        } else if (REQUEST_OPEN_TYPE(Request) == (PVOID)TDI_CONNECTION_FILE) {

            Connection = (PCONNECTION)REQUEST_OPEN_CONTEXT(Request);

            Status = NbiVerifyConnection (Connection);

            if (!NT_SUCCESS(Status)) {
                break;
            }

            if (!(AddressFile = Connection->AddressFile))
            {
                Status = STATUS_INVALID_ADDRESS;
                break;
            }

            UsedConnection = TRUE;

        } else {

            Status = STATUS_INVALID_ADDRESS;
            break;

        }

        Address = AddressFile->Address;

        NB_DEBUG2 (QUERY, ("Query address info on %lx\n", AddressFile));

        TempBuffer.AddressInfo.ActivityCount = 0;

        NB_GET_LOCK (&Address->Lock, &LockHandle);

        for (p = Address->AddressFileDatabase.Flink;
             p != &Address->AddressFileDatabase;
             p = p->Flink) {

            if (CONTAINING_RECORD (p, ADDRESS_FILE, Linkage)->State == ADDRESSFILE_STATE_OPEN) {
                ++TempBuffer.AddressInfo.ActivityCount;
            }
        }

        NB_FREE_LOCK (&Address->Lock, LockHandle);

        TdiBuildNetbiosAddress(
            AddressFile->Address->NetbiosAddress.NetbiosName,
            (BOOLEAN)(AddressFile->Address->NetbiosAddress.NetbiosNameType == TDI_ADDRESS_NETBIOS_TYPE_GROUP),
            &TempBuffer.AddressInfo.NbiAddress);

        Status = TdiCopyBufferToMdl(
            &TempBuffer.AddressInfo,
            0,
            sizeof(ULONG) + sizeof(TA_NETBIOS_ADDRESS),
            REQUEST_NDIS_BUFFER(Request),
            0,
            &ActualBytesCopied);

            REQUEST_INFORMATION(Request) = ActualBytesCopied;

        if (UsedConnection) {

            NbiDereferenceConnection (Connection, CREF_VERIFY);

        } else {

            NbiDereferenceAddressFile (AddressFile, AFREF_VERIFY);

        }

        break;

    case TDI_QUERY_CONNECTION_INFO:

        //
        // Connection info is queried on a connection,
        // verify this.
        //

        Connection = (PCONNECTION)REQUEST_OPEN_CONTEXT(Request);

        Status = NbiVerifyConnection (Connection);

        if (!NT_SUCCESS (Status)) {
            return Status;
        }

        if (Connection->State != CONNECTION_STATE_ACTIVE) {

            Status = STATUS_INVALID_CONNECTION;

        } else {

            //
            // Assume 50 ms of delay for every hop after the
            // first. The delay is returned as a negative number.
            //

            if (Connection->HopCount > 1) {
                Connection->ConnectionInfo.Delay.HighPart = (ULONG)-1;
                Connection->ConnectionInfo.Delay.LowPart =
                    -((Connection->HopCount-1) * 50 * MILLISECONDS);
            } else {
                Connection->ConnectionInfo.Delay.HighPart = 0;
                Connection->ConnectionInfo.Delay.LowPart = 0;
            }

            //
            // We have tick count; to convert to bytes/second we do:
            //
            //      packet        576 bytes   18.21 ticks
            // ---------------- * --------- * -----------
            // tick_count ticks     packet      seconds
            //
            // to get 10489/tick_count = bytes/second. We
            // double this because routers tend to
            // overestimate it.
            //
            // Since tick_count has such a low granularity,
            // a tick count of 1 gives us a throughput of
            // only 84 kbps, which is much too low. In
            // that case we return twice the link speed
            // which is in 100 bps units; that corresponds
            // to about 1/6 of our bandwidth in bytes/sec.
            //

            if (Connection->TickCount <= Connection->HopCount) {

                Connection->ConnectionInfo.Throughput.QuadPart =
                        UInt32x32To64 (Connection->LineInfo.LinkSpeed, 2);

            } else {

                Connection->ConnectionInfo.Throughput.HighPart = 0;
                Connection->ConnectionInfo.Throughput.LowPart =
                    20978 / (Connection->TickCount - Connection->HopCount);

            }

            Connection->ConnectionInfo.Unreliable = FALSE;

            Status = TdiCopyBufferToMdl (
                            &Connection->ConnectionInfo,
                            0,
                            sizeof(TDI_CONNECTION_INFO),
                            REQUEST_NDIS_BUFFER(Request),
                            0,
                            &ActualBytesCopied);

            REQUEST_INFORMATION(Request) = ActualBytesCopied;
        }

        NbiDereferenceConnection (Connection, CREF_VERIFY);

        break;

    case TDI_QUERY_PROVIDER_INFO:

        NB_DEBUG2 (QUERY, ("Query provider info\n"));

        Status = TdiCopyBufferToMdl (
                    &Device->Information,
                    0,
                    sizeof (TDI_PROVIDER_INFO),
                    REQUEST_NDIS_BUFFER(Request),
                    0,
                    &ActualBytesCopied);

        REQUEST_INFORMATION(Request) = ActualBytesCopied;
        break;

    case TDI_QUERY_BROADCAST_ADDRESS:

        //
        // for this provider, the broadcast address is a zero byte name,
        // contained in a Transport address structure.
        //

        NB_DEBUG2 (QUERY, ("Query broadcast address\n"));

        TempBuffer.BroadcastAddress.TAAddressCount = 1;
        TempBuffer.BroadcastAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
        TempBuffer.BroadcastAddress.Address[0].AddressLength = 0;

        Status = TdiCopyBufferToMdl (
                        (PVOID)&TempBuffer.BroadcastAddress,
                        0L,
                        sizeof (TempBuffer.BroadcastAddress.TAAddressCount) +
                          sizeof (TempBuffer.BroadcastAddress.Address[0].AddressType) +
                          sizeof (TempBuffer.BroadcastAddress.Address[0].AddressLength),
                        REQUEST_NDIS_BUFFER(Request),
                        0,
                        &ActualBytesCopied);

        REQUEST_INFORMATION(Request) = ActualBytesCopied;

        break;

    case TDI_QUERY_ADAPTER_STATUS:

        //
        // Determine if this is a local or remote query.
        //

        RemoteAdapterStatus = FALSE;

        if (Query->RequestConnectionInformation != NULL) {

            RemoteAddress = NbiParseTdiAddress(Query->RequestConnectionInformation->RemoteAddress, Query->RequestConnectionInformation->RemoteAddressLength, FALSE);

            if (RemoteAddress == NULL) {
                return STATUS_BAD_NETWORK_PATH;
            }

#if defined(_PNP_POWER)
            if ( !NbiFindAdapterAddress(
                    RemoteAddress->NetbiosName,
                    LOCK_NOT_ACQUIRED ) ) {

                RemoteAdapterStatus =   TRUE;
            }
#else
            if (!RtlEqualMemory(
                 RemoteAddress->NetbiosName,
                 Device->ReservedNetbiosName,
                 16)) {

                 RemoteAdapterStatus = TRUE;

            }
#endif  _PNP_POWER

        }

        if (RemoteAdapterStatus) {

            //
            // See if we have this name cached.
            //

            NB_GET_LOCK (&Device->Lock, &LockHandle);

            Status = CacheFindName(
                         Device,
                         FindNameOther,
                         RemoteAddress->NetbiosName,
                         &CacheName);

            if (Status == STATUS_PENDING) {

                //
                // A request for routes to this name has been
                // sent out on the net, we queue up this status
                // request and processing will be resumed when
                // we get a response.
                //
                // The status field in the request will hold
                // the cache entry for the remote. The information
                // field will hold the remote netbios name while
                // it is in the WaitingAdapterStatus queue, and
                // will hold a timeout value while we it is in
                // the ActiveAdapterStatus queue.
                //

                NB_DEBUG2 (QUERY, ("Queueing up adapter status %lx\n", Request));

                NbiReferenceDevice (Device, DREF_STATUS_QUERY);

                REQUEST_INFORMATION (Request) = (ULONG_PTR) RemoteAddress;

                InsertTailList(
                    &Device->WaitingAdapterStatus,
                    REQUEST_LINKAGE (Request));

                NB_FREE_LOCK (&Device->Lock, LockHandle);

            } else if (Status == STATUS_SUCCESS) {

                NB_DEBUG2 (QUERY, ("Found adapter status cached %lx\n", Request));

                //
                // We reference the cache name entry so it won't
                // go away while we are using it.
                //

                REQUEST_STATUSPTR(Request) = (PVOID)CacheName;
                ++CacheName->ReferenceCount;

                NbiReferenceDevice (Device, DREF_STATUS_QUERY);

                REQUEST_INFORMATION (Request) = 0;

                InsertTailList(
                    &Device->ActiveAdapterStatus,
                    REQUEST_LINKAGE (Request));

                NB_FREE_LOCK (&Device->Lock, LockHandle);

                NbiSendStatusQuery (Request);

                Status = STATUS_PENDING;

            } else {

                if (Status != STATUS_INSUFFICIENT_RESOURCES) {
                    Status = STATUS_IO_TIMEOUT;
                }

                REQUEST_INFORMATION (Request) = 0;

                NB_FREE_LOCK (&Device->Lock, LockHandle);

            }

        } else {

            //
            // Local adapter status.
            //

            NbiGetBufferChainLength (REQUEST_NDIS_BUFFER(Request), &TargetBufferLength);

            Status = NbiStoreAdapterStatus(
                         TargetBufferLength,
                         1,                     // NIC ID, was 0, changed to 1 for Bug #18026
                                                // because for NicId = 0, Ipx returns virtual
                                                // address. Netbios uses that to register the
                                                // name (00...01) and fails.
                         &AdapterStatus,
                         &AdapterStatusLength,
                         &ValidStatusLength);

            if (Status != STATUS_INSUFFICIENT_RESOURCES) {

                //
                // This should succeed since we know the length
                // will fit.
                //

                (VOID)TdiCopyBufferToMdl(
                          AdapterStatus,
                          0,
                          ValidStatusLength,
                          REQUEST_NDIS_BUFFER(Request),
                          0,
                          &ActualBytesCopied);

                REQUEST_INFORMATION(Request) = ActualBytesCopied;

                NbiFreeMemory (AdapterStatus, AdapterStatusLength, MEMORY_STATUS, "Adapter Status");
            }

        }

        break;

    case TDI_QUERY_FIND_NAME:

        //
        // Check that there is a valid Netbios remote address.
        //

        if ((Query->RequestConnectionInformation == NULL) ||
            ((RemoteAddress = NbiParseTdiAddress(Query->RequestConnectionInformation->RemoteAddress, Query->RequestConnectionInformation->RemoteAddressLength, FALSE)) == NULL)) {

            return STATUS_BAD_NETWORK_PATH;
        }

        //
        // We assume the entire request buffer is in the first
        // piece of the MDL chain.
        // Make sure there is room for at least the header.
        //

        NdisQueryBufferSafe (REQUEST_NDIS_BUFFER(Request), (PVOID *)&FindNameHeader, &FindNameBufferLength,
                             HighPagePriority);
        if ((!FindNameHeader) ||
            (FindNameBufferLength < sizeof(FIND_NAME_HEADER))) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }


        //
        // See if we have this name cached. We specify that this is
        // a netbios name query, so this will only succeed if this is a
        // unique name -- for a group name it will queue up a find
        // name query and when we get the response we will fill in
        // the request's buffer based on it.
        //

        NB_GET_LOCK (&Device->Lock, &LockHandle);

        Status = CacheFindName(
                     Device,
                     FindNameNetbiosFindName,
                     RemoteAddress->NetbiosName,
                     &CacheName);

        if (Status == STATUS_PENDING) {

            //
            // A request for routes to this name has been
            // sent out on the net, we queue up this find
            // name request and processing will be resumed when
            // we get a response.
            //
            // The information field will hold the remote
            // netbios name while it is in the WaitingNetbiosFindName
            // queue. The status will hold the current status --
            // initially failure, then success, then overflow
            // if the buffer is too small.
            //

            NB_DEBUG2 (QUERY, ("Queueing up find name %lx\n", Request));

            NbiReferenceDevice (Device, DREF_NB_FIND_NAME);

            FindNameHeader->node_count = 0;
            FindNameHeader->reserved = 0;
            FindNameHeader->unique_group = 0;

            REQUEST_INFORMATION (Request) = (ULONG_PTR)RemoteAddress;

            //
            // Assume it fails, we update the status to
            // SUCCESS or BUFFER_OVERFLOW if needed.
            //

            REQUEST_STATUS (Request) = STATUS_IO_TIMEOUT;

            InsertTailList(
                &Device->WaitingNetbiosFindName,
                REQUEST_LINKAGE (Request));

            NB_FREE_LOCK (&Device->Lock, LockHandle);

        } else if (Status == STATUS_SUCCESS) {

            NB_DEBUG2 (QUERY, ("Found find name cached %lx\n", Request));

            //
            // We don't need to reference the cache entry since
            // we only use it here with the lock still held.
            //

            //
            // Query the local address, which we will return as
            // the destination address of this query. Since we
            // use TempBuffer.IpxAddress for this query, we have
            // to immediately copy it to its correct place in
            // TempBuffer.FindNameInfo.Buffer.
            //
#if     defined(_PNP_POWER)
            if( (*Device->Bind.QueryHandler)(   // Check return code
                    IPX_QUERY_IPX_ADDRESS,
                    &CacheName->Networks[0].LocalTarget.NicHandle,
                    &TempBuffer.IpxAddress,
                    sizeof(TDI_ADDRESS_IPX),
                    NULL) != STATUS_SUCCESS ) {
                NB_DEBUG( QUERY, ("Ipx Query %d failed for Nic %x\n",IPX_QUERY_IPX_ADDRESS,
                                    CacheName->Networks[0].LocalTarget.NicHandle.NicId ));

                goto QueryFindNameFailed;
            }
#else
            (VOID)(*Device->Bind.QueryHandler)(   // Check return code
                IPX_QUERY_IPX_ADDRESS,
                CacheName->Networks[0].LocalTarget.NicId,
                &TempBuffer.IpxAddress,
                sizeof(TDI_ADDRESS_IPX),
                NULL);
#endif  _PNP_POWER

            RtlMoveMemory (TempBuffer.FindNameInfo.Buffer.destination_addr, TempBuffer.IpxAddress.NodeAddress, 6);
            TempBuffer.FindNameInfo.Buffer.access_control = 0x10;   // standard token-ring values
            TempBuffer.FindNameInfo.Buffer.frame_control = 0x40;
            RtlCopyMemory (TempBuffer.FindNameInfo.Buffer.source_addr, CacheName->FirstResponse.NodeAddress, 6);

            //
            // Query source routing information about this remote, if any.
            //

            SourceRoutingInfo.Identifier = IDENTIFIER_NB;
            RtlCopyMemory (SourceRoutingInfo.RemoteAddress, CacheName->FirstResponse.NodeAddress, 6);

            QueryStatus = (*Device->Bind.QueryHandler)(
                IPX_QUERY_SOURCE_ROUTING,
#if     defined(_PNP_POWER)
                &CacheName->Networks[0].LocalTarget.NicHandle,
#else
                CacheName->Networks[0].LocalTarget.NicId,
#endif  _PNP_POWER
                &SourceRoutingInfo,
                sizeof(IPX_SOURCE_ROUTING_INFO),
                NULL);

            RtlZeroMemory(TempBuffer.FindNameInfo.Buffer.routing_info, 18);
            if (QueryStatus != STATUS_SUCCESS) {
                SourceRoutingInfo.SourceRoutingLength = 0;
            } else if (SourceRoutingInfo.SourceRoutingLength > 0) {
                RtlMoveMemory(
                    TempBuffer.FindNameInfo.Buffer.routing_info,
                    SourceRoutingInfo.SourceRouting,
                    SourceRoutingInfo.SourceRoutingLength);
            }

            TempBuffer.FindNameInfo.Buffer.length = (UCHAR)(14 + SourceRoutingInfo.SourceRoutingLength);

            TempBuffer.FindNameInfo.Header.node_count = 1;
            TempBuffer.FindNameInfo.Header.reserved = 0;
            TempBuffer.FindNameInfo.Header.unique_group = 0;   // unique

            NB_FREE_LOCK (&Device->Lock, LockHandle);

            //
            // 33 is sizeof(FIND_NAME_BUFFER) without the padding.
            //

            Status = TdiCopyBufferToMdl (
                            (PVOID)&TempBuffer.FindNameInfo,
                            0,
                            sizeof(FIND_NAME_HEADER) + 33,
                            REQUEST_NDIS_BUFFER(Request),
                            0,
                            &ActualBytesCopied);

            REQUEST_INFORMATION(Request) = ActualBytesCopied;
        } else {

#if     defined(_PNP_POWER)
QueryFindNameFailed:
#endif  _PNP_POWER

            if (Status != STATUS_INSUFFICIENT_RESOURCES) {
                Status = STATUS_IO_TIMEOUT;
            }

            REQUEST_INFORMATION (Request) = 0;

            NB_FREE_LOCK (&Device->Lock, LockHandle);

        }

        break;

    case TDI_QUERY_PROVIDER_STATISTICS:

        //
        // Keep track of more of these.
        //

        NB_DEBUG2 (QUERY, ("Query provider statistics\n"));

        Status = TdiCopyBufferToMdl (
                    &Device->Statistics,
                    0,
                    FIELD_OFFSET (TDI_PROVIDER_STATISTICS, ResourceStats[0]),
                    REQUEST_NDIS_BUFFER(Request),
                    0,
                    &ActualBytesCopied);

        REQUEST_INFORMATION(Request) = ActualBytesCopied;
        break;

    case TDI_QUERY_DATAGRAM_INFO:

        NB_DEBUG2 (QUERY, ("Query datagram info\n"));

        TempBuffer.DatagramInfo.MaximumDatagramBytes = 0;
        TempBuffer.DatagramInfo.MaximumDatagramCount = 0;

        Status = TdiCopyBufferToMdl (
                    &TempBuffer.DatagramInfo,
                    0,
                    sizeof(TempBuffer.DatagramInfo),
                    REQUEST_NDIS_BUFFER(Request),
                    0,
                    &ActualBytesCopied);

        REQUEST_INFORMATION(Request) = ActualBytesCopied;
        break;

    case TDI_QUERY_DATA_LINK_ADDRESS:
    case TDI_QUERY_NETWORK_ADDRESS:{
#if     defined(_PNP_POWER)
        Status = (*Device->Bind.QueryHandler)(   // Check return code
                     (Query->QueryType == TDI_QUERY_DATA_LINK_ADDRESS
                                        ? IPX_QUERY_DATA_LINK_ADDRESS
                                        : IPX_QUERY_NETWORK_ADDRESS ),
                     NULL,
                     Request,
                     0,
                     NULL);
#else
        ULONG   TransportAddressAllocSize;

        if (Query->QueryType == TDI_QUERY_DATA_LINK_ADDRESS) {
            ElementSize = (2 * sizeof(USHORT)) + 6;
        } else {
            ElementSize = (2 * sizeof(USHORT)) + sizeof(TDI_ADDRESS_IPX);
        }

//        TransportAddress = CTEAllocMem(sizeof(int) + (ElementSize * Device->MaximumNicId));
        TransportAddressAllocSize = sizeof(int) + ( ElementSize * Device->MaximumNicId);
        TransportAddress = NbiAllocateMemory( TransportAddressAllocSize, MEMORY_QUERY, "Temp Query Allocation");

        if (TransportAddress == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            TransportAddress->TAAddressCount = 0;
            TransportAddressSize = sizeof(int);
            CurAddress = (TA_ADDRESS UNALIGNED *)TransportAddress->Address;

            for (i = 1; i <= Device->MaximumNicId; i++) {

                Status = (*Device->Bind.QueryHandler)(   // Check return code
                             IPX_QUERY_IPX_ADDRESS,
                             (USHORT)i,
                             &TempBuffer.IpxAddress,
                             sizeof(TDI_ADDRESS_IPX),
                             NULL);

                if (Status != STATUS_SUCCESS) {
                    continue;
                }

                if (Query->QueryType == TDI_QUERY_DATA_LINK_ADDRESS) {
                    CurAddress->AddressLength = 6;
                    CurAddress->AddressType = TDI_ADDRESS_TYPE_UNSPEC;
                    RtlCopyMemory (CurAddress->Address, TempBuffer.IpxAddress.NodeAddress, 6);
                } else {
                    CurAddress->AddressLength = sizeof(TDI_ADDRESS_IPX);
                    CurAddress->AddressType = TDI_ADDRESS_TYPE_IPX;
                    RtlCopyMemory (CurAddress->Address, &TempBuffer.IpxAddress, sizeof(TDI_ADDRESS_IPX));
                }
                ++TransportAddress->TAAddressCount;
                TransportAddressSize += ElementSize;
                CurAddress = (TA_ADDRESS UNALIGNED *)(((PUCHAR)CurAddress) + ElementSize);

            }

            Status = TdiCopyBufferToMdl (
                        TransportAddress,
                        0,
                        TransportAddressSize,
                        REQUEST_NDIS_BUFFER(Request),
                        0,
                        &ActualBytesCopied);

            REQUEST_INFORMATION(Request) = ActualBytesCopied;

//            CTEFreeMem (TransportAddress);
            NbiFreeMemory( TransportAddress, TransportAddressAllocSize, MEMORY_QUERY, "Temp Query Allocation");

        }
#endif  _PNP_POWER
        break;
    }
    default:

        NB_DEBUG (QUERY, ("Invalid query type %d\n", Query->QueryType));
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    return Status;

}   /* NbiTdiQueryInformation */


NTSTATUS
NbiStoreAdapterStatus(
    IN ULONG MaximumLength,
    IN USHORT NicId,
    OUT PVOID * StatusBuffer,
    OUT ULONG * StatusBufferLength,
    OUT ULONG * ValidBufferLength
    )

/*++

Routine Description:

    This routine allocates an ADAPTER_STATUS buffer and
    fills it in. The buffer will be allocated at most
    MaximumLength size. The caller is responsible for
    freeing the buffer.

Arguments:

    MaximumLength - The maximum length to allocate.

    NicId - The NIC ID the query was received on, or 0 for
        a local query.

    StatusBuffer - Returns the allocated buffer.

    StatusBufferLength - Returns the length of the buffer.

    ValidBufferLength - Returns the length of the buffer which
        contains valid adapter status data.

Return Value:

    STATUS_SUCCESS - The buffer was written successfully.
    STATUS_BUFFER_OVERFLOW - The buffer was written but not all
        data could fit in MaximumLength bytes.
    STATUS_INSUFFICIENT_RESOURCES - The buffer could not be allocated.

--*/

{

    PADAPTER_STATUS AdapterStatus;
    PNAME_BUFFER NameBuffer;
    ADAPTER_STATUS TempAdapterStatus;
#if      !defined(_PNP_POWER)
    TDI_ADDRESS_IPX IpxAddress;
#endif  !_PNP_POWER
    PDEVICE Device = NbiDevice;
    PADDRESS Address;
    UCHAR NameCount;
    ULONG LengthNeeded;
    ULONG BytesWritten;
    NTSTATUS Status;
    PLIST_ENTRY p;
    CTELockHandle LockHandle;


    //
    // First fill in the basic adapter status structure, to make
    // it easier to copy over if the target buffer is really short.
    //

    RtlZeroMemory ((PVOID)&TempAdapterStatus, sizeof(ADAPTER_STATUS));

#if     defined(_PNP_POWER)
    RtlCopyMemory (TempAdapterStatus.adapter_address, Device->Bind.Node, 6);
#else
    (VOID)(*Device->Bind.QueryHandler)(   // Check return code
        IPX_QUERY_IPX_ADDRESS,
        NicId,
        &IpxAddress,
        sizeof(TDI_ADDRESS_IPX),
        NULL);

    RtlCopyMemory (TempAdapterStatus.adapter_address, IpxAddress.NodeAddress, 6);
#endif  _PNP_POWER


    //
    // Some of the fields mean different things for Novell Netbios,
    // as described in the comments.
    //

    TempAdapterStatus.rev_major = 0;          // Jumpers
    TempAdapterStatus.reserved0 = 0;          // SelfTest
    TempAdapterStatus.adapter_type = 0;       // MajorVersion
    TempAdapterStatus.rev_minor = 0;          // MinorVersion

    TempAdapterStatus.duration = 0;           // ReportingPeriod
    TempAdapterStatus.frmr_recv = 0;          // ReceiveCRCErrors
    TempAdapterStatus.frmr_xmit = 0;          // ReceiveAlignErrors

    TempAdapterStatus.iframe_recv_err = 0;    // XmitCollisions
    TempAdapterStatus.xmit_aborts = 0;        // XmitAbort

    TempAdapterStatus.xmit_success = Device->Statistics.DataFramesSent; // SuccessfulXmits
    TempAdapterStatus.recv_success = Device->Statistics.DataFramesReceived; // SuccessfulReceive

    TempAdapterStatus.iframe_xmit_err = (WORD)Device->Statistics.DataFramesResent; // XmitRetries
    TempAdapterStatus.recv_buff_unavail = (WORD)Device->Statistics.DataFramesRejected; // ExhaustedResource

    // t1_timeouts, ti_timeouts, and reserved1 are unused.

    TempAdapterStatus.free_ncbs = 0xffff;     // FreeBlocks
    TempAdapterStatus.max_cfg_ncbs = 0xffff;  // ConfiguredNCB
    TempAdapterStatus.max_ncbs = 0xffff;      // MaxNCB

    // xmit_bug_unavail and max_dgram_size are unused.

    TempAdapterStatus.pending_sess = (WORD)Device->Statistics.OpenConnections; // CurrentSessions
    TempAdapterStatus.max_cfg_sess = 0xffff;  // MaxSessionConfigured
    TempAdapterStatus.max_sess = 0xffff;      // MaxSessionPossible
    TempAdapterStatus.max_sess_pkt_size = (USHORT)
        (Device->Bind.LineInfo.MaximumSendSize - sizeof(NB_CONNECTION)); // MaxSessionPacketSize

    TempAdapterStatus.name_count = 0;


    //
    // Do a quick estimate of how many names we need room for.
    // This includes stopping addresses and the broadcast
    // address, for the moment.
    //

    NB_GET_LOCK (&Device->Lock, &LockHandle);

    LengthNeeded = sizeof(ADAPTER_STATUS) + (Device->AddressCount * sizeof(NAME_BUFFER));

    if (LengthNeeded > MaximumLength) {
        LengthNeeded = MaximumLength;
    }

    AdapterStatus = NbiAllocateMemory(LengthNeeded, MEMORY_STATUS, "Adapter Status");
    if (AdapterStatus == NULL) {
        NB_FREE_LOCK (&Device->Lock, LockHandle);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *StatusBuffer = AdapterStatus;
    *StatusBufferLength = LengthNeeded;

    if (LengthNeeded < sizeof(ADAPTER_STATUS)) {
        RtlCopyMemory (AdapterStatus, &TempAdapterStatus, LengthNeeded);
        *ValidBufferLength = LengthNeeded;
        NB_FREE_LOCK (&Device->Lock, LockHandle);
        return STATUS_BUFFER_OVERFLOW;
    }

    RtlCopyMemory (AdapterStatus, &TempAdapterStatus, sizeof(ADAPTER_STATUS));

    BytesWritten = sizeof(ADAPTER_STATUS);
    NameBuffer = (PNAME_BUFFER)(AdapterStatus+1);
    NameCount = 0;

    //
    // Scan through the device's address database, filling in
    // the NAME_BUFFERs.
    //

    Status = STATUS_SUCCESS;

    for (p = Device->AddressDatabase.Flink;
         p != &Device->AddressDatabase;
         p = p->Flink) {

        Address = CONTAINING_RECORD (p, ADDRESS, Linkage);

        //
        // Ignore addresses that are shutting down.
        //

#if     defined(_PNP_POWER)
        if ((Address->State != ADDRESS_STATE_OPEN) ||
            (Address->Flags & ADDRESS_FLAGS_CONFLICT)) {
            continue;
        }
#else
        if ((Address->State != ADDRESS_STATE_OPEN) != 0) {
            continue;
        }
#endif  _PNP_POWER

        //
        // Ignore the broadcast address.
        //

        if (Address->NetbiosAddress.Broadcast) {
            continue;
        }

        //
        // Ignore our reserved address.
        //
#if defined(_PNP_POWER)
        if ( NbiFindAdapterAddress(
                Address->NetbiosAddress.NetbiosName,
                LOCK_ACQUIRED
                )) {
            continue;
        }
#else
        if (RtlEqualMemory(
                Address->NetbiosAddress.NetbiosName,
                Device->ReservedNetbiosName,
                16)) {
            continue;
        }

#endif  _PNP_POWER
        //
        // Make sure we still have room.
        //

        if (BytesWritten + sizeof(NAME_BUFFER) > LengthNeeded) {
            Status = STATUS_BUFFER_OVERFLOW;
            break;
        }

        RtlCopyMemory(
            NameBuffer->name,
            Address->NetbiosAddress.NetbiosName,
            16);

        ++NameCount;
        NameBuffer->name_num = NameCount;

        NameBuffer->name_flags = REGISTERED;
        if (Address->NameTypeFlag == NB_NAME_GROUP) {
            NameBuffer->name_flags |= GROUP_NAME;
        }

        BytesWritten += sizeof(NAME_BUFFER);
        ++NameBuffer;

    }

    AdapterStatus->name_count = (WORD)NameCount;
    *ValidBufferLength = BytesWritten;
    NB_FREE_LOCK (&Device->Lock, LockHandle);
    return Status;

}   /* NbiStoreAdapterStatus */


VOID
NbiUpdateNetbiosFindName(
    IN PREQUEST Request,
#if     defined(_PNP_POWER)
    IN PNIC_HANDLE NicHandle,
#else
    IN USHORT NicId,
#endif  _PNP_POWER
    IN TDI_ADDRESS_IPX UNALIGNED * RemoteIpxAddress,
    IN BOOLEAN Unique
    )

/*++

Routine Description:

    This routine updates the find name request with the
    new information received. It updates the status in
    the request if needed.

Arguments:

    Request - The netbios find name request.

    NicId - The NIC ID the response was received on.

    RemoteIpxAddress - The IPX address of the remote.

    Unique - TRUE if the name is unique.

Return Value:

    None.

--*/

{
    FIND_NAME_HEADER UNALIGNED * FindNameHeader = NULL;
    FIND_NAME_BUFFER UNALIGNED * FindNameBuffer;
    UINT FindNameBufferLength;
    TDI_ADDRESS_IPX LocalIpxAddress;
    IPX_SOURCE_ROUTING_INFO SourceRoutingInfo;
    NTSTATUS QueryStatus;
    UINT i;


    NdisQueryBufferSafe (REQUEST_NDIS_BUFFER(Request), (PVOID *)&FindNameHeader, &FindNameBufferLength,
                         HighPagePriority);
    if (!FindNameHeader)
    {
        return;
    }

    //
    // Scan through the names saved so far and see if this one
    // is there.
    //
    FindNameBuffer = (FIND_NAME_BUFFER UNALIGNED *)(FindNameHeader+1);
    for (i = 0; i < FindNameHeader->node_count; i++) {

        if (RtlEqualMemory(
                FindNameBuffer->source_addr,
                RemoteIpxAddress->NodeAddress,
                6)) {

            //
            // This remote already responded, ignore it.
            //

            return;

        }

        FindNameBuffer = (FIND_NAME_BUFFER UNALIGNED *) (((PUCHAR)FindNameBuffer) + 33);
    }

    //
    // Make sure there is room for this new node. 33 is
    // sizeof(FIND_NAME_BUFFER) without padding.
    //

    if (FindNameBufferLength < sizeof(FIND_NAME_HEADER) + ((FindNameHeader->node_count+1) * 33)) {
        REQUEST_STATUS(Request) = STATUS_BUFFER_OVERFLOW;
        return;
    }

    //
    // Query the local address, which we will return as
    // the destination address of this query.
    //

#if     defined(_PNP_POWER)
    if( (*NbiDevice->Bind.QueryHandler)(   // Check return code
        IPX_QUERY_IPX_ADDRESS,
        NicHandle,
        &LocalIpxAddress,
        sizeof(TDI_ADDRESS_IPX),
        NULL) != STATUS_SUCCESS ) {
        //
        // Ignore this response if the query fails. maybe the NicHandle
        // is bad or it just got removed.
        //
        NB_DEBUG( QUERY, ("Ipx Query %d failed for Nic %x\n",IPX_QUERY_IPX_ADDRESS,
                            NicHandle->NicId ));
        return;
    }
#else
    (VOID)(*NbiDevice->Bind.QueryHandler)(   // Check return code
        IPX_QUERY_IPX_ADDRESS,
        NicId,
        &LocalIpxAddress,
        sizeof(TDI_ADDRESS_IPX),
        NULL);
#endif  _PNP_POWER

    FindNameBuffer->access_control = 0x10;   // standard token-ring values
    FindNameBuffer->frame_control = 0x40;
    RtlMoveMemory (FindNameBuffer->destination_addr, LocalIpxAddress.NodeAddress, 6);
    RtlCopyMemory (FindNameBuffer->source_addr, RemoteIpxAddress->NodeAddress, 6);

    //
    // Query source routing information about this remote, if any.
    //

    SourceRoutingInfo.Identifier = IDENTIFIER_NB;
    RtlCopyMemory (SourceRoutingInfo.RemoteAddress, RemoteIpxAddress->NodeAddress, 6);

    QueryStatus = (*NbiDevice->Bind.QueryHandler)(
        IPX_QUERY_SOURCE_ROUTING,
#if     defined(_PNP_POWER)
        NicHandle,
#else
        NicId,
#endif  _PNP_POWER
        &SourceRoutingInfo,
        sizeof(IPX_SOURCE_ROUTING_INFO),
        NULL);

    RtlZeroMemory(FindNameBuffer->routing_info, 18);
    if (QueryStatus != STATUS_SUCCESS) {
        SourceRoutingInfo.SourceRoutingLength = 0;
    } else if (SourceRoutingInfo.SourceRoutingLength > 0) {
        RtlMoveMemory(
            FindNameBuffer->routing_info,
            SourceRoutingInfo.SourceRouting,
            SourceRoutingInfo.SourceRoutingLength);
    }

    FindNameBuffer->length = (UCHAR)(14 + SourceRoutingInfo.SourceRoutingLength);

    ++FindNameHeader->node_count;
    if (!Unique) {
        FindNameHeader->unique_group = 1;   // group
    }

    REQUEST_STATUS(Request) = STATUS_SUCCESS;

}   /* NbiUpdateNetbiosFindName */


VOID
NbiSetNetbiosFindNameInformation(
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine sets the REQUEST_INFORMATION field to the right
    value based on the number of responses recorded in the netbios
    find name request's buffer.

Arguments:

    Request - The netbios find name request.

Return Value:

    None.

--*/

{
    FIND_NAME_HEADER UNALIGNED * FindNameHeader = NULL;
    UINT FindNameBufferLength;


    NdisQueryBufferSafe (REQUEST_NDIS_BUFFER(Request), (PVOID *)&FindNameHeader, &FindNameBufferLength,
                         HighPagePriority);
    if (FindNameHeader)
    {
        //
        // 33 is sizeof(FIND_NAME_BUFFER) without the padding.
        //
        REQUEST_INFORMATION(Request) = sizeof(FIND_NAME_HEADER) + (FindNameHeader->node_count * 33);
    }

}   /* NbiSetNetbiosFindNameInformation */


NTSTATUS
NbiTdiSetInformation(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine performs the TdiSetInformation request for the transport
    provider.

Arguments:

    Device - the device.

    Request - the request for the operation.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    UNREFERENCED_PARAMETER (Device);
    UNREFERENCED_PARAMETER (Request);

    return STATUS_NOT_IMPLEMENTED;

}   /* NbiTdiSetInformation */


VOID
NbiProcessStatusQuery(
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR PacketBuffer,
    IN UINT PacketSize
    )

/*++

Routine Description:

    This routine handles NB_CMD_STATUS_QUERY frames.

Arguments:

    RemoteAddress - The local target this packet was received from.

    MacOptions - The MAC options for the underlying NDIS binding.

    LookaheadBuffer - The packet data, starting at the IPX
        header.

    PacketSize - The total length of the packet, starting at the
        IPX header.

Return Value:

    None.

--*/

{
    PSLIST_ENTRY s;
    PNB_SEND_RESERVED Reserved;
    PNDIS_PACKET Packet;
    NB_CONNECTIONLESS UNALIGNED * Header;
    NDIS_STATUS NdisStatus;
    IPX_LINE_INFO LineInfo;
    ULONG ResponseSize;
    NTSTATUS Status;
    PNDIS_BUFFER AdapterStatusBuffer;
    PADAPTER_STATUS AdapterStatus;
    ULONG AdapterStatusLength;
    ULONG ValidStatusLength;
    PDEVICE Device = NbiDevice;
    NB_CONNECTIONLESS UNALIGNED * Connectionless =
                        (NB_CONNECTIONLESS UNALIGNED *)PacketBuffer;


    //
    // The old stack does not include the 14 bytes of padding in
    // the 802.3 or IPX length of the packet.
    //

    if (PacketSize < (sizeof(IPX_HEADER) + 2)) {
        return;
    }

    //
    // Get the maximum size we can send.
    //
#if     defined(_PNP_POWER)
    if( (*Device->Bind.QueryHandler)(   // Check return code
        IPX_QUERY_LINE_INFO,
        &RemoteAddress->NicHandle,
        &LineInfo,
        sizeof(IPX_LINE_INFO),
        NULL) != STATUS_SUCCESS ) {
        //
        // Bad NicHandle or it just got removed.
        //
        NB_DEBUG( QUERY, ("Ipx Query %d failed for Nic %x\n",IPX_QUERY_LINE_INFO,
                            RemoteAddress->NicHandle.NicId ));

        return;
    }

    //
    // Allocate a packet from the pool.
    //

    s = NbiPopSendPacket(Device, FALSE);
    if (s == NULL) {
        return;
    }
#else
    //
    // Allocate a packet from the pool.
    //

    s = NbiPopSendPacket(Device, FALSE);
    if (s == NULL) {
        return;
    }

    //
    // Get the maximum size we can send.
    //

    (VOID)(*Device->Bind.QueryHandler)(   // Check return code
        IPX_QUERY_LINE_INFO,
        RemoteAddress->NicId,
        &LineInfo,
        sizeof(IPX_LINE_INFO),
        NULL);
#endif  _PNP_POWER

    ResponseSize = LineInfo.MaximumSendSize - sizeof(IPX_HEADER) - sizeof(NB_STATUS_RESPONSE);

    //
    // Get the local adapter status (this allocates a buffer).
    //

    Status = NbiStoreAdapterStatus(
                 ResponseSize,
#if     defined(_PNP_POWER)
                 RemoteAddress->NicHandle.NicId,
#else
                 RemoteAddress->NicId,
#endif  _PNP_POWER
                 &AdapterStatus,
                 &AdapterStatusLength,
                 &ValidStatusLength);

    if (Status == STATUS_INSUFFICIENT_RESOURCES) {
        ExInterlockedPushEntrySList(
            &Device->SendPacketList,
            s,
            &NbiGlobalPoolInterlock);
        return;
    }

    //
    // Allocate an NDIS buffer to map the extra buffer.
    //

    NdisAllocateBuffer(
        &NdisStatus,
        &AdapterStatusBuffer,
        Device->NdisBufferPoolHandle,
        AdapterStatus,
        ValidStatusLength);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        NbiFreeMemory (AdapterStatus, AdapterStatusLength, MEMORY_STATUS, "Adapter Status");
        ExInterlockedPushEntrySList(
            &Device->SendPacketList,
            s,
            &NbiGlobalPoolInterlock);
        return;
    }

    NB_DEBUG2 (QUERY, ("Reply to AdapterStatus from %lx %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x\n",
                           *(UNALIGNED ULONG *)Connectionless->IpxHeader.SourceNetwork,
                           Connectionless->IpxHeader.SourceNode[0],
                           Connectionless->IpxHeader.SourceNode[1],
                           Connectionless->IpxHeader.SourceNode[2],
                           Connectionless->IpxHeader.SourceNode[3],
                           Connectionless->IpxHeader.SourceNode[4],
                           Connectionless->IpxHeader.SourceNode[5]));

    Reserved = CONTAINING_RECORD (s, NB_SEND_RESERVED, PoolLinkage);
    Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);

    CTEAssert (Reserved->SendInProgress == FALSE);
    Reserved->SendInProgress = TRUE;
    Reserved->Type = SEND_TYPE_STATUS_RESPONSE;
    Reserved->u.SR_AS.ActualBufferLength = AdapterStatusLength;

    //
    // Fill in the IPX header -- the default header has the broadcast
    // address on net 0 as the destination IPX address.
    //

    Header = (NB_CONNECTIONLESS UNALIGNED *)
                (&Reserved->Header[Device->Bind.IncludedHeaderOffset]);
    RtlCopyMemory((PVOID)&Header->IpxHeader, &Device->ConnectionlessHeader, sizeof(IPX_HEADER));
    RtlCopyMemory(&Header->IpxHeader.DestinationNetwork, Connectionless->IpxHeader.SourceNetwork, 12);

    Header->IpxHeader.PacketLength[0] = (UCHAR)((sizeof(IPX_HEADER)+sizeof(NB_STATUS_RESPONSE)+ValidStatusLength) / 256);
    Header->IpxHeader.PacketLength[1] = (UCHAR)((sizeof(IPX_HEADER)+sizeof(NB_STATUS_RESPONSE)+ValidStatusLength) % 256);

    Header->IpxHeader.PacketType = 0x04;

    //
    // Now fill in the Netbios header.
    //

    Header->StatusResponse.ConnectionControlFlag = 0x00;
    Header->StatusResponse.DataStreamType = NB_CMD_STATUS_RESPONSE;

    NbiReferenceDevice (Device, DREF_STATUS_RESPONSE);

    NdisChainBufferAtBack (Packet, AdapterStatusBuffer);


    //
    // Now send the frame, IPX will adjust the length of the
    // first buffer correctly.
    //

    NdisAdjustBufferLength(NB_GET_NBHDR_BUFF(Packet), sizeof(IPX_HEADER) + sizeof(NB_STATUS_RESPONSE));
    if ((NdisStatus =
        (*Device->Bind.SendHandler)(
            RemoteAddress,
            Packet,
            sizeof(IPX_HEADER) + sizeof(NB_STATUS_RESPONSE) + ValidStatusLength,
            sizeof(IPX_HEADER) + sizeof(NB_STATUS_RESPONSE))) != STATUS_PENDING) {

        NbiSendComplete(
            Packet,
            NdisStatus);

    }

}   /* NbiProcessStatusQuery */


VOID
NbiSendStatusQuery(
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine sends NB_CMD_STATUS_QUERY frames.

Arguments:

    Request - Holds the request describing the remote adapter
        status query. REQUEST_STATUS(Request) points
        to the netbios cache entry for the remote name.

Return Value:

    None.

--*/

{
    PSLIST_ENTRY s;
    PNB_SEND_RESERVED Reserved;
    PNDIS_PACKET Packet;
    NB_CONNECTIONLESS UNALIGNED * Header;
    NDIS_STATUS NdisStatus;
    PNETBIOS_CACHE CacheName;
    PIPX_LOCAL_TARGET LocalTarget;
    PDEVICE Device = NbiDevice;

    //
    // Allocate a packet from the pool.
    //

    s = NbiPopSendPacket(Device, FALSE);
    if (s == NULL) {
        return;
    }

    Reserved = CONTAINING_RECORD (s, NB_SEND_RESERVED, PoolLinkage);
    Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);

    CTEAssert (Reserved->SendInProgress == FALSE);
    Reserved->SendInProgress = TRUE;
    Reserved->Type = SEND_TYPE_STATUS_QUERY;

    CacheName = (PNETBIOS_CACHE)REQUEST_STATUSPTR(Request);

    //
    // Fill in the IPX header -- the default header has the broadcast
    // address on net 0 as the destination IPX address.
    //

    Header = (NB_CONNECTIONLESS UNALIGNED *)
                (&Reserved->Header[Device->Bind.IncludedHeaderOffset]);
    RtlCopyMemory((PVOID)&Header->IpxHeader, &Device->ConnectionlessHeader, sizeof(IPX_HEADER));
    RtlCopyMemory (Header->IpxHeader.DestinationNetwork, &CacheName->FirstResponse, 12);

    LocalTarget = &CacheName->Networks[0].LocalTarget;

    Header->IpxHeader.PacketLength[0] = (sizeof(IPX_HEADER)+sizeof(NB_STATUS_QUERY)) / 256;
    Header->IpxHeader.PacketLength[1] = (sizeof(IPX_HEADER)+sizeof(NB_STATUS_QUERY)) % 256;

    Header->IpxHeader.PacketType = 0x04;

    //
    // Now fill in the Netbios header.
    //

    Header->StatusResponse.ConnectionControlFlag = 0x00;
    Header->StatusResponse.DataStreamType = NB_CMD_STATUS_QUERY;

    NbiReferenceDevice (Device, DREF_STATUS_FRAME);


    //
    // Now send the frame, IPX will adjust the length of the
    // first buffer correctly.
    //

    NdisAdjustBufferLength(NB_GET_NBHDR_BUFF(Packet), sizeof(IPX_HEADER) + sizeof(NB_STATUS_QUERY));
    if ((NdisStatus =
        (*Device->Bind.SendHandler)(
            LocalTarget,
            Packet,
            sizeof(IPX_HEADER) + sizeof(NB_STATUS_QUERY),
            sizeof(IPX_HEADER) + sizeof(NB_STATUS_QUERY))) != STATUS_PENDING) {

        NbiSendComplete(
            Packet,
            NdisStatus);

    }

}   /* NbiProcessStatusQuery */


VOID
NbiProcessStatusResponse(
    IN NDIS_HANDLE MacBindingHandle,
    IN NDIS_HANDLE MacReceiveContext,
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR LookaheadBuffer,
    IN UINT LookaheadBufferSize,
    IN UINT LookaheadBufferOffset,
    IN UINT PacketSize
    )

/*++

Routine Description:

    This routine handles NB_CMD_STATUS_RESPONSE frames.

Arguments:

    MacBindingHandle - A handle to use when calling NdisTransferData.

    MacReceiveContext - A context to use when calling NdisTransferData.

    RemoteAddress - The local target this packet was received from.

    MacOptions - The MAC options for the underlying NDIS binding.

    LookaheadBuffer - The lookahead buffer, starting at the IPX
        header.

    LookaheadBufferSize - The length of the lookahead data.

    LookaheadBufferOffset - The offset to add when calling
        NdisTransferData.

    PacketSize - The total length of the packet, starting at the
        IPX header.

Return Value:

    None.

--*/

{
    PDEVICE Device = NbiDevice;
    CTELockHandle LockHandle;
    PREQUEST AdapterStatusRequest;
    PNETBIOS_CACHE CacheName;
    PLIST_ENTRY p;
    PSLIST_ENTRY s;
    PNDIS_BUFFER TargetBuffer;
    ULONG TargetBufferLength, BytesToTransfer;
    ULONG BytesTransferred;
    NDIS_STATUS NdisStatus;
    PNB_RECEIVE_RESERVED ReceiveReserved;
    PNDIS_PACKET Packet;
    BOOLEAN Found;
    PNAME_BUFFER    NameBuffer;
    UINT            i,NameCount = 0;
    NB_CONNECTIONLESS UNALIGNED * Connectionless =
                        (NB_CONNECTIONLESS UNALIGNED *)LookaheadBuffer;


    if (PacketSize < (sizeof(IPX_HEADER) + sizeof(NB_STATUS_RESPONSE))) {
        return;
    }

    //
    // Find out how many names are there.
    //
    NameBuffer = (PNAME_BUFFER)(LookaheadBuffer + sizeof(IPX_HEADER) + sizeof(NB_STATUS_RESPONSE) + sizeof(ADAPTER_STATUS));
    if ( LookaheadBufferSize > sizeof(IPX_HEADER) + sizeof(NB_STATUS_RESPONSE) + sizeof(ADAPTER_STATUS) ) {
        NameCount =  (LookaheadBufferSize - (sizeof(IPX_HEADER) + sizeof(NB_STATUS_RESPONSE) + sizeof(ADAPTER_STATUS)) ) /
                        sizeof(NAME_BUFFER);
    }
    //
    // Find a request queued to this remote. If there are
    // multiple requests outstanding for the same name we
    // should get multiple responses, so we only need to
    // find one.
    //

    NB_GET_LOCK (&Device->Lock, &LockHandle);

    Found = FALSE;
    p = Device->ActiveAdapterStatus.Flink;

    while (p != &Device->ActiveAdapterStatus) {

        AdapterStatusRequest = LIST_ENTRY_TO_REQUEST(p);
        p = p->Flink;

        CacheName = (PNETBIOS_CACHE)REQUEST_STATUSPTR(AdapterStatusRequest);
        if ( CacheName->Unique ) {
            if (RtlEqualMemory(
                    &CacheName->FirstResponse,
                    Connectionless->IpxHeader.SourceNetwork,
                    12)) {
                Found = TRUE;
                break;
            }
        } else if ( RtlEqualMemory( CacheName->NetbiosName,NetbiosBroadcastName,16)){
            //
            // It's a broadcast name. Any response is fine.
            //
            Found = TRUE;
            break;
        } else {
            //
            //  It's group name. Make sure that this remote
            //  has this group name registered with him.
            //
            for (i =0;i<NameCount;i++) {
                if ( (RtlEqualMemory(
                        CacheName->NetbiosName,
                        NameBuffer[i].name,
                        16)) &&

                     (NameBuffer[i].name_flags & GROUP_NAME) ) {

                    Found = TRUE;
                    break;
                }
            }
        }

    }

    if (!Found) {
        NB_FREE_LOCK (&Device->Lock, LockHandle);
        return;
    }

    NB_DEBUG2 (QUERY, ("Got response to AdapterStatus %lx\n", AdapterStatusRequest));

    RemoveEntryList (REQUEST_LINKAGE(AdapterStatusRequest));

    if (--CacheName->ReferenceCount == 0) {

        NB_DEBUG2 (CACHE, ("Free delete name cache entry %lx\n", CacheName));
        NbiFreeMemory(
            CacheName,
            sizeof(NETBIOS_CACHE) + ((CacheName->NetworksAllocated-1) * sizeof(NETBIOS_NETWORK)),
            MEMORY_CACHE,
            "Name deleted");

    }

    NB_FREE_LOCK (&Device->Lock, LockHandle);

    s = NbiPopReceivePacket (Device);
    if (s == NULL) {

        REQUEST_INFORMATION (AdapterStatusRequest) = 0;
        REQUEST_STATUS (AdapterStatusRequest) = STATUS_INSUFFICIENT_RESOURCES;

        NbiCompleteRequest (AdapterStatusRequest);
        NbiFreeRequest (Device, AdapterStatusRequest);

        NbiDereferenceDevice (Device, DREF_STATUS_QUERY);

        return;
    }

    ReceiveReserved = CONTAINING_RECORD (s, NB_RECEIVE_RESERVED, PoolLinkage);
    Packet = CONTAINING_RECORD (ReceiveReserved, NDIS_PACKET, ProtocolReserved[0]);

    //
    // Initialize the receive packet.
    //

    ReceiveReserved->Type = RECEIVE_TYPE_ADAPTER_STATUS;
    ReceiveReserved->u.RR_AS.Request = AdapterStatusRequest;
    REQUEST_STATUS(AdapterStatusRequest) = STATUS_SUCCESS;
    CTEAssert (!ReceiveReserved->TransferInProgress);
    ReceiveReserved->TransferInProgress = TRUE;

    //
    // Now that we have a packet and a buffer, set up the transfer.
    // We will complete the request when the transfer completes.
    //

    TargetBuffer = REQUEST_NDIS_BUFFER (AdapterStatusRequest);

    NdisChainBufferAtFront (Packet, TargetBuffer);

    NbiGetBufferChainLength (TargetBuffer, &TargetBufferLength);
    BytesToTransfer = PacketSize - (sizeof(IPX_HEADER) + sizeof(NB_STATUS_RESPONSE));
    if (TargetBufferLength < BytesToTransfer) {
        BytesToTransfer = TargetBufferLength;
        REQUEST_STATUS(AdapterStatusRequest) = STATUS_BUFFER_OVERFLOW;
    }

    (*Device->Bind.TransferDataHandler) (
        &NdisStatus,
        MacBindingHandle,
        MacReceiveContext,
        LookaheadBufferOffset + (sizeof(IPX_HEADER) + sizeof(NB_STATUS_RESPONSE)),
        BytesToTransfer,
        Packet,
        &BytesTransferred);

    if (NdisStatus != NDIS_STATUS_PENDING) {
#if DBG
        if (NdisStatus == STATUS_SUCCESS) {
            CTEAssert (BytesTransferred == BytesToTransfer);
        }
#endif

        NbiTransferDataComplete(
            Packet,
            NdisStatus,
            BytesTransferred);

    }

}   /* NbiProcessStatusResponse */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\fwddecls.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    fwddecls.h				

Abstract:


Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:


--*/

struct _SPX_ADDR      ;
struct _SPX_ADDR_FILE ;
struct _SPX_CONN_FILE ;
struct _SPX_SEND_RESD ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\nb\session.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    session.c

Abstract:

    This module contains the code to handle session frames
    for the Netbios module of the ISN transport.

Author:

    Adam Barr (adamba) 28-November-1993

Environment:

    Kernel mode

Revision History:


--*/

#include "precomp.h"
#ifdef RASAUTODIAL
#include <acd.h>
#include <acdapi.h>
#endif // RASAUTODIAL
#pragma hdrstop

#ifdef RASAUTODIAL
extern BOOLEAN fAcdLoadedG;
extern ACD_DRIVER AcdDriverG;

VOID
NbiNoteNewConnection(
    PCONNECTION pConnection
    );
#endif

#ifdef  RSRC_TIMEOUT_DBG
VOID
NbiSendDeathPacket(
    IN PCONNECTION  Connection,
    IN CTELockHandle    LockHandle
    )
{
    PNDIS_PACKET  Packet = PACKET(&NbiGlobalDeathPacket);
    PNB_SEND_RESERVED Reserved = (PNB_SEND_RESERVED)(Packet->ProtocolReserved);
    NB_CONNECTION UNALIGNED * Header;
    PDEVICE Device = NbiDevice;
    NDIS_STATUS NdisStatus;

    if ( Reserved->SendInProgress ) {
        DbgPrint("***Could not send death packet - in use\n");
        NB_FREE_LOCK(&Connection->Lock, LockHandle);
        return;
    }

    Reserved->SendInProgress = TRUE;
    Reserved->Type = SEND_TYPE_DEATH_PACKET;

    //
    // Fill in the IPX header -- the default header has the broadcast
    // address on net 0 as the destination IPX address.
    //

    Header = (NB_CONNECTION UNALIGNED *)
                (&Reserved->Header[Device->Bind.IncludedHeaderOffset]);
    RtlCopyMemory((PVOID)&Header->IpxHeader, &Connection->RemoteHeader, sizeof(IPX_HEADER));

    Header->IpxHeader.PacketLength[0] = (sizeof(NB_CONNECTION)) / 256;
    Header->IpxHeader.PacketLength[1] = (sizeof(NB_CONNECTION)) % 256;

    Header->IpxHeader.PacketType = 0x04;

    //
    // Now fill in the Netbios header.
    //
    Header->Session.ConnectionControlFlag = 0;
    Header->Session.DataStreamType = NB_CMD_DEATH_PACKET;
    Header->Session.SourceConnectionId = Connection->LocalConnectionId;
    Header->Session.DestConnectionId = Connection->RemoteConnectionId;
    Header->Session.SendSequence = 0;
    Header->Session.TotalDataLength = 0;
    Header->Session.Offset = 0;
    Header->Session.DataLength = 0;


    NB_FREE_LOCK(&Connection->Lock, LockHandle);

    DbgPrint("*****Death packet is being sent for connection %lx, to <%.16s>\n",Connection, Connection->RemoteName);
    //
    // Now send the frame, IPX will adjust the length of the
    // first buffer correctly.
    //

    NdisAdjustBufferLength(NB_GET_NBHDR_BUFF(Packet), sizeof(NB_CONNECTION));
    if ((NdisStatus =
        (*Device->Bind.SendHandler)(
            &Connection->LocalTarget,
            Packet,
            sizeof(NB_CONNECTION),
            sizeof(NB_CONNECTION))) != STATUS_PENDING) {

        NbiSendComplete(
            Packet,
            NdisStatus);

    }

}
#endif  //RSRC_TIMEOUT_DBG


VOID
NbiProcessSessionData(
    IN NDIS_HANDLE MacBindingHandle,
    IN NDIS_HANDLE MacReceiveContext,
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR LookaheadBuffer,
    IN UINT LookaheadBufferSize,
    IN UINT LookaheadBufferOffset,
    IN UINT PacketSize
    )

/*++

Routine Description:

    This routine handles NB_CMD_SESSION_DATA frames.

Arguments:

    MacBindingHandle - A handle to use when calling NdisTransferData.

    MacReceiveContext - A context to use when calling NdisTransferData.

    RemoteAddress - The local target this packet was received from.

    MacOptions - The MAC options for the underlying NDIS binding.

    LookaheadBuffer - The lookahead buffer, starting at the IPX
        header.

    LookaheadBufferSize - The length of the lookahead data.

    LookaheadBufferOffset - The offset to add when calling
        NdisTransferData.

    PacketSize - The total length of the packet, starting at the
        IPX header.

Return Value:

    None.

--*/

{
    NB_CONNECTION UNALIGNED * Conn = (NB_CONNECTION UNALIGNED *)LookaheadBuffer;
    NB_SESSION UNALIGNED * Sess = (NB_SESSION UNALIGNED *)(&Conn->Session);
    PCONNECTION Connection;
    PREQUEST Request;
    PDEVICE Device = NbiDevice;
    ULONG Hash;
    ULONG ReceiveFlags;
    ULONG IndicateBytesTransferred = 0;
    ULONG DataAvailable, DataIndicated;
    ULONG DestBytes, BytesToTransfer;
    PUCHAR DataHeader;
    BOOLEAN Last, CompleteReceive, EndOfMessage, PartialReceive, CopyLookahead;
    NTSTATUS Status;
    NDIS_STATUS NdisStatus;
    ULONG NdisBytesTransferred;
    PIRP ReceiveIrp;
    PSLIST_ENTRY s;
    PNB_RECEIVE_RESERVED ReceiveReserved;
    PNDIS_PACKET Packet;
    PNDIS_BUFFER BufferChain;
    ULONG BufferChainLength;
    NB_DEFINE_LOCK_HANDLE (LockHandle)
    CTELockHandle   CancelLH;

    if (Sess->DestConnectionId != 0xffff) {

        //
        // This is an active connection, find it using
        // our session id.
        //

        Hash = (Sess->DestConnectionId & CONNECTION_HASH_MASK) >> CONNECTION_HASH_SHIFT;

        NB_SYNC_GET_LOCK (&Device->Lock, &LockHandle);

        Connection = Device->ConnectionHash[Hash].Connections;

        while (Connection != NULL) {

            if (Connection->LocalConnectionId == Sess->DestConnectionId) {
                break;
            }
            Connection = Connection->NextConnection;
        }

        if (Connection == NULL) {
            NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);
            return;
        }

        NbiReferenceConnectionLock (Connection, CREF_INDICATE);
        NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);

        //
        // See what is happening with this connection.
        //

        NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);

        if (Connection->State == CONNECTION_STATE_ACTIVE) {

#ifdef  RSRC_TIMEOUT_DBG
            if ( Connection->FirstMessageRequest && NbiGlobalDebugResTimeout ) {
                LARGE_INTEGER   CurrentTime, ElapsedTime;
                KeQuerySystemTime(&CurrentTime);
                ElapsedTime.QuadPart = CurrentTime.QuadPart - Connection->FirstMessageRequestTime.QuadPart;
//                DbgPrint("*****Elapsed %lx.%lx time\n",ElapsedTime.HighPart,ElapsedTime.LowPart);
                if ( ElapsedTime.QuadPart > NbiGlobalMaxResTimeout.QuadPart ) {

                    DbgPrint("*****Connection %lx is not copleting irp %lx for %lx.%lx time\n",Connection, Connection->FirstMessageRequest,
                        ElapsedTime.HighPart,ElapsedTime.LowPart);
                    DbgPrint("************irp arrived at %lx.%lx current time %lx.%lx\n",
                        Connection->FirstMessageRequestTime.HighPart,Connection->FirstMessageRequestTime.LowPart,
                        CurrentTime.HighPart, CurrentTime.LowPart);

                    NbiSendDeathPacket( Connection, LockHandle );

                    NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);
                }
            }
#endif  //RSRC_TIMEOUT_DBG

            //
            // The connection is up, see if this is data should
            // be received.
            //

            if (Sess->ConnectionControlFlag & NB_CONTROL_SYSTEM) {

                //
                // This is an ack. This call releases the lock.
                //

                NbiProcessDataAck(
                    Connection,
                    Sess,
                    RemoteAddress
                    NB_LOCK_HANDLE_ARG (LockHandle)
                    );

            } else {

                //
                // See if there is any piggyback ack here.
                //

                if (Connection->SubState == CONNECTION_SUBSTATE_A_W_ACK) {

                    //
                    // We are waiting for an ack, so see if this acks
                    // anything. Even the old netbios sometimes piggyback
                    // acks (and doesn't send the explicit ack).
                    //
                    // This releases the lock.
                    //

                    NbiReframeConnection(
                        Connection,
                        Sess->ReceiveSequence,
                        Sess->BytesReceived,
                        FALSE
                        NB_LOCK_HANDLE_ARG(LockHandle));

                    NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);

                    if (Connection->State != CONNECTION_STATE_ACTIVE) {
                        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
                        NbiDereferenceConnection (Connection, CREF_INDICATE);
                        return;
                    }

                } else if ((Connection->NewNetbios) &&
                           (Connection->CurrentSend.SendSequence != Connection->UnAckedSend.SendSequence)) {

                    //
                    // For the new netbios, even if we are not waiting
                    // for an ack he may have acked something with this
                    // send and we should check, since it may allow
                    // us to open our send window.
                    //
                    // This releases the lock.
                    //

                    NbiReframeConnection(
                        Connection,
                        Sess->ReceiveSequence,
                        Sess->BytesReceived,
                        FALSE
                        NB_LOCK_HANDLE_ARG(LockHandle));

                    NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);

                    if (Connection->State != CONNECTION_STATE_ACTIVE) {
                        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
                        NbiDereferenceConnection (Connection, CREF_INDICATE);
                        return;
                    }

                }

                //
                // This is data on the connection. First make sure
                // it is the data we expect next.
                //

                if (Connection->NewNetbios) {

                    if (Sess->SendSequence != Connection->ReceiveSequence) {

                        ++Connection->ConnectionInfo.ReceiveErrors;
                        ++Device->Statistics.DataFramesRejected;
                        ADD_TO_LARGE_INTEGER(
                            &Device->Statistics.DataFrameBytesRejected,
                            PacketSize - sizeof(NB_CONNECTION));

                        if ((Connection->ReceiveState == CONNECTION_RECEIVE_IDLE) ||
                            (Connection->ReceiveState == CONNECTION_RECEIVE_ACTIVE)) {

                            NB_ACK_TYPE AckType;

                            NB_DEBUG2 (RECEIVE, ("Got unexp data on %lx, %x(%d) expect %x(%d)\n",
                                Connection, Sess->SendSequence, Sess->Offset,
                                Connection->ReceiveSequence, Connection->CurrentReceive.MessageOffset));

                            //
                            // If we are receiving a packet we have already seen, just
                            // send a normal ack, otherwise force a resend. This test
                            // we do is equivalent to
                            //     Sess->SendSequence < Connection->ReceiveSequence
                            // but rearranged so it works when the numbers wrap.
                            //

                            if ((SHORT)(Sess->SendSequence - Connection->ReceiveSequence) < 0) {

                                //
                                // Since this is a resend, check if the local
                                // target has changed.
                                //
#if     defined(_PNP_POWER)

                                if (!RtlEqualMemory (&Connection->LocalTarget, RemoteAddress, sizeof(IPX_LOCAL_TARGET))) {
#if DBG
                                    DbgPrint ("NBI: Switch local target for %lx, (%d,%d)\n", Connection,
                                            Connection->LocalTarget.NicHandle.NicId, RemoteAddress->NicHandle.NicId);
#endif
                                    Connection->LocalTarget = *RemoteAddress;
                                }

#else

                                if (!RtlEqualMemory (&Connection->LocalTarget, RemoteAddress, 8)) {
#if DBG
                                    DbgPrint ("NBI: Switch local target for %lx\n", Connection);
#endif
                                    Connection->LocalTarget = *RemoteAddress;
                                }

#endif  _PNP_POWER
                                AckType = NbiAckResponse;

                            } else {

                                AckType = NbiAckResend;
                            }

                            //
                            // This frees the lock.
                            //

                            NbiSendDataAck(
                                Connection,
                                AckType
                                NB_LOCK_HANDLE_ARG(LockHandle));

                        } else {

                            NB_DEBUG (RECEIVE, ("Got unexp on %lx RcvState %d, %x(%d) exp %x(%d)\n",
                                Connection, Connection->ReceiveState,
                                Sess->SendSequence, Sess->Offset,
                                Connection->ReceiveSequence, Connection->CurrentReceive.MessageOffset));
                            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
                        }

                        NbiDereferenceConnection (Connection, CREF_INDICATE);
                        return;

                    }

                } else {

                    //
                    // Old netbios.
                    //

                    if ((Sess->SendSequence != Connection->ReceiveSequence) ||
                        (Sess->Offset != Connection->CurrentReceive.MessageOffset)) {

                        ++Connection->ConnectionInfo.ReceiveErrors;
                        ++Device->Statistics.DataFramesRejected;
                        ADD_TO_LARGE_INTEGER(
                            &Device->Statistics.DataFrameBytesRejected,
                            PacketSize - sizeof(NB_CONNECTION));

                        if ((Connection->ReceiveState == CONNECTION_RECEIVE_IDLE) ||
                            (Connection->ReceiveState == CONNECTION_RECEIVE_ACTIVE)) {

                            NB_ACK_TYPE AckType;

                            NB_DEBUG2 (RECEIVE, ("Got unexp on %lx, %x(%d) expect %x(%d)\n",
                                Connection, Sess->SendSequence, Sess->Offset,
                                Connection->ReceiveSequence, Connection->CurrentReceive.MessageOffset));

                            //
                            // If we are receiving the last packet again, just
                            // send a normal ack, otherwise force a resend.
                            //

                            if (((Sess->SendSequence == Connection->ReceiveSequence) &&
                                 ((ULONG)(Sess->Offset + Sess->DataLength) == Connection->CurrentReceive.MessageOffset)) ||
                                (Sess->SendSequence == (USHORT)(Connection->ReceiveSequence-1))) {
                                AckType = NbiAckResponse;
                            } else {
                                AckType = NbiAckResend;
                            }

                            //
                            // This frees the lock.
                            //

                            NbiSendDataAck(
                                Connection,
                                AckType
                                NB_LOCK_HANDLE_ARG(LockHandle));

                        } else {

                            NB_DEBUG (RECEIVE, ("Got unexp on %lx RcvState %d, %x(%d) exp %x(%d)\n",
                                Connection, Connection->ReceiveState,
                                Sess->SendSequence, Sess->Offset,
                                Connection->ReceiveSequence, Connection->CurrentReceive.MessageOffset));
                            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
                        }

                        NbiDereferenceConnection (Connection, CREF_INDICATE);
                        return;

                    }

                }

                DataAvailable = PacketSize - sizeof(NB_CONNECTION);
                DataIndicated = LookaheadBufferSize - sizeof(NB_CONNECTION);
                DataHeader = LookaheadBuffer + sizeof(NB_CONNECTION);

                ++Device->TempFramesReceived;
                Device->TempFrameBytesReceived += DataAvailable;

                if (Connection->CurrentIndicateOffset) {
                    CTEAssert (DataAvailable >= Connection->CurrentIndicateOffset);
                    DataAvailable -= Connection->CurrentIndicateOffset;
                    if (DataIndicated >= Connection->CurrentIndicateOffset) {
                        DataIndicated -= Connection->CurrentIndicateOffset;
                    } else {
                        DataIndicated = 0;
                    }
                    DataHeader += Connection->CurrentIndicateOffset;
                }

                CopyLookahead = (BOOLEAN)(MacOptions & NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA);

                if (Connection->NewNetbios) {
                    Last = (BOOLEAN)((Sess->ConnectionControlFlag & NB_CONTROL_EOM) != 0);
                } else {
                    Last = (BOOLEAN)(Sess->Offset + Sess->DataLength == Sess->TotalDataLength);
                }

                Connection->CurrentReceiveNoPiggyback =
                    (BOOLEAN)((Sess->ConnectionControlFlag & NB_CONTROL_SEND_ACK) != 0);

                if (Connection->ReceiveState == CONNECTION_RECEIVE_IDLE) {

                    //
                    // We don't have a receive posted, so see if we can
                    // get one from the queue or our client.
                    //

                    if (Connection->ReceiveQueue.Head != NULL) {

                        PTDI_REQUEST_KERNEL_RECEIVE ReceiveParameters;

                        Request = Connection->ReceiveQueue.Head;
                        Connection->ReceiveQueue.Head = REQUEST_SINGLE_LINKAGE(Request);
                        Connection->ReceiveState = CONNECTION_RECEIVE_ACTIVE;

                        Connection->ReceiveRequest = Request;
                        ReceiveParameters = (PTDI_REQUEST_KERNEL_RECEIVE)
                                                (REQUEST_PARAMETERS(Request));
                        Connection->ReceiveLength = ReceiveParameters->ReceiveLength;

                        //
                        // If there is a send in progress, then we assume
                        // we are not in straight request-response mode
                        // and disable piggybacking of this ack.
                        //

                        if (Connection->SubState != CONNECTION_SUBSTATE_A_IDLE) {
                            Connection->NoPiggybackHeuristic = TRUE;
                        } else {
                            Connection->NoPiggybackHeuristic = (BOOLEAN)
                                ((ReceiveParameters->ReceiveFlags & TDI_RECEIVE_NO_RESPONSE_EXP) != 0);
                        }

                        Connection->CurrentReceive.Offset = 0;
                        Connection->CurrentReceive.Buffer = REQUEST_NDIS_BUFFER (Request);
                        Connection->CurrentReceive.BufferOffset = 0;

                        NB_DEBUG2 (RECEIVE, ("Activated receive %lx on %lx (%d)\n", Request, Connection, Connection->ReceiveSequence));

                        //
                        // Fall through the if and process the data.
                        //

                    } else {

                        if ((Connection->ReceiveUnaccepted == 0) &&
                            (Connection->AddressFile->RegisteredHandler[TDI_EVENT_RECEIVE])) {

                            Connection->ReceiveState = CONNECTION_RECEIVE_INDICATE;
                            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

                            ReceiveFlags = TDI_RECEIVE_AT_DISPATCH_LEVEL;
                            if (Last) {
                                ReceiveFlags |= TDI_RECEIVE_ENTIRE_MESSAGE;
                            }
                            if (CopyLookahead) {
                                ReceiveFlags |= TDI_RECEIVE_COPY_LOOKAHEAD;
                            }

                            Status = (*Connection->AddressFile->ReceiveHandler)(
                                         Connection->AddressFile->HandlerContexts[TDI_EVENT_RECEIVE],
                                         Connection->Context,
                                         ReceiveFlags,
                                         DataIndicated,
                                         DataAvailable,
                                         &IndicateBytesTransferred,
                                         DataHeader,
                                         &ReceiveIrp);

                            if (Status == STATUS_MORE_PROCESSING_REQUIRED) {

                                //
                                // We got an IRP, activate it.
                                //

                                Request = NbiAllocateRequest (Device, ReceiveIrp);

                                IF_NOT_ALLOCATED(Request) {

                                    ReceiveIrp->IoStatus.Information = 0;
                                    ReceiveIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                                    IoCompleteRequest (ReceiveIrp, IO_NETWORK_INCREMENT);

                                    Connection->ReceiveState = CONNECTION_RECEIVE_W_RCV;

                                    if (Connection->NewNetbios) {

                                        NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);

                                        Connection->LocalRcvSequenceMax =
                                            (USHORT)(Connection->ReceiveSequence - 1);

                                        //
                                        // This releases the lock.
                                        //

                                        NbiSendDataAck(
                                            Connection,
                                            NbiAckResponse
                                            NB_LOCK_HANDLE_ARG(LockHandle));

                                    }

                                    NbiDereferenceConnection (Connection, CREF_INDICATE);
                                    return;

                                }

                                CTEAssert (REQUEST_OPEN_CONTEXT(Request) == Connection);

                                NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);

                                if (Connection->State == CONNECTION_STATE_ACTIVE) {

                                    PTDI_REQUEST_KERNEL_RECEIVE ReceiveParameters;

                                    Connection->ReceiveState = CONNECTION_RECEIVE_ACTIVE;
                                    Connection->ReceiveUnaccepted = DataAvailable - IndicateBytesTransferred;

                                    Connection->ReceiveRequest = Request;
                                    ReceiveParameters = (PTDI_REQUEST_KERNEL_RECEIVE)
                                                            (REQUEST_PARAMETERS(Request));
                                    Connection->ReceiveLength = ReceiveParameters->ReceiveLength;

                                    //
                                    // If there is a send in progress, then we assume
                                    // we are not in straight request-response mode
                                    // and disable piggybacking of this ack.
                                    //

                                    if (Connection->SubState != CONNECTION_SUBSTATE_A_IDLE) {
                                        Connection->NoPiggybackHeuristic = TRUE;
                                    } else {
                                        Connection->NoPiggybackHeuristic = (BOOLEAN)
                                            ((ReceiveParameters->ReceiveFlags & TDI_RECEIVE_NO_RESPONSE_EXP) != 0);
                                    }

                                    Connection->CurrentReceive.Offset = 0;
                                    Connection->CurrentReceive.Buffer = REQUEST_NDIS_BUFFER (Request);
                                    Connection->CurrentReceive.BufferOffset = 0;

                                    NbiReferenceConnectionSync (Connection, CREF_RECEIVE);

                                    NB_DEBUG2 (RECEIVE, ("Indicate got receive %lx on %lx (%d)\n", Request, Connection, Connection->ReceiveSequence));

                                    //
                                    // Fall through the if and process the data.
                                    //

                                } else {

                                    //
                                    // The connection has been stopped.
                                    //

                                    NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
                                    NbiDereferenceConnection (Connection, CREF_INDICATE);
                                    return;
                                }

                            } else if (Status == STATUS_SUCCESS) {

                                //
                                // He accepted some or all of the data.
                                //

                                NB_DEBUG2 (RECEIVE, ("Indicate took receive data %lx (%d)\n", Connection, Connection->ReceiveSequence));

                                if ( (IndicateBytesTransferred >= DataAvailable)) {

                                    CTEAssert (IndicateBytesTransferred == DataAvailable);

                                    NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);

                                    if (Connection->State == CONNECTION_STATE_ACTIVE) {

                                        ++Connection->ReceiveSequence;
                                        ++Connection->LocalRcvSequenceMax;  // harmless if NewNetbios is FALSE
                                        Connection->CurrentIndicateOffset = 0;
                                        if ( Last ) {
                                            Connection->CurrentReceive.MessageOffset = 0;
                                        } else {
                                            Connection->CurrentReceive.MessageOffset+= IndicateBytesTransferred;
                                        }


                                        ++Connection->ConnectionInfo.ReceivedTsdus;

                                        //
                                        // If there is a send in progress, then we assume
                                        // we are not in straight request-response mode
                                        // and disable piggybacking of this ack.
                                        //

                                        Connection->NoPiggybackHeuristic = (BOOLEAN)
                                            (Connection->SubState != CONNECTION_SUBSTATE_A_IDLE);

                                        Connection->ReceiveState = CONNECTION_RECEIVE_IDLE;
                                        Connection->ReceiveRequest = NULL;

                                        //
                                        // This releases the lock.
                                        //

                                        NbiAcknowledgeReceive(
                                            Connection
                                            NB_LOCK_HANDLE_ARG(LockHandle));

                                    } else {

                                        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

                                    }

                                } else {

                                    //
                                    // We will do the easiest thing here, which
                                    // is to send an ack for the amount he
                                    // took, and force a retransmit on the
                                    // remote. For net netbios we make a note
                                    // of how many bytes were taken and ask
                                    // for a resend.
                                    //

#if DBG
                                    DbgPrint ("NBI: Client took partial indicate data\n");
#endif

                                    NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);

                                    if (Connection->State == CONNECTION_STATE_ACTIVE) {

                                        Connection->CurrentReceive.MessageOffset +=
                                            IndicateBytesTransferred;
                                        Connection->ReceiveUnaccepted =
                                            DataAvailable - IndicateBytesTransferred;
                                        Connection->ReceiveState = CONNECTION_RECEIVE_W_RCV;

                                        if (Connection->NewNetbios) {
                                            Connection->CurrentIndicateOffset = IndicateBytesTransferred;
                                            //
                                            // NOTE: We don't advance ReceiveSequence
                                            //
                                        }

                                        //
                                        // This releases the lock.
                                        //

                                        NbiSendDataAck(
                                            Connection,
                                            Connection->NewNetbios ?
                                                NbiAckResend : NbiAckResponse
                                            NB_LOCK_HANDLE_ARG(LockHandle));

                                    } else {

                                        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

                                    }

                                }

                                NbiDereferenceConnection (Connection, CREF_INDICATE);
                                return;

                            } else {

                                //
                                // No IRP returned.
                                //

                                NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);

                                if (Connection->State == CONNECTION_STATE_ACTIVE) {

                                    Connection->ReceiveUnaccepted = DataAvailable;
                                    Connection->ReceiveState = CONNECTION_RECEIVE_W_RCV;
                                    NB_DEBUG (RECEIVE, ("Indicate got no receive on %lx (%lx)\n", Connection, Status));

                                    if (Connection->NewNetbios) {

                                        Connection->LocalRcvSequenceMax =
                                            (USHORT)(Connection->ReceiveSequence - 1);

                                        //
                                        // This releases the lock.
                                        //

                                        NbiSendDataAck(
                                            Connection,
                                            NbiAckResponse
                                            NB_LOCK_HANDLE_ARG(LockHandle));

                                    } else {

                                        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
                                    }

                                } else {

                                    NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
                                }

                                NbiDereferenceConnection (Connection, CREF_INDICATE);
                                return;

                            }

                        } else {

                            //
                            // No receive handler.
                            //

                            Connection->ReceiveState = CONNECTION_RECEIVE_W_RCV;
                            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
                            if (Connection->ReceiveUnaccepted == 0) {
                                NB_DEBUG (RECEIVE, ("No receive, no handler on %lx\n", Connection));
                            } else {
                                NB_DEBUG (RECEIVE, ("No receive, ReceiveUnaccepted %d on %lx\n",
                                    Connection->ReceiveUnaccepted, Connection));
                            }

                            if (Connection->NewNetbios) {

                                NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);

                                Connection->LocalRcvSequenceMax =
                                    (USHORT)(Connection->ReceiveSequence - 1);

                                //
                                // This releases the lock.
                                //

                                NbiSendDataAck(
                                    Connection,
                                    NbiAckResponse
                                    NB_LOCK_HANDLE_ARG(LockHandle));

                            }

                            NbiDereferenceConnection (Connection, CREF_INDICATE);
                            return;

                        }

                    }

                } else if (Connection->ReceiveState != CONNECTION_RECEIVE_ACTIVE) {

                    //
                    // If we have a transfer in progress, or are waiting for
                    // a receive to be posted, then ignore this frame.
                    //

                    NB_DEBUG2 (RECEIVE, ("Got data on %lx, state %d (%d)\n", Connection, Connection->ReceiveState, Connection->ReceiveSequence));
                    NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
                    NbiDereferenceConnection (Connection, CREF_INDICATE);
                    return;

                }
                else if (Connection->ReceiveUnaccepted)
                {
                    //
                    // Connection->ReceiveState == CONNECTION_RECEIVE_ACTIVE
                    //                          &&
                    //               Connection->ReceiveUnaccepted
                    //
                    Connection->ReceiveUnaccepted += DataAvailable;
                }

                //
                // At this point we have a receive and it is set to
                // the correct current location.
                //
                DestBytes = Connection->ReceiveLength - Connection->CurrentReceive.Offset;
                BytesToTransfer = DataAvailable - IndicateBytesTransferred;

                if (DestBytes < BytesToTransfer) {

                    //
                    // If the data overflows the current receive, then make a
                    // note that we should complete the receive at the end of
                    // transfer data, but with EOR false.
                    //

                    EndOfMessage = FALSE;
                    CompleteReceive = TRUE;
                    PartialReceive = TRUE;
                    BytesToTransfer = DestBytes;

                } else if (DestBytes == BytesToTransfer) {

                    //
                    // If the data just fills the current receive, then complete
                    // the receive; EOR depends on whether this is a DOL or not.
                    //

                    EndOfMessage = Last;
                    CompleteReceive = TRUE;
                    PartialReceive = FALSE;

                } else {

                    //
                    // Complete the receive if this is a DOL.
                    //

                    EndOfMessage = Last;
                    CompleteReceive = Last;
                    PartialReceive = FALSE;

                }

                //
                // If we can copy the data directly, then update our
                // pointers, send an ack, and do the copy.
                //

                if ((BytesToTransfer > 0) &&
                        (IndicateBytesTransferred + BytesToTransfer <= DataIndicated)) {

                    ULONG BytesNow, BytesLeft;
                    PUCHAR CurTarget = NULL, CurSource;
                    ULONG CurTargetLen;
                    PNDIS_BUFFER CurBuffer;
                    ULONG CurByteOffset;

                    NB_DEBUG2 (RECEIVE, ("Direct copy of %d bytes %lx (%d)\n", BytesToTransfer, Connection, Connection->ReceiveSequence));

                    Connection->ReceiveState = CONNECTION_RECEIVE_TRANSFER;

                    CurBuffer = Connection->CurrentReceive.Buffer;
                    CurByteOffset = Connection->CurrentReceive.BufferOffset;
                    CurSource = DataHeader + IndicateBytesTransferred;
                    BytesLeft = BytesToTransfer;

                    NdisQueryBufferSafe (CurBuffer, &CurTarget, &CurTargetLen, HighPagePriority);
                    if (CurTarget)
                    {
                        CurTarget += CurByteOffset;
                        CurTargetLen -= CurByteOffset;
                    }

                    while (CurTarget) {

                        if (CurTargetLen < BytesLeft) {
                            BytesNow = CurTargetLen;
                        } else {
                            BytesNow = BytesLeft;
                        }
                        TdiCopyLookaheadData(
                            CurTarget,
                            CurSource,
                            BytesNow,
                            CopyLookahead ? TDI_RECEIVE_COPY_LOOKAHEAD : 0);

                        if (BytesNow == CurTargetLen) {
                            BytesLeft -= BytesNow;
                            CurBuffer = CurBuffer->Next;
                            CurByteOffset = 0;
                            if (BytesLeft > 0) {
                                NdisQueryBufferSafe (CurBuffer, &CurTarget, &CurTargetLen, HighPagePriority);
                                CurSource += BytesNow;
                            } else {
                                break;
                            }
                        } else {
                            CurByteOffset += BytesNow;
                            CTEAssert (BytesLeft == BytesNow);
                            break;
                        }

                    }

                    Connection->CurrentReceive.Buffer = CurBuffer;
                    Connection->CurrentReceive.BufferOffset = CurByteOffset;

                    Connection->CurrentReceive.Offset += BytesToTransfer;
                    Connection->CurrentReceive.MessageOffset += BytesToTransfer;

                    //
                    // Release and re-acquire the lock, but this time with the
                    // Cancel lock
                    //
                    NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
                    NB_GET_CANCEL_LOCK( &CancelLH );
                    NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);

                    if (CompleteReceive ||
                        (Connection->State != CONNECTION_STATE_ACTIVE)) {

                        if (EndOfMessage) {

                            CTEAssert (!PartialReceive);

                            ++Connection->ReceiveSequence;
                            ++Connection->LocalRcvSequenceMax;  // harmless if NewNetbios is FALSE
                            Connection->CurrentReceive.MessageOffset = 0;
                            Connection->CurrentIndicateOffset = 0;

                        } else if (Connection->NewNetbios) {

                            if (PartialReceive) {
                                Connection->CurrentIndicateOffset += BytesToTransfer;
                            } else {
                                ++Connection->ReceiveSequence;
                                ++Connection->LocalRcvSequenceMax;
                                Connection->CurrentIndicateOffset = 0;
                            }
                        }

                        //
                        // This sends an ack and releases the connection lock.
                        // and CANCEL Lock.
                        //

                        NbiCompleteReceive(
                            Connection,
                            EndOfMessage,
                            CancelLH
                            NB_LOCK_HANDLE_ARG(LockHandle));

                    } else {

                        NB_SYNC_SWAP_IRQL( CancelLH, LockHandle);
                        NB_FREE_CANCEL_LOCK( CancelLH );
                        //
                        // CompleteReceive is FALSE, so EndOfMessage is FALSE.
                        //

                        Connection->ReceiveState = CONNECTION_RECEIVE_ACTIVE;

                        //
                        // This releases the lock.
                        //

                        if (Connection->NewNetbios) {

                            //
                            // A partial receive should only happen if we are
                            // completing the receive.
                            //

                            CTEAssert (!PartialReceive);

                            ++Connection->ReceiveSequence;
                            ++Connection->LocalRcvSequenceMax;
                            Connection->CurrentIndicateOffset = 0;

                            if ((Connection->CurrentReceiveNoPiggyback) ||
                                ((Device->AckWindow != 0) &&
                                 (++Connection->ReceivesWithoutAck >= Device->AckWindow))) {

                                NbiSendDataAck(
                                    Connection,
                                    NbiAckResponse
                                    NB_LOCK_HANDLE_ARG(LockHandle));

                            } else {

                                NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

                            }

                        } else {

                            NbiSendDataAck(
                                Connection,
                                NbiAckResponse
                                NB_LOCK_HANDLE_ARG(LockHandle));

                        }

                    }

                    NbiDereferenceConnection (Connection, CREF_INDICATE);
                    return;

                }

                //
                // We have to set up a call to transfer data and send
                // the ack after it completes (if it succeeds).
                //

                s = NbiPopReceivePacket (Device);
                if (s == NULL) {

                    NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
                    ++Connection->ConnectionInfo.ReceiveErrors;
                    ++Device->Statistics.DataFramesRejected;
                    ADD_TO_LARGE_INTEGER(
                        &Device->Statistics.DataFrameBytesRejected,
                        DataAvailable);

                    NbiDereferenceConnection (Connection, CREF_INDICATE);
                    return;
                }

                ReceiveReserved = CONTAINING_RECORD (s, NB_RECEIVE_RESERVED, PoolLinkage);
                Packet = CONTAINING_RECORD (ReceiveReserved, NDIS_PACKET, ProtocolReserved[0]);

                //
                // Initialize the receive packet.
                //

                ReceiveReserved->u.RR_CO.Connection = Connection;
                ReceiveReserved->u.RR_CO.EndOfMessage = EndOfMessage;
                ReceiveReserved->u.RR_CO.CompleteReceive = CompleteReceive;
                ReceiveReserved->u.RR_CO.PartialReceive = PartialReceive;

                ReceiveReserved->Type = RECEIVE_TYPE_DATA;
                CTEAssert (!ReceiveReserved->TransferInProgress);
                ReceiveReserved->TransferInProgress = TRUE;

                //
                // if we've got zero bytes left, avoid the TransferData below and
                // just deliver.
                //

                if (BytesToTransfer <= 0) {

                    ReceiveReserved->u.RR_CO.NoNdisBuffer = TRUE;
                    NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
                    NB_DEBUG2 (RECEIVE, ("TransferData of 0 bytes %lx (%d)\n", Connection, Connection->ReceiveSequence));
                    NbiTransferDataComplete(
                            Packet,
                            NDIS_STATUS_SUCCESS,
                            0);

                    return;
                }

                //
                // If needed, build a buffer chain to describe this
                // to NDIS.
                //

                Connection->PreviousReceive = Connection->CurrentReceive;

                if ((Connection->CurrentReceive.Offset == 0) &&
                    CompleteReceive) {

                    BufferChain = Connection->CurrentReceive.Buffer;
                    BufferChainLength = BytesToTransfer;
                    Connection->CurrentReceive.Buffer = NULL;
                    ReceiveReserved->u.RR_CO.NoNdisBuffer = TRUE;

                } else {

                    if (NbiBuildBufferChainFromBufferChain (
                                Device->NdisBufferPoolHandle,
                                Connection->CurrentReceive.Buffer,
                                Connection->CurrentReceive.BufferOffset,
                                BytesToTransfer,
                                &BufferChain,
                                &Connection->CurrentReceive.Buffer,
                                &Connection->CurrentReceive.BufferOffset,
                                &BufferChainLength) != NDIS_STATUS_SUCCESS) {

                        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
                        NB_DEBUG2 (RECEIVE, ("Could not build receive buffer chain %lx (%d)\n", Connection, Connection->ReceiveSequence));
                        NbiDereferenceConnection (Connection, CREF_INDICATE);
                        return;

                    }

                    ReceiveReserved->u.RR_CO.NoNdisBuffer = FALSE;

                }


                NdisChainBufferAtFront (Packet, BufferChain);

                Connection->ReceiveState = CONNECTION_RECEIVE_TRANSFER;

                NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

                NB_DEBUG2 (RECEIVE, ("TransferData of %d bytes %lx (%d)\n", BytesToTransfer, Connection, Connection->ReceiveSequence));

                (*Device->Bind.TransferDataHandler) (
                    &NdisStatus,
                    MacBindingHandle,
                    MacReceiveContext,
                    LookaheadBufferOffset + sizeof(NB_CONNECTION) +
                        Connection->CurrentIndicateOffset + IndicateBytesTransferred,
                    BytesToTransfer,
                    Packet,
                    (PUINT)&NdisBytesTransferred);

                if (NdisStatus != NDIS_STATUS_PENDING) {
#if DBG
                    if (NdisStatus == STATUS_SUCCESS) {
                        CTEAssert (NdisBytesTransferred == BytesToTransfer);
                    }
#endif

                    NbiTransferDataComplete (
                            Packet,
                            NdisStatus,
                            NdisBytesTransferred);

                }

                return;

            }

        } else if ((Connection->State == CONNECTION_STATE_CONNECTING) &&
                   (Connection->SubState != CONNECTION_SUBSTATE_C_DISCONN)) {

            //
            // If this is the ack for the session initialize, then
            // complete the pending connects. This routine releases
            // the connection lock.
            //

            NbiProcessSessionInitAck(
                Connection,
                Sess
                NB_LOCK_HANDLE_ARG(LockHandle));

        } else {

            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

        }

        NbiDereferenceConnection (Connection, CREF_INDICATE);

    } else {

        //
        // This is a session initialize frame.
        //
        // If there is more data than in the lookahead
        // buffer, we won't be able to echo it back in the
        // response.
        //

        NbiProcessSessionInitialize(
            RemoteAddress,
            MacOptions,
            LookaheadBuffer,
            LookaheadBufferSize);

    }

}   /* NbiProcessSessionData */


VOID
NbiProcessDataAck(
    IN PCONNECTION Connection,
    IN NB_SESSION UNALIGNED * Sess,
    IN PIPX_LOCAL_TARGET RemoteAddress
    NB_LOCK_HANDLE_PARAM(LockHandle)
    )

/*++

Routine Description:

    This routine processes an ack on an active connection.

    NOTE: THIS FUNCTION IS CALLED WITH CONNECTION->LOCK HELD
    AND RETURNS WITH IT RELEASED.

Arguments:

    Connection - The connection.

    Sess - The session frame.

    RemoteAddress - The local target this packet was received from.

    LockHandle - The handle used to acquire the lock.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    BOOLEAN Resend;

    //
    // Make sure we expect an ack right now.
    //

    if (Connection->State == CONNECTION_STATE_ACTIVE) {

        if (((Connection->SubState == CONNECTION_SUBSTATE_A_W_ACK) ||
             (Connection->SubState == CONNECTION_SUBSTATE_A_REMOTE_W)) &&
            ((Sess->ConnectionControlFlag & NB_CONTROL_SEND_ACK) == 0)) {

            //
            // We are waiting for an ack (because we completed
            // packetizing a send, or ran out of receive window).
            //
            // This will complete any sends that are acked by
            // this receive, and if necessary readjust the
            // send pointer and requeue the connection for
            // packetizing. It release the connection lock.
            //

            if (Connection->ResponseTimeout) {
                Resend = TRUE;
                Connection->ResponseTimeout = FALSE;
            } else {
                Resend = (BOOLEAN)
                    ((Sess->ConnectionControlFlag & NB_CONTROL_RESEND) != 0);
            }

            NbiReframeConnection(
                Connection,
                Sess->ReceiveSequence,
                Sess->BytesReceived,
                Resend
                NB_LOCK_HANDLE_ARG(LockHandle));

        } else if ((Connection->SubState == CONNECTION_SUBSTATE_A_W_PROBE) &&
                   ((Sess->ConnectionControlFlag & NB_CONTROL_SEND_ACK) == 0)) {

            //
            // We had a probe outstanding and got a response. Restart
            // the connection if needed (a send may have just been
            // posted while the probe was outstanding).
            //
            // We should check that the response is really correct.
            //

            if (Connection->NewNetbios) {
                Connection->RemoteRcvSequenceMax = Sess->ReceiveSequenceMax;
            }

            NbiRestartConnection (Connection);

            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

        } else if ((Connection->SubState == CONNECTION_SUBSTATE_A_PACKETIZE) &&
                   ((Sess->ConnectionControlFlag & NB_CONTROL_SEND_ACK) == 0)) {

            if (Connection->NewNetbios) {

                //
                // We are packetizing, reframe. In the unlikely
                // event that this acks everything we may packetize
                // in this call, but that is OK (the other thread
                // will exit if we finish up). More normally we
                // will just advance UnAcked send a bit.
                //

                NbiReframeConnection(
                    Connection,
                    Sess->ReceiveSequence,
                    Sess->BytesReceived,
                    (BOOLEAN)((Sess->ConnectionControlFlag & NB_CONTROL_RESEND) != 0)
                    NB_LOCK_HANDLE_ARG(LockHandle));

            } else {

                NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
            }

#if 0

        //
        // Should handle this case (i.e. may be in W_PACKET).
        //

        } else if ((Sess->ConnectionControlFlag & NB_CONTROL_SEND_ACK) == 0) {

            DbgPrint ("NWLNKNB: Ignoring ack, state is %d\n", Connection->SubState);
            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
#endif

        } else {

            //
            // We got a probe from the remote. Some old DOS clients
            // send probes that do not have the send ack bit on,
            // so we respond to any probe if none of the conditions
            // above are true. This call releases the lock.
            //
            // We use the IgnoreNextDosProbe flag to ignore every
            // second probe of this nature, to avoid a data ack
            // war between two machines who each think they are
            // responding to the other. This flag is set to FALSE
            // whenever we send an ack or a probe.
            //

            if (!Connection->IgnoreNextDosProbe) {

                //
                // Since this is a probe, check if the local
                // target has changed.
                //

                if (!RtlEqualMemory (&Connection->LocalTarget, RemoteAddress, 8)) {
#if DBG
                    DbgPrint ("NBI: Switch local target for %lx\n", Connection);
#endif
                    Connection->LocalTarget = *RemoteAddress;
                }

                NbiSendDataAck(
                    Connection,
                    NbiAckResponse
                    NB_LOCK_HANDLE_ARG(LockHandle));
                Connection->IgnoreNextDosProbe = TRUE;

            } else {

                Connection->IgnoreNextDosProbe = FALSE;
                NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
            }

        }

    } else {

        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
        return;

    }

}   /* NbiProcessDataAck */


VOID
NbiProcessSessionInitialize(
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR PacketBuffer,
    IN UINT PacketSize
    )

/*++

Routine Description:

    This routine handles NB_CMD_SESSION frames which have
    a remote connection ID of 0xffff -- these are session
    initialize frames.

Arguments:

    RemoteAddress - The local target this packet was received from.

    MacOptions - The MAC options for the underlying NDIS binding.

    PacketBuffer - The packet data, starting at the IPX
        header.

    PacketSize - The total length of the packet, starting at the
        IPX header.

Return Value:

    None.

--*/

{
    NB_CONNECTION UNALIGNED * Conn = (NB_CONNECTION UNALIGNED *)PacketBuffer;
    NB_SESSION UNALIGNED * Sess = (NB_SESSION UNALIGNED *)(&Conn->Session);
    NB_SESSION_INIT UNALIGNED * SessInit = (NB_SESSION_INIT UNALIGNED *)(Sess+1);
    CONNECT_INDICATION TempConnInd;
    PCONNECT_INDICATION ConnInd;
    PCONNECTION Connection;
    PADDRESS Address;
    PREQUEST Request, ListenRequest, AcceptRequest;
    PDEVICE Device = NbiDevice;
    PLIST_ENTRY p;
    ULONG Hash;
    TA_NETBIOS_ADDRESS SourceName;
    PIRP AcceptIrp;
    CONNECTION_CONTEXT ConnectionContext;
    NTSTATUS AcceptStatus;
    PADDRESS_FILE AddressFile, ReferencedAddressFile;
    PTDI_REQUEST_KERNEL_LISTEN ListenParameters;
    PTDI_CONNECTION_INFORMATION ListenInformation;
    PTDI_CONNECTION_INFORMATION RemoteInformation;
    TDI_ADDRESS_NETBIOS * ListenAddress;
    NB_DEFINE_LOCK_HANDLE (LockHandle1)
    NB_DEFINE_LOCK_HANDLE (LockHandle2)
    NB_DEFINE_LOCK_HANDLE (LockHandle3)
    CTELockHandle   CancelLH;

    //
    // Verify that the whole packet is there.
    //

    if (PacketSize < (sizeof(IPX_HEADER) + sizeof(NB_SESSION) + sizeof(NB_SESSION_INIT))) {
#if DBG
        DbgPrint ("NBI: Got short session initialize, %d/%d\n", PacketSize,
            sizeof(IPX_HEADER) + sizeof(NB_SESSION) + sizeof(NB_SESSION_INIT));
#endif
        return;
    }

    //
    // Verify that MaximumDataSize that remote can support is > 0
    // Bug # 19405
    //
    if ( SessInit->MaximumDataSize == 0 ) {
        NB_DEBUG(CONNECTION, ("Connect request with MaximumDataSize == 0\n"
));
        return;
    }

    //
    // Make sure this is for an address we care about.
    //

    if (Device->AddressCounts[SessInit->DestinationName[0]] == 0) {
        return;
    }

    Address = NbiFindAddress (Device, (PUCHAR)SessInit->DestinationName);

    if (Address == NULL) {
        return;
    }

    //
    // First see if we have a session to this remote. We check
    // this in case our ack of the session initialize was dropped,
    // we don't want to reindicate our client.
    //

    NB_SYNC_GET_LOCK (&Device->Lock, &LockHandle3);

    for (Hash = 0; Hash < CONNECTION_HASH_COUNT; Hash++) {

        Connection = Device->ConnectionHash[Hash].Connections;

        while (Connection != NULL) {

            if ((RtlEqualMemory (&Connection->RemoteHeader.DestinationNetwork, Conn->IpxHeader.SourceNetwork, 12)) &&
                (Connection->RemoteConnectionId == Sess->SourceConnectionId) &&
                (Connection->State != CONNECTION_STATE_DISCONNECT)) {

                //
                // Yes, we are talking to this remote, if it is active then
                // respond, otherwise we are in the process of connecting
                // and we will respond eventually.
                //

#if DBG
                DbgPrint ("NBI: Got connect request on active connection %lx\n", Connection);
#endif

                if (Connection->State == CONNECTION_STATE_ACTIVE) {

                    NbiReferenceConnectionLock (Connection, CREF_INDICATE);
                    NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle3);

                    NbiSendSessionInitAck(
                        Connection,
                        (PUCHAR)(SessInit+1),
                        PacketSize - (sizeof(IPX_HEADER) + sizeof(NB_SESSION) + sizeof(NB_SESSION_INIT)),
                        NULL);   // lock is not held
                    NbiDereferenceConnection (Connection, CREF_INDICATE);

                } else {

                    NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle3);

                }

                NbiDereferenceAddress (Address, AREF_FIND);
                return;
            }

            Connection = Connection->NextConnection;
        }
    }


    TdiBuildNetbiosAddress ((PUCHAR)SessInit->SourceName, FALSE, &SourceName);

    //
    // Scan the queue of listens to see if there is one that
    // satisfies this request.
    //
    // NOTE: The device lock is held here.
    //

    for (p = Device->ListenQueue.Flink;
         p != &Device->ListenQueue;
         p = p->Flink) {

        Request = LIST_ENTRY_TO_REQUEST (p);
        Connection = (PCONNECTION)REQUEST_OPEN_CONTEXT(Request);

        if (Connection->AddressFile->Address != Address) {
            continue;
        }

        //
        // Check that this listen is not specific to a different
        // netbios name.
        //

        ListenParameters = (PTDI_REQUEST_KERNEL_LISTEN)REQUEST_PARAMETERS(Request);
        ListenInformation = ListenParameters->RequestConnectionInformation;

        if (ListenInformation &&
            (ListenInformation->RemoteAddress) &&
            (ListenAddress = NbiParseTdiAddress(ListenInformation->RemoteAddress, ListenInformation->RemoteAddressLength, FALSE)) &&
            (!RtlEqualMemory(
                SessInit->SourceName,
                ListenAddress->NetbiosName,
                16))) {
            continue;
        }

        //
        // This connection is valid, so we use it.
        //

        NB_DEBUG2 (CONNECTION, ("Activating queued listen %lx\n", Connection));

        RemoveEntryList (REQUEST_LINKAGE(Request));

        RtlCopyMemory(&Connection->RemoteHeader.DestinationNetwork, Conn->IpxHeader.SourceNetwork, 12);
        RtlCopyMemory (Connection->RemoteName, SessInit->SourceName, 16);
        Connection->LocalTarget = *RemoteAddress;
        Connection->RemoteConnectionId = Sess->SourceConnectionId;

        Connection->SessionInitAckDataLength =
            PacketSize - (sizeof(IPX_HEADER) + sizeof(NB_SESSION) + sizeof(NB_SESSION_INIT));
        if (Connection->SessionInitAckDataLength > 0) {
            if (Connection->SessionInitAckData = NbiAllocateMemory (Connection->SessionInitAckDataLength,
                                                                    MEMORY_CONNECTION, "SessionInitAckData"))
            {
                RtlCopyMemory (Connection->SessionInitAckData,
                               (PUCHAR)(SessInit+1),
                               Connection->SessionInitAckDataLength);
            }
            else
            {
                Connection->SessionInitAckDataLength = 0;
            }
        }


        Connection->MaximumPacketSize = SessInit->MaximumDataSize;

        Connection->CurrentSend.SendSequence = 0;
        Connection->UnAckedSend.SendSequence = 0;
        Connection->RetransmitThisWindow = FALSE;
        Connection->ReceiveSequence = 1;
        Connection->CurrentReceive.MessageOffset = 0;
        Connection->Retries = Device->KeepAliveCount;
        if (Device->Extensions && ((Sess->ConnectionControlFlag & NB_CONTROL_NEW_NB) != 0)) {
            Connection->NewNetbios = TRUE;
            Connection->LocalRcvSequenceMax = 4;   // may get modified after ripping based on card
            Connection->RemoteRcvSequenceMax = Sess->ReceiveSequenceMax;
            Connection->SendWindowSequenceLimit = 2;
            if (Connection->RemoteRcvSequenceMax == 0) {
                Connection->RemoteRcvSequenceMax = 1;
            }
        } else {
            Connection->NewNetbios = FALSE;
        }

        //
        // Save this information now for whenever we complete the listen.
        //

        RemoteInformation = ListenParameters->ReturnConnectionInformation;

        if (RemoteInformation != NULL) {

            RtlCopyMemory(
                (PTA_NETBIOS_ADDRESS)RemoteInformation->RemoteAddress,
                &SourceName,
                (RemoteInformation->RemoteAddressLength < sizeof(TA_NETBIOS_ADDRESS)) ?
                    RemoteInformation->RemoteAddressLength : sizeof(TA_NETBIOS_ADDRESS));
        }


        if (ListenParameters->RequestFlags & TDI_QUERY_ACCEPT) {

            //
            // We have to wait for an accept before sending the
            // session init ack, so we complete the listen and wait.
            //

            ListenRequest = Request;
            Connection->ListenRequest = NULL;

            NB_DEBUG2 (CONNECTION, ("Queued listen on %lx awaiting accept\n", Connection));

            Connection->SubState = CONNECTION_SUBSTATE_L_W_ACCEPT;

            NbiTransferReferenceConnection (Connection, CREF_LISTEN, CREF_W_ACCEPT);

            NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle3);

        } else {

            //
            // We are ready to go, so we send out the find route request
            // for the remote. We keep the listen alive and the CREF_LISTEN
            // reference on until this completes.
            //

            NB_DEBUG2 (CONNECTION, ("Activating queued listen on %lx\n", Connection));

            ListenRequest = NULL;

            Connection->SubState = CONNECTION_SUBSTATE_L_W_ROUTE;

            NbiReferenceConnectionLock (Connection, CREF_FIND_ROUTE);

            NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle3);

            *(UNALIGNED ULONG *)Connection->FindRouteRequest.Network =
                *(UNALIGNED ULONG *)Conn->IpxHeader.SourceNetwork;
            RtlCopyMemory(Connection->FindRouteRequest.Node,Conn->IpxHeader.SourceNode,6);
            Connection->FindRouteRequest.Identifier = IDENTIFIER_NB;
            Connection->FindRouteRequest.Type = IPX_FIND_ROUTE_NO_RIP;

            //
            // When this completes, we will send the session init
            // ack. We don't call it if the client is for network 0,
            // instead just fake as if no route could be found
            // and we will use the local target we got here.
            //

            if (*(UNALIGNED ULONG *)Conn->IpxHeader.SourceNetwork != 0) {

                (*Device->Bind.FindRouteHandler)(
                    &Connection->FindRouteRequest);

            } else {

                NbiFindRouteComplete(
                    &Connection->FindRouteRequest,
                    FALSE);

            }

        }

        //
        // Complete the listen if needed.
        //

        if (ListenRequest != NULL) {

            REQUEST_INFORMATION (ListenRequest) = 0;
            REQUEST_STATUS (ListenRequest) = STATUS_SUCCESS;

            NB_GET_CANCEL_LOCK ( &CancelLH );
            IoSetCancelRoutine (ListenRequest, (PDRIVER_CANCEL)NULL);
            NB_FREE_CANCEL_LOCK( CancelLH );

            NbiCompleteRequest (ListenRequest);
            NbiFreeRequest (Device, ListenRequest);

        }

        NbiDereferenceAddress (Address, AREF_FIND);

        return;

    }

    //
    // We could not find a listen, so we indicate to every
    // client. Make sure there is no session initialize for this
    // remote being indicated. If there is not, we insert
    // ourselves in the queue to block others.
    //
    // NOTE: The device lock is held here.
    //

    for (p = Device->ConnectIndicationInProgress.Flink;
         p != &Device->ConnectIndicationInProgress;
         p = p->Flink) {

        ConnInd = CONTAINING_RECORD (p, CONNECT_INDICATION, Linkage);

        if ((RtlEqualMemory(ConnInd->NetbiosName, SessInit->DestinationName, 16)) &&
            (RtlEqualMemory(&ConnInd->RemoteAddress, Conn->IpxHeader.SourceNetwork, 12)) &&
            (ConnInd->ConnectionId == Sess->SourceConnectionId)) {

            //
            // We are processing a request from this remote for
            // the same ID, to avoid confusion we just exit.
            //

#if DBG
            DbgPrint ("NBI: Already processing connect to <%.16s>\n", SessInit->DestinationName);
#endif

            NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle3);
            NbiDereferenceAddress (Address, AREF_FIND);
            return;
        }

    }

    RtlCopyMemory (TempConnInd.NetbiosName, SessInit->DestinationName, 16);
    RtlCopyMemory (&TempConnInd.RemoteAddress, Conn->IpxHeader.SourceNetwork, 12);
    TempConnInd.ConnectionId = Sess->SourceConnectionId;

    InsertTailList (&Device->ConnectIndicationInProgress, &TempConnInd.Linkage);

    NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle3);


    //
    // Now scan through the address to find someone who has
    // an indication routine registed and wants this connection.
    //


    ReferencedAddressFile = NULL;

    NB_SYNC_GET_LOCK (&Address->Lock, &LockHandle1);

    for (p = Address->AddressFileDatabase.Flink;
         p != &Address->AddressFileDatabase;
         p = p->Flink) {

        //
        // Find the next open address file in the list.
        //

        AddressFile = CONTAINING_RECORD (p, ADDRESS_FILE, Linkage);
        if (AddressFile->State != ADDRESSFILE_STATE_OPEN) {
            continue;
        }

        NbiReferenceAddressFileLock (AddressFile, AFREF_INDICATION);

        NB_SYNC_FREE_LOCK (&Address->Lock, LockHandle1);

        if (ReferencedAddressFile != NULL) {
            NbiDereferenceAddressFile (ReferencedAddressFile, AFREF_INDICATION);
        }
        ReferencedAddressFile = AddressFile;

        //
        // No posted listen requests; is there a kernel client?
        //

        if (AddressFile->RegisteredHandler[TDI_EVENT_CONNECT]) {

            if ((*AddressFile->ConnectionHandler)(
                     AddressFile->HandlerContexts[TDI_EVENT_CONNECT],
                     sizeof (TA_NETBIOS_ADDRESS),
                     &SourceName,
                     0,                 // user data
                     NULL,
                     0,                 // options
                     NULL,
                     &ConnectionContext,
                     &AcceptIrp) != STATUS_MORE_PROCESSING_REQUIRED) {

                //
                // The client did not return a request, go to the
                // next address file.
                //

                NB_SYNC_GET_LOCK (&Address->Lock, &LockHandle1);
                continue;

            }

            AcceptRequest = NbiAllocateRequest (Device, AcceptIrp);

            IF_NOT_ALLOCATED(AcceptRequest) {

                AcceptStatus = STATUS_INSUFFICIENT_RESOURCES;

            } else {
                //
                // The client accepted the connect, so activate
                // the connection and complete the accept.
                // listen. This lookup references the connection
                // so we know it will remain valid.
                //

                Connection = NbiLookupConnectionByContext (
                                AddressFile,
                                ConnectionContext);

                if (Connection != NULL) {

                    ASSERT (Connection->AddressFile == AddressFile);

                    NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle2);
                    NB_SYNC_GET_LOCK (&Device->Lock, &LockHandle3);

                    if ((Connection->State == CONNECTION_STATE_INACTIVE) &&
                        (Connection->DisassociatePending == NULL) &&
                        (Connection->ClosePending == NULL)) {

                        NB_DEBUG2 (CONNECTION, ("Indication on %lx returned connection %lx\n", AddressFile, Connection));

                        Connection->State = CONNECTION_STATE_LISTENING;
                        Connection->SubState = CONNECTION_SUBSTATE_L_W_ROUTE;

                        Connection->Retries = Device->KeepAliveCount;

                        RtlCopyMemory(&Connection->RemoteHeader.DestinationNetwork, Conn->IpxHeader.SourceNetwork, 12);
                        RtlCopyMemory (Connection->RemoteName, SessInit->SourceName, 16);
                        Connection->LocalTarget = *RemoteAddress;

                        Connection->SessionInitAckDataLength =
                            PacketSize - (sizeof(IPX_HEADER) + sizeof(NB_SESSION) + sizeof(NB_SESSION_INIT));
                        if (Connection->SessionInitAckDataLength > 0) {
                            if (Connection->SessionInitAckData = NbiAllocateMemory(
                                Connection->SessionInitAckDataLength, MEMORY_CONNECTION, "SessionInitAckData"))
                            {
                                RtlCopyMemory (Connection->SessionInitAckData,
                                               (PUCHAR)(SessInit+1),
                                               Connection->SessionInitAckDataLength);
                            }
                            else
                            {
                                Connection->SessionInitAckDataLength = 0;
                            }
                        }

                        Connection->MaximumPacketSize = SessInit->MaximumDataSize;

                        (VOID)NbiAssignConnectionId (Device, Connection);     // Check return code.
                        Connection->RemoteConnectionId = Sess->SourceConnectionId;

                        Connection->CurrentSend.SendSequence = 0;
                        Connection->UnAckedSend.SendSequence = 0;
                        Connection->RetransmitThisWindow = FALSE;
                        Connection->ReceiveSequence = 1;
                        Connection->CurrentReceive.MessageOffset = 0;
                        Connection->Retries = Device->KeepAliveCount;
                        if (Device->Extensions && ((Sess->ConnectionControlFlag & NB_CONTROL_NEW_NB) != 0)) {
                            Connection->NewNetbios = TRUE;
                            Connection->LocalRcvSequenceMax = 4;   // may get modified after ripping based on card
                            Connection->RemoteRcvSequenceMax = Sess->ReceiveSequenceMax;
                            Connection->SendWindowSequenceLimit = 2;
                            if (Connection->RemoteRcvSequenceMax == 0) {
                                Connection->RemoteRcvSequenceMax = 1;
                            }
                        } else {
                            Connection->NewNetbios = FALSE;
                        }

                        NbiReferenceConnectionLock (Connection, CREF_ACCEPT);
                        NbiReferenceConnectionLock (Connection, CREF_FIND_ROUTE);

                        Connection->AcceptRequest = AcceptRequest;
                        AcceptStatus = STATUS_PENDING;

                        //
                        // Take us out of this list now, we will jump to
                        // FoundConnection which is past the removal below.
                        //

                        RemoveEntryList (&TempConnInd.Linkage);

                        NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle3);
                        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle2);

                        *(UNALIGNED ULONG *)Connection->FindRouteRequest.Network =
                            *(UNALIGNED ULONG *)Conn->IpxHeader.SourceNetwork;
                        RtlCopyMemory(Connection->FindRouteRequest.Node,Conn->IpxHeader.SourceNode,6);
                        Connection->FindRouteRequest.Identifier = IDENTIFIER_NB;
                        Connection->FindRouteRequest.Type = IPX_FIND_ROUTE_NO_RIP;

                        //
                        // When this completes, we will send the session init
                        // ack. We don't call it if the client is for network 0,
                        // instead just fake as if no route could be found
                        // and we will use the local target we got here.
                        // The accept is completed when this completes.
                        //

                        if (*(UNALIGNED ULONG *)Conn->IpxHeader.SourceNetwork != 0) {

                            (*Device->Bind.FindRouteHandler)(
                                &Connection->FindRouteRequest);

                        } else {

                            NbiFindRouteComplete(
                                &Connection->FindRouteRequest,
                                FALSE);

                        }

                    } else {

                        NB_DEBUG (CONNECTION, ("Indication on %lx returned invalid connection %lx\n", AddressFile, Connection));
                        AcceptStatus = STATUS_INVALID_CONNECTION;
                        NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle3);
                        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle2);


                    }

                    NbiDereferenceConnection (Connection, CREF_BY_CONTEXT);

                } else {

                    NB_DEBUG (CONNECTION, ("Indication on %lx returned unknown connection %lx\n", AddressFile, Connection));
                    AcceptStatus = STATUS_INVALID_CONNECTION;

                }
            }

            //
            // Complete the accept request in the failure case.
            //

            if (AcceptStatus != STATUS_PENDING) {

                REQUEST_STATUS (AcceptRequest) = AcceptStatus;

                NbiCompleteRequest (AcceptRequest);
                NbiFreeRequest (Device, AcceptRequest);

            } else {

                //
                // We found a connection, so we break; this is
                // a jump since the while exit assumes the
                // address lock is held.
                //

                goto FoundConnection;

            }

        }

        NB_SYNC_GET_LOCK (&Address->Lock, &LockHandle1);

    }    // end of for loop through the address files

    NB_SYNC_FREE_LOCK (&Address->Lock, LockHandle1);


    //
    // Take us out of the list that blocks other indications
    // from this remote to this address.
    //

    NB_SYNC_GET_LOCK (&Device->Lock, &LockHandle3);
    RemoveEntryList (&TempConnInd.Linkage);
    NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle3);

FoundConnection:

    if (ReferencedAddressFile != NULL) {
        NbiDereferenceAddressFile (ReferencedAddressFile, AFREF_INDICATION);
    }

    NbiDereferenceAddress (Address, AREF_FIND);

}   /* NbiProcessSessionInitialize */


VOID
NbiProcessSessionInitAck(
    IN PCONNECTION Connection,
    IN NB_SESSION UNALIGNED * Sess
    IN NB_LOCK_HANDLE_PARAM(LockHandle)
    )

/*++

Routine Description:

    This routine handles session init ack frames.

    THIS ROUTINE IS CALLED WITH THE CONNECTION LOCK HELD
    AND RETURNS WITH IT RELEASED.

Arguments:

    Connection - The connection.

    Sess - The netbios header for the received frame.

    LockHandle - The handle with which Connection->Lock was acquired.

Return Value:

    None.

--*/

{
    PREQUEST Request;
    NB_SESSION_INIT UNALIGNED * SessInit = (NB_SESSION_INIT UNALIGNED *)(Sess+1);
    BOOLEAN TimerWasStopped = FALSE;
    CTELockHandle   CancelLH;

    if ((Sess->ConnectionControlFlag & NB_CONTROL_SYSTEM) &&
        (Sess->SendSequence == 0x0000) &&
        (Sess->ReceiveSequence == 0x0001)) {

        NB_DEBUG2 (CONNECTION, ("Completing connect on %lx\n", Connection));

        if (CTEStopTimer (&Connection->Timer)) {
            TimerWasStopped = TRUE;
        }

        Connection->State = CONNECTION_STATE_ACTIVE;
        Connection->SubState = CONNECTION_SUBSTATE_A_IDLE;
        Connection->ReceiveState = CONNECTION_RECEIVE_IDLE;

        if (Connection->Retries == NbiDevice->ConnectionCount) {
            ++NbiDevice->Statistics.ConnectionsAfterNoRetry;
        } else {
            ++NbiDevice->Statistics.ConnectionsAfterRetry;
        }
        ++NbiDevice->Statistics.OpenConnections;

        Connection->Retries = NbiDevice->KeepAliveCount;
        NbiStartWatchdog (Connection);

        Connection->RemoteConnectionId = Sess->SourceConnectionId;

        Connection->CurrentSend.SendSequence = 1;
        Connection->UnAckedSend.SendSequence = 1;
        Connection->RetransmitThisWindow = FALSE;
        Connection->ReceiveSequence = 0;
        Connection->CurrentReceive.MessageOffset = 0;
        Connection->Retries = NbiDevice->KeepAliveCount;
        if (NbiDevice->Extensions && ((Sess->ConnectionControlFlag & NB_CONTROL_NEW_NB) != 0)) {
            Connection->NewNetbios = TRUE;
            Connection->LocalRcvSequenceMax =
                (USHORT)(Connection->ReceiveWindowSize - 1);
            Connection->RemoteRcvSequenceMax = Sess->ReceiveSequenceMax;
            Connection->SendWindowSequenceLimit = 3;
        } else {
            Connection->NewNetbios = FALSE;
        }

        if (Connection->MaximumPacketSize > SessInit->MaximumDataSize) {
            Connection->MaximumPacketSize = SessInit->MaximumDataSize;
        }

        Request = Connection->ConnectRequest;

#ifdef RASAUTODIAL
        //
        // Check to see if we have to notify
        // the automatic connection driver about
        // this connection.
        //
        if (fAcdLoadedG) {
            BOOLEAN fEnabled;
            CTELockHandle AcdHandle;

            CTEGetLock(&AcdDriverG.SpinLock, &AcdHandle);
            fEnabled = AcdDriverG.fEnabled;
            CTEFreeLock(&AcdDriverG.SpinLock, AcdHandle);
            if (fEnabled)
                NbiNoteNewConnection(Connection);
        }
#endif // RASAUTODIAL

        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

        NB_GET_CANCEL_LOCK( &CancelLH );
        IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);
        NB_FREE_CANCEL_LOCK( CancelLH );

        REQUEST_STATUS (Request) = STATUS_SUCCESS;
        NbiCompleteRequest (Request);
        NbiFreeRequest (Device, Request);

        NbiTransferReferenceConnection (Connection, CREF_CONNECT, CREF_ACTIVE);

        if (TimerWasStopped) {
            NbiDereferenceConnection (Connection, CREF_TIMER);
        }

    } else {

        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

    }

}   /* NbiProcessSessionInitAck */


VOID
NbiProcessSessionEnd(
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR PacketBuffer,
    IN UINT PacketSize
    )

/*++

Routine Description:

    This routine handles NB_CMD_SESSION_END frames.

Arguments:

    RemoteAddress - The local target this packet was received from.

    MacOptions - The MAC options for the underlying NDIS binding.

    LookaheadBuffer - The packet data, starting at the IPX
        header.

    PacketSize - The total length of the packet, starting at the
        IPX header.

Return Value:

    None.

--*/

{

    NB_CONNECTION UNALIGNED * Conn = (NB_CONNECTION UNALIGNED *)PacketBuffer;
    NB_SESSION UNALIGNED * Sess = (NB_SESSION UNALIGNED *)(&Conn->Session);
    PCONNECTION Connection;
    PDEVICE Device = NbiDevice;
    ULONG Hash;
    NB_DEFINE_LOCK_HANDLE (LockHandle1)
    NB_DEFINE_LOCK_HANDLE (LockHandle2)

    //
    // This is an active connection, find it using
    // our session id.
    //

    Hash = (Sess->DestConnectionId & CONNECTION_HASH_MASK) >> CONNECTION_HASH_SHIFT;

    NB_SYNC_GET_LOCK (&Device->Lock, &LockHandle2);

    Connection = Device->ConnectionHash[Hash].Connections;

    while (Connection != NULL) {

        if (Connection->LocalConnectionId == Sess->DestConnectionId) {
            break;
        }
        Connection = Connection->NextConnection;
    }


    //
    // We reply to any session end, even if we don't know the
    // connection, to speed up the disconnect on the remote.
    //

    if (Connection == NULL) {

        NB_DEBUG (CONNECTION, ("Session end received on unknown id %lx\n", Sess->DestConnectionId));
        NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle2);

        NbiSendSessionEndAck(
            (TDI_ADDRESS_IPX UNALIGNED *)(Conn->IpxHeader.SourceNetwork),
            RemoteAddress,
            Sess);
        return;
    }

    NbiReferenceConnectionLock (Connection, CREF_INDICATE);
    NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle2);


    NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle1);
    NB_SYNC_GET_LOCK (&Device->Lock, &LockHandle2);

    if (Connection->State == CONNECTION_STATE_ACTIVE) {

        NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle2);

        if (Connection->SubState == CONNECTION_SUBSTATE_A_W_ACK) {

            //
            // We are waiting for an ack, so see if this acks
            // anything. We do this in case a full send has been
            // received by the remote but he did not send an
            // ack before the session went down -- this will
            // prevent us from failing a send which actually
            // succeeded. If we are not in W_ACK this may ack
            // part of a send, but in that case we don't care
            // since StopConnection will abort it anyway and
            // the amount successfully received by the remote
            // doesn't matter.
            //
            // This releases the lock.
            //

            NB_DEBUG2 (CONNECTION, ("Session end at W_ACK, reframing %lx (%d)\n", Connection, Sess->ReceiveSequence));

            NbiReframeConnection(
                Connection,
                Sess->ReceiveSequence,
                Sess->BytesReceived,
                FALSE
                NB_LOCK_HANDLE_ARG(LockHandle1));

            NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle1);

        } else {

            NB_DEBUG2 (CONNECTION, ("Session end received on connection %lx\n", Connection));

        }

        //
        // This call sets the state to DISCONNECT and
        // releases the connection lock. It will also
        // complete a disconnect wait request if one
        // is pending, and indicate to our client
        // if needed.
        //

        NbiStopConnection(
            Connection,
            STATUS_REMOTE_DISCONNECT
            NB_LOCK_HANDLE_ARG (LockHandle1));

    } else {

        NB_DEBUG2 (CONNECTION, ("Session end received on inactive connection %lx\n", Connection));

        NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle2);
        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle1);

    }

    NbiSendSessionEndAck(
        (TDI_ADDRESS_IPX UNALIGNED *)(Conn->IpxHeader.SourceNetwork),
        RemoteAddress,
        Sess);

    NbiDereferenceConnection (Connection, CREF_INDICATE);

}   /* NbiProcessSessionEnd */


VOID
NbiProcessSessionEndAck(
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR PacketBuffer,
    IN UINT PacketSize
    )

/*++

Routine Description:

    This routine handles NB_CMD_SESSION_END_ACK frames.

Arguments:

    RemoteAddress - The local target this packet was received from.

    MacOptions - The MAC options for the underlying NDIS binding.

    LookaheadBuffer - The packet data, starting at the IPX
        header.

    PacketSize - The total length of the packet, starting at the
        IPX header.

Return Value:

    None.

--*/

{
    NB_CONNECTION UNALIGNED * Conn = (NB_CONNECTION UNALIGNED *)PacketBuffer;
    NB_SESSION UNALIGNED * Sess = (NB_SESSION UNALIGNED *)(&Conn->Session);
    PCONNECTION Connection;
    PDEVICE Device = NbiDevice;
    ULONG Hash;
    NB_DEFINE_LOCK_HANDLE (LockHandle)

    //
    // This is an active connection, find it using
    // our session id.
    //

    Hash = (Sess->DestConnectionId & CONNECTION_HASH_MASK) >> CONNECTION_HASH_SHIFT;

    NB_SYNC_GET_LOCK (&Device->Lock, &LockHandle);

    Connection = Device->ConnectionHash[Hash].Connections;

    while (Connection != NULL) {

        if (Connection->LocalConnectionId == Sess->DestConnectionId) {
            break;
        }
        Connection = Connection->NextConnection;
    }

    if (Connection == NULL) {

        NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);
        return;
    }

    NbiReferenceConnectionLock (Connection, CREF_INDICATE);
    NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);

    //
    // See what is happening with this connection.
    //

    NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);

    if (Connection->State == CONNECTION_STATE_DISCONNECT) {

        //
        // Stop the timer, when the reference goes away it
        // will shut down. We set the substate so if the
        // timer is running it will not restart (there is
        // a small window here, but it is not
        // harmful, we will just have to timeout one
        // more time).
        //

        NB_DEBUG2 (CONNECTION, ("Got session end ack on %lx\n", Connection));

        Connection->SubState = CONNECTION_SUBSTATE_D_GOT_ACK;
        if (CTEStopTimer (&Connection->Timer)) {
            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
            NbiDereferenceConnection (Connection, CREF_TIMER);
        } else {
            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
        }

    } else {

        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

    }

    NbiDereferenceConnection (Connection, CREF_INDICATE);

}   /* NbiProcessSessionEndAck */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\nb\send.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    send.c

Abstract:

    This module contains the send routines for the Netbios
    module of the ISN transport.

Author:

    Adam Barr (adamba) 22-November-1993

Environment:

    Kernel mode

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop


//
// Work Item structure for work items put on the Kernel Excutive worker threads
//
typedef struct
{
    WORK_QUEUE_ITEM         Item;   // Used by OS to queue these requests
    PVOID                   Context;
} NBI_WORK_ITEM_CONTEXT;



VOID
SendDgram(
    PNDIS_PACKET            Packet
    )
/*++

Routine Description:

    This routine sends a datagram from a Worker thread.
    Earlier, this code was part of the NbiSendComplete module,
    but since we could end up with a stack overflow, this may
    now be handled over a worker thread.

Arguments:

    WorkItem    - The work item that was allocated for this.

Return Value:

    None.

--*/

{
    PNB_SEND_RESERVED       Reserved = (PNB_SEND_RESERVED)(Packet->ProtocolReserved);
    NDIS_STATUS             Status;
    PNETBIOS_CACHE          CacheName;
    PDEVICE Device =        NbiDevice;

    NB_CONNECTIONLESS UNALIGNED * Header;
    PIPX_LOCAL_TARGET LocalTarget;
    ULONG   HeaderLength;
    ULONG   PacketLength;

    // send the datagram on the next net.
    CTEAssert (!Reserved->u.SR_DG.Cache->Unique);
    Reserved->SendInProgress = TRUE;
    CacheName = Reserved->u.SR_DG.Cache;

    //
    // Fill in the IPX header -- the default header has the broadcast
    // address on net 0 as the destination IPX address, so we modify
    // that for the current netbios cache entry if needed.
    //
    Header = (NB_CONNECTIONLESS UNALIGNED *) (&Reserved->Header[Device->Bind.IncludedHeaderOffset]);
    RtlCopyMemory((PVOID)&Header->IpxHeader, &Device->ConnectionlessHeader, sizeof(IPX_HEADER));


    *(UNALIGNED ULONG *)Header->IpxHeader.DestinationNetwork = CacheName->Networks[Reserved->u.SR_DG.CurrentNetwork].Network;
    RtlCopyMemory (&Header->IpxHeader.DestinationNode, BroadcastAddress, 6);

    LocalTarget = &CacheName->Networks[Reserved->u.SR_DG.CurrentNetwork].LocalTarget;
    HeaderLength = sizeof(IPX_HEADER) + sizeof(NB_DATAGRAM);
    PacketLength = HeaderLength + (ULONG) REQUEST_INFORMATION(Reserved->u.SR_DG.DatagramRequest);

    Header->IpxHeader.PacketLength[0] = (UCHAR)(PacketLength / 256);
    Header->IpxHeader.PacketLength[1] = (UCHAR)(PacketLength % 256);
    Header->IpxHeader.PacketType = 0x04;

    //
    // Now fill in the Netbios header.
    //
    Header->Datagram.ConnectionControlFlag = 0x00;
    RtlCopyMemory(
        Header->Datagram.SourceName,
        Reserved->u.SR_DG.AddressFile->Address->NetbiosAddress.NetbiosName,
        16);

    if (Reserved->u.SR_DG.RemoteName != (PVOID)-1) {

        //
        // This is a directed, as opposed to broadcast, datagram.
        //

        Header->Datagram.DataStreamType = NB_CMD_DATAGRAM;
        RtlCopyMemory(
            Header->Datagram.DestinationName,
            Reserved->u.SR_DG.RemoteName->NetbiosName,
            16);

    } else {

        Header->Datagram.DataStreamType = NB_CMD_BROADCAST_DATAGRAM;
        RtlZeroMemory(
            Header->Datagram.DestinationName,
            16);

    }

    //
    // Now send the frame (IPX will adjust the length of the
    // first buffer and the whole frame correctly).
    //
    if ((Status = (*Device->Bind.SendHandler) (LocalTarget,
                                               Packet,
                                               PacketLength,
                                               HeaderLength)) != STATUS_PENDING) {

        NbiSendComplete (Packet, Status);
    }
}



VOID
NbiDelayedSendDatagram(
    IN PVOID    pContextInfo
    )
{
    NBI_WORK_ITEM_CONTEXT   *pContext = (NBI_WORK_ITEM_CONTEXT *) pContextInfo;
    PNDIS_PACKET            Packet = (PNDIS_PACKET) pContext->Context;
    PNB_SEND_RESERVED       Reserved = (PNB_SEND_RESERVED)(Packet->ProtocolReserved);

    Reserved->CurrentSendIteration = 0;
    SendDgram (Packet);

    NbiFreeMemory (pContextInfo, sizeof(NBI_WORK_ITEM_CONTEXT), MEMORY_WORK_ITEM,
                   "Free delayed DgramSend work item");
}




VOID
NbiSendComplete(
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS Status
)

/*++

Routine Description:

    This routine handles a send completion call from IPX.

Arguments:

    Packet - The packet which has been completed.

    Status - The status of the send.

Return Value:

    None.

--*/



{
    PDEVICE Device = NbiDevice;
    PADDRESS Address;
    PADDRESS_FILE AddressFile;
    PCONNECTION Connection;
    PREQUEST DatagramRequest;
    PREQUEST SendRequest, TmpRequest;
    PNDIS_BUFFER CurBuffer, TmpBuffer;
    PNETBIOS_CACHE CacheName;
    PNDIS_BUFFER SecondBuffer = NULL;
    PVOID SecondBufferMemory = NULL;
    UINT SecondBufferLength;
    ULONG oldvalue;
    PNB_SEND_RESERVED Reserved = (PNB_SEND_RESERVED)(Packet->ProtocolReserved);
    CTELockHandle   CancelLH;
#if     defined(_PNP_POWER)
    CTELockHandle   LockHandle;
#endif  _PNP_POWER

    //
    // We jump back here if we re-call send from inside this
    // function and it doesn't pend (to avoid stack overflow).
    //
    ++Device->Statistics.PacketsSent;

    switch (Reserved->Type) {

    case SEND_TYPE_SESSION_DATA:

        //
        // This was a send on a session. This references the
        // IRP.
        //

        NB_DEBUG2 (SEND, ("Complete NDIS packet %lx\n", Reserved));

        CTEAssert (Reserved->SendInProgress);
        Reserved->SendInProgress = FALSE;

        Connection = Reserved->u.SR_CO.Connection;
        SendRequest = Reserved->u.SR_CO.Request;

        if (!Reserved->u.SR_CO.NoNdisBuffer) {

            CurBuffer = NDIS_BUFFER_LINKAGE (NDIS_BUFFER_LINKAGE(Reserved->HeaderBuffer));
            while (CurBuffer) {
                TmpBuffer = NDIS_BUFFER_LINKAGE (CurBuffer);
                NdisFreeBuffer (CurBuffer);
                CurBuffer = TmpBuffer;
            }

        }

        //
        // If NoNdisBuffer is TRUE, then we could set
        // Connection->SendBufferInUse to FALSE here. The
        // problem is that a new send might be in progress
        // by the time this completes and it may have
        // used the user buffer, then if we need to
        // retransmit that packet we would use the buffer
        // twice. We instead rely on the fact that whenever
        // we make a new send active we set SendBufferInUse
        // to FALSE. The net effect is that the user's buffer
        // can be used the first time a send is packetize
        // but not on resends.
        //

        NDIS_BUFFER_LINKAGE (NDIS_BUFFER_LINKAGE(Reserved->HeaderBuffer)) = NULL;
        NdisRecalculatePacketCounts (Packet);

#if DBG
        if (REQUEST_REFCOUNT(SendRequest) > 100) {
            DbgPrint ("Request %lx (%lx) has high refcount\n",
                Connection, SendRequest);
            DbgBreakPoint();
        }
#endif

#if defined(__PNP)
        NB_GET_LOCK( &Connection->Lock, &LockHandle );
        oldvalue = REQUEST_REFCOUNT(SendRequest)--;
        if ( DEVICE_NETWORK_PATH_NOT_FOUND == Status ) {
            Connection->LocalTarget = Reserved->LocalTarget;
        }
        NB_FREE_LOCK( &Connection->Lock, LockHandle );
#else
        oldvalue = NB_ADD_ULONG(
            &REQUEST_REFCOUNT (SendRequest),
            (ULONG)-1,
            &Connection->Lock);
#endif  __PNP

        if (oldvalue == 1) {

            //
            // If the refcount on this request is now zero then
            // we already got the ack for it, which means
            // that the ack-processing code has unlinked the
            // request from Connection->SendQueue. So we
            // can just run the queue of connections here
            // and complete them.
            //
            // We dereference the connection for all but one
            // of the requests, we hang on to that until a bit
            // later so everything stays around.
            //

            while (TRUE) {

                TmpRequest = REQUEST_SINGLE_LINKAGE (SendRequest);
                NB_DEBUG2 (SEND, ("Completing request %lx from send complete\n", SendRequest));
                REQUEST_STATUS (SendRequest) = STATUS_SUCCESS;

                NB_GET_CANCEL_LOCK( &CancelLH );
                IoSetCancelRoutine (SendRequest, (PDRIVER_CANCEL)NULL);
                NB_FREE_CANCEL_LOCK( CancelLH );

                NbiCompleteRequest (SendRequest);
                NbiFreeRequest (Device, SendRequest);
                ++Connection->ConnectionInfo.TransmittedTsdus;
                SendRequest = TmpRequest;

                if (SendRequest == NULL) {
                    break;
                }
                NbiDereferenceConnection (Connection, CREF_SEND);

            }

        }

        if (Reserved->OwnedByConnection) {

            Connection->SendPacketInUse = FALSE;

            if (Connection->OnWaitPacketQueue) {

                //
                // This will put the connection on the packetize
                // queue if appropriate.
                //

                NbiCheckForWaitPacket (Connection);

            }

        } else {

            NbiPushSendPacket(Reserved);

        }

        if (oldvalue == 1) {
            NbiDereferenceConnection (Connection, CREF_SEND);
        }

        break;

    case SEND_TYPE_NAME_FRAME:

        //
        // The frame is an add name/delete name; put it back in
        // the pool and deref the address.
        //

        CTEAssert (Reserved->SendInProgress);

        Address = Reserved->u.SR_NF.Address;

        Reserved->SendInProgress = FALSE;

        NbiPushSendPacket (Reserved);

        if (Address) {
            NbiDereferenceAddress (Address, AREF_NAME_FRAME);
        } else {
            NbiDereferenceDevice (Device, DREF_NAME_FRAME);
        }

        break;

    case SEND_TYPE_SESSION_INIT:

        //
        // This is a session initialize or session init ack; free
        // the second buffer, put the packet back in the pool and
        // deref the device.
        //

        CTEAssert (Reserved->SendInProgress);
        Reserved->SendInProgress = FALSE;

        NdisUnchainBufferAtBack (Packet, &SecondBuffer);
        if (SecondBuffer)
        {
            NdisQueryBufferSafe (SecondBuffer, &SecondBufferMemory, &SecondBufferLength, HighPagePriority);
            CTEAssert (SecondBufferLength == sizeof(NB_SESSION_INIT));
            if (SecondBufferMemory)
            {
                NbiFreeMemory (SecondBufferMemory, sizeof(NB_SESSION_INIT), MEMORY_CONNECTION,
                               "Session Initialize");
            }
            NdisFreeBuffer(SecondBuffer);
        }

        NbiPushSendPacket (Reserved);
        NbiDereferenceDevice (Device, DREF_SESSION_INIT);

        break;

    case SEND_TYPE_SESSION_NO_DATA:

        //
        // This is a frame which was sent on a connection but
        // has no data (ack, session end, session end ack).
        //

        CTEAssert (Reserved->SendInProgress);
        Reserved->SendInProgress = FALSE;

        Connection = Reserved->u.SR_CO.Connection;

        if (Reserved->OwnedByConnection) {

            CTEAssert (Connection != NULL);
            Connection->SendPacketInUse = FALSE;

            if (Connection->OnWaitPacketQueue) {

                //
                // This will put the connection on the packetize
                // queue if appropriate.
                //

                NbiCheckForWaitPacket (Connection);

            }

        } else {

            NbiPushSendPacket(Reserved);

        }

        if (Connection != NULL) {
            NbiDereferenceConnection (Connection, CREF_FRAME);
        } else {
            NbiDereferenceDevice (Device, DREF_FRAME);
        }

        break;

    case SEND_TYPE_FIND_NAME:

        //
        // The frame is a find name; just set SendInProgress to
        // FALSE and FindNameTimeout will clean it up.
        //
#if     defined(_PNP_POWER)
        NB_GET_LOCK( &Device->Lock, &LockHandle);
        CTEAssert (Reserved->SendInProgress);
        Reserved->SendInProgress = FALSE;
        //
        // We keep track of when it finds a net that isn't
        // a down wan line so that we can tell when datagram
        // sends should fail (otherwise we succeed them, so
        // the browser won't think this is a down wan line).
        //
        if ( STATUS_SUCCESS == Status ) {
            NB_SET_SR_FN_SENT_ON_UP_LINE (Reserved, TRUE);
        } else {
            NB_DEBUG( CACHE, ("Send complete of find name with failure %lx\n",Status ));
        }
        NB_FREE_LOCK(&Device->Lock, LockHandle);
#else
        CTEAssert (Reserved->SendInProgress);
        Reserved->SendInProgress = FALSE;
#endif  _PNP_POWER
        break;

    case SEND_TYPE_DATAGRAM:

        //
        // If there are any more networks to send this on then
        // do so, otherwise put it back in the pool and complete
        // the request.
        //

        CTEAssert (Reserved->SendInProgress);
        Reserved->SendInProgress = FALSE;

        if ((Reserved->u.SR_DG.Cache == NULL) ||
            (++Reserved->u.SR_DG.CurrentNetwork >=
                Reserved->u.SR_DG.Cache->NetworksUsed)) {

            AddressFile = Reserved->u.SR_DG.AddressFile;
            DatagramRequest = Reserved->u.SR_DG.DatagramRequest;

            NB_DEBUG2 (DATAGRAM, ("Completing datagram %lx on %lx\n", DatagramRequest, AddressFile));

            //
            // Remove any user buffers chained on this packet.
            //

            NdisReinitializePacket (Packet);
            NDIS_BUFFER_LINKAGE (NDIS_BUFFER_LINKAGE(Reserved->HeaderBuffer)) = NULL;
            NdisChainBufferAtFront (Packet, Reserved->HeaderBuffer);

            //
            // Complete the request.
            //

            REQUEST_STATUS(DatagramRequest) = Status;

            NbiCompleteRequest(DatagramRequest);
            NbiFreeRequest (Device, DatagramRequest);

            CacheName = Reserved->u.SR_DG.Cache;

            NbiPushSendPacket (Reserved);

            //
            // Since we are no longer referencing the cache
            // name, see if we should delete it (this will
            // happen if the cache entry was aged out while
            // the datagram was being processed).
            //

            if (CacheName != NULL) {

                oldvalue = NB_ADD_ULONG(
                    &CacheName->ReferenceCount,
                    (ULONG)-1,
                    &Device->Lock);

                if (oldvalue == 1) {

                    NB_DEBUG2 (CACHE, ("Free aged cache entry %lx\n", CacheName));
                    NbiFreeMemory(
                        CacheName,
                        sizeof(NETBIOS_CACHE) + ((CacheName->NetworksAllocated-1) * sizeof(NETBIOS_NETWORK)),
                        MEMORY_CACHE,
                        "Free old cache");

                }
            }

            NbiDereferenceAddressFile (AddressFile, AFREF_SEND_DGRAM);

        } else {
            NBI_WORK_ITEM_CONTEXT   *WorkItem;

            if ((++Reserved->CurrentSendIteration >= MAX_SEND_ITERATIONS) &&
                (WorkItem = (NBI_WORK_ITEM_CONTEXT *) NbiAllocateMemory (sizeof(NBI_WORK_ITEM_CONTEXT),
                                                                        MEMORY_WORK_ITEM,
                                                                        "Delayed DgramSend work item")))
            {
                WorkItem->Context = (PVOID) Packet;
                ExInitializeWorkItem (&WorkItem->Item, NbiDelayedSendDatagram, (PVOID)WorkItem);
                ExQueueWorkItem(&WorkItem->Item, DelayedWorkQueue);
            }
            else
            {
                SendDgram (Packet);
            }
        }

        break;

    case SEND_TYPE_STATUS_QUERY:

        //
        // This is an adapter status query, which is a simple
        // packet.
        //

        CTEAssert (Reserved->SendInProgress);
        Reserved->SendInProgress = FALSE;

        NbiPushSendPacket (Reserved);

        NbiDereferenceDevice (Device, DREF_STATUS_FRAME);

        break;

    case SEND_TYPE_STATUS_RESPONSE:

        //
        // This is an adapter status response, we have to free the
        // second buffer.
        //

        CTEAssert (Reserved->SendInProgress);
        Reserved->SendInProgress = FALSE;

        NdisUnchainBufferAtBack (Packet, &SecondBuffer);
        if (SecondBuffer)
        {
            NdisQueryBufferSafe (SecondBuffer, &SecondBufferMemory, &SecondBufferLength, HighPagePriority);
            if (SecondBufferMemory)
            {
                NbiFreeMemory (SecondBufferMemory, Reserved->u.SR_AS.ActualBufferLength, MEMORY_STATUS,
                               "Adapter Status");
            }

            NdisFreeBuffer(SecondBuffer);
        }

        NbiPushSendPacket (Reserved);
        NbiDereferenceDevice (Device, DREF_STATUS_RESPONSE);

        break;

#ifdef  RSRC_TIMEOUT_DBG
    case SEND_TYPE_DEATH_PACKET:

        //
        // This is a session initialize or session init ack; free
        // the second buffer, put the packet back in the pool and
        // deref the device.
        //

        CTEAssert (Reserved->SendInProgress);
        Reserved->SendInProgress = FALSE;
        DbgPrint("********Death packet send completed status %lx\n",Status);
        DbgBreakPoint();
        break;
#endif  //RSRC_TIMEOUT_DBG

    default:

        CTEAssert (FALSE);
        break;

    }

}   /* NbiSendComplete */

#if 0
ULONG NbiLoudSendQueue = 1;
#endif

VOID
NbiAssignSequenceAndSend(
    IN PCONNECTION Connection,
    IN PNDIS_PACKET Packet
    IN NB_LOCK_HANDLE_PARAM(LockHandle)
    )

/*++

Routine Description:

    This routine is used to ensure that receive sequence numbers on
    packets are numbered correctly. It is called in place of the lower-level
    send handler; after assigning the receive sequence number it locks out
    other sends until the NdisSend call has returned (not necessarily completed),
    insuring that the packets with increasing receive sequence numbers
    are queue in the right order by the MAC.

    NOTE: THIS ROUTINE IS CALLED WITH THE CONNECTION LOCK HELD, AND
    RETURNS WITH IT RELEASED.

Arguments:

    Connection - The connection the send is on.

    Packet - The packet to send.

    LockHandle - The handle with which Connection->Lock was acquired.

Return Value:

    None.

--*/

{
    NDIS_STATUS NdisStatus;
    PNB_SEND_RESERVED Reserved;
    PLIST_ENTRY p;
    NB_CONNECTION UNALIGNED * Header;
    PDEVICE Device = NbiDevice;
    BOOLEAN NdisSendReference;
    ULONG result;


    Reserved = (PNB_SEND_RESERVED)(Packet->ProtocolReserved);

    CTEAssert (Connection->State == CONNECTION_STATE_ACTIVE);

    //
    // If there is a send in progress, then queue this packet
    // and return.
    //

    if (Connection->NdisSendsInProgress > 0) {

        NB_DEBUG2 (SEND, ("Queueing send packet %lx on %lx\n", Reserved, Connection));
        InsertTailList (&Connection->NdisSendQueue, &Reserved->WaitLinkage);
        ++Connection->NdisSendsInProgress;
        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
        return;
    }

    //
    // No send in progress. Set the flag to true, and fill in the
    // receive sequence fields in the packet.
    //

    Connection->NdisSendsInProgress = 1;
    NdisSendReference = FALSE;
    Connection->NdisSendReference = &NdisSendReference;

    while (TRUE) {

        Header = (NB_CONNECTION UNALIGNED *)
                    (&Reserved->Header[Device->Bind.IncludedHeaderOffset]);
        Header->Session.ReceiveSequence = Connection->ReceiveSequence;
        if (Connection->NewNetbios) {
            Header->Session.ReceiveSequenceMax = Connection->LocalRcvSequenceMax;
        } else {
            Header->Session.BytesReceived = (USHORT)Connection->CurrentReceive.MessageOffset;
        }

        //
        // Since we are acking as much as we know, we can clear
        // this flag. The connection will eventually get removed
        // from the queue by the long timeout.
        //

        Connection->DataAckPending = FALSE;

        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

        NdisAdjustBufferLength(NB_GET_NBHDR_BUFF(Packet), sizeof(NB_CONNECTION));
        NdisStatus = (*Device->Bind.SendHandler)(
                         &Connection->LocalTarget,
                         Packet,
                         Reserved->u.SR_CO.PacketLength,
                         sizeof(NB_CONNECTION));

        if (NdisStatus != NDIS_STATUS_PENDING) {

            NbiSendComplete(
                Packet,
                NdisStatus);

        }

        //
        // Take the ref count down, which may allow others
        // to come through.
        //

        result = NB_ADD_ULONG(
                     &Connection->NdisSendsInProgress,
                     (ULONG)-1,
                     &Connection->Lock);

        //
        // We have now sent a packet, see if any queued up while we
        // were doing it. If the count was zero after removing ours,
        // then anything else queued is being processed, so we can
        // exit. If the connection was stopped while we were sending,
        // a special reference was added which we remove (NbiStopConnection
        // sets NdisSendReference to TRUE, using the pointer saved
        // in Connection->NdisSendReference).
        //

        if (result == 1) {
            if (NdisSendReference) {
                NB_DEBUG2 (SEND, ("Remove CREF_NDIS_SEND from %lx\n", Connection));
                NbiDereferenceConnection (Connection, CREF_NDIS_SEND);
            }
            return;
        }

        NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);

        p = RemoveHeadList(&Connection->NdisSendQueue);

        //
        // If the refcount was not zero, then nobody else should
        // have taken packets off since they would have been
        // blocked by us. So, the queue should not be empty.
        //

        ASSERT (p != &Connection->NdisSendQueue);

        Reserved = CONTAINING_RECORD (p, NB_SEND_RESERVED, WaitLinkage);
        Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);

    }   // while loop

    //
    // We should never reach here.
    //

    CTEAssert (FALSE);

    NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

}   /* NbiAssignSequenceAndSend */


NTSTATUS
NbiTdiSend(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine does a send on an active connection.

Arguments:

    Device - The netbios device.

    Request - The request describing the send.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PCONNECTION Connection;
    PTDI_REQUEST_KERNEL_SEND Parameters;
    NB_DEFINE_SYNC_CONTEXT (SyncContext)
    NB_DEFINE_LOCK_HANDLE (LockHandle)
    CTELockHandle   CancelLH;

    //
    // Check that the file type is valid
    //
    if (REQUEST_OPEN_TYPE(Request) != (PVOID)TDI_CONNECTION_FILE)
    {
        CTEAssert(FALSE);
        return (STATUS_INVALID_ADDRESS_COMPONENT);
    }

    //
    // First make sure the connection is valid.
    //
    Connection = (PCONNECTION)REQUEST_OPEN_CONTEXT(Request);

    if (Connection->Type == NB_CONNECTION_SIGNATURE) {

        NB_GET_CANCEL_LOCK( &CancelLH );
        NB_BEGIN_SYNC (&SyncContext);
        NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);

        //
        // Make sure the connection is in a good state.
        //

        if (Connection->State == CONNECTION_STATE_ACTIVE) {

            //
            // If the connection is idle then send it now, otherwise
            // queue it.
            //


            if (!Request->Cancel) {


                Parameters = (PTDI_REQUEST_KERNEL_SEND)REQUEST_PARAMETERS(Request);

                //
                // For old netbios, don't allow sends greater than 64K-1.
                //

                if ((Connection->NewNetbios) ||
                    (Parameters->SendLength <= 0xffff)) {

                    IoSetCancelRoutine (Request, NbiCancelSend);
                    NB_SYNC_SWAP_IRQL( CancelLH, LockHandle );
                    NB_FREE_CANCEL_LOCK( CancelLH );

                    REQUEST_INFORMATION (Request) = Parameters->SendLength;   // assume it succeeds.

                    REQUEST_REFCOUNT (Request) = 1;   // refcount starts at 1.
                    NbiReferenceConnectionSync (Connection, CREF_SEND);

                    //
                    // NOTE: The connection send queue is managed such
                    // that the current send being packetized is not on
                    // the queue. For multiple-request messages, the
                    // first one is not on the queue, but its linkage
                    // field points to the next request in the message
                    // (which will be on the head of the queue).
                    //

                    if ((Parameters->SendFlags & TDI_SEND_PARTIAL) == 0) {

                        //
                        // This is a final send.
                        //

                        if (Connection->SubState == CONNECTION_SUBSTATE_A_IDLE) {

                            NB_DEBUG2 (SEND, ("Send %lx, connection %lx idle\n", Request, Connection));

                            Connection->CurrentSend.Request = Request;
                            Connection->CurrentSend.MessageOffset = 0;
                            Connection->CurrentSend.Buffer = REQUEST_NDIS_BUFFER (Request);
                            Connection->CurrentSend.BufferOffset = 0;
                            Connection->SendBufferInUse = FALSE;

                            Connection->UnAckedSend = Connection->CurrentSend;

                            Connection->FirstMessageRequest = Request;
#ifdef  RSRC_TIMEOUT_DBG
                            KeQuerySystemTime(&Connection->FirstMessageRequestTime);

                            (((LARGE_INTEGER UNALIGNED *)&(IoGetCurrentIrpStackLocation(Request))->Parameters.Others.Argument3))->QuadPart =
                                Connection->FirstMessageRequestTime.QuadPart;
#endif  //RSRC_TIMEOUT_DBG

                            Connection->LastMessageRequest = Request;
                            Connection->CurrentMessageLength = Parameters->SendLength;

                            //
                            // This frees the connection lock.
                            //

                            NbiPacketizeSend(
                                Connection
                                NB_LOCK_HANDLE_ARG(LockHandle)
                                );

                        } else if (Connection->SubState == CONNECTION_SUBSTATE_A_W_EOR) {

                            //
                            // We have been collecting partial sends waiting
                            // for a final one, which we have now received,
                            // so start packetizing.
                            //
                            // We chain it on the back of the send queue,
                            // in addition if this is the second request in the
                            // message, we have to link the first request (which
                            // is not on the queue) to this one.
                            //
                            //

                            NB_DEBUG2 (SEND, ("Send %lx, connection %lx got eor\n", Request, Connection));

                            Connection->LastMessageRequest = Request;
                            Connection->CurrentMessageLength += Parameters->SendLength;

                            if (Connection->SendQueue.Head == NULL) {
                                REQUEST_SINGLE_LINKAGE(Connection->FirstMessageRequest) = Request;
                            }
                            REQUEST_SINGLE_LINKAGE(Request) = NULL;
                            REQUEST_LIST_INSERT_TAIL(&Connection->SendQueue, Request);

                            Connection->UnAckedSend = Connection->CurrentSend;
#ifdef  RSRC_TIMEOUT_DBG
                            {
                                LARGE_INTEGER   Time;

                                KeQuerySystemTime(&Time);
                                (((LARGE_INTEGER UNALIGNED *)&(IoGetCurrentIrpStackLocation(Request))->Parameters.Others.Argument3))->QuadPart =
                                    Time.QuadPart;
                            }
#endif  //RSRC_TIMEOUT_DBG
                            //
                            // This frees the connection lock.
                            //

                            NbiPacketizeSend(
                                Connection
                                NB_LOCK_HANDLE_ARG(LockHandle)
                                );

                        } else {

                            //
                            // The state is PACKETIZE, W_ACK, or W_PACKET.
                            //

                            NB_DEBUG2 (SEND, ("Send %lx, connection %lx busy\n", Request, Connection));

                            REQUEST_SINGLE_LINKAGE(Request) = NULL;
                            REQUEST_LIST_INSERT_TAIL(&Connection->SendQueue, Request);

#ifdef  RSRC_TIMEOUT_DBG
                            {
                                LARGE_INTEGER   Time;
                                KeQuerySystemTime(&Time);
                                (((LARGE_INTEGER UNALIGNED *)&(IoGetCurrentIrpStackLocation(Request))->Parameters.Others.Argument3))->QuadPart =
                                    Time.QuadPart;
                            }
#endif  //RSRC_TIMEOUT_DBG

                            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

                        }

                    } else {

                        //
                        // This is a partial send. We queue them up without
                        // packetizing until we get a final (this is because
                        // we have to put a correct Connection->CurrentMessageLength
                        // in the frames.
                        //

                        if (Connection->SubState == CONNECTION_SUBSTATE_A_IDLE) {

                            //
                            // Start collecting partial sends. NOTE: Partial sends
                            // are always inserted in the send queue
                            //

                            Connection->CurrentSend.Request = Request;
                            Connection->CurrentSend.MessageOffset = 0;
                            Connection->CurrentSend.Buffer = REQUEST_NDIS_BUFFER (Request);
                            Connection->CurrentSend.BufferOffset = 0;
                            Connection->SendBufferInUse = FALSE;

                            Connection->FirstMessageRequest = Request;
#ifdef  RSRC_TIMEOUT_DBG
                            KeQuerySystemTime(&Connection->FirstMessageRequestTime);
                            (((LARGE_INTEGER UNALIGNED *)&(IoGetCurrentIrpStackLocation(Request))->Parameters.Others.Argument3))->QuadPart =
                                Connection->FirstMessageRequestTime.QuadPart;
#endif  //RSRC_TIMEOUT_DBG

                            Connection->CurrentMessageLength = Parameters->SendLength;

                            Connection->SubState = CONNECTION_SUBSTATE_A_W_EOR;

                        } else if (Connection->SubState == CONNECTION_SUBSTATE_A_W_EOR) {

                            //
                            // We have got another partial send to add to our
                            // list. We chain it on the back of the send queue,
                            // in addition if this is the second request in the
                            // message, we have to link the first request (which
                            // is not on the queue) to this one.
                            //

                            Connection->LastMessageRequest = Request;
                            Connection->CurrentMessageLength += Parameters->SendLength;

                            if (Connection->SendQueue.Head == NULL) {
                                REQUEST_SINGLE_LINKAGE(Connection->FirstMessageRequest) = Request;
                            }
                            REQUEST_SINGLE_LINKAGE(Request) = NULL;
                            REQUEST_LIST_INSERT_TAIL(&Connection->SendQueue, Request);
#ifdef  RSRC_TIMEOUT_DBG
                            {
                                LARGE_INTEGER   Time;
                                KeQuerySystemTime(&Time);
                                (((LARGE_INTEGER UNALIGNED *)&(IoGetCurrentIrpStackLocation(Request))->Parameters.Others.Argument3))->QuadPart =
                                    Time.QuadPart;
                            }
#endif  //RSRC_TIMEOUT_DBG
                        } else {

                            REQUEST_SINGLE_LINKAGE(Request) = NULL;
                            REQUEST_LIST_INSERT_TAIL(&Connection->SendQueue, Request);

#ifdef  RSRC_TIMEOUT_DBG
                            {
                                LARGE_INTEGER   Time;
                                KeQuerySystemTime(&Time);
                                (((LARGE_INTEGER UNALIGNED *)&(IoGetCurrentIrpStackLocation(Request))->Parameters.Others.Argument3))->QuadPart =
                                    Time.QuadPart;
                            }
#endif  //RSRC_TIMEOUT_DBG
                        }

                        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

                    }

                    NB_END_SYNC (&SyncContext);
                    return STATUS_PENDING;

                } else {

                    NB_DEBUG2 (SEND, ("Send %lx, too long for connection %lx (%d)\n", Request, Connection, Parameters->SendLength));
                    NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
                    NB_END_SYNC (&SyncContext);
                    NB_FREE_CANCEL_LOCK( CancelLH );
                    return STATUS_INVALID_PARAMETER;

                }

            } else {

                NB_DEBUG2 (SEND, ("Send %lx, connection %lx cancelled\n", Request, Connection));
                NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
                NB_END_SYNC (&SyncContext);
                NB_FREE_CANCEL_LOCK( CancelLH );
                return STATUS_CANCELLED;

            }

        } else {

            NB_DEBUG (SEND, ("Send connection %lx state is %d\n", Connection, Connection->State));
            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
            NB_END_SYNC (&SyncContext);
            NB_FREE_CANCEL_LOCK( CancelLH );
            return STATUS_INVALID_CONNECTION;

        }

    } else {

        NB_DEBUG (SEND, ("Send connection %lx has bad signature\n", Connection));
        return STATUS_INVALID_CONNECTION;

    }

}   /* NbiTdiSend */


VOID
NbiPacketizeSend(
    IN PCONNECTION Connection
    IN NB_LOCK_HANDLE_PARAM(LockHandle)
    )

/*++

Routine Description:

    This routine does a send on an active connection.

    NOTE: THIS FUNCTION IS CALLED WITH CONNECTION->LOCK HELD
    AND RETURNS WITH IT RELEASED.

Arguments:

    Connection - The connection.

    LockHandle - The handle used to acquire the lock.

Return Value:

    None.

--*/

{
    PREQUEST Request;
    PNDIS_PACKET Packet;
    PNDIS_BUFFER BufferChain;
    PNB_SEND_RESERVED Reserved;
    PDEVICE Device = NbiDevice;
    NB_CONNECTION UNALIGNED * Header;
    ULONG PacketLength;
    ULONG PacketSize;
    ULONG DesiredLength;
    ULONG ActualLength;
    NTSTATUS Status;
    PSLIST_ENTRY s;
    USHORT ThisSendSequence;
    USHORT ThisOffset;
    BOOLEAN ExitAfterSend;
    UCHAR ConnectionControlFlag;
    CTELockHandle   DeviceLockHandle;

    //
    // We jump back here if we are talking new Netbios and it
    // is OK to packetize another send.
    //

SendAnotherPacket:

    //
    // If we decide to packetize another send after this, we
    // change ExitAfterSend to FALSE and SubState to PACKETIZE.
    // Right now we don't change SubState in case it is W_PACKET.
    //

    ExitAfterSend = TRUE;

    CTEAssert (Connection->CurrentSend.Request != NULL);

    if (Connection->NewNetbios) {

        //
        // Check that we have send window, both that advertised
        // by the remote and our own locally-decided window which
        // may be smaller.
        //

        if (((USHORT)(Connection->CurrentSend.SendSequence-1) == Connection->RemoteRcvSequenceMax) ||
            (((USHORT)(Connection->CurrentSend.SendSequence - Connection->UnAckedSend.SendSequence)) >= Connection->SendWindowSize)) {

            //
            // Keep track of whether we are waiting because of his window
            // or because of our local window. If it is because of our local
            // window then we may want to adjust it after this window
            // is acked.
            //

            if ((USHORT)(Connection->CurrentSend.SendSequence-1) != Connection->RemoteRcvSequenceMax) {
                Connection->SubState = CONNECTION_SUBSTATE_A_W_ACK;
                NB_DEBUG2 (SEND, ("Connection %lx local shut down at %lx, %lx\n", Connection, Connection->CurrentSend.SendSequence, Connection->UnAckedSend.SendSequence));
            } else {
                Connection->SubState = CONNECTION_SUBSTATE_A_REMOTE_W;
                NB_DEBUG2 (SEND, ("Connection %lx remote shut down at %lx\n", Connection, Connection->CurrentSend.SendSequence));
            }

            //
            // Start the timer so we will keep bugging him about
            // this. What if he doesn't get a receive down
            // quickly -- but this is better than losing his ack
            // and then dying. We won't really back off our timer
            // because we will keep getting acks, and resetting it.
            //

            NbiStartRetransmit (Connection);
            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
            return;

        }

    }

    Request = Connection->CurrentSend.Request;

    //
    // If we are in this routine then we know that
    // we are coming out of IDLE, W_ACK, or W_PACKET
    // and we still have the lock held. We also know
    // that there is a send request in progress. If
    // an ack for none or part of the last packet was
    // received, then our send pointers have been
    // adjusted to reflect that.
    //

    //
    // First get a packet for the current send.
    //

    if (!Connection->SendPacketInUse) {

        Connection->SendPacketInUse = TRUE;
        Packet = PACKET(&Connection->SendPacket);
        Reserved = (PNB_SEND_RESERVED)(Packet->ProtocolReserved);

    } else {

        s = ExInterlockedPopEntrySList(
                &Device->SendPacketList,
                &NbiGlobalPoolInterlock);

        if (s == NULL) {

            //
            // This function tries to allocate another packet pool.
            //

            s = NbiPopSendPacket(Device, FALSE);

            if (s == NULL) {

                //
                // It is possible to come in here and already be in
                // W_PACKET state -- this is because we may packetize
                // when in that state, and rather than always be
                // checking that we weren't in W_PACKET, we go
                // ahead and check again here.
                //

                if (Connection->SubState != CONNECTION_SUBSTATE_A_W_PACKET) {

                    Connection->SubState = CONNECTION_SUBSTATE_A_W_PACKET;

                    NB_GET_LOCK (&Device->Lock, &DeviceLockHandle);
                    if (!Connection->OnWaitPacketQueue) {

                        NbiReferenceConnectionLock (Connection, CREF_W_PACKET);

                        Connection->OnWaitPacketQueue = TRUE;

                        InsertTailList(
                            &Device->WaitPacketConnections,
                            &Connection->WaitPacketLinkage
                            );

//                        NB_INSERT_TAIL_LIST(
//                            &Device->WaitPacketConnections,
//                            &Connection->WaitPacketLinkage,
//                            &Device->Lock);

                    }
                    NB_FREE_LOCK (&Device->Lock, DeviceLockHandle);
                }

                NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
                return;
            }
        }

        Reserved = CONTAINING_RECORD (s, NB_SEND_RESERVED, PoolLinkage);
        Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);

    }

    //
    // Set this now, we will change it later if needed.
    //

    Connection->SubState = CONNECTION_SUBSTATE_A_W_ACK;


    //
    // Save these since they go in this next packet.
    //

    ThisSendSequence = Connection->CurrentSend.SendSequence;
    ThisOffset = (USHORT)Connection->CurrentSend.MessageOffset;


    //
    // Now see if we need to copy the buffer chain.
    //

    PacketSize = Connection->MaximumPacketSize;

    if (Connection->CurrentSend.MessageOffset + PacketSize >= Connection->CurrentMessageLength) {

        PacketSize = Connection->CurrentMessageLength - Connection->CurrentSend.MessageOffset;

        if ((Connection->CurrentSend.MessageOffset == 0) &&
            (!Connection->SendBufferInUse)) {

            //
            // If the entire send remaining fits in one packet,
            // and this is also the first packet in the send,
            // then the entire send fits in one packet and
            // we don't need to build a duplicate buffer chain.
            //

            BufferChain = Connection->CurrentSend.Buffer;
            Reserved->u.SR_CO.NoNdisBuffer = TRUE;
            Connection->CurrentSend.Buffer = NULL;
            Connection->CurrentSend.BufferOffset = 0;
            Connection->CurrentSend.MessageOffset = Connection->CurrentMessageLength;
            Connection->CurrentSend.Request = NULL;
            ++Connection->CurrentSend.SendSequence;
            Connection->SendBufferInUse = TRUE;
            if (Connection->NewNetbios) {
                if ((ThisSendSequence == Connection->RemoteRcvSequenceMax) ||
                    ((((PTDI_REQUEST_KERNEL_SEND)REQUEST_PARAMETERS(Request))->SendFlags) &
                        TDI_SEND_NO_RESPONSE_EXPECTED)) {  // optimize this check
                    ConnectionControlFlag = NB_CONTROL_EOM | NB_CONTROL_SEND_ACK;
                } else {
                    ConnectionControlFlag = NB_CONTROL_EOM;
                }
                Connection->PiggybackAckTimeout = FALSE;
            } else {
                ConnectionControlFlag = NB_CONTROL_SEND_ACK;
            }

            if (BufferChain != NULL) {
                NB_DEBUG2 (SEND, ("Send packet %lx on %lx (%d/%d), user buffer\n",
                Reserved, Connection,
                    Connection->CurrentSend.SendSequence,
                    Connection->CurrentSend.MessageOffset));
                NdisChainBufferAtBack (Packet, BufferChain);
            } else {
                NB_DEBUG2 (SEND, ("Send packet %lx on %lx (%d/%d), no buffer\n",
                    Reserved, Connection,
                    Connection->CurrentSend.SendSequence,
                    Connection->CurrentSend.MessageOffset));
            }

            goto GotBufferChain;

        }

    }

    //
    // We need to build a partial buffer chain. In the case
    // where the current request is a partial one, we may
    // build this from the ndis buffer chains of several
    // requests.
    //

    if (PacketSize > 0) {

        DesiredLength = PacketSize;

        NB_DEBUG2 (SEND, ("Send packet %lx on %lx (%d/%d), allocate buffer\n",
            Reserved, Connection,
            Connection->CurrentSend.SendSequence,
            Connection->CurrentSend.MessageOffset));

        while (TRUE) {

            Status = NbiBuildBufferChainFromBufferChain (
                        Device->NdisBufferPoolHandle,
                        Connection->CurrentSend.Buffer,
                        Connection->CurrentSend.BufferOffset,
                        DesiredLength,
                        &BufferChain,
                        &Connection->CurrentSend.Buffer,
                        &Connection->CurrentSend.BufferOffset,
                        &ActualLength);

            if (Status != STATUS_SUCCESS) {

                PNDIS_BUFFER CurBuffer, TmpBuffer;

                NB_DEBUG2 (SEND, ("Allocate buffer chain failed for packet %lx\n", Reserved));

                //
                // We could not allocate resources for this send.
                // We'll put the connection on the packetize
                // queue and hope we get more resources later.
                //

                NbiReferenceConnectionSync (Connection, CREF_PACKETIZE);

                CTEAssert (!Connection->OnPacketizeQueue);
                Connection->OnPacketizeQueue = TRUE;

                //
                // Connection->CurrentSend can stay where it is.
                //

                NB_INSERT_TAIL_LIST(
                    &Device->PacketizeConnections,
                    &Connection->PacketizeLinkage,
                    &Device->Lock);

                Connection->SubState = CONNECTION_SUBSTATE_A_PACKETIZE;

                NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

                //
                // Free any buffers we have allocated on previous calls
                // to BuildBufferChain inside this same while(TRUE) loop,
                // then free the packet.
                //

                CurBuffer = NDIS_BUFFER_LINKAGE (NDIS_BUFFER_LINKAGE(Reserved->HeaderBuffer));
                while (CurBuffer) {
                    TmpBuffer = NDIS_BUFFER_LINKAGE (CurBuffer);
                    NdisFreeBuffer (CurBuffer);
                    CurBuffer = TmpBuffer;
                }

                NDIS_BUFFER_LINKAGE (NDIS_BUFFER_LINKAGE(Reserved->HeaderBuffer)) = NULL;
                NdisRecalculatePacketCounts (Packet);

                if (Reserved->OwnedByConnection) {
                    Connection->SendPacketInUse = FALSE;
                } else {
                    NbiPushSendPacket(Reserved);
                }

                return;

            }

            NdisChainBufferAtBack (Packet, BufferChain);
            Connection->CurrentSend.MessageOffset += ActualLength;

            DesiredLength -= ActualLength;

            if (DesiredLength == 0) {

                //
                // We have gotten enough data for our packet.
                //

                if (Connection->CurrentSend.MessageOffset == Connection->CurrentMessageLength) {
                    Connection->CurrentSend.Request = NULL;
                }
                break;
            }

            //
            // We ran out of buffer chain on this send, which means
            // that we must have another one behind it (since we
            // don't start packetizing partial sends until all of
            // them are queued).
            //

            Request = REQUEST_SINGLE_LINKAGE(Request);
            if (Request == NULL) {
                KeBugCheck (NDIS_INTERNAL_ERROR);
            }

            Connection->CurrentSend.Request = Request;
            Connection->CurrentSend.Buffer = REQUEST_NDIS_BUFFER (Request);
            Connection->CurrentSend.BufferOffset = 0;

        }

    } else {

        //
        // This is a zero-length send (in general we will go
        // through the code before the if that uses the user's
        // buffer, but not on a resend).
        //

        Connection->CurrentSend.Buffer = NULL;
        Connection->CurrentSend.BufferOffset = 0;
        CTEAssert (Connection->CurrentSend.MessageOffset == Connection->CurrentMessageLength);
        Connection->CurrentSend.Request = NULL;

        NB_DEBUG2 (SEND, ("Send packet %lx on %lx (%d/%d), no alloc buf\n",
            Reserved, Connection,
            Connection->CurrentSend.SendSequence,
            Connection->CurrentSend.MessageOffset));

    }

    Reserved->u.SR_CO.NoNdisBuffer = FALSE;

    if (Connection->NewNetbios) {

        ++Connection->CurrentSend.SendSequence;
        if (Connection->CurrentSend.MessageOffset == Connection->CurrentMessageLength) {

            if (((USHORT)(Connection->CurrentSend.SendSequence - Connection->UnAckedSend.SendSequence)) >= Connection->SendWindowSize) {

                ConnectionControlFlag = NB_CONTROL_EOM | NB_CONTROL_SEND_ACK;

            } else if ((ThisSendSequence == Connection->RemoteRcvSequenceMax) ||
                ((((PTDI_REQUEST_KERNEL_SEND)REQUEST_PARAMETERS(Request))->SendFlags) &
                    TDI_SEND_NO_RESPONSE_EXPECTED)) {  // optimize this check

                ConnectionControlFlag = NB_CONTROL_EOM | NB_CONTROL_SEND_ACK;

            } else {

                ConnectionControlFlag = NB_CONTROL_EOM;
            }
            Connection->PiggybackAckTimeout = FALSE;

        } else if (((USHORT)(Connection->CurrentSend.SendSequence - Connection->UnAckedSend.SendSequence)) >= Connection->SendWindowSize) {

            ConnectionControlFlag = NB_CONTROL_SEND_ACK;

        } else if (ThisSendSequence == Connection->RemoteRcvSequenceMax) {

            ConnectionControlFlag = NB_CONTROL_SEND_ACK;

        } else {

            ConnectionControlFlag = 0;
            ExitAfterSend = FALSE;
            Connection->SubState = CONNECTION_SUBSTATE_A_PACKETIZE;

        }

    } else {

        ConnectionControlFlag = NB_CONTROL_SEND_ACK;
        if (Connection->CurrentSend.MessageOffset == Connection->CurrentMessageLength) {
            ++Connection->CurrentSend.SendSequence;
        }
    }

GotBufferChain:

    //
    // We have a packet and a buffer chain, there are
    // no other resources required for a send so we can
    // fill in the header and go.
    //

    CTEAssert (Reserved->SendInProgress == FALSE);
    Reserved->SendInProgress = TRUE;
    Reserved->Type = SEND_TYPE_SESSION_DATA;
    Reserved->u.SR_CO.Connection = Connection;
    Reserved->u.SR_CO.Request = Connection->FirstMessageRequest;

    PacketLength = PacketSize + sizeof(NB_CONNECTION);
    Reserved->u.SR_CO.PacketLength = PacketLength;


    Header = (NB_CONNECTION UNALIGNED *)
                (&Reserved->Header[Device->Bind.IncludedHeaderOffset]);
    RtlCopyMemory((PVOID)&Header->IpxHeader, &Connection->RemoteHeader, sizeof(IPX_HEADER));

    Header->IpxHeader.PacketLength[0] = (UCHAR)(PacketLength / 256);
    Header->IpxHeader.PacketLength[1] = (UCHAR)(PacketLength % 256);

    Header->IpxHeader.PacketType = 0x04;

    //
    // Now fill in the Netbios header. Put this in
    // a contiguous buffer in the connection ?
    //

    Header->Session.ConnectionControlFlag = ConnectionControlFlag;
    Header->Session.DataStreamType = NB_CMD_SESSION_DATA;
    Header->Session.SourceConnectionId = Connection->LocalConnectionId;
    Header->Session.DestConnectionId = Connection->RemoteConnectionId;
    Header->Session.SendSequence = ThisSendSequence;
    Header->Session.TotalDataLength = (USHORT)Connection->CurrentMessageLength;
    Header->Session.Offset = ThisOffset;
    Header->Session.DataLength = (USHORT)PacketSize;

#if 0
    //
    // These are set by NbiAssignSequenceAndSend.
    //

    Header->Session.ReceiveSequence = Connection->ReceiveSequence;
    Header->Session.BytesReceived = (USHORT)Connection->CurrentReceive.MessageOffset;
#endif

    //
    // Reference the request to account for this send.
    //

#if DBG
    if (REQUEST_REFCOUNT(Request) > 100) {
        DbgPrint ("Request %lx (%lx) has high refcount\n",
            Connection, Request);
        DbgBreakPoint();
    }
#endif
    ++REQUEST_REFCOUNT (Request);

    ++Device->TempFramesSent;
    Device->TempFrameBytesSent += PacketSize;

    //
    // Start the timer.
    //

    NbiStartRetransmit (Connection);

    //
    // This frees the lock. IPX will adjust the length of
    // the first buffer correctly.
    //

    NbiAssignSequenceAndSend(
        Connection,
        Packet
        NB_LOCK_HANDLE_ARG(LockHandle));

    if (!ExitAfterSend) {

        //
        // Did we need to reference the connection until we
        // get the lock back??
        //

        NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);
        if ((Connection->State == CONNECTION_STATE_ACTIVE) &&
            (Connection->SubState == CONNECTION_SUBSTATE_A_PACKETIZE)) {

            //
            // Jump back to the beginning of the function to
            // repacketize.

            goto SendAnotherPacket;

        } else {

            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

        }

    }

}   /* NbiPacketizeSend */


VOID
NbiAdjustSendWindow(
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This routine adjusts a connection's send window if needed. It is
    assumed that we just got an ack for a full send window.

    NOTE: THIS FUNCTION IS CALLED WITH CONNECTION->LOCK HELD
    AND RETURNS WITH IT HELD.

Arguments:

    Connection - The connection.

Return Value:

    None.

--*/

{

    if (Connection->RetransmitThisWindow) {

        //
        // Move it down. Check if this keeps happening.
        //

        if (Connection->SendWindowSize > 2) {
            --Connection->SendWindowSize;
            NB_DEBUG2 (SEND_WINDOW, ("Lower window to %d on %lx (%lx)\n", Connection->SendWindowSize, Connection, Connection->CurrentSend.SendSequence));
        }

        if (Connection->SendWindowIncrease) {

            //
            // We just increased the window.
            //

            ++Connection->IncreaseWindowFailures;
            NB_DEBUG2 (SEND_WINDOW, ("%d consecutive increase failues on %lx (%lx)\n", Connection->IncreaseWindowFailures, Connection, Connection->CurrentSend.SendSequence));

            if (Connection->IncreaseWindowFailures >= 2) {

                if (Connection->MaxSendWindowSize > 2) {

                    //
                    // Lock ourselves at a smaller window.
                    //

                    Connection->MaxSendWindowSize = Connection->SendWindowSize;
                    NB_DEBUG2 (SEND_WINDOW, ("Lock send window at %d on %lx (%lx)\n", Connection->MaxSendWindowSize, Connection, Connection->CurrentSend.SendSequence));
                }

                Connection->IncreaseWindowFailures = 0;
            }

            Connection->SendWindowIncrease = FALSE;
        }

    } else {

        //
        // Increase it if allowed, and make a note
        // in case this increase causes problems in
        // the next window.
        //

        if (Connection->SendWindowSize < Connection->MaxSendWindowSize) {

            ++Connection->SendWindowSize;
            NB_DEBUG2 (SEND_WINDOW, ("Raise window to %d on %lx (%lx)\n", Connection->SendWindowSize, Connection, Connection->CurrentSend.SendSequence));
            Connection->SendWindowIncrease = TRUE;

        } else {

            if (Connection->SendWindowIncrease) {

                //
                // We just increased it and nothing failed,
                // which is good.
                //

                Connection->SendWindowIncrease = FALSE;
                Connection->IncreaseWindowFailures = 0;
                NB_DEBUG2 (SEND_WINDOW, ("Raised window OK on %lx (%lx)\n", Connection, Connection->CurrentSend.SendSequence));
            }
        }
    }


    //
    // This controls when we'll check this again.
    //

    Connection->SendWindowSequenceLimit += Connection->SendWindowSize;

}   /* NbiAdjustSendWindow */


VOID
NbiReframeConnection(
    IN PCONNECTION Connection,
    IN USHORT ReceiveSequence,
    IN USHORT BytesReceived,
    IN BOOLEAN Resend
    IN NB_LOCK_HANDLE_PARAM(LockHandle)
    )

/*++

Routine Description:

    This routine is called when we have gotten an ack
    for some data. It completes any sends that have
    been acked, and if needed modifies the current send
    pointer and queues the connection for repacketizing.

    NOTE: THIS FUNCTION IS CALLED WITH CONNECTION->LOCK HELD
    AND RETURNS WITH IT RELEASED.

Arguments:

    Connection - The connection.

    ReceiveSequence - The receive sequence from the remote.

    BytesReceived - The number of bytes received in this message.

    Resend - If it is OK to resend based on this packet.

    LockHandle - The handle with which Connection->Lock was acquired.

Return Value:

    None.

--*/

{
    PREQUEST Request, TmpRequest;
    PREQUEST RequestToComplete;
    PDEVICE Device = NbiDevice;
    CTELockHandle   CancelLH;


    //
    // We should change to stop the timer
    // only if we go idle, since otherwise we still
    // want it running, or will restart it when we
    // packetize.
    //

    //
    // See how much is acked here.
    //

    if ((Connection->CurrentSend.MessageOffset == Connection->CurrentMessageLength) &&
        (ReceiveSequence == (USHORT)(Connection->CurrentSend.SendSequence)) &&
        (Connection->FirstMessageRequest != NULL)) {

        // Special check for 0 length send which was not accepted by the remote.
        // In this case it will pass the above 3 conditions yet, nothing
        // is acked. BUG#10395
        if (!Connection->CurrentSend.MessageOffset && Connection->CurrentSend.SendSequence == Connection->UnAckedSend.SendSequence ) {
            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
            return;
        }

        //
        // This acks the entire message.
        //

        NB_DEBUG2 (SEND, ("Got ack for entire message on %lx (%d)\n", Connection, Connection->CurrentSend.SendSequence));

        NbiStopRetransmit (Connection);

        Connection->CurrentSend.MessageOffset = 0;  //  Needed?
        Connection->UnAckedSend.MessageOffset = 0;

        //
        // We don't adjust the send window since we likely stopped
        // packetizing before we hit it.
        //

        Connection->Retries = NbiDevice->KeepAliveCount;
        Connection->CurrentRetransmitTimeout = Connection->BaseRetransmitTimeout;


        if (Connection->NewNetbios) {

            Connection->RemoteRcvSequenceMax = BytesReceived;   // really RcvSeqMac

            //
            // See if we need to adjust our send window.
            //

            if (((SHORT)(Connection->CurrentSend.SendSequence - Connection->SendWindowSequenceLimit)) >= 0) {

                NbiAdjustSendWindow (Connection);

            } else {

                //
                // Advance this, we won't get meaningful results until we
                // send a full window in one message.
                //

                Connection->SendWindowSequenceLimit = Connection->CurrentSend.SendSequence + Connection->SendWindowSize;
            }


        }

        Connection->RetransmitThisWindow = FALSE;

        Request = Connection->FirstMessageRequest;

        //
        // We dequeue these requests from the connection's
        // send queue.
        //

        if (Connection->FirstMessageRequest == Connection->LastMessageRequest) {

            REQUEST_SINGLE_LINKAGE (Request) = NULL;

        } else {

            Connection->SendQueue.Head = REQUEST_SINGLE_LINKAGE (Connection->LastMessageRequest);
            REQUEST_SINGLE_LINKAGE (Connection->LastMessageRequest) = NULL;

        }

#if DBG
        if (REQUEST_REFCOUNT(Request) > 100) {
            DbgPrint ("Request %lx (%lx) has high refcount\n",
                Connection, Request);
            DbgBreakPoint();
        }
#endif
        if (--REQUEST_REFCOUNT(Request) == 0) {

            RequestToComplete = Request;

        } else {

            //
            // There are still sends pending, this will get
            // completed when the last send completes. Since
            // we have already unlinked the request from the
            // connection's send queue we can do this without
            // any locks.
            //

            RequestToComplete = NULL;

        }

        //
        // Now see if there is a send to activate.
        //

        NbiRestartConnection (Connection);

        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

        //
        // Now complete any requests we need to.
        //

        while (RequestToComplete != NULL) {

            TmpRequest = REQUEST_SINGLE_LINKAGE (RequestToComplete);
            REQUEST_STATUS (RequestToComplete) = STATUS_SUCCESS;
            NB_GET_CANCEL_LOCK( &CancelLH );
            IoSetCancelRoutine (RequestToComplete, (PDRIVER_CANCEL)NULL);
            NB_FREE_CANCEL_LOCK( CancelLH );
            NbiCompleteRequest (RequestToComplete);
            NbiFreeRequest (Device, RequestToComplete);
            ++Connection->ConnectionInfo.TransmittedTsdus;
            RequestToComplete = TmpRequest;

            NbiDereferenceConnection (Connection, CREF_SEND);

        }

    } else if ((ReceiveSequence == Connection->CurrentSend.SendSequence) &&
               (Connection->NewNetbios || (BytesReceived == Connection->CurrentSend.MessageOffset)) &&
               (Connection->CurrentSend.Request != NULL)) {

        //
        // This acks whatever we sent last time, and we are
        // not done packetizing this send, so we can repacketize.
        // With SendSequence changing as it does now,
        // don't need the CurrentSend.Request check???
        //

        NB_DEBUG2 (SEND, ("Got full ack on %lx (%d)\n", Connection, Connection->CurrentSend.SendSequence));

        NbiStopRetransmit (Connection);

        if (Connection->NewNetbios) {

            //
            // If we are waiting for a window, and this does not open it
            // anymore, then we don't reset our timers/retries.
            //

            if (Connection->SubState == CONNECTION_SUBSTATE_A_REMOTE_W) {

                if (Connection->RemoteRcvSequenceMax != BytesReceived) {
                    Connection->RemoteRcvSequenceMax = BytesReceived;   // really RcvSeqMac
                    Connection->Retries = NbiDevice->KeepAliveCount;
                    Connection->CurrentRetransmitTimeout = Connection->BaseRetransmitTimeout;

                }

                //
                // Advance this, we won't get meaningful results until we
                // send a full window in one message.
                //

                Connection->SendWindowSequenceLimit = Connection->CurrentSend.SendSequence + Connection->SendWindowSize;

            } else {

                Connection->Retries = NbiDevice->KeepAliveCount;
                Connection->CurrentRetransmitTimeout = Connection->BaseRetransmitTimeout;
                Connection->RemoteRcvSequenceMax = BytesReceived;   // really RcvSeqMac

                if (((SHORT)(Connection->CurrentSend.SendSequence - Connection->SendWindowSequenceLimit)) >= 0) {

                    NbiAdjustSendWindow (Connection);

                } else {

                    //
                    // Advance this, we won't get meaningful results until we
                    // send a full window in one message.
                    //

                    Connection->SendWindowSequenceLimit = Connection->CurrentSend.SendSequence + Connection->SendWindowSize;
                }

            }

        } else {

            Connection->Retries = NbiDevice->KeepAliveCount;
            Connection->CurrentRetransmitTimeout = Connection->BaseRetransmitTimeout;
        }

        Connection->RetransmitThisWindow = FALSE;

        Connection->UnAckedSend = Connection->CurrentSend;

        if (Connection->SubState != CONNECTION_SUBSTATE_A_PACKETIZE) {

            //
            // We may be on if this ack is duplicated.
            //

            NbiReferenceConnectionSync (Connection, CREF_PACKETIZE);

            CTEAssert(!Connection->OnPacketizeQueue);
            Connection->OnPacketizeQueue = TRUE;

            NB_INSERT_TAIL_LIST(
                &Device->PacketizeConnections,
                &Connection->PacketizeLinkage,
                &Device->Lock);

            Connection->SubState = CONNECTION_SUBSTATE_A_PACKETIZE;
        }

        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

    } else if( Connection->FirstMessageRequest ) {

        //
        // This acked part of the current send. If the
        // remote is requesting a resend then we advance
        // the current send location by the amount
        // acked and resend from there. If he does
        // not want a resend, just ignore this.
        //
        // We repacketize immediately because we have
        // backed up the pointer, and this would
        // cause us to ignore an ack for the amount
        // sent. Since we don't release the lock
        // until we have packetized, the current
        // pointer will be advanced past there.
        //
        // If he is acking more than we sent, we
        // ignore this -- the remote is confused and there
        // is nothing much we can do.
        //

        if (Resend) {

            if (Connection->NewNetbios &&
                (((Connection->UnAckedSend.SendSequence < Connection->CurrentSend.SendSequence) &&
                  (ReceiveSequence >= Connection->UnAckedSend.SendSequence) &&
                  (ReceiveSequence < Connection->CurrentSend.SendSequence)) ||
                 ((Connection->UnAckedSend.SendSequence > Connection->CurrentSend.SendSequence) &&
                  ((ReceiveSequence >= Connection->UnAckedSend.SendSequence) ||
                   (ReceiveSequence < Connection->CurrentSend.SendSequence))))) {

                BOOLEAN SomethingAcked = (BOOLEAN)
                        (ReceiveSequence != Connection->UnAckedSend.SendSequence);

                //
                // New netbios and the receive sequence is valid.
                //

                NbiStopRetransmit (Connection);

                //
                // Advance our unacked pointer by the amount
                // acked in this response.
                //

                NbiAdvanceUnAckedBySequence(
                    Connection,
                    ReceiveSequence);

                Connection->RetransmitThisWindow = TRUE;

                ++Connection->ConnectionInfo.TransmissionErrors;
                ++Device->Statistics.DataFramesResent;
                ADD_TO_LARGE_INTEGER(
                    &Device->Statistics.DataFrameBytesResent,
                    Connection->CurrentSend.MessageOffset - Connection->UnAckedSend.MessageOffset);

                //
                // Packetize from that point on.
                //

                Connection->CurrentSend = Connection->UnAckedSend;

                //
                // If anything was acked, then reset the retry count.
                //

                if (SomethingAcked) {

                    //
                    // See if we need to adjust our send window.
                    //

                    if (((SHORT)(Connection->UnAckedSend.SendSequence - Connection->SendWindowSequenceLimit)) >= 0) {

                        NbiAdjustSendWindow (Connection);

                    }

                    Connection->Retries = NbiDevice->KeepAliveCount;
                    Connection->CurrentRetransmitTimeout = Connection->BaseRetransmitTimeout;

                }

                Connection->RemoteRcvSequenceMax = BytesReceived;   // really RcvSeqMac

                //
                // Now packetize. This will set the state to
                // something meaningful and release the lock.
                //

                if (Connection->SubState != CONNECTION_SUBSTATE_A_PACKETIZE) {

                    NbiPacketizeSend(
                        Connection
                        NB_LOCK_HANDLE_ARG(LockHandle)
                        );

                } else {

                    NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

                }

            } else if (!Connection->NewNetbios &&
                       ((ReceiveSequence == Connection->UnAckedSend.SendSequence) &&
                        (BytesReceived <= Connection->CurrentSend.MessageOffset))) {

                ULONG BytesAcked =
                        BytesReceived - Connection->UnAckedSend.MessageOffset;

                //
                // Old netbios.
                //

                NbiStopRetransmit (Connection);

                //
                // Advance our unacked pointer by the amount
                // acked in this response.
                //

                NbiAdvanceUnAckedByBytes(
                    Connection,
                    BytesAcked);

                ++Connection->ConnectionInfo.TransmissionErrors;
                ++Device->Statistics.DataFramesResent;
                ADD_TO_LARGE_INTEGER(
                    &Device->Statistics.DataFrameBytesResent,
                    Connection->CurrentSend.MessageOffset - Connection->UnAckedSend.MessageOffset);

                //
                // Packetize from that point on.
                //

                Connection->CurrentSend = Connection->UnAckedSend;

                //
                // If anything was acked, reset the retry count
                //
                if ( BytesAcked ) {
                    Connection->Retries = NbiDevice->KeepAliveCount;
                    Connection->CurrentRetransmitTimeout = Connection->BaseRetransmitTimeout;
                }

                //
                // Now packetize. This will set the state to
                // something meaningful and release the lock.
                //

                if (Connection->SubState != CONNECTION_SUBSTATE_A_PACKETIZE) {

                    NbiPacketizeSend(
                        Connection
                        NB_LOCK_HANDLE_ARG(LockHandle)
                        );

                } else {

                    NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

                }

            } else {

                NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

            }

        } else {

            if (Connection->NewNetbios &&
                (((Connection->UnAckedSend.SendSequence < Connection->CurrentSend.SendSequence) &&
                  (ReceiveSequence >= Connection->UnAckedSend.SendSequence) &&
                  (ReceiveSequence < Connection->CurrentSend.SendSequence)) ||
                 ((Connection->UnAckedSend.SendSequence > Connection->CurrentSend.SendSequence) &&
                  ((ReceiveSequence >= Connection->UnAckedSend.SendSequence) ||
                   (ReceiveSequence < Connection->CurrentSend.SendSequence))))) {

                BOOLEAN SomethingAcked = (BOOLEAN)
                        (ReceiveSequence != Connection->UnAckedSend.SendSequence);

                //
                // New netbios and the receive sequence is valid. We advance
                // the back of our send window, but we don't repacketize.
                //

                //
                // Advance our unacked pointer by the amount
                // acked in this response.
                //

                NbiAdvanceUnAckedBySequence(
                    Connection,
                    ReceiveSequence);

                Connection->RemoteRcvSequenceMax = BytesReceived;   // really RcvSeqMac

                //
                // If anything was acked, then reset the retry count.
                //

                if (SomethingAcked) {

                    //
                    // See if we need to adjust our send window.
                    //

                    if (((SHORT)(Connection->UnAckedSend.SendSequence - Connection->SendWindowSequenceLimit)) >= 0) {

                        NbiAdjustSendWindow (Connection);

                    }

                    Connection->Retries = NbiDevice->KeepAliveCount;
                    Connection->CurrentRetransmitTimeout = Connection->BaseRetransmitTimeout;


                    //
                    // Now packetize. This will set the state to
                    // something meaningful and release the lock.
                    //

                   if ((Connection->CurrentSend.Request != NULL) &&
                       (Connection->SubState != CONNECTION_SUBSTATE_A_PACKETIZE)) {

                        NbiReferenceConnectionSync (Connection, CREF_PACKETIZE);

                        CTEAssert(!Connection->OnPacketizeQueue);
                        Connection->OnPacketizeQueue = TRUE;

                        Connection->SubState = CONNECTION_SUBSTATE_A_PACKETIZE;

                        NB_INSERT_TAIL_LIST(
                            &Device->PacketizeConnections,
                            &Connection->PacketizeLinkage,
                            &Device->Lock);

                    }
                }
            }

            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

        }

    } else {
        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);
    }

}   /* NbiReframeConnection */


VOID
NbiRestartConnection(
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This routine is called when have gotten an ack for
    a full message, or received a response to a watchdog
    probe, and need to check if the connection should
    start packetizing.

    NOTE: THIS FUNCTION IS CALLED WITH CONNECTION->LOCK HELD
    AND RETURNS WITH IT HELD.

Arguments:

    Connection - The connection.

Return Value:

    None.

--*/

{
    PREQUEST Request, TmpRequest;
    ULONG TempCount;
    PTDI_REQUEST_KERNEL_SEND Parameters;
    PDEVICE Device = NbiDevice;

    //
    // See if there is a send to activate.
    //

    if (Connection->SendQueue.Head != NULL) {

        //
        // Take the first send off the queue and make
        // it current.
        //

        Request = Connection->SendQueue.Head;
        Connection->SendQueue.Head = REQUEST_SINGLE_LINKAGE (Request);

        //
        // Cache the information about being EOM
        // in a more easily accessible location?
        //

        Parameters = (PTDI_REQUEST_KERNEL_SEND)REQUEST_PARAMETERS(Request);
        if ((Parameters->SendFlags & TDI_SEND_PARTIAL) == 0) {

            //
            // This is a one-request message.
            //

            Connection->CurrentSend.Request = Request;
            Connection->CurrentSend.MessageOffset = 0;
            Connection->CurrentSend.Buffer = REQUEST_NDIS_BUFFER (Request);
            Connection->CurrentSend.BufferOffset = 0;
            Connection->SendBufferInUse = FALSE;

            Connection->UnAckedSend = Connection->CurrentSend;

            Connection->FirstMessageRequest = Request;
#ifdef  RSRC_TIMEOUT_DBG
            KeQuerySystemTime(&Connection->FirstMessageRequestTime);
#endif  //RSRC_TIMEOUT_DBG

            Connection->LastMessageRequest = Request;
            Connection->CurrentMessageLength = Parameters->SendLength;

            Connection->SubState = CONNECTION_SUBSTATE_A_PACKETIZE;

            NbiReferenceConnectionSync (Connection, CREF_PACKETIZE);

            CTEAssert (!Connection->OnPacketizeQueue);
            Connection->OnPacketizeQueue = TRUE;

            NB_INSERT_TAIL_LIST(
                &Device->PacketizeConnections,
                &Connection->PacketizeLinkage,
                &Device->Lock);

        } else {

            //
            // This is a multiple-request message. We scan
            // to see if we have the end of message received
            // yet.
            //

            TempCount = Parameters->SendLength;
            TmpRequest = Request;
            Request = REQUEST_SINGLE_LINKAGE(Request);

            while (Request != NULL) {

                TempCount += Parameters->SendLength;

                Parameters = (PTDI_REQUEST_KERNEL_SEND)REQUEST_PARAMETERS(Request);
                if ((Parameters->SendFlags & TDI_SEND_PARTIAL) == 0) {

                    Connection->CurrentSend.Request = TmpRequest;
                    Connection->CurrentSend.MessageOffset = 0;
                    Connection->CurrentSend.Buffer = REQUEST_NDIS_BUFFER (TmpRequest);
                    Connection->CurrentSend.BufferOffset = 0;
                    Connection->SendBufferInUse = FALSE;

                    Connection->UnAckedSend = Connection->CurrentSend;

                    Connection->FirstMessageRequest = TmpRequest;
                    Connection->LastMessageRequest = Request;
#ifdef  RSRC_TIMEOUT_DBG
                    KeQuerySystemTime(&Connection->FirstMessageRequestTime);
#endif  //RSRC_TIMEOUT_DBG

                    Connection->CurrentMessageLength = TempCount;

                    Connection->SubState = CONNECTION_SUBSTATE_A_PACKETIZE;

                    NbiReferenceConnectionSync (Connection, CREF_PACKETIZE);

                    CTEAssert (!Connection->OnPacketizeQueue);
                    Connection->OnPacketizeQueue = TRUE;

                    NB_INSERT_TAIL_LIST(
                        &Device->PacketizeConnections,
                        &Connection->PacketizeLinkage,
                        &Device->Lock);

                    break;

                }

                Request = REQUEST_SINGLE_LINKAGE(Request);

            }

            if (Request == NULL) {

                Connection->SubState = CONNECTION_SUBSTATE_A_W_EOR;

            }

        }

    } else {

        Connection->FirstMessageRequest = NULL;
        Connection->SubState = CONNECTION_SUBSTATE_A_IDLE;

        NbiStartWatchdog (Connection);

    }

}   /* NbiRestartConnection */


VOID
NbiAdvanceUnAckedByBytes(
    IN PCONNECTION Connection,
    IN ULONG BytesAcked
    )

/*++

Routine Description:

    This routine advances the Connection->UnAckedSend
    send pointer by the specified number of bytes. It
    assumes that there are enough send requests to
    handle the number specified.

    NOTE: THIS FUNCTION IS CALLED WITH CONNECTION->LOCK HELD
    AND RETURNS WITH IT HELD.

Arguments:

    Connection - The connection.

    BytesAcked - The number of bytes acked.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    ULONG CurSendBufferLength;
    ULONG BytesLeft = BytesAcked;
    ULONG TempBytes;

    while (BytesLeft > 0) {

        NdisQueryBufferSafe (Connection->UnAckedSend.Buffer, NULL, &CurSendBufferLength, HighPagePriority);

        //
        // See if bytes acked ends within the current buffer.
        //

        if (Connection->UnAckedSend.BufferOffset + BytesLeft <
                CurSendBufferLength) {

            Connection->UnAckedSend.BufferOffset += BytesLeft;
            Connection->UnAckedSend.MessageOffset += BytesLeft;
            break;

        } else {

            TempBytes = CurSendBufferLength - Connection->UnAckedSend.BufferOffset;
            BytesLeft -= TempBytes;
            Connection->UnAckedSend.MessageOffset += TempBytes;

            //
            // No, so advance the buffer.
            //

            Connection->UnAckedSend.BufferOffset = 0;
            Connection->UnAckedSend.Buffer =
                NDIS_BUFFER_LINKAGE (Connection->UnAckedSend.Buffer);

            //
            // Is there a next buffer in this request?
            //

            if (Connection->UnAckedSend.Buffer == NULL) {

                //
                // No, so advance the request unless we are done.
                //

                if (BytesLeft == 0) {
                    return;
                }

                Connection->UnAckedSend.Request =
                    REQUEST_SINGLE_LINKAGE(Connection->UnAckedSend.Request);

                if (Connection->UnAckedSend.Request == NULL) {
                    KeBugCheck (NDIS_INTERNAL_ERROR);
                }

                Connection->UnAckedSend.Buffer =
                    REQUEST_NDIS_BUFFER (Connection->UnAckedSend.Request);

            }
        }
    }

}   /* NbiAdvanceUnAckedByBytes */


VOID
NbiAdvanceUnAckedBySequence(
    IN PCONNECTION Connection,
    IN USHORT ReceiveSequence
    )

/*++

Routine Description:

    This routine advances the Connection->UnAckedSend
    send pointer so that the next packet to send will be
    the correct one for ReceiveSequence. UnAckedSend
    must point to a known valid combination. It
    assumes that there are enough send requests to
    handle the sequence specified.

    NOTE: THIS FUNCTION IS CALLED WITH CONNECTION->LOCK HELD
    AND RETURNS WITH IT HELD.

Arguments:

    Connection - The connection.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    USHORT PacketsAcked;

    //
    // Fix this to account for partial sends, where
    // we might not have used the max. for all packets.
    //

    PacketsAcked = ReceiveSequence - Connection->UnAckedSend.SendSequence;

    NbiAdvanceUnAckedByBytes(
        Connection,
        PacketsAcked * Connection->MaximumPacketSize);

    Connection->UnAckedSend.SendSequence += PacketsAcked;

}   /* NbiAdvanceUnAckedBySequence */


VOID
NbiCancelSend(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to cancel a send
    The request is found on the connection's send queue.

    NOTE: This routine is called with the CancelSpinLock held and
    is responsible for releasing it.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    none.

--*/

{
    PCONNECTION Connection;
    PREQUEST Request = (PREQUEST)Irp;
    NB_DEFINE_LOCK_HANDLE (LockHandle)
    NB_DEFINE_SYNC_CONTEXT (SyncContext)


    CTEAssert ((REQUEST_MAJOR_FUNCTION(Request) == IRP_MJ_INTERNAL_DEVICE_CONTROL) &&
               (REQUEST_MINOR_FUNCTION(Request) == TDI_SEND));

    CTEAssert (REQUEST_OPEN_TYPE(Request) == (PVOID)TDI_CONNECTION_FILE);

    Connection = (PCONNECTION)REQUEST_OPEN_CONTEXT(Request);

    //
    // Just stop the connection, that will tear down any
    // sends.
    //
    // Do we care about cancelling non-active
    // sends without stopping the connection??
    //

    NbiReferenceConnectionSync (Connection, CREF_CANCEL);

    IoReleaseCancelSpinLock (Irp->CancelIrql);


    NB_BEGIN_SYNC (&SyncContext);

    NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);

    //
    // This frees the lock, cancels any sends, etc.
    //

    NbiStopConnection(
        Connection,
        STATUS_CANCELLED
        NB_LOCK_HANDLE_ARG (LockHandle));

    NbiDereferenceConnection (Connection, CREF_CANCEL);

    NB_END_SYNC (&SyncContext);

}   /* NbiCancelSend */


NTSTATUS
NbiBuildBufferChainFromBufferChain (
    IN NDIS_HANDLE BufferPoolHandle,
    IN PNDIS_BUFFER CurrentSourceBuffer,
    IN ULONG CurrentByteOffset,
    IN ULONG DesiredLength,
    OUT PNDIS_BUFFER *DestinationBuffer,
    OUT PNDIS_BUFFER *NewSourceBuffer,
    OUT ULONG *NewByteOffset,
    OUT ULONG *ActualLength
    )

/*++

Routine Description:

    This routine is called to build an NDIS_BUFFER chain from a source
    NDIS_BUFFER chain and offset into it. We assume we don't know the
    length of the source Mdl chain, and we must allocate the NDIS_BUFFERs
    for the destination chain, which we do from the NDIS buffer pool.

    If the system runs out of memory while we are building the destination
    NDIS_BUFFER chain, we completely clean up the built chain and return with
    NewCurrentMdl and NewByteOffset set to the current values of CurrentMdl
    and ByteOffset.

Environment:

Arguments:

    BufferPoolHandle - The buffer pool to allocate buffers from.

    CurrentSourceBuffer - Points to the start of the NDIS_BUFFER chain
        from which to draw the packet.

    CurrentByteOffset - Offset within this NDIS_BUFFER to start the packet at.

    DesiredLength - The number of bytes to insert into the packet.

    DestinationBuffer - returned pointer to the NDIS_BUFFER chain describing
        the packet.

    NewSourceBuffer - returned pointer to the NDIS_BUFFER that would
        be used for the next byte of packet. NULL if the source NDIS_BUFFER
        chain was exhausted.

    NewByteOffset - returned offset into the NewSourceBuffer for the next byte
        of packet. NULL if the source NDIS_BUFFER chain was exhausted.

    ActualLength - The actual length of the data copied.

Return Value:

    STATUS_SUCCESS if the build of the returned NDIS_BUFFER chain succeeded
        and was the correct length.

    STATUS_INSUFFICIENT_RESOURCES if we ran out of NDIS_BUFFERs while
        building the destination chain.

--*/
{
    ULONG AvailableBytes;
    ULONG CurrentByteCount;
    ULONG BytesCopied;
    PNDIS_BUFFER OldNdisBuffer;
    PNDIS_BUFFER NewNdisBuffer;
    NDIS_STATUS NdisStatus;


    OldNdisBuffer = CurrentSourceBuffer;
    NdisQueryBufferSafe (OldNdisBuffer, NULL, &CurrentByteCount, HighPagePriority);

    AvailableBytes = CurrentByteCount - CurrentByteOffset;
    if (AvailableBytes > DesiredLength) {
        AvailableBytes = DesiredLength;
    }

    //
    // Build the first NDIS_BUFFER, which could conceivably be the only one...
    //

    NdisCopyBuffer(
        &NdisStatus,
        &NewNdisBuffer,
        BufferPoolHandle,
        OldNdisBuffer,
        CurrentByteOffset,
        AvailableBytes);


    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        *NewSourceBuffer = CurrentSourceBuffer;
        *NewByteOffset = CurrentByteOffset;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *DestinationBuffer = NewNdisBuffer;
    BytesCopied = AvailableBytes;

    //
    // Was the first NDIS_BUFFER enough data.
    //

    if (BytesCopied == DesiredLength) {
        if (CurrentByteOffset + AvailableBytes == CurrentByteCount) {
            *NewSourceBuffer = CurrentSourceBuffer->Next;
            *NewByteOffset = 0;
        } else {
            *NewSourceBuffer = CurrentSourceBuffer;
            *NewByteOffset = CurrentByteOffset + AvailableBytes;
        }
        *ActualLength = BytesCopied;
        return STATUS_SUCCESS;
    }

    if (CurrentSourceBuffer->Next == NULL) {

        *NewSourceBuffer = NULL;
        *NewByteOffset = 0;
        *ActualLength = BytesCopied;
        return STATUS_SUCCESS;

    }

    //
    // Need more data, so follow the in Mdl chain to create a packet.
    //

    OldNdisBuffer = OldNdisBuffer->Next;
    NdisQueryBufferSafe (OldNdisBuffer, NULL, &CurrentByteCount, HighPagePriority);

    while (OldNdisBuffer != NULL) {

        AvailableBytes = DesiredLength - BytesCopied;
        if (AvailableBytes > CurrentByteCount) {
            AvailableBytes = CurrentByteCount;
        }

        NdisCopyBuffer(
            &NdisStatus,
            &(NDIS_BUFFER_LINKAGE(NewNdisBuffer)),
            BufferPoolHandle,
            OldNdisBuffer,
            0,
            AvailableBytes);

        if (NdisStatus != NDIS_STATUS_SUCCESS) {

            //
            // ran out of resources. put back what we've used in this call and
            // return the error.
            //

            while (*DestinationBuffer != NULL) {
                NewNdisBuffer = NDIS_BUFFER_LINKAGE(*DestinationBuffer);
                NdisFreeBuffer (*DestinationBuffer);
                *DestinationBuffer = NewNdisBuffer;
            }

            *NewByteOffset = CurrentByteOffset;
            *NewSourceBuffer = CurrentSourceBuffer;

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        NewNdisBuffer = NDIS_BUFFER_LINKAGE(NewNdisBuffer);

        BytesCopied += AvailableBytes;

        if (BytesCopied == DesiredLength) {
            if (AvailableBytes == CurrentByteCount) {
                *NewSourceBuffer = OldNdisBuffer->Next;
                *NewByteOffset = 0;
            } else {
                *NewSourceBuffer = OldNdisBuffer;
                *NewByteOffset = AvailableBytes;
            }
            *ActualLength = BytesCopied;
            return STATUS_SUCCESS;
        }

        OldNdisBuffer = OldNdisBuffer->Next;
        NdisQueryBufferSafe (OldNdisBuffer, NULL, &CurrentByteCount, HighPagePriority);

    }

    //
    // We ran out of source buffer chain.
    //

    *NewSourceBuffer = NULL;
    *NewByteOffset = 0;
    *ActualLength = BytesCopied;
    return STATUS_SUCCESS;

}   /* NbiBuildBufferChainFromBufferChain */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\globals.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    globals.c

Abstract:


Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

//  Global values
PDEVICE                     SpxDevice       = NULL;
UNICODE_STRING              IpxDeviceName   = {0};
HANDLE                      IpxHandle       = NULL;

LARGE_INTEGER				Magic100000		= {
												0x1b478424,
												0xa7c5ac47
											  };
#define DEFAULT_MAXPACKETSIZE 1500

//  Line info
IPX_LINE_INFO               IpxLineInfo     = {0, DEFAULT_MAXPACKETSIZE, 0 , 0 };
USHORT                      IpxMacHdrNeeded = 0;
USHORT                      IpxInclHdrOffset= 0;

//  Entry Points into the IPX stack
IPX_INTERNAL_SEND               IpxSendPacket	= NULL;
IPX_INTERNAL_FIND_ROUTE         IpxFindRoute	= NULL;
IPX_INTERNAL_QUERY			    IpxQuery		= NULL;
IPX_INTERNAL_TRANSFER_DATA	    IpxTransferData	= NULL;
IPX_INTERNAL_PNP_COMPLETE       IpxPnPComplete  = NULL;

#if DBG
ULONG   SpxDebugDump        = 0;
LONG    SpxDumpInterval     = DBG_DUMP_DEF_INTERVAL;
ULONG   SpxDebugLevel       = DBG_LEVEL_ERR;
ULONG   SpxDebugSystems     = DBG_COMP_MOST;
#endif

//	Unload event triggered when ref count on device goes to zero.
KEVENT	SpxUnloadEvent		= {0};

//	Maximum packet size quanta used during packet size negotiation
ULONG	SpxMaxPktSize[] =	{
								576 	- MIN_IPXSPX2_HDRSIZE,
								1024 	- MIN_IPXSPX2_HDRSIZE,
								1474	- MIN_IPXSPX2_HDRSIZE,
								1492	- MIN_IPXSPX2_HDRSIZE,
								1500	- MIN_IPXSPX2_HDRSIZE,
								1954	- MIN_IPXSPX2_HDRSIZE,
								4002	- MIN_IPXSPX2_HDRSIZE,
								8192	- MIN_IPXSPX2_HDRSIZE,
								17314	- MIN_IPXSPX2_HDRSIZE,
								65535	- MIN_IPXSPX2_HDRSIZE
							};

ULONG	SpxMaxPktSizeIndex	= sizeof(SpxMaxPktSize)/sizeof(ULONG);


//	Global interlock
CTELock	SpxGlobalInterlock	= {0};

//	Another one, used only for global queues for addr/conn
CTELock			SpxGlobalQInterlock = {0};
PSPX_CONN_FILE	SpxGlobalConnList	= NULL;
PSPX_ADDR_FILE	SpxGlobalAddrList	= NULL;

SPX_CONNFILE_LIST	SpxPktConnList	= {NULL, NULL};
SPX_CONNFILE_LIST	SpxRecvConnList	= {NULL, NULL};

//	Timer globals
LONG		SpxTimerCurrentTime = 0;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\globals.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    globals.h

Abstract:


Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:


--*/


extern  PDEVICE                     SpxDevice;
extern  UNICODE_STRING              IpxDeviceName;
extern  HANDLE                      IpxHandle;

extern	LARGE_INTEGER				Magic100000;

#if 1	// DBG
extern  ULONG   SpxDebugDump;
extern  LONG    SpxDumpInterval;
extern  ULONG   SpxDebugLevel;
extern  ULONG   SpxDebugSystems;

#endif

//  More IPX info.
extern  IPX_LINE_INFO       IpxLineInfo;
extern  USHORT              IpxMacHdrNeeded;
extern  USHORT              IpxInclHdrOffset;

//  Entry Points into the IPX stack
extern  IPX_INTERNAL_SEND               IpxSendPacket;
extern  IPX_INTERNAL_FIND_ROUTE         IpxFindRoute;
extern  IPX_INTERNAL_QUERY			    IpxQuery;
extern  IPX_INTERNAL_TRANSFER_DATA	    IpxTransferData;

//	Unload event
extern	KEVENT	SpxUnloadEvent;

extern	ULONG	SpxMaxPktSize[];
extern	ULONG	SpxMaxPktSizeIndex;

extern	CTELock		SpxGlobalInterlock;


extern	CTELock			SpxGlobalQInterlock;
extern	PSPX_CONN_FILE	SpxGlobalConnList;
extern	PSPX_ADDR_FILE	SpxGlobalAddrList;

extern	SPX_CONNFILE_LIST   SpxPktConnList;
extern	SPX_CONNFILE_LIST   SpxRecvConnList;

extern	LONG			SpxTimerCurrentTime;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\precomp.h ===
#include "isnspx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\isnspx.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    isnspx.h

Abstract:

    This module contains definitions specific to the
    SPX module of the ISN transport.

Author:

    Adam Barr (adamba) 2-September-1993

Environment:

    Kernel mode

Revision History:


--*/

#define ISN_NT 1
//#define DBG 1
//
// These are needed for CTE
//

#if DBG
#define DEBUG 1
#endif

#define NT 1

#include <ntosp.h>
#include <tdikrnl.h>
#include <ndis.h>
#ifndef CTE_TYPEDEFS_DEFINED
#include <cxport.h>
#endif
#include <bind.h>

#include "wsnwlink.h"

#define SPX_DEVICE_SIGNATURE        (CSHORT)(*(PUSHORT)"SD")
#define SPX_ADDRESS_SIGNATURE		(CSHORT)(*(PUSHORT)"AD")
#define SPX_ADDRESSFILE_SIGNATURE	(CSHORT)(*(PUSHORT)"AF")
#define SPX_CONNFILE_SIGNATURE		(CSHORT)(*(PUSHORT)"CF")

#define SPX_FILE_TYPE_CONTROL   	(ULONG)0x4701   // file is type control

#define SPX_ADD_ULONG(_Pulong, _Ulong, _Lock)  InterlockedExchangeAdd(_Pulong, _Ulong)

typedef	UCHAR	BYTE, *PBYTE;
typedef ULONG	DWORD, *PDWORD;

//
// These definitions are for abstracting IRPs from the
// transport for portability.
//

#if ISN_NT

typedef IRP REQUEST, *PREQUEST;

//
// PREQUEST
// SpxAllocateRequest(
//     IN PDEVICE Device,
//     IN PIRP Irp
// );
//
// Allocates a request for the system-specific request structure.
//

#define SpxAllocateRequest(_Device,_Irp) \
    (_Irp)

//
// BOOLEAN
// IF_NOT_ALLOCATED(
//     IN PREQUEST Request
// );
//
// Checks if a request was not successfully allocated.
//

#define IF_NOT_ALLOCATED(_Request) \
    if (0)


//
// VOID
// SpxFreeRequest(
//     IN PDEVICE Device,
//     IN PREQUEST Request
// );
//
// Frees a previously allocated request.
//

#define SpxFreeRequest(_Device,_Request) \
    ;


//
// VOID
// MARK_REQUEST_PENDING(
//     IN PREQUEST Request
// );
//
// Marks that a request will pend.
//

#define MARK_REQUEST_PENDING(_Request) \
    IoMarkIrpPending(_Request)


//
// VOID
// UNMARK_REQUEST_PENDING(
//     IN PREQUEST Request
// );
//
// Marks that a request will not pend.
//

#define UNMARK_REQUEST_PENDING(_Request) \
    (((IoGetCurrentIrpStackLocation(_Request))->Control) &= ~SL_PENDING_RETURNED)


//
// UCHAR
// REQUEST_MAJOR_FUNCTION
//     IN PREQUEST Request
// );
//
// Returns the major function code of a request.
//

#define REQUEST_MAJOR_FUNCTION(_Request) \
    ((IoGetCurrentIrpStackLocation(_Request))->MajorFunction)


//
// UCHAR
// REQUEST_MINOR_FUNCTION
//     IN PREQUEST Request
// );
//
// Returns the minor function code of a request.
//

#define REQUEST_MINOR_FUNCTION(_Request) \
    ((IoGetCurrentIrpStackLocation(_Request))->MinorFunction)


//
// PNDIS_BUFFER
// REQUEST_NDIS_BUFFER
//     IN PREQUEST Request
// );
//
// Returns the NDIS buffer chain associated with a request.
//

#define REQUEST_NDIS_BUFFER(_Request) \
    ((PNDIS_BUFFER)((_Request)->MdlAddress))


//
// PVOID
// REQUEST_TDI_BUFFER
//     IN PREQUEST Request
// );
//
// Returns the TDI buffer chain associated with a request.
//

#define REQUEST_TDI_BUFFER(_Request) \
    ((PVOID)((_Request)->MdlAddress))


//
// PVOID
// REQUEST_OPEN_CONTEXT(
//     IN PREQUEST Request
// );
//
// Gets the context associated with an opened address/connection/control channel.
//

#define REQUEST_OPEN_CONTEXT(_Request) \
    (((IoGetCurrentIrpStackLocation(_Request))->FileObject)->FsContext)


//
// PVOID
// REQUEST_OPEN_TYPE(
//     IN PREQUEST Request
// );
//
// Gets the type associated with an opened address/connection/control channel.
//

#define REQUEST_OPEN_TYPE(_Request) \
    (((IoGetCurrentIrpStackLocation(_Request))->FileObject)->FsContext2)


//
// PFILE_FULL_EA_INFORMATION
// OPEN_REQUEST_EA_INFORMATION(
//     IN PREQUEST Request
// );
//
// Returns the EA information associated with an open/close request.
//

#define OPEN_REQUEST_EA_INFORMATION(_Request) \
    ((PFILE_FULL_EA_INFORMATION)((_Request)->AssociatedIrp.SystemBuffer))


//
// PTDI_REQUEST_KERNEL
// REQUEST_PARAMETERS(
//     IN PREQUEST Request
// );
//
// Obtains a pointer to the parameters of a request.
//

#define REQUEST_PARAMETERS(_Request) \
    (&((IoGetCurrentIrpStackLocation(_Request))->Parameters))


//
// PLIST_ENTRY
// REQUEST_LINKAGE(
//     IN PREQUEST Request
// );
//
// Returns a pointer to a linkage field in the request.
//

#define REQUEST_LINKAGE(_Request) \
    (&((_Request)->Tail.Overlay.ListEntry))


//
// PREQUEST
// LIST_ENTRY_TO_REQUEST(
//     IN PLIST_ENTRY ListEntry
// );
//
// Returns a request given a linkage field in it.
//

#define LIST_ENTRY_TO_REQUEST(_ListEntry) \
    ((PREQUEST)(CONTAINING_RECORD(_ListEntry, REQUEST, Tail.Overlay.ListEntry)))


//
// PUNICODE_STRING
// REQUEST_OPEN_NAME(
//     IN PREQUEST Request
// );
//
// Used to access the RemainingName field of a request.
//

#define	REQUEST_OPEN_NAME(_Request)		\
		(&((IoGetCurrentIrpStackLocation(_Request))->FileObject->FileName))

//
// NTSTATUS
// REQUEST_STATUS(
//     IN PREQUEST Request
// );
//
// Used to access the status field of a request.
//

#define REQUEST_STATUS(_Request) \
		(_Request)->IoStatus.Status


//
// ULONG
// REQUEST_INFORMATION(
//     IN PREQUEST Request)
// );
//
// Used to access the information field of a request.
//

#define REQUEST_INFORMATION(_Request) \
		(_Request)->IoStatus.Information


//
// VOID
// SpxCompleteRequest(
//     IN PREQUEST Request
// );
//
// Completes a request whose status and information fields have
// been filled in.
//

#define SpxCompleteRequest(_Request) 									\
		{																\
            CTELockHandle   _CancelIrql;                                 \
			DBGPRINT(TDI, INFO,											\
					("SpxCompleteRequest: Completing %lx with %lx\n",	\
						(_Request), REQUEST_STATUS(_Request)));			\
																		\
            IoAcquireCancelSpinLock( &_CancelIrql );                     \
			(_Request)->CancelRoutine = NULL;							\
            IoReleaseCancelSpinLock( _CancelIrql );                      \
			IoCompleteRequest (_Request, IO_NETWORK_INCREMENT);			\
		}																

#else

//
// These routines must be defined for portability to a VxD.
//

#endif

#include "fwddecls.h"

#ifndef _NTIOAPI_
#include "spxntdef.h"
#endif

#include "spxreg.h"
#include "spxdev.h"
#include "spxbind.h"
#include "spxtimer.h"
#include "spxpkt.h"
#include "spxerror.h"
#include "spxaddr.h"
#include "spxconn.h"
#include "spxrecv.h"
#include "spxsend.h"
#include "spxquery.h"
#include "spxmem.h"
#include "spxutils.h"


//  Globals
#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\nb\timer.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    timer.c

Abstract:

    This module contains code which implements the timers for
    netbios.

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


ULONG NbiTickIncrement = 0;
ULONG NbiShortTimerDeltaTicks = 0;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NbiInitializeTimers)
#endif


VOID
NbiStartRetransmit(
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This routine starts the retransmit timer for the given connection.
    The connection is inserted on the short list if it isn't on already.

    NOTE: THIS ROUTINE MUST BE CALLED AT DPC LEVEL.

Arguments:

    Connection - pointer to the connection.

Return Value:

    None.

--*/

{
    PDEVICE Device = NbiDevice;
    NB_DEFINE_LOCK_HANDLE (LockHandle)

    //
    // Insert us in the queue if we aren't in it.
    //

    Connection->Retransmit =
        Device->ShortAbsoluteTime + Connection->CurrentRetransmitTimeout;

    if (!Connection->OnShortList) {

        CTEAssert (KeGetCurrentIrql() == DISPATCH_LEVEL);

        NB_SYNC_GET_LOCK (&Device->TimerLock, &LockHandle);

        if (!Connection->OnShortList) {
            Connection->OnShortList = TRUE;
            InsertTailList (&Device->ShortList, &Connection->ShortList);
        }

        if (!Device->ShortListActive) {
            NbiStartShortTimer (Device);
            Device->ShortListActive = TRUE;
        }

        NB_SYNC_FREE_LOCK (&Device->TimerLock, LockHandle);
    }

}   /* NbiStartRetransmit */


VOID
NbiStartWatchdog(
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This routine starts the watchdog timer for a connection.

    NOTE: THIS ROUTINE MUST BE CALLED AT DPC LEVEL.

Arguments:

    Connection - pointer to the connection.

Return Value:

    None.

--*/

{
    PDEVICE Device = NbiDevice;
    NB_DEFINE_LOCK_HANDLE (LockHandle);


    Connection->Watchdog = Device->LongAbsoluteTime + Connection->WatchdogTimeout;

    if (!Connection->OnLongList) {

        ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

        NB_SYNC_GET_LOCK (&Device->TimerLock, &LockHandle);

        if (!Connection->OnLongList) {
            Connection->OnLongList = TRUE;
            InsertTailList (&Device->LongList, &Connection->LongList);
        }

        NB_SYNC_FREE_LOCK (&Device->TimerLock, LockHandle);
    }

}   /* NbiStartWatchdog */

#if DBG

VOID
NbiStopRetransmit(
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This routine stops the retransmit timer for a connection.

Arguments:

    Connection - pointer to the connection.

Return Value:

    None.

--*/

{
    Connection->Retransmit = 0;

}   /* NbiStopRetransmit */


VOID
NbiStopWatchdog(
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This routine stops the watchdog timer for a connection.

Arguments:

    Connection - pointer to the connection.

Return Value:

    None.

--*/

{
    Connection->Watchdog = 0;

}   /* NbiStopWatchdog */
#endif


VOID
NbiExpireRetransmit(
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This routine is called when the connection's retransmit timer
    expires. It is called from NbiShortTimeout.

Arguments:

    Connection - Pointer to the connection whose timer has expired.

Return Value:

    none.

--*/

{
    PDEVICE Device = NbiDevice;
    BOOLEAN SendFindRoute;
    NB_DEFINE_LOCK_HANDLE (LockHandle);

    NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);

    if (Connection->State == CONNECTION_STATE_ACTIVE) {

        SendFindRoute = FALSE;

        ++Device->Statistics.ResponseTimerExpirations;

        if (!(Connection->NewNetbios) &&
            (Connection->SubState == CONNECTION_SUBSTATE_A_W_ACK)) {

            if (--Connection->Retries == 0) {

                //
                // Shut down the connection. This will send
                // out half the usual number of session end
                // frames.
                //

                NB_DEBUG2 (CONNECTION, ("Wait for ack timeout of active connection %lx\n", Connection));

                //
                // This free the connection lock.
                //

                NbiStopConnection(
                    Connection,
                    STATUS_LINK_FAILED
                    NB_LOCK_HANDLE_ARG (LockHandle)
                    );

            } else {

                //
                // Set our current packetize location back to the
                // spot of the last ack, and start up again.
                //
                // Should we send a probe here?
                //

                Connection->CurrentSend = Connection->UnAckedSend;
                Connection->RetransmitThisWindow = TRUE;
                if (Connection->CurrentRetransmitTimeout < (Connection->BaseRetransmitTimeout*8)) {
                    Connection->CurrentRetransmitTimeout =
                        (Connection->CurrentRetransmitTimeout * 3) / 2;
                }

                NB_DEBUG2 (SEND, ("Connection %lx retransmit timeout\n", Connection));

                //
                // After half the retries, send a find route unless we
                // are already doing one, or the connection is to network
                // 0. When this completes we update the local target,
                // for whatever good that does.
                //

                if ((!Connection->FindRouteInProgress) &&
                    (Connection->Retries == (Device->KeepAliveCount/2)) &&
                    (*(UNALIGNED ULONG *)Connection->RemoteHeader.DestinationNetwork != 0)) {

                    SendFindRoute = TRUE;
                    Connection->FindRouteInProgress = TRUE;
                    NbiReferenceConnectionSync (Connection, CREF_FIND_ROUTE);

                }

                //
                // This releases the lock.
                //

                NbiPacketizeSend(
                    Connection
                    NB_LOCK_HANDLE_ARG(LockHandle)
                    );

            }

        } else if ((Connection->SubState == CONNECTION_SUBSTATE_A_W_PROBE) ||
                   (Connection->SubState == CONNECTION_SUBSTATE_A_REMOTE_W) ||
                   (Connection->SubState == CONNECTION_SUBSTATE_A_W_ACK)) {

            if (--Connection->Retries == 0) {

                //
                // Shut down the connection. This will send
                // out half the usual number of session end
                // frames.
                //

                NB_DEBUG2 (CONNECTION, ("Probe timeout of active connection %lx\n", Connection));

                //
                // This free the connection lock.
                //

                NbiStopConnection(
                    Connection,
                    STATUS_LINK_FAILED
                    NB_LOCK_HANDLE_ARG (LockHandle)
                    );

            } else {

                Connection->RetransmitThisWindow = TRUE;
                if (Connection->CurrentRetransmitTimeout < (Connection->BaseRetransmitTimeout*8)) {
                    Connection->CurrentRetransmitTimeout =
                        (Connection->CurrentRetransmitTimeout * 3) / 2;
                }

                NbiStartRetransmit (Connection);

                //
                // After half the retries, send a find route unless we
                // are already doing one, or the connection is to network
                // 0. When this completes we update the local target,
                // for whatever good that does.
                //

                if ((!Connection->FindRouteInProgress) &&
                    (Connection->Retries == (Device->KeepAliveCount/2)) &&
                    (*(UNALIGNED ULONG *)Connection->RemoteHeader.DestinationNetwork != 0)) {

                    SendFindRoute = TRUE;
                    Connection->FindRouteInProgress = TRUE;
                    NbiReferenceConnectionSync (Connection, CREF_FIND_ROUTE);

                }

                //
                // Set this so we know to retransmit when the ack
                // is received.
                //

                if (Connection->SubState != CONNECTION_SUBSTATE_A_W_PROBE) {
                    Connection->ResponseTimeout = TRUE;
                }


                //
                // This releases the lock.
                //

                NbiSendDataAck(
                    Connection,
                    NbiAckQuery
                    NB_LOCK_HANDLE_ARG(LockHandle));


            }

        } else {

            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

        }

        if (SendFindRoute) {

            Connection->FindRouteRequest.Identifier = IDENTIFIER_NB;
            *(UNALIGNED ULONG *)Connection->FindRouteRequest.Network =
                *(UNALIGNED ULONG *)Connection->RemoteHeader.DestinationNetwork;
            RtlCopyMemory(Connection->FindRouteRequest.Node,Connection->RemoteHeader.DestinationNode,6);
            Connection->FindRouteRequest.Type = IPX_FIND_ROUTE_FORCE_RIP;

            (*Device->Bind.FindRouteHandler)(
                &Connection->FindRouteRequest);

        }

    } else {

        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

    }

}   /* NbiExpireRetansmit */


VOID
NbiExpireWatchdog(
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This routine is called when the connection's watchdog timer
    expires. It is called from NbiLongTimeout.

Arguments:

    Connection - Pointer to the connection whose timer has expired.

Return Value:

    none.

--*/

{
    NB_DEFINE_LOCK_HANDLE (LockHandle);


    NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);

    //
    // If we are not idle, then something else is happening
    // so the watchdog is unnecessary.
    //

    if ((Connection->State == CONNECTION_STATE_ACTIVE) &&
        (Connection->SubState == CONNECTION_SUBSTATE_A_IDLE)) {

        Connection->Retries = NbiDevice->KeepAliveCount;
        Connection->SubState = CONNECTION_SUBSTATE_A_W_PROBE;
        NbiStartRetransmit (Connection);

        //
        // This releases the lock.
        //

        NbiSendDataAck(
            Connection,
            NbiAckQuery
            NB_LOCK_HANDLE_ARG(LockHandle));

    } else {

        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

    }

}   /* NbiExpireWatchdog */


VOID
NbiShortTimeout(
    IN CTEEvent * Event,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called at regular intervals to see if any of
    the short connection timers have expired, and if so to execute their
    expiration routines.

Arguments:

    Event - The event controlling the timer.

    Context - Points to our device.

Return Value:

    none.

--*/

{
    PLIST_ENTRY p, nextp;
    PDEVICE Device = (PDEVICE)Context;
    PCONNECTION Connection;
    BOOLEAN RestartTimer = FALSE;
    LARGE_INTEGER CurrentTick;
    LARGE_INTEGER TickDifference;
    ULONG TickDelta;
    NB_DEFINE_LOCK_HANDLE (LockHandle);


    NB_SYNC_GET_LOCK (&Device->TimerLock, &LockHandle);

    //
    // This prevents anybody from starting the timer while we
    // are in this routine (the main reason for this is that it
    // makes it easier to determine whether we should restart
    // it at the end of this routine).
    //

    Device->ProcessingShortTimer = TRUE;

    //
    // Advance the up-counter used to mark time in SHORT_TIMER_DELTA units.  If we
    // advance it all the way to 0xf0000000, then reset it to 0x10000000.
    // We also run all the lists, decreasing all counters by 0xe0000000.
    //


    KeQueryTickCount (&CurrentTick);

    TickDifference.QuadPart = CurrentTick.QuadPart -
                              Device->ShortTimerStart.QuadPart;

    TickDelta = TickDifference.LowPart / NbiShortTimerDeltaTicks;
    if (TickDelta == 0) {
        TickDelta = 1;
    }

    Device->ShortAbsoluteTime += TickDelta;

    if (Device->ShortAbsoluteTime >= 0xf0000000) {

        ULONG Timeout;

        Device->ShortAbsoluteTime -= 0xe0000000;

        p = Device->ShortList.Flink;
        while (p != &Device->ShortList) {

            Connection = CONTAINING_RECORD (p, CONNECTION, ShortList);

            Timeout = Connection->Retransmit;
            if (Timeout) {
                Connection->Retransmit = Timeout - 0xe0000000;
            }

            p = p->Flink;
        }

    }

    p = Device->ShortList.Flink;
    while (p != &Device->ShortList) {

        Connection = CONTAINING_RECORD (p, CONNECTION, ShortList);

        ASSERT (Connection->OnShortList);

        //
        // To avoid problems with the refcount being 0, don't
        // do this if we are in ADM.
        //

        if (Connection->State == CONNECTION_STATE_ACTIVE) {

            if (Connection->Retransmit &&
                (Device->ShortAbsoluteTime > Connection->Retransmit)) {

                Connection->Retransmit = 0;
                NB_SYNC_FREE_LOCK (&Device->TimerLock, LockHandle);

                NbiExpireRetransmit (Connection);   // no locks held

                NB_SYNC_GET_LOCK (&Device->TimerLock, &LockHandle);

            }

        }

        if (!Connection->OnShortList) {

            //
            // The link has been taken out of the list while
            // we were processing it. In this (rare) case we
            // stop processing the whole list, we'll get it
            // next time.
            //

            break;

        }

        nextp = p->Flink;

        if (Connection->Retransmit == 0) {

            Connection->OnShortList = FALSE;
            RemoveEntryList(p);

            //
            // Do another check; that way if someone slipped in between
            // the check of Connection->Tx and the OnShortList = FALSE and
            // therefore exited without inserting, we'll catch that here.
            //

            if (Connection->Retransmit != 0) {
                InsertTailList(&Device->ShortList, &Connection->ShortList);
                Connection->OnShortList = TRUE;
            }

        }

        p = nextp;

    }

    //
    // If the list is empty note that, otherwise ShortListActive
    // remains TRUE.
    //

    if (IsListEmpty (&Device->ShortList)) {
        Device->ShortListActive = FALSE;
    }


    //
    // Connection Data Ack timers. This queue is used to indicate
    // that a piggyback ack is pending for this connection. We walk
    // the queue, for each element we check if the connection has
    // been on the queue for enough times through here,
    // If so, we take it off and send an ack. Note that
    // we have to be very careful how we walk the queue, since
    // it may be changing while this is running.
    //

    for (p = Device->DataAckConnections.Flink;
         p != &Device->DataAckConnections;
         p = p->Flink) {

        Connection = CONTAINING_RECORD (p, CONNECTION, DataAckLinkage);

        //
        // Skip this connection if it is not queued or it is
        // too recent to matter. We may skip incorrectly if
        // the connection is just being queued, but that is
        // OK, we will get it next time.
        //

        if (!Connection->DataAckPending) {
            continue;
        }

        ++Connection->DataAckTimeouts;

        if (Connection->DataAckTimeouts < Device->AckDelayTime) {
            continue;
        }

        NbiReferenceConnectionSync (Connection, CREF_SHORT_D_ACK);

        Device->DataAckQueueChanged = FALSE;

        NB_SYNC_FREE_LOCK (&Device->TimerLock, LockHandle);

        //
        // Check the correct connection flag, to ensure that a
        // send has not just taken him off the queue.
        //

        NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle);

        if (Connection->DataAckPending) {

            //
            // Yes, we were waiting to piggyback an ack, but no send
            // has come along. Turn off the flags and send an ack.
            // We set PiggybackAckTimeout to TRUE so that we won't try
            // to piggyback a response until we get back traffic.
            //

            Connection->DataAckPending = FALSE;
            Connection->PiggybackAckTimeout = TRUE;
            ++Device->Statistics.AckTimerExpirations;
            ++Device->Statistics.PiggybackAckTimeouts;

            //
            // This call releases the lock.
            //

            NbiSendDataAck(
                Connection,
                NbiAckResponse
                NB_LOCK_HANDLE_ARG(LockHandle));

        } else {

            NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle);

        }

        NbiDereferenceConnection (Connection, CREF_SHORT_D_ACK);

        NB_SYNC_GET_LOCK (&Device->TimerLock, &LockHandle);

        //
        // If the list has changed, then we need to stop processing
        // since p->Flink is not valid.
        //

        if (Device->DataAckQueueChanged) {
            break;
        }

    }

    if (IsListEmpty (&Device->DataAckConnections)) {
        Device->DataAckActive = FALSE;
    }


    //
    // Update the real counters from the temp ones. We have
    // TimerLock here, which is good enough.
    //

    ADD_TO_LARGE_INTEGER(
        &Device->Statistics.DataFrameBytesSent,
        Device->TempFrameBytesSent);
    Device->Statistics.DataFramesSent += Device->TempFramesSent;

    Device->TempFrameBytesSent = 0;
    Device->TempFramesSent = 0;

    ADD_TO_LARGE_INTEGER(
        &Device->Statistics.DataFrameBytesReceived,
        Device->TempFrameBytesReceived);
    Device->Statistics.DataFramesReceived += Device->TempFramesReceived;

    Device->TempFrameBytesReceived = 0;
    Device->TempFramesReceived = 0;


    //
    // Determine if we have to restart the timer.
    //

    Device->ProcessingShortTimer = FALSE;

    if ((Device->ShortListActive || Device->DataAckActive) &&
        (Device->State != DEVICE_STATE_STOPPING)) {

        RestartTimer = TRUE;

    }

    NB_SYNC_FREE_LOCK (&Device->TimerLock, LockHandle);

    if (RestartTimer) {

        //
        // Start up the timer again.  Note that because we start the timer
        // after doing work (above), the timer values will slip somewhat,
        // depending on the load on the protocol.  This is entirely acceptable
        // and will prevent us from using the timer DPC in two different
        // threads of execution.
        //

        KeQueryTickCount(&Device->ShortTimerStart);

        CTEStartTimer(
            &Device->ShortTimer,
            SHORT_TIMER_DELTA,
            NbiShortTimeout,
            (PVOID)Device);

    } else {

        NbiDereferenceDevice (Device, DREF_SHORT_TIMER);

    }

}   /* NbiShortTimeout */


VOID
NbiLongTimeout(
    IN CTEEvent * Event,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called at regular intervals to see if any of
    the long connection timers have expired, and if so to execute their
    expiration routines.

Arguments:

    Event - The event controlling the timer.

    Context - Points to our device.

Return Value:

    none.

--*/

{
    PDEVICE Device = (PDEVICE)Context;
    PLIST_ENTRY p, nextp;
    LIST_ENTRY AdapterStatusList;
    PREQUEST AdapterStatusRequest;
    PCONNECTION Connection;
    PNETBIOS_CACHE CacheName;
    NB_DEFINE_LOCK_HANDLE (LockHandle)
    NB_DEFINE_LOCK_HANDLE (LockHandle1)


    //
    // Advance the up-counter used to mark time in LONG_TIMER_DELTA units.  If we
    // advance it all the way to 0xf0000000, then reset it to 0x10000000.
    // We also run all the lists, decreasing all counters by 0xe0000000.
    //

    NB_SYNC_GET_LOCK (&Device->TimerLock, &LockHandle);

    if (++Device->LongAbsoluteTime == 0xf0000000) {

        ULONG Timeout;

        Device->LongAbsoluteTime = 0x10000000;

        p = Device->LongList.Flink;
        while (p != &Device->LongList) {

            Connection = CONTAINING_RECORD (p, CONNECTION, LongList);

            Timeout = Connection->Watchdog;
            if (Timeout) {
                Connection->Watchdog = Timeout - 0xe0000000;
            }

            p = p->Flink;
        }

    }


    if ((Device->LongAbsoluteTime % 4) == 0) {

        p = Device->LongList.Flink;
        while (p != &Device->LongList) {

            Connection = CONTAINING_RECORD (p, CONNECTION, LongList);

            ASSERT (Connection->OnLongList);

            //
            // To avoid problems with the refcount being 0, don't
            // do this if we are in ADM.
            //

            if (Connection->State == CONNECTION_STATE_ACTIVE) {

                if (Connection->Watchdog && (Device->LongAbsoluteTime > Connection->Watchdog)) {

                    Connection->Watchdog = 0;
                    NB_SYNC_FREE_LOCK (&Device->TimerLock, LockHandle);

                    NbiExpireWatchdog (Connection);       // no spinlocks held

                    NB_SYNC_GET_LOCK (&Device->TimerLock, &LockHandle);

                }

            }

            if (!Connection->OnLongList) {

                //
                // The link has been taken out of the list while
                // we were processing it. In this (rare) case we
                // stop processing the whole list, we'll get it
                // next time.
                //

#if DBG
                DbgPrint ("NBI: Stop processing LongList, %lx removed\n", Connection);
#endif
                break;

            }

            nextp = p->Flink;

            if (Connection->Watchdog == 0) {

                Connection->OnLongList = FALSE;
                RemoveEntryList(p);

                if (Connection->Watchdog != 0) {
                    InsertTailList(&Device->LongList, &Connection->LongList);
                    Connection->OnLongList = TRUE;
                }

            }

            p = nextp;

        }

    }


    //
    // Now scan the data ack queue, looking for connections with
    // no acks queued that we can get rid of.
    //
    // Note: The timer spinlock is held here.
    //

    for (p = Device->DataAckConnections.Flink;
         p != &Device->DataAckConnections;
         p = p->Flink) {

        Connection = CONTAINING_RECORD (p, CONNECTION, DataAckLinkage);

        if (Connection->DataAckPending) {
            continue;
        }

        NbiReferenceConnectionSync (Connection, CREF_LONG_D_ACK);

        NB_SYNC_FREE_LOCK (&Device->TimerLock, LockHandle);

        NB_SYNC_GET_LOCK (&Connection->Lock, &LockHandle1);
        NB_SYNC_GET_LOCK (&Device->TimerLock, &LockHandle);

        //
        // Have to check again, because the connection might
        // just have been stopped, and it also might just have
        // had a data ack queued.
        //

        if (Connection->OnDataAckQueue) {

            Connection->OnDataAckQueue = FALSE;

            RemoveEntryList (&Connection->DataAckLinkage);

            if (Connection->DataAckPending) {
                InsertTailList (&Device->DataAckConnections, &Connection->DataAckLinkage);
                Connection->OnDataAckQueue = TRUE;
            }

            Device->DataAckQueueChanged = TRUE;

        }

        NB_SYNC_FREE_LOCK (&Device->TimerLock, LockHandle);
        NB_SYNC_FREE_LOCK (&Connection->Lock, LockHandle1);

        NbiDereferenceConnection (Connection, CREF_LONG_D_ACK);

        NB_SYNC_GET_LOCK (&Device->TimerLock, &LockHandle);

        //
        // Since we have changed the list, we can't tell if p->Flink
        // is valid, so break. The effect is that we gradually peel
        // connections off the queue.
        //

        break;

    }

    NB_SYNC_FREE_LOCK (&Device->TimerLock, LockHandle);


    //
    // Scan for any uncompleted receive IRPs, this may happen if
    // the cable is pulled and we don't get any more ReceiveComplete
    // indications.

    NbiReceiveComplete((USHORT)0);


    //
    // Check if any adapter status queries are getting old.
    //

    InitializeListHead (&AdapterStatusList);

    NB_SYNC_GET_LOCK (&Device->Lock, &LockHandle);

    p = Device->ActiveAdapterStatus.Flink;

    while (p != &Device->ActiveAdapterStatus) {

        AdapterStatusRequest = LIST_ENTRY_TO_REQUEST(p);

        p = p->Flink;

        if (REQUEST_INFORMATION(AdapterStatusRequest) == 1) {

            //
            // We should resend a certain number of times.
            //

            RemoveEntryList (REQUEST_LINKAGE(AdapterStatusRequest));
            InsertTailList (&AdapterStatusList, REQUEST_LINKAGE(AdapterStatusRequest));

            //
            // We are going to abort this request, so dereference
            // the cache entry it used.
            //

            CacheName = (PNETBIOS_CACHE)REQUEST_STATUSPTR(AdapterStatusRequest);
            if (--CacheName->ReferenceCount == 0) {

                NB_DEBUG2 (CACHE, ("Free delete name cache entry %lx\n", CacheName));
                NbiFreeMemory(
                    CacheName,
                    sizeof(NETBIOS_CACHE) + ((CacheName->NetworksAllocated-1) * sizeof(NETBIOS_NETWORK)),
                    MEMORY_CACHE,
                    "Name deleted");

            }

        } else {

            ++REQUEST_INFORMATION(AdapterStatusRequest);

        }

    }

    NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);


    for (p = AdapterStatusList.Flink; p != &AdapterStatusList; ) {

        AdapterStatusRequest = LIST_ENTRY_TO_REQUEST(p);
        p = p->Flink;

        NB_DEBUG2 (QUERY, ("AdapterStatus %lx got name but no response\n", AdapterStatusRequest));

        REQUEST_INFORMATION(AdapterStatusRequest) = 0;
        REQUEST_STATUS(AdapterStatusRequest) = STATUS_IO_TIMEOUT;

        NbiCompleteRequest(AdapterStatusRequest);
        NbiFreeRequest (Device, AdapterStatusRequest);

        NbiDereferenceDevice (Device, DREF_STATUS_QUERY);

    }

    //
    // See if a minute has passed and we need to check for empty
    // cache entries to age out. We check for 64 seconds to make
    // the mod operation faster.
    //

#if     defined(_PNP_POWER)
    NB_SYNC_GET_LOCK (&Device->Lock, &LockHandle);
#endif  _PNP_POWER

    ++Device->CacheTimeStamp;

    if ((Device->CacheTimeStamp % 64) == 0) {


        //
        // flush all the entries which have been around for ten minutes
        // (LONG_TIMER_DELTA is in milliseconds).
        //

        FlushOldFromNetbiosCacheTable( Device->NameCache, (600000 / LONG_TIMER_DELTA) );

    }


    //
    // Start up the timer again.  Note that because we start the timer
    // after doing work (above), the timer values will slip somewhat,
    // depending on the load on the protocol.  This is entirely acceptable
    // and will prevent us from using the timer DPC in two different
    // threads of execution.
    //

    if (Device->State != DEVICE_STATE_STOPPING) {

        CTEStartTimer(
            &Device->LongTimer,
            LONG_TIMER_DELTA,
            NbiLongTimeout,
            (PVOID)Device);

    } else {
#if     defined(_PNP_POWER)
        Device->LongTimerRunning = FALSE;
#endif  _PNP_POWER
        NbiDereferenceDevice (Device, DREF_LONG_TIMER);
    }

#if     defined(_PNP_POWER)
    NB_SYNC_FREE_LOCK (&Device->Lock, LockHandle);
#endif  _PNP_POWER
}   /* NbiLongTimeout */


VOID
NbiStartShortTimer(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine starts the short timer, if it is not already running.

Arguments:

    Device - Pointer to our device context.

Return Value:

    none.

--*/

{

    //
    // Start the timer unless it the DPC is already running (in
    // which case it will restart the timer itself if needed),
    // or some list is active (meaning the timer is already
    // queued up).
    //

    if ((!Device->ProcessingShortTimer) &&
        (!(Device->ShortListActive)) &&
        (!(Device->DataAckActive))) {

        NbiReferenceDevice (Device, DREF_SHORT_TIMER);

        KeQueryTickCount(&Device->ShortTimerStart);

        CTEStartTimer(
            &Device->ShortTimer,
            SHORT_TIMER_DELTA,
            NbiShortTimeout,
            (PVOID)Device);

    }

}   /* NbiStartShortTimer */


VOID
NbiInitializeTimers(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine initializes the lightweight timer system for the transport
    provider.

Arguments:

    Device - Pointer to our device.

Return Value:

    none.

--*/

{

    //
    // NbiTickIncrement is the number of NT time increments
    // which pass between each tick. NbiShortTimerDeltaTicks
    // is the number of ticks which should happen in
    // SHORT_TIMER_DELTA milliseconds (i.e. between each
    // expiration of the short timer).
    //

    NbiTickIncrement = KeQueryTimeIncrement();

    if (NbiTickIncrement > (SHORT_TIMER_DELTA * MILLISECONDS)) {
        NbiShortTimerDeltaTicks = 1;
    } else {
        NbiShortTimerDeltaTicks = (SHORT_TIMER_DELTA * MILLISECONDS) / NbiTickIncrement;
    }

    //
    // The AbsoluteTime cycles between 0x10000000 and 0xf0000000.
    //

    Device->ShortAbsoluteTime = 0x10000000;
    Device->LongAbsoluteTime = 0x10000000;

    CTEInitTimer (&Device->ShortTimer);
    CTEInitTimer (&Device->LongTimer);

#if      !defined(_PNP_POWER)
    //
    // One reference for the long timer.
    //

    NbiReferenceDevice (Device, DREF_LONG_TIMER);

    CTEStartTimer(
        &Device->LongTimer,
        LONG_TIMER_DELTA,
        NbiLongTimeout,
        (PVOID)Device);

#endif  !_PNP_POWER

    Device->TimersInitialized = TRUE;
    Device->ShortListActive = FALSE;
    Device->ProcessingShortTimer = FALSE;

    InitializeListHead (&Device->ShortList);
    InitializeListHead (&Device->LongList);

    CTEInitLock (&Device->TimerLock.Lock);

} /* NbiInitializeTimers */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxbind.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxbind.c

Abstract:

    This module contains the code to bind to the IPX transport, as well as the
	indication routines for the IPX transport not including the send/recv ones.

Author:

	Stefan Solomon	 (stefans) Original Version
    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

//	Define module number for event logging entries
#define	FILENUM		SPXBIND

extern IPX_INTERNAL_PNP_COMPLETE       IpxPnPComplete;

VOID
SpxStatus (
    IN USHORT NicId,
    IN NDIS_STATUS GeneralStatus,
    IN PVOID StatusBuffer,
    IN UINT StatusBufferLength);

VOID
SpxFindRouteComplete (
    IN PIPX_FIND_ROUTE_REQUEST FindRouteRequest,
    IN BOOLEAN FoundRoute);

VOID
SpxScheduleRoute (
    IN PIPX_ROUTE_ENTRY RouteEntry);

VOID
SpxLineDown (
    IN USHORT NicId,
    IN ULONG_PTR FwdAdapterContext);

VOID
SpxLineUp (
    IN USHORT           NicId,
    IN PIPX_LINE_INFO   LineInfo,
    IN NDIS_MEDIUM 		DeviceType,
    IN PVOID            ConfigurationData);

VOID
SpxFindRouteComplete (
    IN PIPX_FIND_ROUTE_REQUEST FindRouteRequest,
    IN BOOLEAN FoundRoute);

#if     defined(_PNP_POWER)
NTSTATUS
SpxPnPNotification(
    IN IPX_PNP_OPCODE OpCode,
    IN PVOID          PnPData
    );
#endif  _PNP_POWER

VOID
SpxPnPCompletionHandler(
                        PNET_PNP_EVENT      netevent,
                        NTSTATUS            status
                        );

#if     defined(_PNP_POWER)
//
// globals and externs
//
extern CTELock     		spxTimerLock;
extern LARGE_INTEGER	spxTimerTick;
extern KTIMER			spxTimer;
extern KDPC				spxTimerDpc;
extern BOOLEAN          spxTimerStopped;
#endif  _PNP_POWER

NTSTATUS
SpxInitBindToIpx(
    VOID
    )

{
    NTSTATUS                    status;
    IO_STATUS_BLOCK             ioStatusBlock;
    OBJECT_ATTRIBUTES           objectAttr;
    PIPX_INTERNAL_BIND_INPUT    pBindInput;
    PIPX_INTERNAL_BIND_OUTPUT   pBindOutput;

    InitializeObjectAttributes(
        &objectAttr,
        &IpxDeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    status = NtCreateFile(
                &IpxHandle,
                SYNCHRONIZE | GENERIC_READ,
                &objectAttr,
                &ioStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0L);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    if ((pBindInput = CTEAllocMem(sizeof(IPX_INTERNAL_BIND_INPUT))) == NULL) {
        NtClose(IpxHandle);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    // Fill in our bind data
#if     defined(_PNP_POWER)
    pBindInput->Version                     = ISN_VERSION;
#else
    pBindInput->Version                     = 1;
#endif  _PNP_POWER
    pBindInput->Identifier                  = IDENTIFIER_SPX;
    pBindInput->BroadcastEnable             = FALSE;
    pBindInput->LookaheadRequired           = IPX_HDRSIZE;
    pBindInput->ProtocolOptions             = 0;
    pBindInput->ReceiveHandler              = SpxReceive;
    pBindInput->ReceiveCompleteHandler      = SpxReceiveComplete;
    pBindInput->StatusHandler               = SpxStatus;
    pBindInput->SendCompleteHandler         = SpxSendComplete;
    pBindInput->TransferDataCompleteHandler = SpxTransferDataComplete;
    pBindInput->FindRouteCompleteHandler    = SpxFindRouteComplete;
    pBindInput->LineUpHandler               = SpxLineUp;
    pBindInput->LineDownHandler             = SpxLineDown;
    pBindInput->ScheduleRouteHandler        = SpxScheduleRoute;
#if     defined(_PNP_POWER)
    pBindInput->PnPHandler                  = SpxPnPNotification;
#endif  _PNP_POWER


    //  First get the length for the output buffer.
    status = NtDeviceIoControlFile(
                IpxHandle,                  // HANDLE to File
                NULL,                       // HANDLE to Event
                NULL,                       // ApcRoutine
                NULL,                       // ApcContext
                &ioStatusBlock,             // IO_STATUS_BLOCK
                IOCTL_IPX_INTERNAL_BIND,    // IoControlCode
                pBindInput,                 // Input Buffer
                sizeof(IPX_INTERNAL_BIND_INPUT),    // Input Buffer Length
                NULL,                               // Output Buffer
                0);

    if (status == STATUS_PENDING) {
        status  = NtWaitForSingleObject(
                    IpxHandle,
                    (BOOLEAN)FALSE,
                    NULL);
    }

    if (status != STATUS_BUFFER_TOO_SMALL) {
        CTEFreeMem(pBindInput);
        NtClose(IpxHandle);
        return(STATUS_INVALID_PARAMETER);
    }

    if ((pBindOutput = CTEAllocMem(ioStatusBlock.Information)) == NULL) {
        CTEFreeMem(pBindInput);
        NtClose(IpxHandle);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    // ioStatusBlock.Information is of type ULONG_PTR and is used as
    // OutputBufferLength in NtDeviceIoControlFile.
    // The length should not exceed ulong or we have to wait until
    // NtDeviceIoControlFile changes to get rid of warning.
    status = NtDeviceIoControlFile(
                IpxHandle,                  // HANDLE to File
                NULL,                       // HANDLE to Event
                NULL,                       // ApcRoutine
                NULL,                       // ApcContext
                &ioStatusBlock,             // IO_STATUS_BLOCK
                IOCTL_IPX_INTERNAL_BIND,    // IoControlCode
                pBindInput,                 // Input Buffer
                sizeof(IPX_INTERNAL_BIND_INPUT),    // Input Buffer Length
                pBindOutput,                        // Output Buffer
                (ULONG)(ioStatusBlock.Information));

    if (status == STATUS_PENDING) {
        status  = NtWaitForSingleObject(
                    IpxHandle,
                    (BOOLEAN)FALSE,
                    NULL);
    }

    if (status == STATUS_SUCCESS) {

        //  Get all the info from the bind output buffer and save in
        //  appropriate places.
        IpxLineInfo         = pBindOutput->LineInfo;
        IpxMacHdrNeeded     = pBindOutput->MacHeaderNeeded;
        IpxInclHdrOffset    = pBindOutput->IncludedHeaderOffset;

        IpxSendPacket       = pBindOutput->SendHandler;
        IpxFindRoute        = pBindOutput->FindRouteHandler;
        IpxQuery		    = pBindOutput->QueryHandler;
        IpxTransferData	    = pBindOutput->TransferDataHandler;

        IpxPnPComplete      = pBindOutput->PnPCompleteHandler;

#if      !defined(_PNP_POWER)
		//  Copy over the network node info.
        RtlCopyMemory(
            SpxDevice->dev_Network,
            pBindOutput->Network,
            IPX_NET_LEN);

        RtlCopyMemory(
            SpxDevice->dev_Node,
            pBindOutput->Node,
            IPX_NODE_LEN);


		DBGPRINT(TDI, INFO,
				("SpxInitBindToIpx: Ipx Net %lx\n",
					*(UNALIGNED ULONG *)SpxDevice->dev_Network));

        //
        // Find out how many adapters IPX has, if this fails
        // just assume one.
        //

        if ((*IpxQuery)(
                IPX_QUERY_MAXIMUM_NIC_ID,
                0,
                &SpxDevice->dev_Adapters,
                sizeof(USHORT),
                NULL) != STATUS_SUCCESS) {

            SpxDevice->dev_Adapters = 1;

        }
#endif  !_PNP_POWER
    } else {

        NtClose(IpxHandle);
        status  = STATUS_INVALID_PARAMETER;
    }
    CTEFreeMem(pBindInput);
    CTEFreeMem(pBindOutput);

    return status;
}




VOID
SpxUnbindFromIpx(
    VOID
    )

{
    NtClose(IpxHandle);
    return;
}




VOID
SpxStatus(
    IN USHORT NicId,
    IN NDIS_STATUS GeneralStatus,
    IN PVOID StatusBuffer,
    IN UINT StatusBufferLength
    )

{
	DBGPRINT(RECEIVE, ERR,
			("SpxStatus: CALLED WITH %lx\n",
				GeneralStatus));

    return;
}



VOID
SpxFindRouteComplete (
    IN PIPX_FIND_ROUTE_REQUEST	FindRouteRequest,
    IN BOOLEAN 					FoundRoute
    )

{
	CTELockHandle			lockHandle;
	PSPX_FIND_ROUTE_REQUEST	pSpxFrReq = (PSPX_FIND_ROUTE_REQUEST)FindRouteRequest;
	PSPX_CONN_FILE			pSpxConnFile = (PSPX_CONN_FILE)pSpxFrReq->fr_Ctx;

	//	This will be on a connection. Grab the lock, check the state and go from
	//	there.
	if (pSpxConnFile == NULL)
	{
		//	Should this ever happen?
		KeBugCheck(0);
		return;
	}

	//	Check the state. The called routines release the lock, remove the reference.
	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
	if (SPX_CONN_CONNECTING(pSpxConnFile))
	{
		//	We are doing an active connect!
		SpxConnConnectFindRouteComplete(
			pSpxConnFile,
			pSpxFrReq,
			FoundRoute,
			lockHandle);
    }
	else 		// For all others call active
	{
		SpxConnActiveFindRouteComplete(
			pSpxConnFile,
			pSpxFrReq,
			FoundRoute,
			lockHandle);
	}

	//	Free the find route request.
	SpxFreeMemory(pSpxFrReq);

    return;
}




VOID
SpxLineUp (
    IN USHORT           NicId,
    IN PIPX_LINE_INFO   LineInfo,
    IN NDIS_MEDIUM 		DeviceType,
    IN PVOID            ConfigurationData
    )

{
    // With PnP, our local address is changed when we get PnP
    // notification.
#if      !defined(_PNP_POWER)

    //
    // If we get a line up for NicId 0, it means our local
    // network number has changed, re-query from IPX.
    //

    if (NicId == 0) {

        TDI_ADDRESS_IPX IpxAddress;

        if ((*IpxQuery)(
                  IPX_QUERY_IPX_ADDRESS,
                  0,
                  &IpxAddress,
                  sizeof(TDI_ADDRESS_IPX),
                  NULL) == STATUS_SUCCESS) {

            RtlCopyMemory(
                SpxDevice->dev_Network,
                &IpxAddress.NetworkAddress,
                IPX_NET_LEN);

    		DBGPRINT(TDI, INFO,
    				("SpxLineUp: Ipx Net %lx\n",
    					*(UNALIGNED ULONG *)SpxDevice->dev_Network));

            //
            // The node shouldn't change!
            //

            if (!RtlEqualMemory(
                SpxDevice->dev_Node,
                IpxAddress.NodeAddress,
                IPX_NODE_LEN)) {

            	DBGPRINT(TDI, ERR,
            			("SpxLineUp: Node address has changed\n"));
            }
        }

    } else {

    	DBGPRINT(RECEIVE, ERR,
    			("SpxLineUp: CALLED WITH %lx\n",
    				NicId));
    }

    return;
#endif  !_PNP_POWER

}




VOID
SpxLineDown (
    IN USHORT NicId,
    IN ULONG_PTR FwdAdapterContext
    )

{
	DBGPRINT(RECEIVE, ERR,
			("SpxLineDown: CALLED WITH %lx\n",
				NicId));

    return;
}




VOID
SpxScheduleRoute (
    IN PIPX_ROUTE_ENTRY RouteEntry
    )

{
	DBGPRINT(RECEIVE, ERR,
			("SpxScheduleRoute: CALLED WITH %lx\n",
				RouteEntry));

    return;
}

#if     defined(_PNP_POWER)
NTSTATUS
SpxPnPNotification(
    IN IPX_PNP_OPCODE OpCode,
    IN PVOID          PnPData
    )

/*++

Routine Description:

    This function receives the notification about PnP events from IPX

Arguments:

    OpCode  -   Type of the PnP event

    PnPData -   Data associated with this event.

Return Value:

    None.

--*/

{

    USHORT          MaximumNicId = 0;
    CTELockHandle   LockHandle;
    PDEVICE         Device      =   SpxDevice;
    UNICODE_STRING  UnicodeDeviceName;
    NTSTATUS        Status = STATUS_SUCCESS;

#ifdef _PNP_POWER_
    PNET_PNP_EVENT  NetPnpEvent;

#endif // _PNP_POWER_

    DBGPRINT(DEVICE, DBG,("Received a pnp notification, opcode %d\n",OpCode));

    switch( OpCode ) {
    case IPX_PNP_ADD_DEVICE : {
        CTELockHandle   TimerLockHandle;
        IPX_PNP_INFO   UNALIGNED *PnPInfo = (IPX_PNP_INFO UNALIGNED *)PnPData;


        CTEGetLock (&Device->dev_Lock, &LockHandle);

        if ( PnPInfo->FirstORLastDevice ) {
            CTEAssert( PnPInfo->NewReservedAddress );
            //CTEAssert( Device->dev_State != DEVICE_STATE_OPEN );

            *(UNALIGNED ULONG *)Device->dev_Network    =   PnPInfo->NetworkAddress;
            RtlCopyMemory( Device->dev_Node, PnPInfo->NodeAddress, 6);

            //
            // Start the timer. It is possible that the timer
            // was still running or we are still in the timer dpc
            // from the previous ADD_DEVICE - DELETE_DEVICE execution
            // cycle. But it is ok simply restart this, because
            // KeSetTimer implicitly cancels the previous Dpc.
            //

            CTEGetLock(&spxTimerLock, &TimerLockHandle);
            spxTimerStopped = FALSE;
            CTEFreeLock(&spxTimerLock, TimerLockHandle);
            KeSetTimer(&spxTimer,
                spxTimerTick,
                &spxTimerDpc);


            Device->dev_State   =   DEVICE_STATE_OPEN;


            //CTEAssert( !Device->dev_Adapters );

            IpxLineInfo.MaximumSendSize =   PnPInfo->LineInfo.MaximumSendSize;
            IpxLineInfo.MaximumPacketSize = PnPInfo->LineInfo.MaximumPacketSize;
            // set the provider info
            SpxDevice->dev_ProviderInfo.MaximumLookaheadData	= IpxLineInfo.MaximumPacketSize;
            //	Set the window size in statistics
            SpxDevice->dev_Stat.MaximumSendWindow =
            SpxDevice->dev_Stat.AverageSendWindow = PARAM(CONFIG_WINDOW_SIZE) *
                                                    IpxLineInfo.MaximumSendSize;

        }else {
            IpxLineInfo.MaximumSendSize =   PnPInfo->LineInfo.MaximumSendSize;
            //	Set the window size in statistics
            SpxDevice->dev_Stat.MaximumSendWindow =
            SpxDevice->dev_Stat.AverageSendWindow = PARAM(CONFIG_WINDOW_SIZE) *
                                                    IpxLineInfo.MaximumSendSize;

        }

        Device->dev_Adapters++;
        CTEFreeLock ( &Device->dev_Lock, LockHandle );

        //
        // Notify the TDI clients about the device creation
        //
        if ( PnPInfo->FirstORLastDevice ) {
            UnicodeDeviceName.Buffer        =  Device->dev_DeviceName;
            UnicodeDeviceName.MaximumLength =  Device->dev_DeviceNameLen;
            UnicodeDeviceName.Length        =  Device->dev_DeviceNameLen - sizeof(WCHAR);

            if ( !NT_SUCCESS( TdiRegisterDeviceObject(
                                &UnicodeDeviceName,
                                &Device->dev_TdiRegistrationHandle ) )) {
                DBGPRINT(TDI,ERR, ("Failed to register Spx Device with TDI\n"));
            }
        }

        break;
    }
    case IPX_PNP_DELETE_DEVICE : {

        IPX_PNP_INFO   UNALIGNED *PnPInfo = (IPX_PNP_INFO UNALIGNED *)PnPData;

        CTEGetLock (&Device->dev_Lock, &LockHandle);

        CTEAssert( Device->dev_Adapters );
        Device->dev_Adapters--;

        if ( PnPInfo->FirstORLastDevice ) {
            Device->dev_State       = DEVICE_STATE_LOADED;
            Device->dev_Adapters    = 0;
        }

        IpxLineInfo.MaximumSendSize =   PnPInfo->LineInfo.MaximumSendSize;
        CTEFreeLock ( &Device->dev_Lock, LockHandle );

        if ( PnPInfo->FirstORLastDevice ) {
            SpxTimerFlushAndStop();
            //
            // inform tdi clients about the device deletion
            //
            if ( !NT_SUCCESS( TdiDeregisterDeviceObject(
                                Device->dev_TdiRegistrationHandle ) )) {
                DBGPRINT(TDI,ERR, ("Failed to Deregister Spx Device with TDI\n"));
            }
        }
        //
        // TBD: call ExNotifyCallback
        //

        break;
    }
    case IPX_PNP_ADDRESS_CHANGE: {
        IPX_PNP_INFO   UNALIGNED *PnPInfo = (IPX_PNP_INFO UNALIGNED *)PnPData;

        CTEGetLock (&Device->dev_Lock, &LockHandle);
        CTEAssert( PnPInfo->NewReservedAddress );

        *(UNALIGNED ULONG *)Device->dev_Network    =   PnPInfo->NetworkAddress;
        RtlCopyMemory( Device->dev_Node, PnPInfo->NodeAddress, 6);

        CTEFreeLock ( &Device->dev_Lock, LockHandle );
        break;
    }
    case IPX_PNP_TRANSLATE_DEVICE:
        break;
    case IPX_PNP_TRANSLATE_ADDRESS:
        break;

#ifdef _PNP_POWER_

    case IPX_PNP_QUERY_POWER:
    case IPX_PNP_QUERY_REMOVE:

        //
        // IPX wants to know if we can power off or remove an apapter.
        // We also look if there are any open connections before deciding.
        // See if we support the NDIS_DEVICE_POWER_STATE
        //
        NetPnpEvent = (PNET_PNP_EVENT) PnPData;
        UnicodeDeviceName.Buffer        =  Device->dev_DeviceName;
        UnicodeDeviceName.MaximumLength =  Device->dev_DeviceNameLen;
        UnicodeDeviceName.Length        =  Device->dev_DeviceNameLen - sizeof(WCHAR);

        // First, Via TDI to our Clients.
        Status = TdiPnPPowerRequest(
                    &UnicodeDeviceName,
                    NetPnpEvent,
                    NULL,
                    NULL,
                    IpxPnPComplete
                    );

#if 0

        if (STATUS_SUCCESS == Status) {
            // now if we do not have any open connections,
            // we are all set.

            Status = STATUS_DEVICE_BUSY;

        }
#endif
        break;

    case IPX_PNP_SET_POWER:
    case IPX_PNP_CANCEL_REMOVE:

        NetPnpEvent = (PNET_PNP_EVENT) PnPData;
        UnicodeDeviceName.Buffer        =  Device->dev_DeviceName;
        UnicodeDeviceName.MaximumLength =  Device->dev_DeviceNameLen;
        UnicodeDeviceName.Length        =  Device->dev_DeviceNameLen - sizeof(WCHAR);

        //
        // Just call TDI here.
        //

        Status = TdiPnPPowerRequest(
                    &UnicodeDeviceName,
                    NetPnpEvent,
                    NULL,
                    NULL,
                    IpxPnPComplete
                    );

        break;

#endif // _PNP_POWER_

    default:
        CTEAssert( FALSE );
    }

    return Status;

}   /* SpxPnPNotification */

#endif  _PNP_POWER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxconn.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxconn.h				

Abstract:


Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:

    Sanjay Anand (SanjayAn) 5-July-1995
    Bug fixes - tagged [SA]

--*/

//	Minimum value for RTT in ms.
//	Have these be a derivate of registry values.
#define	SPX_T1_MIN					200
#define	MAX_RETRY_DELAY				5000	//	5 seconds
#define	SPX_DEF_RENEG_RETRYCOUNT	1		//  All reneg pkts except min sent once

//	Some types
typedef enum
{
	SPX_CALL_RECVLEVEL,
	SPX_CALL_TDILEVEL
} SPX_CALL_LEVEL;

typedef enum
{
	SPX_REQ_DATA,
	SPX_REQ_ORDREL,
	SPX_REQ_DISC

} SPX_SENDREQ_TYPE;

// This structure is pointed to by the FsContext field in the FILE_OBJECT
// for this Connection.

#define CFREF_CREATE     	0
#define CFREF_VERIFY     	1
#define CFREF_INDICATION 	2
#define CFREF_BYCTX			3
#define CFREF_BYID			4
#define CFREF_ADDR			5
#define CFREF_REQ			6
#define CFREF_TIMER			7
#define	CFREF_PKTIZE		8
#define	CFREF_RECV			9
#define	CFREF_ABORTPKT		10
#define	CFREF_ERRORSTATE	11
#define	CFREF_FINDROUTE		12

//
// New state added to reflect an SPXI connection which is waiting for
// a local disconnect after having indicated a RELEASE to AFD.
//
#define	CFREF_DISCWAITSPX   13

#define CFREF_TOTAL  		14

#define CFMAX_STATES        20

typedef struct _SPX_CONN_FILE
{

#if DBG
    ULONG 	scf_RefTypes[CFREF_TOTAL];

#if 0
//
// Disabled for now - to enable logging of states, move this array *after* the Type/Size;
// a change in their offset can cause problems since we assume the offset to be less than
// the size of an AddressFile structure. (see SpxTdiQueryInformation)
//
    ULONG   scf_StateBuffer[CFMAX_STATES];
    ULONG   scf_NextStatePtr;
#endif

#endif

    CSHORT 					scf_Type;
    CSHORT 					scf_Size;

	// number of references to this object.
    ULONG 					scf_RefCount;

    // Linkage in device address file list. The connection can be on the device
	// connection list, address inactive/listen/active list.
    struct _SPX_CONN_FILE *	scf_Next;
	struct _SPX_CONN_FILE * scf_AssocNext;
    struct _SPX_CONN_FILE *	scf_GlobalActiveNext;

	// Queued in a global list, stays here from creation to destroy.
    struct _SPX_CONN_FILE *	scf_GlobalNext;
    struct _SPX_CONN_FILE *	scf_PktNext;
    struct _SPX_CONN_FILE *	scf_ProcessRecvNext;

    // the current state of the connection. One main state and multiple substates.
    ULONG 					scf_Flags;

	//	More information
	ULONG					scf_Flags2;

#if DBG
	//	Save the state of flags/flags2 before reinit. Overwritten every reinit.
	ULONG					scf_GhostFlags;
	ULONG					scf_GhostFlags2;
	ULONG					scf_GhostRefCount;
	PREQUEST				scf_GhostDiscReq;
#endif

	//	Connection retry counts, or watchdog timer count when the connection goes
	//	active
	union
	{
		LONG				scf_CRetryCount;
		LONG				scf_WRetryCount;
	};
	LONG					scf_RRetryCount;
	USHORT					scf_RRetrySeqNum;

	union
	{
		ULONG				scf_CTimerId;
		ULONG				scf_RTimerId;	//	Only after we turn active
	};

	ULONG					scf_WTimerId;		//	Watchdog timer
	ULONG					scf_TTimerId;		//	TDI Connect/Disconnect timer
	ULONG					scf_ATimerId;		//	Ack timer id

	//	Variables used to manage the Retry timer tick value
	//	Note our timer subsytem fires at 100ms granularity.
	int						scf_BaseT1;
	int						scf_AveT1;
	int						scf_DevT1;

	//	Stored in HOST-ORDER
	//	LOCAL variables
	USHORT					scf_LocalConnId;
	USHORT					scf_SendSeqNum;				// Debug dw +9a
	USHORT					scf_SentAllocNum;			// 		 dw +9c

	//	REMOTE variables
	USHORT					scf_RecvSeqNum;				// 		 dw +9e
	USHORT					scf_RecdAckNum;				//		 dw +a0
	USHORT					scf_RecdAllocNum;			// 		 dw +a2

	//	RETRY sequence number
	USHORT					scf_RetrySeqNum;

	//	Saved ack number to be used in building the reneg ack packet.
	//	Note that our RecvSeqNum which we normally use is overwritten
	//	when we receive a renegotiate request.
	USHORT					scf_RenegAckAckNum;

	//	Stored in NETWORK-ORDER. scf_RemAckAddr contains the remote address
	//	for a data packet that had the ack bit set, buildAck will use this
	//	address.
	BYTE			 		scf_RemAddr[12];
	BYTE			 		scf_RemAckAddr[12];
	USHORT                  scf_RemConnId;				// Debug  dw +be

	//	Maximum packet size (or size of first) reneg packet.
	USHORT					scf_RenegMaxPktSize;

	//	Local target to use in when sending acks. This is set to received
	//	data's indicated local target.
	IPX_LOCAL_TARGET		scf_AckLocalTarget;

	//	Maximum packet size to use for this connection
	USHORT					scf_MaxPktSize;
	UCHAR					scf_DataType;

	//	Local target to use in sends, initialized upon connect indication
	//	or when find_route completes
	IPX_LOCAL_TARGET		scf_LocalTarget;

	// Connection lock
    CTELock  				scf_Lock;

    // address to which we are bound
    struct _SPX_ADDR_FILE *	scf_AddrFile;

	// Connection context
	CONNECTION_CONTEXT		scf_ConnCtx;

#ifdef ISN_NT
	// easy backlink to file object.
    PFILE_OBJECT 			scf_FileObject;
#endif

	// LIST_ENTRY of disconnect irps waiting for completion. There could be
	// multiple disconnect inform irps.
	LIST_ENTRY				scf_DiscLinkage;

	// LIST_ENTRY of send requests (intially contains connect/listen/accept also)
	// on this connection.
	LIST_ENTRY				scf_ReqLinkage;

	//	Queue for completed requests awaiting completion
	LIST_ENTRY				scf_ReqDoneLinkage;
	LIST_ENTRY				scf_RecvDoneLinkage;

	//	Queue for pending receives
	LIST_ENTRY				scf_RecvLinkage;
	PREQUEST				scf_CurRecvReq;
	ULONG					scf_CurRecvOffset;
	ULONG					scf_CurRecvSize;

	//	Current request packetize info
	PREQUEST				scf_ReqPkt;
	ULONG					scf_ReqPktOffset;
	ULONG					scf_ReqPktSize;
	ULONG					scf_ReqPktFlags;
	SPX_SENDREQ_TYPE		scf_ReqPktType;

	// Single linked list of sequenced send/disc packets
	PSPX_SEND_RESD 			scf_SendSeqListHead;
	PSPX_SEND_RESD 			scf_SendSeqListTail;

	// Single linked list of send (unsequenced) packets
	PSPX_SEND_RESD			scf_SendListHead;
	PSPX_SEND_RESD			scf_SendListTail;

	// Single linked list of buffered recv packets.
	PSPX_RECV_RESD			scf_RecvListHead;
	PSPX_RECV_RESD			scf_RecvListTail;

	// Connect request
    PREQUEST 				scf_ConnectReq;

    // This holds the request used to close this address file,
    // for pended completion. We also pend cleanup requests for connections.
    PREQUEST 				scf_CleanupReq;
    PREQUEST 				scf_CloseReq;

#if DBG

	//	Packet being indicated, seq num, flags/flags2
	USHORT					scf_PktSeqNum;
	ULONG					scf_PktFlags;
	ULONG					scf_PktFlags2;

	ULONG					scf_IndBytes;
	ULONG					scf_IndLine;
#endif

#if DBG_WDW_CLOSE

	//	Keep track of how long the window was closed on this connection.
	ULONG					scf_WdwCloseAve;
	LARGE_INTEGER			scf_WdwCloseTime;	//	Time when wdw was closed
#endif

	// device to which we are attached.
    struct _DEVICE *		scf_Device;

} SPX_CONN_FILE, *PSPX_CONN_FILE;


//	Basic states
//  Least significant byte of flags is used.
//	Mutually exclusive states are coded as numbers, others are bit flags.
//	Only main states are currently in form of numbers. Also, send and receive.
//
//	Once we go active, we need SEND/RECEIVE/DISC substates to be mutually
//	exclusive with each other. As all three could be active at the same time.

//  Connection MAIN states. These are all mutually exclusive.
#define SPX_CONNFILE_MAINMASK	0x00000007
#define	SPX_CONNFILE_ACTIVE		0x00000001
#define	SPX_CONNFILE_CONNECTING	0x00000002
#define	SPX_CONNFILE_LISTENING	0x00000003
#define SPX_CONNFILE_DISCONN	0x00000004

//  Connecting states (VALID when CONNFILE_CONNECTING)
#define	SPX_CONNECT_MASK		0x000000F0
#define	SPX_CONNECT_SENTREQ		0x00000010
#define	SPX_CONNECT_NEG			0x00000020
#define	SPX_CONNECT_W_SETUP		0x00000030

//  Listening states (VALID when CONNFILE_LISTENING)
#define	SPX_LISTEN_MASK			0x000000F0
#define	SPX_LISTEN_RECDREQ      0x00000010
#define	SPX_LISTEN_SENTACK     	0x00000020
#define	SPX_LISTEN_NEGACK	    0x00000030
#define	SPX_LISTEN_SETUP	    0x00000040

//	Connection SUB states
//	Send machine states	 (VALID when CONNFILE_ACTIVE)
#define	SPX_SEND_MASK			0x000000F0
#define	SPX_SEND_IDLE			0x00000000
#define	SPX_SEND_PACKETIZE		0x00000010
#define	SPX_SEND_RETRY			0x00000020
#define	SPX_SEND_RETRYWD		0x00000030
#define	SPX_SEND_RENEG			0x00000040
#define	SPX_SEND_RETRY2			0x00000050
#define	SPX_SEND_RETRY3			0x00000060
#define	SPX_SEND_WD				0x00000070	//	We dont reneg pkt size on wdog
											//  Also we change to this state only
											//	2nd time wdog fires w/out ack.
#define	SPX_SEND_NAK_RECD		0x00000080

//	Receive machine states (VALID when CONNFILE_ACTIVE)
#define	SPX_RECV_MASK			0x00000F00
#define	SPX_RECV_IDLE			0x00000000
#define	SPX_RECV_POSTED			0x00000100
#define	SPX_RECV_PROCESS_PKTS	0x00000200

//	Disconnect states (VALID when CONNFILE_DISCONN/CONNFILE_ACTIVE)
//	These are valid when either ACTIVE/DISCONN is set. We use these when
//	active for a orderly release, i.e. we receive pkt from remote, but we
//	stay active (setting SPX_DISC_RECV_ORDREL) until our client posts a
//	disconnect, which is when we move to disconnecting.
#define	SPX_DISC_MASK			0x0000F000
#define SPX_DISC_IDLE			0x00000000
#define SPX_DISC_ABORT			0x00001000
#define	SPX_DISC_SENT_IDISC		0x00002000
#define	SPX_DISC_POST_ORDREL    0x00003000
#define	SPX_DISC_SENT_ORDREL    0x00004000
#define	SPX_DISC_ORDREL_ACKED	0x00005000
#define	SPX_DISC_POST_IDISC		0x00006000

// [SA] bug #14655 added flag to indicate that SpxConnInactivate already called for
// this disconnecting connection
//
#define SPX_DISC_INACTIVATED    0x00007000

//	The following are not mutually exclusive.
#define SPX_CONNFILE_RECVQ    	0x00010000	// Process completed receives/pkts
#define SPX_CONNFILE_RENEG_SIZE 0x00020000	// Size changed in renegotiate pkt
#define	SPX_CONNFILE_ACKQ		0x00040000	// Waiting to piggyback ack queue
#define	SPX_CONNFILE_PKTQ		0x00080000	// Waiting to packetize queue

#define	SPX_CONNFILE_ASSOC		0x00100000 	// associated
#define SPX_CONNFILE_NEG		0x00200000	// CR had neg set (for delayed accept)
#define	SPX_CONNFILE_SPX2		0x00400000
#define	SPX_CONNFILE_STREAM		0x00800000
#define	SPX_CONNFILE_R_TIMER	0x01000000	// Retry timer (only after ACTIVE)
#define	SPX_CONNFILE_C_TIMER	0x01000000	// Connect timer
#define SPX_CONNFILE_W_TIMER	0x02000000	// Watchdog timer
#define SPX_CONNFILE_T_TIMER 	0x04000000  // tdi connect/disc timer specified
#define SPX_CONNFILE_RENEG_PKT	0x08000000	// Renegotiate changed size, repacketize
#define	SPX_CONNFILE_IND_IDISC	0x10000000	// Indicated abortive disc to afd
#define	SPX_CONNFILE_IND_ODISC	0x20000000	// Indicated orderly release to afd

#define	SPX_CONNFILE_STOPPING	0x40000000
#define SPX_CONNFILE_CLOSING   	0x80000000  // closing

#define	SPX_CONNFILE2_PKT_NOIND	0x00000001
#define SPX_CONNFILE2_RENEGRECD	0x00000002	// A renegotiate was received.
											// scf_RenegAckAckNum set.
#define	SPX_CONNFILE2_PKT		0x00000004
#define SPX_CONNFILE2_FINDROUTE	0x00000010	// A find route in progress on conn.
#define SPX_CONNFILE2_NOACKWAIT	0x00000020	// Dont delay acks on connection, option
#define	SPX_CONNFILE2_IMMED_ACK	0x00000040	// Send an immediate ack,no back traffic
#define	SPX_CONNFILE2_IPXHDR	0x00000080	// Pass ipxhdr in receives

//
// [SA] Saves the IDisc flag passed to AbortiveDisc; this is TRUE only if there was
// a remote disconnect on an SPX connection (in which case, we indicate TDI_DISCONNECT_RELEASE
// else we indicate TDI_DISCONNECT_ABORT)
//
#define SPX_CONNFILE2_IDISC     0x00000100

//
// Indicates an SPXI connfile waiting for a local disconnect in response
// to a TDI_DISCONNECT_RELEASE to AFD.
//
#define SPX_CONNFILE2_DISC_WAIT     0x00000200

//	FindRoute request structure
typedef struct _SPX_FIND_ROUTE_REQUEST
{
	//	!!!!This must be the first element in the structure
	IPX_FIND_ROUTE_REQUEST	fr_FindRouteReq;
	PVOID					fr_Ctx;

} SPX_FIND_ROUTE_REQUEST, *PSPX_FIND_ROUTE_REQUEST;

typedef struct _SPX_CONNFILE_LIST
{
	PSPX_CONN_FILE	pcl_Head;
	PSPX_CONN_FILE	pcl_Tail;

} SPX_CONNFILE_LIST, *PSPX_CONNFILE_LIST;

//	Exported routines

NTSTATUS
SpxConnOpen(
    IN 	PDEVICE 			pDevice,
	IN	CONNECTION_CONTEXT	pConnCtx,
    IN 	PREQUEST 			pRequest);
	
NTSTATUS
SpxConnCleanup(
    IN PDEVICE 	Device,
    IN PREQUEST Request);

NTSTATUS
SpxConnClose(
    IN PDEVICE 	Device,
    IN PREQUEST Request);

NTSTATUS
SpxConnDisAssociate(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest);

NTSTATUS
spxConnDisAssoc(
	IN	PSPX_CONN_FILE	pSpxConnFile,
	IN	CTELockHandle	LockHandleConn);

VOID
SpxConnStop(
	IN	PSPX_CONN_FILE	pSpxConnFile);

NTSTATUS
SpxConnAssociate(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest);

NTSTATUS
SpxConnConnect(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest);

NTSTATUS
SpxConnListen(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest);

NTSTATUS
SpxConnAccept(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest);

NTSTATUS
SpxConnAction(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest);

NTSTATUS
SpxConnDisconnect(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest);

NTSTATUS
SpxConnSend(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest);

NTSTATUS
SpxConnRecv(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest);

VOID
SpxConnFileRefByCtxLock(
	IN	PSPX_ADDR_FILE		pSpxAddrFile,
	IN	CONNECTION_CONTEXT	Ctx,
	OUT	PSPX_CONN_FILE	*	ppSpxConnFile,
	OUT	NTSTATUS		*	pStatus);

NTSTATUS
SpxConnFileVerify (
    IN PSPX_CONN_FILE pConnFile);

VOID
SpxConnFileDeref(
    IN PSPX_CONN_FILE pSpxConnFile);

VOID
SpxConnConnectFindRouteComplete(
	IN	PSPX_CONN_FILE			pSpxConnFile,
    IN 	PSPX_FIND_ROUTE_REQUEST	pFrReq,
    IN 	BOOLEAN 				FoundRoute,
	IN	CTELockHandle			LockHandle);

VOID
SpxConnActiveFindRouteComplete(
	IN	PSPX_CONN_FILE			pSpxConnFile,
    IN 	PSPX_FIND_ROUTE_REQUEST	pFrReq,
    IN 	BOOLEAN 				FoundRoute,
	IN	CTELockHandle			LockHandle);

BOOLEAN
SpxConnPacketize(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	BOOLEAN				fNormalState,
	IN	CTELockHandle		LockHandleConn);

#if DBG
VOID
SpxConnFileRef(
    IN PSPX_CONN_FILE pSpxConnFile);

VOID
SpxConnFileLockRef(
    IN PSPX_CONN_FILE pSpxConnFile);
#endif

VOID
SpxConnFileRefByIdLock (
	IN	USHORT				ConnId,
    OUT PSPX_CONN_FILE 	* 	ppSpxConnFile,
	OUT	PNTSTATUS  			pStatus);

BOOLEAN
SpxConnDequeuePktLock(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN 	PNDIS_PACKET		pPkt);

VOID
SpxConnSendAck(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	CTELockHandle		LockHandleConn);

VOID
SpxConnSendNack(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	USHORT				NumToSend,
	IN	CTELockHandle		LockHandleConn);

BOOLEAN
SpxConnProcessAck(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	PIPXSPX_HDR			pAckHdr,
	IN	CTELockHandle		lockHandle);

VOID
SpxConnProcessRenegReq(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	PIPXSPX_HDR			pIpxSpxHdr,
	IN  PIPX_LOCAL_TARGET   pRemoteAddr,
	IN	CTELockHandle		lockHandle);

VOID
SpxConnProcessIDisc(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	CTELockHandle		lockHandle);

VOID
SpxConnProcessOrdRel(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	CTELockHandle		lockHandle);

BOOLEAN
SpxConnDequeueRecvPktLock(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN 	PNDIS_PACKET		pPkt);

BOOLEAN
SpxConnDequeueSendPktLock(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN 	PNDIS_PACKET		pPkt);

//	LOCAL functions
VOID
spxConnHandleConnReq(
    IN  PIPXSPX_HDR         pIpxSpxHdr,
	IN  PIPX_LOCAL_TARGET   pRemoteAddr);

VOID
spxConnHandleSessPktFromClient(
    IN  PIPXSPX_HDR         pIpxSpxHdr,
	IN  PIPX_LOCAL_TARGET   pRemoteAddr,
	IN	PSPX_CONN_FILE		pSpxConnFile);

VOID
spxConnHandleSessPktFromSrv(
    IN  PIPXSPX_HDR         pIpxSpxHdr,
	IN  PIPX_LOCAL_TARGET   pRemoteAddr,
	IN	PSPX_CONN_FILE		pSpxConnFile);

ULONG
spxConnConnectTimer(
	IN PVOID 	Context,
	IN BOOLEAN	TimerShuttingDown);

ULONG
spxConnWatchdogTimer(
	IN PVOID 	Context,
	IN BOOLEAN	TimerShuttingDown);

ULONG
spxConnRetryTimer(
	IN PVOID 	Context,
	IN BOOLEAN	TimerShuttingDown);

ULONG
spxConnAckTimer(
	IN PVOID 	Context,
	IN BOOLEAN	TimerShuttingDown);

VOID
spxConnCompletePended(
	IN	PSPX_CONN_FILE	pSpxConnFile);

VOID
SpxConnQWaitAck(
	IN	PSPX_CONN_FILE		pSpxConnFile);

USHORT
spxConnGetId(
	VOID);

VOID
spxConnInsertIntoActiveList(
	IN	PSPX_ADDR		pSpxAddr,
	IN	PSPX_CONN_FILE	pSpxConnFile);

VOID
spxConnInsertIntoInactiveList(
	IN	PSPX_ADDR		pSpxAddr,
	IN	PSPX_CONN_FILE	pSpxConnFile);

NTSTATUS
spxConnRemoveFromGlobalList(
	IN	PSPX_CONN_FILE	pSpxConnFile);

VOID
spxConnInsertIntoGlobalList(
	IN	PSPX_CONN_FILE	pSpxConnFile);

NTSTATUS
spxConnRemoveFromGlobalActiveList(
	IN	PSPX_CONN_FILE	pSpxConnFile);

VOID
spxConnPushIntoPktList(
	IN	PSPX_CONN_FILE	pSpxConnFile);

VOID
spxConnPopFromPktList(
	IN	PSPX_CONN_FILE	* ppSpxConnFile);

VOID
spxConnPushIntoRecvList(
	IN	PSPX_CONN_FILE	pSpxConnFile);

VOID
spxConnPopFromRecvList(
	IN	PSPX_CONN_FILE	* ppSpxConnFile);

VOID
spxConnInsertIntoGlobalActiveList(
	IN	PSPX_CONN_FILE	pSpxConnFile);

VOID
spxConnInsertIntoListenList(
	IN	PSPX_ADDR		pSpxAddr,
	IN	PSPX_CONN_FILE	pSpxConnFile);

NTSTATUS
spxConnRemoveFromList(
	IN	PSPX_CONN_FILE *	ppConnListHead,
	IN	PSPX_CONN_FILE		pConnRemove);

NTSTATUS
spxConnRemoveFromAssocList(
	IN	PSPX_CONN_FILE *	ppConnListHead,
	IN	PSPX_CONN_FILE		pConnRemove);

VOID
spxConnInactivate(
	IN	PSPX_CONN_FILE		pSpxConnFile);

BOOLEAN
spxConnGetPktByType(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	ULONG				PktType,
	IN	BOOLEAN				fSeqList,
	IN 	PNDIS_PACKET	*	ppPkt);

BOOLEAN
spxConnGetPktBySeqNum(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	USHORT				SeqNum,
	IN 	PNDIS_PACKET	*	ppPkt);

VOID
spxConnResendPkts(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	CTELockHandle		LockHandleConn);

BOOLEAN
spxConnCheckNegSize(
	IN	PUSHORT		pNegSize);

VOID
spxConnSetNegSize(
	IN OUT	PNDIS_PACKET		pPkt,
	IN		ULONG				Size);

BOOLEAN
spxConnAcceptCr(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	PSPX_ADDR			pSpxAddr,
	IN	CTELockHandle		LockHandleDev,
	IN	CTELockHandle		LockHandleAddr,
	IN	CTELockHandle		LockHandleConn);

VOID
spxConnAbortConnect(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	NTSTATUS			Status,
	IN	CTELockHandle		LockHandleDev,
	IN	CTELockHandle		LockHandleAddr,
	IN	CTELockHandle		LockHandleConn);

VOID
spxConnCompleteConnect(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	CTELockHandle		LockHandleDev,
	IN	CTELockHandle		LockHandleAddr,
	IN	CTELockHandle		LockHandleConn);

VOID
SpxConnQueueRecv(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	PREQUEST			pRequest);

NTSTATUS
spxConnProcessRecv(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	PREQUEST			pRequest,
	IN	SPX_CALL_LEVEL		CallLevel,
	IN	CTELockHandle		LockHandleConn);

VOID
spxConnProcessIndData(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	SPX_CALL_LEVEL		CallLevel,
	IN	CTELockHandle		LockHandleConn);

NTSTATUS
spxConnOrderlyDisc(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	NTSTATUS			Status,
    IN 	PREQUEST 			pRequest,
	IN	CTELockHandle		LockHandleConn);

NTSTATUS
spxConnInformedDisc(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	NTSTATUS			Status,
    IN 	PREQUEST 			pRequest,
	IN	CTELockHandle		LockHandleConn);

VOID
spxConnAbortiveDisc(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	NTSTATUS			Status,
	IN	SPX_CALL_LEVEL		CallLevel,
	IN	CTELockHandle		LockHandleConn,
    IN BOOLEAN              Flag); // [SA] Bug #15249

VOID
spxConnAbortRecvs(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	NTSTATUS			Status,
	IN	SPX_CALL_LEVEL		CallLevel,
	IN	CTELockHandle		LockHandleConn);

VOID
spxConnAbortSends(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	NTSTATUS			Status,
	IN	SPX_CALL_LEVEL		CallLevel,
	IN	CTELockHandle		LockHandleConn);

VOID
spxConnResetSendQueue(
	IN	PSPX_CONN_FILE		pSpxConnFile);

VOID
spxConnAbortSendPkt(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	PSPX_SEND_RESD		pSendResd,
	IN	SPX_CALL_LEVEL		CallLevel,
	IN	CTELockHandle		LockHandleConn);

BOOLEAN
CheckSentPacket(
    PNDIS_PACKET npkt,
    UINT        hlen,
    UINT        len);


//
//	MACROS
//
#define SHIFT100000 16

#define	SPX_CONVERT100NSTOCENTISEC(Li)								\
		RtlExtendedMagicDivide((Li), Magic100000, SHIFT100000)

#define	UNSIGNED_BETWEEN_WITH_WRAP(Low, High, Target)				\
		((Low <= High) ? ((Target >= Low) && (Target <= High))	:	\
						 ((Target >= Low) || (Target <= High)))

//	This is with the assumption that the window size will never be greater
//	than the difference of 0x8000 and 0x1000. If High is < 1000 and Low
//	is > 8000 then we can assume a wrap happened. Otherwise, we assume no
//	wrap and do a straight compare.
#define	MAX_WINDOW_SIZE			0x6000
#define	DEFAULT_WINDOW_SIZE		8

#define UNSIGNED_GREATER_WITH_WRAP(High, Low)						\
		(((High < 0x1000) && (Low > 0x8000)) ? TRUE : (High > Low))

#define	SPX_SET_ACKNUM(pSpxConnFile, RecdAckNum, RecdAllocNum)					\
		{																		\
			DBGPRINT(SEND, DBG,													\
					("SPX_SET_ACKNUM: %lx.%lx = %lx.%lx (%s.%d)\n",				\
	                    (RecdAckNum), (RecdAllocNum),							\
                        ((pSpxConnFile)->scf_RecdAckNum),						\
                        ((pSpxConnFile)->scf_RecdAllocNum),						\
						__FILE__, __LINE__));									\
																				\
			if (UNSIGNED_GREATER_WITH_WRAP((RecdAckNum),						\
											((pSpxConnFile)->scf_RecdAckNum)))	\
			{																	\
                (pSpxConnFile)->scf_RecdAckNum = (RecdAckNum);					\
			}																	\
																				\
			if (UNSIGNED_GREATER_WITH_WRAP((RecdAllocNum),						\
											((pSpxConnFile)->scf_RecdAllocNum)))\
			{																	\
                (pSpxConnFile)->scf_RecdAllocNum = (RecdAllocNum);				\
			}																	\
		}

#define	BEGIN_PROCESS_PACKET(pSpxConnFile, seqNum)								\
		{																		\
			SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_PKT);					\
		}																		

#define	END_PROCESS_PACKET(pSpxConnFile, fBuffered, fSuccess)					\
		{																		\
			SPX_CONN_RESETFLAG2(pSpxConnFile,									\
								(SPX_CONNFILE2_PKT |SPX_CONNFILE2_RENEGRECD));	\
			if (fSuccess)														\
			{																	\
				SPX_CONN_RESETFLAG2(pSpxConnFile, SPX_CONNFILE2_PKT_NOIND);		\
				SPX_SET_RECVNUM(pSpxConnFile, fBuffered);						\
			}																	\
		}

#define	INCREMENT_WINDOW(pSpxConnFile)											\
		((pSpxConnFile)->scf_SentAllocNum++)		

#define	ADD_TO_WINDOW(pSpxConnFile, numPkts)									\
		((pSpxConnFile)->scf_SentAllocNum += (numPkts))		

#if DBG_WDW_CLOSE
#define	SPX_SET_RECVNUM(pSpxConnFile, fBuffered)								\
		{																		\
			(pSpxConnFile)->scf_RecvSeqNum++;									\
			if (!fBuffered)														\
				(pSpxConnFile)->scf_SentAllocNum++;								\
																				\
			if (fBuffered &&													\
				(UNSIGNED_GREATER_WITH_WRAP(									\
	                (pSpxConnFile)->scf_RecvSeqNum,								\
                    (pSpxConnFile)->scf_SentAllocNum)))							\
			{																	\
				KeQuerySystemTime(												\
					(PLARGE_INTEGER)&pSpxConnFile->scf_WdwCloseTime);			\
			}																	\
		}
#else
#define	SPX_SET_RECVNUM(pSpxConnFile, fBuffered)								\
		{																		\
			(pSpxConnFile)->scf_RecvSeqNum++;									\
			if (!fBuffered)														\
				(pSpxConnFile)->scf_SentAllocNum++;								\
		}
#endif


#define	SPX_CONN_SETNEXT_CUR_RECV(pSpxConnFile, pRequest)						\
		{																		\
			RemoveEntryList(REQUEST_LINKAGE((pRequest)));						\
			pSpxConnFile->scf_CurRecvReq		= NULL;							\
			pSpxConnFile->scf_CurRecvOffset		= 0;							\
			pSpxConnFile->scf_CurRecvSize		= 0;							\
			if (!IsListEmpty(&(pSpxConnFile)->scf_RecvLinkage))					\
			{																	\
				PTDI_REQUEST_KERNEL_RECEIVE	 	_p;								\
				DBGPRINT(RECEIVE, DBG,											\
						("spxConnProcessRecv: CURRECV %lx\n", pRequest));		\
																				\
				(pSpxConnFile)->scf_CurRecvReq =								\
					LIST_ENTRY_TO_REQUEST(										\
								(pSpxConnFile)->scf_RecvLinkage.Flink);			\
																				\
				_p 	= (PTDI_REQUEST_KERNEL_RECEIVE)								\
						REQUEST_PARAMETERS((pSpxConnFile)->scf_CurRecvReq);		\
																				\
				(pSpxConnFile)->scf_CurRecvOffset	= 0;						\
				(pSpxConnFile)->scf_CurRecvSize	= 	(_p)->ReceiveLength;		\
			}																	\
			if ((SPX_RECV_STATE(pSpxConnFile) == SPX_RECV_IDLE)	||				\
				(SPX_RECV_STATE(pSpxConnFile) == SPX_RECV_POSTED))				\
			{																	\
				SPX_RECV_SETSTATE(												\
					pSpxConnFile,												\
					(pSpxConnFile->scf_CurRecvReq == NULL) ?					\
						SPX_RECV_IDLE : SPX_RECV_POSTED);						\
			}																	\
		}

#define	SPX_INSERT_ADDR_ACTIVE(pSpxAddr, pSpxConnFile)							\
		{																		\
			(pSpxConnFile)->scf_Next 		= (pSpxAddr)->sa_ActiveConnList;	\
			(pSpxAddr)->sa_ActiveConnList	= pSpxConnFile;						\
		}																		

#define	SPX_INSERT_ADDR_INACTIVE(pSpxAddr, pSpxConnFile)						\
		{																		\
			(pSpxConnFile)->scf_Next 		= (pSpxAddr)->sa_InactiveConnList;	\
			(pSpxAddr)->sa_InactiveConnList	= pSpxConnFile;						\
		}
																				
#define	SPX_INSERT_ADDR_LISTEN(pSpxAddr, pSpxConnFile)							\
		{																		\
			(pSpxConnFile)->scf_Next 		= (pSpxAddr)->sa_ListenConnList;	\
			(pSpxAddr)->sa_ListenConnList	= pSpxConnFile;						\
		}


//
//	STATE MANIPULATION
//

#if 0
//
// Disabled for now
//
#define SPX_STORE_LAST_STATE(pSpxConnFile) \
        (pSpxConnFile)->scf_StateBuffer[(pSpxConnFile)->scf_NextStatePtr++] =   \
            (pSpxConnFile)->scf_Flags;                                          \
         (pSpxConnFile)->scf_NextStatePtr %= CFMAX_STATES;
#else

#define SPX_STORE_LAST_STATE(pSpxConnFile)

#endif

#define	SPX_MAIN_STATE(pSpxConnFile)                                         	\
		((pSpxConnFile)->scf_Flags & SPX_CONNFILE_MAINMASK)

// #define	SPX_CONN_IDLE(pSpxConnFile)												\
// 	((BOOLEAN)(SPX_MAIN_STATE(pSpxConnFile) == 0))

#define	SPX_CONN_IDLE(pSpxConnFile)												\
	((BOOLEAN)((SPX_MAIN_STATE(pSpxConnFile) == 0) || \
               ((SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN) && \
                (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_INACTIVATED))))

#define	SPX_CONN_ACTIVE(pSpxConnFile)											\
		((BOOLEAN)(SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_ACTIVE))
		
#define	SPX_CONN_CONNECTING(pSpxConnFile)										\
		((BOOLEAN)(SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_CONNECTING))
		
#define	SPX_CONN_LISTENING(pSpxConnFile)										\
		((BOOLEAN)(SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_LISTENING))
		
#define	SPX_CONN_DISC(pSpxConnFile)												\
		((BOOLEAN)(SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN))

#if DBG

#define	SPX_MAIN_SETSTATE(pSpxConnFile, newState)                             	\
		{																		\
            SPX_STORE_LAST_STATE(pSpxConnFile)                                                              \
			(pSpxConnFile)->scf_Flags = 										\
			(((pSpxConnFile)->scf_Flags & ~SPX_CONNFILE_MAINMASK) | (newState));\
		}

#else

#define	SPX_MAIN_SETSTATE(pSpxConnFile, newState)                             	\
		{																		\
			(pSpxConnFile)->scf_Flags = 										\
			(((pSpxConnFile)->scf_Flags & ~SPX_CONNFILE_MAINMASK) | (newState));\
		}

#endif

#define	SPX_CONN_FLAG(pSpxConnFile, Flag)										\
		((BOOLEAN)(((pSpxConnFile)->scf_Flags & (Flag)) != 0))

#define	SPX_CONN_FLAG2(pSpxConnFile, Flag)										\
		((BOOLEAN)(((pSpxConnFile)->scf_Flags2 & (Flag)) != 0))

#if DBG

#define	SPX_CONN_SETFLAG(pSpxConnFile, Flag)									\
        SPX_STORE_LAST_STATE(pSpxConnFile)                                                              \
		((pSpxConnFile)->scf_Flags |= (Flag))
#else

#define	SPX_CONN_SETFLAG(pSpxConnFile, Flag)									\
		((pSpxConnFile)->scf_Flags |= (Flag))

#endif

#define	SPX_CONN_SETFLAG2(pSpxConnFile, Flag)									\
		((pSpxConnFile)->scf_Flags2 |= (Flag))

#define	SPX_CONN_RESETFLAG(pSpxConnFile, Flag)									\
		((pSpxConnFile)->scf_Flags &= ~(Flag))

#define	SPX_CONN_RESETFLAG2(pSpxConnFile, Flag)									\
		((pSpxConnFile)->scf_Flags2 &= ~(Flag))

#define SPX2_CONN(pSpxConnFile)													\
		(SPX_CONN_FLAG((pSpxConnFile), SPX_CONNFILE_SPX2))

#define	SPX_CONN_STREAM(pSpxConnFile)											\
		(SPX_CONN_FLAG((pSpxConnFile), SPX_CONNFILE_STREAM))

#define	SPX_CONN_MSG(pSpxConnFile)												\
		(!SPX_CONN_FLAG((pSpxConnFile), SPX_CONNFILE_STREAM))

#define	SPX_LISTEN_STATE(pSpxConnFile)                                         	\
		((pSpxConnFile)->scf_Flags & SPX_LISTEN_MASK)

#define	SPX_CONNECT_STATE(pSpxConnFile)                                         \
		((pSpxConnFile)->scf_Flags & SPX_CONNECT_MASK)

#define	SPX_SEND_STATE(pSpxConnFile)                                         	\
		((pSpxConnFile)->scf_Flags & SPX_SEND_MASK)

#define	SPX_RECV_STATE(pSpxConnFile)                                         	\
		((pSpxConnFile)->scf_Flags & SPX_RECV_MASK)

#define	SPX_DISC_STATE(pSpxConnFile)                                        	\
		((pSpxConnFile)->scf_Flags & SPX_DISC_MASK)

#if DBG

#define	SPX_LISTEN_SETSTATE(pSpxConnFile, newState)                             \
		{																		\
			DBGPRINT(STATE, INFO,												\
					("LISTEN: %x -> %x\n",										\
					SPX_LISTEN_STATE(pSpxConnFile), (newState)));				\
			DBGPRINT(STATE, INFO,												\
					("FILE: %s - %d\n", __FILE__, __LINE__));					\
            SPX_STORE_LAST_STATE(pSpxConnFile)                                                              \
			pSpxConnFile->scf_Flags = 											\
				(((pSpxConnFile)->scf_Flags & ~SPX_LISTEN_MASK) | (newState));	\
		}

#define	SPX_CONNECT_SETSTATE(pSpxConnFile, newState)                            \
		{																		\
			DBGPRINT(STATE, INFO,												\
					("CONNECT: %x -> %x\n",										\
					SPX_CONNECT_STATE(pSpxConnFile), (newState)));				\
			DBGPRINT(STATE, INFO,												\
					("FILE: %s - %d\n", __FILE__, __LINE__));					\
            SPX_STORE_LAST_STATE(pSpxConnFile)                                                              \
			(pSpxConnFile)->scf_Flags = 										\
				(((pSpxConnFile)->scf_Flags & ~SPX_CONNECT_MASK) | (newState));	\
		}

#define	SPX_SEND_SETSTATE(pSpxConnFile, newState)                               \
		{																		\
			DBGPRINT(STATE, INFO,												\
					("SEND: %x -> %x\n",										\
					SPX_SEND_STATE(pSpxConnFile), (newState)));					\
			DBGPRINT(STATE, INFO,												\
					("FILE: %s - %d\n", __FILE__, __LINE__));					\
            SPX_STORE_LAST_STATE(pSpxConnFile)                                                              \
			(pSpxConnFile)->scf_Flags = 										\
				(((pSpxConnFile)->scf_Flags & ~SPX_SEND_MASK) | (newState));	\
		}

#define	SPX_RECV_SETSTATE(pSpxConnFile, newState)                               \
		{																		\
			DBGPRINT(STATE, INFO,												\
					("RECV: %x -> %x\n",										\
					SPX_RECV_STATE(pSpxConnFile), (newState)));					\
			DBGPRINT(STATE, INFO,												\
					("FILE: %s - %d\n", __FILE__, __LINE__));					\
            SPX_STORE_LAST_STATE(pSpxConnFile)                                                              \
			(pSpxConnFile)->scf_Flags = 											\
				(((pSpxConnFile)->scf_Flags & ~SPX_RECV_MASK) | (newState));		\
		}

#define	SPX_DISC_SETSTATE(pSpxConnFile, newState)                               \
		{																		\
			DBGPRINT(STATE, INFO,												\
					("DISC: %x -> %x\n",										\
					SPX_DISC_STATE(pSpxConnFile), (newState)));					\
			DBGPRINT(STATE, INFO,												\
					("FILE: %s - %d\n", __FILE__, __LINE__));					\
            SPX_STORE_LAST_STATE(pSpxConnFile)                                                              \
			(pSpxConnFile)->scf_Flags = 											\
				(((pSpxConnFile)->scf_Flags & ~SPX_DISC_MASK) | (newState));		\
		}

#else

#define	SPX_LISTEN_SETSTATE(pSpxConnFile, newState)                             \
		{																		\
			DBGPRINT(STATE, INFO,												\
					("LISTEN: %x -> %x\n",										\
					SPX_LISTEN_STATE(pSpxConnFile), (newState)));				\
			DBGPRINT(STATE, INFO,												\
					("FILE: %s - %d\n", __FILE__, __LINE__));					\
			pSpxConnFile->scf_Flags = 											\
				(((pSpxConnFile)->scf_Flags & ~SPX_LISTEN_MASK) | (newState));	\
		}

#define	SPX_CONNECT_SETSTATE(pSpxConnFile, newState)                            \
		{																		\
			DBGPRINT(STATE, INFO,												\
					("CONNECT: %x -> %x\n",										\
					SPX_CONNECT_STATE(pSpxConnFile), (newState)));				\
			DBGPRINT(STATE, INFO,												\
					("FILE: %s - %d\n", __FILE__, __LINE__));					\
			(pSpxConnFile)->scf_Flags = 										\
				(((pSpxConnFile)->scf_Flags & ~SPX_CONNECT_MASK) | (newState));	\
		}

#define	SPX_SEND_SETSTATE(pSpxConnFile, newState)                               \
		{																		\
			DBGPRINT(STATE, INFO,												\
					("SEND: %x -> %x\n",										\
					SPX_SEND_STATE(pSpxConnFile), (newState)));					\
			DBGPRINT(STATE, INFO,												\
					("FILE: %s - %d\n", __FILE__, __LINE__));					\
			(pSpxConnFile)->scf_Flags = 										\
				(((pSpxConnFile)->scf_Flags & ~SPX_SEND_MASK) | (newState));	\
		}

#define	SPX_RECV_SETSTATE(pSpxConnFile, newState)                               \
		{																		\
			DBGPRINT(STATE, INFO,												\
					("RECV: %x -> %x\n",										\
					SPX_RECV_STATE(pSpxConnFile), (newState)));					\
			DBGPRINT(STATE, INFO,												\
					("FILE: %s - %d\n", __FILE__, __LINE__));					\
			(pSpxConnFile)->scf_Flags = 											\
				(((pSpxConnFile)->scf_Flags & ~SPX_RECV_MASK) | (newState));		\
		}

#define	SPX_DISC_SETSTATE(pSpxConnFile, newState)                               \
		{																		\
			DBGPRINT(STATE, INFO,												\
					("DISC: %x -> %x\n",										\
					SPX_DISC_STATE(pSpxConnFile), (newState)));					\
			DBGPRINT(STATE, INFO,												\
					("FILE: %s - %d\n", __FILE__, __LINE__));					\
			(pSpxConnFile)->scf_Flags = 											\
				(((pSpxConnFile)->scf_Flags & ~SPX_DISC_MASK) | (newState));		\
		}
#endif  //DBG
#define	SpxConnQueueSendPktTail(pSpxConnFile, pPkt)						\
		{																\
			PSPX_SEND_RESD	_pSendResd;									\
			_pSendResd	= (PSPX_SEND_RESD)((pPkt)->ProtocolReserved);	\
			_pSendResd->sr_Next = NULL;									\
			if ((pSpxConnFile)->scf_SendListTail != NULL)				\
			{															\
				(pSpxConnFile)->scf_SendListTail->sr_Next = _pSendResd;	\
				(pSpxConnFile)->scf_SendListTail			= _pSendResd;\
			}															\
			else														\
			{															\
				(pSpxConnFile)->scf_SendListTail	=					\
				(pSpxConnFile)->scf_SendListHead	= _pSendResd;		\
			}															\
		}																

#define	SpxConnQueueSendPktHead(pSpxConnFile, pPkt)						\
		{																\
			PSPX_SEND_RESD	_pSendResd;									\
			_pSendResd	= (PSPX_SEND_RESD)((pPkt)->ProtocolReserved);	\
			_pSendResd->sr_Next = NULL;									\
			if ((pSpxConnFile)->scf_SendListTail != NULL)				\
			{															\
				_pSendResd->sr_Next	= (pSpxConnFile)->scf_SendListHead;	\
			}															\
			else														\
			{															\
				(pSpxConnFile)->scf_SendListTail	= _pSendResd;		\
			}															\
			(pSpxConnFile)->scf_SendListHead	= _pSendResd;			\
		}																

#define	SpxConnQueueSendSeqPktTail(pSpxConnFile, pPkt)					\
		{																\
			PSPX_SEND_RESD	_pSendResd;									\
			_pSendResd	= (PSPX_SEND_RESD)((pPkt)->ProtocolReserved);	\
			_pSendResd->sr_Next = NULL;									\
			if ((pSpxConnFile)->scf_SendSeqListTail != NULL)			\
			{															\
				(pSpxConnFile)->scf_SendSeqListTail->sr_Next = _pSendResd;\
				(pSpxConnFile)->scf_SendSeqListTail			= _pSendResd;\
			}															\
			else														\
			{															\
				(pSpxConnFile)->scf_SendSeqListTail	=					\
				(pSpxConnFile)->scf_SendSeqListHead	= _pSendResd;		\
			}															\
		}																

#define	SpxConnQueueSendSeqPktHead(pSpxConnFile, pPkt)					\
		{																\
			PSPX_SEND_RESD	_pSendResd;									\
			_pSendResd	= (PSPX_SEND_RESD)((pPkt)->ProtocolReserved);	\
			_pSendResd->sr_Next = NULL;									\
			if ((pSpxConnFile)->scf_SendSeqListTail != NULL)			\
			{															\
				_pSendResd->sr_Next	= (pSpxConnFile)->scf_SendSeqListHead;\
			}															\
			else														\
			{															\
				(pSpxConnFile)->scf_SendSeqListTail	= _pSendResd;		\
			}															\
			(pSpxConnFile)->scf_SendSeqListHead	= _pSendResd;			\
		}																

#define	SpxConnQueueRecvPktTail(pSpxConnFile, pPkt)						\
		{																\
			PSPX_RECV_RESD	_pRecvResd;									\
			_pRecvResd	= (PSPX_RECV_RESD)((pPkt)->ProtocolReserved);	\
			_pRecvResd->rr_Next = NULL;									\
			if ((pSpxConnFile)->scf_RecvListTail != NULL)				\
			{															\
				(pSpxConnFile)->scf_RecvListTail->rr_Next = _pRecvResd;	\
				(pSpxConnFile)->scf_RecvListTail			= _pRecvResd;\
			}															\
			else														\
			{															\
				(pSpxConnFile)->scf_RecvListTail	=					\
				(pSpxConnFile)->scf_RecvListHead	= _pRecvResd;		\
			}															\
		}																

#define	SpxConnQueueRecvPktHead(pSpxConnFile, pPkt)						\
		{																\
			PSPX_RECV_RESD	_pRecvResd;									\
			_pRecvResd	= (PSPX_RECV_RESD)((pPkt)->ProtocolReserved);	\
			_pRecvResd->rr_Next = NULL;									\
			if ((pSpxConnFile)->scf_RecvListTail != NULL)				\
			{															\
				_pRecvResd->rr_Next	= (pSpxConnFile)->scf_RecvListHead;	\
			}															\
			else														\
			{															\
				(pSpxConnFile)->scf_RecvListTail	= _pRecvResd;		\
			}															\
			(pSpxConnFile)->scf_RecvListHead	= _pRecvResd;			\
		}																

#if DBG
#define SpxConnFileReference(_ConnFile, _Type)			\
		{												\
			(VOID)SPX_ADD_ULONG ( 				\
				&(_ConnFile)->scf_RefTypes[_Type], 		\
				1, 										\
				&SpxGlobalInterlock); 					\
			SpxConnFileRef (_ConnFile);					\
		}

#define SpxConnFileLockReference(_ConnFile, _Type)			\
		{													\
			(VOID)SPX_ADD_ULONG ( 					\
				&(_ConnFile)->scf_RefTypes[_Type], 			\
				1, 											\
				&SpxGlobalInterlock); 						\
			SpxConnFileLockRef (_ConnFile);					\
		}

#define SpxConnFileDereference(_ConnFile, _Type) 			\
		{													\
			(VOID)SPX_ADD_ULONG ( 					\
				&(_ConnFile)->scf_RefTypes[_Type], 			\
				(ULONG)-1, 									\
				&SpxGlobalInterlock); 						\
			SpxConnFileDeref (_ConnFile);					\
		}

#define	SpxConnFileReferenceByCtx(_pAddrFile, _Ctx, _ppConnFile, _pStatus)			\
		{																			\
			CTELockHandle	_lockHandle;											\
			CTEGetLock((_pAddrFile)->saf_AddrLock, &(_lockHandle));					\
			SpxConnFileRefByCtxLock((_pAddrFile), (_Ctx), (_ppConnFile),(_pStatus));\
			CTEFreeLock((_pAddrFile)->saf_AddrLock, (_lockHandle)); 				\
		}

#define	SpxConnFileReferenceByCtxLock(_pAddrFile, _Ctx, _ppConnFile, _pStatus)		\
		SpxConnFileRefByCtxLock((_pAddrFile), (_Ctx), (_ppConnFile),(_pStatus));

#define	SpxConnFileReferenceById(_ConnId, _ppConnFile, _pStatus)		\
		{																\
			CTELockHandle	_l;											\
			CTEGetLock(&SpxDevice->dev_Lock, &(_l));					\
			SpxConnFileRefByIdLock(_ConnId, _ppConnFile, _pStatus);		\
			CTEFreeLock(&SpxDevice->dev_Lock, _l);						\
		}

#define SpxConnFileTransferReference(_ConnFile, _OldType, _NewType)			\
		{																	\
			(VOID)SPX_ADD_ULONG ( 									\
				&(_ConnFile)->scf_RefTypes[_NewType], 						\
				1, 															\
				&SpxGlobalInterlock); 										\
			(VOID)SPX_ADD_ULONG ( 									\
				&(_ConnFile)->scf_RefTypes[_OldType], 						\
				(ULONG)-1, 													\
				&SpxGlobalInterlock);										\
		}

#else  // DBG

#define SpxConnFileReference(_ConnFile, _Type) 	\
			SPX_ADD_ULONG( 				\
				&(_ConnFile)->scf_RefCount, 	\
				1, 								\
				&(_ConnFile)->scf_Lock)

#define SpxConnFileLockReference(_ConnFile, _Type) \
			SPX_ADD_ULONG( 				\
				&(_ConnFile)->scf_RefCount, 	\
				1, 								\
				&(_ConnFile)->scf_Lock);

#define SpxConnFileDereference(_ConnFile, _Type) 			\
		{													\
			SpxConnFileDeref(_ConnFile);					\
		}

#define	SpxConnFileReferenceByCtx(_pAddrFile, _Ctx, _ppConnFile, _pStatus)			\
		{																			\
			CTELockHandle	_lockHandle;											\
			CTEGetLock((_pAddrFile)->saf_AddrLock, &(_lockHandle));				\
			SpxConnFileRefByCtxLock((_pAddrFile), (_Ctx), (_ppConnFile),(_pStatus));\
			CTEFreeLock((_pAddrFile)->saf_AddrLock, (_lockHandle)); 				\
		}

#define	SpxConnFileReferenceByCtxLock(_pAddrFile, _Ctx, _ppConnFile, _pStatus)		\
		SpxConnFileRefByCtxLock((_pAddrFile), (_Ctx), (_ppConnFile),(_pStatus));

#define	SpxConnFileReferenceById(_ConnId, _ppConnFile, _pStatus)					\
		{																			\
			CTELockHandle	_lockHandle;											\
			CTEGetLock(&SpxDevice->dev_Lock, &(_lockHandle));						\
			SpxConnFileRefByIdLock(_ConnId, _ppConnFile, _pStatus);					\
			CTEFreeLock(&SpxDevice->dev_Lock, (_lockHandle));						\
		}

#define SpxConnFileTransferReference(_ConnFile, _OldType, _NewType)

#endif // DBG


//	Set the packet size. If we are spx1 or spx2 and !neg, check if we are different
//	nets, set to min then, else use the size indicated by IPX. If we are spx2, just
//	set it to our local max.
//
//	Also always even out packet size and round down. This solves an issue with
//	data size needing to be even for some novell 802.2 clients.
//
//	Fix after beta2 for tokring using receive size. Only if spx2 and neg.
#if     defined(_PNP_POWER)
#define	SPX_MAX_PKT_SIZE(pSpxConnFile, fSpx2Neg, fSpx2, pRemNet)		    \
		{																	\
           if (!fSpx2 && PARAM(CONFIG_BACKCOMP_SPX))  {                     \
                (pSpxConnFile)->scf_MaxPktSize = SPX_MAX_PACKET;			\
           }                                                                \
           else {                                                           \
			IPX_LINE_INFO	_i;												\
																			\
			(VOID)(*IpxQuery)(												\
				IPX_QUERY_LINE_INFO,										\
				&(pSpxConnFile)->scf_LocalTarget.NicHandle, 				\
				&(_i),														\
				sizeof(IPX_LINE_INFO),										\
				NULL);														\
																			\
			(pSpxConnFile)->scf_MaxPktSize = (USHORT) (_i).MaximumPacketSize;		\
			if (!fSpx2Neg)													\
			{																\
				(pSpxConnFile)->scf_MaxPktSize = (USHORT) (_i).MaximumSendSize;       \
			}																\
																			\
			if ((pSpxConnFile)->scf_MaxPktSize < SPX_MAX_PACKET)			\
			{																\
                (pSpxConnFile)->scf_MaxPktSize = SPX_MAX_PACKET;			\
			}																\
                															\
			DBGPRINT(CONNECT, DBG,											\
					("SPX_MAX_PKT_SIZE: Nets %lx.%lx Max Pkt %d\n",			\
						(*(UNALIGNED ULONG *)(pRemNet)),					\
						*(UNALIGNED ULONG *)SpxDevice->dev_Network,			\
						(pSpxConnFile)->scf_MaxPktSize));					\
			DBGPRINT(CONNECT, DBG,											\
					("%s : %d.%d\n", __FILE__, __LINE__, fSpx2Neg));		\
																			\
			if ((!fSpx2Neg) &&												\
				((*(UNALIGNED ULONG *)(pRemNet)) !=	0)	&&					\
				((*(UNALIGNED ULONG *)SpxDevice->dev_Network) != 0) &&		\
				((*(UNALIGNED ULONG *)(pRemNet)) !=							\
					*(UNALIGNED ULONG *)SpxDevice->dev_Network))			\
			{																\
				if (PARAM(CONFIG_ROUTER_MTU) != 0)							\
				{															\
					DBGPRINT(CONNECT, ERR,									\
							("SPX_MAX_PKT_SIZE: PARAM %lx Max Pkt %lx\n",	\
	                            PARAM(CONFIG_ROUTER_MTU),					\
								(pSpxConnFile)->scf_MaxPktSize));			\
																			\
					(pSpxConnFile)->scf_MaxPktSize =						\
						(USHORT)(MIN(PARAM(CONFIG_ROUTER_MTU),				\
									(ULONG)((pSpxConnFile)->scf_MaxPktSize)));\
				}															\
				else														\
				{															\
					(pSpxConnFile)->scf_MaxPktSize = SPX_MAX_PACKET;		\
				}															\
																			\
				DBGPRINT(CONNECT, DBG,										\
						("SPX_MAX_PKT_SIZE: Nets %lx.%lx Max Pkt %d\n",		\
							(*(UNALIGNED ULONG *)(pRemNet)),				\
							*(UNALIGNED ULONG *)SpxDevice->dev_Network,		\
							(pSpxConnFile)->scf_MaxPktSize));				\
				DBGPRINT(CONNECT, DBG,										\
						("SPX_MAX_PKT_SIZE: LineInfo Pkt %d\n",				\
	                        (_i).MaximumSendSize));							\
			}	 															\
           }                                                                \
			(pSpxConnFile)->scf_MaxPktSize &= ~((USHORT)1);					\
			DBGPRINT(CONNECT, DBG,											\
					("SPX_MAX_PKT_SIZE: %lx.%d\n",							\
	                    (pSpxConnFile)->scf_MaxPktSize,						\
                        (pSpxConnFile)->scf_MaxPktSize));					\
		}
#else
#define	SPX_MAX_PKT_SIZE(pSpxConnFile, fSpx2Neg, fSpx2, pRemNet)		    \
		{																	\
           if (!fSpx2 && PARAM(CONFIG_BACKCOMP_SPX))  {                     \
                (pSpxConnFile)->scf_MaxPktSize = SPX_MAX_PACKET;			\
           }                                                                \
           else {                                                           \
			IPX_LINE_INFO	_i;												\
																			\
			(VOID)(*IpxQuery)(												\
				IPX_QUERY_LINE_INFO,										\
				(pSpxConnFile)->scf_LocalTarget.NicId,						\
				&(_i),														\
				sizeof(IPX_LINE_INFO),										\
				NULL);														\
																			\
			(pSpxConnFile)->scf_MaxPktSize = (_i).MaximumPacketSize;		\
			if (!fSpx2Neg)													\
			{																\
				(pSpxConnFile)->scf_MaxPktSize = (_i).MaximumSendSize;       \
			}																\
																			\
			if ((pSpxConnFile)->scf_MaxPktSize < SPX_MAX_PACKET)			\
			{																\
                (pSpxConnFile)->scf_MaxPktSize = SPX_MAX_PACKET;			\
			}																\
                															\
			DBGPRINT(CONNECT, DBG,											\
					("SPX_MAX_PKT_SIZE: Nets %lx.%lx Max Pkt %d\n",			\
						(*(UNALIGNED ULONG *)(pRemNet)),					\
						*(UNALIGNED ULONG *)SpxDevice->dev_Network,			\
						(pSpxConnFile)->scf_MaxPktSize));					\
			DBGPRINT(CONNECT, DBG,											\
					("%s : %d.%d\n", __FILE__, __LINE__, fSpx2Neg));		\
																			\
			if ((!fSpx2Neg) &&												\
				((*(UNALIGNED ULONG *)(pRemNet)) !=	0)	&&					\
				((*(UNALIGNED ULONG *)SpxDevice->dev_Network) != 0) &&		\
				((*(UNALIGNED ULONG *)(pRemNet)) !=							\
					*(UNALIGNED ULONG *)SpxDevice->dev_Network))			\
			{																\
				if (PARAM(CONFIG_ROUTER_MTU) != 0)							\
				{															\
					DBGPRINT(CONNECT, ERR,									\
							("SPX_MAX_PKT_SIZE: PARAM %lx Max Pkt %lx\n",	\
	                            PARAM(CONFIG_ROUTER_MTU),					\
								(pSpxConnFile)->scf_MaxPktSize));			\
																			\
					(pSpxConnFile)->scf_MaxPktSize =						\
						(USHORT)(MIN(PARAM(CONFIG_ROUTER_MTU),				\
									(ULONG)((pSpxConnFile)->scf_MaxPktSize)));\
				}															\
				else														\
				{															\
					(pSpxConnFile)->scf_MaxPktSize = SPX_MAX_PACKET;		\
				}															\
																			\
				DBGPRINT(CONNECT, DBG,										\
						("SPX_MAX_PKT_SIZE: Nets %lx.%lx Max Pkt %d\n",		\
							(*(UNALIGNED ULONG *)(pRemNet)),				\
							*(UNALIGNED ULONG *)SpxDevice->dev_Network,		\
							(pSpxConnFile)->scf_MaxPktSize));				\
				DBGPRINT(CONNECT, DBG,										\
						("SPX_MAX_PKT_SIZE: LineInfo Pkt %d\n",				\
	                        (_i).MaximumSendSize));							\
			}	 															\
           }                                                                \
			(pSpxConnFile)->scf_MaxPktSize &= ~((USHORT)1);					\
			DBGPRINT(CONNECT, DBG,											\
					("SPX_MAX_PKT_SIZE: %lx.%d\n",							\
	                    (pSpxConnFile)->scf_MaxPktSize,						\
                        (pSpxConnFile)->scf_MaxPktSize));					\
		}
#endif  _PNP_POWER


#if DBG
#define	SPX_SENDPACKET(pSpxConnFile, pNdisPkt, pSendResd)					\
		{																	\
			NDIS_STATUS	_n;													\
																			\
			++SpxDevice->dev_Stat.PacketsSent;								\
																			\
			_n = (*IpxSendPacket)(											\
			        &(pSpxConnFile)->scf_LocalTarget,               		\
					(pNdisPkt),												\
					(pSendResd)->sr_Len,									\
					(pSendResd)->sr_HdrLen);								\
																			\
			if (_n != NDIS_STATUS_PENDING)									\
			{																\
                if (_n != NDIS_STATUS_SUCCESS)                              \
                {                                                           \
				   DBGPRINT(SEND, ERR,								   		\
						("SPX_SENDPACKET: Failed with %lx in %s.%lx\n",		\
							_n, __FILE__, __LINE__));						\
                }                                                           \
																			\
				SpxSendComplete(											\
					(pNdisPkt),												\
					_n);									                \
			}																\
		}

#define	SPX_SENDACK(pSpxConnFile, pNdisPkt, pSendResd)						\
		{																	\
			NDIS_STATUS	_n;													\
																			\
			++SpxDevice->dev_Stat.PacketsSent;								\
                                                                            \
			_n = (*IpxSendPacket)(											\
			        &(pSpxConnFile)->scf_AckLocalTarget,               		\
					(pNdisPkt),												\
					(pSendResd)->sr_Len,									\
					(pSendResd)->sr_HdrLen);								\
																			\
			if (_n != NDIS_STATUS_PENDING)									\
			{																\
                if (_n != NDIS_STATUS_SUCCESS)                              \
                {                                                           \
				DBGPRINT(SEND, ERR,								   			\
						("SPX_SENDPACKET: Failed with %lx in %s.%lx\n",		\
							_n, __FILE__, __LINE__));						\
                }                                                           \
																			\
				SpxSendComplete(											\
					(pNdisPkt),												\
					_n);									\
			}																\
		}

#else  // DBG
#define	SPX_SENDPACKET(pSpxConnFile, pNdisPkt, pSendResd)					\
		{																	\
			NDIS_STATUS	_n;													\
																			\
			++SpxDevice->dev_Stat.PacketsSent;								\
																			\
			_n = (*IpxSendPacket)(											\
			        &(pSpxConnFile)->scf_LocalTarget,               		\
					(pNdisPkt),												\
					(pSendResd)->sr_Len,									\
					(pSendResd)->sr_HdrLen);								\
																			\
			if (_n != NDIS_STATUS_PENDING)									\
			{																\
				SpxSendComplete(											\
					(pNdisPkt),												\
					_n);									                \
			}																\
		}
#define	SPX_SENDACK(pSpxConnFile, pNdisPkt, pSendResd)						\
		{																	\
			NDIS_STATUS	_n;													\
																			\
			++SpxDevice->dev_Stat.PacketsSent;								\
																			\
			_n = (*IpxSendPacket)(											\
			        &(pSpxConnFile)->scf_AckLocalTarget,               		\
					(pNdisPkt),												\
					(pSendResd)->sr_Len,									\
					(pSendResd)->sr_HdrLen);								\
																			\
			if (_n != NDIS_STATUS_PENDING)									\
			{																\
				SpxSendComplete(											\
					(pNdisPkt),												\
					_n);									                \
			}																\
		}

#endif // DBG

#define	SPX_QUEUE_FOR_RECV_COMPLETION(pSpxConnFile)							\
		{																	\
			if (!SPX_CONN_FLAG(												\
					(pSpxConnFile),											\
					SPX_CONNFILE_RECVQ))									\
			{																\
				SPX_CONN_SETFLAG((pSpxConnFile), SPX_CONNFILE_RECVQ);		\
				SpxConnFileLockReference(pSpxConnFile, CFREF_RECV);			\
				SPX_QUEUE_TAIL_RECVLIST(pSpxConnFile);						\
			}																\
		}

#define	SPX_QUEUE_TAIL_PKTLIST(pSpxConnFile)									\
		{																		\
            if (SpxPktConnList.pcl_Tail)										\
			{																	\
                SpxPktConnList.pcl_Tail->scf_PktNext 	= pSpxConnFile;			\
                SpxPktConnList.pcl_Tail			  		= pSpxConnFile;			\
			}																	\
			else																\
			{																	\
                SpxPktConnList.pcl_Tail =										\
                SpxPktConnList.pcl_Head = pSpxConnFile;							\
			}																	\
		}																		
																				
#define	SPX_QUEUE_TAIL_RECVLIST(pSpxConnFile)									\
		{																		\
            if (SpxRecvConnList.pcl_Tail)										\
			{																	\
                SpxRecvConnList.pcl_Tail->scf_ProcessRecvNext	= pSpxConnFile;	\
                SpxRecvConnList.pcl_Tail			  			= pSpxConnFile;	\
			}																	\
			else																\
			{																	\
                SpxRecvConnList.pcl_Tail =										\
                SpxRecvConnList.pcl_Head = pSpxConnFile;						\
			}																	\
		}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxbind.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxbind.h

Abstract:


Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:


--*/

NTSTATUS
SpxInitBindToIpx(
    VOID);

VOID
SpxUnbindFromIpx(
    VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxaddr.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxaddr.c

Abstract:

    This module contains code which implements the ADDRESS object.
    Routines are provided to create, destroy, reference, and dereference,
    transport address objects.

Author:

	Adam   Barr		 (adamba ) Original Version
    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
//#pragma alloc_text( PAGE, SpxAddrFileCreate)
#pragma alloc_text( PAGE, SpxAddrFileClose)
#endif

#ifndef __PREFAST__
#pragma warning(disable:4068)
#endif
#pragma prefast(disable:276, "The assignments are harmless")


//	Define module number for event logging entries
#define	FILENUM		SPXADDR

// Map all generic accesses to the same one.
static GENERIC_MAPPING AddressGenericMapping =
       { READ_CONTROL, READ_CONTROL, READ_CONTROL, READ_CONTROL };

#define REORDER(_Socket) ((((_Socket) & 0xff00) >> 8) | (((_Socket) & 0x00ff) << 8))




NTSTATUS
SpxAddrOpen(
    IN PDEVICE 	Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine opens a file that points to an existing address object, or, if
    the object doesn't exist, creates it (note that creation of the address
    object includes registering the address, and may take many seconds to
    complete, depending upon system configuration).

    If the address already exists, and it has an ACL associated with it, the
    ACL is checked for access rights before allowing creation of the address.

Arguments:

    DeviceObject - pointer to the device object describing the ST transport.

    Request - a pointer to the request used for the creation of the address.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS 					status;
    PSPX_ADDR 					pAddr;
    PSPX_ADDR_FILE 				pAddrFile;
    PFILE_FULL_EA_INFORMATION 	ea;
    TRANSPORT_ADDRESS UNALIGNED *name;
    TA_ADDRESS *		AddressName;
    USHORT 						Socket, hostSocket;
    ULONG 						DesiredShareAccess;
    CTELockHandle 				LockHandle, LockHandleAddr;
    PACCESS_STATE 				AccessState;
    ACCESS_MASK 				GrantedAccess;
    BOOLEAN 					AccessAllowed;
    int 						i;
    BOOLEAN 					found = FALSE;
    INT                         Size = 0;

#ifdef ISN_NT
    PIRP Irp = (PIRP)Request;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
#endif

    // The network name is in the EA, passed in the request.
    ea = OPEN_REQUEST_EA_INFORMATION(Request);
    if (ea == NULL)
	{
        DBGPRINT(TDI, ERR,
				("OpenAddress: REQUEST %lx has no EA\n", Request));

        return STATUS_NONEXISTENT_EA_ENTRY;
    }

    // this may be a valid name; parse the name from the EA and use it if OK.
    name = (PTRANSPORT_ADDRESS)&ea->EaName[ea->EaNameLength+1];

    if (ea->EaValueLength < (sizeof(TRANSPORT_ADDRESS) -1)) {

        DBGPRINT(TDI, ERR,  ("The ea value length does not match the TA address length\n"));
        DbgPrint("IPX: STATUS_INVALID_EA_NAME - 1\n");
        return STATUS_INVALID_EA_NAME;

    }

    AddressName = (PTA_ADDRESS)&name->Address[0];
    Size = FIELD_OFFSET(TRANSPORT_ADDRESS, Address) + FIELD_OFFSET(TA_ADDRESS, Address) + AddressName->AddressLength;

    //
    // The name can be passed with multiple entries; we'll take and use only
    // the first one of type IPX.
    //

    //DbgPrint("Size (%d) & EaValueLength (%d)", Size, ea->EaValueLength);
    if (Size > ea->EaValueLength) {
        DbgPrint("EA:%lx, Name:%lx, AddressName:%lx\n", ea, name, AddressName);
        CTEAssert(FALSE);
    }

    // The name can be passed with multiple entries; we'll take and use only
    // the first one of type IPX.
    for (i=0;i<name->TAAddressCount;i++)
	{

        if (Size > ea->EaValueLength) {

            DBGPRINT(TDI, ERR, ("The EA value length does not match the TA address length (2)\n"));
            DbgPrint("IPX: STATUS_INVALID_EA_NAME - 2\n");

            return STATUS_INVALID_EA_NAME;

        }


        if (AddressName->AddressType == TDI_ADDRESS_TYPE_IPX)
		{
            if (AddressName->AddressLength >= sizeof(TDI_ADDRESS_IPX))
			{
				Socket =
				((TDI_ADDRESS_IPX UNALIGNED *)&AddressName->Address[0])->Socket;

				GETSHORT2SHORT(&hostSocket, &Socket);

				DBGPRINT(CREATE, DBG,
						("SpxAddrOpen: Creating socket %lx.h%lx\n",
							Socket, hostSocket ));

                found = TRUE;
            }
            break;

        }
		else
		{

            AddressName = (PTA_ADDRESS)(AddressName->Address +
                                        AddressName->AddressLength);

            Size += FIELD_OFFSET(TA_ADDRESS, Address);

            if (Size < ea->EaValueLength) {

                Size += AddressName->AddressLength;

            } else {

                break;

            }

        }
    }

    if (!found)
	{
        DBGPRINT(TDI, ERR,
				("OpenAddress: REQUEST %lx has no IPX Address\n", Request));

        return STATUS_INVALID_ADDRESS_COMPONENT;
    }

#ifdef SOCKET_RANGE_OPEN_LIMITATION_REMOVED
	//	Is the socket in our range if its in the range 0x4000-0x7FFF
	if (IN_RANGE(hostSocket, DYNSKT_RANGE_START, DYNSKT_RANGE_END))
	{
		if (!IN_RANGE(
				hostSocket,
				PARAM(CONFIG_SOCKET_RANGE_START),
				PARAM(CONFIG_SOCKET_RANGE_END)))
		{
			return(STATUS_INVALID_ADDRESS);
		}
	}
#endif

    // get an address file structure to represent this address.
    status = SpxAddrFileCreate(Device, Request, &pAddrFile);
    if (!NT_SUCCESS(status))
        return status;

    // See if this address is already established.  This call automatically
    // increments the reference count on the address so that it won't disappear
    // from underneath us after this call but before we have a chance to use it.
    //
    // To ensure that we don't create two address objects for the
    // same address, we hold the device context addressResource until
    // we have found the address or created a new one.

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite (&Device->dev_AddrResource, TRUE);
    CTEGetLock (&Device->dev_Lock, &LockHandle);

	//	We checkfor/create sockets within the critical section.
    if (Socket == 0)
	{
		Socket = SpxAddrAssignSocket(Device);

        if (Socket == 0)
		{
            DBGPRINT(ADDRESS, ERR,
					("OpenAddress, no unique socket found\n"));

			CTEFreeLock (&Device->dev_Lock, LockHandle);
			ExReleaseResourceLite (&Device->dev_AddrResource);
            SpxAddrFileDestroy(pAddrFile);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        DBGPRINT(ADDRESS, INFO,
				("OpenAddress, assigned socket %lx\n", Socket));
    }

	pAddr = SpxAddrLookup(Device, Socket);

    if (pAddr == NULL)
	{
        CTEFreeLock (&Device->dev_Lock, LockHandle);

        // This address doesn't exist. Create it.
        // registering it. It also puts a ref of type ADDR_FILE on address.
        pAddr = SpxAddrCreate(
                    Device,
                    Socket);

        if (pAddr != (PSPX_ADDR)NULL)
		{
#ifdef ISN_NT

            // Initialize the shared access now. We use read access
            // to control all access.
            DesiredShareAccess = (ULONG)
                (((IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ) ||
                  (IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE)) ?
                        FILE_SHARE_READ : 0);

            IoSetShareAccess(
                FILE_READ_DATA,
                DesiredShareAccess,
                IrpSp->FileObject,
                &pAddr->u.sa_ShareAccess);


            // Assign the security descriptor (need to do this with
            // the spinlock released because the descriptor is not
            // mapped).
            AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;

            status = SeAssignSecurity(
                         NULL,                       // parent descriptor
                         AccessState->SecurityDescriptor,
                         &pAddr->sa_SecurityDescriptor,
                         FALSE,                      // is directory
                         &AccessState->SubjectSecurityContext,
                         &AddressGenericMapping,
                         NonPagedPool);

            if (!NT_SUCCESS(status))
			{
                // Error, return status.
                IoRemoveShareAccess (IrpSp->FileObject, &pAddr->u.sa_ShareAccess);
                ExReleaseResourceLite (&Device->dev_AddrResource);
		KeLeaveCriticalRegion();
                SpxAddrDereference (pAddr, AREF_ADDR_FILE);

				SpxAddrFileDestroy(pAddrFile);
                return status;
            }

#endif

            ExReleaseResourceLite (&Device->dev_AddrResource);
	    KeLeaveCriticalRegion();

            // if the adapter isn't ready, we can't do any of this; get out
#if     defined(_PNP_POWER)
            if (Device->dev_State != DEVICE_STATE_OPEN)
#else
            if (Device->dev_State == DEVICE_STATE_STOPPING)
#endif  _PNP_POWER
			{
                SpxAddrDereference (pAddr, AREF_ADDR_FILE);

				SpxAddrFileDestroy(pAddrFile);
                status = STATUS_DEVICE_NOT_READY;
            }
			else
			{
                REQUEST_OPEN_CONTEXT(Request) = (PVOID)pAddrFile;
                REQUEST_OPEN_TYPE(Request) = (PVOID)TDI_TRANSPORT_ADDRESS_FILE;
#ifdef ISN_NT
                pAddrFile->saf_FileObject = IrpSp->FileObject;
#endif
                CTEGetLock (&pAddr->sa_Lock, &LockHandleAddr);
                pAddrFile->saf_Addr 	= pAddr;
                pAddrFile->saf_AddrLock = &pAddr->sa_Lock;

				//	Set flags appropriately, note spx/stream flags are set at this
				//	point.
				pAddrFile->saf_Flags   &= ~SPX_ADDRFILE_OPENING;
                pAddrFile->saf_Flags   |= SPX_ADDRFILE_OPEN;

				//	Queue in the address list, removed in destroy.
				pAddrFile->saf_Next				= pAddr->sa_AddrFileList;
				pAddr->sa_AddrFileList			= pAddrFile;
			
                CTEFreeLock (&pAddr->sa_Lock, LockHandleAddr);
                status = STATUS_SUCCESS;
            }
        }
		else
		{
            ExReleaseResourceLite (&Device->dev_AddrResource);
	    KeLeaveCriticalRegion();

            // If the address could not be created, and is not in the process of
            // being created, then we can't open up an address.

			SpxAddrFileDestroy(pAddrFile);
			status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
	else
	{
        CTEFreeLock (&Device->dev_Lock, LockHandle);

        DBGPRINT(ADDRESS, ERR,
				("Add to address %lx\n", pAddr));

        // The address already exists.  Check the ACL and see if we
        // can access it.  If so, simply use this address as our address.

#ifdef ISN_NT

        AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;

        AccessAllowed = SeAccessCheck(
                            pAddr->sa_SecurityDescriptor,
                            &AccessState->SubjectSecurityContext,
                            FALSE,                   // tokens locked
                            IrpSp->Parameters.Create.SecurityContext->DesiredAccess,
                            (ACCESS_MASK)0,             // previously granted
                            NULL,                    // privileges
                            &AddressGenericMapping,
                            Irp->RequestorMode,
                            &GrantedAccess,
                            &status);

#else   // ISN_NT

        AccessAllowed = TRUE;

#endif  // ISN_NT

        if (!AccessAllowed)
		{
            ExReleaseResourceLite (&Device->dev_AddrResource);
	    KeLeaveCriticalRegion();
			SpxAddrFileDestroy(pAddrFile);
        }
		else
		{
#ifdef ISN_NT

            // Now check that we can obtain the desired share
            // access. We use read access to control all access.
            DesiredShareAccess = (ULONG)
                (((IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ) ||
                  (IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE)) ?
                        FILE_SHARE_READ : 0);

            status = IoCheckShareAccess(
                         FILE_READ_DATA,
                         DesiredShareAccess,
                         IrpSp->FileObject,
                         &pAddr->u.sa_ShareAccess,
                         TRUE);

#else   // ISN_NT

            status = STATUS_SUCCESS;

#endif  // ISN_NT

            if (!NT_SUCCESS (status))
			{
                ExReleaseResourceLite (&Device->dev_AddrResource);
		KeLeaveCriticalRegion();
				SpxAddrFileDestroy(pAddrFile);
            }
			else
			{
                ExReleaseResourceLite (&Device->dev_AddrResource);
		KeLeaveCriticalRegion();
				CTEGetLock (&Device->dev_Lock, &LockHandle);
                CTEGetLock (&pAddr->sa_Lock, &LockHandleAddr);

                pAddrFile->saf_Addr 	= pAddr;
                pAddrFile->saf_AddrLock	= &pAddr->sa_Lock;
#ifdef ISN_NT
                pAddrFile->saf_FileObject	= IrpSp->FileObject;
#endif
				//	Set flags appropriately, note spx/stream flags are set at this
				//	point.
				pAddrFile->saf_Flags   &= ~SPX_ADDRFILE_OPENING;
                pAddrFile->saf_Flags   |= SPX_ADDRFILE_OPEN;

                SpxAddrLockReference (pAddr, AREF_ADDR_FILE);

                REQUEST_OPEN_CONTEXT(Request) 	= (PVOID)pAddrFile;
                REQUEST_OPEN_TYPE(Request) 		= (PVOID)TDI_TRANSPORT_ADDRESS_FILE;

				//	Queue in the address list, removed in destroy.
				pAddrFile->saf_Next				= pAddr->sa_AddrFileList;
				pAddr->sa_AddrFileList			= pAddrFile;
			
                CTEFreeLock (&pAddr->sa_Lock, LockHandleAddr);
				CTEFreeLock (&Device->dev_Lock, LockHandle);

                status = STATUS_SUCCESS;
            }
        }

        // Remove the reference from SpxLookupAddress.
        SpxAddrDereference (pAddr, AREF_LOOKUP);
    }

    return status;

} // SpxAddrOpen




NTSTATUS
SpxAddrSetEventHandler(
    IN PDEVICE 	Device,
    IN PREQUEST pRequest
    )
{
	CTELockHandle		lockHandle;
	NTSTATUS			status = STATUS_SUCCESS;

	PSPX_ADDR_FILE
		pSpxAddrFile = (PSPX_ADDR_FILE)REQUEST_OPEN_CONTEXT(pRequest);
	PTDI_REQUEST_KERNEL_SET_EVENT
		pParam = (PTDI_REQUEST_KERNEL_SET_EVENT)REQUEST_PARAMETERS(pRequest);

	if ((status = SpxAddrFileVerify(pSpxAddrFile)) != STATUS_SUCCESS)
		return(status);

	CTEGetLock(pSpxAddrFile->saf_AddrLock, &lockHandle);
	switch (pParam->EventType)
	{

	case TDI_EVENT_ERROR:

		break;

	case TDI_EVENT_CONNECT:

		pSpxAddrFile->saf_ConnHandler 	=
					(PTDI_IND_CONNECT)(pParam->EventHandler);
		pSpxAddrFile->saf_ConnHandlerCtx 	=
					pParam->EventContext;

		break;

	case TDI_EVENT_RECEIVE:

		pSpxAddrFile->saf_RecvHandler 	=
					(PTDI_IND_RECEIVE)(pParam->EventHandler);
		pSpxAddrFile->saf_RecvHandlerCtx 	=
					pParam->EventContext;

		break;

	case TDI_EVENT_DISCONNECT:

		pSpxAddrFile->saf_DiscHandler 	=
					(PTDI_IND_DISCONNECT)(pParam->EventHandler);
		pSpxAddrFile->saf_DiscHandlerCtx 	=
					pParam->EventContext;

		break;


	case TDI_EVENT_SEND_POSSIBLE :

		pSpxAddrFile->saf_SendPossibleHandler 	=
					(PTDI_IND_SEND_POSSIBLE)(pParam->EventHandler);
		pSpxAddrFile->saf_SendPossibleHandlerCtx 	=
					pParam->EventContext;

		break;

	case TDI_EVENT_RECEIVE_DATAGRAM:
	case TDI_EVENT_RECEIVE_EXPEDITED:
	default:

		status = STATUS_INVALID_PARAMETER;
	}

	CTEFreeLock(pSpxAddrFile->saf_AddrLock, lockHandle);

	SpxAddrFileDereference(pSpxAddrFile, AFREF_VERIFY);
	return(status);
}



PSPX_ADDR
SpxAddrCreate(
    IN PDEVICE 	Device,
    IN USHORT 	Socket
    )

/*++

Routine Description:

    This routine creates a transport address and associates it with
    the specified transport device context.  The reference count in the
    address is automatically set to 1, and the reference count of the
    device context is incremented.

    NOTE: This routine must be called with the Device
    spinlock held.

Arguments:

    Device - Pointer to the device context (which is really just
        the device object with its extension) to be associated with the
        address.

    Socket - The socket to assign to this address.

Return Value:

    The newly created address, or NULL if none can be allocated.

--*/

{
    PSPX_ADDR 			pAddr;
	int					index;
	CTELockHandle		lockHandle;

    pAddr = (PSPX_ADDR)SpxAllocateZeroedMemory (sizeof(SPX_ADDR));
    if (pAddr == NULL)
	{
        DBGPRINT(ADDRESS, INFO,
				("Create address %lx failed\n", (ULONG)Socket));

        return NULL;
    }

    DBGPRINT(ADDRESS, INFO,
			("Create address %lx (%lx)\n", pAddr, (ULONG)Socket));

    pAddr->sa_Type 	= SPX_ADDRESS_SIGNATURE;
    pAddr->sa_Size 	= sizeof (SPX_ADDR);
    pAddr->sa_Flags	= 0;

    pAddr->sa_Device		= Device;
    pAddr->sa_DeviceLock 	= &Device->dev_Lock;
    CTEInitLock (&pAddr->sa_Lock);

	//	This reference is for the address file that will associated with this addr.
    pAddr->sa_RefCount = 1;

#if DBG
    pAddr->sa_RefTypes[AREF_ADDR_FILE] = 1;
#endif

    pAddr->sa_Socket = Socket;

	//	Insert address into the device hash table.
	index	= (int)(Socket & NUM_SPXADDR_HASH_MASK);

	CTEGetLock (&Device->dev_Lock, &lockHandle);
	pAddr->sa_Next						= Device->dev_AddrHashTable[index];
	Device->dev_AddrHashTable[index]	= pAddr;
	CTEFreeLock (&Device->dev_Lock, lockHandle);

    SpxReferenceDevice (Device, DREF_ADDRESS);

    return pAddr;

} // SpxAddrCreate




NTSTATUS
SpxAddrFileVerify(
    IN PSPX_ADDR_FILE pAddrFile
    )

/*++

Routine Description:

    This routine is called to verify that the pointer given us in a file
    object is in fact a valid address file object. We also verify that the
    address object pointed to by it is a valid address object, and reference
    it to keep it from disappearing while we use it.

Arguments:

    AddressFile - potential pointer to a SPX_ADDR_FILE object

Return Value:

    STATUS_SUCCESS if all is well; STATUS_INVALID_ADDRESS otherwise

--*/

{
    CTELockHandle 	LockHandle;
    NTSTATUS 		status = STATUS_SUCCESS;
    PSPX_ADDR 		Address;

    // try to verify the address file signature. If the signature is valid,
    // verify the address pointed to by it and get the address spinlock.
    // check the address's state, and increment the reference count if it's
    // ok to use it. Note that the only time we return an error for state is
    // if the address is closing.

    try
	{
        if ((pAddrFile->saf_Size == sizeof (SPX_ADDR_FILE)) &&
            (pAddrFile->saf_Type == SPX_ADDRESSFILE_SIGNATURE) )
		{
            Address = pAddrFile->saf_Addr;

            if ((Address->sa_Size == sizeof (SPX_ADDR)) &&
                (Address->sa_Type == SPX_ADDRESS_SIGNATURE)    )
			{
                CTEGetLock (&Address->sa_Lock, &LockHandle);

                if ((Address->sa_Flags & SPX_ADDR_CLOSING) == 0)
				{
                    SpxAddrFileLockReference(pAddrFile, AFREF_VERIFY);
                }
				else
				{
                    DBGPRINT(TDI, ERR,
							("StVerifyAddressFile: A %lx closing\n", Address));

                    status = STATUS_INVALID_ADDRESS;
                }

                CTEFreeLock (&Address->sa_Lock, LockHandle);
            }
			else
			{
                DBGPRINT(TDI, ERR,
						("StVerifyAddressFile: A %lx bad signature\n", Address));

                status = STATUS_INVALID_ADDRESS;
            }
        }
		else
		{
            DBGPRINT(TDI, ERR,
					("StVerifyAddressFile: AF %lx bad signature\n", pAddrFile));

            status = STATUS_INVALID_ADDRESS;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

         DBGPRINT(TDI, ERR,
				("SpxAddrFileVerify: AF %lx exception\n", Address));

         return GetExceptionCode();
    }

    return status;

}   // SpxAddrFileVerify




VOID
SpxAddrDestroy(
    IN PVOID Parameter
    )

/*++

Routine Description:

    This routine destroys a transport address and removes all references
    made by it to other objects in the transport.  The address structure
    is returned to nonpaged system pool. It is assumed
    that the caller has already removed all addressfile structures associated
    with this address.

    It is called from a worker thread queue by SpxDerefAddress when
    the reference count goes to 0.

    This thread is only queued by SpxDerefAddress.  The reason for
    this is that there may be multiple streams of execution which are
    simultaneously referencing the same address object, and it should
    not be deleted out from under an interested stream of execution.

Arguments:

    Address - Pointer to a transport address structure to be destroyed.

Return Value:

    NTSTATUS - status of operation.

--*/

{
	PSPX_ADDR		pAddr, *ppAddr;
    CTELockHandle 	LockHandle;

    PSPX_ADDR 	Address = (PSPX_ADDR)Parameter;
    PDEVICE 	Device 	= Address->sa_Device;
	int			index	= (int)(Address->sa_Socket & NUM_SPXADDR_HASH_MASK);

    DBGPRINT(ADDRESS, INFO,
			("Destroy address %lx\n", Address));

    SeDeassignSecurity (&Address->sa_SecurityDescriptor);

    // Delink this address from its associated device context's address
    // database.  To do this we must spin lock on the device context object,
    // not on the address.
    CTEGetLock (&Device->dev_Lock, &LockHandle);
	for (ppAddr = &Device->dev_AddrHashTable[index]; (pAddr = *ppAddr) != NULL;)
	{
		if (pAddr == Address)
		{
			*ppAddr = pAddr->sa_Next;
			break;
		}

		ppAddr = &pAddr->sa_Next;
	}
    CTEFreeLock (&Device->dev_Lock, LockHandle);

    SpxFreeMemory (Address);
    SpxDereferenceDevice (Device, DREF_ADDRESS);

}




#if DBG

VOID
SpxAddrRef(
    IN PSPX_ADDR Address
    )

/*++

Routine Description:

    This routine increments the reference count on a transport address.

Arguments:

    Address - Pointer to a transport address object.

Return Value:

    none.

--*/

{

    CTEAssert (Address->sa_RefCount > 0);    // not perfect, but...

    (VOID)SPX_ADD_ULONG (
            &Address->sa_RefCount,
            1,
            Address->sa_DeviceLock);
}




VOID
SpxAddrLockRef(
    IN PSPX_ADDR Address
    )

/*++

Routine Description:

    This routine increments the reference count on a transport address
    when the device lock is already held.

Arguments:

    Address - Pointer to a transport address object.

Return Value:

    none.

--*/

{

    CTEAssert (Address->sa_RefCount > 0);    // not perfect, but...
    (VOID)SPX_ADD_ULONG (
            &Address->sa_RefCount,
            1,
            Address->sa_DeviceLock);
}
#endif




VOID
SpxAddrDeref(
    IN PSPX_ADDR Address
    )

/*++

Routine Description:

    This routine dereferences a transport address by decrementing the
    reference count contained in the structure.  If, after being
    decremented, the reference count is zero, then this routine calls
    SpxDestroyAddress to remove it from the system.

Arguments:

    Address - Pointer to a transport address object.

Return Value:

    none.

--*/

{
    ULONG oldvalue;

    oldvalue = SPX_ADD_ULONG (
                &Address->sa_RefCount,
                (ULONG)-1,
                Address->sa_DeviceLock);

    //
    // If we have deleted all references to this address, then we can
    // destroy the object.  It is okay to have already released the spin
    // lock at this point because there is no possible way that another
    // stream of execution has access to the address any longer.
    //

    CTEAssert (oldvalue != 0);

    if (oldvalue == 1)
	{
#if ISN_NT
        ExInitializeWorkItem(
            &Address->u.sa_DestroyAddrQueueItem,
            SpxAddrDestroy,
            (PVOID)Address);
        ExQueueWorkItem(&Address->u.sa_DestroyAddrQueueItem, DelayedWorkQueue);
#else
        SpxAddrDestroy(Address);
#endif

    }

}




NTSTATUS
SpxAddrFileCreate(
    IN 	PDEVICE 			Device,	
    IN 	PREQUEST 			Request,
	OUT PSPX_ADDR_FILE *	ppAddrFile
    )

/*++

Routine Description:

    This routine creates an address file from the pool of ther
    specified device context. The reference count in the
    address is automatically set to 1.

Arguments:

    Device - Pointer to the device context (which is really just
        the device object with its extension) to be associated with the
        address.

Return Value:

    The allocate address file or NULL.

--*/

{
	NTSTATUS		status;
	BYTE			socketType;
    CTELockHandle 	LockHandle;
    PSPX_ADDR_FILE 	pAddrFile;

	//	What is the address file type?
	if (!NT_SUCCESS(status = SpxUtilGetSocketType(
								REQUEST_OPEN_NAME(Request),
								&socketType)))
	{
		return(status);
	}

    pAddrFile = (PSPX_ADDR_FILE)SpxAllocateZeroedMemory (sizeof(SPX_ADDR_FILE));
    if (pAddrFile == NULL)
	{
        DBGPRINT(ADDRESS, ERR,
				("Create address file failed\n"));

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGPRINT(ADDRESS, INFO,
			("Create address file %lx\n", pAddrFile));

    CTEGetLock (&Device->dev_Lock, &LockHandle);

    pAddrFile->saf_Type = SPX_ADDRESSFILE_SIGNATURE;
    pAddrFile->saf_Size = sizeof (SPX_ADDR_FILE);

    pAddrFile->saf_Addr 		= NULL;

#ifdef ISN_NT
    pAddrFile->saf_FileObject 	= NULL;
#endif

    pAddrFile->saf_Device 		= Device;
    pAddrFile->saf_Flags 	    = SPX_ADDRFILE_OPENING;
    if ((socketType == SOCKET1_TYPE_SEQPKT) ||
		(socketType == SOCKET1_TYPE_STREAM))
	{
		if (socketType == SOCKET1_TYPE_STREAM)
		{
			pAddrFile->saf_Flags 	    |= SPX_ADDRFILE_STREAM;
		}
	}

    if ((socketType == SOCKET2_TYPE_SEQPKT) ||
		(socketType == SOCKET2_TYPE_STREAM))
	{
		pAddrFile->saf_Flags 	    |= SPX_ADDRFILE_SPX2;
		if (socketType == SOCKET2_TYPE_STREAM)
		{
			pAddrFile->saf_Flags 	    |= SPX_ADDRFILE_STREAM;
		}
	}

    pAddrFile->saf_RefCount 	= 1;

#if DBG
    pAddrFile->saf_RefTypes[AFREF_CREATE] = 1;
#endif

    pAddrFile->saf_CloseReq 	= (PREQUEST)NULL;

    // Initialize the request handlers.
    pAddrFile->saf_ConnHandler 		=
    pAddrFile->saf_ConnHandlerCtx 	= NULL;
    pAddrFile->saf_DiscHandler 		=
    pAddrFile->saf_DiscHandlerCtx	= NULL;
    pAddrFile->saf_RecvHandler		=
    pAddrFile->saf_RecvHandlerCtx 	= NULL;
    pAddrFile->saf_ErrHandler 		=
    pAddrFile->saf_ErrHandlerCtx	= NULL;

	//	Release lock
    CTEFreeLock (&Device->dev_Lock, LockHandle);

	//	Put in the global list for our reference
	spxAddrInsertIntoGlobalList(pAddrFile);

	*ppAddrFile	= pAddrFile;
    return STATUS_SUCCESS;

}




NTSTATUS
SpxAddrFileDestroy(
    IN PSPX_ADDR_FILE pAddrFile
    )

/*++

Routine Description:

    This routine destroys an address file and removes all references
    made by it to other objects in the transport.

    This routine is only called by SpxAddrFileDereference. The reason
    for this is that there may be multiple streams of execution which are
    simultaneously referencing the same address file object, and it should
    not be deleted out from under an interested stream of execution.

Arguments:

    pAddrFile Pointer to a transport address file structure to be destroyed.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    CTELockHandle 	LockHandle, LockHandle1;
    PSPX_ADDR 		Address;
    PDEVICE 		Device;
    PREQUEST 		CloseRequest;
	PSPX_ADDR_FILE	pRemAddr, *ppRemAddr;

    DBGPRINT(ADDRESS, INFO,
			("Destroy address file %lx\n", pAddrFile));

    Address 	= pAddrFile->saf_Addr;
    Device 		= pAddrFile->saf_Device;

    if (Address)
	{
		CTEGetLock (&Device->dev_Lock, &LockHandle1);

        // This addressfile was associated with an address.
        CTEGetLock (&Address->sa_Lock, &LockHandle);

		//	If the last reference on the address is being removed, set the
		//	closing flag to prevent further references.

        //if (Address->sa_RefCount == 1)

        //
        // ** The lock passed here is a dummy - it is pre-compiled out.
        //
        if (SPX_ADD_ULONG(&Address->sa_RefCount, 0, &Address->sa_Lock) == 1) {
			Address->sa_Flags |= SPX_ADDR_CLOSING;
        }

		//	Dequeue the address file from the address list.
		for (ppRemAddr = &Address->sa_AddrFileList; (pRemAddr = *ppRemAddr) != NULL;)
		{
			if (pRemAddr == pAddrFile)
			{
				*ppRemAddr = pRemAddr->saf_Next;
				break;
			}
	
			ppRemAddr = &pRemAddr->saf_Next;
		}

        pAddrFile->saf_Addr = NULL;

#ifdef ISN_NT
        pAddrFile->saf_FileObject->FsContext = NULL;
        pAddrFile->saf_FileObject->FsContext2 = NULL;
#endif

        CTEFreeLock (&Address->sa_Lock, LockHandle);
		CTEFreeLock (&Device->dev_Lock, LockHandle1);

        // We will already have been removed from the ShareAccess
        // of the owning address.
        //
        // Now dereference the owning address.
        SpxAddrDereference(Address, AREF_ADDR_FILE);
    }

    // 	Save this for later completion.
    CloseRequest = pAddrFile->saf_CloseReq;

	//	Remove from the global list
	spxAddrRemoveFromGlobalList(pAddrFile);

    // 	return the addressFile to the pool of address files
    SpxFreeMemory (pAddrFile);

    if (CloseRequest != (PREQUEST)NULL)
	{
        REQUEST_INFORMATION(CloseRequest) = 0;
        REQUEST_STATUS(CloseRequest) = STATUS_SUCCESS;
        SpxCompleteRequest (CloseRequest);
        SpxFreeRequest (Device, CloseRequest);
    }

    return STATUS_SUCCESS;

}




#if DBG

VOID
SpxAddrFileRef(
    IN PSPX_ADDR_FILE pAddrFile
    )

/*++

Routine Description:

    This routine increments the reference count on an address file.

Arguments:

    pAddrFile - Pointer to a transport address file object.

Return Value:

    none.

--*/

{

    CTEAssert (pAddrFile->saf_RefCount > 0);   // not perfect, but...

    (VOID)SPX_ADD_ULONG (
            &pAddrFile->saf_RefCount,
            1,
            pAddrFile->saf_AddrLock);

} // SpxRefAddressFile




VOID
SpxAddrFileLockRef(
    IN PSPX_ADDR_FILE pAddrFile
    )

/*++

Routine Description:

    This routine increments the reference count on an address file.
    IT IS CALLED WITH THE ADDRESS LOCK HELD.

Arguments:

    pAddrFile - Pointer to a transport address file object.

Return Value:

    none.

--*/

{

    CTEAssert (pAddrFile->saf_RefCount > 0);   // not perfect, but...
    (VOID)SPX_ADD_ULONG (
            &pAddrFile->saf_RefCount,
            1,
            pAddrFile->saf_AddrLock);

}
#endif




VOID
SpxAddrFileDeref(
    IN PSPX_ADDR_FILE pAddrFile
    )

/*++

Routine Description:

    This routine dereferences an address file by decrementing the
    reference count contained in the structure.  If, after being
    decremented, the reference count is zero, then this routine calls
    SpxDestroyAddressFile to remove it from the system.

Arguments:

    pAddrFile - Pointer to a transport address file object.

Return Value:

    none.

--*/

{
    ULONG oldvalue;

    oldvalue = SPX_ADD_ULONG (
                &pAddrFile->saf_RefCount,
                (ULONG)-1,
                pAddrFile->saf_AddrLock);

    // If we have deleted all references to this address file, then we can
    // destroy the object.  It is okay to have already released the spin
    // lock at this point because there is no possible way that another
    // stream of execution has access to the address any longer.
    CTEAssert (oldvalue > 0);

    if (oldvalue == 1)
	{
        SpxAddrFileDestroy(pAddrFile);
    }

}




PSPX_ADDR
SpxAddrLookup(
    IN PDEVICE 	Device,
    IN USHORT 	Socket
    )	

/*++

Routine Description:

    This routine scans the transport addresses defined for the given
    device context and compares them with the specified NETWORK
    NAME values.  If an exact match is found, then a pointer to the
    ADDRESS object is returned, and as a side effect, the reference
    count to the address object is incremented.  If the address is not
    found, then NULL is returned.

    NOTE: This routine must be called with the Device
    spinlock held.

Arguments:

    Device - Pointer to the device object and its extension.

    Socket - The socket to look up.

Return Value:

    Pointer to the ADDRESS object found, or NULL if not found.

--*/

{
    PSPX_ADDR 	Address;
	int			index	= (int)(Socket & NUM_SPXADDR_HASH_MASK);

    for (Address = Device->dev_AddrHashTable[index];
         Address != NULL;
         Address = Address->sa_Next)
	{
        if ((Address->sa_Flags & SPX_ADDR_CLOSING) != 0)
		{
            continue;
        }

        if (Address->sa_Socket == Socket)
		{
            // We found the match.  Bump the reference count on the address, and
            // return a pointer to the address object for the caller to use.
            SpxAddrLockReference(Address, AREF_LOOKUP);
            return Address;

        }
    }

    // The specified address was not found.
    return NULL;

}




BOOLEAN
SpxAddrExists(
    IN PDEVICE 	Device,
    IN USHORT 	Socket
    )	

/*++

Routine Description:

    NOTE: This routine must be called with the Device
    spinlock held.

Arguments:

    Device - Pointer to the device object and its extension.

    Socket - The socket to look up.

Return Value:

	TRUE if so, else FALSE

--*/

{
    PSPX_ADDR 	Address;
	int			index	= (int)(Socket & NUM_SPXADDR_HASH_MASK);

    for (Address = Device->dev_AddrHashTable[index];
         Address != NULL;
         Address = Address->sa_Next)
	{
        if ((Address->sa_Flags & SPX_ADDR_CLOSING) != 0)
		{
            continue;
        }

        if (Address->sa_Socket == Socket)
		{
            // We found the match
            return TRUE;
        }
    }

    // The specified address was not found.
    return FALSE;

}   // SpxAddrExists




NTSTATUS
SpxAddrConnByRemoteIdAddrLock(
    IN 	PSPX_ADDR	 	pSpxAddr,
    IN 	USHORT			SrcConnId,
	IN	PBYTE			SrcIpxAddr,
	OUT	PSPX_CONN_FILE *ppSpxConnFile
	)
{
	PSPX_CONN_FILE	pSpxConnFile;
	NTSTATUS	status = STATUS_INVALID_CONNECTION;

	for (pSpxConnFile = pSpxAddr->sa_ActiveConnList;
		 pSpxConnFile != NULL;
		 pSpxConnFile = pSpxConnFile->scf_Next)
	{
		if ((pSpxConnFile->scf_RemConnId == SrcConnId) &&
			(*((UNALIGNED ULONG *)SrcIpxAddr) ==
				*((UNALIGNED ULONG *)pSpxConnFile->scf_RemAddr)) &&
			(*(UNALIGNED ULONG *)(SrcIpxAddr+4) ==
				*(UNALIGNED ULONG *)(pSpxConnFile->scf_RemAddr+4)) &&
			(*(UNALIGNED ULONG *)(SrcIpxAddr+8) ==
				*(UNALIGNED ULONG *)(pSpxConnFile->scf_RemAddr+8)))
		{
			SpxConnFileReference(pSpxConnFile, CFREF_ADDR);
			*ppSpxConnFile 	= pSpxConnFile;
			status 			= STATUS_SUCCESS;
			break;
		}
	}

	return(status);
}
	



NTSTATUS
SpxAddrFileStop(
    IN PSPX_ADDR_FILE pAddrFile,
    IN PSPX_ADDR Address
    )

/*++

Routine Description:

    This routine is called to terminate all activity on an pAddrFile and
    destroy the object.  We remove every connection and datagram associated
    with this addressfile from the address database and terminate their
    activity. Then, if there are no other outstanding addressfiles open on
    this address, the address will go away.

Arguments:

    pAddrFile - pointer to the addressFile to be stopped

    Address - the owning address for this addressFile (we do not depend upon
        the pointer in the addressFile because we want this routine to be safe)

Return Value:

    STATUS_SUCCESS if all is well, STATUS_INVALID_HANDLE if the request
    is not for a real address.

--*/

{
	PSPX_CONN_FILE	pSpxConnFile, pSpxConnFileNext;
    CTELockHandle 	LockHandle;


	DBGPRINT(ADDRESS, DBG,
			("SpxAddrFileStop: %lx\n", pAddrFile));

    CTEGetLock (&Address->sa_Lock, &LockHandle);

    if (pAddrFile->saf_Flags & SPX_ADDRFILE_CLOSING)
	{
        CTEFreeLock (&Address->sa_Lock, LockHandle);
        return STATUS_SUCCESS;
    }

    pAddrFile->saf_Flags |= SPX_ADDRFILE_CLOSING;

	pSpxConnFileNext = NULL;
	if (pSpxConnFile = pAddrFile->saf_AssocConnList)
	{
		pSpxConnFileNext = pSpxConnFile;
		SpxConnFileReference(pSpxConnFile, CFREF_ADDR);
	}

	while (pSpxConnFile)
	{
		if (pSpxConnFileNext = pSpxConnFile->scf_AssocNext)
		{
			SpxConnFileReference(pSpxConnFileNext, CFREF_ADDR);
		}
		CTEFreeLock (&Address->sa_Lock, LockHandle);

	
		DBGPRINT(CREATE, INFO,
				("SpxAddrFileClose: Assoc conn stop %lx when %lx\n",
					pSpxConnFile, pSpxConnFile->scf_RefCount));

		SpxConnStop(pSpxConnFile);
		SpxConnFileDereference(pSpxConnFile, CFREF_ADDR);

		CTEGetLock (&Address->sa_Lock, &LockHandle);
		pSpxConnFile = pSpxConnFileNext;
	}

    CTEFreeLock (&Address->sa_Lock, LockHandle);
	return STATUS_SUCCESS;

}




NTSTATUS
SpxAddrFileCleanup(
    IN PDEVICE Device,
    IN PREQUEST Request
    )
/*++

Routine Description:


Arguments:

    Request - the close request.

Return Value:

    STATUS_SUCCESS if all is well, STATUS_INVALID_HANDLE if the
    request does not point to a real address.

--*/

{
    PSPX_ADDR 		Address;
    PSPX_ADDR_FILE 	pSpxAddrFile;
	NTSTATUS		status;

    pSpxAddrFile = (PSPX_ADDR_FILE)REQUEST_OPEN_CONTEXT(Request);

	DBGPRINT(ADDRESS, INFO,
			("SpxAddrFileCleanup: %lx\n", pSpxAddrFile));

	status = SpxAddrFileVerify(pSpxAddrFile);
	if (!NT_SUCCESS (status))
	{
		return(status);
	}

    // We assume that addressFile has already been verified
    // at this point.
    Address = pSpxAddrFile->saf_Addr;
    CTEAssert (Address);

    SpxAddrFileStop(pSpxAddrFile, Address);
	SpxAddrFileDereference(pSpxAddrFile, AFREF_VERIFY);
    return STATUS_SUCCESS;
}




NTSTATUS
SpxAddrFileClose(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine is called to close the addressfile pointed to by a file
    object. If there is any activity to be run down, we will run it down
    before we terminate the addressfile. We remove every connection and
    datagram associated with this addressfile from the address database
    and terminate their activity. Then, if there are no other outstanding
    addressfiles open on this address, the address will go away.

Arguments:

    Request - the close request.

Return Value:

    STATUS_SUCCESS if all is well, STATUS_INVALID_HANDLE if the
    request does not point to a real address.

--*/

{
    PSPX_ADDR 		Address;
    PSPX_ADDR_FILE 	pSpxAddrFile;
	NTSTATUS		status;

    pSpxAddrFile = (PSPX_ADDR_FILE)REQUEST_OPEN_CONTEXT(Request);

	DBGPRINT(ADDRESS, DBG,
			("SpxAddrFileClose: %lx\n", pSpxAddrFile));

	status = SpxAddrFileVerify(pSpxAddrFile);

	if (!NT_SUCCESS (status))
	{
		return(status);
	}

    pSpxAddrFile->saf_CloseReq = Request;

    // We assume that addressFile has already been verified
    // at this point.
    Address = pSpxAddrFile->saf_Addr;
    CTEAssert (Address);

    // Remove us from the access info for this address.
    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite (&Device->dev_AddrResource, TRUE);

#ifdef ISN_NT
    IoRemoveShareAccess (pSpxAddrFile->saf_FileObject, &Address->u.sa_ShareAccess);
#endif

    ExReleaseResourceLite (&Device->dev_AddrResource);
    KeLeaveCriticalRegion();


    SpxAddrFileDereference (pSpxAddrFile, AFREF_CREATE);
	SpxAddrFileDereference(pSpxAddrFile, AFREF_VERIFY);
    return STATUS_PENDING;

}   // SpxCloseAddressFile




USHORT
SpxAddrAssignSocket(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine assigns a socket that is unique within a range
    of SocketUniqueness.

Arguments:

    Device - Pointer to the device context.

Return Value:

    The assigned socket number, or 0 if a unique one cannot
    be found.

--*/

{
	BOOLEAN		wrapped = FALSE;
	USHORT		temp, Socket;

	// We have to auto-assign a socket.
	temp = Device->dev_CurrentSocket;
	PUTSHORT2SHORT(
		&Socket,
        Device->dev_CurrentSocket);

	while (TRUE)
	{
		Device->dev_CurrentSocket 	+= (USHORT)PARAM(CONFIG_SOCKET_UNIQUENESS);
		if (Device->dev_CurrentSocket > PARAM(CONFIG_SOCKET_RANGE_END))
		{
			Device->dev_CurrentSocket = (USHORT)PARAM(CONFIG_SOCKET_RANGE_START);
			wrapped = TRUE;
		}

		if (!SpxAddrExists (Device, Socket))
		{
			break;
		}

		PUTSHORT2SHORT(
			&Socket,
			Device->dev_CurrentSocket);

		if (wrapped && (Device->dev_CurrentSocket >= temp))
		{
			//	If we have checked all possible values given SOCKET_UNIQUENESS...
			//	This may actually return ERROR even if there are
			//	available socket numbers although they may be
			//	implicitly in use due to SOCKET_UNIQUENESS being
			//	> 1. That is the way it is to work.

			Socket = 0;
			break;
		}
	}

	DBGPRINT(ADDRESS, INFO,
			("OpenAddress, assigned socket %lx\n", Socket));

    return(Socket);
}




VOID
spxAddrInsertIntoGlobalList(
	IN	PSPX_ADDR_FILE	pSpxAddrFile
	)

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
	CTELockHandle	lockHandle;

	//	Get the global q lock
	CTEGetLock(&SpxGlobalQInterlock, &lockHandle);
	pSpxAddrFile->saf_GlobalNext	= SpxGlobalAddrList;
    SpxGlobalAddrList				= pSpxAddrFile;
	CTEFreeLock(&SpxGlobalQInterlock, lockHandle);

	return;
}




NTSTATUS
spxAddrRemoveFromGlobalList(
	IN	PSPX_ADDR_FILE	pSpxAddrFile
	)

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
	CTELockHandle	lockHandle;
    PSPX_ADDR_FILE	pC, *ppC;
	NTSTATUS		status = STATUS_SUCCESS;

	//	Get the global q lock
	CTEGetLock(&SpxGlobalQInterlock, &lockHandle);
	for (ppC = &SpxGlobalAddrList;
		(pC = *ppC) != NULL;)
	{
		if (pC == pSpxAddrFile)
		{
			DBGPRINT(SEND, INFO,
					("SpxAddrRemoveFromGlobal: %lx\n", pSpxAddrFile));

			//	Remove from list
			*ppC = pC->saf_GlobalNext;
			break;
		}

		ppC = &pC->saf_GlobalNext;
	}
	CTEFreeLock(&SpxGlobalQInterlock, lockHandle);

	if (pC	== NULL)
		status = STATUS_INVALID_ADDRESS;

	return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxcpkt.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxcpkt.c

Abstract:

    This module contains code which implements the CONNECTION object.
    Routines are provided to create, destroy, reference, and dereference,
    transport connection objects.

Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:

   Sanjay Anand (SanjayAn) 14-July-1995
   Bug fixes - tagged [SA]

--*/

#include "precomp.h"
#pragma hdrstop

//      Define module number for event logging entries
#define FILENUM         SPXCPKT

VOID
SpxTdiCancel(
    IN PDEVICE_OBJECT 	DeviceObject,
    IN PIRP 			Irp);

NTSTATUS
spxPrepareIrpForCancel(PIRP pIrp) 
{
   KIRQL oldIrql;

   IoAcquireCancelSpinLock(&oldIrql);

   CTEAssert(pIrp->CancelRoutine == NULL);
   
   if (!pIrp->Cancel) {

      IoMarkIrpPending(pIrp);

      // Double check if the routine can handle accept cancel. 
      IoSetCancelRoutine(pIrp, SpxTdiCancel);
      // Do I need to increment any reference count here?

      DBGPRINT(CONNECT, INFO,
		 ("spxPrepareIrpForCancel: Prepare IRP %p for cancel.\n", pIrp));
      IoReleaseCancelSpinLock(oldIrql);

      return(STATUS_SUCCESS);
   }

   DBGPRINT(CONNECT, INFO,
	    ("spxPrepareIrpForCancel: The IRP %p has already been canceled.\n", pIrp));

   IoReleaseCancelSpinLock(oldIrql);
	
   pIrp->IoStatus.Status = STATUS_CANCELLED;
   pIrp->IoStatus.Information = 0;

   IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

   return(STATUS_CANCELLED);
}

VOID
spxConnHandleConnReq(
    IN  PIPXSPX_HDR         pIpxSpxHdr,
        IN  PIPX_LOCAL_TARGET   pRemoteAddr
        )
/*++

Routine Description:


Arguments:


Return Value:


--*/

{
        BOOLEAN                         fNeg, fSpx2;
        TA_IPX_ADDRESS          srcIpxAddr;
        PTDI_IND_CONNECT        connHandler;
        USHORT                          srcConnId, destConnId, destSkt,
                                                pktLen, seqNum, ackNum, allocNum;
        PVOID                           connHandlerCtx;
        PREQUEST                        pListenReq;
    PSPX_SEND_RESD              pSendResd;
        NTSTATUS                        status;
        CTELockHandle           lockHandle, lockHandleDev, lockHandleConn;
        CONNECTION_CONTEXT  connCtx;
        PIRP                            acceptIrp;
        PSPX_ADDR                       pSpxAddr;
        PSPX_ADDR_FILE          pSpxAddrFile, pSpxRefFile;
        PSPX_CONN_FILE          pSpxConnFile;
        PNDIS_PACKET            pCrAckPkt;
        BOOLEAN                         connectAccepted = FALSE, delayAccept = FALSE,
                                                addrLock = FALSE, tdiListen = FALSE;

        //      Convert hdr to host format as needed.
        GETSHORT2SHORT(&pktLen, &pIpxSpxHdr->hdr_PktLen);
        GETSHORT2SHORT(&destConnId, &pIpxSpxHdr->hdr_DestConnId);
        GETSHORT2SHORT(&seqNum, &pIpxSpxHdr->hdr_SeqNum);
        GETSHORT2SHORT(&ackNum, &pIpxSpxHdr->hdr_AckNum);
        GETSHORT2SHORT(&allocNum, &pIpxSpxHdr->hdr_AllocNum);

        //      We keep and use the remote id in the net format. This maintains the
        //      0x0 and 0xFFFF to be as in the host format.
        srcConnId       = *(USHORT UNALIGNED *)&pIpxSpxHdr->hdr_SrcConnId;

        //      Verify Connect Request
        if (((pIpxSpxHdr->hdr_ConnCtrl & (SPX_CC_ACK | SPX_CC_SYS)) !=
                                                                        (SPX_CC_ACK | SPX_CC_SYS))      ||
                (pIpxSpxHdr->hdr_DataType != 0) ||
        (seqNum != 0) ||
        (ackNum != 0) ||
                (srcConnId == 0) ||
                (srcConnId == 0xFFFF) ||
                (destConnId != 0xFFFF))
        {
                DBGPRINT(RECEIVE, ERR,
                                ("SpxConnSysPacket: VerifyCR Failed %lx.%lx\n",
                                        srcConnId, destConnId));
                return;
        }

        //      Get the destination socket from the header
        destSkt = *(USHORT UNALIGNED *)&pIpxSpxHdr->hdr_DestSkt;

        SpxBuildTdiAddress(
                &srcIpxAddr,
                sizeof(srcIpxAddr),
                (PBYTE)pIpxSpxHdr->hdr_SrcNet,
                pIpxSpxHdr->hdr_SrcNode,
                pIpxSpxHdr->hdr_SrcSkt);

        //      Ok, get the address object this is destined for.
        CTEGetLock (&SpxDevice->dev_Lock, &lockHandleDev);
        pSpxAddr = SpxAddrLookup(SpxDevice, destSkt);
        CTEFreeLock (&SpxDevice->dev_Lock, lockHandleDev);
        if (pSpxAddr == NULL)
        {
                DBGPRINT(RECEIVE, DBG,
                                ("SpxReceive: No addr for %lx\n", destSkt));

                return;
        }

        fSpx2   = ((PARAM(CONFIG_DISABLE_SPX2) == 0) &&
                           (BOOLEAN)(pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_SPX2));
        fNeg    = (BOOLEAN)(fSpx2 && (pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_NEG));

        DBGPRINT(CONNECT, DBG,
                        ("spxConnHandleConnReq: Received connect req! %d.%d\n",
                                fSpx2, fNeg));

        CTEGetLock (&pSpxAddr->sa_Lock, &lockHandle);
        addrLock                = TRUE;

        //      We use a bit setting in the flag to prevent reentering
        //      per address file.
        //
        //      We first search the list of non-inactive connections on the address
        //      this packet came in on to see if it is a duplicate. If it is, we just
        //      resend ack. Note we dont need to scan the global connection list.
        status = SpxAddrConnByRemoteIdAddrLock(
                                pSpxAddr, srcConnId, pIpxSpxHdr->hdr_SrcNet, &pSpxConnFile);

        if (NT_SUCCESS(status))
        {
                DBGPRINT(CONNECT, ERR,
                                ("spxConnHandleConnReq: Received duplicate connect req! %lx\n",
                                        pSpxConnFile));

                if (SPX_CONN_ACTIVE(pSpxConnFile) ||
            (SPX_CONN_LISTENING(pSpxConnFile) &&
                         ((SPX_LISTEN_STATE(pSpxConnFile) == SPX_LISTEN_SENTACK) ||
                          (SPX_LISTEN_STATE(pSpxConnFile) == SPX_LISTEN_SETUP))))
                {
                        DBGPRINT(CONNECT, ERR,
                                        ("spxConnHandleConnReq: Sending Duplicate CR - ACK! %lx\n",
                                                pSpxConnFile));

                        //      Build and send an ack
                        CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);
                        SpxPktBuildCrAck(
                                pSpxConnFile,
                                pSpxAddr,
                                &pCrAckPkt,
                                SPX_SENDPKT_IPXOWNS | SPX_SENDPKT_DESTROY,
                                SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_NEG),
                                SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_SPX2));

                        if (pCrAckPkt != NULL)
                        {
                                SpxConnQueueSendPktTail(pSpxConnFile, pCrAckPkt);
                        }
                        CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
                        CTEFreeLock (&pSpxAddr->sa_Lock, lockHandle);
                        addrLock = FALSE;

                        //      Send the CR Ack packet!
                        if (pCrAckPkt != NULL)
                        {
                                pSendResd       = (PSPX_SEND_RESD)(pCrAckPkt->ProtocolReserved);
                                SPX_SENDPACKET(pSpxConnFile, pCrAckPkt, pSendResd);
                        }
                }

                if (addrLock)
                {
                        CTEFreeLock (&pSpxAddr->sa_Lock, lockHandle);
                        //      We should return in this if, else addrLock should be set to
                        //      FALSE.
                }

                //      Deref the connection
                SpxConnFileDereference(pSpxConnFile, CFREF_ADDR);

                //      Deref the address
                SpxAddrDereference (pSpxAddr, AREF_LOOKUP);
                return;
        }

        do
        {
                //      New connection request:
                //      Assume we will be able to accept it and allocate a packet for the ack.
                //      Walk list of listening connections if any.

                pSpxRefFile             = NULL;
                if ((pSpxConnFile = pSpxAddr->sa_ListenConnList) != NULL)
                {
                        PTDI_REQUEST_KERNEL_LISTEN              pParam;

                        DBGPRINT(RECEIVE, INFO,
                                        ("SpxConnIndicate: Listen available!\n"));

                        //      dequeue connection
                        pSpxAddr->sa_ListenConnList = pSpxConnFile->scf_Next;

                        CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);

                        CTEAssert(!IsListEmpty(&pSpxConnFile->scf_ReqLinkage));
                        pListenReq = LIST_ENTRY_TO_REQUEST(pSpxConnFile->scf_ReqLinkage.Flink);
                        pParam  = (PTDI_REQUEST_KERNEL_LISTEN)REQUEST_PARAMETERS(pListenReq);

                        //      if autoaccept, acceptIrp = listenIrp, get connection id and
                        //      process as we do for an indication. As the connection has a
                        //      listen posted on it, it must have a reference for it.
                        //
                        //      if !autoaccept, we need to complete the listen irp.
                        delayAccept = (BOOLEAN)((pParam->RequestFlags & TDI_QUERY_ACCEPT) != 0);
                        if (delayAccept)
                        {
                                //      Remove the listen irp and prepare for completion.
                                //      NOTE!! Here we do not remove the listen reference. This will
                                //                 be removed if disconnect happens, or if accept
                                //                 happens, it is transferred to being ref for connection
                                //                 being active.
                                RemoveEntryList(REQUEST_LINKAGE(pListenReq));
                                REQUEST_STATUS(pListenReq)              = STATUS_SUCCESS;
                                REQUEST_INFORMATION(pListenReq) = 0;
                        }

                        //      Are we ok with spx2?
                        if (!(SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_SPX2)) ||
                                !fSpx2)
                        {
                                //      We better use spx only.
                                SPX_CONN_RESETFLAG(pSpxConnFile,
                                                                        (SPX_CONNFILE_SPX2 | SPX_CONNFILE_NEG));
                                fSpx2 = fNeg = FALSE;
                        }
                        CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);

                        connectAccepted = TRUE;
            tdiListen           = TRUE;
                }
                else
                {
                        //      No listens available. Check for connect handlers.
                        //      Walk list of address files indicating to each until accepted.
                        for (pSpxAddrFile = pSpxAddr->sa_AddrFileList;
                                 pSpxAddrFile != NULL;
                                 pSpxAddrFile = pSpxAddrFile->saf_Next)
                        {
                                if ((pSpxAddrFile->saf_Flags & (SPX_ADDRFILE_CLOSING |
                                                                                                SPX_ADDRFILE_CONNIND)) ||
                                        ((connHandler = pSpxAddrFile->saf_ConnHandler) == NULL))
                                {
                                        continue;
                                }

                                //      Connect indication in progress, drop all subsequent.
                                pSpxAddrFile->saf_Flags |= SPX_ADDRFILE_CONNIND;

                                connHandlerCtx = pSpxAddrFile->saf_ConnHandlerCtx;
                                SpxAddrFileLockReference(pSpxAddrFile, AFREF_INDICATION);
                                CTEFreeLock(&pSpxAddr->sa_Lock, lockHandle);
                                addrLock        = FALSE;

                                if (pSpxRefFile)
                                {
                                        SpxAddrFileDereference(pSpxRefFile, AFREF_INDICATION);
                                        pSpxRefFile = NULL;
                                }

                                //      Make the indication. We are always returned an accept irp on
                                //      indication. Else we fail to accept the connection.
                                status = (*connHandler)(
                                                        connHandlerCtx,
                                                        sizeof(srcIpxAddr),
                                                        (PVOID)&srcIpxAddr,
                                                        0,                      // User data length
                                                        NULL,                   // User data
                                                        0,                      // Option length
                                                        NULL,                   // Options
                                                        &connCtx,
                                                        &acceptIrp);

                                DBGPRINT(RECEIVE, DBG,
                                                ("SpxConn: indicate status %lx.%lx\n",
                                                        status, acceptIrp));

                                CTEGetLock (&pSpxAddr->sa_Lock, &lockHandle);
                                addrLock = TRUE;
                                pSpxAddrFile->saf_Flags &= ~SPX_ADDRFILE_CONNIND;

                                if (status == STATUS_MORE_PROCESSING_REQUIRED)
                                {
    				        NTSTATUS retStatus; 

                                        CTEAssert(acceptIrp != NULL);
					
					retStatus = spxPrepareIrpForCancel(acceptIrp);

					if (!NT_SUCCESS(retStatus)) {
                                             
					    // Copy from the failure case below. [TC] 
                                            if (acceptIrp) 
                                            {
                                                IoCompleteRequest (acceptIrp, IO_NETWORK_INCREMENT);
                                            }      

                                            pSpxRefFile     = pSpxAddrFile;
                                            
					    // Shall we close the connection request and listion object here? 

					    break;
					}
                                        //  Find the connection and accept the connection using that
                                        //      connection object.
                                        SpxConnFileReferenceByCtxLock(
                                                pSpxAddrFile,
                                                connCtx,
                                                &pSpxConnFile,
                                                &status);

                                        if (!NT_SUCCESS(status))
                                        {
                                                //      The connection object is closing, or is not found
                                                //      in our list. The accept irp must have had the same
                                                //      connection object. AFD isnt behaving well.
                                                //  KeBugCheck(0);
                                            
                                            // The code bugchecked (as commented out above).
                                            // Now, we just return error to the TDI client and return from here.
                                            
                                            if (acceptIrp) 
                                            {

                                                acceptIrp->IoStatus.Status = STATUS_ADDRESS_NOT_ASSOCIATED;
                                                IoCompleteRequest (acceptIrp, IO_NETWORK_INCREMENT);

                                            }      

                                            pSpxRefFile     = pSpxAddrFile;
                                            break;

                                        }

                                        //      Only for debugging.
                                        SpxConnFileTransferReference(
                                                pSpxConnFile,
                                                CFREF_BYCTX,
                                                CFREF_VERIFY);

                                        pListenReq      = SpxAllocateRequest(
                                                                        SpxDevice,
                                                                        acceptIrp);

                                        IF_NOT_ALLOCATED(pListenReq)
                                        {
                                                acceptIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                                                IoCompleteRequest (acceptIrp, IO_NETWORK_INCREMENT);

                                                //      Setup for dereference
                                                pSpxRefFile     = pSpxAddrFile;
                                                break;
                                        }

                                        InsertTailList(
                                                &pSpxConnFile->scf_ReqLinkage,
                                                REQUEST_LINKAGE(pListenReq));

                                        //      Setup for dereference
                                        pSpxRefFile             = pSpxAddrFile;
                                        connectAccepted = TRUE;

                                        //      See if this connection is to be a spx2 connection.
                                        SPX_CONN_RESETFLAG(pSpxConnFile,
                                                                                (SPX_CONNFILE_SPX2      |
                                                                                 SPX_CONNFILE_NEG       |
                                                                                 SPX_CONNFILE_STREAM));

                                        if ((pSpxAddrFile->saf_Flags & SPX_ADDRFILE_SPX2) && fSpx2)
                                        {
                                                SPX_CONN_SETFLAG(
                                                        pSpxConnFile, (SPX_CONNFILE_SPX2 | SPX_CONNFILE_NEG));
                                        }
                                        else
                                        {
                                                fSpx2 = fNeg = FALSE;
                                        }

                                        if (pSpxAddrFile->saf_Flags & SPX_ADDRFILE_STREAM)
                                        {
                                                SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_STREAM);
                                        }

                                        if (pSpxAddrFile->saf_Flags & SPX_ADDRFILE_NOACKWAIT)
                                        {
                                                DBGPRINT(CONNECT, ERR,
                                                                ("spxConnHandleConnReq: NOACKWAIT requested %lx\n",
                                                                        pSpxConnFile));

                                                SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_NOACKWAIT);
                                        }

                                        if (pSpxAddrFile->saf_Flags & SPX_ADDRFILE_IPXHDR)
                                        {
                                                DBGPRINT(CONNECT, ERR,
                                                                ("spxConnHandleConnReq: IPXHDR requested %lx\n",
                                                                        pSpxConnFile));

                                                SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_IPXHDR);
                                        }

                                        break;
                                }
                                else
                                {
                                        //      We are not going to accept the connection on this address.
                                        //      Try next one.
                                        pSpxRefFile = pSpxAddrFile;
                                        continue;
                                }
                        }
                }

        } while (FALSE);

        if (addrLock)
        {
                CTEFreeLock (&pSpxAddr->sa_Lock, lockHandle);
                //      No need for flag from this point on.
                //      addrLock        = FALSE;
        }

        if (pSpxRefFile)
        {
                SpxAddrFileDereference(pSpxRefFile, AFREF_INDICATION);
                pSpxRefFile = NULL;
        }

        if (connectAccepted)
        {
                CTEGetLock (&SpxDevice->dev_Lock, &lockHandleDev);
                CTEGetLock (&pSpxAddr->sa_Lock, &lockHandle);
                CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);

                if (((USHORT)PARAM(CONFIG_WINDOW_SIZE) == 0) ||
            ((USHORT)PARAM(CONFIG_WINDOW_SIZE) > MAX_WINDOW_SIZE))
                {
            PARAM(CONFIG_WINDOW_SIZE) = DEFAULT_WINDOW_SIZE;
                }

                pSpxConnFile->scf_LocalConnId   = spxConnGetId();
                pSpxConnFile->scf_RemConnId             = srcConnId;
        pSpxConnFile->scf_SendSeqNum    = 0;
                pSpxConnFile->scf_RecvSeqNum    = 0;
                pSpxConnFile->scf_RecdAckNum    = 0;
                pSpxConnFile->scf_RetrySeqNum   = 0;
        pSpxConnFile->scf_SentAllocNum  = (USHORT)(PARAM(CONFIG_WINDOW_SIZE) - 1);
                pSpxConnFile->scf_RecdAllocNum  = allocNum;

                DBGPRINT(CONNECT, INFO,
                                ("spxConnHandleConnReq: %lx CONN L.R %lx.%lx\n",
                                        pSpxConnFile,
                                        pSpxConnFile->scf_LocalConnId,
                                        pSpxConnFile->scf_RemConnId));

                pSpxConnFile->scf_LocalTarget   = *pRemoteAddr;
                pSpxConnFile->scf_AckLocalTarget= *pRemoteAddr;
                SpxCopyIpxAddr(pIpxSpxHdr, pSpxConnFile->scf_RemAddr);

                //      Set max packet size in connection
                SPX_MAX_PKT_SIZE(pSpxConnFile, (fSpx2 && fNeg), fSpx2, pIpxSpxHdr->hdr_SrcNet);

                DBGPRINT(CONNECT, DBG,
                                ("spxConnHandleConnReq: Accept connect req on %lx.%lx..%lx.%lx!\n",
                                        pSpxConnFile, pSpxConnFile->scf_LocalConnId,
                                        pSpxConnFile->scf_RecdAllocNum, pSpxConnFile->scf_MaxPktSize));

                //      Aborts must now deal with the lists. Need this as Accept has to
                //      deal with it.
                //      Put in non-inactive list. All processing now is equivalent to
                //      that when a listen is completed on a connection.
                if ((!tdiListen) && (!NT_SUCCESS(spxConnRemoveFromList(
                                                                &pSpxAddr->sa_InactiveConnList,
                                                                pSpxConnFile))))
                {
                        //      Should never happen!
                        KeBugCheck(0);
                }

                SPX_INSERT_ADDR_ACTIVE(pSpxAddr, pSpxConnFile);

                //      Insert in the global connection tree on device.
                spxConnInsertIntoGlobalActiveList(
                        pSpxConnFile);

                SPX_CONN_SETFLAG(pSpxConnFile,
                                                        ((fNeg  ? SPX_CONNFILE_NEG : 0) |
                                                         (fSpx2 ? SPX_CONNFILE_SPX2: 0)));

                //
                // If this was a post-inactivated file, clear the disconnect flags
                //
                if ((SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN) &&
                    (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_INACTIVATED)) {

                    SPX_DISC_SETSTATE(pSpxConnFile, 0);
                }
#if 0
                //
                // Make sure that this connection got a local disconnect if it was an SPXI
                // connection earlier, in response to a TDI_DISCONNECT_RELEASE.
                //

                CTEAssert(pSpxConnFile->scf_RefTypes[CFREF_DISCWAITSPX] == 0);
#endif

                SPX_MAIN_SETSTATE(pSpxConnFile, SPX_CONNFILE_LISTENING);
                SPX_LISTEN_SETSTATE(pSpxConnFile, (delayAccept ? SPX_LISTEN_RECDREQ : 0));

                if (!delayAccept)
                {
                        spxConnAcceptCr(
                                        pSpxConnFile,
                                        pSpxAddr,
                                        lockHandleDev,
                                        lockHandle,
                                        lockHandleConn);
                }
                else
                {
                        //      Release the locks.
                        CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
                        CTEFreeLock (&pSpxAddr->sa_Lock, lockHandle);
                        CTEFreeLock (&SpxDevice->dev_Lock, lockHandleDev);

                        //      Complete the listen irp. Note reference is not removed. Done when
                        //      accept is posted.
                        SpxCompleteRequest(pListenReq);
                }
        } else {
        ++SpxDevice->dev_Stat.NoListenFailures;
    }

        //      Deref the address
        SpxAddrDereference (pSpxAddr, AREF_LOOKUP);
        return;
}




VOID
spxConnHandleSessPktFromClient(
    IN  PIPXSPX_HDR         pIpxSpxHdr,
        IN  PIPX_LOCAL_TARGET   pRemoteAddr,
        IN      PSPX_CONN_FILE          pSpxConnFile
        )
/*++

Routine Description:

        Packet received from the client side of the connection.
        Handles:
                Session Negotiate
                Sends Session Setup, when recd, handles SS Ack

        STATE MACHINE:

                                                RR
                                           /  \
                                          /    \ ReceivedAck(SPX1Connection)
                                         /              \
                                        /                \--------> ACTIVE
                               /                     ^
                        Send  /                                  |
                        ACK  /                                   |
                                /                                        |
                           / RecvNeg/NoNeg           |
                          /  SendSS                              |
                        SA--------->SS---------------+
                              ^         |          SSAckRecv
                                  |     |
                              +-----+
                                        RecvNeg

        RR - Received Connect Request
        SA - Sent CR Ack
        SS - Sent Session Setup

        We move from SA to SS when connection is not negotiatiable and we
        immediately send the SS, or when we receive negotiate packet and send the neg
    ack and the session setup.

        Note we could receive a negotiate packet when in SS, as our ack to the
        negotiate could have been dropped. We deal with this.

Arguments:


Return Value:


--*/

{
        PNDIS_PACKET            pSnAckPkt, pSsPkt = NULL;
        PSPX_SEND_RESD          pSendResd, pSsSendResd;
        USHORT                  srcConnId, destConnId, pktLen, seqNum = 0, negSize, ackNum, allocNum;
        CTELockHandle           lockHandleConn, lockHandleAddr, lockHandleDev;
        BOOLEAN                 locksHeld = FALSE;

        GETSHORT2SHORT(&pktLen, &pIpxSpxHdr->hdr_PktLen);
        GETSHORT2SHORT(&destConnId, &pIpxSpxHdr->hdr_DestConnId);
        GETSHORT2SHORT(&seqNum, &pIpxSpxHdr->hdr_SeqNum);
        GETSHORT2SHORT(&ackNum, &pIpxSpxHdr->hdr_AckNum);
        GETSHORT2SHORT(&allocNum, &pIpxSpxHdr->hdr_AllocNum);

        //      We keep and use the remote id in the net format. This maintains the
        //      0x0 and 0xFFFF to be as in the host format.
        srcConnId       = *(USHORT UNALIGNED *)&pIpxSpxHdr->hdr_SrcConnId;

         //     If spx2 we convert neg size field too
        if (pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_SPX2)
        {
                GETSHORT2SHORT(&negSize, &pIpxSpxHdr->hdr_NegSize);
                CTEAssert(negSize > 0);
        }

        //      Grab all three locks
        CTEGetLock(&SpxDevice->dev_Lock, &lockHandleDev);
        CTEGetLock(pSpxConnFile->scf_AddrFile->saf_AddrLock, &lockHandleAddr);
        CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);
        locksHeld = TRUE;

        DBGPRINT(CONNECT, INFO,
                        ("spxConnHandleSessPktFromClient: %lx\n", pSpxConnFile));

        //      Check substate
        switch (SPX_LISTEN_STATE(pSpxConnFile))
        {
        case SPX_LISTEN_RECDREQ:

                //      Do nothing.
                break;

        case SPX_LISTEN_SETUP:

                //      Is this a setup ack? If so, yippee. Our ack to a negotiate packet
                //      could have been dropped, and so we could also get a negotiate packet
                //      in that case. If that happens, fall through.
                //      Verify Ss Ack
                if (!SPX2_CONN(pSpxConnFile) ||
                        (pktLen != MIN_IPXSPX2_HDRSIZE) ||
                        ((pIpxSpxHdr->hdr_ConnCtrl &
                                (SPX_CC_SYS | SPX_CC_SPX2)) !=
                                        (SPX_CC_SYS | SPX_CC_SPX2))     ||
                        (pIpxSpxHdr->hdr_DataType != 0) ||
                        (srcConnId == 0) ||
                        (srcConnId == 0xFFFF) ||
                        (srcConnId  != pSpxConnFile->scf_RemConnId) ||
                        (destConnId == 0) ||
                        (destConnId == 0xFFFF) ||
                        (destConnId != pSpxConnFile->scf_LocalConnId) ||
                        (seqNum != 0))
                {
                        DBGPRINT(RECEIVE, DBG,
                                        ("SpxConnSysPacket: VerifySSACK Failed Checking SN %lx.%lx\n",
                                                srcConnId, destConnId));

                        //      Fall through to see if this is a neg packet
                        if (!(SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_NEG)))
                        {
                                break;
                        }
                }
                else
                {
                        DBGPRINT(CONNECT, DBG,
                                        ("spxConnHandleSessPktFromClient: Recd SSACK %lx\n",
                                                pSpxConnFile));

                        spxConnCompleteConnect(
                                pSpxConnFile,
                                lockHandleDev,
                                lockHandleAddr,
                                lockHandleConn);

                        locksHeld  = FALSE;
                        break;
                }

        case SPX_LISTEN_SENTACK:

                //      We expect a negotiate packet.
                //      We should have asked for SPX2/NEG to begin with.
                //      Verify Sn
                if (((pSpxConnFile->scf_Flags & (SPX_CONNFILE_SPX2 | SPX_CONNFILE_NEG)) !=
                                                                                (SPX_CONNFILE_SPX2 | SPX_CONNFILE_NEG)) ||
                        ((pIpxSpxHdr->hdr_ConnCtrl &
                                (SPX_CC_ACK | SPX_CC_SYS | SPX_CC_NEG | SPX_CC_SPX2)) !=
                                        (SPX_CC_ACK | SPX_CC_SYS | SPX_CC_NEG | SPX_CC_SPX2))   ||
                        (pIpxSpxHdr->hdr_DataType != 0) ||
                        (srcConnId == 0) ||
                        (srcConnId == 0xFFFF) ||
                        (srcConnId  != pSpxConnFile->scf_RemConnId) ||
                        (destConnId == 0) ||
                        (destConnId == 0xFFFF) ||
                        (destConnId != pSpxConnFile->scf_LocalConnId) ||
                        (seqNum != 0) ||
                        ((negSize < SPX_NEG_MIN) ||
                         (negSize > SPX_NEG_MAX)))
                {
                        DBGPRINT(RECEIVE, ERR,
                                        ("SpxConnSysPacket: VerifySN Failed %lx.%lx\n",
                                                srcConnId, destConnId));

                        break;
                }

                //      Remember max packet size in connection.
                pSpxConnFile->scf_MaxPktSize = negSize;
                CTEAssert(negSize > 0);

                //      Build sn ack, abort if we fail
                SpxPktBuildSnAck(
                        pSpxConnFile,
                        &pSnAckPkt,
                        SPX_SENDPKT_IPXOWNS | SPX_SENDPKT_DESTROY);

                if (pSnAckPkt == NULL)
                {
                        spxConnAbortConnect(
                                pSpxConnFile,
                                STATUS_INSUFFICIENT_RESOURCES,
                                lockHandleDev,
                                lockHandleAddr,
                                lockHandleConn);

                        locksHeld  = FALSE;
                        break;
                }

                DBGPRINT(CONNECT, DBG,
                                ("spxConnHandleSessPktFromClient: Sending SNACK %lx\n",
                                        pSpxConnFile));

                //      Queue in the packet.
                SpxConnQueueSendPktTail(pSpxConnFile, pSnAckPkt);

                //      The session packet should already be on queue.
                if (!spxConnGetPktByType(
                                pSpxConnFile,
                                SPX_TYPE_SS,
                                FALSE,
                                &pSsPkt))
                {
                        KeBugCheck(0);
                }

                DBGPRINT(CONNECT, DBG,
                                ("spxConnHandleSessPktFromClient: Sending SS %lx\n",
                                        pSpxConnFile));

                pSsSendResd     = (PSPX_SEND_RESD)(pSsPkt->ProtocolReserved);

                //      We need to resend the packet
                if ((pSsSendResd->sr_State & SPX_SENDPKT_IPXOWNS) != 0)
                {
                        //      Try next time.
                        pSsPkt = NULL;
                }
                else
                {
                        //      Set the size to the neg size indicated in connection.
                        //      This could be lower than the size the packet was build
                        //      with originally. But will never be higher.
                        pSsSendResd->sr_State   |= SPX_SENDPKT_IPXOWNS;
                        spxConnSetNegSize(
                                pSsPkt,
                                pSpxConnFile->scf_MaxPktSize - MIN_IPXSPX2_HDRSIZE);
                }

                //      If we are actually LISTEN_SETUP, then send the ss packet also.
                //      We need to start the connect timer to resend the ss pkt.
                if (SPX_LISTEN_STATE(pSpxConnFile) == SPX_LISTEN_SENTACK)
                {
                        if ((pSpxConnFile->scf_CTimerId =
                                        SpxTimerScheduleEvent(
                                                spxConnConnectTimer,
                                                PARAM(CONFIG_CONNECTION_TIMEOUT) * HALFSEC_TO_MS_FACTOR,
                                                pSpxConnFile)) == 0)
                        {
                                spxConnAbortConnect(
                                        pSpxConnFile,
                                        STATUS_INSUFFICIENT_RESOURCES,
                                        lockHandleDev,
                                        lockHandleAddr,
                                        lockHandleConn);

                                locksHeld  = FALSE;
                                break;
                        }

                        //      Reference connection for the timer
                        SpxConnFileLockReference(pSpxConnFile, CFREF_VERIFY);

                        SPX_LISTEN_SETSTATE(pSpxConnFile, SPX_LISTEN_SETUP);
                        SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_C_TIMER);
                        pSpxConnFile->scf_CRetryCount   = PARAM(CONFIG_CONNECTION_COUNT);
                }
                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
                CTEFreeLock(pSpxConnFile->scf_AddrFile->saf_AddrLock, lockHandleAddr);
                CTEFreeLock(&SpxDevice->dev_Lock, lockHandleDev);
                locksHeld  = FALSE;

                //      Send ack packet
                pSendResd       = (PSPX_SEND_RESD)(pSnAckPkt->ProtocolReserved);
                SPX_SENDPACKET(pSpxConnFile, pSnAckPkt, pSendResd);

                //      If we have to send the session setup packet, send that too.
                if (pSsPkt != NULL)
                {
                        pSendResd       = (PSPX_SEND_RESD)(pSsPkt->ProtocolReserved);
                        SPX_SENDPACKET(pSpxConnFile, pSsPkt, pSendResd);
                }

                break;

        default:

                //      Ignore
                DBGPRINT(RECEIVE, DBG,
                                ("SpxConnSysPacket: UNKNOWN %lx.%lx\n",
                                        srcConnId, destConnId));

                break;
        }

        if (locksHeld)
        {
                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
                CTEFreeLock(pSpxConnFile->scf_AddrFile->saf_AddrLock, lockHandleAddr);
                CTEFreeLock(&SpxDevice->dev_Lock, lockHandleDev);
        }

        return;
}




VOID
spxConnHandleSessPktFromSrv(
    IN  PIPXSPX_HDR         pIpxSpxHdr,
        IN  PIPX_LOCAL_TARGET   pRemoteAddr,
        IN      PSPX_CONN_FILE          pSpxConnFile
        )
/*++

Routine Description:

        Packet received from the server side of the connection. This will both
        release the lock and dereference the connection as it sees fit.

        STATE MACHINE:

                                                SR--CTimerExpires-->IDLE
                                           /| \
                                          / |  \ ReceivedAck(SPX1Connection)
                                         /      |       \
                                        /       |        \--------> ACTIVE
                        (Neg)  /    |                ^
                        Send  /         |RecvAck                 |
                        SN       /      |NoNeg                   |
                                /               |                                |
                           /            |                                |
                          /             v                                |
                        SN--------->WS---------------+
                          RecvSNAck                RecvSS

        SR - Sent Connect request
        SN - Sent Session Negotiate
        WS - Waiting for session setup packet

Arguments:


Return Value:


--*/
{
        PSPX_SEND_RESD          pSendResd;
        BOOLEAN                         fNeg, fSpx2;
        USHORT                          srcConnId, destConnId,
                                                pktLen, seqNum, negSize = 0, ackNum, allocNum;
        CTELockHandle           lockHandleConn, lockHandleAddr, lockHandleDev;
        BOOLEAN                         cTimerCancelled = FALSE, fAbort = FALSE, locksHeld = FALSE;
        PNDIS_PACKET        pSsAckPkt, pSnPkt, pPkt = NULL;

        //      We should get a CR Ack, or if our substate is sent session neg
        //      we should get a session neg ack, or if we are waiting for session
        //      setup, we should get one of those.

        fSpx2   = (BOOLEAN)(pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_SPX2);
        fNeg    = (BOOLEAN)(fSpx2 && (pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_NEG));

        GETSHORT2SHORT(&pktLen, &pIpxSpxHdr->hdr_PktLen);
        GETSHORT2SHORT(&destConnId, &pIpxSpxHdr->hdr_DestConnId);
        GETSHORT2SHORT(&seqNum, &pIpxSpxHdr->hdr_SeqNum);
        GETSHORT2SHORT(&ackNum, &pIpxSpxHdr->hdr_AckNum);
        GETSHORT2SHORT(&allocNum, &pIpxSpxHdr->hdr_AllocNum);

        //      We keep and use the remote id in the net format. This maintains the
        //      0x0 and 0xFFFF to be as in the host format.
        srcConnId       = *(USHORT UNALIGNED *)&pIpxSpxHdr->hdr_SrcConnId;

        //      If spx2 we convert neg size field too
        if (pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_SPX2)
        {
                GETSHORT2SHORT(&negSize, &pIpxSpxHdr->hdr_NegSize);
                CTEAssert(negSize > 0);
        }

        //      Grab all three locks
        CTEGetLock(&SpxDevice->dev_Lock, &lockHandleDev);
        CTEGetLock(pSpxConnFile->scf_AddrFile->saf_AddrLock, &lockHandleAddr);
        CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);
        locksHeld = TRUE;

        DBGPRINT(CONNECT, INFO,
                        ("spxConnHandleSessPktFromSrv: %lx\n", pSpxConnFile));

        //      Check substate
        switch (SPX_CONNECT_STATE(pSpxConnFile))
        {
        case SPX_CONNECT_SENTREQ:

                //      Check if this qualifies as the ack.
                //      Verify CR Ack
                if ((pIpxSpxHdr->hdr_DataType != 0)     ||
                        (srcConnId == 0) ||
                        (srcConnId == 0xFFFF) ||
                        (destConnId == 0) ||
                        (destConnId == 0xFFFF) ||
                        (seqNum != 0) ||
                        (ackNum != 0) ||
                        ((pktLen  != MIN_IPXSPX_HDRSIZE) &&
                                ((pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_SPX2) &&
                                 (pktLen  != MIN_IPXSPX2_HDRSIZE))) ||
                        ((pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_SPX2) &&
                                ((negSize < SPX_NEG_MIN) ||
                                 (negSize > SPX_NEG_MAX))))
                {
                        DBGPRINT(CONNECT, ERR,
                                        ("spxConnHandleSessPktFromSrv: CRAck Invalid %lx %lx.%lx.%lx\n",
                                                pSpxConnFile,
                                                pktLen, negSize, pIpxSpxHdr->hdr_ConnCtrl));

                        break;
                }

                //      From current spx code base:
                //      Do we need to send an ack to this ack? In case of SPX only?
                //      What if this ack is dropped? We need to send an ack, if in future
                //      we get CONNECT REQ Acks, until we reach active?
                //      * If they want an ack schedule it. The normal case is for this not
                //      * to happen, but some Novell mainframe front ends insist on having
                //      * this. And technically, it is OK for them to do this.

                DBGPRINT(CONNECT, INFO,
                                ("spxConnHandleSessPktFromSrv: Recd CRACK %lx\n", pSpxConnFile));

                //      Grab the remote alloc num/conn id (in net format)
        pSpxConnFile->scf_SendSeqNum    = 0;
                pSpxConnFile->scf_RecvSeqNum    = 0;
                pSpxConnFile->scf_RecdAckNum    = 0;
                pSpxConnFile->scf_RemConnId         = srcConnId;
                pSpxConnFile->scf_RecdAllocNum  = allocNum;

        // If we have been looking for network 0, which means the
        // packets were sent on all NIC IDs, update our local
        // target now that we have received a response.

#if     defined(_PNP_POWER)
                if (pSpxConnFile->scf_LocalTarget.NicHandle.NicId == (USHORT)ITERATIVE_NIC_ID) {
#else
                if (*((UNALIGNED ULONG *)(pSpxConnFile->scf_RemAddr)) == 0) {
#endif  _PNP_POWER
            pSpxConnFile->scf_LocalTarget = *pRemoteAddr;
                        pSpxConnFile->scf_AckLocalTarget= *pRemoteAddr;
        }

                DBGPRINT(CONNECT, INFO,
                                ("spxConnHandleSessPktFromSrv: %lx CONN L.R %lx.%lx\n",
                                        pSpxConnFile,
                                        pSpxConnFile->scf_LocalConnId,
                                        pSpxConnFile->scf_RemConnId));

                if (!fSpx2 || !fNeg)
                {
                        cTimerCancelled = SpxTimerCancelEvent(
                                                                pSpxConnFile->scf_CTimerId, FALSE);

                        SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_C_TIMER);

                        if ((pSpxConnFile->scf_WTimerId =
                                        SpxTimerScheduleEvent(
                                                spxConnWatchdogTimer,
                                                PARAM(CONFIG_KEEPALIVE_TIMEOUT) * HALFSEC_TO_MS_FACTOR,
                                                pSpxConnFile)) == 0)
                        {
                                fAbort = TRUE;
                                break;
                        }

                        //      Reference transferred to watchdog timer.
            if (cTimerCancelled)
                        {
                                cTimerCancelled = FALSE;
                        }
                        else
                        {
                                //      Reference connection for the timer
                                SpxConnFileLockReference(pSpxConnFile, CFREF_VERIFY);
                        }

                        SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER);
                        pSpxConnFile->scf_WRetryCount = PARAM(CONFIG_KEEPALIVE_COUNT);
                }

                //      Set max packet size, assume not spx2 or !neg, so pass in FALSE
                SPX_MAX_PKT_SIZE(pSpxConnFile, FALSE, FALSE, pIpxSpxHdr->hdr_SrcNet);

                DBGPRINT(CONNECT, DBG,
                                ("spxConnHandleSessPSrv: Accept connect req on %lx.%lx.%lx.%lx!\n",
                                        pSpxConnFile, pSpxConnFile->scf_LocalConnId,
                                        pSpxConnFile->scf_RecdAllocNum, pSpxConnFile->scf_MaxPktSize));

                if (!fSpx2)
                {
                        //      Reset spx2 flags.
                        SPX_CONN_RESETFLAG(pSpxConnFile, (SPX_CONNFILE_SPX2     | SPX_CONNFILE_NEG));

                        //      Complete connect request, this free the lock.
                        //      Cancels tdi timer too. Sets all necessary flags.
                        spxConnCompleteConnect(
                                pSpxConnFile,
                                lockHandleDev,
                                lockHandleAddr,
                                lockHandleConn);

                        locksHeld  = FALSE;
                        break;
                }

                if (!fNeg)
                {
                        //      Goto W_SETUP
                        //      Reset all connect related flags, also spx2/neg flags.
                        SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_NEG);
                        SPX_CONNECT_SETSTATE(pSpxConnFile, SPX_CONNECT_W_SETUP);
                        break;
                }

                //      Reset max packet size. SPX2 and NEG.
                SPX_MAX_PKT_SIZE(pSpxConnFile, TRUE, TRUE, pIpxSpxHdr->hdr_SrcNet);

                CTEAssert(negSize > 0);
                CTEAssert(pSpxConnFile->scf_MaxPktSize > 0);
                pSpxConnFile->scf_MaxPktSize =
                        MIN(negSize, pSpxConnFile->scf_MaxPktSize);

                pSpxConnFile->scf_MaxPktSize = (USHORT)
                        MIN(pSpxConnFile->scf_MaxPktSize, PARAM(CONFIG_MAX_PACKET_SIZE));

                //      For SPX2 with negotiation, we set up sneg packet and move to
                //      SPX_CONNECT_NEG.
                SpxPktBuildSn(
                        pSpxConnFile,
                        &pSnPkt,
                        SPX_SENDPKT_IPXOWNS);

                if (pSnPkt == NULL)
                {
                        fAbort = TRUE;
                        break;
                }

                //      Queue in packet
                SpxConnQueueSendPktTail(pSpxConnFile, pSnPkt);

                DBGPRINT(CONNECT, DBG,
                                ("spxConnHandleSessPktFromSrv: Sending SN %lx\n",
                                        pSpxConnFile));

                //      Reset retry count for connect timer
                pSpxConnFile->scf_CRetryCount   = PARAM(CONFIG_CONNECTION_COUNT);

                //      Change state.
                SPX_CONNECT_SETSTATE(pSpxConnFile, SPX_CONNECT_NEG);

                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
                CTEFreeLock(pSpxConnFile->scf_AddrFile->saf_AddrLock, lockHandleAddr);
                CTEFreeLock(&SpxDevice->dev_Lock, lockHandleDev);
                locksHeld = FALSE;

                //      Send the packet
                pSendResd       = (PSPX_SEND_RESD)(pSnPkt->ProtocolReserved);
                SPX_SENDPACKET(pSpxConnFile, pSnPkt, pSendResd);
                break;

        case SPX_CONNECT_NEG:

                //      We expect a session neg ack.
                //      We should have asked for SPX2/NEG to begin with.
                //      Verify SN Ack
                if (((pSpxConnFile->scf_Flags & (SPX_CONNFILE_SPX2 | SPX_CONNFILE_NEG)) !=
                                                                                (SPX_CONNFILE_SPX2 | SPX_CONNFILE_NEG)) ||
                        (pktLen != MIN_IPXSPX2_HDRSIZE) ||
                        ((pIpxSpxHdr->hdr_ConnCtrl &
                                (SPX_CC_SYS | SPX_CC_NEG | SPX_CC_SPX2)) !=
                                        (SPX_CC_SYS | SPX_CC_NEG | SPX_CC_SPX2))        ||
                        (pIpxSpxHdr->hdr_DataType != 0) ||
                        (srcConnId == 0) ||
                        (srcConnId == 0xFFFF) ||
                        (srcConnId  != pSpxConnFile->scf_RemConnId) ||
                        (destConnId == 0) ||
                        (destConnId == 0xFFFF) ||
                        (destConnId != pSpxConnFile->scf_LocalConnId) ||
                        (seqNum != 0))
                {
                        DBGPRINT(RECEIVE, ERR,
                                        ("SpxConnSysPacket: VerifySNACK Failed %lx.%lx\n",
                                                srcConnId, destConnId));

                        break;
                }

                DBGPRINT(CONNECT, DBG,
                                ("spxConnHandleSessPktFromSrv: Recd SNACK %lx %lx.%lx\n",
                                pSpxConnFile, negSize, pSpxConnFile->scf_MaxPktSize));

                if (negSize > pSpxConnFile->scf_MaxPktSize)
                        negSize = pSpxConnFile->scf_MaxPktSize;

                //      Get the size to use
                if (negSize <= pSpxConnFile->scf_MaxPktSize)
                {
                        pSpxConnFile->scf_MaxPktSize = negSize;
                        if (!spxConnGetPktByType(
                                        pSpxConnFile,
                                        SPX_TYPE_SN,
                                        FALSE,
                                        &pPkt))
                        {
                                KeBugCheck(0);
                        }

                        SpxConnDequeueSendPktLock(pSpxConnFile, pPkt);

                        pSendResd       = (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
                        if ((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) != 0)
                        {
                                //      Set abort flag and reference conn for the pkt.
                                pSendResd->sr_State     |= SPX_SENDPKT_ABORT;
                                SpxConnFileLockReference(pSpxConnFile, CFREF_ABORTPKT);
                        }
                        else
                        {
                                //      Free the negotiate packet
                                SpxPktSendRelease(pPkt);
                        }

                        CTEAssert(pSpxConnFile->scf_Flags & SPX_CONNFILE_C_TIMER);
                        cTimerCancelled = SpxTimerCancelEvent(
                                                                pSpxConnFile->scf_CTimerId, FALSE);
                        SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_C_TIMER);

                        //      Start the watchdog timer, if fail, we abort.
                        if ((pSpxConnFile->scf_WTimerId =
                                        SpxTimerScheduleEvent(
                                                spxConnWatchdogTimer,
                                                PARAM(CONFIG_KEEPALIVE_TIMEOUT) * HALFSEC_TO_MS_FACTOR,
                                                pSpxConnFile)) == 0)
                        {
                                //      Complete cr with error.
                                fAbort = TRUE;
                                break;
                        }

                        //      Reference goes to watchdog timer.
            if (cTimerCancelled)
                        {
                                cTimerCancelled = FALSE;
                        }
                        else
                        {
                                //      Reference connection for the timer
                                SpxConnFileLockReference(pSpxConnFile, CFREF_VERIFY);
                        }

                        //      We move to the W_SETUP state.
                        SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER);
                        pSpxConnFile->scf_WRetryCount   = PARAM(CONFIG_KEEPALIVE_COUNT);

                        SPX_CONNECT_SETSTATE(pSpxConnFile, SPX_CONNECT_W_SETUP);
                }

                break;

        case SPX_CONNECT_W_SETUP:

                //      Does this qualify as a session setup packet?
                //      Verify SS
                if (!SPX2_CONN(pSpxConnFile) ||
                        ((pIpxSpxHdr->hdr_ConnCtrl &
                                (SPX_CC_ACK | SPX_CC_SYS | SPX_CC_SPX2)) !=
                                        (SPX_CC_ACK | SPX_CC_SYS | SPX_CC_SPX2))        ||
                        (pIpxSpxHdr->hdr_DataType != 0) ||
                        (srcConnId == 0) ||
                        (srcConnId == 0xFFFF) ||
                        (srcConnId  != pSpxConnFile->scf_RemConnId) ||
                        (destConnId == 0) ||
                        (destConnId == 0xFFFF) ||
                        (destConnId != pSpxConnFile->scf_LocalConnId) ||
                        (seqNum != 0) ||
                        ((negSize < SPX_NEG_MIN) ||
                         (negSize > SPX_NEG_MAX)))
                {
                        DBGPRINT(RECEIVE, ERR,
                                        ("SpxConnSysPacket: VerifySS Failed %lx.%lx, %lx %lx.%lx\n",
                                                srcConnId, destConnId, negSize,
                                                pIpxSpxHdr->hdr_ConnCtrl,
                                                (SPX_CC_ACK | SPX_CC_SYS | SPX_CC_SPX2)));

                        break;
                }

                DBGPRINT(CONNECT, DBG,
                                ("spxConnHandleSessPktFromSrv: Recd SS %lx\n", pSpxConnFile));

                //      Copy remote address over into connection (socket could change)
                SpxCopyIpxAddr(pIpxSpxHdr, pSpxConnFile->scf_RemAddr);

                //      Remember max packet size in connection.
                pSpxConnFile->scf_MaxPktSize = negSize;

                //      Build ss ack, abort if we fail
                SpxPktBuildSsAck(
                        pSpxConnFile,
                        &pSsAckPkt,
                        SPX_SENDPKT_IPXOWNS | SPX_SENDPKT_DESTROY | SPX_SENDPKT_ABORT);

                if (pSsAckPkt == NULL)
                {
                        fAbort = TRUE;
                        break;
                }

                DBGPRINT(CONNECT, DBG,
                                ("spxConnHandleSessPktFromSrv: Sending SSACK %lx\n",
                                        pSpxConnFile));

                SpxConnFileLockReference(pSpxConnFile, CFREF_ABORTPKT);

                //      We dont queue in the pkt as its already marked as abort.
                //      Queue in the packet.
                //      SpxConnQueueSendPktTail(pSpxConnFile, pSsAckPkt);

                //      Complete connect, this releases lock.
                spxConnCompleteConnect(
                        pSpxConnFile,
                        lockHandleDev,
                        lockHandleAddr,
                        lockHandleConn);

                locksHeld = FALSE;

                //      Send ack packet
                pSendResd       = (PSPX_SEND_RESD)(pSsAckPkt->ProtocolReserved);
                SPX_SENDPACKET(pSpxConnFile, pSsAckPkt, pSendResd);
                break;

        default:

                //      Ignore
                DBGPRINT(RECEIVE, DBG,
                                ("SpxConnSysPacket: UNKNOWN %lx.%lx\n",
                                        srcConnId, destConnId));

                break;
        }

        if (fAbort)
        {
                spxConnAbortConnect(
                        pSpxConnFile,
                        STATUS_INSUFFICIENT_RESOURCES,
                        lockHandleDev,
                        lockHandleAddr,
                        lockHandleConn);

                locksHeld  = FALSE;
        }

        if (locksHeld)
        {
                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
                CTEFreeLock(pSpxConnFile->scf_AddrFile->saf_AddrLock, lockHandleAddr);
                CTEFreeLock(&SpxDevice->dev_Lock, lockHandleDev);
        }

        if (cTimerCancelled)
        {
                SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
        }

        return;
}




VOID
spxConnAbortConnect(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      NTSTATUS                        Status,
        IN      CTELockHandle           LockHandleDev,
        IN      CTELockHandle           LockHandleAddr,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:

        This routine abort a connection (both client and server side) in the middle
        of a connection establishment.

        !!! Called with connection lock held, releases lock before return !!!

Arguments:


Return Value:


--*/
{
        PSPX_SEND_RESD          pSendResd;
        PNDIS_PACKET            pPkt;
        PREQUEST                        pRequest  = NULL;
        int                             numDerefs = 0;


        DBGPRINT(CONNECT, DBG,
                        ("spxConnAbortConnect: %lx\n", pSpxConnFile));

#if DBG
        if (!SPX_CONN_CONNECTING(pSpxConnFile) && !SPX_CONN_LISTENING(pSpxConnFile))
        {
                KeBugCheck(0);
        }
#endif

    if (Status == STATUS_INSUFFICIENT_RESOURCES) {  // others should be counted elsewhere
        ++SpxDevice->dev_Stat.LocalResourceFailures;
    }

        //      Free up all the packets
        while ((pSendResd   = pSpxConnFile->scf_SendListHead) != NULL)
        {
                pPkt = (PNDIS_PACKET)CONTAINING_RECORD(
                                                                pSendResd, NDIS_PACKET, ProtocolReserved);

                SpxConnDequeueSendPktLock(pSpxConnFile, pPkt);
                if ((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) == 0)
                {
                        //      Free the packet
                        SpxPktSendRelease(pPkt);
                }
                else
                {
                        //      Set abort flag and reference conn for the pkt.
                        pSendResd->sr_State     |= SPX_SENDPKT_ABORT;
                        SpxConnFileLockReference(pSpxConnFile, CFREF_ABORTPKT);
                }
        }


        //      Cancel all timers
        if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_T_TIMER))
        {
                if (SpxTimerCancelEvent(pSpxConnFile->scf_TTimerId, FALSE))
                {
                        numDerefs++;
                }
                SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_T_TIMER);
        }

        if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_C_TIMER))
        {
                if (SpxTimerCancelEvent(pSpxConnFile->scf_CTimerId, FALSE))
                {
                        numDerefs++;
                }
                SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_C_TIMER);
        }

        if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER))
        {
                if (SpxTimerCancelEvent(pSpxConnFile->scf_WTimerId, FALSE))
                {
                        numDerefs++;
                }
                SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER);
        }

        //      We could be called from disconnect for an accept in which case there
        //      will be no queued request. But we need to remove the reference if there
        //      is no request (an accept/listen irp) and listen state is on.
        CTEAssert(IsListEmpty(&pSpxConnFile->scf_DiscLinkage));
        if (!IsListEmpty(&pSpxConnFile->scf_ReqLinkage))
        {
                pRequest = LIST_ENTRY_TO_REQUEST(pSpxConnFile->scf_ReqLinkage.Flink);
                RemoveEntryList(REQUEST_LINKAGE(pRequest));
                REQUEST_STATUS(pRequest)                = Status;
                REQUEST_INFORMATION(pRequest)   = 0;

                //      Save req in conn for deref to complete.
                pSpxConnFile->scf_ConnectReq = pRequest;

                numDerefs++;
        }
        else if (SPX_CONN_LISTENING(pSpxConnFile))
        {
                numDerefs++;
        }

        //      Bug #20999
        //      Race condition was an abort came in from timer, but the connect state
        //      was left unchanged. Due to an extra ref on the connection from the
        //      aborted cr, the state remained so, and then the cr ack came in, and
        //      a session neg was built and queued on the connection. Although it should
        //      not have been. And we hit the assert in deref where the connection is
        //      being reinitialized. Since this can be called for both listening and
        //      connecting connections, do the below.
        SPX_LISTEN_SETSTATE(pSpxConnFile, 0);
        if (SPX_CONN_CONNECTING(pSpxConnFile))
        {
                SPX_CONNECT_SETSTATE(pSpxConnFile, 0);
        }

        CTEFreeLock (&pSpxConnFile->scf_Lock, LockHandleConn);
        CTEFreeLock (pSpxConnFile->scf_AddrFile->saf_AddrLock, LockHandleAddr);
        CTEFreeLock (&SpxDevice->dev_Lock, LockHandleDev);

        while (numDerefs-- > 0)
        {
                SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
        }

        return;
}



VOID
spxConnCompleteConnect(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      CTELockHandle           LockHandleDev,
        IN      CTELockHandle           LockHandleAddr,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:

        This routine completes a connection (both client and server side)
        !!! Called with connection lock held, releases lock before return !!!

Arguments:


Return Value:


--*/
{
        PREQUEST                        pRequest;
        PSPX_SEND_RESD          pSendResd;
        PNDIS_PACKET            pPkt;
        int                             numDerefs = 0;

        DBGPRINT(CONNECT, INFO,
                        ("spxConnCompleteConnect: %lx\n", pSpxConnFile));

#if DBG
        if (!SPX_CONN_CONNECTING(pSpxConnFile) && !SPX_CONN_LISTENING(pSpxConnFile))
        {
                DBGBRK(FATAL);
        }
#endif

        //      Free up all the packets
        while ((pSendResd = pSpxConnFile->scf_SendListHead) != NULL)
        {
                pPkt = (PNDIS_PACKET)CONTAINING_RECORD(
                                                                pSendResd, NDIS_PACKET, ProtocolReserved);

                SpxConnDequeueSendPktLock(pSpxConnFile, pPkt);
                if ((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) == 0)
                {
                        //      Free the packet
                        SpxPktSendRelease(pPkt);
                }
                else
                {
                        //      Set abort flag and reference conn for the pkt.
                        pSendResd->sr_State     |= SPX_SENDPKT_ABORT;
                        SpxConnFileLockReference(pSpxConnFile, CFREF_ABORTPKT);
                }
        }


        //      Cancel tdi connect timer if we are connecting.
        switch (SPX_MAIN_STATE(pSpxConnFile))
        {
        case SPX_CONNFILE_CONNECTING:

                if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_T_TIMER))
                {
                        if (SpxTimerCancelEvent(pSpxConnFile->scf_TTimerId, FALSE))
                        {
                                numDerefs++;
                        }
                        SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_T_TIMER);
                }

                if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_C_TIMER))
                {
                        if (SpxTimerCancelEvent(pSpxConnFile->scf_CTimerId, FALSE))
                        {
                                numDerefs++;
                        }
                        SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_C_TIMER);
                }

                if (pSpxConnFile->scf_CRetryCount == (LONG)(PARAM(CONFIG_CONNECTION_COUNT))) {
                        ++SpxDevice->dev_Stat.ConnectionsAfterNoRetry;
        } else {
            ++SpxDevice->dev_Stat.ConnectionsAfterRetry;
        }

                //      Reset all connect related flags
                SPX_MAIN_SETSTATE(pSpxConnFile, 0);
                SPX_CONNECT_SETSTATE(pSpxConnFile, 0);
                break;

        case SPX_CONNFILE_LISTENING:

                if (pSpxConnFile->scf_Flags     & SPX_CONNFILE_C_TIMER)
                {
                        if (SpxTimerCancelEvent(pSpxConnFile->scf_CTimerId, FALSE))
                        {
                                numDerefs++;
                        }
                        SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_C_TIMER);
                }

                SPX_MAIN_SETSTATE(pSpxConnFile, 0);
                SPX_LISTEN_SETSTATE(pSpxConnFile, 0);
                break;

        default:

                KeBugCheck(0);

        }

        SPX_MAIN_SETSTATE(pSpxConnFile, SPX_CONNFILE_ACTIVE);
        SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_IDLE);
        SPX_RECV_SETSTATE(pSpxConnFile, SPX_RECV_IDLE);

    ++SpxDevice->dev_Stat.OpenConnections;

        //      Initialize timer values
        pSpxConnFile->scf_BaseT1                =
        pSpxConnFile->scf_AveT1                 = PARAM(CONFIG_INITIAL_RETRANSMIT_TIMEOUT);
        pSpxConnFile->scf_DevT1                 = 0;
        pSpxConnFile->scf_RRetryCount   = PARAM(CONFIG_REXMIT_COUNT);

        pRequest = LIST_ENTRY_TO_REQUEST(pSpxConnFile->scf_ReqLinkage.Flink);
        RemoveEntryList(REQUEST_LINKAGE(pRequest));
        REQUEST_STATUS(pRequest)                = STATUS_SUCCESS;
        REQUEST_INFORMATION(pRequest)   = 0;

        //      When we complete the request, we essentially transfer the reference
        //      to the fact that the connection is active. This will be taken away
        //      when a Disconnect happens on the connection and we transition from
        //      ACTIVE to DISCONN.
        //      numDerefs++;

        CTEFreeLock (&pSpxConnFile->scf_Lock, LockHandleConn);
        CTEFreeLock (pSpxConnFile->scf_AddrFile->saf_AddrLock, LockHandleAddr);
        CTEFreeLock (&SpxDevice->dev_Lock, LockHandleDev);

        //      Complete request
        SpxCompleteRequest(pRequest);

        while (numDerefs-- > 0)
        {
                SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
        }

        return;
}




BOOLEAN
spxConnAcceptCr(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      PSPX_ADDR                       pSpxAddr,
        IN      CTELockHandle           LockHandleDev,
        IN      CTELockHandle           LockHandleAddr,
        IN      CTELockHandle           LockHandleConn
        )
{
        PNDIS_PACKET    pSsPkt, pCrAckPkt;
        PSPX_SEND_RESD  pSendResd;

        BOOLEAN fNeg    = SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_NEG);
        BOOLEAN fSpx2   = SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_SPX2);

        DBGPRINT(CONNECT, DBG,
                        ("spxConnAcceptCr: %lx.%d.%d\n",
                                pSpxConnFile, fSpx2, fNeg));

        //      Build and queue in packet.
        SpxPktBuildCrAck(
                pSpxConnFile,
                pSpxAddr,
                &pCrAckPkt,
                SPX_SENDPKT_IPXOWNS | SPX_SENDPKT_DESTROY,
                fNeg,
                fSpx2);

        if ((pCrAckPkt  != NULL) &&
                (pSpxConnFile->scf_LocalConnId != 0))
        {
                //      Queue in the packet.
                SpxConnQueueSendPktTail(pSpxConnFile, pCrAckPkt);
        }
        else
        {
                goto AbortConnect;
        }


        //      Start the timer
        if ((pSpxConnFile->scf_WTimerId =
                        SpxTimerScheduleEvent(
                                spxConnWatchdogTimer,
                                PARAM(CONFIG_KEEPALIVE_TIMEOUT) * HALFSEC_TO_MS_FACTOR,
                                pSpxConnFile)) != 0)
        {
                //      Reference connection for the timer
                SpxConnFileLockReference(pSpxConnFile, CFREF_VERIFY);
                SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER);
                pSpxConnFile->scf_WRetryCount   = PARAM(CONFIG_KEEPALIVE_COUNT);
        }
        else
        {
                goto AbortConnect;
        }


        //      We start the connect timer for retrying ss which we send out now
        //      if we are not negotiating.
        if (fSpx2)
        {
                //      Build the session setup packet also for spx2.
                SpxPktBuildSs(
                        pSpxConnFile,
                        &pSsPkt,
                        (USHORT)(fNeg ? 0 : SPX_SENDPKT_IPXOWNS));

                if (pSsPkt != NULL)
                {
                        SpxConnQueueSendPktTail(pSpxConnFile, pSsPkt);
                }
                else
                {
                        goto AbortConnect;
                }

                if (!fNeg)
                {
                        if ((pSpxConnFile->scf_CTimerId =
                                        SpxTimerScheduleEvent(
                                                spxConnConnectTimer,
                                                PARAM(CONFIG_CONNECTION_TIMEOUT) * HALFSEC_TO_MS_FACTOR,
                                                pSpxConnFile)) != 0)
                        {
                                SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_C_TIMER);
                                pSpxConnFile->scf_CRetryCount = PARAM(CONFIG_CONNECTION_COUNT);

                                //      Reference connection for the timer
                                SpxConnFileLockReference(pSpxConnFile, CFREF_VERIFY);
                        }
                        else
                        {
                                goto AbortConnect;
                        }
                }
        }

        CTEAssert((fNeg && fSpx2) || (!fSpx2 && !fNeg));

        //      For a SPX connection, we immediately become active. This happens
        //      in the completeConnect routine. !!Dont change it here!!
        if (!fSpx2)
        {
                spxConnCompleteConnect(
                        pSpxConnFile,
                        LockHandleDev,
                        LockHandleAddr,
                        LockHandleConn);
        }
        else
        {
                SPX_LISTEN_SETSTATE(
                        pSpxConnFile, (fNeg ? SPX_LISTEN_SENTACK : SPX_LISTEN_SETUP));

                CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
                CTEFreeLock (&pSpxAddr->sa_Lock, LockHandleAddr);
                CTEFreeLock (&SpxDevice->dev_Lock, LockHandleDev);
        }

        //      Send the CR Ack packet!
        pSendResd       = (PSPX_SEND_RESD)(pCrAckPkt->ProtocolReserved);
        SPX_SENDPACKET(pSpxConnFile, pCrAckPkt, pSendResd);

        if (fSpx2 && !fNeg)
        {
                pSendResd = (PSPX_SEND_RESD)(pSsPkt->ProtocolReserved);
                SPX_SENDPACKET(pSpxConnFile, pSsPkt, pSendResd);
        }

        return(TRUE);


AbortConnect:

        spxConnAbortConnect(
                pSpxConnFile,
                STATUS_INSUFFICIENT_RESOURCES,
                LockHandleDev,
                LockHandleAddr,
                LockHandleConn);

        return (FALSE);
}



BOOLEAN
SpxConnPacketize(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      BOOLEAN                         fNormalState,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:

        The caller needs to set the state to packetize before calling this
        routine. This can be called when SEND state is RENEG also.

Arguments:

    pSpxConnFile - Pointer to a transport address file object.

        fNormalState - If true, it will assume it can release lock to send,
                                   else, it just builds pkts without releasing lock and
                                   releases lock at end. Used after reneg changes size.

Return Value:


--*/
{
        PLIST_ENTRY             p;
        PNDIS_PACKET    pPkt;
        PSPX_SEND_RESD  pSendResd;
        USHORT                  windowSize;
        ULONG                   dataLen;
        USHORT                  sendFlags;
        int                             numDerefs = 0;
        BOOLEAN                 fFirstPass = TRUE, fSuccess = TRUE;
        PREQUEST                pRequest;

#if DBG
        if ((SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_PACKETIZE) &&
        fNormalState)
        {
                DBGBRK(FATAL);
                KeBugCheck(0);
        }
#endif

        //      Build all of the packets.  The firsttime flag is used so
        //      that if we get a 0 byte send, we will send it.  The firsttime
        //      flag will be set and we will build the packet and send it.
        //
        //      FOR SPX1, we cannot trust the remote window size. So we only send
        //      stuff if window size is greater than 0 *AND* we do not have any pending
        //      sends. Dont get in here if we are ABORT. Dont want to be handling any
        //      more requests.
        while((SPX_DISC_STATE(pSpxConnFile) != SPX_DISC_ABORT)  &&
                  ((pRequest = pSpxConnFile->scf_ReqPkt) != NULL)       &&
                  ((pSpxConnFile->scf_ReqPktSize > 0) || fFirstPass))
        {
                fFirstPass      = FALSE;
                windowSize      = pSpxConnFile->scf_RecdAllocNum -
                                                pSpxConnFile->scf_SendSeqNum + 1;

                DBGPRINT(SEND, DBG,
                                ("SpxConnPacketize: WINDOW %lx for %lx\n",
                                        windowSize, pSpxConnFile));


                DBGPRINT(SEND, DBG,
                                ("REMALLOC %lx SENDSEQ %lx\n",
                        pSpxConnFile->scf_RecdAllocNum,
                    pSpxConnFile->scf_SendSeqNum));


                CTEAssert(windowSize >= 0);

                //      Disconnect/Orderly release is not subject to window closure.
                if ((pSpxConnFile->scf_ReqPktType == SPX_REQ_DATA) &&
                        ((windowSize == 0)  ||
                         (!SPX2_CONN(pSpxConnFile) &&
                             (pSpxConnFile->scf_SendSeqListHead != NULL))))
                {
                        break;
                }

                if (pSpxConnFile->scf_ReqPktType == SPX_REQ_DATA)
                {
                        CTEAssert(pRequest == pSpxConnFile->scf_ReqPkt);

                        //      Get data length
                        dataLen = (ULONG)MIN(pSpxConnFile->scf_ReqPktSize,
                                                                 (pSpxConnFile->scf_MaxPktSize -
                                                                  ((SPX2_CONN(pSpxConnFile) ?
                                                                        MIN_IPXSPX2_HDRSIZE : MIN_IPXSPX_HDRSIZE))));

                        DBGPRINT(SEND, DBG,
                                        ("SpxConnPacketize: %lx Sending %lx Size %lx Req %lx.%lx\n",
                                                pSpxConnFile,
                                                pSpxConnFile->scf_SendSeqNum,
                                                dataLen,
                        pSpxConnFile->scf_ReqPkt,
                                                pSpxConnFile->scf_ReqPktSize));

                        //      Build data packet. Handles 0-length for data. Puts in seq num in
                        //      send resd section of packet also.
                        sendFlags =
                                (USHORT)((fNormalState ? SPX_SENDPKT_IPXOWNS : 0)       |
                                                 SPX_SENDPKT_REQ                                                        |
                                                 SPX_SENDPKT_SEQ                                |
                                                 ((!SPX2_CONN(pSpxConnFile) || (windowSize == 1)) ?
                                                        SPX_SENDPKT_ACKREQ : 0));

                        if (dataLen == pSpxConnFile->scf_ReqPktSize)
                        {
                                //      Last packet of send, ask for a ack.
                                sendFlags |= (SPX_SENDPKT_LASTPKT | SPX_SENDPKT_ACKREQ);
                                if ((pSpxConnFile->scf_ReqPktFlags & TDI_SEND_PARTIAL) == 0)
                                        sendFlags |= SPX_SENDPKT_EOM;
                        }

                        SpxPktBuildData(
                                pSpxConnFile,
                                &pPkt,
                                sendFlags,
                                (USHORT)dataLen);
                }
                else
                {
                        dataLen = 0;

                        DBGPRINT(SEND, DBG,
                                        ("Building DISC packet on %lx ReqPktSize %lx\n",
                                                pSpxConnFile, pSpxConnFile->scf_ReqPktSize));

                        //      Build informed disc/orderly rel packet, associate with request
                        SpxPktBuildDisc(
                                pSpxConnFile,
                                pRequest,
                                &pPkt,
                                (USHORT)((fNormalState ? SPX_SENDPKT_IPXOWNS : 0) | SPX_SENDPKT_REQ |
                                                SPX_SENDPKT_SEQ | SPX_SENDPKT_LASTPKT),
                                (UCHAR)((pSpxConnFile->scf_ReqPktType == SPX_REQ_ORDREL) ?
                                                        SPX2_DT_ORDREL : SPX2_DT_IDISC));
                }

                if (pPkt != NULL)
                {
                        //      If we were waiting to send an ack, we don't have to as we are
                        //      piggybacking it now. Cancel ack timer, get out.
                        if (fNormalState && SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_ACKQ))
                        {
                                DBGPRINT(SEND, DBG,
                                                ("SpxConnPacketize: Piggyback happening for %lx.%lx\n",
                                                        pSpxConnFile, pSpxConnFile->scf_RecvSeqNum));

                                //      We are sending data, allow piggybacks to happen.
                                SPX_CONN_RESETFLAG2(pSpxConnFile, SPX_CONNFILE2_IMMED_ACK);

                SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_ACKQ);
                                if (SpxTimerCancelEvent(pSpxConnFile->scf_ATimerId, FALSE))
                                {
                                        numDerefs++;
                                }
                        }

                        if (pSpxConnFile->scf_ReqPktType != SPX_REQ_DATA)
                        {
                                //      For a disconnect set the state
                                if (pSpxConnFile->scf_ReqPktType == SPX_REQ_ORDREL)
                                {
                                        if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_ODISC))
                                        {
                                                SPX_MAIN_SETSTATE(pSpxConnFile, SPX_CONNFILE_DISCONN);
                                                SPX_DISC_SETSTATE(pSpxConnFile, SPX_DISC_SENT_ORDREL);
                                                numDerefs++;
                                        }
                                        else if (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_POST_ORDREL)
                                        {
                                                CTEAssert((SPX_MAIN_STATE(pSpxConnFile) ==
                                                                                                                SPX_CONNFILE_ACTIVE) ||
                                  (SPX_MAIN_STATE(pSpxConnFile) ==
                                                                                                                SPX_CONNFILE_DISCONN));

                                                SPX_DISC_SETSTATE(pSpxConnFile, SPX_DISC_SENT_ORDREL);
                                        }
                                        else
                                        {
                                                CTEAssert(
                                                        (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_SENT_ORDREL));
                                        }
                                }
                                else
                                {
                                        CTEAssert(SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN);
                                        CTEAssert(SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_POST_IDISC);

                                        //      Note we have send the idisc here.
                                        SPX_DISC_SETSTATE(pSpxConnFile, SPX_DISC_SENT_IDISC);
                                }
                        }
                }
                else
                {
                        fSuccess = FALSE;
                        break;
                }


                //      Queue in packet, reference request for the packet
                SpxConnQueueSendSeqPktTail(pSpxConnFile, pPkt);
                REQUEST_INFORMATION(pRequest)++;

                pSpxConnFile->scf_ReqPktSize    -= dataLen;
                pSpxConnFile->scf_ReqPktOffset  += dataLen;

                DBGPRINT(SEND, INFO,
                                ("SpxConnPacketize: Req %lx Size after pkt %lx.%lx\n",
                                        pSpxConnFile->scf_ReqPkt, pSpxConnFile->scf_ReqPktSize,
                                        dataLen));

                //      Even if window size if zero, setup next request is current one
                //      is done. We are here only after we have packetized this send req.
                if (pSpxConnFile->scf_ReqPktSize == 0)
                {
                        //      This request has been fully packetized. Either go on to
                        //      next request or we are done packetizing.
                        p = REQUEST_LINKAGE(pRequest);
                        if (p->Flink == &pSpxConnFile->scf_ReqLinkage)
                        {
                                DBGPRINT(SEND, INFO,
                                                ("SpxConnPacketize: Req %lx done, no more\n",
                                                        pRequest));

                                pSpxConnFile->scf_ReqPkt                = NULL;
                                pSpxConnFile->scf_ReqPktSize    = 0;
                                pSpxConnFile->scf_ReqPktOffset  = 0;
                                pRequest = NULL;
                        }
                        else
                        {
                                pRequest = LIST_ENTRY_TO_REQUEST(p->Flink);
                if (REQUEST_MINOR_FUNCTION(pRequest) != TDI_DISCONNECT)
                                {
                                        PTDI_REQUEST_KERNEL_SEND                pParam;

                                        pParam  = (PTDI_REQUEST_KERNEL_SEND)REQUEST_PARAMETERS(pRequest);

                                        DBGPRINT(SEND, DBG,
                                                        ("SpxConnPacketize: Req done, setting next %lx.%lx\n",
                                                                pRequest, pParam->SendLength));

                                        DBGPRINT(SEND, INFO,
                                                        ("-%lx-\n",
                                                                pRequest));

                                        //      Set parameters in connection for another go.
                                        pSpxConnFile->scf_ReqPkt                = pRequest;
                                        pSpxConnFile->scf_ReqPktOffset  = 0;
                                        pSpxConnFile->scf_ReqPktFlags   = pParam->SendFlags;
                                        pSpxConnFile->scf_ReqPktType    = SPX_REQ_DATA;

                                        if ((pSpxConnFile->scf_ReqPktSize = pParam->SendLength) == 0)
                                        {
                                                //      Another zero length send.
                                                fFirstPass = TRUE;
                                        }
                                }
                                else
                                {
                                        PTDI_REQUEST_KERNEL_DISCONNECT  pParam;

                                        pParam  =
                                                (PTDI_REQUEST_KERNEL_DISCONNECT)REQUEST_PARAMETERS(pRequest);

                                        pSpxConnFile->scf_ReqPkt                = pRequest;
                                        pSpxConnFile->scf_ReqPktOffset  = 0;
                                        pSpxConnFile->scf_ReqPktSize    = 0;
                                        fFirstPass                                              = TRUE;
                                        pSpxConnFile->scf_ReqPktType    = SPX_REQ_DISC;
                                        if (pParam->RequestFlags == TDI_DISCONNECT_RELEASE)
                                        {
                                                pSpxConnFile->scf_ReqPktType    = SPX_REQ_ORDREL;
                                        }
                                }
                        }
                }

        if (fNormalState)
                {
                        //      Send the packet if we are not at the reneg state
                        CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
                        pSendResd       = (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
            ++SpxDevice->dev_Stat.DataFramesSent;
            ExInterlockedAddLargeStatistic(
                &SpxDevice->dev_Stat.DataFrameBytesSent,
                dataLen);

                        SPX_SENDPACKET(pSpxConnFile, pPkt, pSendResd);
                        CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);
                }

                //      Check if retry timer needs to be started.
                if (!(SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_R_TIMER)))
                {
                        if ((pSpxConnFile->scf_RTimerId =
                                        SpxTimerScheduleEvent(
                                                spxConnRetryTimer,
                                                pSpxConnFile->scf_BaseT1,
                                                pSpxConnFile)) != 0)
                        {
                                SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_R_TIMER);
                                pSpxConnFile->scf_RRetryCount = PARAM(CONFIG_REXMIT_COUNT);

                                //      Reference connection for the timer
                                SpxConnFileLockReference(pSpxConnFile, CFREF_VERIFY);
                        }
                        else
                        {
                                DBGPRINT(SEND, ERR,
                                                ("SpxConnPacketize: Failed to start retry timer\n"));

                                fSuccess = FALSE;
                                break;
                        }
                }
        }

        //      Dont overwrite an error state.
        if (((fNormalState) &&
                 (SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_PACKETIZE)) ||
                ((SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_RETRY3) &&
                 (pSpxConnFile->scf_SendSeqListHead == NULL)))
        {
                if (SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_RETRY3)
                {
                        DBGPRINT(SEND, ERR,
                                        ("COULD NOT PACKETIZE AFTER RENEG %lx\n", pSpxConnFile));

                        SpxConnFileTransferReference(
                                pSpxConnFile,
                                CFREF_ERRORSTATE,
                                CFREF_VERIFY);

                        numDerefs++;
                }

                SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_IDLE);
        }

        CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);

        while (numDerefs-- > 0)
        {
                SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
        }

        return(fSuccess);
}




VOID
SpxConnQueueRecv(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      PREQUEST                        pRequest
        )
/*++

Routine Description:


Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:


--*/
{
        PTDI_REQUEST_KERNEL_RECEIVE             pParam;
        NTSTATUS                                                status = STATUS_PENDING;

        if (IsListEmpty(&pSpxConnFile->scf_RecvLinkage))
        {
                pParam  = (PTDI_REQUEST_KERNEL_RECEIVE)REQUEST_PARAMETERS(pRequest);
                pSpxConnFile->scf_CurRecvReq            = pRequest;
                pSpxConnFile->scf_CurRecvOffset         = 0;
                pSpxConnFile->scf_CurRecvSize           = pParam->ReceiveLength;
        }

        DBGPRINT(RECEIVE, DBG,
                        ("spxConnQueueRecv: %lx.%lx\n", pRequest, pParam->ReceiveLength));

        //      Reference connection for this recv.
        SpxConnFileLockReference(pSpxConnFile, CFREF_VERIFY);

        InsertTailList(
                &pSpxConnFile->scf_RecvLinkage,
                REQUEST_LINKAGE(pRequest));

        //      RECV irps have no creation references.
        REQUEST_INFORMATION(pRequest) = 0;
        REQUEST_STATUS(pRequest)          = STATUS_SUCCESS;

        //      State to receive_posted if we are idle.
        if (SPX_RECV_STATE(pSpxConnFile) == SPX_RECV_IDLE)
        {
                SPX_RECV_SETSTATE(pSpxConnFile, SPX_RECV_POSTED);
        }

        return;
}




VOID
spxConnCompletePended(
        IN      PSPX_CONN_FILE  pSpxConnFile
        )
{
        CTELockHandle           lockHandleInter;
        LIST_ENTRY                      ReqList, *p;
        PREQUEST                        pRequest;

        InitializeListHead(&ReqList);

        DBGPRINT(RECEIVE, DBG,
                        ("spxConnCompletePended: PENDING RECV REQUESTS IN DONE LIST! %lx\n",
                                pSpxConnFile));

        CTEGetLock(&SpxGlobalQInterlock, &lockHandleInter);
        p = pSpxConnFile->scf_RecvDoneLinkage.Flink;
        while (p != &pSpxConnFile->scf_RecvDoneLinkage)
        {
                pRequest = LIST_ENTRY_TO_REQUEST(p);
                p = p->Flink;

                RemoveEntryList(REQUEST_LINKAGE(pRequest));
                InsertTailList(
                        &ReqList,
                        REQUEST_LINKAGE(pRequest));
        }
        CTEFreeLock(&SpxGlobalQInterlock, lockHandleInter);

        while (!IsListEmpty(&ReqList))
        {
                p = RemoveHeadList(&ReqList);
                pRequest = LIST_ENTRY_TO_REQUEST(p);

                DBGPRINT(TDI, DBG,
                                ("SpxConnDiscPkt: PENDING REQ COMP %lx with %lx.%lx\n",
                                        pRequest, REQUEST_STATUS(pRequest),
                                        REQUEST_INFORMATION(pRequest)));


#if DBG
                        if (REQUEST_MINOR_FUNCTION(pRequest) == TDI_RECEIVE)
                        {
                                if ((REQUEST_STATUS(pRequest) == STATUS_SUCCESS) &&
                                        (REQUEST_INFORMATION(pRequest) == 0))
                                {
                                        DBGPRINT(TDI, DBG,
                                                        ("SpxReceiveComplete: Completing %lx with %lx.%lx\n",
                                                                pRequest, REQUEST_STATUS(pRequest),
                                                                REQUEST_INFORMATION(pRequest)));
                                }
                        }
#endif

                SpxCompleteRequest(pRequest);
                SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
        }

        return;
}



VOID
SpxConnQWaitAck(
        IN      PSPX_CONN_FILE          pSpxConnFile
        )
/*++

Routine Description:


Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:


--*/
{
        //      If we are not already in ack queue, queue ourselves in starting
        //      ack timer.
        if (!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_ACKQ))
        {
                //      First start ack timer.
                if ((pSpxConnFile->scf_ATimerId =
                                SpxTimerScheduleEvent(
                                        spxConnAckTimer,
                                        100,
                                        pSpxConnFile)) != 0)
                {
                        //      Reference connection for timer
                        SpxConnFileLockReference(pSpxConnFile, CFREF_VERIFY);
                        SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_ACKQ);
            ++SpxDevice->dev_Stat.PiggybackAckQueued;
                }
        }

        return;
}





VOID
SpxConnSendAck(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:


Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:


--*/
{
        PSPX_SEND_RESD  pSendResd;
        PNDIS_PACKET    pPkt = NULL;

        DBGPRINT(SEND, DBG,
                        ("spxConnSendAck: ACKING on %lx.%lx\n",
                                pSpxConnFile, pSpxConnFile->scf_RecvSeqNum));

        //      Build an ack packet, queue it in non-sequenced queue. Only if we are
        //      active.
        if (SPX_CONN_ACTIVE(pSpxConnFile))
        {
                SpxPktBuildAck(
                        pSpxConnFile,
                        &pPkt,
                        SPX_SENDPKT_IPXOWNS | SPX_SENDPKT_DESTROY,
                        FALSE,
                        0);

                if (pPkt != NULL)
                {
                        SpxConnQueueSendPktTail(pSpxConnFile, pPkt);
                }
                else
                {
                        //      Log error
                        DBGPRINT(SEND, ERR,
                                        ("SpxConnSendAck: Could not allocate!\n"));
                }
        }
#if DBG
        else
        {
                DBGPRINT(SEND, DBG,
                                ("SpxConnSendAck: WHEN NOT ACTIVE STATE@!@\n"));
        }
#endif

        CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);

        //      Send it.
        if (pPkt != NULL)
        {
                pSendResd       = (PSPX_SEND_RESD)(pPkt->ProtocolReserved);

                //      Send the packet
                SPX_SENDACK(pSpxConnFile, pPkt, pSendResd);
        }

        return;
}




VOID
SpxConnSendNack(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      USHORT                          NumToSend,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:


Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:


--*/
{
        PSPX_SEND_RESD  pSendResd;
        PNDIS_PACKET    pPkt = NULL;

        DBGPRINT(SEND, DBG,
                        ("spxConnSendNack: NACKING on %lx.%lx\n",
                                pSpxConnFile, pSpxConnFile->scf_RecvSeqNum));

        //      Build an nack packet, queue it in non-sequenced queue. Only if we are
        //      active.
        if (SPX_CONN_ACTIVE(pSpxConnFile))
        {
                SpxPktBuildAck(
                        pSpxConnFile,
                        &pPkt,
                        SPX_SENDPKT_IPXOWNS | SPX_SENDPKT_DESTROY,
                        TRUE,
                        NumToSend);

                if (pPkt != NULL)
                {
                        SpxConnQueueSendPktTail(pSpxConnFile, pPkt);
                }
                else
                {
                        //      Log error
                        DBGPRINT(SEND, ERR,
                                        ("SpxConnSendAck: Could not allocate!\n"));
                }
        }
#if DBG
        else
        {
                DBGPRINT(SEND, DBG,
                                ("SpxConnSendAck: WHEN NOT ACTIVE STATE@!@\n"));
        }
#endif

        CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);

        //      Send it.
        if (pPkt != NULL)
        {
                pSendResd       = (PSPX_SEND_RESD)(pPkt->ProtocolReserved);

                //      Send the packet
                SPX_SENDACK(pSpxConnFile, pPkt, pSendResd);
        }

        return;
}





BOOLEAN
SpxConnProcessAck(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      PIPXSPX_HDR                     pIpxSpxHdr,
        IN      CTELockHandle           lockHandle
        )
/*++

Routine Description:

        !!!MUST BE CALLED WITH THE CONNECTION LOCK HELD!!!

Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:


--*/
{
        PNDIS_PACKET    pPkt;
        PREQUEST                pRequest;
        PSPX_SEND_RESD  pSendResd;
        CTELockHandle   interLockHandle;
        USHORT                  seqNum = 0, ackNum;
        int                             numDerefs = 0;
        BOOLEAN                 fLastPkt, lockHeld = TRUE, fAbort = FALSE,
                                        fResetRetryTimer, fResendPkt = FALSE, fResetSendQueue = FALSE;
        PNDIS_BUFFER    NdisBuf, NdisBuf2;
        ULONG           BufLen = 0;

        if (pIpxSpxHdr != NULL)
        {
                GETSHORT2SHORT(&seqNum, &pIpxSpxHdr->hdr_SeqNum);
                GETSHORT2SHORT(&ackNum, &pIpxSpxHdr->hdr_AckNum);

                //      Ack numbers should already be set in connection!
                if (SPX2_CONN(pSpxConnFile))
                {
                        switch (SPX_SEND_STATE(pSpxConnFile))
                        {
                        case SPX_SEND_RETRYWD:

                                //      Did we receive an ack for pending data? If so, we goto
                                //      idle and process the ack.
                                if (((pSendResd = pSpxConnFile->scf_SendSeqListHead) != NULL) &&
                                         (UNSIGNED_GREATER_WITH_WRAP(
                                                        pSpxConnFile->scf_RecdAckNum,
                                                        pSendResd->sr_SeqNum)))
                                {
                                        DBGPRINT(SEND, ERR,
                                                        ("SpxConnProcessAck: Data acked RETRYWD %lx.%lx!\n",
                                                                pSpxConnFile, pSendResd->sr_SeqNum));

                                        SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_IDLE);
                    SpxConnFileTransferReference(
                                                pSpxConnFile,
                        CFREF_ERRORSTATE,
                        CFREF_VERIFY);

                                        numDerefs++;
                                }
                                else
                                {
                                        //      Ok, we received an ack for our probe retry, goto
                                        //      renegotiate packet size.
                                        //      For this both sides must have negotiated size to begin with.
                                        //      If they did not, we go on to retrying the data packet.
                                        if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_NEG))
                                        {
                                                pSpxConnFile->scf_RRetryCount = SPX_DEF_RENEG_RETRYCOUNT;
                                                if ((ULONG)pSpxConnFile->scf_MaxPktSize <=
                                                                (SpxMaxPktSize[0] + MIN_IPXSPX2_HDRSIZE))
                                                {
                                                        pSpxConnFile->scf_RRetryCount = PARAM(CONFIG_REXMIT_COUNT);

                                                        DBGPRINT(SEND, DBG3,
                                                                        ("SpxConnProcessAck: %lx MIN RENEG SIZE\n",
                                                                                pSpxConnFile));
                                                }
                                                SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_RENEG);

                                                DBGPRINT(SEND, DBG3,
                                                                ("SpxConnProcessAck: %lx CONNECTION ENTERING RENEG\n",
                                                                        pSpxConnFile));
                                        }
                                        else
                                        {
                                                DBGPRINT(SEND, ERR,
                                                                ("spxConnRetryTimer: NO NEG FLAG SET: %lx - %lx\n",
                                                                        pSpxConnFile,
                                                                        pSpxConnFile->scf_Flags));

                                                //      Reset count to be
                                                pSpxConnFile->scf_RRetryCount = PARAM(CONFIG_REXMIT_COUNT);
                                                SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_RETRY3);
                                        }
                                }

                                break;

                        case SPX_SEND_RENEG:

                                //      We better have a data packet in the list.
                                CTEAssert(pSpxConnFile->scf_SendSeqListHead);

#if DBG
                                if ((pIpxSpxHdr->hdr_ConnCtrl &
                                                (SPX_CC_SYS | SPX_CC_NEG | SPX_CC_SPX2)) ==
                        (SPX_CC_SYS | SPX_CC_NEG | SPX_CC_SPX2))
                                {
                                        DBGPRINT(SEND, DBG3,
                                                        ("SpxConnProcessAck: %lx.%lx.%lx RENEGACK SEQNUM %lx ACKNUM %lx EXPSEQ %lx\n",
                                                                pSpxConnFile,
                                                                pIpxSpxHdr->hdr_ConnCtrl,
                                SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_RENEG_PKT),
                                                                seqNum,
                                                                ackNum,
                                                                (pSpxConnFile->scf_SendSeqListHead->sr_SeqNum + 1)));
                                }
#endif

                                //      Verify we received an RR ack. If so, we set state to
                                //      SEND_RETRY3. First repacketize if we need to.
                                if ((SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_RENEG_PKT))       &&
                                        ((pIpxSpxHdr->hdr_ConnCtrl &
                                                (SPX_CC_SYS | SPX_CC_NEG | SPX_CC_SPX2)) ==
                        (SPX_CC_SYS | SPX_CC_NEG | SPX_CC_SPX2)))
                                {
                                        DBGPRINT(SEND, DBG3,
                                                        ("SpxConnProcessAck: RENEG! NEW %lx.%lx!\n",
                                                                pSpxConnFile, pSpxConnFile->scf_MaxPktSize));

                                        //      Dont allow anymore reneg packet acks to be looked at.
                                        SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_RENEG_PKT);
                                        pSpxConnFile->scf_RRetryCount = PARAM(CONFIG_REXMIT_COUNT);

                                        //      Also set the new send sequence number.
                                        pSpxConnFile->scf_SendSeqNum =
                                                (USHORT)(pSpxConnFile->scf_SendSeqListTail->sr_SeqNum + 1);

                                        //      Get the max packet size we will really use. Retry timer
                                        //      could have sent other sizes by now, so we can't depend
                                        //      on whats set.
                                        //      Remember max packet size in connection.
                                        GETSHORT2SHORT(
                                                &pSpxConnFile->scf_MaxPktSize, &pIpxSpxHdr->hdr_NegSize);

                                        //      Basic sanity checking on the max packet size.
                                        if (pSpxConnFile->scf_MaxPktSize < SPX_NEG_MIN)
                                                pSpxConnFile->scf_MaxPktSize = SPX_NEG_MIN;

                                        //      Get ready to reset the send queue.
                                        fResetSendQueue = TRUE;

                                        DBGPRINT(SEND, DBG3,
                                                        ("SpxConnProcessAck: RENEG DONE : RETRY3 %lx.%lx MP %lx!\n",
                                                                pSpxConnFile,
                                                                pSpxConnFile->scf_SendSeqNum,
                                                                pSpxConnFile->scf_MaxPktSize));

                                        SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_RETRY3);
                                }
                                else
                                {
                                        DBGPRINT(SEND, DBG3,
                                                        ("SpxConnProcessAck: DUPLICATE RENEG ACK %lx!\n",
                                                                pSpxConnFile));
                                }

                                break;

                        case SPX_SEND_RETRY:
                        case SPX_SEND_RETRY2:
                        case SPX_SEND_RETRY3:

                                if (((pSendResd = pSpxConnFile->scf_SendSeqListHead) != NULL) &&
                                         (UNSIGNED_GREATER_WITH_WRAP(
                                                        pSpxConnFile->scf_RecdAckNum,
                                                        pSendResd->sr_SeqNum)))
                                {
                                        DBGPRINT(SEND, DBG,
                                                        ("SpxConnProcessAck: Data acked %lx.%lx!\n",
                                                                pSpxConnFile, SPX_SEND_STATE(pSpxConnFile)));

#if DBG
                                        if (SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_RETRY3)
                                        {
                                                DBGPRINT(SEND, DBG3,
                                                                ("SpxConnProcessAck: CONN RESTORED %lx.%lx!\n",
                                                                        pSpxConnFile, pSendResd->sr_SeqNum));
                                        }
#endif

                                        SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_IDLE);
                    SpxConnFileTransferReference(
                                                pSpxConnFile,
                        CFREF_ERRORSTATE,
                        CFREF_VERIFY);

                                        numDerefs++;
                                }

                                break;

                        case SPX_SEND_WD:

                                //      Ok, we received an ack for our watchdog. Done.
                                SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_IDLE);
                                numDerefs++;

                                SpxConnFileTransferReference(
                                        pSpxConnFile,
                                        CFREF_ERRORSTATE,
                                        CFREF_VERIFY);

                                break;

                        default:

                                break;
                        }

#if DBG
                        if (seqNum != 0)
                        {
                                //      We have a nack, which contains an implicit ack.
                                //      Instead of nack processing, what we do is we resend a
                                //      packet left unacked after ack processing. ONLY if we
                                //      either enter the loop below (fResetRetryTimer is FALSE)
                                //      or if seqNum is non-zero (SPX2 only NACK)
                        }
#endif
                }
        }

        //      Once our numbers are updated, we check to see if any of our packets
        //      have been acked.
        fResetRetryTimer = TRUE;
        while (((pSendResd = pSpxConnFile->scf_SendSeqListHead) != NULL)        &&
                        ((SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_IDLE)                ||
                         (SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_PACKETIZE)   ||
                         fResetSendQueue)                                                                                       &&
                         (UNSIGNED_GREATER_WITH_WRAP(
                                pSpxConnFile->scf_RecdAckNum,
                                pSendResd->sr_SeqNum)))
        {
                //      Reset retry timer
                if (fResetRetryTimer)
                {
                        if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_R_TIMER))
                        {
                                //      This will either successfully restart or not affect the timer
                                //      if it is currently running.
                                SpxTimerCancelEvent(
                                        pSpxConnFile->scf_RTimerId,
                                        TRUE);

                                pSpxConnFile->scf_RRetryCount = PARAM(CONFIG_REXMIT_COUNT);
                        }

                        fResetRetryTimer = FALSE;
                }

                //      Update the retry seq num.
                pSpxConnFile->scf_RetrySeqNum = pSendResd->sr_SeqNum;

                pPkt = (PNDIS_PACKET)CONTAINING_RECORD(
                                                                pSendResd, NDIS_PACKET, ProtocolReserved);

                pRequest = pSendResd->sr_Request;

#if DBG
                if (fResetSendQueue)
                {
                        DBGPRINT(SEND, ERR,
                                        ("SpxConnProcessAck: Data acked RENEG %lx.%lx!\n",
                                                pSpxConnFile, SPX_SEND_STATE(pSpxConnFile)));
                }
#endif

                DBGPRINT(SEND, DBG,
                                ("%lx Acked\n", pSendResd->sr_SeqNum));

                DBGPRINT(SEND, DBG,
                                ("SpxConnProcessAck: %lx Seq %lx Acked Sr %lx Req %lx %lx.%lx\n",
                                        pSpxConnFile,
                                        pSendResd->sr_SeqNum,
                                        pSendResd,
                                        pRequest, REQUEST_STATUS(pRequest),
                                        REQUEST_INFORMATION(pRequest)));

                //      If this packet is the last one comprising this request, remove request
                //      from queue. Calculate retry time.
                fLastPkt = (BOOLEAN)((pSendResd->sr_State & SPX_SENDPKT_LASTPKT) != 0);
                if ((pSendResd->sr_State & SPX_SENDPKT_ACKREQ) &&
                        ((pSendResd->sr_State & SPX_SENDPKT_REXMIT) == 0) &&
                        ((pSendResd->sr_SeqNum + 1) == pSpxConnFile->scf_RecdAckNum))
                {
                        LARGE_INTEGER   li, ntTime;
                        int                             value;

                        //      This is the packet which is being acked. Adjust round trip
                        //      timer.
                        li = pSendResd->sr_SentTime;
                        if (li.LowPart && li.HighPart)
                        {
                                KeQuerySystemTime(&ntTime);

                                //      Get the difference
                                ntTime.QuadPart = ntTime.QuadPart - li.QuadPart;

                                //      Convert to milliseconds. If the highpart is 0, we
                                //      take a shortcut.
                                if (ntTime.HighPart == 0)
                                {
                                        value   = ntTime.LowPart/10000;
                                }
                                else
                                {
                                        ntTime  = SPX_CONVERT100NSTOCENTISEC(ntTime);
                                        value   = ntTime.LowPart << 4;
                                }

                                                                //
                                // 55280
                                // calculate only if required.
                                //
                                if (0 == PARAM(CONFIG_DISABLE_RTT)) {
                                   //      Set new time
                                   SpxCalculateNewT1(pSpxConnFile, value);
                                }
                        }
                }

                if (fLastPkt)
                {
                        //      Set status
                        REQUEST_STATUS(pRequest) = STATUS_SUCCESS;
                        RemoveEntryList(REQUEST_LINKAGE(pRequest));

                        //      Remove creation reference
                        --(REQUEST_INFORMATION(pRequest));

                        DBGPRINT(SEND, DBG,
                                        ("SpxConnProcessAck: LASTSEQ # %lx for Req %lx with %lx.%lx\n",
                                                pSendResd->sr_SeqNum,
                                                pRequest, REQUEST_STATUS(pRequest),
                                                REQUEST_INFORMATION(pRequest)));

                        CTEAssert(REQUEST_INFORMATION(pRequest) != 0);
                }

                //      Dequeue the packet
                CTEAssert((pSendResd->sr_State & SPX_SENDPKT_SEQ) != 0);
                SpxConnDequeueSendPktLock(pSpxConnFile, pPkt);

                if ((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) == 0)
                {
                        //      Dereference request for the dequeing of the packet
                        --(REQUEST_INFORMATION(pRequest));

                        DBGPRINT(SEND, DBG,
                                        ("SpxConnProcessAck: Request %lx with %lx.%lx\n",
                                                pRequest, REQUEST_STATUS(pRequest),
                                                REQUEST_INFORMATION(pRequest)));

                        //      Free the packet
                        SpxPktSendRelease(pPkt);
                }
                else
                {
                        //      Packet owned by IPX. What do we do now? Set acked pkt so request
                        //      gets dereferenced in send completion. Note that the packet is already
                        //      off the queue and is floating at this point.

                        DBGPRINT(SEND, DBG,
                                        ("SpxConnProcessAck: IPXOWNS Pkt %lx with %lx.%lx\n",
                                                pPkt, pRequest, REQUEST_STATUS(pRequest)));

                        pSendResd->sr_State |=  SPX_SENDPKT_ACKEDPKT;
                }

                if (SPX2_CONN(pSpxConnFile) &&
                        (REQUEST_MINOR_FUNCTION(pRequest) == TDI_DISCONNECT) &&
                        (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_SENT_ORDREL))
                {
                        SPX_DISC_SETSTATE(pSpxConnFile, SPX_DISC_ORDREL_ACKED);

                        //      If we had received an ordrel in the meantime, we need
                        //      to disconnect.
                        if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_ODISC))
                        {
                                fAbort = TRUE;
                        }
                }

                //      All packets comprising a request have been acked!
                if (REQUEST_INFORMATION(pRequest) == 0)
                {
                        CTELockHandle                           lockHandleInter;

                        if (REQUEST_MINOR_FUNCTION(pRequest) != TDI_DISCONNECT)
                        {
                                PTDI_REQUEST_KERNEL_SEND                pParam;

                                pParam  = (PTDI_REQUEST_KERNEL_SEND)
                                                        REQUEST_PARAMETERS(pRequest);

                                REQUEST_INFORMATION(pRequest) = pParam->SendLength;

                                DBGPRINT(SEND, DBG,
                                                ("SpxSendComplete: QForComp Request %lx with %lx.%lx\n",
                                                        pRequest, REQUEST_STATUS(pRequest),
                                                        REQUEST_INFORMATION(pRequest)));

                                //      Request is done. Move to completion list.
                                CTEGetLock(&SpxGlobalQInterlock, &lockHandleInter);
                                InsertTailList(
                                        &pSpxConnFile->scf_ReqDoneLinkage,
                                        REQUEST_LINKAGE(pRequest));

                                //      If connection is not already in recv queue, put it in
                                //      there.
                                SPX_QUEUE_FOR_RECV_COMPLETION(pSpxConnFile);
                                CTEFreeLock(&SpxGlobalQInterlock, lockHandleInter);
                        }
                        else
                        {
                                DBGPRINT(SEND, DBG,
                                                ("SpxSendComplete: DISC Request %lx with %lx.%lx\n",
                                                        pRequest, REQUEST_STATUS(pRequest),
                                                        REQUEST_INFORMATION(pRequest)));

                                //      Set the request in the connection, and deref for it.
                                InsertTailList(
                                        &pSpxConnFile->scf_DiscLinkage,
                                        REQUEST_LINKAGE(pRequest));

                                numDerefs++;

                        }
                }
#if DBG
                else if (fLastPkt)
                {
                        DBGPRINT(RECEIVE, DBG,
                                        ("spxConnProcessAck: ReqFloating %lx.%lx\n",
                                                pSpxConnFile, pRequest));
                }
#endif
        }

        //      See if we reset the send queue and repacketize.
        if (fResetSendQueue)
        {
                //      Reset send queue and repacketize only if pkts left unacked.
                if (pSpxConnFile->scf_SendSeqListHead)
                {
                        DBGPRINT(SEND, DBG3,
                                        ("SpxConnProcessAck: Resetting send queue %lx.%lx!\n",
                                                pSpxConnFile, pSpxConnFile->scf_MaxPktSize));

                        spxConnResetSendQueue(pSpxConnFile);

                        DBGPRINT(SEND, DBG3,
                                        ("SpxConnProcessAck: Repacketizing %lx.%lx!\n",
                                                pSpxConnFile, pSpxConnFile->scf_MaxPktSize));

                        SpxConnPacketize(pSpxConnFile, FALSE, lockHandle);
                        CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
                }
                else
                {
                        //      We just go back to idle state now.
                        DBGPRINT(SEND, ERR,
                                        ("SpxConnProcessAck: All packets acked reneg ack! %lx.%lx!\n",
                                                pSpxConnFile, pSpxConnFile->scf_MaxPktSize));

                        SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_IDLE);
                        numDerefs++;

                        SpxConnFileTransferReference(
                                pSpxConnFile,
                                CFREF_ERRORSTATE,
                                CFREF_VERIFY);
                }
        }

        //      See if we resend a packet.
        if ((seqNum != 0)                                                                                               &&
                !fAbort                                                                                                         &&
        ((pSendResd = pSpxConnFile->scf_SendSeqListHead) != NULL)   &&
        (SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_IDLE)                         &&
                ((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) == 0))
        {
                PIPXSPX_HDR             pSendHdr;

                pPkt = (PNDIS_PACKET)CONTAINING_RECORD(
                                                                pSendResd, NDIS_PACKET, ProtocolReserved);

                //
                // Get the MDL that points to the IPX/SPX header. (the second one)
                //
         
                NdisQueryPacket(pPkt, NULL, NULL, &NdisBuf, NULL);
                NdisGetNextBuffer(NdisBuf, &NdisBuf2);
                NdisQueryBuffer(NdisBuf2, (PUCHAR) &pSendHdr, &BufLen);

#if OWN_PKT_POOLS
                pSendHdr        = (PIPXSPX_HDR)((PBYTE)pPkt                     +
                                                                        NDIS_PACKET_SIZE                +
                                                                        sizeof(SPX_SEND_RESD)   +
                                                                        IpxInclHdrOffset);
#endif 
                //      Set ack bit in packet. pSendResd initialized at beginning.
                pSendHdr->hdr_ConnCtrl |= SPX_CC_ACK;

                //      We are going to resend this packet
                pSendResd->sr_State |= (SPX_SENDPKT_IPXOWNS |
                                                                SPX_SENDPKT_ACKREQ      |
                                                                SPX_SENDPKT_REXMIT);

                fResendPkt = TRUE;
        }

        //      Push into packetize only if we received an ack. And if there arent any
        //      packets already waiting. Probably retransmit happening.
        if (!fAbort                                                                                                                     &&
                SPX_CONN_ACTIVE(pSpxConnFile)                                                                   &&
                (SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_IDLE)                                 &&
                (pSpxConnFile->scf_ReqPkt != NULL)                                                              &&
                (!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_PKTQ))                               &&
                ((pSpxConnFile->scf_SendSeqListHead) == NULL)                                   &&
                (!SPX2_CONN(pSpxConnFile)                                                                       ||
                 ((SPX_DISC_STATE(pSpxConnFile) != SPX_DISC_ORDREL_ACKED)       &&
                  (SPX_DISC_STATE(pSpxConnFile) != SPX_DISC_SENT_ORDREL))))
        {
                DBGPRINT(RECEIVE, DBG,
                                ("spxConnProcessAck: Recd ack pktizng\n", pSpxConnFile));

                SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_PKTQ);
                SpxConnFileLockReference(pSpxConnFile, CFREF_PKTIZE);

                CTEGetLock(&SpxGlobalQInterlock, &interLockHandle);
                SPX_QUEUE_TAIL_PKTLIST(pSpxConnFile);
                CTEFreeLock(&SpxGlobalQInterlock, interLockHandle);
        }
        else if (fAbort)
        {
                //      Set IDISC flag so Abortive doesnt reindicate.
                SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC);
                spxConnAbortiveDisc(
                        pSpxConnFile,
                        STATUS_SUCCESS,
                        SPX_CALL_RECVLEVEL,
                        lockHandle,
                        FALSE);     // [SA] bug #15249

                lockHeld = FALSE;
        }

        if (lockHeld)
        {
                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
        }

        if (fResendPkt)
        {
                DBGPRINT(SEND, DBG3,
                                ("SpxConnProcessAck: Resend pkt on %lx.%lx\n",
                                        pSpxConnFile, pSendResd->sr_SeqNum));

        ++SpxDevice->dev_Stat.DataFramesResent;
        ExInterlockedAddLargeStatistic(
            &SpxDevice->dev_Stat.DataFrameBytesResent,
            pSendResd->sr_Len - (SPX2_CONN(pSpxConnFile) ? MIN_IPXSPX2_HDRSIZE : MIN_IPXSPX_HDRSIZE));

                SPX_SENDPACKET(pSpxConnFile, pPkt, pSendResd);
        }

        while (numDerefs-- > 0)
        {
                SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
        }

        return(TRUE);
}




VOID
SpxConnProcessRenegReq(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      PIPXSPX_HDR                     pIpxSpxHdr,
        IN  PIPX_LOCAL_TARGET   pRemoteAddr,
        IN      CTELockHandle           lockHandle
        )
/*++

Routine Description:

        !!!MUST BE CALLED WITH THE CONNECTION LOCK HELD!!!

Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:


--*/
{
        USHORT                  seqNum, ackNum, allocNum, maxPktSize;
        PSPX_SEND_RESD  pSendResd;
        PNDIS_PACKET    pPkt = NULL;

        //      The remote sent us a renegotiate request. We need to send an ack back
        //      ONLY if we have not acked a data packet with that same sequence number.
        //      This is guaranteed by the fact that we will not accept the reneg request
        //      if we have already acked a data packet with the same seq num, as our
        //      receive seq number would be incremented already.
        //
        //      Note that if we have pending send packets we may end up doing a reneg
        //      also.

        GETSHORT2SHORT(&seqNum, &pIpxSpxHdr->hdr_SeqNum);
        GETSHORT2SHORT(&ackNum, &pIpxSpxHdr->hdr_AckNum);
        GETSHORT2SHORT(&allocNum, &pIpxSpxHdr->hdr_AllocNum);
        GETSHORT2SHORT(&maxPktSize, &pIpxSpxHdr->hdr_PktLen);

        //      If the received seq num is less than the expected receive sequence number
        //      we ignore this request.
        if (!UNSIGNED_GREATER_WITH_WRAP(
                        seqNum,
                        pSpxConnFile->scf_RecvSeqNum) &&
                (seqNum != pSpxConnFile->scf_RecvSeqNum))
        {
                DBGPRINT(SEND, DBG3,
                                ("SpxConnProcessRenegReq: %lx ERROR RENSEQ %lx RECVSEQ %lx %lx\n",
                                        pSpxConnFile, seqNum, pSpxConnFile->scf_RecvSeqNum));

                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
                return;
        }

        DBGPRINT(SEND, DBG3,
                        ("SpxConnProcessRenegReq: %lx RENSEQ %lx RECVSEQ %lx MAXPKT %lx\n",
                                pSpxConnFile, seqNum, pSpxConnFile->scf_RecvSeqNum, maxPktSize));

        //      Set ack numbers for connection.
        SPX_SET_ACKNUM(
                pSpxConnFile, ackNum, allocNum);

        SpxCopyIpxAddr(pIpxSpxHdr, pSpxConnFile->scf_RemAckAddr);
        pSpxConnFile->scf_AckLocalTarget        = *pRemoteAddr;

        //      Set RenegAckAckNum before calling buildrrack. If a previous reneg
        //      request was received with a greater maxpktsize, send an ack with
        //      that maxpktsize.
        if (!SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_RENEGRECD))
        {
                pSpxConnFile->scf_RenegAckAckNum = pSpxConnFile->scf_RecvSeqNum;
                pSpxConnFile->scf_RenegMaxPktSize= maxPktSize;
        SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_RENEGRECD);

                DBGPRINT(SEND, DBG3,
                                ("SpxConnProcessRenegReq: %lx SENT ALLOC NUM CURRENT %lx\n",
                                        pSpxConnFile,
                                        pSpxConnFile->scf_SentAllocNum));

                //      Adjust sentallocnum now that recvseqnum might have moved up.
                pSpxConnFile->scf_SentAllocNum   +=
                        (seqNum - pSpxConnFile->scf_RenegAckAckNum);

                DBGPRINT(SEND, DBG3,
                                ("SpxConnProcessRenegReq: %lx SENT ALLOC NUM ADJUSTED %lx\n",
                                        pSpxConnFile,
                                        pSpxConnFile->scf_SentAllocNum));
        }

        //      The recvseqnum for the reneg is always >= the renegackacknum.
    pSpxConnFile->scf_RecvSeqNum         = seqNum;

        DBGPRINT(SEND, DBG3,
                        ("SpxConnProcessRenegReq: %lx RESET RECVSEQ %lx SavedACKACK %lx\n",
                                pSpxConnFile,
                                pSpxConnFile->scf_RecvSeqNum,
                                pSpxConnFile->scf_RenegAckAckNum));

        //      Build and send an ack.
        SpxPktBuildRrAck(
                pSpxConnFile,
                &pPkt,
                SPX_SENDPKT_IPXOWNS | SPX_SENDPKT_DESTROY,
                pSpxConnFile->scf_RenegMaxPktSize);

        if (pPkt != NULL)
        {
                SpxConnQueueSendPktTail(pSpxConnFile, pPkt);
        }
#if DBG
        else
        {
                //      Log error
                DBGPRINT(SEND, ERR,
                                ("SpxConnSendRenegReqAck: Could not allocate!\n"));
        }
#endif


        //      Check if we are an ack/nack packet in which case call process
        //      ack. Note that the spx2 orderly release ack is a normal spx2 ack.
        SpxConnProcessAck(pSpxConnFile, NULL, lockHandle);

        if (pPkt != NULL)
        {
                pSendResd       = (PSPX_SEND_RESD)(pPkt->ProtocolReserved);

                //      Send the packet
                SPX_SENDACK(pSpxConnFile, pPkt, pSendResd);
        }

        return;
}




VOID
SpxConnProcessOrdRel(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      CTELockHandle           lockHandle
        )
/*++

Routine Description:

        !!!MUST BE CALLED WITH THE CONNECTION LOCK HELD!!!

Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:


--*/
{
        PSPX_SEND_RESD                  pSendResd;
    PVOID                                       pDiscHandlerCtx;
    PTDI_IND_DISCONNECT         pDiscHandler    = NULL;
        int                                             numDerefs               = 0;
        PNDIS_PACKET                    pPkt                    = NULL;
        BOOLEAN                                 lockHeld                = TRUE, fAbort = FALSE;

        if (SPX_CONN_ACTIVE(pSpxConnFile))
        {
                if (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_ORDREL_ACKED)
                {
                        fAbort = TRUE;
                }

                //      Send an ack if one was asked for. And we are done with this pkt
                //      Update seq numbers and stuff.
                SPX_SET_RECVNUM(pSpxConnFile, FALSE);

                //      Build and send an ack for this. Ordinary spx2 ack.
                SpxPktBuildAck(
                        pSpxConnFile,
                        &pPkt,
                        SPX_SENDPKT_IPXOWNS | SPX_SENDPKT_DESTROY | SPX_SENDPKT_ABORT,
                        FALSE,
                        0);

                if (pPkt != NULL)
                {
                        //      We don't queue this pkt in as we have the ABORT flag set in
                        //      the packet, which implies the pkt is already dequeued.
                        //      SpxConnQueueSendPktTail(pSpxConnFile, pPkt);

                        //      Reference conn for the pkt.
                        SpxConnFileLockReference(pSpxConnFile, CFREF_ABORTPKT);
                }

                //      Get disconnect handler if we have one. And have not indicated
                //      abortive disconnect on this connection to afd.

                //
                // Bug #14354 - odisc and idisc cross each other, leading to double disc to AFD
                //
                if (!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_ODISC) &&
                    !SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC))
                {
                        //      Yeah, we set the flag regardless of whether a handler is
                        //      present.
                        pDiscHandler   =pSpxConnFile->scf_AddrFile->saf_DiscHandler;
                        pDiscHandlerCtx=pSpxConnFile->scf_AddrFile->saf_DiscHandlerCtx;
                        SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_IND_ODISC);
                }

                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);

                //      Indicate disconnect to afd.
                if (pDiscHandler != NULL)
                {
                        (*pDiscHandler)(
                                pDiscHandlerCtx,
                                pSpxConnFile->scf_ConnCtx,
                                0,                                                              // Disc data
                                NULL,
                                0,                                                              // Disc info
                                NULL,
                                TDI_DISCONNECT_RELEASE);
                }

                //      We abort any receives here if !fAbort else we abort conn.
                CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);

                if (fAbort)
                {
                        //      Set IDISC flag so Abortive doesnt reindicate.
                        SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC);
                        spxConnAbortiveDisc(
                                pSpxConnFile,
                                STATUS_SUCCESS,
                                SPX_CALL_RECVLEVEL,
                                lockHandle,
                                FALSE);     // [SA] bug #15249

                        lockHeld = FALSE;
                }
                else
                {
                        //      Go through and kill all pending requests.
                        spxConnAbortRecvs(
                                pSpxConnFile,
                                STATUS_REMOTE_DISCONNECT,
                                SPX_CALL_RECVLEVEL,
                                lockHandle);

                        lockHeld = FALSE;
                }
        }

        if (lockHeld)
        {
                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
        }

        if (pPkt != NULL)
        {
                pSendResd       = (PSPX_SEND_RESD)(pPkt->ProtocolReserved);

                //      Send the packet
                SPX_SENDACK(pSpxConnFile, pPkt, pSendResd);
        }

        while (numDerefs-- > 0)
        {
                SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
        }

        return;
}




VOID
SpxConnProcessIDisc(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      CTELockHandle           lockHandle
        )
/*++

Routine Description:

        !!!MUST BE CALLED WITH THE CONNECTION LOCK HELD!!!

Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:


--*/
{
        PSPX_SEND_RESD                  pSendResd;
        PNDIS_PACKET                    pPkt    = NULL;
        PNDIS_BUFFER    NdisBuf, NdisBuf2;
        ULONG           BufLen = 0;

        SPX_SET_RECVNUM(pSpxConnFile, FALSE);

        //      Build and send an ack for the idisc. Need to modify data type
        //      and reset sys bit on ack.
        //      BUG #12344 - Fixing this led to the problem where we queue in
        //      the pkt below, but AbortSends could already have been called
        //      => this packet stays on queue without a ref, conn gets freed
        //      underneath, and in the sendcomplete we crash when this send
        //      completes.
        //
        //      Fix is to setup this pkt as a aborted pkt to start with.

        SpxPktBuildAck(
                pSpxConnFile,
                &pPkt,
                SPX_SENDPKT_IPXOWNS | SPX_SENDPKT_DESTROY | SPX_SENDPKT_ABORT,
                FALSE,
                0);

        if (pPkt != NULL)
        {
                PIPXSPX_HDR             pSendHdr;

                pSendResd       = (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
                
                //
                // Get the MDL that points to the IPX/SPX header. (the second one)
                //
                 
                NdisQueryPacket(pPkt, NULL, NULL, &NdisBuf, NULL);
                NdisGetNextBuffer(NdisBuf, &NdisBuf2);
                NdisQueryBuffer(NdisBuf2, (PUCHAR) &pSendHdr, &BufLen);

#if OWN_PKT_POOLS

                pSendHdr        = (PIPXSPX_HDR)((PBYTE)pPkt                     +
                                                                        NDIS_PACKET_SIZE                +
                                                                        sizeof(SPX_SEND_RESD)   +
                                                                        IpxInclHdrOffset);
#endif 
                pSendHdr->hdr_ConnCtrl &= ~SPX_CC_SYS;
                pSendHdr->hdr_DataType  = SPX2_DT_IDISC_ACK;

                //      We don't queue this pkt in as we have the ABORT flag set in
                //      the packet, which implies the pkt is already dequeued.
                //      SpxConnQueueSendPktTail(pSpxConnFile, pPkt);

                //      Reference conn for the pkt.
                SpxConnFileLockReference(pSpxConnFile, CFREF_ABORTPKT);
        }

        //      We better not have any received pkts, we ignore disconnect
        //      pkts when that happens.
        CTEAssert(pSpxConnFile->scf_RecvListTail == NULL);
        CTEAssert(pSpxConnFile->scf_RecvListHead == NULL);

#if DBG
        if (pSpxConnFile->scf_SendSeqListHead != NULL)
        {
                DBGPRINT(CONNECT, DBG1,
                                ("SpxConnDiscPacket: DATA/DISC %lx.%lx.%lx\n",
                                        pSpxConnFile,
                                        pSpxConnFile->scf_SendListHead,
                                        pSpxConnFile->scf_SendSeqListHead));
        }
#endif

        //      Call abortive disconnect on connection.

        //
        // [SA] bug #15249
        // This is an informed disconnect, hence pass DISCONNECT_RELEASE to AFD (TRUE in last param)
        //
        //
        // We pass true only in the case of an SPX connection. SPX2 connections follow the
        // exact semantics of Informed Disconnect.
        //
		if (!SPX2_CONN(pSpxConnFile)) {
            spxConnAbortiveDisc(
                    pSpxConnFile,
                    STATUS_REMOTE_DISCONNECT,
                    SPX_CALL_RECVLEVEL,
                    lockHandle,
                    TRUE);
        } else {
            spxConnAbortiveDisc(
                    pSpxConnFile,
                    STATUS_REMOTE_DISCONNECT,
                    SPX_CALL_RECVLEVEL,
                    lockHandle,
                    FALSE);
        }

        if (pPkt != NULL)
        {
                pSendResd       = (PSPX_SEND_RESD)(pPkt->ProtocolReserved);

                //      Send the packet
                SPX_SENDACK(pSpxConnFile, pPkt, pSendResd);
        }

        return;
}




VOID
spxConnResetSendQueue(
        IN      PSPX_CONN_FILE          pSpxConnFile
        )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
        PSPX_SEND_RESD  pSendResd;
        PREQUEST                pRequest;
        PNDIS_PACKET    pPkt;

        pSendResd = pSpxConnFile->scf_SendSeqListHead;
        CTEAssert(pSendResd != NULL);

        pRequest        = pSendResd->sr_Request;

        //      Reset the current send request values
        pSpxConnFile->scf_ReqPkt                = pSendResd->sr_Request;
        pSpxConnFile->scf_ReqPktOffset  = pSendResd->sr_Offset;
        pSpxConnFile->scf_ReqPktType    = SPX_REQ_DATA;

        if (REQUEST_MINOR_FUNCTION(pRequest) != TDI_DISCONNECT)
        {
                PTDI_REQUEST_KERNEL_SEND                pParam;

                pParam  = (PTDI_REQUEST_KERNEL_SEND)REQUEST_PARAMETERS(pRequest);

                DBGPRINT(SEND, DBG3,
                                ("spxConnResetSendQueue: %lx.%lx.%lx Reset SEND Req to %lx.%lx\n",
                                        pSpxConnFile, pSpxConnFile->scf_Flags, pSpxConnFile->scf_Flags2,
                                        pRequest, pParam->SendLength));

                //      Set parameters in connection for another go. Size parameter is
                //      original size - offset at this point.
                pSpxConnFile->scf_ReqPktFlags   = pParam->SendFlags;
                pSpxConnFile->scf_ReqPktSize    = pParam->SendLength -
                                                                                  pSpxConnFile->scf_ReqPktOffset;
        }
        else
        {
                PTDI_REQUEST_KERNEL_DISCONNECT  pParam;

                DBGPRINT(SEND, ERR,
                                ("spxConnResetSendQueue: %lx.%lx.%lx Reset DISC Req to %lx\n",
                                        pSpxConnFile, pSpxConnFile->scf_Flags, pSpxConnFile->scf_Flags2,
                                        pRequest));

                DBGPRINT(SEND, ERR,
                                ("spxConnResetSendQueue: DISC Request %lx with %lx.%lx\n",
                                        pRequest, REQUEST_STATUS(pRequest),
                                        REQUEST_INFORMATION(pRequest)));

                pParam  =
                        (PTDI_REQUEST_KERNEL_DISCONNECT)REQUEST_PARAMETERS(pRequest);

                pSpxConnFile->scf_ReqPktOffset  = 0;
                pSpxConnFile->scf_ReqPktSize    = 0;
                pSpxConnFile->scf_ReqPktType    = SPX_REQ_DISC;
                if (pParam->RequestFlags == TDI_DISCONNECT_RELEASE)
                {
                        pSpxConnFile->scf_ReqPktType    = SPX_REQ_ORDREL;
                }
        }

        DBGPRINT(SEND, DBG3,
                        ("spxConnResetSendQueue: Seq Num for %lx is now %lx\n",
                                pSpxConnFile, pSpxConnFile->scf_SendSeqNum));

        //      When we are trying to abort a pkt and it is in use by ipx, we simply let
        //      it float.
        do
        {
                pPkt = (PNDIS_PACKET)CONTAINING_RECORD(
                                                                pSendResd, NDIS_PACKET, ProtocolReserved);

                CTEAssert((pSendResd->sr_State & SPX_SENDPKT_REQ) != 0);
                pRequest        = pSendResd->sr_Request;

                CTEAssert(REQUEST_INFORMATION(pRequest) != 0);

                SpxConnDequeueSendPktLock(pSpxConnFile, pPkt);
                if ((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) == 0)
                {
                        if (--(REQUEST_INFORMATION(pRequest)) == 0)
                        {
                                DBGPRINT(SEND, DBG,
                                                ("SpxSendComplete: DISC Request %lx with %lx.%lx\n",
                                                        pRequest, REQUEST_STATUS(pRequest),
                                                        REQUEST_INFORMATION(pRequest)));

                                KeBugCheck(0);
                        }

                        //      Free the packet
                        SpxPktSendRelease(pPkt);
                }
                else
                {
                        //      We let send completion know that this packet is to be aborted.
                        pSendResd->sr_State     |= SPX_SENDPKT_ABORT;
                        SpxConnFileLockReference(pSpxConnFile, CFREF_ABORTPKT);
                }

        } while ((pSendResd = pSpxConnFile->scf_SendSeqListHead) != NULL);

        return;
}




VOID
spxConnAbortSendPkt(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      PSPX_SEND_RESD          pSendResd,
        IN      SPX_CALL_LEVEL          CallLevel,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:

        Called to abort either a sequenced or a non-sequenced packet ONLY from
        send completion.

Arguments:


Return Value:


--*/
{
        LIST_ENTRY              ReqList, *p;
        PREQUEST                pRequest;
        PNDIS_PACKET    pPkt;
        int                             numDerefs = 0;

        InitializeListHead(&ReqList);

        pPkt = (PNDIS_PACKET)CONTAINING_RECORD(
                                                        pSendResd, NDIS_PACKET, ProtocolReserved);

        if ((pSendResd->sr_State & SPX_SENDPKT_REQ) != 0)
        {
                pRequest        = pSendResd->sr_Request;

                CTEAssert(REQUEST_INFORMATION(pRequest) != 0);
                CTEAssert((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) == 0);
                if (--(REQUEST_INFORMATION(pRequest)) == 0)
                {
                        //      Remove request from list its on
                        //      BUG #11626 - request is already removed from list.
                        //      RemoveEntryList(REQUEST_LINKAGE(pRequest));

                        if (REQUEST_MINOR_FUNCTION(pRequest) != TDI_DISCONNECT)
                        {
                                DBGPRINT(SEND, DBG,
                                                ("SpxSendAbort: QForComp Request %lx with %lx.%lx\n",
                                                        pRequest, REQUEST_STATUS(pRequest),
                                                        REQUEST_INFORMATION(pRequest)));

                                if (CallLevel == SPX_CALL_RECVLEVEL)
                                {
                                        CTELockHandle           lockHandleInter;

                                        //      Request is done. Move to completion list.
                                        CTEGetLock(&SpxGlobalQInterlock, &lockHandleInter);
                                        InsertTailList(
                                                &pSpxConnFile->scf_ReqDoneLinkage,
                                                REQUEST_LINKAGE(pRequest));

                                        //      If connection is not already in recv queue, put it in
                                        //      there.
                                        SPX_QUEUE_FOR_RECV_COMPLETION(pSpxConnFile);
                                        CTEFreeLock(&SpxGlobalQInterlock, lockHandleInter);
                                }
                                else
                                {
                                        InsertTailList(
                                                &ReqList,
                                                REQUEST_LINKAGE(pRequest));
                                }
                        }
                        else
                        {
                                DBGPRINT(SEND, DBG,
                                                ("SpxSendComplete: DISC Request %lx with %lx.%lx\n",
                                                        pRequest, REQUEST_STATUS(pRequest),
                                                        REQUEST_INFORMATION(pRequest)));

                                //      Set the request in the connection, and deref for it.
                                InsertTailList(
                                        &pSpxConnFile->scf_DiscLinkage,
                                        REQUEST_LINKAGE(pRequest));

                                numDerefs++;
                        }
                }
        }

        //      Release
        CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);

        //      Free the packet
        SpxPktSendRelease(pPkt);
        SpxConnFileDereference(pSpxConnFile, CFREF_ABORTPKT);

        if (!IsListEmpty(&ReqList))
        {
                p = RemoveHeadList(&ReqList);
                pRequest = LIST_ENTRY_TO_REQUEST(p);

                SpxCompleteRequest(pRequest);
                numDerefs++;
        }

        while (numDerefs-- > 0)
        {
                SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
        }

        return;
}




VOID
spxConnAbortSends(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      NTSTATUS                        Status,
        IN      SPX_CALL_LEVEL          CallLevel,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
        LIST_ENTRY              ReqList, *p;
        PSPX_SEND_RESD  pSendResd;
        PREQUEST                pRequest;
        PNDIS_PACKET    pPkt;
        int                             numDerefs = 0;

        InitializeListHead(&ReqList);

        //      We better be in disconnect state, abortive/informed/orderly initiate.
        CTEAssert(SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN);

        //      Reset the current send request values
        pSpxConnFile->scf_ReqPkt                = NULL;
        pSpxConnFile->scf_ReqPktOffset  = 0;
        pSpxConnFile->scf_ReqPktSize    = 0;
        pSpxConnFile->scf_ReqPktType    = SPX_REQ_DATA;

        //      First go through the non-seq pkt queue.Just set abort flag if owned by ipx
        while ((pSendResd   = pSpxConnFile->scf_SendListHead) != NULL)
        {
                pPkt = (PNDIS_PACKET)CONTAINING_RECORD(
                                                                pSendResd, NDIS_PACKET, ProtocolReserved);

                CTEAssert((pSendResd->sr_State & SPX_SENDPKT_REQ) == 0);

                SpxConnDequeueSendPktLock(pSpxConnFile, pPkt);
                if ((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) == 0)
                {
                        //      Free the packet
                        SpxPktSendRelease(pPkt);
                }
                else
                {
                        //      Set abort flag and reference conn for the pkt if its not already.
                        //      We only do this check for the non-sequenced packets.
                        //      BUG #12344 (see SpxRecvDiscPacket())
                        if ((pSendResd->sr_State & SPX_SENDPKT_ABORT) == 0)
                        {
                                pSendResd->sr_State     |= SPX_SENDPKT_ABORT;
                                SpxConnFileLockReference(pSpxConnFile, CFREF_ABORTPKT);
                        }
                }
        }

        //      When we are trying to abort a pkt and it is in use by ipx, we simply let
        //      it float.
        while ((pSendResd   = pSpxConnFile->scf_SendSeqListHead) != NULL)
        {
                pPkt = (PNDIS_PACKET)CONTAINING_RECORD(
                                                                pSendResd, NDIS_PACKET, ProtocolReserved);

                CTEAssert((pSendResd->sr_State & SPX_SENDPKT_REQ) != 0);
                pRequest        = pSendResd->sr_Request;

                CTEAssert(REQUEST_INFORMATION(pRequest) != 0);

                SpxConnDequeueSendPktLock(pSpxConnFile, pPkt);
                if ((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) == 0)
                {
                        if (--(REQUEST_INFORMATION(pRequest)) == 0)
                        {
                                //      Remove request from list its on
                                RemoveEntryList(REQUEST_LINKAGE(pRequest));

                                //      Set status
                                REQUEST_STATUS(pRequest)                = Status;
                                REQUEST_INFORMATION(pRequest)   = 0;

                                if (REQUEST_MINOR_FUNCTION(pRequest) != TDI_DISCONNECT)
                                {
                                        DBGPRINT(SEND, DBG,
                                                        ("SpxSendAbort: QForComp Request %lx with %lx.%lx\n",
                                                                pRequest, REQUEST_STATUS(pRequest),
                                                                REQUEST_INFORMATION(pRequest)));

                                        if (CallLevel == SPX_CALL_RECVLEVEL)
                                        {
                                                CTELockHandle           lockHandleInter;

                                                //      Request is done. Move to completion list.
                                                CTEGetLock(&SpxGlobalQInterlock, &lockHandleInter);
                                                InsertTailList(
                                                        &pSpxConnFile->scf_ReqDoneLinkage,
                                                        REQUEST_LINKAGE(pRequest));

                                                //      If connection is not already in recv queue, put it in
                                                //      there.
                                                SPX_QUEUE_FOR_RECV_COMPLETION(pSpxConnFile);
                                                CTEFreeLock(&SpxGlobalQInterlock, lockHandleInter);
                                        }
                                        else
                                        {
                                                InsertTailList(
                                                        &ReqList,
                                                        REQUEST_LINKAGE(pRequest));
                                        }
                                }
                                else
                                {
                                        DBGPRINT(SEND, DBG,
                                                        ("SpxSendComplete: DISC Request %lx with %lx.%lx\n",
                                                                pRequest, REQUEST_STATUS(pRequest),
                                                                REQUEST_INFORMATION(pRequest)));

                                        //      Set the request in the connection, and deref for it.
                                        InsertTailList(
                                                &pSpxConnFile->scf_DiscLinkage,
                                                REQUEST_LINKAGE(pRequest));

                                        numDerefs++;
                                }
                        }

                        //      Free the packet
                        SpxPktSendRelease(pPkt);
                }
                else
                {
                        //      We let send completion know that this packet is to be aborted.
                        pSendResd->sr_State     |= SPX_SENDPKT_ABORT;
                        SpxConnFileLockReference(pSpxConnFile, CFREF_ABORTPKT);
                }
        }

        //      If retry timer state is on, then we need to reset and deref.
        if ((SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_IDLE) &&
                (SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_PACKETIZE) &&
                (SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_WD))
        {
                DBGPRINT(SEND, DBG1,
                                ("spxConnAbortSends: When SEND ERROR STATE %lx.%lx\n",
                                        pSpxConnFile, SPX_SEND_STATE(pSpxConnFile)));

                SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_IDLE);

                SpxConnFileTransferReference(
                        pSpxConnFile,
                        CFREF_ERRORSTATE,
                        CFREF_VERIFY);

                numDerefs++;
        }

        //      Remove creation references on all sends.
        if (!IsListEmpty(&pSpxConnFile->scf_ReqLinkage))
        {
                p                = pSpxConnFile->scf_ReqLinkage.Flink;
                while (p != &pSpxConnFile->scf_ReqLinkage)
                {
                        pRequest = LIST_ENTRY_TO_REQUEST(p);
                        p                = p->Flink;

                        //      Remove request from list its on. Its complete or abort list for it.
                        RemoveEntryList(REQUEST_LINKAGE(pRequest));

                        //      Set status
                        REQUEST_STATUS(pRequest)                = Status;

                        DBGPRINT(SEND, DBG1,
                                        ("SpxSendAbort: %lx Aborting Send Request %lx with %lx.%lx\n",
                                                pSpxConnFile, pRequest, REQUEST_STATUS(pRequest),
                                                REQUEST_INFORMATION(pRequest)));

                        if (--(REQUEST_INFORMATION(pRequest)) == 0)
                        {
                                if (REQUEST_MINOR_FUNCTION(pRequest) != TDI_DISCONNECT)
                                {
                                        DBGPRINT(SEND, DBG,
                                                        ("SpxSendAbort: QForComp Request %lx with %lx.%lx\n",
                                                                pRequest, REQUEST_STATUS(pRequest),
                                                                REQUEST_INFORMATION(pRequest)));

                                        if (CallLevel == SPX_CALL_RECVLEVEL)
                                        {
                                                CTELockHandle           lockHandleInter;

                                                //      Request is done. Move to completion list.
                                                CTEGetLock(&SpxGlobalQInterlock, &lockHandleInter);
                                                InsertTailList(
                                                        &pSpxConnFile->scf_ReqDoneLinkage,
                                                        REQUEST_LINKAGE(pRequest));

                                                //      If connection is not already in recv queue, put it in
                                                //      there.
                                                SPX_QUEUE_FOR_RECV_COMPLETION(pSpxConnFile);
                                                CTEFreeLock(&SpxGlobalQInterlock, lockHandleInter);
                                         }
                                        else
                                        {
                                                InsertTailList(
                                                        &ReqList,
                                                        REQUEST_LINKAGE(pRequest));
                                        }
                                }
                                else
                                {
                                        DBGPRINT(SEND, DBG1,
                                                        ("SpxSendComplete: DISC Request %lx with %lx.%lx\n",
                                                                pRequest, REQUEST_STATUS(pRequest),
                                                                REQUEST_INFORMATION(pRequest)));

                                        //      Set the request in the connection, and deref for it.
                                        InsertTailList(
                                                &pSpxConnFile->scf_DiscLinkage,
                                                REQUEST_LINKAGE(pRequest));

                                        numDerefs++;
                                }
                        }
#if DBG
                        else
                        {
                                //      Let it float,
                                DBGPRINT(SEND, DBG1,
                                                ("SpxSendAbort: %lx Floating Send %lx with %lx.%lx\n",
                                                        pSpxConnFile, pRequest, REQUEST_STATUS(pRequest),
                                                        REQUEST_INFORMATION(pRequest)));
                        }
#endif
                }
        }

        //      Release
        CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
        while (!IsListEmpty(&ReqList))
        {
                p = RemoveHeadList(&ReqList);
                pRequest = LIST_ENTRY_TO_REQUEST(p);

                SpxCompleteRequest(pRequest);
                numDerefs++;
        }

        while (numDerefs-- > 0)
        {
                SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
        }

        return;
}




VOID
spxConnAbortRecvs(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      NTSTATUS                        Status,
        IN      SPX_CALL_LEVEL          CallLevel,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
        LIST_ENTRY              ReqList, *p;
        PREQUEST                pRequest;
    PSPX_RECV_RESD      pRecvResd;
        PNDIS_PACKET    pNdisPkt;
        PNDIS_BUFFER    pNdisBuffer;
        PBYTE                   pData;
        ULONG                   dataLen;
        int                             numDerefs = 0;

        InitializeListHead(&ReqList);

        //      We better be in disconnect state, abortive/informed/orderly initiate.
        //      Reset the current receive request values
        pSpxConnFile->scf_CurRecvReq    = NULL;
        pSpxConnFile->scf_CurRecvOffset = 0;
        pSpxConnFile->scf_CurRecvSize   = 0;

        //      If we have any buffered data, abort it.
        //      Buffered data that is 0 bytes long (only eom) may not have a ndis
        //      buffer associated with it.
        while ((pRecvResd = pSpxConnFile->scf_RecvListHead) != NULL)
        {
        if ((pSpxConnFile->scf_RecvListHead = pRecvResd->rr_Next) == NULL)
                {
                        pSpxConnFile->scf_RecvListTail = NULL;
                }

                pNdisPkt = (PNDIS_PACKET)
                                        CONTAINING_RECORD(pRecvResd, NDIS_PACKET, ProtocolReserved);

                DBGPRINT(RECEIVE, DBG1,
                                ("spxConnAbortRecvs: %lx in bufferlist on %lx\n",
                                        pSpxConnFile, pNdisPkt));

                NdisUnchainBufferAtFront(pNdisPkt, &pNdisBuffer);
                if (pNdisBuffer != NULL)
                {
                        NdisQueryBuffer(pNdisBuffer, &pData, &dataLen);
                        CTEAssert(pData != NULL);
                        CTEAssert((LONG)dataLen >= 0);

                        SpxFreeMemory(pData);
                        NdisFreeBuffer(pNdisBuffer);
                }

                //      Packet consumed. Free it up.
                numDerefs++;

                //      Free the ndis packet
                SpxPktRecvRelease(pNdisPkt);
        }

        //      If packets are on this queue, they are waiting for transfer data to
        //      complete. Can't do much about that, just go and remove creation refs
        //      on the receives.
        if (!IsListEmpty(&pSpxConnFile->scf_RecvLinkage))
        {
                p                = pSpxConnFile->scf_RecvLinkage.Flink;
                while (p != &pSpxConnFile->scf_RecvLinkage)
                {
                        pRequest = LIST_ENTRY_TO_REQUEST(p);
                        p                = p->Flink;

                        //      Remove request from list its on
                        RemoveEntryList(REQUEST_LINKAGE(pRequest));

                        //      Set status
                        REQUEST_STATUS(pRequest)                = Status;

                        DBGPRINT(RECEIVE, DBG1,
                                        ("SpxRecvAbort: Aborting Recv Request %lx with %lx.%lx\n",
                                                pRequest, REQUEST_STATUS(pRequest),
                                                REQUEST_INFORMATION(pRequest)));

                        if (REQUEST_INFORMATION(pRequest) == 0)
                        {
                                DBGPRINT(RECEIVE, DBG,
                                                ("SpxRecvAbort: QForComp Request %lx with %lx.%lx\n",
                                                        pRequest, REQUEST_STATUS(pRequest),
                                                        REQUEST_INFORMATION(pRequest)));

                                if (CallLevel == SPX_CALL_RECVLEVEL)
                                {
                                        CTELockHandle           lockHandleInter;

                                        //      Request is done. Move to completion list.
                                        CTEGetLock(&SpxGlobalQInterlock, &lockHandleInter);
                                        InsertTailList(
                                                &pSpxConnFile->scf_RecvDoneLinkage,
                                                REQUEST_LINKAGE(pRequest));

                                        //      If connection is not already in recv queue, put it in
                                        //      there.
                                        SPX_QUEUE_FOR_RECV_COMPLETION(pSpxConnFile);
                                        CTEFreeLock(&SpxGlobalQInterlock, lockHandleInter);
                                }
                                else
                                {
                                        InsertTailList(
                                                &ReqList,
                                                REQUEST_LINKAGE(pRequest));
                                }
                        }
#if DBG
                        else
                        {
                                //      Let it float,
                                DBGPRINT(SEND, DBG1,
                                                ("SpxSendAbort: %lx Floating Send %lx with %lx.%lx\n",
                                                        pSpxConnFile, pRequest, REQUEST_STATUS(pRequest),
                                                        REQUEST_INFORMATION(pRequest)));
                        }
#endif
                }
        }

        //      Release
        CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
        while (!IsListEmpty(&ReqList))
        {
                p = RemoveHeadList(&ReqList);
                pRequest = LIST_ENTRY_TO_REQUEST(p);

                numDerefs++;

                SpxCompleteRequest(pRequest);
        }

        while (numDerefs-- > 0)
        {
                SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
        }

        return;
}



#if 0

VOID
spxConnResendPkts(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
        PNDIS_PACKET    pPkt;
        PSPX_SEND_RESD  pSendResd;
        USHORT                  startSeqNum;
        BOOLEAN                 fLockHeld = TRUE, fDone = FALSE;

        pSendResd = pSpxConnFile->scf_SendSeqListHead;
        if (pSendResd)
        {
                startSeqNum = pSendResd->sr_SeqNum;
                DBGPRINT(SEND, DBG,
                                ("spxConnResendPkts: StartSeqNum %lx for resend on %lx\n",
                                        startSeqNum, pSpxConnFile));

                while (spxConnGetPktBySeqNum(pSpxConnFile, startSeqNum++, &pPkt))
                {
                        CTEAssert(pPkt != NULL);

                        pSendResd = (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
                        if (!(pSendResd->sr_State & SPX_SENDPKT_IPXOWNS))
                        {
                                DBGPRINT(SEND, DBG,
                                                ("spxConnResendPkts: Pkt %lx.%lx resent on %lx\n",
                                                        pPkt, (startSeqNum - 1), pSpxConnFile));

                                //      We are going to send this packet
                                pSendResd->sr_State |= (SPX_SENDPKT_IPXOWNS |
                                                                                SPX_SENDPKT_REXMIT);
                        }
                        else
                        {
                                DBGPRINT(SEND, DBG,
                                                ("spxConnResendPkts: Pkt %lx.%lx owned by ipx on %lx\n",
                                                        pPkt, (startSeqNum - 1), pSpxConnFile));
                                break;
                        }
                        CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
                        fLockHeld = FALSE;

                        //      If pkt has the ack bit set, we break.
                        fDone = ((pSendResd->sr_State & SPX_SENDPKT_ACKREQ) != 0);

                        //      Send the packet
                        SPX_SENDPACKET(pSpxConnFile, pPkt, pSendResd);
                        if (fDone)
                        {
                                break;
                        }

                        CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);
                        fLockHeld = TRUE;
                }
        }

        if (fLockHeld)
        {
                CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
        }

        return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxcutil.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxcutil.c

Abstract:

    This module contains code which implements the CONNECTION object.
    Routines are provided to create, destroy, reference, and dereference,
    transport connection objects.

Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:

    Sanjay Anand (SanjayAn) 5-July-1995
    Bug fixes - tagged [SA]

--*/

#include "precomp.h"
#pragma hdrstop

#ifndef __PREFAST__
#pragma warning(disable:4068)
#endif
#pragma prefast(disable:276, "The assignments are harmless")

//	Define module number for event logging entries
#define	FILENUM		SPXCUTIL

//
//	Minor utility routines
//


BOOLEAN
spxConnCheckNegSize(
	IN	PUSHORT		pNegSize
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	int	i;

	//	We go thru table and see if this is the minimum size or if it
	//	can go down further. Return true if it is not the minimum size.
	DBGPRINT(CONNECT, INFO,
			("spxConnCheckNegSize: Current %lx Check Val %lx\n",
				(ULONG)(*pNegSize - MIN_IPXSPX2_HDRSIZE),
				SpxMaxPktSize[0]));

	if ((ULONG)(*pNegSize - MIN_IPXSPX2_HDRSIZE) <= SpxMaxPktSize[0])
		return(FALSE);

	for (i = SpxMaxPktSizeIndex-1; i > 0; i--)
	{
		DBGPRINT(CONNECT, INFO,
				("spxConnCheckNegSize: Current %lx Check Val %lx\n",
	                (ULONG)(*pNegSize - MIN_IPXSPX2_HDRSIZE),
					SpxMaxPktSize[i]));

		if (SpxMaxPktSize[i] < (ULONG)(*pNegSize - MIN_IPXSPX2_HDRSIZE))
			break;
	}

	*pNegSize = (USHORT)(SpxMaxPktSize[i] + MIN_IPXSPX2_HDRSIZE);

	DBGPRINT(CONNECT, ERR,
			("spxConnCheckNegSize: Trying Size %lx Min size possible %lx\n",
				*pNegSize, SpxMaxPktSize[0] + MIN_IPXSPX2_HDRSIZE));

	return(TRUE);
}




VOID
spxConnSetNegSize(
	IN OUT	PNDIS_PACKET		pPkt,
	IN		ULONG				Size
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PNDIS_BUFFER	pNdisBuffer;
	UINT			bufCount;
    PSPX_SEND_RESD	pSendResd;
	PIPXSPX_HDR		pIpxSpxHdr;

	CTEAssert(Size > 0);
	NdisQueryPacket(pPkt, NULL, &bufCount, &pNdisBuffer, NULL);
	CTEAssert (bufCount == 3);

	NdisGetNextBuffer(pNdisBuffer, &pNdisBuffer);
    NdisQueryBuffer(pNdisBuffer, &pIpxSpxHdr, &bufCount);

    NdisGetNextBuffer(pNdisBuffer, &pNdisBuffer);
    NdisAdjustBufferLength(pNdisBuffer, Size);


	//	Change it in send reserved
	pSendResd	= (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
    pSendResd->sr_Len 	= (Size + MIN_IPXSPX2_HDRSIZE);

#if SPX_OWN_PACKETS
	//	Change in ipx header
	pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pPkt 				+
										NDIS_PACKET_SIZE 		+
										sizeof(SPX_SEND_RESD)	+
										IpxInclHdrOffset);
#endif

	PUTSHORT2SHORT((PUSHORT)&pIpxSpxHdr->hdr_PktLen, (Size + MIN_IPXSPX2_HDRSIZE));

	//	Change in the neg packet field of the header.
	PUTSHORT2SHORT(
		&pIpxSpxHdr->hdr_NegSize,
		(Size + MIN_IPXSPX2_HDRSIZE));

	DBGPRINT(CONNECT, DBG,
			("spxConnSetNegSize: Setting size to %lx Hdr %lx\n",
				Size, (Size + MIN_IPXSPX2_HDRSIZE)));

	return;
}




BOOLEAN
SpxConnDequeueSendPktLock(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN 	PNDIS_PACKET		pPkt
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PSPX_SEND_RESD	pSr, pListHead, pListTail;
	PSPX_SEND_RESD	pSendResd;
	BOOLEAN			removed = TRUE;

	//	If we are sequenced or not decides which list we choose.
	pSendResd	= (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
	if ((pSendResd->sr_State & SPX_SENDPKT_SEQ) != 0)
	{
		pListHead = pSpxConnFile->scf_SendSeqListHead;
		pListTail = pSpxConnFile->scf_SendSeqListTail;
	}
	else
	{
		pListHead = pSpxConnFile->scf_SendListHead;
		pListTail = pSpxConnFile->scf_SendListTail;
	}

	//	Most often, we will be at the head of the list.
	if (pListHead == pSendResd)
	{
        if ((pListHead = pSendResd->sr_Next) == NULL)
		{
			DBGPRINT(SEND, INFO,
					("SpxConnDequeuePktLock: %lx first in list\n", pSendResd));

			pListTail = NULL;
		}
	}
	else
	{
		DBGPRINT(SEND, INFO,
				("SpxConnDequeuePktLock: %lx !first in list\n", pSendResd));

        pSr = pListHead;
		while (pSr != NULL)
		{
			if (pSr->sr_Next == pSendResd)
			{
				if ((pSr->sr_Next = pSendResd->sr_Next) == NULL)
				{
					pListTail = pSr;
				}

				break;
			}

			pSr = pSr->sr_Next;
		}
	
		if (pSr == NULL)
			removed = FALSE;
	}

	if (removed)
	{
		if ((pSendResd->sr_State & SPX_SENDPKT_SEQ) != 0)
		{
			pSpxConnFile->scf_SendSeqListHead = pListHead;
			pSpxConnFile->scf_SendSeqListTail = pListTail;
		}
		else
		{
			pSpxConnFile->scf_SendListHead = pListHead;
			pSpxConnFile->scf_SendListTail = pListTail;
		}
	}

	return(removed);
}




BOOLEAN
SpxConnDequeueRecvPktLock(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN 	PNDIS_PACKET		pPkt
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PSPX_RECV_RESD	pSr, pListHead, pListTail;
	PSPX_RECV_RESD	pRecvResd;
	BOOLEAN			removed = TRUE;

	pRecvResd	= (PSPX_RECV_RESD)(pPkt->ProtocolReserved);
	pListHead = pSpxConnFile->scf_RecvListHead;
	pListTail = pSpxConnFile->scf_RecvListTail;

	//	Most often, we will be at the head of the list.
	if (pListHead == pRecvResd)
	{
		DBGPRINT(RECEIVE, INFO,
				("SpxConnDequeuePktLock: %lx first in list\n", pRecvResd));

        if ((pListHead = pRecvResd->rr_Next) == NULL)
		{
			pListTail = NULL;
		}
	}
	else
	{
		DBGPRINT(RECEIVE, INFO,
				("SpxConnDequeuePktLock: %lx !first in list\n", pRecvResd));

        pSr = pListHead;
		while (pSr != NULL)
		{
			if (pSr->rr_Next == pRecvResd)
			{
				if ((pSr->rr_Next = pRecvResd->rr_Next) == NULL)
				{
					pListTail = pSr;
				}

				break;
			}

			pSr = pSr->rr_Next;
		}
	
		if (pSr == NULL)
			removed = FALSE;
	}

	if (removed)
	{
		pSpxConnFile->scf_RecvListHead = pListHead;
		pSpxConnFile->scf_RecvListTail = pListTail;
	}

	return(removed);
}




BOOLEAN
spxConnGetPktByType(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	ULONG				PktType,
	IN	BOOLEAN				fSeqList,
	IN 	PNDIS_PACKET	*	ppPkt
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PSPX_SEND_RESD	pSr, *ppSr;

	//	Most often, we will be at the head of the list.
	ppSr = (fSeqList ?
				&pSpxConnFile->scf_SendSeqListHead :
				&pSpxConnFile->scf_SendListHead);

	for (; (pSr = *ppSr) != NULL; )
	{
		if (pSr->sr_Type == PktType)
		{
			*ppPkt	 = (PNDIS_PACKET)CONTAINING_RECORD(
										pSr, NDIS_PACKET, ProtocolReserved);
			
			DBGPRINT(SEND, INFO,
					("SpxConnFindByType: %lx.%lx.%d\n", pSr,*ppPkt, fSeqList));

			break;
		}

		ppSr = &pSr->sr_Next;
	}

	return(pSr != NULL);
}




BOOLEAN
spxConnGetPktBySeqNum(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	USHORT				SeqNum,
	IN 	PNDIS_PACKET	*	ppPkt
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PSPX_SEND_RESD	pSr, *ppSr;

	//	Most often, we will be at the head of the list.
	ppSr = &pSpxConnFile->scf_SendSeqListHead;
	for (; (pSr = *ppSr) != NULL; )
	{
		if (pSr->sr_SeqNum == SeqNum)
		{
			*ppPkt	 = (PNDIS_PACKET)CONTAINING_RECORD(
										pSr, NDIS_PACKET, ProtocolReserved);
			
			DBGPRINT(SEND, DBG,
					("SpxConnFindBySeq: %lx.%lx.%d\n", pSr,*ppPkt, SeqNum));

			break;
		}

		ppSr = &pSr->sr_Next;
	}

	return(pSr != NULL);
}




USHORT
spxConnGetId(
	VOID
	)
/*++

Routine Description:

	This must be called with the device lock held.

Arguments:


Return Value:


--*/
{
	PSPX_CONN_FILE	pSpxConnFile;
	BOOLEAN			wrapped = FALSE;
	USHORT			startConnId, retConnId;

    startConnId = SpxDevice->dev_NextConnId;

	//	Search the global active list.
	do
	{
		if ((SpxDevice->dev_NextConnId >= startConnId) && wrapped)
		{
            retConnId = 0;
			break;
		}

		if (SpxDevice->dev_NextConnId == 0xFFFF)
		{
			wrapped = TRUE;
			SpxDevice->dev_NextConnId	= 1;
			continue;
		}

		//	Later this be a tree.
		for (pSpxConnFile = SpxDevice->dev_GlobalActiveConnList[
								SpxDevice->dev_NextConnId & NUM_SPXCONN_HASH_MASK];
			 pSpxConnFile != NULL;
			 pSpxConnFile = pSpxConnFile->scf_GlobalActiveNext)
		{
			if (pSpxConnFile->scf_LocalConnId == SpxDevice->dev_NextConnId)
			{
				break;
			}
		}

		//	Increment for next time.
		retConnId = SpxDevice->dev_NextConnId++;

		//	Ensure we are still legal. We could return if connfile is null.
		if (SpxDevice->dev_NextConnId == 0xFFFF)
		{
			wrapped = TRUE;
			SpxDevice->dev_NextConnId	= 1;
		}

		if (pSpxConnFile != NULL)
		{
			continue;
		}

		break;

	} while (TRUE);

	return(retConnId);
}




NTSTATUS
spxConnRemoveFromList(
	IN	PSPX_CONN_FILE *	ppConnListHead,
	IN	PSPX_CONN_FILE		pConnRemove
	)

/*++

Routine Description:

	This routine must be called with the address lock (and the lock of the remove
	connection will usually also be, but is not needed) held.

Arguments:


Return Value:


--*/
{
	PSPX_CONN_FILE	pRemConn, *ppRemConn;
	NTSTATUS		status = STATUS_SUCCESS;

	//	Dequeue the connection file from the address list. It must be
	//	in the inactive list.
	for (ppRemConn = ppConnListHead;
		 (pRemConn = *ppRemConn) != NULL;)
	{
		if (pRemConn == pConnRemove)
		{
			*ppRemConn = pRemConn->scf_Next;
			break;
		}

		ppRemConn = &pRemConn->scf_Next;
	}

	if (pRemConn == NULL)
	{
		DBGBRK(FATAL);
		CTEAssert(0);
		status = STATUS_INVALID_CONNECTION;
	}

	return(status);
}




NTSTATUS
spxConnRemoveFromAssocList(
	IN	PSPX_CONN_FILE *	ppConnListHead,
	IN	PSPX_CONN_FILE		pConnRemove
	)

/*++

Routine Description:

	This routine must be called with the address lock (and the lock of the remove
	connection will usually also be, but is not needed) held.

Arguments:


Return Value:


--*/
{
	PSPX_CONN_FILE	pRemConn, *ppRemConn;
	NTSTATUS		status = STATUS_SUCCESS;

	//	Dequeue the connection file from the address list. It must be
	//	in the inactive list.
	for (ppRemConn = ppConnListHead;
		 (pRemConn = *ppRemConn) != NULL;)
	{
		if (pRemConn == pConnRemove)
		{
			*ppRemConn = pRemConn->scf_AssocNext;
			break;
		}

		ppRemConn = &pRemConn->scf_AssocNext;
	}

	if (pRemConn == NULL)
	{
		CTEAssert(0);
		status = STATUS_INVALID_CONNECTION;
	}

	return(status);
}




VOID
spxConnInsertIntoGlobalActiveList(
	IN	PSPX_CONN_FILE	pSpxConnFile
	)

/*++

Routine Description:

	This routine must be called with the device lock held.

Arguments:


Return Value:


--*/

{
	int				index = (int)(pSpxConnFile->scf_LocalConnId &
														NUM_SPXCONN_HASH_MASK);

	//	For now, its just a linear list.
	pSpxConnFile->scf_GlobalActiveNext	=
		SpxDevice->dev_GlobalActiveConnList[index];

    SpxDevice->dev_GlobalActiveConnList[index] =
		pSpxConnFile;

	return;
}




NTSTATUS
spxConnRemoveFromGlobalActiveList(
	IN	PSPX_CONN_FILE	pSpxConnFile
	)

/*++

Routine Description:

	This routine must be called with the device lock held.

Arguments:


Return Value:


--*/

{
    PSPX_CONN_FILE	pC, *ppC;
	int				index = (int)(pSpxConnFile->scf_LocalConnId &
														NUM_SPXCONN_HASH_MASK);
	NTSTATUS		status = STATUS_SUCCESS;

	//	For now, its just a linear list.
	for (ppC = &SpxDevice->dev_GlobalActiveConnList[index];
		(pC = *ppC) != NULL;)
	{
		if (pC == pSpxConnFile)
		{
			DBGPRINT(SEND, INFO,
					("SpxConnRemoveFromGlobal: %lx\n", pSpxConnFile));

			//	Remove from list
			*ppC = pC->scf_GlobalActiveNext;
			break;
		}

		ppC = &pC->scf_GlobalActiveNext;
	}

	if (pC	== NULL)
		status = STATUS_INVALID_CONNECTION;

	return(status);
}




VOID
spxConnInsertIntoGlobalList(
	IN	PSPX_CONN_FILE	pSpxConnFile
	)

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
	CTELockHandle	lockHandle;

	//	Get the global q lock
	CTEGetLock(&SpxGlobalQInterlock, &lockHandle);
	pSpxConnFile->scf_GlobalNext	= SpxGlobalConnList;
    SpxGlobalConnList				= pSpxConnFile;
	CTEFreeLock(&SpxGlobalQInterlock, lockHandle);

	return;
}




NTSTATUS
spxConnRemoveFromGlobalList(
	IN	PSPX_CONN_FILE	pSpxConnFile
	)

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
	CTELockHandle	lockHandle;
    PSPX_CONN_FILE	pC, *ppC;
	NTSTATUS		status = STATUS_SUCCESS;

	//	Get the global q lock
	CTEGetLock(&SpxGlobalQInterlock, &lockHandle);
	for (ppC = &SpxGlobalConnList;
		(pC = *ppC) != NULL;)
	{
		if (pC == pSpxConnFile)
		{
			DBGPRINT(SEND, DBG,
					("SpxConnRemoveFromGlobal: %lx\n", pSpxConnFile));

			//	Remove from list
			*ppC = pC->scf_GlobalNext;
			break;
		}

		ppC = &pC->scf_GlobalNext;
	}
	CTEFreeLock(&SpxGlobalQInterlock, lockHandle);

	if (pC	== NULL)
		status = STATUS_INVALID_CONNECTION;

	return(status);
}






#if 0

VOID
spxConnPushIntoPktList(
	IN	PSPX_CONN_FILE	pSpxConnFile
	)

/*++

Routine Description:

	!!!MACROIZE!!!

Arguments:


Return Value:


--*/

{
	CTELockHandle	lockHandle;

	//	Get the global q lock
	CTEGetLock(&SpxGlobalQInterlock, &lockHandle);
	pSpxConnFile->scf_PktNext	= SpxPktConnList;
    SpxPktConnList		        = pSpxConnFile;
	CTEFreeLock(&SpxGlobalQInterlock, lockHandle);

	return;
}




VOID
spxConnPopFromPktList(
	IN	PSPX_CONN_FILE	* ppSpxConnFile
	)

/*++

Routine Description:

	!!!MACROIZE!!!

Arguments:


Return Value:


--*/

{
	CTELockHandle	lockHandle;

	//	Get the global q lock
	CTEGetLock(&SpxGlobalQInterlock, &lockHandle);
	if ((*ppSpxConnFile = SpxPktConnList) != NULL)
	{
		SpxPktConnList = SpxPktConnList->scf_PktNext;
		DBGPRINT(SEND, DBG,
				("SpxConnRemoveFromPkt: %lx\n", *ppSpxConnFile));
	}
	CTEFreeLock(&SpxGlobalQInterlock, lockHandle);
	return;
}




VOID
spxConnPushIntoRecvList(
	IN	PSPX_CONN_FILE	pSpxConnFile
	)

/*++

Routine Description:

	!!!MACROIZE!!!

Arguments:


Return Value:


--*/

{
	CTELockHandle	lockHandle;

	//	Get the global q lock
	CTEGetLock(&SpxGlobalQInterlock, &lockHandle);
	pSpxConnFile->scf_ProcessRecvNext	= SpxRecvConnList;
    SpxRecvConnList		        		= pSpxConnFile;
	CTEFreeLock(&SpxGlobalQInterlock, lockHandle);

	return;
}




VOID
spxConnPopFromRecvList(
	IN	PSPX_CONN_FILE	* ppSpxConnFile
	)

/*++

Routine Description:

	!!!MACROIZE!!!

Arguments:


Return Value:


--*/

{
	CTELockHandle	lockHandle;

	//	Get the global q lock
	CTEGetLock(&SpxGlobalQInterlock, &lockHandle);
	if ((*ppSpxConnFile = SpxRecvConnList) != NULL)
	{
		SpxRecvConnList = SpxRecvConnList->scf_ProcessRecvNext;
		DBGPRINT(SEND, INFO,
				("SpxConnRemoveFromRecv: %lx\n", *ppSpxConnFile));
	}
	CTEFreeLock(&SpxGlobalQInterlock, lockHandle);
	return;
}

#endif


//
//	Reference/Dereference routines
//


#if DBG

VOID
SpxConnFileRef(
    IN PSPX_CONN_FILE pSpxConnFile
    )

/*++

Routine Description:

    This routine increments the reference count on an address file.

Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:

    none.

--*/

{

    CTEAssert ((LONG)pSpxConnFile->scf_RefCount >= 0);   // not perfect, but...

    (VOID)SPX_ADD_ULONG (
            &pSpxConnFile->scf_RefCount,
            1,
            &pSpxConnFile->scf_Lock);

} // SpxRefConnectionFile




VOID
SpxConnFileLockRef(
    IN PSPX_CONN_FILE pSpxConnFile
    )

/*++

Routine Description:

    This routine increments the reference count on an address file.
    IT IS CALLED WITH THE CONNECTION LOCK HELD.

Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:

    none.

--*/

{

    CTEAssert ((LONG)pSpxConnFile->scf_RefCount >= 0);   // not perfect, but...

    (VOID)SPX_ADD_ULONG (
            &pSpxConnFile->scf_RefCount,
            1,
            &pSpxConnFile->scf_Lock);

} // SpxRefConnectionFileLock

#endif




VOID
SpxConnFileRefByIdLock (
	IN	USHORT				ConnId,
    OUT PSPX_CONN_FILE 	* 	ppSpxConnFile,
	OUT	PNTSTATUS  			pStatus
    )

/*++

Routine Description:

	!!!MUST BE CALLED WITH THE DEVICE LOCK HELD!!!

	All active connections should be on the device active list. Later,
	this data structure will be a tree, caching the last accessed
	connection.

Arguments:



Return Value:

    STATUS_SUCCESS if all is well; STATUS_INVALID_CONNECTION otherwise

--*/
{
	PSPX_CONN_FILE	pSpxChkConn;

	*pStatus = STATUS_SUCCESS;

	for (pSpxChkConn =
			SpxDevice->dev_GlobalActiveConnList[ConnId & NUM_SPXCONN_HASH_MASK];
		 pSpxChkConn != NULL;
		 pSpxChkConn = pSpxChkConn->scf_GlobalActiveNext)
	{
		if (pSpxChkConn->scf_LocalConnId == ConnId)
		{
			SpxConnFileReference(pSpxChkConn, CFREF_BYID);
			*ppSpxConnFile = pSpxChkConn;
			break;
		}
	}

	if (pSpxChkConn == NULL)
	{
		*pStatus = STATUS_INVALID_CONNECTION;
	}

	return;

}




VOID
SpxConnFileRefByCtxLock(
	IN	PSPX_ADDR_FILE		pSpxAddrFile,
	IN	CONNECTION_CONTEXT	Ctx,
	OUT	PSPX_CONN_FILE	*	ppSpxConnFile,
	OUT	PNTSTATUS			pStatus
	)
/*++

Routine Description:

	!!!MUST BE CALLED WITH THE ADDRESS LOCK HELD!!!

	Returns a referenced connection file with the associated context and
	address file desired.

Arguments:


Return Value:


--*/
{
	PSPX_CONN_FILE	pSpxChkConn = NULL;
    BOOLEAN         Found       = FALSE;

	*pStatus = STATUS_SUCCESS;

	for (pSpxChkConn = pSpxAddrFile->saf_Addr->sa_InactiveConnList;
		 pSpxChkConn != NULL;
		 pSpxChkConn = pSpxChkConn->scf_Next)
	{
		if ((pSpxChkConn->scf_ConnCtx == Ctx) &&
			(pSpxChkConn->scf_AddrFile == pSpxAddrFile))
		{
			SpxConnFileReference(pSpxChkConn, CFREF_BYCTX);
			*ppSpxConnFile = pSpxChkConn;
            Found = TRUE;
			break;
		}
	}

	if (!Found)
	{
		*pStatus = STATUS_INVALID_CONNECTION;
	}

	return;
}




NTSTATUS
SpxConnFileVerify (
    IN PSPX_CONN_FILE pConnFile
    )

/*++

Routine Description:

    This routine is called to verify that the pointer given us in a file
    object is in fact a valid address file object. We also verify that the
    address object pointed to by it is a valid address object, and reference
    it to keep it from disappearing while we use it.

Arguments:



Return Value:

    STATUS_SUCCESS if all is well; STATUS_INVALID_CONNECTION otherwise

--*/

{
    CTELockHandle 	LockHandle;
    NTSTATUS 		status = STATUS_SUCCESS;

    try
	{
        if ((pConnFile->scf_Size == sizeof (SPX_CONN_FILE)) &&
            (pConnFile->scf_Type == SPX_CONNFILE_SIGNATURE))
		{
            CTEGetLock (&pConnFile->scf_Lock, &LockHandle);
			if (!SPX_CONN_FLAG(pConnFile, SPX_CONNFILE_CLOSING))
			{
				SpxConnFileLockReference(pConnFile, CFREF_VERIFY);
			}
			else
			{
				DBGPRINT(TDI, ERR,
						("StVerifyConnFile: A %lx closing\n", pConnFile));

				status = STATUS_INVALID_CONNECTION;
			}
			CTEFreeLock (&pConnFile->scf_Lock, LockHandle);
        }
		else
		{
            DBGPRINT(TDI, ERR,
					("StVerifyAddressFile: AF %lx bad signature\n", pConnFile));

            status = STATUS_INVALID_CONNECTION;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

         DBGPRINT(TDI, ERR,
				("SpxVerifyConnFile: AF %lx exception\n", pConnFile));

         return GetExceptionCode();
    }

    return status;

}   // SpxVerifyConnFile




VOID
SpxConnFileDeref(
    IN PSPX_CONN_FILE pSpxConnFile
    )

/*++

Routine Description:

    This routine dereferences an address file by decrementing the
    reference count contained in the structure.  If, after being
    decremented, the reference count is zero, then this routine calls
    SpxDestroyConnectionFile to remove it from the system.

Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:

    none.

--*/

{
    ULONG 			oldvalue;
    BOOLEAN         fDiscNotIndicated = FALSE;
    BOOLEAN         fIDiscFlag = FALSE;
    BOOLEAN         fSpx2;

	CTEAssert(pSpxConnFile->scf_RefCount > 0);
    oldvalue = SPX_ADD_ULONG (
                &pSpxConnFile->scf_RefCount,
                (ULONG)-1,
                &pSpxConnFile->scf_Lock);

    CTEAssert (oldvalue > 0);
    if (oldvalue == 1)
	{
		CTELockHandle		lockHandleConn, lockHandleAddr, lockHandleDev;
		LIST_ENTRY			discReqList, *p;
		PREQUEST			pDiscReq;
		PSPX_ADDR_FILE		pSpxAddrFile = NULL;
		PREQUEST			pCloseReq = NULL,
							pCleanupReq = NULL,
							pConnectReq = NULL;
		BOOLEAN				fDisassoc = FALSE;

		InitializeListHead(&discReqList);

		//	We may not be associated at this point. Note: When we are active we
		//	always have a reference. So its not like we execute this code very often.
		CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);
		if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_ASSOC))
		{
			pSpxAddrFile = pSpxConnFile->scf_AddrFile;
		}
		else
		{
			if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_STOPPING))
			{
				DBGPRINT(TDI, DBG,
						("SpxDerefConnectionFile: Conn cleanup %lx.%lx\n",
							pSpxConnFile,
							pSpxConnFile->scf_CleanupReq));
	
				// Save this for later completion.
				pCleanupReq = pSpxConnFile->scf_CleanupReq;
                pSpxConnFile->scf_CleanupReq = NULL;
			}

			if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_CLOSING))
			{
				DBGPRINT(TDI, DBG,
						("SpxDerefConnectionFile: Conn closing %lx\n",
							pSpxConnFile));
	
				// Save this for later completion.
				pCloseReq = pSpxConnFile->scf_CloseReq;

                //
                // Null this out so on a re-entrant case, we dont try to complete this again.
                //
                pSpxConnFile->scf_CloseReq = NULL;
				CTEAssert(pCloseReq != NULL);
			}
		}
		CTEFreeLock (&pSpxConnFile->scf_Lock, lockHandleConn);

		if (pSpxAddrFile)
		{
			CTEGetLock(&SpxDevice->dev_Lock, &lockHandleDev);
			CTEGetLock(pSpxAddrFile->saf_AddrLock, &lockHandleAddr);
			CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);

			//if (pSpxConnFile->scf_RefCount == 0)

            //
            // ** The lock passed here is a dummy - it is pre-compiled out.
            //
            if (SPX_ADD_ULONG(&pSpxConnFile->scf_RefCount, 0, &pSpxConnFile->scf_Lock) == 0)
			{
				DBGPRINT(TDI, INFO,
						("SpxDerefConnectionFile: Conn is 0 %lx.%lx\n",
							pSpxConnFile, pSpxConnFile->scf_Flags));
	
				//	All pending requests on this connection are done. See if we
				//	need to complete the disconnect phase etc.
				switch (SPX_MAIN_STATE(pSpxConnFile))
				{
				case SPX_CONNFILE_DISCONN:
	
					//	Disconnect is done. Move connection out of all the lists
					//	it is on, reset states etc.
					DBGPRINT(TDI, INFO,
							("SpxDerefConnectionFile: Conn being inactivated %lx\n",
								pSpxConnFile));

					//	Time to complete disc requests if present.
					//	There could be multiple of them.
					p = pSpxConnFile->scf_DiscLinkage.Flink;
					while (p != &pSpxConnFile->scf_DiscLinkage)
					{
						pDiscReq = LIST_ENTRY_TO_REQUEST(p);
						p = p->Flink;

						DBGPRINT(TDI, DBG,
								("SpxDerefConnectionFile: Disc on %lx.%lx\n",
									pSpxConnFile, pDiscReq));
	
						RemoveEntryList(REQUEST_LINKAGE(pDiscReq));

						if (REQUEST_STATUS(pDiscReq) == STATUS_PENDING)
						{
							REQUEST_STATUS(pDiscReq) = STATUS_SUCCESS;
						}

						InsertTailList(
							&discReqList,
							REQUEST_LINKAGE(pDiscReq));
					}

                    //
                    // Note the state here, and check after the conn has been inactivated.
                    //

                    //
                    // Bug #14354 - odisc and idisc cross each other, leading to double disc to AFD
                    //
                    if (!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC) &&
                        !SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_ODISC)) {
                        fDiscNotIndicated = TRUE;
                    }

                    if (SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_IDISC)) {
                        fIDiscFlag = TRUE;
                    }

                    fSpx2 = (SPX2_CONN(pSpxConnFile)) ? TRUE : FALSE;

                    //
                    // [SA] Bug #14655
                    // Do not try to inactivate an already inactivated connection
                    //

                    if (!(SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_INACTIVATED)) {
                        spxConnInactivate(pSpxConnFile);
                    } else {
                        //
                        // This is an SPXI connection which has got the local disconnect.
                        // Reset the flags now.
                        //
                        CTEAssert(!fDiscNotIndicated);

                        SPX_MAIN_SETSTATE(pSpxConnFile, 0);
                        SPX_DISC_SETSTATE(pSpxConnFile, 0);
                        SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC);
                    }

                    //
                    // [SA] If we were waiting for sends to be aborted and did not indicate this
                    // disconnect to AFD; and AFD did not call a disconnect on this connection,
                    // then call the disonnect handler now.
                    //
                    if (fDiscNotIndicated) {
                        PVOID 					pDiscHandlerCtx;
                        PTDI_IND_DISCONNECT 	pDiscHandler	= NULL;
                        ULONG   discCode = 0;

                        pDiscHandler 	= pSpxConnFile->scf_AddrFile->saf_DiscHandler;
                        pDiscHandlerCtx = pSpxConnFile->scf_AddrFile->saf_DiscHandlerCtx;

                        //	Indicate disconnect to afd.
                        if (pDiscHandler != NULL) {

                            //
                            // If this was an SPXI connection, the disconnect state is still
                            // DISCONN, so if this routine is re-entered, we need to prevent
                            // a re-indicate to AFD.
                            // Also, we need to wait for a local disconnect from AFD since
                            // we indicated a TDI_DISCONNECT_RELEASE. We bump up the ref count
                            // in this case.
                            //
                            if (!fSpx2) {
                                CTEAssert(  (SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN) &&
                                            (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_INACTIVATED)  );

                                SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC);

                                if (fIDiscFlag) {
                                    SpxConnFileLockReference(pSpxConnFile, CFREF_DISCWAITSPX);
                                    SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_DISC_WAIT);
                                }
                            }

                            CTEFreeLock (&pSpxConnFile->scf_Lock, lockHandleConn);
                            CTEFreeLock (pSpxAddrFile->saf_AddrLock, lockHandleAddr);
                            CTEFreeLock (&SpxDevice->dev_Lock, lockHandleDev);

                            DBGPRINT(CONNECT, INFO,
                                    ("spxDerefConnectionFile: Indicating to afd On %lx when %lx\n",
                                        pSpxConnFile, SPX_MAIN_STATE(pSpxConnFile)));

                            //	First complete all requests waiting for receive completion on
                            //	this conn before indicating disconnect.
                            spxConnCompletePended(pSpxConnFile);

                            if (fIDiscFlag) {
                                //
                                // Indicate DISCONNECT_RELEASE to AFD so it allows receive of packets
                                // it has buffered before the remote disconnect took place.
                                //
                                discCode = TDI_DISCONNECT_RELEASE;
                            } else {
                                //
                                // [SA] bug #15249
                                // If not Informed disconnect, indicate DISCONNECT_ABORT to AFD
                                //
                                discCode = TDI_DISCONNECT_ABORT;
                            }

                            (*pDiscHandler)(
                                    pDiscHandlerCtx,
                                    pSpxConnFile->scf_ConnCtx,
                                    0,								// Disc data
                                    NULL,
                                    0,								// Disc info
                                    NULL,
                                    discCode);

                            CTEGetLock(&SpxDevice->dev_Lock, &lockHandleDev);
                            CTEGetLock(pSpxAddrFile->saf_AddrLock, &lockHandleAddr);
                            CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);
                        }
                    }

					--SpxDevice->dev_Stat.OpenConnections;

					break;
	
				case SPX_CONNFILE_CONNECTING:
				case SPX_CONNFILE_LISTENING:

					//	Get connect/accept request if present.
					pConnectReq = pSpxConnFile->scf_ConnectReq;
					pSpxConnFile->scf_ConnectReq = NULL;

					spxConnInactivate(pSpxConnFile);
					break;

				case SPX_CONNFILE_ACTIVE:
	
					KeBugCheck(0);
			
				default:

					CTEAssert(SPX_MAIN_STATE(pSpxConnFile) == 0);
					break;
				}
	
				//	If stopping, disassociate from the address file. Complete
				//	cleanup request.
				if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_STOPPING))
				{
					DBGPRINT(TDI, DBG,
							("SpxDerefConnectionFile: Conn cleanup %lx.%lx\n",
								pSpxConnFile,
								pSpxConnFile->scf_CleanupReq));
		
					// Save this for later completion.
					pCleanupReq = pSpxConnFile->scf_CleanupReq;
					pSpxConnFile->scf_CleanupReq = NULL;
	
					SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_STOPPING);
					if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_ASSOC))
					{
						DBGPRINT(TDI, INFO,
								("SpxDerefConnectionFile: Conn stopping %lx\n",
									pSpxConnFile));
		
						pSpxAddrFile =  pSpxConnFile->scf_AddrFile;
						SPX_CONN_RESETFLAG(pSpxConnFile,SPX_CONNFILE_ASSOC);
		
						//	Dequeue the connection from the address file
						spxConnRemoveFromAssocList(
							&pSpxAddrFile->saf_AssocConnList,
							pSpxConnFile);
				
						//	Dequeue the connection file from the address list. It must
						//	be in the inactive list.
						spxConnRemoveFromList(
							&pSpxAddrFile->saf_Addr->sa_InactiveConnList,
							pSpxConnFile);
				
						DBGPRINT(CREATE, INFO,
								("SpxConnDerefDisAssociate: %lx from addr file %lx\n",
									pSpxConnFile, pSpxAddrFile));
				
						fDisassoc = TRUE;
					}
				}
	
				if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_CLOSING))
				{
					DBGPRINT(TDI, DBG,
							("SpxDerefConnectionFile: Conn closing %lx\n",
								pSpxConnFile));
		
					// Save this for later completion.
					pCloseReq = pSpxConnFile->scf_CloseReq;

                    //
                    // Null this out so on a re-entrant case, we dont try to complete this again.
                    //
                    pSpxConnFile->scf_CloseReq = NULL;
					CTEAssert(pCloseReq != NULL);
				}

				CTEAssert(IsListEmpty(&pSpxConnFile->scf_ReqLinkage));
				CTEAssert(IsListEmpty(&pSpxConnFile->scf_RecvLinkage));
				CTEAssert(IsListEmpty(&pSpxConnFile->scf_DiscLinkage));
			}
			CTEFreeLock (&pSpxConnFile->scf_Lock, lockHandleConn);
			CTEFreeLock (pSpxAddrFile->saf_AddrLock, lockHandleAddr);
			CTEFreeLock (&SpxDevice->dev_Lock, lockHandleDev);
		}

		if (fDisassoc)
		{
			//	Remove reference on address for this association.
			SpxAddrFileDereference(pSpxAddrFile, AFREF_CONN_ASSOC);
		}

		if (pConnectReq != (PREQUEST)NULL)
		{
			DBGPRINT(TDI, DBG,
					("SpxDerefConnectionFile: Connect on %lx req %lx\n",
						pSpxConnFile, pConnectReq));

			//	Status will already be set in here. We should be here only if
			//	connect is being aborted.
			SpxCompleteRequest(pConnectReq);
		}

		while (!IsListEmpty(&discReqList))
		{
			p = RemoveHeadList(&discReqList);
			pDiscReq = LIST_ENTRY_TO_REQUEST(p);
	
			DBGPRINT(CONNECT, DBG,
					("SpxConnFileDeref: DISC REQ %lx.%lx Completing\n",
						pSpxConnFile, pDiscReq));
	
			SpxCompleteRequest(pDiscReq);
		}

		if (pCleanupReq != (PREQUEST)NULL)
		{
			DBGPRINT(TDI, DBG,
					("SpxDerefConnectionFile: Cleanup complete %lx req %lx\n",
						pSpxConnFile, pCleanupReq));

			REQUEST_INFORMATION(pCleanupReq) = 0;
			REQUEST_STATUS(pCleanupReq) = STATUS_SUCCESS;
			SpxCompleteRequest (pCleanupReq);
		}

		if (pCloseReq != (PREQUEST)NULL)
		{
			DBGPRINT(TDI, DBG,
					("SpxDerefConnectionFile: Freed %lx close req %lx\n",
						pSpxConnFile, pCloseReq));

			CTEAssert(pSpxConnFile->scf_RefCount == 0);

			//	Remove from the global list
			if (!NT_SUCCESS(spxConnRemoveFromGlobalList(pSpxConnFile)))
			{
				KeBugCheck(0);
			}

			// 	Free it up.
			SpxFreeMemory (pSpxConnFile);
		
			REQUEST_INFORMATION(pCloseReq) = 0;
			REQUEST_STATUS(pCloseReq) = STATUS_SUCCESS;
			SpxCompleteRequest (pCloseReq);
		}
    }

	return;

}   // SpxDerefConnectionFile




VOID
spxConnReInit(
	IN	PSPX_CONN_FILE		pSpxConnFile
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	//	Reinit all variables.
    pSpxConnFile->scf_Flags2			= 0;

    pSpxConnFile->scf_GlobalActiveNext 	= NULL;
    pSpxConnFile->scf_PktNext			= NULL;
	pSpxConnFile->scf_CRetryCount		= 0;
	pSpxConnFile->scf_WRetryCount		= 0;
	pSpxConnFile->scf_RRetryCount		= 0;
	pSpxConnFile->scf_RRetrySeqNum		= 0;

	pSpxConnFile->scf_CTimerId =
	pSpxConnFile->scf_RTimerId =
	pSpxConnFile->scf_WTimerId =
	pSpxConnFile->scf_TTimerId =
	pSpxConnFile->scf_ATimerId = 0;

	pSpxConnFile->scf_LocalConnId	=
	pSpxConnFile->scf_SendSeqNum	=
	pSpxConnFile->scf_SentAllocNum	=
	pSpxConnFile->scf_RecvSeqNum	=
	pSpxConnFile->scf_RetrySeqNum	=
	pSpxConnFile->scf_RecdAckNum	=
    pSpxConnFile->scf_RemConnId		=
	pSpxConnFile->scf_RecdAllocNum	= 0;

#if DBG
	//	Initialize so we dont hit breakpoint on seq 0
	pSpxConnFile->scf_PktSeqNum 	= 0xFFFF;
#endif

	pSpxConnFile->scf_DataType		= 0;

	CTEAssert(IsListEmpty(&pSpxConnFile->scf_ReqLinkage));
	CTEAssert(IsListEmpty(&pSpxConnFile->scf_DiscLinkage));
	CTEAssert(IsListEmpty(&pSpxConnFile->scf_RecvLinkage));
	CTEAssert(pSpxConnFile->scf_RecvListHead == NULL);
	CTEAssert(pSpxConnFile->scf_RecvListTail == NULL);
	CTEAssert(pSpxConnFile->scf_SendListHead == NULL);
	CTEAssert(pSpxConnFile->scf_SendListTail == NULL);
	CTEAssert(pSpxConnFile->scf_SendSeqListHead == NULL);
	CTEAssert(pSpxConnFile->scf_SendSeqListTail == NULL);
	pSpxConnFile->scf_CurRecvReq	= NULL;
	pSpxConnFile->scf_CurRecvOffset	= 0;
	pSpxConnFile->scf_CurRecvSize	= 0;

	pSpxConnFile->scf_ReqPkt		= NULL;

	return;
}




VOID
spxConnInactivate(
	IN	PSPX_CONN_FILE		pSpxConnFile
	)
/*++

Routine Description:

	!!! Called with dev/addr/connection lock held !!!

Arguments:

	This gets us back to associate SAVING the state of the STOPPING and
	CLOSING flags so that dereference can go ahead and finish those.

Return Value:


--*/
{
	BOOLEAN	fStopping, fClosing, fAborting;

	fStopping = SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_STOPPING);
	fClosing  = SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_CLOSING);

    //
    // [SA] Bug #14655
    // Save the disconnect states so that a proper error can be given in the case of
    // a send after a remote disconnection.
    //

    //
    // Bug #17729
    // Dont retain these flags if a local disconnect has already occured.
    //

    fAborting = (!SPX2_CONN(pSpxConnFile) &&
                 !SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC) &&
                 (SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN) &&
                 (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_ABORT));

#if DBG
	pSpxConnFile->scf_GhostFlags	= pSpxConnFile->scf_Flags;
	pSpxConnFile->scf_GhostFlags2	= pSpxConnFile->scf_Flags2;
	pSpxConnFile->scf_GhostRefCount	= pSpxConnFile->scf_RefCount;
#endif

	//	Clear all flags, go back to the assoc state. Restore stop/close
	pSpxConnFile->scf_Flags 	   	= SPX_CONNFILE_ASSOC;
	SPX_CONN_SETFLAG(pSpxConnFile,
					((fStopping ? SPX_CONNFILE_STOPPING : 0) |
					 (fClosing  ? SPX_CONNFILE_CLOSING : 0)));

    //
    // [SA] bug #14655
    // In order to avoid a re-entry, mark connection as SPX_DISC_INACTIVATED
    //
    if (fAborting)
    {
        SPX_MAIN_SETSTATE(pSpxConnFile, SPX_CONNFILE_DISCONN);
        SPX_DISC_SETSTATE(pSpxConnFile, SPX_DISC_INACTIVATED);
    }

	//	Remove connection from global list on device
	if (!NT_SUCCESS(spxConnRemoveFromGlobalActiveList(
						pSpxConnFile)))
	{
		KeBugCheck(0);
	}

	//	Remove connection from active list on address
	if (!NT_SUCCESS(spxConnRemoveFromList(
						&pSpxConnFile->scf_AddrFile->saf_Addr->sa_ActiveConnList,
						pSpxConnFile)))
	{
		KeBugCheck(0);
	}

	//	Put connection in inactive list on address
	SPX_INSERT_ADDR_INACTIVE(
		pSpxConnFile->scf_AddrFile->saf_Addr,
		pSpxConnFile);

	spxConnReInit(pSpxConnFile);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxaddr.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxaddr.h				

Abstract:


Author:

	Adam   Barr		 (adamba ) Original Version
    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:


--*/

#define		DYNSKT_RANGE_START	0x4000
#define		DYNSKT_RANGE_END  	0x7FFF
#define		SOCKET_UNIQUENESS	1

// This structure is pointed to by the FsContext field in the FILE_OBJECT
// for this Address.  This structure is the base for all activities on
// the open file object within the transport provider.  All active connections
// on the address point to this structure, although no queues exist here to do
// work from. This structure also maintains a reference to an ADDRESS
// structure, which describes the address that it is bound to.

#define AFREF_CREATE     	0
#define AFREF_VERIFY     	1
#define AFREF_INDICATION 	2
#define	AFREF_CONN_ASSOC	3

#define AFREF_TOTAL  		4

typedef struct _SPX_ADDR_FILE {

#if DBG
    ULONG 					saf_RefTypes[AFREF_TOTAL];
#endif

    CSHORT 					saf_Type;
    CSHORT 					saf_Size;

	// number of references to this object.
    ULONG 					saf_RefCount;

    // Linkage in address list.
    struct _SPX_ADDR_FILE *	saf_Next;
    struct _SPX_ADDR_FILE *	saf_GlobalNext;

	//	List of associated connection/active or otherwise
	struct _SPX_CONN_FILE *	saf_AssocConnList;

    // the current state of the address file structure; this is either open or
    // closing
    USHORT 					saf_Flags;

    // address to which we are bound, pointer to its lock.
    struct _SPX_ADDR 	*	saf_Addr;
    CTELock * 				saf_AddrLock;

#ifdef ISN_NT
	// easy backlink to file object.
    PFILE_OBJECT 			saf_FileObject;
#endif

	// device to which we are attached.
    struct _DEVICE *		saf_Device;

    // This holds the request used to close this address file,
    // for pended completion.
    PREQUEST 				saf_CloseReq;

    // This function pointer points to a connection indication handler for this
    // Address. Any time a connect request is received on the address, this
    // routine is invoked.
    PTDI_IND_CONNECT 		saf_ConnHandler;
    PVOID 					saf_ConnHandlerCtx;

    // The following function pointer always points to a TDI_IND_DISCONNECT
    // handler for the address.
    PTDI_IND_DISCONNECT 	saf_DiscHandler;
    PVOID 					saf_DiscHandlerCtx;

    // The following function pointer always points to a TDI_IND_RECEIVE
    // event handler for connections on this address.
    PTDI_IND_RECEIVE 		saf_RecvHandler;
    PVOID 					saf_RecvHandlerCtx;

	//	Send possible handler
    PTDI_IND_SEND_POSSIBLE	saf_SendPossibleHandler;
	PVOID					saf_SendPossibleHandlerCtx;

	//	!!!We do not do datagrams or expedited data!!!

    // The following function pointer always points to a TDI_IND_ERROR
    // handler for the address.
    PTDI_IND_ERROR 			saf_ErrHandler;
    PVOID 					saf_ErrHandlerCtx;
    PVOID 					saf_ErrHandlerOwner;


} SPX_ADDR_FILE, *PSPX_ADDR_FILE;

#define SPX_ADDRFILE_OPENING   	0x0000  // not yet open for business
#define SPX_ADDRFILE_OPEN      	0x0001  // open for business
#define SPX_ADDRFILE_CLOSING   	0x0002  // closing
#define	SPX_ADDRFILE_STREAM	   	0x0004	// Opened for stream mode operation
#define	SPX_ADDRFILE_CONNIND   	0x0008	// Connect ind in progress
#define	SPX_ADDRFILE_SPX2		0x0010	// Attempt SPX2 address file
#define	SPX_ADDRFILE_NOACKWAIT	0x0020	// Dont delay acks on assoc connections
#define SPX_ADDRFILE_IPXHDR		0x0040	// Pass ipx hdr on all assoc connections
// 	***STOP*** ***STOP*** ***STOP*** ***STOP*** ***STOP*** ***STOP*** ***STOP***
//	If you are adding any more states to this beyond 0x0080, MAKE SURE to go
//	in code and change statements like (Flags & SPX_***) to
//	((Flags & SPX_**) != 0)!!! I dont want to make that change that at this stage.
//	***STOP*** ***STOP*** ***STOP*** ***STOP*** ***STOP*** ***STOP*** ***STOP***

// This structure defines an ADDRESS, or active transport address,
// maintained by the transport provider.  It contains all the visible
// components of the address (such as the TSAP and network name components),
// and it also contains other maintenance parts, such as a reference count,
// ACL, and so on.

#define AREF_ADDR_FILE 		0
#define AREF_LOOKUP       	1
#define AREF_RECEIVE      	2

#define AREF_TOTAL   		4

typedef struct _SPX_ADDR {

#if DBG
    ULONG 					sa_RefTypes[AREF_TOTAL];
#endif

    USHORT 					sa_Size;
    CSHORT 					sa_Type;

	// number of references to this object.
    ULONG 					sa_RefCount;

	// next address/this device object.
    struct _SPX_ADDR	*	sa_Next;

    // The following fields are used to maintain state about this address.
	// attributes of the address.
    ULONG 					sa_Flags;

	// 	Next addressfile for this address
	struct _SPX_ADDR_FILE *	sa_AddrFileList;

	// List of inactive connections and active connections on this address file.
	struct _SPX_CONN_FILE *	sa_InactiveConnList;
	struct _SPX_CONN_FILE *	sa_ActiveConnList;

	//	This is the list of connections which have a POST_LISTEN on them. They
	//	do not have a local connection id at this point. But will, when they move
	//	from here to the ActiveConnList, when the listen is satisfied (no matter
	//	if the accept has not been posted yet, in the case of non-autoaccept listens)
	struct _SPX_CONN_FILE *	sa_ListenConnList;

    CTELock 				sa_Lock;

    // the socket this address corresponds to.
    USHORT 					sa_Socket;

	// device context to which we are attached.
    struct _DEVICE *		sa_Device;
    CTELock * 				sa_DeviceLock;

#ifdef ISN_NT

    // These two can be a union because they are not used
    // concurrently.
    union {

        // This structure is used for checking share access.
        SHARE_ACCESS 		sa_ShareAccess;

        // Used for delaying NbfDestroyAddress to a thread so
        // we can access the security descriptor.
        WORK_QUEUE_ITEM 	sa_DestroyAddrQueueItem;

    } u;

    // This structure is used to hold ACLs on the address.
    PSECURITY_DESCRIPTOR 	sa_SecurityDescriptor;

#endif

} SPX_ADDR, *PSPX_ADDR;

#define SPX_ADDR_CLOSING  	0x00000001


//	ROUTINE PROTOTYPES

VOID
SpxAddrRef(
    IN PSPX_ADDR Address);

VOID
SpxAddrLockRef(
    IN PSPX_ADDR Address);

VOID
SpxAddrDeref(
    IN PSPX_ADDR Address);

VOID
SpxAddrFileRef(
    IN PSPX_ADDR_FILE pAddrFile);

VOID
SpxAddrFileLockRef(
    IN PSPX_ADDR_FILE pAddrFile);

VOID
SpxAddrFileDeref(
    IN PSPX_ADDR_FILE pAddrFile);

PSPX_ADDR
SpxAddrCreate(
    IN PDEVICE 	Device,
    IN USHORT 	Socket);

NTSTATUS
SpxAddrFileCreate(
    IN 	PDEVICE 			Device,	
    IN 	PREQUEST 			Request,
	OUT PSPX_ADDR_FILE *	ppAddrFile);

NTSTATUS
SpxAddrOpen(
    IN PDEVICE Device,
    IN PREQUEST Request);

NTSTATUS
SpxAddrSetEventHandler(
    IN PDEVICE 	Device,
    IN PREQUEST pRequest);

NTSTATUS
SpxAddrFileVerify(
    IN PSPX_ADDR_FILE pAddrFile);

NTSTATUS
SpxAddrFileStop(
    IN PSPX_ADDR_FILE pAddrFile,
    IN PSPX_ADDR Address);

NTSTATUS
SpxAddrFileCleanup(
    IN PDEVICE Device,
    IN PREQUEST Request);

NTSTATUS
SpxAddrFileClose(
    IN PDEVICE Device,
    IN PREQUEST Request);

PSPX_ADDR
SpxAddrLookup(
    IN PDEVICE Device,
    IN USHORT Socket);

NTSTATUS
SpxAddrConnByRemoteIdAddrLock(
    IN 	PSPX_ADDR	 	pSpxAddr,
    IN 	USHORT			SrcConnId,
	IN	PBYTE			SrcIpxAddr,
	OUT	struct _SPX_CONN_FILE **ppSpxConnFile);

NTSTATUS
SpxAddrFileDestroy(
    IN PSPX_ADDR_FILE pAddrFile);

VOID
SpxAddrDestroy(
    IN PVOID Parameter);

USHORT
SpxAddrAssignSocket(
    IN PDEVICE Device);

BOOLEAN
SpxAddrExists(
    IN PDEVICE 	Device,
    IN USHORT 	Socket);

NTSTATUS
spxAddrRemoveFromGlobalList(
	IN	PSPX_ADDR_FILE	pSpxAddrFile);

VOID
spxAddrInsertIntoGlobalList(
	IN	PSPX_ADDR_FILE	pSpxAddrFile);

#if DBG
#define SpxAddrReference(_Address, _Type) 		\
		{										\
			(VOID)SPX_ADD_ULONG ( 		\
				&(_Address)->sa_RefTypes[_Type],\
				1, 								\
				&SpxGlobalInterlock); 			\
			SpxAddrRef (_Address);				\
		}

#define SpxAddrLockReference(_Address, _Type)		\
		{											\
			(VOID)SPX_ADD_ULONG ( 			\
				&(_Address)->sa_RefTypes[_Type], 	\
				1, 									\
				&SpxGlobalInterlock); 				\
			SpxAddrLockRef (_Address);				\
		}

#define SpxAddrDereference(_Address, _Type) 		\
		{							   				\
			(VOID)SPX_ADD_ULONG ( 			\
				&(_Address)->sa_RefTypes[_Type], 	\
				(ULONG)-1, 							\
				&SpxGlobalInterlock); 				\
			if (SPX_ADD_ULONG( \
					&(_Address)->sa_RefCount, \
					(ULONG)-1, \
					&(_Address)->sa_Lock) == 1) { \
				SpxAddrDestroy (_Address); \
			}\
		}


#define SpxAddrFileReference(_AddressFile, _Type)		\
		{												\
			(VOID)SPX_ADD_ULONG ( 				\
				&(_AddressFile)->saf_RefTypes[_Type], 	\
				1, 										\
				&SpxGlobalInterlock); 					\
			SpxAddrFileRef (_AddressFile);				\
		}

#define SpxAddrFileLockReference(_AddressFile, _Type)		\
		{													\
			(VOID)SPX_ADD_ULONG ( 					\
				&(_AddressFile)->saf_RefTypes[_Type], 		\
				1, 											\
				&SpxGlobalInterlock); 						\
			SpxAddrFileLockRef (_AddressFile);				\
		}

#define SpxAddrFileDereference(_AddressFile, _Type) 		\
		{													\
			(VOID)SPX_ADD_ULONG ( 					\
				&(_AddressFile)->saf_RefTypes[_Type], 		\
				(ULONG)-1, 									\
				&SpxGlobalInterlock); 						\
			SpxAddrFileDeref (_AddressFile);				\
		}

#define SpxAddrFileTransferReference(_AddressFile, _OldType, _NewType)		\
		{																	\
			(VOID)SPX_ADD_ULONG ( 									\
				&(_AddressFile)->saf_RefTypes[_NewType], 					\
				1, 															\
				&SpxGlobalInterlock); 										\
			(VOID)SPX_ADD_ULONG ( 									\
				&(_AddressFile)->saf_RefTypes[_OldType], 					\
				(ULONG)-1, 													\
				&SpxGlobalInterlock);										\
		}

#else  // DBG

#define SpxAddrReference(_Address, _Type) 	\
			SPX_ADD_ULONG( \
				&(_Address)->sa_RefCount, \
				1, \
				(_Address)->sa_DeviceLock)

#define SpxAddrLockReference(_Address, _Type) \
			SPX_ADD_ULONG( \
				&(_Address)->sa_RefCount, \
				1, \
				(_Address)->sa_DeviceLock);

#define SpxAddrDereference(_Address, _Type) \
			if (SPX_ADD_ULONG( \
					&(_Address)->sa_RefCount, \
					(ULONG)-1, \
					&(_Address)->sa_Lock) == 1) { \
				SpxAddrDestroy (_Address); \
			}

#define SpxAddrFileReference(_AddressFile, _Type) \
			SPX_ADD_ULONG( \
				&(_AddressFile)->saf_RefCount, \
				1, \
				(_AddressFile)->saf_AddrLock)

#define SpxAddrFileLockReference(_AddressFile, _Type) \
			SPX_ADD_ULONG( \
				&(_AddressFile)->saf_RefCount, \
				1, \
				(_AddressFile)->saf_AddrLock);

#define SpxAddrFileDereference(_AddressFile, _Type) \
			if (SPX_ADD_ULONG( \
					&(_AddressFile)->saf_RefCount, \
					(ULONG)-1, \
					(_AddressFile)->saf_AddrLock) == 1) { \
				SpxAddrFileDestroy (_AddressFile); \
			}

#define SpxAddrFileTransferReference(_AddressFile, _OldType, _NewType)

#endif // DBG

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxconn.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxconn.c

Abstract:

    This module contains code which implements the CONNECTION object.
    Routines are provided to create, destroy, reference, and dereference,
    transport connection objects.

Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:

    Sanjay Anand (SanjayAn) 5-July-1995
    Bug fixes - tagged [SA]

--*/

#include "precomp.h"

extern POBJECT_TYPE *IoFileObjectType;

#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SpxConnOpen)
#endif
#ifndef __PREFAST__
#pragma warning(disable:4068)
#endif
#pragma prefast(disable:276, "The assignments are harmless")

//	Define module number for event logging entries
#define	FILENUM		SPXCONN

VOID
SpxFindRouteComplete (
    IN PIPX_FIND_ROUTE_REQUEST FindRouteRequest,
    IN BOOLEAN FoundRoute);


NTSTATUS
SpxConnOpen(
	IN 	PDEVICE 			pDevice,
	IN	CONNECTION_CONTEXT	ConnCtx,
	IN 	PREQUEST 			pRequest
    )
	
/*++

Routine Description:

	This routine is used to create a connection object and associate the
	passed ConnectionContext with it.

Arguments:

	pConnCtx - The TDI ConnectionContext to be associated with object

Return Value:

	STATUS_SUCCESS if connection was successfully opened
	Error otherwise.

--*/

{
	NTSTATUS		status = STATUS_SUCCESS;
	PSPX_CONN_FILE	pSpxConnFile;

#ifdef ISN_NT
    PIRP Irp = (PIRP)pRequest;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
#endif


	// Allocate memory for a connection object
	if ((pSpxConnFile = SpxAllocateZeroedMemory(sizeof(SPX_CONN_FILE))) == NULL)
	{
		return(STATUS_INSUFFICIENT_RESOURCES);
	}

	//	Initialize values
	pSpxConnFile->scf_Flags 	= 0;
	pSpxConnFile->scf_Type 		= SPX_CONNFILE_SIGNATURE;
	pSpxConnFile->scf_Size 		= sizeof (SPX_CONN_FILE);

	CTEInitLock (&pSpxConnFile->scf_Lock);

	pSpxConnFile->scf_ConnCtx		= ConnCtx;
	pSpxConnFile->scf_Device		= pDevice;

	//	Initialize list for requests.
	InitializeListHead(&pSpxConnFile->scf_ReqLinkage);
	InitializeListHead(&pSpxConnFile->scf_RecvLinkage);
	InitializeListHead(&pSpxConnFile->scf_RecvDoneLinkage);
	InitializeListHead(&pSpxConnFile->scf_ReqDoneLinkage);
	InitializeListHead(&pSpxConnFile->scf_DiscLinkage);

#ifdef ISN_NT
	// easy backlink to file object.
	pSpxConnFile->scf_FileObject	= IrpSp->FileObject;
#endif

	//	For connections we go from 0->0 with flags indicating if a close
	//	happened.
	pSpxConnFile->scf_RefCount		= 0;

	//	Insert into a global connection list.
	spxConnInsertIntoGlobalList(pSpxConnFile);

#if DBG

	//	Initialize this to 0xFFFF so we dont hit assert on first packet.
	pSpxConnFile->scf_PktSeqNum 	= 0xFFFF;

#endif

	//	Set values in the request.
	REQUEST_OPEN_CONTEXT(pRequest) 	= (PVOID)pSpxConnFile;
	REQUEST_OPEN_TYPE(pRequest) 	= (PVOID)TDI_CONNECTION_FILE;

	DBGPRINT(CREATE, INFO,
			("SpxConnOpen: Opened %lx\n", pSpxConnFile));

	ASSERT(status == STATUS_SUCCESS);
	return(status);
}




NTSTATUS
SpxConnCleanup(
    IN PDEVICE 	Device,
    IN PREQUEST Request
    )

/*++

Routine Description:


Arguments:

    Request - the close request.

Return Value:

    STATUS_SUCCESS if all is well, STATUS_INVALID_HANDLE if the
    request does not point to a real connection

--*/

{
	NTSTATUS		status;
	CTELockHandle	lockHandle;
	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(Request);

	//	Verify connection file
	if ((status = SpxConnFileVerify(pSpxConnFile)) != STATUS_SUCCESS)
	{
		DBGBRK(FATAL);
		return (status);
	}

	DBGPRINT(CREATE, INFO,
			("SpxConnFileCleanup: %lx.%lx when %lx\n",
				pSpxConnFile, Request, pSpxConnFile->scf_RefCount));

	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
    pSpxConnFile->scf_CleanupReq = Request;
	CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);

	//	We have a reference, so it wont go to zero until stop returns. Therefore
	//	deref can expect flag to be set.
	SpxConnStop(pSpxConnFile);
    SpxConnFileDereference (pSpxConnFile, CFREF_VERIFY);

    //
    // If this is a connection which is waiting for a local disconnect,
    // deref it since we dont expect a disconnect after a cleanup.
    //

	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
    if (SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_DISC_WAIT)) {

        CTEAssert(  (SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN) &&
                    (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_INACTIVATED) &&
                    SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC));

        CTEAssert(pSpxConnFile->scf_RefTypes[CFREF_DISCWAITSPX]);

        SPX_CONN_RESETFLAG2(pSpxConnFile, SPX_CONNFILE2_DISC_WAIT);

	    CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);

        KdPrint(("Deref for DISCWAIT on connfile: %lx\n", pSpxConnFile));

        SpxConnFileDereference (pSpxConnFile, CFREF_DISCWAITSPX);
    } else {
	    CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
    }


    return STATUS_PENDING;
}




NTSTATUS
SpxConnClose(
    IN PDEVICE 	Device,
    IN PREQUEST Request
    )

/*++

Routine Description:


Arguments:

    Request - the close request.

Return Value:

    STATUS_SUCCESS if all is well, STATUS_INVALID_HANDLE if the
    request does not point to a real connection

--*/

{
	NTSTATUS		status;
	CTELockHandle	lockHandle;
	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(Request);

	//	Verify connection file
	if ((status = SpxConnFileVerify(pSpxConnFile)) != STATUS_SUCCESS)
	{
		DBGBRK(FATAL);
		return (status);
	}

	DBGPRINT(CREATE, INFO,
			("SpxConnFileClose: %lx when %lx\n",
				pSpxConnFile, pSpxConnFile->scf_RefCount));

	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
    pSpxConnFile->scf_CloseReq = Request;
	SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_CLOSING);
	CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);

    SpxConnFileDereference (pSpxConnFile, CFREF_VERIFY);
    return STATUS_PENDING;
}




VOID
SpxConnStop(
	IN	PSPX_CONN_FILE	pSpxConnFile
	)
/*++

Routine Description:

	!!!Connection must have a reference when this is called!!!

Arguments:


Return Value:


--*/
{
	CTELockHandle	lockHandle;

	DBGPRINT(CREATE, INFO,
			("SpxConnFileStop: %lx when %lx.%lx\n",
				pSpxConnFile, pSpxConnFile->scf_RefCount,
				pSpxConnFile->scf_Flags));

	//	Call disconnect and disassociate
	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
	if (!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_STOPPING))
	{
        SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_STOPPING);
		if (!SPX_CONN_IDLE(pSpxConnFile))
		{
			spxConnAbortiveDisc(
				pSpxConnFile,
				STATUS_LOCAL_DISCONNECT,
				SPX_CALL_TDILEVEL,
				lockHandle,
                FALSE);     // [SA] Bug #15249

		}
		else
		{
			//	Disassociate if we are associated.
			spxConnDisAssoc(pSpxConnFile, lockHandle);
		}

		//	Lock released at this point.
	}
	else
	{
		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
	}
	return;
}




NTSTATUS
SpxConnAssociate(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest
	)

/*++

Routine Description:

	This routine moves the connection from the device list to the inactive
	connection list in the address of the address file specified. The address
	file is pointed to by the connection and is referenced for the associate.

Arguments:


Return Value:


--*/

{
	NTSTATUS		status;
	PSPX_ADDR_FILE	pSpxAddrFile;
	CTELockHandle	lockHandle1, lockHandle2;

	BOOLEAN			derefAddr 	= FALSE, derefConn = FALSE;
	PFILE_OBJECT	pFileObj 	= NULL;
	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(pRequest);
	HANDLE			AddrObjHandle =
	((PTDI_REQUEST_KERNEL_ASSOCIATE)(REQUEST_PARAMETERS(pRequest)))->AddressHandle;

	do
	{
		// Get the handle to the address object from the irp and map it to
		// the corres. file object.
		status = ObReferenceObjectByHandle(
					AddrObjHandle,
					0,
					*IoFileObjectType,
					pRequest->RequestorMode,
					(PVOID *)&pFileObj,
					NULL);

		if (!NT_SUCCESS(status))
			break;

		if (pFileObj->DeviceObject != SpxDevice->dev_DevObj || pFileObj->FsContext2 != (PVOID)TDI_TRANSPORT_ADDRESS_FILE ) {
		   ObDereferenceObject(pFileObj);
		   status = STATUS_INVALID_HANDLE;
		   break;
		}

		pSpxAddrFile = pFileObj->FsContext;
		// ASSERT(pFileObj->FsContext2 == (PVOID)TDI_TRANSPORT_ADDRESS_FILE);

		//	Verify address file/connection file
		if ((status = SpxAddrFileVerify(pSpxAddrFile)) != STATUS_SUCCESS) {
                   ObDereferenceObject(pFileObj);
		   break;
		}


		derefAddr = TRUE;

		if ((status = SpxConnFileVerify(pSpxConnFile)) != STATUS_SUCCESS) {
		   ObDereferenceObject(pFileObj);
		   break;
		}


		derefConn = TRUE;

		//	Grab the addres file lock, then the connection lock for associate.
		CTEGetLock(pSpxAddrFile->saf_AddrLock, &lockHandle1);
		CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle2);
		if (!SPX_CONN_FLAG(pSpxConnFile, (SPX_CONNFILE_CLOSING 		|
										  SPX_CONNFILE_STOPPING   	|
										  SPX_CONNFILE_ASSOC))
			&&
			!(pSpxAddrFile->saf_Flags & SPX_ADDRFILE_CLOSING))
		{
			derefAddr = FALSE;
            SpxAddrFileTransferReference(
				pSpxAddrFile, AFREF_VERIFY, AFREF_CONN_ASSOC);

			//	Queue in the inactive list in the address
			pSpxConnFile->scf_Next	= pSpxAddrFile->saf_Addr->sa_InactiveConnList;
            pSpxAddrFile->saf_Addr->sa_InactiveConnList	= pSpxConnFile;

			//	Queue in the assoc list in the address file
			pSpxConnFile->scf_AssocNext		= pSpxAddrFile->saf_AssocConnList;
            pSpxAddrFile->saf_AssocConnList	= pSpxConnFile;

			//	Remember the addrfile in the connection
			pSpxConnFile->scf_AddrFile	= pSpxAddrFile;
			SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_ASSOC);

			status = STATUS_SUCCESS;

			DBGPRINT(CREATE, INFO,
					("SpxConnAssociate: %lx with address file %lx\n",
						pSpxConnFile, pSpxAddrFile));
		}
		else
		{
			status = STATUS_INVALID_PARAMETER;
		}
		CTEFreeLock (&pSpxConnFile->scf_Lock, lockHandle2);
		CTEFreeLock (pSpxAddrFile->saf_AddrLock, lockHandle1);

		// Dereference the file object corres. to the address object
		ObDereferenceObject(pFileObj);

	} while (FALSE);

	if (derefAddr)
	{
		SpxAddrFileDereference(pSpxAddrFile, AFREF_VERIFY);
	}

	if (derefConn)
	{
		SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	}

	return(status);
}




NTSTATUS
SpxConnDisAssociate(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest
	)

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
	NTSTATUS		status;
	CTELockHandle	lockHandle;
	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(pRequest);

	//	Verify connection file
	if ((status = SpxConnFileVerify(pSpxConnFile)) != STATUS_SUCCESS)
		return (status);

	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
	if (!SPX_CONN_IDLE(pSpxConnFile)
		||
		(!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_ASSOC)))
	{
		status = STATUS_INVALID_CONNECTION;
	}
	CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);

	//	Unlink it if ok.
	if (NT_SUCCESS(status))
	{
		SpxConnStop(pSpxConnFile);
	}

	SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	return(status);
}




NTSTATUS
spxConnDisAssoc(
	IN	PSPX_CONN_FILE	pSpxConnFile,
	IN	CTELockHandle	LockHandleConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NTSTATUS		status = STATUS_SUCCESS;
	CTELockHandle	lockHandleAddr;
	PSPX_ADDR_FILE	pSpxAddrFile;

	if (SPX_CONN_IDLE(pSpxConnFile)
		&&
		(SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_ASSOC)))
	{
		pSpxAddrFile				= pSpxConnFile->scf_AddrFile;
	}
	else
	{
		status = STATUS_INVALID_CONNECTION;
	}
	CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);

	//	Unlink it if ok.
	if (NT_SUCCESS(status))
	{
		CTEGetLock(pSpxAddrFile->saf_AddrLock, &lockHandleAddr);
		CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);

		//	Check again as we had released the lock
		if (SPX_CONN_IDLE(pSpxConnFile)
			&&
			(SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_ASSOC)))
		{
			pSpxConnFile->scf_AddrFile	= NULL;
			SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_ASSOC);

			//	Dequeue the connection from the address file
			spxConnRemoveFromAssocList(
				&pSpxAddrFile->saf_AssocConnList,
				pSpxConnFile);
	
			//	Dequeue the connection file from the address list. It must be
			//	in the inactive list.
			spxConnRemoveFromList(
				&pSpxAddrFile->saf_Addr->sa_InactiveConnList,
				pSpxConnFile);
		}
		else
		{
			status = STATUS_INVALID_CONNECTION;
		}

		CTEFreeLock (&pSpxConnFile->scf_Lock, LockHandleConn);
		CTEFreeLock (pSpxAddrFile->saf_AddrLock, lockHandleAddr);

		DBGPRINT(CREATE, INFO,
				("SpxConnDisAssociate: %lx from address file %lx\n",
					pSpxConnFile, pSpxAddrFile));

		if (NT_SUCCESS(status))
		{
			//	Remove reference on address for this association.
			SpxAddrFileDereference(pSpxAddrFile, AFREF_CONN_ASSOC);
		}
	}

	return(status);
}




NTSTATUS
SpxConnConnect(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest
	)

/*++

Routine Description:


Arguments:

	We need to have another timer that will be started on the connection
	if the tdi client indicated a timeout value. 0 -> we do not start such
	a timer, -1 implies, we let our connection timeout values do their thing.
	Any other value will forcibly shutdown the connect process, when the timer
	fires.

Return Value:


--*/

{
	PTDI_REQUEST_KERNEL_CONNECT 	pParam;
	TDI_ADDRESS_IPX	UNALIGNED 	*	pTdiAddr;
	PNDIS_PACKET					pCrPkt;
	NTSTATUS						status;
	PIPXSPX_HDR						pIpxSpxHdr;
	PSPX_FIND_ROUTE_REQUEST			pFindRouteReq;
	CTELockHandle					lockHandleConn, lockHandleAddr, lockHandleDev;
	PSPX_ADDR						pSpxAddr;
	BOOLEAN							locksHeld = TRUE;
    PNDIS_BUFFER                    NdisBuf, NdisBuf2;
    ULONG                           BufLen =0;

	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(pRequest);

	//	Unpack the connect parameters
	pParam 	= (PTDI_REQUEST_KERNEL_CONNECT)REQUEST_PARAMETERS(pRequest);
	pTdiAddr= SpxParseTdiAddress(
				pParam->RequestConnectionInformation->RemoteAddress);

	DBGPRINT(CONNECT, DBG,
			("SpxConnConnect: Remote SOCKET %lx on %lx.%lx\n",
				pTdiAddr->Socket,
				pSpxConnFile,
				pRequest));

	//	Check if the connection is in a valid state
	if ((status = SpxConnFileVerify(pSpxConnFile)) != STATUS_SUCCESS)
	{
		return(status);
	}

	do
	{
		if ((pFindRouteReq =
			(PSPX_FIND_ROUTE_REQUEST)SpxAllocateMemory(
										sizeof(SPX_FIND_ROUTE_REQUEST))) == NULL)
		{
			status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}
										
		//	Check if connection is associated, if so, the association cannot
		//	go away until the reference above is removed. So we are safe in
		//	releasing the lock.
		CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);
		status = STATUS_INVALID_ADDRESS;
		if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_ASSOC))
		{
			status		= STATUS_SUCCESS;
			pSpxAddr	= pSpxConnFile->scf_AddrFile->saf_Addr;

			//	See if this connection is to be a spx2 connection.
			SPX_CONN_RESETFLAG(pSpxConnFile,
								(SPX_CONNFILE_SPX2 	|
								 SPX_CONNFILE_NEG	|
								 SPX_CONNFILE_STREAM));

			if ((PARAM(CONFIG_DISABLE_SPX2) == 0) &&
				(pSpxConnFile->scf_AddrFile->saf_Flags & SPX_ADDRFILE_SPX2))
			{
				DBGPRINT(CONNECT, DBG,
						("SpxConnConnect: SPX2 requested %lx\n",
							pSpxConnFile));

				SPX_CONN_SETFLAG(
					pSpxConnFile, (SPX_CONNFILE_SPX2 | SPX_CONNFILE_NEG));
			}

			if (pSpxConnFile->scf_AddrFile->saf_Flags & SPX_ADDRFILE_STREAM)
			{
				DBGPRINT(CONNECT, DBG,
						("SpxConnConnect: SOCK_STREAM requested %lx\n",
							pSpxConnFile));

				SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_STREAM);
			}

			if (pSpxConnFile->scf_AddrFile->saf_Flags & SPX_ADDRFILE_NOACKWAIT)
			{
				DBGPRINT(CONNECT, ERR,
						("SpxConnConnect: NOACKWAIT requested %lx\n",
							pSpxConnFile));

				SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_NOACKWAIT);
			}

			if (pSpxConnFile->scf_AddrFile->saf_Flags & SPX_ADDRFILE_IPXHDR)
			{
				DBGPRINT(CONNECT, ERR,
						("spxConnHandleConnReq: IPXHDR requested %lx\n",
							pSpxConnFile));

				SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_IPXHDR);
			}
		}
		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
	
	} while (FALSE);

	if (!NT_SUCCESS(status))
	{
		DBGPRINT(CONNECT, ERR,
				("SpxConnConnect: Failed %lx\n", status));

		if (pFindRouteReq)
		{
			SpxFreeMemory(pFindRouteReq);
		}

		return(status);
	}

	CTEGetLock(&SpxDevice->dev_Lock, &lockHandleDev);
	CTEGetLock(&pSpxAddr->sa_Lock, &lockHandleAddr);
	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);
	locksHeld = TRUE;

	status = STATUS_INVALID_CONNECTION;
	if (SPX_CONN_IDLE(pSpxConnFile) &&
		((pSpxConnFile->scf_LocalConnId = spxConnGetId()) != 0))
	{
        //
        // If this was a post-inactivated file, clear the disconnect flags
        //
        if ((SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN) &&
            (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_INACTIVATED)) {

            SPX_DISC_SETSTATE(pSpxConnFile, 0);
        }

		SPX_MAIN_SETSTATE(pSpxConnFile, SPX_CONNFILE_CONNECTING);
		pSpxConnFile->scf_CRetryCount 	= PARAM(CONFIG_CONNECTION_COUNT);

		if (((USHORT)PARAM(CONFIG_WINDOW_SIZE) == 0) ||
            ((USHORT)PARAM(CONFIG_WINDOW_SIZE) > MAX_WINDOW_SIZE))
		{
            PARAM(CONFIG_WINDOW_SIZE) = DEFAULT_WINDOW_SIZE;
		}

		pSpxConnFile->scf_SentAllocNum	= (USHORT)(PARAM(CONFIG_WINDOW_SIZE) - 1);

		//	Move connection from inactive list to non-inactive list.
		if (!NT_SUCCESS(spxConnRemoveFromList(
							&pSpxAddr->sa_InactiveConnList,
							pSpxConnFile)))
		{
			//	This should never happen!
			KeBugCheck(0);
		}

		//	Put connection in the non-inactive list. Connection id must be set.
		SPX_INSERT_ADDR_ACTIVE(
			pSpxAddr,
			pSpxConnFile);

		//	 Insert in the global connection tree on device
		spxConnInsertIntoGlobalActiveList(
			pSpxConnFile);

		//	Store the remote address in the connection.
		//	!!NOTE!! We get both the network/socket in network form.
		*((UNALIGNED ULONG *)(pSpxConnFile->scf_RemAddr)) =
			*((UNALIGNED ULONG *)(&pTdiAddr->NetworkAddress));

		RtlCopyMemory(
			pSpxConnFile->scf_RemAddr+4,
			pTdiAddr->NodeAddress,
			6);

		*((UNALIGNED USHORT *)(pSpxConnFile->scf_RemAddr+10)) =
			*((UNALIGNED USHORT *)(&pTdiAddr->Socket));

		//	Ok, we are all set, build connect packet, queue it into connection
		//	with the connect request. Ndis buffer already describes this memory
		//	Build IPX header.

        pCrPkt = NULL;   // so it knows to allocate one.

		SpxPktBuildCr(
			pSpxConnFile,
			pSpxAddr,
			&pCrPkt,
			SPX_SENDPKT_IDLE,
			SPX2_CONN(pSpxConnFile));

		if (pCrPkt != NULL)
		{
    		//	Remember the request in the connection
            //
            // Dont queue for the failure case since we complete it in SpxInternalDispatch.
            //
    		InsertTailList(
    			&pSpxConnFile->scf_ReqLinkage,
    			REQUEST_LINKAGE(pRequest));

			SpxConnQueueSendPktTail(pSpxConnFile, pCrPkt);
	
            //
            // Get the MDL that points to the IPX/SPX header. (the second one)
            //

            NdisQueryPacket(pCrPkt, NULL, NULL, &NdisBuf, NULL);
            NdisGetNextBuffer(NdisBuf, &NdisBuf2);
            NdisQueryBufferSafe(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen, HighPagePriority);
			ASSERT(pIpxSpxHdr != NULL);	// Can't fail since it is already mapped
			
#if OWN_PKT_POOLS
            pIpxSpxHdr	= (PIPXSPX_HDR)((PBYTE)pCrPkt +
										NDIS_PACKET_SIZE +
										sizeof(SPX_SEND_RESD) +
										IpxInclHdrOffset);
#endif	
			//	Initialize the find route request
			*((UNALIGNED ULONG *)pFindRouteReq->fr_FindRouteReq.Network)=
				*((UNALIGNED ULONG *)pIpxSpxHdr->hdr_DestNet);

         //
         // [SA] Bug #15094
         // We need to also pass in the node number to IPX so that IPX can
         // compare the node addresses to determine the proper WAN NICid
         //

         // RtlCopyMemory (pFindRouteReq->fr_FindRouteReq.Node, pIpxSpxHdr->hdr_DestNode, 6) ;

           *((UNALIGNED ULONG *)pFindRouteReq->fr_FindRouteReq.Node)=
		    *((UNALIGNED ULONG *)pIpxSpxHdr->hdr_DestNode);

		 *((UNALIGNED USHORT *)(pFindRouteReq->fr_FindRouteReq.Node+4))=
		    *((UNALIGNED USHORT *)(pIpxSpxHdr->hdr_DestNode+4));

		 DBGPRINT(CONNECT, DBG,
					("SpxConnConnect: NETWORK %lx\n",
						*((UNALIGNED ULONG *)pIpxSpxHdr->hdr_DestNet)));

		 DBGPRINT(CONNECT, DBG,
					("SpxConnConnect: NODE %02x-%02x-%02x-%02x-%02x-%02x\n",
					   pFindRouteReq->fr_FindRouteReq.Node[0], pFindRouteReq->fr_FindRouteReq.Node[1],
                       pFindRouteReq->fr_FindRouteReq.Node[2], pFindRouteReq->fr_FindRouteReq.Node[3],
                       pFindRouteReq->fr_FindRouteReq.Node[4], pFindRouteReq->fr_FindRouteReq.Node[5]));

         pFindRouteReq->fr_FindRouteReq.Identifier 	= IDENTIFIER_SPX;
			pFindRouteReq->fr_Ctx						= pSpxConnFile;

			//	We wont force a rip for every connection. Only if its not
			//	in the IPX database.
            pFindRouteReq->fr_FindRouteReq.Type	 = IPX_FIND_ROUTE_RIP_IF_NEEDED;

			//	Reference for the find route. So that abort connect wont
			//	free up the connection until we return from here.
			SpxConnFileLockReference(pSpxConnFile, CFREF_FINDROUTE);
			status = STATUS_PENDING;
		}
		else
		{
			//	Abort connect attempt.
			spxConnAbortConnect(
				pSpxConnFile,
				status,
				lockHandleDev,
				lockHandleAddr,
				lockHandleConn);

            CTEAssert(pSpxConnFile->scf_ConnectReq == NULL);

			locksHeld = FALSE;
			status = STATUS_INSUFFICIENT_RESOURCES;
		}
	}

	if (locksHeld)
	{
		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
		CTEFreeLock(&pSpxAddr->sa_Lock, lockHandleAddr);
		CTEFreeLock(&SpxDevice->dev_Lock, lockHandleDev);
	}

	if (NT_SUCCESS(status))
	{
		//	Start off the find route request, We send the packet in completion.
		//	The verify reference is kept until the connect request completes.
        //  If connecting to network 0 we don't do this, proceed to find
        //  route completion which will send the request on very card.

		if (*((UNALIGNED ULONG *)(pSpxConnFile->scf_RemAddr)) == 0) {

            SpxFindRouteComplete(
                &pFindRouteReq->fr_FindRouteReq,
                TRUE);

        } else {

    		(*IpxFindRoute)(
    			&pFindRouteReq->fr_FindRouteReq);
        }
	}
	else
	{
		DBGPRINT(CONNECT, ERR,
				("SpxConnConnect: Failed %lx\n", status));

		SpxFreeMemory(pFindRouteReq);
		SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	}

	return(status);
}




NTSTATUS
SpxConnListen(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest
	)

/*++

Routine Description:


Arguments:

	We assume the connection passed in is already associated with an address.
	If it is not, we will die! Is that ok?

Return Value:


--*/

{
	NTSTATUS						status;
	CTELockHandle					lockHandle1, lockHandle2;
	PSPX_ADDR						pSpxAddr;

	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(pRequest);

	//	Check if the connection is in a valid state
	if ((status = SpxConnFileVerify(pSpxConnFile)) != STATUS_SUCCESS)
	{
		return(status);
	}

	//	Check if connection is associated, if so, the association cannot
	//	go away until the reference above is removed. So we are safe in
	//	releasing the lock.
	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle2);
	status = STATUS_INVALID_ADDRESS;
	if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_ASSOC))
	{
		status		= STATUS_SUCCESS;
		pSpxAddr	= pSpxConnFile->scf_AddrFile->saf_Addr;

		//	See if this connection is to be a spx2 connection.
		SPX_CONN_RESETFLAG(pSpxConnFile,
							(SPX_CONNFILE_SPX2 	|
							 SPX_CONNFILE_NEG	|
							 SPX_CONNFILE_STREAM));

		if (pSpxConnFile->scf_AddrFile->saf_Flags & SPX_ADDRFILE_SPX2)
		{
			SPX_CONN_SETFLAG(
				pSpxConnFile, (SPX_CONNFILE_SPX2 | SPX_CONNFILE_NEG));
		}

		if (pSpxConnFile->scf_AddrFile->saf_Flags & SPX_ADDRFILE_STREAM)
		{
			SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_STREAM);
		}

		if (pSpxConnFile->scf_AddrFile->saf_Flags & SPX_ADDRFILE_NOACKWAIT)
		{
			DBGPRINT(CONNECT, ERR,
					("SpxConnConnect: NOACKWAIT requested %lx\n",
						pSpxConnFile));

			SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_NOACKWAIT);
		}

		if (pSpxConnFile->scf_AddrFile->saf_Flags & SPX_ADDRFILE_IPXHDR)
		{
			DBGPRINT(CONNECT, ERR,
					("spxConnHandleConnReq: IPXHDR requested %lx\n",
						pSpxConnFile));
	
			SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_IPXHDR);
		}
	}
	CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle2);

	if (NT_SUCCESS(status))
	{
		CTEGetLock(&pSpxAddr->sa_Lock, &lockHandle1);
		CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle2);
		status = STATUS_INVALID_CONNECTION;
		if (SPX_CONN_IDLE(pSpxConnFile))
		{
			SPX_MAIN_SETSTATE(pSpxConnFile, SPX_CONNFILE_LISTENING);
	
			//	Move connection from inactive list to listening list.
			if (NT_SUCCESS(spxConnRemoveFromList(
								&pSpxAddr->sa_InactiveConnList,
								pSpxConnFile)))
			{
				//	Put connection in the listening list.
				SPX_INSERT_ADDR_LISTEN(pSpxAddr, pSpxConnFile);
		
				InsertTailList(
					&pSpxConnFile->scf_ReqLinkage,
					REQUEST_LINKAGE(pRequest));
		
				status = STATUS_PENDING;
			}
			else
			{
				//	This should never happen!
				KeBugCheck(0);
			}
		}
		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle2);
		CTEFreeLock(&pSpxAddr->sa_Lock, lockHandle1);
	}


	if (!NT_SUCCESS(status))
	{
		SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	}

	return(status);
}




NTSTATUS
SpxConnAccept(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PSPX_ADDR 		pSpxAddr;
	NTSTATUS		status;
	CTELockHandle	lockHandleConn, lockHandleAddr, lockHandleDev;
	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(pRequest);

	DBGPRINT(CONNECT, DBG,
			("SpxConnAccept: %lx\n", pSpxConnFile));

	//	Check if the connection is in a valid state
	if ((status = SpxConnFileVerify(pSpxConnFile)) != STATUS_SUCCESS)
	{
		return (status);
	}

	//	Check if we are in the correct state and associated.
	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);
	status = STATUS_INVALID_CONNECTION;
	if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_ASSOC))
	{
		status		= STATUS_SUCCESS;
		pSpxAddr	= pSpxConnFile->scf_AddrFile->saf_Addr;
	}
	CTEFreeLock (&pSpxConnFile->scf_Lock, lockHandleConn);

	if (NT_SUCCESS(status))
	{
		//	Grab all three locks
		CTEGetLock(&SpxDevice->dev_Lock, &lockHandleDev);
		CTEGetLock(pSpxConnFile->scf_AddrFile->saf_AddrLock, &lockHandleAddr);
		CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);

		status = STATUS_INVALID_CONNECTION;
		if ((SPX_CONN_LISTENING(pSpxConnFile)) &&
			(SPX_LISTEN_STATE(pSpxConnFile) == SPX_LISTEN_RECDREQ))
		{
			InsertTailList(
				&pSpxConnFile->scf_ReqLinkage,
				REQUEST_LINKAGE(pRequest));
	
			//	Call acceptcr now.
			spxConnAcceptCr(
					pSpxConnFile,
					pSpxAddr,
					lockHandleDev,
					lockHandleAddr,
					lockHandleConn);
	
			DBGPRINT(CONNECT, DBG,
					("SpxConnAccept: Accepted\n"));
	
			status = STATUS_PENDING;
		}
		else
		{
			//	Free all locks.
			CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
			CTEFreeLock(pSpxConnFile->scf_AddrFile->saf_AddrLock, lockHandleAddr);
			CTEFreeLock(&SpxDevice->dev_Lock, lockHandleDev);
		}
	}

	//	Remove reference. Note: Listen reference will exist if ok. And that will
	//	be transferred to the fact that the connection is active when accepted.
	SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	return(status);
}




NTSTATUS
SpxConnDisconnect(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest
	)
/*++

Routine Description:

	If active, we do the following.
	If informative disconnect, just remember the request in the connection.
	We do not ref for request. Assume it will always be checked for when
	changing from disconnect to idle.

Arguments:


Return Value:


--*/
{
	PTDI_REQUEST_KERNEL_DISCONNECT 	pParam;
	NTSTATUS						status;
	CTELockHandle					lockHandleConn;
	BOOLEAN							lockHeld;
	SPX_SENDREQ_TYPE				reqType;
	int								numDerefs = 0;
	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(pRequest);

	pParam 	= (PTDI_REQUEST_KERNEL_DISCONNECT)REQUEST_PARAMETERS(pRequest);

	//	Check if the connection is in a valid state
	if ((status = SpxConnFileVerify(pSpxConnFile)) != STATUS_SUCCESS)
	{
		return(status);
	}

	//	Deref unless the disc request gets queued in as a send request.
	numDerefs++;

	DBGPRINT(CONNECT, DBG,
			("spxConnDisconnect: %lx On %lx when %lx.%lx %lx Params %lx\n",
				pRequest, pSpxConnFile, SPX_MAIN_STATE(pSpxConnFile),
				SPX_DISC_STATE(pSpxConnFile),
				SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC),
                SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_ODISC),
				pParam->RequestFlags));

	DBGPRINT(CONNECT, DBG,
			("SpxConnDisconnect: %lx\n", pSpxConnFile));

	//	Check if we are in the correct state and associated.
	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);
	lockHeld = TRUE;
	switch (pParam->RequestFlags)
	{
	case TDI_DISCONNECT_WAIT:

		//	If informative disconnect, just remember in the connection.
		status = STATUS_INVALID_CONNECTION;
		if (!SPX_CONN_IDLE(pSpxConnFile))
		{
			InsertTailList(
				&pSpxConnFile->scf_DiscLinkage,
				REQUEST_LINKAGE(pRequest));

			status = STATUS_PENDING;
		}
	
		break;

	case TDI_DISCONNECT_ABORT:
	case TDI_DISCONNECT_RELEASE:

		//	NOTE! We don't honor the async disconnect symantics of tdi
		//		  but map them to an abortive disconnect.
		//	NOTE! If our send list is not empty but our client tries to
		//		  do a orderly release, we just queue the ord rel as a send
		//		  data request. In process ack, we check for the next packet
		//		  to not be a ord rel before giving up on window closure.
		//	NOTE! For spx1 connection, map TDI_DISCONNECT_RELEASE to
		//		  TDI_DISCONNECT_ABORT (Informed disconnect)

		if (!SPX2_CONN(pSpxConnFile))
		{
			pParam->RequestFlags = TDI_DISCONNECT_ABORT;
		}

		switch (SPX_MAIN_STATE(pSpxConnFile))
		{
		case SPX_CONNFILE_ACTIVE:
	
			//	Since we are not a timer disconnect, then we need to keep
			//	retrying the disconnect packet. Change state to DISCONN if this
			//	is not an orderly release or we previously received an orderly
			//	release and are now confirming it.
			//	Retry timer will now keep sending out the disconnect packet.

			reqType = SPX_REQ_DISC;
			if (pParam->RequestFlags == TDI_DISCONNECT_RELEASE)
			{
				SPX_DISC_SETSTATE(pSpxConnFile, SPX_DISC_POST_ORDREL);
                reqType = SPX_REQ_ORDREL;
			}
			else
			{
				//	Abortive disconnect
				SPX_MAIN_SETSTATE(pSpxConnFile, SPX_CONNFILE_DISCONN);
				SPX_DISC_SETSTATE(pSpxConnFile, SPX_DISC_POST_IDISC);
				numDerefs++;

				spxConnAbortSends(
					pSpxConnFile,
					STATUS_LOCAL_DISCONNECT,
					SPX_CALL_TDILEVEL,
					lockHandleConn);
	
				CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);

				//	Abort all receives if we are informed disconnect.
				spxConnAbortRecvs(
					pSpxConnFile,
					STATUS_LOCAL_DISCONNECT,
					SPX_CALL_TDILEVEL,
					lockHandleConn);
	
				CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);

				//	Since we released the lock, a remote IDISC could have come
				//	in in which case we really don't want to queue in the disc
				//	request. Instead, we set it as the disc request in the
				//	connection if one is not already there.
				if (SPX_DISC_STATE(pSpxConnFile) != SPX_DISC_POST_IDISC)
				{
					DBGPRINT(CONNECT, ERR,
							("SpxConnDisconnect: DISC not POST! %lx.%lx\n",
								pSpxConnFile, SPX_DISC_STATE(pSpxConnFile)));
				
					InsertTailList(
						&pSpxConnFile->scf_DiscLinkage,
						REQUEST_LINKAGE(pRequest));

					status = STATUS_PENDING;
					break;
				}
			}

			//	!NOTE
			//	AbortSends might leave send requests around as packets might
			//	have been with ipx at the time. That is why SendComplete should
			//	never call AbortSends but must call AbortPkt else it may complete
			//	the following disconnect request prematurely.

			//	Creation reference for request.
			REQUEST_INFORMATION(pRequest) = 1;
	
			//	If we have no current requests, queue it in and
			//	set it to be the current request, else just queue it in.
			//	There may be other pending requests in queue.	
			if (pSpxConnFile->scf_ReqPkt == NULL)
			{
				pSpxConnFile->scf_ReqPkt 		= pRequest;
				pSpxConnFile->scf_ReqPktOffset 	= 0;
				pSpxConnFile->scf_ReqPktSize 	= 0;
				pSpxConnFile->scf_ReqPktType	= reqType;
			}
	
			InsertTailList(
				&pSpxConnFile->scf_ReqLinkage,
				REQUEST_LINKAGE(pRequest));

			//	Do not deref the connection, it is taken by the pending request
			numDerefs--;

			//	We packetize only upto the window we have.
			if (SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_IDLE)
			{
				SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_PACKETIZE);
				SpxConnPacketize(
					pSpxConnFile,
					TRUE,
					lockHandleConn);

				lockHeld = FALSE;
			}

			status	  = STATUS_PENDING;
			break;
	
		case SPX_CONNFILE_CONNECTING:
		case SPX_CONNFILE_LISTENING:
	
			spxConnAbortiveDisc(
				pSpxConnFile,
				STATUS_INSUFFICIENT_RESOURCES,
				SPX_CALL_TDILEVEL,
				lockHandleConn,
                FALSE);         // [SA] Bug #15249
	
			lockHeld = FALSE;
			status = STATUS_SUCCESS;
			break;

		case SPX_CONNFILE_DISCONN:

			//	When we queue in a disconnect as a send request, we expect
			//	to be able to set it into the scf_DiscReq when it is done.
			//	So we don't use scf_DiscReq here. This will be a problem if
			//	the client has a InformDiscReq pending, and a remote disconnect
			//	comes in, *and* the client then does a disc. We will be completing
			//	the request with STATUS_INVALID_CONNECTION.
			status = STATUS_INVALID_CONNECTION;
			if (pParam->RequestFlags != TDI_DISCONNECT_RELEASE)
			{
				InsertTailList(
					&pSpxConnFile->scf_DiscLinkage,
					REQUEST_LINKAGE(pRequest));

				status = STATUS_PENDING;

                //
                // If this is a disconnect for a connection which was already
                // disconnected (but AFD's disconnect handler was not called
                // because the connfile could not be placed in the inactive list),
                // set this flag so that the disconnect is not called from
                // ConnInactivate now that the disconnect has occured here.
                //
        		if (!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC)) {
                    SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC);
                }

                //
                // If this was an SPXI connection where we indicated TDI_DISCONNECT_RELEASE
                // to AFD, the ref count was bumped up to indicate a wait for local disconnect
                // from AFD. Now that we have this disconnect, deref the connection file. Now
                // we are ready to truly inactivate this connection file.
                //
                if (SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_DISC_WAIT)) {

                    CTEAssert( (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_INACTIVATED) &&
                                SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC));

                    CTEAssert(pSpxConnFile->scf_RefTypes[CFREF_DISCWAITSPX]);

                    SPX_CONN_RESETFLAG2(pSpxConnFile, SPX_CONNFILE2_DISC_WAIT);

            		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
                    lockHeld = FALSE;

                    SpxConnFileDereference(pSpxConnFile, CFREF_DISCWAITSPX);
                }
			}

			break;

		default:
	
			//	Should never happen!
			status = STATUS_INVALID_CONNECTION;
		}
	
		break;

	default:

		status = STATUS_INVALID_PARAMETER;
		break;
	}

	if (lockHeld)
	{
		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
	}

	DBGPRINT(CONNECT, INFO,
			("SpxConnDisconnect: returning for %lx.%lx\n", pSpxConnFile, status));

	while (numDerefs-- > 0)
	{
		SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	}

	return(status);
}		




NTSTATUS
SpxConnSend(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PTDI_REQUEST_KERNEL_SEND	 	pParam;
	NTSTATUS						status;
	CTELockHandle					lockHandleConn;
	BOOLEAN							lockHeld;
	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(pRequest);

	pParam 	= (PTDI_REQUEST_KERNEL_SEND)REQUEST_PARAMETERS(pRequest);

	//	Check if the connection is in a valid state
	if ((status = SpxConnFileVerify(pSpxConnFile)) != STATUS_SUCCESS)
	{
		return(status);
	}

	DBGPRINT(SEND, DBG,
			("SpxConnSend: %lx.%lx.%lx.%lx\n",
				pSpxConnFile, pRequest, pParam->SendLength, pParam->SendFlags));


	//	Check if we are in the correct state and associated.
	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);
	lockHeld 	= TRUE;

	DBGPRINT(SEND, INFO,
			("Send: %lx.%lx.%lx\n",
				pParam->SendLength, pParam->SendFlags, pRequest));

	status		= STATUS_PENDING;
	do
	{
		if (SPX_CONN_ACTIVE(pSpxConnFile) &&
			((SPX_DISC_STATE(pSpxConnFile) != SPX_DISC_POST_ORDREL) &&
			 (SPX_DISC_STATE(pSpxConnFile) != SPX_DISC_SENT_ORDREL) &&
			 (SPX_DISC_STATE(pSpxConnFile) != SPX_DISC_ORDREL_ACKED)))
		{
			//	Creation reference for request.
			REQUEST_INFORMATION(pRequest) = 1;
	
			//	If we have no current requests, queue it in and
			//	set it to be the current request, else just queue it in.
			//	There may be other pending requests in queue.	
			if (pSpxConnFile->scf_ReqPkt == NULL)
			{
				DBGPRINT(SEND, INFO,
						("%lx\n",
							pRequest));

				pSpxConnFile->scf_ReqPkt 		= pRequest;
				pSpxConnFile->scf_ReqPktOffset 	= 0;
				pSpxConnFile->scf_ReqPktSize 	= pParam->SendLength;
				pSpxConnFile->scf_ReqPktFlags	= pParam->SendFlags;
				pSpxConnFile->scf_ReqPktType	= SPX_REQ_DATA;
			}
	
			InsertTailList(
				&pSpxConnFile->scf_ReqLinkage,
				REQUEST_LINKAGE(pRequest));
		}
		else
		{
            //
            // [SA] Bug #14655
            // Return the correct error message in case a send fails due to remote disconnect
            //

            if ((SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN) &&
                ((SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_ABORT) ||
                (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_INACTIVATED)))
            {
                status = STATUS_REMOTE_DISCONNECT ;
            }
            else
            {
                status = STATUS_INVALID_CONNECTION;
            }

        	break;
		}

		//	We packetize only upto the window we have.
		if (SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_IDLE)
		{
			SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_PACKETIZE);
			SpxConnPacketize(pSpxConnFile, TRUE, lockHandleConn);
			lockHeld = FALSE;
		}

	} while (FALSE);


	if (lockHeld)
	{
		CTEFreeLock (&pSpxConnFile->scf_Lock, lockHandleConn);
	}

	if (!NT_SUCCESS(status))
	{
		SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	}

	return(status);
}




NTSTATUS
SpxConnRecv(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NTSTATUS		status;
	CTELockHandle	lockHandle;
	BOOLEAN			fLockHeld;
	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(pRequest);

	//	Check if the connection is in a valid state
	if ((status = SpxConnFileVerify(pSpxConnFile)) != STATUS_SUCCESS)
	{
		return(status);
	}

	DBGPRINT(CONNECT, DBG,
			("SpxConnReceive: %lx.%lx\n", pSpxConnFile, pRequest));

	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
	fLockHeld	= TRUE;
	status		= STATUS_INVALID_CONNECTION;
	if (SPX_CONN_ACTIVE(pSpxConnFile) &&
		!(SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_ODISC)))
	{
		status = STATUS_PENDING;

		//	This routine adds its own reference.
		SpxConnQueueRecv(pSpxConnFile, pRequest);
	
		//	If recv pkt queue is non-empty then we have buffered data. Call
		//	process pkts/receives.
		if ((SPX_RECV_STATE(pSpxConnFile) == SPX_RECV_IDLE) ||
            (SPX_RECV_STATE(pSpxConnFile) == SPX_RECV_POSTED))
		{
			SpxRecvProcessPkts(pSpxConnFile, lockHandle);
			fLockHeld	= FALSE;
		}
	}

	if (fLockHeld)
	{
		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
	}

	SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	return(status);
}




NTSTATUS
SpxConnAction(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    NTSTATUS 		Status;
    UINT 			BufferLength;
    UINT 			DataLength;
    PNDIS_BUFFER 	NdisBuffer;
    PNWLINK_ACTION 	NwlinkAction;
	CTELockHandle	lockHandle;
    PIPX_SPXCONNSTATUS_DATA	pGetStats;
    PSPX_CONN_FILE 	pSpxConnFile	= NULL;
	PSPX_ADDR_FILE	pSpxAddrFile	= NULL;
    static UCHAR BogusId[4] = { 0x01, 0x00, 0x00, 0x00 };   // old nwrdr uses this

    //
    // To maintain some compatibility with the NWLINK streams-
    // based transport, we use the streams header format for
    // our actions. The old transport expected the action header
    // to be in InputBuffer and the output to go in OutputBuffer.
    // We follow the TDI spec, which states that OutputBuffer
    // is used for both input and output. Since IOCTL_TDI_ACTION
    // is method out direct, this means that the output buffer
    // is mapped by the MDL chain; for action the chain will
    // only have one piece so we use it for input and output.
    //

    NdisBuffer = REQUEST_NDIS_BUFFER(pRequest);
    if (NdisBuffer == NULL)
	{
        return STATUS_INVALID_PARAMETER;
    }

    NdisQueryBufferSafe(
		REQUEST_NDIS_BUFFER(pRequest), (PVOID *)&NwlinkAction, &BufferLength, LowPagePriority);
	if (NwlinkAction == NULL)
	{
		return(STATUS_INSUFFICIENT_RESOURCES);
	}

    // Make sure we have enough room for just the header not
    // including the data.
    if (BufferLength < (UINT)(FIELD_OFFSET(NWLINK_ACTION, Data[0])))
    {
        DBGPRINT(ACTION, ERR,
		 ("Nwlink action failed, buffer too small\n"));

        return STATUS_BUFFER_TOO_SMALL;
    }

    if ((!RtlEqualMemory ((PVOID)(&NwlinkAction->Header.TransportId), "MISN", 4)) &&
        (!RtlEqualMemory ((PVOID)(&NwlinkAction->Header.TransportId), "MIPX", 4)) &&
        (!RtlEqualMemory ((PVOID)(&NwlinkAction->Header.TransportId), "XPIM", 4)) &&
        (!RtlEqualMemory ((PVOID)(&NwlinkAction->Header.TransportId), BogusId, 4))) {
        return STATUS_NOT_SUPPORTED;
    }


    DataLength = BufferLength - FIELD_OFFSET(NWLINK_ACTION, Data[0]);

    // Make sure that the correct file object is being used.
	switch (NwlinkAction->OptionType)
	{
	case NWLINK_OPTION_CONNECTION:

        if (REQUEST_OPEN_TYPE(pRequest) != (PVOID)TDI_CONNECTION_FILE)
		{
            DBGPRINT(ACTION, ERR,
					("Nwlink action failed, not connection file\n"));

            return STATUS_INVALID_HANDLE;
        }

        pSpxConnFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(pRequest);

		if ((Status = SpxConnFileVerify(pSpxConnFile)) != STATUS_SUCCESS)
			return(Status);

		break;

	case NWLINK_OPTION_ADDRESS:

        if (REQUEST_OPEN_TYPE(pRequest) != (PVOID)TDI_TRANSPORT_ADDRESS_FILE)
		{
            DBGPRINT(ACTION, ERR,
					("Nwlink action failed, not address file\n"));

            return STATUS_INVALID_HANDLE;
        }

        pSpxAddrFile = (PSPX_ADDR_FILE)REQUEST_OPEN_CONTEXT(pRequest);

		if ((Status = SpxAddrFileVerify(pSpxAddrFile)) != STATUS_SUCCESS)
			return(Status);

		break;

	default:

        DBGPRINT(ACTION, ERR,
				("Nwlink action failed, option type %d\n",
					NwlinkAction->OptionType));

		return STATUS_INVALID_HANDLE;
	}

    // Handle the requests based on the action code. For these
    // requests ActionHeader->ActionCode is 0, we use the
    // Option field in the streams header instead.

    Status = STATUS_SUCCESS;

	DBGPRINT(ACTION, INFO,
			("SpxConnAction: Option %x\n", NwlinkAction->Option));

    switch (NwlinkAction->Option)
	{

    //
    // This first group support the winsock helper dll.
    // In most cases the corresponding sockopt is shown in
    // the comment, as well as the contents of the Data
    // part of the action buffer.
    //

    case MSPX_SETDATASTREAM:

		if (pSpxConnFile == NULL)
		{
			Status = STATUS_INVALID_HANDLE;
			break;
		}

        if (DataLength >= 1)
		{
            DBGPRINT(ACTION, INFO,
					("%lx: MIPX_SETSENDPTYPE %x\n",
						pSpxConnFile, NwlinkAction->Data[0]));

			pSpxConnFile->scf_DataType = NwlinkAction->Data[0];
        }
		else
		{
            Status = STATUS_BUFFER_TOO_SMALL;
        }

        break;

    case MSPX_SENDHEADER:

        DBGPRINT(ACTION, INFO,
				("%lx: MSPX_SENDHEADER\n", pSpxAddrFile));

		if (pSpxAddrFile == NULL)
		{
			  Status = STATUS_INVALID_HANDLE;
              break;
		}

		   CTEGetLock(pSpxAddrFile->saf_AddrLock, &lockHandle);
		   pSpxAddrFile->saf_Flags |= SPX_ADDRFILE_IPXHDR;
		   CTEFreeLock(pSpxAddrFile->saf_AddrLock, lockHandle);
           break ;

    case MSPX_NOSENDHEADER:

        DBGPRINT(ACTION, INFO,
				("%lx: MSPX_NOSENDHEADER\n", pSpxAddrFile));

		if (pSpxAddrFile == NULL)
		{
                 Status = STATUS_INVALID_HANDLE;
                 break;
		}

		   CTEGetLock(pSpxAddrFile->saf_AddrLock, &lockHandle);
		   pSpxAddrFile->saf_Flags &= ~SPX_ADDRFILE_IPXHDR;
		   CTEFreeLock(pSpxAddrFile->saf_AddrLock, lockHandle);
           break;

	case MSPX_GETSTATS:

        DBGPRINT(ACTION, INFO,
				("%lx: MSPX_GETSTATS\n", pSpxConnFile));


		if (pSpxConnFile == NULL)
		{
		   Status = STATUS_INVALID_HANDLE;
                   DBGPRINT(ACTION, INFO,
				("pSpxConnFile is NULL. %lx: MSPX_GETSTATS\n", pSpxConnFile));
		   break;
		}

		CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
		if (!SPX_CONN_IDLE(pSpxConnFile))
		{
            USHORT TempRetryCount;

            //
            // Status fields are returned in network order.
            //

			pGetStats = (PIPX_SPXCONNSTATUS_DATA)&NwlinkAction->Data[0];

            switch (SPX_MAIN_STATE(pSpxConnFile)) {
            case SPX_CONNFILE_LISTENING: pGetStats->ConnectionState = 1; break;
            case SPX_CONNFILE_CONNECTING: pGetStats->ConnectionState = 2; break;
            case SPX_CONNFILE_ACTIVE: pGetStats->ConnectionState = 3; break;
            case SPX_CONNFILE_DISCONN: pGetStats->ConnectionState = 4; break;
            default: pGetStats->ConnectionState = 0;
            }
			pGetStats->WatchDogActive		= 1;	// Always 1
			GETSHORT2SHORT(                    // scf_LocalConnId is in host order
				&pGetStats->LocalConnectionId,
				&pSpxConnFile->scf_LocalConnId);
			pGetStats->RemoteConnectionId		= pSpxConnFile->scf_RemConnId;
	
			GETSHORT2SHORT(&pGetStats->LocalSequenceNumber, &pSpxConnFile->scf_SendSeqNum);
			GETSHORT2SHORT(&pGetStats->LocalAckNumber, &pSpxConnFile->scf_RecvSeqNum);
			GETSHORT2SHORT(&pGetStats->LocalAllocNumber, &pSpxConnFile->scf_SentAllocNum);
			GETSHORT2SHORT(&pGetStats->RemoteAckNumber, &pSpxConnFile->scf_RecdAckNum);
			GETSHORT2SHORT(&pGetStats->RemoteAllocNumber, &pSpxConnFile->scf_RecdAllocNum);

			pGetStats->LocalSocket = pSpxConnFile->scf_AddrFile->saf_Addr->sa_Socket;
	
			RtlZeroMemory(pGetStats->ImmediateAddress, 6);

			//	Remote network returned in net order.
			*((ULONG UNALIGNED *)pGetStats->RemoteNetwork) =
				*((ULONG UNALIGNED *)pSpxConnFile->scf_RemAddr);
	
			RtlCopyMemory(
				pGetStats->RemoteNode,
				&pSpxConnFile->scf_RemAddr[4],
				6);
	
			pGetStats->RemoteSocket = *((UNALIGNED USHORT *)(pSpxConnFile->scf_RemAddr+10));
	
			TempRetryCount = (USHORT)pSpxConnFile->scf_WRetryCount;
			GETSHORT2SHORT(&pGetStats->RetransmissionCount, &TempRetryCount);
			GETSHORT2SHORT(&pGetStats->EstimatedRoundTripDelay, &pSpxConnFile->scf_BaseT1);
			pGetStats->RetransmittedPackets		= 0;
			pGetStats->SuppressedPacket			= 0;

			DBGPRINT(ACTION, INFO,
					("SSeq %lx RSeq %lx RecdAck %lx RemAllocNum %lx\n",
						pGetStats->LocalSequenceNumber,
						pGetStats->LocalAckNumber,
						pGetStats->RemoteAckNumber,
						pGetStats->RemoteAllocNumber));
	
			DBGPRINT(ACTION, INFO,
					("LocalSkt %lx RemSkt %lx LocConnId %lx RemConnId %lx\n",
						pGetStats->LocalSocket,
						pGetStats->RemoteSocket,
                        pGetStats->LocalConnectionId,
						pGetStats->RemoteConnectionId));
		}
		else
		{
			Status = STATUS_INVALID_CONNECTION;
		}

		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
        break;

	case MSPX_NOACKWAIT:

        DBGPRINT(ACTION, ERR,
				("%lx: MSPX_NOACKWAIT\n", pSpxAddrFile));

		if (pSpxAddrFile == NULL)
		{
			Status = STATUS_INVALID_HANDLE;
			break;
		}

		CTEGetLock(pSpxAddrFile->saf_AddrLock, &lockHandle);
		pSpxAddrFile->saf_Flags |= SPX_ADDRFILE_NOACKWAIT;
		CTEFreeLock(pSpxAddrFile->saf_AddrLock, lockHandle);
		break;

	case MSPX_ACKWAIT:

        DBGPRINT(ACTION, ERR,
				("%lx: MSPX_ACKWAIT\n", pSpxAddrFile));

		if (pSpxAddrFile == NULL)
		{
			Status = STATUS_INVALID_HANDLE;
			break;
		}

		CTEGetLock(pSpxAddrFile->saf_AddrLock, &lockHandle);
		pSpxAddrFile->saf_Flags &= ~SPX_ADDRFILE_NOACKWAIT;
		CTEFreeLock(pSpxAddrFile->saf_AddrLock, lockHandle);
		break;


    //
    // These are new for ISN (not supported in NWLINK).
    //

    // The Option was not supported, so fail.
    default:

        Status = STATUS_NOT_SUPPORTED;
        break;


    }   // end of the long switch on NwlinkAction->Option


#if DBG
    if (Status != STATUS_SUCCESS) {
        DBGPRINT(ACTION, ERR,
				("Nwlink action %lx failed, status %lx\n",
					NwlinkAction->Option, Status));
    }

#endif

	if (pSpxConnFile)
	{
		SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	}

	if (pSpxAddrFile)
	{
		SpxAddrFileDereference(pSpxAddrFile, AFREF_VERIFY);
	}

    return Status;
}




VOID
SpxConnConnectFindRouteComplete(
	IN	PSPX_CONN_FILE			pSpxConnFile,
    IN 	PSPX_FIND_ROUTE_REQUEST	pFrReq,
    IN 	BOOLEAN 				FoundRoute,
	IN	CTELockHandle			LockHandle
	)
/*++

Routine Description:

	This routine is called with the connection lock held and the conn refd.
	It should deal with both.

Arguments:


Return Value:


--*/
{
	PNDIS_PACKET	pCrPkt;
	PSPX_SEND_RESD	pSendResd;
    ULONG           Timeout;
	NTSTATUS		status = STATUS_BAD_NETWORK_PATH;

	pSendResd	= pSpxConnFile->scf_SendListHead;

	if (pSendResd == NULL) {

	   CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandle);

	   //  Remove the reference for the call.
	   SpxConnFileDereference(pSpxConnFile, CFREF_FINDROUTE);

	   return;
	}

	pCrPkt	 = (PNDIS_PACKET)CONTAINING_RECORD(
								pSendResd, NDIS_PACKET, ProtocolReserved);

	DBGPRINT(CONNECT, INFO,
			("SpxConnConnectFindRouteComplete: %lx.%d\n",
				pSpxConnFile, FoundRoute));
	
#if defined(_PNP_POWER)

    Timeout = PARAM(CONFIG_CONNECTION_TIMEOUT) * HALFSEC_TO_MS_FACTOR;
#else
	if (*((UNALIGNED ULONG *)(pSpxConnFile->scf_RemAddr)) == 0) {

        // Here we are going to send on every NIC ID. We adjust the
        // timeout down so that a full run through all the NIC IDs will
        // take one normal timeout. We don't adjust the timer below
        // 100 ms however.

	    Timeout = (PARAM(CONFIG_CONNECTION_TIMEOUT) * HALFSEC_TO_MS_FACTOR) / SpxDevice->dev_Adapters;
        if (Timeout < (HALFSEC_TO_MS_FACTOR/5)) {
            Timeout = HALFSEC_TO_MS_FACTOR / 5;
        }

    } else {

	    Timeout = PARAM(CONFIG_CONNECTION_TIMEOUT) * HALFSEC_TO_MS_FACTOR;
    }
#endif


	//	Timeout value is in half-seconds
	if ((FoundRoute) &&
		((pSpxConnFile->scf_CTimerId =
			SpxTimerScheduleEvent(
				spxConnConnectTimer,
				Timeout,
				pSpxConnFile)) != 0))
	{
		//	Add a reference for the connect timer
		SpxConnFileLockReference(pSpxConnFile, CFREF_VERIFY);


		//	If the mac address in local target is all zeros, fill it with our
		//	destination address. Also if this is a connect to network 0 fill
        //  it in with the destination address, and further down we will loop
        //  through all possible NIC IDs.
		if (((*((UNALIGNED ULONG *)
				(pFrReq->fr_FindRouteReq.LocalTarget.MacAddress)) == (ULONG)0)
			&&
			 (*((UNALIGNED USHORT *)
				(pFrReq->fr_FindRouteReq.LocalTarget.MacAddress+4)) == (USHORT)0))
            ||
    		(*((UNALIGNED ULONG *)(pSpxConnFile->scf_RemAddr)) == 0))
		{
			DBGPRINT(CONNECT, INFO,
					("SpxConnConnectFindRouteComplete: LOCAL NET\n"));

			RtlCopyMemory(
				pFrReq->fr_FindRouteReq.LocalTarget.MacAddress,
				pSpxConnFile->scf_RemAddr+4,
				6);
		}

		//	We are all set to go ahead with the connect.
		//	Timer is started on connection
		status	= STATUS_SUCCESS;

#if defined(_PNP_POWER)
        pSpxConnFile->scf_CRetryCount	= PARAM(CONFIG_CONNECTION_COUNT);
#else
		if (*((UNALIGNED ULONG *)(pSpxConnFile->scf_RemAddr)) == 0) {
		    pSpxConnFile->scf_CRetryCount	= PARAM(CONFIG_CONNECTION_COUNT) * SpxDevice->dev_Adapters;
        } else {
    		pSpxConnFile->scf_CRetryCount	= PARAM(CONFIG_CONNECTION_COUNT);
        }
#endif _PNP_POWER

		SPX_CONN_SETFLAG(pSpxConnFile,
						(SPX_CONNFILE_C_TIMER | SPX_CONNECT_SENTREQ));

		pSpxConnFile->scf_LocalTarget	= pFrReq->fr_FindRouteReq.LocalTarget;
		pSpxConnFile->scf_AckLocalTarget= pFrReq->fr_FindRouteReq.LocalTarget;
		if (*((UNALIGNED ULONG *)(pSpxConnFile->scf_RemAddr)) == 0) {
#if     defined(_PNP_POWER)
            pSpxConnFile->scf_LocalTarget.NicHandle.NicId = (USHORT)ITERATIVE_NIC_ID;
            pSpxConnFile->scf_AckLocalTarget.NicHandle.NicId = (USHORT)ITERATIVE_NIC_ID;
#else
            pSpxConnFile->scf_LocalTarget.NicId = 1;
            pSpxConnFile->scf_AckLocalTarget.NicId = 1;
#endif  _PNP_POWER
        }

		//	We will be giving the packet to ipx.
		pSendResd->sr_State			   |= SPX_SENDPKT_IPXOWNS;
		CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandle);

		//	Send the packet
		SPX_SENDPACKET(pSpxConnFile, pCrPkt, pSendResd);
	}

	if (!NT_SUCCESS(status))
	{
		CTELockHandle	lockHandleConn, lockHandleAddr, lockHandleDev;

		CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandle);

		CTEGetLock(&SpxDevice->dev_Lock, &lockHandleDev);
		CTEGetLock(pSpxConnFile->scf_AddrFile->saf_AddrLock, &lockHandleAddr);
		CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);

		DBGPRINT(CONNECT, ERR,
				("SpxConnConnectFindRouteComplete: FAILED on %lx.%d\n",
					pSpxConnFile, FoundRoute));

		spxConnAbortConnect(
			pSpxConnFile,
			status,
			lockHandleDev,
			lockHandleAddr,
			lockHandleConn);
	}

	//	Remove the reference for the call.
	SpxConnFileDereference(pSpxConnFile, CFREF_FINDROUTE);
	return;
}




VOID
SpxConnActiveFindRouteComplete(
	IN	PSPX_CONN_FILE			pSpxConnFile,
    IN 	PSPX_FIND_ROUTE_REQUEST	pFrReq,
    IN 	BOOLEAN 				FoundRoute,
	IN	CTELockHandle			LockHandle
	)
/*++

Routine Description:

	This routine is called with the connection lock held and the conn refd.
	It should deal with both.

Arguments:


Return Value:


--*/
{
	BOOLEAN		fDisconnect = TRUE;

	SPX_CONN_RESETFLAG2(pSpxConnFile, SPX_CONNFILE2_FINDROUTE);

	DBGPRINT(CONNECT, DBG,
			("SpxConnActiveFindRouteComplete: %lx.%lx\n",
				pSpxConnFile, SPX_MAIN_STATE(pSpxConnFile)));

	//	If we are disconnecting, just remove the reference and exit.
	if (SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_ACTIVE)
	{
		fDisconnect = FALSE;

		//	We are here if either the wdog or the retry timer did a find
		//	route. We need to save the info from the find route if it was
		//	successful and just restart the timers.
		if (FoundRoute)
		{
			//	If the mac address in local target is all zeros, fill it with our
			//	destination address.
			if ((*((UNALIGNED ULONG *)
				(pFrReq->fr_FindRouteReq.LocalTarget.MacAddress+2)) == (ULONG)0)
				&&
				(*((UNALIGNED USHORT *)
				(pFrReq->fr_FindRouteReq.LocalTarget.MacAddress+4)) == (USHORT)0))
			{
				DBGPRINT(CONNECT, INFO,
						("SpxConnActiveFindRouteComplete: LOCAL NET\n"));
	
				RtlCopyMemory(
					pFrReq->fr_FindRouteReq.LocalTarget.MacAddress,
					pSpxConnFile->scf_RemAddr+4,
					6);
			}
	
			pSpxConnFile->scf_LocalTarget	= pFrReq->fr_FindRouteReq.LocalTarget;
		}

		//	Depending on state restart the wdog or retry timer. Add reference
		//	for it.
		switch (SPX_SEND_STATE(pSpxConnFile))
		{
		case SPX_SEND_RETRY:

			//	Set state to SPX_SEND_RETRYWD
			SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_RETRYWD);

			//	Start retry timer.
			if ((pSpxConnFile->scf_RTimerId =
					SpxTimerScheduleEvent(
						spxConnRetryTimer,
						pSpxConnFile->scf_BaseT1,
						pSpxConnFile)) != 0)
			{
				SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_R_TIMER);

				//	Reference connection for the timer
				SpxConnFileLockReference(pSpxConnFile, CFREF_VERIFY);
			}
			else
			{
				fDisconnect = TRUE;
			}

			break;

		case SPX_SEND_WD:

			//	Start watchdog timer.
			if ((pSpxConnFile->scf_WTimerId =
					SpxTimerScheduleEvent(
						spxConnWatchdogTimer,
						PARAM(CONFIG_KEEPALIVE_TIMEOUT) * HALFSEC_TO_MS_FACTOR,
						pSpxConnFile)) != 0)
			{
				//	Reference connection for the timer
				SpxConnFileLockReference(pSpxConnFile, CFREF_VERIFY);
				SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER);
			}
			else
			{
				fDisconnect = TRUE;
			}

			break;

		case SPX_SEND_IDLE:
		case SPX_SEND_PACKETIZE:

			//	Do nothing, remove reference and leave.
			break;

		default:

			KeBugCheck(0);
		}
	}

	if (fDisconnect)
	{
		DBGPRINT(CONNECT, DBG1,
				("SpxConnActiveFindRouteComplete: DISCONNECT %lx.%lx\n",
					pSpxConnFile, SPX_MAIN_STATE(pSpxConnFile)));

		//	Abortive disc will reset the funky state if necessary.
		spxConnAbortiveDisc(
			pSpxConnFile,
			STATUS_INSUFFICIENT_RESOURCES,
			SPX_CALL_TDILEVEL,
			LockHandle,
            FALSE);     // [SA] Bug #15249
	}
	else
	{
		CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandle);
	}

	SpxConnFileDereference(pSpxConnFile, CFREF_FINDROUTE);
	return;
}




ULONG
spxConnConnectTimer(
	IN PVOID 	Context,
	IN BOOLEAN	TimerShuttingDown
	)
/*++

Routine Description:

 	We enter this routine during the connection attempt. We could be at any
	stage of sending either the CR or the SN packet. If we have reached the end of
	the retry count, we need to know the substate at that point. For a CR, we give
	up trying to connect, and for a SN we try the next lower packet size or if we
	have reached the minimum packet size, we give up the connect.

Arguments:


Return Value:


--*/
{
	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)Context;
	PNDIS_PACKET	pPkt;
	PSPX_SEND_RESD	pSendResd;
	CTELockHandle	lockHandleConn, lockHandleAddr, lockHandleDev;
	BOOLEAN			fAbort		= FALSE, locksHeld = FALSE, sendPkt     = FALSE;
	PREQUEST		pRequest	= NULL;

	//	Get all locks
	CTEGetLock(&SpxDevice->dev_Lock, &lockHandleDev);
	CTEGetLock(pSpxConnFile->scf_AddrFile->saf_AddrLock, &lockHandleAddr);
	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);
	locksHeld = TRUE;

	DBGPRINT(CONNECT, INFO,
			("spxConnConnectTimer: Entered\n"));

	do
	{
		if ((!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_C_TIMER)) ||
			(!SPX_CONN_CONNECTING(pSpxConnFile)	&&
			 !SPX_CONN_LISTENING(pSpxConnFile)))
		{
			TimerShuttingDown = TRUE;
		}

		if (TimerShuttingDown)
		{
			break;
		}

		if (SPX_CONN_CONNECTING(pSpxConnFile))
		{
			switch (SPX_CONNECT_STATE(pSpxConnFile))
			{
            case SPX_CONNECT_SENTREQ:

				//	There should be only one packet in list, the cr.
				CTEAssert(pSpxConnFile->scf_SendListHead ==
							pSpxConnFile->scf_SendListTail);

				pSendResd	= pSpxConnFile->scf_SendListHead;
				pPkt	 	= (PNDIS_PACKET)CONTAINING_RECORD(
												pSendResd,
												NDIS_PACKET,
												ProtocolReserved);
		
				if (pSpxConnFile->scf_CRetryCount-- == 0)
				{
					//	No luck, we need to complete connect request with failure
                    ++SpxDevice->dev_Stat.NotFoundFailures;
					fAbort	= TRUE;
					break;
				}
		
				//	We need to resend the packet
				if ((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) != 0)
				{
					//	Try next time.
					break;
				}
		
				pSendResd->sr_State			   |= SPX_SENDPKT_IPXOWNS;
				sendPkt	= TRUE;
				break;

            case SPX_CONNECT_NEG:

				if (!spxConnGetPktByType(
						pSpxConnFile,
						SPX_TYPE_SN,
						FALSE,
						&pPkt))
				{
					KeBugCheck(0);
				}

				pSendResd	= (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
				if ((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) != 0)
				{
					//	Try when we come in next.
					break;
				}
		

				//	If we have exhausted current retries, try next smaller size.
				//	If this was the smallest size, we abort.
				if (pSpxConnFile->scf_CRetryCount-- == 0)
				{
					// 	Have we tried the smallest size?
					CTEAssert(pSpxConnFile->scf_MaxPktSize > 0);
					if (!spxConnCheckNegSize(&pSpxConnFile->scf_MaxPktSize))
					{
						//	Give up! Remove negotiate packet etc.
                        ++SpxDevice->dev_Stat.SessionTimeouts;
						fAbort	= TRUE;
						break;
					}

					//	Set neg pkt size to new lower size
					spxConnSetNegSize(
						pPkt,
						pSpxConnFile->scf_MaxPktSize - MIN_IPXSPX2_HDRSIZE);

                    pSpxConnFile->scf_CRetryCount  =
											PARAM(CONFIG_CONNECTION_COUNT);
				}
		
				//	We need to resend the packet
				CTEAssert((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) == 0);
				pSendResd->sr_State			   |= SPX_SENDPKT_IPXOWNS;
				sendPkt	= TRUE;
				break;

            case SPX_CONNECT_W_SETUP:
			default:

				DBGPRINT(CONNECT, ERR,
						("spxConnConnectTimer: state is W_Setup %lx\n",
							pSpxConnFile));

				KeBugCheck(0);
			}
		}
		else
		{
			switch (SPX_LISTEN_STATE(pSpxConnFile))
			{
            case SPX_LISTEN_SETUP:

				if (!spxConnGetPktByType(
						pSpxConnFile,
						SPX_TYPE_SS,
						FALSE,
						&pPkt))
				{
					KeBugCheck(0);
				}

				pSendResd	= (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
				if ((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) != 0)
				{
					//	Try when we come in next.
					break;
				}

				//	If we have exhausted current retries, try next smaller size.
				//	If this was the smallest size, we abort.
				if (pSpxConnFile->scf_CRetryCount-- == 0)
				{
					// 	Have we tried the smallest size?
					if (!spxConnCheckNegSize(&pSpxConnFile->scf_MaxPktSize))
					{
						//	Give up! Remove negotiate packet etc. Have an abort
						//	kind of routine.
                        ++SpxDevice->dev_Stat.SessionTimeouts;
						fAbort	= TRUE;
						break;
					}

					//	Set neg pkt size to new lower size
					spxConnSetNegSize(
						pPkt,
						pSpxConnFile->scf_MaxPktSize - MIN_IPXSPX2_HDRSIZE);

                    pSpxConnFile->scf_CRetryCount  =
											PARAM(CONFIG_CONNECTION_COUNT);
				}
		
				//	We need to resend the packet
				CTEAssert((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) == 0);

				pSendResd->sr_State			   |= SPX_SENDPKT_IPXOWNS;
				sendPkt	= TRUE;
				break;

			default:

				KeBugCheck(0);

			}
		}

	} while (FALSE);

	if (fAbort)
	{
		CTEAssert(!sendPkt);

		DBGPRINT(CONNECT, ERR,
				("spxConnConnectTimer: Expired for %lx\n", pSpxConnFile));
	
		spxConnAbortConnect(
			pSpxConnFile,
			STATUS_BAD_NETWORK_PATH,
			lockHandleDev,
			lockHandleAddr,
			lockHandleConn);

		locksHeld = FALSE;
	}

	if (locksHeld)
	{
		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
		CTEFreeLock(pSpxConnFile->scf_AddrFile->saf_AddrLock, lockHandleAddr);
		CTEFreeLock(&SpxDevice->dev_Lock, lockHandleDev);
	}

	if (sendPkt)
	{
		CTEAssert(!fAbort);

#if !defined(_PNP_POWER)
		if ((SPX_CONNECT_STATE(pSpxConnFile) == SPX_CONNECT_SENTREQ) &&
		    (*((UNALIGNED ULONG *)(pSpxConnFile->scf_RemAddr)) == 0)) {

            // we are sending to all NICs because this is the initial
            // connect frame and the remote network is 0.

            pSpxConnFile->scf_LocalTarget.NicId = (USHORT)
                ((pSpxConnFile->scf_LocalTarget.NicId % SpxDevice->dev_Adapters) + 1);

            // we pass this a valid packet in pPkt, so it knows to
            // just refresh the header and not update the protocol
            // reserved variables.

    		SpxPktBuildCr(
    			pSpxConnFile,
			    pSpxConnFile->scf_AddrFile->saf_Addr,
    			&pPkt,
    			0,           // state will not be updated
    			SPX2_CONN(pSpxConnFile));

        }
#endif !_PNP_POWER

		//	Send the packet
		SPX_SENDPACKET(pSpxConnFile, pPkt, pSendResd);
	}

	if (TimerShuttingDown || fAbort)
	{
		//	Dereference connection for verify done in connect, for timer. This
		//	should complete any pending disconnects if they had come in in the
		//	meantime.
		SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
		return(TIMER_DONT_REQUEUE);
	}

	return(TIMER_REQUEUE_CUR_VALUE);
}




ULONG
spxConnWatchdogTimer(
	IN PVOID 	Context,
	IN BOOLEAN	TimerShuttingDown
	)
/*++

Routine Description:

	This is started on a connection right after the CR or the CR ack is received.
	During the connection establishment phase, it does nothing other than decrement
	the retry count and upon reaching 0, it aborts the connection. When it goes off
	and finds the connection is active, it sends a probe.

Arguments:


Return Value:


--*/
{
	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)Context;
	CTELockHandle	lockHandle;
	PSPX_SEND_RESD	pSendResd;
	PSPX_FIND_ROUTE_REQUEST	pFindRouteReq;
	PNDIS_PACKET	pProbe		= NULL;
	BOOLEAN			lockHeld, fSpx2	= SPX2_CONN(pSpxConnFile),
					fDisconnect = FALSE, fFindRoute = FALSE, fSendProbe = FALSE;

	DBGPRINT(CONNECT, INFO,
			("spxConnWatchdogTimer: Entered\n"));

	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
	lockHeld = TRUE;
	do
	{
		if (TimerShuttingDown ||
			(!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER)) ||
			(SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_ABORT))
		{
#if DBG
			if ((SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_IDLE) &&
				(SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_WD))
			{
				CTEAssert(FALSE);
			}
#endif

			SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER);
			TimerShuttingDown = TRUE;
			break;
		}

		//	If the retry timer is active on this connection, and the watchdog
		//	timer happens to fire, just requeue ourselves for spx2. For spx1,
		//	we go ahead with sending a probe. Retry timer does the same things
		//	watchdog does for spx2.
		switch (SPX_MAIN_STATE(pSpxConnFile))
		{
		case SPX_CONNFILE_ACTIVE:
		case SPX_CONNFILE_DISCONN:

			//	Squash the race condition where a disconnect request is never
			//	packetized, because the send state was not IDLE.
			if (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_POST_IDISC)
			{
				DBGPRINT(CONNECT, ERR,
						("spxConnWatchdogTimer: POST IDISC %lx\n",
							pSpxConnFile));
			
				if (SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_IDLE)
				{
					DBGPRINT(CONNECT, ERR,
							("spxConnWatchdogTimer: PKT POST IDISC %lx\n",
								pSpxConnFile));
				
					SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_PACKETIZE);
					SpxConnPacketize(
						pSpxConnFile,
						TRUE,
						lockHandle);
	
					lockHeld = FALSE;
					break;
				}
			}

			if (!fSpx2)
			{
				if (pSpxConnFile->scf_WRetryCount-- > 0)
				{
					fSendProbe = TRUE;
				}
				else
				{
					fDisconnect = TRUE;
				}

				break;
			}

			//	SPX2 connection. Watchdog algorithm needs to do lots of goody
			//	stuff. If retry is active, just requeue ourselves.
			if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_R_TIMER))
				break;

			//	There is a race between watchdog and retry if its started. Who
			//	ever changes the state first gets to go do its thing.
			switch (SPX_SEND_STATE(pSpxConnFile))
			{
			case SPX_SEND_IDLE:

				//	Enter WD state only if we fired for the second time witout
				//	an ack. This prevents PACKETIZE from blocking due to being
				//	in a non-idle state.
                CTEAssert(pSpxConnFile->scf_WRetryCount != 0);
                if ((pSpxConnFile->scf_WRetryCount)-- !=
						(LONG)PARAM(CONFIG_KEEPALIVE_COUNT))
				{
					//	We enter the WD state. Build and send a probe.
					SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_WD);
					SpxConnFileLockReference(pSpxConnFile, CFREF_ERRORSTATE);
				}

				fSendProbe = TRUE;
				break;
	
			case SPX_SEND_PACKETIZE:

				// Do nothing.
				break;

			case SPX_SEND_RETRY:
			case SPX_SEND_RETRYWD:
			case SPX_SEND_RENEG:
			case SPX_SEND_RETRY2:
			case SPX_SEND_RETRY3:

				//	Do nothing. Send timer got in first.
				DBGPRINT(CONNECT, DBG1,
						("SpxConnWDogTimer: When retry fired %lx\n",
							pSpxConnFile));
	
				break;

			case SPX_SEND_WD:

				//	Decrement count. If not zero, send a probe. If half the
				//	count is reached, stop timer and call find route.
				if (pSpxConnFile->scf_WRetryCount-- > 0)
				{
					if (pSpxConnFile->scf_WRetryCount !=
							(LONG)PARAM(CONFIG_KEEPALIVE_COUNT)/2)
					{
						fSendProbe = TRUE;
						break;
					}

					if ((pFindRouteReq =
							(PSPX_FIND_ROUTE_REQUEST)SpxAllocateMemory(
										sizeof(SPX_FIND_ROUTE_REQUEST))) == NULL)
					{
						fDisconnect = TRUE;
						break;
					}

					//	Remove timer reference/ Add find route request ref
					fFindRoute = TRUE;
					TimerShuttingDown = TRUE;
					SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER);
					SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_FINDROUTE);
					SpxConnFileLockReference(pSpxConnFile, CFREF_FINDROUTE);

					//	Initialize the find route request
					*((UNALIGNED ULONG *)pFindRouteReq->fr_FindRouteReq.Network) =
						*((UNALIGNED ULONG *)pSpxConnFile->scf_RemAddr);
		
               //
               // [SA] Bug #15094
               // We need to also pass in the node number to IPX so that IPX can
               // compare the node addresses to determine the proper WAN NICid
               //

               // RtlCopyMemory (pFindRouteReq->fr_FindRouteReq.Node, pSpxConnFile->scf_RemAddr+4, 6);

               *((UNALIGNED ULONG *)pFindRouteReq->fr_FindRouteReq.Node)=
                *((UNALIGNED ULONG *)(pSpxConnFile->scf_RemAddr+4));

               *((UNALIGNED USHORT *)(pFindRouteReq->fr_FindRouteReq.Node+4))=
                *((UNALIGNED USHORT *)(pSpxConnFile->scf_RemAddr+8));

					DBGPRINT(CONNECT, DBG,
							("SpxConnWDogTimer: NETWORK %lx\n",
								*((UNALIGNED ULONG *)pSpxConnFile->scf_RemAddr)));
		
					pFindRouteReq->fr_FindRouteReq.Identifier= IDENTIFIER_SPX;
					pFindRouteReq->fr_Ctx					 = pSpxConnFile;

					//	Make sure we have IPX re-rip.
                    pFindRouteReq->fr_FindRouteReq.Type	 = IPX_FIND_ROUTE_FORCE_RIP;
				}
				else
				{
					fDisconnect = TRUE;
				}

				break;

			default:
	
				KeBugCheck(0);
			}

			break;

		case SPX_CONNFILE_CONNECTING:

			if ((SPX_CONNECT_STATE(pSpxConnFile) == SPX_CONNECT_SENTREQ) ||
				(SPX_CONNECT_STATE(pSpxConnFile) == SPX_CONNECT_NEG))
			{
				//	Do nothing. Connect timer is active.
				DBGPRINT(CONNECT, ERR,
						("SpxConnWDogTimer: CR Timer active %lx\n",
							pSpxConnFile));
	
				break;
			}

			if (!(pSpxConnFile->scf_WRetryCount--))
			{
				//	Disconnect!
				DBGPRINT(CONNECT, ERR,
						("spxConnWatchdogTimer: Connection %lx.%lx expired\n",
							pSpxConnFile->scf_LocalConnId, pSpxConnFile));

				fDisconnect = TRUE;
			}

			break;

		case SPX_CONNFILE_LISTENING:

			if (SPX_LISTEN_STATE(pSpxConnFile) == SPX_LISTEN_SETUP)
			{
				//	Do nothing. Connect timer is active.
				DBGPRINT(CONNECT, ERR,
						("SpxConnWDogTimer: CR Timer active %lx\n",
							pSpxConnFile));
	
				break;
			}

			if (!(pSpxConnFile->scf_WRetryCount--))
			{
				//	Disconnect!
				DBGPRINT(CONNECT, ERR,
						("spxConnWatchdogTimer: Connection %lx.%lx expired\n",
							pSpxConnFile->scf_LocalConnId, pSpxConnFile));

				fDisconnect = TRUE;
			}

			break;

		default:

			//	Should never happen!
			KeBugCheck(0);
		}

	} while (FALSE);

	if (fSendProbe)
	{
		CTEAssert(lockHeld);
		CTEAssert(!fDisconnect);

		DBGPRINT(CONNECT, DBG1,
				("spxConnWatchdogTimer: Send Probe from %lx.%lx\n",
					pSpxConnFile->scf_LocalConnId, pSpxConnFile));

		//	Build a probe and send it out to the remote end.
		SpxPktBuildProbe(
			pSpxConnFile,
			&pProbe,
			(SPX_SENDPKT_IPXOWNS | SPX_SENDPKT_DESTROY),
			fSpx2);

		if (pProbe != NULL)
		{
			SpxConnQueueSendPktTail(pSpxConnFile, pProbe);
			pSendResd	= (PSPX_SEND_RESD)(pProbe->ProtocolReserved);
		}
	}

	if (fDisconnect)
	{
		CTEAssert(lockHeld);
		CTEAssert(!fSendProbe);

		//	Disconnect!
		DBGPRINT(CONNECT, ERR,
				("spxConnWatchdogTimer: Connection %lx.%lx expired\n",
					pSpxConnFile->scf_LocalConnId, pSpxConnFile));

		TimerShuttingDown = TRUE;
		SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER);

		//	If spx2, check if we need to do anything special.
		//	AbortiveDisc will reset funky state if needed.
		spxConnAbortiveDisc(
			pSpxConnFile,
			STATUS_LINK_TIMEOUT,
			SPX_CALL_TDILEVEL,
			lockHandle,
            FALSE);     // [SA] Bug #15249

		lockHeld = FALSE;
	}

	if (lockHeld)
	{
		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
	}

	if (fFindRoute)
	{
		CTEAssert(!fSendProbe);
		CTEAssert(!fDisconnect);
		CTEAssert(TimerShuttingDown);

		//	Start off the find route request
		(*IpxFindRoute)(
			&pFindRouteReq->fr_FindRouteReq);
	}

	if (pProbe != NULL)
	{
		//	Send the packet
		SPX_SENDPACKET(pSpxConnFile, pProbe, pSendResd);
	}

	if (TimerShuttingDown)
	{
		//	Dereference connection for verify done in connect, for timer. This
		//	should complete any pending disconnects if they had come in in the
		//	meantime.
		SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	}

	return((TimerShuttingDown ? TIMER_DONT_REQUEUE : TIMER_REQUEUE_CUR_VALUE));
}



ULONG
spxConnRetryTimer(
	IN PVOID 	Context,
	IN BOOLEAN	TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)Context;
	PSPX_SEND_RESD	pSendResd;
	CTELockHandle	lockHandleConn;
	PIPXSPX_HDR		pSendHdr;
	PNDIS_PACKET	pPkt;
	PNDIS_PACKET	pProbe		= NULL;
	PSPX_FIND_ROUTE_REQUEST	pFindRouteReq;
	
	// Compiler warning  reenqueueTime = pSpxConnFile->scf_BaseT1; [tingcai]
	// USHORT			reenqueueTime	= TIMER_REQUEUE_CUR_VALUE;
   	UINT			reenqueueTime	= TIMER_REQUEUE_CUR_VALUE;
	BOOLEAN			lockHeld, fResendPkt = FALSE, fDisconnect = FALSE,
					fFindRoute = FALSE, fBackoffTimer = FALSE;
	PREQUEST		pRequest		= NULL;
    PNDIS_BUFFER    NdisBuf, NdisBuf2;
    ULONG           BufLen = 0;

	DBGPRINT(CONNECT, INFO,
			("spxConnRetryTimer: Entered\n"));

	//	Get lock
	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);
	lockHeld = TRUE;

	do
	{
		//	If timer is not up, no send pkts, just return.
		if (TimerShuttingDown ||
			(!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_R_TIMER)) ||
			(SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_ABORT)	 ||
			((pSendResd = pSpxConnFile->scf_SendSeqListHead) == NULL))
		{
#if DBG
            if ((pSendResd = pSpxConnFile->scf_SendSeqListHead) == NULL)
			{
				if ((SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_IDLE) &&
					(SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_PACKETIZE) &&
					(SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_WD))
				{
					CTEAssert(FALSE);
				}
			}
#endif

			SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_R_TIMER);
			TimerShuttingDown 	= TRUE;
			break;
		}

		//	In all other cases, reenqueue with potentially modified reenqueue
		//	time.
		reenqueueTime = pSpxConnFile->scf_BaseT1;
		DBGPRINT(SEND, INFO,
				("spxConnRetryTimer: BaseT1 %lx on %lx\n",
					pSpxConnFile->scf_BaseT1, pSpxConnFile));

		//	If an ack for a packet was processed while we were out, reset
		//	retry count and return. Or if we are packetizing, return.
		if (SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_PACKETIZE)
		{
			break;
		}
		else if ((SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_IDLE) &&
	             (pSpxConnFile->scf_RetrySeqNum != pSendResd->sr_SeqNum))
		{
			pSpxConnFile->scf_RetrySeqNum = pSendResd->sr_SeqNum;
			break;
		}

		//	If packet is still with IPX, requeue for next time.
		if (pSendResd->sr_State & SPX_SENDPKT_IPXOWNS)
		{
			break;
		}

		CTEAssert(pSendResd != NULL);
		pPkt = (PNDIS_PACKET)CONTAINING_RECORD(
								pSendResd, NDIS_PACKET, ProtocolReserved);

        //
        // Get the MDL that points to the IPX/SPX header. (the second one)
        //

        NdisQueryPacket(pPkt, NULL, NULL, &NdisBuf, NULL);
        NdisGetNextBuffer(NdisBuf, &NdisBuf2);
        NdisQueryBufferSafe(NdisBuf2, (PUCHAR) &pSendHdr, &BufLen, LowPagePriority);
		ASSERT(pSendHdr != NULL);

#if OWN_PKT_POOLS
		pSendHdr	= (PIPXSPX_HDR)((PBYTE)pPkt 			+
									NDIS_PACKET_SIZE 		+
									sizeof(SPX_SEND_RESD)	+
									IpxInclHdrOffset);
#endif
		switch (SPX_SEND_STATE(pSpxConnFile))
		{
		case SPX_SEND_IDLE:

			//	Set ack bit in packet. pSendResd initialized at beginning.
			pSendHdr->hdr_ConnCtrl |= SPX_CC_ACK;

			//	Do we backoff the timer?
			fBackoffTimer =
				(BOOLEAN)((pSendResd->sr_State & SPX_SENDPKT_REXMIT) != 0);

			//	We are going to resend this packet
			pSendResd->sr_State |= (SPX_SENDPKT_IPXOWNS |
									SPX_SENDPKT_ACKREQ	|
									SPX_SENDPKT_REXMIT);

            ++SpxDevice->dev_Stat.ResponseTimerExpirations;

			CTEAssert((ULONG)pSpxConnFile->scf_RRetryCount <=
						PARAM(CONFIG_REXMIT_COUNT));

			DBGPRINT(SEND, DBG1,
					("spxConnRetryTimer: Retry Count %lx on %lx\n",
						pSpxConnFile->scf_RRetryCount, pSpxConnFile));

			fResendPkt = TRUE;
			if (pSpxConnFile->scf_RRetryCount-- != 0)
			{
				//	We dont treat the IDISC packet as a data packet, so none
				//	of the fancy spx2 retry stuff if we are retrying the idisc.
				if (SPX2_CONN(pSpxConnFile) &&
					(SPX_DISC_STATE(pSpxConnFile) != SPX_DISC_SENT_IDISC))
				{
					//	We enter the RETRY state. Reference conn for this
					//	"funky" state.
					CTEAssert(SPX2_CONN(pSpxConnFile));
					SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_RETRY);
					SpxConnFileLockReference(pSpxConnFile, CFREF_ERRORSTATE);
				}
			}
			else
			{
				DBGPRINT(SEND, ERR,
						("spxConnRetryTimer: Retry Count over on %lx\n",
							pSpxConnFile));

				fDisconnect = TRUE;
				fResendPkt	= FALSE;
				pSendResd->sr_State &= ~SPX_SENDPKT_IPXOWNS;
			}

			break;

		case SPX_SEND_RETRY:

			//	When we have reached retry_count/2 limit, start locate route. Do
			//	not queue ourselves. Handle restarting timer in find route
			//	completion. If timer starts successfully in find route comp, then
			//	it will change our state to RETRYWD.

			//	Decrement count. If half the count is reached, stop timer and call
			//	find route.
			if (pSpxConnFile->scf_RRetryCount-- !=
						(LONG)PARAM(CONFIG_REXMIT_COUNT)/2)
			{
				//	We are going to resend this packet
				pSendResd->sr_State |= (SPX_SENDPKT_IPXOWNS |
										SPX_SENDPKT_ACKREQ	|
										SPX_SENDPKT_REXMIT);
	
				fResendPkt = TRUE;
				fBackoffTimer = TRUE;
				break;
			}

			if ((pFindRouteReq =
					(PSPX_FIND_ROUTE_REQUEST)SpxAllocateMemory(
								sizeof(SPX_FIND_ROUTE_REQUEST))) == NULL)
			{
				DBGPRINT(SEND, ERR,
						("spxConnRetryTimer: Alloc Mem %lx\n",
							pSpxConnFile));

				fDisconnect = TRUE;
				break;
			}

			//	Remove timer reference/ Add find route request ref
			fFindRoute = TRUE;
			TimerShuttingDown = TRUE;
			SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_R_TIMER);
			SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_FINDROUTE);
			SpxConnFileLockReference(pSpxConnFile, CFREF_FINDROUTE);

			//	Initialize the find route request
			*((UNALIGNED ULONG *)pFindRouteReq->fr_FindRouteReq.Network)=
				*((UNALIGNED ULONG *)pSpxConnFile->scf_RemAddr);

         //
         // [SA] Bug #15094
         // We need to also pass in the node number to IPX so that IPX can
         // compare the node addresses to determine the proper WAN NICid
         //

         // RtlCopyMemory (pFindRouteReq->fr_FindRouteReq.Node, pSpxConnFile->scf_RemAddr+4, 6) ;

         *((UNALIGNED ULONG *)pFindRouteReq->fr_FindRouteReq.Node)=
          *((UNALIGNED ULONG *)(pSpxConnFile->scf_RemAddr+4));

         *((UNALIGNED USHORT *)(pFindRouteReq->fr_FindRouteReq.Node+4)) =
          *((UNALIGNED USHORT *)(pSpxConnFile->scf_RemAddr+8));

			DBGPRINT(CONNECT, DBG,
					("SpxConnRetryTimer: NETWORK %lx\n",
						*((UNALIGNED ULONG *)pSpxConnFile->scf_RemAddr)));

			pFindRouteReq->fr_FindRouteReq.Identifier= IDENTIFIER_SPX;
			pFindRouteReq->fr_Ctx					 = pSpxConnFile;

			//	Make sure we have IPX re-rip.
			pFindRouteReq->fr_FindRouteReq.Type	 = IPX_FIND_ROUTE_FORCE_RIP;
			break;

		case SPX_SEND_RETRYWD:

			//	Retry a watchdog packet WCount times (initialize to RETRY_COUNT).
			//	If process ack receives an ack (i.e. actual ack packet) while in
			//	this state, it will transition the state to RENEG.
			//
			//	If the pending data gets acked while in this state, we go back
			//	to idle.
			DBGPRINT(CONNECT, DBG1,
					("spxConnRetryTimer: Send Probe from %lx.%lx\n",
						pSpxConnFile->scf_LocalConnId, pSpxConnFile));

			//	Use watchdog count here.
			if (pSpxConnFile->scf_WRetryCount-- > 0)
			{
				//	Build a probe and send it out to the remote end.
				SpxPktBuildProbe(
					pSpxConnFile,
					&pProbe,
					(SPX_SENDPKT_IPXOWNS | SPX_SENDPKT_DESTROY),
					TRUE);
		
				if (pProbe != NULL)
				{
					SpxConnQueueSendPktTail(pSpxConnFile, pProbe);
					pSendResd	= (PSPX_SEND_RESD)(pProbe->ProtocolReserved);
					break;
				}
			}

			//	Just set state to retry data packet retry_count/2 times.
			pSpxConnFile->scf_WRetryCount = PARAM(CONFIG_KEEPALIVE_COUNT);
			SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_RETRY2);
			break;

		case SPX_SEND_RENEG:

			//	Renegotiate size. If we give up, goto RETRY3.
			//	For this both sides must have negotiated size to begin with.
			//	If they did not, we go on to retrying the data packet.
			if (!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_NEG))
			{
				DBGPRINT(SEND, ERR,
						("spxConnRetryTimer: NO NEG FLAG SET: %lx - %lx\n",
							pSpxConnFile,
							pSpxConnFile->scf_Flags));

				//	Reset count to be
				pSpxConnFile->scf_RRetryCount = PARAM(CONFIG_REXMIT_COUNT);
				SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_RETRY3);
				break;
			}

			//	Send reneg packet, if we get the rr ack, then we resend data
			//	on queue. Note that each time we goto a new negotiate size,
			//	we rebuild the data packets.
			if (pSpxConnFile->scf_RRetryCount-- == 0)
			{
				//	Reset count.
				pSpxConnFile->scf_RRetryCount = SPX_DEF_RENEG_RETRYCOUNT;
				if ((ULONG)pSpxConnFile->scf_MaxPktSize <=
						(SpxMaxPktSize[0] + MIN_IPXSPX2_HDRSIZE))
				{
					pSpxConnFile->scf_RRetryCount = PARAM(CONFIG_REXMIT_COUNT);

					DBGPRINT(SEND, DBG3,
							("SpxConnRetryTimer: %lx MIN RENEG SIZE\n",
								pSpxConnFile));
				}

				//	Are we at the lowest possible reneg pkt size? If not, try
				//	next lower. When we do this, we free all pending send
				//	packets and reset the packetize queue to the first packet.
				//	Process ack will just do packetize and will not do anything
				//	more other than resetting state to proper value.
				DBGPRINT(SEND, DBG3,
						("spxConnRetryTimer: RENEG: %lx - CURRENT %lx\n",
							pSpxConnFile,
							pSpxConnFile->scf_MaxPktSize));

				if (!spxConnCheckNegSize(&pSpxConnFile->scf_MaxPktSize))
				{
					//	We tried lowest size and failed to receive ack. Just
					//	retry data packet, and disc if no ack.
					DBGPRINT(SEND, DBG3,
							("spxConnRetryTimer: RENEG(min), RETRY3: %lx - %lx\n",
								pSpxConnFile,
								pSpxConnFile->scf_MaxPktSize));
	
					pSpxConnFile->scf_RRetryCount = PARAM(CONFIG_REXMIT_COUNT);
					SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_RETRY3);
					SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_RENEG_PKT);
					break;
				}

				DBGPRINT(SEND, DBG3,
						("spxConnRetryTimer: RENEG(!min): %lx - ATTEMPT %lx\n",
							pSpxConnFile,
							pSpxConnFile->scf_MaxPktSize));
			}

			DBGPRINT(SEND, DBG3,
					("spxConnRetryTimer: %lx.%lx.%lx RENEG SEQNUM %lx ACKNUM %lx\n",
						pSpxConnFile,
						pSpxConnFile->scf_RRetryCount,
						pSpxConnFile->scf_MaxPktSize,
						(USHORT)(pSpxConnFile->scf_SendSeqListTail->sr_SeqNum + 1),
						pSpxConnFile->scf_SentAllocNum));

			//	Use first unused data packet sequence number.
			SpxPktBuildRr(
				pSpxConnFile,
				&pPkt,
				(USHORT)(pSpxConnFile->scf_SendSeqListTail->sr_SeqNum + 1),
				(SPX_SENDPKT_IPXOWNS | SPX_SENDPKT_DESTROY));

			if (pPkt != NULL)
			{
				SpxConnQueueSendPktTail(pSpxConnFile, pPkt);
				pSendResd	= (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
				fResendPkt  = TRUE;
				SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_RENEG_PKT);
			}

			break;

		case SPX_SEND_RETRY2:

			//	Retry the data packet for remaining amount of RRetryCount. If not
			//	acked goto cleanup. If ack received while in this state, goto idle.

			if (pSpxConnFile->scf_RRetryCount-- > 0)
			{
				//	We are going to resend this packet
				pSendResd->sr_State |= (SPX_SENDPKT_IPXOWNS |
										SPX_SENDPKT_ACKREQ	|
										SPX_SENDPKT_REXMIT);
	
				DBGPRINT(SEND, DBG3,
						("spxConnRetryTimer: 2nd try Resend on %lx\n",
							pSpxConnFile));
		
				fResendPkt = TRUE;
				fBackoffTimer = TRUE;
			}
			else
			{
				DBGPRINT(SEND, ERR,
						("spxConnRetryTimer: Retry Count over on %lx\n",
							pSpxConnFile));

				fDisconnect = TRUE;
			}

			break;

		case SPX_SEND_RETRY3:

			//	Send data packet for RETRY_COUNT times initialized in RRetryCount
			//	before state changed to this state. If ok, process ack moves us
			//	back to PKT/IDLE. If not, we disconnect.
			//	We are going to resend this packet

			if (pSpxConnFile->scf_RRetryCount-- > 0)
			{
				DBGPRINT(SEND, DBG3,
						("spxConnRetryTimer: 3rd try Resend on %lx\n",
							pSpxConnFile));
		
				//	We are going to resend this packet
				pSendResd->sr_State |= (SPX_SENDPKT_IPXOWNS |
										SPX_SENDPKT_ACKREQ	|
										SPX_SENDPKT_REXMIT);
	
				fResendPkt = TRUE;
				fBackoffTimer = TRUE;
			}
			else
			{
				DBGPRINT(SEND, ERR,
						("spxConnRetryTimer: Retry Count over on %lx\n",
							pSpxConnFile));

				fDisconnect = TRUE;
			}

			break;

		case SPX_SEND_WD:

			//	Do nothing. Watchdog timer has fired, just requeue.
			break;

		default:

			KeBugCheck(0);
		}

		if (fBackoffTimer)
		{
			//	Increase retransmit timeout by 50% upto maximum indicated by
			//	initial retransmission value.

			reenqueueTime += reenqueueTime/2;
			if (reenqueueTime > MAX_RETRY_DELAY)
				reenqueueTime = MAX_RETRY_DELAY;
	
			pSpxConnFile->scf_BaseT1 =
			pSpxConnFile->scf_AveT1	 = reenqueueTime;
			pSpxConnFile->scf_DevT1	 = 0;

			DBGPRINT(SEND, DBG,
					("spxConnRetryTimer: Backed retry on %lx.%lx %lx\n",
						pSpxConnFile, pSendResd->sr_SeqNum, reenqueueTime));
		}

		if (fDisconnect)
		{
			CTEAssert(lockHeld);

			//	Do not requeue this timer.
			SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_R_TIMER);
			TimerShuttingDown = TRUE;

			//	Disconnect the connection.
			spxConnAbortiveDisc(
				pSpxConnFile,
				STATUS_LINK_TIMEOUT,
				SPX_CALL_TDILEVEL,
				lockHandleConn,
                FALSE);     // [SA] Bug #15249

			lockHeld = FALSE;
		}

	} while (FALSE);

	if (lockHeld)
	{
		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
	}

	if (fResendPkt)
	{
		DBGPRINT(SEND, DBG,
				("spxConnRetryTimer: Resend pkt on %lx.%lx\n",
					pSpxConnFile, pSendResd->sr_SeqNum));

        ++SpxDevice->dev_Stat.DataFramesResent;
        ExInterlockedAddLargeStatistic(
            &SpxDevice->dev_Stat.DataFrameBytesResent,
            pSendResd->sr_Len - (SPX2_CONN(pSpxConnFile) ? MIN_IPXSPX2_HDRSIZE : MIN_IPXSPX_HDRSIZE));
		SPX_SENDPACKET(pSpxConnFile, pPkt, pSendResd);
	}
	else if (fFindRoute)
	{
		CTEAssert(!fResendPkt);
		CTEAssert(!fDisconnect);
		CTEAssert(TimerShuttingDown);

		DBGPRINT(SEND, DBG3,
				("spxConnRetryTimer: Find route on %lx\n",
					pSpxConnFile));

		//	Start off the find route request
		(*IpxFindRoute)(
			&pFindRouteReq->fr_FindRouteReq);
	}
	else if (pProbe != NULL)
	{
		//	Send the packet
		SPX_SENDPACKET(pSpxConnFile, pProbe, pSendResd);
	}

	if (TimerShuttingDown)
	{
		//	Dereference connection for verify done in connect, for timer. This
		//	should complete any pending disconnects if they had come in in the
		//	meantime.
		SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
		reenqueueTime = TIMER_DONT_REQUEUE;
	}

	DBGPRINT(SEND, INFO,
			("spxConnRetryTimer: Reenqueue time : %lx on %lx\n",
				reenqueueTime, pSpxConnFile));

	return(reenqueueTime);
}




ULONG
spxConnAckTimer(
	IN PVOID 	Context,
	IN BOOLEAN	TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)Context;
	CTELockHandle	lockHandleConn;

	DBGPRINT(SEND, INFO,
			("spxConnAckTimer: Entered\n"));

	//	Get lock
	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);

	if (!TimerShuttingDown &&
		SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_ACKQ))
	{
		//	We didnt have any back traffic, until we do a send from this
		//	end, send acks immediately. Dont try to piggyback.
		SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_ACKQ);
		SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_IMMED_ACK);

        ++SpxDevice->dev_Stat.PiggybackAckTimeouts;

		DBGPRINT(SEND, DBG,
				("spxConnAckTimer: Send ack on %lx.%lx\n",
					pSpxConnFile, pSpxConnFile->scf_RecvSeqNum));

		SpxConnSendAck(pSpxConnFile, lockHandleConn);
	}
	else
	{
		SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_ACKQ);
		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
	}

	//	Dereference connection for verify done in connect, for timer. This
	//	should complete any pending disconnects if they had come in in the
	//	meantime.
	SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	return(TIMER_DONT_REQUEUE);
}



//
//	DISCONNECT ROUTINES
//


VOID
spxConnAbortiveDisc(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	NTSTATUS	        Status,
	IN	SPX_CALL_LEVEL		CallLevel,
	IN	CTELockHandle		LockHandleConn,
    IN  BOOLEAN             IDiscFlag       // [SA] Bug #15249
	)
/*++

Routine Description:

	This is called when:
		We time out or have insufficient resources 	-
			STATUS_LINK_TIMEOUT/STATUS_INSUFFICIENT_RESOURCES
			- We abort everything. Could be from watchdog or retry. Stop both.

		We receive a informed disconnect packet    	-
			STATUS_REMOTE_DISCONNECT
			- We abort everything. Ack must be sent by caller as an orphan pkt.

		We receive a informed disconnect ack pkt
			STATUS_SUCCESS
			- We abort everything
			- Abort is done with status success (this completes our disc req in
			  the send queue)

    NOTE: CALLED UNDER THE CONNECTION LOCK.

Arguments:
[SA]    Bug #15249: Added IDiscFlag to indicate if this is an Informed Disconnect. If so, indicate
        TDI_DISCONNECT_RELEASE to AFD so it allows a receive of buffered pkts. This flag is TRUE
        only if this routine is called from SpxConnProcessIDisc for SPX connections.

Return Value:


--*/
{
	int						numDerefs = 0;
    PVOID 					pDiscHandlerCtx=NULL;
    PTDI_IND_DISCONNECT 	pDiscHandler	= NULL;
	BOOLEAN					lockHeld = TRUE;

	DBGPRINT(CONNECT, DBG,
			("spxConnAbortiveDisc: %lx - On %lx when %lx\n",
				Status, pSpxConnFile, SPX_MAIN_STATE(pSpxConnFile)));

    switch (Status) {
    case STATUS_LINK_TIMEOUT: ++SpxDevice->dev_Stat.LinkFailures; break;
    case STATUS_INSUFFICIENT_RESOURCES: ++SpxDevice->dev_Stat.LocalResourceFailures; break;
    case STATUS_REMOTE_DISCONNECT: ++SpxDevice->dev_Stat.RemoteDisconnects; break;
    case STATUS_SUCCESS:
    case STATUS_LOCAL_DISCONNECT: ++SpxDevice->dev_Stat.LocalDisconnects; break;
    }

	switch (SPX_MAIN_STATE(pSpxConnFile))
	{
	case SPX_CONNFILE_ACTIVE:

		//	For transition from active to disconn.
		numDerefs++;

	case SPX_CONNFILE_DISCONN:

		//	If we are in any state other than idle/packetize,
		//	remove the reference for the funky state, and reset the send state to be
		//	idle.
		if ((SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_IDLE) &&
			(SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_PACKETIZE))
		{
#if DBG
			if ((SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN) &&
				(SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_ABORT))
			{
				DBGPRINT(CONNECT, ERR,
						("spxConnAbortiveDisc: When DISC STATE %lx.%lx\n",
							pSpxConnFile, SPX_SEND_STATE(pSpxConnFile)));
			}
#endif

			DBGPRINT(CONNECT, DBG1,
					("spxConnAbortiveDisc: When SEND ERROR STATE %lx.%lx\n",
						pSpxConnFile, SPX_SEND_STATE(pSpxConnFile)));
		
            SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_IDLE);

			SpxConnFileTransferReference(
				pSpxConnFile,
				CFREF_ERRORSTATE,
				CFREF_VERIFY);

			numDerefs++;
		}

		//	This can be called when a idisc is received, or if a timer
		//	disconnect is happening, or if we sent a idisc/ordrel, but the retries
		//	timed out and we are aborting the connection.
		//	So if we are already aborting, never mind.

        //
        // [SA] Bug #15249
        // SPX_DISC_INACTIVATED indicates a DISC_ABORT'ing connection that has been
        // inactivated (connfile removed from active conn. list)
        //

		if ((SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN) &&
            ((SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_ABORT) ||
            (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_INACTIVATED)))
		{
			break;
		}

        SPX_MAIN_SETSTATE(pSpxConnFile, SPX_CONNFILE_DISCONN);
        SPX_DISC_SETSTATE(pSpxConnFile, SPX_DISC_ABORT);

		//	Stop all timers.
		if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_T_TIMER))
		{
			if (SpxTimerCancelEvent(pSpxConnFile->scf_TTimerId, FALSE))
			{
				numDerefs++;
			}
			SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_T_TIMER);
		}
	
		if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_R_TIMER))
		{
			if (SpxTimerCancelEvent(pSpxConnFile->scf_RTimerId, FALSE))
			{
				numDerefs++;
			}
			SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_R_TIMER);
		}
		
		if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER))
		{
			if (SpxTimerCancelEvent(pSpxConnFile->scf_WTimerId, FALSE))
			{
				numDerefs++;
			}
			SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER);
		}
#if 0
        //
        // [SA] We need to call AFD after aborting sends since this connection
        // becomes a candidate for re-use as soon as the disconnect handler is
        // called.
        // We call the disconnect handler when the refcount falls to 0 and the
        // connection transitions to the inactive list.
        //

		//	NOTE! We indicate disconnect to afd *before* aborting sends to avoid
		//		  afd from calling us again with a disconnect.
		//	Get disconnect handler if we have one. And we have not indicated
		//	abortive disconnect on this connection to afd.
		if (!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC))
		{
			//	Yeah, we set the flag regardless of whether a handler is
			//	present.
			pDiscHandler 	= pSpxConnFile->scf_AddrFile->saf_DiscHandler;
			pDiscHandlerCtx = pSpxConnFile->scf_AddrFile->saf_DiscHandlerCtx;
			SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC);
		}
#endif
        //
        // [SA] Save the IDiscFlag in the Connection.
        //
        (IDiscFlag) ?
            SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_IDISC) :
            SPX_CONN_RESETFLAG2(pSpxConnFile, SPX_CONNFILE2_IDISC);

		//	Indicate disconnect to afd.
		if (pDiscHandler != NULL)
		{
			CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);

			DBGPRINT(CONNECT, INFO,
					("spxConnAbortiveDisc: Indicating to afd On %lx when %lx\n",
						pSpxConnFile, SPX_MAIN_STATE(pSpxConnFile)));
		
			//	First complete all requests waiting for receive completion on
			//	this conn before indicating disconnect.
			spxConnCompletePended(pSpxConnFile);


            //
            // [SA] bug #15249
            // If not Informed disconnect, indicate DISCONNECT_ABORT to AFD
            //

            if (!IDiscFlag)
            {
                (*pDiscHandler)(
                        pDiscHandlerCtx,
                        pSpxConnFile->scf_ConnCtx,
                        0,								// Disc data
                        NULL,
                        0,								// Disc info
                        NULL,
                        TDI_DISCONNECT_ABORT);
            }
            else
            {
                //
                // [SA] bug #15249
                // Indicate DISCONNECT_RELEASE to AFD so it allows receive of packets
                // it has buffered before the remote disconnect took place.
                //

                (*pDiscHandler)(
                        pDiscHandlerCtx,
                        pSpxConnFile->scf_ConnCtx,
                        0,								// Disc data
                        NULL,
                        0,								// Disc info
                        NULL,
                        TDI_DISCONNECT_RELEASE);
            }

			CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);
		}

		//	Go through and kill all pending requests.
		spxConnAbortRecvs(
			pSpxConnFile,
			Status,
			CallLevel,
			LockHandleConn);

		CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);

		spxConnAbortSends(
			pSpxConnFile,
			Status,
			CallLevel,
			LockHandleConn);

		lockHeld = FALSE;
		break;

	case SPX_CONNFILE_CONNECTING:
	case SPX_CONNFILE_LISTENING:

		DBGPRINT(CONNECT, DBG,
				("spxConnAbortiveDisc: CONN/LIST Disc On %lx when %lx\n",
					pSpxConnFile, SPX_MAIN_STATE(pSpxConnFile)));

		CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
		lockHeld = FALSE;

		{
			CTELockHandle	lockHandleAddr, lockHandleDev;

			CTEGetLock(&SpxDevice->dev_Lock, &lockHandleDev);
			CTEGetLock(pSpxConnFile->scf_AddrFile->saf_AddrLock, &lockHandleAddr);
			CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);

			//	Ensure we are still in connecting/listening, else call abortive
			//	again.
			switch (SPX_MAIN_STATE(pSpxConnFile))
			{
			case SPX_CONNFILE_CONNECTING:
			case SPX_CONNFILE_LISTENING:

				DBGPRINT(CONNECT, DBG,
						("spxConnAbortiveDisc: CONN/LIST Disc2 On %lx when %lx\n",
							pSpxConnFile, SPX_MAIN_STATE(pSpxConnFile)));

				spxConnAbortConnect(
					pSpxConnFile,
					Status,
					lockHandleDev,
					lockHandleAddr,
					LockHandleConn);

				break;

			case SPX_CONNFILE_ACTIVE:

				CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
				CTEFreeLock(
					pSpxConnFile->scf_AddrFile->saf_AddrLock, lockHandleAddr);
				CTEFreeLock(
					&SpxDevice->dev_Lock, lockHandleDev);

				CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);

				DBGPRINT(CONNECT, DBG,
						("spxConnAbortiveDisc: CHG ACT Disc2 On %lx when %lx\n",
							pSpxConnFile, SPX_MAIN_STATE(pSpxConnFile)));

				spxConnAbortiveDisc(
					pSpxConnFile,
					Status,
					CallLevel,
					LockHandleConn,
                    FALSE);     // [SA] Bug #15249

				break;

			default:

				CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
				CTEFreeLock(
					pSpxConnFile->scf_AddrFile->saf_AddrLock, lockHandleAddr);
				CTEFreeLock(
					&SpxDevice->dev_Lock, lockHandleDev);

				break;
			}
		}

	default:

		//	Already disconnected.
		break;
	}

	if (lockHeld)
	{
		CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
	}

	while (numDerefs-- > 0)
	{
		SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxerror.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxerror.c

Abstract:

    This module contains code which provides error logging support.

Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifndef __PREFAST__
#pragma warning(disable:4068)
#endif
#pragma prefast(disable:276, "The assignments are harmless")


//      Define module number for event logging entries
#define FILENUM         SPXERROR

LONG            SpxLastRawDataLen               = 0;
NTSTATUS        SpxLastUniqueErrorCode  = STATUS_SUCCESS;
NTSTATUS        SpxLastNtStatusCode             = STATUS_SUCCESS;
ULONG           SpxLastErrorCount               = 0;
LONG            SpxLastErrorTime                = 0;
BYTE            SpxLastRawData[PORT_MAXIMUM_MESSAGE_LENGTH - \
                                                         sizeof(IO_ERROR_LOG_PACKET)]   = {0};

BOOLEAN
SpxFilterErrorLogEntry(
    IN  NTSTATUS                        UniqueErrorCode,
    IN  NTSTATUS                        NtStatusCode,
    IN  PVOID                           RawDataBuf                      OPTIONAL,
    IN  LONG                            RawDataLen
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{

    int                                         insertionStringLength = 0;

        // Filter out events such that the same event recurring close together does not
        // cause errorlog clogging. The scheme is - if the event is same as the last event
        // and the elapsed time is > THRESHOLD and ERROR_CONSEQ_FREQ simulataneous errors
        // have happened, then log it else skip
        if ((UniqueErrorCode == SpxLastUniqueErrorCode) &&
                (NtStatusCode    == SpxLastNtStatusCode))
        {
                SpxLastErrorCount++;
                if ((SpxLastRawDataLen == RawDataLen)                                   &&
                        (RtlEqualMemory(SpxLastRawData, RawDataBuf, RawDataLen)) &&
                        ((SpxLastErrorCount % ERROR_CONSEQ_FREQ) != 0)          &&
                        ((SpxGetCurrentTime() - SpxLastErrorTime) < ERROR_CONSEQ_TIME))
                {
                        return(FALSE);
                }
        }

        SpxLastUniqueErrorCode  = UniqueErrorCode;
        SpxLastNtStatusCode             = NtStatusCode;
        SpxLastErrorCount               = 0;
        SpxLastErrorTime                = SpxGetCurrentTime();
        if (RawDataLen != 0)
        {
            SpxLastRawDataLen = RawDataLen;
                RtlCopyMemory(
                        SpxLastRawData,
                        RawDataBuf,
                        RawDataLen);
        }

        return(TRUE);
}




VOID
SpxWriteResourceErrorLog(
    IN PDEVICE  Device,
    IN ULONG    BytesNeeded,
    IN ULONG    UniqueErrorValue
    )

/*++

Routine Description:

    This routine allocates and writes an error log entry indicating
    an out of resources condition.

Arguments:

    Device - Pointer to the device context.

    BytesNeeded - If applicable, the number of bytes that could not
        be allocated.

    UniqueErrorValue - Used as the UniqueErrorValue in the error log
        packet.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    UCHAR EntrySize;
    PUCHAR StringLoc;
    ULONG TempUniqueError;
    static WCHAR UniqueErrorBuffer[4] = L"000";
    INT i;

        if (!SpxFilterErrorLogEntry(
                        EVENT_TRANSPORT_RESOURCE_POOL,
                        STATUS_INSUFFICIENT_RESOURCES,
                        (PVOID)&BytesNeeded,
                        sizeof(BytesNeeded)))
        {
                return;
        }

    EntrySize = sizeof(IO_ERROR_LOG_PACKET) +
                Device->dev_DeviceNameLen       +
                sizeof(UniqueErrorBuffer);

    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
                                                                                                (PDEVICE_OBJECT)Device,
                                                                                                EntrySize);

    // Convert the error value into a buffer.
    TempUniqueError = UniqueErrorValue;
    for (i=1; i>=0; i--)
        {
        UniqueErrorBuffer[i] = (WCHAR)((TempUniqueError % 10) + L'0');
        TempUniqueError /= 10;
    }

    if (errorLogEntry != NULL)
        {
        errorLogEntry->MajorFunctionCode = (UCHAR)-1;
        errorLogEntry->RetryCount = (UCHAR)-1;
        errorLogEntry->DumpDataSize = sizeof(ULONG);
        errorLogEntry->NumberOfStrings = 2;
        errorLogEntry->StringOffset = sizeof(IO_ERROR_LOG_PACKET);
        errorLogEntry->EventCategory = 0;
        errorLogEntry->ErrorCode = EVENT_TRANSPORT_RESOURCE_POOL;
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;
        errorLogEntry->SequenceNumber = (ULONG)-1;
        errorLogEntry->IoControlCode = 0;
        errorLogEntry->DumpData[0] = BytesNeeded;

        StringLoc = ((PUCHAR)errorLogEntry) + errorLogEntry->StringOffset;
        RtlCopyMemory(
                        StringLoc, Device->dev_DeviceName, Device->dev_DeviceNameLen);

        StringLoc += Device->dev_DeviceNameLen;
        RtlCopyMemory(
                        StringLoc, UniqueErrorBuffer, sizeof(UniqueErrorBuffer));

        IoWriteErrorLogEntry(errorLogEntry);
    }
}




VOID
SpxWriteGeneralErrorLog(
    IN PDEVICE  Device,
    IN NTSTATUS ErrorCode,
    IN ULONG    UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN PWSTR    SecondString,
    IN  PVOID   RawDataBuf              OPTIONAL,
    IN  LONG    RawDataLen
    )

/*++

Routine Description:

    This routine allocates and writes an error log entry indicating
    a general problem as indicated by the parameters. It handles
    event codes REGISTER_FAILED, BINDING_FAILED, ADAPTER_NOT_FOUND,
    TRANSFER_DATA, TOO_MANY_LINKS, and BAD_PROTOCOL. All these
    events have messages with one or two strings in them.

Arguments:

    Device - Pointer to the device context, or this may be
        a driver object instead.

    ErrorCode - The transport event code.

    UniqueErrorValue - Used as the UniqueErrorValue in the error log
        packet.

    FinalStatus - Used as the FinalStatus in the error log packet.

    SecondString - If not NULL, the string to use as the %3
        value in the error log packet.

    RawDataBuf  - The number of ULONGs of dump data.

    RawDataLen  - Dump data for the packet.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    UCHAR EntrySize;
    ULONG SecondStringSize;
    PUCHAR StringLoc;
    static WCHAR DriverName[4] = L"Spx";

        if (!SpxFilterErrorLogEntry(
                        ErrorCode,
                        FinalStatus,
                        RawDataBuf,
                        RawDataLen))
        {
                return;
        }

#ifdef DBG
		if ( sizeof(IO_ERROR_LOG_PACKET) + RawDataLen > 255) {
			DbgPrint("Size greater than maximum entry size 255.\n");
		}
#endif

    EntrySize = (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) + RawDataLen);
    if (Device->dev_Type == SPX_DEVICE_SIGNATURE)
        {
        EntrySize += (UCHAR)Device->dev_DeviceNameLen;
    }
        else
        {
        EntrySize += sizeof(DriverName);
    }

    if (SecondString)
        {
        SecondStringSize = (wcslen(SecondString)*sizeof(WCHAR)) + sizeof(UNICODE_NULL);
        EntrySize += (UCHAR)SecondStringSize;
    }

    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
                                                                                                        (PDEVICE_OBJECT)Device,
                                                                                                        EntrySize);

    if (errorLogEntry != NULL)
        {
        errorLogEntry->MajorFunctionCode = (UCHAR)-1;
        errorLogEntry->RetryCount = (UCHAR)-1;
        errorLogEntry->DumpDataSize = (USHORT)RawDataLen;
        errorLogEntry->NumberOfStrings = (SecondString == NULL) ? 1 : 2;
        errorLogEntry->StringOffset = (USHORT)
            (sizeof(IO_ERROR_LOG_PACKET) + RawDataLen);
        errorLogEntry->EventCategory = 0;
        errorLogEntry->ErrorCode = ErrorCode;
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->FinalStatus = FinalStatus;
        errorLogEntry->SequenceNumber = (ULONG)-1;
        errorLogEntry->IoControlCode = 0;

        if (RawDataLen != 0)
                {
            RtlCopyMemory(errorLogEntry->DumpData, RawDataBuf, RawDataLen);
                }

        StringLoc = ((PUCHAR)errorLogEntry) + errorLogEntry->StringOffset;
        if (Device->dev_Type == SPX_DEVICE_SIGNATURE)
                {
            RtlCopyMemory(
                                StringLoc, Device->dev_DeviceName, Device->dev_DeviceNameLen);

            StringLoc += Device->dev_DeviceNameLen;
        }
                else
                {
            RtlCopyMemory (StringLoc, DriverName, sizeof(DriverName));
            StringLoc += sizeof(DriverName);
        }

        if (SecondString)
                {
            RtlCopyMemory (StringLoc, SecondString, SecondStringSize);
        }

        IoWriteErrorLogEntry(errorLogEntry);
    }

        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxdev.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxdev.c

Abstract:

    This module contains code which implements the DEVICE_CONTEXT object.
    Routines are provided to reference, and dereference transport device
    context objects.

    The transport device context object is a structure which contains a
    system-defined DEVICE_OBJECT followed by information which is maintained
    by the transport provider, called the context.

Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//      Define module number for event logging entries
#define FILENUM         SPXDEV

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, SpxInitCreateDevice)
#pragma alloc_text(PAGE, SpxDestroyDevice)
#endif

#ifndef __PREFAST__
#pragma warning(disable:4068)
#endif
#pragma prefast(disable:276, "The assignments are harmless")



VOID
SpxDerefDevice(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine dereferences a device context by decrementing the
    reference count contained in the structure.  Currently, we don't
    do anything special when the reference count drops to zero, but
    we could dynamically unload stuff then.

Arguments:

    Device - Pointer to a transport device context object.

Return Value:

    none.

--*/

{
    LONG result;

    result = InterlockedDecrement (&Device->dev_RefCount);

    CTEAssert (result >= 0);

    if (result == 0)
        {
                //      Close binding to IPX
                SpxUnbindFromIpx();

                //      Set unload event.
                KeSetEvent(&SpxUnloadEvent, IO_NETWORK_INCREMENT, FALSE);
    }

} // SpxDerefDevice




NTSTATUS
SpxInitCreateDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  DeviceName
    )

/*++

Routine Description:

    This routine creates and initializes a device context structure.

Arguments:


    DriverObject - pointer to the IO subsystem supplied driver object.

    Device - Pointer to a pointer to a transport device context object.

    DeviceName - pointer to the name of the device this device object points to.

Return Value:

    STATUS_SUCCESS if all is well; STATUS_INSUFFICIENT_RESOURCES otherwise.

--*/

{
    NTSTATUS        status;
    PDEVICE         Device;
    ULONG           DeviceNameOffset;

    DBGPRINT(DEVICE, INFO,
                        ("SpxInitCreateDevice - Create device %ws\n", DeviceName->Buffer));

    // Create the device object for the sample transport, allowing
    // room at the end for the device name to be stored (for use
    // in logging errors).

    SpxDevice = SpxAllocateMemory(sizeof (DEVICE) + DeviceName->Length + sizeof(UNICODE_NULL));

    if (!SpxDevice) {
        DbgPrint("SPX: FATAL Error: cant allocate Device Structure\n");
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Device                               = (PDEVICE)SpxDevice;

    RtlZeroMemory(SpxDevice, sizeof (DEVICE) + DeviceName->Length + sizeof(UNICODE_NULL) );

    //
    // This is the closest we can set the provider info [ShreeM]
    //
    SpxQueryInitProviderInfo(&Device->dev_ProviderInfo);

    DBGPRINT(DEVICE, INFO, ("IoCreateDevice succeeded %lx\n", Device));

    // Initialize our part of the device context.
    RtlZeroMemory(
        ((PUCHAR)Device) + sizeof(DEVICE_OBJECT),
        sizeof(DEVICE) - sizeof(DEVICE_OBJECT));

    DeviceNameOffset = sizeof(DEVICE);

    // Copy over the device name.
    Device->dev_DeviceNameLen   = DeviceName->Length + sizeof(WCHAR);
    Device->dev_DeviceName      = (PWCHAR)(((PUCHAR)Device) + DeviceNameOffset);

    RtlCopyMemory(
        Device->dev_DeviceName,
        DeviceName->Buffer,
        DeviceName->Length);

    Device->dev_DeviceName[DeviceName->Length/sizeof(WCHAR)] = UNICODE_NULL;

    // Initialize the reference count.
    Device->dev_RefCount = 1;

#if DBG
    Device->dev_RefTypes[DREF_CREATE] = 1;
#endif

#if DBG
    RtlCopyMemory(Device->dev_Signature1, "IDC1", 4);
    RtlCopyMemory(Device->dev_Signature2, "IDC2", 4);
#endif

        //      Set next conn id to be used.
        Device->dev_NextConnId                                                  = (USHORT)SpxRandomNumber();
        if (Device->dev_NextConnId == 0xFFFF)
        {
                Device->dev_NextConnId  = 1;
        }

        DBGPRINT(DEVICE, ERR,
                        ("SpxInitCreateDevice: Start Conn Id %lx\n", Device->dev_NextConnId));

    // Initialize the resource that guards address ACLs.
    ExInitializeResourceLite (&Device->dev_AddrResource);

    // initialize the various fields in the device context
    CTEInitLock (&Device->dev_Interlock);
    CTEInitLock (&Device->dev_Lock);
    KeInitializeSpinLock (&Device->dev_StatInterlock);
    KeInitializeSpinLock (&Device->dev_StatSpinLock);

    Device->dev_State       = DEVICE_STATE_CLOSED;
    Device->dev_Type        = SPX_DEVICE_SIGNATURE;
    Device->dev_Size        = sizeof (DEVICE);

    Device->dev_Stat.Version = 0x100;

    return STATUS_SUCCESS;

}   // SpxCreateDevice




VOID
SpxDestroyDevice(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine destroys a device context structure.

Arguments:

    Device - Pointer to a pointer to a transport device context object.

Return Value:

    None.

--*/

{
    ExDeleteResourceLite (&Device->dev_AddrResource);

    IoDeleteDevice ((PDEVICE_OBJECT)SpxDevice->dev_DevObj);

    SpxFreeMemory(SpxDevice);

}   // SpxDestroyDevice
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxdev.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxdev.h

Abstract:

    This module contains definitions specific to the
    SPX module of the ISN transport.

Author:

        Adam   Barr              (adamba ) Original Version
    Nikhil Kamkolkar (nikhilk) 17-November-1993

Environment:

    Kernel mode

Revision History:

--*/


// Hash buckets for SPX_ADDR done using socket number
#define NUM_SPXADDR_HASH_BUCKETS        8
#define NUM_SPXADDR_HASH_MASK           7
#define NUM_SPXCONN_HASH_BUCKETS        8
#define NUM_SPXCONN_HASH_MASK           7

// This structure defines the per-device structure for SPX
// (one of these is allocated globally).
#define DREF_CREATE   0
#define DREF_LOADED   1
#define DREF_ADAPTER  2
#define DREF_ADDRESS  3
#define DREF_ORPHAN       4

#define DREF_TOTAL    5

typedef struct _DEVICE {

    PDEVICE_OBJECT   dev_DevObj;                         // the I/O system's device object.

#if DBG
    ULONG           dev_RefTypes[DREF_TOTAL];
#endif

    CSHORT          dev_Type;               // type of this structure
    USHORT          dev_Size;               // size of this structure

#if DBG
    UCHAR                       dev_Signature1[4];              // contains "SPX1"
#endif

    // activity count/this provider.
    LONG                        dev_RefCount;
    UCHAR                       dev_State;

    // number of adapters IPX is bound to.
    USHORT          dev_Adapters;

        // GLOBAL lock for reference count (used in ExInterlockedXxx calls).
    CTELock             dev_Interlock;
    CTELock             dev_Lock;

        //      Hash table of lists of addresses opened on this device
        struct  _SPX_ADDR               *       dev_AddrHashTable[NUM_SPXADDR_HASH_BUCKETS];

        //      List of all active connections, later this be a tree.
        struct  _SPX_CONN_FILE  *       dev_GlobalActiveConnList[NUM_SPXCONN_HASH_BUCKETS];
        USHORT                                          dev_NextConnId;

    // Other configuration parameters.
    // Where the current socket allocation is.
    USHORT                      dev_CurrentSocket;

    // Our node and network.
    UCHAR                       dev_Network[4];
    UCHAR                       dev_Node[6];

        //      Pointer to the config information from registry
        PCONFIG                 dev_ConfigInfo;

        //      Control channel identifier
        ULONG                   dev_CcId;

    // These are kept around for error logging, and stored right
    // after this structure.
    PWCHAR          dev_DeviceName;
#if     defined(_PNP_POWER)
    USHORT           dev_DeviceNameLen;
#else
    ULONG           dev_DeviceNameLen;
#endif  _PNP_POWER

#if DBG
    UCHAR                       dev_Signature2[4];      // contains "SPX2"
#endif

        //      Handle to ndis buffer pool for spx stack.
        NDIS_HANDLE             dev_NdisBufferPoolHandle;

    // registration handle with tdi clients.
#if     defined(_PNP_POWER)
    HANDLE              dev_TdiRegistrationHandle;
#endif  _PNP_POWER

    // This interlock is used to guard access to the statistics
    // define below.
    KSPIN_LOCK          dev_StatInterlock;              // for ULONG quantities
    KSPIN_LOCK          dev_StatSpinLock;       // for LARGE_INTEGER quantities

    // Counters for most of the statistics that SPX maintains;
    // some of these are kept elsewhere. Including the structure
    // itself wastes a little space but ensures that the alignment
    // inside the structure is correct.
    TDI_PROVIDER_STATISTICS dev_Stat;

    // This resource guards access to the ShareAccess
    // and SecurityDescriptor fields in addresses.
    ERESOURCE           dev_AddrResource;

    // The following structure contains statistics counters for use
    // by TdiQueryInformation and TdiSetInformation.  They should not
    // be used for maintenance of internal data structures.
    TDI_PROVIDER_INFO dev_ProviderInfo;     // information about this provider.

} DEVICE, * PDEVICE;

//
// As part of "doing it ourselves" theme as opposed to the DeviceExtension code,
// we declare a global SpxDevice that will be used by all.
//
//PDEVICE         SpxDevice;
//PDEVICE_OBJECT  DeviceObject;

// device state definitions
#if     defined(_PNP_POWER)
#define DEVICE_STATE_CLOSED   0x00      // Initial state
#define DEVICE_STATE_LOADED   0x01      // Loaded and bound to IPX but no adapters
#define DEVICE_STATE_OPEN     0x02      // Fully operational
#define DEVICE_STATE_STOPPING 0x03      // Unload has been initiated, The I/O system
                                        // will not call us until nobody above has Netbios open.
#else
#define DEVICE_STATE_CLOSED   0x00
#define DEVICE_STATE_OPEN     0x01
#define DEVICE_STATE_STOPPING 0x02
#endif  _PNP_POWER


//  SPX device name
#define SPX_DEVICE_NAME         L"\\Device\\NwlnkSpx"

#define SPX_TDI_RESOURCES     9


//      MACROS
#if DBG

#define SpxReferenceDevice(_Device, _Type)                              \
                {                                                                                               \
                        (VOID)SPX_ADD_ULONG (                           \
                                &(_Device)->dev_RefTypes[_Type],                \
                                1,                                                                              \
                                &SpxGlobalInterlock);                                   \
                                                                                                                \
                        (VOID)InterlockedIncrement (                      \
                                          &(_Device)->dev_RefCount);                     \
                }

#define SpxDereferenceDevice(_Device, _Type)                    \
                {                                                                                               \
                        (VOID)SPX_ADD_ULONG (                           \
                                &(_Device)->dev_RefTypes[_Type],                \
                                (ULONG)-1,                                                              \
                                &SpxGlobalInterlock);                                   \
                        SpxDerefDevice (_Device);                                       \
                }

#else

#define SpxReferenceDevice(_Device, _Type)                              \
                {                                                                                               \
                        (VOID)InterlockedIncrement (                      \
                                          &(_Device)->dev_RefCount);                     \
                }

#define SpxDereferenceDevice(_Device, _Type)                    \
                        SpxDerefDevice (_Device)

#endif

//  EXPORTED ROUTINES

VOID
SpxDestroyDevice(
    IN PDEVICE Device);

VOID
SpxDerefDevice(
    IN PDEVICE Device);

NTSTATUS
SpxInitCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING DeviceName);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxmem.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxmem.h

Abstract:

    This module contains memory management routines.

Author:

    Nikhil Kamkolkar (nikhilk) 17-November-1993

Environment:

    Kernel mode

Revision History:

--*/


#define	QWORDSIZEBLOCK(Size)	(((Size)+sizeof(LARGE_INTEGER)-1) & ~(sizeof(LARGE_INTEGER)-1))
#define	SPX_MEMORY_SIGNATURE	*(PULONG)"SPXM"
#define	ZEROED_MEMORY_TAG		0xF0000000
#define	SPX_TAG					*((PULONG)"SPX ")

//
// Definitions for the block management package
//
typedef	UCHAR	BLKID;

// Add a BLKID_xxx and an entry to atalkBlkSize for every block client
#define	BLKID_TIMERLIST				(BLKID)0
#define	BLKID_NDISSEND				(BLKID)1
#define	BLKID_NDISRECV				(BLKID)2
#define	NUM_BLKIDS					(BLKID)3

typedef	struct _BLK_CHUNK
{
	struct _BLK_CHUNK *	bc_Next;		// Pointer to next in the link
	SHORT				bc_NumFrees;	// Number of free blocks in the chunk
	UCHAR				bc_Age;			// Number of invocations since the chunk free
	BLKID				bc_BlkId;		// Id of the block
	struct _BLK_HDR *	bc_FreeHead;	// Head of the list of free blocks

#ifndef SPX_OWN_PACKETS
	PVOID				bc_ChunkCtx;	// Used to store pool header if not own
										// packets
#else
    PVOID               bc_Padding;     // Keep the header 16 bytes
#endif

	// This is followed by an array of N blks of size M such that the block header
	// is exactly spxChunkSize[i]

} BLK_CHUNK, *PBLK_CHUNK;

typedef	struct _BLK_HDR
{
	union
	{
		struct _BLK_HDR	*	bh_Next;	// Valid when it is free
		struct _BLK_CHUNK *	bh_pChunk;	// The parent chunk to which this blocks belong
										// valid when it is allocated
	};
    PVOID               bh_Padding;     // Make the header 8 bytes
} BLK_HDR, *PBLK_HDR;

#define	BC_OVERHEAD				(8+8)		// LARGE_INTEGER for SpxAllocMemory() header and
										// POOL_HEADER for ExAllocatePool() header

#define	BLOCK_POOL_TIMER			1000	//	Check interval (1 sec)
#define	MAX_BLOCK_POOL_AGE			3		// # of timer invocations before free

ULONG
spxBPAgePool(
	IN PVOID 	Context,
	IN BOOLEAN	TimerShuttingDown);


#ifdef	TRACK_MEMORY_USAGE

#define	SpxAllocateMemory(Size)	SpxAllocMem((Size), FILENUM | __LINE__)

extern
PVOID
SpxAllocMem(
    IN	ULONG   Size,
	IN	ULONG	FileLine
);

extern
VOID
SpxTrackMemoryUsage(
	IN	PVOID	pMem,
	IN	BOOLEAN	Alloc,
	IN	ULONG	FileLine
);

#else

#define	SpxAllocateMemory(Size)	SpxAllocMem(Size)
#define	SpxTrackMemoryUsage(pMem, Alloc, FileLine)

extern
PVOID
SpxAllocMem(
    IN	ULONG   Size
);

#endif	// TRACK_MEMORY_USAGE

VOID
SpxFreeMemory(
	IN	PVOID	pBuf);

#define	SpxAllocateZeroedMemory(Size)	SpxAllocateMemory((Size) | ZEROED_MEMORY_TAG)


extern
NTSTATUS
SpxInitMemorySystem(
	IN	PDEVICE		pSpxDevice);

extern
VOID
SpxDeInitMemorySystem(
	IN	PDEVICE		pSpxDevice);

PVOID
SpxBPAllocBlock(
	IN	BLKID		BlockId);

VOID
SpxBPFreeBlock(
	IN	PVOID		pBlock,
	IN	BLKID		BlockId);

PNDIS_PACKET
GrowSPXPacketList(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxdrvr.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxdrvr.c

Abstract:

    This module contains the DriverEntry and other initialization
    code for the SPX/SPXII module of the ISN transport.

Author:

	Adam   Barr		 (adamba)  Original Version
    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:

   Sanjay Anand (SanjayAn) 14-July-1995
   Bug fixes - tagged [SA]

--*/

#include "precomp.h"
#pragma hdrstop

//	Define module number for event logging entries
#define	FILENUM		SPXDRVR

// Forward declaration of various routines used in this module.

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath);

NTSTATUS
SpxDispatchOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

NTSTATUS
SpxDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

NTSTATUS
SpxDispatchInternal (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

NTSTATUS
SpxDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

VOID
SpxUnload(
    IN PDRIVER_OBJECT DriverObject);

VOID
SpxTdiCancel(
    IN PDEVICE_OBJECT 	DeviceObject,
    IN PIRP 			Irp);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, SpxUnload)
#pragma alloc_text(PAGE, SpxDispatch)
#pragma alloc_text(PAGE, SpxDeviceControl)
#pragma alloc_text(PAGE, SpxUnload)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT 	DriverObject,
    IN PUNICODE_STRING 	RegistryPath
    )

/*++

Routine Description:

    This routine performs initialization of the SPX ISN module.
    It creates the device objects for the transport
    provider and performs other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

    RegistryPath - The name of ST's node in the registry.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    UNICODE_STRING	deviceName;
    NTSTATUS        status  = STATUS_SUCCESS;
    BOOLEAN         BoundToIpx = FALSE;
    //	DBGBRK(FATAL);

	// Initialize the Common Transport Environment.
	if (CTEInitialize() == 0) {
		return (STATUS_UNSUCCESSFUL);
	}

	//	We have this #define'd. Ugh, but CONTAINING_RECORD has problem owise.
	//CTEAssert(NDIS_PACKET_SIZE == FIELD_OFFSET(NDIS_PACKET, ProtocolReserved[0]));

	// Create the device object. (IoCreateDevice zeroes the memory
	// occupied by the object.)
	RtlInitUnicodeString(&deviceName, SPX_DEVICE_NAME);

    status = SpxInitCreateDevice(
				 DriverObject,
				 &deviceName);

	if (!NT_SUCCESS(status))
	{
		return(status);
	}

    do
	{
		CTEInitLock (&SpxGlobalInterlock);
		CTEInitLock (&SpxGlobalQInterlock);

        // 
        // We need the following locks for the NDIS_PACKETPOOL changes [MS]
        //
        CTEInitLock(&SendHeaderLock);
        CTEInitLock(&RecvHeaderLock);
        ExInitializeSListHead(&SendPacketList);
        ExInitializeSListHead(&RecvPacketList);

		//	Initialize the unload event
 		KeInitializeEvent(
			&SpxUnloadEvent,
			NotificationEvent,
			FALSE);

		//	!!!The device is created at this point!!!
        //  Get information from the registry.
        status  = SpxInitGetConfiguration(
                    RegistryPath,
                    &SpxDevice->dev_ConfigInfo);

        if (!NT_SUCCESS(status))
		{
            break;
        }

#if     defined(_PNP_POWER)
        //
        // Make Tdi ready for pnp notifications before binding
        // to IPX
        //
        TdiInitialize();

		//	Initialize the timer system. This should be done before
        //  binding to ipx because we should have timers intialized
        //  before ipx calls our pnp indications.
		if (!NT_SUCCESS(status = SpxTimerInit()))
		{
			break;
		}
#endif  _PNP_POWER

        //  Bind to the IPX transport.
        if (!NT_SUCCESS(status = SpxInitBindToIpx()))
		{
			//	Have ipx name here as second string
			LOG_ERROR(
				EVENT_TRANSPORT_BINDING_FAILED,
				status,
				NULL,
				NULL,
				0);

            break;
        }

        BoundToIpx = TRUE;

#if      !defined(_PNP_POWER)
		//	Initialize the timer system
		if (!NT_SUCCESS(status = SpxTimerInit()))
		{
			break;
		}
#endif  !_PNP_POWER

		//	Initialize the block manager
		if (!NT_SUCCESS(status = SpxInitMemorySystem(SpxDevice)))
		{

			//	Stop the timer subsystem
			SpxTimerFlushAndStop();
			break;
		}

        // Initialize the driver object with this driver's entry points.
        DriverObject->MajorFunction [IRP_MJ_CREATE]     = SpxDispatchOpenClose;
        DriverObject->MajorFunction [IRP_MJ_CLOSE]      = SpxDispatchOpenClose;
        DriverObject->MajorFunction [IRP_MJ_CLEANUP]    = SpxDispatchOpenClose;
        DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL]
                                                        = SpxDispatch;
        DriverObject->MajorFunction [IRP_MJ_INTERNAL_DEVICE_CONTROL]
                                                        = SpxDispatchInternal;
        DriverObject->DriverUnload                      = SpxUnload;

		//	Initialize the provider info
		SpxQueryInitProviderInfo(&SpxDevice->dev_ProviderInfo);
		SpxDevice->dev_CurrentSocket = (USHORT)PARAM(CONFIG_SOCKET_RANGE_START);

		//	We are open now.
		SpxDevice->dev_State		= DEVICE_STATE_OPEN;

		//	Set the window size in statistics
		SpxDevice->dev_Stat.MaximumSendWindow =
		SpxDevice->dev_Stat.AverageSendWindow = PARAM(CONFIG_WINDOW_SIZE) *
												IpxLineInfo.MaximumSendSize;

#if     defined(_PNP_POWER)
        if ( DEVICE_STATE_CLOSED == SpxDevice->dev_State ) {
            SpxDevice->dev_State = DEVICE_STATE_LOADED;
        }
#endif  _PNP_POWER

    } while (FALSE);



    

    DBGPRINT(DEVICE, INFO,
                        ("SpxInitCreateDevice - Create device %ws\n", deviceName.Buffer));

    // Create the device object for the sample transport, allowing
    // room at the end for the device name to be stored (for use
    // in logging errors).
    
    status = IoCreateDevice(
                 DriverObject,
                 0, //DeviceSize,
                 &deviceName,
                 FILE_DEVICE_TRANSPORT,
                 FILE_DEVICE_SECURE_OPEN,
                 FALSE,
                 &SpxDevice->dev_DevObj);

    if (!NT_SUCCESS(status)) {
        DBGPRINT(DEVICE, ERR, ("IoCreateDevice failed\n"));
        
        //
        // We're outta here forever.
        //
        ExFreePool(SpxDevice);
        return status;
    }

    SpxDevice->dev_DevObj->Flags     |= DO_DIRECT_IO;

	if (!NT_SUCCESS(status) )
	{
		//	Delete the device and any associated resources created.
        if( BoundToIpx ) {
		    SpxDerefDevice(SpxDevice);
        }
		SpxDestroyDevice(SpxDevice);
	}

    return (status);
}




VOID
SpxUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine unloads the sample transport driver. The I/O system will not
	call us until nobody above has ST open.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    None. When the function returns, the driver is unloaded.

--*/

{
    UNREFERENCED_PARAMETER (DriverObject);

	//	Stop the timer subsystem
	SpxTimerFlushAndStop();

	CTEFreeMem(SpxDevice->dev_ConfigInfo); 

	RtlFreeUnicodeString (&IpxDeviceName);

	//	Remove creation reference count on the IPX device object.
	SpxDerefDevice(SpxDevice);

	//	Wait on the unload event.
	KeWaitForSingleObject(
		&SpxUnloadEvent,
		Executive,
		KernelMode,
		TRUE,
		(PLARGE_INTEGER)NULL);

	// if the device is in a open state - deregister the device object 
	// with TDI before going away!
	// 
//	if (SpxDevice->dev_State == DEVICE_STATE_OPEN) {
	//	if (STATUS_SUCCESS != TdiDeregisterDeviceObject(SpxDevice->dev_TdiRegistrationHandle )) {
		//	DBGPRINT("Cant deregisterdevice object\n");
		//}
	//}
	
	//	Release the block memory stuff
	SpxDeInitMemorySystem(SpxDevice);
	SpxDestroyDevice(SpxDevice);
    return;
}



NTSTATUS
SpxDispatch(
    IN PDEVICE_OBJECT	DeviceObject,
    IN PIRP 			Irp
    )

/*++

Routine Description:

    This routine is the main dispatch routine for the ST device driver.
    It accepts an I/O Request Packet, performs the request, and then
    returns with the appropriate status.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS 			Status;
    PDEVICE 			Device 	= SpxDevice; // (PDEVICE)DeviceObject;
    PIO_STACK_LOCATION 	IrpSp 	= IoGetCurrentIrpStackLocation(Irp);


    if (Device->dev_State != DEVICE_STATE_OPEN) {
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        return STATUS_INVALID_DEVICE_STATE;
    }

    // Make sure status information is consistent every time.
    IoMarkIrpPending (Irp);
    Irp->IoStatus.Status = STATUS_PENDING;
    Irp->IoStatus.Information = 0;

    // Case on the function that is being performed by the requestor.  If the
    // operation is a valid one for this device, then make it look like it was
    // successfully completed, where possible.
    switch (IrpSp->MajorFunction) {

	case IRP_MJ_DEVICE_CONTROL:

		Status = SpxDeviceControl (DeviceObject, Irp);
		break;

	default:

        Status = STATUS_INVALID_DEVICE_REQUEST;

        //
        // Complete the Irp here instead of below.
        //
        IrpSp->Control &= ~SL_PENDING_RETURNED;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);

    } // major function switch

    /* Commented out and re-located to the default case above.

    if (Status != STATUS_PENDING) {
        IrpSp->Control &= ~SL_PENDING_RETURNED;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
    }
    */

    // Return the immediate status code to the caller.
    return Status;

} // SpxDispatch

VOID
SpxAssignControlChannelId(
    IN  PDEVICE Device,
    IN  PIRP    Request
    )
/*++

Routine Description:

    This routine is required to ensure that the Device lock (to protect the ControlChannelId in the Device)
    is not taken in a pageable routine (SpxDispatchOpenClose).

    NOTE: SPX returns the ControlChannelId in the Request, but never uses it later when it comes down in a
    close/cleanup. The CCID is a ULONG; in future, if we start using this field (as in IPX which uses these Ids
    to determine lineup Irps to complete), then we may run out of numbers (since we monotonically increase the CCID);
    though there is a low chance of that since we will probably run out of memory before that! Anyhow, if that
    happens, one solution (used in IPX) is to make the CCID into a Large Integer and pack the values into the
    REQUEST_OPEN_TYPE(Irp) too.


Arguments:

    Device - Pointer to the device object for this driver.

    Request - Pointer to the request packet representing the I/O request.

Return Value:

    None.

--*/
{
    CTELockHandle 				LockHandle;

    CTEGetLock (&Device->dev_Lock, &LockHandle);

    REQUEST_OPEN_CONTEXT(Request) = UlongToPtr(Device->dev_CcId);
    ++Device->dev_CcId;
    if (Device->dev_CcId == 0) {
        Device->dev_CcId = 1;
    }

    CTEFreeLock (&Device->dev_Lock, LockHandle);
}

NTSTATUS
SpxDispatchOpenClose(
    IN PDEVICE_OBJECT 	DeviceObject,
    IN PIRP 			Irp
    )

/*++

Routine Description:

    This routine is the main dispatch routine for the ST device driver.
    It accepts an I/O Request Packet, performs the request, and then
    returns with the appropriate status.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    PDEVICE 					Device = SpxDevice; // (PDEVICE)DeviceObject;
    NTSTATUS 					Status = STATUS_UNSUCCESSFUL;   	
    BOOLEAN 					found;
    PREQUEST 					Request;
    UINT 						i;
    PFILE_FULL_EA_INFORMATION 	openType;
	CONNECTION_CONTEXT			connCtx;


#if      !defined(_PNP_POWER)
    if (Device->dev_State != DEVICE_STATE_OPEN) {
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        return STATUS_INVALID_DEVICE_STATE;
    }
#endif  !_PNP_POWER

    // Allocate a request to track this IRP.
    Request = SpxAllocateRequest (Device, Irp);
    IF_NOT_ALLOCATED(Request) {
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        return STATUS_INVALID_DEVICE_STATE;
    }


    // Make sure status information is consistent every time.
    MARK_REQUEST_PENDING(Request);
    REQUEST_STATUS(Request) = STATUS_PENDING;
    REQUEST_INFORMATION(Request) = 0;

    // Case on the function that is being performed by the requestor.  If the
    // operation is a valid one for this device, then make it look like it was
    // successfully completed, where possible.
    switch (REQUEST_MAJOR_FUNCTION(Request)) {

    // The Create function opens a transport object (either address or
    // connection).  Access checking is performed on the specified
    // address to ensure security of transport-layer addresses.
    case IRP_MJ_CREATE:

#if     defined(_PNP_POWER)
        if (Device->dev_State != DEVICE_STATE_OPEN) {
            Status = STATUS_INVALID_DEVICE_STATE;
            break;
        }
#endif  _PNP_POWER


        openType = OPEN_REQUEST_EA_INFORMATION(Request);

        if (openType != NULL) {


            found = TRUE;
            //DbgPrint("EA:%d, TdiTransportAddress Length : %d \n", openType->EaNameLength, TDI_TRANSPORT_ADDRESS_LENGTH);

            for (i = 0; i < openType->EaNameLength && i < TDI_TRANSPORT_ADDRESS_LENGTH; i++) {
                if (openType->EaName[i] == TdiTransportAddress[i]) {
                    continue;
                } else {
                    found = FALSE;
                    break;
                }
            }

            if (found) {
                Status = SpxAddrOpen (Device, Request);
                break;
            }

            // Connection?
            found = TRUE;

            for (i=0;i<openType->EaNameLength && i < TDI_CONNECTION_CONTEXT_LENGTH;i++) {
                if (openType->EaName[i] == TdiConnectionContext[i]) {
                     continue;
                } else {
                    found = FALSE;
                    break;
                }
            }

            if (found) {
				if (openType->EaValueLength < sizeof(CONNECTION_CONTEXT))
				{
		
					DBGPRINT(CREATE, ERR,
							("Create: Context size %d\n", openType->EaValueLength));
		
					Status = STATUS_EA_LIST_INCONSISTENT;
					break;
				}
		
				connCtx =
				*((CONNECTION_CONTEXT UNALIGNED *)
					&openType->EaName[openType->EaNameLength+1]);
		
				Status = SpxConnOpen(
							Device,
							connCtx,
							Request);
		
                break;
            }

        } else {

            //
            // Takes a lock in a Pageable routine - call another (non-paged) function to do that.
            //
            if (Device->dev_State != DEVICE_STATE_OPEN) {
                DBGPRINT(TDI, ERR, ("DEVICE NOT OPEN - letting thru control channel only\n"))
            }
            
            SpxAssignControlChannelId(Device, Request);

            REQUEST_OPEN_TYPE(Request) = UlongToPtr(SPX_FILE_TYPE_CONTROL);
            Status = STATUS_SUCCESS;
        }

        break;

    case IRP_MJ_CLOSE:

#if     defined(_PNP_POWER)
        if ((Device->dev_State != DEVICE_STATE_OPEN) && ( Device->dev_State != DEVICE_STATE_LOADED )) {
            Status = STATUS_INVALID_DEVICE_STATE;
            break;
        }
#endif  _PNP_POWER

        // The Close function closes a transport endpoint, terminates
        // all outstanding transport activity on the endpoint, and unbinds
        // the endpoint from its transport address, if any.  If this
        // is the last transport endpoint bound to the address, then
        // the address is removed from the provider.
        switch ((ULONG_PTR)REQUEST_OPEN_TYPE(Request)) {
        case TDI_TRANSPORT_ADDRESS_FILE:

            Status = SpxAddrFileClose(Device, Request);
            break;

		case TDI_CONNECTION_FILE:
            Status = SpxConnClose(Device, Request);
			break;

        case SPX_FILE_TYPE_CONTROL:

			Status = STATUS_SUCCESS;
            break;

        default:
            Status = STATUS_INVALID_HANDLE;
        }

        break;

    case IRP_MJ_CLEANUP:

#if     defined(_PNP_POWER)
        if ((Device->dev_State != DEVICE_STATE_OPEN) && ( Device->dev_State != DEVICE_STATE_LOADED )) {
            Status = STATUS_INVALID_DEVICE_STATE;
            break;
        }
#endif  _PNP_POWER

        // Handle the two stage IRP for a file close operation. When the first
        // stage hits, run down all activity on the object of interest. This
        // do everything to it but remove the creation hold. Then, when the
        // CLOSE irp hits, actually close the object.
        switch ((ULONG_PTR)REQUEST_OPEN_TYPE(Request)) {
        case TDI_TRANSPORT_ADDRESS_FILE:

            Status = SpxAddrFileCleanup(Device, Request);
            break;

		case TDI_CONNECTION_FILE:

            Status = SpxConnCleanup(Device, Request);
            break;

        case SPX_FILE_TYPE_CONTROL:

            Status = STATUS_SUCCESS;
            break;

        default:
            Status = STATUS_INVALID_HANDLE;
        }

        break;

    default:
        Status = STATUS_INVALID_DEVICE_REQUEST;

    } // major function switch

    if (Status != STATUS_PENDING) {
        UNMARK_REQUEST_PENDING(Request);
        REQUEST_STATUS(Request) = Status;
        SpxCompleteRequest (Request);
        SpxFreeRequest (Device, Request);
    }

    // Return the immediate status code to the caller.
    return Status;

} // SpxDispatchOpenClose




NTSTATUS
SpxDeviceControl(
    IN PDEVICE_OBJECT 	DeviceObject,
    IN PIRP 			Irp
    )

/*++

Routine Description:

    This routine dispatches TDI request types to different handlers based
    on the minor IOCTL function code in the IRP's current stack location.
    In addition to cracking the minor function code, this routine also
    reaches into the IRP and passes the packetized parameters stored there
    as parameters to the various TDI request handlers so that they are
    not IRP-dependent.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
	NTSTATUS	Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (Irp);

	// Convert the user call to the proper internal device call.
	Status = TdiMapUserRequest (DeviceObject, Irp, IrpSp);
	if (Status == STATUS_SUCCESS) {

		// If TdiMapUserRequest returns SUCCESS then the IRP
		// has been converted into an IRP_MJ_INTERNAL_DEVICE_CONTROL
		// IRP, so we dispatch it as usual. The IRP will
		// be completed by this call.
		Status = SpxDispatchInternal (DeviceObject, Irp);

        //
        // Return the proper error code here. If SpxDispatchInternal returns an error,
        // then we used to map it to pending below; this is wrong since the client above
        // us could wait for ever since the IO subsystem does not set the event if an
        // error is returned and the Irp is not marked pending.
        //

		// Status = STATUS_PENDING;
	} else {

    	DBGPRINT(TDI, DBG,
		    ("Unknown Tdi code in Irp: %lx\n", Irp));

        //
        // Complete the Irp....
        //
        IrpSp->Control &= ~SL_PENDING_RETURNED;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
    }

    return Status;

} // SpxDeviceControl




NTSTATUS
SpxDispatchInternal (
    IN PDEVICE_OBJECT 	DeviceObject,
    IN PIRP 			Irp
    )

/*++

Routine Description:

    This routine dispatches TDI request types to different handlers based
    on the minor IOCTL function code in the IRP's current stack location.
    In addition to cracking the minor function code, this routine also
    reaches into the IRP and passes the packetized parameters stored there
    as parameters to the various TDI request handlers so that they are
    not IRP-dependent.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    PREQUEST 	Request;
	KIRQL	    oldIrql;
    NTSTATUS 	Status 	= STATUS_INVALID_DEVICE_REQUEST;
    PDEVICE 	Device 	= SpxDevice; // (PDEVICE)DeviceObject;
    BOOLEAN CompleteIrpIfCancel = FALSE; 


    //
    // AFD asks SPX about its provider info before SPX is out of driver entry.
    // We need work around this by letting TDI_QUERY_INFORMATION through. [Shreem]
    //
    if (Device->dev_State != DEVICE_STATE_OPEN) 
	{
        
        if ((TDI_QUERY_INFORMATION == (IoGetCurrentIrpStackLocation(Irp))->MinorFunction) && 
            (TDI_QUERY_PROVIDER_INFO == ((PTDI_REQUEST_KERNEL_QUERY_INFORMATION)REQUEST_PARAMETERS(Irp))->QueryType))
        {
            DBGPRINT(TDI, ERR,
                     ("SpxDispatchIoctl: Letting through since it is a QueryProviderInformation\n"));
            
        } 
        else 
        {

            Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
            IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
            return STATUS_INVALID_DEVICE_STATE;
        }
    }


    // Allocate a request to track this IRP.
    Request = SpxAllocateRequest (Device, Irp);
    IF_NOT_ALLOCATED(Request)
	{
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        return STATUS_INVALID_DEVICE_STATE;
    }


    // Make sure status information is consistent every time.
    MARK_REQUEST_PENDING(Request);
    REQUEST_STATUS(Request) = STATUS_PENDING;
    REQUEST_INFORMATION(Request) = 0;

	//	Cancel irp
	IoAcquireCancelSpinLock(&oldIrql);
    if (!Irp->Cancel)
    {
       IoSetCancelRoutine(Irp, (PDRIVER_CANCEL)SpxTdiCancel);
    } else {
       CompleteIrpIfCancel = TRUE; 
    }
    IoReleaseCancelSpinLock(oldIrql);
	
    if (Irp->Cancel) {
       if (CompleteIrpIfCancel) {
	  // We only want to complete the irp if we didn't register our cancel routine. 
	  // Assume the SpxTdiCancel will complete the irp, we don't want to complete it twice. 
	  Irp->IoStatus.Status = STATUS_CANCELLED;
	  DBGPRINT(TDI, DBG,
		   ("SpxDispatchInternal: Completing IRP with Ipr->Cancel = True\n"));
       
	  IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
       }
       return STATUS_CANCELLED;
    }


    // Branch to the appropriate request handler.  Preliminary checking of
    // the size of the request block is performed here so that it is known
    // in the handlers that the minimum input parameters are readable.  It
    // is *not* determined here whether variable length input fields are
    // passed correctly; this is a check which must be made within each routine.
    switch (REQUEST_MINOR_FUNCTION(Request))
	{
	case TDI_ACCEPT:

		Status = SpxConnAccept(
					Device,
					Request);

		break;

	case TDI_SET_EVENT_HANDLER:

		Status = SpxAddrSetEventHandler(
					Device,
					Request);

		break;

	case TDI_RECEIVE:

		Status = SpxConnRecv(
					Device,
					Request);
		break;


	case TDI_SEND:

		Status = SpxConnSend(
					Device,
					Request);
		break;

	case TDI_ACTION:

		Status = SpxConnAction(
					Device,
					Request);
		break;

	case TDI_ASSOCIATE_ADDRESS:

		Status = SpxConnAssociate(
					Device,
					Request);

		break;

	case TDI_DISASSOCIATE_ADDRESS:

		Status = SpxConnDisAssociate(
					Device,
					Request);

		break;

	case TDI_CONNECT:

		Status = SpxConnConnect(
					Device,
					Request);

		break;

	case TDI_DISCONNECT:

		Status = SpxConnDisconnect(
					Device,
					Request);
		break;

	case TDI_LISTEN:

		Status = SpxConnListen(
					Device,
					Request);
		break;

	case TDI_QUERY_INFORMATION:

		Status = SpxTdiQueryInformation(
					Device,
					Request);

		break;

	case TDI_SET_INFORMATION:

		Status = SpxTdiSetInformation(
					Device,
					Request);

		break;

    // Something we don't know about was submitted.
	default:

        Status = STATUS_INVALID_DEVICE_REQUEST;
		break;
    }

    if (Status != STATUS_PENDING)
	{
        UNMARK_REQUEST_PENDING(Request);
        REQUEST_STATUS(Request) = Status;
    	IoAcquireCancelSpinLock(&oldIrql);
  		IoSetCancelRoutine(Irp, (PDRIVER_CANCEL)NULL);
    	IoReleaseCancelSpinLock(oldIrql);
        SpxCompleteRequest (Request);
        SpxFreeRequest (Device, Request);
    }

    // Return the immediate status code to the caller.
    return Status;

} // SpxDispatchInternal




VOID
SpxTdiCancel(
    IN PDEVICE_OBJECT 	DeviceObject,
    IN PIRP 			Irp
	)
/*++

Routine Description:

	This routine handles cancellation of IO requests

Arguments:


Return Value:
--*/
{
	PREQUEST				Request;
	PSPX_ADDR_FILE			pSpxAddrFile;
	PSPX_ADDR				pSpxAddr;
    PDEVICE 				Device 	= SpxDevice; // (PDEVICE)DeviceObject;
    CTELockHandle           connectIrql;
    CTELockHandle           TempIrql;
    PSPX_CONN_FILE          pSpxConnFile;

    Request = SpxAllocateRequest (Device, Irp);
    IF_NOT_ALLOCATED(Request)
	{
        return;
    }

	DBGPRINT(TDI, ERR,
			("SpxTdiCancel: ------ !!! Cancel irp called %lx.%lx.%lx\n",
				Irp, REQUEST_OPEN_CONTEXT(Request), REQUEST_OPEN_TYPE(Request)));

	switch ((ULONG_PTR)REQUEST_OPEN_TYPE(Request))
	{
    case TDI_CONNECTION_FILE:
        pSpxConnFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(Request);
        CTEGetLock(&pSpxConnFile->scf_Lock, &connectIrql);

        //
        // Swap the irql
        //
        TempIrql = connectIrql;
        connectIrql = Irp->CancelIrql;
        Irp->CancelIrql  = TempIrql;

        IoReleaseCancelSpinLock (Irp->CancelIrql);
        if (!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_STOPPING))
        {
            if (!SPX_CONN_IDLE(pSpxConnFile))
            {
                //
                // This releases the lock
                //
                spxConnAbortiveDisc(
                    pSpxConnFile,
                    STATUS_LOCAL_DISCONNECT,
                    SPX_CALL_TDILEVEL,
                    connectIrql,
                    FALSE);     // [SA] bug #15249
            }
        }

//		SpxConnStop((PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(Request));
		break;

	case TDI_TRANSPORT_ADDRESS_FILE:

        IoReleaseCancelSpinLock (Irp->CancelIrql);
		pSpxAddrFile = (PSPX_ADDR_FILE)REQUEST_OPEN_CONTEXT(Request);
		pSpxAddr = pSpxAddrFile->saf_Addr;
		SpxAddrFileStop(pSpxAddrFile, pSpxAddr);
		break;

	default:

        IoReleaseCancelSpinLock (Irp->CancelIrql);
		break;

	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxmem.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxmem.c

Abstract:

    This module contains code which implements the memory allocation wrappers.

Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993
        Jameel Hyder     (jameelh) Initial Version

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, SpxInitMemorySystem)
#pragma alloc_text( PAGE, SpxDeInitMemorySystem)
#endif

#if !defined SPX_OWN_PACKETS

typedef struct	NdisResEntry {
	struct NdisResEntry	*nre_next;
	NDIS_HANDLE			nre_handle;
	uchar				*nre_buffer;
} NdisResEntry;

NdisResEntry	*SendPacketPoolList = NULL;
SLIST_HEADER    SendPacketList;
NdisResEntry	*RecvPacketPoolList = NULL;
SLIST_HEADER    RecvPacketList;

DEFINE_LOCK_STRUCTURE(SendHeaderLock);
DEFINE_LOCK_STRUCTURE(RecvHeaderLock);

uint  CurrentSendPacketCount = 0;
uint  CurrentRecvPacketCount = 0;
uint  MaxPacketCount = 0x0ffffff;

#define	PACKET_GROW_COUNT		16

#endif // SPX_OWN_PACKETS

//      Define module number for event logging entries
#define FILENUM         SPXMEM

//      Globals for this module
//      Some block sizes (like NDISSEND/NDISRECV are filled in after binding with IPX)
USHORT  spxBlkSize[NUM_BLKIDS] =        // Size of each block
                {
                        sizeof(BLK_HDR)+sizeof(TIMERLIST),                      // BLKID_TIMERLIST
                        0,                                                                                      // BLKID_NDISSEND
                        0                                                                                       // BLKID_NDISRECV
                };

USHORT  spxChunkSize[NUM_BLKIDS] =      // Size of each Chunk
                {
                         512-BC_OVERHEAD,                                                       // BLKID_TIMERLIST
                         512-BC_OVERHEAD,                                                       // BLKID_NDISSEND
                         512-BC_OVERHEAD                                                        // BLKID_NDISRECV
                };


//      Filled in after binding with IPX
//      Reference for below.
//      ( 512-BC_OVERHEAD-sizeof(BLK_CHUNK))/
//              (sizeof(BLK_HDR)+sizeof(TIMERLIST)),    // BLKID_TIMERLIST
USHORT  spxNumBlks[NUM_BLKIDS] =        // Number of blocks per chunk
                {
                        ( 512-BC_OVERHEAD-sizeof(BLK_CHUNK))/
                                (sizeof(BLK_HDR)+sizeof(TIMERLIST)),    // BLKID_TIMERLIST
                        0,                                                                                      // BLKID_NDISSEND
                        0                                                                                       // BLKID_NDISRECV
                };

CTELock                 spxBPLock[NUM_BLKIDS] = { 0 };
PBLK_CHUNK              spxBPHead[NUM_BLKIDS] = { 0 };




NTSTATUS
SpxInitMemorySystem(
        IN      PDEVICE pSpxDevice
        )
/*++

Routine Description:

        !!! MUST BE CALLED AFTER BINDING TO IPX!!!

Arguments:


Return Value:


--*/
{
        LONG            i;
        NDIS_STATUS     ndisStatus;

        //      Try to allocate the ndis buffer pool.
        NdisAllocateBufferPool(
                &ndisStatus,
                &pSpxDevice->dev_NdisBufferPoolHandle,
                20);

        if (ndisStatus != NDIS_STATUS_SUCCESS)
                return(STATUS_INSUFFICIENT_RESOURCES);

        for (i = 0; i < NUM_BLKIDS; i++)
                CTEInitLock (&spxBPLock[i]);

        //      Set the sizes in the block id info arrays.
        for (i = 0; i < NUM_BLKIDS; i++)
        {
                switch (i)
                {
                case BLKID_NDISSEND:

#ifdef SPX_OWN_PACKETS
                        spxBlkSize[i] = sizeof(BLK_HDR)                 +
                                                        sizeof(SPX_SEND_RESD)   +
                                                        NDIS_PACKET_SIZE                +
                                                        IpxMacHdrNeeded                 +
                                                        MIN_IPXSPX2_HDRSIZE;
#else
                        spxBlkSize[i] = sizeof(PNDIS_PACKET);
#endif

            //
            // Round the block size up to the next 8-byte boundary.
            //
            spxBlkSize[i] = QWORDSIZEBLOCK(spxBlkSize[i]);

                        //      Set number blocks
            spxNumBlks[i] = ( 512-BC_OVERHEAD-sizeof(BLK_CHUNK))/spxBlkSize[i];
                        break;

                case BLKID_NDISRECV:

#ifdef SPX_OWN_PACKETS
                        spxBlkSize[i] = sizeof(BLK_HDR)                 +
                                                        sizeof(SPX_RECV_RESD)   +
                                                        NDIS_PACKET_SIZE;
#else
                        spxBlkSize[i] = sizeof(PNDIS_PACKET);
#endif

            //
            // Round the block size up to the next 8-byte boundary.
            //
            spxBlkSize[i] = QWORDSIZEBLOCK(spxBlkSize[i]);

                        //      Set number blocks
            spxNumBlks[i] = ( 512-BC_OVERHEAD-sizeof(BLK_CHUNK))/spxBlkSize[i];
                        break;

                default:

                        break;
                }

        }

        SpxTimerScheduleEvent((TIMER_ROUTINE)spxBPAgePool,
                                                        BLOCK_POOL_TIMER,
                                                        NULL);

	return STATUS_SUCCESS; 
}




VOID
SpxDeInitMemorySystem(
        IN      PDEVICE         pSpxDevice
        )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
        LONG            i, j, NumBlksPerChunk;
        PBLK_CHUNK      pChunk, pFree;

        for (i = 0; i < NUM_BLKIDS; i++)
        {
                NumBlksPerChunk = spxNumBlks[i];
                for (pChunk = spxBPHead[i];
                         pChunk != NULL; )
                {
                        DBGPRINT(RESOURCES, ERR,
                                        ("SpxInitMemorySystem: Freeing %lx\n", pChunk));

                        CTEAssert (pChunk->bc_NumFrees == NumBlksPerChunk);

                        if ((pChunk->bc_BlkId == BLKID_NDISSEND) ||
                                (pChunk->bc_BlkId == BLKID_NDISRECV))
                        {
                                PBLK_HDR        pBlkHdr;

                                // We need to free the Ndis stuff for these guys
                                for (j = 0, pBlkHdr = pChunk->bc_FreeHead;
                                         j < NumBlksPerChunk;
                                         j++, pBlkHdr = pBlkHdr->bh_Next)
                                {
                                        PNDIS_PACKET    pNdisPkt;
                                        PNDIS_BUFFER    pNdisBuffer;

#ifdef SPX_OWN_PACKETS
                                        // Only need to free the ndis buffer.
                                        pNdisPkt        = (PNDIS_PACKET)((PBYTE)pBlkHdr + sizeof(BLK_HDR));

                                        if (pChunk->bc_BlkId == BLKID_NDISSEND)
                                        {
                                                NdisUnchainBufferAtFront(pNdisPkt, &pNdisBuffer);
                                                if (pNdisBuffer == NULL)
                                                {
                                                        //      Something is terribly awry.
                                                        KeBugCheck(0);
                                                }

                                                NdisFreeBuffer(pNdisBuffer);

                                                //
                                                // Free the second MDL also
                                                //
                                                NdisUnchainBufferAtFront(pNdisPkt, &pNdisBuffer);
                                                if (pNdisBuffer == NULL)
                                                {
                                                        //      Something is terribly awry.
                                                        KeBugCheck(0);
                                                }

                                                NdisFreeBuffer(pNdisBuffer);
                                        }
#else
                    /*                    //      Need to free both the packet and the buffer.
                                        pNdisPkt       = (PNDIS_PACKET *)((PBYTE)pBlkHdr + sizeof(BLK_HDR));

                                        if (pChunk->bc_BlkId == BLKID_NDISSEND)
                                        {

                                                NdisUnchainBufferAtFront(*pNdisPkt, &pNdisBuffer);
                                                if (pNdisBuffer == NULL)
                                                {
                                                        //      Something is terribly awry.
                                                        KeBugCheck(0);
                                                }

                                                NdisFreeBuffer(pNdisBuffer);
                                        }
                                        NdisFreePacket(*pNdisPkt);
                                        */
#endif
                                }
                        }
                        pFree = pChunk;
                        pChunk = pChunk->bc_Next;

#ifndef SPX_OWN_PACKETS
/*
                        //      Free the ndis packet pool in chunk
                        NdisFreePacketPool((NDIS_HANDLE)pFree->bc_ChunkCtx); */
#endif
                        SpxFreeMemory(pFree);
                }
        }

        //      Free up the ndis buffer pool
        NdisFreeBufferPool(
                pSpxDevice->dev_NdisBufferPoolHandle);

        return;
}




PVOID
SpxAllocMem(
#ifdef  TRACK_MEMORY_USAGE
        IN      ULONG   Size,
        IN      ULONG   FileLine
#else
        IN      ULONG   Size
#endif  // TRACK_MEMORY_USAGE
        )
/*++

Routine Description:

        Allocate a block of non-paged memory. This is just a wrapper over ExAllocPool.
        Allocation failures are error-logged. We always allocate a ULONG more than
        the specified size to accomodate the size. This is used by SpxFreeMemory
        to update the statistics.

Arguments:


Return Value:


--*/
{
        PBYTE   pBuf;
        BOOLEAN zeroed;

        //      round up the size so that we can put a signature at the end
        //      that is on a LARGE_INTEGER boundary
        zeroed = ((Size & ZEROED_MEMORY_TAG) == ZEROED_MEMORY_TAG);

        Size = QWORDSIZEBLOCK(Size & ~ZEROED_MEMORY_TAG);

        // Do the actual memory allocation. Allocate eight extra bytes so
        // that we can store the size of the allocation for the free routine
    // and still keep the buffer quadword aligned.

        if ((pBuf = ExAllocatePoolWithTag(NonPagedPool, Size + sizeof(LARGE_INTEGER)
#if DBG
                                                                                                        + sizeof(ULONG)
#endif
                ,SPX_TAG)) == NULL)
        {
                DBGPRINT(RESOURCES, FATAL,
                                ("SpxAllocMemory: failed - size %lx\n", Size));

                TMPLOGERR();
                return NULL;
        }

        // Save the size of this block in the four extra bytes we allocated.
        *((PULONG)pBuf) = (Size + sizeof(LARGE_INTEGER));

        // Return a pointer to the memory after the size longword.
        pBuf += sizeof(LARGE_INTEGER);

#if DBG
        *((PULONG)(pBuf+Size)) = SPX_MEMORY_SIGNATURE;
        DBGPRINT(RESOURCES, INFO,
                        ("SpxAllocMemory: %p Allocated %lx bytes @%p\n",
                        _ReturnAddress(), Size, pBuf));
#endif

        SpxTrackMemoryUsage((PVOID)(pBuf - sizeof(LARGE_INTEGER)), TRUE, FileLine);

        if (zeroed)
                RtlZeroMemory(pBuf, Size);

        return (pBuf);
}




VOID
SpxFreeMemory(
        IN      PVOID   pBuf
        )
/*++

Routine Description:

        Free the block of memory allocated via SpxAllocMemory. This is
        a wrapper around ExFreePool.

Arguments:


Return Value:


--*/
{
        PULONG  pRealBuffer;

        // Get a pointer to the block allocated by ExAllocatePool --
    // we allocate a LARGE_INTEGER at the front.
        pRealBuffer = ((PULONG)pBuf - 2);

        SpxTrackMemoryUsage(pRealBuffer, FALSE, 0);

#if     DBG
        // Check the signature at the end
        if (*(PULONG)((PCHAR)pRealBuffer + *(PULONG)pRealBuffer)
                                                                                        != SPX_MEMORY_SIGNATURE)
        {
                DBGPRINT(RESOURCES, FATAL,
                                ("SpxFreeMemory: Memory overrun on block %lx\n", pRealBuffer));

                DBGBRK(FATAL);
        }

        *(PULONG)((PCHAR)pRealBuffer + *(PULONG)pRealBuffer) = 0;
#endif

#if     DBG
        *pRealBuffer = 0;
#endif

        // Free the pool and return.
        ExFreePool(pRealBuffer);
}




#ifdef  TRACK_MEMORY_USAGE

#define MAX_PTR_COUNT           4*1024
#define MAX_MEM_USERS           512
CTELock                         spxMemTrackLock = {0};
CTELockHandle           lockHandle              = {0};
struct
{
        PVOID   mem_Ptr;
        ULONG   mem_FileLine;
} spxMemPtrs[MAX_PTR_COUNT]     = {0};

struct
{
        ULONG   mem_FL;
        ULONG   mem_Count;
} spxMemUsage[MAX_MEM_USERS]    = {0};

VOID
SpxTrackMemoryUsage(
        IN      PVOID   pMem,
        IN      BOOLEAN Alloc,
        IN      ULONG   FileLine
        )
/*++

Routine Description:

        Keep track of memory usage by storing and clearing away pointers as and
        when they are allocated or freed. This helps in keeping track of memory
        leaks.

Arguments:


Return Value:


--*/
{
        static int              i = 0;
        int                             j, k;

    CTEGetLock (&spxMemTrackLock, &lockHandle);

        if (Alloc)
        {
                for (j = 0; j < MAX_PTR_COUNT; i++, j++)
                {
                        i = i & (MAX_PTR_COUNT-1);
                        if (spxMemPtrs[i].mem_Ptr == NULL)
                        {
                                spxMemPtrs[i].mem_Ptr = pMem;
                                spxMemPtrs[i++].mem_FileLine = FileLine;
                                break;
                        }
                }

                for (k = 0; k < MAX_MEM_USERS; k++)
                {
                        if (spxMemUsage[k].mem_FL == FileLine)
                        {
                                spxMemUsage[k].mem_Count ++;
                                break;
                        }
                }
                if (k == MAX_MEM_USERS)
                {
                        for (k = 0; k < MAX_MEM_USERS; k++)
                        {
                                if (spxMemUsage[k].mem_FL == 0)
                                {
                                        spxMemUsage[k].mem_FL = FileLine;
                                        spxMemUsage[k].mem_Count = 1;
                                        break;
                                }
                        }
                }
                if (k == MAX_MEM_USERS)
                {
                        DBGPRINT(RESOURCES, ERR,
                                ("SpxTrackMemoryUsage: Out of space on spxMemUsage !!!\n"));

                        DBGBRK(FATAL);
                }
        }
        else
        {
                for (j = 0, k = i; j < MAX_PTR_COUNT; j++, k--)
                {
                        k = k & (MAX_PTR_COUNT-1);
                        if (spxMemPtrs[k].mem_Ptr == pMem)
                        {
                                spxMemPtrs[k].mem_Ptr = 0;
                                spxMemPtrs[k].mem_FileLine = 0;
                                break;
                        }
                }
        }

    CTEFreeLock (&spxMemTrackLock, lockHandle);

        if (j == MAX_PTR_COUNT)
        {
                DBGPRINT(RESOURCES, ERR,
                        ("SpxTrackMemoryUsage: %s\n", Alloc ? "Table Full" : "Can't find"));

                DBGBRK(FATAL);
        }
}

#endif  // TRACK_MEMORY_USAGE


PVOID
SpxBPAllocBlock(
        IN      BLKID   BlockId
        )
/*++

Routine Description:

        Alloc a block of memory from the block pool package. This is written to speed up
        operations where a lot of small fixed size allocations/frees happen. Going to
        ExAllocPool() in these cases is expensive.

Arguments:


Return Value:


--*/
{
        PBLK_HDR                        pBlk = NULL;
        PBLK_CHUNK                      pChunk, *ppChunkHead;
        USHORT                          BlkSize;
        CTELockHandle           lockHandle;
        PSPX_SEND_RESD          pSendResd;
        PSPX_RECV_RESD          pRecvResd;
        PNDIS_PACKET            pNdisPkt;
        PNDIS_BUFFER            pNdisBuffer;
        PNDIS_BUFFER            pNdisIpxSpxBuffer;


        CTEAssert (BlockId < NUM_BLKIDS);

        if (BlockId < NUM_BLKIDS)
        {
                BlkSize = spxBlkSize[BlockId];
                ppChunkHead = &spxBPHead[BlockId];

                CTEGetLock(&spxBPLock[BlockId], &lockHandle);

                for (pChunk = *ppChunkHead;
                         pChunk != NULL;
                         pChunk = pChunk->bc_Next)
                {
                        CTEAssert(pChunk->bc_BlkId == BlockId);
                        if (pChunk->bc_NumFrees > 0)
                        {
                                DBGPRINT(SYSTEM, INFO,
                                                ("SpxBPAllocBlock: Found space in Chunk %lx\n", pChunk));
#ifdef  PROFILING
                                InterlockedIncrement( &SpxStatistics.stat_NumBPHits);
#endif
                                break;
                        }
                }

                if (pChunk == NULL)
                {
                        DBGPRINT(SYSTEM, INFO,
                                        ("SpxBPAllocBlock: Allocating a new chunk for Id %d\n", BlockId));

#ifdef  PROFILING
                        InterlockedIncrement( &SpxStatistics.stat_NumBPMisses);
#endif
                        pChunk = SpxAllocateMemory(spxChunkSize[BlockId]);
                        if (pChunk != NULL)
                        {
                                LONG            i, j;
                                PBLK_HDR        pBlkHdr;
                                USHORT          NumBlksPerChunk;

                                NumBlksPerChunk = spxNumBlks[BlockId];
                                pChunk->bc_NumFrees = NumBlksPerChunk;
                pChunk->bc_BlkId = BlockId;
                                pChunk->bc_FreeHead = (PBLK_HDR)((PBYTE)pChunk + sizeof(BLK_CHUNK));

                                DBGPRINT(SYSTEM, INFO,
                                                ("SpxBPAllocBlock: Initializing chunk %lx\n", pChunk));

                                // Initialize the blocks in the chunk
                                for (i = 0, pBlkHdr = pChunk->bc_FreeHead;
                                         i < NumBlksPerChunk;
                                         i++, pBlkHdr = pBlkHdr->bh_Next)
                                {
                                        NDIS_STATUS     ndisStatus;

                                        pBlkHdr->bh_Next = (PBLK_HDR)((PBYTE)pBlkHdr + BlkSize);
                                        if (BlockId == BLKID_NDISSEND)
                                        {
                                                PBYTE                   pHdrMem;

#ifdef SPX_OWN_PACKETS
                                                // Point to the ndis packet,initialize it.
                                                pNdisPkt        = (PNDIS_PACKET)((PBYTE)pBlkHdr + sizeof(BLK_HDR));
                                                NdisReinitializePacket(pNdisPkt);

                                                // Allocate a ndis buffer descriptor describing hdr memory
                                                // and queue it in.
                                                pHdrMem         =       (PBYTE)pNdisPkt         +
                                                                                NDIS_PACKET_SIZE        +
                                                                                sizeof(SPX_SEND_RESD);

                                                NdisAllocateBuffer(
                                                        &ndisStatus,
                                                        &pNdisBuffer,
                                                        SpxDevice->dev_NdisBufferPoolHandle,
                                                        pHdrMem,
                                                        IpxMacHdrNeeded);

                                                if (ndisStatus != NDIS_STATUS_SUCCESS)
                                                {
                                                        break;
                                                }

                                                //  Link the buffer descriptor into the packet descriptor
                                                NdisChainBufferAtBack(
                                                        pNdisPkt,
                                                        pNdisBuffer);


                                                NdisAllocateBuffer(
                                                        &ndisStatus,
                                                        &pNdisIpxSpxBuffer,
                                                        SpxDevice->dev_NdisBufferPoolHandle,
                                                        pHdrMem + IpxMacHdrNeeded,
                                                        MIN_IPXSPX2_HDRSIZE);

                                                if (ndisStatus != NDIS_STATUS_SUCCESS)
                                                {
                                                        break;
                                                }

                                                //  Link the buffer descriptor into the packet descriptor
                                                NdisChainBufferAtBack(
                                                        pNdisPkt,
                                                        pNdisIpxSpxBuffer);



                                                pSendResd = (PSPX_SEND_RESD)pNdisPkt->ProtocolReserved;

//#else
                                                // Allocate a ndis packet pool for this chunk
//                                                NdisAllocatePacketPool();
//                                                etc.



                                                //      Initialize elements of the protocol reserved structure.
                                                pSendResd->sr_Id        = IDENTIFIER_SPX;
                                                pSendResd->sr_Reserved1 = NULL;
                                                pSendResd->sr_Reserved2 = NULL;
                                                pSendResd->sr_State     = SPX_SENDPKT_IDLE;
#endif
                                        }
                                        else if (BlockId == BLKID_NDISRECV)
                                        {
#ifdef SPX_OWN_PACKETS
                                                // Point to the ndis packet,initialize it.
                                                pNdisPkt        = (PNDIS_PACKET)((PBYTE)pBlkHdr + sizeof(BLK_HDR));
                                                NdisReinitializePacket(pNdisPkt);

                                                pRecvResd = (PSPX_RECV_RESD)pNdisPkt->ProtocolReserved;

//#else
                                                // Allocate a ndis packet pool for this chunk
  //                                              NdisAllocatePacketPool();
  //                                              etc.


                                                //      Initialize elements of the protocol reserved structure.
                                                pRecvResd->rr_Id        = IDENTIFIER_SPX;
                                                pRecvResd->rr_State     = SPX_RECVPKT_IDLE;
#endif
                                        }
                                }

                                if (i != NumBlksPerChunk)
                                {
                                        // This has to be a failure from Ndis for send blocks!!!
                                        // Undo a bunch of stuff
                                        CTEAssert (BlockId == BLKID_NDISSEND);
                                        pBlkHdr = pChunk->bc_FreeHead;
                                        for (j = 0, pBlkHdr = pChunk->bc_FreeHead;
                                                 j < i; j++, pBlkHdr = pBlkHdr->bh_Next)
                                        {
                                                NdisUnchainBufferAtFront(
                                                        (PNDIS_PACKET)((PBYTE)pBlkHdr + sizeof(BLK_HDR)),
                                                        &pNdisBuffer);

                                                CTEAssert(pNdisBuffer != NULL);
                                                NdisFreeBuffer(pNdisBuffer);

                                                NdisUnchainBufferAtFront(
                                                        (PNDIS_PACKET)((PBYTE)pBlkHdr + sizeof(BLK_HDR)),
                                                        &pNdisIpxSpxBuffer);

                                                if (pNdisIpxSpxBuffer)
                                                {
                                                  NdisFreeBuffer(pNdisIpxSpxBuffer);
                                                }
                                        }

                                        SpxFreeMemory(pChunk);
                                        pChunk = NULL;
                                }
                                else
                                {
                                        // Successfully initialized the chunk, link it in
                                        pChunk->bc_Next = *ppChunkHead;
                                        *ppChunkHead = pChunk;
                                }
                        }
                }

                if (pChunk != NULL)
                {
                        CTEAssert(pChunk->bc_BlkId == BlockId);
                        DBGPRINT(RESOURCES, INFO,
                                        ("SpxBPAllocBlock: Allocating a block out of chunk %lx(%d) for Id %d\n",
                                                pChunk, pChunk->bc_NumFrees, BlockId));

                        pChunk->bc_NumFrees --;
                        pChunk->bc_Age = 0;                     // Reset age
                        pBlk = pChunk->bc_FreeHead;
                        pChunk->bc_FreeHead = pBlk->bh_Next;
                        pBlk->bh_pChunk = pChunk;

                        //      Skip the block header!
                        pBlk++;
                }

                CTEFreeLock(&spxBPLock[BlockId], lockHandle);
        }

        return pBlk;
}



VOID
SpxBPFreeBlock(
        IN      PVOID           pBlock,
        IN      BLKID           BlockId
        )
/*++

Routine Description:

        Return a block to its owning chunk.

Arguments:


Return Value:


--*/
{
        PBLK_CHUNK              pChunk;
        PBLK_HDR                pBlkHdr = (PBLK_HDR)((PCHAR)pBlock - sizeof(BLK_HDR));
        CTELockHandle   lockHandle;

        CTEGetLock(&spxBPLock[BlockId], &lockHandle);

        for (pChunk = spxBPHead[BlockId];
                 pChunk != NULL;
                 pChunk = pChunk->bc_Next)
        {
                CTEAssert(pChunk->bc_BlkId == BlockId);
                if (pBlkHdr->bh_pChunk == pChunk)
                {
                        DBGPRINT(SYSTEM, INFO,
                                        ("SpxBPFreeBlock: Returning Block %lx to chunk %lx for Id %d\n",
                                        pBlkHdr, pChunk, BlockId));

                        CTEAssert (pChunk->bc_NumFrees < spxNumBlks[BlockId]);
                        pChunk->bc_NumFrees ++;
                        pBlkHdr->bh_Next = pChunk->bc_FreeHead;
                        pChunk->bc_FreeHead = pBlkHdr;
                        break;
                }
        }
        CTEAssert ((pChunk != NULL) && (pChunk->bc_FreeHead == pBlkHdr));

        CTEFreeLock(&spxBPLock[BlockId], lockHandle);
        return;
}




ULONG
spxBPAgePool(
        IN PVOID        Context,
        IN BOOLEAN      TimerShuttingDown
        )
/*++

Routine Description:

        Age out the block pool of unused blocks

Arguments:


Return Value:


--*/
{
        PBLK_CHUNK              pChunk, *ppChunk, pFree = NULL;
        LONG                    i, j, NumBlksPerChunk;
        CTELockHandle   lockHandle;
        PNDIS_PACKET    pNdisPkt;
        PNDIS_BUFFER    pNdisBuffer;

        if (TimerShuttingDown)
        {
                return TIMER_DONT_REQUEUE;
        }

        for (i = 0; i < NUM_BLKIDS; i++)
        {
            NumBlksPerChunk = spxNumBlks[i];
                CTEGetLock(&spxBPLock[i], &lockHandle);

                for (ppChunk = &spxBPHead[i];
                         (pChunk = *ppChunk) != NULL; )
                {
                        if ((pChunk->bc_NumFrees == NumBlksPerChunk) &&
                                (++(pChunk->bc_Age) >= MAX_BLOCK_POOL_AGE))
                        {
                                DBGPRINT(SYSTEM, INFO,
                                                ("spxBPAgePool: freeing Chunk %lx, Id %d\n",
                                                pChunk, pChunk->bc_BlkId));

                                *ppChunk = pChunk->bc_Next;
#ifdef  PROFILING
                                InterlockedIncrement( &SpxStatistics.stat_NumBPAge);
#endif
                                if (pChunk->bc_BlkId == BLKID_NDISSEND)
                                {
                                        PBLK_HDR        pBlkHdr;

                                        // We need to free Ndis stuff for these guys
                                        pBlkHdr = pChunk->bc_FreeHead;

                                        for (j = 0, pBlkHdr = pChunk->bc_FreeHead;
                                                 j < NumBlksPerChunk;
                                                 j++, pBlkHdr = pBlkHdr->bh_Next)
                                        {

                                                pNdisPkt = (PNDIS_PACKET)((PBYTE)pBlkHdr + sizeof(BLK_HDR));

                                                NdisUnchainBufferAtFront(
                                                        pNdisPkt,
                                                        &pNdisBuffer);

                                                NdisFreeBuffer(pNdisBuffer);

                                                NdisUnchainBufferAtFront(
                                                        pNdisPkt,
                                                        &pNdisBuffer);

                                                NdisFreeBuffer(pNdisBuffer);

                                        }
                                }

                                SpxFreeMemory(pChunk);
                        }
                        else
                        {
                                ppChunk = &pChunk->bc_Next;
                        }
                }
                CTEFreeLock(&spxBPLock[i], lockHandle);
        }

        return TIMER_REQUEUE_CUR_VALUE;
}

#if !defined SPX_OWN_PACKETS
//
// GrowSPXSendPacketsList
// Called when we dont have any free packets in the SendPacketsList.
//
// Allocate a packet pool, allocate all the packets for that pool and
// store these on a list.
//
// Returns: Pointer to newly allocated packet, or NULL if this faild.
//
PNDIS_PACKET
GrowSPXSendPacketList(void)
{
	NdisResEntry		*NewEntry;
	NDIS_STATUS			Status;
	PNDIS_PACKET		Packet, ReturnPacket;
	uint				i;
	CTELockHandle		Handle;
	
	CTEGetLock(&SendHeaderLock, &Handle);
	
	if (CurrentSendPacketCount >= MaxPacketCount)
		goto failure;
		
	// First, allocate a tracking structure.
	NewEntry = CTEAllocMem(sizeof(NdisResEntry));
	if (NewEntry == NULL)
		goto failure;
		
    NewEntry->nre_handle = (void *) NDIS_PACKET_POOL_TAG_FOR_NWLNKSPX;

	// Got a tracking structure. Now allocate a packet pool.
	NdisAllocatePacketPoolEx(
                             &Status,
                             &NewEntry->nre_handle,
                             PACKET_GROW_COUNT,
                             0,
                             sizeof(SPX_SEND_RESD)
                             );
	
	if (Status != NDIS_STATUS_SUCCESS) {
		CTEFreeMem(NewEntry);
		goto failure;
	}
	
    NdisSetPacketPoolProtocolId(NewEntry->nre_handle,NDIS_PROTOCOL_ID_IPX);

	// We've allocated the pool. Now initialize the packets, and link them
	// on the free list.
	ReturnPacket = NULL;
	
	// Link the new NDIS resource tracker entry onto the list.
	NewEntry->nre_next = SendPacketPoolList;
	SendPacketPoolList = NewEntry;
	CurrentSendPacketCount += PACKET_GROW_COUNT;
	CTEFreeLock(&SendHeaderLock, Handle);
	
	for (i = 0; i < PACKET_GROW_COUNT; i++) {
		SPX_SEND_RESD   *SendReserved;
		
		NdisAllocatePacket(&Status, &Packet, NewEntry->nre_handle);
		if (Status != NDIS_STATUS_SUCCESS) {
			CTEAssert(FALSE);
			break;
		}
		
		CTEMemSet(Packet->ProtocolReserved, 0, sizeof(SPX_SEND_RESD));
		SendReserved = (SPX_SEND_RESD *)Packet->ProtocolReserved;
		// store whatever's required in the reserved section.

        if (i != 0) {
			(void)SpxFreeSendPacket(SpxDevice, Packet);
		} else
			ReturnPacket = Packet;

	}
	
	// We've put all but the first one on the list. Return the first one.
	return ReturnPacket;

failure:
	CTEFreeLock(&SendHeaderLock, Handle);
	return NULL;
		
}

//
// GrowSPXRecvPacketsList
// Called when we dont have any free packets in the RecvPacketsList.
//
// Allocate a packet pool, allocate all the packets for that pool and
// store these on a list.
//
// Returns: Pointer to newly allocated packet, or NULL if this faild.
//
PNDIS_PACKET
GrowSPXRecvPacketList(void)
{
	NdisResEntry		*NewEntry;
	NDIS_STATUS			Status;
	PNDIS_PACKET		Packet, ReturnPacket;
	uint				i;
	CTELockHandle		Handle;
	
	CTEGetLock(&RecvHeaderLock, &Handle);
	
	if (CurrentRecvPacketCount >= MaxPacketCount)
		goto failure;
		
	// First, allocate a tracking structure.
	NewEntry = CTEAllocMem(sizeof(NdisResEntry));
	if (NewEntry == NULL)
		goto failure;
		
    NewEntry->nre_handle = (void *) NDIS_PACKET_POOL_TAG_FOR_NWLNKSPX;

	// Got a tracking structure. Now allocate a packet pool.
	NdisAllocatePacketPoolEx(
                             &Status,
                             &NewEntry->nre_handle,
                             PACKET_GROW_COUNT,
                             0,
                             sizeof(SPX_RECV_RESD)
                             );
	
	if (Status != NDIS_STATUS_SUCCESS) {
		CTEFreeMem(NewEntry);
		goto failure;
	}
	
    NdisSetPacketPoolProtocolId(NewEntry->nre_handle,NDIS_PROTOCOL_ID_IPX);

	// We've allocated the pool. Now initialize the packets, and link them
	// on the free list.
	ReturnPacket = NULL;
	
	// Link the new NDIS resource tracker entry onto the list.
	NewEntry->nre_next = RecvPacketPoolList;
	RecvPacketPoolList = NewEntry;
	CurrentRecvPacketCount += PACKET_GROW_COUNT;
	CTEFreeLock(&RecvHeaderLock, Handle);
	
	for (i = 0; i < PACKET_GROW_COUNT; i++) {
		SPX_RECV_RESD   *RecvReserved;
		
		NdisAllocatePacket(&Status, &Packet, NewEntry->nre_handle);
		if (Status != NDIS_STATUS_SUCCESS) {
			CTEAssert(FALSE);
			break;
		}
		
		CTEMemSet(Packet->ProtocolReserved, 0, sizeof(SPX_RECV_RESD));
		RecvReserved = (SPX_RECV_RESD *)Packet->ProtocolReserved;
		// store whatever's required in the reserved section.

        if (i != 0) {
			(void)SpxFreeRecvPacket(SpxDevice, Packet);
		} else
			ReturnPacket = Packet;

	}
	
	// We've put all but the first one on the list. Return the first one.
	return ReturnPacket;

failure:
	CTEFreeLock(&RecvHeaderLock, Handle);
	return NULL;
		
}

PNDIS_PACKET
SpxAllocSendPacket(
                   IN  PDEVICE      _Device,
                   OUT NDIS_PACKET  **_SendPacket,
                   OUT NDIS_STATUS  *_Status)					

{
        PSLIST_ENTRY        Link;
        SPX_SEND_RESD       *Common, *pSendResd;
        PNDIS_BUFFER        pNdisIpxMacBuffer, pNdisIpxSpxBuffer;
        NDIS_STATUS         ndisStatus;
        PUCHAR              pHdrMem = NULL;

        Link = ExInterlockedPopEntrySList(&SendPacketList, &SendHeaderLock);			

        if (Link != NULL) {

           Common = STRUCT_OF(SPX_SEND_RESD, Link, Linkage);
           (*_SendPacket) = STRUCT_OF(NDIS_PACKET, Common, ProtocolReserved);

           (*_Status) = NDIS_STATUS_SUCCESS;

        } else {

           (*_SendPacket) = GrowSPXSendPacketList();
           (*_Status)     =  NDIS_STATUS_SUCCESS;

           if (NULL == *_SendPacket) {
              DBGPRINT(NDIS, DBG, ("Couldn't grow packets allocated...\r\n"));
              (*_Status)     =  NDIS_STATUS_RESOURCES;
              return NULL;
           }
        }

        //
        //  Now add the NdisBuffers to the packet.
        //  1. IPX MAC HDR
        //  2. IPX/SPX Hdr
        //  3. Chain these
        //

        if (NDIS_STATUS_SUCCESS == (*_Status)) {

           //
           // First allocate the memory
           //
           pHdrMem = SpxAllocateMemory(IpxMacHdrNeeded + MIN_IPXSPX2_HDRSIZE);

           if (NULL == pHdrMem) {
              DBGPRINT(NDIS, DBG, ("Cannot allocate non paged pool for sendpacket\n"));
              (*_Status) = NDIS_STATUS_RESOURCES;
              goto failure;
           }

           NdisAllocateBuffer(
                   &ndisStatus,
                   &pNdisIpxMacBuffer,
                   SpxDevice->dev_NdisBufferPoolHandle,
                   pHdrMem,
                   IpxMacHdrNeeded);

           if (ndisStatus != NDIS_STATUS_SUCCESS)
           {

               if (NULL != pHdrMem) {
                   SpxFreeMemory(pHdrMem);
                   pHdrMem = NULL;
               }

               DBGPRINT(NDIS, DBG, ("NdisallocateBuffer failed\r\n", ndisStatus));
               goto failure;
           }

           //  Link the buffer descriptor into the packet descriptor
           NdisChainBufferAtBack(
                   (*_SendPacket),
                   pNdisIpxMacBuffer);


           NdisAllocateBuffer(
                   &ndisStatus,
                   &pNdisIpxSpxBuffer,
                   SpxDevice->dev_NdisBufferPoolHandle,
                   pHdrMem + IpxMacHdrNeeded,
                   MIN_IPXSPX2_HDRSIZE);

           if (ndisStatus != NDIS_STATUS_SUCCESS)
           {
              DBGPRINT(NDIS, DBG, ("NdisallocateBuffer failed\r\n", ndisStatus));
              goto failure;
           }

           //  Link the buffer descriptor into the packet descriptor
           NdisChainBufferAtBack(
                   (*_SendPacket),
                   pNdisIpxSpxBuffer);

           pSendResd = (PSPX_SEND_RESD)(*_SendPacket)->ProtocolReserved;

           //  Initialize elements of the protocol reserved structure.
           pSendResd->sr_Id        = IDENTIFIER_SPX;
           pSendResd->sr_Reserved1 = NULL;
           pSendResd->sr_Reserved2 = NULL;
           pSendResd->sr_State     = SPX_SENDPKT_IDLE;

           return (*_SendPacket);
        }

failure:

   SpxFreeSendPacket(SpxDevice, (*_SendPacket));
   (*_Status) = NDIS_STATUS_RESOURCES;
   return NULL;

}

PNDIS_PACKET
SpxAllocRecvPacket(
                   IN  PDEVICE      _Device,
                   OUT NDIS_PACKET  **_RecvPacket,
                   OUT NDIS_STATUS  *_Status)
{

        PSLIST_ENTRY        Link;
        SPX_RECV_RESD       *Common, *pRecvResd;

        Link = ExInterlockedPopEntrySList(
                     &RecvPacketList,
                     &RecvHeaderLock
                     );											

        if (Link != NULL) {
           Common = STRUCT_OF(SPX_RECV_RESD, Link, Linkage);
           //PC = STRUCT_OF(PacketContext, Common, pc_common);
           (*_RecvPacket) = STRUCT_OF(NDIS_PACKET, Common, ProtocolReserved);

           (*_Status) = NDIS_STATUS_SUCCESS;
        } else {

           (*_RecvPacket) = GrowSPXRecvPacketList();
               (*_Status)     =  NDIS_STATUS_SUCCESS;
           if (NULL == *_RecvPacket) {
              DBGPRINT(NDIS, DBG, ("Couldn't grow packets allocated...\r\n"));
              (*_Status)     =  NDIS_STATUS_RESOURCES;
           }
        }

        if ((*_Status) == NDIS_STATUS_SUCCESS) {

           pRecvResd = (PSPX_RECV_RESD)(*_RecvPacket)->ProtocolReserved;
           //  Initialize elements of the protocol reserved structure.
           pRecvResd->rr_Id        = IDENTIFIER_SPX;
           pRecvResd->rr_State     = SPX_RECVPKT_IDLE;

        }

        return (*_RecvPacket);
}

//* SpxFreeSendPacket - Free an SPX packet when we're done with it.
//
//  Called when a send completes and a packet needs to be freed. We look at the
//  packet, decide what to do with it, and free the appropriate components.
//
//  Entry:  Packet  - Packet to be freed.
//
//
void
SpxFreeSendPacket(PDEVICE        _Device,
                  PNDIS_PACKET   _Packet)
{

    PNDIS_BUFFER    NextBuffer, Buffer;
    SPX_SEND_RESD   *Context = (SPX_SEND_RESD *)_Packet->ProtocolReserved;
    PVOID           Header = NULL;
    ULONG           Length = 0;

    DBGPRINT(NDIS, DBG,
     ("SpxFreeSendPacket\n"));

    NdisQueryPacket(_Packet, NULL, NULL, &Buffer, NULL);

    if (NULL != Buffer) {
       NdisQueryBuffer(Buffer, &Header, &Length);
       //KdPrint(("Pointer = %x Length = %x", Header, Length));

       if (Header != NULL && Length > 0) {
          //KdPrint(("Freed buffer"));
          SpxFreeMemory(Header);
       }
    }

    while (Buffer != (PNDIS_BUFFER)NULL) {
        NdisGetNextBuffer(Buffer, &NextBuffer);
        NdisFreeBuffer(Buffer);
        Buffer = NextBuffer;
    }

    NdisReinitializePacket(_Packet);

    ExInterlockedPushEntrySList(
                                &SendPacketList,
                                STRUCT_OF(SLIST_ENTRY, &(Context->Linkage), Next),
                                &SendHeaderLock
                                );

    return;
}


//* SpxFreeRecvPacket - Free an SPX packet when we're done with it.
//
//  Called when a recv completes and a packet needs to be freed. We look at the
//  packet, decide what to do with it, and free the appropriate components.
//
//  Entry:  Packet  - Packet to be freed.
//
//

void
SpxFreeRecvPacket(PDEVICE        _Device,
                  PNDIS_PACKET   _Packet)
{ 																		
    PNDIS_BUFFER    NextBuffer, Buffer;
    SPX_RECV_RESD *Context = (SPX_RECV_RESD *)_Packet->ProtocolReserved;

    DBGPRINT(NDIS, DBG,
            ("SpxFreeRecvPacket\n"));

    NdisQueryPacket(_Packet, NULL, NULL, &Buffer, NULL);

    while (Buffer != (PNDIS_BUFFER)NULL) {
        NdisGetNextBuffer(Buffer, &NextBuffer);
        NdisFreeBuffer(Buffer);
        Buffer = NextBuffer;
    }

    NdisReinitializePacket(_Packet);

    ExInterlockedPushEntrySList(
                                &RecvPacketList,
                                STRUCT_OF(SLIST_ENTRY, &(Context->Linkage), Next),
                                &RecvHeaderLock
                                );

    return;

}

void
SpxReInitSendPacket(PNDIS_PACKET _Packet)
{
   DBGPRINT(NDIS, DBG,
            ("SpxReInitSendPacket\n"));
}

void
SpxReInitRecvPacket(PNDIS_PACKET _Packet)
{
   DBGPRINT(NDIS, DBG,
               ("SpxReInitRecvPacket\n"));
}


#endif //SPX_OWN_PACKETS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxerror.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	spxerror.h

Abstract:

	This module contains some error definitions for spx.

Author:

	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:

Notes:	Tab stop: 4
--*/

//	Define the modules names for SPX - use the high bits.
#define		SPXDRVR			0x00010000
#define		SPXREG			0x00020000
#define		SPXDEV			0x00030000
#define		SPXBIND			0x00040000
#define		SPXRECV			0x00050000
#define		SPXSEND			0x00060000
#define		SPXTIMER		0x00070000
#define		SPXERROR		0x00080000
#define		SPXPKT			0x00090000
#define		SPXUTILS		0x000a0000
#define		SPXCPKT			0x000b0000
#define		SPXCONN			0x000c0000
#define		SPXADDR			0x000d0000
#define		SPXCUTIL 		0x000e0000
#define		SPXINIT			0x000f0000
#define		SPXMEM			0x00100000
#define		SPXQUERY		0x00200000

// DEBUGGING SUPPORT:
// Debugging messages are provided per-subsystem defined here, and within
// the subsystems, there are 4 levels of messages.
//
// The four levels of debug messages are:
//
// INFO:		Informational messages, eg., entry exit in routines
// DBG:			Used when debugging some msgs are turned from info to dbg
// WARN:		Something went wrong, but its not an error, eg., packet was not ours
// ERR:		    Error situations, but we can still run if a retry happens
// FATAL:		In this situation, the driver is not operational

#define	DBG_LEVEL_INFO			0x4000
#define	DBG_LEVEL_DBG			0x5000
#define	DBG_LEVEL_DBG1			0x5001
#define	DBG_LEVEL_DBG2			0x5002
#define	DBG_LEVEL_DBG3			0x5003
#define	DBG_LEVEL_WARN			0x6000
#define	DBG_LEVEL_ERR			0x7000
#define	DBG_LEVEL_FATAL			0x8000

// SUBSYSTEMS
#define DBG_COMP_DEVICE         0x00000001
#define DBG_COMP_CREATE         0x00000002
#define DBG_COMP_ADDRESS        0x00000004
#define DBG_COMP_SEND           0x00000008
#define DBG_COMP_NDIS           0x00000010
#define DBG_COMP_RECEIVE        0x00000020
#define DBG_COMP_CONFIG         0x00000040
#define DBG_COMP_PACKET         0x00000080
#define DBG_COMP_RESOURCES      0x00000100
#define DBG_COMP_BIND           0x00000200
#define DBG_COMP_UNLOAD			0x00000400
#define	DBG_COMP_DUMP			0x00000800
#define DBG_COMP_REFCOUNTS		0x00001000
#define DBG_COMP_SYSTEM			0x00002000
#define DBG_COMP_CRITSEC		0x00004000
#define DBG_COMP_UTILS			0x00008000
#define DBG_COMP_TDI			0x00010000
#define DBG_COMP_CONNECT		0x00020000
#define DBG_COMP_DISC			0x00040000
#define	DBG_COMP_ACTION			0x00080000
#define	DBG_COMP_STATE			0x00100000

#define DBG_COMP_MOST           (DBG_COMP_DEVICE	|	\
								DBG_COMP_CREATE     |	\
                                DBG_COMP_ADDRESS    |	\
                                DBG_COMP_SEND       |	\
                                DBG_COMP_NDIS       |	\
                                DBG_COMP_RECEIVE    |	\
                                DBG_COMP_CONFIG     |	\
                                DBG_COMP_PACKET     |	\
                                DBG_COMP_RESOURCES  |	\
                                DBG_COMP_BIND       |	\
                                DBG_COMP_UNLOAD     |	\
                                DBG_COMP_DUMP       |	\
                                DBG_COMP_REFCOUNTS  |	\
                                DBG_COMP_SYSTEM     |	\
                                DBG_COMP_CRITSEC    |	\
                                DBG_COMP_UTILS      |	\
                                DBG_COMP_TDI		|	\
                                DBG_COMP_CONNECT	|	\
								DBG_COMP_DISC		|	\
								DBG_COMP_ACTION		|	\
								DBG_COMP_STATE)


// More debugging support. These values define the dumping components.
// There are a max of 32 such components that can be defined. Each of
// these are associated with a dump routine. It one is specified and
// enabled, periodically it is called. It is upto that component to
// decide what it wants to do

#define	DBG_DUMP_DEF_INTERVAL		30			// In Seconds

//	This defines the number of times an error has to happen consecutively before
//	it gets logged again.
#define		ERROR_CONSEQ_FREQ	200
#define		ERROR_CONSEQ_TIME	(60*30)	// 30 minutes

#ifdef	DBG
typedef VOID	(*DUMP_ROUTINE)(VOID);

extern
BOOLEAN
SpxDumpComponents(
	IN	PVOID	Context);

#endif

//
//	PROTOTYPES
//

BOOLEAN
SpxFilterErrorLogEntry(
    IN	NTSTATUS 			UniqueErrorCode,
    IN	NTSTATUS 			NtStatusCode,
    IN	PVOID    			RawDataBuf			OPTIONAL,
    IN	LONG     			RawDataLen);
VOID
SpxWriteResourceErrorLog(
    IN PDEVICE 	Device,
    IN ULONG 	BytesNeeded,
    IN ULONG 	UniqueErrorValue);

VOID
SpxWriteGeneralErrorLog(
    IN PDEVICE 	Device,
    IN NTSTATUS ErrorCode,
    IN ULONG 	UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN PWSTR 	SecondString,
    IN	PVOID   RawDataBuf		OPTIONAL,
    IN	LONG    RawDataLen);


//
//	MACROS
//

#if DBG
#define LOG_ERROR(Error, NtStatus, SecondString, RawData, RawDataLen)		\
	{																		\
		SpxWriteGeneralErrorLog(											\
			SpxDevice,														\
			Error,															\
			FILENUM | __LINE__,		        								\
			NtStatus,														\
			SecondString,													\
			RawData,														\
			RawDataLen);													\
	}

#define RES_LOG_ERROR(BytesNeeded)											\
	{																		\
		SpxWriteResourceErrorLog(											\
			SpxDevice,														\
			BytesNeeded,													\
			FILENUM | __LINE__);	        								\
	}

#else

#define LOG_ERROR(Error, NtStatus, SecondString, RawData, RawDataLen)		\
	{																		\
		SpxWriteGeneralErrorLog(											\
			SpxDevice,														\
			Error,															\
			FILENUM | __LINE__,		        								\
			NtStatus,														\
			SecondString,													\
			RawData,														\
			RawDataLen);													\
	}

#define RES_LOG_ERROR(BytesNeeded)											\
	{																		\
		SpxWriteResourceErrorLog(											\
			SpxDevice,														\
			BytesNeeded,													\
			FILENUM | __LINE__);	        								\
	}

#endif


#if DBG

#define DBGPRINT(Component, Level, Fmt)										\
		{																	\
			if (((DBG_LEVEL_ ## Level) >= SpxDebugLevel) &&					\
				(SpxDebugSystems & (DBG_COMP_ ## Component)))				\
			{																\
				DbgPrint("SPX: ");										    \
				DbgPrint Fmt;												\
			}																\
		}
			
#define DBGBRK(Level)														\
		{																	\
			if ((DBG_LEVEL_ ## Level) >= SpxDebugLevel) 					\
				DbgBreakPoint();											\
		}                                                       			
			
#define	TMPLOGERR()															\
		{																	\
			DBGPRINT(MOST, ERR,												\
					("TempErrLog: %s, Line %ld\n", __FILE__, __LINE__));	\
		}

#else
#define DBGPRINT(Component, Level, Fmt)
#define DBGBRK(Level)
#define	TMPLOGERR()
#endif

extern
VOID
SpxWriteErrorLogEntry(
	IN	NTSTATUS 					UniqueErrorCode,
	IN	ULONG						UniqueErrorValue,
	IN	NTSTATUS 					NtStatusCode,
	IN	PVOID						RawDataBuf OPTIONAL,
	IN	LONG	 					RawDataLen);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxntdef.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxntdef.h				

Abstract:

	Missing nt definitions in ntddk.h

Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:


--*/


NTSTATUS
NTAPI
NtCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );

NTSTATUS
NTAPI
NtClose(
    IN HANDLE Handle
    );

NTSTATUS
NTAPI
NtDeviceIoControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );

NTSTATUS
NTAPI
NtWaitForSingleObject(
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxquery.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxquery.h				

Abstract:


Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:


--*/

#define SPX_TDI_PROVIDERINFO_VERSION    0x0001
#define SPX_PINFOSENDSIZE               0xFFFFFFFF
#define SPX_PINFOMINMAXLOOKAHEAD		128

//
// Bug #14498: Indicate to AFD that we are capable of orderly disc so AFD can follow
// these semantics.
// In order to have SPXI connections work correctly, we OR this bit in at query time.
// (see SpxTdiQueryInformation)
//
#define SPX_PINFOSERVICEFLAGS   (   TDI_SERVICE_CONNECTION_MODE     | \
                                    TDI_SERVICE_DELAYED_ACCEPTANCE  | \
                                    TDI_SERVICE_MESSAGE_MODE        | \
                                    TDI_SERVICE_ERROR_FREE_DELIVERY) // | \
                                    // TDI_SERVICE_ORDERLY_RELEASE       )

VOID
SpxQueryInitProviderInfo(
    PTDI_PROVIDER_INFO  ProviderInfo);

NTSTATUS
SpxTdiQueryInformation(
    IN PDEVICE Device,
    IN PREQUEST Request);

NTSTATUS
SpxTdiSetInformation(
    IN PDEVICE Device,
    IN PREQUEST Request);


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxpkt.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxpkt.c

Abstract:

    This module contains code that builds various spx packets.

Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//	Define module number for event logging entries
#define	FILENUM		SPXPKT

VOID
SpxPktBuildCr(
	IN		PSPX_CONN_FILE		pSpxConnFile,
	IN		PSPX_ADDR			pSpxAddr,
	IN OUT	PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		BOOLEAN				fSpx2
	)
/*++

Routine Description:

    NOTE: If *ppPkt is NULL, we allocate a packet. If not, we just
    recreate the data and don't update the packet's state.

Arguments:


Return Value:


--*/
{
	PNDIS_PACKET		pCrPkt;
	PSPX_SEND_RESD		pSendResd;
	NDIS_STATUS			ndisStatus;
	PIPXSPX_HDR			pIpxSpxHdr;
    PNDIS_BUFFER        pNdisMacHdr, pNdisIpxHdr;
    PNDIS_BUFFER        NdisBuf, NdisBuf2;
    ULONG               BufLen = 0;

    if (*ppPkt == NULL) {

    	SpxAllocSendPacket(SpxDevice, &pCrPkt, &ndisStatus);
    	if (ndisStatus != NDIS_STATUS_SUCCESS)
    	{
    		DBGPRINT(CONNECT, ERR,
    				("SpxConnHandleConnReq: Could not allocate ndis packet\n"));
    		return;
    	}

    } else {

        pCrPkt = *ppPkt;
    }
    
    //
    // Get the MDL that points to the IPX/SPX header. (the second one)
    //
     
    NdisQueryPacket(pCrPkt, NULL, NULL, &NdisBuf, NULL);
    NdisGetNextBuffer(NdisBuf, &NdisBuf2);
    NdisQueryBuffer(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen);

#if OWN_PKT_POOLS
	pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pCrPkt 			+
										NDIS_PACKET_SIZE 		+
										sizeof(SPX_SEND_RESD)	+
										IpxInclHdrOffset);
#endif 
    NdisQueryPacket(pCrPkt, NULL, NULL, &pNdisMacHdr, NULL);
    pNdisIpxHdr = NDIS_BUFFER_LINKAGE(pNdisMacHdr);
    if (!fSpx2)
    {
      NdisAdjustBufferLength(pNdisIpxHdr, MIN_IPXSPX_HDRSIZE);
    }
	SpxBuildIpxHdr(
		pIpxSpxHdr,
		MIN_IPXSPX_HDRSIZE,
		pSpxConnFile->scf_RemAddr,
		pSpxAddr->sa_Socket);

	//	Build SPX Header.
	pIpxSpxHdr->hdr_ConnCtrl	= (SPX_CC_SYS | SPX_CC_ACK |
									(fSpx2 ? (SPX_CC_SPX2 | SPX_CC_NEG) : 0));
	pIpxSpxHdr->hdr_DataType	= 0;
	PUTSHORT2SHORT(
		&pIpxSpxHdr->hdr_SrcConnId,
		pSpxConnFile->scf_LocalConnId);
	pIpxSpxHdr->hdr_DestConnId	= 0xFFFF;
	pIpxSpxHdr->hdr_SeqNum		= 0;
	pIpxSpxHdr->hdr_AckNum		= 0;
	PUTSHORT2SHORT(
		&pIpxSpxHdr->hdr_AllocNum,
		pSpxConnFile->scf_SentAllocNum);

	//	Initialize

    if (*ppPkt == NULL) {

    	pSendResd	= (PSPX_SEND_RESD)(pCrPkt->ProtocolReserved);
    	pSendResd->sr_Id		= IDENTIFIER_SPX;
    	pSendResd->sr_Type		= SPX_TYPE_CR;
    	pSendResd->sr_Reserved1	= NULL;
    	pSendResd->sr_Reserved2	= NULL;
    	pSendResd->sr_State		= State;
    	pSendResd->sr_ConnFile	= pSpxConnFile;
    	pSendResd->sr_Request	= NULL;
    	pSendResd->sr_Next 		= NULL;
    	pSendResd->sr_Len		= pSendResd->sr_HdrLen = MIN_IPXSPX_HDRSIZE;

    	*ppPkt	= pCrPkt;
    }

	return;
}




VOID
SpxPktBuildCrAck(
	IN		PSPX_CONN_FILE		pSpxConnFile,
	IN		PSPX_ADDR			pSpxAddr,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		BOOLEAN				fNeg,
	IN		BOOLEAN				fSpx2
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PNDIS_PACKET		pCrAckPkt;
	PSPX_SEND_RESD		pSendResd;
    PIPXSPX_HDR         pIpxSpxHdr;
	NDIS_STATUS			ndisStatus;
	USHORT				hdrLen;
    PNDIS_BUFFER        pNdisMacHdr, pNdisIpxHdr;
    PNDIS_BUFFER        NdisBuf, NdisBuf2;
    ULONG               BufLen = 0;

	*ppPkt	= NULL;

	SpxAllocSendPacket(SpxDevice, &pCrAckPkt, &ndisStatus);
	if (ndisStatus != NDIS_STATUS_SUCCESS)
	{
		DBGPRINT(CONNECT, ERR,
				("SpxConnHandleConnReq: Could not allocate ndis packet\n"));
		return;
	}
    
    //
    // Get the MDL that points to the IPX/SPX header. (the second one)
    //
     
    NdisQueryPacket(pCrAckPkt, NULL, NULL, &NdisBuf, NULL);
    NdisGetNextBuffer(NdisBuf, &NdisBuf2);
    NdisQueryBuffer(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen);
#if OWN_PKT_POOLS
	pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pCrAckPkt 			+
										NDIS_PACKET_SIZE 		+
										sizeof(SPX_SEND_RESD)	+
										IpxInclHdrOffset);
#endif 
	hdrLen = (SPX2_CONN(pSpxConnFile) ? MIN_IPXSPX2_HDRSIZE : MIN_IPXSPX_HDRSIZE);

    NdisQueryPacket(pCrAckPkt, NULL, NULL, &pNdisMacHdr, NULL);
    pNdisIpxHdr = NDIS_BUFFER_LINKAGE(pNdisMacHdr);
    if (!SPX2_CONN(pSpxConnFile))
    {
      NdisAdjustBufferLength(pNdisIpxHdr, MIN_IPXSPX_HDRSIZE);
    }
	SpxBuildIpxHdr(
		pIpxSpxHdr,
		hdrLen,
		pSpxConnFile->scf_RemAddr,
		pSpxAddr->sa_Socket);

	pIpxSpxHdr->hdr_ConnCtrl	=
		(SPX_CC_SYS 														|
		 (fSpx2 ? SPX_CC_SPX2 : 0)	|
		 (fNeg  ? SPX_CC_NEG : 0));

	pIpxSpxHdr->hdr_DataType		= 0;
	PUTSHORT2SHORT(
		&pIpxSpxHdr->hdr_SrcConnId,
		pSpxConnFile->scf_LocalConnId);

	pIpxSpxHdr->hdr_DestConnId	= pSpxConnFile->scf_RemConnId;
	pIpxSpxHdr->hdr_SeqNum		= 0;
	pIpxSpxHdr->hdr_AckNum		= 0;
	PUTSHORT2SHORT(
		&pIpxSpxHdr->hdr_AllocNum,
		pSpxConnFile->scf_SentAllocNum);

	if (SPX2_CONN(pSpxConnFile))
	{
		DBGPRINT(CONNECT, DBG,
				("SpxConnBuildCrAck: Spx2 packet size %d.%lx\n",
					pSpxConnFile->scf_MaxPktSize));

		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_NegSize,
			pSpxConnFile->scf_MaxPktSize);
	}


	pSendResd	= (PSPX_SEND_RESD)(pCrAckPkt->ProtocolReserved);
	pSendResd->sr_Id		= IDENTIFIER_SPX;
	pSendResd->sr_Type		= SPX_TYPE_CRACK;
	pSendResd->sr_Reserved1	= NULL;
	pSendResd->sr_Reserved2	= NULL;
	pSendResd->sr_State		= State;
	pSendResd->sr_ConnFile	= pSpxConnFile;
	pSendResd->sr_Request	= NULL;
	pSendResd->sr_Next 		= NULL;
	pSendResd->sr_Len		= pSendResd->sr_HdrLen = hdrLen;

	*ppPkt	= pCrAckPkt;
	return;
}



VOID
SpxPktBuildSn(
	IN		PSPX_CONN_FILE		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PNDIS_PACKET 	pPkt;
	PSPX_SEND_RESD	pSendResd;
	PNDIS_BUFFER	pBuf;
	NDIS_STATUS		ndisStatus;
    PIPXSPX_HDR     pIpxSpxHdr;
	PBYTE			pData;
    PNDIS_BUFFER        NdisBuf, NdisBuf2;
    ULONG               BufLen = 0;

	do
	{
		*ppPkt = NULL;

		//	Allocate a ndis packet for the cr.
		SpxAllocSendPacket(SpxDevice, &pPkt, &ndisStatus);
		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		CTEAssert(pSpxConnFile->scf_MaxPktSize != 0);
		DBGPRINT(SEND, DBG,
				("SpxPktBuildSn: Data size %lx\n", pSpxConnFile->scf_MaxPktSize));

		if ((pData =
				SpxAllocateMemory(
			        pSpxConnFile->scf_MaxPktSize - MIN_IPXSPX2_HDRSIZE)) == NULL)
		{
			SpxPktSendRelease(pPkt);
			break;
		}

		//	Build ndis buffer desc
		NdisAllocateBuffer(
			&ndisStatus,
			&pBuf,
			SpxDevice->dev_NdisBufferPoolHandle,
			pData,
            pSpxConnFile->scf_MaxPktSize - MIN_IPXSPX2_HDRSIZE);

		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			SpxPktSendRelease(pPkt);
			SpxFreeMemory(pData);
			break;
		}

		//	Chain at back.
		NdisChainBufferAtBack(
			pPkt,
			pBuf);

        //
        // Get the MDL that points to the IPX/SPX header. (the second one)
        //
         
        NdisQueryPacket(pPkt, NULL, NULL, &NdisBuf, NULL);
        NdisGetNextBuffer(NdisBuf, &NdisBuf2);
        NdisQueryBuffer(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen);
#if OWN_PKT_POOLS
		pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pPkt 				+
											NDIS_PACKET_SIZE 		+
											sizeof(SPX_SEND_RESD)	+
											IpxInclHdrOffset);
#endif 
		SpxBuildIpxHdr(
			pIpxSpxHdr,
			pSpxConnFile->scf_MaxPktSize,
			pSpxConnFile->scf_RemAddr,
			pSpxConnFile->scf_AddrFile->saf_Addr->sa_Socket);
	
		//	Build SPX Header.
		pIpxSpxHdr->hdr_ConnCtrl	= (	SPX_CC_SYS | SPX_CC_ACK |
										SPX_CC_NEG | SPX_CC_SPX2);
		pIpxSpxHdr->hdr_DataType	= 0;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SrcConnId,
			pSpxConnFile->scf_LocalConnId);
		pIpxSpxHdr->hdr_DestConnId	= pSpxConnFile->scf_RemConnId;
		pIpxSpxHdr->hdr_SeqNum		= 0;
		pIpxSpxHdr->hdr_AckNum		= 0;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AllocNum,
			pSpxConnFile->scf_SentAllocNum);
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_NegSize,
			pSpxConnFile->scf_MaxPktSize);
	
		//	Init the data part to indicate no neg values
		*(UNALIGNED ULONG *)pData = 0;

		pSendResd	= (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
		pSendResd->sr_Id		= IDENTIFIER_SPX;
		pSendResd->sr_Type		= SPX_TYPE_SN;
		pSendResd->sr_Reserved1	= NULL;
		pSendResd->sr_Reserved2	= NULL;
		pSendResd->sr_State		= (State | SPX_SENDPKT_FREEDATA);
		pSendResd->sr_ConnFile	= pSpxConnFile;
		pSendResd->sr_Request	= NULL;
		pSendResd->sr_Next 		= NULL;
		pSendResd->sr_HdrLen 	= MIN_IPXSPX2_HDRSIZE;
		pSendResd->sr_Len	    = pSpxConnFile->scf_MaxPktSize;

		*ppPkt 	= pPkt;

	} while (FALSE);

	return;
}




VOID
SpxPktBuildSnAck(
	IN		PSPX_CONN_FILE		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PNDIS_PACKET 	pPkt;
	NDIS_STATUS		ndisStatus;
    PIPXSPX_HDR     pIpxSpxHdr;
	PSPX_SEND_RESD	pSendResd;
    PNDIS_BUFFER        NdisBuf, NdisBuf2;
    ULONG               BufLen = 0;

	do
	{
		*ppPkt = NULL;

		//	Allocate a ndis packet for the cr.
		SpxAllocSendPacket(SpxDevice, &pPkt, &ndisStatus);
		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			break;
		}
	
#if OWN_PKT_POOLS
		pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pPkt 				+
											NDIS_PACKET_SIZE 		+
											sizeof(SPX_SEND_RESD)	+
											IpxInclHdrOffset);
#endif 
        //
        // Get the MDL that points to the IPX/SPX header. (the second one)
        //
         
        NdisQueryPacket(pPkt, NULL, NULL, &NdisBuf, NULL);
        NdisGetNextBuffer(NdisBuf, &NdisBuf2);
        NdisQueryBuffer(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen);

	
		SpxBuildIpxHdr(
			pIpxSpxHdr,
			MIN_IPXSPX2_HDRSIZE,
			pSpxConnFile->scf_RemAddr,
			pSpxConnFile->scf_AddrFile->saf_Addr->sa_Socket);
	
		//	Build SPX Header.
		pIpxSpxHdr->hdr_ConnCtrl	= (SPX_CC_SYS | SPX_CC_NEG | SPX_CC_SPX2);
		pIpxSpxHdr->hdr_DataType	= 0;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SrcConnId,
			pSpxConnFile->scf_LocalConnId);
		pIpxSpxHdr->hdr_DestConnId	= pSpxConnFile->scf_RemConnId;
		pIpxSpxHdr->hdr_SeqNum		= 0;
		pIpxSpxHdr->hdr_AckNum		= 0;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AllocNum,
			pSpxConnFile->scf_SentAllocNum);
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_NegSize,
			pSpxConnFile->scf_MaxPktSize);
	
		pSendResd	= (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
		pSendResd->sr_Id		= IDENTIFIER_SPX;
		pSendResd->sr_Type		= SPX_TYPE_SNACK;
		pSendResd->sr_Reserved1	= NULL;
		pSendResd->sr_Reserved2	= NULL;
		pSendResd->sr_State		= State;
		pSendResd->sr_ConnFile	= pSpxConnFile;
		pSendResd->sr_Request	= NULL;
		pSendResd->sr_Next 		= NULL;
		pSendResd->sr_Len		= pSendResd->sr_HdrLen = MIN_IPXSPX2_HDRSIZE;

		*ppPkt 	= pPkt;

	} while (FALSE);

	return;
}




VOID
SpxPktBuildSs(
	IN		PSPX_CONN_FILE		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PNDIS_PACKET 	pPkt;
	PSPX_SEND_RESD	pSendResd;
	PNDIS_BUFFER	pBuf;
	NDIS_STATUS		ndisStatus;
    PIPXSPX_HDR     pIpxSpxHdr;
	PBYTE			pData;
    PNDIS_BUFFER        NdisBuf, NdisBuf2;
    ULONG               BufLen = 0;

	do
	{
		*ppPkt = NULL;

		//	Allocate a ndis packet for the cr.
		SpxAllocSendPacket(SpxDevice, &pPkt, &ndisStatus);
		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			break;
		}


		CTEAssert(pSpxConnFile->scf_MaxPktSize != 0);
		DBGPRINT(SEND, DBG,
				("SpxPktBuildSs: Data size %lx\n", pSpxConnFile->scf_MaxPktSize));

		if ((pData =
				SpxAllocateMemory(
					pSpxConnFile->scf_MaxPktSize - MIN_IPXSPX2_HDRSIZE)) == NULL)
		{
			SpxPktSendRelease(pPkt);
			break;
		}

		//	Build ndis buffer desc
		NdisAllocateBuffer(
			&ndisStatus,
			&pBuf,
			SpxDevice->dev_NdisBufferPoolHandle,
			pData,
            pSpxConnFile->scf_MaxPktSize - MIN_IPXSPX2_HDRSIZE);

		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			SpxPktSendRelease(pPkt);
			SpxFreeMemory(pData);
			break;
		}

		//	Chain at back.
		NdisChainBufferAtBack(
			pPkt,
			pBuf);

#if OWN_PKT_POOLS
		pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pPkt 				+
											NDIS_PACKET_SIZE 		+
											sizeof(SPX_SEND_RESD)	+
											IpxInclHdrOffset);
#endif 
        //
        // Get the MDL that points to the IPX/SPX header. (the second one)
        //
         
        NdisQueryPacket(pPkt, NULL, NULL, &NdisBuf, NULL);
        NdisGetNextBuffer(NdisBuf, &NdisBuf2);
        NdisQueryBuffer(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen);

		SpxBuildIpxHdr(
			pIpxSpxHdr,
			pSpxConnFile->scf_MaxPktSize,
			pSpxConnFile->scf_RemAddr,
			pSpxConnFile->scf_AddrFile->saf_Addr->sa_Socket);
  	
		//	Build SPX Header.
		pIpxSpxHdr->hdr_ConnCtrl	=
			(SPX_CC_SYS | SPX_CC_ACK | SPX_CC_SPX2 |
				((pSpxConnFile->scf_Flags & SPX_CONNFILE_NEG) ? SPX_CC_NEG : 0));

		pIpxSpxHdr->hdr_DataType	= 0;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SrcConnId,
			pSpxConnFile->scf_LocalConnId);
		pIpxSpxHdr->hdr_DestConnId	= pSpxConnFile->scf_RemConnId;
		pIpxSpxHdr->hdr_SeqNum		= 0;
		pIpxSpxHdr->hdr_AckNum		= 0;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AllocNum,
			pSpxConnFile->scf_SentAllocNum);
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_NegSize,
			pSpxConnFile->scf_MaxPktSize);
	
		//	Init the data part to indicate no neg values
		*(UNALIGNED ULONG *)pData = 0;

		pSendResd	= (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
		pSendResd->sr_Id		= IDENTIFIER_SPX;
		pSendResd->sr_Type		= SPX_TYPE_SS;
		pSendResd->sr_Reserved1	= NULL;
		pSendResd->sr_Reserved2	= NULL;
		pSendResd->sr_State		= (State | SPX_SENDPKT_FREEDATA);
		pSendResd->sr_ConnFile	= pSpxConnFile;
		pSendResd->sr_Request	= NULL;
		pSendResd->sr_Next 		= NULL;
		pSendResd->sr_HdrLen 	= MIN_IPXSPX2_HDRSIZE;
		pSendResd->sr_Len	    = pSpxConnFile->scf_MaxPktSize;

		*ppPkt 	= pPkt;
	} while (FALSE);

	return;
}



VOID
SpxPktBuildSsAck(
	IN		PSPX_CONN_FILE		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PNDIS_PACKET 	pPkt;
	NDIS_STATUS		ndisStatus;
    PIPXSPX_HDR     pIpxSpxHdr;
	PSPX_SEND_RESD	pSendResd;
    PNDIS_BUFFER        NdisBuf, NdisBuf2;
    ULONG               BufLen = 0;

	do
	{
		*ppPkt = NULL;

		//	Allocate a ndis packet for the cr.
		SpxAllocSendPacket(SpxDevice, &pPkt, &ndisStatus);
		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			break;
		}
	
        //
        // Get the MDL that points to the IPX/SPX header. (the second one)
        //
         
        NdisQueryPacket(pPkt, NULL, NULL, &NdisBuf, NULL);
        NdisGetNextBuffer(NdisBuf, &NdisBuf2);
        NdisQueryBuffer(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen);

#if OWN_PKT_POOLS
        
		pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pPkt 				+
											NDIS_PACKET_SIZE 		+
											sizeof(SPX_SEND_RESD)	+
											IpxInclHdrOffset);
#endif 
	
		SpxBuildIpxHdr(
			pIpxSpxHdr,
			MIN_IPXSPX2_HDRSIZE,
			pSpxConnFile->scf_RemAddr,
			pSpxConnFile->scf_AddrFile->saf_Addr->sa_Socket);
	
		//	Build SPX Header.
		pIpxSpxHdr->hdr_ConnCtrl	=
			(SPX_CC_SYS | SPX_CC_SPX2 |
				((pSpxConnFile->scf_Flags & SPX_CONNFILE_NEG) ? SPX_CC_NEG : 0));

		pIpxSpxHdr->hdr_DataType	= 0;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SrcConnId,
			pSpxConnFile->scf_LocalConnId);
		pIpxSpxHdr->hdr_DestConnId	= pSpxConnFile->scf_RemConnId;
		pIpxSpxHdr->hdr_SeqNum		= 0;
		pIpxSpxHdr->hdr_AckNum		= 0;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AllocNum,
			pSpxConnFile->scf_SentAllocNum);
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_NegSize,
			pSpxConnFile->scf_MaxPktSize);
	
		pSendResd	= (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
		pSendResd->sr_Id		= IDENTIFIER_SPX;
		pSendResd->sr_Type		= SPX_TYPE_SSACK;
		pSendResd->sr_Reserved1	= NULL;
		pSendResd->sr_Reserved2	= NULL;
		pSendResd->sr_State		= State;
		pSendResd->sr_ConnFile	= pSpxConnFile;
		pSendResd->sr_Request	= NULL;
		pSendResd->sr_Next 		= NULL;
		pSendResd->sr_Len		= pSendResd->sr_HdrLen = MIN_IPXSPX2_HDRSIZE;

		*ppPkt 	= pPkt;

	} while (FALSE);

	return;
}




VOID
SpxPktBuildRr(
	IN		PSPX_CONN_FILE		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				SeqNum,
	IN		USHORT				State
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PNDIS_PACKET 	pPkt;
	PSPX_SEND_RESD	pSendResd;
	PNDIS_BUFFER	pBuf;
	NDIS_STATUS		ndisStatus;
    PIPXSPX_HDR     pIpxSpxHdr;
	PBYTE			pData;
    PNDIS_BUFFER        NdisBuf, NdisBuf2;
    ULONG               BufLen = 0;

	do
	{
		*ppPkt = NULL;

		//	Allocate a ndis packet for the cr.
		SpxAllocSendPacket(SpxDevice, &pPkt, &ndisStatus);
		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		if ((pData =
				SpxAllocateMemory(
			        pSpxConnFile->scf_MaxPktSize - MIN_IPXSPX2_HDRSIZE)) == NULL)
		{
			SpxPktSendRelease(pPkt);
			break;
		}

		//	Build ndis buffer desc
		NdisAllocateBuffer(
			&ndisStatus,
			&pBuf,
			SpxDevice->dev_NdisBufferPoolHandle,
			pData,
            pSpxConnFile->scf_MaxPktSize - MIN_IPXSPX2_HDRSIZE);

		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			SpxPktSendRelease(pPkt);
			SpxFreeMemory(pData);
			break;
		}

		//	Chain at back.
		NdisChainBufferAtBack(
			pPkt,
			pBuf);

        //
        // Get the MDL that points to the IPX/SPX header. (the second one)
        //
         
        NdisQueryPacket(pPkt, NULL, NULL, &NdisBuf, NULL);
        NdisGetNextBuffer(NdisBuf, &NdisBuf2);
        NdisQueryBuffer(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen);

#if OWN_PKT_POOLS
		pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pPkt 				+
											NDIS_PACKET_SIZE 		+
											sizeof(SPX_SEND_RESD)	+
											IpxInclHdrOffset);
#endif 
		SpxBuildIpxHdr(
			pIpxSpxHdr,
			pSpxConnFile->scf_MaxPktSize,
			pSpxConnFile->scf_RemAddr,
			pSpxConnFile->scf_AddrFile->saf_Addr->sa_Socket);
	
		//	Build SPX Header.
		pIpxSpxHdr->hdr_ConnCtrl	= (	SPX_CC_SYS | SPX_CC_ACK |
										SPX_CC_NEG | SPX_CC_SPX2);
		pIpxSpxHdr->hdr_DataType	= 0;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SrcConnId,
			pSpxConnFile->scf_LocalConnId);
		pIpxSpxHdr->hdr_DestConnId	= pSpxConnFile->scf_RemConnId;

		//	For a renegotiate request, we use the sequence number of
		//	the first waiting data packet. Passed in.
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SeqNum,
			SeqNum);

		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AckNum,
			pSpxConnFile->scf_RecvSeqNum);
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AllocNum,
			pSpxConnFile->scf_SentAllocNum);
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_NegSize,
			pSpxConnFile->scf_MaxPktSize);
	
		//	Init the data part to indicate no neg values
		*(UNALIGNED ULONG *)pData = 0;

		pSendResd	= (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
		pSendResd->sr_Id		= IDENTIFIER_SPX;
		pSendResd->sr_Type		= SPX_TYPE_RR;
		pSendResd->sr_Reserved1	= NULL;
		pSendResd->sr_Reserved2	= NULL;
		pSendResd->sr_State		= (State | SPX_SENDPKT_FREEDATA);
		pSendResd->sr_ConnFile	= pSpxConnFile;
		pSendResd->sr_Request	= NULL;
		pSendResd->sr_Next 		= NULL;
		pSendResd->sr_SeqNum	= SeqNum;
		pSendResd->sr_HdrLen 	= MIN_IPXSPX2_HDRSIZE;
		pSendResd->sr_Len	    = pSpxConnFile->scf_MaxPktSize;

		*ppPkt 	= pPkt;

	} while (FALSE);

	return;
}




VOID
SpxPktBuildRrAck(
	IN		PSPX_CONN_FILE		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		USHORT				MaxPktSize
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PNDIS_PACKET 	pPkt;
	NDIS_STATUS		ndisStatus;
    PIPXSPX_HDR     pIpxSpxHdr;
	PSPX_SEND_RESD	pSendResd;
    PNDIS_BUFFER        NdisBuf, NdisBuf2;
    ULONG               BufLen = 0;

	do
	{
		*ppPkt = NULL;

		//	Allocate a ndis packet for the cr.
		SpxAllocSendPacket(SpxDevice, &pPkt, &ndisStatus);
		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			break;
		}
	
        //
        // Get the MDL that points to the IPX/SPX header. (the second one)
        //
         
        NdisQueryPacket(pPkt, NULL, NULL, &NdisBuf, NULL);
        NdisGetNextBuffer(NdisBuf, &NdisBuf2);
        NdisQueryBuffer(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen);

#if OWN_PKT_POOLS
		pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pPkt 				+
											NDIS_PACKET_SIZE 		+
											sizeof(SPX_SEND_RESD)	+
											IpxInclHdrOffset);
#endif	
	
		SpxBuildIpxHdr(
			pIpxSpxHdr,
			MIN_IPXSPX2_HDRSIZE,
			pSpxConnFile->scf_RemAckAddr,
			pSpxConnFile->scf_AddrFile->saf_Addr->sa_Socket);
	
		//	Build SPX Header.
		pIpxSpxHdr->hdr_ConnCtrl	= (SPX_CC_SYS | SPX_CC_NEG | SPX_CC_SPX2);
		pIpxSpxHdr->hdr_DataType	= 0;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SrcConnId,
			pSpxConnFile->scf_LocalConnId);
		pIpxSpxHdr->hdr_DestConnId	= pSpxConnFile->scf_RemConnId;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SeqNum,
			pSpxConnFile->scf_SendSeqNum);

		//	For the RrAck, ack number will be the appropriate number
		//	for the last data packet received.
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AckNum,
			pSpxConnFile->scf_RenegAckAckNum);
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AllocNum,
			pSpxConnFile->scf_SentAllocNum);
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_NegSize,
			MaxPktSize);
	
		DBGPRINT(SEND, DBG3,
				("SpxPktBuildRrAck: SEQ %lx ACKNUM %lx ALLOCNUM %lx MAXPKT %lx\n",
	                pSpxConnFile->scf_SendSeqNum,
                    pSpxConnFile->scf_RenegAckAckNum,
                    pSpxConnFile->scf_SentAllocNum,
                    MaxPktSize));
	
		pSendResd	= (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
		pSendResd->sr_Id		= IDENTIFIER_SPX;
		pSendResd->sr_Type		= SPX_TYPE_RRACK;
		pSendResd->sr_Reserved1	= NULL;
		pSendResd->sr_Reserved2	= NULL;
		pSendResd->sr_State		= State;
		pSendResd->sr_ConnFile	= pSpxConnFile;
		pSendResd->sr_Request	= NULL;
		pSendResd->sr_Next 		= NULL;
		pSendResd->sr_Len		= pSendResd->sr_HdrLen = MIN_IPXSPX2_HDRSIZE;

		*ppPkt 	= pPkt;

	} while (FALSE);

	return;
}




VOID
SpxPktBuildDisc(
	IN		PSPX_CONN_FILE		pSpxConnFile,
	IN		PREQUEST			pRequest,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		UCHAR				DataType
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PSPX_SEND_RESD	pSendResd;
	PNDIS_PACKET	pDiscPkt;
	NDIS_STATUS		ndisStatus;
	PIPXSPX_HDR		pIpxSpxHdr;
	USHORT			hdrLen;
    PNDIS_BUFFER    pNdisMacHdr, pNdisIpxHdr;
    PNDIS_BUFFER        NdisBuf, NdisBuf2;
    ULONG               BufLen = 0;


	*ppPkt = NULL;

	SpxAllocSendPacket(SpxDevice, &pDiscPkt, &ndisStatus);
	if (ndisStatus == NDIS_STATUS_SUCCESS)
	{
#if OWN_PKT_POOLS
		pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pDiscPkt 			+
											NDIS_PACKET_SIZE 		+
											sizeof(SPX_SEND_RESD)	+
											IpxInclHdrOffset);
#endif 
        //
        // Get the MDL that points to the IPX/SPX header. (the second one)
        //
         
        NdisQueryPacket(pDiscPkt, NULL, NULL, &NdisBuf, NULL);
        NdisGetNextBuffer(NdisBuf, &NdisBuf2);
        NdisQueryBuffer(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen);

		hdrLen = SPX2_CONN(pSpxConnFile) ? MIN_IPXSPX2_HDRSIZE : MIN_IPXSPX_HDRSIZE;
        NdisQueryPacket(pDiscPkt, NULL, NULL, &pNdisMacHdr, NULL);
        pNdisIpxHdr = NDIS_BUFFER_LINKAGE(pNdisMacHdr);
        if (!SPX2_CONN(pSpxConnFile))
        {
           NdisAdjustBufferLength(pNdisIpxHdr, MIN_IPXSPX_HDRSIZE);
        }
	
		SpxBuildIpxHdr(
			pIpxSpxHdr,
			hdrLen,
			pSpxConnFile->scf_RemAddr,
			pSpxConnFile->scf_AddrFile->saf_Addr->sa_Socket);

		//	Build SPX Header.
		pIpxSpxHdr->hdr_ConnCtrl =
			(SPX_CC_ACK |
             (SPX2_CONN(pSpxConnFile) ? SPX_CC_SPX2 : 0) |
			 ((DataType == SPX2_DT_IDISC) ? 0 : SPX_CC_EOM));

		pIpxSpxHdr->hdr_DataType = DataType;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SrcConnId,
			pSpxConnFile->scf_LocalConnId);
		pIpxSpxHdr->hdr_DestConnId	=
			*((UNALIGNED USHORT *)&pSpxConnFile->scf_RemConnId);
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SeqNum,
			pSpxConnFile->scf_SendSeqNum);
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AckNum,
			pSpxConnFile->scf_RecvSeqNum);
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AllocNum,
			pSpxConnFile->scf_SentAllocNum);

		if (SPX2_CONN(pSpxConnFile))
		{
			PUTSHORT2SHORT(
				&pIpxSpxHdr->hdr_NegSize,
				pSpxConnFile->scf_MaxPktSize);
		}

		pSendResd	= (PSPX_SEND_RESD)(pDiscPkt->ProtocolReserved);

		pSendResd->sr_Id		= IDENTIFIER_SPX;
		pSendResd->sr_State		= State;
		pSendResd->sr_Reserved1	= NULL;
		pSendResd->sr_Reserved2	= NULL;
		pSendResd->sr_Type		=
			((DataType == SPX2_DT_IDISC) ? SPX_TYPE_IDISC : SPX_TYPE_ORDREL);
		pSendResd->sr_Next 		= NULL;
		pSendResd->sr_Request	= pRequest;
		pSendResd->sr_ConnFile	= pSpxConnFile;
		pSendResd->sr_Offset	= 0;
		pSendResd->sr_SeqNum	= pSpxConnFile->scf_SendSeqNum;
		pSendResd->sr_Len		=
		pSendResd->sr_HdrLen 	= hdrLen;

		*ppPkt = pDiscPkt;
	}

	return;
}




VOID
SpxPktBuildProbe(
	IN		PSPX_CONN_FILE		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		BOOLEAN				fSpx2
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PSPX_SEND_RESD	pSendResd;
	PNDIS_PACKET	pProbe;
	NDIS_STATUS		ndisStatus;
	PIPXSPX_HDR		pIpxSpxHdr;
	USHORT		    hdrLen;
    PNDIS_BUFFER    pNdisMacHdr, pNdisIpxHdr;
    PNDIS_BUFFER        NdisBuf, NdisBuf2;
    ULONG               BufLen = 0;


	*ppPkt = NULL;

	SpxAllocSendPacket(SpxDevice, &pProbe, &ndisStatus);
	if (ndisStatus == NDIS_STATUS_SUCCESS)
	{
       //
       // Get the MDL that points to the IPX/SPX header. (the second one)
       //
        
       NdisQueryPacket(pProbe, NULL, NULL, &NdisBuf, NULL);
       NdisGetNextBuffer(NdisBuf, &NdisBuf2);
       NdisQueryBuffer(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen);
   
#if OWN_PKT_POOLS

		pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pProbe 			+
											NDIS_PACKET_SIZE 		+
											sizeof(SPX_SEND_RESD)	+
											IpxInclHdrOffset);
#endif 
		hdrLen = (fSpx2 ? MIN_IPXSPX2_HDRSIZE : MIN_IPXSPX_HDRSIZE);
	
        NdisQueryPacket(pProbe, NULL, NULL, &pNdisMacHdr, NULL);
        pNdisIpxHdr = NDIS_BUFFER_LINKAGE(pNdisMacHdr);
        if (!fSpx2)
        {
           NdisAdjustBufferLength(pNdisIpxHdr, MIN_IPXSPX_HDRSIZE);
        }
		SpxBuildIpxHdr(
			pIpxSpxHdr,
			hdrLen,
			pSpxConnFile->scf_RemAddr,
			pSpxConnFile->scf_AddrFile->saf_Addr->sa_Socket);

		//	Build SPX Header.
		pIpxSpxHdr->hdr_ConnCtrl	= (SPX_CC_SYS | SPX_CC_ACK |
										(fSpx2 ? SPX_CC_SPX2 : 0));
		pIpxSpxHdr->hdr_DataType	= 0;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SrcConnId,
			pSpxConnFile->scf_LocalConnId);
		pIpxSpxHdr->hdr_DestConnId	=
			*((UNALIGNED USHORT *)&pSpxConnFile->scf_RemConnId);

		if (fSpx2)
		{
			pIpxSpxHdr->hdr_SeqNum		= 0;
			PUTSHORT2SHORT(
				&pIpxSpxHdr->hdr_NegSize,
				pSpxConnFile->scf_MaxPktSize);
		}
		else
		{
			PUTSHORT2SHORT(
				&pIpxSpxHdr->hdr_SeqNum,
				pSpxConnFile->scf_SendSeqNum);
		}

		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AckNum,
			pSpxConnFile->scf_RecvSeqNum);

		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AllocNum,
			pSpxConnFile->scf_SentAllocNum);

		pSendResd	= (PSPX_SEND_RESD)(pProbe->ProtocolReserved);
		pSendResd->sr_Id		= IDENTIFIER_SPX;
		pSendResd->sr_Type		= SPX_TYPE_PROBE;
		pSendResd->sr_Reserved1	= NULL;
		pSendResd->sr_Reserved2	= NULL;
		pSendResd->sr_State		= State;
		pSendResd->sr_Next 		= NULL;
		pSendResd->sr_Request	= NULL;
		pSendResd->sr_ConnFile	= pSpxConnFile;
		pSendResd->sr_Len		=
		pSendResd->sr_HdrLen 	= (fSpx2 ? MIN_IPXSPX2_HDRSIZE
											: MIN_IPXSPX_HDRSIZE);

		*ppPkt = pProbe;
	}

	return;
}




VOID
SpxPktBuildData(
	IN		PSPX_CONN_FILE		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		USHORT				Length
	)
/*++

Routine Description:

	Handles zero length sends.

Arguments:


Return Value:


--*/
{
	PNDIS_BUFFER	pNdisBuffer;
	PSPX_SEND_RESD	pSendResd;
	PNDIS_PACKET	pDataPkt;
	NDIS_STATUS		ndisStatus;
	PIPXSPX_HDR		pIpxSpxHdr;
	USHORT			hdrLen;
    PNDIS_BUFFER    pNdisMacHdr, pNdisIpxHdr;
    PNDIS_BUFFER        NdisBuf, NdisBuf2;
    ULONG               BufLen = 0;

	*ppPkt = NULL;

	SpxAllocSendPacket(SpxDevice, &pDataPkt, &ndisStatus);
	if (ndisStatus == NDIS_STATUS_SUCCESS)
	{
		//	Make a ndis buffer descriptor for the data if present.
		if (Length > 0)
		{
			SpxCopyBufferChain(
				&ndisStatus,
				&pNdisBuffer,
				SpxDevice->dev_NdisBufferPoolHandle,
				REQUEST_TDI_BUFFER(pSpxConnFile->scf_ReqPkt),
				pSpxConnFile->scf_ReqPktOffset,
				Length);
	
			if (ndisStatus != NDIS_STATUS_SUCCESS)
			{
				//	Free the send packet
				SpxPktSendRelease(pDataPkt);
				return;
			}
	
			//	Chain this in the packet
			NdisChainBufferAtBack(pDataPkt, pNdisBuffer);
		}
        
        //
        // Get the MDL that points to the IPX/SPX header. (the second one)
        //
         
        NdisQueryPacket(pDataPkt, NULL, NULL, &NdisBuf, NULL);
        NdisGetNextBuffer(NdisBuf, &NdisBuf2);
        NdisQueryBuffer(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen);
    
#if OWN_PKT_POOLS

		pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pDataPkt 			+
											NDIS_PACKET_SIZE 		+
											sizeof(SPX_SEND_RESD)	+
											IpxInclHdrOffset);
#endif 

		hdrLen = SPX2_CONN(pSpxConnFile) ? MIN_IPXSPX2_HDRSIZE : MIN_IPXSPX_HDRSIZE;
		Length	+= hdrLen;

        NdisQueryPacket(pDataPkt, NULL, NULL, &pNdisMacHdr, NULL);
        pNdisIpxHdr = NDIS_BUFFER_LINKAGE(pNdisMacHdr);
        if (!SPX2_CONN(pSpxConnFile))
        {
           NdisAdjustBufferLength(pNdisIpxHdr, MIN_IPXSPX_HDRSIZE);
        }
		SpxBuildIpxHdr(
			pIpxSpxHdr,
			Length,
			pSpxConnFile->scf_RemAddr,
			pSpxConnFile->scf_AddrFile->saf_Addr->sa_Socket);

		//	Build SPX Header.
		pIpxSpxHdr->hdr_ConnCtrl =
			(((State & SPX_SENDPKT_ACKREQ) ? SPX_CC_ACK : 0) |
			 ((State & SPX_SENDPKT_EOM) ? SPX_CC_EOM : 0)	 |
             (SPX2_CONN(pSpxConnFile) ? SPX_CC_SPX2 : 0));

		pIpxSpxHdr->hdr_DataType = pSpxConnFile->scf_DataType;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SrcConnId,
			pSpxConnFile->scf_LocalConnId);
		pIpxSpxHdr->hdr_DestConnId	=
			*((UNALIGNED USHORT *)&pSpxConnFile->scf_RemConnId);

		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SeqNum,
			pSpxConnFile->scf_SendSeqNum);

		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AckNum,
			pSpxConnFile->scf_RecvSeqNum);

		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AllocNum,
			pSpxConnFile->scf_SentAllocNum);

		if (SPX2_CONN(pSpxConnFile))
		{
			PUTSHORT2SHORT(
				&pIpxSpxHdr->hdr_NegSize,
				pSpxConnFile->scf_MaxPktSize);
		}

		pSendResd	= (PSPX_SEND_RESD)(pDataPkt->ProtocolReserved);

		pSendResd->sr_Id		= IDENTIFIER_SPX;
		pSendResd->sr_State		= State;
		pSendResd->sr_Reserved1	= NULL;
		pSendResd->sr_Reserved2	= NULL;
		pSendResd->sr_Type		= SPX_TYPE_DATA;
		pSendResd->sr_Next 		= NULL;
		pSendResd->sr_Request	= pSpxConnFile->scf_ReqPkt;
		pSendResd->sr_Offset	= pSpxConnFile->scf_ReqPktOffset;
		pSendResd->sr_ConnFile	= pSpxConnFile;
		pSendResd->sr_SeqNum	= pSpxConnFile->scf_SendSeqNum;
		pSendResd->sr_Len		= Length;
		pSendResd->sr_HdrLen 	= hdrLen;

		if (State & SPX_SENDPKT_ACKREQ)
		{
			KeQuerySystemTime((PLARGE_INTEGER)&pSendResd->sr_SentTime);
		}

		CTEAssert(pSendResd->sr_Len <= pSpxConnFile->scf_MaxPktSize);
		*ppPkt = pDataPkt;

		//	Ok, allocation succeeded. Increment send seq.
		pSpxConnFile->scf_SendSeqNum++;
	}

	return;
}


VOID
SpxCopyBufferChain(
    OUT PNDIS_STATUS Status,
    OUT PNDIS_BUFFER * TargetChain,
    IN NDIS_HANDLE PoolHandle,
    IN PNDIS_BUFFER SourceChain,
    IN UINT Offset,
    IN UINT Length
    )
/*++

Routine Description:

    Creates a TargetBufferChain from the SourceBufferChain.  The copy begins at
    the 'Offset' location in the source chain. It copies 'Length' bytes. It also
    handles Length = 0. If we run out of source chain before copying length amount
    of bytes or run out of memory to create any more buffers for the target chain,
    we clean up the partial chain created so far.

Arguments:

    Status - Status of the request.
    TargetChain - Pointer to the allocated buffer descriptor.
    PoolHandle - Handle that is used to specify the pool.
    SourceChain - Pointer to the descriptor of the source memory.
    Offset - The Offset in the sources memory from which the copy is to
             begin
    Length - Number of Bytes to copy.

Return Value:

    None.

--*/
{
    UINT            BytesBeforeCurBuffer        = 0;
    PNDIS_BUFFER    CurBuffer                   = SourceChain;
    UINT            BytesLeft;
    UINT            AvailableBytes;
    PNDIS_BUFFER    NewNdisBuffer, StartTargetChain;

    CTEAssert( SourceChain );

    // First of all find the source buffer that contains data that starts at
    // Offset.
    NdisQueryBuffer( CurBuffer, NULL, &AvailableBytes );
    while ( BytesBeforeCurBuffer + AvailableBytes <= Offset ) {
        BytesBeforeCurBuffer    += AvailableBytes;
        CurBuffer               = CurBuffer->Next;
        if ( CurBuffer ) {
            NdisQueryBuffer( CurBuffer, NULL, &AvailableBytes );
        } else {
            break;
        }
    }

    if ( ! CurBuffer ) {
        *Status = STATUS_UNSUCCESSFUL;
        return;
    }

    //
    // Copy the first buffer. This takes care of Length = 0.
    //
    BytesLeft   = Length;

    //
    // ( Offset - BytesBeforeCurBuffer ) gives us the offset within this buffer.
    //

    AvailableBytes -= ( Offset - BytesBeforeCurBuffer );

    if ( AvailableBytes > BytesLeft ) {
        AvailableBytes = BytesLeft;
    }

    NdisCopyBuffer(
        Status,
        &NewNdisBuffer,
        PoolHandle,
        CurBuffer,
        Offset - BytesBeforeCurBuffer,
        AvailableBytes);

    if ( *Status != NDIS_STATUS_SUCCESS ) {
        return;
    }

    StartTargetChain    =  NewNdisBuffer;
    BytesLeft           -= AvailableBytes;

    //
    // Did the first buffer have enough data. If so, we r done.
    //
    if ( ! BytesLeft ) {
        *TargetChain = StartTargetChain;
        return;
    }

    //
    // Now follow the Mdl chain and copy more buffers.
    //
    CurBuffer = CurBuffer->Next;
    NdisQueryBuffer( CurBuffer, NULL, &AvailableBytes );
    while ( CurBuffer  ) {

        if ( AvailableBytes > BytesLeft ) {
            AvailableBytes = BytesLeft;
        }

        NdisCopyBuffer(
            Status,
            &(NDIS_BUFFER_LINKAGE(NewNdisBuffer)),
            PoolHandle,
            CurBuffer,
            0,
            AvailableBytes);

        if ( *Status != NDIS_STATUS_SUCCESS ) {

            //
            // ran out of resources. put back what we've used in this call and
            // return the error.
            //

            while ( StartTargetChain != NULL) {
                NewNdisBuffer = NDIS_BUFFER_LINKAGE( StartTargetChain );
                NdisFreeBuffer ( StartTargetChain );
                StartTargetChain = NewNdisBuffer;
            }

            return;
        }

        NewNdisBuffer = NDIS_BUFFER_LINKAGE(NewNdisBuffer);
        BytesLeft -= AvailableBytes;

        if ( ! BytesLeft ) {
            *TargetChain = StartTargetChain;
            return;
        }

        CurBuffer   = CurBuffer->Next;
        NdisQueryBuffer( CurBuffer, NULL, &AvailableBytes );
    }

    //
    // Ran out of source chain. This should not happen.
    //

    CTEAssert( FALSE );

    // For Retail build we clean up anyways.

    while ( StartTargetChain != NULL) {
        NewNdisBuffer = NDIS_BUFFER_LINKAGE( StartTargetChain );
        NdisFreeBuffer ( StartTargetChain );
        StartTargetChain = NewNdisBuffer;
    }

    *Status = STATUS_UNSUCCESSFUL;
    return;
}


VOID
SpxPktBuildAck(
	IN		PSPX_CONN_FILE		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		BOOLEAN				fBuildNack,
	IN		USHORT				NumToResend
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PNDIS_PACKET		pPkt;
	PSPX_SEND_RESD		pSendResd;
    PIPXSPX_HDR         pIpxSpxHdr;
	NDIS_STATUS			ndisStatus;
	USHORT				hdrLen;
    PNDIS_BUFFER    pNdisMacHdr, pNdisIpxHdr;
    PNDIS_BUFFER        NdisBuf, NdisBuf2;
    ULONG               BufLen = 0;

	BOOLEAN				fSpx2 = SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_SPX2);

	*ppPkt	= NULL;

	SpxAllocSendPacket(SpxDevice, &pPkt, &ndisStatus);
	if (ndisStatus != NDIS_STATUS_SUCCESS)
	{
		DBGPRINT(SEND, ERR,
				("SpxPktBuildAck: Could not allocate ndis packet\n"));
		return;
	}

    //
    // Get the MDL that points to the IPX/SPX header. (the second one)
    //
     
    NdisQueryPacket(pPkt, NULL, NULL, &NdisBuf, NULL);
    NdisGetNextBuffer(NdisBuf, &NdisBuf2);
    NdisQueryBuffer(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen);

#if OWN_PKT_POOLS
	pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pPkt 				+
										NDIS_PACKET_SIZE 		+
										sizeof(SPX_SEND_RESD)	+
										IpxInclHdrOffset);
#endif 
	hdrLen = SPX2_CONN(pSpxConnFile) ? MIN_IPXSPX2_HDRSIZE : MIN_IPXSPX_HDRSIZE;
    NdisQueryPacket(pPkt, NULL, NULL, &pNdisMacHdr, NULL);
    pNdisIpxHdr = NDIS_BUFFER_LINKAGE(pNdisMacHdr);
    if (!fSpx2)
    {
           NdisAdjustBufferLength(pNdisIpxHdr, MIN_IPXSPX_HDRSIZE);
    }

    // Send where data came from
	SpxBuildIpxHdr(
		pIpxSpxHdr,
		hdrLen,
		pSpxConnFile->scf_RemAckAddr,
		pSpxConnFile->scf_AddrFile->saf_Addr->sa_Socket);

	pIpxSpxHdr->hdr_ConnCtrl	= (SPX_CC_SYS | (fSpx2 ? SPX_CC_SPX2 : 0));

	pIpxSpxHdr->hdr_DataType		= 0;
	PUTSHORT2SHORT(
		&pIpxSpxHdr->hdr_SrcConnId,
		pSpxConnFile->scf_LocalConnId);

	pIpxSpxHdr->hdr_DestConnId	= pSpxConnFile->scf_RemConnId;

	PUTSHORT2SHORT(
		&pIpxSpxHdr->hdr_AckNum,
		pSpxConnFile->scf_RecvSeqNum);

	if (fSpx2)
	{
        pIpxSpxHdr->hdr_SeqNum = 0;
		if (fBuildNack)
		{
			PUTSHORT2SHORT(
				&pIpxSpxHdr->hdr_SeqNum,
				NumToResend);
		}

		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_NegSize,
			pSpxConnFile->scf_MaxPktSize);
	}
	else
	{
		//	Put current send seq number in packet for spx1
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SeqNum,
			pSpxConnFile->scf_SendSeqNum);
	}

	PUTSHORT2SHORT(
		&pIpxSpxHdr->hdr_AllocNum,
		pSpxConnFile->scf_SentAllocNum);

	pSendResd	= (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
	pSendResd->sr_Id		= IDENTIFIER_SPX;
	pSendResd->sr_Type		= (fBuildNack ? SPX_TYPE_DATANACK : SPX_TYPE_DATAACK);
	pSendResd->sr_Reserved1	= NULL;
	pSendResd->sr_Reserved2	= NULL;
	pSendResd->sr_State		= State;
	pSendResd->sr_ConnFile	= pSpxConnFile;
	pSendResd->sr_Request	= NULL;
	pSendResd->sr_Next 		= NULL;
	pSendResd->sr_Len		= pSendResd->sr_HdrLen = hdrLen;

	*ppPkt	= pPkt;
	return;
}



VOID
SpxPktRecvRelease(
	IN	PNDIS_PACKET	pPkt
	)
{
	((PSPX_RECV_RESD)(pPkt->ProtocolReserved))->rr_State = SPX_RECVPKT_IDLE;
	SpxFreeRecvPacket(SpxDevice, pPkt);
	return;
}




VOID
SpxPktSendRelease(
	IN	PNDIS_PACKET	pPkt
	)
{
	PNDIS_BUFFER	pBuf, pIpxSpxBuf, pFreeBuf;
	UINT			bufCount;

	CTEAssert((((PSPX_SEND_RESD)(pPkt->ProtocolReserved))->sr_State &
									SPX_SENDPKT_IPXOWNS) == 0);

	NdisQueryPacket(pPkt, NULL, &bufCount, &pBuf, NULL);

	//	BufCount == 1 for only the header. That's ok, we just reset the length
	//	and free the packet to the buffer pools. Else we need to free user buffers
	//	before that.

	NdisUnchainBufferAtFront(
		pPkt,
		&pBuf);

	NdisUnchainBufferAtFront(
		pPkt,
		&pIpxSpxBuf);

    //
    // Set the header length to the max. that can be needed.
    //
    NdisAdjustBufferLength(pIpxSpxBuf, MIN_IPXSPX2_HDRSIZE);

	while (bufCount-- > 2)
	{
		PBYTE	pData;
		ULONG	dataLen;

		NdisUnchainBufferAtBack(
			pPkt,
			&pFreeBuf);

		//	See if we free data associated with the buffer
		if ((((PSPX_SEND_RESD)(pPkt->ProtocolReserved))->sr_State &
												SPX_SENDPKT_FREEDATA) != 0)
		{
			NdisQueryBuffer(pFreeBuf, &pData, &dataLen);
			CTEAssert(pData != NULL);
			SpxFreeMemory(pData);
		}

		CTEAssert(pFreeBuf != NULL);
		NdisFreeBuffer(pFreeBuf);
	}

	NdisReinitializePacket(pPkt);

	//	Initialize elements of the protocol reserved structure.
	((PSPX_SEND_RESD)(pPkt->ProtocolReserved))->sr_Id	 	= IDENTIFIER_SPX;
	((PSPX_SEND_RESD)(pPkt->ProtocolReserved))->sr_State	= SPX_SENDPKT_IDLE;
	((PSPX_SEND_RESD)(pPkt->ProtocolReserved))->sr_Reserved1= NULL;
	((PSPX_SEND_RESD)(pPkt->ProtocolReserved))->sr_Reserved2= NULL;

	NdisChainBufferAtFront(
		pPkt,
		pBuf);

	NdisChainBufferAtBack(
		pPkt,
		pIpxSpxBuf);

	SpxFreeSendPacket(SpxDevice, pPkt);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxquery.c ===
/*++

Copyright (c) 1989-1993 Microsoft Corporation

Module Name:

    spxquery.c

Abstract:

    This module contains code which performs the following TDI services:

        o   TdiQueryInformation

Author:

	Adam   Barr		 (adamba)  Initial Version
    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//  Discardable code after Init time
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, SpxQueryInitProviderInfo)
#endif

//	Define module number for event logging entries
#define	FILENUM		SPXQUERY

// Useful macro to obtain the total length of an MDL chain.
#define SpxGetMdlChainLength(Mdl, Length) { \
    PMDL _Mdl = (Mdl); \
    *(Length) = 0; \
    while (_Mdl) { \
        *(Length) += MmGetMdlByteCount(_Mdl); \
        _Mdl = _Mdl->Next; \
    } \
}



VOID
SpxQueryInitProviderInfo(
    PTDI_PROVIDER_INFO  ProviderInfo
    )
{
    //  Initialize to defaults first
    RtlZeroMemory((PVOID)ProviderInfo, sizeof(TDI_PROVIDER_INFO));

    ProviderInfo->Version 		= SPX_TDI_PROVIDERINFO_VERSION;
    KeQuerySystemTime (&ProviderInfo->StartTime);
    ProviderInfo->MinimumLookaheadData	= SPX_PINFOMINMAXLOOKAHEAD;
    ProviderInfo->MaximumLookaheadData	= IpxLineInfo.MaximumPacketSize;
    ProviderInfo->MaxSendSize 	= SPX_PINFOSENDSIZE;
    ProviderInfo->ServiceFlags 	= SPX_PINFOSERVICEFLAGS;
    return;
}




NTSTATUS
SpxTdiQueryInformation(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine performs the TdiQueryInformation request for the transport
    provider.

Arguments:

    Request - the request for the operation.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS 							status;
    PSPX_ADDR_FILE 						AddressFile;
    PSPX_CONN_FILE 						ConnectionFile;
    PTDI_REQUEST_KERNEL_QUERY_INFORMATION 	query;
	struct {
        ULONG 			ActivityCount;
        TA_IPX_ADDRESS 	SpxAddress;
    } AddressInfo;



    // what type of status do we want?
    query = (PTDI_REQUEST_KERNEL_QUERY_INFORMATION)REQUEST_PARAMETERS(Request);

    switch (query->QueryType)
	{
	case TDI_QUERY_CONNECTION_INFO:

		status = STATUS_NOT_IMPLEMENTED;
		break;

    case TDI_QUERY_ADDRESS_INFO:

        // The caller wants the exact address value.

        ConnectionFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(Request);
        status = SpxConnFileVerify(ConnectionFile);

        if (status == STATUS_SUCCESS) {
            AddressFile = ConnectionFile->scf_AddrFile;
            SpxConnFileDereference(ConnectionFile, CFREF_VERIFY);
        } else {
            AddressFile = (PSPX_ADDR_FILE)REQUEST_OPEN_CONTEXT(Request);
        }

        status = SpxAddrFileVerify(AddressFile);

        if (status == STATUS_SUCCESS)
		{
			DBGPRINT(RECEIVE, INFO,
					("SpxTdiQuery: Net.Socket %lx.%lx\n",
						*(PULONG)Device->dev_Network,
						AddressFile->saf_Addr->sa_Socket));

            AddressInfo.ActivityCount = 0;
            (VOID)SpxBuildTdiAddress(
                &AddressInfo.SpxAddress,
                sizeof(TA_IPX_ADDRESS),
                Device->dev_Network,
                Device->dev_Node,
                AddressFile->saf_Addr->sa_Socket);

            status = TdiCopyBufferToMdl(
                &AddressInfo,
                0,
                sizeof(AddressInfo),
                REQUEST_NDIS_BUFFER(Request),
                0,
                (PULONG)&REQUEST_INFORMATION(Request));

            SpxAddrFileDereference(AddressFile, AFREF_VERIFY);

        }

        break;

    case TDI_QUERY_PROVIDER_INFO: {
        BYTE    socketType;
        TDI_PROVIDER_INFO  providerInfo = Device->dev_ProviderInfo;

        //
        // The device name extension comes down in the Irp
        //
    	if (!NT_SUCCESS(status = SpxUtilGetSocketType(
    								REQUEST_OPEN_NAME(Request),
    								&socketType))) {
            DBGPRINT(RECEIVE, ERR, ("TDI_QUERY_PROVIDER_INFO: SpxUtilGetSocketType failed: %lx\n", status));
    		return(status);
    	}

        //
        // The Catapult folks had a problem where AFD was discarding buffered sends on the NT box when it got a
        // local disconnect on SPX1. This was because the Orderly release flag was always set in the provider
        // info. AFD queries this once per device type. We detect the device above and OR in the orderly release
        // flag if this query came down on an SPX2 endpoint.
        // This is to make sure that AFD follows the correct disconnect semantics for SPX1 and SPX2 (SPX1 does
        // only abortive; SPX2 does both abortive and orderly).
        //
        // this will still not solve the problem completely since a connection that starts off as an SPX2
        // one can still be negotiated to SPX1 if the remote supports only SPX1.
        //
        if ((socketType == SOCKET2_TYPE_SEQPKT) ||
            (socketType == SOCKET2_TYPE_STREAM)) {

            DBGPRINT(RECEIVE, INFO, ("TDI_QUERY_PROVIDER_INFO: SPX2 socket\n"));
            providerInfo.ServiceFlags |= TDI_SERVICE_ORDERLY_RELEASE;
        } else {
            DBGPRINT(RECEIVE, INFO, ("TDI_QUERY_PROVIDER_INFO: SPX1 socket\n"));
        }

        status = TdiCopyBufferToMdl (
                    &providerInfo,
                    0,
                    sizeof (TDI_PROVIDER_INFO),
                    REQUEST_TDI_BUFFER(Request),
                    0,
                    (PULONG)&REQUEST_INFORMATION(Request));
        break;
    }

    case TDI_QUERY_PROVIDER_STATISTICS:

        status = TdiCopyBufferToMdl (
                    &Device->dev_Stat,
                    0,
                    FIELD_OFFSET (TDI_PROVIDER_STATISTICS, ResourceStats[0]),
                    REQUEST_TDI_BUFFER(Request),
                    0,
                    (PULONG)&REQUEST_INFORMATION(Request));
        break;

    default:
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    return status;

} // SpxTdiQueryInformation



NTSTATUS
SpxTdiSetInformation(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine performs the TdiSetInformation request for the transport
    provider.

Arguments:

    Device - the device.

    Request - the request for the operation.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    UNREFERENCED_PARAMETER (Device);
    UNREFERENCED_PARAMETER (Request);

    return STATUS_NOT_IMPLEMENTED;

} // SpxTdiSetInformation
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\nwlink\spx\spxrecv.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxrecv.c

Abstract:


Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:

    Sanjay Anand (SanjayAn) 5-July-1995
    Bug fixes - tagged [SA]

--*/

#include "precomp.h"
#pragma hdrstop

//      Define module number for event logging entries
#define FILENUM         SPXRECV

BOOLEAN
SpxReceive(
        IN  NDIS_HANDLE         MacBindingHandle,
        IN  NDIS_HANDLE         MacReceiveContext,
        IN  ULONG_PTR           FwdAdapterCtx,
        IN  PIPX_LOCAL_TARGET   RemoteAddress,
        IN  ULONG               MacOptions,
        IN  PUCHAR              LookaheadBuffer,
        IN  UINT                LookaheadBufferSize,
        IN  UINT                LookaheadBufferOffset,
        IN  UINT                PacketSize,
        IN  PMDL                pMdl
        )

{
        PIPXSPX_HDR                     pHdr;

        //      We have a separate routine to process SYS packets. DATA packets are
        //      processed within this routine.
        if (LookaheadBufferSize < MIN_IPXSPX_HDRSIZE)
        {
                DBGPRINT(RECEIVE, ERR,
                                ("SpxReceive: Invalid length %lx\n", LookaheadBufferSize));

                return FALSE;
        }

    ++SpxDevice->dev_Stat.PacketsReceived;

        pHdr    = (PIPXSPX_HDR)LookaheadBuffer;
        if ((pHdr->hdr_ConnCtrl & SPX_CC_SYS) == 0)
        {
                //      Check for data packets
                if ((pHdr->hdr_DataType != SPX2_DT_ORDREL) &&
                        (pHdr->hdr_DataType != SPX2_DT_IDISC) &&
                        (pHdr->hdr_DataType != SPX2_DT_IDISC_ACK))
                {
                        //      HANDLE DATA PACKET
                        SpxRecvDataPacket(
                                MacBindingHandle,
                                MacReceiveContext,
                                RemoteAddress,
                                MacOptions,
                                LookaheadBuffer,
                                LookaheadBufferSize,
                                LookaheadBufferOffset,
                                PacketSize);
                }
                else
                {
                        //      The whole packet better be in the lookahead, else we ignore.
                        if (LookaheadBufferSize == PacketSize)
                        {
                                SpxRecvDiscPacket(
                                        LookaheadBuffer,
                                        RemoteAddress,
                                        LookaheadBufferSize);
                        }
                }
        }
        else
        {
                SpxRecvSysPacket(
                        MacBindingHandle,
                        MacReceiveContext,
                        RemoteAddress,
                        MacOptions,
                        LookaheadBuffer,
                        LookaheadBufferSize,
                        LookaheadBufferOffset,
                        PacketSize);
        }

        return FALSE;
}




VOID
SpxTransferDataComplete(
    IN  PNDIS_PACKET    pNdisPkt,
    IN  NDIS_STATUS     NdisStatus,
    IN  UINT            BytesTransferred
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
        PSPX_CONN_FILE          pSpxConnFile;
        PREQUEST                        pRequest;
        PSPX_RECV_RESD          pRecvResd;
        CTELockHandle           lockHandle;
        NTSTATUS                        status;
        BOOLEAN                         fAck, fEom, fBuffered, fImmedAck, fLockHeld;
        PNDIS_BUFFER            pNdisBuffer;

        DBGPRINT(RECEIVE, DBG,
                        ("SpxTransferData: For %lx with status %lx\n", pNdisPkt, NdisStatus));

        pRecvResd               = RECV_RESD(pNdisPkt);
        pSpxConnFile    = pRecvResd->rr_ConnFile;

        CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
        fLockHeld = TRUE;

        fEom            = ((pRecvResd->rr_State & SPX_RECVPKT_EOM) != 0);
        fImmedAck       = ((pRecvResd->rr_State & SPX_RECVPKT_IMMEDACK) != 0);
        fBuffered       = ((pRecvResd->rr_State & SPX_RECVPKT_BUFFERING) != 0);
        fAck            = ((pRecvResd->rr_State & SPX_RECVPKT_SENDACK) != 0);

        //      Check if receive is done. If we remove the reference for this
        //      packet and it goes to zero, that means the receive was aborted.
        //      Move to the completion queue.
        //      If receive is filled up, then remove the creation reference
        //      i.e. just complete the receive at this point.
        //      There can be only one packet per receive, we dont support
        //      out of order reception.

        if (!fBuffered)
        {
                //      Get pointer to the buffer descriptor and its memory.
                NdisUnchainBufferAtFront(pNdisPkt, &pNdisBuffer);
                CTEAssert((pNdisBuffer != NULL) || (BytesTransferred == 0));

                //      BUG #11772
                //      On MP-machines scf_CurRecvReq could be set to NULL. Get the req
                //      from the recv packet.
                //      pRequest                = pSpxConnFile->scf_CurRecvReq;
                //      CTEAssert(pRequest == pRecvResd->rr_Request);
        pRequest = pRecvResd->rr_Request;

                //      Remove reference for this packet.
                --(REQUEST_INFORMATION(pRequest));

                if (NdisStatus == NDIS_STATUS_SUCCESS)
                {
                        pSpxConnFile->scf_CurRecvOffset += BytesTransferred;
                        pSpxConnFile->scf_CurRecvSize   -= BytesTransferred;

#if DBG
                        if ((pRecvResd->rr_State & SPX_RECVPKT_INDICATED) != 0)
                        {
                                if (BytesTransferred != 0)
                                {
                                        CTEAssert (pSpxConnFile->scf_IndBytes != 0);
                                        pSpxConnFile->scf_IndBytes      -= BytesTransferred;
                                }
                        }
#endif

                        if (REQUEST_INFORMATION(pRequest) == 0)
                        {
                                DBGPRINT(RECEIVE, DBG,
                                                ("SpxTransferDataComplete: Request %lx ref %lx Cur %lx.%lx\n",
                                                        pRequest, REQUEST_INFORMATION(pRequest),
                                                        REQUEST_STATUS(pRequest),
                                                        pSpxConnFile->scf_CurRecvSize));

                                if (SPX_CONN_STREAM(pSpxConnFile)                       ||
                                        (pSpxConnFile->scf_CurRecvSize == 0)    ||
                                        fEom                                                                    ||
                                        ((REQUEST_STATUS(pRequest) != STATUS_SUCCESS) &&
                                         (REQUEST_STATUS(pRequest) != STATUS_RECEIVE_PARTIAL)))
                                {
                                        CTELockHandle                                   lockHandleInter;

                                        //      We are done with this receive.
                                        REQUEST_INFORMATION(pRequest) = pSpxConnFile->scf_CurRecvOffset;

                                        status = STATUS_SUCCESS;
                                        if (!SPX_CONN_STREAM(pSpxConnFile) &&
                                                (pSpxConnFile->scf_CurRecvSize == 0) &&
                                                !fEom)
                                        {
                                                status = STATUS_RECEIVE_PARTIAL;
                                        }

                                        if ((REQUEST_STATUS(pRequest) != STATUS_SUCCESS) &&
                                                (REQUEST_STATUS(pRequest) != STATUS_RECEIVE_PARTIAL))
                                        {
                                                status = REQUEST_STATUS(pRequest);
                                        }

                                        REQUEST_STATUS(pRequest) = status;

                                        DBGPRINT(RECEIVE, DBG,
                                                        ("SpxTransferDataComplete: Request %lx ref %lx Cur %lx.%lx\n",
                                                                pRequest, REQUEST_INFORMATION(pRequest),
                                                                REQUEST_STATUS(pRequest),
                                                                pSpxConnFile->scf_CurRecvSize));

                                        //      Dequeue this request, Set next recv if one exists.
                                        SPX_CONN_SETNEXT_CUR_RECV(pSpxConnFile, pRequest);
                                        CTEGetLock(&SpxGlobalQInterlock, &lockHandleInter);
                                        InsertTailList(
                                                &pSpxConnFile->scf_RecvDoneLinkage,
                                                REQUEST_LINKAGE(pRequest));

                                        SPX_QUEUE_FOR_RECV_COMPLETION(pSpxConnFile);
                                        CTEFreeLock(&SpxGlobalQInterlock, lockHandleInter);
                                }
                        }
                }

                if (pNdisBuffer != NULL)
                {
                        NdisFreeBuffer(pNdisBuffer);
                }
        }
        else
        {
                //      Buffered receive, queue it in if successful.
                //      BUG #18363
                //      IF WE DISCONNECTED in the meantime, we need to just dump this
                //      packet.
                if (SPX_CONN_ACTIVE(pSpxConnFile) &&
            (NdisStatus == NDIS_STATUS_SUCCESS))
                {
                        //      Queue packet in connection. Reference connection for this.
                        SpxConnQueueRecvPktTail(pSpxConnFile, pNdisPkt);
                        SpxConnFileLockReference(pSpxConnFile, CFREF_VERIFY);

                        DBGPRINT(RECEIVE, DBG,
                                        ("SpxTransferData: Buffering: %lx Pkt %lx Size %lx F %lx\n",
                                        pSpxConnFile, pNdisPkt, BytesTransferred, pRecvResd->rr_State));

                        //      There could either be queued receives. (This could happen in
                        //      a partial receive case. Or if a receive got queued in while we
                        //      were processing this packet (Possible on MP)), or a packet was
                        //      buffered while we were completing some receives

                        CTEAssert(pSpxConnFile->scf_RecvListHead);

                        if ((pSpxConnFile->scf_CurRecvReq != NULL) ||
                                ((pSpxConnFile->scf_RecvListHead->rr_State &
                                                                                                SPX_RECVPKT_INDICATED) == 0))
                        {
                                CTELockHandle   interLockHandle;

                                //      Push this connection into a ProcessRecv queue which will be
                                //      dealt with in receive completion.

                                DBGPRINT(RECEIVE, DBG,
                                                ("spxRecvTransferData: Queueing for recvp %lx.%lx\n",
                                                        pSpxConnFile, pSpxConnFile->scf_Flags));

                                //      Get the global q lock, push into recv list.
                                CTEGetLock(&SpxGlobalQInterlock, &interLockHandle);
                                SPX_QUEUE_FOR_RECV_COMPLETION(pSpxConnFile);
                                CTEFreeLock(&SpxGlobalQInterlock, interLockHandle);
                        }
                }
                else
                {
                        PBYTE                                           pData;
                        ULONG                                           dataLen;

                        //      Get pointer to the buffer descriptor and its memory.
                        NdisUnchainBufferAtFront(pNdisPkt, &pNdisBuffer);
                        if (pNdisBuffer != NULL)
                        {
                                NdisQueryBuffer(pNdisBuffer, &pData, &dataLen);
                                CTEAssert(pData != NULL);
                                CTEAssert((LONG)dataLen >= 0);

                                //      Free the data, ndis buffer.
                                if (pNdisBuffer != NULL)
                                {
                                        NdisFreeBuffer(pNdisBuffer);
                                }
                                SpxFreeMemory(pData);
                        }

                        //      Dont send ack, set status to be failure so we free packet/buffer.
                        fAck = FALSE;
                        NdisStatus = NDIS_STATUS_FAILURE;
                }
        }

        END_PROCESS_PACKET(
                pSpxConnFile, fBuffered, (NdisStatus == NDIS_STATUS_SUCCESS));

        if (fAck)
        {
                //      Rem ack addr should have been copied in receive.

                //      #17564
                if (fImmedAck                                                                                     ||
                        SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_NOACKWAIT) ||
                        SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_IMMED_ACK))
                {
                        SpxConnSendAck(pSpxConnFile, lockHandle);
                        fLockHeld = FALSE;
                }
                else
                {
                        SpxConnQWaitAck(pSpxConnFile);
                }
        }

        if (fLockHeld)
        {
                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
        }

        if (!fBuffered || (NdisStatus != STATUS_SUCCESS))
        {
                //      Free the ndis packet/buffer
                SpxPktRecvRelease(pNdisPkt);
        }

    return;
}




VOID
SpxReceiveComplete(
    IN  USHORT  NicId
    )

{
        CTELockHandle           lockHandleInter, lockHandle;
        PREQUEST                        pRequest;
        BOOLEAN                         fConnLockHeld, fInterlockHeld;
        PSPX_CONN_FILE          pSpxConnFile;
        int                                     numDerefs = 0;

        //      See if any connections need recv processing. This will also take
        //      care of any acks opening up window so our sends go to the max.
        CTEGetLock(&SpxGlobalQInterlock, &lockHandleInter);
        fInterlockHeld = TRUE;

        while ((pSpxConnFile = SpxRecvConnList.pcl_Head) != NULL)
        {
                //      Reset for each connection
                numDerefs = 0;

                if ((SpxRecvConnList.pcl_Head = pSpxConnFile->scf_ProcessRecvNext) == NULL)
            SpxRecvConnList.pcl_Tail    = NULL;

                //      Reset next field to NULL
        pSpxConnFile->scf_ProcessRecvNext = NULL;

                DBGPRINT(SEND, DBG,
                                ("SpxConnRemoveFromRecv: %lx\n", pSpxConnFile));

                CTEFreeLock(&SpxGlobalQInterlock, lockHandleInter);
                CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);

                do
                {
                        //      Complete pending requests.
                        while (!IsListEmpty(&pSpxConnFile->scf_ReqDoneLinkage))
                        {
                                pRequest =
                                        LIST_ENTRY_TO_REQUEST(pSpxConnFile->scf_ReqDoneLinkage.Flink);

                                RemoveEntryList(REQUEST_LINKAGE(pRequest));
                                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);

                                DBGPRINT(TDI, DBG,
                                                ("SpxReceiveComplete: Completing %lx with %lx.%lx\n",
                                                        pRequest, REQUEST_STATUS(pRequest),
                                                        REQUEST_INFORMATION(pRequest)));

                                CTEAssert (REQUEST_MINOR_FUNCTION(pRequest) != TDI_RECEIVE);
                                SpxCompleteRequest(pRequest);
                                numDerefs++;
                                CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
                        }

                        //      Call process pkts if we have any packets or if any receives to
                        //      complete. Note this will call even when there are no receives
                        //      queued and the first packet has already been indicated.
                        if ((SPX_RECV_STATE(pSpxConnFile) != SPX_RECV_PROCESS_PKTS) &&
                                        (!IsListEmpty(&pSpxConnFile->scf_RecvDoneLinkage) ||
                                        (pSpxConnFile->scf_RecvListHead != NULL)))
                        {
                                //      We have the flag reference on the connection.
                                SpxRecvProcessPkts(pSpxConnFile, lockHandle);
                                CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
                        }

#if DBG
                        if (!IsListEmpty(&pSpxConnFile->scf_RecvDoneLinkage))
                        {
                                DBGPRINT(TDI, DBG,
                                                ("SpxReceiveComplete: RecvDone left %lx\n",
                                                        pSpxConnFile));
                        }
#endif

                //      Hmm. This check is rather expensive, and essentially we are doing
                //      it twice. Should look to see if this can be modified safely.
                } while ((!IsListEmpty(&pSpxConnFile->scf_ReqDoneLinkage))                      ||
                                 ((SPX_RECV_STATE(pSpxConnFile) != SPX_RECV_PROCESS_PKTS) &&
                                  ((!IsListEmpty(&pSpxConnFile->scf_RecvDoneLinkage))     ||
                                   ((pSpxConnFile->scf_RecvListHead != NULL) &&
                                   ((pSpxConnFile->scf_RecvListHead->rr_State &
                                        (SPX_RECVPKT_BUFFERING | SPX_RECVPKT_INDICATED)) ==
                                                SPX_RECVPKT_BUFFERING)))));

                SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_RECVQ);
                SpxConnFileTransferReference(
                        pSpxConnFile,
                        CFREF_RECV,
                        CFREF_VERIFY);

                numDerefs++;
                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);

                while (numDerefs-- > 0)
                {
                        SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
                }

                CTEGetLock(&SpxGlobalQInterlock, &lockHandleInter);
        }


        //      First see if we need to packetize.
        while ((pSpxConnFile = SpxPktConnList.pcl_Head) != NULL)
        {
                if ((SpxPktConnList.pcl_Head = pSpxConnFile->scf_PktNext) == NULL)
            SpxPktConnList.pcl_Tail = NULL;

                //      Reset next field to NULL
        pSpxConnFile->scf_PktNext = NULL;

                CTEFreeLock(&SpxGlobalQInterlock, lockHandleInter);

                DBGPRINT(SEND, DBG,
                                ("SpxConnRemoveFromPkt: %lx\n", pSpxConnFile));

                CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
                fConnLockHeld = TRUE;

                DBGPRINT(RECEIVE, DBG,
                                ("SpxReceiveComplete: Packetizing %lx\n", pSpxConnFile));

                SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_PKTQ);
                if (SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_IDLE)
                {
                        SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_PACKETIZE);

			// 262691 SpxConnPacketize always frees the lock.
                        SpxConnPacketize(
                                        pSpxConnFile,
                                        TRUE,
                                        lockHandle);
                        fConnLockHeld = FALSE;
                }

                if (fConnLockHeld)
                {
                        CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
                }

                SpxConnFileDereference(pSpxConnFile, CFREF_PKTIZE);
                CTEGetLock(&SpxGlobalQInterlock, &lockHandleInter);
        }

        if (fInterlockHeld)
        {
                CTEFreeLock(&SpxGlobalQInterlock, lockHandleInter);
        }

    return;
}




//
//      PACKET HANDLING ROUTINES
//


VOID
SpxRecvSysPacket(
        IN  NDIS_HANDLE         MacBindingHandle,
        IN  NDIS_HANDLE         MacReceiveContext,
        IN  PIPX_LOCAL_TARGET   pRemoteAddr,
        IN  ULONG               MacOptions,
        IN  PUCHAR              LookaheadBuffer,
        IN  UINT                LookaheadBufferSize,
        IN  UINT                LookaheadBufferOffset,
        IN  UINT                PacketSize
        )
/*++

Routine Description:

        This is called to indicate an incoming system packet.

Arguments:


Return Value:


--*/

{
        NTSTATUS                        status;
        PIPXSPX_HDR                     pHdr;
        USHORT                          srcConnId, destConnId,
                                                pktLen, ackNum, allocNum;
        PSPX_CONN_FILE          pSpxConnFile;
        CTELockHandle           lockHandle;
        BOOLEAN                         lockHeld = FALSE;

        pHdr    = (PIPXSPX_HDR)LookaheadBuffer;

        //      check minimum length
        if (PacketSize < MIN_IPXSPX_HDRSIZE)
        {
                return;
        }

        //      Convert hdr to host format as needed.
        GETSHORT2SHORT(&pktLen, &pHdr->hdr_PktLen);
        GETSHORT2SHORT(&destConnId, &pHdr->hdr_DestConnId);

        if ((pktLen < MIN_IPXSPX_HDRSIZE)       ||
                (pktLen > PacketSize)                   ||
                (pHdr->hdr_PktType != SPX_PKT_TYPE))
        {
         