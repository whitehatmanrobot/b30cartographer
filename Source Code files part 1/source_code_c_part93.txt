on top of the PDO
    //
    //

    lowerDevice = IoAttachDeviceToDeviceStack(fdo,Pdo);

    //
    // No status. Do the best we can.
    //
    if (lowerDevice == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanupExit;
    };

    deviceExtension->LowerDevice = lowerDevice;
    deviceExtension->Pdo = Pdo;

    status = IoGetDeviceProperty(Pdo,
                                 DevicePropertyLegacyBusType,
                                 sizeof(INTERFACE_TYPE),
                                 (PVOID)&deviceExtension->InterfaceType,
                                 &resultLength);

    if (!NT_SUCCESS(status)) {
        //
        // Probably a legacy pcic device
        //
        deviceExtension->InterfaceType = InterfaceTypeUndefined;
    }

    //
    // Get our controller type
    //

    deviceExtension->ControllerType = PcmciaInvalidControllerType;


    if (deviceExtension->InterfaceType == PCIBus) {

        status = PcmciaGetPciControllerType(Pdo, fdo);
        if (!NT_SUCCESS(status)) {
            goto cleanupExit;
        }

    } else {
        PCMCIA_CONTROLLER_TYPE controllerType;

        status = PcmciaGetLegacyDetectedControllerType(deviceExtension->Pdo,
                                                       &controllerType);

        if (NT_SUCCESS(status)) {
            PcmciaSetControllerType(deviceExtension, controllerType);
        }
    }

    //
    // Do some cardbus specific initialization
    //
    if (CardBusExtension(deviceExtension)) {
        BOOLEAN OnDebugPath;
        ACPI_INTERFACE_STANDARD AcpiInterface;
        USHORT word;
        //
        // Get the pci/cardbus private interface
        //
        status = PcmciaGetInterface(Pdo,
                                    &GUID_PCI_CARDBUS_INTERFACE_PRIVATE,
                                    sizeof(PCI_CARDBUS_INTERFACE_PRIVATE),
                                    (PINTERFACE) &deviceExtension->PciCardBusInterface
                                    );

        if (!NT_SUCCESS(status)) {
            goto cleanupExit;
        }

        status = deviceExtension->PciCardBusInterface.GetLocation(Pdo,
                                                                  &deviceExtension->PciBusNumber,
                                                                  &deviceExtension->PciDeviceNumber,
                                                                  &deviceExtension->PciFunctionNumber,
                                                                  &OnDebugPath);

        if (!NT_SUCCESS(status)) {
            goto cleanupExit;
        }

        if (OnDebugPath) {
            SetDeviceFlag(deviceExtension, PCMCIA_FDO_ON_DEBUG_PATH);
        }

        //
        // Get the pci interface for reading/writing to config header space
        //
        status = PcmciaGetInterface(Pdo,
                                    &GUID_BUS_INTERFACE_STANDARD,
                                    sizeof(BUS_INTERFACE_STANDARD),
                                    (PINTERFACE) &deviceExtension->PciBusInterface);
        if (!NT_SUCCESS(status)) {
            goto cleanupExit;
        }

        //
        // Make sure IRQ routing is to isa. This has come up when installing from a pcmcia CD-rom.
        // What happens is that, after we start booting GUI mode, the controller is at first
        // in legacy PCIC mode (set by the bios to accomplish boot). At some point, the _INIT
        // method is run, and we switch to cardbus mode. So, under the following conditions:
        // 1) irq routing bit is still off
        // 2) cd-rom is asserting its interrupt
        // 3) host controller routes cd-rom interrupt to PCI
        // then we hang.
        //
        GetPciConfigSpace(deviceExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
        word |= BCTRL_IRQROUTING_ENABLE;
        SetPciConfigSpace(deviceExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);

        if (!(PcmciaGlobalFlags & PCMCIA_DISABLE_ACPI_NAMESPACE_CHECK)) {
            status = PcmciaGetInterface(fdo,
                                        &GUID_ACPI_INTERFACE_STANDARD,
                                        sizeof(ACPI_INTERFACE_STANDARD),
                                        (PINTERFACE) &AcpiInterface
                                        );

            if (NT_SUCCESS(status)) {
                SetFdoFlag(deviceExtension, PCMCIA_FDO_IN_ACPI_NAMESPACE);
            }
        }
    }

    //
    // Get settings from registry (potentially also compatible ControllerType)
    //

    PcmciaGetControllerRegistrySettings(deviceExtension);

    if ((deviceExtension->ControllerType == PcmciaInvalidControllerType)) {
        //
        // not really sure what this is... maybe it's a PNP0E00 on a boot. Just do
        // the least common denominator
        //
        PcmciaSetControllerType(deviceExtension, PcmciaIntelCompatible);
    }


    //
    // Link this fdo to the list of fdo's managed by the driver
    //

    DebugPrint((PCMCIA_DEBUG_PNP, "FDO %08X now linked to fdolist by AddDevice\n", fdo));
    deviceExtension->NextFdo = FdoList;
    FdoList = fdo;

    fdo->Flags &= ~DO_DEVICE_INITIALIZING;

    return STATUS_SUCCESS;

cleanupExit:
    MarkDeviceDeleted(deviceExtension);
    //
    // Cannot support a controller without knowing its type etc.
    //
    if (deviceExtension->LinkName.Buffer) {
        IoDeleteSymbolicLink(&deviceExtension->LinkName);
        ExFreePool(deviceExtension->LinkName.Buffer);
    }

    if (deviceExtension->LowerDevice) {
        IoDetachDevice(deviceExtension->LowerDevice);
    }

    IoDeleteDevice(fdo);
    return status;
}



NTSTATUS
PcmciaCreateFdo(
    IN PDRIVER_OBJECT DriverObject,
    OUT PDEVICE_OBJECT *NewDeviceObject
    )

/*++

Routine Description:

    This routine will create and initialize a functional device object to
    be attached to a Pcmcia controller PDO.

Arguments:

    DriverObject - a pointer to the driver object this is created under
    DeviceObject - a location to store the pointer to the new device object

Return Value:

    STATUS_SUCCESS if everything was successful
    reason for failure otherwise

--*/

{
    UCHAR deviceNameBuffer[64];
    LONG deviceNumber = -1;
    ANSI_STRING ansiDeviceName;
    UNICODE_STRING unicodeDeviceName;
    UNICODE_STRING unicodeLinkName;

    PDEVICE_OBJECT deviceObject = NULL;
    PFDO_EXTENSION deviceExtension = NULL;
    BOOLEAN LinkCreated = FALSE;

    ULONG count;

    NTSTATUS status=STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Zero out allocated memory pointers so we know if they must be freed
    //

    RtlZeroMemory(&ansiDeviceName, sizeof(ANSI_STRING));
    RtlZeroMemory(&unicodeDeviceName, sizeof(UNICODE_STRING));
    RtlZeroMemory(&unicodeLinkName, sizeof(UNICODE_STRING));


    //
    // Run in a loop incrementing the device number count until we either
    // get an error or find a name that's not taken
    //

    try {

        if (pcmciaIoctlInterface) {
            do {
                //
                // free buffer from previous loop
                //
                if (unicodeDeviceName.Buffer != NULL) {
                    RtlFreeUnicodeString(&unicodeDeviceName);
                    unicodeDeviceName.Buffer = NULL;
                }

                //
                // create the device name
                //
                sprintf(deviceNameBuffer, "%s%d", PCMCIA_DEVICE_NAME, ++deviceNumber);

                RtlInitAnsiString(&ansiDeviceName, deviceNameBuffer);

                status = RtlAnsiStringToUnicodeString(
                                                                 &unicodeDeviceName,
                                                                 &ansiDeviceName,
                                                                 TRUE);

                if (!NT_SUCCESS(status)) {

                    DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaCreateFdo: Error creating unicode "
                                    "string [%#08lx]\n",
                                    status));
                    leave;
                }

                //
                // create the device object
                //

                status = IoCreateDevice(DriverObject,
                                        sizeof(FDO_EXTENSION),
                                        &unicodeDeviceName,
                                        FILE_DEVICE_CONTROLLER,
                                        FILE_DEVICE_SECURE_OPEN,
                                        FALSE,
                                        &deviceObject);

            } while ((status == STATUS_OBJECT_NAME_EXISTS) ||
                        (status == STATUS_OBJECT_NAME_COLLISION));

        } else {
            status = IoCreateDevice(DriverObject,
                                    sizeof(FDO_EXTENSION),
                                    NULL,
                                    FILE_DEVICE_CONTROLLER,
                                    FILE_DEVICE_SECURE_OPEN,
                                    FALSE,
                                    &deviceObject);
        }

        if (!NT_SUCCESS(status)) {

            DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaCreateFdo: Error creating device object "
                            "[%#08lx]\n",
                            status));
            leave;
        }

        //
        // Set up the device extension.
        //
        deviceExtension = deviceObject->DeviceExtension;
        deviceExtension->Signature  = PCMCIA_FDO_EXTENSION_SIGNATURE;
        deviceExtension->DeviceObject = deviceObject;
        deviceExtension->RegistryPath = DriverRegistryPath;
        deviceExtension->DriverObject = DriverObject;
        deviceExtension->PdoList        = NULL;
        deviceExtension->LivePdoCount = 0;
        deviceExtension->Flags          = PCMCIA_FDO_OFFLINE;
        deviceExtension->WaitWakeState= WAKESTATE_DISARMED;

        // Setup symbolic link for VDDs
        //
        //
        // create the link name (reuse the device name buffers for this)
        //

        if (pcmciaIoctlInterface) {
            SetDeviceFlag(deviceExtension, PCMCIA_FDO_IOCTL_INTERFACE_ENABLED);

            sprintf(deviceNameBuffer,"%s%d", PCMCIA_LINK_NAME, deviceNumber);

            RtlInitAnsiString(&ansiDeviceName, deviceNameBuffer);

            status = RtlAnsiStringToUnicodeString(
                                                  &unicodeLinkName,
                                                  &ansiDeviceName,
                                                  TRUE);

            if (!NT_SUCCESS(status)) {

                DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaCreateFdo: Error creating unicode "
                                "string [%#08lx]\n",
                                status));
                leave;
            }

            status = IoCreateSymbolicLink(&unicodeLinkName, &unicodeDeviceName);

            if (!NT_SUCCESS(status)) {
                DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaCreateFdo: Symbolic Link was not created\n"));
                leave;
            }

            LinkCreated = TRUE;
            deviceExtension->LinkName = unicodeLinkName;
        }


        //
        // Lock for synching device access
        //
        PCMCIA_INITIALIZE_DEVICE_LOCK(deviceExtension);

        *NewDeviceObject = deviceObject;

    } finally {


        DebugPrint((PCMCIA_DEBUG_INFO, "PcmciaCreateFdo: Cleanup\n"));

        //
        //
        // deallocate temporary objects
        //

        if (unicodeDeviceName.Buffer != NULL) {
            RtlFreeUnicodeString(&unicodeDeviceName);
        }

        //
        // destroy objects if there was an error
        //
        if (!NT_SUCCESS(status)) {
            if (LinkCreated) {
                IoDeleteSymbolicLink(&unicodeLinkName);
            }

            if (unicodeLinkName.Buffer != NULL) {
                RtlFreeUnicodeString(&unicodeLinkName);
            }

            if (deviceObject != NULL) {
                MarkDeviceDeleted(deviceExtension);
                IoDeleteDevice(deviceObject);
            }
        }
    }
    return status;
}



NTSTATUS
PcmciaStartPcmciaController(
    IN PDEVICE_OBJECT Fdo
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    PFDO_EXTENSION  deviceExtension = Fdo->DeviceExtension;
    PSOCKET socket;
    BOOLEAN             sharedInterrupt;
    KINTERRUPT_MODE interruptMode;
    NTSTATUS            status;
    INTERFACE_TYPE  interfaceType;

    //
    // Now the controller registers should be accessible
    //
    deviceExtension->Flags &= ~PCMCIA_FDO_OFFLINE;

    //
    // Set up the socket list
    //

    if (!deviceExtension->SocketList) {
        if (CardBusExtension(deviceExtension)) {

            status = CBBuildSocketList(deviceExtension);

        } else {

            switch (deviceExtension->ControllerType) {
            case PcmciaIntelCompatible:
            case PcmciaElcController:
            case PcmciaCLPD6729:
            case PcmciaPciPcmciaBridge:
            case PcmciaNEC98:
            case PcmciaNEC98102: {
                    status = PcicBuildSocketList(deviceExtension);
                    break;
                }

            case PcmciaDatabook: {
                    status = TcicBuildSocketList(deviceExtension);
                    break;
                }
            default:
                status = STATUS_UNSUCCESSFUL;
            }
        }

        if (!NT_SUCCESS(status)) {
            return status;
        }

    }

    //
    // Get the IRQ mask for the controller. This is based on several
    // values in the registry.
    //
    PcmciaGetRegistryFdoIrqMask(deviceExtension);


    deviceExtension->SystemPowerState = PowerSystemWorking;
    deviceExtension->DevicePowerState = PowerDeviceD0;

    //
    // Initialize our DpcForIsr
    //
    IoInitializeDpcRequest(Fdo, PcmciaInterruptDpc);

    //
    // Initialize socket objects
    //
    for (socket = deviceExtension->SocketList; socket; socket = socket->NextSocket) {

        socket->Signature = PCMCIA_SOCKET_SIGNATURE;
        socket->PdoList = NULL;
        //
        // Initialize the ready enable event.
        //
        KeInitializeEvent(&socket->PCCardReadyEvent,
                          SynchronizationEvent,
                          FALSE
                          );
        //
        // Initialize power objects
        //
        KeInitializeTimer(&socket->PowerTimer);
        KeInitializeDpc(&socket->PowerDpc, PcmciaSocketPowerWorker, socket);

        socket->FdoIrq = deviceExtension->Configuration.Interrupt.u.Interrupt.Vector;
    }

    //
    // Assume we are going to poll
    //
    deviceExtension->Flags |= PCMCIA_USE_POLLED_CSC;
    deviceExtension->PcmciaInterruptObject = NULL;

    if ((deviceExtension->Configuration.Interrupt.u.Interrupt.Level != 0) &&
         CardBusExtension(deviceExtension) &&
         !(PcmciaGlobalFlags & PCMCIA_GLOBAL_FORCE_POLL_MODE)) {

        //
        // Hook up the controller interrupt for detecting pc-card plug ins/outs
        //
        interruptMode=((deviceExtension->Configuration.Interrupt.Flags & CM_RESOURCE_INTERRUPT_LATCHED) == CM_RESOURCE_INTERRUPT_LATCHED) ? Latched:LevelSensitive;

        sharedInterrupt=(deviceExtension->Configuration.Interrupt.ShareDisposition == CmResourceShareShared)?
                             TRUE:FALSE;


        status = IoConnectInterrupt(&(deviceExtension->PcmciaInterruptObject),
                                    (PKSERVICE_ROUTINE) PcmciaInterrupt,
                                    (PVOID) Fdo,
                                    NULL,
                                    deviceExtension->Configuration.TranslatedInterrupt.u.Interrupt.Vector,
                                    (KIRQL) deviceExtension->Configuration.TranslatedInterrupt.u.Interrupt.Level,
                                    (KIRQL) deviceExtension->Configuration.TranslatedInterrupt.u.Interrupt.Level,
                                    interruptMode,
                                    sharedInterrupt,
                                    (KAFFINITY) deviceExtension->Configuration.TranslatedInterrupt.u.Interrupt.Affinity,
                                    FALSE);
        if (!NT_SUCCESS(status)) {

            DebugPrint((PCMCIA_DEBUG_FAIL, "Unable to connect interrupt\n"));
        } else {
            //
            // We connected. Turn off poll mode
            //
            deviceExtension->Flags &= ~PCMCIA_USE_POLLED_CSC;
        }
    }


    status = PcmciaInitializeController(Fdo);

    if (!NT_SUCCESS(status)) {
        DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaStartAdapter: PcmciaInitializeFdo failed\n"));
        return status;
    }


    if (deviceExtension->Flags & PCMCIA_USE_POLLED_CSC) {
        LARGE_INTEGER dueTime;

        KeInitializeDpc(&deviceExtension->TimerDpc, PcmciaTimerDpc, deviceExtension->DeviceObject);

        KeInitializeTimer(&deviceExtension->PollTimer);

        //
        // Set first fire to twice the peroidic interval - just
        //
        dueTime.QuadPart = -PCMCIA_CSC_POLL_INTERVAL * 1000 * 10 * 2;

        KeSetTimerEx(&(deviceExtension->PollTimer),
                     dueTime,
                     PCMCIA_CSC_POLL_INTERVAL,
                     &deviceExtension->TimerDpc
                     );
    }
    return STATUS_SUCCESS;
}



NTSTATUS
PcmciaInitializeController(
    IN PDEVICE_OBJECT Fdo
    )
/*++

Routine Description:

    Initializes the pcmcia controller

Arguments:

    Fdo - pointer to the device object for the controller

Return value:

    STATUS_SUCCESS - if initialization is successful

--*/
{
    PFDO_EXTENSION fdoExtension=Fdo->DeviceExtension;
    PSOCKET socket;
    NTSTATUS    status = STATUS_SUCCESS;

    //
    // do vendor-specific init of controller
    //

    if (DeviceDispatchTable[fdoExtension->DeviceDispatchIndex].InitController) {
        (*DeviceDispatchTable[fdoExtension->DeviceDispatchIndex].InitController)(fdoExtension);
    }

    //
    // If LegacyIrqMask is not filled in, put a generic mask there in case we need it
    //
    if (fdoExtension->LegacyIrqMask == 0) {
        fdoExtension->LegacyIrqMask = (USHORT)(*(fdoExtension->SocketList->SocketFnPtr->PCBGetIrqMask))(fdoExtension);
    }

    fdoExtension->LegacyIrqMask &= ~globalFilterIrqMask;

    for (socket = fdoExtension->SocketList; socket; socket = socket->NextSocket) {

        if (!(*(socket->SocketFnPtr->PCBInitializePcmciaSocket))(socket)) {
            status = STATUS_UNSUCCESSFUL;
            break;
        }

        PcmciaGetSocketStatus(socket);

        PcmciaSetZV(fdoExtension, socket, FALSE);

        ResetSocketFlag(socket, SOCKET_ENABLED_FOR_CARD_DETECT);

        if (!(fdoExtension->Flags & PCMCIA_USE_POLLED_CSC) && (socket->FdoIrq != 0)) {

            if ((*(socket->SocketFnPtr->PCBEnableDisableCardDetectEvent))(socket, TRUE)) {
                //
                // card detect event was successfully enabled
                //
                SetSocketFlag(socket, SOCKET_ENABLED_FOR_CARD_DETECT);

            } else {

                DebugPrint((PCMCIA_DEBUG_FAIL, "fdo %x failed to enable card detect event on IRQ %x\n",
                                                         Fdo, fdoExtension->Configuration.Interrupt.u.Interrupt.Vector));
            }
        }
    }

    return status;
}




VOID
PcmciaTimerDpc(
    IN PKDPC            Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID            SystemContext1,
    IN PVOID            SystemContext2
    )
/*++

Routine Description

    This routine polls for card insertions or deletions
    for the given PCMCIA controller. If a card status change
    condition is detected, it invokes the appropriate DPC
    to process the card arrival/departure.

Arguments

    Dpc              - Pointer to the Dpc object
    DeviceObject - Pointer to the FDO of the PCMCIA controller that should be polled

Return Value

    None

--*/

{

    PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PSOCKET         socket;
    BOOLEAN         isCardInSocket, wasCardInSocket, callDpc = FALSE;

    if (fdoExtension->Flags & PCMCIA_FDO_OFFLINE) {
        return;
    }

    if (!ValidateController(fdoExtension)) {
        //
        // Something is wrong with the controller, hopefully it is just
        // temporary. For now, do nothing
        //
        return;
    }

    for (socket = fdoExtension->SocketList; socket; socket = socket->NextSocket) {

        isCardInSocket = (*(socket->SocketFnPtr->PCBDetectCardInSocket))(socket);
        wasCardInSocket = IsCardInSocket(socket);

        if (isCardInSocket != wasCardInSocket) {
            DebugPrint((PCMCIA_DEBUG_INFO, "PcmciaTimerDpc: Setting socket %x change interrupt,  cardInSocket=%x Socket->Flags=%x\n", socket, isCardInSocket, socket->Flags));
            SetSocketFlag(socket, SOCKET_CHANGE_INTERRUPT);
            callDpc = TRUE;
        }
    }

    if (callDpc) {
        LARGE_INTEGER dueTime;

        KeCancelTimer(&fdoExtension->EventTimer);
        dueTime.QuadPart = -((LONG)EventDpcDelay*10);
        KeSetTimer(&fdoExtension->EventTimer, dueTime, &fdoExtension->EventDpc);
    }
}



BOOLEAN
PcmciaInterrupt(
    IN PKINTERRUPT InterruptObject,
    PVOID Context
    )

/*++

Routine Description:

    interrupt handler

Arguments:

    InterruptObject - Pointer to the interrupt object.
    Context - Pointer to the device context.

Return Value:

    Status

--*/

{
    PFDO_EXTENSION  deviceExtension;
    PSOCKET             socket;
    BOOLEAN             statusChanged = FALSE;

    deviceExtension=((PDEVICE_OBJECT)Context)->DeviceExtension;

    if (deviceExtension->Flags & PCMCIA_FDO_OFFLINE) {
        return FALSE;
    }

    if (!ValidateController(deviceExtension)) {
        //
        // the controller is broken in some way. Treat like a spurious int
        //
        ASSERT(FALSE);
        return FALSE;
    }

    //
    // Interrupted because of a card removal, or a card insertion.
    //
    for (socket = deviceExtension->SocketList; socket; socket = socket->NextSocket) {
        //
        // Check if the card status changed
        //
        if ((*(socket->SocketFnPtr->PCBDetectCardChanged))(socket)) {
            DebugPrint((PCMCIA_DEBUG_ISR, "skt %x card change\n", socket));
            if (deviceExtension->DevicePowerState == PowerDeviceD0) {
                SetSocketFlag(socket, SOCKET_CHANGE_INTERRUPT);
            }
            statusChanged = TRUE;
        }

        socket->ReadyChanged = (*(socket->SocketFnPtr->PCBDetectReadyChanged))(socket);

        if (socket->ReadyChanged) {
            DebugPrint((PCMCIA_DEBUG_ISR, "skt %x Ready changed\n", socket));
            statusChanged = TRUE;
        }

        //
        // Clear card status interrupt, probably leftover from wait/wake
        //

        if ((socket->SocketFnPtr->PCBDetectCardStatus)) {
            (*(socket->SocketFnPtr->PCBDetectCardStatus))(socket);
        }

    }

    if (statusChanged && (deviceExtension->DevicePowerState == PowerDeviceD0)) {
        //
        // Something changed out there.. could be
        // a card insertion/removal.
        // Request a DPC to check it out.
        //
        IoRequestDpc((PDEVICE_OBJECT) Context, NULL, NULL);
    }
    return statusChanged;
}



VOID
PcmciaInterruptDpc(
    IN PKDPC            Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID            SystemContext1,
    IN PVOID            SystemContext2
    )

/*++

Routine Description:

    This DPC is just an intermediate step in getting to the main DPC
    handler. This is used to "debounce" hardware and give it some time after
    the physical interrupt has come in.

Arguments:

    DeviceObject - Pointer to the device object.

Return Value:


--*/

{
    PFDO_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    LARGE_INTEGER dueTime;

    KeCancelTimer(&deviceExtension->EventTimer);
    dueTime.QuadPart = -((LONG)EventDpcDelay*10);
    KeSetTimer(&deviceExtension->EventTimer, dueTime, &deviceExtension->EventDpc);
}



VOID
PcmciaDpc(
    IN PKDPC            Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID            SystemContext1,
    IN PVOID            SystemContext2
    )

/*++

Routine Description:

    This deferred procedure will be called due to a request for DPC
    from the interrupt routine.    The device object passed contains
    information concerning which sockets have changed.  Search this
    list and free/clean up any sockets that used to have PCCards.

Arguments:

    DeviceObject - Pointer to the device object.

Return Value:


--*/

{
    PFDO_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PSOCKET                     socket;

    if (fdoExtension->Flags & PCMCIA_FDO_OFFLINE) {
        return;
    }

    DebugPrint((PCMCIA_DEBUG_DPC, "PcmciaDpc: Card Status Change DPC entered...\n"));

    //
    // For synchronization with the enumeration & removal
    // routines which have a tendency to pop off pdo's
    // etc
    //
    PCMCIA_ACQUIRE_DEVICE_LOCK_AT_DPC_LEVEL(fdoExtension);

    for (socket = fdoExtension->SocketList; socket; socket = socket->NextSocket) {

        if (socket->ReadyChanged) {
            KeSetEvent(&socket->PCCardReadyEvent, 0, FALSE);
        }

        if (IsSocketFlagSet(socket,SOCKET_CHANGE_INTERRUPT)) {
            DebugPrint((PCMCIA_DEBUG_DPC, "PcmciaDpc: Socket %x has SOCKET_CHANGE_INTERRUPT set\n", socket));
            //
            // This socket has changed status
            //
            ResetSocketFlag(socket, SOCKET_CHANGE_INTERRUPT);
            ResetSocketFlag(socket, SOCKET_SUPPORT_MESSAGE_SENT);
            SetSocketFlag(socket, SOCKET_CARD_STATUS_CHANGE);

            if ((*(socket->SocketFnPtr->PCBDetectCardInSocket))(socket)) {
                //
                // Assume we have a single function card here.
                // This will be corrected by when we parse the tuple data (for an R2 card)
                // or PCI returns more than one PDO (for a cardbus card)
                //
                socket->NumberOfFunctions = 1;
                ResetSocketFlag(socket, SOCKET_CARD_MULTIFUNCTION);
                //
                // If we get a physical plug in, then we better clean up even if we didn't
                // get the remove yet.
                //
                ResetSocketFlag(socket, SOCKET_CLEANUP_PENDING);
                ResetSocketFlag(socket, SOCKET_ENUMERATE_PENDING);

            } else {

                if (socket->PdoList) {
                    PPDO_EXTENSION pdoExtension;
                    PDEVICE_OBJECT pdo;
                    //
                    // Mark all the pdo's which hang off this socket (more than one possible only
                    // if this is a Multifunction PC-Card)
                    //
                    for (pdo = socket->PdoList; pdo!=NULL; pdo=pdoExtension->NextPdoInSocket) {
                        pdoExtension = pdo->DeviceExtension;
                        MarkDevicePhysicallyRemoved(pdoExtension);
                    }
                }

                //
                // Hack for Topic95 controllers staying in 3.3v
                //
                if (fdoExtension->ControllerType == PcmciaTopic95) {
                    ULONG state = CBReadSocketRegister(socket, CARDBUS_SOCKET_PRESENT_STATE_REG);

                    if ((state & CARDBUS_CB_CARD) && !(state & (CARDBUS_CD1 | CARDBUS_CD2))) {
                        state &= ~(SKTFORCE_CBCARD | SKTFORCE_3VCARD);
                        CBWriteSocketRegister(socket, CARDBUS_SOCKET_FORCE_EVENT_REG, state);
                    }
                }

                //
                // Clear power requirements
                //
                socket->Vcc = socket->Vpp1 = socket->Vpp2 = 0;

                //
                // Make sure i/o arbiter is not hanging on the devnode
                //
                if (CardBusExtension(fdoExtension)) {
                    IoInvalidateDeviceState(fdoExtension->Pdo);
                }
            }
        }
    }

    PCMCIA_RELEASE_DEVICE_LOCK_FROM_DPC_LEVEL(fdoExtension);

    IoInvalidateDeviceRelations(fdoExtension->Pdo, BusRelations);

    return;
}



VOID
PcmciaSetControllerType(
    IN PFDO_EXTENSION FdoExtension,
    IN PCMCIA_CONTROLLER_TYPE ControllerType
    )
/*++
Routine Description

    This routine does the housekeeping for setting the controller type,
    and the corresponding device index.

Arguments

    FdoExtension - Pointer to device extension for the pcmcia controller
    ControllerType - new controller type to set into the extension

Return Value

    None. Must succeed.

--*/
{
    PCMCIA_CONTROLLER_CLASS ctlClass;
    ULONG index;

    FdoExtension->ControllerType = ControllerType;
    ctlClass = PcmciaClassFromControllerType(FdoExtension->ControllerType);

    //
    // first assume cardbus
    //
    MarkDeviceCardBus(FdoExtension);

    switch(ctlClass) {
        case PcmciaIntelCompatible:
        case PcmciaPciPcmciaBridge:
        case PcmciaElcController:
        case PcmciaDatabook:
        case PcmciaNEC_98:
            MarkDevice16Bit(FdoExtension);
            break;

        case PcmciaCirrusLogic:
            if (ControllerType == PcmciaCLPD6729) {
                MarkDevice16Bit(FdoExtension);
            }
            break;
    }


    //
    // Look up the device in our dispatch table
    //
    for (index = 0; DeviceDispatchTable[index].ControllerClass != PcmciaInvalidControllerClass; index++) {
        if (DeviceDispatchTable[index].ControllerClass == ctlClass) {
            FdoExtension->DeviceDispatchIndex = index;
            break;
        }
    }


    FdoExtension->Flags &= ~PCMCIA_MEMORY_24BIT;

    if (!HasWindowPageRegister(FdoExtension)) {
        FdoExtension->Flags |= PCMCIA_MEMORY_24BIT;
    }

    if ((FdoExtension->InterfaceType == InterfaceTypeUndefined) ||
         (FdoExtension->InterfaceType == Isa)) {
        FdoExtension->Flags |= PCMCIA_MEMORY_24BIT;
    }


    switch(ControllerType) {
        case PcmciaTI1031:
        case PcmciaTI1130:
            //
            // restrict memory ranges for PDO's to 24bit
            // (because of missing "window page" functionality).
            //
            FdoExtension->Flags |= PCMCIA_MEMORY_24BIT;
            break;

    }


    DebugPrint((PCMCIA_DEBUG_INFO, "fdo %08x Controller Type %x\n",
                                                FdoExtension->DeviceObject, ControllerType));

}



NTSTATUS
PcmciaGetPciControllerType(
    IN PDEVICE_OBJECT Pdo,
    IN PDEVICE_OBJECT Fdo
    )
/*++

Routine Description:
    Look at the PCI hardware ID to see if it is already a device we know about. If so,
    set the appropriate controller type in the fdoExtension.

Arguments:
    Pdo - Physical Device object for the Pcmcia controller owned by the PCI driver
    Fdo - Functional Device object for the pcmcia controller owned by this driver, whose
            extension will store the relevant controller information upon exit from this routine.

Return Value:
    STATUS_SUCCESS              Things are fine and information obtained
    STATUS_NOT_SUPPORTED        This is actually a healthy status for this routine: all it means
                                         is that this PDO is not on a PCI bus, so no information needs to be
                                         obtained anyways.
    Any other status                 Failure. Caller probably needs to back out & not support this controller
--*/
{
    PFDO_EXTENSION fdoExtension  = Fdo->DeviceExtension;
    PIRP                                        irp;
    IO_STATUS_BLOCK                     statusBlock;
    PIO_STACK_LOCATION                  irpSp;
    PCI_COMMON_CONFIG                   pciConfig;
    PPCI_CONTROLLER_INFORMATION     id;
    PPCI_VENDOR_INFORMATION             vid;
    KEVENT                                  event;
    NTSTATUS                                status;
    BOOLEAN                                 foundController = FALSE;

    PAGED_CODE();
    //
    // Allocate & initialize an Irp (IRP_MN_READ_CONFIG) to be sent down
    // to the PCI bus driver to get config. header for this controller
    //
    // Following is all standard stuff to send an IRP down - needs no documentation

    //
    // Fresh PDO. No need to jump through hoops to get attached devices
    //
    KeInitializeEvent (&event, NotificationEvent, FALSE);
    irp = IoBuildSynchronousFsdRequest( IRP_MJ_PNP,
                                                    Pdo,
                                                    NULL,
                                                    0,
                                                    0,
                                                    &event,
                                                    &statusBlock
                                                 );

    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;

    irpSp = IoGetNextIrpStackLocation(irp);

    irpSp->MinorFunction = IRP_MN_READ_CONFIG;

    irpSp->Parameters.ReadWriteConfig.WhichSpace = PCI_WHICHSPACE_CONFIG;
    irpSp->Parameters.ReadWriteConfig.Buffer = &pciConfig;
    irpSp->Parameters.ReadWriteConfig.Offset = 0;
    irpSp->Parameters.ReadWriteConfig.Length = sizeof(pciConfig);


    status = IoCallDriver(Pdo, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = statusBlock.Status;
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }
    //
    // Now weed out the critical information from the config header and
    // store it away in the fdo's extension
    //

    if (pciConfig.SubClass == PCI_SUBCLASS_BR_PCMCIA) {

        PcmciaSetControllerType(fdoExtension, PcmciaPciPcmciaBridge);

    } else if (pciConfig.SubClass == PCI_SUBCLASS_BR_CARDBUS) {

        PcmciaSetControllerType(fdoExtension, PcmciaCardBusCompatible);

    } else {
        //
        // Unknown controller
        //
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Look up the PCI device id in our table
    //
    for (id = (PPCI_CONTROLLER_INFORMATION) PciControllerInformation;id->VendorID != PCI_INVALID_VENDORID; id++) {
        if ((id->VendorID == pciConfig.VendorID) && (id->DeviceID == pciConfig.DeviceID)) {

            PcmciaSetControllerType(fdoExtension, id->ControllerType);
            foundController = TRUE;

            break;
        }
    }

    //
    // Didn't find a specific vendor/device id, try to just base it on the vendor id
    //
    if (!foundController) {
        for (vid = (PPCI_VENDOR_INFORMATION) PciVendorInformation;vid->VendorID != PCI_INVALID_VENDORID; vid++) {
            if (vid->VendorID == pciConfig.VendorID) {

                PcmciaSetControllerType(fdoExtension, vid->ControllerClass);
                break;
            }
        }
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\db.c ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    db.c

Abstract:

    This module contains the code that contains
    Databook carbus controller specific initialization and
    other dispatches

Author:

    Ravisankar Pudipeddi (ravisp) 1-Nov-97


Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"



VOID
DBInitialize(IN PFDO_EXTENSION FdoExtension)
/*++

Routine Description:

    Initialize Databook cardbus controllers

Arguments:

    FdoExtension - Pointer to the device extension for the controller FDO

Return Value:

    None
--*/
{

    PcicWriteSocket(FdoExtension->SocketList,
                    PCIC_INTERRUPT,
                    (UCHAR) (PcicReadSocket(FdoExtension->SocketList, PCIC_INTERRUPT)
                                           | IGC_INTR_ENABLE));
}


BOOLEAN
DBSetZV(
    IN PSOCKET Socket,
    IN BOOLEAN Enable
    )
{

    if (Enable) {
        PcicWriteSocket(Socket, PCIC_DBK_ZV_ENABLE, DBK_ZVE_MM_MODE);
    } else {
        PcicWriteSocket(Socket, PCIC_DBK_ZV_ENABLE, DBK_ZVE_STANDARD_MODE);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\debug.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module provides debugging support.

Author:

    Neil Sandlin (neilsa) 10-Aug-98
       - code merged from mf.sys and pcmcia.sys

Revision History:


--*/


#include "pch.h"

//
// Get mappings from status codes to strings
//

#include <ntstatus.dbg>

#undef MAP
#define MAP(_Value) { (_Value), #_Value }
#define END_STRING_MAP  { 0xFFFFFFFF, NULL }
#if DBG

typedef struct _DBG_MASK_STRING {
    ULONG Mask;
    PUCHAR String;
} DBG_MASK_STRING, *PDBG_MASK_STRING;


DBG_MASK_STRING MaskStrings[] = {
    PCMCIA_DEBUG_FAIL,      "ERR",
    PCMCIA_DEBUG_INFO,      "INF",
    PCMCIA_DEBUG_PNP,       "PNP",
    PCMCIA_DEBUG_POWER,     "PWR",
    PCMCIA_DEBUG_SOCKET,    "SKT",
    PCMCIA_DEBUG_CONFIG,    "CFG",
    PCMCIA_DEBUG_TUPLES,    "TPL",
    PCMCIA_DEBUG_RESOURCES, "RES",
    PCMCIA_DEBUG_ENUM,      "ENU",
    PCMCIA_DEBUG_INTERFACE, "IFC",
    PCMCIA_DEBUG_IOCTL,     "IOC",
    PCMCIA_DEBUG_DPC,       "DPC",
    PCMCIA_DEBUG_ISR,       "ISR",
    PCMCIA_PCCARD_READY,    "PCR",
    PCMCIA_DEBUG_DETECT,    "DET",
    PCMCIA_COUNTERS,            "CNT",
    PCMCIA_DEBUG_IRQMASK,   "MSK",
    PCMCIA_DUMP_SOCKET,     "DSK",
    0, NULL
    };


PPCMCIA_STRING_MAP PcmciaDbgStatusStringMap = (PPCMCIA_STRING_MAP) ntstatusSymbolicNames;

PCMCIA_STRING_MAP PcmciaDbgPnpIrpStringMap[] = {

    MAP(IRP_MN_START_DEVICE),
    MAP(IRP_MN_QUERY_REMOVE_DEVICE),
    MAP(IRP_MN_REMOVE_DEVICE),
    MAP(IRP_MN_CANCEL_REMOVE_DEVICE),
    MAP(IRP_MN_STOP_DEVICE),
    MAP(IRP_MN_QUERY_STOP_DEVICE),
    MAP(IRP_MN_CANCEL_STOP_DEVICE),
    MAP(IRP_MN_QUERY_DEVICE_RELATIONS),
    MAP(IRP_MN_QUERY_INTERFACE),
    MAP(IRP_MN_QUERY_CAPABILITIES),
    MAP(IRP_MN_QUERY_RESOURCES),
    MAP(IRP_MN_QUERY_RESOURCE_REQUIREMENTS),
    MAP(IRP_MN_QUERY_DEVICE_TEXT),
    MAP(IRP_MN_FILTER_RESOURCE_REQUIREMENTS),
    MAP(IRP_MN_READ_CONFIG),
    MAP(IRP_MN_WRITE_CONFIG),
    MAP(IRP_MN_EJECT),
    MAP(IRP_MN_SET_LOCK),
    MAP(IRP_MN_QUERY_ID),
    MAP(IRP_MN_QUERY_PNP_DEVICE_STATE),
    MAP(IRP_MN_QUERY_BUS_INFORMATION),
    MAP(IRP_MN_DEVICE_USAGE_NOTIFICATION),
    MAP(IRP_MN_SURPRISE_REMOVAL),
    MAP(IRP_MN_QUERY_LEGACY_BUS_INFORMATION),
    END_STRING_MAP
};


PCMCIA_STRING_MAP PcmciaDbgPoIrpStringMap[] = {

    MAP(IRP_MN_WAIT_WAKE),
    MAP(IRP_MN_POWER_SEQUENCE),
    MAP(IRP_MN_SET_POWER),
    MAP(IRP_MN_QUERY_POWER),
    END_STRING_MAP
};



PCMCIA_STRING_MAP PcmciaDbgDeviceRelationStringMap[] = {

    MAP(BusRelations),
    MAP(EjectionRelations),
    MAP(PowerRelations),
    MAP(RemovalRelations),
    MAP(TargetDeviceRelation),
    END_STRING_MAP

};

PCMCIA_STRING_MAP PcmciaDbgSystemPowerStringMap[] = {

    MAP(PowerSystemUnspecified),
    MAP(PowerSystemWorking),
    MAP(PowerSystemSleeping1),
    MAP(PowerSystemSleeping2),
    MAP(PowerSystemSleeping3),
    MAP(PowerSystemHibernate),
    MAP(PowerSystemShutdown),
    MAP(PowerSystemMaximum),
    END_STRING_MAP

};

PCMCIA_STRING_MAP PcmciaDbgDevicePowerStringMap[] = {

    MAP(PowerDeviceUnspecified),
    MAP(PowerDeviceD0),
    MAP(PowerDeviceD1),
    MAP(PowerDeviceD2),
    MAP(PowerDeviceD3),
    MAP(PowerDeviceMaximum),
    END_STRING_MAP

};

PCMCIA_STRING_MAP PcmciaDbgPdoPowerWorkerStringMap[] = {

    MAP(PPW_Stopped),
    MAP(PPW_Exit),
    MAP(PPW_InitialState),
    MAP(PPW_PowerUp),
    MAP(PPW_PowerDown),
    MAP(PPW_SendIrpDown),
    MAP(PPW_16BitConfigure),
    MAP(PPW_CardBusRefresh),
    MAP(PPW_CardBusDelay),

    END_STRING_MAP
};

PCMCIA_STRING_MAP PcmciaDbgFdoPowerWorkerStringMap[] = {

    MAP(FPW_Stopped),
    MAP(FPW_BeginPowerDown),
    MAP(FPW_PowerDown),
    MAP(FPW_PowerDownSocket),
    MAP(FPW_PowerDownComplete),
    MAP(FPW_BeginPowerUp),
    MAP(FPW_PowerUp),
    MAP(FPW_PowerUpSocket),
    MAP(FPW_PowerUpSocket2),
    MAP(FPW_PowerUpSocketVerify),
    MAP(FPW_PowerUpSocketComplete),
    MAP(FPW_PowerUpComplete),
    MAP(FPW_SendIrpDown),
    MAP(FPW_CompleteIrp),
    END_STRING_MAP
};

PCMCIA_STRING_MAP PcmciaDbgSocketPowerWorkerStringMap[] = {

    MAP(SPW_Stopped),
    MAP(SPW_Exit),
    MAP(SPW_RequestPower),
    MAP(SPW_ReleasePower),
    MAP(SPW_SetPowerOn),
    MAP(SPW_SetPowerOff),
    MAP(SPW_ResetCard),
    MAP(SPW_Deconfigure),

    END_STRING_MAP
};

PCMCIA_STRING_MAP PcmciaDbgConfigurationWorkerStringMap[] = {

    MAP(CW_Stopped),
    MAP(CW_InitialState),
    MAP(CW_ResetCard),
    MAP(CW_Phase1),
    MAP(CW_Phase2),
    MAP(CW_Phase3),
    MAP(CW_Exit),

    END_STRING_MAP
};


PCMCIA_STRING_MAP PcmciaDbgTupleStringMap[] = {

    MAP(CISTPL_NULL),
    MAP(CISTPL_DEVICE),
    MAP(CISTPL_INDIRECT),
    MAP(CISTPL_CONFIG_CB),
    MAP(CISTPL_CFTABLE_ENTRY_CB),
    MAP(CISTPL_LONGLINK_MFC),
    MAP(CISTPL_CHECKSUM),
    MAP(CISTPL_LONGLINK_A),
    MAP(CISTPL_LONGLINK_C),
    MAP(CISTPL_LINKTARGET),
    MAP(CISTPL_NO_LINK),
    MAP(CISTPL_VERS_1),
    MAP(CISTPL_ALTSTR),
    MAP(CISTPL_DEVICE_A),
    MAP(CISTPL_JEDEC_C),
    MAP(CISTPL_JEDEC_A),
    MAP(CISTPL_CONFIG),
    MAP(CISTPL_CFTABLE_ENTRY),
    MAP(CISTPL_DEVICE_OC),
    MAP(CISTPL_DEVICE_OA),
    MAP(CISTPL_GEODEVICE),
    MAP(CISTPL_GEODEVICE_A),
    MAP(CISTPL_MANFID),
    MAP(CISTPL_FUNCID),
    MAP(CISTPL_FUNCE),
    MAP(CISTPL_VERS_2),
    MAP(CISTPL_FORMAT),
    MAP(CISTPL_GEOMETRY),
    MAP(CISTPL_BYTEORDER),
    MAP(CISTPL_DATE),
    MAP(CISTPL_BATTERY),
    MAP(CISTPL_ORG),
    MAP(CISTPL_LONGLINK_CB),
    MAP(CISTPL_END),

    END_STRING_MAP
};


PCMCIA_STRING_MAP PcmciaDbgWakeStateStringMap[] = {

    MAP(WAKESTATE_DISARMED),
    MAP(WAKESTATE_WAITING),
    MAP(WAKESTATE_WAITING_CANCELLED),
    MAP(WAKESTATE_ARMED),
    MAP(WAKESTATE_ARMING_CANCELLED),
    MAP(WAKESTATE_COMPLETING),

    END_STRING_MAP
};


PCHAR
PcmciaDbgLookupString(
    IN PPCMCIA_STRING_MAP Map,
    IN ULONG Id
    )

/*++

Routine Description:

    Looks up the string associated with Id in string map Map

Arguments:

    Map - The string map

    Id - The id to lookup

Return Value:

    The string

--*/

{
    PPCMCIA_STRING_MAP current = Map;

    while(current->Id != 0xFFFFFFFF) {

        if (current->Id == Id) {
            return current->String;
        }

        current++;
    }

    return "** UNKNOWN **";
}


VOID
PcmciaDebugPrint(
                 ULONG  DebugMask,
                 PCCHAR DebugMessage,
                 ...
                 )

/*++

Routine Description:

    Debug print for the PCMCIA enabler.

Arguments:

    Check the mask value to see if the debug message is requested.

Return Value:

    None

--*/

{
    va_list ap;
    char      buffer[256];
    ULONG i = 0;

    va_start(ap, DebugMessage);

    strcpy(buffer, "Pcmcia ");

    for (i = 0; (MaskStrings[i].Mask != 0); i++) {
        if (DebugMask & MaskStrings[i].Mask) {
            strcat(buffer, MaskStrings[i].String);
            strcat(buffer, ": ");
            break;
        }
    }

    if (MaskStrings[i].Mask == 0) {
            strcat(buffer, "???: ");
    }

    if (DebugMask & PcmciaDebugMask) {
        vsprintf(&buffer[12], DebugMessage, ap);
        DbgPrint(buffer);
    }

    va_end(ap);

} // end PcmciaDebugPrint()


VOID
PcmciaDumpSocket(
    IN PSOCKET Socket
    )
{
    UCHAR index;
#define MAX_SOCKET_INDEX 64
    UCHAR buffer[MAX_SOCKET_INDEX];

    for (index = 0; index < MAX_SOCKET_INDEX; index++) {
        buffer[index] = PcicReadSocket(Socket, index);
    }

    for (index = 0; index < 8; index++) {
        DebugPrint((PCMCIA_DEBUG_INFO,"%.02x: %.02x\n", index, buffer[index]));
    }

    for (index = 8; index < MAX_SOCKET_INDEX; index+=2) {
        USHORT data;

        data = buffer[index] | (buffer[index+1]<<8);
        DebugPrint((PCMCIA_DEBUG_INFO,"%.02x: %.04x\n", index, data));
    }
}


TRACE_ENTRY GlobalTraceEntry;

VOID
PcmciaWriteTraceEntry(
    IN PSOCKET Socket,
    IN ULONG Context
    )
/*++

Routine Description:


Arguments:


Return Value:

    None

--*/

{
    UCHAR i;
    PTRACE_ENTRY pEntry = &GlobalTraceEntry;

    pEntry->Context = Context;

    if (CardBusExtension(Socket->DeviceExtension)) {
        for (i = 0; i < 5; i++) {
            pEntry->CardBusReg[i] = CBReadSocketRegister(Socket, (UCHAR)(i*sizeof(ULONG)));
        }
    }

    for (i = 0; i < 70; i++) {
        pEntry->ExcaReg[i] = PcicReadSocket(Socket, i);
    }
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\dispatch.c ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module contains the global dispatch related
    routines for the pcmcia controller & it's child devices

Author:

    Ravisankar Pudipeddi  (ravisp) 11/1/96

Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, PcmciaInitDeviceDispatchTable)
#endif

//
// Dispatch table array for FDOs/PDOs
//
PDRIVER_DISPATCH DeviceObjectDispatch[sizeof(DEVICE_OBJECT_TYPE)][IRP_MJ_MAXIMUM_FUNCTION + 1];

VOID
PcmciaInitDeviceDispatchTable(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:
    Initializes the IRP dispatch tables for Pdo's & Fdo's

Arguments:
    None

Return value:
    None

--*/
{
    ULONG i;

    PAGED_CODE();

    //
    // Init the controller (FDO) dispatch table
    //
    DeviceObjectDispatch[FDO][IRP_MJ_CREATE] =         PcmciaOpenCloseDispatch;
    DeviceObjectDispatch[FDO][IRP_MJ_CLOSE]  =         PcmciaOpenCloseDispatch;
    DeviceObjectDispatch[FDO][IRP_MJ_CLEANUP]=         PcmciaCleanupDispatch;
    DeviceObjectDispatch[FDO][IRP_MJ_DEVICE_CONTROL] = PcmciaDeviceControl;
    DeviceObjectDispatch[FDO][IRP_MJ_SYSTEM_CONTROL] = PcmciaFdoSystemControl;
    DeviceObjectDispatch[FDO][IRP_MJ_PNP] =            PcmciaFdoPnpDispatch;
    DeviceObjectDispatch[FDO][IRP_MJ_POWER] =          PcmciaFdoPowerDispatch;

    //
    // Init the PDO dispatch table
    //
    DeviceObjectDispatch[PDO][IRP_MJ_DEVICE_CONTROL] = PcmciaPdoDeviceControl;
    DeviceObjectDispatch[PDO][IRP_MJ_SYSTEM_CONTROL] = PcmciaPdoSystemControl;
    DeviceObjectDispatch[PDO][IRP_MJ_PNP] =            PcmciaPdoPnpDispatch;
    DeviceObjectDispatch[PDO][IRP_MJ_POWER] =          PcmciaPdoPowerDispatch;

    //
    // Set the global dispatch table
    DriverObject->MajorFunction[IRP_MJ_CREATE] =         PcmciaDispatch;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] =          PcmciaDispatch;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] =        PcmciaDispatch;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = PcmciaDispatch;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = PcmciaDispatch;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] =       PcmciaDispatch;
    DriverObject->MajorFunction[IRP_MJ_PNP] =            PcmciaDispatch;
    DriverObject->MajorFunction[IRP_MJ_POWER] =          PcmciaDispatch;
}

NTSTATUS
PcmciaDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Dispatch routine for all IRPs handled by this driver. This dispatch would then
    call the appropriate real dispatch routine which corresponds to the device object
    type (physical or functional).

Arguments:

    DeviceObject -  Pointer to the device object this dispatch is intended for
    Irp          -  Pointer to the IRP to be handled

Return value:
    Returns the status from the 'real' dispatch routine which handles this IRP

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;
    DEVICE_OBJECT_TYPE devtype = IS_PDO(DeviceObject) ? PDO : FDO;
    UCHAR MajorFunction = irpStack->MajorFunction;

    if ((MajorFunction > IRP_MJ_MAXIMUM_FUNCTION) ||
        (DeviceObjectDispatch[devtype][MajorFunction] == NULL)) {

        DebugPrint((PCMCIA_DEBUG_INFO, "PCMCIA: Dispatch skipping unimplemented Irp MJ function %x\n", MajorFunction));
        status = Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

    } else if (((devtype == PDO) && IsDeviceDeleted((PPDO_EXTENSION)DeviceObject->DeviceExtension)) ||
                  ((devtype == FDO) && IsDeviceDeleted((PFDO_EXTENSION)DeviceObject->DeviceExtension))) {
        //
        // This do was supposed to have been already deleted
        // so we don't support any IRPs on it
        //
        DebugPrint((PCMCIA_DEBUG_INFO, "PCMCIA: Dispatch skipping Irp on deleted DO %08x MJ function %x\n", DeviceObject, MajorFunction));

        if (MajorFunction == IRP_MJ_POWER) {
            PoStartNextPowerIrp(Irp);
        }
        status = Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

    } else if (((KeGetCurrentIrql() == DISPATCH_LEVEL) && (MajorFunction != IRP_MJ_POWER)) ||
                  (KeGetCurrentIrql() > DISPATCH_LEVEL)) {
        //
        // This is too high an IRQL to handle
        //

        if (MajorFunction == IRP_MJ_POWER) {
            PoStartNextPowerIrp(Irp);
        }
        status = Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

    } else {

        //
        // Dispatch the irp
        //
        status = ((*DeviceObjectDispatch[devtype][MajorFunction])(DeviceObject, Irp));

    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\detect.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    detect.c

Abstract:

    This module contains the code that controls the PCMCIA slots.

Authors:

    Bob Rinne (BobRi) 3-Nov-1994
    Neil Sandlin (neilsa) June 1 1999

Environment:

    Kernel mode

Revision History:
    Modified for plug'n'play support
         Ravisankar Pudipeddi (ravisp) 1 Dec 1996


--*/

#include "pch.h"


NTSTATUS
PcmciaDetectControllers(
    IN PDRIVER_OBJECT           DriverObject,
    IN PUNICODE_STRING          RegistryPath,
    IN PPCMCIA_DETECT_ROUTINE   PcmciaDetectFn
    );

NTSTATUS
PcmciaReportDetectedDevice(
    IN PFDO_EXTENSION DeviceExtension
    );

NTSTATUS
PcmciaAllocateOpenMemoryWindow(
    IN PFDO_EXTENSION DeviceExtension,
    IN PPHYSICAL_ADDRESS PhysicalAddress,
    IN PULONG PhysicalAddressSize
    );


#ifdef ALLOC_PRAGMA
//   #pragma alloc_text(INIT,PcmciaLegacyDetectionOk)
    #pragma alloc_text(INIT,PcmciaDetectPcmciaControllers)
    #pragma alloc_text(INIT,PcmciaDetectControllers)
    #pragma alloc_text(INIT,PcmciaReportDetectedDevice)
    #pragma alloc_text(INIT,PcmciaAllocateOpenMemoryWindow)
#endif


#if 0

BOOLEAN
PcmciaLegacyDetectionOk(
    VOID
    )
/*++

Routine Description

     Checks if legacy detection needs to be done for pcmcia controllers

Arguments

     None

Return Value

     TRUE   - If legacy detection can be done
     FALSE  - If legacy detection should NOT be attempted

--*/
{
    UNICODE_STRING                   unicodeKey, unicodeValue;
    OBJECT_ATTRIBUTES                objectAttributes;
    HANDLE                           handle;
    UCHAR                            buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+
                                                      sizeof(ULONG)];
    PKEY_VALUE_PARTIAL_INFORMATION value = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
    ULONG                            length;
    NTSTATUS                         status;

    PAGED_CODE();

    RtlInitUnicodeString(&unicodeKey,
                                L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Pnp");

    RtlZeroMemory(&objectAttributes, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes(&objectAttributes,
                               &unicodeKey,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    if (!NT_SUCCESS(ZwOpenKey(&handle,
                              KEY_QUERY_VALUE,
                              &objectAttributes))) {
        //
        // Key doesn't exist
        //
        return TRUE;
    }

    RtlInitUnicodeString(&unicodeValue, L"DisableFirmwareMapper");

    status =  ZwQueryValueKey(handle,
                              &unicodeValue,
                              KeyValuePartialInformation,
                              value,
                              sizeof(buffer),
                              &length);
    ZwClose(handle);

    if (!NT_SUCCESS(status)) {
        //
        // Value doesn't exist
        //
        return TRUE;
    }

    if (value->Type == REG_DWORD) {
        //
        // If value is non-zero don't do legacy detection
        // otherwise it's ok
        //
        return  ((ULONG) (*((PULONG)value->Data)) ? FALSE : TRUE);
    }
    return TRUE;
}
#endif



NTSTATUS
PcmciaDetectPcmciaControllers(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:
    Detects appropriate PCMCIA controllers both ISA & PCI based
    in the system.

Arguments:

    DriverObject     Just as passed in to DriverEntry
    RegistryPath

Return Value:
    STATUS_SUCCESS if any PCMCIA controllers were found
    STATUS_NO_SUCH_DEVICE otherwise

--*/
{
    NTSTATUS pcicIsaStatus = STATUS_UNSUCCESSFUL, tcicStatus = STATUS_UNSUCCESSFUL;

    PAGED_CODE();

    //
    // We enumerate the PCI devices first to ensure that the ISA detect
    // doesn't probe those address ports which are already claimed by
    // detected PCI devices
    //
    pcicIsaStatus = PcmciaDetectControllers(DriverObject, RegistryPath, PcicIsaDetect);

    tcicStatus = PcmciaDetectControllers(DriverObject, RegistryPath, TcicDetect);

    //
    // Indicate success if we found any controllers
    //
    return ((NT_SUCCESS(pcicIsaStatus) ||
                NT_SUCCESS(tcicStatus) ) ? STATUS_SUCCESS : STATUS_NO_SUCH_DEVICE);
}



NTSTATUS
PcmciaDetectControllers(
    IN PDRIVER_OBJECT            DriverObject,
    IN PUNICODE_STRING           RegistryPath,
    IN PPCMCIA_DETECT_ROUTINE    PcmciaDetectFn
    )
/*++

Routine Description:
    Detects PCMCIA controllers in the system and reports them. This is called
    by PcmciaDetectPcmciaControllers. This reports bus specific controllers.

Arguments:
    DriverObject, RegistryPath - See DriverEntry
    PcmciaDetectFn              - Pointer to the function that actually probes the hardware
                                          to find PCMCIA controllers. So this routine can be called
                                          with an ISA detect function or a PCI detect function for eg.

Return Value:
    STATUS_SUCCESS                  Found one or more PCMCIA controllers
    STATUS_NO_SUCH_DEVICE           No controllers found.
    STATUS_INSUFFICIENT_RESOURCES Pool allocation failures etc.

--*/
{

    PFDO_EXTENSION            deviceExtension = NULL;
    NTSTATUS                      status = STATUS_SUCCESS;
    NTSTATUS                      detectStatus;
    BOOLEAN                       controllerDetected = FALSE;

    PAGED_CODE();

    //
    // Allocate a dummy device extension which is used by the Pcic & Tcic detect modules
    // Have to do this since the original detection code required device extensions
    // Too painful to change this structure now.
    //
    deviceExtension = ExAllocatePool(NonPagedPool, sizeof(FDO_EXTENSION));
    if (deviceExtension == NULL) {
        DebugPrint((PCMCIA_DEBUG_FAIL, "Cannot allocate pool for FDO extension\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    do {

        RtlZeroMemory(deviceExtension, sizeof(FDO_EXTENSION));

        deviceExtension->RegistryPath = RegistryPath;
        deviceExtension->DriverObject = DriverObject;

        detectStatus = (*PcmciaDetectFn)(deviceExtension);

        if (detectStatus != STATUS_SUCCESS) {
            continue;
        }

        controllerDetected = TRUE;

        status = PcmciaReportDetectedDevice(deviceExtension);

        if (!NT_SUCCESS(status)) {
            DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaDetectControllers: PcmciaReportDetectedDevice "
                            "failed, status %x\n", status));
            continue;
        }

    } while (detectStatus != STATUS_NO_MORE_ENTRIES);

    ExFreePool(deviceExtension);

    if (controllerDetected) {
        return STATUS_SUCCESS;
    }

    return (STATUS_NO_SUCH_DEVICE);
}



NTSTATUS
PcmciaReportDetectedDevice(
    IN PFDO_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Reports the PCMCIA controllers detected to the IO subsystem which creates the
    madeup devnodes for these DeviceObjects.

Arguments:

    DeviceExtension - DeviceExtension for the DeviceObject (FDO) of the PCMCIA controller
                            being reported
Return Value:

--*/
{
    PDEVICE_OBJECT            pdo = NULL, fdo, lowerDevice;
    PFDO_EXTENSION            fdoExtension;
    ULONG                         pcmciaInterruptVector;
    KIRQL                         pcmciaInterruptLevel;
    KAFFINITY                     pcmciaAffinity;
    PSOCKET                       socket;
    NTSTATUS                      status;
    ULONG                         pcmciaIrq;
    ULONG                         count, ioResourceReqSize;
    PHYSICAL_ADDRESS              halMemoryAddress;
    ULONG                         addressSpace;
    PIO_RESOURCE_REQUIREMENTS_LIST  ioResourceReq=NULL;
    PIO_RESOURCE_LIST                 ioResourceList;
    PIO_RESOURCE_DESCRIPTOR           ioResourceDesc;
    PCM_RESOURCE_LIST                 allocatedResources;
    PCM_RESOURCE_LIST                 scratchResources;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmResourceDesc;
    BOOLEAN                       translated;
    UCHAR                         option;

    PAGED_CODE();

    //
    // Do initial setup in our "fake" device extension
    //
    PcmciaGetControllerRegistrySettings(DeviceExtension);

    DeviceExtension->Configuration.InterruptPin = 0;
    DeviceExtension->Configuration.Interrupt.u.Interrupt.Vector = 0;
    DeviceExtension->Configuration.Interrupt.u.Interrupt.Level = 0;

    count=0;
    //
    // Get an 'open' memory window
    //
    status = PcmciaAllocateOpenMemoryWindow(DeviceExtension,
                                            &DeviceExtension->PhysicalBase,
                                            &DeviceExtension->AttributeMemorySize);
    count++;

    if (DeviceExtension->Configuration.UntranslatedPortAddress) {
        count++;
    }

    ioResourceReqSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) + (count-1)*sizeof(IO_RESOURCE_DESCRIPTOR);

    ioResourceReq = ExAllocatePool(PagedPool, ioResourceReqSize);
    if (ioResourceReq == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(ioResourceReq, ioResourceReqSize);

    ioResourceReq->ListSize = ioResourceReqSize;
    ioResourceReq->InterfaceType = Isa; // DeviceExtension->Configuration.InterfaceType;
    ioResourceReq->BusNumber = DeviceExtension->Configuration.BusNumber;
    ioResourceReq->SlotNumber= DeviceExtension->Configuration.SlotNumber;
    ioResourceReq->AlternativeLists=1;

    ioResourceList = &(ioResourceReq->List[0]);
    ioResourceList->Version  = IO_RESOURCE_LIST_VERSION;
    ioResourceList->Revision = IO_RESOURCE_LIST_REVISION;
    ioResourceList->Count    = count;

    ioResourceDesc = ioResourceList->Descriptors;

    //
    //Request IO
    //
    if (DeviceExtension->Configuration.UntranslatedPortAddress) {
        ioResourceDesc->Option = 0;
        ioResourceDesc->Type = CmResourceTypePort;
        ioResourceDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        ioResourceDesc->Flags = CM_RESOURCE_PORT_IO;
        ioResourceDesc->u.Port.MinimumAddress.LowPart = (ULONG)(DeviceExtension->Configuration.UntranslatedPortAddress);
        ioResourceDesc->u.Port.MaximumAddress.LowPart = (ULONG)(DeviceExtension->Configuration.UntranslatedPortAddress+
                                                                                   DeviceExtension->Configuration.PortSize - 1);
        ioResourceDesc->u.Port.Length = DeviceExtension->Configuration.PortSize;
        ioResourceDesc->u.Port.Alignment =  1;
        ioResourceDesc++;
    }

    //
    // Request memory
    //
    ioResourceDesc->Option = 0;
    ioResourceDesc->Type = CmResourceTypeMemory;
    ioResourceDesc->ShareDisposition = CmResourceShareDeviceExclusive;
    ioResourceDesc->Flags = CM_RESOURCE_MEMORY_READ_WRITE;
    if (DeviceExtension->PhysicalBase.QuadPart) {
        ioResourceDesc->u.Memory.MinimumAddress = DeviceExtension->PhysicalBase;
        ioResourceDesc->u.Memory.MaximumAddress.QuadPart = DeviceExtension->PhysicalBase.QuadPart+DeviceExtension->AttributeMemorySize-1;
        ioResourceDesc->u.Memory.Length = DeviceExtension->AttributeMemorySize;
        ioResourceDesc->u.Memory.Alignment = 1;
        ioResourceDesc++;
    } else {
        //
        ioResourceDesc->u.Memory.MinimumAddress.LowPart = DeviceExtension->AttributeMemoryLow;
        ioResourceDesc->u.Memory.MaximumAddress.LowPart = DeviceExtension->AttributeMemoryHigh;
        ioResourceDesc->u.Memory.Length = DeviceExtension->AttributeMemorySize;
        switch (DeviceExtension->ControllerType) {

        case PcmciaDatabook: {
                ioResourceDesc->u.Memory.Alignment = TCIC_WINDOW_ALIGNMENT;
                break;
            }
        default: {
                ioResourceDesc->u.Memory.Alignment = PCIC_WINDOW_ALIGNMENT;
                break;
            }
        }
        ioResourceDesc++;
    }


    status = IoAssignResources(DeviceExtension->RegistryPath,
                               NULL,
                               DeviceExtension->DriverObject,
                               NULL,
                               ioResourceReq,
                               &allocatedResources
                               );

    if (!NT_SUCCESS(status)) {
        //
        // Log an event here
        //
        PcmciaLogError(DeviceExtension, PCMCIA_NO_RESOURCES, 1, 0);

        DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaReportDetectedDevice: IoAssignResources failed status %x\n",
                        status));
        ExFreePool(ioResourceReq);
        return status;
    }


    //
    // Fish out the Memory Base allocated to this controller from the
    // nether depths of the CM_RESOURCE_LIST
    //
    count = allocatedResources->List[0].PartialResourceList.Count;
    cmResourceDesc = &(allocatedResources->List[0].PartialResourceList.PartialDescriptors[0]);

    while (count--) {
        switch (cmResourceDesc->Type) {

        case CmResourceTypeMemory: {

                DeviceExtension->PhysicalBase = cmResourceDesc->u.Memory.Start;
                DeviceExtension->AttributeMemorySize = cmResourceDesc->u.Memory.Length;

                addressSpace=0;
                translated = HalTranslateBusAddress(Isa,
                                                    0,
                                                    cmResourceDesc->u.Memory.Start,
                                                    &addressSpace,
                                                    &halMemoryAddress);
                ASSERT(translated);
                if (addressSpace) {
                    DeviceExtension->AttributeMemoryBase = (PUCHAR)(halMemoryAddress.QuadPart);
                    DeviceExtension->Flags &= ~PCMCIA_ATTRIBUTE_MEMORY_MAPPED;
                }

                else {
                    DeviceExtension->AttributeMemoryBase = MmMapIoSpace(halMemoryAddress,
                                                                        cmResourceDesc->u.Memory.Length,
                                                                        FALSE);
                    DeviceExtension->Flags |= PCMCIA_ATTRIBUTE_MEMORY_MAPPED;
                }
                DebugPrint((PCMCIA_DEBUG_INFO,
                                "Attribute Memory Physical Base: %x Virtual Addr: %x\n",
                                DeviceExtension->PhysicalBase,
                                DeviceExtension->AttributeMemoryBase));
                break;
            }
            // Don't bother to parse IO, it was a fixed resource requirement which we already know about
        }
        cmResourceDesc++;
    }

    //
    // Free resources so IoReportDetectedDevice can assign them for the PDO
    //
    IoAssignResources(DeviceExtension->RegistryPath,
                      NULL,
                      DeviceExtension->DriverObject,
                      NULL,
                      NULL,
                      &scratchResources
                      );

    pdo = NULL;
    status = IoReportDetectedDevice(
                                    DeviceExtension->DriverObject,
                                    InterfaceTypeUndefined,
                                    -1,
                                    -1,
                                    allocatedResources,
                                    ioResourceReq,
                                    FALSE,
                                    &pdo
                                    );

    ExFreePool(allocatedResources);
    ExFreePool(ioResourceReq);

    if (!NT_SUCCESS(status)) {
        DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaReportDetectedDevice: IoReportDetectedDevice failed\n"));
        return status;
    }

    //
    // Set up registry params for the madeup pdo so we'll recognize it on the next boot
    // when the PNP manager gives us an AddDevice/IRP_MN_START_DEVICE
    //
    PcmciaSetLegacyDetectedControllerType(pdo, DeviceExtension->ControllerType);

    //
    // The I/O subsystem has created the true PDO which we will use during this boot. So we
    // have to attach to this PDO, and initialize our new FDO extension to values already set
    // into our original (fake) FDO extension.
    //

    status = PcmciaAddDevice(DeviceExtension->DriverObject, pdo);

    if (!NT_SUCCESS(status)) {

        DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaReportDetectedDevice: AddDevice failed status %x\n", status));
        return status;
    }

    pdo->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Head of list is our fdo
    //
    fdo = FdoList;
    fdoExtension = fdo->DeviceExtension;

    //
    // Copy in the rest of the config. from the DeviceExtension
    //
    fdoExtension->SocketList = DeviceExtension->SocketList;
    fdoExtension->Configuration = DeviceExtension->Configuration;
    fdoExtension->PhysicalBase = DeviceExtension->PhysicalBase;
    fdoExtension->AttributeMemoryBase = DeviceExtension->AttributeMemoryBase;
    fdoExtension->AttributeMemorySize = DeviceExtension->AttributeMemorySize;
    fdoExtension->Flags = DeviceExtension->Flags;

    // Reinitialize the socket's device extensions
    //
    for (socket = fdoExtension->SocketList; socket!=NULL; socket=socket->NextSocket) {
        socket->DeviceExtension = fdoExtension;
    }

    fdoExtension->Flags |= PCMCIA_DEVICE_STARTED;
    //
    // This is legacy detected..
    //
    fdoExtension->Flags |= PCMCIA_DEVICE_LEGACY_DETECTED;

    status=PcmciaStartPcmciaController(fdo);

    if (!NT_SUCCESS(status)) {
        fdoExtension->Flags &= ~PCMCIA_DEVICE_STARTED;
    }

    return status;
}



NTSTATUS
PcmciaAllocateOpenMemoryWindow(
    IN PFDO_EXTENSION DeviceExtension,
    IN PPHYSICAL_ADDRESS PhysicalAddress,
    IN PULONG PhysicalAddressSize
    )

/*++

Routine Description:

    Search the 640K to 1MB region for an open area to be used
    for mapping PCCARD attribute memory.

Arguments:


Return Value:

    A physical address for the window to the card or zero meaning
    there is no opening.

--*/

{
#define NUMBER_OF_TEST_BYTES 25
    PHYSICAL_ADDRESS physicalMemoryAddress;
    PHYSICAL_ADDRESS halMemoryAddress;
    BOOLEAN           translated;
    ULONG             untranslatedAddress;
    PUCHAR            memoryAddress;
    PUCHAR            bogus;
    ULONG             addressSpace;
    ULONG             index;
    UCHAR             memory[NUMBER_OF_TEST_BYTES];
    PCM_RESOURCE_LIST cmResourceList = NULL;
    PCM_PARTIAL_RESOURCE_LIST cmPartialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmResourceDesc;
    BOOLEAN conflict = TRUE;
    NTSTATUS                              status;
    ULONG               windowSize, windowAlignment;

    PAGED_CODE();


    cmResourceList = ExAllocatePool(PagedPool, sizeof(CM_RESOURCE_LIST));
    if (!cmResourceList) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(cmResourceList, sizeof(CM_RESOURCE_LIST));
    cmResourceList->Count = 1;
    cmResourceList->List[0].InterfaceType = Isa;
    cmPartialResourceList = &(cmResourceList->List[0].PartialResourceList);
    cmPartialResourceList->Version  = 1;
    cmPartialResourceList->Revision = 1;
    cmPartialResourceList->Count      = 1;
    cmResourceDesc = cmPartialResourceList->PartialDescriptors;
    cmResourceDesc->Type = CmResourceTypeMemory;
    cmResourceDesc->ShareDisposition = CmResourceShareDeviceExclusive;
    cmResourceDesc->Flags = CM_RESOURCE_MEMORY_READ_WRITE;

    //
    // Size of the attr. memory window
    //
    switch (DeviceExtension->ControllerType) {

    case PcmciaDatabook: {
            windowSize       = TCIC_WINDOW_SIZE;
            windowAlignment = TCIC_WINDOW_ALIGNMENT;
            break;
        }

    default: {
            windowSize = PCIC_WINDOW_SIZE;
            windowAlignment = PCIC_WINDOW_ALIGNMENT;
            break;
        }
    }

    for (untranslatedAddress = DeviceExtension->AttributeMemoryLow;
         untranslatedAddress < DeviceExtension->AttributeMemoryHigh;
         untranslatedAddress += windowAlignment) {

        if (untranslatedAddress == 0xc0000) {

            //
            // This is VGA.  Keep this test if the for loop should
            // ever change.
            //

            continue;
        }

        //
        // Check if it's available
        //
        cmResourceDesc->u.Memory.Start.LowPart = untranslatedAddress;
        cmResourceDesc->u.Memory.Length = windowSize;

        status=IoReportResourceForDetection(
                                            DeviceExtension->DriverObject,
                                            cmResourceList,
                                            sizeof(CM_RESOURCE_LIST),
                                            NULL,
                                            NULL,
                                            0,
                                            &conflict);
        if (!NT_SUCCESS(status) || conflict) {
            //
            // This range's already taken. Move on to the next
            //
            continue;
        }

        addressSpace = 0;
        physicalMemoryAddress.LowPart = untranslatedAddress;
        physicalMemoryAddress.HighPart = 0;

        translated = HalTranslateBusAddress(Isa,
                                            0,
                                            physicalMemoryAddress,
                                            &addressSpace,
                                            &halMemoryAddress);

        if (!translated) {

            //
            // HAL doesn't like this translation
            //

            continue;
        }
        if (addressSpace) {
            memoryAddress = (PUCHAR)(halMemoryAddress.QuadPart);
        } else {
            memoryAddress = MmMapIoSpace(halMemoryAddress, windowSize, FALSE);
        }

        //
        // Test the memory window to determine if it is a BIOS, video
        // memory, or open memory.  Only want to keep the window if it
        // is not being used by something else.
        //

        for (index = 0; index < NUMBER_OF_TEST_BYTES; index++) {
            memory[index] = READ_REGISTER_UCHAR(memoryAddress + index);
            if (index) {
                if (memory[index] != memory[index - 1]) {
                    break;
                }
            }
        }

        if (index == NUMBER_OF_TEST_BYTES) {

            //
            // There isn't a BIOS here
            //

            UCHAR memoryPattern[NUMBER_OF_TEST_BYTES];
            BOOLEAN changed = FALSE;

            //
            // Check for video memory - open memory should always remain
            // the same regardless what the changes are.  Change the
            // pattern previously found.
            //

            for (index = 0; index < NUMBER_OF_TEST_BYTES; index++) {
                memoryPattern[index] = ~memory[index];
                WRITE_REGISTER_UCHAR(memoryAddress + index,
                                     memoryPattern[index]);
            }

            //
            // See if the pattern in memory changed.
            // Some system exhibit a problem where the memory pattern
            // seems to be cached.  If this code is debugged it will
            // work as expected, but if it is run normally it will
            // always return that the memory changed.  This random
            // wandering seems to remove this problem.
            //

            for (index = 0; index < NUMBER_OF_TEST_BYTES; index++) {
                memoryPattern[index] = 0;
            }
            bogus = ExAllocatePool(PagedPool, 64 * 1024);

            if (bogus) {
                for (index = 0; index < 64 * 1024; index++) {
                    bogus[index] = 0;
                }
                ExFreePool(bogus);
            }

            //
            // Now go off and do the actual check to see if the memory
            // changed.
            //

            for (index = 0; index < NUMBER_OF_TEST_BYTES; index++) {

                if ((memoryPattern[index] = READ_REGISTER_UCHAR(memoryAddress + index)) != memory[index]) {

                    //
                    // It changed - this is not an area of open memory
                    //

                    changed = TRUE;
                }
                WRITE_REGISTER_UCHAR(memoryAddress + index,
                                     memory[index]);
            }

            if (!changed) {

                //
                // Area isn't a BIOS and didn't change when written.
                // Use this region for the memory window to PCMCIA
                // attribute memory.
                //

                PhysicalAddress->LowPart = untranslatedAddress;
                PhysicalAddress->HighPart = 0;
                *PhysicalAddressSize = windowSize;
                if (!addressSpace) {
                    MmUnmapIoSpace(memoryAddress, windowSize);
                }
                ExFreePool(cmResourceList);
                return STATUS_SUCCESS;
            }
        }

        if (!addressSpace) {
            MmUnmapIoSpace(memoryAddress, windowSize);
        }
    }
    ExFreePool(cmResourceList);
    return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\enum.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    enum.c

Abstract:

    This module contains the bus enum code for Pcmcia driver

Authors:

    Ravisankar Pudipeddi (ravisp) 10/15/96
    Neil Sandlin (neilsa) 1-Jun-1999

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#include "pch.h"

//
// Internal References
//

NTSTATUS
PcmciaEnumerateDevices(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp
    );

NTSTATUS
PcmciaEnumerateCardBusCard(
    IN PSOCKET socket,
    IN PIRP    Irp
    );

NTSTATUS
PcmciaEnumerateR2Card(
    IN PSOCKET socket
    );

NTSTATUS
PcmciaCreatePdo(
    IN PDEVICE_OBJECT  Fdo,
    IN PSOCKET         Socket,
    OUT PDEVICE_OBJECT *PdoPtr
    );

VOID
PcmciaSetPowerFromConfigData(
    IN PSOCKET         Socket,
    IN PDEVICE_OBJECT  Pdo
    );

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, PcmciaEnumerateDevices)
    #pragma alloc_text(PAGE, PcmciaEnumerateCardBusCard)
    #pragma alloc_text(PAGE, PcmciaCreatePdo)
    #pragma alloc_text(PAGE, PcmciaDeviceRelations)
#endif

NTSTATUS
PcmciaEnumerateDevices(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp
    )
/*++

Routine Description:

    This enumerates the pcmcia bus which is represented by Fdo (a pointer to the device object representing
    the pcmcia controller. It creates new PDOs for any new PC-Cards which have been discovered
    since the last enumeration

Notes:

    Because a user can yank a pccard at any time, the enumeration code only updates the current socket
    status after PnP has had a chance to gracefully remove the device. Specifically, if a surprise remove
    happens, then a number of things has to happen:
     - power has to be reset on the socket
     - bridge windows need to be closed
     - if cardbus, PCI.SYS needs to be informed
    The problem is that we can't do these things immediately here. Instead, on a surprise remove, we
    check to see if there is still state that has yet to be cleared. If so, we report the socket as
    empty, and bail out, even if another card has been inserted (or the same card re-inserted). Later,
    the remove code will cause a new enumeration call, at which point we can update the state and honestly
    report the new device.

Arguments:

    Fdo - Pointer to the functional device object for the PCMCIA controller which needs to be enumerated

Return value:

    None

--*/
{
    PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PPDO_EXTENSION pdoExtension = NULL;
    PDEVICE_OBJECT pdo;
    PSOCKET        socket;
    NTSTATUS       status = STATUS_SUCCESS;
    ULONG          i;

    PAGED_CODE();

    DebugPrint((PCMCIA_DEBUG_ENUM, "fdo %08x enumerate devices\n", Fdo));

    for (socket = fdoExtension->SocketList; socket != NULL; socket = socket->NextSocket) {

        if (!IsSocketFlagSet(socket, SOCKET_CARD_STATUS_CHANGE)) {
            //
            // return previous results
            //
            DebugPrint((PCMCIA_DEBUG_ENUM, "fdo %08x skt %08x No status change\n", Fdo, socket));
            continue;
        }

        ResetDeviceFlag(fdoExtension, PCMCIA_FDO_DISABLE_AUTO_POWEROFF);

        //
        // The socket either has a new card, or the card has been
        // removed. Either way, the old pdo list on this socket, if
        // it exists, will now be thrown away.
        //
        for (pdo = socket->PdoList; pdo!=NULL; pdo=pdoExtension->NextPdoInSocket) {
            pdoExtension = pdo->DeviceExtension;
            DebugPrint((PCMCIA_DEBUG_INFO, "fdo %08x enumeration marking pdo %08x REMOVED\n", Fdo, pdo));
            MarkDevicePhysicallyRemoved(pdoExtension);
        }

        if (fdoExtension->PciCardBusDeviceContext != NULL) {
            //
            // If we previously had a cardbus card, and that status has changed,
            // let PCI learn about the empty slot. If there is currently a
            // cardbus card in the slot then PCI found out anyway.
            //
            status = (*fdoExtension->PciCardBusInterface.DispatchPnp)(fdoExtension->PciCardBusDeviceContext, Irp);
        }

        //
        // Check to see if we are waiting on a remove to finish cleaning up the socket. If so,
        // then don't enumerate anything just yet. Let the remove happen, and enumerate later.
        //
        if (socket->Flags & SOCKET_CLEANUP_MASK) {
            socket->Flags |= SOCKET_ENUMERATE_PENDING;
            DebugPrint((PCMCIA_DEBUG_ENUM, "fdo %08x skt %08x Enumeration deferred! Waiting on remove\n", Fdo, socket));
            continue;
        }

        //
        // Update the current socket status
        //
        PcmciaGetSocketStatus(socket);

        //
        // Now that we are committed to enumerating the card, this can be reset
        //
        ResetSocketFlag(socket, SOCKET_CARD_STATUS_CHANGE);

        //
        // Cleanup PCI state if we learn that the status has changed
        //

        if (fdoExtension->PciCardBusDeviceContext != NULL) {

            //
            // Let pci clean up
            //
            (*fdoExtension->PciCardBusInterface.DeleteCardBus)(fdoExtension->PciCardBusDeviceContext);
            fdoExtension->PciCardBusDeviceContext = NULL;

            if (IsDeviceFlagSet(fdoExtension, PCMCIA_INT_ROUTE_INTERFACE)) {
                //
                // Here is one might dereference the interface, that is if that
                // ever had any affect, which it doesn't.
                //
                ResetDeviceFlag(fdoExtension, PCMCIA_INT_ROUTE_INTERFACE);
            }
        }


        if (!IsCardInSocket(socket)) {
            //
            // This socket is empty, continue
            //
            DebugPrint((PCMCIA_DEBUG_ENUM, "fdo %08x skt %08x Socket is empty\n", Fdo, socket));
            continue;
        }

        //
        // If this is a cardbus card, check to see if we can run it
        //

        if (IsCardBusCardInSocket(socket) && IsDeviceFlagSet(fdoExtension, PCMCIA_CARDBUS_NOT_SUPPORTED)) {

            if (!IsSocketFlagSet(socket, SOCKET_SUPPORT_MESSAGE_SENT)) {
                SetSocketFlag(socket, SOCKET_SUPPORT_MESSAGE_SENT);
                PcmciaReportControllerError(fdoExtension, STATUS_CARDBUS_NOT_SUPPORTED);
            }
            continue;
        }

        //
        // Some cards may be in a funky state, particularly if the machine crashed
        // previously... power is shown to be on, but the device won't respond. The fix is
        // to force power off first.
        //
        if (!IsDeviceFlagSet(fdoExtension, PCMCIA_FDO_ON_DEBUG_PATH)) {

            //
            // Fool SetSocketPower into actually powering off the card no matter what
            // state it thinks it is in
            //
            SetSocketFlag(socket, SOCKET_CARD_POWERED_UP);

            PcmciaSetSocketPower(socket, NULL, NULL, PCMCIA_POWEROFF);
        }

        //
        // Power up the socket so the device(s) can be enumerated
        //
        if (!NT_SUCCESS(PcmciaSetSocketPower(socket, NULL, NULL, PCMCIA_POWERON))) {
            //
            // Tell the user there was an error
            //
            PcmciaLogError(fdoExtension, PCMCIA_DEVICE_POWER_ERROR, 1, 0);
            continue;
        }

        //
        // Card found here - but no Pdo for it
        // We create a new pdo for the card & initialize the
        // socket to point to it.
        //

        if (IsCardBusCardInSocket(socket)) {
            //
            // 32-bit cardbus card. Enum via PCI
            //

            status = PcmciaEnumerateCardBusCard(socket, Irp);

        } else {
            //
            // R2 card
            //
            status = PcmciaEnumerateR2Card(socket);

        }

        if (!NT_SUCCESS(status)) {
            DebugPrint((PCMCIA_DEBUG_FAIL, "fdo %08x CardBus enumeration failed: %x\n", Fdo, status));
            //
            // Tell the user there was an error
            //
            PcmciaSetSocketPower(socket, NULL, NULL, PCMCIA_POWEROFF);
            PcmciaLogError(fdoExtension, PCMCIA_DEVICE_ENUMERATION_ERROR, 1, 0);
            continue;
        }

        PcmciaSetPowerFromConfigData(socket, fdoExtension->PdoList);
    }

    fdoExtension->LivePdoCount = 0;
    for (pdo = fdoExtension->PdoList; pdo != NULL; pdo = pdoExtension->NextPdoInFdoChain) {
        pdoExtension = pdo->DeviceExtension;
        if (!IsDevicePhysicallyRemoved(pdoExtension)) {
            fdoExtension->LivePdoCount++;
        }
    }

    DebugPrint((PCMCIA_DEBUG_ENUM, "fdo %08x live pdo count = %d\n", Fdo, fdoExtension->LivePdoCount));

    if (fdoExtension->LivePdoCount == 0) {
         //
         // Hint for the controller to check if it should turn itself off
         //
         PcmciaFdoCheckForIdle(fdoExtension);
    }
    return status;
}



VOID
PcmciaSetPowerFromConfigData(
    IN PSOCKET           Socket,
    IN PDEVICE_OBJECT  Pdo
    )
/*++

Routine Description:

    This routine will reset the socket power if the CIS of the device contains
    more specific power requirements than is shown on the controller hardware.

Arguments


Return value

    None

--*/
{
    PPDO_EXTENSION pdoExtension;
    PSOCKET_DATA    socketData;
    BOOLEAN powerChange = FALSE;

    pdoExtension = Pdo->DeviceExtension;
    socketData = pdoExtension->SocketData;

    //
    // Only change Vcc if we are lowering it
    //
    if (socketData->Vcc && (socketData->Vcc < Socket->Vcc)) {
        //
        // Here we should check the controller if it can support the requested
        // voltage. This isn't implemented, so just hard-wire a check for 5v
        // and 3.3v.
        //
        if ((socketData->Vcc == 50) || (socketData->Vcc == 33)) {
            powerChange = TRUE;
            Socket->Vcc = socketData->Vcc;
        }
    }

    if (socketData->Vpp1 && (socketData->Vpp1 != Socket->Vpp1)) {
        powerChange = TRUE;
        Socket->Vpp1 = socketData->Vpp1;
    }

    if (socketData->Vpp2 && (socketData->Vpp2 != Socket->Vpp2)) {
        powerChange = TRUE;
        Socket->Vpp2 = socketData->Vpp2;
    }

    if (powerChange) {
        PcmciaSetSocketPower(Socket, NULL, NULL, PCMCIA_POWEROFF);
        PcmciaSetSocketPower(Socket, NULL, NULL, PCMCIA_POWERON);
    }
}



NTSTATUS
PcmciaEnumerateCardBusCard(
    IN PSOCKET socket,
    IN PIRP   Irp
    )
/*++

Routine Description:

    This enumerates the cardbus card present in the given cardbus controller

    Note: this routine effectively parties on Irp->IoStatus.Information. This
    value should not be relied upon after return from this routine.

Arguments

    socket           - pointer to the socket structure which contains the cardbus card
    Irp              -  Enumeration irp (IRP_MN_DEVICE_RELATIONS) sent to the controller

Return value

    Status
--*/
{
    PFDO_EXTENSION FdoExtension = socket->DeviceExtension;
    PDEVICE_OBJECT Fdo = FdoExtension->DeviceObject;
    PVOID deviceContext;
    NTSTATUS  status;
    ULONG   i;
    PDEVICE_RELATIONS deviceRelations;

    PAGED_CODE();
    //
    // We should have already done a delete on any previous context
    //
    ASSERT(FdoExtension->PciCardBusDeviceContext == NULL);
    ASSERT(!IsDeviceFlagSet(FdoExtension, PCMCIA_INT_ROUTE_INTERFACE));

    //
    // Call PCI's private AddDevice routine to
    // indicate it needs to play a role in enumerating
    // cardbus cards
    //

    status = (*FdoExtension->PciCardBusInterface.AddCardBus)(FdoExtension->Pdo, &deviceContext);
    FdoExtension->PciCardBusDeviceContext = deviceContext;

    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = PcmciaGetInterface(FdoExtension->Pdo,
                                &GUID_INT_ROUTE_INTERFACE_STANDARD,
                                sizeof(INT_ROUTE_INTERFACE_STANDARD),
                                (PINTERFACE) &FdoExtension->PciIntRouteInterface
                                );

    if (NT_SUCCESS(status)) {
        SetDeviceFlag(FdoExtension, PCMCIA_INT_ROUTE_INTERFACE);
    }

    //
    // Call PCI repeatedly till the card is enumerated.
    //
    // We don't let PCI report what has already been reported
    //
    Irp->IoStatus.Information = 0;
    status = STATUS_DEVICE_NOT_READY;

    for (i = 0; i < CARDBUS_CONFIG_RETRY_COUNT; i++) {

        status =  (*FdoExtension->PciCardBusInterface.DispatchPnp)(deviceContext, Irp);

        if (!NT_SUCCESS(status)) {
            //
            // PCI failed this IRP for some reason.
            //
            break;
        }
        deviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;
        if ((deviceRelations == NULL) ||
             ((deviceRelations)->Count <= 0)) {
            //
            // This is the problem case: try again
            //
            DebugPrint((PCMCIA_DEBUG_ENUM, "fdo %08x Pci enumerated ZERO device objects\n", FdoExtension->DeviceObject));
            status = STATUS_DEVICE_NOT_READY;
        } else {
            //
            // Cardbus card is enumerated, get out of this loop
            //
            DebugPrint((PCMCIA_DEBUG_ENUM, "fdo %08x Pci enumerated %d device object(s)\n",
                                        FdoExtension->DeviceObject, (deviceRelations)->Count));
            status = STATUS_SUCCESS;
            break;
        }
    }

    if (!NT_SUCCESS(status)) {
        //
        // Let pci clean up
        //
        (*FdoExtension->PciCardBusInterface.DeleteCardBus)(FdoExtension->PciCardBusDeviceContext);
        FdoExtension->PciCardBusDeviceContext = NULL;
        ResetDeviceFlag(FdoExtension, PCMCIA_INT_ROUTE_INTERFACE);
        return status;
    }

    ASSERT (deviceRelations && (deviceRelations->Count > 0));
    for (i = 0; i < deviceRelations->Count; i++) {
        PDEVICE_OBJECT pdo;
        PPDO_EXTENSION pdoExtension;
        //
        // Create a filter device for this pci owned pdo
        //
        status = PcmciaCreatePdo(Fdo, socket, &pdo);
        if (!NT_SUCCESS(status)) {
            //
            // Cleanup allocated socket data structures, if any
            //
            DebugPrint((PCMCIA_DEBUG_FAIL, "fdo %08x create pdo failed %08x\n", Fdo, status));
            continue;
        }
        DebugPrint((PCMCIA_DEBUG_INFO, "fdo %08x created pdo %08x (cardbus)\n", Fdo, pdo));
        pdoExtension = pdo->DeviceExtension;
        //
        // Layer ourselves on top of the PCI ejected pdo
        //
        pdoExtension->PciPdo = deviceRelations->Objects[i];
        MarkDeviceCardBus(pdoExtension);

        if (!NT_SUCCESS(PcmciaGetInterface(pdoExtension->PciPdo,
                                           &GUID_BUS_INTERFACE_STANDARD,
                                           sizeof(BUS_INTERFACE_STANDARD),
                                           (PINTERFACE) &pdoExtension->PciBusInterface))) {
            ASSERT(FALSE);
        }

        GetPciConfigSpace(pdoExtension,
                                CFGSPACE_VENDOR_ID,
                                &pdoExtension->CardBusId,
                                sizeof(ULONG));
        DebugPrint((PCMCIA_DEBUG_ENUM, "pdo %08x CardBusId %08x\n", pdo, pdoExtension->CardBusId));

        //
        // Make the intline register of this cardbus card match the parent
        //
        PcmciaUpdateInterruptLine(pdoExtension, FdoExtension);

        //
        // See if there is any CIS data we may need
        //
        PcmciaGetConfigData(pdoExtension);
        //
        // Attach to stack
        //
        pdoExtension->LowerDevice = IoAttachDeviceToDeviceStack(pdo, deviceRelations->Objects[i]);
        //
        // Link this to the flat chain of PDOs hanging off the controller's extension
        //
        pdoExtension->NextPdoInFdoChain = FdoExtension->PdoList;
        FdoExtension->PdoList = pdo;
        pdoExtension->NextPdoInSocket = socket->PdoList;
        socket->PdoList = pdo;
        pdo->Flags &= ~DO_DEVICE_INITIALIZING;
    }
    //
    // Make the current socket point to the head of the pdo list off this socket
    //
    socket->NumberOfFunctions = (UCHAR) deviceRelations->Count;
    if (socket->NumberOfFunctions > 1) {
        //
        // This socket has a multifunction card in it
        //
        SetSocketFlag(socket, SOCKET_CARD_MULTIFUNCTION);
    }

    FdoExtension->PciAddCardBusCount = deviceRelations->Count;
    SetSocketFlag(socket, SOCKET_CLEANUP_PENDING);

    ExFreePool(deviceRelations);

    return status;
}



NTSTATUS
PcmciaEnumerateR2Card(
    IN PSOCKET socket
    )
/*++

Routine Description:

    This enumerates the R2 card present in the given PCMCIA controller,
    and updates the internal structures to reflect the new card state.


Arguments

    socket - pointer to the socket structure which contains the R2 card

Return value

    Status
--*/
{
    PFDO_EXTENSION fdoExtension = socket->DeviceExtension;
    PDEVICE_OBJECT Fdo = fdoExtension->DeviceObject;
    PDEVICE_OBJECT pdo;
    PPDO_EXTENSION pdoExtension = NULL;
    UCHAR           DeviceType;
    NTSTATUS  status;

    status = PcmciaCreatePdo(Fdo, socket, &pdo);

    if (!NT_SUCCESS(status)) {
        return status;
    }
    DebugPrint((PCMCIA_DEBUG_ENUM, "fdo %08x created PDO %08x (R2)\n", Fdo, pdo));
    //
    // initialize the pointers
    //
    pdoExtension = pdo->DeviceExtension;
    //
    // Add a reference count on the socket for power
    //
    PcmciaRequestSocketPower(pdoExtension, NULL);

    //
    // Get configuration info
    //
    status = PcmciaGetConfigData(pdoExtension);

    if (!NT_SUCCESS(status)) {
        DebugPrint((PCMCIA_DEBUG_FAIL, "socket %08x GetConfigData failed %08x\n", socket, status));
        MarkDeviceDeleted(pdoExtension);
        IoDeleteDevice(pdo);
        return status;
    }

    DebugPrint((PCMCIA_DEBUG_ENUM, "pdo %08x R2 CardId %x-%x-%x\n", pdo,
                                              pdoExtension->SocketData->ManufacturerCode,
                                              pdoExtension->SocketData->ManufacturerInfo,
                                              pdoExtension->SocketData->CisCrc
                                              ));

    //
    // Make the socket point to the head of the pdo's hanging off this socket
    //
    socket->PdoList = pdo;
    //
    // Link this to the flat chain of PDOs hanging off the controller's extension
    //
    pdoExtension->NextPdoInFdoChain = fdoExtension->PdoList;
    fdoExtension->PdoList = pdo;
    //
    // Remember if this is a multifunction card in the
    // parent pdo itself
    //
    if (socket->NumberOfFunctions > 1) {
        //
        // This is a multifunction card
        //
        MarkDeviceMultifunction(pdoExtension);
    }

    pdo->Flags &= ~DO_DEVICE_INITIALIZING;

    ASSERT(pdoExtension->SocketData);
    DeviceType = pdoExtension->SocketData->DeviceType;
    if (DeviceType == PCCARD_TYPE_MODEM   ||
        DeviceType == PCCARD_TYPE_SERIAL  ||
        DeviceType == PCCARD_TYPE_NETWORK ||
        DeviceType == PCCARD_TYPE_MULTIFUNCTION3) {
        //
        // We want power IRPs at < DPC_LEVEL
        //
        pdo->Flags |= DO_POWER_PAGABLE;
    }

    SetSocketFlag(socket, SOCKET_CLEANUP_PENDING);
    return status;
}


NTSTATUS
PcmciaDeviceRelations(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp,
    IN DEVICE_RELATION_TYPE RelationType,
    OUT PDEVICE_RELATIONS *DeviceRelations
    )

/*++

Routine Description:

     This routine will force enumeration of the PCMCIA controller represented by Fdo,
     allocate a device relations structure and fill in the count and object array with
     referenced object pointers to the valid PDOs which are created during enumeration

Arguments:

     Fdo - a pointer to the functional device object being enumerated
     Irp - pointer to the Irp
     RelationType - Type of relationship to be retrieved
     DeviceRelations - Structure to store the device relations

--*/

{

    PDEVICE_OBJECT currentPdo;
    PPDO_EXTENSION currentPdoExtension;
    PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
    ULONG newRelationsSize, oldRelationsSize = 0;
    PDEVICE_RELATIONS deviceRelations = NULL, oldDeviceRelations;
    ULONG i;
    ULONG count;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Handle only bus, ejection & removal relations for now
    //

    if (RelationType != BusRelations &&
         RelationType != RemovalRelations) {
        DebugPrint((PCMCIA_DEBUG_INFO,
                        "PcmciaDeviceRelations: RelationType %d, not handled\n",
                        (USHORT) RelationType));
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Need reenumeration only if bus relations are required
    // We need to save the pointer to the old device relations
    // before we call PcmciaReenumerateDevices, as it might trample
    // on it
    //
    oldDeviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;

    // I don't understand how this can be non-null, so I added this
    // assert to find out.
    ASSERT(oldDeviceRelations == NULL);

    if (RelationType == BusRelations) {
        status =  PcmciaEnumerateDevices(Fdo, Irp);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    if ((fdoExtension->LivePdoCount == 0) ||
         (RelationType == RemovalRelations)) {
        //
        // No PDO's to report, we can return early.
        // If no device_relations structure has yet been allocated, however,
        // we need to allocate one & set the count to zero. This will ensure
        // that regardless of whether we pass this IRP down or not, the IO
        // subsystem won't barf.
        //
        if (oldDeviceRelations == NULL) {
            *DeviceRelations = ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));
            if (*DeviceRelations == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            (*DeviceRelations)->Count = 0;
            (*DeviceRelations)->Objects[0] = NULL;
        }
        return STATUS_SUCCESS;
    }

    if (!(oldDeviceRelations) || (oldDeviceRelations->Count == 0)) {
        newRelationsSize =  sizeof(DEVICE_RELATIONS)+(fdoExtension->LivePdoCount - 1)
                                  * sizeof(PDEVICE_OBJECT);
    } else {
        oldRelationsSize = sizeof(DEVICE_RELATIONS) +
                                 (oldDeviceRelations->Count-1) * sizeof(PDEVICE_OBJECT);
        newRelationsSize = oldRelationsSize + fdoExtension->LivePdoCount
                                 * sizeof(PDEVICE_OBJECT);
    }

    deviceRelations = ExAllocatePool(PagedPool, newRelationsSize);

    if (deviceRelations == NULL) {

        DebugPrint((PCMCIA_DEBUG_FAIL,
                        "PcmciaDeviceRelations: unable to allocate %d bytes for device relations\n",
                        newRelationsSize));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (oldDeviceRelations) {
        if ((oldDeviceRelations)->Count > 0) {
            RtlCopyMemory(deviceRelations, oldDeviceRelations, oldRelationsSize);
        }
        count = oldDeviceRelations->Count; // May be zero
        ExFreePool (oldDeviceRelations);
    } else {
        count = 0;
    }
    //
    // Copy the object pointers into the structure
    //
    for (currentPdo = fdoExtension->PdoList ;currentPdo != NULL;
         currentPdo = currentPdoExtension->NextPdoInFdoChain) {

        currentPdoExtension = currentPdo->DeviceExtension;

        if (!IsDevicePhysicallyRemoved(currentPdoExtension)) {
            //
            // Return PCI pdo if it's a cardbus card
            //
            if (IsCardBusCard(currentPdoExtension)) {
                ASSERT(currentPdoExtension->PciPdo != NULL);
                //
                // Return the PDO provided by PCI instead of our filter
                //
                deviceRelations->Objects[count++] = currentPdoExtension->PciPdo;
                status = ObReferenceObjectByPointer(currentPdoExtension->PciPdo,
                                                    0,
                                                    NULL,
                                                    KernelMode);
            } else {
                //
                // Devices have to be referenced by the bus driver
                // before returning them to PNP
                //
                deviceRelations->Objects[count++] = currentPdo;
                status = ObReferenceObjectByPointer(currentPdo,
                                                    0,
                                                    NULL,
                                                    KernelMode);
            }

            if (!NT_SUCCESS(status)) {

                DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaDeviceRelations: status %#08lx "
                                "while referencing object %#08lx\n",
                                status,
                                currentPdo));
            }
        }
    }

    deviceRelations->Count = count;
    *DeviceRelations = deviceRelations;
    return STATUS_SUCCESS;
}



NTSTATUS
PcmciaCreatePdo(
    IN PDEVICE_OBJECT Fdo,
    IN PSOCKET Socket,
    OUT PDEVICE_OBJECT *PdoPtr
    )
/*++

Routine Description:
    Creates and initializes a device object - which will be referred to as a Physical Device
    Object or PDO - for the PC-Card in the socket represented by Socket, hanging off the PCMCIA
    controller represented by Fdo.

Arguments:

    Fdo  - Functional device object representing the PCMCIA controller
    Socket - Socket in which the PC-Card for which we're creating a PDO resides
    PdoPtr - Pointer to an area of memory where the created PDO is returned

Return value:

    STATUS_SUCCESS - Pdo creation/initialization successful, PdoPtr contains the pointer
                            to the Pdo
    Any other status - creation/initialization unsuccessful

--*/
{
    ULONG pdoNameIndex = 0, socketNumber;
    PSOCKET currentSocket;
    PPDO_EXTENSION pdoExtension;
    PFDO_EXTENSION fdoExtension=Fdo->DeviceExtension;
    char deviceName[128];
    ANSI_STRING ansiName;
    UNICODE_STRING unicodeName;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Locate socket 'number'
    //
    for (currentSocket=fdoExtension->SocketList, socketNumber=0;
         currentSocket && (currentSocket != Socket);
         currentSocket = currentSocket->NextSocket, socketNumber++);

    //
    // Allocate space for the Unicode string:(handles upto 0xFFFF
    // devices for now :)
    //
    sprintf(deviceName, "%s%d-%d", PCMCIA_PCCARD_NAME,socketNumber, 0xFFFF);
    RtlInitAnsiString(&ansiName, deviceName);
    status = RtlAnsiStringToUnicodeString(&unicodeName, &ansiName, TRUE);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Attempt to create the device with a unique name
    //
    do {
        sprintf(deviceName, "%s%d-%d", PCMCIA_PCCARD_NAME,socketNumber, pdoNameIndex++);
        RtlInitAnsiString(&ansiName, deviceName);
        status = RtlAnsiStringToUnicodeString(&unicodeName, &ansiName, FALSE);

        if (!NT_SUCCESS(status)) {
            RtlFreeUnicodeString(&unicodeName);
            return status;
        }

        status = IoCreateDevice(
                                Fdo->DriverObject,
                                sizeof(PDO_EXTENSION),
                                &unicodeName,
                                FILE_DEVICE_UNKNOWN,
                                0,
                                FALSE,
                                PdoPtr
                                );
    } while ((status == STATUS_OBJECT_NAME_EXISTS) ||
                (status == STATUS_OBJECT_NAME_COLLISION));

    RtlFreeUnicodeString(&unicodeName);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Initialize the device extension for the PDO
    //
    pdoExtension = (*PdoPtr)->DeviceExtension;
    RtlZeroMemory(pdoExtension, sizeof(PDO_EXTENSION));

    pdoExtension->Signature = PCMCIA_PDO_EXTENSION_SIGNATURE;
    pdoExtension->DeviceObject = *PdoPtr;
    pdoExtension->Socket = Socket;
    pdoExtension->SpecifiedDeviceType = PCCARD_TYPE_RESERVED;

    //
    // Initialize power states
    //
    pdoExtension->SystemPowerState = PowerSystemWorking;
    pdoExtension->DevicePowerState = PowerDeviceD0;

    //
    // Initialize pending enable objects
    //
    KeInitializeTimer(&pdoExtension->ConfigurationTimer);

    KeInitializeDpc(&pdoExtension->ConfigurationDpc,
                    PcmciaConfigurationWorker,
                    pdoExtension);

    KeInitializeTimer(&pdoExtension->PowerWorkerTimer);

    KeInitializeDpc(&pdoExtension->PowerWorkerDpc,
                    PcmciaPdoPowerWorkerDpc,
                    pdoExtension);

    //
    // PNP is going to mark the PDO as a DO_BUS_ENUMERATED_DEVICE,
    // but for CardBus cards- the PDO we return is owned by PCI.
    // Hence we need to mark this device object (in that case a
    // filter on top of PCI's PDO) as PDO explicitly.
    //
    MARK_AS_PDO(*PdoPtr);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\fdopnp.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    fdopnp.c

Abstract:

    This module contains the code that handles PNP irps for pcmcia bus driver
    targeted towards the FDO's (for the pcmcia controller object)

Author:

    Ravisankar Pudipeddi (ravisp) Oct 15 1996
    Neil Sandlin (neilsa) June 1 1999

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

//
// Internal References
//

NTSTATUS
PcmciaFdoFilterResourceRequirements(
    IN  PDEVICE_OBJECT Fdo,
    IN  PIRP             Irp
    );

NTSTATUS
PcmciaFdoGetHardwareIds(
    IN PDEVICE_OBJECT Fdo,
    OUT PUNICODE_STRING HardwareIds
    );

NTSTATUS
PcmciaFdoStartDevice(
    IN  PDEVICE_OBJECT Fdo,
    IN  PIRP             Irp,
    OUT BOOLEAN          *PassedDown,
    OUT BOOLEAN          *NeedsRecompletion
    );

NTSTATUS
PcmciaFdoStopDevice(
    IN  PDEVICE_OBJECT Fdo,
    IN  PIRP             Irp,
    OUT BOOLEAN          *PassedDown,
    OUT BOOLEAN          *NeedsRecompletion
    );

NTSTATUS
PcmciaFdoRemoveDevice(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp
    );

VOID
PcmciaCleanupFdo(
    IN PFDO_EXTENSION FdoExtension
    );

NTSTATUS
PcmciaFdoDeviceCapabilities(
    IN  PDEVICE_OBJECT Fdo,
    IN  PIRP             Irp,
    OUT BOOLEAN          *PassedDown,
    OUT BOOLEAN          *NeedsRecompletion
    );

NTSTATUS
PcmciaAreCardBusCardsSupported(
    IN PFDO_EXTENSION FdoExtension
    );

NTSTATUS
PcmciaFdoGetAssignedResources(
    IN PCM_RESOURCE_LIST ResourceList,
    IN PCM_RESOURCE_LIST TranslatedResourceList,
    IN PFDO_EXTENSION   DeviceExtension
    );


#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, PcmciaFdoPnpDispatch)
    #pragma alloc_text(PAGE, PcmciaFdoGetHardwareIds)
    #pragma alloc_text(PAGE, PcmciaFdoStartDevice)
    #pragma alloc_text(PAGE, PcmciaFdoStopDevice)
    #pragma alloc_text(PAGE, PcmciaFdoRemoveDevice)
    #pragma alloc_text(PAGE, PcmciaFdoFilterResourceRequirements)
    #pragma alloc_text(PAGE, PcmciaFdoGetAssignedResources)
    #pragma alloc_text(PAGE, PcmciaFdoDeviceCapabilities)
    #pragma alloc_text(PAGE, PcmciaAreCardBusCardsSupported)
#endif



NTSTATUS
PcmciaFdoPnpDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    PNP/Power IRPs dispatch routine for the PCMCIA bus controller

Arguments:

    DeviceObject - Pointer to the device object.
    Irp - Pointer to the IRP

Return Value:

    Status

--*/
{

    PIO_STACK_LOCATION nextIrpStack;
    PIO_STACK_LOCATION irpStack          = IoGetCurrentIrpStackLocation(Irp);
    PFDO_EXTENSION   deviceExtension     = DeviceObject->DeviceExtension;
    NTSTATUS             status              = Irp->IoStatus.Status;
    BOOLEAN              PassedDown          = FALSE;
    BOOLEAN              NeedsReCompletion = FALSE;

    PAGED_CODE();

#if DBG
    if (irpStack->MinorFunction > IRP_MN_PNP_MAXIMUM_FUNCTION) {
        DebugPrint((PCMCIA_DEBUG_PNP, "fdo %08x irp %08x - Unknown PNP irp\n",
                                                 DeviceObject, irpStack->MinorFunction));
    } else {
        DebugPrint((PCMCIA_DEBUG_PNP, "fdo %08x irp %08x --> %s\n",
                          DeviceObject, Irp, PNP_IRP_STRING(irpStack->MinorFunction)));
    }
#endif

    switch (irpStack->MinorFunction) {

    case IRP_MN_START_DEVICE: {
            status = PcmciaFdoStartDevice(DeviceObject,
                                          Irp,
                                          &PassedDown,
                                          &NeedsReCompletion);
            break;
        }

    case IRP_MN_QUERY_STOP_DEVICE: {
            status = STATUS_SUCCESS;
            break;
        }

    case IRP_MN_CANCEL_STOP_DEVICE: {
            status = STATUS_SUCCESS;
            break;
        }

    case IRP_MN_STOP_DEVICE: {
            status = PcmciaFdoStopDevice(DeviceObject,
                                         Irp,
                                         &PassedDown,
                                         &NeedsReCompletion);

            break;
        }

    case IRP_MN_QUERY_DEVICE_RELATIONS: {

            //
            // Return the list of devices on the bus
            //

            status = PcmciaDeviceRelations(
                                           DeviceObject,
                                           Irp,
                                           irpStack->Parameters.QueryDeviceRelations.Type,
                                           (PDEVICE_RELATIONS *) &Irp->IoStatus.Information
                                           );
            break;
        }

    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS: {
            status = PcmciaFdoFilterResourceRequirements(DeviceObject, Irp);
            PassedDown = TRUE;
            NeedsReCompletion = TRUE;
            break;
        }

    case IRP_MN_QUERY_REMOVE_DEVICE: {
            status = STATUS_SUCCESS;
            break;
        }

    case IRP_MN_CANCEL_REMOVE_DEVICE: {
            status = STATUS_SUCCESS;
            break;
        }

    case IRP_MN_REMOVE_DEVICE:{
            status = PcmciaFdoRemoveDevice(DeviceObject, Irp);
            PassedDown = TRUE ;
            NeedsReCompletion = TRUE ;
            break;
        }

    case IRP_MN_SURPRISE_REMOVAL: {
            PcmciaFdoStopDevice(DeviceObject, NULL, NULL, NULL);
            status = STATUS_SUCCESS;
            break;
        }

    case IRP_MN_QUERY_ID: {

            UNICODE_STRING unicodeId;

            if (deviceExtension->Flags & PCMCIA_DEVICE_LEGACY_DETECTED) {

                RtlInitUnicodeString(&unicodeId, NULL);

                switch (irpStack->Parameters.QueryId.IdType) {

                case BusQueryHardwareIDs: {

                        DebugPrint((PCMCIA_DEBUG_INFO, " Hardware Ids for fdo %x\n", DeviceObject));
                        status = PcmciaFdoGetHardwareIds(DeviceObject, &unicodeId);

                        if (NT_SUCCESS(status)) {
                            Irp->IoStatus.Information = (ULONG_PTR) unicodeId.Buffer;
                        }
                        break;
                    }
                }
            }
            break;
        }

    case IRP_MN_QUERY_CAPABILITIES: {
            status = PcmciaFdoDeviceCapabilities(DeviceObject,
                                                 Irp,
                                                 &PassedDown,
                                                 &NeedsReCompletion);
            break;
        }

    case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:
            //
            // If this FDO represents a CardBus bridge, we pass this irp down
            // to the PCI PDO which will fill in the PCI bus type and number,
            // otherwise we fail the IRP.
            //

            if (!CardBusExtension(deviceExtension)) {
                 status = STATUS_NOT_IMPLEMENTED;
            }

            //
            // if status is still STATUS_NOT_SUPPORTED, then later code will pass
            // this irp down the stack.
            //
            break;

    default: {
            DebugPrint((PCMCIA_DEBUG_PNP, "fdo %08x irp %08x - Skipping unsupported irp\n", DeviceObject, Irp));
            break;
        }
    }


    if (!PassedDown) {
         //
         // Set the IRP status only if we set it to something other than
         // STATUS_NOT_SUPPORTED.
         //
         if (status != STATUS_NOT_SUPPORTED) {

              Irp->IoStatus.Status = status ;
         }
         //
         // Pass down if success or STATUS_NOT_SUPPORTED. Otherwise, Complete.
         //
         if (NT_SUCCESS(status) || (status == STATUS_NOT_SUPPORTED)) {

              DebugPrint((PCMCIA_DEBUG_PNP, "fdo %08x irp %08x pass %s %08x\n",
                                                              DeviceObject, Irp,
                                                              STATUS_STRING(Irp->IoStatus.Status), Irp->IoStatus.Status));
              //
              // Below macro fills status with return of IoCallDriver. It does
              // not change the Irps status in any way.
              //
              PcmciaSkipCallLowerDriver(status, deviceExtension->LowerDevice, Irp);

         } else {
              DebugPrint((PCMCIA_DEBUG_PNP, "fdo %08x irp %08x comp %s %08x\n",
                                                              DeviceObject, Irp,
                                                              STATUS_STRING(status), status));
              IoCompleteRequest(Irp, IO_NO_INCREMENT);
         }

    } else if (NeedsReCompletion) {
         //
         // Set the IRP status only if we set it to something other than
         // STATUS_NOT_SUPPORTED.
         //
         if (status != STATUS_NOT_SUPPORTED) {

              Irp->IoStatus.Status = status ;
         }

         status = Irp->IoStatus.Status ;
         DebugPrint((PCMCIA_DEBUG_PNP, "fdo %08x irp %08x comp %s %08x\n",
                                                         DeviceObject, Irp,
                                                         STATUS_STRING(status), status));
         IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status ;
}



NTSTATUS
PcmciaFdoDeviceCapabilities(
    IN  PDEVICE_OBJECT Fdo,
    IN  PIRP           Irp,
    OUT BOOLEAN        *PassedDown,
    OUT BOOLEAN        *NeedsRecompletion
    )
/*++

Routine Description
    Records the device capabilities of this pcmcia controller,
    so  1. they can be used in the power management for the controller
    and 2. they can be used for determining the capabilities of the
             child pc-card PDO's of this pcmcia controller.
    If this is legacy detected pcmcia controller (ISA-based), the pdo for
    the pcmcia controller is a dummy madeup device - hence  the capabilities
    are filled in by ourselves.
    Otherwise, the capabilities are obtained by sending down the Irp
    to the parent bus.
    In either case, the capabilities are cached in the device extension of
    the pcmcia controller for future use.

Arguments

    Fdo                 - Pointer to functional device object of the pcmcia
                              controller
    Irp                 - Pointer to the i/o request packet
    PassedDown          - Contains FALSE on entry, which means caller must
                              complete or pass down irp based on status. If set
                              to TRUE, Irp may need to be re-completed...
    NeedsRecompletion - ...In which case this parameter will be checked

Return Value

    STATUS_SUCCESS                           Capabilities returned
    STATUS_INSUFFICIENT_RESOURCES        Could not allocate memory to cache the capabilities

--*/
{
    PFDO_EXTENSION fdoExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_CAPABILITIES capabilities;
    NTSTATUS        status;

    PAGED_CODE();

    capabilities = irpStack->Parameters.DeviceCapabilities.Capabilities;
    fdoExtension = Fdo->DeviceExtension;

    if (fdoExtension->Flags & PCMCIA_DEVICE_LEGACY_DETECTED) {

        //
        // This is a madeup devnode (ISA based PCMCIA controller).
        // Fill in the capabilities ourselves
        //
        RtlZeroMemory(capabilities,
                          sizeof(DEVICE_CAPABILITIES));
        //
        // Non removable, non ejectable
        //
        capabilities->Removable       = FALSE;
        capabilities->UniqueID        = FALSE;
        capabilities->EjectSupported = FALSE;
        //
        // Address & number need work..
        //
        capabilities->Address  = -1;
        capabilities->UINumber = -1;
        //
        // We cannot power down this controller
        //
        capabilities->DeviceState[PowerSystemSleeping1] = PowerDeviceD0;
        capabilities->DeviceState[PowerSystemSleeping2] = PowerDeviceD0;
        capabilities->DeviceState[PowerSystemSleeping3] = PowerDeviceD0;
        capabilities->DeviceState[PowerSystemHibernate] = PowerDeviceD3;
        //
        // Obviously wake is not supported on this legacy detected
        // piece of xxxx
        //
        capabilities->SystemWake = PowerSystemUnspecified;
        capabilities->DeviceWake = PowerDeviceUnspecified;
        capabilities->D1Latency = 0;
        capabilities->D2Latency = 0;
        capabilities->D3Latency = 0;
        status = STATUS_SUCCESS;
    } else {

        //
        // Either a PCI-PCMCIA bridge or PCI-Cardbus bridge
        // Send this down the stack to obtain the capabilities
        //
        ASSERT (fdoExtension->LowerDevice != NULL);

        status = PcmciaIoCallDriverSynchronous(fdoExtension->LowerDevice, Irp);

        *PassedDown          = TRUE ;
        *NeedsRecompletion = TRUE ;
    }

    if (NT_SUCCESS(status)) {

        //
        // NOTE: HACKHACK:
        //
        // Here we provide an option to override the device wake of the pcmcia controller.
        // There are several controllers, notably TI 12xx controllers, which say they
        // can wake from D3, but really can effectively only do WOL from D2. That's because they
        // turn of socket power when put into D3. They fixed this on the TI 14xx line.
        //
        // So here we update the device wake field, and potentially the device states from the BIOS.
        // Note that this has to be used carefully, and only override a particular BIOS's settings
        // where it has been verified the device still works at the lower (more awake) device state.
        //
        if (PcmciaControllerDeviceWake) {
            if (PcmciaControllerDeviceWake < capabilities->DeviceWake) {
                capabilities->DeviceWake = PcmciaControllerDeviceWake;
            }
            if (PcmciaControllerDeviceWake < capabilities->DeviceState[PowerSystemSleeping1]) {
                capabilities->DeviceState[PowerSystemSleeping1] = PcmciaControllerDeviceWake;
            }
            if (PcmciaControllerDeviceWake < capabilities->DeviceState[PowerSystemSleeping2]) {
                capabilities->DeviceState[PowerSystemSleeping2] = PcmciaControllerDeviceWake;
            }
            if (PcmciaControllerDeviceWake < capabilities->DeviceState[PowerSystemSleeping3]) {
                capabilities->DeviceState[PowerSystemSleeping3] = PcmciaControllerDeviceWake;
            }
        }

        //
        // Cache the device capabilities in the device extension
        // for this pcmcia controller.
        //
        RtlCopyMemory(&fdoExtension->DeviceCapabilities,
                      capabilities,
                      sizeof(DEVICE_CAPABILITIES));

    } else {

        RtlZeroMemory(&fdoExtension->DeviceCapabilities, sizeof(DEVICE_CAPABILITIES));

    }

    return status;
}



NTSTATUS
PcmciaFdoFilterResourceRequirements(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp
    )
/*++

Routine Description

     Filters Resource requirements for PCMCIA controllers generated
     by the bus driver controlling the PDO for the PCMCIA controller.
     Currently adds memory range as an additional resource requirement
     since the BAR doesn't specify this

     Note for CardBus controllers:
     It is necessary to request an attribute memory window here for
     reading CIS of 16-bit PC-Cards - we need a 24 bit address for that,
     and this is the most elegant way of doing it - instead of
     special casing it in PCI driver

Arguments

     DeviceExtension - Pointer to extension for the PCMCIA controller in question
     IoReqList        - Pointer the the original resource requiremnts ejected by
                             the bus driver
     FilteredRequirements - Pointer to the filtered resource req. list will be returned
                                    in this variable

Return Value:

     STATUS_SUCCESS  if filtering is successful
     Any other status - could not filter

--*/
{

    PFDO_EXTENSION                    fdoExtension = Fdo->DeviceExtension;
    PIO_RESOURCE_REQUIREMENTS_LIST  oldReqList;
    PIO_RESOURCE_REQUIREMENTS_LIST  newReqList;
    PIO_RESOURCE_LIST                 oldList, newList;
    PIO_RESOURCE_DESCRIPTOR           ioResourceDesc;
    ULONG                                 newReqSize;
    ULONG                                 oldlistSize, newlistSize, altListSize;
    ULONG                                 index;
    ULONG                                 IntCount = 0;
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                              status;

    PAGED_CODE();

    status = PcmciaIoCallDriverSynchronous(fdoExtension->LowerDevice, Irp);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (Irp->IoStatus.Information == 0) {

        oldReqList = irpStack->Parameters.FilterResourceRequirements.IoResourceRequirementList;

        if (oldReqList == NULL) {
            //
            // NULL List, nothing to do
            //
            return(Irp->IoStatus.Status);
        }

    } else {
        //
        // Use the returned list
        //
        oldReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)Irp->IoStatus.Information;
    }


    //
    // Add an alternative list without the IRQ requirement, if one exists. Model the
    // new alternative list after the first list.
    //

    oldList = oldReqList->List;
    ioResourceDesc = oldList->Descriptors;
    altListSize = 0;

    for (index = 0; index < oldList->Count; index++) {
        // Count the descriptors, excluding any IRQ descriptors
        if (ioResourceDesc->Type == CmResourceTypeInterrupt) {
            IntCount++;
        }
        ioResourceDesc++;
    }

    if (IntCount) {
        //
        // "+1" because we are adding two later, but IO_RESOURCE_LIST already has 1
        //
        altListSize = sizeof(IO_RESOURCE_LIST) + ((oldList->Count+1)-IntCount)*sizeof(IO_RESOURCE_DESCRIPTOR);
    }

    //
    // Add a memory range requirement to what we already have..
    //
    newReqSize = oldReqList->ListSize +
                     oldReqList->AlternativeLists*2*sizeof(IO_RESOURCE_DESCRIPTOR) +
                     altListSize;
    newReqList = ExAllocatePool(PagedPool, newReqSize);

    if (newReqList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(newReqList, oldReqList, FIELD_OFFSET(IO_RESOURCE_REQUIREMENTS_LIST, List));
    newReqList->ListSize = newReqSize;

    newList = newReqList->List;
    oldList = oldReqList->List;

    for (index = 0; index < oldReqList->AlternativeLists; index++) {
        //
        // Compute the size of the current original list
        //
        oldlistSize = sizeof(IO_RESOURCE_LIST) + (oldList->Count-1) * sizeof(IO_RESOURCE_DESCRIPTOR);
        newlistSize = oldlistSize;
        RtlCopyMemory(newList, oldList, newlistSize);

        //
        // Add memory requirement
        //
        ioResourceDesc = (PIO_RESOURCE_DESCRIPTOR) (((PUCHAR) newList) + newlistSize);

        ioResourceDesc->Option = IO_RESOURCE_PREFERRED;
        ioResourceDesc->Type = CmResourceTypeMemory;
        ioResourceDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        ioResourceDesc->Flags = CM_RESOURCE_MEMORY_READ_WRITE;
        ioResourceDesc->u.Memory.MinimumAddress.QuadPart = fdoExtension->AttributeMemoryLow;
        ioResourceDesc->u.Memory.MaximumAddress.QuadPart = fdoExtension->AttributeMemoryHigh;
        ioResourceDesc->u.Memory.Length                      = fdoExtension->AttributeMemorySize;
        ioResourceDesc->u.Memory.Alignment                   = fdoExtension->AttributeMemoryAlignment;
        if (fdoExtension->Flags & PCMCIA_MEMORY_24BIT) {
            ioResourceDesc->u.Memory.MaximumAddress.QuadPart &= 0xFFFFFF;
        }
        ioResourceDesc++;
        //
        // The other - less restrictive - alternative.
        //
        ioResourceDesc->Option = IO_RESOURCE_ALTERNATIVE;
        ioResourceDesc->Type = CmResourceTypeMemory;
        ioResourceDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        ioResourceDesc->Flags = CM_RESOURCE_MEMORY_READ_WRITE;
        ioResourceDesc->u.Memory.MinimumAddress.QuadPart = 0;
        ioResourceDesc->u.Memory.MaximumAddress.QuadPart = 0xFFFFFFFF;
        ioResourceDesc->u.Memory.Length   = fdoExtension->AttributeMemorySize;
        ioResourceDesc->u.Memory.Alignment = fdoExtension->AttributeMemoryAlignment;
        if (fdoExtension->Flags & PCMCIA_MEMORY_24BIT) {
            ioResourceDesc->u.Memory.MaximumAddress.QuadPart &= 0xFFFFFF;
        }

        newList->Count += 2;
        newlistSize += 2*sizeof(IO_RESOURCE_DESCRIPTOR);

        oldList = (PIO_RESOURCE_LIST) (((PUCHAR) oldList) + oldlistSize);
        newList = (PIO_RESOURCE_LIST) (((PUCHAR) newList) + newlistSize);
    }

    if (altListSize != 0) {
        PIO_RESOURCE_DESCRIPTOR oldResourceDesc;
        //
        // Here we add the alternate list which doesn't contain an IRQ requirement.
        // Note that we use the first "new list" as the "old list". This way, we
        // pick up the things we added in the previous loop. All we have to do is
        // copy every descriptor except for the interrupt descriptor.
        //
        // Note: newList is still set from previous loop
        //
        oldList = newReqList->List;

        //
        // First copy the basic structure without the descriptors
        //
        RtlCopyMemory(newList, oldList, sizeof(IO_RESOURCE_LIST) - sizeof(IO_RESOURCE_DESCRIPTOR));

        oldResourceDesc = oldList->Descriptors;
        ioResourceDesc = newList->Descriptors;

        for (index = 0; index < oldList->Count; index++) {

            if (oldResourceDesc->Type != CmResourceTypeInterrupt) {
                *ioResourceDesc = *oldResourceDesc;
                ioResourceDesc++;

            } else {
                //
                // We've deleted a descriptor
                //
                newList->Count--;
            }
            oldResourceDesc++;
        }
        newReqList->AlternativeLists++;
    }


    Irp->IoStatus.Information = (ULONG_PTR) newReqList;
    irpStack->Parameters.FilterResourceRequirements.IoResourceRequirementList =
                                                                                        newReqList;

    //
    // Free up the old resource reqs
    //
    ExFreePool(oldReqList);

    fdoExtension->Flags |= PCMCIA_FILTER_ADDED_MEMORY;
    return STATUS_SUCCESS;
}



NTSTATUS
PcmciaFdoGetHardwareIds(
    IN PDEVICE_OBJECT Fdo,
    OUT PUNICODE_STRING HardwareIds
    )

/*++

Routine description:

    This routine returns the hardware ids for the given 'legacy' pcmcia controller
    NOTE: this routine is required only for pcmcia controllers detected by this driver
    itself and registered via IoReportDetectedDevice.

Arguments:

    Fdo - Pointer to the functional device object representing the pcmcia controller
    CompatibleIds - Pointer to the unicode string which would contain the hardware ids
                         as a multi-string on return

Return value:

    STATUS_SUCCESS
    Any other status - could not generate compatible ids
--*/

{
    PCSTR   strings[2];
    PCMCIA_CONTROLLER_TYPE controllerType;
    ULONG   count, index;
    BOOLEAN found;

    PAGED_CODE();

    controllerType  = ((PFDO_EXTENSION)Fdo->DeviceExtension)->ControllerType;
    found = FALSE;

    for (index = 0; (PcmciaAdapterHardwareIds[index].ControllerType != PcmciaInvalidControllerType); index++) {
        if (PcmciaAdapterHardwareIds[index].ControllerType == controllerType) {
            found = TRUE;
            break;
        }
    }

    if (found) {
        strings[0] = PcmciaAdapterHardwareIds[index].Id;
    } else {
        DebugPrint((PCMCIA_DEBUG_INFO, "PcmciaGetAdapterHardwareIds: Could not find find hardware id for %x, controllerType %x\n",
                        Fdo,
                        controllerType
                      ));

        strings[0] = "";
    }

    count = 1;
    return PcmciaStringsToMultiString(strings,
                                      count,
                                      HardwareIds);
}




NTSTATUS
PcmciaFdoStartDevice(
    IN  PDEVICE_OBJECT Fdo,
    IN  PIRP           Irp,
    OUT BOOLEAN        *PassedDown,
    OUT BOOLEAN        *NeedsRecompletion
    )
/*++

Routine Description:

     This routine will start the PCMCIA controller with the supplied
     resources.  The IRP is sent down to the pdo first, so PCI or ISAPNP
     or whoever sits underneath gets a chance to program the controller
     to decode the resources.

Arguments:

     Fdo                     - Functional device object of the PCMCIA controller
     Irp                     - Well, it's the start irp, yah?
     PassedDown          - Contains FALSE on entry, which means caller must
                                complete or pass down irp based on status. If set
                                to TRUE, Irp may need to be re-completed...
     NeedsRecompletion - ...In which case this parameter will be checked

Return value:

     Status

--*/
{
    NTSTATUS             status;
    PFDO_EXTENSION   deviceExtension = Fdo->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PCM_RESOURCE_LIST  resList, translatedResList, newResList, newTranslatedResList;

    PAGED_CODE();

    if (deviceExtension->Flags & PCMCIA_DEVICE_STARTED) {
        //
        // Start to already started device
        //
        DebugPrint((PCMCIA_DEBUG_FAIL,"PcmciaFdoStartDevice: Fdo %x already started\n",
                        Fdo));
        return STATUS_SUCCESS;
    }

    //
    // Parse AllocatedResources & get IoPort/AttributeMemoryBase/IRQ info.
    //
    status = PcmciaFdoGetAssignedResources(irpStack->Parameters.StartDevice.AllocatedResources,
                                           irpStack->Parameters.StartDevice.AllocatedResourcesTranslated,
                                           deviceExtension
                                           );

    if (!NT_SUCCESS(status)) {
        //
        // Ha. This is most likely a START for a madeup devnode (report-detected legacy PCMCIA controller)
        // which has been removed subsequently, hence not reported again with proper resources.
        // We return an appropriate status
        //
        DebugPrint((PCMCIA_DEBUG_FAIL, "Pcmcia: No  resources assigned to FDO, probably bogus START for"
                        "non-existent controller\n" ));
        return STATUS_NO_SUCH_DEVICE;
    }

    DebugPrint((PCMCIA_DEBUG_PNP, "fdo %08x StartAdapter: AttrMem Base %x\n", Fdo, deviceExtension->PhysicalBase));
    DebugPrint((PCMCIA_DEBUG_PNP, "                       VirtualBase %x AttrMem Size %x\n", deviceExtension->AttributeMemoryBase, deviceExtension->AttributeMemorySize));

    if (deviceExtension->Flags & PCMCIA_FILTER_ADDED_MEMORY) {
        ULONG newSize;
        ULONG index;
        PCM_PARTIAL_RESOURCE_LIST   resPartialList, translatedResPartialList;
        PCM_PARTIAL_RESOURCE_DESCRIPTOR resDesc, translatedResDesc;
        PCM_PARTIAL_RESOURCE_DESCRIPTOR newResDesc, newTranslatedResDesc;
        //
        // We need to remove the memory resource requirement
        //
        resList= irpStack->Parameters.StartDevice.AllocatedResources;
        resPartialList = &resList->List[0].PartialResourceList;
        translatedResList= irpStack->Parameters.StartDevice.AllocatedResourcesTranslated;
        translatedResPartialList = &translatedResList->List[0].PartialResourceList;

        newSize = sizeof(CM_RESOURCE_LIST) + (resPartialList->Count-2)*sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
        newResList = ExAllocatePool(PagedPool,
                                    newSize);
        if (newResList == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        newTranslatedResList = ExAllocatePool(PagedPool,
                                              newSize);

        if (newTranslatedResList == NULL) {
            ExFreePool(newResList);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        newResList->Count = newTranslatedResList->Count = 1;
        newResList->List[0].InterfaceType = resList->List[0].InterfaceType;
        newTranslatedResList->List[0].InterfaceType = translatedResList->List[0].InterfaceType;
        newResList->List[0].BusNumber = resList->List[0].BusNumber;
        newTranslatedResList->List[0].BusNumber = translatedResList->List[0].BusNumber;

        newResList->List[0].PartialResourceList.Version  = resPartialList->Version;
        newResList->List[0].PartialResourceList.Revision = resPartialList->Revision;
        newResList->List[0].PartialResourceList.Count    = resPartialList->Count - 1;

        newTranslatedResList->List[0].PartialResourceList.Version  = translatedResPartialList->Version;
        newTranslatedResList->List[0].PartialResourceList.Revision = translatedResPartialList->Revision;
        newTranslatedResList->List[0].PartialResourceList.Count    = translatedResPartialList->Count - 1;


        resDesc = resPartialList->PartialDescriptors;
        translatedResDesc = translatedResPartialList->PartialDescriptors;
        newResDesc = newResList->List[0].PartialResourceList.PartialDescriptors;
        newTranslatedResDesc = newTranslatedResList->List[0].PartialResourceList.PartialDescriptors;

        if (CardBusExtension(deviceExtension)) {
            //
            // Remove last memory descriptor - which is what we added
            //
            RtlCopyMemory(newResDesc,
                          resDesc,
                          newResList->List[0].PartialResourceList.Count * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

            RtlCopyMemory(newTranslatedResDesc,
                          translatedResDesc,
                          newTranslatedResList->List[0].PartialResourceList.Count * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

        } else {
            //
            // Remove the only memory descriptor..
            //
            for (index = 0; index < resPartialList->Count;
                 index++, resDesc++, translatedResDesc++, newResDesc++, newTranslatedResDesc++) {
                if (resDesc->Type != CmResourceTypeMemory) {
                    *newResDesc = *resDesc;
                    *newTranslatedResDesc = *translatedResDesc;
                }
            }
        }

        irpStack->Parameters.StartDevice.AllocatedResources = newResList;
        irpStack->Parameters.StartDevice.AllocatedResourcesTranslated = newTranslatedResList;
    }

    //
    // Send this down to the PDO first
    //

    status = PcmciaIoCallDriverSynchronous(deviceExtension->LowerDevice, Irp);
    *PassedDown = TRUE ;

    //
    // We set this because the completion routine returns
    // STATUS_MORE_PROCESSING_REQUIRED, which means it needs to be completed
    // again.
    //
    *NeedsRecompletion = TRUE ;

    if (deviceExtension->Flags & PCMCIA_FILTER_ADDED_MEMORY) {
        ExFreePool(newResList);
        ExFreePool(newTranslatedResList);
        irpStack->Parameters.StartDevice.AllocatedResources = resList;
        irpStack->Parameters.StartDevice.AllocatedResourcesTranslated = translatedResList;
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Give the hardware some time to settle after returning from the pdo
    //
    PcmciaWait(256);

    //
    // Initialize the hardware
    //

    status = PcmciaStartPcmciaController(Fdo);


    if (NT_SUCCESS(status)) {
        deviceExtension->Flags |= PCMCIA_DEVICE_STARTED;
    }
    //
    // Remember if cardbus cards will be supported for this controller
    //
    if (CardBusExtension(deviceExtension) &&
         !PcmciaAreCardBusCardsSupported(deviceExtension)) {
        deviceExtension->Flags |= PCMCIA_CARDBUS_NOT_SUPPORTED;
    }
    return status;
}





NTSTATUS
PcmciaFdoStopDevice(
    IN  PDEVICE_OBJECT Fdo,
    IN  PIRP             Irp                      OPTIONAL,
    OUT BOOLEAN          *PassedDown          OPTIONAL,
    OUT BOOLEAN          *NeedsRecompletion OPTIONAL
    )
/*++

Routine Description:

    IRP_MN_STOP_DEVICE handler for the given pcmcia controller.
    If Irp is present, it'll send it down first to the PDO.
    Unhooks the interrupt/cancels poll timer etc.

Arguments:

    Fdo                 - Pointer to functional device object for the pcmcia
                              controller
    Irp                 - If present it's the pointer to the stop Irp initiated
                              by PnP
    PassedDown          - Contains FALSE on entry, which means caller must
                              complete or pass down irp based on status. If set
                              to TRUE, Irp may need to be re-completed...
    NeedsRecompletion - ...In which case this parameter will be checked.

                              Note: PassedDown and NeedsCompletion are ignored and
                                      optional only if Irp is NULL.

Return value:

    STATUS_SUCCESS  - Pcmcia controller successfully stopped
    Other               - Stop failed

--*/
{
    PFDO_EXTENSION deviceExtension = Fdo->DeviceExtension;
    PSOCKET         socket;
    NTSTATUS        status;

    if (!(deviceExtension->Flags & PCMCIA_DEVICE_STARTED)) {
        //
        // Already stopped
        //
        return STATUS_SUCCESS;
    }

    PcmciaFdoDisarmWake(deviceExtension);

    //
    // Disable the interrupt
    //
    if (deviceExtension->PcmciaInterruptObject) {

        for (socket = deviceExtension->SocketList; socket; socket = socket->NextSocket) {
            //
            // Disable the controller interrupts
            //
            (*(socket->SocketFnPtr->PCBEnableDisableCardDetectEvent))(socket, FALSE);
            (*(socket->SocketFnPtr->PCBEnableDisableWakeupEvent))(socket, NULL, FALSE);
            //
            // Apparently IBM ThinkPads like this
            //
            PcmciaWait(PCMCIA_ENABLE_DELAY);
        }
    }

    //
    // the bus driver below us will make us go offline
    //
    deviceExtension->Flags |= PCMCIA_FDO_OFFLINE;

    //
    // clear pending event
    //
    KeCancelTimer(&deviceExtension->EventTimer);

    //
    // Send this down to the PDO
    //
    if (ARGUMENT_PRESENT(Irp)) {

        status = PcmciaIoCallDriverSynchronous(deviceExtension->LowerDevice, Irp);

        *PassedDown = TRUE ;
        *NeedsRecompletion = TRUE ;


        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    if (deviceExtension->Flags & PCMCIA_USE_POLLED_CSC) {
        //
        // cancel the card status change poller
        //
        KeCancelTimer(&deviceExtension->PollTimer);
        deviceExtension->Flags &= ~PCMCIA_USE_POLLED_CSC;
    }

    if (deviceExtension->PcmciaInterruptObject) {
        //
        // unhook the interrupt
        //
        IoDisconnectInterrupt(deviceExtension->PcmciaInterruptObject);
        deviceExtension->PcmciaInterruptObject = NULL;
    }

    //
    // Unmap any i/o space or memory we might have mapped
    //
    if (deviceExtension->Flags & PCMCIA_ATTRIBUTE_MEMORY_MAPPED) {
        MmUnmapIoSpace(deviceExtension->AttributeMemoryBase,
                            deviceExtension->AttributeMemorySize);
        deviceExtension->Flags &= ~PCMCIA_ATTRIBUTE_MEMORY_MAPPED;
        deviceExtension->AttributeMemoryBase = 0;
        deviceExtension->AttributeMemorySize = 0;
    }

    if (deviceExtension->Flags & PCMCIA_SOCKET_REGISTER_BASE_MAPPED) {
        MmUnmapIoSpace(deviceExtension->CardBusSocketRegisterBase,
                            deviceExtension->CardBusSocketRegisterSize);
        deviceExtension->Flags &= ~PCMCIA_SOCKET_REGISTER_BASE_MAPPED;
        deviceExtension->CardBusSocketRegisterBase = 0;
        deviceExtension->CardBusSocketRegisterSize = 0;
    }

    deviceExtension->Flags &= ~PCMCIA_DEVICE_STARTED;
    return STATUS_SUCCESS;
}



NTSTATUS
PcmciaFdoRemoveDevice(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp
    )
/*++

Routine Description:

    Handles IRP_MN_REMOVE for the pcmcia controller.
    Stops the adapter if it isn't already, sends the IRP
    to the PDO first & cleans up the Fdo for this controller
    and detaches & deletes the device object.

Arguments:

    Fdo - Pointer to functional device object for the controller
              to be removed

Return value:

    Status

--*/
{
    PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PDEVICE_OBJECT pdo, nextPdo, fdo, prevFdo;
    PPDO_EXTENSION pdoExtension;
    NTSTATUS        status;
    ULONG waitCount = 0;

    UNREFERENCED_PARAMETER(Irp);

    if (fdoExtension->Flags & PCMCIA_DEVICE_STARTED) {
        //
        // Stop the fdo first.
        //
        PcmciaFdoStopDevice(Fdo, NULL, NULL, NULL);
    }

    //
    // Send this down to the PDO
    //

    status = PcmciaIoCallDriverSynchronous(fdoExtension->LowerDevice, Irp);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Synchronize with power routines
    //
    while(!PCMCIA_TEST_AND_SET(&fdoExtension->DeletionLock)) {
        PcmciaWait(1000000);
        if (waitCount++ > PCMCIA_DELETION_TIMEOUT) {
            ASSERT(waitCount <= PCMCIA_DELETION_TIMEOUT);
            break;
        }
    }

    //
    // If the PdoList in the fdoExtension is non-empty it means:
    // that the PDOs in the list were not physically removed, but
    // a soft REMOVE was issued, hence they are still hanging on
    // and now this controller itself is being REMOVED.
    // Hence we dispose of those PDOs now
    //

    for (pdo = fdoExtension->PdoList; pdo != NULL ; pdo = nextPdo) {
        DebugPrint((PCMCIA_DEBUG_INFO,
                        "RemoveDevice: pdo %x child of fdo %x was not removed before fdo\n",
                        pdo, Fdo));

        pdoExtension = pdo->DeviceExtension;

        ASSERT (!IsDevicePhysicallyRemoved(pdoExtension));
        //
        // It's possible for this bit to be on, if the device was added,
        // but never started (because of some other error.
        //ASSERT (!IsDeviceAlive(pdoExtension));

        nextPdo =  pdoExtension->NextPdoInFdoChain;
        if (!IsDeviceDeleted(pdoExtension)) {
            MarkDeviceDeleted(pdoExtension);
            PcmciaCleanupPdo(pdo);
            IoDeleteDevice(pdo);
        }
    }

    MarkDeviceDeleted(fdoExtension);
    PcmciaCleanupFdo(fdoExtension);

    //
    // Remove this from the fdo list..
    //
    prevFdo = NULL;
    for (fdo = FdoList; fdo != NULL; prevFdo = fdo, fdo = fdoExtension->NextFdo) {
        fdoExtension = fdo->DeviceExtension;
        if (fdo == Fdo) {
            if (prevFdo) {
                //
                // Delink this fdo
                //
                ((PFDO_EXTENSION)prevFdo->DeviceExtension)->NextFdo
                = fdoExtension->NextFdo;
            } else {
                FdoList = fdoExtension->NextFdo;
            }
            break;
        }
    }

    DebugPrint((PCMCIA_DEBUG_PNP, "fdo %08x Remove detach & delete\n", Fdo));
    IoDetachDevice(((PFDO_EXTENSION)Fdo->DeviceExtension)->LowerDevice);
    IoDeleteDevice(Fdo);

    return STATUS_SUCCESS;
}



VOID
PcmciaCleanupContext(
    IN PPCMCIA_CONTEXT pContext
    )
/*++

Routine Description

    Frees up allocated pool associated with a specific controller
    register context.

Arguments

    pContext - pointer to a PCMCIA_CONTEXT structure

Return value

    none

--*/
{
    pContext->RangeCount = 0;

    if (pContext->Range) {
        ExFreePool(pContext->Range);
        pContext->Range = NULL;
    }
}



VOID
PcmciaCleanupFdo(
    IN PFDO_EXTENSION FdoExtension
    )
/*++

Routine Description

    Frees up allocated pool, deletes symbolic links etc. for the
    associated FDO for the pcmcia controller which is to be removed.

Arguments

    FdoExtension    - Pointer to the device extension for the FDO of the pcmcia controller
                          which is being removed

Return value

    none

--*/
{
    PSOCKET         socket, nextSocket;

    //
    // Free the controller register context
    //
    PcmciaCleanupContext(&FdoExtension->PciContext);
    if (FdoExtension->PciContextBuffer) {
        ExFreePool(FdoExtension->PciContextBuffer);
        FdoExtension->PciContextBuffer = NULL;
    }

    PcmciaCleanupContext(&FdoExtension->CardbusContext);
    PcmciaCleanupContext(&FdoExtension->ExcaContext);

    //
    // Delete symbolic links to this fdo
    //
    if (FdoExtension->LinkName.Buffer != NULL) {
        IoDeleteSymbolicLink(&FdoExtension->LinkName);
        RtlFreeUnicodeString(&FdoExtension->LinkName);
    }

    //
    // Cleanup the socket structures
    //
    for (socket = FdoExtension->SocketList; socket != NULL; socket = nextSocket) {

        if (socket->CardbusContextBuffer) {
            ExFreePool(socket->CardbusContextBuffer);
            socket->CardbusContextBuffer = NULL;
        }

        if (socket->ExcaContextBuffer) {
            ExFreePool(socket->ExcaContextBuffer);
            socket->ExcaContextBuffer = NULL;
        }

        nextSocket = socket->NextSocket;
        ExFreePool(socket);
    }

    FdoExtension->SocketList = NULL;
    return;
}



NTSTATUS
PcmciaFdoGetAssignedResources(
    IN PCM_RESOURCE_LIST ResourceList,
    IN PCM_RESOURCE_LIST TranslatedResourceList,
    IN PFDO_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    Extracts the assigned resources to the pcmcia controller

Arguments:

    ResourceList                - Raw resource list
    TranslatedResourceList
    DeviceExtension         - Device extension of the PCMCIA controller

Return value:

    STATUS_SUCCESS
    STATUS_UNSUCCESSFUL      if resources are not right or enough.

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR        fullResourceDesc;
    PCM_PARTIAL_RESOURCE_LIST           partialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialResourceDesc;
    ULONG                                   addressSpace;
    PHYSICAL_ADDRESS                        physicalAddress;
    PHYSICAL_ADDRESS                        translatedAddress;
    ULONG i;
    ULONG attributeIndex;
    PULONG                                  devicePrivate;
    BOOLEAN                                 translated;

    PAGED_CODE();


    if ((ResourceList == NULL) || (ResourceList->Count <=0) ) {
        return STATUS_UNSUCCESSFUL;
    }


    if (CardBusExtension(DeviceExtension)) {

        fullResourceDesc=&TranslatedResourceList->List[0];
        DeviceExtension->Configuration.InterfaceType = fullResourceDesc->InterfaceType;
        DeviceExtension->Configuration.BusNumber = fullResourceDesc->BusNumber;

        partialResourceList = &fullResourceDesc->PartialResourceList;
        partialResourceDesc = partialResourceList->PartialDescriptors;
        //
        // We need just the exca register base
        // According to PeterJ the first descriptor
        // for us is the cardbus socket register base.
        // We trust him.
        for (i=0; (i < partialResourceList->Count) && (partialResourceDesc->Type != CmResourceTypeMemory);
             i++, partialResourceDesc++);
        if (i >= partialResourceList->Count) {
            return STATUS_UNSUCCESSFUL;
        };

        //
        // This is memory. We need to map it
        //
        DeviceExtension->CardBusSocketRegisterBase = MmMapIoSpace(partialResourceDesc->u.Memory.Start,
                                                                  partialResourceDesc->u.Memory.Length,
                                                                  FALSE);
        DeviceExtension->CardBusSocketRegisterSize = partialResourceDesc->u.Memory.Length;

        DeviceExtension->Flags |= PCMCIA_SOCKET_REGISTER_BASE_MAPPED;

        //
        // Last BAR is attribute memory window. This will be peeled off later.
        // It might be a good idea to tack a device private on at the end to
        // confirm this. However how do we guarantee our device private does
        // not contain the same data as somebody else's? PnP is lacking here -
        // we need some convention so that devices can set uniquely identifying stuff
        // in there - like maybe the device object they own - to identify it is
        // theirs. Till then this should do.
        //
        if (i > (partialResourceList->Count - 2)) {
            //
            // No more resources? Bail out.
            //
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        for (i++, partialResourceDesc++; (i < (partialResourceList->Count - 1));i++,partialResourceDesc++);
        //
        // partialResourceDesc points to the last descriptor
        //
        ASSERT (partialResourceDesc->Type == CmResourceTypeMemory);
        DeviceExtension->PhysicalBase = partialResourceDesc->u.Memory.Start;
        //
        // This is memory. We need to map it
        //
        DeviceExtension->AttributeMemoryBase = MmMapIoSpace(partialResourceDesc->u.Memory.Start,
                                                            partialResourceDesc->u.Memory.Length,
                                                            FALSE);
        DeviceExtension->AttributeMemorySize = partialResourceDesc->u.Memory.Length;
        DeviceExtension->Flags |= PCMCIA_ATTRIBUTE_MEMORY_MAPPED;

        //
        // Finally see if an IRQ is assigned
        //

        for (i = 0, partialResourceDesc = partialResourceList->PartialDescriptors;
             (i < partialResourceList->Count) && (partialResourceDesc->Type != CmResourceTypeInterrupt);
             i++,partialResourceDesc++);


        if (i < partialResourceList->Count) {
            //
            // We have an interrupt to used for CSC
            // PCI will ensure that this interrupt is exactly the
            // same as the one assigned to the functional interrupt
            // for a cardbus pc-card in this controller's socket
            //
            DebugPrint((PCMCIA_DEBUG_INFO, "PcmciaGetAssignedResources: Interrupt resource assigned\n"));
            DeviceExtension->Configuration.TranslatedInterrupt = *partialResourceDesc;
            //
            // Get the raw interrupt resource  - needed to enable the interrupt on the controller
            //
            fullResourceDesc=&ResourceList->List[0];
            partialResourceList = &fullResourceDesc->PartialResourceList;
            partialResourceDesc = partialResourceList->PartialDescriptors;
            for (i=0; (i< partialResourceList->Count) && (partialResourceDesc->Type != CmResourceTypeInterrupt);
                 i++, partialResourceDesc++);
            if (i < partialResourceList->Count) {
                DeviceExtension->Configuration.Interrupt = *partialResourceDesc;
            } else {
                //
                // Should not happen.. translated descriptor was present, but raw is missing!
                // Just reset the translated interrupt and pretend no interrupt was assigned
                //
                RtlZeroMemory(&DeviceExtension->Configuration.TranslatedInterrupt, sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));
            }
        }
    } else {
        //
        // 16-bit pcmcia controller
        //
        fullResourceDesc=&ResourceList->List[0];
        DeviceExtension->Configuration.InterfaceType = fullResourceDesc->InterfaceType;
        DeviceExtension->Configuration.BusNumber = fullResourceDesc->BusNumber;

        partialResourceList = &fullResourceDesc->PartialResourceList;
        partialResourceDesc = partialResourceList->PartialDescriptors;

        for (i=0; i<partialResourceList->Count; i++, partialResourceDesc++) {

            devicePrivate = partialResourceDesc->u.DevicePrivate.Data;

            switch (partialResourceDesc->Type) {

            case CmResourceTypeInterrupt: {
                    if (DeviceExtension->ControllerType != PcmciaCLPD6729 &&
                         DeviceExtension->ControllerType != PcmciaPciPcmciaBridge &&
                         DeviceExtension->ControllerType != PcmciaNEC98 &&
                         DeviceExtension->ControllerType != PcmciaNEC98102) {

                        // We always poll for Cirrus Logic PCI to PCMCIA  controllers
                        // and other PCI-PCMCIA bridges
                        //

                        DeviceExtension->Configuration.Interrupt = *partialResourceDesc;
                    }
                    break;
                }
            case CmResourceTypePort: {
                    DeviceExtension->Configuration.UntranslatedPortAddress = (USHORT) partialResourceDesc->u.Port.Start.QuadPart;
                    DeviceExtension->Configuration.PortSize = (USHORT) partialResourceDesc->u.Port.Length;
                    break;
                }
            case CmResourceTypeMemory: {
                    DeviceExtension->PhysicalBase =          partialResourceDesc->u.Memory.Start;
                    DeviceExtension->AttributeMemorySize =  partialResourceDesc->u.Memory.Length;
                    attributeIndex = i;
                    break;
                }
            }
        }

        if ((DeviceExtension->PhysicalBase.QuadPart == 0) ||
             (DeviceExtension->Configuration.UntranslatedPortAddress == 0)) {

            DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaGetAssignedResources: Need both memory and i/o for pcmcia controller 0x%X\n",
                            DeviceExtension->DeviceObject));
            return STATUS_INSUFFICIENT_RESOURCES;
        }


        fullResourceDesc=&TranslatedResourceList->List[0];
        partialResourceList = &fullResourceDesc->PartialResourceList;
        partialResourceDesc = &partialResourceList->PartialDescriptors[attributeIndex];


        switch (partialResourceDesc->Type) {

        case CmResourceTypeMemory:
            DeviceExtension->AttributeMemoryBase = MmMapIoSpace(partialResourceDesc->u.Memory.Start,
                                                                DeviceExtension->AttributeMemorySize,
                                                                FALSE);
            DeviceExtension->Flags |= PCMCIA_ATTRIBUTE_MEMORY_MAPPED;
            break;

        case CmResourceTypePort:
            DeviceExtension->AttributeMemoryBase = (PUCHAR)(partialResourceDesc->u.Port.Start.QuadPart);
            DeviceExtension->Flags &= ~PCMCIA_ATTRIBUTE_MEMORY_MAPPED;
            break;

        default:
            ASSERT(FALSE);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    }
    return STATUS_SUCCESS;
}



NTSTATUS
PcmciaAreCardBusCardsSupported(
    IN PFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

    Indicates if cardbus cards will be supported on the given PCMCIA
    controller on this system
    Currently we support cardbus cards only on:
         Machines on which BIOS programmed the bus numbers & IntLine

Arguments:

    FdoExtension - Pointer to device extension for the pcmcia controller

Return Value:

    TRUE  - if cardbus cards are supported
    FALSE - if not

--*/
{
    UCHAR               byte;

    PAGED_CODE();

    //
    // Check int line
    //
    GetPciConfigSpace(FdoExtension,
                      CFGSPACE_INT_LINE,
                      &byte,
                      1);
    if (byte == 0xff) {
        return FALSE;
    }

    //
    // Check  cardbus bus number
    //
    GetPciConfigSpace(FdoExtension,
                      CFGSPACE_CARDBUS_BUSNUM,
                      &byte,
                      1);
    if (byte == 0) {
        return FALSE;
    }

    //
    // Check subordinate bus number
    //
    GetPciConfigSpace(FdoExtension,
                      CFGSPACE_SUB_BUSNUM,
                      &byte,
                      1);
    if (byte == 0) {
        return FALSE;
    }

    //
    // All tests passed
    //
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\id.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    id.c

Abstract:

    This module contains the code to handle IRP_MN_QUERY_ID

Authors:

    Ravisankar Pudipeddi (ravisp)

Environment:

    Kernel mode only

Notes:

Revision History:

    Neil Sandlin (neilsa) - split off from pdopnp.c

--*/

#include "pch.h"

//
// Internal References
//

NTSTATUS
PcmciaGenerateDeviceId(
    IN  PSOCKET_DATA      SocketData,
    IN  ULONG             FunctionNumber,
    OUT PUCHAR           *DeviceId
    );

BOOLEAN
PcmciaCheckInstance(
    IN PUCHAR  DeviceId,
    IN ULONG   Instance
    );

NTSTATUS
PcmciaGetDeviceType(
    IN  PDEVICE_OBJECT Pdo,
    IN  ULONG FunctionNumber,
    OUT PUCHAR DeviceType
    );

VOID
PcmciaFilterIdString(
    IN PUCHAR pIn,
    OUT PUCHAR pOut,
    ULONG MaxLen
    );


#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE,  PcmciaGenerateDeviceId)
    #pragma alloc_text(PAGE,  PcmciaGetDeviceId)
    #pragma alloc_text(PAGE,  PcmciaGetHardwareIds)
    #pragma alloc_text(PAGE,  PcmciaGetCompatibleIds)
    #pragma alloc_text(PAGE,  PcmciaGetDeviceType)
    #pragma alloc_text(PAGE,  PcmciaFilterIdString)
#endif


#define PCMCIA_MAX_DEVICE_TYPE_SUPPORTED 12

const
UCHAR *PcmciaCompatibleIds[PCMCIA_MAX_DEVICE_TYPE_SUPPORTED+1] = {
    "",            // Unknown..
    "",            // Memory card (RAM, ROM, EPROM, Flash)
    "",            // Serial I/O port, includes modems
    "",            // Parallel printer port
    "*PNP0600",    // Disk driver (ATA)
    "",            // Video interface
    "",            // Local Area Network adapter
    "",            // Auto Increment Mass Storage card
    "",            // SCSI bridge card
    "",            // Security card
    "*PNP0D00",    // Multi-Function 3.0 PC Card
    "",            // Flash memory card
    "*PNPC200",    // Modem card (sync with PCCARD_TYPE_MODEM)
};



NTSTATUS
PcmciaGenerateDeviceId(
    IN  PSOCKET_DATA      SocketData,
    IN  ULONG             FunctionNumber,
    OUT PUCHAR           *DeviceId
    )
/*++
    The device ID is created from tuple information on the PC Card
    The goal is to create a unique ID for each
    card.  The device ID is created from the manufacturer name string,
    the product name string, and a 16-bit CRC of a set of tuples.

    The ID is created by concatenating the "PCMCIA" prefix, the manufacturer
    name string, the product name string and the 16-bit CRC for the card.

         PCMCIA\<manuf_name>-<prod_name>-<crc>

    If the CISTPL_VERS_1 tuple is not available, or the manufacturer name is
    NULL, the string "UNKNOWN_MANUFACTURER" will be included in its place.

    If this is for a child function within a multifunctionn card, the generated
    device id would be:

         PCMCIA\<manuf_name>-<prod_name>-DEV<function number>-<crc>

    This device id is compatible with win 9x device id's (excluding the instance
    number which is returned separtely by handling another IRP.

Arguments:

    Pdo             - Pointer to the physical device object for the pc-card
    FunctionNumber - Function number of the function in  a multi-function card.
                          If this is PCMCIA_MULTIFUNCTION_PARENT, then the requested device id
                          is for the parent device - not for any individual function
    DeviceId        - Pointer to the string in which device id is returned

Return Value

    Status

--*/
{
    PUCHAR deviceId;

    PAGED_CODE();

    deviceId = ExAllocatePool(PagedPool, PCMCIA_MAXIMUM_DEVICE_ID_LENGTH);

    if (deviceId == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    //  Generate the device id
    //
    if (*(SocketData->Mfg) == '\0' ) {
        //
        // No manufacturer name available
        //
        if (FunctionNumber == PCMCIA_MULTIFUNCTION_PARENT) {
            //
            // Device id for the pc-card
            //
            if (SocketData->Flags & SDF_JEDEC_ID) {
                //
                // Flash memory cards have the special device id
                //
                sprintf(deviceId, "%s\\%s-%04x",
                          PCMCIA_ID_STRING,
                          PCMCIA_MEMORY_ID_STRING,
                          SocketData->JedecId);

            } else {
                sprintf(deviceId, "%s\\%s-%04X",
                          PCMCIA_ID_STRING,
                          PCMCIA_UNKNOWN_MANUFACTURER_STRING,
                          SocketData->CisCrc);
            }
        } else {
            //
            // This is for the individual multifunction child
            //
            sprintf(deviceId, "%s\\%s-DEV%d-%04X",
                      PCMCIA_ID_STRING,
                      PCMCIA_UNKNOWN_MANUFACTURER_STRING,
                      FunctionNumber,
                      SocketData->CisCrc);
        }

    } else {
        UCHAR Mfg[MAX_MANFID_LENGTH];
        UCHAR Ident[MAX_IDENT_LENGTH];

        PcmciaFilterIdString(SocketData->Mfg, Mfg, MAX_MANFID_LENGTH);
        PcmciaFilterIdString(SocketData->Ident, Ident, MAX_IDENT_LENGTH);

        if (FunctionNumber == PCMCIA_MULTIFUNCTION_PARENT) {
            //
            // Device id for the pc-card
            //
            sprintf(deviceId, "%s\\%s-%s-%04X",
                      PCMCIA_ID_STRING,
                      Mfg,
                      Ident,
                      SocketData->CisCrc);
        } else {
            //
            // This is for the individual multifunction child
            //
            sprintf(deviceId, "%s\\%s-%s-DEV%d-%04X",
                      PCMCIA_ID_STRING,
                      Mfg,
                      Ident,
                      FunctionNumber,
                      SocketData->CisCrc);

        }
    }

    *DeviceId = deviceId;
    DebugPrint((PCMCIA_DEBUG_INFO, "pdo %08x Device Id=%s\n", SocketData->PdoExtension->DeviceObject, deviceId));

    if ((FunctionNumber == PCMCIA_MULTIFUNCTION_PARENT) &&
         (SocketData->PdoExtension != NULL) &&
         (SocketData->PdoExtension->DeviceId == NULL)) {
        //
        // Keep a copy of the device id
        //
        PPDO_EXTENSION pdoExtension = SocketData->PdoExtension;

        pdoExtension->DeviceId = ExAllocatePool(NonPagedPool, strlen(deviceId)+1);
        if (pdoExtension->DeviceId) {
            RtlCopyMemory(pdoExtension->DeviceId, deviceId, strlen(deviceId)+1);
        }
    }
    return STATUS_SUCCESS;
}


NTSTATUS
PcmciaGetDeviceId(
    IN  PDEVICE_OBJECT  Pdo,
    IN  ULONG           FunctionNumber,
    OUT PUNICODE_STRING DeviceId
    )
/*++

    Generated device id is returned for the supplied pc-card

Arguments:

    Pdo             - Pointer to the physical device object for the pc-card
    FunctionNumber - Function number of the function in  a multi-function card.
                          If this is PCMCIA_MULTIFUNCTION_PARENT, then the requested device id
                          is for the parent device - not for any individual function
    DeviceId        - Pointer to the unicode string in which device id is returned

Return Value

    Status

--*/
{
    PPDO_EXTENSION pdoExtension=Pdo->DeviceExtension;
    PSOCKET_DATA    socketData = pdoExtension->SocketData;
    ANSI_STRING ansiId;
    PUCHAR      deviceId;
    NTSTATUS    status;

    PAGED_CODE();

    ASSERT(DeviceId);

    if (!socketData) {
        ASSERT (socketData);
        return STATUS_DEVICE_NOT_READY;
    }

    status = PcmciaGenerateDeviceId(socketData,
                                    FunctionNumber,
                                    &deviceId);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    RtlInitAnsiString(&ansiId,  deviceId);

    status =  RtlAnsiStringToUnicodeString(DeviceId,
                                           &ansiId,
                                           TRUE);
    ExFreePool(deviceId);
    return status;
}


NTSTATUS
PcmciaGetHardwareIds(
    IN  PDEVICE_OBJECT  Pdo,
    IN  ULONG           FunctionNumber,
    OUT PUNICODE_STRING HardwareIds
    )
/*++

Routine Description:

    This routine generates the hardware id's for the given PC-Card and returns them
    as a Unicode multi-string.
    Hardware ids for PC-Cards are:

    1. The device id of the PC-Card
    2. The device id of the PC-Card with the CRC replaced with the Manufacturer code and
        Manufacturer info fields obtained from the tuple information on the PC-Card

    These hardware id's are compatible with win 9x hardware ids

Arguments:

    Pdo - Pointer to device object representing the PC-Card
    FunctionNumber - Function number of the function in  a multi-function card.
                          If this is PCMCIA_MULTIFUNCTION_PARENT, then the requested hardware id
                          is for the parent device - not for any individual function
    HardwareIds - Pointer to the unicode string which contains the hardware id's as a multi-string

Return value:

--*/
{
    PPDO_EXTENSION pdoExtension=Pdo->DeviceExtension;
    PSOCKET socket = pdoExtension->Socket;
    PSOCKET_DATA socketData = pdoExtension->SocketData;
    NTSTATUS status;
    PSTR        strings[4] = {NULL};
    PUCHAR  hwId, hwId2;
    UCHAR   deviceType;
    UCHAR   stringCount = 0;

    PAGED_CODE();

    if (!socketData) {
        ASSERT (socketData);
        return STATUS_DEVICE_NOT_READY;
    }

    //
    // get the device type for later use
    //
    status = PcmciaGetDeviceType(Pdo, FunctionNumber, &deviceType);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // The first hardware id is identical to the device id
    // Generate the device id
    //
    status = PcmciaGenerateDeviceId(socketData,
                                    FunctionNumber,
                                    &strings[stringCount++]);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    try {
        status = STATUS_INSUFFICIENT_RESOURCES;

        hwId = ExAllocatePool(PagedPool, PCMCIA_MAXIMUM_DEVICE_ID_LENGTH);

        if (!hwId) {
            leave;
        }
        strings[stringCount++] = hwId;

        //
        // The second hardware is the device id with the CRC replaced
        // with the manufacturer code and info
        //
        if (*(socketData->Mfg) == '\0' ) {
            //
            // No manufacturer name available
            //
            if (FunctionNumber == PCMCIA_MULTIFUNCTION_PARENT) {
                if (socketData->Flags & SDF_JEDEC_ID) {
                    sprintf(hwId, "%s\\%s-%04x",
                              PCMCIA_ID_STRING,
                              PCMCIA_MEMORY_ID_STRING,
                              socketData->JedecId);
                } else {
                    sprintf(hwId, "%s\\%s-%04X-%04X",
                              PCMCIA_ID_STRING,
                              PCMCIA_UNKNOWN_MANUFACTURER_STRING,
                              socketData->ManufacturerCode,
                              socketData->ManufacturerInfo);
                }
            } else {
                sprintf(hwId, "%s\\%s-DEV%d-%04X-%04X", PCMCIA_ID_STRING,
                          PCMCIA_UNKNOWN_MANUFACTURER_STRING,
                          FunctionNumber,
                          socketData->ManufacturerCode,
                          socketData->ManufacturerInfo);

            }

            DebugPrint((PCMCIA_DEBUG_INFO, "pdo %08x HwId=%s\n", Pdo, hwId));

        } else {
            UCHAR Mfg[MAX_MANFID_LENGTH];
            UCHAR Ident[MAX_IDENT_LENGTH];

            PcmciaFilterIdString(socketData->Mfg, Mfg, MAX_MANFID_LENGTH);
            PcmciaFilterIdString(socketData->Ident, Ident, MAX_IDENT_LENGTH);

            //
            // Here a mistake on Win2000 is forcing us to now generate two different
            // IDs. The intended and documented form at this point is to generate:
            //
            //   PCMCIA\<mfg>-<ident>-<code>-<info>
            //
            // but Win2000 had a bug where this was generated instead:
            //
            //   PCMCIA\<mfg>-<code>-<info>
            //
            // So now we generate both in case someone started using the bogus format.
            //

            hwId2 = ExAllocatePool(PagedPool, PCMCIA_MAXIMUM_DEVICE_ID_LENGTH);

            if (!hwId2) {
                leave;
            }
            strings[stringCount++] = hwId2;

            if (FunctionNumber == PCMCIA_MULTIFUNCTION_PARENT) {
                sprintf(hwId, "%s\\%s-%s-%04X-%04X", PCMCIA_ID_STRING,
                          Mfg,
                          Ident,
                          socketData->ManufacturerCode,
                          socketData->ManufacturerInfo);

                sprintf(hwId2, "%s\\%s-%04X-%04X", PCMCIA_ID_STRING,
                          Mfg,
                          socketData->ManufacturerCode,
                          socketData->ManufacturerInfo);
            } else {
                sprintf(hwId, "%s\\%s-%s-DEV%d-%04X-%04X",
                          PCMCIA_ID_STRING,
                          Mfg,
                          Ident,
                          FunctionNumber,
                          socketData->ManufacturerCode,
                          socketData->ManufacturerInfo);

                sprintf(hwId2, "%s\\%s-DEV%d-%04X-%04X",
                          PCMCIA_ID_STRING,
                          Mfg,
                          FunctionNumber,
                          socketData->ManufacturerCode,
                          socketData->ManufacturerInfo);
            }
            DebugPrint((PCMCIA_DEBUG_INFO, "pdo %08x HwId=%s\n", Pdo, hwId));
            DebugPrint((PCMCIA_DEBUG_INFO, "pdo %08x HwId=%s\n", Pdo, hwId2));
        }


        if (deviceType == PCCARD_TYPE_ATA) {

            hwId = ExAllocatePool(PagedPool, PCMCIA_MAXIMUM_DEVICE_ID_LENGTH);

            if (!hwId) {
                leave;
            }
            strings[stringCount++] = hwId;

            sprintf(hwId, "%s\\%s",
                      PCMCIA_ID_STRING,
                      PcmciaCompatibleIds[PCCARD_TYPE_ATA]);

            DebugPrint((PCMCIA_DEBUG_INFO, "pdo %08x HwId=%s\n", Pdo, hwId));
        }

        status = PcmciaStringsToMultiString(strings , stringCount, HardwareIds);

    } finally {

        while(stringCount != 0) {
            ExFreePool(strings[--stringCount]);
        }

    }

    return  status;
}


NTSTATUS
PcmciaGetCompatibleIds(
    IN  PDEVICE_OBJECT Pdo,
    IN  ULONG FunctionNumber,
    OUT PUNICODE_STRING CompatibleIds
    )
/*++

Routine Description:

    This routine returns the  compatible ids for the given PC-Card.
    Compatible id's are generated based on the Function Id of the PC-Card
    obtained from the CISTPL_FUNCID in the CIS tuple info. on the PC-Card.
    A table lookup is done based on the CISTPL_FUNCID to obtain the compatible id

    This compatible id is identical to the win 9x generated compatible ids

Arguments:

    Pdo - Pointer to the device object representing the PC-Card
    FunctionNumber - Function number of the function in  a multi-function card.
                          If this is PCMCIA_MULTIFUNCTION_PARENT, then the requested compatibleid
                          is for the parent device - not for any individual function
    CompatibleIds - Pointer to the unicode string which would contain the compatible ids
                         as a multi-string on return

Return value:

    STATUS_SUCCESS
    Any other status - could not generate compatible ids

--*/
{
    UCHAR   deviceType ;
    NTSTATUS status;
    PCSTR strings[1] = {""};

    PAGED_CODE();

    status = PcmciaGetDeviceType(Pdo, FunctionNumber, &deviceType);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    if ((deviceType == PCCARD_TYPE_RESERVED) ||
         (deviceType > PCMCIA_MAX_DEVICE_TYPE_SUPPORTED)) {
        status =  PcmciaStringsToMultiString(strings, 1, CompatibleIds);
    } else {
        status =  PcmciaStringsToMultiString(&PcmciaCompatibleIds[deviceType], 1, CompatibleIds);
        DebugPrint((PCMCIA_DEBUG_INFO, "pdo %08x CompatId=%s\n", Pdo, PcmciaCompatibleIds[deviceType]));
    }

    return status;
}


NTSTATUS
PcmciaGetDeviceType(
    IN  PDEVICE_OBJECT Pdo,
    IN  ULONG FunctionNumber,
    OUT PUCHAR DeviceType
    )
/*++

Routine Description:

    This routine returns the device type for the given PC-Card.
    device type is obtained from the CISTPL_FUNCID in the CIS tuple info. on the PC-Card.

Arguments:

    Pdo - Pointer to the device object representing the PC-Card
    FunctionNumber - Function number of the function in  a multi-function card.
                          If this is PCMCIA_MULTIFUNCTION_PARENT, then the requested compatibleid
                          is for the parent device - not for any individual function

Return value:

    device type

--*/
{
    UCHAR   deviceType ;
    PPDO_EXTENSION pdoExtension;

    PAGED_CODE();

    pdoExtension = Pdo->DeviceExtension;

    if (IsDeviceMultifunction(pdoExtension)) {
        if (FunctionNumber == PCMCIA_MULTIFUNCTION_PARENT) {
            //
            // This is for the root multifunction pc-card
            //
            deviceType = PCCARD_TYPE_MULTIFUNCTION3;
        } else {
            //
            // This is for the individual multifunction child
            //
            PSOCKET_DATA socketData;
            ULONG index;

            for (socketData = pdoExtension->SocketData, index = 0; (socketData != NULL);
                 socketData = socketData->Next,index++) {
                if (socketData->Function == FunctionNumber) {
                    //
                    // Found the child;
                    //
                    break;
                }
            }
            if (!socketData) {
                ASSERT (socketData);
                return STATUS_DEVICE_NOT_READY;
            }
            deviceType = socketData->DeviceType;
        }
    } else {
        //
        // This is a run-of-the mill single function card
        //
        deviceType = pdoExtension->SocketData->DeviceType;
    }

    *DeviceType = deviceType;
    return STATUS_SUCCESS;
}


NTSTATUS
PcmciaStringsToMultiString(
    IN PCSTR * Strings,
    IN ULONG Count,
    IN PUNICODE_STRING MultiString
    )
/*++

Routine Description:

    This routine formats a set of supplied strings into a multi string format, terminating
    it with a double '\0' character

Arguments:

    Strings - Pointer to an array of strings
    Count -  Number of strings in the supplied array which are packed into the multi-string
    MultiString - Pointer to the Unicode string which packs the supplied string as a multi-string
                      terminated by double NULL

Return value:

    STATUS_SUCCESS
    STATUS_INSUFFICIENT_RESOURCES - Could not allocate memory for the multi-string


--*/
{
    ULONG i, multiStringLength=0;
    UNICODE_STRING tempMultiString;
    PCSTR * currentString;
    ANSI_STRING ansiString;
    NTSTATUS status;


    ASSERT (MultiString->Buffer == NULL);

    for (i = Count, currentString = Strings; i > 0;i--, currentString++) {
        RtlInitAnsiString(&ansiString, *currentString);
        multiStringLength += RtlAnsiStringToUnicodeSize(&ansiString);

    }
    ASSERT(multiStringLength != 0);
    multiStringLength += sizeof(WCHAR);

    if (multiStringLength > MAXUSHORT) {
        return STATUS_UNSUCCESSFUL;
    }

    MultiString->Buffer = ExAllocatePool(PagedPool, multiStringLength);
    if (MultiString->Buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    MultiString->MaximumLength = (USHORT) multiStringLength;
    MultiString->Length = (USHORT) multiStringLength;

    tempMultiString = *MultiString;

    for (i = Count, currentString = Strings; i > 0;i--, currentString++) {
        RtlInitAnsiString(&ansiString, *currentString);
        status = RtlAnsiStringToUnicodeString(&tempMultiString,
                                              &ansiString,
                                              FALSE);
        ASSERT(NT_SUCCESS(status));
        ((PSTR) tempMultiString.Buffer) += tempMultiString.Length + sizeof(WCHAR);
    };

    //
    // Add one more NULL to terminate the multi string
    //
    RtlZeroMemory(tempMultiString.Buffer, sizeof(WCHAR));
    return STATUS_SUCCESS;
}


NTSTATUS
PcmciaGetInstanceId(
    IN PDEVICE_OBJECT Pdo,
    OUT PUNICODE_STRING InstanceId
    )
/*++

Routine Description:

    This routine generates a unique instance id (1 upwards) for the supplied
    PC-Card which is guaranteed not to clash with any other instance ids under
    the same pcmcia controller, for the same type of card.
    A new instance id is computed only if it was not already  present for the PC-Card.

Arguments:

    Pdo - Pointer to the  device object representing the PC-Card
    InstanceId -  Pointer to a unicode string which will contain the generated
                      instance id.
                      Memory for the unicode string allocated by this routine.
                      Caller's responsibility to free it .

Return value:

    STATUS_SUCCESS
    STATUS_UNSUCCESSFUL - Currently there's a cap on the maximum value of instance id - 999999
                                 This status returned only if more than 999999 PC-Cards exist under
                                 this PCMCIA controller!
    Any other status - Something failed in the string allocation/conversion

--*/
{
    PPDO_EXTENSION pdoExtension=Pdo->DeviceExtension;
    PSOCKET socket = pdoExtension->Socket;
    PSOCKET_DATA socketData = pdoExtension->SocketData;
    ULONG   instance;
    NTSTATUS status;
    ANSI_STRING sizeString;

    ASSERT(InstanceId);

    if (!socketData) {
        return STATUS_DEVICE_NOT_READY;
    }
    //
    // Allocate memory for the unicode string
    // Maximum of 6 digits in the instance..
    //
    RtlInitAnsiString(&sizeString, "123456");
    status = RtlAnsiStringToUnicodeString(InstanceId, &sizeString, TRUE);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Don't recompute instance if it's already present
    //
    if (socketData->Instance) {

        status = RtlIntegerToUnicodeString(socketData->Instance, 10, InstanceId);

    } else {
        KIRQL OldIrql;
        //
        // Synchronize access to prevent two identical ids/instances
        //
        KeAcquireSpinLock(&PcmciaGlobalLock, &OldIrql);

        //
        // assume failure
        //
        status = STATUS_UNSUCCESSFUL;

        for (instance = 1; instance <= PCMCIA_MAX_INSTANCE; instance++) {
            if (PcmciaCheckInstance(pdoExtension->DeviceId,
                                    instance)) {
                socketData->Instance = instance;
                break;
            }
        }

        KeReleaseSpinLock(&PcmciaGlobalLock, OldIrql);

        if (socketData->Instance) {
            status = RtlIntegerToUnicodeString(instance, 10, InstanceId);
        }
    }

    if (!NT_SUCCESS(status)) {
        RtlFreeUnicodeString(InstanceId);
    }

    if (NT_SUCCESS(status)) {
        DebugPrint((PCMCIA_DEBUG_INFO, "pdo %08x InstanceId=%d\n", Pdo, socketData->Instance));
    }

    return status;
}


BOOLEAN
PcmciaCheckInstance(
    IN PUCHAR  DeviceId,
    IN ULONG   Instance
    )
/*++

Routine Description:

    This routine checks to see if the supplied instance id clashes with any other PC-card
    with the same device id

Arguments:

    SocketList - Pointer to the list of sockets on the PCMCIA controller
    DeviceId   - Pointer to the device id of the PC-Card for which the Instance Id is being checked
    Instance   - Instance Id which needs to be verified

Return value:

    TRUE - Instance is unique for the given DeviceId and may be used
    FALSE - Instance clashes with another instance id for the same device id

--*/
{
    PPDO_EXTENSION pdoExtension;
    PFDO_EXTENSION fdoExtension;
    PSOCKET_DATA    socketData;
    PDEVICE_OBJECT fdo, pdo;

    for (fdo = FdoList; fdo != NULL; fdo = fdoExtension->NextFdo) {
        fdoExtension = fdo->DeviceExtension;
        ASSERT (fdoExtension);

        if (!IsDeviceStarted(fdoExtension)) {
            continue;
        }

        for (pdo = fdoExtension->PdoList; pdo != NULL; pdo = pdoExtension->NextPdoInFdoChain) {
            pdoExtension = pdo->DeviceExtension;
            socketData = pdoExtension->SocketData;

            if (IsDevicePhysicallyRemoved(pdoExtension)) {
                //
                // going to be removed soon
                //
                continue;
            }
            if (!socketData) {
                //
                // socketData already cleaned up
                //
                continue;
            }
            //
            // If  an instance has not
            // been assigned yet to this card, skip
            //
            if (socketData->Instance == 0) {
                continue;
            }

            //
            // If this socket's device id matches the given socket's device id
            // compare the instances: if equal, then this instance is not ok.
            //
            //
            if ((pdoExtension->DeviceId == NULL) || (DeviceId == NULL)) {
                continue;
            }

            if ((strcmp(pdoExtension->DeviceId, DeviceId)==0) &&
                 (socketData->Instance == Instance)) {
                return FALSE;
            }
        }
    }
    //
    // Instance is ok and unique
    //
    return TRUE;
}



VOID
PcmciaFilterIdString(
    IN PUCHAR pIn,
    OUT PUCHAR pOut,
    ULONG MaxLen
    )
/*++

    Filters out characters that shouldn't appear in device id's

Arguments:

    pIn  - pointer to input string
    pOut     - pointer to output string
    MaxLen - size of buffers

Return Value

    none

--*/
{
    ULONG i;

    for (i=0; i < MaxLen; i++) {

        if (*pIn == 0) {
            *pOut = 0;
            break;
        }

        if (*pIn >= ' ' && *pIn < 0x7F) {
             *pOut++ = *pIn++;
        } else {
             pIn++;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\fdopower.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    fdopower.c

Abstract:

    This module contains code to handle
    IRP_MJ_POWER dispatches for PCMCIA controllers
    Contains support routines for pc-card power management


Authors:

    Ravisankar Pudipeddi (ravisp) May 30, 1997
    Neil Sandlin (neilsa) June 1, 1999

Environment:

    Kernel mode only

Notes:

Revision History:

    Neil Sandlin (neilsa) April 16, 1999
       - split setpower into device and system, fixed synchronization

--*/

#include "pch.h"

//
// Internal References
//

NTSTATUS
PcmciaFdoWaitWake(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP             Irp
    );

NTSTATUS
PcmciaFdoWaitWakeIoCompletion(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP             Irp,
    IN PVOID            Context
    );

NTSTATUS
PcmciaFdoSaveControllerContext(
    IN PFDO_EXTENSION FdoExtension
    );

NTSTATUS
PcmciaFdoRestoreControllerContext(
    IN PFDO_EXTENSION FdoExtension
    );

NTSTATUS
PcmciaFdoSaveSocketContext(
    IN PSOCKET Socket
    );

NTSTATUS
PcmciaFdoRestoreSocketContext(
    IN PSOCKET Socket
    );

NTSTATUS
PcmciaSetFdoPowerState(
    IN PDEVICE_OBJECT Fdo,
    IN OUT PIRP Irp
    );

NTSTATUS
PcmciaSetFdoSystemPowerState(
    IN PDEVICE_OBJECT Fdo,
    IN OUT PIRP Irp
    );

VOID
PcmciaFdoSystemPowerDeviceIrpComplete(
    IN PDEVICE_OBJECT Fdo,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
PcmciaSetFdoDevicePowerState(
    IN PDEVICE_OBJECT Fdo,
    IN OUT PIRP Irp
    );

NTSTATUS
PcmciaFdoPowerWorker (
    IN PVOID Context,
    IN NTSTATUS Status
    );

NTSTATUS
PcmciaFdoDevicePowerCompletion(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp,
    IN PVOID Context
    );

//
//
//


NTSTATUS
PcmciaFdoPowerDispatch(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles power requests
    for the PDOs.

Arguments:

    Pdo - pointer to the physical device object
    Irp - pointer to the io request packet

Return Value:

    status

--*/

{
    PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS         status = STATUS_INVALID_DEVICE_REQUEST;


    switch (irpStack->MinorFunction) {

    case IRP_MN_SET_POWER: {

            DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x --> IRP_MN_SET_POWER\n", Fdo, Irp));
            DebugPrint((PCMCIA_DEBUG_POWER, "                              (%s%x context %x)\n",
                            (irpStack->Parameters.Power.Type == SystemPowerState)  ?
                            "S":
                            ((irpStack->Parameters.Power.Type == DevicePowerState) ?
                             "D" :
                             "Unknown"),
                            irpStack->Parameters.Power.State,
                            irpStack->Parameters.Power.SystemContext
                          ));
            status = PcmciaSetFdoPowerState(Fdo, Irp);
            break;
        }

    case IRP_MN_QUERY_POWER: {

            DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x --> IRP_MN_QUERY_POWER\n", Fdo, Irp));
            DebugPrint((PCMCIA_DEBUG_POWER, "                              (%s%x context %x)\n",
                            (irpStack->Parameters.Power.Type == SystemPowerState)  ?
                            "S":
                            ((irpStack->Parameters.Power.Type == DevicePowerState) ?
                             "D" :
                             "Unknown"),
                            irpStack->Parameters.Power.State,
                            irpStack->Parameters.Power.SystemContext
                          ));
            //
            // Let the pdo handle it
            //
            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(fdoExtension->LowerDevice, Irp);
            break;
        }

    case IRP_MN_WAIT_WAKE: {
            DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x --> IRP_MN_WAIT_WAKE\n", Fdo, Irp));
            status = PcmciaFdoWaitWake(Fdo, Irp);
            break;
        }

    default: {
            DebugPrint((PCMCIA_DEBUG_POWER, "FdoPowerDispatch: Unhandled Irp %x received for 0x%08x\n",
                            Irp,
                            Fdo));

            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(fdoExtension->LowerDevice, Irp);
            break;
        }
    }
    DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x <-- %08x\n", Fdo, Irp, status));
    return status;
}


/**************************************************************************

    WAKE ROUTINES

 **************************************************************************/


NTSTATUS
PcmciaFdoWaitWake(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP             Irp
    )
/*++


Routine Description

    Handles WAIT_WAKE for the given pcmcia controller

Arguments

    Pdo - Pointer to the functional device object for the pcmcia controller
    Irp - The IRP_MN_WAIT_WAKE Irp

Return Value

    STATUS_PENDING  - Wait wake is pending
    STATUS_SUCCESS  - Wake is already asserted, wait wake IRP is completed
                              in this case
    Any other status    - Error
--*/

{
    PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
    WAKESTATE oldWakeState;

    //
    // Record the wait wake Irp..
    //
    fdoExtension->WaitWakeIrp = Irp;

    oldWakeState = InterlockedCompareExchange(&fdoExtension->WaitWakeState,
                                              WAKESTATE_ARMED, WAKESTATE_WAITING);

    DebugPrint((PCMCIA_DEBUG_POWER, "fdo %x irp %x WaitWake: prevState %s\n",
                                                Fdo, Irp, WAKESTATE_STRING(oldWakeState)));

    if (oldWakeState == WAKESTATE_WAITING_CANCELLED) {
        fdoExtension->WaitWakeState = WAKESTATE_COMPLETING;

        Irp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_CANCELLED;
    }

    IoMarkIrpPending(Irp);

    IoCopyCurrentIrpStackLocationToNext (Irp);
    //
    // Set our completion routine in the Irp..
    //
    IoSetCompletionRoutine(Irp,
                           PcmciaFdoWaitWakeIoCompletion,
                           Fdo,
                           TRUE,
                           TRUE,
                           TRUE);
    //
    // now pass this down to the lower driver..
    //
    PoCallDriver(fdoExtension->LowerDevice, Irp);
    return STATUS_PENDING;
}


NTSTATUS
PcmciaFdoWaitWakeIoCompletion(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++

Routine Description:

    Completion routine for the IRP_MN_WAIT_WAKE request for this
    pcmcia controller. This is called when the WAIT_WAKE IRP is
    completed by the lower driver (PCI/ACPI) indicating either that
    1. PCMCIA controller asserted wake
    2. WAIT_WAKE was cancelled
    3. Lower driver returned an error for some reason

Arguments:
    Fdo             -     Pointer to Functional device object for the pcmcia controller
    Irp             -     Pointer to the IRP for the    power request (IRP_MN_WAIT_WAKE)
    Context         -     Not used

Return Value:

    STATUS_SUCCESS   - WAIT_WAKE was completed with success
    Any other status - Wake could be not be accomplished.

--*/
{
    PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PPDO_EXTENSION pdoExtension;
    PDEVICE_OBJECT pdo;
    WAKESTATE oldWakeState;

    UNREFERENCED_PARAMETER(Context);

    oldWakeState = InterlockedExchange(&fdoExtension->WaitWakeState, WAKESTATE_COMPLETING);

    DebugPrint((PCMCIA_DEBUG_POWER, "fdo %x irp %x WW IoComp: prev=%s\n",
                                                Fdo, Irp, WAKESTATE_STRING(oldWakeState)));

    if (oldWakeState != WAKESTATE_ARMED) {
        ASSERT(oldWakeState == WAKESTATE_ARMING_CANCELLED);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }


    if (IsFdoFlagSet(fdoExtension, PCMCIA_FDO_WAKE_BY_CD)) {
        POWER_STATE powerState;

        ResetFdoFlag(fdoExtension, PCMCIA_FDO_WAKE_BY_CD);

        PoStartNextPowerIrp(Irp);

        powerState.DeviceState = PowerDeviceD0;
        PoRequestPowerIrp(fdoExtension->DeviceObject, IRP_MN_SET_POWER, powerState, NULL, NULL, NULL);

    } else {
        // NOTE:
        // At this point we do NOT know how to distinguish which function
        // in a multifunction device has asserted wake.
        // So we go through the entire list of PDOs hanging off this FDO
        // and complete all the outstanding WAIT_WAKE Irps for every PDO that
        // that's waiting. We leave it up to the FDO for the device to figure
        // if it asserted wake
        //

        for (pdo = fdoExtension->PdoList; pdo != NULL ; pdo = pdoExtension->NextPdoInFdoChain) {

            pdoExtension = pdo->DeviceExtension;

            if (IsDeviceLogicallyRemoved(pdoExtension) ||
                 IsDevicePhysicallyRemoved(pdoExtension)) {
                //
                // This pdo is about to be removed ..
                // skip it
                //
                continue;
            }

            if (pdoExtension->WaitWakeIrp != NULL) {
                PIRP    finishedIrp;
                //
                // Ah.. this is a possible candidate to have asserted the wake
                //
                //
                // Make sure this IRP will not be completed again or cancelled
                //
                finishedIrp = pdoExtension->WaitWakeIrp;

                DebugPrint((PCMCIA_DEBUG_POWER, "fdo %x WW IoComp: irp %08x for pdo %08x\n",
                                                            Fdo, finishedIrp, pdo));


                IoSetCancelRoutine(finishedIrp, NULL);
                //
                // Propagate parent's status to child
                //
                PoStartNextPowerIrp(finishedIrp);
                finishedIrp->IoStatus.Status = Irp->IoStatus.Status;

                //
                // Since we didn't pass this IRP down, call our own completion routine
                //
                PcmciaPdoWaitWakeCompletion(pdo, finishedIrp, pdoExtension);
                IoCompleteRequest(finishedIrp, IO_NO_INCREMENT);
            }
        }
        PoStartNextPowerIrp(Irp);
    }

    return Irp->IoStatus.Status;
}



VOID
PcmciaFdoWaitWakePoCompletion(
    IN PDEVICE_OBJECT Fdo,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description

    This routine is called on completion of a D irp generated by an S irp.

Parameters

    DeviceObject    -   Pointer to the Fdo for the PCMCIA controller
    MinorFunction   -   Minor function of the IRP_MJ_POWER request
    PowerState      -   Power state requested
    Context         -   Context passed in to the completion routine
    IoStatus        -   Pointer to the status block which will contain
                            the returned status
Return Value

    Status

--*/
{
    PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;

    DebugPrint((PCMCIA_DEBUG_POWER, "fdo %x irp %x WaitWakePoCompletion: prevState %s\n",
                                                Fdo, fdoExtension->WaitWakeIrp,
                                                WAKESTATE_STRING(fdoExtension->WaitWakeState)));

    ASSERT (fdoExtension->WaitWakeIrp);
    fdoExtension->WaitWakeIrp = NULL;
    ASSERT (fdoExtension->WaitWakeState == WAKESTATE_COMPLETING);
    fdoExtension->WaitWakeState = WAKESTATE_DISARMED;
}



NTSTATUS
PcmciaFdoArmForWake(
    PFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

    This routine is called to enable the controller for wake. It is called by the Pdo
    wake routines when a wake-enabled controller gets a wait-wake irp, and also by
    the idle routine to arm for wake from D3 by card insertion.

Arguments:

    FdoExtension - device extension of the controller

Return Value:

    status

--*/
{
    NTSTATUS status = STATUS_PENDING;
    PIO_STACK_LOCATION irpStack;
    PIRP irp;
    LONG oldWakeState;
    POWER_STATE powerState;

    oldWakeState = InterlockedCompareExchange(&FdoExtension->WaitWakeState,
                                              WAKESTATE_WAITING, WAKESTATE_DISARMED);

    DebugPrint((PCMCIA_DEBUG_POWER, "fdo %x ArmForWake: prevState %s\n",
                                                FdoExtension->DeviceObject, WAKESTATE_STRING(oldWakeState)));

    if ((oldWakeState == WAKESTATE_ARMED) || (oldWakeState == WAKESTATE_WAITING)) {
        return STATUS_SUCCESS;
    }
    if (oldWakeState != WAKESTATE_DISARMED) {
        return STATUS_UNSUCCESSFUL;
    }



    powerState.SystemState = FdoExtension->DeviceCapabilities.SystemWake;

    status = PoRequestPowerIrp(FdoExtension->DeviceObject,
                               IRP_MN_WAIT_WAKE,
                               powerState,
                               PcmciaFdoWaitWakePoCompletion,
                               NULL,
                               NULL);

    if (!NT_SUCCESS(status)) {

        FdoExtension->WaitWakeState = WAKESTATE_DISARMED;

        DebugPrint((PCMCIA_DEBUG_POWER, "WaitWake to FDO, expecting STATUS_PENDING, got %08X\n", status));
    }

    return status;
}



NTSTATUS
PcmciaFdoDisarmWake(
    PFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

    This routine is called to disable the controller for wake.

Arguments:

    FdoExtension - device extension of the controller

Return Value:

    status

--*/
{
    WAKESTATE oldWakeState;

    oldWakeState = InterlockedCompareExchange(&FdoExtension->WaitWakeState,
                                                            WAKESTATE_WAITING_CANCELLED, WAKESTATE_WAITING);

    DebugPrint((PCMCIA_DEBUG_POWER, "fdo %x DisarmWake: prevState %s\n",
                                                FdoExtension->DeviceObject, WAKESTATE_STRING(oldWakeState)));

    if (oldWakeState != WAKESTATE_WAITING) {

        oldWakeState = InterlockedCompareExchange(&FdoExtension->WaitWakeState,
                                                                WAKESTATE_ARMING_CANCELLED, WAKESTATE_ARMED);

        if (oldWakeState != WAKESTATE_ARMED) {
            return STATUS_UNSUCCESSFUL;
        }
    }

    if (oldWakeState == WAKESTATE_ARMED) {
        IoCancelIrp(FdoExtension->WaitWakeIrp);

        //
        // Now that we've cancelled the IRP, try to give back ownership
        // to the completion routine by restoring the WAKESTATE_ARMED state
        //
        oldWakeState = InterlockedCompareExchange(&FdoExtension->WaitWakeState,
                                                                WAKESTATE_ARMED, WAKESTATE_ARMING_CANCELLED);

        if (oldWakeState == WAKESTATE_COMPLETING) {
            //
            // We didn't give control back of the IRP in time, we we own it now
            //
            IoCompleteRequest(FdoExtension->WaitWakeIrp, IO_NO_INCREMENT);
        }

    }

    return STATUS_SUCCESS;
}



NTSTATUS
PcmciaFdoCheckForIdle(
    IN PFDO_EXTENSION FdoExtension
    )
{
    POWER_STATE powerState;
    NTSTATUS status;
    PSOCKET socket;

    if (!(PcmciaPowerPolicy & PCMCIA_PP_D3_ON_IDLE)) {
        return STATUS_SUCCESS;
    }

    //
    // Make sure all sockets are empty
    //

    for (socket = FdoExtension->SocketList; socket != NULL; socket = socket->NextSocket) {
        if (IsCardInSocket(socket)) {
            return STATUS_UNSUCCESSFUL;
        }
    }

    //
    // Arm for wakeup
    //

    status = PcmciaFdoArmForWake(FdoExtension);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    SetFdoFlag(FdoExtension, PCMCIA_FDO_WAKE_BY_CD);

    powerState.DeviceState = PowerDeviceD3;
    PoRequestPowerIrp(FdoExtension->DeviceObject, IRP_MN_SET_POWER, powerState, NULL, NULL, NULL);

    return STATUS_SUCCESS;
}



/**************************************************************************

    POWER ROUTINES

 **************************************************************************/



NTSTATUS
PcmciaSetFdoPowerState(
    IN PDEVICE_OBJECT Fdo,
    IN OUT PIRP Irp
    )
/*++

Routine Description

    Dispatches the IRP based on whether a system power state
    or device power state transition is requested

Arguments

    DeviceObject        - Pointer to the functional device object for the pcmcia controller
    Irp                 - Pointer to the Irp for the power dispatch

Return value

    status

--*/
{
    PFDO_EXTENSION   fdoExtension = Fdo->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS             status;

    if (irpStack->Parameters.Power.Type == DevicePowerState) {
        status = PcmciaSetFdoDevicePowerState(Fdo, Irp);

    } else if (irpStack->Parameters.Power.Type == SystemPowerState) {
        status = PcmciaSetFdoSystemPowerState(Fdo, Irp);

    } else {
        status = Irp->IoStatus.Status;
        PoStartNextPowerIrp (Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;
}


NTSTATUS
PcmciaSetFdoSystemPowerState(
    IN PDEVICE_OBJECT Fdo,
    IN OUT PIRP Irp
    )
/*++

Routine Description

    Handles system power state IRPs for the pccard controller.

Arguments

    DeviceObject        - Pointer to the functional device object for the pcmcia controller
    Irp                 - Pointer to the Irp for the power dispatch

Return value

    status

--*/
{
    PFDO_EXTENSION   fdoExtension = Fdo->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    SYSTEM_POWER_STATE newSystemState = irpStack->Parameters.Power.State.SystemState;
    NTSTATUS             status = STATUS_SUCCESS;
    POWER_STATE          powerState;

    ASSERT(irpStack->Parameters.Power.Type == SystemPowerState);

    //
    // Find the device power state corresponding to this system state
    //
    if (newSystemState >= PowerSystemHibernate) {
        //
        // Turn device off beyond hibernate..
        //
        powerState.DeviceState = PowerDeviceD3;
    } else {
        //
        // Switch to the appropriate device power state
        //

        powerState.DeviceState = fdoExtension->DeviceCapabilities.DeviceState[newSystemState];


        if (powerState.DeviceState == PowerDeviceUnspecified) {
             //
             // Capabilities not obtained?
             // do the best we can
             //
             // Working --> D0
             // otherwise power it off
             //
             if (newSystemState == PowerSystemWorking) {
                  powerState.DeviceState = PowerDeviceD0;
             } else {
                  powerState.DeviceState = PowerDeviceD3;
             }
        }

        // NOTE: HACKHACK:
        //
        // This hack is available to work around a BIOS bug. The way that WOL is supposed to work
        // is that, after the device causes the wake, then the BIOS should run a method which
        // issues a "notify(,0x2)", and thus prompting ACPI to complete the wait-wake IRP. If the
        // W/W IRP is completed, then this allows the device state to be cleared before repowering
        // the device.
        //
        // If the device state is not cleared, then we get an interrupt storm. This happens because
        // when PCI.SYS switches the device to D0, then the PME# which was asserted to wake the system
        // is still firing, which becomes a cardbus STSCHG interrupt, which asserts the PCI IRQ. But
        // the act of switching the device to D0 has cleared the socket register BAR, so now the ISR
        // can't clear the interrupt.
        //
        // The risk of forcing the device to D0 while going to standby is that the machine may be
        // designed such that cardbus bridge may not function. So this should only be applied when
        // we know that it will work.
        //

        if ((PcmciaPowerPolicy & PCMCIA_PP_WAKE_FROM_D0) &&
            (powerState.DeviceState != PowerDeviceD0) && (fdoExtension->WaitWakeState != WAKESTATE_DISARMED) &&
            (newSystemState < PowerSystemHibernate)) {
            powerState.DeviceState = PowerDeviceD0; // force D0
        }
    }
    //
    // Transitioned to system state
    //
    DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x transition S state %d => %d, sending D%d\n",
                                              Fdo, Irp, fdoExtension->SystemPowerState-1, newSystemState-1, powerState.DeviceState-1));

    fdoExtension->SystemPowerState = newSystemState;
    //
    // Send a D IRP to the cardbus controller stack if necessary
    //
    if ((powerState.DeviceState > PowerDeviceUnspecified) &&
         (powerState.DeviceState != fdoExtension->DevicePowerState)) {


        if (powerState.DeviceState == PowerDeviceD0) {
            //
            // Powering up, optimize by letting the S irp complete immediately
            //
            PoRequestPowerIrp(fdoExtension->DeviceObject, IRP_MN_SET_POWER, powerState, NULL, NULL, NULL);
            PoSetPowerState (Fdo, SystemPowerState, irpStack->Parameters.Power.State);
            //
            // Send the S IRP to the pdo
            //
            PoStartNextPowerIrp (Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(fdoExtension->LowerDevice, Irp);

        } else {

            IoMarkIrpPending(Irp);

            status = PoRequestPowerIrp(fdoExtension->DeviceObject,
                                       IRP_MN_SET_POWER,
                                       powerState,
                                       PcmciaFdoSystemPowerDeviceIrpComplete,
                                       Irp,
                                       NULL
                                       );

            if (status != STATUS_PENDING) {
                //
                // Probably low memory failure
                //
                ASSERT( !NT_SUCCESS(status) );
                Irp->IoStatus.Status = status;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                //
                // We've already marked the IRP pending, so we must return STATUS_PENDING
                // (ie fail it asynchronously)
                //
                status = STATUS_PENDING;
            }

        }

    } else {
        PoSetPowerState (Fdo, SystemPowerState, irpStack->Parameters.Power.State);
        //
        // Send the S IRP to the pdo
        //
        PoStartNextPowerIrp (Irp);
        IoSkipCurrentIrpStackLocation(Irp);
        status = PoCallDriver(fdoExtension->LowerDevice, Irp);
    }

    DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x <-- %08x\n", Fdo, Irp, status));

    return status;
}


VOID
PcmciaFdoSystemPowerDeviceIrpComplete(
    IN PDEVICE_OBJECT Fdo,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description

    This routine is called on completion of a D irp generated by an S irp.

Parameters

    DeviceObject    -   Pointer to the Fdo for the PCMCIA controller
    MinorFunction   -   Minor function of the IRP_MJ_POWER request
    PowerState      -   Power state requested
    Context         -   Context passed in to the completion routine
    IoStatus        -   Pointer to the status block which will contain
                            the returned status
Return Value

    Status

--*/
{
    PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PIRP Irp = Context;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    ASSERT(NT_SUCCESS(IoStatus->Status));

    PoSetPowerState (Fdo, SystemPowerState, irpStack->Parameters.Power.State);

    DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x request for D%d complete, passing S irp down\n",
                                                Fdo, Irp, PowerState.DeviceState-1));
    //
    // Send the S IRP to the pdo
    //
    PoStartNextPowerIrp (Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    PoCallDriver(fdoExtension->LowerDevice, Irp);
}



NTSTATUS
PcmciaSetFdoDevicePowerState (
    IN PDEVICE_OBJECT Fdo,
    IN OUT PIRP Irp
    )
/*++

Routine Description

    Handles device power state IRPs for the pccard controller.

Arguments

    DeviceObject        - Pointer to the functional device object for the pcmcia controller
    Irp                 - Pointer to the Irp for the power dispatch

Return value

    status

--*/
{
    NTSTATUS             status;
    PFDO_EXTENSION   fdoExtension = Fdo->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    if ((fdoExtension->PendingPowerIrp != NULL) || (fdoExtension->PowerWorkerState != FPW_Stopped)) {
        //
        // oops. We already have a pending irp.
        //
        ASSERT(fdoExtension->PendingPowerIrp == NULL);
        status = STATUS_DEVICE_BUSY;
        Irp->IoStatus.Status = status;
        PoStartNextPowerIrp (Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

    } else {

        fdoExtension->PendingPowerIrp = Irp;

        if (irpStack->Parameters.Power.State.DeviceState != PowerDeviceD0) {
            fdoExtension->PowerWorkerState = FPW_BeginPowerDown;
        } else {
            fdoExtension->PowerWorkerState = FPW_BeginPowerUp;
        }
        status = PcmciaFdoPowerWorker(Fdo, STATUS_SUCCESS);

    }
    return status;
}



VOID
MoveToNextFdoPowerWorkerState(
    PFDO_EXTENSION fdoExtension,
    LONG increment
    )
/*++

Routine Description

    This routine controls the sequencing of FDO power worker.

    Initially, the state must be set to one of two states, namely BeginPowerDown
    or BeginPowerUp. From there, this routine defines the list of states to follow.

    The parameter "increment" is normally the value '1'. Other values are used
    to modify the normal sequence. For example, '-1' backs the engine up 1 step.
    Use FPW_END_SEQUENCE to skip to the end of the sequence.

Arguments


Return Value

    status

--*/
{

    //
    // NOTE!: code in power worker dependent on the following state sequences
    // in PowerUpSequence remaining adjacent:
    //
    //  FPW_PowerUpSocket : FPW_PowerUpSocketVerify : FPW_PowerUpComplete
    //
    //  FPW_IrpComplete : FPW_Stopped
    //


    static FDO_POWER_WORKER_STATE PowerUpSequence[] = {
        FPW_SendIrpDown,
        FPW_PowerUp,
        FPW_PowerUpSocket,
        FPW_PowerUpSocket2,
        FPW_PowerUpSocketVerify,
        FPW_PowerUpSocketComplete,
        FPW_PowerUpComplete,
        FPW_CompleteIrp,
        FPW_Stopped
        };

    static FDO_POWER_WORKER_STATE PowerDownSequence[] = {
        FPW_PowerDown,
        FPW_PowerDownSocket,
        FPW_PowerDownComplete,
        FPW_SendIrpDown,
        FPW_CompleteIrp,
        FPW_Stopped
        };

    static FDO_POWER_WORKER_STATE NoOpSequence[] = {
        FPW_SendIrpDown,
        FPW_CompleteIrp,
        FPW_Stopped
        };


    if (fdoExtension->PowerWorkerState == FPW_BeginPowerDown) {

        //
        // Initialize sequence and phase
        //
        fdoExtension->PowerWorkerPhase = (UCHAR) -1;

        if (fdoExtension->DevicePowerState == PowerDeviceD0) {
            fdoExtension->PowerWorkerSequence = PowerDownSequence;
            fdoExtension->PowerWorkerMaxPhase = sizeof(PowerDownSequence)/sizeof(FDO_POWER_WORKER_STATE) - 1;
        } else {
            fdoExtension->PowerWorkerSequence = NoOpSequence;
            fdoExtension->PowerWorkerMaxPhase = sizeof(NoOpSequence)/sizeof(FDO_POWER_WORKER_STATE) - 1;
        }

    } else if (fdoExtension->PowerWorkerState == FPW_BeginPowerUp) {

        //
        // Initialize sequence and phase
        //
        fdoExtension->PowerWorkerPhase = (UCHAR) -1;

        if (fdoExtension->DevicePowerState > PowerDeviceD0) {
            fdoExtension->PowerWorkerSequence = PowerUpSequence;
            fdoExtension->PowerWorkerMaxPhase = sizeof(PowerUpSequence)/sizeof(FDO_POWER_WORKER_STATE) - 1;
        } else {
            fdoExtension->PowerWorkerSequence = NoOpSequence;
            fdoExtension->PowerWorkerMaxPhase = sizeof(NoOpSequence)/sizeof(FDO_POWER_WORKER_STATE) - 1;
        }
    }

    //
    // Increment the phase, but not past the end of the sequence
    //
    if (fdoExtension->PowerWorkerState != FPW_Stopped) {

        if (increment == FPW_END_SEQUENCE) {

            fdoExtension->PowerWorkerPhase = fdoExtension->PowerWorkerMaxPhase;

        } else {
            fdoExtension->PowerWorkerPhase += (UCHAR)increment;

            if (fdoExtension->PowerWorkerPhase > fdoExtension->PowerWorkerMaxPhase) {
                fdoExtension->PowerWorkerPhase = fdoExtension->PowerWorkerMaxPhase;
            }
        }

        //
        // The next state is pointed to by the current phase
        //
        fdoExtension->PowerWorkerState =
            fdoExtension->PowerWorkerSequence[ fdoExtension->PowerWorkerPhase ];
    }

    DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x power worker next state : %s\n", fdoExtension->DeviceObject,
                                                FDO_POWER_WORKER_STRING(fdoExtension->PowerWorkerState)));

}


NTSTATUS
PcmciaFdoPowerWorker (
    IN PVOID Context,
    IN NTSTATUS Status
    )
/*++

Routine Description

    This routine handles sequencing of the device power state change for the
    ppcard controller.

Arguments

    DeviceObject        - Pointer to the functional device object for the pcmcia controller
    Status              - status from previous operation

Return value

    status

--*/



{
    PDEVICE_OBJECT Fdo = Context;
    PFDO_EXTENSION   fdoExtension = Fdo->DeviceExtension;
    PIRP Irp = fdoExtension->PendingPowerIrp;
    PIO_STACK_LOCATION irpStack;
    NTSTATUS             status = Status;
    PDEVICE_OBJECT   pdo;
    PPDO_EXTENSION   pdoExtension;
    PSOCKET              socket;
    BOOLEAN              cardInSocket;
    BOOLEAN              deviceChange;
    ULONG                DelayTime = 0;

    DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x power worker - %s\n", Fdo,
                                                FDO_POWER_WORKER_STRING(fdoExtension->PowerWorkerState)));

    switch(fdoExtension->PowerWorkerState) {

    //-------------------------------------------------------------------------
    // POWER DOWN STATES
    //-------------------------------------------------------------------------


    case FPW_BeginPowerDown:
        MoveToNextFdoPowerWorkerState(fdoExtension, 1);
        break;


    case FPW_PowerDown:
        //
        // Controller being powered down
        //
        DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x preparing for powerdown\n", Fdo, Irp));
        //
        // Getting out of D0
        //
        if (fdoExtension->Flags & PCMCIA_USE_POLLED_CSC) {
            //
            // Cancel the poll timer
            //
            KeCancelTimer(&fdoExtension->PollTimer);
        }
        //
        // Save necessary controller registers
        //
        PcmciaFdoSaveControllerContext(fdoExtension);
        fdoExtension->PendingPowerSocket = fdoExtension->SocketList;
        MoveToNextFdoPowerWorkerState(fdoExtension, 1);
        break;


    case FPW_PowerDownSocket:

        if ((socket = fdoExtension->PendingPowerSocket) == NULL) {
            MoveToNextFdoPowerWorkerState(fdoExtension, 1);
            break;
        }

        //
        // Ready to turn off the socket
        //
        PcmciaFdoSaveSocketContext(socket);

        //
        // Clear card detect unless we intend to wake using it
        //
        if (IsSocketFlagSet(socket, SOCKET_ENABLED_FOR_CARD_DETECT) && !IsFdoFlagSet(fdoExtension, PCMCIA_FDO_WAKE_BY_CD)) {
            (*(socket->SocketFnPtr->PCBEnableDisableCardDetectEvent))(socket, FALSE);
        }

        //
        // Cardbus cards need socket power all the time to allow PCI.SYS to read config space, even
        // if the device is logically removed. So instead of turning off socket power when the
        // children go to D3, we turn it off here when the parent goes to D3.
        // For R2 cards, the power may already be off, since the socket power does follow the
        // children. So this step would typically be superfluous.
        //

        DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x skt %08x power worker SystemState=S%d\n",
                                                    Fdo, socket, fdoExtension->SystemPowerState-1));

        switch(fdoExtension->SystemPowerState) {

        case PowerSystemWorking:
            //
            // The system is still running, we must be powering down because the socket is idle
            //
            ASSERT(!IsCardInSocket(socket));
            status = PcmciaSetSocketPower(socket, PcmciaFdoPowerWorker, Fdo, PCMCIA_POWEROFF);
            break;

        case PowerSystemSleeping1:
        case PowerSystemSleeping2:
        case PowerSystemSleeping3:
            //
            // If the device is armed for wakeup, we need to leave socket power on
            //
            if (fdoExtension->WaitWakeState == WAKESTATE_DISARMED) {
                status = PcmciaSetSocketPower(socket, PcmciaFdoPowerWorker, Fdo, PCMCIA_POWEROFF);
            }
            break;

        case PowerSystemHibernate:
            status = PcmciaSetSocketPower(socket, PcmciaFdoPowerWorker, Fdo, PCMCIA_POWEROFF);
            break;

        case PowerSystemShutdown:
            //
            // Doing a shutdown - check to see if we need to leave socket power on since NDIS
            // and SCSIPORT leaves their devices in D0. This can be a problem since many machines
            // will hang in the BIOS if devices are left powered up.
            //
            if (!IsDeviceFlagSet(fdoExtension, PCMCIA_FDO_DISABLE_AUTO_POWEROFF)) {
                status = PcmciaSetSocketPower(socket, PcmciaFdoPowerWorker, Fdo, PCMCIA_POWEROFF);
            }
            break;

        default:
            ASSERT(FALSE);
        }

        //
        // if success, then recurse below
        // if pending, then release_socket_power will call us back
        // Prepare to go to next socket
        //
        fdoExtension->PendingPowerSocket = fdoExtension->PendingPowerSocket->NextSocket;

        if (fdoExtension->PendingPowerSocket == NULL) {
            //
            // Done, ready to move on
            //
            MoveToNextFdoPowerWorkerState(fdoExtension, 1);
        }
        break;

    case FPW_PowerDownComplete:
        irpStack = IoGetCurrentIrpStackLocation(Irp);
        fdoExtension->DevicePowerState = irpStack->Parameters.Power.State.DeviceState;

        PoSetPowerState (Fdo, DevicePowerState, irpStack->Parameters.Power.State);
        fdoExtension->Flags |= PCMCIA_FDO_OFFLINE;
        MoveToNextFdoPowerWorkerState(fdoExtension, 1);
        break;


    //-------------------------------------------------------------------------
    // POWER UP STATES
    //-------------------------------------------------------------------------


    case FPW_BeginPowerUp:
        //
        // Back in D0. Restore the minimal context so we can access the registers
        //
        PcmciaFdoRestoreControllerContext(fdoExtension);

        //
        // Delay for a while after restoring PCI config space to allow the controller
        // to settle. The Panasonic Toughbook with at TI-1251B seemed to need this delay
        // before the cardbus state register showed the right value.
        //
        DelayTime = 8192;

        MoveToNextFdoPowerWorkerState(fdoExtension, 1);
        break;

    case FPW_PowerUp:
        //
        // Should be ready to touch the registers again
        //
        fdoExtension->Flags &= ~PCMCIA_FDO_OFFLINE;

        //
        // Get registers to a known state
        //
        PcmciaInitializeController(Fdo);

        if (!ValidateController(fdoExtension)) {
            status = STATUS_DEVICE_NOT_READY;
            //
            // Fast forward the sequence skipping to complete the irp
            //
            MoveToNextFdoPowerWorkerState(fdoExtension, FPW_END_SEQUENCE);   // moves to state: Stopped
            MoveToNextFdoPowerWorkerState(fdoExtension, -1);    // moves to state: CompleteIrp
            break;
        }
        //
        // We just transitioned into D0
        // Set socket flags to current state
        //
        for (socket = fdoExtension->SocketList; socket != NULL; socket = socket->NextSocket) {

            if (fdoExtension->PcmciaInterruptObject) {
                //
                // this should clear any pending interrupts in the socket event register
                //
                ((*(socket->SocketFnPtr->PCBDetectCardChanged))(socket));
            }

            //
            // Some cardbus cards (NEC based 1394 cards) are not quiet when they power up,
            // avoid an interrupt storm here by setting ISA irq routing
            //
            if (IsCardBusCardInSocket(socket)) {
                USHORT word;
                GetPciConfigSpace(fdoExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
                word |= BCTRL_IRQROUTING_ENABLE;
                SetPciConfigSpace(fdoExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
            }
        }

        fdoExtension->PendingPowerSocket = fdoExtension->SocketList;
        MoveToNextFdoPowerWorkerState(fdoExtension, 1);
        break;


    case FPW_PowerUpSocket:

        MoveToNextFdoPowerWorkerState(fdoExtension, 1);
        if ((socket = fdoExtension->PendingPowerSocket) == NULL) {
            break;
        }

        //
        // Make sure socket is really off first before powering up
        //

        status = PcmciaSetSocketPower(socket, PcmciaFdoPowerWorker, Fdo, PCMCIA_POWEROFF);
        break;

    case FPW_PowerUpSocket2:

        MoveToNextFdoPowerWorkerState(fdoExtension, 1);
        if ((socket = fdoExtension->PendingPowerSocket) == NULL) {
            break;
        }

        //
        // We now decide if the socket should be turned on. We really want to turn
        // at this point to make sure the device hasn't been swapped while the
        // controller was off. If status_change is already set on the socket flags,
        // then we anyway will power it on during enumeration, so don't bother now.
        //

        if (!IsSocketFlagSet(socket, SOCKET_CARD_STATUS_CHANGE) && IsCardInSocket(socket)) {

            DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x power worker - PowerON socket %08x\n", Fdo, socket));
            status = PcmciaSetSocketPower(socket, PcmciaFdoPowerWorker, Fdo, PCMCIA_POWERON);

        }

        break;


    case FPW_PowerUpSocketVerify:

        MoveToNextFdoPowerWorkerState(fdoExtension, 1);
        if ((socket = fdoExtension->PendingPowerSocket) == NULL) {
            break;
        }

        //
        // verify the same card is still inserted.
        //

        if (!IsSocketFlagSet(socket, SOCKET_CARD_STATUS_CHANGE) &&
             IsCardInSocket(socket) &&
             IsSocketFlagSet(socket, SOCKET_CARD_POWERED_UP)) {

             PcmciaVerifyCardInSocket(socket);
        }

        //
        // Now we decide whether or not to turn the power back off.
        //
        if (Is16BitCardInSocket(socket)) {
            if (IsSocketFlagSet(socket, SOCKET_CARD_STATUS_CHANGE) ||
                (socket->PowerRequests == 0)) {
                status = PcmciaSetSocketPower(socket, PcmciaFdoPowerWorker, Fdo, PCMCIA_POWEROFF);
            }
        }
        break;



    case FPW_PowerUpSocketComplete:

        if (fdoExtension->PendingPowerSocket == NULL) {
            MoveToNextFdoPowerWorkerState(fdoExtension, 1);
            break;
        }

        //
        // go to next socket, if any
        //
        fdoExtension->PendingPowerSocket = fdoExtension->PendingPowerSocket->NextSocket;

        if (fdoExtension->PendingPowerSocket != NULL) {
            //
            // Back up sequence to FPW_PowerUpSocket
            //
            MoveToNextFdoPowerWorkerState(fdoExtension, -2);
            break;
        }
        MoveToNextFdoPowerWorkerState(fdoExtension, 1);
        break;


    case FPW_PowerUpComplete:

        irpStack = IoGetCurrentIrpStackLocation(Irp);
        deviceChange = FALSE;
        for (socket = fdoExtension->SocketList; socket != NULL; socket = socket->NextSocket) {
            if (IsSocketFlagSet(socket, SOCKET_CARD_STATUS_CHANGE)) {
                deviceChange = TRUE;
            }
            PcmciaFdoRestoreSocketContext(socket);

            if (CardBus(socket)) {
                CBEnableDeviceInterruptRouting(socket);
            }

            if (IsSocketFlagSet(socket, SOCKET_ENABLED_FOR_CARD_DETECT)) {
                (*(socket->SocketFnPtr->PCBEnableDisableCardDetectEvent))(socket, TRUE);
            }
        }

        fdoExtension->DevicePowerState = irpStack->Parameters.Power.State.DeviceState;
        PoSetPowerState (Fdo, DevicePowerState, irpStack->Parameters.Power.State);

        if (deviceChange) {
            //
            // Make sure i/o arbiter is not hanging on the devnode
            //
            if (CardBusExtension(fdoExtension)) {
                IoInvalidateDeviceState(fdoExtension->Pdo);
            }
            //
            // Device state changed..
            //
            DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x power worker - Invalidating Device Relations!\n", Fdo));
            IoInvalidateDeviceRelations(fdoExtension->Pdo, BusRelations);
        }

        //
        // Getting back to D0, set the poll timer on
        //
        if (fdoExtension->Flags & PCMCIA_USE_POLLED_CSC) {
            LARGE_INTEGER dueTime;
            //
            // Set first fire to twice the peroidic interval - just
            //
            dueTime.QuadPart = -PCMCIA_CSC_POLL_INTERVAL * 1000 * 10 * 2;

            KeSetTimerEx(&(fdoExtension->PollTimer),
                         dueTime,
                         PCMCIA_CSC_POLL_INTERVAL,
                         &fdoExtension->TimerDpc
                         );
        }

        PCMCIA_ACQUIRE_DEVICE_LOCK(fdoExtension);

        if (!IsListEmpty(&fdoExtension->PdoPowerRetryList)) {
            PLIST_ENTRY NextEntry;
            PIRP pdoIrp;

            NextEntry = RemoveHeadList(&fdoExtension->PdoPowerRetryList);
            PCMCIA_RELEASE_DEVICE_LOCK(fdoExtension);

            pdoIrp = CONTAINING_RECORD(NextEntry, IRP, Tail.Overlay.DriverContext[0]);
            KeInsertQueueDpc(&fdoExtension->PdoPowerRetryDpc, pdoIrp, NULL);
        } else {
            PCMCIA_RELEASE_DEVICE_LOCK(fdoExtension);
        }

        MoveToNextFdoPowerWorkerState(fdoExtension, 1);
        break;

    //-------------------------------------------------------------------------
    // IRP HANDLING STATES
    //-------------------------------------------------------------------------


    case FPW_SendIrpDown:
        DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x sending irp down to PDO\n", Fdo, Irp));
        MoveToNextFdoPowerWorkerState(fdoExtension, 1);
        //
        // Send the IRP to the pdo
        //
        IoMarkIrpPending(Irp);

        IoCopyCurrentIrpStackLocationToNext (Irp);

        IoSetCompletionRoutine(Irp,
                               PcmciaFdoDevicePowerCompletion,
                               NULL,
                               TRUE,
                               TRUE,
                               TRUE);

        status = PoCallDriver(fdoExtension->LowerDevice, Irp);

        if (NT_SUCCESS(status)) {
            status = STATUS_PENDING;
        }
        break;

    case FPW_CompleteIrp:

        MoveToNextFdoPowerWorkerState(fdoExtension, 1);
        if (Irp) {
            fdoExtension->PendingPowerIrp = NULL;
            Irp->IoStatus.Status = status;

            DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x comp %08x\n", fdoExtension->DeviceObject, Irp, Irp->IoStatus.Status));

            PoStartNextPowerIrp(Irp);
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
        fdoExtension->PowerWorkerState = FPW_Stopped;
        break;

    case FPW_Stopped:
        DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x power worker final exit %08x\n", Fdo, status));
        if (!NT_SUCCESS(status)) {
            for (socket = fdoExtension->SocketList; socket != NULL; socket = socket->NextSocket) {
                SetSocketFlag(socket, SOCKET_CARD_STATUS_CHANGE);
            }
        }
        return status;
    default:
        ASSERT(FALSE);
    }

    DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x power worker status %08x\n", Fdo, status));

    if (status == STATUS_PENDING) {
        DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x power worker exit (pending)\n", Fdo));
        //
        // Current action calls us back
        //
        if ((Irp=fdoExtension->PendingPowerIrp)!=NULL) {
            IoMarkIrpPending(Irp);
        }
        return status;
    }
    //
    // Not done yet. Recurse or call timer
    //

    if (DelayTime) {

        DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x power worker delay type %s, %d usec\n", Fdo,
                                                                (KeGetCurrentIrql() < DISPATCH_LEVEL) ? "Wait" : "Timer",
                                                                DelayTime));

        if (KeGetCurrentIrql() < DISPATCH_LEVEL) {
            PcmciaWait(DelayTime);
        } else {
            LARGE_INTEGER   dueTime;
            //
            // Running on a DPC, kick of a kernel timer
            //

            dueTime.QuadPart = -((LONG) DelayTime*10);
            KeSetTimer(&fdoExtension->PowerTimer, dueTime, &fdoExtension->PowerDpc);

            //
            // We will reenter on timer dpc
            //
            if ((Irp=fdoExtension->PendingPowerIrp)!=NULL) {
                IoMarkIrpPending(Irp);
            }
            return STATUS_PENDING;
        }
    }

    //
    // recurse
    //
    return (PcmciaFdoPowerWorker(Fdo, status));
}



NTSTATUS
PcmciaFdoDevicePowerCompletion(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description

    Completion routine for the power IRP sent down to the PDO for the
    pcmcia controller. If we are getting out of a working system state,
    requests a power IRP to put the device in appropriate device power state.
    Also makes sure that we stop poking device registers when the controller
    is powered down and reenables that if necessary when it powers up

Parameters

    DeviceObject    -     Pointer to FDO for the controller
    Irp             -     Pointer to the IRP for the power request
    Context         -     Pointer to the FDO_POWER_CONTEXT which is
                              filled in when the IRP is passed down
Return Value

    Status

--*/
{
    PFDO_EXTENSION   fdoExtension = Fdo->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG                timerInterval;
    NTSTATUS             status;
    LARGE_INTEGER        dueTime;

    DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x DevicePowerCompletion PDO status %08x\n", Fdo, Irp, Irp->IoStatus.Status));

    if ((NT_SUCCESS(Irp->IoStatus.Status))) {

        if (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD0) {

            timerInterval = PCMCIA_CONTROLLER_POWERUP_DELAY;
        } else {
            //
            // powering down
            // stall to avoid hardware problem on ThinkPads where power
            // to the device is left on after the system in general powers off
            //
            timerInterval = 20000;
        }
        //
        // Do the rest in our timer routine
        //

        dueTime.QuadPart = -((LONG) timerInterval*10);
        KeSetTimer(&fdoExtension->PowerTimer, dueTime, &fdoExtension->PowerDpc);

        status = STATUS_MORE_PROCESSING_REQUIRED;

    } else {
        DebugPrint ((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x power irp failed by pdo %08x\n", Fdo, Irp, fdoExtension->LowerDevice));
        PoStartNextPowerIrp (Irp);
        status = Irp->IoStatus.Status;
        //
        // This irp is now complete
        //
        fdoExtension->PendingPowerIrp = NULL;
        MoveToNextFdoPowerWorkerState(fdoExtension, FPW_END_SEQUENCE);   // moves to state: Stopped
        PcmciaFdoPowerWorker(Fdo, status);
    }

    DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x DevicePowerCompletion <-- %08x\n", Fdo, Irp, status));
    return status;
}



VOID
PcmciaFdoPowerWorkerDpc(
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description

    This routine is called a short time after the controller power state
    is changed in order to give the hardware a chance to stabilize. It
    is called in the context of a device power request.

Parameters

    same as KDPC (Context is fdoExtension)

Return Value

    none

--*/
{
    PFDO_EXTENSION fdoExtension = Context;

    DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x PowerWorkerDpc\n", fdoExtension->DeviceObject, fdoExtension->PendingPowerIrp));
    //
    // Fdo power worker will complete the irp
    //
    PcmciaFdoPowerWorker(fdoExtension->DeviceObject, STATUS_SUCCESS);
}


VOID
PcmciaFdoRetryPdoPowerRequest(
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description

    This routine is called to finish off any PDO power irps that may have
    been queued.

Parameters

    same as KDPC (Context is fdoExtension)

Return Value

    none

--*/
{
    PFDO_EXTENSION fdoExtension = Context;
    PIRP Irp = SystemArgument1;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x FdoRetryPdoPowerRequest\n", fdoExtension->DeviceObject, Irp));

    PcmciaSetPdoDevicePowerState(irpStack->DeviceObject, Irp);

    while(TRUE) {
        PLIST_ENTRY NextEntry;

        PCMCIA_ACQUIRE_DEVICE_LOCK(fdoExtension);

        if (IsListEmpty(&fdoExtension->PdoPowerRetryList)) {
            PCMCIA_RELEASE_DEVICE_LOCK(fdoExtension);
            break;
        }

        NextEntry = RemoveHeadList(&fdoExtension->PdoPowerRetryList);

        PCMCIA_RELEASE_DEVICE_LOCK(fdoExtension);

        Irp = CONTAINING_RECORD(NextEntry, IRP, Tail.Overlay.DriverContext[0]);
        irpStack = IoGetCurrentIrpStackLocation(Irp);

        PcmciaSetPdoDevicePowerState(irpStack->DeviceObject, Irp);
    }
}



NTSTATUS
PcmciaFdoSaveControllerContext(
    IN PFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

    Saves the state of the necessary PCI config registers
    in the device extension of the cardbus controller

Arguments:

    FdoExtension        - Pointer to device extension for the FDO of the
                              cardbus controller

Return Value:

    Status
--*/
{
    ULONG index, offset, count;
    PULONG alignedBuffer;

    DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x save reg context\n", FdoExtension->DeviceObject));

    if (!FdoExtension->PciContext.BufferLength) {
        // nothing to save
        return STATUS_SUCCESS;
    }

    if (!ValidateController(FdoExtension)) {
        return STATUS_DEVICE_NOT_READY;
    }

    SetDeviceFlag(FdoExtension, PCMCIA_FDO_CONTEXT_SAVED);

    if (FdoExtension->PciContextBuffer == NULL) {
        FdoExtension->PciContextBuffer = ExAllocatePool(NonPagedPool, FdoExtension->PciContext.BufferLength);

        if (FdoExtension->PciContextBuffer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    alignedBuffer = ExAllocatePool(NonPagedPool, FdoExtension->PciContext.MaxLen);
    if (alignedBuffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (CardBusExtension(FdoExtension)) {
        //
        // Save PCI context
        //

        for (index = 0, offset = 0; index < FdoExtension->PciContext.RangeCount; index++) {

            DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x saving PCI context, offset %x length %x\n",
                                                        FdoExtension->DeviceObject,
                                                        FdoExtension->PciContext.Range[index].wOffset,
                                                        FdoExtension->PciContext.Range[index].wLen));

            ASSERT(FdoExtension->PciContext.Range[index].wLen <= FdoExtension->PciContext.MaxLen);

            GetPciConfigSpace(FdoExtension,
                                    (ULONG) FdoExtension->PciContext.Range[index].wOffset,
                                    alignedBuffer,
                                    FdoExtension->PciContext.Range[index].wLen);

            RtlCopyMemory(&FdoExtension->PciContextBuffer[offset], alignedBuffer, FdoExtension->PciContext.Range[index].wLen);
            offset += FdoExtension->PciContext.Range[index].wLen;
        }
    }

    ExFreePool(alignedBuffer);
    return STATUS_SUCCESS;
}



NTSTATUS
PcmciaFdoSaveSocketContext(
    IN PSOCKET Socket
    )
/*++

Routine Description:

    Saves the state of the necessary socket registers (CB, EXCA)

Arguments:

    Socket              - Pointer to socket data structure

Return Value:

    Status
--*/
{
    PFDO_EXTENSION fdoExtension = Socket->DeviceExtension;
    ULONG index, offset, count;

    if (CardBusExtension(fdoExtension) && fdoExtension->CardbusContext.BufferLength) {
        //
        // Save Cardbus context
        //
        if (Socket->CardbusContextBuffer == NULL) {
            Socket->CardbusContextBuffer = ExAllocatePool(NonPagedPool, fdoExtension->CardbusContext.BufferLength);

            if (Socket->CardbusContextBuffer == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        for (index = 0, offset = 0; index < fdoExtension->CardbusContext.RangeCount; index++) {
            PULONG pBuffer = (PULONG) &Socket->CardbusContextBuffer[offset];

            DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x saving Cardbus context, offset %x length %x\n",
                                                        fdoExtension->DeviceObject,
                                                        fdoExtension->CardbusContext.Range[index].wOffset,
                                                        fdoExtension->CardbusContext.Range[index].wLen));

            for (count = 0; count < (fdoExtension->CardbusContext.Range[index].wLen/sizeof(ULONG)) ; count++) {

                *pBuffer++ = CBReadSocketRegister(Socket,
                                                  (UCHAR) (fdoExtension->CardbusContext.Range[index].wOffset + count*sizeof(ULONG)));
            }

            offset += fdoExtension->CardbusContext.Range[index].wLen;
        }
    }

    //
    // Save Exca context
    //

    if (fdoExtension->ExcaContext.BufferLength) {

        if (Socket->ExcaContextBuffer == NULL) {
            Socket->ExcaContextBuffer = ExAllocatePool(NonPagedPool, fdoExtension->ExcaContext.BufferLength);

            if (Socket->ExcaContextBuffer == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        for (index = 0, offset = 0; index < fdoExtension->ExcaContext.RangeCount; index++) {
            PUCHAR pBuffer = &Socket->ExcaContextBuffer[offset];

            DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x saving Exca context, offset %x length %x\n",
                                                        fdoExtension->DeviceObject,
                                                        fdoExtension->ExcaContext.Range[index].wOffset,
                                                        fdoExtension->ExcaContext.Range[index].wLen));

            for (count = 0; count < fdoExtension->ExcaContext.Range[index].wLen; count++) {

                *pBuffer++ = PcicReadSocket(Socket,
                                            fdoExtension->ExcaContext.Range[index].wOffset + count);
            }

            offset += fdoExtension->ExcaContext.Range[index].wLen;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
PcmciaFdoRestoreControllerContext(
    IN PFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

    Restores the state of the necessary PCI config registers
    from the device extension of the cardbus controller

Arguments:

    FdoExtension        - Pointer to device extension for the FDO of the
                              cardbus controller

Return Value:

    Status
--*/
{
    ULONG index, offset, count;
    PULONG alignedBuffer;

    if (!CardBusExtension(FdoExtension)) {
        return STATUS_SUCCESS;
    }

    //
    // Make sure we don't restore stale or uninitialized data
    //
    if (!IsDeviceFlagSet(FdoExtension, PCMCIA_FDO_CONTEXT_SAVED)) {
        ASSERT(IsDeviceFlagSet(FdoExtension, PCMCIA_FDO_CONTEXT_SAVED));
        return STATUS_UNSUCCESSFUL;
    }
    ResetDeviceFlag(FdoExtension, PCMCIA_FDO_CONTEXT_SAVED);

    if (FdoExtension->PciContextBuffer == NULL) {
        // nothing to restore... strange since our flag was set
        ASSERT(FALSE);
        return STATUS_SUCCESS;
    }


    alignedBuffer = ExAllocatePool(NonPagedPool, FdoExtension->PciContext.MaxLen);
    if (alignedBuffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    DebugPrint((PCMCIA_DEBUG_POWER,
                    "fdo %08x restore reg context\n", FdoExtension->DeviceObject));

    //
    // Restore PCI context
    //

    for (index = 0, offset = 0; index < FdoExtension->PciContext.RangeCount; index++) {

        DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x restoring PCI context, offset %x length %x\n",
                                                    FdoExtension->DeviceObject,
                                                    FdoExtension->PciContext.Range[index].wOffset,
                                                    FdoExtension->PciContext.Range[index].wLen));

        ASSERT(FdoExtension->PciContext.Range[index].wLen <= FdoExtension->PciContext.MaxLen);

        RtlCopyMemory(alignedBuffer, &FdoExtension->PciContextBuffer[offset], FdoExtension->PciContext.Range[index].wLen);

        SetPciConfigSpace(FdoExtension,
                          (ULONG) FdoExtension->PciContext.Range[index].wOffset,
                          alignedBuffer,
                          FdoExtension->PciContext.Range[index].wLen);

        offset += FdoExtension->PciContext.Range[index].wLen;

        //
        // hang on resume on NEC NX laptop (w/ Ricoh devid 0x475) is avoided with a stall here.
        // The hang occurs if CBRST is turned OFF. I'm unclear about the reason for it, this
        // is just an empirically derived hack.
        //
        PcmciaWait(1);
    }
    ExFreePool(alignedBuffer);
    return STATUS_SUCCESS;
}



NTSTATUS
PcmciaFdoRestoreSocketContext(
    IN PSOCKET Socket
    )
/*++

Routine Description:

    Restores the state of the necessary socket registers (CB, EXCA)

Arguments:

    Socket              - Pointer to socket data structure

Return Value:

    Status
--*/
{
    PFDO_EXTENSION fdoExtension = Socket->DeviceExtension;
    ULONG index, offset, count;

    if (CardBusExtension(fdoExtension) && (Socket->CardbusContextBuffer != NULL)) {
        //
        // Restore Cardbus context
        //

        for (index = 0, offset = 0; index < fdoExtension->CardbusContext.RangeCount; index++) {
            PULONG pBuffer = (PULONG) &Socket->CardbusContextBuffer[offset];

            DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x restoring Cardbus context offset %x length %x\n",
                                                        fdoExtension->DeviceObject,
                                                        fdoExtension->CardbusContext.Range[index].wOffset,
                                                        fdoExtension->CardbusContext.Range[index].wLen));

            for (count = 0; count < (fdoExtension->CardbusContext.Range[index].wLen/sizeof(ULONG)) ; count++) {

                CBWriteSocketRegister(Socket,
                                      (UCHAR) (fdoExtension->CardbusContext.Range[index].wOffset + count*sizeof(ULONG)),
                                      *pBuffer++);
            }

            offset += fdoExtension->CardbusContext.Range[index].wLen;
        }
    }

    //
    // Restore Exca context
    //

    if (Socket->ExcaContextBuffer != NULL) {
        for (index = 0, offset = 0; index < fdoExtension->ExcaContext.RangeCount; index++) {
            PUCHAR pBuffer = &Socket->ExcaContextBuffer[offset];

            DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x Restoring Exca context, offset %x length %x\n",
                                                        fdoExtension->DeviceObject,
                                                        fdoExtension->ExcaContext.Range[index].wOffset,
                                                        fdoExtension->ExcaContext.Range[index].wLen));

            for (count = 0; count < fdoExtension->ExcaContext.Range[index].wLen; count++) {

                PcicWriteSocket(Socket,
                                fdoExtension->ExcaContext.Range[index].wOffset + count,
                                *pBuffer++);
            }

            offset += fdoExtension->ExcaContext.Range[index].wLen;
        }
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\intrface.c ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    intrface.c

Abstract:

    This module contains the external interfaces of the
    pcmcia driver

Author:

    Neil Sandlin (neilsa) 3-Mar-1999

Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"

//
// Internal References
//

ULONG
PcmciaReadCardMemory(
    IN  PDEVICE_OBJECT Pdo,
    IN  ULONG            WhichSpace,
    OUT PUCHAR           Buffer,
    IN  ULONG            Offset,
    IN  ULONG            Length
    );

ULONG
PcmciaWriteCardMemory(
    IN PDEVICE_OBJECT Pdo,
    IN ULONG            WhichSpace,
    IN PUCHAR           Buffer,
    IN ULONG            Offset,
    IN ULONG            Length
    );

NTSTATUS
PcmciaMfEnumerateChild(
    IN  PPDO_EXTENSION PdoExtension,
    IN  ULONG Index,
    OUT PMF_DEVICE_INFO ChildInfo
    );

BOOLEAN
PcmciaModifyMemoryWindow(
    IN PDEVICE_OBJECT Pdo,
    IN ULONGLONG HostBase,
    IN ULONGLONG CardBase,
    IN BOOLEAN   Enable,
    IN ULONG     WindowSize  OPTIONAL,
    IN UCHAR     AccessSpeed OPTIONAL,
    IN UCHAR     BusWidth    OPTIONAL,
    IN BOOLEAN   IsAttributeMemory OPTIONAL
    );

BOOLEAN
PcmciaSetVpp(
    IN PDEVICE_OBJECT Pdo,
    IN UCHAR            VppLevel
    );

BOOLEAN
PcmciaIsWriteProtected(
    IN PDEVICE_OBJECT Pdo
    );

BOOLEAN
PcmciaTranslateBusAddress(
    IN PVOID Context,
    IN PHYSICAL_ADDRESS BusAddress,
    IN ULONG Length,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

PDMA_ADAPTER
PcmciaGetDmaAdapter(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    );

VOID
PcmciaNop(
    IN PVOID Context
    );


#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE,  PcmciaPdoQueryInterface)
    #pragma alloc_text(PAGE,  PcmciaMfEnumerateChild)
    #pragma alloc_text(PAGE,  PcmciaNop)
    #pragma alloc_text(PAGE,  PcmciaGetInterface)
    #pragma alloc_text(PAGE,  PcmciaUpdateInterruptLine)
#endif



NTSTATUS
PcmciaPdoQueryInterface(
    IN PDEVICE_OBJECT Pdo,
    IN OUT PIRP         Irp
    )
/*++

Routine Description:

    Fills in the interface requested


    Interfaces supported are:

     GUID_PCMCIA_INTERFACE_STANDARD:

     This returns a pointer to a PCMCIA_INTERFACE_STANDARD structure.
     These interfaces are exported solely for flash memory card support as
     a means for flash memory card drivers to slide memory windows,
     set Vpp levels etc.

     GUID_TRANSLATOR_INTERFACE_STANDARD:

     This returns an interrupt translator for 16-bit pc-cards which is used
     by PnP for translating raw IRQs. We simply return the Hal implemented
     translator, since PCMCIA does not need any specific translation. We do not
     return a translator if this is for a cardbus card

     GUID_PCMCIA_BUS_INTERFACE_STANDARD:

     This returns a pointer to a PCMCIA_BUS_INTERFACE_STANDARD structure.
     This contains entry points to set/get PCMCIA config data for the pc-card


     GUID_MF_ENUMERATION_INTERFACE

     For 16-bit multifunction pc-cards returns a pointer to MF_ENUMERATION_INTERFACE
     structure which contains entry points to enumerate multifunction children of
     the pc-card

     Completes the Passed in IRP before returning

Arguments

    Pdo - Pointer to the device object
    Irp - Pointer to the io request packet

Return Value

    STATUS_SUCCESS
    STATUS_INSUFFICIENT_RESOURCES - if supplied interface size is
                                              not big enough to accomodate the interface
    STATUS_INVALID_PARAMETER_1 - if the requested interface is not supported
                                          by this driver
--*/

{

    PIO_STACK_LOCATION irpStack;
    PPCMCIA_INTERFACE_STANDARD pcmciaInterfaceStandard;
    GUID *interfaceType;
    PPDO_EXTENSION  pdoExtension;
    PFDO_EXTENSION  fdoExtension;
    NTSTATUS status = STATUS_NOT_SUPPORTED;

    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    interfaceType = (GUID *) irpStack->Parameters.QueryInterface.InterfaceType;
    pdoExtension = Pdo->DeviceExtension;
    fdoExtension = pdoExtension->Socket->DeviceExtension;

    try{

        if (Is16BitCard(pdoExtension) && CompareGuid(interfaceType, (PVOID) &GUID_PCMCIA_INTERFACE_STANDARD)) {

            if (irpStack->Parameters.QueryInterface.Size < sizeof(PCMCIA_INTERFACE_STANDARD)) {
                status = STATUS_INVALID_PARAMETER;
                leave;
            }

            //
            // Ignore the version for the present
            //
            pcmciaInterfaceStandard = (PPCMCIA_INTERFACE_STANDARD) irpStack->Parameters.QueryInterface.Interface;

            RtlZeroMemory(pcmciaInterfaceStandard, sizeof (PCMCIA_INTERFACE_STANDARD));
            pcmciaInterfaceStandard->Size =   sizeof(PCMCIA_INTERFACE_STANDARD);
            pcmciaInterfaceStandard->Version = 1;
            pcmciaInterfaceStandard->Context = Pdo;
            //
            // Fill in the exported functions
            //

            pcmciaInterfaceStandard->InterfaceReference  = (PINTERFACE_REFERENCE) PcmciaNop;
            pcmciaInterfaceStandard->InterfaceDereference = (PINTERFACE_DEREFERENCE) PcmciaNop;
            pcmciaInterfaceStandard->ModifyMemoryWindow  = PcmciaModifyMemoryWindow;
            pcmciaInterfaceStandard->SetVpp                  = PcmciaSetVpp;
            pcmciaInterfaceStandard->IsWriteProtected    = PcmciaIsWriteProtected;
            DebugPrint((PCMCIA_DEBUG_INTERFACE, "pdo %08x returning PCMCIA_INTERFACE_STANDARD\n", Pdo));
            status = STATUS_SUCCESS;

        } else if (CompareGuid(interfaceType, (PVOID) &GUID_TRANSLATOR_INTERFACE_STANDARD)
                      && ((ULONG_PTR)irpStack->Parameters.QueryInterface.InterfaceSpecificData ==
                            CmResourceTypeInterrupt)) {

            if ((Is16BitCard(pdoExtension) && !IsSocketFlagSet(pdoExtension->Socket, SOCKET_CB_ROUTE_R2_TO_PCI)) &&
                 //
                 // Eject a translator only if  the controller is   PCI enumerated
                 // (i.e. we are enumerated by PCI - so we eject a PCI-Isa translator)
                 //
                 (CardBusExtension(fdoExtension) ||  PciPcmciaBridgeExtension(fdoExtension))) {

                PTRANSLATOR_INTERFACE translator;
                ULONG busNumber;
                //
                // We need a translator for this PDO (16-bit pc-card) which uses
                // ISA resources.
                //
                status = HalGetInterruptTranslator(
                                                   PCIBus,
                                                   0,
                                                   Isa,
                                                   irpStack->Parameters.QueryInterface.Size,
                                                   irpStack->Parameters.QueryInterface.Version,
                                                   (PTRANSLATOR_INTERFACE) irpStack->Parameters.QueryInterface.Interface,
                                                   &busNumber
                                                   );
            }

        } else if (IsDeviceMultifunction(pdoExtension) && CompareGuid(interfaceType, (PVOID)&GUID_MF_ENUMERATION_INTERFACE)) {
            //
            // Multifunction enumeration interface
            //
            PMF_ENUMERATION_INTERFACE mfEnum;

            if (irpStack->Parameters.QueryInterface.Size < sizeof(MF_ENUMERATION_INTERFACE)) {
                status = STATUS_INVALID_PARAMETER;
                leave;
            }

            mfEnum = (PMF_ENUMERATION_INTERFACE) irpStack->Parameters.QueryInterface.Interface;
            mfEnum->Context = pdoExtension;
            mfEnum->InterfaceReference = PcmciaNop;
            mfEnum->InterfaceDereference = PcmciaNop;
            mfEnum->EnumerateChild = (PMF_ENUMERATE_CHILD) PcmciaMfEnumerateChild;
            DebugPrint((PCMCIA_DEBUG_INTERFACE, "pdo %08x returning MF_ENUMERATION_INTERFACE\n", Pdo));
            status = STATUS_SUCCESS;

        } else if (CompareGuid(interfaceType, (PVOID)&GUID_PCMCIA_BUS_INTERFACE_STANDARD)) {

            PPCMCIA_BUS_INTERFACE_STANDARD busInterface;

            if (irpStack->Parameters.QueryInterface.Size < sizeof(PCMCIA_BUS_INTERFACE_STANDARD)) {
                status = STATUS_INVALID_PARAMETER;
                leave;
            }

            busInterface = (PPCMCIA_BUS_INTERFACE_STANDARD) irpStack->Parameters.QueryInterface.Interface;
            busInterface->Context = Pdo;
            busInterface->InterfaceReference   = PcmciaNop;
            busInterface->InterfaceDereference = PcmciaNop;
            busInterface->ReadConfig  = PcmciaReadCardMemory;
            busInterface->WriteConfig = PcmciaWriteCardMemory;
            DebugPrint((PCMCIA_DEBUG_INTERFACE, "pdo %08x returning PCMCIA_BUS_INTERFACE_STANDARD\n", Pdo));
            status = STATUS_SUCCESS;

        } else if (Is16BitCard(pdoExtension) && CompareGuid(interfaceType, (PVOID) &GUID_BUS_INTERFACE_STANDARD)) {
            PBUS_INTERFACE_STANDARD busInterface = (PBUS_INTERFACE_STANDARD)irpStack->Parameters.QueryInterface.Interface;

            if (irpStack->Parameters.QueryInterface.Size < sizeof(BUS_INTERFACE_STANDARD)) {
                status = STATUS_INVALID_PARAMETER;
                leave;
            }

            busInterface->Size = sizeof( BUS_INTERFACE_STANDARD );
            busInterface->Version = 1;
            busInterface->Context = Pdo;
            busInterface->InterfaceReference   = PcmciaNop;
            busInterface->InterfaceDereference = PcmciaNop;
            busInterface->TranslateBusAddress = PcmciaTranslateBusAddress;
            busInterface->GetDmaAdapter = PcmciaGetDmaAdapter;
            busInterface->GetBusData = PcmciaReadCardMemory;
            busInterface->SetBusData = PcmciaWriteCardMemory;
            DebugPrint((PCMCIA_DEBUG_INTERFACE, "pdo %08x returning BUS_INTERFACE_STANDARD\n", Pdo));
            status = STATUS_SUCCESS;
        }

    } finally {

        if (status == STATUS_NOT_SUPPORTED) {
            //
            // Query Interface type not supported
            //
            if (pdoExtension->LowerDevice != NULL) {
                PcmciaSkipCallLowerDriver(status, pdoExtension->LowerDevice, Irp);
            } else {
                status = Irp->IoStatus.Status;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
        } else {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
    }
    return status;
}


ULONG
PcmciaReadCardMemory(
    IN    PDEVICE_OBJECT Pdo,
    IN    ULONG          WhichSpace,
    OUT   PUCHAR         Buffer,
    IN    ULONG          Offset,
    IN    ULONG          Length
    )
/*++

Routine Description:

      Stub for reading card memory which is exported via
      PCMCIA_BUS_INTERFACE_STANDARD. This just calls the
      PcmciaReadWriteCardMemory which does the real work

      Note: this has to be non-paged since it can be called by
      clients at DISPATCH_LEVEL

Arguments:

 Pdo -           Device object representing the PC-CARD whose config memory needs to be read
 WhichSpace -    Indicates which memory space needs to be mapped: one of
                     PCCARD_COMMON_MEMORY_SPACE
                     PCCARD_ATTRIBUTE_MEMORY_SPACE
                     PCCARD_PCI_CONFIGURATION_MEMORY_SPACE (only for cardbus cards)


 Buffer -        Caller supplied buffer into which the memory contents are copied
                     Offset -        Offset of the attribute memory at which we copy
                     Length -        Number of bytes of attribute memory to be copied

 Return value:

     Count of bytes read

--*/
{

    DebugPrint((PCMCIA_DEBUG_INTERFACE, "pdo %08x read card memory\n", Pdo));
    return NT_SUCCESS(PcmciaReadWriteCardMemory(Pdo, WhichSpace, Buffer, Offset, Length, TRUE)) ?
                            Length : 0;
}



ULONG
PcmciaWriteCardMemory(
    IN    PDEVICE_OBJECT Pdo,
    IN    ULONG          WhichSpace,
    IN    PUCHAR         Buffer,
    IN    ULONG          Offset,
    IN    ULONG          Length
    )
/*++

Routine Description:

      Stub for writing to card memory which is exported via
      PCMCIA_BUS_INTERFACE_STANDARD. This just calls
      PcmciaReadWriteCardMemory which does the real work

      Note: this has to be non-paged since it can be called by
      clients at DISPATCH_LEVEL

Arguments:

 Pdo -           Device object representing the PC-CARD whose config memory needs to be written to
 WhichSpace -    Indicates which memory space needs to be mapped: one of
                     PCCARD_COMMON_MEMORY_SPACE
                     PCCARD_ATTRIBUTE_MEMORY_SPACE
                     PCCARD_PCI_CONFIGURATION_MEMORY_SPACE (only for cardbus cards)


 Buffer -        Caller supplied buffer out of which the memory contents are copied
                     Offset -        Offset of the attribute memory at which we copy
                     Length -        Number of bytes of buffer to be copied

 Return value:

     Count of bytes written

--*/
{

    DebugPrint((PCMCIA_DEBUG_INTERFACE, "pdo %08x write card memory\n", Pdo));
    return NT_SUCCESS(PcmciaReadWriteCardMemory(Pdo, WhichSpace, Buffer, Offset, Length, FALSE)) ?
                            Length : 0;
}


BOOLEAN
PcmciaModifyMemoryWindow(
    IN PDEVICE_OBJECT Pdo,
    IN ULONGLONG HostBase,
    IN ULONGLONG CardBase,
    IN BOOLEAN   Enable,
    IN ULONG     WindowSize  OPTIONAL,
    IN UCHAR     AccessSpeed OPTIONAL,
    IN UCHAR     BusWidth    OPTIONAL,
    IN BOOLEAN   IsAttributeMemory OPTIONAL
    )
/*++

Routine Description:

    Part of the interfaces originally developed to
    support flash memory cards.

    This routine enables the caller to 'slide' the supplied
    host memory window across the given (16-bit)pc-card's card memory.
    i.e. the host memory window will be modified to map
    the pc-card at a new card memory offset

Arguments:

    Pdo         - Pointer to the device object for the PC-Card

    HostBase    - Host memory window base to be mapped

    CardBase    - Mandatory if Enable is TRUE
                      New card memory offset to map the host memory window
                      to

    Enable      - If this is FALSE - all the remaining arguments
                      are ignored and the host window will simply be
                      disabled

    WindowSize  - Specifies the size of the host memory window to
                      be mapped. Note this must be at the proper alignment
                      and must be less than or equal to the originally
                      allocated window size for the host base.
                      If this is zero, the originally allocated window
                      size will be used.

    AccessSpeed - Mandatory if Enable is TRUE
                      Specifies the new access speed for the pc-card.
                      (AccessSpeed should be encoded as per the pc-card
                        standard, card/socket services spec)

    BusWidth    - Mandatory if Enable is TRUE
                      One of PCMCIA_MEMORY_8BIT_ACCESS
                      or        PCMCIA_MEMORY_16BIT_ACCESS

    IsAttributeMemory - Mandatory if Enable is TRUE
                              Specifies if the window should be mapped
                              to the pc-card's attribute or common memory


Return Value:

    TRUE    -        Memory window was enabled/disabled as requested
    FALSE -      If not

--*/
{
    PPDO_EXTENSION pdoExtension;
    PSOCKET socket;

    pdoExtension = Pdo->DeviceExtension;
    socket = pdoExtension->Socket;

    DebugPrint((PCMCIA_DEBUG_INTERFACE, "pdo %08x modify memory window\n", Pdo));
    if (socket->SocketFnPtr->PCBModifyMemoryWindow == NULL) {
        return FALSE;
    } else {
        return (*(socket->SocketFnPtr->PCBModifyMemoryWindow))(Pdo, HostBase, CardBase, Enable,
                                                               WindowSize, AccessSpeed, BusWidth,
                                                               IsAttributeMemory);
    }
}

BOOLEAN
PcmciaSetVpp(
    IN PDEVICE_OBJECT Pdo,
    IN UCHAR          VppLevel
    )
/*++

Routine Description

  Part of the interfaces originally developed to
  support flash memory cards.
  Sets VPP1 to the required setting

Arguments

  Pdo - Pointer to device object  for the PC-Card
  Vpp - Desired Vpp setting. This is currently one of
          PCMCIA_VPP_12V      (12 volts)
          PCMCIA_VPP_0V   (disable VPP)
          PCMCIA_VPP_IS_VCC (route VCC to VPP)

Return

    TRUE - if successful
    FALSE - if not. This will be returned if the
              PC-Card is not already powered up
--*/
{
    PPDO_EXTENSION pdoExtension;
    PSOCKET socket;

    pdoExtension = Pdo->DeviceExtension;
    socket = pdoExtension->Socket;

    DebugPrint((PCMCIA_DEBUG_INTERFACE, "pdo %08x set vpp\n", Pdo));
    if (socket->SocketFnPtr->PCBSetVpp == NULL) {
        return FALSE;
    } else {
        return (*(socket->SocketFnPtr->PCBSetVpp))(Pdo, VppLevel);
    }
}

BOOLEAN
PcmciaIsWriteProtected(
    IN PDEVICE_OBJECT Pdo
    )
/*++

Routine Description:

    Part of the interfaces originally developed to
    support flash memory cards.

    Returns the status of the write protected pin
    for the given PC-Card

Arguments:

    Pdo - Pointer to the device object for the PC-Card

Return Value:

    TRUE    -        if the PC-Card is write-protected
    FALSE -      if not

--*/
{
    PPDO_EXTENSION pdoExtension;
    PSOCKET socket;

    pdoExtension = Pdo->DeviceExtension;
    socket = pdoExtension->Socket;

    DebugPrint((PCMCIA_DEBUG_INTERFACE, "pdo %08x is write protected \n", Pdo));
    if (socket->SocketFnPtr->PCBIsWriteProtected == NULL) {
        return FALSE;
    } else {
        return (*(socket->SocketFnPtr->PCBIsWriteProtected))(Pdo);
    }
}



BOOLEAN
PcmciaTranslateBusAddress(
    IN PVOID Context,
    IN PHYSICAL_ADDRESS BusAddress,
    IN ULONG Length,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )
/*++

Routine Description

    This function is used to translate bus addresses from legacy drivers.

Arguments

    Context - Supplies a pointer to the interface context.  This is actually
         the PDO for the root bus.

    BusAddress - Supplies the orginal address to be translated.

    Length - Supplies the length of the range to be translated.

    AddressSpace - Points to the location of of the address space type such as
         memory or I/O port.  This value is updated by the translation.

    TranslatedAddress - Returns the translated address.

Return Value

    Returns a boolean indicating if the operations was a success.

--*/
{
    return HalTranslateBusAddress(Isa,
                                  0,
                                  BusAddress,
                                  AddressSpace,
                                  TranslatedAddress);
}



PDMA_ADAPTER
PcmciaGetDmaAdapter(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    )
/*++

Routine Description

    Passes IoGetDmaAdapter calls to the parent.

Arguments

    Context - Supplies a pointer to the interface context. This is actually the PDO.

    DeviceDescriptor - Supplies the device descriptor used to allocate the dma
         adapter object.

    NubmerOfMapRegisters - Returns the maximum number of map registers a device
         can allocate at one time.

Return Value

    Returns a DMA adapter or NULL.

--*/
{
    PDEVICE_OBJECT Pdo = Context;
    PPDO_EXTENSION pdoExtension;
    PFDO_EXTENSION fdoExtension;

    pdoExtension = Pdo->DeviceExtension;

    if (!pdoExtension || !pdoExtension->Socket || !pdoExtension->Socket->DeviceExtension) {
        return NULL;
    }

    //
    // Get the parent FDO extension
    //
    fdoExtension = pdoExtension->Socket->DeviceExtension;

    //
    // Pass the call on to the parent
    //
    return IoGetDmaAdapter(fdoExtension->Pdo,
                           DeviceDescriptor,
                           NumberOfMapRegisters);
}


VOID
PcmciaNop(
    IN PVOID Context
    )
/*++

Routine Description

    Does nothing

Arguments

    none

Return Value

    none

--*/
{
    PAGED_CODE();
    UNREFERENCED_PARAMETER(Context);
}



NTSTATUS
PcmciaMfEnumerateChild(
    IN  PPDO_EXTENSION PdoExtension,
    IN  ULONG Index,
    OUT PMF_DEVICE_INFO ChildInfo
    )
/*++

Routine Description

    Returns required enumeration information for the multifunction children
    of the given pc-card. This fills in the required info. for the child
    indicated, returing STATUS_NO_MORE_ENTRIES when there are no more
    children to be enumerated

Arguments

    PdoExtension - Pointer to the device extension for the multifunction parent pc-card
    Index        - Zero based index for the child to be enumerated
    ChildInfo    - Caller allocated buffer in which the info about the child is returned.
                        We may allocate additional buffers for each field in the supplied
                        structure. This will be freed by the caller when no longer needed

Return value

    STATUS_SUCCESS          - supplied child info filled in & returned
    STATUS_NO_MORE_ENTRIES  - No child of the given index exists. Caller is
                                      assumed to iteratively call this routine with index incremented
                                      from 0 upwards till this status value is returned
    STATUS_NO_SUCH_DEVICE   - if the pc-card no longer exists
--*/
{
    PSOCKET             socket;
    PSOCKET_DATA        socketData;
    PCONFIG_ENTRY       configEntry, mfConfigEntry;
    ULONG               i, currentIndex, count;
    NTSTATUS            status;
    UCHAR               iRes;
    PUCHAR              idString;
    ANSI_STRING         ansiString;

    PAGED_CODE();

    DebugPrint((PCMCIA_DEBUG_INTERFACE,
                    "PcmciaMfEnumerateChild: parent ext %x child index %x\n",
                    PdoExtension,
                    Index
                  ));
    try {
        if (IsDeviceDeleted(PdoExtension) ||
             IsDeviceLogicallyRemoved(PdoExtension)) {
            //
            // This pdo is deleted or marked to be deleted
            //
            status = STATUS_NO_SUCH_DEVICE;
            leave;
        }

        socket = PdoExtension->Socket;
        ASSERT (socket != NULL);

        RtlZeroMemory(ChildInfo, sizeof(MF_DEVICE_INFO));

        if (Index >= socket->NumberOfFunctions) {
            //
            // info requested for a child which doesn't exist
            //
            status =  STATUS_NO_MORE_ENTRIES;
            leave;
        }

        //
        // Fill in the name field
        // This is of the form ChildXX
        // where XX is the number of the function
        // Examples: Child00, Child01 etc.
        //
        idString = (PUCHAR) ExAllocatePool(PagedPool, PCMCIA_MAXIMUM_DEVICE_ID_LENGTH);
        if (!idString) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }
        sprintf(idString, "Child%02x", Index);
        RtlInitAnsiString(&ansiString, idString);
        status = RtlAnsiStringToUnicodeString(&ChildInfo->Name,
                                              &ansiString,
                                              TRUE);
        ExFreePool(idString);
        if (!NT_SUCCESS(status)) {
            leave;
        }

        //
        // Get compatible ids
        //
        status = PcmciaGetCompatibleIds(PdoExtension->DeviceObject,
                                        Index,
                                        &ChildInfo->CompatibleID);
        if (!NT_SUCCESS(status)) {
            leave;
        }

        //
        // Get hardware ids
        //
        status = PcmciaGetHardwareIds(PdoExtension->DeviceObject,
                                      Index,
                                      &ChildInfo->HardwareID);
        if (!NT_SUCCESS(status)) {
            leave;
        }

        //
        // Fill in the resource map stuff
        //
        // Locate the socket data structure corresponding to this function
        for (socketData = PdoExtension->SocketData, i=0; (socketData != NULL) && (i != Index); socketData=socketData->Next, i++);

        if (!socketData) {
            //
            // this condition should never be encountered
            //
            ASSERT (FALSE);
            status = STATUS_NO_MORE_ENTRIES;
            leave;
        }

        if (!(socketData->NumberOfConfigEntries > 0)) {
            //
            // No resource map required
            //
            status = STATUS_SUCCESS;
            leave;
        }

        count = (socketData->MfNeedsIrq ? 1 : 0) + socketData->MfIoPortCount + socketData->MfMemoryCount;
        if (count == 0) {
            ASSERT(FALSE);
            //
            // No resource map required
            //
            status = STATUS_SUCCESS;
            leave;
        }

        //
        // Allocate resource map
        //
        ChildInfo->ResourceMap = ExAllocatePool(PagedPool,
                                                sizeof(MF_RESOURCE_MAP) + (count-1) * sizeof(UCHAR));
        if (!ChildInfo->ResourceMap) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        ChildInfo->ResourceMap->Count = count;
        //
        // Compute the resource map indices
        // The config entry *already* contains fields (MfIrqResourceMapIndex, MfIoPortResourceMapIndex etc.)
        // which indicate the relative index of the resource requested for this function within the resource type.
        // We calculate the absolute index by adding up the number of instances of each resource type requested,
        // preceding the current resource type, to this relative index.
        //
        currentIndex = 0;
        //
        // Fill the irq map if there's one
        //
        if (socketData->MfNeedsIrq) {
            ChildInfo->ResourceMap->Resources[currentIndex++] = socketData->MfIrqResourceMapIndex;
        }
        //
        // Fill the i/o port map if there's one
        //
        if (socketData->MfIoPortCount) {
            for (iRes=0; iRes<socketData->MfIoPortCount; iRes++) {

                ChildInfo->ResourceMap->Resources[currentIndex++] = socketData->MfIoPortResourceMapIndex + iRes;

            }
        }
        //
        // Fill the memory request map if there's one
        //
        if (socketData->MfMemoryCount) {
            for (iRes=0; iRes<socketData->MfMemoryCount; iRes++) {

                ChildInfo->ResourceMap->Resources[currentIndex++] = socketData->MfMemoryResourceMapIndex + iRes;

            }
        }

        status = STATUS_SUCCESS;

    } finally {
        if (!NT_SUCCESS(status)) {
            //
            // Free up all the allocated buffers
            //
            if (ChildInfo->Name.Buffer) {
                ExFreePool(ChildInfo->Name.Buffer);
            }

            if (ChildInfo->CompatibleID.Buffer) {
                ExFreePool(ChildInfo->CompatibleID.Buffer);
            }

            if (ChildInfo->HardwareID.Buffer) {
                ExFreePool(ChildInfo->HardwareID.Buffer);
            }

            if (ChildInfo->ResourceMap) {
                ExFreePool(ChildInfo->ResourceMap);
            }

            if (ChildInfo->VaryingResourceMap) {
                ExFreePool(ChildInfo->ResourceMap);
            }
        }
    }

    return status;
}



NTSTATUS
PcmciaGetInterface(
    IN PDEVICE_OBJECT DeviceObject,
    IN CONST GUID *pGuid,
    IN USHORT sizeofInterface,
    OUT PINTERFACE pInterface
    )
/*

Routine Description

    Gets the interface exported by PCI for enumerating 32-bit cardbus cards, which
    appear as regular PCI devices. This interface will be used to respond during
    subsequent enumeration requests from PnP to invoke PCI to enumerate the cards.

Arguments

    Pdo - Pointer to physical device object for the cardbus controller
    PciCardBusInterface -  Pointer to the PCI-Cardbus interface  will be returned
                                  in this variable

Return Value

    Status

*/

{
    KEVENT event;
    PIRP     irp;
    NTSTATUS status;
    IO_STATUS_BLOCK statusBlock;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE();

    KeInitializeEvent (&event, NotificationEvent, FALSE);
    irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                       DeviceObject,
                                       NULL,
                                       0,
                                       0,
                                       &event,
                                       &statusBlock
                                       );

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED ;
    irp->IoStatus.Information = 0;

    irpSp = IoGetNextIrpStackLocation(irp);

    irpSp->MinorFunction = IRP_MN_QUERY_INTERFACE;

    irpSp->Parameters.QueryInterface.InterfaceType= pGuid;
    irpSp->Parameters.QueryInterface.Size = sizeofInterface;
    irpSp->Parameters.QueryInterface.Version = 1;
    irpSp->Parameters.QueryInterface.Interface = pInterface;

    status = IoCallDriver(DeviceObject, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = statusBlock.Status;
    }

    if (!NT_SUCCESS(status)) {
        DebugPrint((PCMCIA_DEBUG_INFO, "GetInterface failed with status %x\n", status));
    }
    return status;
}


NTSTATUS
PcmciaUpdateInterruptLine(
    IN PPDO_EXTENSION PdoExtension,
    IN PFDO_EXTENSION FdoExtension
    )
/*

Routine Description

    This routine uses the PCI Irq Routing interface to update the raw interrupt
    line of a cardbus card. This is done in order to allow cardbus cards to run
    on non-acpi machines without pci irq routing, as long as the bios supplies
    the interrupt for the cardbus controller.

Arguments

    PdoExtension - Pointer to the extension for the cardbus card
    FdoExtension - Pointer to the extension for the cardbus controller

Return Value

    Status

*/

{

    PAGED_CODE();

    if (!IsDeviceFlagSet(FdoExtension, PCMCIA_INT_ROUTE_INTERFACE)) {
        return STATUS_UNSUCCESSFUL;
    }

    if (FdoExtension->Configuration.Interrupt.u.Interrupt.Vector == 0) {
        return STATUS_UNSUCCESSFUL;
    }

    (FdoExtension->PciIntRouteInterface.UpdateInterruptLine)(PdoExtension->PciPdo,
                                                             (UCHAR) FdoExtension->Configuration.Interrupt.u.Interrupt.Vector);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\ioctl.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    This module handles device ioctl's to the pcmcia driver.

Authors:

    Ravisankar Pudipeddi (ravisp) Oct 15 1996
    Neil Sandlin (neilsa) 1-Jun-1999

Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"


PSOCKET
PcmciaGetPointerFromSocketNumber(
    PFDO_EXTENSION DeviceExtension,
    USHORT SocketNumber
    );


#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE,  PcmciaDeviceControl)
    #pragma alloc_text(PAGE,  PcmciaGetPointerFromSocketNumber)
#endif



PSOCKET
PcmciaGetPointerFromSocketNumber(
    PFDO_EXTENSION DeviceExtension,
    USHORT SocketNumber
    )
{
    PSOCKET               socket;
    ULONG                 index;
    //
    // Find the socket pointer for the requested offset.
    //

    socket = DeviceExtension->SocketList;
    index = 0;
    while (socket) {
        if (index == SocketNumber) {
            break;
        }
        socket = socket->NextSocket;
        index++;
    }
    return socket;
}



NTSTATUS
PcmciaDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    IOCTL device routine

Arguments:

    DeviceObject - Pointer to the device object.
    Irp - Pointer to the IRP

Return Value:

    Status

--*/

{
    PFDO_EXTENSION    deviceExtension = DeviceObject->DeviceExtension;
    PDEVICE_OBJECT    pdo;
    PPDO_EXTENSION    pdoExtension;
    PIO_STACK_LOCATION  currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS              status = STATUS_SUCCESS;
    PSOCKET               socket;

    InterlockedIncrement(&deviceExtension->DeletionLock);

    if (!IsDeviceFlagSet(deviceExtension, PCMCIA_FDO_IOCTL_INTERFACE_ENABLED) ||
         !IsDeviceFlagSet(deviceExtension, PCMCIA_DEVICE_STARTED)) {
        Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        InterlockedDecrement(&deviceExtension->DeletionLock);
        return status;
    }

    switch (currentIrpStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_GET_TUPLE_DATA: {
            PTUPLE_REQUEST tupleRequest = (PTUPLE_REQUEST)Irp->AssociatedIrp.SystemBuffer;
            ULONG bufLen = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

            DebugPrint((PCMCIA_DEBUG_IOCTL, "IOCTL_GET_TUPLE_DATA\n"));

            if (!bufLen) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }
            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(TUPLE_REQUEST)) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            socket = PcmciaGetPointerFromSocketNumber(deviceExtension, tupleRequest->Socket);
            if (socket == NULL) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            pdo = socket->PdoList;
            if (pdo == NULL) {
                status = STATUS_UNSUCCESSFUL;
                break;
            }
            pdoExtension = pdo->DeviceExtension;

            //
            // Zero the target buffer
            //
            RtlZeroMemory(Irp->AssociatedIrp.SystemBuffer, bufLen);

            Irp->IoStatus.Information = (*(socket->SocketFnPtr->PCBReadCardMemory))(pdoExtension,
                                                                                    PCCARD_ATTRIBUTE_MEMORY,
                                                                                    0,
                                                                                    Irp->AssociatedIrp.SystemBuffer,
                                                                                    bufLen);

            break;
        }


    case IOCTL_SOCKET_INFORMATION: {
            PPCMCIA_SOCKET_INFORMATION infoRequest = (PPCMCIA_SOCKET_INFORMATION)Irp->AssociatedIrp.SystemBuffer;
            USHORT temp;

            DebugPrint((PCMCIA_DEBUG_IOCTL, "IOCTL_SOCKET_INFORMATION\n"));

            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(PCMCIA_SOCKET_INFORMATION)) {
                status = STATUS_BUFFER_TOO_SMALL;
                Irp->IoStatus.Information = sizeof(PCMCIA_SOCKET_INFORMATION);
                break;
            }
            if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(PCMCIA_SOCKET_INFORMATION)) {
                status = STATUS_BUFFER_TOO_SMALL;
                Irp->IoStatus.Information = sizeof(PCMCIA_SOCKET_INFORMATION);
                break;
            }

            socket = PcmciaGetPointerFromSocketNumber(deviceExtension, infoRequest->Socket);
            if (socket == NULL) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // At this point we know we will succeed the call, so fill in the length
            //
            Irp->IoStatus.Information = sizeof(PCMCIA_SOCKET_INFORMATION);
            status = STATUS_SUCCESS;

            //
            // Insure caller data is zero - maintain value for socket.
            //

            temp = infoRequest->Socket;
            RtlZeroMemory(infoRequest, sizeof(PCMCIA_SOCKET_INFORMATION));
            infoRequest->Socket = temp;

            //
            // Only if there is a card in the socket does this proceed.
            //

            infoRequest->CardInSocket = (UCHAR) IsCardInSocket(socket);
            infoRequest->CardEnabled = (UCHAR) IsSocketFlagSet(socket, SOCKET_CARD_CONFIGURED);
            infoRequest->ControllerType = deviceExtension->ControllerType;


            pdo = socket->PdoList;
            if (infoRequest->CardInSocket && (pdo != NULL)) {
                PSOCKET_DATA socketData;

                pdoExtension = pdo->DeviceExtension;
                socketData = pdoExtension->SocketData;
                //
                // For now returned the cached data.
                //

                if (socketData) {
                    RtlMoveMemory(&infoRequest->Manufacturer[0], &socketData->Mfg[0], MANUFACTURER_NAME_LENGTH);
                    RtlMoveMemory(&infoRequest->Identifier[0], &socketData->Ident[0], DEVICE_IDENTIFIER_LENGTH);
                    infoRequest->TupleCrc = socketData->CisCrc;
                    infoRequest->DeviceFunctionId = socketData->DeviceType;
                }

            }

            break;
        }


    case IOCTL_PCMCIA_HIDE_DEVICE: {
            PPCMCIA_SOCKET_REQUEST socketRequest = (PPCMCIA_SOCKET_REQUEST)Irp->AssociatedIrp.SystemBuffer;

            DebugPrint((PCMCIA_DEBUG_IOCTL, "IOCTL_PCMCIA_HIDE_DEVICE\n"));

            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(PCMCIA_SOCKET_REQUEST)) {
                status = STATUS_BUFFER_TOO_SMALL;
                Irp->IoStatus.Information = sizeof(PCMCIA_SOCKET_REQUEST);
                break;
            }

            socket = PcmciaGetPointerFromSocketNumber(deviceExtension, socketRequest->Socket);
            if (socket == NULL) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            SetSocketFlag(socket, SOCKET_DEVICE_HIDDEN);
            SetSocketFlag(socket, SOCKET_CARD_STATUS_CHANGE);
            PcmciaSetSocketPower(socket, NULL, NULL, PCMCIA_POWEROFF);
            IoInvalidateDeviceRelations(socket->DeviceExtension->Pdo, BusRelations);
            Irp->IoStatus.Information = 0;
            break;
        }


    case IOCTL_PCMCIA_REVEAL_DEVICE: {
            PPCMCIA_SOCKET_REQUEST socketRequest = (PPCMCIA_SOCKET_REQUEST)Irp->AssociatedIrp.SystemBuffer;

            DebugPrint((PCMCIA_DEBUG_IOCTL, "IOCTL_PCMCIA_REVEAL_DEVICE\n"));

            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(PCMCIA_SOCKET_REQUEST)) {
                status = STATUS_BUFFER_TOO_SMALL;
                Irp->IoStatus.Information = sizeof(PCMCIA_SOCKET_REQUEST);
                break;
            }

            socket = PcmciaGetPointerFromSocketNumber(deviceExtension, socketRequest->Socket);
            if (socket == NULL) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            ResetSocketFlag(socket, SOCKET_DEVICE_HIDDEN);
            SetSocketFlag(socket, SOCKET_CARD_STATUS_CHANGE);
            IoInvalidateDeviceRelations(socket->DeviceExtension->Pdo, BusRelations);
            Irp->IoStatus.Information = 0;
            break;
        }


    default: {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
    }
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    InterlockedDecrement(&deviceExtension->DeletionLock);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\o2m.c ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    o2m.c

Abstract:

    This module contains the code that contains
    O2 micro cardbus controller specific initialization and
    other dispatches

Author:

    Ravisankar Pudipeddi (ravisp) 1-Nov-97


Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"



VOID
O2MInitialize(
    IN PFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

     Initialize O2Micro controllers

Arguments:

     FdoExtension - Pointer to the device extension for the controller FDO

Return Value:

     None
--*/
{
    UCHAR byte;
    USHORT word;

    //
    // patch for o2micro controllers courtesy of Eric Still (ejstill@o2micro.com)
    //
    byte = PcicReadSocket(FdoExtension->SocketList, 0x3a) | 0xa0;
    PcicWriteSocket(FdoExtension->SocketList, 0x3a, byte);

    //
    // initialize IRQ routing to ISA
    //

    GetPciConfigSpace(FdoExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
    word |= BCTRL_IRQROUTING_ENABLE;
    SetPciConfigSpace(FdoExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
}


NTSTATUS
O2MSetPower(
    IN PSOCKET Socket,
    IN BOOLEAN Enable,
    OUT PULONG pDelayTime
    )

/*++

Routine Description:

     Set power to the specified socket.

Arguments:

     SocketPtr - the socket to set
     Enable - TRUE means to set power - FALSE is to turn it off.
     pDelayTime - specifies delay (msec) to occur after the current phase

Return Value:

     STATUS_MORE_PROCESSING_REQUIRED - increment phase, perform delay, recall
     other status values terminate sequence

--*/

{
    NTSTATUS status;

    status = CBSetPower(Socket, Enable, pDelayTime);

    if (NT_SUCCESS(status) & Enable) {
        UCHAR byte;

        //
        // patch for o2micro controllers courtesy of Eric Still (ejstill@o2micro.com)
        //
        byte = PcicReadSocket(Socket, 0x3a) | 0xa0;
        PcicWriteSocket(Socket, 0x3a, byte);
    }
    return status;
}


BOOLEAN
O2MSetZV(
    IN PSOCKET Socket,
    IN BOOLEAN Enable
    )
{
    ULONG oldValue;

    if (Enable) {
        oldValue = CBReadSocketRegister(Socket, CBREG_O2MICRO_ZVCTRL);
        oldValue |= ZVCTRL_ZV_ENABLE;
        CBWriteSocketRegister(Socket, CBREG_O2MICRO_ZVCTRL, oldValue);
    } else {
        oldValue = CBReadSocketRegister(Socket, CBREG_O2MICRO_ZVCTRL);
        oldValue &= ~ZVCTRL_ZV_ENABLE;
        CBWriteSocketRegister(Socket, CBREG_O2MICRO_ZVCTRL, oldValue);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\pch.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    PCH.H

Abstract:

    This module includes all  the headers which need
    to be precompiled & are included by all the source
    files in the PCMCIA project.

Author(s):

    Ravisankar Pudipeddi (ravisp) 1-Dec-1997

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#ifndef _PCMCIA_PCH_H_
#define _PCMCIA_PCH_H_

#include "ntosp.h"
#include <zwapi.h>
#include <initguid.h>
#include "mf.h"
#include "ntddpcm.h"
#include "pcmciap.h"
#include "pciintrf.h"
#include "wdmguid.h"
#include <stdarg.h>
#include <stdio.h>
#include "data.h"
#include "tuple.h"
#include "string.h"
#include "pcmcia.h"
#include "card.h"
#include "extern.h"
#include "pcicfg.h"
#include "exca.h"
#include "cb.h"
#include "tcic2.h"
#include "dbsocket.h"
#include "tcicext.h"
#include "pcmciamc.h"
#include "debug.h"

#endif  // _PCMCIA_PCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\opti.c ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    opti.c

Abstract:

    This module contains the code that contains
    OPTi controller(s) specific initialization and
    other dispatches

Author:

    Ravisankar Pudipeddi (ravisp) 1-Nov-97


Environment:

    Kernel mode

Revision History :

    Neil Sandlin (neilsa) 3-Mar-99
       new setpower routine interface

--*/

#include "pch.h"


VOID
OptiInitialize(
    IN PFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

    Initialize OPTI cardbus controllers

Arguments:

    FdoExtension - Pointer to the device extension for the controller FDO

Return Value:

    None
--*/

{
    if (FdoExtension->ControllerType == PcmciaOpti82C814) {
        UCHAR byte;

        //
        // This fix per Opti for USB/1394 Combo hang
        //  5Eh[7] - enables the deadlock prevention mechanism
        //  5Fh[1] - reduces the retry count delay to 8 - note that 5Fh is a
        //      WRITE-ONLY  register and always reads 0. All other bits
        //      of this register can safely be written to 0.
        //  5Eh[5] - enables write posting on upstream transfers
        //  5Eh[4] - sets the chip input buffer scaling (not related to deadlock)

        GetPciConfigSpace(FdoExtension, 0x5e, &byte, 1);
        byte |= 0xB0;
        SetPciConfigSpace(FdoExtension, 0x5e, &byte, 1);
        byte = 2;
        SetPciConfigSpace(FdoExtension, 0x5f, &byte, 1);
    }
}


NTSTATUS
OptiSetPower(
    IN PSOCKET SocketPtr,
    IN BOOLEAN Enable,
    OUT PULONG pDelayTime
    )
/*++

Routine Description:

    Set power to the specified socket.

Arguments:

    SocketPtr - the socket to set
    Enable - TRUE means to set power - FALSE is to turn it off.
    pDelayTime - specifies delay (msec) to occur after the current phase

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - increment phase, perform delay, recall
    other status values terminate sequence

--*/

{
    NTSTATUS status;
    UCHAR               oldPower, newPower;

    if (IsCardBusCardInSocket(SocketPtr)) {
        //
        // Hand over to generic power setting routine
        //
        return(CBSetPower(SocketPtr, Enable, pDelayTime));

    }

    switch(SocketPtr->PowerPhase) {
    case 1:
        //
        // R2 card - special handling
        //
        oldPower = PcicReadSocket(SocketPtr, PCIC_PWR_RST);
        //
        // Set new vcc
        // VCC always set to 5V if power is to be enabled..
        //
        newPower = (Enable ? PC_VCC_OPTI_050V : PC_VCC_OPTI_NO_CONNECT);
        //
        // Set vpp
        //
        if (Enable) {
             //
             // We - as always - set vpp to vcc..
             //
             newPower |= PC_VPP_OPTI_SETTO_VCC;
        } else {
            newPower |= PC_VPP_OPTI_NO_CONNECT;
        }

        newPower |= (oldPower & PC_OUTPUT_ENABLE);
        //
        // If Vcc is turned off, reset OUTPUT_ENABLE & AUTOPWR_ENABLE
        //
        if (!(newPower & PC_VCC_OPTI_MASK)) {
            newPower &= ~PC_OUTPUT_ENABLE;
        }

        status = STATUS_SUCCESS;
        if (newPower != oldPower) {
            PcicWriteSocket(SocketPtr, PCIC_PWR_RST, newPower);
            //
            // Allow ramp up.. (actually we don't need to this if
            // Enable was FALSE).  Keep it for paranoia's sake
            //
            *pDelayTime = PCMCIA_PCIC_STALL_POWER;
            SocketPtr->PowerData = (ULONG) newPower;
            status = STATUS_MORE_PROCESSING_REQUIRED;
        }
        break;

    case 2:

        newPower = (UCHAR) SocketPtr->PowerData;

        if ((newPower & PC_VCC_OPTI_MASK)  && !(newPower & PC_OUTPUT_ENABLE)){
            //
            // More paranoia?
            //
            newPower |= PC_OUTPUT_ENABLE;
            PcicWriteSocket(SocketPtr, PCIC_PWR_RST, newPower);
        }
        status = STATUS_SUCCESS;
        break;

    default:
        ASSERT(FALSE);
        status = STATUS_UNSUCCESSFUL;
    }
    return status;
}


BOOLEAN
OptiSetZV(
    IN PSOCKET Socket,
    IN BOOLEAN Enable
    )
{
    UCHAR bData;

    if (Enable) {

        bData = PcicReadSocket(Socket, PCIC_OPTI_GLOBAL_CTRL);
        bData |= OPTI_ZV_ENABLE;
        PcicWriteSocket(Socket, PCIC_OPTI_GLOBAL_CTRL, bData);

    } else {

        bData = PcicReadSocket(Socket, PCIC_OPTI_GLOBAL_CTRL);
        bData &= ~OPTI_ZV_ENABLE;
        PcicWriteSocket(Socket, PCIC_OPTI_GLOBAL_CTRL, bData);

    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\pcicsup.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    pcicsup.c

Abstract:

    This module supplies functions that control the 82365SL chip. In turn,
    these functions are abstracted out to the main PCMCIA support module.

Author(s):

    Bob Rinne (BobRi)  3-Aug-1994
    Jeff McLeman (mcleman@zso.dec.com)
    Neil Sandlin (neilsa) June 1 1999

Revisions:
    6-Apr-95
         Modified for databook support changes - John Keys Databook
    1-Nov-96
         Complete overhaul for plug'n'play support,
         flash interfaces, power support etc.

               - Ravisankar Pudipeddi (ravisp)
--*/

#include "pch.h"

#ifdef POOL_TAGGING
    #undef ExAllocatePool
    #define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'cicP')
#endif

//
// Internal References
//

NTSTATUS
PcicResetCard(
    IN PSOCKET Socket,
    OUT PULONG pDelayTime
    );

BOOLEAN
PcicInitializePcmciaSocket(
    IN PSOCKET Socket
    );

UCHAR
PcicReadController(
    IN PUCHAR Base,
    IN USHORT Socket,
    IN UCHAR  PcicRegister
    );

VOID
PcicWriteController(
    IN PUCHAR Base,
    IN USHORT Socket,
    IN UCHAR  PcicRegister,
    IN UCHAR  DataByte
    );

NTSTATUS
PcicDetect(
    IN PFDO_EXTENSION DeviceExtension,
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG            IoPortBase
    );

BOOLEAN
PcicDetectCardInSocket(
    IN PSOCKET Socket
    );

BOOLEAN
PcicDetectCardChanged(
    IN PSOCKET Socket
    );

BOOLEAN
PcicPCCardReady(
    IN PSOCKET Socket
    );

BOOLEAN
PcicDetectReadyChanged(
    IN PSOCKET Socket
    );

BOOLEAN
PcicProcessConfigureRequest(
    IN PSOCKET Socket,
    IN PCARD_REQUEST ConfigRequest,
    IN PUCHAR  Base
    );

VOID
PcicEnableDisableWakeupEvent(
    IN PSOCKET Socket,
    IN PPDO_EXTENSION PdoExtension,
    IN BOOLEAN Enable
    );

VOID
PcicEnableDisableMemory(
    IN PSOCKET Socket,
    IN MEMORY_SPACE MemorySpace,
    IN ULONG   CardBase,
    IN UCHAR   Mem16BitWindow,
    IN BOOLEAN Enable
    );

BOOLEAN
PcicEnableDisableCardDetectEvent(
    IN PSOCKET Socket,
    IN BOOLEAN Enable
    );

UCHAR
PcicReadExtendedCirrusController(
    IN PUCHAR Base,
    IN USHORT Socket,
    IN UCHAR  Register
    );

VOID
PcicWriteExtendedCirrusController(
    IN PUCHAR Base,
    IN USHORT Socket,
    IN UCHAR  PcicRegister,
    IN UCHAR  DataByte
    );

ULONG
PcicWriteCardMemory(
    IN PPDO_EXTENSION PdoExtension,
    IN  MEMORY_SPACE MemorySpace,
    IN  ULONG  Offset,
    IN  PUCHAR Buffer,
    IN  ULONG  Length
    );

ULONG
PcicReadCardMemory(
    IN PPDO_EXTENSION PdoExtension,
    IN MEMORY_SPACE MemorySpace,
    IN ULONG   Offset,
    IN PUCHAR Buffer,
    IN ULONG  Length
    );

BOOLEAN
PcicModifyMemoryWindow(
    IN PDEVICE_OBJECT Pdo,
    IN ULONGLONG HostBase,
    IN ULONGLONG CardBase,
    IN BOOLEAN   Enable,
    IN ULONG     WindowSize  OPTIONAL,
    IN UCHAR     AccessSpeed OPTIONAL,
    IN UCHAR     BusWidth    OPTIONAL,
    IN BOOLEAN   IsAttributeMemory OPTIONAL
    );

BOOLEAN
PcicSetVpp(
    IN PDEVICE_OBJECT Pdo,
    IN UCHAR            VppLevel
    );

BOOLEAN
PcicIsWriteProtected(
    IN PDEVICE_OBJECT Pdo
    );

ULONG
PcicGetIrqMask(
    IN PFDO_EXTENSION deviceExtension
    );

NTSTATUS
PcicConvertSpeedToWait(
    IN  UCHAR Speed,
    OUT PUCHAR WaitIndex
    );

//
// Internal Data
//

ULONG  PcicStallCounter = 4000;     //4ms

UCHAR WaitToSpeedTable[4] = {
    0x42,   //350ns
    0x52,   //450ns
    0x62,   //600ns
    0x72      //700ns
};

UCHAR DevSpeedTable[8] = {
    0xff,   // speed 0: invalid
    0x32,   // speed 1: 250ns
    0x2a,   // speed 2: 200ns
    0x22,   // speed 3: 150ns
    0x0a,   // speed 4: 100ns
    0xff,   // speed 5: reserved
    0xff,   // speed 6: reserved
    0xff      // speed 7: invalid
};

PCMCIA_CTRL_BLOCK PcicSupportFns = {
    PcicInitializePcmciaSocket,
    PcicResetCard,
    PcicDetectCardInSocket,
    PcicDetectCardChanged,
    NULL,                                               // PcicDetectCardStatus
    PcicDetectReadyChanged,
    NULL,                                               // GetPowerRequirements
    PcicProcessConfigureRequest,
    PcicEnableDisableCardDetectEvent,
    PcicEnableDisableWakeupEvent,
    PcicGetIrqMask,
    PcicReadCardMemory,
    PcicWriteCardMemory,
    PcicModifyMemoryWindow,
    PcicSetVpp,
    PcicIsWriteProtected
};

#define MEM_16BIT 1
#define MEM_8BIT    0

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(INIT,PcicIsaDetect)
    #pragma alloc_text(INIT,PcicDetect)
    #pragma alloc_text(PAGE,PcicBuildSocketList)
#endif


ULONG
PcicGetIrqMask(
    IN PFDO_EXTENSION DeviceExtension
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    //
    // Return the set of supported IRQs for the controller
    // and PcCards
    //
    if (CLPD6729(DeviceExtension->SocketList)) {
        return CL_SUPPORTED_INTERRUPTS;
    } else {
        return PCIC_SUPPORTED_INTERRUPTS;
    }
}



BOOLEAN
PcicEnableDisableCardDetectEvent(
    IN PSOCKET Socket,
    IN BOOLEAN Enable
    )

/*++

Routine Description:

     Enable card detect interrupt.

Arguments:

     Socket - socket information
     Irq - the interrupt value to set.
     Enable - if  TRUE, CSC interrupt is enabled,
                 if FALSE, it is disabled
Return Value:

     None

--*/

{
    PFDO_EXTENSION deviceExtension = Socket->DeviceExtension;
    INTERFACE_TYPE interface;
    UCHAR byte;
    ULONG Irq = Socket->FdoIrq;

    switch (Enable) {

    case TRUE: {
                if (CLPD6729(Socket)) {
                    //
                    // For Cirrus Logic PCI controller we need to know the interrupt pin
                    // (INTA, INTB etc.) corresponding to the level passed in. Hence the
                    // passed in Irq is discarded. Actually the Irq parameter is redundant
                    // since it can be fetched from the device extension itself.
                    // If we remove the Irq param from this routine, the following is
                    // not so inelegant..
                    //
                    interface = PCIBus;
                    switch (deviceExtension->Configuration.InterruptPin) {
                    case 0: {
                            //
                            // This is what tells us that ISA interrupts are being used...
                            //
                            interface = Isa;
                            break;
                        }
                    case 1: {
                            Irq = PCIC_CIRRUS_INTA;
                            break;
                        }
                    case 2: {
                            Irq = PCIC_CIRRUS_INTB;
                            break;
                        }
                    case 3: {
                            Irq = PCIC_CIRRUS_INTC;
                            break;
                        }
                    case 4: {
                            Irq = PCIC_CIRRUS_INTD;
                            break;
                        }
                    }
                    //
                    // Set the Cirrus Logic controller for PCI style interrupts
                    //
                    byte = PcicReadExtendedCirrusController(Socket->AddressPort,
                                                            Socket->RegisterOffset,
                                                            PCIC_CIRRUS_EXTENSION_CTRL_1);
                    if (interface == PCIBus) {
                        byte |= 0x10;   // PCI style interrupt
                    } else {
                        byte &= ~0x10; // Isa style interrupt
                    }
                    PcicWriteExtendedCirrusController(Socket->AddressPort,
                                                      Socket->RegisterOffset,
                                                      PCIC_CIRRUS_EXTENSION_CTRL_1,
                                                      byte);
                    PcmciaWait(100);
                }

                byte=PcicReadSocket(Socket, PCIC_CARD_INT_CONFIG);

                byte = byte & CSCFG_BATT_MASK;  // Don't nuke any other enables
                byte = byte | (UCHAR) ((Irq << 4) & 0x00ff); // Put IRQ in upper nibble
                byte |= CSCFG_CD_ENABLE;

                PcicWriteSocket(Socket, PCIC_CARD_INT_CONFIG, byte);
                break;
            }

    case FALSE: {
                //
                // Clear pending interrupt (for now)
                //
                byte = PcicReadSocket(Socket, PCIC_CARD_CHANGE);
                DebugPrint((PCMCIA_DEBUG_INFO, "PcicDisableInterrupt:Status Change %x\n", byte));
                PcicWriteSocket(Socket,
                                PCIC_CARD_INT_CONFIG,
                                0x0);
                break;
            }
    }

    return TRUE;
}



NTSTATUS
PcicSetPower(
    IN PSOCKET Socket,
    IN BOOLEAN Enable,
    OUT PULONG pDelayTime
    )

/*++

Routine Description:

     Set power to the specified socket.

Arguments:

     Socket - the socket to set
     Enable - TRUE means to set power - FALSE is to turn it off.
     pDelayTime - specifies delay (msec) to occur after the current phase

Return Value:

     STATUS_MORE_PROCESSING_REQUIRED - increment phase, perform delay, recall
     other status values terminate sequence

--*/

{
    NTSTATUS status;
    UCHAR               tmp, vcc;

    //
    // Turn on the power - then turn on output - this is two operations
    // per the Intel 82365SL documentation.
    //

    if (Enable) {
        switch(Socket->PowerPhase) {
        case 1:

            tmp = PcicReadSocket(Socket, PCIC_PWR_RST);
            //
            // 5V for R2 cards..
            //
            vcc = PC_CARDPWR_ENABLE;

            if (Elc(Socket)) {
                tmp = PC_VPP_SETTO_VCC | vcc; // vpp1 = vcc
            } else {
                //
                // Apparently we need to set bit 2 also for some obscure reason
                //
                tmp = 0x4 | PC_VPP_SETTO_VCC | vcc; // vpp1 = vpp2 = vcc
            }

            PcicWriteSocket(Socket, PCIC_PWR_RST, tmp);

            //
            // OUTPUT_ENABLE & AUTOPWR_ENABLE..
            // Disable RESETDRV also..
            //
            tmp |= PC_OUTPUT_ENABLE | PC_AUTOPWR_ENABLE | PC_RESETDRV_DISABLE;

            PcicWriteSocket(Socket, PCIC_PWR_RST, tmp);
            //
            // When power is enabled always stall to give the PCCARD
            // a chance to react.
            //
            *pDelayTime = PCMCIA_PCIC_STALL_POWER;
            status = STATUS_MORE_PROCESSING_REQUIRED;
            break;

        case 2:
            //
            // Check for an as yet unexplained condition on Dell Latitude XPi's
            //
            tmp = PcicReadSocket(Socket, PCIC_STATUS);
            if (!(tmp & 0x40)) {
                //
                // power hasn't come on, flip the mystery bit
                //
                tmp = PcicReadSocket(Socket, 0x2f);
                if (tmp == 0x42) {
                    PcicWriteSocket(Socket, 0x2f, 0x40);
                    *pDelayTime = PCMCIA_PCIC_STALL_POWER;
                }
            }
            status = STATUS_SUCCESS;
            break;

        default:
            ASSERT(FALSE);
            status = STATUS_UNSUCCESSFUL;
        }

    } else {
        PcicWriteSocket(Socket, PCIC_PWR_RST,   0x00);
        status = STATUS_SUCCESS;
    }
    return status;
}


NTSTATUS
PcicConvertSpeedToWait(
    IN  UCHAR Speed,
    OUT PUCHAR WaitIndex
    )
{
    NTSTATUS status = STATUS_INVALID_PARAMETER;
    UCHAR exponent, exponent2, mantissa, index;


    if (Speed & SPEED_EXT_MASK) {
        return status;
    }

    exponent = Speed & SPEED_EXPONENT_MASK;
    mantissa = Speed & SPEED_MANTISSA_MASK;

    if (mantissa == 0) {
        mantissa = DevSpeedTable[exponent] & SPEED_MANTISSA_MASK;
        exponent = DevSpeedTable[exponent] & SPEED_EXPONENT_MASK;
    }
    for (index = 0; index < sizeof(WaitToSpeedTable); index++) {
        exponent2= WaitToSpeedTable[index] & SPEED_EXPONENT_MASK;
        if ((exponent < exponent2) ||
             ((exponent == exponent2) &&
              (mantissa < (WaitToSpeedTable[index] & SPEED_MANTISSA_MASK)))) {
            *WaitIndex = index;
            status = STATUS_SUCCESS;
            break;
        }
    }
    return status;
}


BOOLEAN
PcicSetVpp(
    IN PDEVICE_OBJECT Pdo,
    IN UCHAR Vpp
    )
/*++

Routine Description

  Part of the interfaces originally developed to
  support flash memory cards.
  Sets VPP1 to the required setting

Arguments

  Pdo - Pointer to device object  for the PC-Card
  Vpp - Desired Vpp setting. This is currently one of
          PCMCIA_VPP_12V      (12 volts)
          PCMCIA_VPP_0V   (disable VPP)
          PCMCIA_VPP_IS_VCC (route VCC to VPP)

Return

    TRUE - if successful
    FALSE - if not. This will be returned if the
              PC-Card is not already powered up
--*/
{

    PSOCKET socketPtr = ((PPDO_EXTENSION) Pdo->DeviceExtension)->Socket;
    UCHAR tmp;

    ASSERT ( socketPtr != NULL );
    tmp = PcicReadSocket(socketPtr, PCIC_PWR_RST);

    if ((tmp & 0x10) == 0) {
        //
        // Vcc not set.
        //
        return FALSE;
    }

    //
    // Turn off Vpp bits
    //
    tmp &= ~0x3;

    switch (Vpp) {
    case PCMCIA_VPP_IS_VCC: {
            tmp |= 0x1;
            break;
        }
    case PCMCIA_VPP_12V: {
            tmp |= 0x2;
            break;
        }
    case PCMCIA_VPP_0V: {
            tmp |= 0x0;
            break;
        }
    }

    PcicWriteSocket(socketPtr, PCIC_PWR_RST, tmp);
    if (Vpp != PCMCIA_VPP_0V) {
        //
        // When power is enabled always stall to give the PCCARD
        // a chance to react.
        //

        PcmciaWait(PCMCIA_PCIC_STALL_POWER);
    }
    return TRUE;
}


BOOLEAN
PcicModifyMemoryWindow(
    IN PDEVICE_OBJECT Pdo,
    IN ULONGLONG HostBase,
    IN ULONGLONG CardBase OPTIONAL,
    IN BOOLEAN   Enable,
    IN ULONG     WindowSize  OPTIONAL,
    IN UCHAR     AccessSpeed OPTIONAL,
    IN UCHAR     BusWidth    OPTIONAL,
    IN BOOLEAN   IsAttributeMemory OPTIONAL
    )
/*++

Routine Description:

    Part of the interfaces originally developed to
    support flash memory cards.

    This routine enables the caller to 'slide' the supplied
    host memory window across the given (16-bit)pc-card's card memory.
    i.e. the host memory window will be modified to map
    the pc-card at a new card memory offset

Arguments:

    Pdo         - Pointer to the device object for the PC-Card

    HostBase    - Host memory window base to be mapped

    CardBase    - Mandatory if Enable is TRUE
                      New card memory offset to map the host memory window
                      to

    Enable      - If this is FALSE - all the remaining arguments
                      are ignored and the host window will simply be
                      disabled

    WindowSize  - Specifies the size of the host memory window to
                      be mapped. Note this must be at the proper alignment
                      and must be less than or equal to the originally
                      allocated window size for the host base.
                      If this is zero, the originally allocated window
                      size will be used.

    AccessSpeed - Mandatory if Enable is TRUE
                      Specifies the new access speed for the pc-card.
                      (AccessSpeed should be encoded as per the pc-card
                        standard, card/socket services spec)

    BusWidth    - Mandatory if Enable is TRUE
                      One of PCMCIA_MEMORY_8BIT_ACCESS
                      or        PCMCIA_MEMORY_16BIT_ACCESS

    IsAttributeMemory - Mandatory if Enable is TRUE
                              Specifies if the window should be mapped
                              to the pc-card's attribute or common memory


Return Value:

    TRUE    -        Memory window was enabled/disabled as requested
    FALSE -      If not

--*/
{
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
    PFDO_EXTENSION fdoExtension;
    PSOCKET socketPtr;
    PSOCKET_CONFIGURATION socketConfig;
    USHORT index;
    UCHAR  registerOffset;
    UCHAR  regl;
    UCHAR  regh;
    UCHAR  tmp, waitIndex;

    socketConfig = pdoExtension->SocketConfiguration;
    if (!socketConfig) {
        // doesn't look like we are started.
        return FALSE;
    }

    socketPtr = pdoExtension->Socket;
    ASSERT ( socketPtr != NULL );
    fdoExtension = socketPtr->DeviceExtension;

    for (index = 0 ; index < socketConfig->NumberOfMemoryRanges; index++) {
        if (socketConfig->Memory[index].HostBase == HostBase) {
            break;
        }
    }

    if (index >= socketConfig->NumberOfMemoryRanges) {
        //
        // Unknown hostbase
        //
        return FALSE;
    }

    //
    // Make sure caller isn't asking a bigger window
    // than he is permitted to
    //
    if (WindowSize > socketConfig->Memory[index].Length) {
        return FALSE;
    }

    if (WindowSize == 0) {
        //
        // WindowSize not provided. Default to
        // the largest size permitted for this pc-card
        //
        WindowSize = socketConfig->Memory[index].Length;
    }

    //
    // Determine offset in registers.
    //
    registerOffset = (index * 8);

    //
    // Disable the window first (this has to be done regardless
    // of whether we want to enable/disable the window ultimately)
    //


    PCMCIA_ACQUIRE_DEVICE_LOCK(socketPtr->DeviceExtension);

    tmp = PcicReadSocket(socketPtr, PCIC_ADD_WIN_ENA);
    tmp &= ~(1 << index);
    PcicWriteSocket(socketPtr, PCIC_ADD_WIN_ENA, tmp);

    if (!Enable) {
        //
        // We're done.. Just write zeroes to the window registers anyway
        // before returning
        //
        PcicWriteSocket(socketPtr,
                             (UCHAR)(PCIC_CRDMEM_OFF_ADD0_L+registerOffset),
                             0);
        PcicWriteSocket(socketPtr,
                             (UCHAR)(PCIC_CRDMEM_OFF_ADD0_H+registerOffset),
                             0);
        PcicWriteSocket(socketPtr,
                             (UCHAR)(PCIC_MEM_ADD0_STRT_L+registerOffset),
                             0);
        PcicWriteSocket(socketPtr,
                             (UCHAR)(PCIC_MEM_ADD0_STRT_H+registerOffset),
                             0);
        PcicWriteSocket(socketPtr,
                             (UCHAR)(PCIC_MEM_ADD0_STOP_L+registerOffset),
                             0);
        PcicWriteSocket(socketPtr,
                             (UCHAR)(PCIC_MEM_ADD0_STOP_H+registerOffset),
                             0);
        PcmciaSetWindowPage(fdoExtension, socketPtr, index, 0);
        PCMCIA_RELEASE_DEVICE_LOCK(socketPtr->DeviceExtension);
        return TRUE;
    }

    if (AccessSpeed) {
        if (!NT_SUCCESS(PcicConvertSpeedToWait(AccessSpeed, &waitIndex))) {
            PCMCIA_RELEASE_DEVICE_LOCK(socketPtr->DeviceExtension);
            return FALSE;
        }
    }

    //
    // Calculate and set card base addresses.
    // This is the 2's complement of the host address and
    // the card offset.
    //

    CardBase = (CardBase - (HostBase & OFFSETCALC_BASE_MASK)) & OFFSETCALC_OFFSET_MASK;
    regl = (UCHAR) (CardBase >> 12);
    regh = (UCHAR) ((CardBase >> 20) & 0x003f);
    if (IsAttributeMemory) {
        regh |= 0x40;
    }


    PcicWriteSocket(socketPtr,
                    (UCHAR)(PCIC_CRDMEM_OFF_ADD0_L + registerOffset),
                    regl);
    PcicWriteSocket(socketPtr,
                    (UCHAR)(PCIC_CRDMEM_OFF_ADD0_H + registerOffset),
                    regh);

    //
    // Calculate and set host window.
    //
    if (!PcmciaSetWindowPage(fdoExtension, socketPtr, index, (UCHAR) ((ULONG) HostBase >> 24))) {
        if ((HostBase + WindowSize) > 0xFFFFFF) {
            DebugPrint((PCMCIA_DEBUG_FAIL, "PcicModifyMemorywindow: HostBase %x specified: doesn't fit in 24 bits!\n", (ULONG) HostBase));
            PCMCIA_RELEASE_DEVICE_LOCK(socketPtr->DeviceExtension);
            return FALSE;
        }
    }

    regl = (UCHAR) (HostBase >> 12);
    regh = (UCHAR) (HostBase >> 20) & 0xF;
    if (BusWidth == PCMCIA_MEMORY_16BIT_ACCESS) {

        regh |= 0x80; // 16-bit access

#if 0
        //
        // If this is not a revision 1 part (0x82), then set
        // the work around register for 16-bit windows.
        //
        // This bit is not used on any chip that I have
        // documentation for. I have no idea why it is here, it is
        // not in win9x.
        // In any case it looks like a NOOP for the vast majority of
        // chips, but since it uses a NOT, then it is invoked on all
        // new controllers. REMOVE after next major release
        //
        if (socketPtr->Revision != PCIC_REVISION) {
            tmp = PcicReadSocket(socketPtr,
                                 PCIC_CARD_DETECT);
            tmp |= 0x01;
            PcicWriteSocket(socketPtr,
                            PCIC_CARD_DETECT,
                            tmp);
        }
#endif
    }


    PcicWriteSocket(socketPtr,
                         (UCHAR)(PCIC_MEM_ADD0_STRT_L + registerOffset),
                         regl);
    PcicWriteSocket(socketPtr,
                         (UCHAR)(PCIC_MEM_ADD0_STRT_H + registerOffset),
                         regh);

    //
    // Set stop address.
    //

    HostBase += WindowSize - 1;
    regl = (UCHAR) (HostBase >> 12);
    regh = (UCHAR) (HostBase >> 20) & 0xF;

    //
    // Set the wait states
    //
    if (AccessSpeed) {
        //
        // New access speed specified, use it
        //
        regh |= (waitIndex << 6);
    } else {
        //
        //  Use existing access speed
        //
        regh |= (PcicReadSocket(socketPtr, (UCHAR)(PCIC_MEM_ADD0_STOP_H + registerOffset)) & 0xC0);

    }

    PcicWriteSocket(socketPtr,
                    (UCHAR)(PCIC_MEM_ADD0_STOP_L + registerOffset),
                    regl);
    PcicWriteSocket(socketPtr,
                    (UCHAR)(PCIC_MEM_ADD0_STOP_H + registerOffset),
                    regh);

    //
    // Memory window set up now enable it
    //
    tmp  = (1 << index);
    tmp |= PcicReadSocket(socketPtr, PCIC_ADD_WIN_ENA);
    PcicWriteSocket(socketPtr, PCIC_ADD_WIN_ENA, tmp);

    //
    // Allow the window to settle
    //
    (VOID) PcicPCCardReady(socketPtr);
    PCMCIA_RELEASE_DEVICE_LOCK(socketPtr->DeviceExtension);
    return TRUE;
}


BOOLEAN
PcicIsWriteProtected(
    IN PDEVICE_OBJECT Pdo
    )
/*++

Routine Description:

    Part of the interfaces originally developed to
    support flash memory cards.

    Returns the status of the write protected pin
    for the given PC-Card

Arguments:

    Pdo - Pointer to the device object for the PC-Card

Return Value:

    TRUE    -        if the PC-Card is write-protected
    FALSE -      if not

--*/
{
    PSOCKET socketPtr = ((PPDO_EXTENSION) Pdo->DeviceExtension)->Socket;

    ASSERT ( socketPtr != NULL );
    return ((PcicReadSocket(socketPtr, PCIC_STATUS) & 0x10) != 0);
}


VOID
PcicEnableDisableWakeupEvent(
    IN PSOCKET Socket,
    IN PPDO_EXTENSION PdoExtension,
    IN BOOLEAN Enable
    )
/*++

Routine Description

    This routine sets/resets the Ring Indicate enable bit for the given socket,
    enabling a PC-Card in the socket to assert/not assert wake through the RingIndicate
    pin.

Arguments

Socket          - Pointer to the socket
Enable          - TRUE : set ring indicate enable
                      FALSE: turn off ring indicate, i.e. system cannot be woken up through
                                    a pc-card in this socket

Return Value

None

--*/
{
    UCHAR byte;

    byte = PcicReadSocket(Socket, PCIC_INTERRUPT);
    if (Enable) {
        byte |= IGC_RINGIND_ENABLE;
    } else {
        byte &= ~IGC_RINGIND_ENABLE;
    }
    PcicWriteSocket(Socket, PCIC_INTERRUPT, byte);
}


BOOLEAN
PcicInitializePcmciaSocket(
    PSOCKET Socket
    )

/*++

Routine Description:

     This routine will setup the 82365 into a state where the pcmcia support
     module will be able to issue commands to read device tuples from the
     cards in the sockets.

Arguments:

     Socket - socket specific information

Return Value:

     TRUE if successful
     FALSE if not successful

--*/

{
    UCHAR index;
    UCHAR byte;
    UCHAR reg;

    //
    // Initialize the EXCA registers
    //
    //
    for (index = 0; index < 0xFF; index++) {
        reg  = (UCHAR) PcicRegisterInitTable[index].Register;
        if (reg == 0xFF) {
            //
            // End of table
            //
            break;
        }

        byte = (UCHAR) PcicRegisterInitTable[index].Value;
        if (reg == PCIC_INTERRUPT) {
            //
            // Don't clobber the Ring Enable bit
            // NOTE: this entire if statement should be removed
            // when WAIT_WAKE support is done for modems
            // also don't clobber the interrupt enable bit
            //
            byte |= (PcicReadSocket(Socket, reg) & (IGC_RINGIND_ENABLE | IGC_INTR_ENABLE));
        }
        PcicWriteSocket(Socket, reg, byte);
    }

    if (CLPD6729(Socket)) {

        //
        // Need to program the chip per code in
        // Windows 95.  This will turn on the
        // audio support bit.
        // NOTE: This used to be done in PcicDetect
        //
        byte = PcicReadSocket(Socket, PCIC_CL_MISC_CTRL1);
        byte |= CL_MC1_SPKR_ENABLE;
        PcicWriteSocket(Socket, PCIC_CL_MISC_CTRL1, byte);

        //
        // Set the Cirrus Logic controller for ISA style interrupts
        //
        byte = PcicReadExtendedCirrusController(Socket->AddressPort,
                                                Socket->RegisterOffset,
                                                PCIC_CIRRUS_EXTENSION_CTRL_1);

        byte &= ~0x08; // Isa style interrupt
        PcicWriteExtendedCirrusController(Socket->AddressPort,
                                          Socket->RegisterOffset,
                                          PCIC_CIRRUS_EXTENSION_CTRL_1,
                                          byte);
    }

    return TRUE;
}


NTSTATUS
PcicResetCard (
    IN PSOCKET Socket,
    OUT PULONG pDelayTime
    )
/*++

Routine Description:

    Resets the pc-card in the given socket.

Arguments:

    Socket - Pointer to the socket in which the pc-card resides
    pDelayTime - specifies delay (msec) to occur after the current phase

Return value:

    STATUS_MORE_PROCESSING_REQUIRED - increment phase, perform delay, recall
    other status values terminate sequence

--*/
{
    NTSTATUS status;
    UCHAR byte;

    switch(Socket->CardResetPhase) {
    case 1:
        //
        // Set interface mode to memory to begin with
        //
        byte = PcicReadSocket(Socket, PCIC_INTERRUPT);
        byte &= ~IGC_PCCARD_IO;
        PcicWriteSocket(Socket, PCIC_INTERRUPT, byte);

        //
        // Start reset
        //
        byte = PcicReadSocket(Socket, PCIC_INTERRUPT);
        byte = byte & ~IGC_PCCARD_RESETLO;
        PcicWriteSocket(Socket, PCIC_INTERRUPT, byte);

        *pDelayTime = PCMCIA_PCIC_RESET_WIDTH_DELAY;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;

    case 2:
        //
        // Stop reset
        //
        byte = PcicReadSocket(Socket, PCIC_INTERRUPT);
        byte |= IGC_PCCARD_RESETLO;
        PcicWriteSocket(Socket, PCIC_INTERRUPT, byte);

        *pDelayTime = PCMCIA_PCIC_RESET_SETUP_DELAY;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;

    case 3:
        //
        // Wait for the card to settle
        //
        PcicPCCardReady(Socket);
        status = STATUS_SUCCESS;
        break;

    default:
        ASSERT(FALSE);
        status = STATUS_UNSUCCESSFUL;
    }
    return status;
}



UCHAR
PcicReadSocket(
    IN PSOCKET Socket,
    IN ULONG Register
    )

/*++

Routine Description:

     This routine will read a byte from the specified socket EXCA register

Arguments:

     Socket -- Pointer to the socket from which we should read
     Register -- The register to be read

Return Value:

    The data returned from the port.

--*/

{
    UCHAR byte;
    if (CardBus(Socket)) {
        //
        // Sanity check in case controller wasn't started
        //
        if (Socket->DeviceExtension->CardBusSocketRegisterBase) {
            byte = READ_REGISTER_UCHAR((PUCHAR) (Socket->DeviceExtension->CardBusSocketRegisterBase + Register
                                                            + CARDBUS_EXCA_REGISTER_BASE));
        } else {
            byte = 0xff;
        }
    } else {
        byte = PcicReadController(Socket->AddressPort, Socket->RegisterOffset,
                                  (UCHAR) Register);
    }
    return byte;
}


VOID
PcicWriteSocket(
    IN PSOCKET Socket,
    IN ULONG Register,
    IN UCHAR DataByte
    )

/*++

Routine Description:

     This routine will write a byte to the specified socket EXCA register

Arguments:

     Socket --   Pointer to the socket to which we write
     Register -- The register to be read
     DataByte -- Data to be written

Return Value:

     None

--*/

{
    if (CardBus(Socket)) {
        //
        // Sanity check in case controller wasn't started
        //
        if (Socket->DeviceExtension->CardBusSocketRegisterBase) {
            WRITE_REGISTER_UCHAR((PUCHAR) (Socket->DeviceExtension->CardBusSocketRegisterBase+Register+CARDBUS_EXCA_REGISTER_BASE), DataByte);
        }
    } else {
        PcicWriteController(Socket->AddressPort, Socket->RegisterOffset, (UCHAR)Register, DataByte);
    }
}


UCHAR
PcicReadController(
    IN PUCHAR Base,
    IN USHORT Socket,
    IN UCHAR Register
    )

/*++

Routine Description:

     This routine will read a byte from the controller data port

Arguments:

     Base -- The I/O port for the controller
     Socket -- The socket in for the card being read
     Register -- The register to be read

Return Value:

    The data returned from the port.

--*/

{
    UCHAR dataByte = 0;

    WRITE_PORT_UCHAR(Base, (UCHAR)(Socket+Register));
    dataByte = READ_PORT_UCHAR((PUCHAR)Base + 1);
    return dataByte;
}


VOID
PcicWriteController(
    IN PUCHAR Base,
    IN USHORT Socket,
    IN UCHAR Register,
    IN UCHAR DataByte
    )

/*++

Routine Description:

     This routine will write a byte to the controller data port

Arguments:

     Base -- The I/O port for the controller
     Socket -- The socket in for the card being read
     Register -- The register to be read
     DataByte -- Data to be written

Return Value:

     None

--*/

{
    WRITE_PORT_UCHAR(Base, (UCHAR)(Socket+Register));
    WRITE_PORT_UCHAR((PUCHAR)Base + 1, DataByte);
}


UCHAR
PcicReadExtendedCirrusController(
    IN PUCHAR Base,
    IN USHORT Socket,
    IN UCHAR Register
    )

/*++

Routine Description:

     This routine will read a byte from the Cirrus
     logic extended registers

Arguments:

     Base -- The I/O port for the controller
     Socket -- The socket in for the card being read
     Register -- The register to be read

Return Value:

    The data returned from the port.

--*/

{
    UCHAR dataByte = 0;
    PcicWriteController(Base, Socket, PCIC_CIRRUS_EXTENDED_INDEX, Register);
    dataByte = PcicReadController(Base, Socket, PCIC_CIRRUS_INDEX_REG);
    return dataByte;
}


VOID
PcicWriteExtendedCirrusController(
    IN PUCHAR Base,
    IN USHORT Socket,
    IN UCHAR Register,
    IN UCHAR DataByte
    )

/*++

Routine Description:

     This routine will write a byte to one of the
     Cirrus Logic extended registers

Arguments:

     Base -- The I/O port for the controller
     Socket -- The socket in for the card being read
     Register -- The register to be read
     DataByte -- Data to be written

Return Value:

     None

--*/

{
    //
    // Register needs to be written out to the extended index register
    //
    PcicWriteController(Base, Socket, PCIC_CIRRUS_EXTENDED_INDEX, Register);
    PcicWriteController(Base, Socket, PCIC_CIRRUS_INDEX_REG, DataByte);
}



ULONG
PcicReadWriteCardMemory(
    IN PSOCKET Socket,
    IN MEMORY_SPACE MemorySpace,
    IN ULONG Offset,
    IN PUCHAR Buffer,
    IN ULONG Length,
    IN CONST BOOLEAN Read
    )
/*++

Routine Description:
    This routine will read or write into the configuration memory on the card
    with the supplied buffer. This is provided as a service to certain
    client drivers (netcard) which need to write to the attribute memory
    (say) to set parameters etc.

Arguments:

     Socket      -- The socket info in for the card being written to
     MemorySpace -- indicates which space - attribute or common memory
     Offset      -- Offset in the memory to write to
     Buffer      -- Buffer contents being dumped to the card
     Length      -- Length of the buffer being written out
     Read        -- boolean indicating read or write

--*/
{
    PFDO_EXTENSION fdoExtension = Socket->DeviceExtension;
    PUCHAR memoryPtr, memoryPtrMax;
    PUCHAR bufferPtr;
    ULONG  index, adjustedOffset, adjustedBase;
    UCHAR  memGran;
    UCHAR memWidth;
    //
    // NOTE: memGran HAS to be a integral divisor of AttributeMemorySize for
    // the rest of the code to work!
    //
    memGran = (MemorySpace == PCCARD_ATTRIBUTE_MEMORY) ? 2 : 1;
    memWidth = (MemorySpace == PCCARD_ATTRIBUTE_MEMORY) ? MEM_8BIT : MEM_16BIT;

    //
    // Adjust for offsets > size of attribute memory window.
    //
    adjustedOffset =    (Offset*memGran) % fdoExtension->AttributeMemorySize;
    //
    // Adjusted base is: |_ Offset _| mod AttrributeMemorySize
    //
    adjustedBase = ((Offset*memGran) / fdoExtension->AttributeMemorySize) *
                        fdoExtension->AttributeMemorySize;

    bufferPtr = Buffer;

    PcicEnableDisableMemory(Socket, MemorySpace, adjustedBase, memWidth, TRUE);
    //
    // Now read the memory contents into the user buffer
    //
    memoryPtr = fdoExtension->AttributeMemoryBase + adjustedOffset;
    memoryPtrMax = fdoExtension->AttributeMemoryBase + fdoExtension->AttributeMemorySize;

    for (index = 0; index < Length; index++) {

        if (memoryPtr >= memoryPtrMax) {
            //
            // Skip to next page of attribute memory
            // (size of page = fdoExtension->AttributeMemorySize)
            //
            adjustedBase += fdoExtension->AttributeMemorySize;
            //
            // Remap window at new base
            //
            PcicEnableDisableMemory(Socket, MemorySpace, adjustedBase, memWidth, TRUE);

            memoryPtr = fdoExtension->AttributeMemoryBase;
        }

        if (Read) {
            *bufferPtr++ = READ_REGISTER_UCHAR(memoryPtr);
        } else {
            WRITE_REGISTER_UCHAR(memoryPtr, *bufferPtr++);
        }
        memoryPtr += memGran;
    }

    PcicEnableDisableMemory(Socket, 0,0,0, FALSE);
    return Length;
}



ULONG
PcicReadWriteCardMemoryIndirect(
    IN PSOCKET Socket,
    IN MEMORY_SPACE MemorySpace,
    IN ULONG Offset,
    IN PUCHAR Buffer,
    IN ULONG Length,
    IN CONST BOOLEAN Read
    )
/*++

Routine Description:
    This routine will read or write the memory space of a pcmcia card
    using the indirect access method.

Arguments:

    Socket      -- The socket info in for the card being written to
    MemorySpace -- indicates which space - attribute or common memory
    Offset      -- Offset in the memory to write to
    Buffer      -- Buffer contents being dumped to the card
    Length      -- Length of the buffer being written out
    Read            -- boolean indicating read or write

--*/
{
    PFDO_EXTENSION fdoExtension = Socket->DeviceExtension;
    ULONG  index, adjustedOffset;
    PUCHAR pMem;
    UCHAR Control = 0;
    UCHAR  memGran;

    PcicEnableDisableMemory(Socket, PCCARD_COMMON_MEMORY, 0, MEM_8BIT, TRUE);

    pMem = (PUCHAR) ((ULONG_PTR)(fdoExtension->AttributeMemoryBase) + IAR_CONTROL_LOW);

    Control = (MemorySpace == PCCARD_ATTRIBUTE_MEMORY_INDIRECT) ? IARF_AUTO_INC :
                                                                  IARF_AUTO_INC | IARF_COMMON | IARF_BYTE_GRAN;
    WRITE_REGISTER_UCHAR(pMem, Control);

    memGran = (MemorySpace == PCCARD_ATTRIBUTE_MEMORY_INDIRECT) ? 2 : 1;
    adjustedOffset = Offset*memGran;

    pMem = (PUCHAR) ((ULONG_PTR)(fdoExtension->AttributeMemoryBase) + IAR_ADDRESS);
    for (index = 0; index < sizeof(ULONG); index++) {
        WRITE_REGISTER_UCHAR(pMem++, (UCHAR)(adjustedOffset>>(index*8)));
    }

    PcicEnableDisableMemory(Socket, PCCARD_COMMON_MEMORY, 0, MEM_16BIT, TRUE);

    for (index = 0; index < Length; index++) {
        // Note that pMem should be pointing to IAR_DATA, and is NOT
        // supposed to be incremented
        if (Read) {
            Buffer[index] = READ_REGISTER_UCHAR(pMem);
        } else {
            WRITE_REGISTER_UCHAR(pMem, Buffer[index]);
        }
    }

    PcicEnableDisableMemory(Socket, 0,0,0, FALSE);
    return Length;
}



ULONG
PcicWriteCardMemory(
    IN PPDO_EXTENSION PdoExtension,
    IN MEMORY_SPACE MemorySpace,
    IN ULONG Offset,
    IN PUCHAR Buffer,
    IN ULONG Length
    )
/*++

Routine Description:
    This routine will write into the configuration memory on the card
    with the supplied buffer. This is provided as a service to certain
    client drivers (netcard) which need to write to the attribute memory
    (say) to set parameters etc.

Arguments:

     PdoExtension-- The extension of the device being written to
     MemorySpace -- indicates which space - attribute or common memory
     Offset      -- Offset in the memory to write to
     Buffer      -- Buffer contents being dumped to the card
     Length      -- Length of the buffer being written out

--*/
{
    PSOCKET Socket = PdoExtension->Socket;
    ULONG retLength;

    ASSERT (IsSocketFlagSet(Socket, SOCKET_CARD_POWERED_UP));

    switch(MemorySpace) {

    case PCCARD_ATTRIBUTE_MEMORY_INDIRECT:
    case PCCARD_COMMON_MEMORY_INDIRECT:

        retLength = PcicReadWriteCardMemoryIndirect(Socket, MemorySpace, Offset, Buffer, Length, FALSE);
        break;

    case PCCARD_ATTRIBUTE_MEMORY:
    case PCCARD_COMMON_MEMORY:

        retLength = PcicReadWriteCardMemory(Socket, MemorySpace, Offset, Buffer, Length, FALSE);
        break;

    default:
        retLength = 0;
        ASSERT(FALSE);
    }

    return retLength;
}


ULONG
PcicReadCardMemory(
    IN PPDO_EXTENSION PdoExtension,
    IN MEMORY_SPACE MemorySpace,
    IN ULONG Offset,
    IN PUCHAR Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

     This routine will read the configuration memory on the card

Arguments:

     PdoExtension-- The extension of the device being read
     MemorySpace -- indicates which space - attribute or common memory
     Offset      -- Offset in the memory to read
     Buffer      -- pointer to pointer for tuple information.
     Length      -- maximum size of the buffer area for tuple information.

Return Value:



--*/

{
    PSOCKET Socket = PdoExtension->Socket;
    ULONG retLength;

    ASSERT (IsSocketFlagSet(Socket, SOCKET_CARD_POWERED_UP));

    switch(MemorySpace) {

    case PCCARD_ATTRIBUTE_MEMORY_INDIRECT:
    case PCCARD_COMMON_MEMORY_INDIRECT:

        retLength = PcicReadWriteCardMemoryIndirect(Socket, MemorySpace, Offset, Buffer, Length, TRUE);
        break;

    case PCCARD_ATTRIBUTE_MEMORY:
    case PCCARD_COMMON_MEMORY:

        retLength = PcicReadWriteCardMemory(Socket, MemorySpace, Offset, Buffer, Length, TRUE);

        DebugPrint((PCMCIA_DEBUG_INFO,"PcicReadCardMemory: "
                        "%.02X %.02X %.02X %.02X %.02X %.02X %.02X %.02X-%.02X %.02X %.02X %.02X %.02X %.02X %.02X %.02X\n",
                        Buffer[0], Buffer[1], Buffer[2], Buffer[3], Buffer[4], Buffer[5], Buffer[6], Buffer[7],
                        Buffer[8], Buffer[9], Buffer[10], Buffer[11], Buffer[12], Buffer[13], Buffer[14], Buffer[15]));
        break;

    default:
        retLength = 0;
        ASSERT(FALSE);
    }

    return retLength;
}



BOOLEAN
PcicProcessConfigureRequest(
    IN PSOCKET Socket,
    IN PCARD_REQUEST request,
    IN PUCHAR Base
    )

/*++

Routine Description:

     Processes a configure or IRQ setup request.

Arguments:

     ConfigRequest -- Socket config structure
     Base - the I/O port base

Return Value:

     None

--*/

{
    USHORT          index;
    UCHAR           tmp;

    //
    // Since all first entries in the config structure is a RequestType,
    // cast the pointer comming in as a PREQUEST_CONFIG to get the proper
    // RequestType
    //

    switch (request->RequestType) {

    case IO_REQUEST: {
            UCHAR ioControl = 0;

            if (!request->u.Io.IoEntry[0].BasePort) {
                break;
            }


            for (index = 0; index < request->u.Io.NumberOfRanges; index++) {
                UCHAR  registerOffset;

                registerOffset = (index * 4);

                if (request->u.Io.IoEntry[index].BasePort) {

                    PcicWriteSocket( Socket,
                                          PCIC_IO_ADD0_STRT_L + registerOffset,
                                          (UCHAR) (request->u.Io.IoEntry[index].BasePort & 0xff));
                    PcicWriteSocket( Socket,
                                          PCIC_IO_ADD0_STRT_H + registerOffset,
                                          (UCHAR) (request->u.Io.IoEntry[index].BasePort >> 8));
                    PcicWriteSocket(Socket,
                                         PCIC_IO_ADD0_STOP_L + registerOffset,
                                         (UCHAR) ((request->u.Io.IoEntry[index].BasePort +
                                                      request->u.Io.IoEntry[index].NumPorts) & 0xff));
                    PcicWriteSocket(Socket,
                                         PCIC_IO_ADD0_STOP_H + registerOffset,
                                         (UCHAR) ((request->u.Io.IoEntry[index].BasePort +
                                                      request->u.Io.IoEntry[index].NumPorts) >> 8));
                }


                //
                // set up the io control register
                //
                tmp = 0;

                if (request->u.Io.IoEntry[index].Attributes & IO_DATA_PATH_WIDTH) {
                    tmp |= IOC_IO0_DATASIZE;
                }

                if ((request->u.Io.IoEntry[index].Attributes & IO_WAIT_STATE_16) &&
                    !((Elc(Socket) || CLPD6729(Socket)))) {
                    tmp |= IOC_IO0_WAITSTATE;
                }

                if (request->u.Io.IoEntry[index].Attributes & IO_SOURCE_16) {
                    tmp |= IOC_IO0_IOCS16;
                }

                if (request->u.Io.IoEntry[index].Attributes & IO_ZERO_WAIT_8) {
                    tmp |= IOC_IO0_ZEROWS;
                }

                ioControl |= tmp << registerOffset;
            }

            PcicWriteSocket(Socket, PCIC_IO_CONTROL, ioControl);

            tmp = PcicReadSocket( Socket, PCIC_ADD_WIN_ENA);
            tmp &= ~(WE_IO0_ENABLE | WE_IO1_ENABLE);

            switch(request->u.Io.NumberOfRanges) {
                case 1:
                    tmp |= WE_IO0_ENABLE;
                    break;
                case 2:
                    tmp |= (WE_IO0_ENABLE | WE_IO1_ENABLE);
                    break;
            }

            PcicWriteSocket(Socket, PCIC_ADD_WIN_ENA, tmp);
            break;
        }

    case IRQ_REQUEST: {
            //
            // Do not nuke the reset and cardtype bits.
            //
            tmp = PcicReadSocket(Socket, PCIC_INTERRUPT);
            tmp &= ~IGC_IRQ_MASK;
            tmp |= request->u.Irq.AssignedIRQ;

            DebugPrint((PCMCIA_DEBUG_INFO, "PcicProcessConfigureRequest: Assigned IRQ %x programming IRQ %x\n", request->u.Irq.AssignedIRQ,tmp));

            PcicWriteSocket(Socket, PCIC_INTERRUPT, tmp);

            if (tmp = request->u.Irq.ReadyIRQ) {
                tmp = (tmp << 4) | 0x04;
                PcicWriteSocket(Socket, PCIC_CARD_INT_CONFIG, tmp);
            }

            break;
        }

    case DECONFIGURE_REQUEST: {
            //
            // Deregister the interrupt, re-init to memory interface
            //
            tmp = PcicReadSocket(Socket, PCIC_INTERRUPT);
            tmp &= ~(IGC_PCCARD_IO | IGC_IRQ_MASK);
            PcicWriteSocket(Socket, PCIC_INTERRUPT, tmp);

            //
            // Disable memory/io windows
            // Don't touch the memory window which is
            // is used by the controller for reading attribute memory
            //

            if (IsSocketFlagSet(Socket, SOCKET_MEMORY_WINDOW_ENABLED)) {
                UCHAR enableMask;
                enableMask = WE_MEM0_ENABLE << Socket->CurrentMemWindow;
                tmp = PcicReadSocket(Socket, PCIC_ADD_WIN_ENA);
                tmp &= enableMask;
            } else {
                //
                // no attribute window enabled, just turn off everything
                //
                tmp = 0;
            }

            PcicWriteSocket(Socket, PCIC_ADD_WIN_ENA, tmp);
            //
            // Zero out the I/O windows
            //
            for (index = PCIC_IO_ADD0_STRT_L; index <= PCIC_IO_ADD1_STOP_H; index++) {
                PcicWriteSocket(Socket,
                                (ULONG) index,
                                0);
            }

            break;
        }

    case CONFIGURE_REQUEST:{

            //
            // Tell the socket controller we are an I/O card if InterfaceType says so
            //
            if (request->u.Config.InterfaceType == CONFIG_INTERFACE_IO_MEM) {

                tmp = PcicReadSocket(Socket, PCIC_INTERRUPT);
                tmp |= IGC_PCCARD_IO;
                PcicWriteSocket(Socket, PCIC_INTERRUPT, tmp);

            } else {
                tmp = PcicReadSocket(Socket, PCIC_INTERRUPT);
                tmp &= ~IGC_PCCARD_IO;
                PcicWriteSocket(Socket, PCIC_INTERRUPT, tmp);
            }

            if (request->u.Config.RegisterWriteMask & (REGISTER_WRITE_CONFIGURATION_INDEX |
                                                       REGISTER_WRITE_CARD_CONFIGURATION  |
                                                       REGISTER_WRITE_IO_BASE)) {
                //
                // This is where we setup the card and get it ready for operation
                //
                ULONG  configRegisterBase = request->u.Config.ConfigBase / 2;
                PDEVICE_OBJECT Pdo = Socket->PdoList;
                PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
                MEMORY_SPACE memorySpace = IsPdoFlagSet(pdoExtension, PCMCIA_PDO_INDIRECT_CIS) ? PCCARD_ATTRIBUTE_MEMORY_INDIRECT :
                                                                                                                            PCCARD_ATTRIBUTE_MEMORY;


                if (request->u.Config.RegisterWriteMask & REGISTER_WRITE_IO_BASE) {
                    UCHAR ioHigh = (UCHAR)(request->u.Config.IoBaseRegister>>8);
                    UCHAR ioLow = (UCHAR) request->u.Config.IoBaseRegister;

                    PcicWriteCardMemory(pdoExtension, memorySpace, configRegisterBase + 5, &ioLow, 1);
                    PcmciaWait(PcicStallCounter);
                    PcicWriteCardMemory(pdoExtension, memorySpace, configRegisterBase + 6, &ioHigh, 1);
                    PcmciaWait(PcicStallCounter);
                }

                if (request->u.Config.RegisterWriteMask & REGISTER_WRITE_IO_LIMIT) {
                    PcicWriteCardMemory(pdoExtension, memorySpace, configRegisterBase + 9, (PUCHAR)&request->u.Config.IoLimitRegister, 1);
                    PcmciaWait(PcicStallCounter);
                }

                if (request->u.Config.RegisterWriteMask & REGISTER_WRITE_CONFIGURATION_INDEX) {
                    UCHAR configIndex = request->u.Config.ConfigIndex;

                    PcicWriteCardMemory(pdoExtension, memorySpace, configRegisterBase, &configIndex, 1);
                    PcmciaWait(PcicStallCounter);

                    configIndex |= 0x40;
                    PcicWriteCardMemory(pdoExtension, memorySpace, configRegisterBase, &configIndex, 1);
                    PcmciaWait(PcicStallCounter);
                }

                if (request->u.Config.RegisterWriteMask & REGISTER_WRITE_CARD_CONFIGURATION) {
                    PcicReadCardMemory(pdoExtension, memorySpace, configRegisterBase + 1, &tmp, 1);
                    PcmciaWait(PcicStallCounter);

                    tmp |= request->u.Config.CardConfiguration;

                    //
                    // turn off power control bit
                    //

                    tmp &= ~0x04;
                    PcicWriteCardMemory(pdoExtension, memorySpace, configRegisterBase + 1, &tmp, 1);
                    PcmciaWait(PcicStallCounter);
                }
            }
            break;
        }

    case MEM_REQUEST: {
            //
            // Set up memory ranges on the controller.
            //

            PFDO_EXTENSION deviceExtension = Socket->DeviceExtension;

            for (index = 0; index < request->u.Memory.NumberOfRanges; index++) {
                UCHAR  registerOffset;
                UCHAR  regl;
                UCHAR  regh;
                ULONG  cardBase = request->u.Memory.MemoryEntry[index].BaseAddress;
                ULONG  base = request->u.Memory.MemoryEntry[index].HostAddress;
                ULONG  size = request->u.Memory.MemoryEntry[index].WindowSize;

                //
                // Determine offset in registers.
                //

                registerOffset = (index * 8);

                //
                // Calculate and set card base addresses.
                // This is the 2's complement of the host address and
                // the card offset.
                //

                cardBase = (cardBase - (base & OFFSETCALC_BASE_MASK)) & OFFSETCALC_OFFSET_MASK;
                regl = (UCHAR) (cardBase >> 12);
                regh = (UCHAR) (cardBase >> 20);
                if (request->u.Memory.MemoryEntry[index].AttributeMemory) {
                    regh |= 0x40;
                }
                PcicWriteSocket(Socket,
                                     (UCHAR)(PCIC_CRDMEM_OFF_ADD0_L + registerOffset),
                                     regl);
                PcicWriteSocket(Socket,
                                     (UCHAR)(PCIC_CRDMEM_OFF_ADD0_H + registerOffset),
                                     regh);

                //
                // Calculate and set host window.
                //


                if (!PcmciaSetWindowPage(deviceExtension, Socket, index, (UCHAR) (base >> 24))) {
                    ASSERT (base <= 0xFFFFFF);
                }

                base &= 0xFFFFFF; // only 24bit host base allowed

                regl = (UCHAR) (base >> 12);
                regh = (UCHAR) (base >> 20);
                if (request->u.Memory.MemoryEntry[index].WindowDataSize16) {
                    //
                    // This memory window is for a 16-bit data path
                    // to the card. Enable appropriately.
                    //
                    regh |= (MEMBASE_16BIT >> 8);

#if 0
                    //
                    // If this is not a revision 1 part (0x82), then set
                    // the work around register for 16-bit windows.
                    //
                    // This bit is not used on any chip that I have
                    // documentation for. I have no idea why it is here, it is
                    // not in win9x.
                    // In any case it looks like a NOOP for the vast majority of
                    // chips, but since it uses a NOT, then it is invoked on all
                    // new controllers. REMOVE after next major release
                    //
                    if (Socket->Revision != PCIC_REVISION) {
                        tmp = PcicReadSocket(Socket,
                                             PCIC_CARD_DETECT);
                        tmp |= 0x01;
                        PcicWriteSocket(Socket,
                                        PCIC_CARD_DETECT,
                                        tmp);

                    }
#endif
                }

                PcicWriteSocket(Socket,
                                     (UCHAR)(PCIC_MEM_ADD0_STRT_L + registerOffset),
                                     regl);
                PcicWriteSocket(Socket,
                                     (UCHAR)(PCIC_MEM_ADD0_STRT_H + registerOffset),
                                     regh);

                //
                // Set stop address.
                //
                base += size - 1;
                regl = (UCHAR) (base >> 12);
                regh = (UCHAR) (base >> 20);

                //
                // Add specified wait states
                //
                regh |= (request->u.Memory.MemoryEntry[index].WaitStates << 6);

                PcicWriteSocket(Socket,
                                     (UCHAR)(PCIC_MEM_ADD0_STOP_L + registerOffset),
                                     regl);
                PcicWriteSocket(Socket,
                                     (UCHAR)(PCIC_MEM_ADD0_STOP_H + registerOffset),
                                     regh);
            }

            //
            // Memory windows are set up now enable them.
            //

            tmp = 0;
            for (index = 0; index < request->u.Memory.NumberOfRanges; index++) {
                tmp |= (1 << index);
            }
            tmp |= PcicReadSocket(Socket, PCIC_ADD_WIN_ENA);
            PcicWriteSocket(Socket, PCIC_ADD_WIN_ENA, tmp);
            break;
        }

    default: {
            DebugPrint((PCMCIA_DEBUG_FAIL, "ConfigRequest is INVALID!\n"));
        }
    }
    return TRUE;
}


BOOLEAN
PcicDetectCardInSocket(
    IN PSOCKET Socket
    )

/*++

Routine Description:

     This routine will determine if a card is in the socket

Arguments:

     Socket -- Socket information

Return Value:

     TRUE if card is present.

--*/

{
    UCHAR   tmp;
    BOOLEAN cardPresent=FALSE;

    //
    // Read the PCIC status register to see if the card is in there.
    //
    tmp = PcicReadSocket(Socket, PCIC_STATUS);
    tmp &= (CARD_DETECT_1 | CARD_DETECT_2);

    if (tmp == (CARD_DETECT_1 | CARD_DETECT_2)) {
        cardPresent = TRUE;
    }

    return cardPresent;
}


BOOLEAN
PcicDetectCardChanged(
    IN PSOCKET Socket
    )

/*++

Routine Description:

     This routine will determine if socket's card insertion status has changed.

Arguments:

     Socket -- Socket info.

Return Value:

     TRUE if card insertion status has changed.

--*/

{
    //
    // Read the PCIC CardStatusChange register to see if CD's have changed.
    //
    return (BOOLEAN) (PcicReadSocket(Socket, PCIC_CARD_CHANGE) & CSC_CD_CHANGE);
}


BOOLEAN
PcicDetectReadyChanged(
    IN PSOCKET Socket
    )

/*++

Routine Description:

     This routine will determine if socket's card ready status has changed

Arguments:

     Socket -- Socket info.

Return Value:

     TRUE if card ready enable has changed.

--*/

{
    //
    // Read the PCIC Card status change register to see if ready has changed
    //
    return (PcicReadSocket(Socket, PCIC_CARD_CHANGE) & CSC_READY_CHANGE
              ?TRUE :FALSE);
}



VOID
PcicEnableDisableMemory(
    IN PSOCKET Socket,
    IN MEMORY_SPACE MemorySpace,
    IN ULONG   CardBase,
    IN UCHAR   memWidth,
    IN BOOLEAN Enable
    )

/*++

Routine Description:

     This routine will enable or disable attribute/common memory.
     It searches for a free window first to avoid using a window already
     in use. Repeated 'enable' calls to this routine without a disable
     (in order to remap the base) is allowed.

Arguments:

     Socket -- Socket information
     MemorySpace -- Indicates which space - ATTRIBUTE_MEMORY/COMMON_MEMORY
     CardBase -- card offset (base) for the attribute memory window
     Enable -- If TRUE, enable, if FALSE, disable

Return Value:

     None

--*/

{
    ULONG location;
    PUCHAR cisBufferPointer;
    PFDO_EXTENSION deviceExtension= Socket->DeviceExtension;
    PUCHAR PcicCisBufferBase = (PUCHAR) deviceExtension->AttributeMemoryBase;
    ULONG  PcicPhysicalBase  = deviceExtension->PhysicalBase.LowPart;
    BOOLEAN memoryInterface;
    UCHAR tmp;
    UCHAR index;
    UCHAR  registerOffset;
    UCHAR enableMask;
    USHORT word;

    ASSERT (IsSocketFlagSet(Socket, SOCKET_CARD_POWERED_UP));

    if (Enable) {
        tmp = PcicReadSocket(Socket, PCIC_INTERRUPT);
        if (tmp & IGC_PCCARD_IO) {
            //
            // Card configured for i/o interface
            //
            memoryInterface = FALSE;
        } else {
            //
            // Card configured for Memory interface
            //
            memoryInterface = TRUE;
        }

        //
        // Find a window to use.
        //
        tmp = PcicReadSocket(Socket, PCIC_ADD_WIN_ENA);

        if (IsSocketFlagSet(Socket, SOCKET_MEMORY_WINDOW_ENABLED)) {
            index = Socket->CurrentMemWindow;
            enableMask = WE_MEM0_ENABLE << index;
        } else {
            for (index = 0, enableMask = WE_MEM0_ENABLE; index < 5; index++, enableMask <<= 1) {
                if (!(tmp & enableMask)) {
                    break;
                }
                if (index==4) {
                    //
                    // If we are here, we didn't find an available window. Just use the last
                    // one anyway, it is likely a pcmcia.sys bug.
                    //
//              ASSERT(FALSE); // hits docked thinkpads
                    break;
                }
            }
            Socket->CurrentMemWindow = index;
            SetSocketFlag(Socket, SOCKET_MEMORY_WINDOW_ENABLED);
        }

        registerOffset = (index * 8);

        //
        // First turn the window off
        //
        tmp &= ~enableMask;
        tmp &= ~WE_MEMCS16_DECODE;
        PcicWriteSocket(Socket, PCIC_ADD_WIN_ENA, tmp);

        //
        // Calculate and set the memory windows start and stop locations.
        //

        //
        // Only 24 bit addresses programmed
        // For cardbus controllers, 32 bit addresses are supported,
        // but the higher 8 bits are written to the page register (see below)
        location = PcicPhysicalBase & 0xFFFFFF;

        word = (USHORT) ((location >> 12) & MEMBASE_ADDR_MASK);

        //
        // typically run attribute memory with 8-bit window, common with 16-bit
        // (except for writing the registers for attribute_indirect)
        //
        if (memWidth == MEM_16BIT) {
            word |= MEMBASE_16BIT;
        }

        PcicWriteSocket(Socket, (UCHAR)(PCIC_MEM_ADD0_STRT_L+registerOffset), (UCHAR)(word));
        PcicWriteSocket(Socket, (UCHAR)(PCIC_MEM_ADD0_STRT_H+registerOffset), (UCHAR)(word >> 8));

        location += (deviceExtension->AttributeMemorySize - 1);

        word = (USHORT) ((location >> 12) & MEMEND_ADDR_MASK);
        //
        // Impose 3 wait states..lessons learnt from win9x implementations
        //
        word |= MEMEND_WS_MASK;

        PcicWriteSocket(Socket, (UCHAR)(PCIC_MEM_ADD0_STOP_L+registerOffset), (UCHAR)(word));
        PcicWriteSocket(Socket, (UCHAR)(PCIC_MEM_ADD0_STOP_H+registerOffset), (UCHAR)(word >> 8));

        //
        // Set up the 2's complement card offset to zero
        //
        location = (CardBase - (PcicPhysicalBase & OFFSETCALC_BASE_MASK)) & OFFSETCALC_OFFSET_MASK;

        word = (USHORT) ((location >> 12) & MEMOFF_ADDR_MASK);
        if (MemorySpace == PCCARD_ATTRIBUTE_MEMORY) {
            word |= MEMOFF_REG_ACTIVE;
        }

        PcicWriteSocket(Socket, (UCHAR)(PCIC_CRDMEM_OFF_ADD0_L+registerOffset), (UCHAR)(word));
        PcicWriteSocket(Socket, (UCHAR)(PCIC_CRDMEM_OFF_ADD0_H+registerOffset), (UCHAR)(word >> 8));

        //
        // Set the page register
        // (this routine is called only for R2 cards)
        // Use mem4 window explicitly
        //
        if (!PcmciaSetWindowPage(deviceExtension, Socket, (USHORT)index, (UCHAR) (PcicPhysicalBase >> 24))) {
            ASSERT (PcicPhysicalBase <= 0xFFFFFF);
        }

        //
        // Enable the address window
        //

        tmp = PcicReadSocket(Socket, PCIC_ADD_WIN_ENA);

        tmp |= enableMask | WE_MEMCS16_DECODE;

        PcicWriteSocket(Socket, PCIC_ADD_WIN_ENA, tmp);

        cisBufferPointer = PcicCisBufferBase;

        if (memoryInterface) {
            //
            // Only wait for card ready if the memory window does not appear
            //

            (VOID) PcicPCCardReady(Socket);
        } else {
            //
            // Wait a little bit for the window to appear
            //
            PcmciaWait(PCMCIA_PCIC_MEMORY_WINDOW_DELAY);
        }

        DebugPrint((PCMCIA_DEBUG_INFO, "skt %08x memory window %d enabled %x\n", Socket, index, PcicPhysicalBase));

    } else {

        if (IsSocketFlagSet(Socket, SOCKET_MEMORY_WINDOW_ENABLED)) {

            enableMask = WE_MEM0_ENABLE << Socket->CurrentMemWindow;
            registerOffset = (Socket->CurrentMemWindow * 8);
            //
            // Disable the Address window
            //

            tmp = PcicReadSocket(Socket, PCIC_ADD_WIN_ENA);
            tmp &= ~enableMask;

            PcicWriteSocket(Socket, PCIC_ADD_WIN_ENA, tmp);
            PcicWriteSocket(Socket, (UCHAR)(PCIC_MEM_ADD0_STRT_L+registerOffset), 0xFF);
            PcicWriteSocket(Socket, (UCHAR)(PCIC_MEM_ADD0_STRT_H+registerOffset), 0x0F);
            PcicWriteSocket(Socket, (UCHAR)(PCIC_MEM_ADD0_STOP_L+registerOffset), 0xFF);
            PcicWriteSocket(Socket, (UCHAR)(PCIC_MEM_ADD0_STOP_H+registerOffset), 0x0F);
            PcicWriteSocket(Socket, (UCHAR)(PCIC_CRDMEM_OFF_ADD0_L+registerOffset), 0x00);
            PcicWriteSocket(Socket, (UCHAR)(PCIC_CRDMEM_OFF_ADD0_H+registerOffset), 0x00);
            PcmciaSetWindowPage(deviceExtension, Socket, Socket->CurrentMemWindow, 0);


            DebugPrint((PCMCIA_DEBUG_INFO, "skt %08x memory window %d disabled\n", Socket, Socket->CurrentMemWindow));
            ResetSocketFlag(Socket, SOCKET_MEMORY_WINDOW_ENABLED);
        }
    }
    return;
}



BOOLEAN
PcicPCCardReady(
    IN PSOCKET Socket
    )

/*++

Routine Description:

     Loop for a reasonable amount of time waiting for the card status to
     return ready.

Arguments:

     Socket - the socket to check.

Return Value:

     TRUE - the card is ready.
     FALSE - after a reasonable delay the card is still not ready.

--*/

{
    ULONG index;
    UCHAR byte;
    PFDO_EXTENSION fdoExtension = Socket->DeviceExtension;
    NTSTATUS        status;
    LARGE_INTEGER   timeout;

#ifdef READY_ENABLE
    if (fdoExtension->PcmciaInterruptObject) {
        byte = PcicReadSocket(Socket, PCIC_STATUS);
        if (byte & 0x20) {
            return TRUE;
        }
        //
        // Enable ready enable controller interrupt
        //
        PcicEnableDisableControllerInterrupt(
                                             Socket,
                                             fdoExtension->Configuration.Interrupt.u.Interrupt.Level,
                                             TRUE,
                                             TRUE);
        RtlConvertLongToLargeInteger(-PCMCIA_READY_WAIT_INTERVAL);
        status = KeWaitForSingleObject(&Socket->PCCardReadyEvent,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       &timeout
                                       );
        if (status != STATUS_TIMEOUT) {
            return TRUE;
        }
        return FALSE;
    }
#endif

    for (index = 0; index < PCMCIA_READY_DELAY_ITER; index++) {
        byte = PcicReadSocket(Socket, PCIC_STATUS);
        if (byte & 0x20) {
            break;
        }
        PcmciaWait(PCMCIA_READY_STALL);
    }

    if (index < PCMCIA_READY_DELAY_ITER) {
        DebugPrint((PCMCIA_COUNTERS, "PcicPCCardReady: %d\n", index));
        return TRUE;
    }

    return FALSE;
}



NTSTATUS
PcicIsaDetect(
    IN PFDO_EXTENSION DeviceExtension
    )

/*++

Routine Description:

     Locate any PCMCIA sockets supported by this driver.    This routine
     will find the 82365SL and compatible parts and construct SOCKET
     structures to represent all sockets found

Arguments:

     DeviceExtension - the root for the SocketList.

Return Value:

     STATUS_SUCCESS if a controller is found: also indicates this might be called
                         again to locate another controller

     STATUS_UNSUCCESSFUL  if something failed/no controllers found.

     STATUS_NO_MORE_ENTRIES if no more pcic controllers can be found.
                                    Stop calling this routine.
--*/

{
#define PCMCIA_NUMBER_ISA_PORT_ADDRESSES 3
    static  ULONG isaIndex=0;
    ULONG   index;
    ULONG   ioPortBases[PCMCIA_NUMBER_ISA_PORT_ADDRESSES] = { 0x3e0, 0x3e2, 0x3e4};
    NTSTATUS status=STATUS_NO_MORE_ENTRIES;

    PAGED_CODE();

    DeviceExtension->Configuration.InterfaceType = Isa;
    DeviceExtension->Configuration.BusNumber = 0x0;

    for (index = isaIndex; !NT_SUCCESS(status) && (index < PCMCIA_NUMBER_ISA_PORT_ADDRESSES); index++) {
        status = PcicDetect(DeviceExtension,Isa, ioPortBases[index]);
    }

    //
    // Set index for next search
    //
    isaIndex = index;
    return status;
}



NTSTATUS
PcicDetect(
    IN PFDO_EXTENSION DeviceExtension,
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG            IoPortBase
    )
/*++

Routine Description:

    This routine is used for legacy detecting PCIC-compatible
    PCMCIA controllers.
    This attempts to sniff the standard PCMCIA controller ports
    to check if anything resembling the PCMCIA revisions exists,
    and if so obtain and initialize socket information for the controller.

Arguments:

    DeviceExtension - pointer to the already allocated device extension
                          for the yet-to-be-detected pcmcia controller.

    InterfaceType   - Bus interface type on which the pcmcia
                          controller is expected to reside. Currently
                          we legacy detect only ISA based controllers

    IoPortBase      - IoPort address we need to sniff at for finding
                          the controller

Return value:

    STATUS_SUCCESS    PCMCIA controller was found

    STATUS_UNSUCCESSFUL otherwise

--*/
{
    ULONG   addressSpace;
    NTSTATUS status;
    PUCHAR  port;
    PUCHAR  elcPort;
    PHYSICAL_ADDRESS cardAddress;
    PHYSICAL_ADDRESS portAddress;
    PCM_RESOURCE_LIST cmResourceList = NULL;
    PCM_PARTIAL_RESOURCE_LIST cmPartialResourceList;
    UCHAR   saveBytes[2];
    UCHAR   dataByte;
    UCHAR   revisionByte;
    USHORT  socket;
    UCHAR   socketNumber = 0;
    BOOLEAN translated;
    BOOLEAN mapped = FALSE;
    BOOLEAN conflict = TRUE;
    BOOLEAN resourcesAllocated = FALSE;

    PAGED_CODE();

    portAddress.LowPart = IoPortBase;
    portAddress.u.HighPart = 0;

    //
    // Get the resources used for detection
    //
    cmResourceList = ExAllocatePool(PagedPool, sizeof(CM_RESOURCE_LIST));

    if (!cmResourceList) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    RtlZeroMemory(cmResourceList, sizeof(CM_RESOURCE_LIST));
    cmResourceList->Count = 1;
    cmResourceList->List[0].InterfaceType = Isa;
    cmPartialResourceList = &(cmResourceList->List[0].PartialResourceList);
    cmPartialResourceList->Version  = 1;
    cmPartialResourceList->Revision = 1;
    cmPartialResourceList->Count      = 1;
    cmPartialResourceList->PartialDescriptors[0].Type = CmResourceTypePort;
    cmPartialResourceList->PartialDescriptors[0].ShareDisposition = CmResourceShareDeviceExclusive;
    cmPartialResourceList->PartialDescriptors[0].Flags = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_10_BIT_DECODE;
    cmPartialResourceList->PartialDescriptors[0].u.Port.Start = portAddress;
    cmPartialResourceList->PartialDescriptors[0].u.Port.Length = 2;

    status=IoReportResourceForDetection(
                                        DeviceExtension->DriverObject,
                                        cmResourceList,
                                        sizeof(CM_RESOURCE_LIST),
                                        NULL,
                                        NULL,
                                        0,
                                        &conflict);
    if (!NT_SUCCESS(status) || conflict) {
        goto Exit;
    }
    resourcesAllocated = TRUE;

    addressSpace = 1; // port space
    translated = HalTranslateBusAddress(InterfaceType,
                                        0,
                                        portAddress,
                                        &addressSpace,
                                        &cardAddress);

    if (!translated) {

        //
        // HAL would not translate the address.
        //
        status = STATUS_UNSUCCESSFUL;
        goto Exit;
    }

    if (addressSpace) {
        //
        // I/O port space
        //
        port = (PUCHAR)(cardAddress.QuadPart);
    } else {
        //
        // Memory space.. we need to map this into memory
        //
        port = MmMapIoSpace(cardAddress,
                                  2,
                                  FALSE);
        mapped = TRUE;
    }

    status = STATUS_UNSUCCESSFUL;
    socket = 0;
    dataByte = PcicReadController(port, socket, PCIC_IDENT);
    revisionByte = dataByte;

    switch (dataByte) {
    case PCIC_REVISION:
    case PCIC_REVISION2:
    case PCIC_REVISION3: {
            //
            // The cirrus logic controller will toggle top 2 lines from the chip info
            // register on the chip. Read from thelocation 3 times and verify that the top two
            // lines are changing. We do this for NEC 98 also..
            //
            ULONG i;
            UCHAR data[4];

            WRITE_PORT_UCHAR(port, (UCHAR)(socket + PCIC_CL_CHIP_INFO));
            for (i = 0; i < 3; i++) {
                data[i] = READ_PORT_UCHAR(port+1);
                if (i) {
                    dataByte = data[i - 1] ^ data[i];
                    if (dataByte != 0xc0) {
                        break;
                    }
                }
            }

            if (i == 3) {
                //
                // Ah. this is a cirrus logic controller
                //
                PcmciaSetControllerType(DeviceExtension, PcmciaCLPD6729);
            }

            dataByte = PcicReadController(port, socket, PCIC_CARD_CHANGE);

            if (dataByte & 0xf0) {

                //
                // Not a socket.
                //

                break;
            }

            //
            // Map and try to locate the Compaq Elite controller
            // This code is a rough approximation of the code in
            // the Windows 95 detection module for the PCIC part.
            //

            addressSpace = 1; // port space
            portAddress.LowPart = IoPortBase + 0x8000;
            portAddress.HighPart = 0;

            translated = HalTranslateBusAddress(Isa,
                                                0,
                                                portAddress,
                                                &addressSpace,
                                                &cardAddress);

            if (translated) {

                if (!addressSpace) {
                    elcPort = MmMapIoSpace(cardAddress,
                                           2,
                                           FALSE);
                } else {
                    elcPort = (PUCHAR)(cardAddress.QuadPart);
                }

                //
                // Save current index value.
                //

                saveBytes[0] = READ_PORT_UCHAR(elcPort);
                WRITE_PORT_UCHAR(elcPort, (UCHAR)(socket + PCIC_IDENT));

                //
                // Save data byte for the location that will be used
                // for the test.
                //

                saveBytes[1] = READ_PORT_UCHAR(elcPort + 1);

                //
                // Check for an ELC
                //

                WRITE_PORT_UCHAR(elcPort+1, 0x55);
                WRITE_PORT_UCHAR(elcPort, (UCHAR)(socket + PCIC_IDENT));
                dataByte = READ_PORT_UCHAR(elcPort+1);

                if (dataByte == 0x55) {
                    WRITE_PORT_UCHAR(elcPort, (UCHAR)(socket + PCIC_IDENT));
                    WRITE_PORT_UCHAR(elcPort+1, 0xaa);
                    WRITE_PORT_UCHAR(elcPort, (UCHAR)(socket + PCIC_IDENT));
                    dataByte = READ_PORT_UCHAR(elcPort+1);

                    if (dataByte == 0xaa) {

                        //
                        // ELC found - initialize eaddr registers
                        //

                        WRITE_PORT_UCHAR(elcPort, (UCHAR)(socket + 0));
                        WRITE_PORT_UCHAR(elcPort+1, 0);
                        WRITE_PORT_UCHAR(elcPort, (UCHAR)(socket + 1));
                        WRITE_PORT_UCHAR(elcPort+1, 0);
                        WRITE_PORT_UCHAR(elcPort, (UCHAR)(socket + 2));
                        WRITE_PORT_UCHAR(elcPort+1, 0x10);
                        PcmciaSetControllerType(DeviceExtension, PcmciaElcController);
                    }
                }
                //
                // Restore the original values.
                //

                WRITE_PORT_UCHAR(elcPort, (UCHAR)(socket + PCIC_IDENT));
                WRITE_PORT_UCHAR(elcPort+1, saveBytes[1]);
                WRITE_PORT_UCHAR(elcPort, saveBytes[0]);

                if (!addressSpace) {
                    MmUnmapIoSpace(elcPort, 2);
                }
            }

            DeviceExtension->Configuration.UntranslatedPortAddress = (USHORT)IoPortBase;
            DeviceExtension->Configuration.PortSize = 2;
            DebugPrint((PCMCIA_DEBUG_DETECT, "Port %x Offset %x\n", port, socket));
            status = STATUS_SUCCESS;
            break;
        }
    default: {
            DebugPrint((PCMCIA_DEBUG_DETECT,
                            "controller at (0x%x:0x%x) not found, returns %x\n",
                            portAddress.LowPart, socket, dataByte));
            break;
        }
    }

    Exit:

    if (!NT_SUCCESS(status) && mapped) {
        MmUnmapIoSpace(port, 2);
    }

    //
    // Free up the allocated resources if any
    //
    if (resourcesAllocated) {
        IoReportResourceForDetection(DeviceExtension->DriverObject,
                                     NULL,
                                     0,
                                     NULL,
                                     NULL,
                                     0,
                                     &conflict);
    }
    //
    // Free up allocated memory if any
    //
    if (cmResourceList) {
        ExFreePool(cmResourceList);
    }
    return status;
}



NTSTATUS
PcicBuildSocketList(
    IN PFDO_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    This routine looks out at the registers of the controller to see how
    many sockets there are. For each socket, a SOCKET structure is allocated
    and chained onto the SocketList pointer of the device extension.

Arguments:

    DeviceExtension - pointer to the device extension
                              enumerated PDO
Return value:

    STATUS_SUCCESS    PCMCIA controller was found and socket structures were
                              succesfully initialized

    STATUS_UNSUCCESSFUL otherwise

--*/
{
    ULONG   addressSpace;
    NTSTATUS status;
    PUCHAR  port;
    PSOCKET socketPtr;
    PSOCKET previousSocket;
    UCHAR   dataByte;
    UCHAR   revisionByte;
    USHORT  socket;
    UCHAR   socketNumber = 0;

    PAGED_CODE();

    previousSocket = DeviceExtension->SocketList;
    port = (PUCHAR)DeviceExtension->Configuration.UntranslatedPortAddress;


    status = STATUS_UNSUCCESSFUL;

    for (socket = 0; socket < 0xFF; socket += 0x40) {
        dataByte = PcicReadController(port, socket, PCIC_IDENT);
        revisionByte = dataByte;

        switch (dataByte) {
        case PCIC_REVISION:
        case PCIC_REVISION2:
        case PCIC_REVISION3: {

                dataByte = PcicReadController(port, socket, PCIC_CARD_CHANGE);

                if (dataByte & 0xf0) {

                    //
                    // Not a socket.
                    //

                    continue;
                }

                //
                // Check for IBM 750
                //

                if (socket & 0x80) {
                    ULONG i;
                    UCHAR tmp;

                    //
                    // See if this socket shadows the socket without
                    // the sign bit.
                    //

                    tmp = PcicReadController(port, socket, PCIC_MEM_ADD4_STRT_L);
                    for (i = 0; i < 8; i++) {

                        //
                        // See if memory window 4 is the same on both sockets
                        //

                        if (PcicReadController(port, socket, (UCHAR) (PCIC_MEM_ADD4_STRT_L + i)) !=
                            PcicReadController(port, (USHORT) (socket & 0x7f), (UCHAR) (PCIC_MEM_ADD4_STRT_L + i))) {
                            break;
                        }
                    }

                    if (i == 8) {

                        //
                        // Currently window is the same - change the
                        // window at one of the socket offsets.
                        //

                        PcicWriteController(port, (USHORT) (socket & 0x7f), PCIC_MEM_ADD4_STRT_L, (UCHAR) ~tmp);
                        if (PcicReadController(port, socket, PCIC_MEM_ADD4_STRT_L) == (UCHAR) ~tmp) {

                            //
                            // The sockets are the same.
                            //

                            continue;
                        } else {
                            PcicWriteController(port, (USHORT) (socket & 0x7f), PCIC_MEM_ADD4_STRT_L, tmp);
                        }
                    }
                }


                socketPtr = ExAllocatePool(NonPagedPool, sizeof(SOCKET));
                if (!socketPtr) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
                RtlZeroMemory(socketPtr, sizeof(SOCKET));

                socketPtr->DeviceExtension = DeviceExtension;
                socketPtr->SocketFnPtr = &PcicSupportFns;
                socketPtr->RegisterOffset = socket;
                socketPtr->AddressPort = port;
                socketPtr->Revision = revisionByte;

                socketPtr->SocketNumber = socketNumber++;
                if (previousSocket) {
                    previousSocket->NextSocket = socketPtr;
                } else {
                    DeviceExtension->SocketList = socketPtr;
                }
                previousSocket = socketPtr;
                status = STATUS_SUCCESS;
                break;
            }

        default: {
                break;
            }
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\pcmcia.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    pcmcia.c

Abstract:

    This module contains the code that controls the PCMCIA slots.

Author:

    Bob Rinne (BobRi) 3-Aug-1994
    Jeff McLeman 12-Apr-1994
    Ravisankar Pudipeddi (ravisp) 1-Nov-96
    Neil Sandlin (neilsa) 1-Jun-1999

Environment:

    Kernel mode

Revision History :
    6-Apr-95
          Modified for databook support - John Keys Databook
    1-Nov-96
          Total overhaul to make this a bus enumerator - Ravisankar Pudipeddi (ravisp)


--*/

#include "pch.h"

//
// Internal References
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
PcmciaUnload(
    IN PDRIVER_OBJECT DriverObject
    );

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(INIT,DriverEntry)
    #pragma alloc_text(PAGE, PcmciaUnload)
    #pragma alloc_text(PAGE, PcmciaOpenCloseDispatch)
    #pragma alloc_text(PAGE, PcmciaCleanupDispatch)
    #pragma alloc_text(PAGE, PcmciaFdoSystemControl)
    #pragma alloc_text(PAGE, PcmciaPdoSystemControl)
#endif

PUNICODE_STRING  DriverRegistryPath;



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    The entry point that the system point calls to initialize
    any driver.
    Since this is a plug'n'play driver, we should return after setting
    the entry points & initializing our dispatch table.
    Currently we also detect our own PCMCIA controllers and report
    them - which should not be needed in the future when a root bus
    driver such as PCI or ISAPNP will locate the controllers for us.

Arguments:

    DriverObject - Pointer to object representing this driver

    RegistryPath - Pointer the the registry key for this driver
                        under \CurrentControlSet\Services

Return Value:


--*/

{
    NTSTATUS                      status = STATUS_SUCCESS;
    ULONG                         i;

    PAGED_CODE();

    DebugPrint((PCMCIA_DEBUG_INFO,"Initializing Driver\n"));

    //
    // Load in common parameters from the registry
    //
    status = PcmciaLoadGlobalRegistryValues();
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    //
    // Set up the device driver entry points.
    //

    DriverObject->DriverExtension->AddDevice = PcmciaAddDevice;

    DriverObject->DriverUnload = PcmciaUnload;
    //
    //
    // Save our registry path
    DriverRegistryPath = RegistryPath;

    //
    // Initialize the event used by the delay execution
    // routine.
    //
    KeInitializeEvent(&PcmciaDelayTimerEvent,
                      NotificationEvent,
                      FALSE);

    //
    // Initialize global lock
    //
    KeInitializeSpinLock(&PcmciaGlobalLock);

    //
    // Init device dispatch table
    //
    PcmciaInitDeviceDispatchTable(DriverObject);

    //
    // Locate PCMCIA controllers and report them - this
    // is temporary - till the detection for these
    // controllers is moved into
    // appropriate root bus driver such as the PCI bus driver..

    //   if (PcmciaLegacyDetectionOk()) {
    status = PcmciaDetectPcmciaControllers(DriverObject,RegistryPath);
    // }

    //
    // Ignore the status. Regardless of whether we found controllers or not
    // we need to stick around since we might get an AddDevice non-legacy
    // controllers
    //
    return STATUS_SUCCESS;
}



NTSTATUS
PcmciaOpenCloseDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

     Open or Close device routine

Arguments:

     DeviceObject - Pointer to the device object.
     Irp - Pointer to the IRP

Return Value:

     Status

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    DebugPrint((PCMCIA_DEBUG_INFO, "PCMCIA: Open / close of Pcmcia controller for IO \n"));

    status = STATUS_SUCCESS;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, 0);
    return status;
}



NTSTATUS
PcmciaCleanupDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

     Handles IRP_MJ_CLEANUP

Arguments:

     DeviceObject - Pointer to the device object.
     Irp - Pointer to the IRP

Return Value:

     Status

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    DebugPrint((PCMCIA_DEBUG_INFO, "PCMCIA: Cleanup of Pcmcia controller for IO \n"));
    status = STATUS_SUCCESS;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, 0);
    return status;
}



NTSTATUS
PcmciaFdoSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

     Handles IRP_MJ_SYSTEM_CONTROL

Arguments:

     DeviceObject - Pointer to the device object.
     Irp - Pointer to the IRP

Return Value:

     Status

--*/

{
    PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(fdoExtension->LowerDevice, Irp);
}



NTSTATUS
PcmciaPdoSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

     Handles IRP_MJ_SYSTEM_CONTROL

Arguments:

     DeviceObject - Pointer to the device object.
     Irp - Pointer to the IRP

Return Value:

     Status

--*/

{
    NTSTATUS status;
    PPDO_EXTENSION pdoExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    if (IsCardBusCard(pdoExtension)) {
        //
        // Pass irp down the stack for cardbus cards
        //
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(pdoExtension->LowerDevice, Irp);
    } else {
        //
        // Complete the irp for R2 cards
        //
        status = Irp->IoStatus.Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    return status;
}



VOID
PcmciaUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Description:

     Unloads the driver after cleaning up

Arguments:

     DriverObject -- THe device drivers object

Return Value:

     None

--*/

{
    PDEVICE_OBJECT  fdo, pdo, nextFdo, nextPdo;
    PFDO_EXTENSION  fdoExtension;
    PSOCKET             socket, nextSocket;
    PPCMCIA_NTDETECT_DATA pData, pNextData;

    PAGED_CODE();

    DebugPrint((PCMCIA_DEBUG_INFO, "PcmciaUnload Entered\n"));

    pData = pNtDetectDataList;
    while(pData != NULL) {
        pNextData = pData->Next;
        ExFreePool(pData);
        pData = pNextData;
    }

    for (fdo = FdoList; fdo !=NULL ; fdo = nextFdo) {

        fdoExtension = fdo->DeviceExtension;
        MarkDeviceDeleted(fdoExtension);

        if (fdoExtension->PcmciaInterruptObject) {
            IoDisconnectInterrupt(fdoExtension->PcmciaInterruptObject);
        }
        //
        // Cleanup socket structures
        //
        for (socket=fdoExtension->SocketList; socket !=NULL; socket=nextSocket) {
            nextSocket = socket->NextSocket;
            ExFreePool(socket);
        }

        //
        // Remove symbolic links
        //
        if (fdoExtension->LinkName.Buffer != NULL) {
            IoDeleteSymbolicLink(&fdoExtension->LinkName);
            RtlFreeUnicodeString(&fdoExtension->LinkName);
        }
        //
        // Clean up all the PDOs
        //
        for (pdo=fdoExtension->PdoList; pdo != NULL; pdo=nextPdo) {
            nextPdo = ((PPDO_EXTENSION) pdo->DeviceExtension)->NextPdoInFdoChain;
            MarkDeviceDeleted((PPDO_EXTENSION)pdo->DeviceExtension);
            PcmciaCleanupPdo(pdo);
            IoDeleteDevice(pdo);
        }

        if (fdoExtension->Flags & PCMCIA_USE_POLLED_CSC) {
                //
                // Cancel the poll timer
                //
                KeCancelTimer(&fdoExtension->PollTimer);
        }

        IoDetachDevice(fdoExtension->LowerDevice);
        nextFdo = fdoExtension->NextFdo;
        IoDeleteDevice(fdo);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\pdopnp.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    pdopnp.c

Abstract:

    This module contains the code to handle
    the IRP_MJ_PNP dispatches for the PDOs
    enumerated by the PCMCIA bus driver


Authors:

    Ravisankar Pudipeddi (ravisp)
    Neil Sandlin (neilsa) 1-Jun-1999

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#include "pch.h"

//
// Internal References
//

NTSTATUS
PcmciaFilterPcCardResourceRequirements(
    IN  PPDO_EXTENSION DeviceExtension,
    IN  PIRP             Irp
    );

NTSTATUS
PcmciaFilterPcCardInterrupts(
    IN  PIO_RESOURCE_REQUIREMENTS_LIST   oldReqList,
    IN  ULONG IrqCount,
    IN  ULONG IrqMask,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST * FilteredReqList,
    BOOLEAN RouteIsaToPci
    );

VOID
PcmciaCleanupSocketData(
    IN PSOCKET_DATA SocketData
    );

VOID
PcmciaCleanupSocketConfiguration(
    PPDO_EXTENSION pdoExtension
    );

NTSTATUS
PcmciaPdoDeviceCapabilities(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP             Irp
    );

NTSTATUS
PcmciaGetPcCardResourceRequirements(
    IN PPDO_EXTENSION PdoExtension,
    PULONG_PTR          Information
    );

NTSTATUS
PcmciaConfigEntriesToResourceListChain(
    PPDO_EXTENSION pdoExtension,
    PCONFIG_LIST ConfigList,
    ULONG configCount,
    PPCMCIA_RESOURCE_CHAIN *ResListChainHead
    );

NTSTATUS
PcmciaMergeResourceChainToList(
    PPCMCIA_RESOURCE_CHAIN ResListChain,
    PIO_RESOURCE_REQUIREMENTS_LIST *GeneratedResourceRequirementsList
    );

VOID
PcmciaFreeResourceChain(
    PPCMCIA_RESOURCE_CHAIN ResListChain
    );

NTSTATUS
PcmciaStartPcCard(
    IN PDEVICE_OBJECT Pdo,
    IN PCM_RESOURCE_LIST AllocatedResources,
    IN OUT PIRP         Irp
    );

NTSTATUS
PcmciaStopPcCard(
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
PcmciaRemovePcCard(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP             Irp
    );

NTSTATUS
PcmciaMfEnumerateConfigurations(
    IN PPDO_EXTENSION PdoExtension,
    IN PSOCKET_DATA socketData,
    PCONFIG_LIST        ConfigList,
    IN ULONG            Depth,
    PPCMCIA_RESOURCE_CHAIN *MfResListChain
    );

NTSTATUS
PcmciaMfGetResourceRequirements(
    IN PPDO_EXTENSION PdoExtension,
    PULONG_PTR          Information
    );

VOID
PcmciaMfBuildResourceMapInfo(
    IN PPDO_EXTENSION PdoExtension,
    PCONFIG_LIST        ConfigList,
    ULONG               ConfigCount
    );

BOOLEAN
PcmciaMfCheckForOverlappingRanges(
    PCONFIG_LIST ConfigList,
    LONG ConfigCount
    );

NTSTATUS
PcmciaPdoGetBusInformation(
    IN  PPDO_EXTENSION          PdoExtension,
    OUT PPNP_BUS_INFORMATION * BusInformation
    );

NTSTATUS
PcmciaQueryDeviceText(
    IN PDEVICE_OBJECT Pdo,
    IN OUT PIRP         Irp
    );

VOID
PcmciaPdoGetDeviceInfSettings(
    IN  PPDO_EXTENSION          PdoExtension
    );

VOID
PcmciaPdoSetDeviceIrqRouting(
    IN  PPDO_EXTENSION PdoExtension
    );

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE,  PcmciaPdoPnpDispatch)
    #pragma alloc_text(PAGE,  PcmciaPdoGetDeviceInfSettings)
    #pragma alloc_text(PAGE,  PcmciaPdoSetDeviceIrqRouting)
    #pragma alloc_text(PAGE,  PcmciaFilterPcCardInterrupts)
    #pragma alloc_text(PAGE,  PcmciaFilterPcCardResourceRequirements)
    #pragma alloc_text(PAGE,  PcmciaQueryDeviceText)
    #pragma alloc_text(PAGE,  PcmciaGetPcCardResourceRequirements)
    #pragma alloc_text(PAGE,  PcmciaConfigEntriesToResourceListChain)
    #pragma alloc_text(PAGE,  PcmciaMergeResourceChainToList)
    #pragma alloc_text(PAGE,  PcmciaFreeResourceChain)
    #pragma alloc_text(PAGE,  PcmciaPdoGetBusInformation)
    #pragma alloc_text(PAGE,  PcmciaStartPcCard)
    #pragma alloc_text(PAGE,  PcmciaStopPcCard)
    #pragma alloc_text(PAGE,  PcmciaRemovePcCard)
    #pragma alloc_text(PAGE,  PcmciaPdoDeviceCapabilities)
    #pragma alloc_text(PAGE,  PcmciaPdoDeviceControl)
    #pragma alloc_text(PAGE,  PcmciaPdoGetDeviceInfSettings)
    #pragma alloc_text(PAGE,  PcmciaMfGetResourceRequirements)
    #pragma alloc_text(PAGE,  PcmciaMfEnumerateConfigurations)
    #pragma alloc_text(PAGE,  PcmciaMfBuildResourceMapInfo)
    #pragma alloc_text(PAGE,  PcmciaMfCheckForOverlappingRanges)
#endif



NTSTATUS
PcmciaPdoPnpDispatch(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    )

/*++

Routine Description:

     This routine handles pnp requests
     for the PDOs.

Arguments:

     Pdo - pointer to the physical device object
     Irp - pointer to the io request packet

Return Value:

     status

--*/

{
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;

    PAGED_CODE();

    //
    // CardBus PnP Dispatch
    //

    if (IsCardBusCard(pdoExtension)) {              //
        return PcmciaPdoCardBusPnPDispatch(Pdo, Irp);
    }

#if DBG
    if (irpStack->MinorFunction > IRP_MN_PNP_MAXIMUM_FUNCTION) {
        DebugPrint((PCMCIA_DEBUG_PNP, "pdo %08x irp %08x Unknown minor function %x\n",
                                                 Pdo, Irp, irpStack->MinorFunction));
    } else {
        DebugPrint((PCMCIA_DEBUG_PNP, "pdo %08x irp %08x --> %s\n",
                          Pdo, Irp, PNP_IRP_STRING(irpStack->MinorFunction)));
    }
#endif

    //
    // 16-bit (R2) PcCard PnP Dispatch
    //
    switch (irpStack->MinorFunction) {

    case IRP_MN_START_DEVICE: {
            status = PcmciaStartPcCard(Pdo, irpStack->Parameters.StartDevice.AllocatedResources, Irp);
            break;
        }

    case IRP_MN_QUERY_STOP_DEVICE:{
            status = STATUS_SUCCESS;
            break;
        }

    case IRP_MN_CANCEL_STOP_DEVICE:{
            status = STATUS_SUCCESS;
            break;
        }

    case IRP_MN_STOP_DEVICE: {
            status = PcmciaStopPcCard(Pdo);
            break;
        }

    case IRP_MN_QUERY_REMOVE_DEVICE:{
            status = STATUS_SUCCESS;
            break;
        }

    case IRP_MN_CANCEL_REMOVE_DEVICE:{
            status = STATUS_SUCCESS;
            break;
        }

    case IRP_MN_REMOVE_DEVICE: {
            status = PcmciaRemovePcCard(Pdo, Irp);
            break;
        }

    case IRP_MN_SURPRISE_REMOVAL: {

            PcmciaReleaseSocketPower(pdoExtension, NULL);
            status = STATUS_SUCCESS;
            break;
        }

    case IRP_MN_QUERY_ID: {

            UNICODE_STRING unicodeId;

            status = Irp->IoStatus.Status;
            RtlInitUnicodeString(&unicodeId, NULL);

            switch (irpStack->Parameters.QueryId.IdType) {

            case BusQueryDeviceID: {
                    DebugPrint((PCMCIA_DEBUG_INFO, " Device Id for pdo %x\n", Pdo));
                    status = PcmciaGetDeviceId(Pdo, PCMCIA_MULTIFUNCTION_PARENT, &unicodeId);
                    if (NT_SUCCESS(status)) {
                        Irp->IoStatus.Information = (ULONG_PTR) unicodeId.Buffer;
                    }
                    break;
                }

            case BusQueryInstanceID: {
                    DebugPrint((PCMCIA_DEBUG_INFO, " Instance Id for pdo %x\n", Pdo));
                    status = PcmciaGetInstanceId(Pdo, &unicodeId);
                    if (NT_SUCCESS(status)) {
                        Irp->IoStatus.Information = (ULONG_PTR) unicodeId.Buffer;
                    }
                    break;
                }

            case BusQueryHardwareIDs: {
                    DebugPrint((PCMCIA_DEBUG_INFO, " Hardware Ids for pdo %x\n", Pdo));
                    status = PcmciaGetHardwareIds(Pdo, PCMCIA_MULTIFUNCTION_PARENT, &unicodeId);
                    if (NT_SUCCESS(status)) {
                        Irp->IoStatus.Information = (ULONG_PTR) unicodeId.Buffer;
                    }
                    break;
                }

            case BusQueryCompatibleIDs: {
                    DebugPrint((PCMCIA_DEBUG_INFO, " Compatible Ids for pdo %x\n", Pdo));
                    status = PcmciaGetCompatibleIds( Pdo, PCMCIA_MULTIFUNCTION_PARENT, &unicodeId);
                    if (NT_SUCCESS(status)) {
                        Irp->IoStatus.Information = (ULONG_PTR) unicodeId.Buffer;
                    }
                    break;
                }
            }
            break;
        }


    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS: {
            //
            // PcmciaGetPcCardResourceRequirements will
            // allocate storage for the resource requirements which will be released
            // by the OS.
            //
            Irp->IoStatus.Information = 0;

            PcmciaPdoGetDeviceInfSettings(pdoExtension);

            //
            // We deferred filtering bad tuple configurations until now so that we could
            // see if the device had specific filtering requirements specified in the INF.
            //
            PcmciaFilterTupleData(pdoExtension);

            PcmciaPdoSetDeviceIrqRouting(pdoExtension);

            if (IsDeviceMultifunction(pdoExtension)) {
                status = PcmciaMfGetResourceRequirements(pdoExtension,
                                                                      &Irp->IoStatus.Information);
            } else {
                status = PcmciaGetPcCardResourceRequirements(pdoExtension,
                                                                      &Irp->IoStatus.Information);
            }
            break;
        }

    case IRP_MN_WRITE_CONFIG:
    case IRP_MN_READ_CONFIG: {
            PFDO_EXTENSION fdoExtension= pdoExtension->Socket->DeviceExtension;
            ULONG whichSpace;
            PVOID buffer;
            ULONG offset;
            ULONG length;

            whichSpace = irpStack->Parameters.ReadWriteConfig.WhichSpace;
            buffer    = irpStack->Parameters.ReadWriteConfig.Buffer;
            offset    = irpStack->Parameters.ReadWriteConfig.Offset;
            length    = irpStack->Parameters.ReadWriteConfig.Length;

            if (irpStack->MinorFunction == IRP_MN_READ_CONFIG) {
                status = PcmciaReadWriteCardMemory(Pdo,
                                                   whichSpace,
                                                   buffer,
                                                   offset,
                                                   length,
                                                   TRUE);
            } else {
                status = PcmciaReadWriteCardMemory(Pdo,
                                                   whichSpace,
                                                   buffer,
                                                   offset,
                                                   length,
                                                   FALSE);
            }
            break;
        }

    case IRP_MN_QUERY_DEVICE_RELATIONS: {

            PDEVICE_RELATIONS deviceRelations;

            if (irpStack->Parameters.QueryDeviceRelations.Type != TargetDeviceRelation) {
                status = Irp->IoStatus.Status;
                break;
            }

            deviceRelations = ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));
            if (deviceRelations == NULL) {

                DebugPrint((PCMCIA_DEBUG_FAIL,
                                "PcmciaPdoPnpDispatch:unable to allocate memory for device relations\n"));

                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            status = ObReferenceObjectByPointer(Pdo,
                                                0,
                                                NULL,
                                                KernelMode);
            if (!NT_SUCCESS(status)) {
                ExFreePool(deviceRelations);
                break;
            }

            deviceRelations->Count  = 1;
            deviceRelations->Objects[0] = Pdo;
            Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
            status = STATUS_SUCCESS;
            break;
        }

    case IRP_MN_QUERY_CAPABILITIES: {
            status = PcmciaPdoDeviceCapabilities(Pdo, Irp);
            break;
        }

    case IRP_MN_QUERY_INTERFACE: {
            status = PcmciaPdoQueryInterface(Pdo, Irp);
            //
            // QueryInterface completes the passed in Irp.
            // So just return immediately.
            //
            return status;
        }

    case IRP_MN_QUERY_DEVICE_TEXT: {

            status = PcmciaQueryDeviceText(Pdo, Irp);

            if (status == STATUS_NOT_SUPPORTED ) {
                //
                // Do not change IRP status if this IRP is
                // not handled
                //
                status = Irp->IoStatus.Status;
            }
            break;
        }

    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS: {
            status = PcmciaFilterPcCardResourceRequirements(pdoExtension, Irp);
            break;
        }

    case IRP_MN_QUERY_BUS_INFORMATION: {
            status = PcmciaPdoGetBusInformation(pdoExtension,
                                                (PPNP_BUS_INFORMATION *) &Irp->IoStatus.Information);
            break;
    }

    default: {
            //
            // Retain the status
            //
            DebugPrint((PCMCIA_DEBUG_PNP, "pdo %08x irp %08x Skipping unsupported irp\n", Pdo, Irp));
            status = Irp->IoStatus.Status;
            break;
        }
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    DebugPrint((PCMCIA_DEBUG_PNP, "pdo %08x irp %08x comp %s %08x\n", Pdo, Irp,
                                               STATUS_STRING(status), status));
    return status;
}


NTSTATUS
PcmciaPdoGetBusInformation(
    IN  PPDO_EXTENSION          PdoExtension,
    OUT PPNP_BUS_INFORMATION * BusInformation
    )

/*++

Routine Description:

  Returns the   bus type information for the pc-card.
  Bus type is GUID_BUS_TYPE_PCMCIA(legacy type is PcmciaBus) for R2 cards
  Bus numbers are not implemented for PCMCIA, so it's always 0

Arguments:

  PdoExtension   - pointer to device extension for the pc-card

  BusInformation - pointer to the bus information structure that
                         needs to be filled in

Return value:

  Status

--*/

{

    PAGED_CODE();

    *BusInformation = ExAllocatePool(PagedPool, sizeof (PNP_BUS_INFORMATION));
    if (!*BusInformation) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(&((*BusInformation)->BusTypeGuid),
                  &GUID_BUS_TYPE_PCMCIA,
                  sizeof(GUID));
    (*BusInformation)->LegacyBusType = PCMCIABus;
    (*BusInformation)->BusNumber = 0;

    return STATUS_SUCCESS;
}


VOID
PcmciaPdoGetDeviceInfSettings(
    IN  PPDO_EXTENSION PdoExtension
    )
/*++

Routine Description:

    This routine retrieves settings from the INF for this device.

Arguments:

    DeviceExtension - Device extension of the Pc-Card

Return value:

    None

--*/
{
    NTSTATUS status;
    PSOCKET socket = PdoExtension->Socket;
    UNICODE_STRING KeyName;
    HANDLE instanceHandle;
    UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
    PKEY_VALUE_PARTIAL_INFORMATION value = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
    ULONG length;

    PAGED_CODE();

    status = IoOpenDeviceRegistryKey(PdoExtension->DeviceObject,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     KEY_READ,
                                     &instanceHandle
                                     );

    if (NT_SUCCESS(status)) {

        //
        // Look to see if PcmciaExclusiveIrq is specified
        //
        RtlInitUnicodeString(&KeyName, L"PcmciaExclusiveIrq");

        status =  ZwQueryValueKey(instanceHandle,
                                          &KeyName,
                                          KeyValuePartialInformation,
                                          value,
                                          sizeof(buffer),
                                          &length);


        //
        // If the key doesn't exist, or zero was specified, it means that
        // routing is ok
        //
        if (NT_SUCCESS(status) && (*(PULONG)(value->Data) != 0)) {
            SetDeviceFlag(PdoExtension, PCMCIA_PDO_EXCLUSIVE_IRQ);
        }

        //
        // Look to see if PcmciaAutoPowerOff is specified
        //
        RtlInitUnicodeString(&KeyName, L"PcmciaAutoPowerOff");

        status =  ZwQueryValueKey(instanceHandle,
                                          &KeyName,
                                          KeyValuePartialInformation,
                                          value,
                                          sizeof(buffer),
                                          &length);


        //
        // If zero was specified, then don't automatically cut power on shutdown
        //
        if (NT_SUCCESS(status) && (*(PULONG)(value->Data) == 0)) {
            SetDeviceFlag(socket->DeviceExtension, PCMCIA_FDO_DISABLE_AUTO_POWEROFF);
        }

        //
        // Look to see if PcmciaEnableAudio is specified
        //
        RtlInitUnicodeString(&KeyName, L"PcmciaEnableAudio");

        status =  ZwQueryValueKey(instanceHandle,
                                          &KeyName,
                                          KeyValuePartialInformation,
                                          value,
                                          sizeof(buffer),
                                          &length);


        if (NT_SUCCESS(status) && (*(PULONG)(value->Data) != 0)) {
            SetDeviceFlag(PdoExtension, PCMCIA_PDO_ENABLE_AUDIO);
        }

        //
        // Look to see if PcmciaDeviceType is specified
        // This was added to ensure that sram cards which don't specify
        // a device type could still use the pcmcia bus interface.
        //
        RtlInitUnicodeString(&KeyName, L"PcmciaDeviceType");

        status =  ZwQueryValueKey(instanceHandle,
                                          &KeyName,
                                          KeyValuePartialInformation,
                                          value,
                                          sizeof(buffer),
                                          &length);


        if (NT_SUCCESS(status)) {
            PdoExtension->SpecifiedDeviceType = (UCHAR) *(PULONG)(value->Data);
        }

        ZwClose(instanceHandle);
    }

    status = IoOpenDeviceRegistryKey(PdoExtension->DeviceObject,
                                                PLUGPLAY_REGKEY_DEVICE,
                                                KEY_READ,
                                                &instanceHandle
                                                );


    if (NT_SUCCESS(status)) {

        //
        // Look for "WakeOnRing", "WakeOnLan"
        //
        RtlInitUnicodeString(&KeyName, L"WakeOnRing");

        status =  ZwQueryValueKey(instanceHandle,
                                          &KeyName,
                                          KeyValuePartialInformation,
                                          value,
                                          sizeof(buffer),
                                          &length);


        if (NT_SUCCESS(status) && (*(PULONG)(value->Data) != 0)) {
            SetPdoFlag(PdoExtension, PCMCIA_PDO_SUPPORTS_WAKE);
        }

        RtlInitUnicodeString(&KeyName, L"WakeOnLan");

        status =  ZwQueryValueKey(instanceHandle,
                                          &KeyName,
                                          KeyValuePartialInformation,
                                          value,
                                          sizeof(buffer),
                                          &length);


        if (NT_SUCCESS(status) && (*(PULONG)(value->Data) != 0)) {
            SetPdoFlag(PdoExtension, PCMCIA_PDO_SUPPORTS_WAKE);
        }
        ZwClose(instanceHandle);
    }
}



VOID
PcmciaPdoSetDeviceIrqRouting(
    IN  PPDO_EXTENSION PdoExtension
    )
/*++

Routine Description:

    This routine retrieves settings from the INF for this device.

Notes:

    PcmciaExclusiveIrq in the INF determines how the IRQ for the R2 card will be routed.
    Currently, the following logic is used:

        if (routing disabled)
          choose either detected or legacy
        else
          if !detected, use FdoIrq

    So, if routing to PCI at all, then only the PCI IRQ will show up in the IoResList.
    BUT: Another approach would be to use the following logic:

        if (routing disabled)
            choose either detected or legacy
        else
            *merge detected with FdoIrq*

    This way we may end up using an exclusive IRQ or routing to PCI, depending on what
    the arbiter has decided. That is the reason why I kept both Detected and Legacy around
    in the FdoExtension, because otherwise it would have made more sense just to choose
    and merge them back when they were generated.

Arguments:

    DeviceExtension - Device extension of the Pc-Card

Return value:

    None (SOCKET structure is updated)

--*/
{
    NTSTATUS status;
    PSOCKET socket = PdoExtension->Socket;
    PFDO_EXTENSION fdoExtension = socket->DeviceExtension;

    PAGED_CODE();

    ResetSocketFlag(socket, SOCKET_CB_ROUTE_R2_TO_PCI);

    //
    // First check the conditions that specify we definitely don't want to route to PCI
    //

    if (!pcmciaDisableIsaPciRouting &&
        CardBusExtension(fdoExtension) &&
        !IsDeviceFlagSet(PdoExtension, PCMCIA_PDO_EXCLUSIVE_IRQ)) {

        //
        // Here we know we *could* route to PCI, now determine if we *should*. This takes
        // into account several registry settings, as well as the result from the NtDetect
        // IRQ detection algorithm.
        //


        //
        // First check to see if there was an override with specifically targeted this
        // controller. This will take precedence.
        //
        if (IsFdoFlagSet(fdoExtension, PCMCIA_FDO_FORCE_PCI_ROUTING)) {
            SetSocketFlag(socket, SOCKET_CB_ROUTE_R2_TO_PCI);
        }
        else if (IsFdoFlagSet(fdoExtension, PCMCIA_FDO_FORCE_ISA_ROUTING)) {
            ResetSocketFlag(socket, SOCKET_CB_ROUTE_R2_TO_PCI);
        }

        //
        // Now check to see if the detection algorithm succeeded. We should honor this result,
        // particularly if the map was zero, which tells us there are no ISA IRQs attached.
        //
        else if (IsFdoFlagSet(fdoExtension, PCMCIA_FDO_IRQ_DETECT_COMPLETED)) {
            if (fdoExtension->DetectedIrqMask == 0) {
                SetSocketFlag(socket, SOCKET_CB_ROUTE_R2_TO_PCI);
            }
        }


        //
        // Now see if there was a general override based on this controller type. This has
        // less precedence than the detection algorithm.
        //
        else if (IsFdoFlagSet(fdoExtension, PCMCIA_FDO_PREFER_PCI_ROUTING)) {
            SetSocketFlag(socket, SOCKET_CB_ROUTE_R2_TO_PCI);
        }
        else if (IsFdoFlagSet(fdoExtension, PCMCIA_FDO_PREFER_ISA_ROUTING)) {
            ResetSocketFlag(socket, SOCKET_CB_ROUTE_R2_TO_PCI);
        }


        //
        // Here look to see if the device was found, but the irq detection failed for some
        // reason. With no special registry overrides, we fall back on the global default.
        //
        else if (IsFdoFlagSet(fdoExtension, PCMCIA_FDO_IRQ_DETECT_DEVICE_FOUND)) {
            if (!(PcmciaGlobalFlags & PCMCIA_DEFAULT_ROUTE_R2_TO_ISA)) {
                SetSocketFlag(socket, SOCKET_CB_ROUTE_R2_TO_PCI);
            }
        }


        //
        // Here ntdetect never saw the device. Maybe we just hot-docked.
        // We will base our decision on if it was in ACPI namespace or not. If it
        // isn't in ACPI namespace, then it probably is not connected to ISA
        //
        else {
            if (!IsFdoFlagSet(fdoExtension, PCMCIA_FDO_IN_ACPI_NAMESPACE)) {
                SetSocketFlag(socket, SOCKET_CB_ROUTE_R2_TO_PCI);
            }
        }

    }

    socket->IrqMask = fdoExtension->DetectedIrqMask ? fdoExtension->DetectedIrqMask : fdoExtension->LegacyIrqMask;

    DebugPrint((PCMCIA_DEBUG_RESOURCES, "pdo %08x IRQ routing=%s, IRQMask=%08x\n", PdoExtension->DeviceObject,
                                                             IsSocketFlagSet(socket, SOCKET_CB_ROUTE_R2_TO_PCI) ? "PCI" : "ISA",
                                                             socket->IrqMask));
}



NTSTATUS
PcmciaFilterPcCardInterrupts(
    IN  PIO_RESOURCE_REQUIREMENTS_LIST   oldReqList,
    IN  ULONG IrqCount,
    IN  ULONG IrqMask,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST * FilteredReqList,
    BOOLEAN RouteIsaToPci
    )
/*++

Routine Description:

     Filters the interrupt resource requirements for R2 Pc-Cards

Arguments:

     oldReqList       - Original, 'raw' resource requirements list
     IrqCount         - # of irq's that will be deleted (already computed by caller)
     IrqMask          - bit mask which indicates which interrupts are valid
     FilteredReqList - pointer to the filtered  requirements list which
                             will be filled in by this routine

Return value:

     Status

--*/
{
    PIO_RESOURCE_REQUIREMENTS_LIST  newReqList;
    PIO_RESOURCE_LIST                 oldList, newList;
    ULONG                                 newReqSize;
    ULONG                                 oldlistSize, newlistSize;
    ULONG                                 index, oldIndex, newIndex;
    BOOLEAN                               irqAlternative;

    PAGED_CODE();
    //
    // Compute the size of the structure with the offending IRQs removed.
    //
    newReqSize = oldReqList->ListSize - IrqCount*sizeof(IO_RESOURCE_DESCRIPTOR);

    newReqList = ExAllocatePool(PagedPool, newReqSize);

    if (newReqList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(newReqList, oldReqList, FIELD_OFFSET(IO_RESOURCE_REQUIREMENTS_LIST, List));
    newReqList->ListSize = newReqSize;

    newList = newReqList->List;
    oldList = oldReqList->List;

    //
    // Loop through each alternative list
    //
    for (index = 0; index < oldReqList->AlternativeLists; index++) {
        newList->Version = oldList->Version;
        newList->Revision = oldList->Revision;

        irqAlternative = FALSE;
        //
        // Loop through each descriptor in the old list
        //
        for (oldIndex = 0, newIndex = 0; oldIndex < oldList->Count; oldIndex++) {

            if (oldList->Descriptors[oldIndex].Type == CmResourceTypeInterrupt) {

                if (RouteIsaToPci) {

                    if (!irqAlternative) {
                        //
                        // First interrupt found, this will be the one we use to route
                        //
                        newList->Descriptors[newIndex++] = oldList->Descriptors[oldIndex];
                        irqAlternative = TRUE;
                    }

                } else {
                    //
                    // Normal case (not routed). Filter out irqs that aren't in our mask
                    //
                    if ((IrqMask & (1<<oldList->Descriptors[oldIndex].u.Interrupt.MinimumVector)) != 0) {
                        //
                        // Not a bad interrupt descriptor. Copy the old to the new
                        //
                        newList->Descriptors[newIndex] = oldList->Descriptors[oldIndex];

                        if (newList->Descriptors[newIndex].Type == CmResourceTypeInterrupt) {
                            if (irqAlternative) {
                                newList->Descriptors[newIndex].Option = IO_RESOURCE_ALTERNATIVE;
                            } else {
                                irqAlternative = TRUE;
                                newList->Descriptors[newIndex].Option = 0;
                            }
                        }
                        newIndex++;
                    }
                }
            } else {
                //
                // Not an interrupt descriptor. Copy the old to the new
                //
                newList->Descriptors[newIndex++] = oldList->Descriptors[oldIndex];
            }
        }
        newList->Count = newIndex;
        oldlistSize = sizeof(IO_RESOURCE_LIST) + (oldList->Count-1) * sizeof(IO_RESOURCE_DESCRIPTOR);
        newlistSize = sizeof(IO_RESOURCE_LIST) + (newList->Count-1) * sizeof(IO_RESOURCE_DESCRIPTOR);
        oldList = (PIO_RESOURCE_LIST) (((PUCHAR) oldList) + oldlistSize);
        newList = (PIO_RESOURCE_LIST) (((PUCHAR) newList) + newlistSize);
    }

    *FilteredReqList = newReqList;
    return STATUS_SUCCESS;
}



NTSTATUS
PcmciaFilterPcCardResourceRequirements(
    IN PPDO_EXTENSION DeviceExtension,
    IN PIRP             Irp
    )

/*++

Routine Description:

     Filters the resource requirements for R2 Pc-Cards

Arguments:

     DeviceExtension - Device extension of the Pc-Card

Return value:

     Status

--*/
{
    PIO_RESOURCE_REQUIREMENTS_LIST IoReqList;
    PIO_RESOURCE_REQUIREMENTS_LIST newReqList;
    PIO_RESOURCE_LIST   ioResourceList;
    PIO_RESOURCE_DESCRIPTOR ioResourceDesc;
    PSOCKET               socket;
    PFDO_EXTENSION    fdoExtension;
    ULONG                 index1, index2, len;
    ULONGLONG             low, high;
    ULONG                 IrqsToDeleteCount = 0;
    NTSTATUS              status = STATUS_SUCCESS;
    BOOLEAN               RouteIrqFound;

    PAGED_CODE();

    IoReqList = (PIO_RESOURCE_REQUIREMENTS_LIST) Irp->IoStatus.Information;

    if (IoReqList == NULL) {
        return STATUS_SUCCESS;
    }

    socket = DeviceExtension->Socket;
    fdoExtension = socket->DeviceExtension;

    for (index1 = 0, ioResourceList = IoReqList->List;
         index1 < IoReqList->AlternativeLists; index1++) {
        ioResourceDesc = ioResourceList->Descriptors;

        RouteIrqFound = FALSE;

        for (index2 = 0 ; index2 < ioResourceList->Count; index2++, ioResourceDesc++) {
            if (ioResourceDesc->Type == CmResourceTypeInterrupt) {

                if (IsSocketFlagSet(socket, SOCKET_CB_ROUTE_R2_TO_PCI)) {

                    //
                    // make sure there is space for just 1 level interrupt requirement
                    //
                    if (!RouteIrqFound) {
                        RouteIrqFound = TRUE;
                        ioResourceDesc->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
                        ioResourceDesc->Option = 0;
                        ioResourceDesc->ShareDisposition = CmResourceShareShared;
                        ioResourceDesc->u.Interrupt.MinimumVector = socket->FdoIrq;
                        ioResourceDesc->u.Interrupt.MaximumVector = socket->FdoIrq;

                    } else {
                        //
                        // Don't need any other IRQs in this list
                        //
                        IrqsToDeleteCount++;
                    }

                } else {
                    ASSERT (ioResourceDesc->u.Interrupt.MinimumVector == ioResourceDesc->u.Interrupt.MaximumVector);
                    //
                    // Look to see if there are IRQ's specified in this IoResList which are
                    // not in our mask. If so, we are going to have to create a new IoResList.
                    // Keep track of how many

                    if (!(socket->IrqMask & (1<<ioResourceDesc->u.Interrupt.MinimumVector))) {
                        IrqsToDeleteCount++;
                    }
                }

            } else if (ioResourceDesc->Type == CmResourceTypeMemory) {

                //
                // pccard hardware can't handle > 32bit addressing
                //
                ASSERT(ioResourceDesc->u.Memory.MinimumAddress.HighPart == 0);
                ioResourceDesc->u.Memory.MaximumAddress.HighPart = 0;

                if (fdoExtension->Flags & PCMCIA_MEMORY_24BIT) {

                    ASSERT((ioResourceDesc->u.Memory.MinimumAddress.LowPart & 0xFF000000) == 0);
                    ioResourceDesc->u.Memory.MaximumAddress.LowPart &= 0xFFFFFF;

                }

                //
                // win2k had a bug where o2micro controllers were marked as 24bit. When
                // that was fixed, an o2micro smart card device with an INF bug suddenly
                // stopped working (because the first bug masked the second). This code
                // fixes their INF.
                //
                if ((ioResourceDesc->Flags & CM_RESOURCE_MEMORY_24) &&
                     (ioResourceDesc->u.Memory.MinimumAddress.LowPart > 0xFFFFFF) &&
                     (PcmciaClassFromControllerType(fdoExtension->ControllerType) == PcmciaO2Micro)) {

                    ioResourceDesc->u.Memory.MinimumAddress.LowPart &= 0xFFFFFF;
                }
            }
        }

        ioResourceList = (PIO_RESOURCE_LIST) (((PUCHAR) ioResourceList) +
                                                          sizeof(IO_RESOURCE_LIST) +
                                                          (ioResourceList->Count - 1)* sizeof(IO_RESOURCE_DESCRIPTOR));
    } // outer for loop

    if (IrqsToDeleteCount) {

        status = PcmciaFilterPcCardInterrupts(IoReqList,
                                              IrqsToDeleteCount,
                                              socket->IrqMask,
                                              &newReqList,
                                              IsSocketFlagSet(socket, SOCKET_CB_ROUTE_R2_TO_PCI)
                                              );

        if (NT_SUCCESS(status)) {
            Irp->IoStatus.Information = (ULONG_PTR) newReqList;
            ExFreePool(IoReqList);
        }
    }

    return status;
}



NTSTATUS
PcmciaQueryDeviceText(
    IN PDEVICE_OBJECT Pdo,
    IN OUT PIRP         Irp
    )

/*++

Routine Description:

    Returns descriptive text information about the
    PDO (location and device desc.)

Arguments:

    Pdo -   Pointer to the PC-Card's device object
    Irp -   IRP_MN_QUERY_DEVICE_TEXT Irp

Return Value:

     STATUS_SUCCESS
     STATUS_NOT_SUPPORTED - if  not supported

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
    UNICODE_STRING   unicodeString;
    ANSI_STRING       ansiString;
    UCHAR           deviceText[128];
    NTSTATUS        status;
    USHORT          deviceTextLength;
    PSOCKET_DATA    socketData = pdoExtension->SocketData;

    PAGED_CODE();

    if (irpStack->Parameters.QueryDeviceText.DeviceTextType == DeviceTextDescription) {

        if (*(socketData->Mfg) == '\0' ) {
            if (socketData->Flags & SDF_JEDEC_ID) {
                sprintf(deviceText, "%s %s-%04x", PCMCIA_ID_STRING, PCMCIA_MEMORY_ID_STRING, socketData->JedecId);

            } else {
                sprintf(deviceText, "%s %s", PCMCIA_ID_STRING, PCMCIA_UNKNOWN_MANUFACTURER_STRING);
            }
        } else {
            sprintf(deviceText, "%s %s", socketData->Mfg, socketData->Ident);
        }
        RtlInitAnsiString(&ansiString, deviceText);

        deviceTextLength = (strlen(deviceText) + 1)*sizeof(WCHAR);
        unicodeString.Buffer = ExAllocatePool(PagedPool, deviceTextLength);
        if (unicodeString.Buffer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        unicodeString.MaximumLength = deviceTextLength;
        unicodeString.Length = 0;

        status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, FALSE);
        if (!NT_SUCCESS(status)) {
            ExFreePool(unicodeString.Buffer);
            return status;
        }

        unicodeString.Buffer[unicodeString.Length/sizeof(WCHAR)] = L'\0';
        Irp->IoStatus.Information = (ULONG_PTR) unicodeString.Buffer;
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_NOT_SUPPORTED ;
    }
    return status;
}



NTSTATUS
PcmciaGetPcCardResourceRequirements(
    PPDO_EXTENSION pdoExtension,
    PULONG_PTR      Information
    )

/*++

Routine Description:
    Fills in the resource requirements for the PC-Card obtained from the tuple information

Arguments:

    PdoExtension    -   Pointer to the device extension for the PDO of the pc-card
    Information - Pointer to an allocated resource requirements list is stored in this
                      argument. Caller's responsibility to free the list

Return value:

  STATUS_INSUFFICIENT_RESOURCES     Could not allocate the list
  STATUS_SUCCES                         Obtained resource requirements, Information contains the pointer
                                                to the IO_RESOURCE_REQUIREMENTS list



--*/
{
    NTSTATUS status;
    PPCMCIA_RESOURCE_CHAIN resListChain = NULL;
    PIO_RESOURCE_REQUIREMENTS_LIST ioResourceRequirementsList;
    PSOCKET socket = pdoExtension->Socket;
    PSOCKET_DATA socketData = pdoExtension->SocketData;
    PCONFIG_ENTRY currentConfigEntry;
    PFDO_EXTENSION fdoExtension = socket->DeviceExtension;
    CONFIG_LIST configList;

    PAGED_CODE();
    ASSERT (!IsDeviceMultifunction(pdoExtension));

    //
    // Run through the config entry chains for IO space & Mem space requirements
    //
    configList.SocketData = socketData;

    for (currentConfigEntry=socketData->ConfigEntryChain; currentConfigEntry != NULL; currentConfigEntry=currentConfigEntry->NextEntry) {

        if (currentConfigEntry->Flags & PCMCIA_INVALID_CONFIGURATION) {
            continue;
        }

        configList.ConfigEntry = currentConfigEntry;

        status = PcmciaConfigEntriesToResourceListChain(pdoExtension,
                                                        &configList,
                                                        (ULONG)1,
                                                        &resListChain
                                                        );

        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    status = PcmciaMergeResourceChainToList(resListChain, &ioResourceRequirementsList);

    if (NT_SUCCESS(status) && (ioResourceRequirementsList != NULL)) {
        ioResourceRequirementsList->InterfaceType = Isa;
        ioResourceRequirementsList->BusNumber = fdoExtension->Configuration.BusNumber;
        ioResourceRequirementsList->SlotNumber = 0; // Need to revisit this..
        *Information = (ULONG_PTR) ioResourceRequirementsList;
    }

    PcmciaFreeResourceChain(resListChain);

    return status;
}



NTSTATUS
PcmciaConfigEntriesToResourceListChain(
    PPDO_EXTENSION  pdoExtension,
    PCONFIG_LIST        ConfigList,
    ULONG               configCount,
    PPCMCIA_RESOURCE_CHAIN *ResListChainHead
    )
/*++

Routine Description:
    Fills in the resource requirements for the PC-Card obtained from the tuple information

Arguments:

    PdoExtension    -   Pointer to the device extension for the PDO of the pc-card

Return value:

  STATUS_INSUFFICIENT_RESOURCES     Could not allocate the list
  STATUS_SUCCES                         Obtained resource requirements, Information contains the pointer
                                                to the IO_RESOURCE_REQUIREMENTS list



--*/
{
    PSOCKET socket = pdoExtension->Socket;
    PFDO_EXTENSION fdoExtension = socket->DeviceExtension;
    PCONFIG_ENTRY currentConfigEntry;
    PPCMCIA_RESOURCE_CHAIN resListChain;
    PIO_RESOURCE_LIST ioResourceList;
    PIO_RESOURCE_DESCRIPTOR ioResourceDesc;
    ULONG irqMask = 0, i, iConfig;
    ULONG totalDescriptorCount = 0;
    ULONG TotalIoRanges = 0;
    ULONG listSize;
    BOOLEAN IoRangeIs16Bit[MAX_NUMBER_OF_IO_RANGES] = {0};
    BOOLEAN irqAlternative;

    PAGED_CODE();
    DebugPrint((PCMCIA_DEBUG_RESOURCES, "pdo %08x build ioreslist from configlist %08x, config count=%d\n",
                                                     pdoExtension->DeviceObject, ConfigList, configCount));

    //
    // Calculate how many descriptors we need. This involves also generating
    // the irqmask with the intersection of the irqmasks of the config entries
    // in the array.
    //

    for (iConfig = 0; iConfig < configCount; iConfig++) {
        currentConfigEntry = ConfigList[iConfig].ConfigEntry;

        irqMask |= currentConfigEntry->IrqMask;

        totalDescriptorCount += currentConfigEntry->NumberOfIoPortRanges;
        totalDescriptorCount += currentConfigEntry->NumberOfMemoryRanges;
    }

    if (irqMask) {
        if (IsSocketFlagSet(socket, SOCKET_CB_ROUTE_R2_TO_PCI)) {
            totalDescriptorCount++;
        } else {
            totalDescriptorCount += PcmciaCountOnes(socket->IrqMask);
        }
    }

    if (!totalDescriptorCount) {
        return STATUS_SUCCESS;
    }

    //
    // Add one more for our private DPTYPE_PCMCIA_CONFIGURATION
    //
    totalDescriptorCount++;

    if (configCount > 1) {
        //
        // Add more for our private DPTYPE_PCMCIA_MF_CONFIGURATION
        //
        totalDescriptorCount+=configCount;
    }

    //
    // Calculate the size of IO_RESOURCE_LIST, allocate and clear it
    //

    listSize = (totalDescriptorCount - 1) * sizeof(IO_RESOURCE_DESCRIPTOR)
                  + sizeof(IO_RESOURCE_LIST);

    ioResourceList = ExAllocatePool(PagedPool, listSize);
    if (ioResourceList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(ioResourceList, listSize);

    //
    // Now that we have the resource list allocated, fill it in
    //

    ioResourceList->Version  =  IO_RESOURCE_LIST_VERSION;
    ioResourceList->Revision =  IO_RESOURCE_LIST_REVISION;
    ioResourceList->Count = totalDescriptorCount;
    ioResourceDesc = &ioResourceList->Descriptors[0];

    //
    // Fill in the IRQ info.
    //
    if (irqMask) {
        if (IsSocketFlagSet(socket, SOCKET_CB_ROUTE_R2_TO_PCI)) {

            ioResourceDesc->Type = CmResourceTypeInterrupt;
            ioResourceDesc->Option = 0;

            ioResourceDesc->Flags = (USHORT)CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
            ioResourceDesc->ShareDisposition = CmResourceShareShared;
            ioResourceDesc->u.Interrupt.MinimumVector = socket->FdoIrq;
            ioResourceDesc->u.Interrupt.MaximumVector = socket->FdoIrq;
            ioResourceDesc++;

        } else {
            ULONG irqn;

            irqMask = socket->IrqMask;
            DebugPrint((PCMCIA_DEBUG_RESOURCES, "irq mask %04x\n", irqMask));

            //
            // For each IRQ supported, fill in a separate IO descriptor
            //
            irqAlternative = FALSE;
            for (irqn = 0 ;irqMask; irqMask = (irqMask >> 1), irqn++) {
                if (irqMask & 0x1) {
                    if (irqAlternative) {
                        ioResourceDesc->Option = IO_RESOURCE_ALTERNATIVE;
                    } else {
                        irqAlternative = TRUE;
                        ioResourceDesc->Option = 0;
                    }
                    ioResourceDesc->Type = CmResourceTypeInterrupt;
                    //
                    // This is for 16-bit pc-cards.. so request an edge-triggered
                    // exclusive interrupt
                    //
                    ioResourceDesc->Flags = (USHORT)CM_RESOURCE_INTERRUPT_LATCHED;
                    ioResourceDesc->ShareDisposition = CmResourceShareDeviceExclusive;
                    ioResourceDesc->u.Interrupt.MinimumVector =
                    ioResourceDesc->u.Interrupt.MaximumVector = irqn;
                    ioResourceDesc++;
                }
            }
        }
    }


    for (iConfig = 0; iConfig < configCount; iConfig++) {
        currentConfigEntry = ConfigList[iConfig].ConfigEntry;

        //
        // for each I/O range, fill in an IoResourceDescriptor
        //
        for (i = 0; i < currentConfigEntry->NumberOfIoPortRanges; i++) {
            PHYSICAL_ADDRESS    port;

            ioResourceDesc->Option = 0;
            ioResourceDesc->Type  =  CmResourceTypePort;
            ioResourceDesc->Flags =  CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
            ioResourceDesc->ShareDisposition =  CmResourceShareDeviceExclusive;

            if (currentConfigEntry->IoPortBase[i] == 0) {
                //
                // This is a flexible requirement. Basically means we need
                // any system address range of specified length & alignment
                //
                port=RtlConvertUlongToLargeInteger(0);
                ioResourceDesc->u.Port.MinimumAddress = port;
                port=RtlConvertUlongToLargeInteger(0xffff);
                ioResourceDesc->u.Port.MaximumAddress = port;
            } else {

                port = RtlConvertUlongToLargeInteger((ULONG) currentConfigEntry->IoPortBase[i]);
                ioResourceDesc->u.Port.MinimumAddress = port;
                port = RtlConvertUlongToLargeInteger((ULONG) (currentConfigEntry->IoPortBase[i]+
                                                                             currentConfigEntry->IoPortLength[i]));
                ioResourceDesc->u.Port.MaximumAddress =  port;
            }
            ioResourceDesc->u.Port.Length = (ULONG) currentConfigEntry->IoPortLength[i]+1;
            ioResourceDesc->u.Port.Alignment = currentConfigEntry->IoPortAlignment[i];

            DebugPrint((PCMCIA_DEBUG_RESOURCES, "Port range: %08x-%08x, Length %04x\n",
                                                            ioResourceDesc->u.Port.MinimumAddress.LowPart,
                                                            ioResourceDesc->u.Port.MaximumAddress.LowPart,
                                                            ioResourceDesc->u.Port.Length
                                                            ));

            if ((TotalIoRanges < MAX_NUMBER_OF_IO_RANGES) &&
                (currentConfigEntry->Io16BitAccess)) {
                IoRangeIs16Bit[TotalIoRanges] = TRUE;
            }
            TotalIoRanges++;

            ioResourceDesc++;
        }
    }

    for (iConfig = 0; iConfig < configCount; iConfig++) {
        currentConfigEntry = ConfigList[iConfig].ConfigEntry;

        //
        // for each memory range, fill in an IoResourceDescriptor
        //
        for (i = 0; i < currentConfigEntry->NumberOfMemoryRanges; i++) {
            PHYSICAL_ADDRESS    mem;

            ioResourceDesc->Option = 0;
            ioResourceDesc->Type  =  CmResourceTypeMemory;
            ioResourceDesc->Flags =  CM_RESOURCE_MEMORY_READ_WRITE;
            ioResourceDesc->ShareDisposition =  CmResourceShareDeviceExclusive;
            if (currentConfigEntry->MemoryHostBase[i]) {
                mem = RtlConvertUlongToLargeInteger((ULONG) currentConfigEntry->MemoryHostBase[i]);
                ioResourceDesc->u.Memory.MinimumAddress = mem;
                mem = RtlConvertUlongToLargeInteger((ULONG) currentConfigEntry->MemoryHostBase[i]+
                                                                (ULONG) currentConfigEntry->MemoryLength[i]-1);
                ioResourceDesc->u.Memory.MaximumAddress = mem;
            } else {
                //
                // Any physical address is ok
                //
                mem = RtlConvertUlongToLargeInteger(0);
                ioResourceDesc->u.Memory.MinimumAddress = mem;
                //
                // Only decode 24 bit memory addresses if there is no page register
                //
                if ((fdoExtension->Flags & PCMCIA_MEMORY_24BIT) == 0) {
                    mem = RtlConvertUlongToLargeInteger(0xFFFFFFFF);
                } else {
                    mem = RtlConvertUlongToLargeInteger(0xFFFFFF);
                }
                ioResourceDesc->u.Memory.MaximumAddress = mem;
            }

            ioResourceDesc->u.Memory.Length = currentConfigEntry->MemoryLength[i];
            //
            // Alignment has to be 12 bits
            //
            ioResourceDesc->u.Memory.Alignment = 0x1000;

            DebugPrint((PCMCIA_DEBUG_RESOURCES, "Mem range: %08x-%08x, Length %08x\n",
                                                            ioResourceDesc->u.Memory.MinimumAddress.LowPart,
                                                            ioResourceDesc->u.Memory.MaximumAddress.LowPart,
                                                            ioResourceDesc->u.Memory.Length
                                                            ));

            ioResourceDesc++;
        }
    }

    //
    // Fill in device private containing our config index
    //
    ioResourceDesc->Option = 0;
    ioResourceDesc->Type  =  CmResourceTypeDevicePrivate;
    PCMRES_SET_DESCRIPTOR_TYPE(ioResourceDesc, DPTYPE_PCMCIA_CONFIGURATION);

    currentConfigEntry = ConfigList[0].ConfigEntry;
    PCMRES_SET_CONFIG_INDEX(ioResourceDesc, currentConfigEntry->IndexForThisConfiguration);

    for (i = 0; i < MAX_NUMBER_OF_IO_RANGES; i++) {
        if (IoRangeIs16Bit[i]) {
            PCMRES_SET_IO_FLAG(ioResourceDesc, i, PCMRESF_IO_16BIT_ACCESS);
            PCMRES_SET_IO_FLAG(ioResourceDesc, i, PCMRESF_IO_SOURCE_16);
            PCMRES_SET_IO_FLAG(ioResourceDesc, i, PCMRESF_IO_WAIT_16);
        }
    }

    PCMRES_SET_MEMORY_CARDBASE(ioResourceDesc, 0, currentConfigEntry->MemoryCardBase[0]);
    PCMRES_SET_MEMORY_CARDBASE(ioResourceDesc, 1, currentConfigEntry->MemoryCardBase[1]);

    //
    // Set defaults
    //
    PCMRES_SET_MEMORY_WAITSTATES(ioResourceDesc, 0, PCMRESF_MEM_WAIT_3);
    PCMRES_SET_MEMORY_WAITSTATES(ioResourceDesc, 1, PCMRESF_MEM_WAIT_3);

    DebugPrint((PCMCIA_DEBUG_RESOURCES, "device private %08x %08x %08x\n",
                                                     ioResourceDesc->u.DevicePrivate.Data[0],
                                                     ioResourceDesc->u.DevicePrivate.Data[1],
                                                     ioResourceDesc->u.DevicePrivate.Data[2]
                                                     ));

    ioResourceDesc++;

    //
    // Fill in device private for MF configurations
    //

    if (configCount > 1) {

        for (iConfig = 0; iConfig < configCount; iConfig++) {
            PSOCKET_DATA socketData;

            currentConfigEntry = ConfigList[iConfig].ConfigEntry;
            socketData = ConfigList[iConfig].SocketData;

            ioResourceDesc->Option = 0;
            ioResourceDesc->Type  =  CmResourceTypeDevicePrivate;
            PCMRES_SET_DESCRIPTOR_TYPE(ioResourceDesc, DPTYPE_PCMCIA_MF_CONFIGURATION);

            PCMRES_SET_CONFIG_OPTIONS(ioResourceDesc, currentConfigEntry->IndexForThisConfiguration);
            PCMRES_SET_PORT_RESOURCE_INDEX(ioResourceDesc, socketData->MfIoPortResourceMapIndex);
            if (socketData->DeviceType == PCCARD_TYPE_MODEM) {
                PCMRES_SET_AUDIO_ENABLE(ioResourceDesc);
            }
            PCMRES_SET_CONFIG_REGISTER_BASE(ioResourceDesc, socketData->ConfigRegisterBase);

            DebugPrint((PCMCIA_DEBUG_RESOURCES, "device private MF %08x %08x %08x\n",
                                                             ioResourceDesc->u.DevicePrivate.Data[0],
                                                             ioResourceDesc->u.DevicePrivate.Data[1],
                                                             ioResourceDesc->u.DevicePrivate.Data[2]
                                                             ));
            ioResourceDesc++;
        }
    }


    ASSERT(ioResourceDesc == &ioResourceList->Descriptors[ioResourceList->Count]);

    //
    // Allocate an PCMCIA_RESOURCE_CHAIN structure to track the IO_RESOURCE_LIST.
    //
    resListChain = ExAllocatePool(PagedPool, sizeof(PCMCIA_RESOURCE_CHAIN));
    if (resListChain == NULL) {
        ExFreePool(ioResourceList);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    resListChain->IoResList = ioResourceList;

    //
    // Link this new node onto the passed in chain
    //
    resListChain->NextList = *ResListChainHead;
    *ResListChainHead = resListChain;

    DebugPrint((PCMCIA_DEBUG_RESOURCES, "Added resource chain node %08x, ioreslist %08x\n",
                                                     resListChain, ioResourceList));
    return STATUS_SUCCESS;
}



NTSTATUS
PcmciaMergeResourceChainToList(
    PPCMCIA_RESOURCE_CHAIN ResListChainHead,
    PIO_RESOURCE_REQUIREMENTS_LIST *GeneratedResourceRequirementsList
    )
/*++

Routine Description:


Arguments:


Return value:


--*/
{
    PPCMCIA_RESOURCE_CHAIN resListChain;
    PIO_RESOURCE_REQUIREMENTS_LIST ioResourceRequirementsList;
    PIO_RESOURCE_LIST newIoResList, oldIoResList;
    ULONG listSize, listCount, totalDescriptorCount;

    PAGED_CODE();
    //
    // Now merge the newly created IO_RESOURCE_LISTs into one big
    // IO_RESOURCE_REQUIREMENTS list.
    //

    listCount = 0;
    totalDescriptorCount = 0;

    for (resListChain = ResListChainHead; resListChain != NULL; resListChain = resListChain->NextList) {
        listCount++;
        totalDescriptorCount += resListChain->IoResList->Count;
    }

    if (totalDescriptorCount > 0) {

        listSize = (totalDescriptorCount - listCount) * sizeof(IO_RESOURCE_DESCRIPTOR)
                     + (listCount-1) * sizeof(IO_RESOURCE_LIST)
                     +  sizeof(IO_RESOURCE_REQUIREMENTS_LIST);

        //
        // Allocate space for the res. req. list here
        //
        ioResourceRequirementsList = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(PagedPool, listSize);

        if (ioResourceRequirementsList == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Init the list
        //

        RtlZeroMemory(ioResourceRequirementsList, listSize);
        ioResourceRequirementsList->ListSize = listSize;
        ioResourceRequirementsList->AlternativeLists = listCount;

        //
        // Copy in all the other lists. Point the target pointer (newIoResList)
        // at the end of the list, and lay each new list preceding the old
        // one. This is done because the list is LIFO.
        //

        newIoResList = (PIO_RESOURCE_LIST) (((PUCHAR) ioResourceRequirementsList) + listSize);

        for (resListChain = ResListChainHead; resListChain != NULL; resListChain = resListChain->NextList) {

            oldIoResList = resListChain->IoResList;
            listSize = sizeof(IO_RESOURCE_LIST) + (oldIoResList->Count-1)*sizeof(IO_RESOURCE_DESCRIPTOR);
            newIoResList = (PIO_RESOURCE_LIST) (((PUCHAR) newIoResList) - listSize);

            DebugPrint((PCMCIA_DEBUG_RESOURCES, "Merge resource chain node %08x, ioreslist %08x\n",
                                                             resListChain, oldIoResList));

            RtlCopyMemory(newIoResList, oldIoResList, listSize);
        }

        ASSERT(newIoResList == &ioResourceRequirementsList->List[0]);

        DebugPrint((PCMCIA_DEBUG_RESOURCES, "Resource chain merged to ioResourceRequirementsList %08x\n",
                                                             ioResourceRequirementsList));

    } else {
        ioResourceRequirementsList = NULL;
    }

    *GeneratedResourceRequirementsList = ioResourceRequirementsList;
    return STATUS_SUCCESS;
}



VOID
PcmciaFreeResourceChain(
    PPCMCIA_RESOURCE_CHAIN ResListChain
    )
/*++

Routine Description:


Arguments:


Return value:


--*/
{
    PPCMCIA_RESOURCE_CHAIN prevResListChain;

    PAGED_CODE();
    //
    // free the temporary structures
    //
    while (ResListChain != NULL) {

        DebugPrint((PCMCIA_DEBUG_RESOURCES, "Delete resource chain node %08x, ioreslist %08x\n",
                                                         ResListChain, ResListChain->IoResList));
        if (ResListChain->IoResList) {
            ExFreePool(ResListChain->IoResList);
        }
        prevResListChain = ResListChain;
        ResListChain = ResListChain->NextList;
        ExFreePool(prevResListChain);
    }
}



NTSTATUS
PcmciaMfEnumerateConfigurations(
    IN PPDO_EXTENSION PdoExtension,
    IN PSOCKET_DATA socketData,
    PCONFIG_LIST        ConfigList,
    IN ULONG            Depth,
    PPCMCIA_RESOURCE_CHAIN *MfResListChain
    )

/*++

Routine Description:

    This routine is responsible for enumerating combinations of resource
    requirements for the functions in a true R2 MF card. It is called
    recursively to perform this function.

    See the description of PcmciaMfGetResourceRequirements() to see the
    initial state. This routine runs down the linked list of SocketData
    structures, and each corresponding linked list of ConfigData structures.

    When it finds itself at the end of the SocketData list, it is ready
    to build an IoResList for a single permutation. It calls
    PcmciaConfigEntriesToResourceList() to build a single IoResList.

    In the example MF card with two functions, and 2 and 3 resource
    alternatives respectively, this routine will build a list that looks
    something like this:

    +--------------+
    |MfResListChain|
    +--------------+
                  |        +-----------------------+     +----------------+
                  +--------|MF_RESOURCE_LIST(A1+B1)|-----|IoResList(A1+B1)|
                           +-----------------------+     +----------------+
                                     |
                           +-----------------------+     +----------------+
                           |MF_RESOURCE_LIST(A1+B2)|-----|IoResList(A1+B2)|
                           +-----------------------+     +----------------+
                                     |
                           +-----------------------+     +----------------+
                           |MF_RESOURCE_LIST(A1+B3)|-----|IoResList(A1+B3)|
                           +-----------------------+     +----------------+
                                     |
                           +-----------------------+     +----------------+
                           |MF_RESOURCE_LIST(A2+B1)|-----|IoResList(A2+B1)|
                           +-----------------------+     +----------------+
                                     |
                           +-----------------------+     +----------------+
                           |MF_RESOURCE_LIST(A2+B2)|-----|IoResList(A2+B2)|
                           +-----------------------+     +----------------+
                                     |
                           +-----------------------+     +----------------+
                           |MF_RESOURCE_LIST(A2+B3)|-----|IoResList(A2+B3)|
                           +-----------------------+     +----------------+

    It returns to PcmciaMfGetResourceRequirements() when the list is complete.


Arguments:

    PdoExtension    -   Pointer to the device extension for the PDO of the pc-card

Return Value:

    STATUS_SUCCESS

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PFDO_EXTENSION fdoExtension = PdoExtension->Socket->DeviceExtension;

    PAGED_CODE();

    if (!socketData) {
        //
        // End of SocketData chain, now ready to generate IoResList for this
        //

        if (PcmciaMfCheckForOverlappingRanges(ConfigList, (LONG)Depth)) {
            //
            // This combination would have generated a bad IoResList
            //
            return STATUS_SUCCESS;
        }

        //
        // Build an io resource list from the current config list
        //

        status = PcmciaConfigEntriesToResourceListChain(PdoExtension,
                                                        ConfigList,
                                                        Depth,
                                                        MfResListChain
                                                        );

    } else {
        PCONFIG_ENTRY configEntry;
        //
        // Not at the bottom of the tree. Recurse through each config entry
        // in this socket data.
        //

        ConfigList[Depth].SocketData = socketData;

        for (configEntry = socketData->ConfigEntryChain;
              configEntry != NULL; configEntry = configEntry->NextEntry) {

            if (configEntry->Flags & PCMCIA_INVALID_CONFIGURATION) {
                continue;
            }

            ConfigList[Depth].ConfigEntry = configEntry;

            DebugPrint((PCMCIA_DEBUG_RESOURCES, "pdo %08x mf enum %d sktdata %08x configEntry %08x\n",
                                                             PdoExtension->DeviceObject, Depth, socketData, configEntry));

            status = PcmciaMfEnumerateConfigurations(PdoExtension,
                                                     socketData->Next,
                                                     ConfigList,
                                                     Depth+1,
                                                     MfResListChain);
        }
    }
    return status;
}



NTSTATUS
PcmciaMfGetResourceRequirements(
    IN PPDO_EXTENSION PdoExtension,
    PULONG_PTR Information
    )

/*++

Routine Description:

    For true Multifunction R2 cards, this routine generates a conglomerate
    IoResourceList based on the permutations of configurations of the
    functions.

    Initially the tuple parsing code builds an internal representation of
    the configuration requirements of the cards with SocketData and
    ConfigData structures. Each SocketData structure represents an
    individual function, and each ConfigData represents an alternative
    resource requirement list for that function.

    So for example, an MF card that has two functions may have an internal
    layout like this:

    +------------+
    |PdoExtension|
    +------------+
                |          +-----------+          +-----------+
                +----------|SocketDataA|----------|SocketDataB|----0
                           +-----------+          +-----------+
                                |                         |
                           +------------+         +------------+
                           |ConfigDataA1|         |ConfigDataB1|
                           +------------+         +------------+
                                |                         |
                           +------------+         +------------+
                           |ConfigDataA2|         |ConfigDataB2|
                           +------------+         +------------+
                                |                         |
                                0                 +------------+
                                                  |ConfigDataB3|
                                                  +------------+
                                                          |
                                                          0

    This example shows that function A has two resource requirement alternatives,
    and function B has three. What we do is make permutations of each alternative,
    e.g.:
         A1-B1, A1-B2, A1-B3, A2-B1, A2-B2, A2-B3

    The permutations are built with recursive calls to PcmciaMfEnumerateConfigurations().
    In this example, the result of this enumeration will be six independent
    IoResLists. Each IoResList will be a merge of the particular permutation. When
    PcmciaMfEnumerateConfigurations() returns to this routine, these IoResLists will
    be chained together through the pointer MfResListChain. The rest of the routine
    builds a single "six-member" IoResList from the chain.

    Finally the support structure and lists for performing the operation are freed, and
    the single conglomerate list is returned.


Arguments:

    PdoExtension    -   Pointer to the device extension for the PDO of the pc-card
    Information - Pointer to an allocated resource requirements list is stored in this
                      argument. Caller's responsibility to free the list

Return value:

  STATUS_INSUFFICIENT_RESOURCES     Could not allocate the list
  STATUS_SUCCES                         Obtained resource requirements, Information contains the pointer
                                                to the IO_RESOURCE_REQUIREMENTS list



--*/
{
    NTSTATUS status;
    PFDO_EXTENSION fdoExtension = PdoExtension->Socket->DeviceExtension;
    ULONG MaxDepth = 0;
    PSOCKET_DATA socketData;
    PCONFIG_LIST ConfigList;
    PPCMCIA_RESOURCE_CHAIN MfResListChain = NULL;
    PIO_RESOURCE_REQUIREMENTS_LIST ioResourceRequirementsList;

    PAGED_CODE();

    ASSERT (IsDeviceMultifunction(PdoExtension));

    //
    // Find out how deep the enumeration will be.
    // Should be the same as Socket->NumberOfFunctions, but just to be paranoid...
    //
    for (socketData = PdoExtension->SocketData; socketData != NULL; socketData = socketData->Next) {
        MaxDepth++;
    }

    if (!MaxDepth) {
        ASSERT (PdoExtension->SocketData);
        return STATUS_UNSUCCESSFUL;
    }

    ConfigList = ExAllocatePool(PagedPool, MaxDepth*sizeof(CONFIG_LIST));

    if (!ConfigList) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    PcmciaMfBuildResourceMapInfo(PdoExtension, ConfigList, MaxDepth);


    status = PcmciaMfEnumerateConfigurations(PdoExtension,
                                             PdoExtension->SocketData,
                                             ConfigList,
                                             0,
                                             &MfResListChain);

    ExFreePool(ConfigList);

    if (NT_SUCCESS(status)) {
        //
        // Now merge everything that EnumerateConfigurations built into a single list
        //
        status = PcmciaMergeResourceChainToList(MfResListChain, &ioResourceRequirementsList);
    }

    if (NT_SUCCESS(status) && (ioResourceRequirementsList != NULL)) {
        ioResourceRequirementsList->InterfaceType = Isa;
        ioResourceRequirementsList->BusNumber = fdoExtension->Configuration.BusNumber;
        ioResourceRequirementsList->SlotNumber = 0; // Need to revisit this..
        *Information = (ULONG_PTR) ioResourceRequirementsList;

        DebugPrint((PCMCIA_DEBUG_RESOURCES, "pdo %08x mf returning req list %08x, %d alternatives\n",
                                                             PdoExtension->DeviceObject, ioResourceRequirementsList,
                                                             ioResourceRequirementsList->AlternativeLists
                                                             ));
    }

    PcmciaFreeResourceChain(MfResListChain);

    return status;
}



VOID
PcmciaMfBuildResourceMapInfo(
    IN PPDO_EXTENSION PdoExtension,
    PCONFIG_LIST        ConfigList,
    ULONG               ConfigCount
    )
/*++

Routine Description:

    This routine initializes variables in the SocketData structures to allow
    PcmciaMfEnumerateChild() to correctly build ChildInfo ResourceMaps for MF.SYS.

    It needs to calculate the base index for a particular resource of a particular
    function. So for the example of a 2-function MF R2 card, the resulting CmResList
    will be layed out positionally like:

         CmResList
             IRQ (Shared)
             I/O (Function A)
             I/O (Function B)
             Mem (Function A)
             Mem (Function B)

    The reason for this is this is simply how PcmciaConfigEntriesToResourceList()
    happens to lay out the requirements. So in order to generate a valid resource
    map, this routine has to calculate, for example, the Memory Base for function B
    by adding together:
        1 (if there will be an IRQ in the cmreslist)
        # of I/O port resources for A
        # of I/O port resources for B
        # of Mem resource for A
    This sum will give you the position in the CmReslist for the first memory resource
    that B would use.

    These calculations are stored in the socket data structures for each corresponding
    function so that PcmciaMfEnumerateChild() can simply fill in the maps for MF.

Arguments:

    PdoExtension    -   Pointer to the device extension for the PDO of the pc-card
    ConfigList - config list array holds a permutation of configdata's
    ConfigCount - # of card functions

Return value:


--*/
{
    PSOCKET_DATA socketData;
    PCONFIG_ENTRY configEntry;
    ULONG index;
    USHORT count;
    UCHAR currentResourceMapIndex = 0;
    BOOLEAN needsIRQ = FALSE;

    for (index = 0, socketData = PdoExtension->SocketData; socketData != NULL; socketData = socketData->Next) {

        //
        // In the current implementation we assume that all the alternative lists in the
        // io resource requirements for the multifunction parent pc-card have the same number
        // and types of resource requirements. i.e. it's currently illegal to request
        // one configuration in which only IRQ and I/O are requested, for example, and an
        // alternative configuration in which MEMORY is also specified.
        // This is because of the limitation in the MF enumerator - (which in turn relied
        // on the Win 9x implementation).
        // So we currently look at only the first valid configuration - that is representative
        // of all the other configurations.
        //
        for (configEntry = socketData->ConfigEntryChain; (configEntry != NULL)  &&
             (configEntry->Flags & PCMCIA_INVALID_CONFIGURATION);
             configEntry = configEntry->NextEntry);

        if (configEntry == NULL) {
            return;
        }

        ASSERT(index < ConfigCount);

        ConfigList[index].SocketData = socketData;
        ConfigList[index].ConfigEntry = configEntry;
        index++;
    }

    //
    // IRQ is unique because it is the only shared resource. So if the card needs an IRQ, then
    // all devices point to the same resource

    for (index = 0; index < ConfigCount; index++) {
        if (ConfigList[index].ConfigEntry->IrqMask) {
            //
            // Index always maps to zero since PcmciaConfigEntriesToResourceList
            // builds IRQs first.
            //
            ConfigList[index].SocketData->MfIrqResourceMapIndex = currentResourceMapIndex;
            ConfigList[index].SocketData->MfNeedsIrq = TRUE;
            needsIRQ = TRUE;
        }
    }

    if (needsIRQ) {
        currentResourceMapIndex++;
    }

    //
    // fill in the bases of the I/O port ranges
    //
    for (index = 0; index < ConfigCount; index++) {
        ConfigList[index].SocketData->MfIoPortResourceMapIndex = currentResourceMapIndex;

        count = ConfigList[index].ConfigEntry->NumberOfIoPortRanges;

        ConfigList[index].SocketData->MfIoPortCount = count;
        currentResourceMapIndex += count;
    }

    //
    // fill in the bases of the memory ranges
    //
    for (index = 0; index < ConfigCount; index++) {
        ConfigList[index].SocketData->MfMemoryResourceMapIndex = currentResourceMapIndex;

        count = ConfigList[index].ConfigEntry->NumberOfMemoryRanges;

        ConfigList[index].SocketData->MfMemoryCount = count;
        currentResourceMapIndex += count;
    }
}



BOOLEAN
PcmciaMfCheckForOverlappingRanges(
    PCONFIG_LIST ConfigList,
    LONG ConfigCount
    )
/*++

Routine Description:

    This routine scans through the current config list to see if the set of configurations
    overlap. For example, if the MF R2 card is a dual-serial card, then each serial device
    may want to have one of the standard com addresses (e.g. 3f8, 2f8, etc.). But now
    that we are merging configurations, we need to weed out any overlapping ranges so
    we don't produce a congolmerate IoResList that contains the same range for different
    functions.

Arguments:

    ConfigList - config list array holds a permutation of configdata's
    ConfigCount - # of card functions

Return value:


--*/
{
    PCONFIG_ENTRY configEntry1, configEntry2;
    LONG configIndex1, configIndex2;
    LONG configCount1, configCount2;
    LONG rangeIndex1, rangeIndex2;
    LONG rangeCount1, rangeCount2;
    ULONG rangeStart1, rangeStart2;
    ULONG rangeEnd1, rangeEnd2;
    BOOLEAN rangesOverlap = FALSE;

    DebugPrint((PCMCIA_DEBUG_RESOURCES, "-------Range Check--------------\n"));
    //
    // Check for overlap in the I/O port ranges
    //
    try {
        for (configIndex1 = 0; configIndex1 < ConfigCount; configIndex1++) {

            configEntry1 = ConfigList[configIndex1].ConfigEntry;
            rangeCount1 = configEntry1->NumberOfIoPortRanges;

            for (rangeIndex1 = 0; rangeIndex1 < rangeCount1; rangeIndex1++) {
                //
                // Get the current range we will compare
                //
                rangeStart1 = configEntry1->IoPortBase[rangeIndex1];
                rangeEnd1 = rangeStart1 + configEntry1->IoPortLength[rangeIndex1];

                if (rangeStart1 == 0) {
                    DebugPrint((PCMCIA_DEBUG_RESOURCES, "RangeCheck I/O: skip unrestricted range %x.%x\n",
                                                                     configIndex1, rangeIndex1));
                    continue;
                }

                //
                // Now start comparing this against the rest of the ranges by
                // starting at then end and working backwards.
                //
                for (configIndex2 = ConfigCount-1; configIndex2 >= 0; configIndex2--) {
                     configEntry2 = ConfigList[configIndex2].ConfigEntry;
                     rangeCount2 = configEntry2->NumberOfIoPortRanges;

                    for (rangeIndex2 = rangeCount2-1; rangeIndex2 >= 0; rangeIndex2--) {

                        if ((configEntry1 == configEntry2) && (rangeIndex1 == rangeIndex2)) {
                            leave;
                        }

                        rangeStart2 = configEntry2->IoPortBase[rangeIndex2];
                        rangeEnd2 = rangeStart2 + configEntry2->IoPortLength[rangeIndex2];

                        if (rangeStart2 == 0) {
                            DebugPrint((PCMCIA_DEBUG_RESOURCES, "RangeCheck I/O: skip unrestricted range %x.%x\n",
                                                                             configIndex2, rangeIndex2));
                            continue;
                        }
                        DebugPrint((PCMCIA_DEBUG_RESOURCES, "RangeCheck I/O: %x.%x %04x-%04x :: %x.%x %04x-%04x\n",
                                                            configIndex1, rangeIndex1, rangeStart1, rangeEnd1,
                                                            configIndex2, rangeIndex2, rangeStart2, rangeEnd2));

                        if (((rangeStart1 >= rangeStart2) && (rangeStart1 <= rangeEnd2)) ||
                             ((rangeEnd1 >= rangeStart2) && (rangeEnd1 <= rangeEnd2))) {
                             rangesOverlap = TRUE;
                             leave;
                        }
                    }
                }
            }
        }
    } finally {
    }

    if (rangesOverlap) {
        DebugPrint((PCMCIA_DEBUG_RESOURCES, "-------Overlap Detected---------\n"));
        return TRUE;
    }

    //
    // Check for overlap in the memory ranges
    //
    try {
        for (configIndex1 = 0; configIndex1 < ConfigCount; configIndex1++) {

            configEntry1 = ConfigList[configIndex1].ConfigEntry;
            rangeCount1 = configEntry1->NumberOfMemoryRanges;

            for (rangeIndex1 = 0; rangeIndex1 < rangeCount1; rangeIndex1++) {
                //
                // Get the current range we will compare
                //
                rangeStart1 = configEntry1->MemoryHostBase[rangeIndex1];
                rangeEnd1 = rangeStart1 + configEntry1->MemoryLength[rangeIndex1] - 1;

                if (rangeStart1 == 0) {
                    DebugPrint((PCMCIA_DEBUG_RESOURCES, "RangeCheck MEM: skip unrestricted range %x.%x\n",
                                                                     configIndex1, rangeIndex1));
                    continue;
                }

                //
                // Now start comparing this against the rest of the ranges by
                // starting at then end and working backwards.
                //
                for (configIndex2 = ConfigCount-1; configIndex2 >= 0; configIndex2--) {
                     configEntry2 = ConfigList[configIndex2].ConfigEntry;
                     rangeCount2 = configEntry2->NumberOfMemoryRanges;

                    for (rangeIndex2 = rangeCount2-1; rangeIndex2 >= 0; rangeIndex2--) {

                        if ((configEntry1 == configEntry2) && (rangeIndex1 == rangeIndex2)) {
                            leave;
                        }

                        rangeStart2 = configEntry2->MemoryHostBase[rangeIndex2];
                        rangeEnd2 = rangeStart2 + configEntry2->MemoryLength[rangeIndex2] - 1;

                        if (rangeStart2 == 0) {
                            DebugPrint((PCMCIA_DEBUG_RESOURCES, "RangeCheck MEM: skip unrestricted range %x.%x\n",
                                                                             configIndex2, rangeIndex2));
                            continue;
                        }
                        DebugPrint((PCMCIA_DEBUG_RESOURCES, "RangeCheck MEM: %x.%x %08x-%08x :: %x.%x %08x-%08x\n",
                                                            configIndex1, rangeIndex1, rangeStart1, rangeEnd1,
                                                            configIndex2, rangeIndex2, rangeStart2, rangeEnd2));

                        if (((rangeStart1 >= rangeStart2) && (rangeStart1 <= rangeEnd2)) ||
                             ((rangeEnd1 >= rangeStart2) && (rangeEnd1 <= rangeEnd2))) {
                             DebugPrint((PCMCIA_DEBUG_RESOURCES, "-------Overlap Detected---------\n"));
                             rangesOverlap = TRUE;
                             leave;
                        }
                    }
                }
            }
        }
    } finally {
    }

#if DBG
    if (rangesOverlap) {
        DebugPrint((PCMCIA_DEBUG_RESOURCES, "-------Overlap Detected---------\n"));
    } else {
        DebugPrint((PCMCIA_DEBUG_RESOURCES, "-------Generate IoResList-------\n"));
    }
#endif

    return rangesOverlap;
}




NTSTATUS
PcmciaStartPcCard(
    IN PDEVICE_OBJECT Pdo,
    IN PCM_RESOURCE_LIST ResourceList,
    IN OUT PIRP         Irp
    )
/*++

Routine Description:

    This routine attempts to start the PC-Card by configuring it with the supplied resources.


Arguments:

    Pdo - Pointer to the device object representing the PC-Card which needs to be started
    ResourceList - Pointer the list of assigned resources for the PC-Card

Return value:

    STATUS_INSUFFICIENT_RESOURCES - Not sufficient resources supplied to start device/
                                              could not allocate memory
    STATUS_UNSUCCESSFUL             - Supplied resources are invalid for this PC-Card
    STATUS_SUCCESS                  - Configured and started the card successfully

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR fullResourceDesc;
    PCM_PARTIAL_RESOURCE_LIST partialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialResourceDesc;
    ULONG fullResourceDescCount, partialResourceDescCount, i, index;
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
    PSOCKET socket = pdoExtension->Socket;
    PFDO_EXTENSION fdoExtension = socket->DeviceExtension;
    PSOCKET_DATA    socketData = pdoExtension->SocketData;
    PSOCKET_CONFIGURATION socketConfig;
    PCONFIG_ENTRY            currentConfig;
    PFUNCTION_CONFIGURATION fnConfig;
    NTSTATUS status;
    ULONG scIoIndex = 0, scMemIndex = 0;

    PAGED_CODE();

    if (IsDeviceStarted(pdoExtension)) {
        //
        // Already started..
        //
        return STATUS_SUCCESS;
    }

    if (IsDevicePhysicallyRemoved(pdoExtension)) {
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    if ( ResourceList == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    PcmciaCleanupSocketConfiguration(pdoExtension);

    socketConfig = ExAllocatePool(NonPagedPool, sizeof(SOCKET_CONFIGURATION));
    if (!socketConfig) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(socketConfig, sizeof(SOCKET_CONFIGURATION));

    fullResourceDescCount = ResourceList->Count;

    ASSERT(fullResourceDescCount == 1);

    fullResourceDesc = &ResourceList->List[0];
    partialResourceList = &fullResourceDesc->PartialResourceList;
    partialResourceDesc = partialResourceList->PartialDescriptors;
    partialResourceDescCount = partialResourceList->Count;

    socketConfig->NumberOfIoPortRanges =
    socketConfig->NumberOfMemoryRanges = 0;

    for (i=0; i< partialResourceList->Count; i++, partialResourceDesc++) {
        switch (partialResourceDesc->Type) {
        case CmResourceTypePort: {
                index = socketConfig->NumberOfIoPortRanges;
                socketConfig->Io[index].Base =  partialResourceDesc->u.Port.Start.LowPart;
                socketConfig->Io[index].Length = (USHORT) partialResourceDesc->u.Port.Length-1;
                socketConfig->NumberOfIoPortRanges++;
                break;
            }

        case CmResourceTypeMemory: {
                index = socketConfig->NumberOfMemoryRanges;
                socketConfig->Memory[index].HostBase = partialResourceDesc->u.Memory.Start.LowPart;
                socketConfig->Memory[index].Length   = partialResourceDesc->u.Memory.Length;
                socketConfig->NumberOfMemoryRanges++;
                break;
            }

        case CmResourceTypeInterrupt: {
                socketConfig->Irq = partialResourceDesc->u.Interrupt.Level;
                DebugPrint((PCMCIA_DEBUG_RESOURCES, "Assigned Irq: 0x%x for socket register offset %d\n",
                                socketConfig->Irq, socket->RegisterOffset));
                break;
            }

        case CmResourceTypePcCardConfig:
        case CmResourceTypeMfCardConfig:
        case CmResourceTypeDevicePrivate: {
                DebugPrint((PCMCIA_DEBUG_RESOURCES, "DevicePrivate received, Data= %08x %08x %08x\n",
                                partialResourceDesc->u.DevicePrivate.Data[0],
                                partialResourceDesc->u.DevicePrivate.Data[1],
                                partialResourceDesc->u.DevicePrivate.Data[2]));

                if (PCMRES_GET_DESCRIPTOR_TYPE (partialResourceDesc) == DPTYPE_PCMCIA_CONFIGURATION) {
                    //
                    // Single function configuration private
                    //
                    socketConfig->IndexForCurrentConfiguration = PCMRES_GET_CONFIG_INDEX(partialResourceDesc);
                    socketConfig->ConfigRegisterBase = socketData->ConfigRegisterBase;

                    DebugPrint((PCMCIA_DEBUG_RESOURCES, "Pccard config resource\n"));
                    DebugPrint((PCMCIA_DEBUG_RESOURCES, "  Index %x\n", socketConfig->IndexForCurrentConfiguration));

                    for (index = 0; index < PCMRES_PCMCIA_MAX_IO; index++) {

                        if (scIoIndex >= MAX_NUMBER_OF_IO_RANGES) {
                            break;
                        }

                        socketConfig->Io[scIoIndex].Width16      = PCMRES_GET_IO_FLAG(partialResourceDesc, index, PCMRESF_IO_16BIT_ACCESS);
                        socketConfig->Io[scIoIndex].WaitState16 = PCMRES_GET_IO_FLAG(partialResourceDesc, index, PCMRESF_IO_WAIT_16);
                        socketConfig->Io[scIoIndex].Source16     = PCMRES_GET_IO_FLAG(partialResourceDesc, index, PCMRESF_IO_SOURCE_16);
                        socketConfig->Io[scIoIndex].ZeroWait8    = PCMRES_GET_IO_FLAG(partialResourceDesc, index, PCMRESF_IO_ZERO_WAIT_8);

                        DebugPrint((PCMCIA_DEBUG_RESOURCES, "PcCardConfig IO%d - Width:%d, Wait16:%d, Source16:%d, ZeroWait8:%d\n", scIoIndex,
                                        socketConfig->Io[scIoIndex].Width16,
                                        socketConfig->Io[scIoIndex].WaitState16,
                                        socketConfig->Io[scIoIndex].Source16,
                                        socketConfig->Io[scIoIndex].ZeroWait8));

                        scIoIndex++;
                    }

                    for (index = 0; index < PCMRES_PCMCIA_MAX_MEM; index++) {

                        if (scMemIndex >= MAX_NUMBER_OF_MEMORY_RANGES) {
                            break;
                        }

                        socketConfig->Memory[scMemIndex].Width16        = PCMRES_GET_MEMORY_FLAG(partialResourceDesc, index, PCMRESF_MEM_16BIT_ACCESS);
                        socketConfig->Memory[scMemIndex].WaitState  = PCMRES_GET_MEMORY_WAITSTATES(partialResourceDesc, index);
                        socketConfig->Memory[scMemIndex].IsAttribute = PCMRES_GET_MEMORY_FLAG(partialResourceDesc, index, PCMRESF_MEM_ATTRIBUTE);
                        socketConfig->Memory[scMemIndex].CardBase   = PCMRES_GET_MEMORY_CARDBASE(partialResourceDesc, index);

                        DebugPrint((PCMCIA_DEBUG_RESOURCES, "PcCardConfig MEM%d - Width:%d, Wait:%d, IsAttr:%d, CardBase:%x\n", scMemIndex,
                                        socketConfig->Memory[scMemIndex].Width16,
                                        socketConfig->Memory[scMemIndex].WaitState,
                                        socketConfig->Memory[scMemIndex].IsAttribute,
                                        socketConfig->Memory[scMemIndex].CardBase));

                        scMemIndex++;
                    }



                } else if (PCMRES_GET_DESCRIPTOR_TYPE (partialResourceDesc) == DPTYPE_PCMCIA_MF_CONFIGURATION) {
                    //
                    // Multifunction configuration private
                    //
                    UCHAR IoResourceIndex;

                    fnConfig = ExAllocatePool(NonPagedPool, sizeof(FUNCTION_CONFIGURATION));
                    if (!fnConfig) {
                        return STATUS_INSUFFICIENT_RESOURCES;
                    }

                    RtlZeroMemory(fnConfig, sizeof(FUNCTION_CONFIGURATION));

                    fnConfig->ConfigRegisterBase = PCMRES_GET_CONFIG_REGISTER_BASE(partialResourceDesc);
                    fnConfig->ConfigOptions = PCMRES_GET_CONFIG_OPTIONS(partialResourceDesc);
                    if (PCMRES_GET_AUDIO_ENABLE(partialResourceDesc)) {
                        fnConfig->ConfigFlags = 0x08;
                    }

                    if (fnConfig->ConfigOptions & 0x02) {
                        IoResourceIndex = PCMRES_GET_PORT_RESOURCE_INDEX(partialResourceDesc);
                        if ((IoResourceIndex < partialResourceList->Count) &&
                            (partialResourceList->PartialDescriptors[IoResourceIndex].Type == CmResourceTypePort)) {

                            fnConfig->IoLimit = (UCHAR) (partialResourceList->PartialDescriptors[IoResourceIndex].u.Port.Length-1);
                            fnConfig->IoBase = partialResourceList->PartialDescriptors[IoResourceIndex].u.Port.Start.LowPart;
                        }
                    }

                    if (socketConfig->FunctionConfiguration == NULL) {
                        //
                        // This is the first MfConfig
                        //
                        socketConfig->FunctionConfiguration = fnConfig;
                    } else {
                        //
                        // Chain it on the end so it is fifo
                        //
                        PFUNCTION_CONFIGURATION mfTmp = socketConfig->FunctionConfiguration;
                        while (mfTmp->Next != NULL) {
                            mfTmp = mfTmp->Next;
                        }
                        mfTmp->Next = fnConfig;
                    }
                }
                break;
            }

        default: {
                DebugPrint((PCMCIA_DEBUG_INFO, "PcmciaStartPcCard:Unknown resource type %d handed down",
                                (ULONG) partialResourceDesc->Type));
                break;
            }
        }
    }

    //
    // Power up the card if it isn't already..
    //
    status = PcmciaRequestSocketPower(pdoExtension, NULL);

    if (!NT_SUCCESS(status)) {
        ASSERT(NT_SUCCESS(status));
        return status;
    }

    //
    // Turn on ZV for this card, if it needs it
    //
    if (socketData->Flags & SDF_ZV) {
        PcmciaSetZV(fdoExtension, socket, TRUE);
        SetSocketFlag(socket, SOCKET_CUSTOM_INTERFACE);
    } else if (IsSocketFlagSet(socket, SOCKET_CUSTOM_INTERFACE)) {
        PcmciaSetZV(fdoExtension, socket, FALSE);
        ResetSocketFlag(socket, SOCKET_CUSTOM_INTERFACE);
    }

    PcmciaSetAudio(fdoExtension, socket, IsDeviceFlagSet(pdoExtension, PCMCIA_PDO_ENABLE_AUDIO));

    pdoExtension->SocketConfiguration = socketConfig;
    if (!NT_SUCCESS(PcmciaConfigurePcCard(pdoExtension, NULL))) {
        //
        // Problems in configuring the card: could be the card
        // was removed while configuring it
        //
        pdoExtension->SocketConfiguration = NULL;
        ExFreePool(socketConfig);
        return STATUS_DEVICE_NOT_READY;
    }

    MarkDeviceStarted(pdoExtension);
    MarkDeviceLogicallyInserted(pdoExtension);

    return STATUS_SUCCESS;
}



NTSTATUS
PcmciaStopPcCard(
    IN PDEVICE_OBJECT Pdo
    )
/*++

Routine Description:

    This routine stops and deconfigures the given PC-Card

Arguments:

    Pdo - Pointer to the device object representing the PC-Card which needs to be stopped

Return value:

  STATUS_SUCCESS - PC-Card was already stopped, or stopped and deconfigured now successfully

--*/
{
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
    PSOCKET      socket = pdoExtension->Socket;
    PFDO_EXTENSION fdoExtension = socket->DeviceExtension;
    CARD_REQUEST          cardRequest;

    PAGED_CODE();

    if (!IsDeviceStarted(pdoExtension)) {
        return STATUS_SUCCESS;
    }
    //
    // Need to deconfigure the controller
    //
    PcmciaSocketDeconfigure(socket);
    (socket->SocketFnPtr->PCBInitializePcmciaSocket)(socket);

    MarkDeviceNotStarted(pdoExtension);
    return STATUS_SUCCESS;
}



NTSTATUS
PcmciaRemovePcCard(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP             Irp
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
    PSOCKET         socket = pdoExtension->Socket;
    NTSTATUS status;

    PAGED_CODE();

    if (socket == NULL) {
        return STATUS_SUCCESS;
    }

    PcmciaStopPcCard(Pdo);
    PcmciaReleaseSocketPower(pdoExtension, NULL);

    if (IsDevicePhysicallyRemoved(pdoExtension)) {
        PFDO_EXTENSION fdoExtension = socket->DeviceExtension;
        PDEVICE_OBJECT curPdo, prevPdo;
        PPDO_EXTENSION curPdoExt;
        ULONG waitCount = 0;

        //
        // Synchronize with power routines
        // LATER: make these values adjustable
        //
        while(!PCMCIA_TEST_AND_SET(&pdoExtension->DeletionLock)) {
            PcmciaWait(1000000);
            if (waitCount++ > 20) {
                ASSERT(waitCount <= 20);
                break;
            }
        }

        //
        // Delink this Pdo from the FDO list.
        //
        for (curPdo = fdoExtension->PdoList, prevPdo = NULL; curPdo!=NULL; prevPdo = curPdo, curPdo=curPdoExt->NextPdoInFdoChain) {
            curPdoExt = curPdo->DeviceExtension;

            if (curPdo == Pdo) {
                if (prevPdo) {
                    ((PPDO_EXTENSION)prevPdo->DeviceExtension)->NextPdoInFdoChain = pdoExtension->NextPdoInFdoChain;
                } else {
                    fdoExtension->PdoList = pdoExtension->NextPdoInFdoChain;
                }
                break;

            }
        }

        for (curPdo = socket->PdoList, prevPdo = NULL; curPdo!=NULL; prevPdo = curPdo, curPdo=curPdoExt->NextPdoInSocket) {
            curPdoExt = curPdo->DeviceExtension;

            if (curPdo == Pdo) {
                //
                // Delink this Pdo from the socket list.
                //
                if (prevPdo) {
                    ((PPDO_EXTENSION)prevPdo->DeviceExtension)->NextPdoInSocket = pdoExtension->NextPdoInSocket;
                } else {
                    socket->PdoList = pdoExtension->NextPdoInSocket;
                }
                break;
            }
        }

        PcmciaCleanupSocketConfiguration(pdoExtension);
        PcmciaCleanupPdo(Pdo);
        //
        // Delete..
        //
        if (!IsDeviceDeleted(pdoExtension)) {
            MarkDeviceDeleted(pdoExtension);
            IoDeleteDevice(Pdo);
        }

        ResetSocketFlag(socket, SOCKET_CLEANUP_PENDING);
        //
        // If a query_device_relations came in after a card was inserted, but before
        // we have removed the previous card configuration, the enumeration would have been
        // postponed. Here, we start it up again
        //
        if (IsSocketFlagSet(socket, SOCKET_ENUMERATE_PENDING)) {
            ResetSocketFlag(socket, SOCKET_ENUMERATE_PENDING);
            SetSocketFlag(socket, SOCKET_CARD_STATUS_CHANGE);
            IoInvalidateDeviceRelations(fdoExtension->Pdo, BusRelations);
        }

    } else {
        //
        // We will keep this Pdo around, since this is not physically ejected.
        //
        MarkDeviceLogicallyRemoved(pdoExtension);
    }

    return STATUS_SUCCESS;
}


VOID
PcmciaCleanupPdo(
    IN PDEVICE_OBJECT Pdo
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    PPDO_EXTENSION          pdoExtension;
    PSOCKET_DATA                socketData, tmpSocketData;

    ASSERT (Pdo != NULL);

    pdoExtension = Pdo->DeviceExtension;

    ASSERT(pdoExtension->WaitWakeIrp == NULL);

    if (pdoExtension->LowerDevice!=NULL) {
        //
        // Detach our filter device
        //
        IoDetachDevice(pdoExtension->LowerDevice);
        pdoExtension->LowerDevice = NULL;
    }

    socketData = pdoExtension->SocketData;
    pdoExtension->SocketData = NULL;
    while (socketData != NULL) {
        tmpSocketData = socketData;
        socketData = socketData->Next;
        PcmciaCleanupSocketData(tmpSocketData);
    }

    PcmciaCleanupSocketConfiguration(pdoExtension);

    //
    // Cleanup device id
    //
    if (pdoExtension->DeviceId) {
        ExFreePool(pdoExtension->DeviceId);
        pdoExtension->DeviceId = NULL;
    }

    if (pdoExtension->CisCache) {
        ExFreePool(pdoExtension->CisCache);
        pdoExtension->CisCache = NULL;
    }
}


VOID
PcmciaCleanupSocketData(
    IN PSOCKET_DATA SocketData
    )
/*++

Routine Descrption

    Frees up the passed in SocketData structure & any
    structures it might point to

Arguments

    SocketData -    Pointer to the SOCKET_DATA structure

Return Value

    none


--*/
{
    PCONFIG_ENTRY               configEntry, nextConfigEntry;

    if (SocketData == NULL) {
        return;
    }
    //
    // Free up the config entry descriptors
    //
    configEntry = SocketData->ConfigEntryChain;
    SocketData->ConfigEntryChain = NULL;
    while (configEntry) {
        nextConfigEntry = configEntry->NextEntry;
        ExFreePool(configEntry);
        configEntry = nextConfigEntry;
    }

    //
    // Free up socket data
    //
    ExFreePool(SocketData);
    return;
}



VOID
PcmciaCleanupSocketConfiguration(
    PPDO_EXTENSION pdoExtension
    )
/*++

Routine Description:

    Frees up the linked list of function configuration, as well as
    the base socket configuration structure itself.

Arguments:

Return value:

--*/
{
    PSOCKET_CONFIGURATION socketConfig = pdoExtension->SocketConfiguration;
    PFUNCTION_CONFIGURATION fnConfig, fnConfigNext;

    if (socketConfig == NULL) {
        return;
    }

    fnConfig = socketConfig->FunctionConfiguration;
    while(fnConfig) {
        fnConfigNext = fnConfig->Next;
        ExFreePool(fnConfig);
        fnConfig = fnConfigNext;
    }

    ExFreePool(pdoExtension->SocketConfiguration);
    pdoExtension->SocketConfiguration = NULL;
}


NTSTATUS
PcmciaPdoDeviceControl(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    PAGED_CODE();

    //
    // No IOCTLs handled currently
    //
    UNREFERENCED_PARAMETER(Pdo);

    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
PcmciaPdoDeviceCapabilities(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Obtains the device capabilities of the given pc-card.

    If the pc-card is an R2 card (16-bit pc-card), the capabilities
    are constructed from the parent PCMCIA controller's capabilities.
    Finally the obtained capabilities are cached in the pc-card's device
    extension for use in power management of the card.

Arguments:

    Pdo -     Pointer to the device object for the pc-card
    Irp -     Pointer to the query device capabilities Irp

Return Value:

    STATUS_SUCCESS                      - Capabilities obtained and recorded in the passed in pointer
    STATUS_INSUFFICIENT_RESOURCES   - Could not allocate memory to cache the capabilities

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_CAPABILITIES capabilities = irpStack->Parameters.DeviceCapabilities.Capabilities;
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
    PDEVICE_CAPABILITIES busCapabilities = &pdoExtension->Socket->DeviceExtension->DeviceCapabilities;

    PAGED_CODE();

    //
    // R2 card. Fill in the capabilities ourselves..
    //

    capabilities->Removable = TRUE;
    capabilities->UniqueID = TRUE;
    capabilities->EjectSupported = FALSE;

    capabilities->Address = pdoExtension->Socket->RegisterOffset;
    // Don't know the UINumber, just leave it alone


    if (busCapabilities->DeviceState[PowerSystemWorking] != PowerDeviceUnspecified) {
        capabilities->DeviceState[PowerSystemWorking] = busCapabilities->DeviceState[PowerSystemWorking];
        capabilities->DeviceState[PowerSystemSleeping1] = busCapabilities->DeviceState[PowerSystemSleeping1];
        capabilities->DeviceState[PowerSystemSleeping2] = busCapabilities->DeviceState[PowerSystemSleeping2];
        capabilities->DeviceState[PowerSystemSleeping3] = busCapabilities->DeviceState[PowerSystemSleeping3];
        capabilities->DeviceState[PowerSystemHibernate] = busCapabilities->DeviceState[PowerSystemHibernate];
        capabilities->DeviceState[PowerSystemShutdown] = busCapabilities->DeviceState[PowerSystemShutdown];

        if (IsPdoFlagSet(pdoExtension, PCMCIA_PDO_SUPPORTS_WAKE)) {
            capabilities->SystemWake = MIN(PowerSystemSleeping3, busCapabilities->SystemWake);
            capabilities->DeviceWake = PowerDeviceD3;
        } else {
            capabilities->SystemWake = PowerSystemUnspecified;
            capabilities->DeviceWake = PowerDeviceUnspecified;
        }

        capabilities->D1Latency = busCapabilities->D1Latency;
        capabilities->D2Latency = busCapabilities->D2Latency;
        capabilities->D3Latency = busCapabilities->D3Latency;
    } else {
        capabilities->DeviceState[PowerSystemWorking]   = PowerDeviceD0;
        capabilities->DeviceState[PowerSystemSleeping1] = PowerDeviceD3;
        capabilities->DeviceState[PowerSystemSleeping2] = PowerDeviceD3;
        capabilities->DeviceState[PowerSystemSleeping3] = PowerDeviceD3;
        capabilities->DeviceState[PowerSystemHibernate] = PowerDeviceD3;
        capabilities->DeviceState[PowerSystemShutdown] = PowerDeviceD3;

        capabilities->SystemWake = PowerSystemUnspecified;
        capabilities->DeviceWake = PowerDeviceUnspecified;
        capabilities->D1Latency = 0;      // No latency - since we do nothing
        capabilities->D2Latency = 0;      //
        capabilities->D3Latency = 100;
    }
    //
    // Store these capabilities away..
    //

    RtlCopyMemory(&pdoExtension->DeviceCapabilities,
                  capabilities,
                  sizeof(DEVICE_CAPABILITIES));

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\ricoh.c ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    ricoh.c

Abstract:

    This module contains the code that contains
    Ricoh cardbus controller specific initialization and
    other dispatches

Author:

    Ravisankar Pudipeddi (ravisp) 1-Nov-97


Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"



VOID
RicohInitialize(IN PFDO_EXTENSION FdoExtension)
/*++

Routine Description:

     Initialize Ricoh cardbus controllers

Arguments:

     FdoExtension - Pointer to the device extension for the controller FDO

Return Value:

     None
--*/
{
    USHORT word;
    UCHAR revisionID;

    //LATER: Remove this IF statement, it was added for paranoia once the other
    // Ricoh controllers were added at the last minute.
    if (FdoExtension->ControllerType == PcmciaRL5C466) {
    GetPciConfigSpace(FdoExtension, CFGSPACE_RICOH_IF16_CTRL, &word, 2);
    word |= IF16_LEGACY_LEVEL_1 | IF16_LEGACY_LEVEL_2;
    SetPciConfigSpace(FdoExtension, CFGSPACE_RICOH_IF16_CTRL, &word, 2);
    }
#ifdef HACK_RICOH
    PcicWriteSocket(FdoExtension->SocketList, PCIC_CARD_INT_CONFIG, 0x08);
#endif

    GetPciConfigSpace(FdoExtension, CFGSPACE_REV_ID, &revisionID, 1);

    if (((FdoExtension->ControllerType == PcmciaRL5C475) && (revisionID >= 0x80) && (revisionID <= 0x9f)) ||
         ((FdoExtension->ControllerType == PcmciaRL5C476) && (revisionID >= 0x80)) ) {

        //
        // Hack to make sure NICs work ok (information is from Intel)
        // (revision of original hack is from Ricoh)
        //
        // What this does:
        // The power save feature of the Ricoh controllers enables the switching off of
        // portions of the clock domain during certain times when, during design, it
        // appeared that this reduce power consumption of the overall device.  However,
        // when this feature is enabled, timing between the PCI Request, Grant, and Frame
        // control signals is made more stringent such that the controller becomes
        // incompatible with some devices that fully support the PCI specification.
        // The additional current consumed by the controller when the power save feature
        // is disabled is small, on the order of a few milliamps.
        //

        ULONG dword;
        ULONG org_value;

        GetPciConfigSpace(FdoExtension, 0x8C, &org_value, 4);
        org_value &= 0xFF0000FF;

        dword = 0xAA5500;
        SetPciConfigSpace(FdoExtension, 0x8C, &dword, 4);

        dword = org_value | 0x30AA5500;
        SetPciConfigSpace(FdoExtension, 0x8C, &dword, 4);

        dword = org_value | 0x30000000;
        SetPciConfigSpace(FdoExtension, 0x8C, &dword, 4);
    }

    //
    // initialize IRQ routing to ISA
    //

    GetPciConfigSpace(FdoExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
    word |= BCTRL_IRQROUTING_ENABLE;
    SetPciConfigSpace(FdoExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
}


BOOLEAN
RicohSetZV(
    IN PSOCKET Socket,
    IN BOOLEAN Enable
    )
{
    UCHAR bData;

    if (Enable) {

        bData = PcicReadSocket(Socket, PCIC_RICOH_MISC_CTRL1);
        bData |= RICOH_MC1_ZV_ENABLE;
        PcicWriteSocket(Socket, PCIC_RICOH_MISC_CTRL1, bData);

    } else {

        bData = PcicReadSocket(Socket, PCIC_RICOH_MISC_CTRL1);
        bData &= ~RICOH_MC1_ZV_ENABLE;
        PcicWriteSocket(Socket, PCIC_RICOH_MISC_CTRL1, bData);

    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\pdopower.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    pdopower.c

Abstract:

    This module contains code to handle
    IRP_MJ_POWER dispatches for PDOs
    enumerated by the PCMCIA bus driver


Authors:

    Ravisankar Pudipeddi (ravisp) May 30, 1997
    Neil Sandlin (neilsa) June 1 1999

Environment:

    Kernel mode only

Notes:

Revision History:

    Neil Sandlin (neilsa) 04-Mar-1999
        Made device power a state machine

--*/

#include "pch.h"

//
// Internal References
//

NTSTATUS
PcmciaPdoWaitWake(
    IN  PDEVICE_OBJECT Pdo,
    IN  PIRP           Irp,
    OUT BOOLEAN        *CompleteIrp
    );

VOID
PcmciaPdoWaitWakeCancelRoutine(
    IN PDEVICE_OBJECT Pdo,
    IN OUT PIRP Irp
    );

NTSTATUS
PcmciaSetPdoPowerState(
    IN PDEVICE_OBJECT Pdo,
    IN OUT PIRP Irp
    );

NTSTATUS
PcmciaSetPdoSystemPowerState(
    IN PDEVICE_OBJECT Pdo,
    IN OUT PIRP Irp
    );

NTSTATUS
PcmciaPdoPowerWorker(
    IN PVOID          Context,
    IN NTSTATUS       DeferredStatus
    );

VOID
MoveToNextPdoPowerWorkerState(
    PPDO_EXTENSION pdoExtension
    );

NTSTATUS
PcmciaPdoPowerSentIrpComplete(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
PcmciaPdoPowerCompletion(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
PcmciaPdoCompletePowerIrp(
    IN PPDO_EXTENSION pdoExtension,
    IN PIRP Irp,
    IN NTSTATUS status
    );

//
//
//


NTSTATUS
PcmciaPdoPowerDispatch(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    )

/*++

Routine Description:

     This routine handles power requests
     for the PDOs.

Arguments:

     Pdo - pointer to the physical device object
     Irp - pointer to the io request packet

Return Value:

     status

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS         status = STATUS_INVALID_DEVICE_REQUEST;
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;

    if(IsDevicePhysicallyRemoved(pdoExtension) || IsDeviceDeleted(pdoExtension)) {
        // couldn't aquire RemoveLock - we're in the process of being removed - abort
        status = STATUS_NO_SUCH_DEVICE;
        PoStartNextPowerIrp( Irp );
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;
    }

    InterlockedIncrement(&pdoExtension->DeletionLock);


    switch (irpStack->MinorFunction) {

    case IRP_MN_SET_POWER: {
            DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x irp %08x --> IRP_MN_SET_POWER\n", Pdo, Irp));
            DebugPrint((PCMCIA_DEBUG_POWER, "                              (%s%x, context %x)\n",
                            (irpStack->Parameters.Power.Type == SystemPowerState)  ?
                            "S":
                            ((irpStack->Parameters.Power.Type == DevicePowerState) ?
                             "D" :
                             "Unknown"),
                            irpStack->Parameters.Power.State,
                            irpStack->Parameters.Power.SystemContext
                          ));

            status = PcmciaSetPdoPowerState(Pdo, Irp);
            break;
        }
    case IRP_MN_QUERY_POWER: {


            DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x irp %08x --> IRP_MN_QUERY_POWER\n", Pdo, Irp));
            DebugPrint((PCMCIA_DEBUG_POWER, "                              (%s%x, context %x)\n",
                            (irpStack->Parameters.Power.Type == SystemPowerState)  ?
                            "S":
                            ((irpStack->Parameters.Power.Type == DevicePowerState) ?
                             "D" :
                             "Unknown"),
                            irpStack->Parameters.Power.State,
                            irpStack->Parameters.Power.SystemContext
                          ));

            status = PcmciaPdoCompletePowerIrp(pdoExtension, Irp, STATUS_SUCCESS);
            break;
        }

    case IRP_MN_WAIT_WAKE: {

            BOOLEAN completeIrp;

            DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x irp %08x --> IRP_MN_WAIT_WAKE\n", Pdo, Irp));
            //
            // Should not have a wake pending already
            //
            ASSERT (!(((PPDO_EXTENSION)Pdo->DeviceExtension)->Flags & PCMCIA_DEVICE_WAKE_PENDING));

            status = PcmciaPdoWaitWake(Pdo, Irp, &completeIrp);

            if (completeIrp) {
                InterlockedDecrement(&pdoExtension->DeletionLock);
                PoStartNextPowerIrp(Irp);
                Irp->IoStatus.Status = status;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
            break;
        }

    default: {
        //
        // Unhandled minor function
        //
        status = PcmciaPdoCompletePowerIrp(pdoExtension, Irp, Irp->IoStatus.Status);
        }
    }

    DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x irp %08x <-- %08x\n", Pdo, Irp, status));
    return status;
}



NTSTATUS
PcmciaPdoWaitWake(
    IN  PDEVICE_OBJECT Pdo,
    IN  PIRP             Irp,
    OUT BOOLEAN         *CompleteIrp
    )
/*++


Routine Description

    Handles WAIT_WAKE for the given pc-card.

Arguments

    Pdo - Pointer to the device object for the pc-card
    Irp - The IRP_MN_WAIT_WAKE Irp
    CompleteIrp - This routine will set this to TRUE if the IRP should be
                      completed after this is called and FALSE if it should not be
                      touched

Return Value

    STATUS_PENDING  - Wait wake is pending
    STATUS_SUCCESS  - Wake is already asserted, wait wake IRP is completed
                              in this case
    Any other status    - Error
--*/
{

    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
    PSOCKET socket = pdoExtension->Socket;
    PFDO_EXTENSION fdoExtension = socket->DeviceExtension;
    NTSTATUS        status;

    *CompleteIrp = FALSE;

    ASSERT (socket != NULL);

    if ((pdoExtension->DeviceCapabilities.DeviceWake == PowerDeviceUnspecified) ||
         (pdoExtension->DeviceCapabilities.DeviceWake < pdoExtension->DevicePowerState)) {
        //
        // Either we don't support wake at all OR the current device power state
        // of the PC-Card doesn't support wake
        //
        return STATUS_INVALID_DEVICE_STATE;
    }

    if (pdoExtension->Flags & PCMCIA_DEVICE_WAKE_PENDING) {
        //
        // A WAKE is already pending
        //
        return STATUS_DEVICE_BUSY;
    }

    status = PcmciaFdoArmForWake(socket->DeviceExtension);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //for the time being, expect STATUS_PENDING from FdoArmForWake
    ASSERT(status == STATUS_PENDING);

    //
    // Parent has one (more) waiter..
    //
    InterlockedIncrement(&fdoExtension->ChildWaitWakeCount);
    //for testing, make sure there is only one waiter
    ASSERT (fdoExtension->ChildWaitWakeCount == 1);


    pdoExtension->WaitWakeIrp = Irp;
    pdoExtension->Flags |= PCMCIA_DEVICE_WAKE_PENDING;

    //
    // Set Ring enable/cstschg for the card here..
    //
    (*socket->SocketFnPtr->PCBEnableDisableWakeupEvent)(socket, pdoExtension, TRUE);

    //
    // PCI currently does not do anything with a WW irp for a cardbus PDO. So we hack around
    // this here by not passing the irp down. Instead it is held pending here, so we can
    // set a cancel routine just like the read PDO driver would. If PCI were to do something
    // with the irp, we could code something like the following:
    //
    // if (IsCardBusCard(pdoExtension)) {
    //  IoSetCompletionRoutine(Irp, PcmciaPdoWaitWakeCompletion, pdoExtension,TRUE,TRUE,TRUE);
    //  IoCopyCurrentIrpStackLocationToNext(Irp);
    //  status = IoCallDriver (pdoExtension->LowerDevice, Irp);
    //  ASSERT (status == STATUS_PENDING);
    //  return status;
    // }


    IoMarkIrpPending(Irp);

    //
    // Allow IRP to be cancelled..
    //
    IoSetCancelRoutine(Irp, PcmciaPdoWaitWakeCancelRoutine);

    IoSetCompletionRoutine(Irp,
                           PcmciaPdoWaitWakeCompletion,
                           pdoExtension,
                           TRUE,
                           TRUE,
                           TRUE);

    return STATUS_PENDING;
}



NTSTATUS
PcmciaPdoWaitWakeCompletion(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP             Irp,
    IN PPDO_EXTENSION PdoExtension
    )
/*++

Routine Description

    Completion routine called when a pending IRP_MN_WAIT_WAKE Irp completes

Arguments

    Pdo  -  Pointer to the physical device object for the pc-card
    Irp  -  Pointer to the wait wake IRP
    PdoExtension - Pointer to the device extension for the Pdo

Return Value

    Status from the IRP

--*/
{
    PSOCKET socket = PdoExtension->Socket;
    PFDO_EXTENSION fdoExtension = socket->DeviceExtension;

    DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x irp %08x --> WaitWakeCompletion\n", Pdo, Irp));

    ASSERT (PdoExtension->Flags & PCMCIA_DEVICE_WAKE_PENDING);

    PdoExtension->Flags &= ~PCMCIA_DEVICE_WAKE_PENDING;
    PdoExtension->WaitWakeIrp = NULL;
    //
    // Reset ring enable/cstschg
    //

    (*socket->SocketFnPtr->PCBEnableDisableWakeupEvent)(socket, PdoExtension, FALSE);

    ASSERT (fdoExtension->ChildWaitWakeCount > 0);
    InterlockedDecrement(&fdoExtension->ChildWaitWakeCount);
    //
    // Wake completed
    //

    InterlockedDecrement(&PdoExtension->DeletionLock);
    return Irp->IoStatus.Status;
}



VOID
PcmciaPdoWaitWakeCancelRoutine(
    IN PDEVICE_OBJECT Pdo,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

     Cancel an outstanding (pending) WAIT_WAKE Irp.
     Note: The CancelSpinLock is held on entry

Arguments:

     Pdo        -   Pointer to the physical device object for the pc-card
                    on which the WAKE is pending
     Irp        -   Pointer to the WAIT_WAKE Irp to be cancelled

Return Value

     None

--*/
{
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
    PSOCKET         socket = pdoExtension->Socket;
    PFDO_EXTENSION fdoExtension = socket->DeviceExtension;

    DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x irp %08x --> WaitWakeCancelRoutine\n", Pdo, Irp));

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    if (pdoExtension->WaitWakeIrp == NULL) {
        //
        //  Wait wake already completed/cancelled
        //
        return;
    }

    pdoExtension->Flags &= ~PCMCIA_DEVICE_WAKE_PENDING;
    pdoExtension->WaitWakeIrp = NULL;

    //
    // Reset ring enable, disabling wake..
    //
    (*socket->SocketFnPtr->PCBEnableDisableWakeupEvent)(socket, pdoExtension, FALSE);

    //
    // Since this is cancelled, see if parent's wait wake
    // needs to be cancelled too.
    // First, decrement the number of child waiters..
    //

    ASSERT (fdoExtension->ChildWaitWakeCount > 0);
    if (InterlockedDecrement(&fdoExtension->ChildWaitWakeCount) == 0) {
        //
        // No more waiters.. cancel the parent's wake IRP
        //
        ASSERT(fdoExtension->WaitWakeIrp);

        if (fdoExtension->WaitWakeIrp) {
            IoCancelIrp(fdoExtension->WaitWakeIrp);
        }
    }


    InterlockedDecrement(&pdoExtension->DeletionLock);
    //
    // Complete the IRP
    //
    Irp->IoStatus.Information = 0;

    //
    // Is this necessary?
    //
    PoStartNextPowerIrp(Irp);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}



NTSTATUS
PcmciaSetPdoPowerState(
    IN PDEVICE_OBJECT Pdo,
    IN OUT PIRP Irp
    )

/*++

Routine Description

    Dispatches the IRP based on whether a system power state
    or device power state transition is requested

Arguments

    Pdo     - Pointer to the physical device object for the pc-card
    Irp     - Pointer to the Irp for the power dispatch

Return value

    status

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PPDO_EXTENSION   pdoExtension = Pdo->DeviceExtension;
    PSOCKET              socket = pdoExtension->Socket;
    PFDO_EXTENSION   fdoExtension=socket->DeviceExtension;
    NTSTATUS status;

    PCMCIA_ACQUIRE_DEVICE_LOCK(fdoExtension);

    //
    // Don't handle any power requests for dead pdos
    //
    if (IsSocketFlagSet(socket, SOCKET_CARD_STATUS_CHANGE)) {
          PCMCIA_RELEASE_DEVICE_LOCK(fdoExtension);
          //
          // Card probably removed..
          //

          InterlockedDecrement(&pdoExtension->DeletionLock);
          status = STATUS_NO_SUCH_DEVICE;
          Irp->IoStatus.Status = status;
          DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x irp %08x comp %08x\n", Pdo, Irp, status));
          PoStartNextPowerIrp(Irp);
          IoCompleteRequest(Irp, IO_NO_INCREMENT);

          return status;
    }

    PCMCIA_RELEASE_DEVICE_LOCK(fdoExtension);


    switch (irpStack->Parameters.Power.Type) {

    case DevicePowerState:

        PCMCIA_ACQUIRE_DEVICE_LOCK(fdoExtension);

        if (fdoExtension->DevicePowerState != PowerDeviceD0) {

            IoMarkIrpPending(Irp);
            status = STATUS_PENDING;
            InsertTailList(&fdoExtension->PdoPowerRetryList,
                           (PLIST_ENTRY) Irp->Tail.Overlay.DriverContext);

            PCMCIA_RELEASE_DEVICE_LOCK(fdoExtension);
        } else {
            PCMCIA_RELEASE_DEVICE_LOCK(fdoExtension);

            status = PcmciaSetPdoDevicePowerState(Pdo, Irp);
        }
        break;

    case SystemPowerState:
        status = PcmciaSetPdoSystemPowerState(Pdo, Irp);
        break;

    default:
        status = PcmciaPdoCompletePowerIrp(pdoExtension, Irp, Irp->IoStatus.Status);
    }

    return status;
}



NTSTATUS
PcmciaSetPdoDevicePowerState(
    IN PDEVICE_OBJECT Pdo,
    IN OUT PIRP Irp
    )
/*++

Routine Description

    Handles the device power state transition for the given pc-card.
    If the state corresponds to a power-up, the parent for this pc-card
    is requested to be powered up first. Similarily if this is a power-down
    the parent is notified so that it may power down if all the children
    are powered down.

Arguments

    Pdo     - Pointer to the physical device object for the pc-card
    Irp     - Irp for the system state transition

Return value

    status

--*/
{
    PPDO_EXTENSION  pdoExtension = Pdo->DeviceExtension;
    PSOCKET          socket       = pdoExtension->Socket;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    DEVICE_POWER_STATE  newDevicePowerState;
    NTSTATUS status;
    BOOLEAN setPowerRequest;

    newDevicePowerState = irpStack->Parameters.Power.State.DeviceState;

    DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x transitioning D state %d => %d\n",
                                                 Pdo, pdoExtension->DevicePowerState, newDevicePowerState));

    setPowerRequest = FALSE;

    if (newDevicePowerState == PowerDeviceD0 ||
         newDevicePowerState == PowerDeviceD1 ||
         newDevicePowerState == PowerDeviceD2) {

        if (pdoExtension->DevicePowerState == PowerDeviceD3) {
            // D3 --> D0, D1 or D2 .. Wake up
            setPowerRequest = TRUE;
            SetDeviceFlag(pdoExtension, PCMCIA_POWER_WORKER_POWERUP);
        } else {
            //
            // Nothing to do here...
            //

        }
    } else {  /* newDevicePowerState == D3 */
        if (pdoExtension->DevicePowerState != PowerDeviceD3) {
            //
            // We need to power down now.
            //
            setPowerRequest=TRUE;
            ResetDeviceFlag(pdoExtension, PCMCIA_POWER_WORKER_POWERUP);
        }

    }

    if (setPowerRequest) {
        if (pdoExtension->DevicePowerState == PowerDeviceD0) {
            //
            // Getting out of D0 -  Call PoSetPowerState first
            //
            POWER_STATE newPowerState;

            newPowerState.DeviceState = newDevicePowerState;

            PoSetPowerState(Pdo,
                            DevicePowerState,
                            newPowerState);
        }

        ASSERT(pdoExtension->PowerWorkerState == PPW_Stopped);
        pdoExtension->PowerWorkerState = PPW_InitialState;
        pdoExtension->PendingPowerIrp = Irp;

        status = PcmciaPdoPowerWorker(pdoExtension, STATUS_SUCCESS);

    } else {
        status = PcmciaPdoCompletePowerIrp(pdoExtension, Irp, STATUS_SUCCESS);
    }
    return status;
}



NTSTATUS
PcmciaPdoPowerWorker(
    IN PVOID Context,
    IN NTSTATUS status
    )
/*++

Routine Description

    State machine for executing the requested DevicePowerState change.

Arguments

    Context         - pdoExtension for the device
    DeferredStatus - status from last deferred operation

Return Value

    status

--*/
{
    PPDO_EXTENSION pdoExtension = Context;
    PSOCKET socket = pdoExtension->Socket;
    PIRP Irp;
    UCHAR CurrentState = pdoExtension->PowerWorkerState;
    ULONG DelayTime = 0;

    DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x power worker - %s\n", pdoExtension->DeviceObject,
                                                PDO_POWER_WORKER_STRING(CurrentState)));

    MoveToNextPdoPowerWorkerState(pdoExtension);

    if (!NT_SUCCESS(status)) {
        //
        // An error occurred previously. Skip to the end of the sequence
        //
        while((CurrentState != PPW_Exit) && (CurrentState != PPW_Stopped)) {
            CurrentState = pdoExtension->PowerWorkerState;
            MoveToNextPdoPowerWorkerState(pdoExtension);
        }
    }

    switch(CurrentState) {


    case PPW_InitialState:
        status = STATUS_SUCCESS;
        break;


    //
    // R2 card states
    //

    case PPW_PowerUp:
        status = PcmciaRequestSocketPower(pdoExtension, PcmciaPdoPowerWorker);
        break;


    case PPW_PowerDown:
        if (0 == (pdoExtension->Flags & PCMCIA_DEVICE_WAKE_PENDING)) {
            status = PcmciaReleaseSocketPower(pdoExtension, PcmciaPdoPowerWorker);
        }
        break;


    case PPW_16BitConfigure:

        if (IsDeviceStarted(pdoExtension)) {

            status = PcmciaConfigurePcCard(pdoExtension, PcmciaPdoPowerWorker);
            DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x 16bit configure returns %08x\n", pdoExtension->DeviceObject, status));

        }
        break;


    //
    // Cardbus card states
    //

    case PPW_CardBusRefresh:
        //
        // Make sure the cardbus card is really working
        //
        status = PcmciaConfigureCardBusCard(pdoExtension);

        if (NT_SUCCESS(status) && pdoExtension->WaitWakeIrp) {
            //
            // Make sure stuff like PME_EN is on
            //
            (*socket->SocketFnPtr->PCBEnableDisableWakeupEvent)(socket, pdoExtension, TRUE);
        }
        break;


    case PPW_SendIrpDown:
        //
        // We're going to send the IRP down. Set completion routine
        // and copy the stack
        //
        if ((Irp=pdoExtension->PendingPowerIrp)!=NULL) {
            IoMarkIrpPending(Irp);
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp,
                                   PcmciaPdoPowerSentIrpComplete,
                                   pdoExtension,
                                   TRUE, TRUE, TRUE);

            status = PoCallDriver(pdoExtension->LowerDevice, Irp);
            DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x irp %08x sent irp returns %08x\n", pdoExtension->DeviceObject, Irp, status));
            ASSERT(NT_SUCCESS(status));
            status = STATUS_PENDING;
        }
        break;


    case PPW_CardBusDelay:
        //
        // Make sure the cardbus card is really working
        //
        {
            UCHAR           BaseClass;
            GetPciConfigSpace(pdoExtension, CFGSPACE_CLASSCODE_BASECLASS, &BaseClass, 1)
            if (BaseClass == PCI_CLASS_SIMPLE_COMMS_CTLR) {
                //
                // Wait for modem to warm up
                //
                DelayTime = PCMCIA_CB_MODEM_READY_DELAY;
            }
        }
        break;


    case PPW_Exit:
        if ((Irp=pdoExtension->PendingPowerIrp)!=NULL) {
            //
            // This is the IRP (for the pdo) that originally caused us to power up the parent
            // Complete it now
            //

            if (NT_SUCCESS(status)) {
                PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
                BOOLEAN callPoSetPowerState;

                callPoSetPowerState = TRUE;

                Irp->IoStatus.Information = irpStack->Parameters.Power.State.DeviceState;

                if (irpStack->Parameters.Power.Type == DevicePowerState) {

                    if (pdoExtension->DevicePowerState == PowerDeviceD0) {
                        //
                        // PoSetPowerState is called before we power down
                        //
                        callPoSetPowerState = FALSE;
                    }

                    if (pdoExtension->DevicePowerState != irpStack->Parameters.Power.State.DeviceState) {

                        DebugPrint ((PCMCIA_DEBUG_POWER, "pdo %08x irp %08x transition D state complete: %d => %d\n",
                                         pdoExtension->DeviceObject, Irp, pdoExtension->DevicePowerState, irpStack->Parameters.Power.State.DeviceState));

                        pdoExtension->DevicePowerState = (SYSTEM_POWER_STATE)Irp->IoStatus.Information;
                    }
                }

                if (callPoSetPowerState) {
                    //
                    // we didn't get out of device D0 state. calling PoSetPowerState now
                    //
                    PoSetPowerState(
                                    pdoExtension->DeviceObject,
                                    irpStack->Parameters.Power.Type,
                                    irpStack->Parameters.Power.State
                                    );
                }

            } else {

                DebugPrint ((PCMCIA_DEBUG_FAIL,"PDO Ext 0x%x failed power Irp 0x%x. status = 0x%x\n", pdoExtension, Irp, status));

                if (status == STATUS_NO_SUCH_DEVICE) {
                    PFDO_EXTENSION fdoExtension=socket->DeviceExtension;

                    SetSocketFlag(socket, SOCKET_CARD_STATUS_CHANGE);
                    IoInvalidateDeviceRelations(fdoExtension->Pdo, BusRelations);
                }
            }

            //
            // Finally, complete the irp
            //

            pdoExtension->PendingPowerIrp = NULL;

            Irp->IoStatus.Status = status;
            DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x irp %08x comp %08x\n", pdoExtension->DeviceObject, Irp, Irp->IoStatus.Status));
            InterlockedDecrement(&pdoExtension->DeletionLock);
            PoStartNextPowerIrp (Irp);
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
        break;


    case PPW_Stopped:
        return status;

    default:
        ASSERT(FALSE);
    }

    if (status == STATUS_PENDING) {
        DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x power worker exit %08x\n", pdoExtension->DeviceObject, status));
        //
        // Current action calls us back
        //
        if ((Irp=pdoExtension->PendingPowerIrp)!=NULL) {
            IoMarkIrpPending(Irp);
        }
        return status;
    }
    //
    // Not done yet. Recurse or call timer
    //

    if (DelayTime) {

        DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x power worker delay type %s, %d usec\n", pdoExtension->DeviceObject,
                                                                (KeGetCurrentIrql() < DISPATCH_LEVEL) ? "Wait" : "Timer",
                                                                DelayTime));

        if (KeGetCurrentIrql() < DISPATCH_LEVEL) {
            PcmciaWait(DelayTime);
        } else {
            LARGE_INTEGER   dueTime;
            //
            // Running on a DPC, kick of a kernel timer
            //

            pdoExtension->PowerWorkerDpcStatus = status;
            dueTime.QuadPart = -((LONG) DelayTime*10);
            KeSetTimer(&pdoExtension->PowerWorkerTimer, dueTime, &pdoExtension->PowerWorkerDpc);

            //
            // We will reenter on timer dpc
            //
            if ((Irp=pdoExtension->PendingPowerIrp)!=NULL) {
                IoMarkIrpPending(Irp);
            }
            return STATUS_PENDING;
        }
    }
    //
    // recurse
    //
    return (PcmciaPdoPowerWorker(pdoExtension, status));
}



NTSTATUS
PcmciaPdoPowerSentIrpComplete(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++

Routine Description

     This is the completion routine for the device power IRPs sent
     by PCMCIA to the underlying PCI PDO for cardbus cards.
     All this does currently is return STATUS_MORE_PROCESSING_REQUIRED
     to indicate that we'll complete the Irp later.

Arguments

     Pdo         - Pointer to device object for the cardbus card
     Irp         - Pointer to the IRP
     Context  - Unreferenced

Return Value

     STATUS_MORE_PROCESSING_REQUIRED

--*/
{
    PPDO_EXTENSION pdoExtension = Context;

#if !(DBG)
    UNREFERENCED_PARAMETER (Pdo);
#endif

    DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x irp %08x sent irp complete %08x\n", Pdo, Irp, Irp->IoStatus.Status));

    pdoExtension->PowerWorkerDpcStatus = Irp->IoStatus.Status;

    KeInsertQueueDpc(&pdoExtension->PowerWorkerDpc, NULL, NULL);

    return STATUS_MORE_PROCESSING_REQUIRED;

}



VOID
PcmciaPdoPowerWorkerDpc(
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description

     This is the completion routine for socket power requests coming
     from the PdoPowerWorker.

Arguments


Return Value


--*/
{
    PPDO_EXTENSION pdoExtension = Context;
    NTSTATUS status;
    DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x pdo power worker dpc\n", pdoExtension->DeviceObject));

    status = PcmciaPdoPowerWorker(pdoExtension, pdoExtension->PowerWorkerDpcStatus);

    DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x pdo power worker dpc exit %08x\n", pdoExtension->DeviceObject, status));
}



VOID
MoveToNextPdoPowerWorkerState(
    PPDO_EXTENSION pdoExtension
    )
/*++

Routine Description

    State machine for executing the requested DevicePowerState change.

Arguments

    Context         - pdoExtension for the device
    DeferredStatus - status from last deferred operation

Return Value

    status

--*/
{
    static UCHAR PowerCardBusUpSequence[]    = {PPW_CardBusRefresh,
                                                PPW_SendIrpDown,
                                                PPW_CardBusDelay,
                                                PPW_Exit,
                                                PPW_Stopped};

    static UCHAR PowerCardBusDownSequence[] = {PPW_SendIrpDown,
                                               PPW_Exit,
                                               PPW_Stopped};

    static UCHAR Power16BitUpSequence[]      = {PPW_PowerUp,
                                                PPW_16BitConfigure,
                                                PPW_Exit,
                                                PPW_Stopped};

    static UCHAR Power16BitDownSequence[]    = {PPW_PowerDown,
                                                PPW_Exit,
                                                PPW_Stopped};

    if (pdoExtension->PowerWorkerState == PPW_InitialState) {
        //
        // Initialize sequence and phase
        //
        pdoExtension->PowerWorkerPhase = 0;

        pdoExtension->PowerWorkerSequence =
                              IsCardBusCard(pdoExtension) ?
                                  (IsDeviceFlagSet(pdoExtension, PCMCIA_POWER_WORKER_POWERUP) ?
                                      PowerCardBusUpSequence : PowerCardBusDownSequence)
                                                                    :
                                  (IsDeviceFlagSet(pdoExtension, PCMCIA_POWER_WORKER_POWERUP) ?
                                      Power16BitUpSequence   : Power16BitDownSequence);
    }

    //
    // The next state is pointed to by the current phase
    //
    pdoExtension->PowerWorkerState =
        pdoExtension->PowerWorkerSequence[ pdoExtension->PowerWorkerPhase ];

    //
    // Increment the phase, but not past the end of the sequence
    //
    if (pdoExtension->PowerWorkerState != PPW_Stopped) {
        pdoExtension->PowerWorkerPhase++;
    }
}



NTSTATUS
PcmciaSetPdoSystemPowerState(
    IN PDEVICE_OBJECT Pdo,
    IN OUT PIRP Irp
    )
/*++

Routine Description

    Handles the system power state transition for the given pc-card.

Arguments

    Pdo     - Pointer to the physical device object for the pc-card
    Irp     - Irp for the system state transition

Return value

    status

--*/
{
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    SYSTEM_POWER_STATE  systemPowerState;


    systemPowerState = irpStack->Parameters.Power.State.SystemState;
    DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x transitioning S state %d => %d\n",
                    Pdo, pdoExtension->SystemPowerState, systemPowerState));

    pdoExtension->SystemPowerState = systemPowerState;
    //
    // We are done.
    //
    return PcmciaPdoCompletePowerIrp(pdoExtension, Irp, STATUS_SUCCESS);
}


NTSTATUS
PcmciaPdoCompletePowerIrp(
    IN PPDO_EXTENSION pdoExtension,
    IN PIRP Irp,
    IN NTSTATUS status
    )
/*++

Routine Description

    Completion routine for the Power Irp directed to the PDO of the
    pc-card.


Arguments

    DeviceObject    -   Pointer to the PDO for the pc-card
    Irp             -   Irp that needs to be completed

Return Value

    None

--*/
{
    if (IsCardBusCard(pdoExtension)) {
        //
        // Pass irp down the stack
        //
        InterlockedDecrement(&pdoExtension->DeletionLock);
        PoStartNextPowerIrp(Irp);
        IoSkipCurrentIrpStackLocation(Irp);
        status = PoCallDriver(pdoExtension->LowerDevice, Irp);
    } else {
        //
        // Complete the irp for R2 cards
        //
        InterlockedDecrement(&pdoExtension->DeletionLock);
        Irp->IoStatus.Status = status;
        PoStartNextPowerIrp(Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\socket.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    socket.c

Abstract:

    This module contains the socket functions of the pcmcia driver

Author:

    Neil Sandlin (neilsa) 3-Mar-1999

Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"

//
// Internal References
//

VOID
PcmciaConfigurationWorkerInitialization(
    PPDO_EXTENSION  pdoExtension
    );

NTSTATUS
PcmciaConfigurePcCardMemIoWindows(
    IN PSOCKET Socket,
    IN PSOCKET_CONFIGURATION SocketConfig
    );

NTSTATUS
PcmciaConfigurePcCardIrq(
    IN PSOCKET Socket,
    IN PSOCKET_CONFIGURATION SocketConfig
    );

NTSTATUS
PcmciaConfigurePcCardRegisters(
    PPDO_EXTENSION  pdoExtension
    );

VOID
PcmciaConfigureModemHack(
    IN PSOCKET Socket,
    IN PSOCKET_CONFIGURATION SocketConfig
    );

BOOLEAN
PcmciaProcessConfigureRequest(
    IN PFDO_EXTENSION DeviceExtension,
    IN PSOCKET Socket,
    IN PCARD_REQUEST CardConfigurationRequest
    );


#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, PcmciaGetConfigData)
#endif



NTSTATUS
PcmciaRequestSocketPower(
    IN PPDO_EXTENSION PdoExtension,
    IN PPCMCIA_COMPLETION_ROUTINE PowerCompletionRoutine
    )
/*++

Routine Description:

    This routine maintains a reference count of how many devices have requested power.
    When the count increments from zero to one, a call is made to actually turn power
    on.

Arguments:

    Socket -  Pointer to the socket for which power is to be applied
    PowerCompletionRoutine - routine to be called after configuration is complete

Return value:

    status

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PSOCKET socket = PdoExtension->Socket;
    PFDO_EXTENSION fdoExtension = socket->DeviceExtension;

    DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x request power\n", socket));

    if (PCMCIA_TEST_AND_SET(&PdoExtension->SocketPowerRequested)) {

        if (InterlockedIncrement(&socket->PowerRequests) == 1) {

            DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x power requests now %d, status %08x\n", socket, socket->PowerRequests));
            status = PcmciaSetSocketPower(socket, PowerCompletionRoutine, PdoExtension, TRUE);

        }
    }
    return status;
}



NTSTATUS
PcmciaReleaseSocketPower(
    IN PPDO_EXTENSION PdoExtension,
    IN PPCMCIA_COMPLETION_ROUTINE PowerCompletionRoutine
    )
/*++

Routine Description:

    This routine maintains a reference count of how many devices have requested power.
    When the count decrements from one to zero, a call is made to actually turn power
    off.

Arguments:

    Socket -  Pointer to the socket for which power is to be removed
    PowerCompletionRoutine - routine to be called after configuration is complete

Return value:

    status

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PSOCKET socket = PdoExtension->Socket;
    PFDO_EXTENSION fdoExtension = socket->DeviceExtension;

    DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x release power\n", socket));

    if (PCMCIA_TEST_AND_RESET(&PdoExtension->SocketPowerRequested)) {

        if (InterlockedDecrement(&socket->PowerRequests) == 0) {

            DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x power requests now %d, status %08x\n", socket, socket->PowerRequests));
            //
            // Never actually turn off the drive rails for cardbus functions since
            // we don't have tight integration with pci.sys, and config space will
            // disappear
            //
            if (!IsCardBusCardInSocket(socket)) {
                status = PcmciaSetSocketPower(socket, PowerCompletionRoutine, PdoExtension, FALSE);
            }
        }

        ASSERT(socket->PowerRequests >= 0);
    }

    return status;
}



NTSTATUS
PcmciaSetSocketPower(
    IN PSOCKET Socket,
    IN PPCMCIA_COMPLETION_ROUTINE PowerCompletionRoutine,
    IN PVOID Context,
    IN BOOLEAN PowerOn
    )
/*++

Routine Description:

    This routine is entered when we know the power state of the socket will
    actually be set.

    NOTE: If this routine is called at less than DISPATCH_LEVEL, then the call
    will complete (not return STATUS_PENDING). If this routine is called at
    DISPATCH_LEVEL or greater, this routine returns STATUS_PENDING, and completes
    the power process using a KTIMER.

Arguments:

    Socket -  Pointer to the socket for which power is to be removed
    PowerCompletionRoutine - routine to be called after configuration is complete

Return value:

    status

--*/
{
    NTSTATUS status;
    PFDO_EXTENSION fdoExtension = Socket->DeviceExtension;
    SPW_STATE InitialState = PowerOn ? SPW_RequestPower : SPW_ReleasePower;

    DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x set power %s\n", Socket, PowerOn ? "ON" : "OFF"));

    if (!PCMCIA_TEST_AND_SET(&Socket->WorkerBusy)) {
        return STATUS_DEVICE_BUSY;
    }

    ASSERT(Socket->WorkerState == SPW_Stopped);

    //
    // committed, will enter SocketPowerWorker now
    //

    Socket->WorkerState = InitialState;
    Socket->PowerCompletionRoutine = PowerCompletionRoutine;
    Socket->PowerCompletionContext = Context;

    PcmciaSocketPowerWorker(&Socket->PowerDpc, Socket, NULL, NULL);

    DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x SetSocketPower returning %08x\n",
                                                 Socket, Socket->CallerStatus));
    return(Socket->CallerStatus);
}



VOID
PcmciaSocketPowerWorker(
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++
Routine Description

    This routine handles the power up process of a socket. Because such
    long delays are needed, and because this routine may be called at
    raised irql, this is a state machine that has the capability of
    calling itself on a KTIMER.

Arguments

    same as KDPC (DeferredContext is socket)

Return Value

    status

--*/
{
    PSOCKET                  Socket = Context;
    PFDO_EXTENSION fdoExtension = Socket->DeviceExtension;
    NTSTATUS                 status = Socket->DeferredStatus;
    ULONG                    DelayTime = 0;
    BOOLEAN                  ContinueExecution = TRUE;

#if DBG
    {
        ULONG Phase = 0;
        switch(Socket->WorkerState) {
        case SPW_SetPowerOn:
        case SPW_SetPowerOff:
            Phase = Socket->PowerPhase;
            break;
        }
        if (Phase) {
            DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x power worker - %s(%d)\n", Socket,
                                                    SOCKET_POWER_WORKER_STRING(Socket->WorkerState), Phase));
        } else {
            DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x power worker - %s\n", Socket,
                                                    SOCKET_POWER_WORKER_STRING(Socket->WorkerState)));
        }
    }
#endif

    //
    // Socket power state machine
    //

    switch(Socket->WorkerState) {


    case SPW_RequestPower:

        status = STATUS_SUCCESS;

        if (IsSocketFlagSet(Socket, SOCKET_CARD_POWERED_UP)) {
            Socket->WorkerState = SPW_Exit;
        } else {
            if ((KeGetCurrentIrql() >= DISPATCH_LEVEL) && (Socket->PowerCompletionRoutine == NULL)) {
                ASSERT((KeGetCurrentIrql() < DISPATCH_LEVEL) || (Socket->PowerCompletionRoutine != NULL));
                //
                // no completion routine at raised irql
                //
                status = STATUS_INVALID_PARAMETER;
            } else {
                //
                // All ok, continue to next state
                //
                Socket->PowerPhase = 1;
                Socket->WorkerState = SPW_SetPowerOn;
            }
        }

        break;


    case SPW_ReleasePower:

        status = STATUS_SUCCESS;

        if (!IsSocketFlagSet(Socket, SOCKET_CARD_POWERED_UP)) {
            Socket->WorkerState = SPW_Exit;
        } else {
            if ((KeGetCurrentIrql() >= DISPATCH_LEVEL) && (Socket->PowerCompletionRoutine == NULL)) {
                ASSERT((KeGetCurrentIrql() < DISPATCH_LEVEL) || (Socket->PowerCompletionRoutine != NULL));
                //
                // no completion routine at raised irql
                //
                status = STATUS_INVALID_PARAMETER;
            } else {
                //
                // All ok, continue to next state
                //
                Socket->WorkerState = SPW_Deconfigure;
            }
        }

        break;


    case SPW_SetPowerOn:
        //
        // Turn power ON
        //
        status = (*(DeviceDispatchTable[fdoExtension->DeviceDispatchIndex].SetPower))
                                            (Socket, TRUE, &DelayTime);

        Socket->PowerPhase++;
        if (status != STATUS_MORE_PROCESSING_REQUIRED) {
            if (NT_SUCCESS(status)) {
                //
                // Done with power up, proceed to the init sequence
                //
                SetSocketFlag(Socket, SOCKET_CARD_POWERED_UP);
                DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x power UP\n", Socket));
                Socket->WorkerState = SPW_ResetCard;
                Socket->CardResetPhase = 1;
            } else if (status == STATUS_INVALID_DEVICE_STATE) {
                //
                // Power was already on, don't reset the card
                //
                SetSocketFlag(Socket, SOCKET_CARD_POWERED_UP);
                DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x power already UP\n", Socket));
                Socket->WorkerState = SPW_Exit;
                status = STATUS_SUCCESS;
            } else {
                //
                // Power didn't go on
                //
                DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x poweron fail %08x\n", Socket, status));
                Socket->WorkerState = SPW_Exit;
            }
        }
        break;


    case SPW_ResetCard:
        //
        // Make sure the card is ready to be enumerated
        //
        status = (*(Socket->SocketFnPtr->PCBResetCard))(Socket, &DelayTime);
        Socket->CardResetPhase++;

        if (status != STATUS_MORE_PROCESSING_REQUIRED) {
            Socket->WorkerState = SPW_Exit;
        }
        break;

    case SPW_Deconfigure:
        PcmciaSocketDeconfigure(Socket);
        Socket->PowerPhase = 1;
        Socket->WorkerState = SPW_SetPowerOff;
        break;

    case SPW_SetPowerOff:
        //
        // Turn power OFF
        //
        status = (*(DeviceDispatchTable[fdoExtension->DeviceDispatchIndex].SetPower))
                                            (Socket, FALSE, &DelayTime);

        Socket->PowerPhase++;
        if (status != STATUS_MORE_PROCESSING_REQUIRED) {
            Socket->WorkerState = SPW_Exit;
            if (NT_SUCCESS(status)) {
                //
                // Power is now off
                //
                ResetSocketFlag(Socket, SOCKET_CARD_POWERED_UP);
                DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x power DOWN\n", Socket));
            } else if (status == STATUS_INVALID_DEVICE_STATE) {
                //
                // Power was already off
                //
                ResetSocketFlag(Socket, SOCKET_CARD_POWERED_UP);
                DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x power already DOWN\n", Socket));
                status = STATUS_SUCCESS;
            } else {
                //
                // Power didn't go off
                //
                DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x poweroff fail %08x\n", Socket, status));
                Socket->WorkerState = SPW_Exit;
            }
        }
        break;


    case SPW_Exit:

        if (!NT_SUCCESS(status)) {
            DebugPrint((PCMCIA_DEBUG_FAIL, "skt %08x SocketPowerWorker FAILED, status %08x\n", Socket, status));
            ASSERT(NT_SUCCESS(status));
        }

        //
        // Done. Update flags, and call the completion routine if required
        //
        if (PCMCIA_TEST_AND_RESET(&Socket->DeferredStatusLock)) {
            PPCMCIA_COMPLETION_ROUTINE PowerCompletionRoutine = Socket->PowerCompletionRoutine;
            PVOID PowerCompletionContext = Socket->PowerCompletionContext;

            Socket->WorkerState = SPW_Stopped;
            PCMCIA_TEST_AND_RESET(&Socket->WorkerBusy);

            if (PowerCompletionRoutine) {
                (*PowerCompletionRoutine)(PowerCompletionContext, status);
            } else {
                ASSERT(PowerCompletionRoutine != NULL);
            }
        } else {
            Socket->CallerStatus = status;
            Socket->WorkerState = SPW_Stopped;
            PCMCIA_TEST_AND_RESET(&Socket->WorkerBusy);
        }

        return;

    default:
        ASSERT(FALSE);
        return;
    }

    //
    // Now check the results
    //

    if (status == STATUS_PENDING) {
        DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x worker exit, status pending\n", Socket));
        //
        // whatever returned pending will call us back
        //
        if (PCMCIA_TEST_AND_SET(&Socket->DeferredStatusLock)) {
            //
            // First time that we are waiting, we will return to original
            // caller. So update the main power status just this time.
            //
            Socket->CallerStatus = STATUS_PENDING;
        }
        return;
    }

    //
    // remember for next time
    //
    Socket->DeferredStatus = status;

    if (!NT_SUCCESS(status) && (status != STATUS_MORE_PROCESSING_REQUIRED)) {
        Socket->WorkerState = SPW_Exit;
        DelayTime = 0;
    }

    //
    // Not done yet. Recurse or call timer
    //

    if (DelayTime) {

        DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x power worker delay type %s, %d usec\n", Socket,
                                                                (KeGetCurrentIrql() < DISPATCH_LEVEL) ? "Wait" : "Timer",
                                                                DelayTime));

        if ((KeGetCurrentIrql() < DISPATCH_LEVEL) && !Socket->PowerCompletionRoutine) {
            PcmciaWait(DelayTime);
        } else {
            LARGE_INTEGER   dueTime;
            //
            // Running on a DPC, kick of a kernel timer
            //
            if (PCMCIA_TEST_AND_SET(&Socket->DeferredStatusLock)) {
                //
                // First time that we are waiting, we will return to original
                // caller. So update the main power status just this time.
                //
                Socket->CallerStatus = STATUS_PENDING;
            }

            dueTime.QuadPart = -((LONG) DelayTime*10);
            KeSetTimer(&Socket->PowerTimer, dueTime, &Socket->PowerDpc);

            //
            // We will reenter on timer dpc
            //
            return;
        }
    }
    //
    // Recurse
    //
    PcmciaSocketPowerWorker(&Socket->PowerDpc, Socket, NULL, NULL);
}



VOID
PcmciaGetSocketStatus(
    IN PSOCKET Socket
    )
/*++

Routine Description:

    A small utility routine that returns some common socket flags. The reason
    it exists is to allow the Enumerate Devices routine to remain pagable.

    NOTE: This routine updates the "software view" of the device state. This
            should only be done at well-defined points in the driver. In particular,
            you do not want to be updating the software state immediately after
            a surprise remove. Instead, most of the driver needs to continue to
            believe the card is still there while it does its unconfigure and
            poweroff.

Arguments:

    Socket - The socket in which the PC-Card resides
    boolean parameters are written according to socket flags

Return Value:

    none

--*/
{
    BOOLEAN isCardInSocket, isCardBusCard;
    UCHAR previousDeviceState;

    PCMCIA_ACQUIRE_DEVICE_LOCK(Socket->DeviceExtension);

    isCardInSocket = (*(Socket->SocketFnPtr->PCBDetectCardInSocket))(Socket);

    isCardBusCard = FALSE;
    if (isCardInSocket && CardBus(Socket)) {
        isCardBusCard = ((CBReadSocketRegister(Socket, CARDBUS_SOCKET_PRESENT_STATE_REG) & CARDBUS_CB_CARD) != 0);
    }

    previousDeviceState = Socket->DeviceState;

    if (!isCardInSocket) {
        SetSocketEmpty(Socket);
    } else if (isCardBusCard) {
        SetCardBusCardInSocket(Socket);
    } else {
        Set16BitCardInSocket(Socket);
    }

    if (previousDeviceState != Socket->DeviceState) {
        DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %x Socket Status: Card Status Change!\n", Socket));
        SetSocketFlag(Socket, SOCKET_CARD_STATUS_CHANGE);
    }

    DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %x Socket Status: %s\n",
                                     Socket, isCardInSocket ? (isCardBusCard ? "INSERTED Cardbus" : "INSERTED R2") : "EMPTY"));

    PCMCIA_RELEASE_DEVICE_LOCK(Socket->DeviceExtension);

    //
    // Fill in socket power values
    //
    if (isCardInSocket && IsSocketFlagSet(Socket, SOCKET_CARD_STATUS_CHANGE) && Socket->SocketFnPtr->PCBGetPowerRequirements) {
        (*(Socket->SocketFnPtr->PCBGetPowerRequirements))(Socket);
    }

}



NTSTATUS
PcmciaGetConfigData(
    PPDO_EXTENSION PdoExtension
    )
/*++

Routine Description:

    This routine controls the translation of the CIS config data for the card into
    SOCKET_DATA structures chained onto the PDO. The action of this routine depends
    on the type of device:

    1) For a standard R2 card, a single SOCKET_DATA structure is linked to the pdo
        extension, which contains a straight translation of the CIS contents.
    2) For a fully compliant true R2 MF card, a chain of SOCKET_DATA structures is
        created, one for each function on the card.
    3) For a non-conforming R2 MF card (the typical case), a single structure is
        linked just like case #1.
    4) For a CardBus card, a single SOCKET_DATA is linked to the pdo extension. If
        there are multiple functions on the device, then there will be multiple pdo
        extensions, each with a single SOCKET_DATA structure.

Arguments:

    pdoExtension - The pdo extension corresponding to the specified pccard or cb function.

Return Value:

    STATUS_SUCCESS
    STATUS_NO_SUCH_DEVICE if no card is present in the socket (i.e. the passed in PDO is 'dead')

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PSOCKET_DATA  socketData, prevSocketData;
    PSOCKET_DATA  socketDataList = NULL;
    UCHAR         function = 0;
    PSOCKET Socket = PdoExtension->Socket;

    PAGED_CODE ();

    if (!IsCardInSocket(Socket)) {
        //
        // Card probably removed,
        // and Pdo's ghost still hanging around
        //
        return STATUS_NO_SUCH_DEVICE;
    }

    ResetSocketFlag(Socket, SOCKET_CARD_MEMORY);
    ResetSocketFlag(Socket, SOCKET_CARD_CONFIGURED);

    DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x performing GetSocketData\n", Socket));

    Socket->NumberOfFunctions = 1;
    prevSocketData = NULL;

    while (function < 255) {
        //
        // Parse tuples of  next function on the card
        //
        socketData = ExAllocatePool(NonPagedPool, sizeof(SOCKET_DATA));

        if (socketData == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        RtlZeroMemory(socketData, sizeof(SOCKET_DATA));
        socketData->Function = function;
        socketData->PdoExtension = PdoExtension;
        socketData->Socket = Socket;
        DebugPrint((PCMCIA_DEBUG_SOCKET, "Parsing function %d...\n", socketData->Function));

        status = PcmciaParseFunctionData(Socket, socketData);

        if (NT_SUCCESS(status)) {
            //
            // Link it to the list of socketdata structures
            //
            socketData->Prev = prevSocketData;
            socketData->Next = NULL;
            if (prevSocketData) {
                prevSocketData->Next = socketData;
            } else {
                //
                // This is the first function on the card
                // Make it the head of the list
                //
                socketDataList = socketData;
            }

            if (socketData->DeviceType == PCCARD_TYPE_MODEM) {
                SetDeviceFlag(PdoExtension, PCMCIA_PDO_ENABLE_AUDIO);
            }
        } else {
            //
            // no more functions on this card
            //
            ExFreePool(socketData);
            if ((function > 0) && (status == STATUS_NO_MORE_ENTRIES)) {
                status = STATUS_SUCCESS;
            }
            break;
        }
        function++;
        prevSocketData = socketData;
    }

    if (!NT_SUCCESS(status)) {

        socketData = socketDataList;

        while(socketData) {

            prevSocketData = socketData;
            socketData = socketData->Next;
            ExFreePool(prevSocketData);

        }

    } else {

        PdoExtension->SocketData = socketDataList;
    }
    return status;
}




UCHAR
PcmciaReadCISChar(
    PPDO_EXTENSION PdoExtension,
    IN MEMORY_SPACE MemorySpace,
    IN ULONG Offset
    )

/*++

Routine Description:

    Returns the card data.  This information is cached in the socket
    structure.  This way once a PCCARD is enabled it will not be touched
    due to a query ioctl.

Arguments:

    Context

Return Value:

    TRUE

--*/

{
    PSOCKET socket = PdoExtension->Socket;
    PDEVICE_OBJECT pdo;
    UCHAR retValue = 0xff;
    ULONG relativeOffset;
    ULONG bytesRead;


    if (socket && IsCardInSocket(socket)) {

        if (!PdoExtension->CisCache) {
#define PCMCIA_CIS_CACHE_SIZE 2048
            PdoExtension->CisCache = ExAllocatePool(NonPagedPool, PCMCIA_CIS_CACHE_SIZE);

            PdoExtension->CisCacheSpace = 0xff;
            PdoExtension->CisCacheBase = 0;
        }

        if (PdoExtension->CisCache) {

            if ((MemorySpace != PdoExtension->CisCacheSpace) ||
                 (Offset < PdoExtension->CisCacheBase) ||
                 (Offset > PdoExtension->CisCacheBase + PCMCIA_CIS_CACHE_SIZE - 1)) {

                //
                // LATER: If devices have CIS > CacheSize, then we should window this
                //
                bytesRead = (*(socket->SocketFnPtr->PCBReadCardMemory))(PdoExtension,
                                                                        MemorySpace,
                                                                        0,
                                                                        PdoExtension->CisCache,
                                                                        PCMCIA_CIS_CACHE_SIZE);

                PdoExtension->CisCacheSpace = MemorySpace;
            }

            relativeOffset = Offset - PdoExtension->CisCacheBase;

            if (relativeOffset < PCMCIA_CIS_CACHE_SIZE) {
                retValue = PdoExtension->CisCache[relativeOffset];
            }
        }
    }

    return retValue;
}



NTSTATUS
PcmciaReadWriteCardMemory(
    IN    PDEVICE_OBJECT Pdo,
    IN    ULONG           WhichSpace,
    IN OUT  PUCHAR        Buffer,
    IN    ULONG           Offset,
    IN    ULONG           Length,
    IN    BOOLEAN         Read
    )
/*++

Routine Description:

     This routine is to provide IRP_MN_READ_CONFIG/WRITE_CONFIG support: this would locate the
     socket on which Pdo resides and map the card's  memory into the system space.
     If Read is TRUE    it would:
        copy the contents of the config memory at a specified offset and length to  the
        caller supplied buffer.
     else
        copy the contents of the caller specified buffer at the specified offset and length of
        the config memory

      Note: this has to be non-paged since it can be called by
      clients at DISPATCH_LEVEL

Arguments:

 Pdo -           Device object representing the PC-CARD whose config memory needs to be read/written
 WhichSpace -    Indicates which memory space needs to be mapped: one of
                     PCCARD_COMMON_MEMORY_SPACE
                     PCCARD_ATTRIBUTE_MEMORY_SPACE
                     PCCARD_PCI_CONFIGURATION_MEMORY_SPACE (only for cardbus cards)


 Buffer -        Caller supplied buffer into/out of which the memory contents are copied
                     Offset -        Offset of the attribute memory at which we copy
                     Length -        Number of bytes of attribute memory/buffer to be copied

 Return value:
          STATUS_INVALID_PARAMETER_1
          STATUS_INVALID_PARAMETER_2
          STATUS_INVALID_PARAMETER_3      If supplied parameters are not valid
          STATUS_NO_SUCH_DEVICE           No PC-Card in the socket
          STATUS_DEVICE_NOT_READY         PC-Card not initialized yet or some other hardware related error
          STATUS_SUCCESS                      Contents copied as requested
--*/
{
    PSOCKET socket;
    PSOCKET_DATA socketData;
    PUCHAR tupleData;
    ULONG  tupleDataSize;
    PPDO_EXTENSION pdoExtension;
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    pdoExtension = Pdo->DeviceExtension;
    socket= pdoExtension->Socket;

    //
    // Got to have a card in the socket to read/write from it..
    //
    if (!IsCardInSocket(socket)) {
        return STATUS_NO_SUCH_DEVICE;
    }
    //
    // Memory space has to be one of the defined ones.
    //
    if ((WhichSpace != PCCARD_COMMON_MEMORY) &&
         (WhichSpace != PCCARD_ATTRIBUTE_MEMORY) &&
         (WhichSpace != PCCARD_PCI_CONFIGURATION_SPACE)) {

        return STATUS_INVALID_PARAMETER_1;
    }

    //
    // We support PCCARD_PCI_CONFIGURATION_SPACE only
    // for cardbus cards (doesn't make sense for R2 cards)
    // Similarily PCCARD_ATTRIBUTE/COMMON_MEMORY only for
    // R2 cards
    //
    if ((((WhichSpace == PCCARD_ATTRIBUTE_MEMORY) ||
            (WhichSpace == PCCARD_COMMON_MEMORY)) && !Is16BitCard(pdoExtension)) ||
         ((WhichSpace == PCCARD_PCI_CONFIGURATION_SPACE) && !IsCardBusCard(pdoExtension))) {
        return STATUS_INVALID_PARAMETER_1;
    }

    if (!Buffer) {
        return STATUS_INVALID_PARAMETER_2;
    }

    if (WhichSpace == PCCARD_PCI_CONFIGURATION_SPACE) {
        //
        // This has to be a cardbus card.
        //
        // NOTE: unimplemented: fill this in! send an IRP down to PCI
        // to get the config space
        status =  STATUS_NOT_SUPPORTED;

    } else {
        //
        // This has to be an R2 Card.
        // Attribute/common memory space
        //
        ASSERT ((WhichSpace == PCCARD_ATTRIBUTE_MEMORY) ||
                  (WhichSpace == PCCARD_COMMON_MEMORY));

        //
        // Offset and length are >= 0 because they are ULONGs,
        // so don't worry about that.
        //

        if (!IsSocketFlagSet(socket, SOCKET_CARD_POWERED_UP)) {
            return STATUS_DEVICE_NOT_READY;
        }

        PCMCIA_ACQUIRE_DEVICE_LOCK(socket->DeviceExtension);

        if (Read && (socket->SocketFnPtr->PCBReadCardMemory != NULL)) {
            //
            // Read from card memory
            //
            status = ((*(socket->SocketFnPtr->PCBReadCardMemory))(pdoExtension,
                                                                  WhichSpace,
                                                                  Offset,
                                                                  Buffer,
                                                                  Length) == Length)
                        ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;

        } else if (socket->SocketFnPtr->PCBWriteCardMemory != NULL) {
            //
            // Write to card memory
            //
            status = ((*(socket->SocketFnPtr->PCBWriteCardMemory))(pdoExtension,
                                                                   WhichSpace,
                                                                   Offset,
                                                                   Buffer,
                                                                   Length) == Length)
                        ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
        }

        PCMCIA_RELEASE_DEVICE_LOCK(socket->DeviceExtension);
    }

    return status;
}



NTSTATUS
PcmciaConfigureCardBusCard(
    PPDO_EXTENSION pdoExtension
    )
/*++

Routine Description:

    This routine does some verification, and applies hacks

Arguments:

    pdoExtension -  Pointer to the physical device object extension for the pc-card

Return value:

    status

--*/
{
    ULONG i, pciConfig;
    NTSTATUS status = STATUS_SUCCESS;
    PSOCKET Socket = pdoExtension->Socket;

    for (i = 0; i < CARDBUS_CONFIG_RETRY_COUNT; i++) {
        GetPciConfigSpace(pdoExtension, CFGSPACE_VENDOR_ID, &pciConfig, sizeof(pciConfig));
        if (pciConfig != 0xffffffff) {
            break;
        }
    }

    if (pciConfig == 0xffffffff) {
        DebugPrint((PCMCIA_DEBUG_FAIL, "pdo %08x failed to verify CardBus config space\n", pdoExtension->DeviceObject));
        status = STATUS_DEVICE_NOT_READY;
    } else {
        PFDO_EXTENSION fdoExtension = Socket->DeviceExtension;

        //
        // The TI1130, 1131, 1031 have a bug such that CAUDIO on a cardbus card
        // is gated by the following bit (which normally only has meaning only
        // for R2 cards). We can workaround the problem simply by turning it on
        // for cardbus cards.
        //
        if ((fdoExtension->ControllerType == PcmciaTI1130) ||
             (fdoExtension->ControllerType == PcmciaTI1131) ||
             (fdoExtension->ControllerType == PcmciaTI1031)) {

            UCHAR byte;

            byte = PcicReadSocket(Socket, PCIC_INTERRUPT);
            byte |= IGC_PCCARD_IO;
            PcicWriteSocket(Socket, PCIC_INTERRUPT, byte);
        }
    }
    return status;
}



NTSTATUS
PcmciaConfigurePcCard(
    PPDO_EXTENSION pdoExtension,
    IN PPCMCIA_COMPLETION_ROUTINE ConfigCompletionRoutine
    )
/*++

Routine Description:

    This routine does the brunt work of enabling the PC-Card using the supplied
    resources.

    NOTE: If this routine is called at less than DISPATCH_LEVEL, then the call
    will complete (not return STATUS_PENDING). If this routine is called at
    DISPATCH_LEVEL or greater, this routine returns STATUS_PENDING, and completes
    the configuration process using a KTIMER.

Arguments:

    pdoExtension -  Pointer to the physical device object extension for the pc-card
    ConfigCompletionRoutine - routine to be called after configuration is complete

Return value:

    status

--*/
{
    DebugPrint((PCMCIA_DEBUG_CONFIG, "pdo %08x ConfigurePcCard entered\n", pdoExtension->DeviceObject));

    if (!PCMCIA_TEST_AND_SET(&pdoExtension->Socket->WorkerBusy)) {
        return STATUS_DEVICE_BUSY;
    }

    ASSERT(pdoExtension->ConfigurationPhase == CW_Stopped);

    pdoExtension->ConfigurationPhase = CW_InitialState;
    pdoExtension->ConfigCompletionRoutine = ConfigCompletionRoutine;
    pdoExtension->ConfigurationStatus = STATUS_SUCCESS;

    PcmciaConfigurationWorker(&pdoExtension->ConfigurationDpc, pdoExtension, NULL, NULL);

    DebugPrint((PCMCIA_DEBUG_CONFIG, "pdo %08x ConfigurePcCard returning %08x\n", pdoExtension->DeviceObject, pdoExtension->ConfigurationStatus));

    return(pdoExtension->ConfigurationStatus);
}



VOID
PcmciaConfigurationWorker(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++
Routine Description

    This routine handles the configuration process of a 16-bit R2 pccard.
    Because certain cards are finicky (modems), and require gigantic pauses
    between steps, this worker routine acts as a state machine, and will
    delay after each step.

Arguments

    same as KDPC (DeferredContext is pdoExtension)

Return Value

    status

--*/
{
    PPDO_EXTENSION       pdoExtension = DeferredContext;
    PSOCKET                  Socket = pdoExtension->Socket;
    PSOCKET_CONFIGURATION SocketConfig = pdoExtension->SocketConfiguration;
    NTSTATUS                 status = pdoExtension->DeferredConfigurationStatus;
    ULONG                    DelayUsec = 0;

    DebugPrint((PCMCIA_DEBUG_CONFIG, "pdo %08x config worker - %s\n", pdoExtension->DeviceObject,
                                                CONFIGURATION_WORKER_STRING(pdoExtension->ConfigurationPhase)));

    switch(pdoExtension->ConfigurationPhase) {

    case CW_InitialState:

        if (IsSocketFlagSet(pdoExtension->Socket, SOCKET_CARD_CONFIGURED)) {
            pdoExtension->ConfigurationPhase = CW_Exit;
            break;
        }
        if (!IsCardInSocket(pdoExtension->Socket)) {
            status = STATUS_NO_SUCH_DEVICE;
            pdoExtension->ConfigurationPhase = CW_Exit;
            break;
        }

        pdoExtension->ConfigurationPhase = CW_ResetCard;
        Socket->CardResetPhase = 1;
        break;

    case CW_ResetCard:
        //
        // Reset the card
        //
        status = (*(Socket->SocketFnPtr->PCBResetCard))(Socket, &DelayUsec);
        Socket->CardResetPhase++;

        if (status != STATUS_MORE_PROCESSING_REQUIRED) {
            pdoExtension->ConfigurationPhase = CW_Phase1;
        }
        break;

    case CW_Phase1:
        //
        // Initialize variables
        //
        PcmciaConfigurationWorkerInitialization(pdoExtension);
        //
        // Configure the cards configuration registers, and the socket mem
        // and I/O windows
        //
        status = PcmciaConfigurePcCardRegisters(pdoExtension);
        if (NT_SUCCESS(status)) {
            status = PcmciaConfigurePcCardMemIoWindows(Socket, SocketConfig);
        }
        DelayUsec = 1000 * (ULONG)pdoExtension->ConfigureDelay1;
        pdoExtension->ConfigurationPhase = CW_Phase2;
        break;

    case CW_Phase2:
        //
        // Take this opportunity to "poke" the modem
        //
        if (pdoExtension->ConfigurationFlags & CONFIG_WORKER_APPLY_MODEM_HACK) {
            PcmciaConfigureModemHack(Socket, SocketConfig);
        }
        DelayUsec = 1000 * (ULONG)pdoExtension->ConfigureDelay2;
        pdoExtension->ConfigurationPhase = CW_Phase3;
        break;

    case CW_Phase3:
        //
        // Configure the IRQ
        //
        status = PcmciaConfigurePcCardIrq(Socket, SocketConfig);

        DelayUsec = 1000 * (ULONG)pdoExtension->ConfigureDelay3;
        pdoExtension->ConfigurationPhase = CW_Exit;
        break;

    case CW_Exit:
        //
        // Done. Update flags, and call the completion routine if required
        //
        if (IsDeviceFlagSet(pdoExtension, PCMCIA_CONFIG_STATUS_DEFERRED)) {
            if (pdoExtension->ConfigCompletionRoutine) {
                (*pdoExtension->ConfigCompletionRoutine)(pdoExtension,
                                                         pdoExtension->DeferredConfigurationStatus);
            }
            ResetDeviceFlag(pdoExtension, PCMCIA_CONFIG_STATUS_DEFERRED);
        } else {
            pdoExtension->ConfigurationStatus = status;
        }

        if (NT_SUCCESS(status)) {
            SetSocketFlag(Socket, SOCKET_CARD_CONFIGURED);
        }
        pdoExtension->ConfigurationPhase = CW_Stopped;
        PCMCIA_TEST_AND_RESET(&Socket->WorkerBusy);

        DebugPrint((PCMCIA_DEBUG_CONFIG, "pdo %08x config worker exit %08x\n", pdoExtension->DeviceObject, status));
        return;

    default:
        ASSERT(FALSE);
        return;
    }

    pdoExtension->DeferredConfigurationStatus = status;

    if (!NT_SUCCESS(status) && (status != STATUS_MORE_PROCESSING_REQUIRED)) {
        DelayUsec = 0;
        pdoExtension->ConfigurationPhase = CW_Exit;
    }

    //
    // Not done yet. Recurse or call timer
    //

    if (DelayUsec) {

        DebugPrint((PCMCIA_DEBUG_CONFIG, "pdo %08x config worker delay type %s, %d usec\n",
                                                   pdoExtension->DeviceObject,
                                                   (KeGetCurrentIrql() < DISPATCH_LEVEL) ? "Wait" : "Timer",
                                                   DelayUsec));

        if (KeGetCurrentIrql() < DISPATCH_LEVEL) {
            PcmciaWait(DelayUsec);
        } else {
            LARGE_INTEGER   dueTime;
            dueTime.QuadPart = -((LONG) DelayUsec*10);
            //
            // Running on a DPC, kick of a kernel timer
            //
            KeSetTimer(&pdoExtension->ConfigurationTimer,
                          dueTime,
                          &pdoExtension->ConfigurationDpc);

            if (!IsDeviceFlagSet(pdoExtension, PCMCIA_CONFIG_STATUS_DEFERRED)) {
                SetDeviceFlag(pdoExtension, PCMCIA_CONFIG_STATUS_DEFERRED);
                pdoExtension->ConfigurationStatus = STATUS_PENDING;
            }
            return;
        }
    }

    PcmciaConfigurationWorker(&pdoExtension->ConfigurationDpc, pdoExtension, NULL, NULL);
}


VOID
PcmciaConfigurationWorkerInitialization(
    PPDO_EXTENSION  pdoExtension
    )
/*++

Routine Description:

     This routine sets variables which control the configuration process.

Arguments:

    pdoExtension -  Pointer to the physical device object extension for the pc-card

Return value:

    none

--*/
{
    PSOCKET_DATA socketData = pdoExtension->SocketData;
    ULONG i;

    pdoExtension->ConfigurationFlags = 0;
    pdoExtension->ConfigureDelay1 = 0;
    pdoExtension->ConfigureDelay2 = 0;
    pdoExtension->ConfigureDelay3 = 0;

    while (socketData) {

        i = 0;
        while (DeviceConfigParams[i].ValidEntry) {

            if (((DeviceConfigParams[i].DeviceType == 0xff) ||
                      (DeviceConfigParams[i].DeviceType == socketData->DeviceType)) &&
                 ((DeviceConfigParams[i].ManufacturerCode == 0xffff) ||
                      (DeviceConfigParams[i].ManufacturerCode == socketData->ManufacturerCode)) &&
                 ((DeviceConfigParams[i].ManufacturerInfo == 0xffff) ||
                      (DeviceConfigParams[i].ManufacturerInfo == socketData->ManufacturerInfo)) &&
                 ((DeviceConfigParams[i].CisCrc == 0xffff) ||
                      (DeviceConfigParams[i].CisCrc == socketData->CisCrc))) {

                pdoExtension->ConfigurationFlags = DeviceConfigParams[i].ConfigFlags;
                pdoExtension->ConfigureDelay1 = DeviceConfigParams[i].ConfigDelay1;
                pdoExtension->ConfigureDelay2 = DeviceConfigParams[i].ConfigDelay2;
                pdoExtension->ConfigureDelay3 = DeviceConfigParams[i].ConfigDelay3;
                break;

            }
            i++;
        }
        socketData = socketData->Next;
    }
}



NTSTATUS
PcmciaConfigurePcCardMemIoWindows(
    IN PSOCKET Socket,
    IN PSOCKET_CONFIGURATION SocketConfig
    )
/*++

Routine Description:

    This routine enables the socket memory and I/O windows

Arguments:

    Socket - Pointer to the socket containing the PC-Card
    SocketConfig - Pointer to the socket configuration structure which contains the
                        resources required to enable this pc-card

Return value:

    status

--*/
{
    CARD_REQUEST          cardRequest = {0};
    PFDO_EXTENSION    fdoExtension = Socket->DeviceExtension;
    NTSTATUS              status = STATUS_SUCCESS;
    ULONG i;

    DebugPrint((PCMCIA_DEBUG_CONFIG, "socket %08x config MemIo\n", Socket));

    //
    // Setup IO ranges if there are any
    //
    if (SocketConfig->NumberOfIoPortRanges) {
        cardRequest.RequestType = IO_REQUEST;
        cardRequest.u.Io.NumberOfRanges = (USHORT) SocketConfig->NumberOfIoPortRanges;

        for (i = 0; i < SocketConfig->NumberOfIoPortRanges; i++) {

            DebugPrint((PCMCIA_DEBUG_CONFIG, "\tport range: 0x%x-0x%x\n",
                            SocketConfig->Io[i].Base,
                            SocketConfig->Io[i].Base + SocketConfig->Io[i].Length));

            cardRequest.u.Io.IoEntry[i].BasePort = SocketConfig->Io[i].Base;
            cardRequest.u.Io.IoEntry[i].NumPorts = SocketConfig->Io[i].Length;

            cardRequest.u.Io.IoEntry[i].Attributes = 0;

            if (SocketConfig->Io[i].Width16) {
                cardRequest.u.Io.IoEntry[i].Attributes |= IO_DATA_PATH_WIDTH;
            }
            if (SocketConfig->Io[i].WaitState16) {
                cardRequest.u.Io.IoEntry[i].Attributes |= IO_WAIT_STATE_16;
            }
            if (SocketConfig->Io[i].Source16) {
                cardRequest.u.Io.IoEntry[i].Attributes |= IO_SOURCE_16;
            }
            if (SocketConfig->Io[i].ZeroWait8) {
                cardRequest.u.Io.IoEntry[i].Attributes |= IO_ZERO_WAIT_8;
            }

        }


        if (!PcmciaProcessConfigureRequest(fdoExtension, Socket, &cardRequest)) {
            status = STATUS_UNSUCCESSFUL;
            DebugPrint((PCMCIA_DEBUG_FAIL, "Failed to configure PcCardIO for socket %x\n", Socket));
        }
    }

    //
    // Set up Memory space if there is some.
    //
    if (NT_SUCCESS(status) && SocketConfig->NumberOfMemoryRanges) {

        cardRequest.RequestType = MEM_REQUEST;
        cardRequest.u.Memory.NumberOfRanges = (USHORT) SocketConfig->NumberOfMemoryRanges;

        for (i = 0; i < SocketConfig->NumberOfMemoryRanges; i++) {

            DebugPrint((PCMCIA_DEBUG_CONFIG, "\tmemory: host %08x for 0x%x, card %08x\n",
                            SocketConfig->Memory[i].HostBase,
                            SocketConfig->Memory[i].Length,
                            SocketConfig->Memory[i].CardBase));

            cardRequest.u.Memory.MemoryEntry[i].BaseAddress      = SocketConfig->Memory[i].CardBase;
            cardRequest.u.Memory.MemoryEntry[i].HostAddress      = SocketConfig->Memory[i].HostBase;
            cardRequest.u.Memory.MemoryEntry[i].WindowSize       = SocketConfig->Memory[i].Length;
            cardRequest.u.Memory.MemoryEntry[i].AttributeMemory  = SocketConfig->Memory[i].IsAttribute;
            cardRequest.u.Memory.MemoryEntry[i].WindowDataSize16 = SocketConfig->Memory[i].Width16;
            cardRequest.u.Memory.MemoryEntry[i].WaitStates       = SocketConfig->Memory[i].WaitState;
        }

        if (!PcmciaProcessConfigureRequest(fdoExtension, Socket, &cardRequest)) {
            status = STATUS_UNSUCCESSFUL;
            DebugPrint((PCMCIA_DEBUG_FAIL, "Failed to configure PcCardMem for socket %x\n", Socket));
        }
    }
    return status;
}


NTSTATUS
PcmciaConfigurePcCardIrq(
    IN PSOCKET Socket,
    IN PSOCKET_CONFIGURATION SocketConfig
    )
/*++

Routine Description:

    This routine enables the socket IRQ

Arguments:

    Socket - Pointer to the socket containing the PC-Card
    SocketConfig - Pointer to the socket configuration structure which contains the
                        resources required to enable this pc-card

Return value:

    status

--*/
{
    CARD_REQUEST          cardRequest = {0};
    PFDO_EXTENSION    fdoExtension = Socket->DeviceExtension;
    NTSTATUS              status = STATUS_SUCCESS;

    DebugPrint((PCMCIA_DEBUG_CONFIG, "skt %08x irq=0x%x\n",
                                                Socket,
                                                SocketConfig->Irq));
    //
    // Set the IRQ on the controller.
    //

    if (SocketConfig->Irq) {
        cardRequest.RequestType = IRQ_REQUEST;
        cardRequest.u.Irq.AssignedIRQ = (UCHAR) SocketConfig->Irq;
        cardRequest.u.Irq.ReadyIRQ = (UCHAR) SocketConfig->ReadyIrq;

        if (!PcmciaProcessConfigureRequest(fdoExtension, Socket, &cardRequest)) {
            status = STATUS_UNSUCCESSFUL;
            DebugPrint((PCMCIA_DEBUG_FAIL, "Failed to configure PcCardIrq for socket %x\n", Socket));
        }
    }
    return status;
}


NTSTATUS
PcmciaConfigurePcCardRegisters(
    PPDO_EXTENSION  pdoExtension
    )
/*++

Routine Description:

     This routine does the work of configuring the function configuration registers
     on the card.

Arguments:

    pdoExtension -  Pointer to the physical device object extension for the pc-card

Return value:

    status

--*/
{
    PSOCKET               Socket = pdoExtension->Socket;
    PSOCKET_CONFIGURATION SocketConfig = pdoExtension->SocketConfiguration;
    PSOCKET_DATA socketData ;
    CARD_REQUEST          cardRequest = {0};
    PFDO_EXTENSION    fdoExtension = Socket->DeviceExtension;
    NTSTATUS              status = STATUS_UNSUCCESSFUL;
    ULONG                 ccrBase;
    PFUNCTION_CONFIGURATION fnConfig;
    UCHAR                 configIndex;

    //
    // Set up the configuration index on the PCCARD.
    //

    cardRequest.RequestType = CONFIGURE_REQUEST;
    fnConfig = SocketConfig->FunctionConfiguration;
    socketData = pdoExtension->SocketData;

    ASSERT(socketData != NULL);

    do {
        cardRequest.u.Config.RegisterWriteMask = 0;

        if (fnConfig) {
            //
            // MF card -
            //   pick up the base and options from the linked list
            //
            ccrBase = fnConfig->ConfigRegisterBase;
            configIndex = fnConfig->ConfigOptions;
        } else {
            //
            // Single function card -
            //   get the base and index from base config structure
            //
            ccrBase = SocketConfig->ConfigRegisterBase;
            configIndex = SocketConfig->IndexForCurrentConfiguration;
        }

        DebugPrint((PCMCIA_DEBUG_CONFIG, "pdo %08x config registers ccr %x\n", pdoExtension->DeviceObject, ccrBase));
        //
        // We support only 2 interfaces:
        // Memory only
        // I/o and memory
        // We consider a card to be memory only if:
        //   The card is of device type PCCARD_TYPE_MEMORY: this is true
        //   for flash memory cards currently
        //           OR
        //   The card doesn't have any i/o ranges & the config register base is 0.
        //

        if (((ccrBase == 0) && (SocketConfig->NumberOfIoPortRanges == 0)) ||
             (socketData->DeviceType == PCCARD_TYPE_MEMORY) ||
             (socketData->DeviceType == PCCARD_TYPE_FLASH_MEMORY)) {

            cardRequest.u.Config.InterfaceType =  CONFIG_INTERFACE_MEM;

        } else {
            //
            // i/o mem card
            //
            cardRequest.u.Config.ConfigBase = ccrBase;
            cardRequest.u.Config.InterfaceType =  CONFIG_INTERFACE_IO_MEM;

            cardRequest.u.Config.RegisterWriteMask |= REGISTER_WRITE_CONFIGURATION_INDEX;
            cardRequest.u.Config.ConfigIndex = configIndex;

            if (IsConfigRegisterPresent(socketData, 1)) {
                cardRequest.u.Config.RegisterWriteMask |= REGISTER_WRITE_CARD_CONFIGURATION;
                cardRequest.u.Config.CardConfiguration = 0;
            }

            if (fnConfig) {
                //
                // MF card - set up the rest of the configuration registers
                //

                // Just check audio for now
                if (fnConfig->ConfigFlags & 0x8) {
                    // probably a modem
                    cardRequest.u.Config.CardConfiguration = 0x08;
                }

                if (fnConfig->ConfigOptions & 0x02) {
                    cardRequest.u.Config.IoBaseRegister = fnConfig->IoBase;
                    cardRequest.u.Config.IoLimitRegister = fnConfig->IoLimit;
                    cardRequest.u.Config.RegisterWriteMask |= (REGISTER_WRITE_IO_BASE | REGISTER_WRITE_IO_LIMIT);
                }

            } else if (IsDeviceFlagSet(pdoExtension, PCMCIA_PDO_ENABLE_AUDIO)) {

                //
                // Request that the audio pin in the card configuration register
                // be set.
                //
                cardRequest.u.Config.CardConfiguration = 0x08;
            }
        }

        if (!PcmciaProcessConfigureRequest(fdoExtension, Socket, &cardRequest)) {
            DebugPrint((PCMCIA_DEBUG_FAIL, "Failed to configure PcCardRegisters for PDO %x\n", pdoExtension->DeviceObject));
            return status;
        }


        if (fnConfig) {
            fnConfig = fnConfig->Next;
        } else {
            //
            // Remember that the socket is configured and what index was used.
            //
            socketData->ConfigIndexUsed = configIndex;
        }

    } while(fnConfig);


    status = STATUS_SUCCESS;
    return status;
}


VOID
PcmciaConfigureModemHack(
    IN PSOCKET Socket,
    IN PSOCKET_CONFIGURATION SocketConfig
    )
/*++

Routine Description:

    This routine does magic to wake the modem up. It is written to accomodate
    the Motorola MobileSURFR 56k, but there may be other modems that need it.

Arguments:

    Socket - Pointer to the socket containing the PC-Card
    SocketConfig - Pointer to the socket configuration structure which contains the
                        resources required to enable this pc-card

Return value:

    status

--*/
{
    static const ULONG ValidPortBases[4] = {0x3f8, 0x2f8, 0x3e8, 0x2e8};
    ULONG i;
    UCHAR ch;
    ULONG base;

    for (i = 0; i < 4; i++) {

        base = SocketConfig->Io[0].Base;

        if (base == ValidPortBases[i]) {
            DebugPrint((PCMCIA_DEBUG_CONFIG, "skt %08x ModemHack base %x\n", Socket, base));

            // read and write the modem control register
            ch = READ_PORT_UCHAR((PUCHAR)ULongToPtr(base + 4));
            WRITE_PORT_UCHAR((PUCHAR)ULongToPtr(base + 4), ch);
            break;
        }
    }
}



VOID
PcmciaSocketDeconfigure(
    IN PSOCKET Socket
    )

/*++

Routine Description:

    deconfigures the card

Arguments:

    Socket - Pointer to the socket containing the PC-Card

Return Value

    none

--*/

{
    CARD_REQUEST  cardReq;

    if (IsSocketFlagSet(Socket, SOCKET_CARD_CONFIGURED)) {

        cardReq.RequestType = DECONFIGURE_REQUEST;

        PcmciaProcessConfigureRequest(Socket->DeviceExtension, Socket, &cardReq);

        ResetSocketFlag(Socket, SOCKET_CARD_CONFIGURED);
    }

    //
    // If a query_device_relations came in after a card was inserted, but before
    // we have removed the previous card configuration, the enumeration would have been
    // postponed. Here, we start it up again
    //
    if (IsSocketFlagSet(Socket, SOCKET_ENUMERATE_PENDING)) {
        ResetSocketFlag(Socket, SOCKET_ENUMERATE_PENDING);
        SetSocketFlag(Socket, SOCKET_CARD_STATUS_CHANGE);
        IoInvalidateDeviceRelations(Socket->DeviceExtension->Pdo, BusRelations);
    }
}


BOOLEAN
PcmciaProcessConfigureRequest(
    IN PFDO_EXTENSION DeviceExtension,
    IN PSOCKET          Socket,
    IN PCARD_REQUEST    CardConfigurationRequest
    )

/*++

Routine Description:

     Actually configures the card

Arguments:

     Context

Return Value

     True

--*/

{
    BOOLEAN status;
    ULONG   counter;


    PCMCIA_ACQUIRE_DEVICE_LOCK(DeviceExtension);

    //
    // Configuring the card can be tricky: the user may pop out the card while
    // configuration is taking place.
    //

    counter = 0;
    do {
        status = (*(Socket->SocketFnPtr->PCBProcessConfigureRequest))(Socket,
                                                                      CardConfigurationRequest,
                                                                      Socket->AddressPort);
        if (!status) {
            if (!(Socket->SocketFnPtr->PCBDetectCardInSocket(Socket))) {
                //
                // Somebody popped out the card
                //
                break;
            }
        }
        counter++;
    } while (!status && counter < PCMCIA_MAX_CONFIG_TRIES);

    PCMCIA_RELEASE_DEVICE_LOCK(DeviceExtension);

    return status;
}


BOOLEAN
PcmciaVerifyCardInSocket(
    IN PSOCKET Socket
    )
/*++

Routine Description:

    This routine compares the current known state to the id of the
    card in the slot to determine if the state is consistent. That is,
    if there is no card in the socket, then we would expect to see no
    cards enumerated in the socket data. If there is a card in the socket,
    then we would expect to see the socket data match the card.

Arguments

    Socket      - Point to the socket to verify

Return Value

    TRUE if the logical state of the socket matches its physical state
    FALSE otherwise

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT pdo, nextPdo;
    PPDO_EXTENSION pdoExtension;
    BOOLEAN verified = FALSE;

    try {
        if (!IsCardInSocket(Socket)) {
            leave;
        }

        if (IsCardBusCardInSocket(Socket)) {
            ULONG pciConfig;
            ULONG i;
            //
            // Cardbus card now in slot, check to see if it matches the
            // PdoList state.
            //
            if (!Socket->PdoList) {
                leave;
            }

            for (pdo = Socket->PdoList; pdo!=NULL; pdo=nextPdo) {
                pdoExtension = pdo->DeviceExtension;
                nextPdo = pdoExtension->NextPdoInSocket;

                if (!IsCardBusCard(pdoExtension)) {
                    leave;
                }

                for (i = 0; i < 1000; i++) {
                    GetPciConfigSpace(pdoExtension, CFGSPACE_VENDOR_ID, &pciConfig, sizeof(pciConfig));
                    if (pdoExtension->CardBusId == pciConfig) {
                        break;
                    }
                    PcmciaWait(10);
                }

                if (i > 0) {
                    DebugPrint((PCMCIA_DEBUG_FAIL, "pdo %08x waited %d usec to verify device id %08x\n",
                                pdoExtension->DeviceObject, i*10, pdoExtension->CardBusId));
                }

                if (pdoExtension->CardBusId != pciConfig) {
                    DebugPrint((PCMCIA_DEBUG_FAIL, "pdo %08x verify device id FAILED: %08x %08x\n",
                                    pdoExtension->DeviceObject, pdoExtension->CardBusId, pciConfig));
                    leave;
                }
            }

            verified = TRUE;

        } else {
            //
            // R2 card now in slot
            //
            pdo = Socket->PdoList;

            if (pdo) {
                pdoExtension = pdo->DeviceExtension;
                if (Is16BitCard(pdoExtension)) {
                    //
                    // Invalidate the cache to force re-reading the CIS
                    //
                    pdoExtension->CisCacheSpace = 0xff;
                    if ((NT_SUCCESS(PcmciaParseFunctionDataForID(pdoExtension->SocketData)))) {
                        verified = TRUE;
                    }
                }
            }
        }

    } finally {
        if (!verified) {
            SetSocketFlag(Socket, SOCKET_CARD_STATUS_CHANGE);
        }
        DebugPrint((PCMCIA_DEBUG_INFO, "skt %08x - card %s\n", Socket, verified ? "not changed" : "changed!"));
    }
    return verified;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\tcicsup.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    tcicsup.c

Abstract:

    This module supplies functions that control the Databook TCIC family
    of chips. In turn, these functions are abstracted out to the main PCMCIA
    support module.

Author(s):
         (pcicsup.c - Source that this file was derived from)
         Bob Rinne (BobRi)  3-Aug-1994
         Jeff McLeman (mcleman@zso.dec.com)
         (tcicsup.c - this file)
                    John Keys - Databook Inc. 7-Apr-1995

Revisions:
         Overhaul for plug'n'play support
                    Ravisankar Pudipeddi (ravisp) 8-Jan-1997
         new setpower and init routine interface
                    Neil Sandlin (neilsa) 3-Mar-99
--*/

#include "pch.h"

VOID
TcicRegistryLookupScanLimits(
    PULONG Start,
    PULONG End
    );

NTSTATUS
TcicDetectSockets(
    IN PFDO_EXTENSION DeviceExtension,
    IN BOOLEAN        LegacyDetection
    );

BOOLEAN
TcicInitializePcmciaSocket(
    IN PSOCKET SocketPtr
    );

NTSTATUS
TcicResetCard(
    IN PSOCKET SocketPtr,
    OUT PULONG pDelayTime
    );

ULONG
TcicReadCardMemory(
    IN PPDO_EXTENSION PdoExtension,
    IN MEMORY_SPACE MemorySpace,
    IN ULONG   Offset,
    IN  PUCHAR Buffer,
    IN  ULONG  Length
    );

ULONG
TcicWriteCardMemory(
    IN PPDO_EXTENSION PdoExtension,
    IN  MEMORY_SPACE MemorySpace,
    IN  ULONG  Offset,
    IN  PUCHAR Buffer,
    IN  ULONG  Length
    );

BOOLEAN
TcicDetectCardInSocket(
    IN PSOCKET SocketPtr
    );

BOOLEAN
TcicDetectCardChanged(
    IN PSOCKET SocketPtr
    );

BOOLEAN
TcicDetectReadyChanged(
    IN PSOCKET SocketPtr
    );

NTSTATUS
TcicGetPowerRequirements(
    IN PSOCKET Socket
    );

BOOLEAN
TcicProcessConfigureRequest(
    IN PSOCKET SocketPtr,
    IN PVOID  ConfigRequest,
    IN PUCHAR Base
    );

BOOLEAN
TcicEnableDisableCardDetectEvent(
    IN PSOCKET SocketPtr,
    IN BOOLEAN Enable
    );

VOID
TcicDisableControllerInterrupt(
    IN PSOCKET socketPtr
    );

BOOLEAN
TcicPCCardReady(
    IN PSOCKET SocketPtr
    );

VOID
TcicGetRegisters(
    IN PFDO_EXTENSION DeviceExtension,
    IN PSOCKET SocketPtr,
    IN PUCHAR Buffer
    );

ULONG
TcicGetIrqMask(
    IN PFDO_EXTENSION deviceExtension
    );

BOOLEAN
TcicCardBusCardInSocket(
    IN PSOCKET SocketPtr
    );

#if DBG
VOID
TcicDump(
    IN PSOCKET socketPtr
    );
#endif

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(INIT,TcicDetect)
    #pragma alloc_text(PAGE,TcicFillInAdapter)
    #pragma alloc_text(PAGE,TcicGetAdapterInfo)
    #pragma alloc_text(PAGE,TcicAllocateMemRange)
    #pragma alloc_text(PAGE,TcicReservedBitsOK)
    #pragma alloc_text(PAGE,TcicChipID)
    #pragma alloc_text(PAGE,TcicCheckSkt)
    #pragma alloc_text(PAGE,TcicCheckAliasing)
    #pragma alloc_text(PAGE,TcicCheckAliasType)
    #pragma alloc_text(PAGE,TcicCheckXBufNeeded)
    #pragma alloc_text(PAGE,TcicSetMemWindow)
    #pragma alloc_text(PAGE,TcicGetPossibleIRQs)
    #pragma alloc_text(PAGE,TcicClockRate)
    #pragma alloc_text(PAGE,TcicGetIRQMap)
    #pragma alloc_text(PAGE,TcicGet5vVccVal)
    #pragma alloc_text(PAGE,TcicHasSktIRQPin)
    #pragma alloc_text(PAGE,TcicGetFlags)
    #pragma alloc_text(PAGE,TcicGetnMemWins)
    #pragma alloc_text(PAGE,TcicGetnIOWins)
    #pragma alloc_text(PAGE,TcicRegistryLookupScanLimits)
#endif

#define TCIC_LOW_ADDR_LIMIT   0x240
#define TCIC_HIGH_ADDR_LIMIT      0x2ff


/*
|| IRQ Tables -
|| Each table consists of 16 bytes. Each byte maps an IRQ level (implied by
|| table index) to a register value that will select that IRQ. For instance,
|| with table irqcaps_082, table[11] gives a value of 1, so using '1' as the
|| card status change IRQ value will cause IRQ11 to be fired.
||
*/
/********************* 0 1 2 3 4 5 6 7 8    9 A  B  C  D  E  F *****************/
UCHAR irqcaps_082[]  ={0,0,0,3,4,5,6,7,0, 0,10,1, 0, 0, 14,0};
UCHAR irqcaps_082sw[] ={0,0,0,3,4,5,0,7,0, 6,10,1, 0, 0, 14,0};
UCHAR irqcaps_072[]  ={0,0,0,3,4,5,0,7,0, 0,10,1, 0, 0, 14,0};
UCHAR irqcaps_072sw[] ={0,0,0,3,4,5,0,7,0,14,10,1, 0, 0, 0, 0};
/* in the case of x84 parts, we determine  6,9,12,&15 at run time */
UCHAR irqcaps_084[]  ={0,0,0,3,4,5,0,7,0, 0,10,11,0, 0, 14,0};


/* The Socket Services Public Power Table */
unsigned short PubPwrTbl[] = {
    3,                                               /* number of Public Entries */
    SPWR_ALL_SUPPLY | SPWR_0p0V,                 /* Public entry                  */
    SPWR_ALL_SUPPLY | SPWR_5p0V,                 /* Public entry                  */
    SPWR_VPP_SUPPLY | SPWR_12p0V                 /* Public entry                  */
};


/* The corresponding Private Table for a TMI-140 type implementation         */
USHORT PwrTbl140[] = {
    3, 0x0000, 0x0001, 0x0800,               /* Private table             */
    0x0001                                           /* CtlBits for Vcc=5V        */
};

/* The other  Private Table for a DB86082/071/072 type implementation        */
USHORT PwrTbl082[] = {
    3, 0x0000, 0x0809, 0x0100,               /* Private table             */
    0x0001                                           /* CtlBits for Vcc=5V        */
};

/* The corresponding Private Table for a DB86084/184 implementation          */
USHORT PwrTbl084[] ={
    3, 0x0000, 0x0207, 0x0100,               /* Private table             */
    0x0007                                           /* CtlBits for Vcc=5V        */
};


/* Properties table - use this to bind possible capabilites to a Chip ID     */

CHIPPROPS ChipProperties[] = {
    {SILID_DB86082_1,
        PwrTbl082, 0, irqcaps_082, NUMSOCKETS, IR_IOWIN_NUM,
        IR_MWIN_NUM_082, (fEXTBUF_CHK | fSKTIRQPIN)},
    {SILID_DB86082A,
        PwrTbl082, 0, irqcaps_082, NUMSOCKETS, IR_IOWIN_NUM,
        IR_MWIN_NUM_082A, (fEXTBUF_CHK | fSKTIRQPIN)},
    {SILID_DB86082B,
        PwrTbl082, 0, irqcaps_082, NUMSOCKETS, IR_IOWIN_NUM,
        IR_MWIN_NUM_082B, (fEXTBUF_CHK | fSKTIRQPIN)},
    {SILID_DB86082B_ES,
        PwrTbl082, 0, irqcaps_082, NUMSOCKETS, IR_IOWIN_NUM,
        IR_MWIN_NUM_082B, (fEXTBUF_CHK | fSKTIRQPIN)},
    {SILID_DB86084_1,
        PwrTbl084, 0, irqcaps_084, NUMSOCKETS, IR_IOWIN_NUM,
        IR_MWIN_NUM_084, fIS_PNP},
    {SILID_DB86084A,
        PwrTbl084, 0, irqcaps_084, NUMSOCKETS, IR_IOWIN_NUM,
        IR_MWIN_NUM_084, fIS_PNP},
    {SILID_DB86184_1,
        PwrTbl084, 0, irqcaps_084, NUMSOCKETS, IR_IOWIN_NUM,
        IR_MWIN_NUM_184, fIS_PNP},
    {SILID_DB86072_1,
        PwrTbl082, 0, irqcaps_072, NUMSOCKETS, IR_IOWIN_NUM,
        IR_MWIN_NUM_072, fSKTIRQPIN},
    {SILID_DB86072_1_ES,
        PwrTbl082, 0, irqcaps_072, NUMSOCKETS, IR_IOWIN_NUM,
        IR_MWIN_NUM_072, fSKTIRQPIN},
    {0, NULL, 0, NULL, 0, 0, 0, 0}
};



#ifdef POOL_TAGGING
    #undef ExAllocatePool
    #define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'bdcP')
#endif

PUCHAR TcicCisBufferBase;
ULONG  TcicPhysicalBase;
ULONG  TcicStallCounter = 5000;
ULONG  TcicStallPower   = 20000;

PCMCIA_CTRL_BLOCK TcicSupportFns = {
    TcicInitializePcmciaSocket,
    TcicResetCard,
    TcicDetectCardInSocket,
    TcicDetectCardChanged,
    NULL,                        // DetectCardStatus
    TcicDetectReadyChanged,
    NULL,                        // GetPowerRequirements
    TcicProcessConfigureRequest,
    TcicEnableDisableCardDetectEvent,
    NULL,                        // EnableDisableWakeupEvent
    TcicGetIrqMask,
    TcicReadCardMemory,
    TcicWriteCardMemory,
    NULL,                        // ModifyMemoryWindow
    NULL,                        // SetVpp
    NULL                             // IsWriteProtected
};



VOID
TcicGetControllerProperties(
    IN PSOCKET socketPtr,
    IN PUSHORT pIoPortBase,
    IN PUSHORT pIoPortSize
    )

/*++

Routine Description:

    Gets the Port base and range from the DBSOCKET pointer. The original code
    stored these values in the device extension, but this did not allow for
    multiple controller products such as the TMB-270.

Arguments:

    socketPtr - pointer to our socket structure
    pIoPortBase - where to write the base address.
    pIoPortSize - where to write the range.

Return Value:

     None

--*/

{
    PDBSOCKET pdb;

    if (Databook(socketPtr)) {
        pdb = (PDBSOCKET)socketPtr;
        *pIoPortBase = (USHORT)pdb->physPortAddr;
        *pIoPortSize = 16;
    }
}



ULONG
TcicGetIrqMask(
    IN PFDO_EXTENSION deviceExtension
    )

/*++

Routine Description:

    Gets the IRQ mask from the DBSOCKET pointer. The original code
    had this mask hardcoded in PCMCIA.C but this did not provide the
    flexibility needed to correctly state the mask for Databook products.

Arguments:

    deviceExtension - the root of the socket list

Return Value:

    The compiled IRQ mask for the 1st socket in the list since this socket
    should be representative of all sockets on this controller.

--*/
{
    PDBSOCKET pdb = (PDBSOCKET)(deviceExtension->SocketList);
    ULONG    mask = 0;
    int                 j;

    for (j = 0; j < 16; j++) {
        //
        // Changed the way the mask is constructed
        // The older (non-PnP) code put 0s for valid IRQs
        // and 1s for non-valid IRQs. Now it's flipped
        // (since the ControllerInterruptMask operates the same
        // way)
        //
        if (pdb->IRQMapTbl[j] != (UCHAR)0) {
            mask |= ((ULONG)1 << j);
        }
    }
    return (mask);
}



#if DBG
    #include "tcicregs.h"

VOID
TcicDump(
    IN PSOCKET socketPtr
    )

/*++

Routine Description:

    Debug routine to print the registers to the debugger.

Arguments:

    socketPtr - provides base address information for the contoller to dump.

Return Value:

    None

--*/

{
    TCIC    tcic;
    ULONG  origAddr;
    USHORT  j;

    origAddr = TcicReadAddrReg(socketPtr);
    for (j = 0; j < 2; j++) {

        //
        // Select the socket
        //

        TcicSocketSelect(socketPtr, j);

        //
        // Read TCIC base registers for this socket
        //

        tcic.baseregs[j].sctrl = (UCHAR)TcicReadBaseReg(socketPtr, R_SCTRL);
        tcic.baseregs[j].sstat = (UCHAR)TcicReadBaseReg(socketPtr, R_SSTAT);
        tcic.baseregs[j].mode  = (UCHAR)TcicReadBaseReg(socketPtr, R_MODE);
        tcic.baseregs[j].pwr   = (UCHAR)TcicReadBaseReg(socketPtr, R_PWR);
        tcic.baseregs[j].edc   =          TcicReadBaseReg(socketPtr, R_EDC);
        tcic.baseregs[j].icsr  = (UCHAR)TcicReadBaseReg(socketPtr, R_ICSR);
        tcic.baseregs[j].iena  = (UCHAR)TcicReadBaseReg(socketPtr, R_IENA);

        //
        // Read TCIC aux regsiters for this socket
        //

        tcic.baseregs[j].wctl   = TcicReadAuxReg(socketPtr, MODE_AR_WCTL);
        tcic.baseregs[j].syscfg = TcicReadAuxReg(socketPtr, MODE_AR_SYSCFG);
        tcic.baseregs[j].ilock  = TcicReadAuxReg(socketPtr, MODE_AR_ILOCK);
        tcic.baseregs[j].test   = TcicReadAuxReg(socketPtr, MODE_AR_TEST);

        //
        // Restore R_MODE - trashed by reading aux regs
        //

        TcicWriteBaseReg(socketPtr, R_MODE, tcic.baseregs[j].mode);
    }

    for (j = 0; j < 2; j++) {
        TcicReadIndirectRegs(socketPtr, IR_SCFG_S(j), 2, (PUSHORT)&tcic.sktregs[j]);
    }

    for (j = 0; j < 4; j++) {
        TcicReadIndirectRegs(socketPtr, IR_IOBASE_W(j), 2, (PUSHORT)&tcic.iowins[j]);
    }

    for (j = 0; j < 10; j++) {
        TcicReadIndirectRegs(socketPtr, IR_MBASE_W(j), 3, (PUSHORT)&tcic.memwins[j]);
    }

    TcicWriteAddrReg(socketPtr, origAddr);

    DebugPrint((PCMCIA_DUMP_SOCKET, "SCTRL\t%02X\t%02X\n",
                    tcic.baseregs[0].sctrl, tcic.baseregs[1].sctrl));

    DebugPrint((PCMCIA_DUMP_SOCKET, "SSTAT\t%02X\t%02X\n",
                    tcic.baseregs[0].sstat, tcic.baseregs[1].sstat));

    DebugPrint((PCMCIA_DUMP_SOCKET, "MODE \t%02X\t%02X\n",
                    tcic.baseregs[0].mode, tcic.baseregs[1].mode));

    DebugPrint((PCMCIA_DUMP_SOCKET, "PWR  \t%02X\t%02X\n",
                    tcic.baseregs[0].pwr  , tcic.baseregs[1].pwr  ));

    DebugPrint((PCMCIA_DUMP_SOCKET, "EDC  \t%04X\t%04X\n",
                    tcic.baseregs[0].edc  , tcic.baseregs[1].edc  ));

    DebugPrint((PCMCIA_DUMP_SOCKET, "ICSR \t%02X\t%02X\n",
                    tcic.baseregs[0].icsr , tcic.baseregs[1].icsr ));

    DebugPrint((PCMCIA_DUMP_SOCKET, "IENA \t%02X\t%02X\n",
                    tcic.baseregs[0].iena , tcic.baseregs[1].iena ));

    DebugPrint((PCMCIA_DUMP_SOCKET, "WCTL \t%02X\t%02X\n",
                    tcic.baseregs[0].wctl , tcic.baseregs[1].wctl ));

    DebugPrint((PCMCIA_DUMP_SOCKET, "SYSCFG\t%02X\t%02X\n",
                    tcic.baseregs[0].syscfg, tcic.baseregs[1].syscfg));

    DebugPrint((PCMCIA_DUMP_SOCKET, "ILOCK\t%02X\t%02X\n",
                    tcic.baseregs[0].ilock, tcic.baseregs[1].ilock));

    DebugPrint((PCMCIA_DUMP_SOCKET, "TEST \t%02X\t%02X\n",
                    tcic.baseregs[0].test , tcic.baseregs[1].test ));

    for (j = 0; j < 2; j++ ) {
        DebugPrint((PCMCIA_DUMP_SOCKET,
                        "SKT%d\tSCF1 %04X\tSCF2 %04X\n",
                        j, tcic.sktregs[j].scfg1, tcic.sktregs[j].scfg2));
    }

    for (j = 0; j < 4; j++ ) {
        DebugPrint((PCMCIA_DUMP_SOCKET,
                        "IOWIN%d\tIOBASE %04X\tIOCTL %04X\n",
                        j, tcic.iowins[j].iobase, tcic.iowins[j].ioctl));
    }

    for (j = 0; j < 10; j++ ) {
        DebugPrint((PCMCIA_DUMP_SOCKET,
                        "MEMWIN%d\tMBASE %04X\tMMAP %04X\tMCTL %04X\n",
                        j, tcic.memwins[j].mbase,
                        tcic.memwins[j].mmap,
                        tcic.memwins[j].mctl));
    }
}
#endif



BOOLEAN
TcicEnableDisableCardDetectEvent(
    IN PSOCKET SocketPtr,
    IN BOOLEAN Enable
    )

/*++

Routine Description:

    Enable card detect interrupt.

Arguments:

    SocketPtr - socket information
    Irq - the interrupt value to set if enable is true.
    Enable - if  TRUE, CSC interrupt is enabled,
             if FALSE, it is disabled

Return Value:

    None

--*/

{
    UCHAR mappedIrq;
    PDBSOCKET pdb = (PDBSOCKET)SocketPtr;
    BOOLEAN retVal;

    switch (Enable) {
    case TRUE:
        //
        // Validate the interrupt request. Only setup if the IRQ is valid
        // for this controller
        //

        if ((mappedIrq = pdb->IRQMapTbl[SocketPtr->FdoIrq]) != (UCHAR)0) {

            USHORT word;

            //
            // Mask status change conditions other than CD. The pcic code comments
            // claimed to setup CD and RDY/BSY notification, but the code itself
            // only allows for CD.
            //

            word = (USHORT)(IRSCF2_MLBAT1 | IRSCF2_MLBAT2 | IRSCF2_MRDY | IRSCF2_MWP);
            TcicWriteIndirectRegs(SocketPtr,
                                  IR_SCF2_S(SocketPtr->RegisterOffset),
                                  1,
                                  &word);

            //
            // Set the correct IRQ value in the SYSCFG register
            //

            word = TcicReadAuxReg(SocketPtr, MODE_AR_SYSCFG);
            word &= ~SYSCFG_IRQ_MASK;
            word |= (USHORT)mappedIrq;
            TcicWriteAuxReg(SocketPtr, MODE_AR_SYSCFG, word);

            //
            // Set IRQ polarity and enable via R_IENA
            //

            TcicSocketSelect(SocketPtr, SocketPtr->RegisterOffset);
            TcicWriteBaseReg(SocketPtr, R_IENA, IENA_CDCHG | IENA_CFG_HIGH);

            PcmciaWait(TcicStallCounter);
            //
            // Clear ICSR - so future insertions/removals will generate interrupts
            //
            (VOID) TcicDetectCardChanged(SocketPtr);
            retVal = TRUE;
        } else {
            retVal = FALSE;
        }
        break;
    case FALSE:{
            retVal = FALSE;
            break;
        }
    }
    return retVal;
}



NTSTATUS
TcicResetCard(
    IN PSOCKET SocketPtr,
    OUT PULONG pDelayTime
    )
/*++

Routine Description:

Arguments:

    SocketPtr - socket information
    pDelayTime - specifies delay (msec) to occur after the current phase

Return value:

    STATUS_MORE_PROCESSING_REQUIRED - increment phase, perform delay, recall
    other status values terminate sequence

--*/
{
    NTSTATUS status;
    PDBSOCKET pdb = (PDBSOCKET)SocketPtr;

    USHORT ilock;
    PDBSOCKET dbskt = (PDBSOCKET)(SocketPtr->DeviceExtension->SocketList);

    switch(SocketPtr->CardResetPhase) {
    case 1:
        //
        // reset PCCARD
        //

        ilock = TcicReadAuxReg(SocketPtr, MODE_AR_ILOCK);
        ilock &= ~(ILOCK_CRESET | ILOCK_CRESENA | ILOCK_CWAIT);
        TcicWriteAuxReg(SocketPtr, MODE_AR_ILOCK, (USHORT)(ilock | ILOCK_CRESENA | ILOCK_CRESET));
        *pDelayTime = TcicStallCounter;
        SocketPtr->PowerData = (ULONG) ilock;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;

    case 2:

        ilock = (USHORT) SocketPtr->PowerData;
        TcicWriteAuxReg(SocketPtr, MODE_AR_ILOCK, (USHORT)(ilock | ILOCK_CRESENA));
        *pDelayTime = TcicStallCounter;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;

    case 3:

        ilock = TcicReadAuxReg(SocketPtr,  MODE_AR_ILOCK);
        if (!(ilock & ILOCK_CWAITSNS)) {
            TcicWriteAuxReg(SocketPtr, MODE_AR_ILOCK, (USHORT)(ilock | ILOCK_CWAIT));
        }
        //
        // If not already started, start a timer to drive the BusyLED
        // Monitor routine.
        if (dbskt->timerStarted == FALSE) {
            IoInitializeTimer(pdb->skt.DeviceExtension->DeviceObject,
                                    TcicBusyLedRoutine, NULL);
            IoStartTimer(pdb->skt.DeviceExtension->DeviceObject);
            dbskt->timerStarted = TRUE;
        }
        status = STATUS_SUCCESS;
        break;
    default:
        ASSERT(FALSE);
        status = STATUS_UNSUCCESSFUL;
    }
    return status;
}



NTSTATUS
TcicSetPower(
    IN PSOCKET socketPtr,
    IN BOOLEAN Enable,
    OUT PULONG pDelayTime
    )

/*++

Routine Description:

    Set power to the specified socket.

Arguments:

    SocketPtr - the socket to set
    Enable - TRUE means to set power - FALSE is to turn it off.
    pDelayTime - specifies delay (msec) to occur after the current phase

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - increment phase, perform delay, recall
    other status values terminate sequence

--*/

{
    NTSTATUS status;

    //
    // Get the specified socket mapped into  the TCIC registers
    //

    TcicSocketSelect(socketPtr, socketPtr->RegisterOffset);

    if (Enable) {
        PDBSOCKET pdb = (PDBSOCKET)socketPtr;

        switch(socketPtr->PowerPhase) {
        case 1:

            //
            // Turn on power
            //

            DebugPrint((PCMCIA_DEBUG_INFO, "TcicSetPower: Powering UP pccard socket\n"));

            TcicWriteBaseReg(socketPtr, R_PWR, pdb->dflt_vcc5v);

            //
            // Enable other strobes to socket
            //

            TcicWriteBaseReg(socketPtr, R_SCTRL, SCTRL_ENA);

            //
            // When power is enabled always stall to give the PCCARD
            // a chance to react.
            //
            *pDelayTime = TcicStallCounter;
            status = STATUS_MORE_PROCESSING_REQUIRED;
            break;

        case 2:

            if (!TcicPCCardReady(socketPtr)) {
                DebugPrint((PCMCIA_PCCARD_READY,
                                "Tcic: PCCARD %x not ready after power\n",
                                socketPtr->RegisterOffset));
            }
            status = STATUS_SUCCESS;
            break;
        default:
            ASSERT(FALSE);
            status = STATUS_UNSUCCESSFUL;
        }
    } else {

        //
        // Disable socket strobes
        //
        DebugPrint((PCMCIA_DEBUG_INFO, "TcicSetPower: Powering DOWN pccard socket\n"));

        TcicWriteBaseReg(socketPtr, R_SCTRL, 0);

        //
        // Diable power
        //

        TcicWriteBaseReg(socketPtr, R_PWR, 0);
        status = STATUS_SUCCESS;
    }
    return status;
}



BOOLEAN
TcicInitializePcmciaSocket(
    PSOCKET SocketPtr
    )

/*++

Routine Description:

    This routine will setup the 82365 into a state where the pcmcia support
    module will be able to issue commands to read device tuples from the
    cards in the sockets.

Arguments:

    SocketPtr - socket specific info

Return Value:

    TRUE if successful
    FALSE if not successful

--*/

{
    PDBSOCKET pdb = (PDBSOCKET)SocketPtr;
    USHORT speedbits = WCTL_300NS;

    speedbits >>= pdb->clkdiv;

    //
    // If this is the first socket on this controller,
    // Reset the controller and do controller-wide initialization.
    //

    if (SocketPtr->RegisterOffset == 0) {
        USHORT words[4];
        int j;

        //
        // Reset Controller
        //

        TcicWriteBaseReg(SocketPtr, R_SCTRL, SCTRL_RESET);
        TcicWriteBaseReg(SocketPtr, R_SCTRL, 0);

        //
        // Initialize indirect socket regs
        //

        words[0] = pdb->dflt_scfg1;
        words[1] = (USHORT)(IRSCF2_MLBAT1 | IRSCF2_MLBAT2 | IRSCF2_MRDY | IRSCF2_MWP);
        TcicWriteIndirectRegs(SocketPtr,  IR_SCFG_S(0), 2, words);
        TcicWriteIndirectRegs(SocketPtr,  IR_SCFG_S(1), 2, words);

        //
        // Initialize indirect memwin regs
        //

        words[0] = words[1] = 0;
        words[2] = pdb->dflt_wrmctl;
        for (j = 0; j < pdb->nmemwins;  j++) {
            TcicWriteIndirectRegs(SocketPtr, IR_MBASE_W(j), 3, words);
        }

        //
        // Initialize indirect iowin regs
        //

        for (j = 0;  j < pdb->niowins; j++ ) {
            TcicWriteIndirectRegs(SocketPtr, IR_IOBASE_W(j), 2, words);
        }


        //
        // Initialize SYSCFG
        //

        TcicWriteAuxReg(SocketPtr, MODE_AR_SYSCFG, pdb->dflt_syscfg);
    }

    //
    // Get the specified Socket mapped into  the TCIC registers
    //

    TcicSocketSelect(SocketPtr, SocketPtr->RegisterOffset);

    //
    // Per/socket we initialize the following base and aux regs:
    // WCTL & ILOCK
    //

    TcicWriteAuxReg(SocketPtr, MODE_AR_WCTL, (USHORT)(pdb->dflt_wctl | speedbits));
    TcicWriteAuxReg(SocketPtr, MODE_AR_ILOCK, pdb->dflt_ilock);

    //
    // Say card is there
    //

    return TRUE;
}



USHORT
TcicReadBaseReg(
    IN PSOCKET SocketPtr,
    IN ULONG  Register
    )

/*++

Routine Description:

    Reads the specified TCIC base register,

Arguments:

    SocketPtr - instance data for this socket
    Register  - index of register to read

Return Value:

    register value read

--*/

{
    USHORT readData = 0;

    switch (Register) {
    case R_DATA:
    case R_ADDR:
    case R_ADDR2:
    case R_EDC:
    case R_AUX:
        readData = READ_PORT_USHORT((PUSHORT)(SocketPtr->AddressPort + Register));
        break;

    case R_SCTRL:
    case R_SSTAT:
    case R_MODE:
    case R_PWR:
    case R_ICSR:
    case R_IENA:
        readData = (USHORT)READ_PORT_UCHAR(SocketPtr->AddressPort + Register);
        break;
    }
    return readData;
}



VOID
TcicWriteBaseReg(
    IN PSOCKET SocketPtr,
    IN ULONG  Register,
    IN USHORT  value
    )

/*++

Routine Description:

    Write a value to the specified TCIC base register

Arguments:

    SocketPtr - instance data for this socket
    Register  - index of register to write
    value   -  value to write to register

Return Value:

    None

--*/

{
    USHORT readData = 0;

    switch (Register) {
    case R_DATA:
    case R_ADDR:
    case R_ADDR2:
    case R_EDC:
    case R_AUX:
        WRITE_PORT_USHORT((PUSHORT)(SocketPtr->AddressPort + Register), value);
        break;

    case R_SCTRL:
    case R_SSTAT:
    case R_MODE:
    case R_PWR:
    case R_ICSR:
    case R_IENA:
        WRITE_PORT_UCHAR(SocketPtr->AddressPort + Register, (UCHAR)value);
        break;
    }
}



ULONG
TcicReadAddrReg(
    IN PSOCKET SocketPtr
    )

/*++

Routine Description:

    Read the current value of the TCIC address register

Arguments:

    SocketPtr - instance data for this socket

Return Value:

    Address read from register

--*/

{
    ULONG retaddr;
    retaddr = (ULONG)TcicReadBaseReg(SocketPtr, R_ADDR);
    retaddr |= ((ULONG)TcicReadBaseReg(SocketPtr, R_ADDR2) << 16);
    return (retaddr);
}



VOID
TcicWriteAddrReg(
    IN PSOCKET SocketPtr,
    IN ULONG   addr
    )

/*++

Routine Description:

    Write an address to the TCIC address register

Arguments:

    SocketPtr - instance data for this socket
    addr - address to write to register

Return Value:

    None

--*/

{
    TcicWriteBaseReg(SocketPtr, R_ADDR, (USHORT)(addr & 0x0000ffff));
    TcicWriteBaseReg(SocketPtr, R_ADDR2, (USHORT)(addr >> 16));
}



USHORT
TcicReadAuxReg(
    IN PSOCKET SocketPtr,
    IN ULONG  Register
    )

/*++

Routine Description:

    Read the specified TCIC AUX register

Arguments:

    SocketPtr - instance data for this socket
    Register  - MODE_AR_xxx justified index of AUX register to read

Return Value:

    contents of specified AUX register

--*/

{
    USHORT readData = 0;
    USHORT OldMode;

    //
    // Get the current mode register value
    //

    OldMode = TcicReadBaseReg(SocketPtr, R_MODE);

    //
    // Mask out previous AUX register selection and add in new selection
    //

    TcicWriteBaseReg(SocketPtr, R_MODE,
                     (USHORT)((OldMode & ~MODE_AUXSEL_MASK) | Register));


    //
    // Read the selected AUX register
    //

    readData = TcicReadBaseReg(SocketPtr, R_AUX);

    //
    // Restore the mode reg to its original state
    //

    TcicWriteBaseReg(SocketPtr, R_MODE, OldMode);
    return readData;
}



VOID
TcicWriteAuxReg(
    IN PSOCKET SocketPtr,
    IN ULONG  Register,
    IN USHORT  value
    )

/*++

Routine Description:

    Write a value into the specified AUX register

Arguments:

    SocketPtr - instance data for this socket
    Register  - MODE_AR_xxx justified index of AUX register to write

Return Value:

    None

--*/

{
    USHORT readData = 0;
    USHORT OldMode;

    //
    // Get the current mode register value
    //

    OldMode = TcicReadBaseReg(SocketPtr, R_MODE);

    //
    // Mask out previous AUX register selection and add in new selection
    //

    TcicWriteBaseReg(SocketPtr, R_MODE,
                     (USHORT)((OldMode & ~MODE_AUXSEL_MASK) | Register));

    //
    // Write the data to the selected AUX register
    //

    TcicWriteBaseReg(SocketPtr, R_AUX, value);

    //
    // Restore the mode reg to its original state
    //

    TcicWriteBaseReg(SocketPtr, R_MODE, OldMode);
}



VOID
TcicReadIndirectRegs(
    IN PSOCKET SocketPtr,
    IN ULONG   StartRegister,
    IN USHORT  numWords,
    IN PUSHORT ReadBuffer
    )

/*++

Routine Description:

    Read one or multiple TCIC indirect registers.

Arguments:

    SocketPtr - instance data for this socket
    StartRegister - starting indirect register
    numWords - number of consecutive registers to read
    ReadBuffer - data buffer

Return Value:

    None

--*/

{
    USHORT OldHaddr;
    USHORT OldLaddr;
    USHORT OldSctrl;
    USHORT j;

    //
    // Get the current TCIC state
    //

    if (numWords > 1) {

        //
        // We won't set AUTO-Inc if only 1 word
        //

        OldSctrl = TcicReadBaseReg(SocketPtr, R_SCTRL);
    }

    OldLaddr = TcicReadBaseReg(SocketPtr, R_ADDR);
    OldHaddr = TcicReadBaseReg(SocketPtr, R_ADDR2);


    //
    // Set the TCIC state required for reading the indirect registers
    //

    TcicWriteBaseReg(SocketPtr, R_ADDR2,
                          (USHORT)(OldHaddr | ADR2_INDREG));
    TcicWriteBaseReg(SocketPtr, R_ADDR, (USHORT)StartRegister);
    if (numWords > 1) {
        TcicWriteBaseReg(SocketPtr, R_SCTRL, (USHORT)(OldSctrl | SCTRL_INCMODE_AUTO));
    }

    //
    // Read the Indirect registert requested
    //

    for (j = 0; j < numWords; j++) {
        *ReadBuffer++ = TcicReadBaseReg(SocketPtr, R_DATA);
    }

    //
    // Restore the original TCIC state
    //

    if (numWords > 1) {

        //
        // We didn't set AUTO-Inc if only 1 word
        //

        TcicWriteBaseReg(SocketPtr, R_SCTRL, OldSctrl);
    }
    TcicWriteBaseReg(SocketPtr, R_ADDR2, OldHaddr);
    TcicWriteBaseReg(SocketPtr, R_ADDR,  OldLaddr);
}



VOID
TcicWriteIndirectRegs(
    IN PSOCKET SocketPtr,
    IN ULONG   StartRegister,
    IN USHORT  numWords,
    IN PUSHORT WriteBuffer
    )

/*++

Routine Description:

    Write one or multiple TCIC indirect registers.

Arguments:

    SocketPtr - instance data for this socket
    StartRegister - starting indirect register
    numWords - number of consecutive registers to write
    WriteBuffer - data buffer

Return Value:

    None

--*/

{
    USHORT OldHaddr;
    USHORT OldLaddr;
    USHORT OldSctrl;
    USHORT j;

    //
    // Get the current TCIC state
    //

    if (numWords > 1) {

        //
        // We won't set AUTO-Inc if only 1 word
        //

        OldSctrl = TcicReadBaseReg(SocketPtr, R_SCTRL);
    }

    OldLaddr = TcicReadBaseReg(SocketPtr, R_ADDR);
    OldHaddr = TcicReadBaseReg(SocketPtr, R_ADDR2);

    //
    // Set the TCIC state required for reading the indirect registers
    //

    TcicWriteBaseReg(SocketPtr, R_ADDR2, (USHORT)(OldHaddr | (USHORT)ADR2_INDREG));
    TcicWriteBaseReg(SocketPtr, R_ADDR, (USHORT)StartRegister);
    if (numWords > 1) {
        TcicWriteBaseReg(SocketPtr, R_SCTRL, (USHORT)(OldSctrl | SCTRL_INCMODE_AUTO));
    }

    //
    // Read the Indirect registert requested
    //

    for (j = 0; j < numWords; j++) {
        TcicWriteBaseReg(SocketPtr, R_DATA, *WriteBuffer++);
    }

    //
    // Restore the original TCIC state
    //

    if (numWords > 1) {

        //
        // We didn't set AUTO-Inc if only 1 word
        //

        TcicWriteBaseReg(SocketPtr, R_SCTRL, OldSctrl);
    }
    TcicWriteBaseReg(SocketPtr, R_ADDR2, OldHaddr);
    TcicWriteBaseReg(SocketPtr, R_ADDR,  OldLaddr);
}





USHORT
TcicSocketSelect(
    IN PSOCKET SocketPtr,
    IN USHORT sktnum
    )

/*++

Routine Description:

    Map the specified socket registers into TCIC register space.

Arguments:

    SocketPtr - instance data for this socket
    sktnum   - socket number to map.

Return Value:

    previous socket mapped.

--*/

{
    USHORT OldAddrHi;

    OldAddrHi = READ_PORT_USHORT((PUSHORT)(SocketPtr->AddressPort + R_ADDR2));

    WRITE_PORT_USHORT((PUSHORT)(SocketPtr->AddressPort + R_ADDR2),
                      (USHORT)((OldAddrHi & ~TCIC_SS_MASK) | (USHORT)(sktnum << TCIC_SS_SHFT)));

    return (USHORT)((OldAddrHi & TCIC_SS_MASK) >> TCIC_SS_SHFT);
}



ULONG
TcicReadCardMemory(
    IN PPDO_EXTENSION PdoExtension,
    IN MEMORY_SPACE MemorySpace,
    IN ULONG   Offset,
    IN PUCHAR  Buffer,
    IN ULONG   Length
    )

/*++

Routine Description:

    This routine will set up the card to read attribute memory.

Arguments:

    SocketPtr -- The socket info in for the card being read
    Offset   -- Offset from which to read
    MemorySpace -- Attribute memory or Common Memory
    Buffer --   Pointer to buffer in which memory contents are returned
    Length --   No. of bytes to be returned

Return Value:

    TRUE - if read was successful.

--*/

{
    PSOCKET SocketPtr = PdoExtension->Socket;
    ULONG  size;
    ULONG  tcicaddr;
    ULONG  i;
    USHORT word;

    //
    // Make sure the card is ready
    //

    if (!TcicPCCardReady(SocketPtr)) {
        DebugPrint((PCMCIA_PCCARD_READY,
                        "Tcic: PCCARD %x not ready for read attribute memory\n",
                        SocketPtr->RegisterOffset));
    }

    if (MemorySpace != PCCARD_ATTRIBUTE_MEMORY) {

        return 0;
    }

    tcicaddr = ADDR_REG | (SocketPtr->RegisterOffset << ADDR_SS_SHFT);
    TcicWriteAddrReg(SocketPtr, tcicaddr);

    word = TcicReadBaseReg(SocketPtr, R_SCTRL);
    word |= SCTRL_INCMODE_AUTO;
    TcicWriteBaseReg(SocketPtr, R_SCTRL, word);

    //
    // Hardware needs to settle
    //
    PcmciaWait(50000);

    //
    // Skip up to the offset
    //
    for (i = 0; i < Offset; i++) {
        (VOID)TcicReadBaseReg(SocketPtr, R_DATA);
    }

    //
    // Read the attribute memory
    //
    for (i = 0; i < Length; i++) {
        *Buffer++ = (UCHAR)TcicReadBaseReg(SocketPtr, R_DATA);
    }

    return Length;
}



ULONG
TcicWriteCardMemory(
    IN PPDO_EXTENSION PdoExtension,
    IN MEMORY_SPACE MemorySpace,
    IN ULONG  Offset,
    IN PUCHAR Buffer,
    IN ULONG  Length
    )
/*++

Routine Description:
    This routine will write into the configuration memory on the card
    with the supplied buffer. This is provided as a service to certain
    client drivers (netcard) which need to write to the attribute memory
    (say) to set parameters etc.

Arguments:

    SocketPtr   -- The socket info in for the card being written to
    MemorySpace -- indicates which space - attribute or common memory
    Offset      -- Offset in the memory to write to
    Buffer      -- Buffer contents being dumped to the card
    Length      -- Length of the buffer being written out

--*/
{

    PSOCKET SocketPtr = PdoExtension->Socket;
#define TCIC_ATTRIBUTE_MEM_WINDOW_INDEX 5
    PUCHAR  memoryPtr;
    ULONG   index;
    UCHAR   memGran;

    memGran = (MemorySpace == PCCARD_ATTRIBUTE_MEMORY)? 2 : 1;

    memoryPtr=((PFDO_EXTENSION) (SocketPtr->DeviceExtension))->AttributeMemoryBase +
                 memGran * Offset;

    TcicSetMemWin(SocketPtr,
                  (USHORT) (TCIC_ATTRIBUTE_MEM_WINDOW_INDEX+SocketPtr->SocketNumber),
                  0,
                  SocketPtr->DeviceExtension->PhysicalBase.LowPart,
                  SocketPtr->DeviceExtension->AttributeMemorySize,
                  (UCHAR) (MemorySpace == PCCARD_ATTRIBUTE_MEMORY),
                  0,
                  0);

    if (!TcicPCCardReady(SocketPtr)) {
        DebugPrint((PCMCIA_PCCARD_READY,
                        "TCIC: PCCARD in socket %x not ready for write memory\n",
                        SocketPtr->RegisterOffset));
    }
    for (index=0; index < Length; index++) {
        WRITE_REGISTER_UCHAR(memoryPtr, Buffer[index]);
        memoryPtr += memGran;
    }

    TcicSetMemWin(SocketPtr,
                  (USHORT) (TCIC_ATTRIBUTE_MEM_WINDOW_INDEX+SocketPtr->SocketNumber),
                  0,
                  0,
                  0,
                  0,
                  0,
                  0);
    return Length;
}



BOOLEAN
TcicProcessConfigureRequest(
    IN PSOCKET socketPtr,
    IN PCARD_REQUEST request,
    IN PUCHAR Base
    )

/*++

Routine Description:

    Processes a configure or IRQ setup request.

Arguments:

    socketPtr - instance data for this socket
    ConfigRequest -- Socket config structure
    Base - the I/O port base   - not used

Return Value:

    None

--*/

{
    USHORT          index, index2;
    USHORT          tmp;
    ULONG           ltmp;
    USHORT               words[3];
    PDBSOCKET            pdbs;

    //
    // Since all first entries in the config structure is a RequestType,
    // cast the pointer comming in as a PREQUEST_CONFIG to get the proper
    // RequestType
    //

    switch (request->RequestType) {
    case IO_REQUEST:

        //
        // Set up I/O ranges on the controller
        //

        for (index = 0; index < request->u.Io.NumberOfRanges; index++) {
            if (request->u.Io.IoEntry[index].BasePort != 0) {
                TcicSetIoWin(socketPtr, index,
                             request->u.Io.IoEntry[index].BasePort,
                             request->u.Io.IoEntry[index].NumPorts,
                             request->u.Io.IoEntry[index].Attributes);
            } else {
                DebugPrint((PCMCIA_DEBUG_FAIL, "PCMCIA: Got an IO Configure Request with an invalid Port\n"));
                break;
            }
        }
        break;

    case IRQ_REQUEST:

        pdbs = (PDBSOCKET)socketPtr;
        ltmp = ADDR_INDREG | (socketPtr->RegisterOffset << ADDR_SS_SHFT);
        ltmp |= (ULONG)IR_SCFG_S(socketPtr->RegisterOffset);
        TcicWriteAddrReg(socketPtr, ltmp);
        TcicWriteBaseReg(socketPtr, R_SCTRL, SCTRL_ENA);
        tmp = TcicReadBaseReg(socketPtr, R_DATA);
        tmp &= ~IRSCFG_IRQ_MASK;
        tmp |= pdbs->IRQMapTbl[request->u.Irq.AssignedIRQ];
        TcicWriteBaseReg(socketPtr, R_DATA, tmp);
        break;

    case CONFIGURE_REQUEST:

        //
        // This is where we setup the card and get it ready for operation
        //

        if (!TcicPCCardReady(socketPtr)) {
            DebugPrint((PCMCIA_PCCARD_READY,
                            "Tcic: PCCARD %x not ready for configuration index\n",
                            socketPtr));
            return FALSE;
        }

        if (request->u.Config.RegisterWriteMask & REGISTER_WRITE_CONFIGURATION_INDEX) {
            ltmp = request->u.Config.ConfigBase;
            ltmp |= ADDR_REG | (socketPtr->RegisterOffset << ADDR_SS_SHFT);
            TcicWriteAddrReg(socketPtr, ltmp);
            TcicWriteBaseReg(socketPtr, R_SCTRL, SCTRL_ENA);

            TcicWriteBaseReg(socketPtr, R_DATA, request->u.Config.ConfigIndex);
            PcmciaWait(TcicStallCounter);
            TcicWriteBaseReg(socketPtr, R_DATA,
                                  (USHORT)(request->u.Config.ConfigIndex | 0x40));
            PcmciaWait(TcicStallCounter);
        }
        if (request->u.Config.RegisterWriteMask & REGISTER_WRITE_CARD_CONFIGURATION) {
            ltmp = request->u.Config.ConfigBase + 2;
            ltmp |= ADDR_REG | (socketPtr->RegisterOffset << ADDR_SS_SHFT);
            TcicWriteAddrReg(socketPtr, ltmp);
            TcicWriteBaseReg(socketPtr, R_SCTRL, SCTRL_ENA);

            tmp = TcicReadBaseReg(socketPtr, R_DATA);
            tmp |= request->u.Config.CardConfiguration;

            //
            // turn off power control bit
            //

            tmp &= ~0x04;

            TcicWriteBaseReg(socketPtr, R_DATA, tmp);
        }
        break;

    case DECONFIGURE_REQUEST:
        //
        // Deregister the interrupt
        //
        pdbs = (PDBSOCKET)socketPtr;
        ltmp = ADDR_INDREG | (socketPtr->RegisterOffset << ADDR_SS_SHFT);
        ltmp |= (ULONG)IR_SCFG_S(socketPtr->RegisterOffset);
        TcicWriteAddrReg(socketPtr, ltmp);
        TcicWriteBaseReg(socketPtr, R_SCTRL, SCTRL_ENA);
        tmp = TcicReadBaseReg(socketPtr, R_DATA);
        tmp &= ~IRSCFG_IRQ_MASK;
        TcicWriteBaseReg(socketPtr, R_DATA, tmp);

        //
        // Disable I/O, memory windows
        //
        break;

    case MEM_REQUEST:

        //
        // Set up memory ranges on the controller.
        //

        for (index = 0; index < request->u.Memory.NumberOfRanges; index++) {

            TcicSetMemWin(socketPtr,
                          index,
                          request->u.Memory.MemoryEntry[index].BaseAddress,
                          request->u.Memory.MemoryEntry[index].HostAddress,
                          request->u.Memory.MemoryEntry[index].WindowSize,
                          request->u.Memory.MemoryEntry[index].AttributeMemory,
                          request->u.Memory.AccessSpeed,
                          request->u.Memory.Attributes);
        }
        break;


    default:
        DebugPrint((PCMCIA_DEBUG_FAIL, "PCMCIA: ConfigRequest is INVALID!\n"));

    }
    return TRUE;
}



BOOLEAN
TcicDetectCardInSocket(
    IN PSOCKET socketPtr
    )

/*++

Routine Description:

    This routine will determine if a card is in the socket

Arguments:

    SocketPtr -- Socket info.

Return Value:

    TRUE if card is present.

--*/

{
    //
    // Get the specified socket mapped into  the TCIC registers
    //

    TcicSocketSelect(socketPtr, socketPtr->RegisterOffset);

    //
    // Read the Tcic status register to see if the card is in there.
    //
    return (TcicReadBaseReg(socketPtr, R_SSTAT) & SSTAT_CD) ?TRUE :FALSE;
}



BOOLEAN
TcicDetectCardChanged(
    IN PSOCKET socketPtr
    )

/*++

Routine Description:

    This routine will determine if socket's card insertion status has changed.

Arguments:

    socketPtr -- Socket info.

Return Value:

    TRUE if card insertion status has changed.

--*/

{
    BOOLEAN changed;

    //
    // Get the specified socket mapped into  the TCIC registers
    //

    TcicSocketSelect(socketPtr, socketPtr->RegisterOffset);

    //
    // Read the Tcic ICSR register to see if CD's have changed.
    //

    changed = (TcicReadBaseReg(socketPtr, R_ICSR) & ICSR_CDCHG) ?TRUE :FALSE;

    //
    // Clear bits in ICSR
    //

    while (TcicReadBaseReg(socketPtr, R_ICSR)) {
        TcicWriteBaseReg(socketPtr, R_ICSR, ICSR_JAM);
    }

    return (changed);
}



BOOLEAN
TcicDetectReadyChanged(
    IN PSOCKET socketPtr
    )
{
    return FALSE;
}



BOOLEAN
TcicPCCardReady(
    IN PSOCKET SocketPtr
    )

/*++

Routine Description:

    Loop for a reasonable amount of time waiting for the card status to
    return ready.

Arguments:

    SocketPtr - instance data for the socket to check.

Return Value:

    TRUE - the card is ready.
    FALSE - after a reasonable delay the card is still not ready.

--*/

{
    ULONG index;

    //
    // Get the specified socket mapped into  the TCIC registers
    //

    TcicSocketSelect(SocketPtr, SocketPtr->RegisterOffset);

    for (index = 0;
         index < 500000
         && !(TcicReadBaseReg(SocketPtr, R_SSTAT) & SSTAT_RDY);
         index++) {

        PcmciaWait(20);
        //
        // Check if the card is still there: if not, we can return
        //
        if (!TcicDetectCardInSocket(SocketPtr)) {
            return FALSE;
        }
    }

    if (index < 500000) {
        DebugPrint((PCMCIA_COUNTERS, "TcicPCCardReady: %d\n", index));
        return TRUE;
    }
    return FALSE;
}




NTSTATUS
TcicDetect(
    IN PFDO_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    Locate any PCMCIA sockets supported by this driver.    This routine
    will find the TCIC2 and compatible parts.

Arguments:

    DeviceExtension - the root for the SocketList.

Return Value:

    STATUS_SUCCESS if a socket is found - failure status otherwise.

--*/

{
    ULONG             ioPortBase        = 0x100;
    ULONG             ioBaseIncrement = 0x10;
    ULONG             tcicLowAddr;
    ULONG             tcicHighAddr;
    ULONG             addressSpace;
    BOOLEAN           mapped;
    PHYSICAL_ADDRESS cardAddress;
    PHYSICAL_ADDRESS portAddress;
    SOCKET            locskt;
    UCHAR             socketNumber = 0;
    static  BOOLEAN  foundOne = FALSE;
    BOOLEAN           resourcesAllocated = FALSE;
    BOOLEAN           conflict;
    PCM_RESOURCE_LIST cmResourceList = NULL;
    PCM_PARTIAL_RESOURCE_LIST cmPartialResourceList;
    NTSTATUS          status;

    if (foundOne) {
        //
        //  No support for multiple controllers currently..
        //  So we just give up if one controller was already reported
        //
        return STATUS_NO_MORE_ENTRIES;
    }


    DeviceExtension->Configuration.InterfaceType = Isa;
    DeviceExtension->Configuration.BusNumber = 0x0;

    TcicRegistryLookupScanLimits(&tcicLowAddr, &tcicHighAddr);

    //
    // Get the resources used for detection
    //
    cmResourceList = ExAllocatePool(PagedPool, sizeof(CM_RESOURCE_LIST));

    if (!cmResourceList) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(cmResourceList, sizeof(CM_RESOURCE_LIST));
    cmResourceList->Count = 1;
    cmResourceList->List[0].InterfaceType = Isa;
    cmPartialResourceList = &(cmResourceList->List[0].PartialResourceList);
    cmPartialResourceList->Version  = 1;
    cmPartialResourceList->Revision = 1;
    cmPartialResourceList->Count      = 1;
    cmPartialResourceList->PartialDescriptors[0].Type = CmResourceTypePort;
    cmPartialResourceList->PartialDescriptors[0].ShareDisposition = CmResourceShareDeviceExclusive;
    cmPartialResourceList->PartialDescriptors[0].Flags = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_10_BIT_DECODE;
    cmPartialResourceList->PartialDescriptors[0].u.Port.Length = 2;


    for (ioPortBase = tcicLowAddr;
         ioPortBase < tcicHighAddr;
         ioPortBase += ioBaseIncrement) {

        //
        // Reset ioBaseIncrement to default value
        //

        ioBaseIncrement = 0x10;

        addressSpace = 1; // port space
        portAddress.LowPart = ioPortBase;
        portAddress.HighPart = 0;

        //
        // Free up the allocated resources if any
        //
        if (resourcesAllocated) {
            IoReportResourceForDetection(DeviceExtension->DriverObject,
                                                  NULL, 0, NULL, NULL, 0, &conflict);
        }

        resourcesAllocated = FALSE;
        cmPartialResourceList->PartialDescriptors[0].u.Port.Start = portAddress;

        status=IoReportResourceForDetection(
                                            DeviceExtension->DriverObject,
                                            cmResourceList,
                                            sizeof(CM_RESOURCE_LIST),
                                            NULL,
                                            NULL,
                                            0,
                                            &conflict);
        if (!NT_SUCCESS(status) || conflict) {
            continue;
        }
        resourcesAllocated = TRUE;


        if (!HalTranslateBusAddress(Isa, 0, portAddress, &addressSpace,&cardAddress)) {
            continue;
        }

        if (addressSpace) {
            mapped = FALSE;
            locskt.AddressPort = (PUCHAR)(cardAddress.QuadPart);
        } else {
            mapped = TRUE;
            locskt.AddressPort = MmMapIoSpace(cardAddress, 0x10, FALSE);
        }

        locskt.RegisterOffset = 0;

        //
        // Sniff the address to see if it even resembles a TCIC chip
        //

        foundOne = TcicReservedBitsOK(&locskt);
        if (mapped) {
            MmUnmapIoSpace(locskt.AddressPort, 0x10);
        }

        //
        // Found an adapter
        //

        if (foundOne) {
            PcmciaSetControllerType(DeviceExtension, PcmciaDatabook);
            break;
        }
#if 0
        //
        // Now check for the aliases
        //

        switch (TcicCheckAliasType((PDBSOCKET)socketPtr)) {
        case TCIC_IS140:

            //
            // TMI-140s decode 32 consecutive bytes, make
            // sure we skip past the alias
            //

            ioBaseIncrement += 0x10;
            break;

        }
#endif
    }

    //
    // Free up the allocated resources if any
    //
    if (resourcesAllocated) {
        IoReportResourceForDetection(DeviceExtension->DriverObject,
                                     NULL, 0, NULL, NULL, 0, &conflict);
    }
    //
    // Free up allocated memory if any
    //
    if (cmResourceList) {
        ExFreePool(cmResourceList);
    }
    return foundOne ? STATUS_SUCCESS : STATUS_NO_MORE_ENTRIES;
}



NTSTATUS
TcicBuildSocketList(
    IN PFDO_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    Locate any PCMCIA sockets supported by this driver.    This routine
    will find the TCIC2 and compatible parts and construct DBSOCKET
    structures to represent all sockets found.

Arguments:

    DeviceExtension - the root for the SocketList.

Return Value:

    STATUS_SUCCESS if a socket is found - failure status otherwise.

--*/

{
    PSOCKET           socketPtr = NULL;
    PSOCKET           previousSocketPtr;
    SOCKET            locskt;
    static UCHAR      socketNumber = 0;

    previousSocketPtr = NULL;


    locskt.RegisterOffset = 0;
    locskt.AddressPort = (PUCHAR)DeviceExtension->Configuration.UntranslatedPortAddress;

    //
    // Sniff the address to see if it even resembles a TCIC chip
    //

    if (TcicReservedBitsOK(&locskt) == FALSE ) {
        return STATUS_NO_MORE_ENTRIES;
    }

    //
    // Found an adapter
    //

    TcicFillInAdapter(&locskt,
                      &socketPtr,
                      &previousSocketPtr,
                      DeviceExtension,
                      (ULONG)DeviceExtension->Configuration.UntranslatedPortAddress);

    if (socketPtr == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    socketPtr->SocketNumber = socketNumber++;

    return STATUS_SUCCESS;
}




VOID
TcicFillInAdapter(
    IN PSOCKET plocskt,
    IN PSOCKET *psocketPtr,
    IN PSOCKET *previousSocketPtr,
    IN PFDO_EXTENSION DeviceExtension,
    IN ULONG   ioPortBase
    )

/*++

Routine Description:

    Fill in the DBSOCKET pointer info for the adapter just located by
    TcicDetect().  This routine is not part of TcicDetect() so as to allow
    for logic flow when dealing with multiple sockets or adapters.

Arguments:

    plocskt - info regarding the socket just found
    psocketPtr   - current socket ptr from caller
    previousSocketPtr - prev socket ptr form caller
    DeviceExtension    - head of socket list
    ioPortBase - physical i/o addr for this controller

Return Value:

    None

--*/

{
    PDBSOCKET dbsocketPtr = ExAllocatePool(NonPagedPool, sizeof(DBSOCKET));

    PAGED_CODE();

    if (!dbsocketPtr) {
        return;
    }
    RtlZeroMemory(dbsocketPtr, sizeof(DBSOCKET));
    dbsocketPtr->physPortAddr = ioPortBase;
    *psocketPtr = (PSOCKET)dbsocketPtr;

    (*psocketPtr)->DeviceExtension = DeviceExtension;
    (*psocketPtr)->RegisterOffset = 0;
    (*psocketPtr)->AddressPort = plocskt->AddressPort;
    (*psocketPtr)->SocketFnPtr = &TcicSupportFns;

    if (*previousSocketPtr) {
        (*previousSocketPtr)->NextSocket = *psocketPtr;
    } else {
        DeviceExtension->SocketList = *psocketPtr;
    }
    *previousSocketPtr = *psocketPtr;

    DebugPrint((PCMCIA_DEBUG_DETECT,
                    "PCMCIA: TCIC Port %x\n",
                    plocskt->AddressPort));

    //
    // Fill in the rest of the adapter info here...
    //

    TcicGetAdapterInfo(dbsocketPtr);

    //
    // See if there is a second socket on this TCIC
    //

    if (TcicCheckSkt(plocskt, 1)) {
        dbsocketPtr = ExAllocatePool(NonPagedPool, sizeof(DBSOCKET));
        if (dbsocketPtr) {
            RtlMoveMemory(dbsocketPtr, *psocketPtr, sizeof(DBSOCKET));
            *psocketPtr = (PSOCKET)dbsocketPtr;
            (*psocketPtr)->RegisterOffset = 1;
            (*previousSocketPtr)->NextSocket = *psocketPtr;
            *previousSocketPtr = *psocketPtr;
            dbsocketPtr->dflt_vcc5v = TcicGet5vVccVal(dbsocketPtr);
        }
    }
}




VOID
TcicGetAdapterInfo(
    IN PDBSOCKET dbsocketPtr
    )

/*++

Routine Description:

    Deterimine adapter specific information from detection heuristics.

Arguments:

    dbsocketPtr - structure to fill in.

Return Value:

    None

--*/

{
    PAGED_CODE();

    TcicChipID(dbsocketPtr);

    dbsocketPtr->niowins    = (UCHAR)TcicGetnIOWins(dbsocketPtr);
    dbsocketPtr->nmemwins   = (UCHAR)TcicGetnMemWins(dbsocketPtr);
    dbsocketPtr->clkdiv     = TcicClockRate(&dbsocketPtr->skt) - (USHORT)1;
    dbsocketPtr->dflt_vcc5v = TcicGet5vVccVal(dbsocketPtr);

    dbsocketPtr->dflt_wctl = (USHORT)((dbsocketPtr->clkdiv  != 0)
                                      ? (WAIT_BCLK | WAIT_RISING | WAIT_ASYNC)
                                      : (WAIT_ASYNC | WAIT_RISING));

    dbsocketPtr->dflt_syscfg = (USHORT)(SYSCFGMPSEL_EXTSEL | SYSCFG_MCSFULL);

    if (TcicCheckXBufNeeded(&dbsocketPtr->skt)) {
        dbsocketPtr->dflt_syscfg |= (USHORT)(SYSCFG_ICSXB | SYSCFG_MCSXB);
    }

    dbsocketPtr->dflt_ilock  = (USHORT)ILOCK_HOLD_CCLK;
    dbsocketPtr->dflt_wrmctl = (USHORT)0;
    dbsocketPtr->dflt_scfg1  = (USHORT)IRSCFG_IOSTS;

    TcicGetIRQMap(dbsocketPtr);

    //
    // Fiddle the map for all but 084/184 so that SKTIRQ (0bh) has
    // the correct map code (1)  (PNPFIX)
    //

    if (TcicHasSktIRQPin(dbsocketPtr) == TRUE && dbsocketPtr->IRQMapTbl[11] == 11) {
        dbsocketPtr->IRQMapTbl[11] = 1;
    }

}


PUCHAR
TcicAllocateMemRange(
    IN PFDO_EXTENSION DeviceExtension,
    IN PULONG Mapped,
    IN PULONG Physical
    )

/*++

Routine Description:

    Search the 640K to 1MB region for an 8K open area to be used
    for XBuffer checking.

Arguments:

    DeviceExtension - head of socket list
    Mapped  - state info from caller to allow later release
    Physical - state info from caller to allow later release

Return Value:

    A physical address for the window to the card or zero meaning
    there is no opening.

--*/

{
#define NUMBER_OF_TEST_BYTES 5
    PHYSICAL_ADDRESS physicalMemoryAddress;
    PHYSICAL_ADDRESS halMemoryAddress;
    BOOLEAN           translated;
    ULONG             untranslatedAddress;
    PUCHAR            memoryAddress;
    PUCHAR            bogus;
    ULONG             addressSpace;
    ULONG             index;
    UCHAR             memory[NUMBER_OF_TEST_BYTES];

    PAGED_CODE();

    *Mapped = FALSE;

    if (DeviceExtension->PhysicalBase.QuadPart) {
        untranslatedAddress = DeviceExtension->PhysicalBase.LowPart;
    } else {
        untranslatedAddress = 0xd0000;
    }

    for (/* nothing */; untranslatedAddress < 0xFF000; untranslatedAddress += TCIC_WINDOW_ALIGNMENT) {

        if (untranslatedAddress == 0xc0000) {

            //
            // This is VGA.  Keep this test if the for loop should
            // ever change.
            //

            continue;
        }
        addressSpace = 0;
        physicalMemoryAddress.LowPart = untranslatedAddress;
        physicalMemoryAddress.HighPart = 0;

        translated = HalTranslateBusAddress(Isa,
                                            0,
                                            physicalMemoryAddress,
                                            &addressSpace,
                                            &halMemoryAddress);

        if (!translated) {

            //
            // HAL doesn't like this translation
            //

            continue;
        }
        if (addressSpace) {
            memoryAddress = (PUCHAR)(halMemoryAddress.QuadPart);
        } else {
            memoryAddress = MmMapIoSpace(halMemoryAddress, TCIC_WINDOW_SIZE, FALSE);
        }

        //
        // Test the memory window to determine if it is a BIOS, video
        // memory, or open memory.  Only want to keep the window if it
        // is not being used by something else.
        //

        for (index = 0; index < NUMBER_OF_TEST_BYTES; index++) {
            memory[index] = READ_REGISTER_UCHAR(memoryAddress + index);
            if (index) {
                if (memory[index] != memory[index - 1]) {
                    break;
                }
            }
        }

        if (index == NUMBER_OF_TEST_BYTES) {

            //
            // There isn't a BIOS here
            //

            UCHAR memoryPattern[NUMBER_OF_TEST_BYTES];
            BOOLEAN changed = FALSE;

            //
            // Check for video memory - open memory should always remain
            // the same regardless what the changes are.  Change the
            // pattern previously found.
            //

            for (index = 0; index < NUMBER_OF_TEST_BYTES; index++) {
                memoryPattern[index] = ~memory[index];
                WRITE_REGISTER_UCHAR(memoryAddress + index,
                                     memoryPattern[index]);
            }

            //
            // See if the pattern in memory changed.
            // Some system exhibit a problem where the memory pattern
            // seems to be cached.  If this code is debugged it will
            // work as expected, but if it is run normally it will
            // always return that the memory changed.  This random
            // wandering seems to remove this problem.
            //

            for (index = 0; index < NUMBER_OF_TEST_BYTES; index++) {
                memoryPattern[index] = 0;
            }
            bogus = ExAllocatePool(NonPagedPool, 64 * 1024);

            if (bogus) {
                for (index = 0; index < 64 * 1024; index++) {
                    bogus[index] = 0;
                }
                ExFreePool(bogus);
            }

            //
            // Now go off and do the actual check to see if the memory
            // changed.
            //

            for (index = 0; index < NUMBER_OF_TEST_BYTES; index++) {

                if ((memoryPattern[index] = READ_REGISTER_UCHAR(memoryAddress + index)) != memory[index]) {

                    //
                    // It changed - this is not an area of open memory
                    //

                    changed = TRUE;
                }
                WRITE_REGISTER_UCHAR(memoryAddress + index,
                                            memory[index]);
            }

            if (!changed) {

                //
                // Area isn't a BIOS and didn't change when written.
                // Use this region for the memory window to PCMCIA
                // attribute memory.
                //

                *Mapped = addressSpace ? FALSE : TRUE;
                *Physical = untranslatedAddress;
                return memoryAddress;
            }
        }

        if (!addressSpace) {
            MmUnmapIoSpace(memoryAddress, TCIC_WINDOW_SIZE);
        }
    }

    return NULL;
}



BOOLEAN
TcicReservedBitsOK(
    IN PSOCKET pskt
    )

/*++

Routine Description:

    Various offsets from a base IO address are read and checked for
    reasonable values (e.g., see that reserved bits are zero)
    First the primary registers are checked, then if the mode
    register is pointing at an aux register that has reserved bits,
    then that value is checked as well.

    If the TCIC is not in reset, then the programming timers
    will have expired by the time this runs

    Further, a read from the data register should change the
    EDC register.

    Note that these tests are as nondestructive as possible, e.g.
    initially only read accesses are made to the IO range in question.

Arguments:

    pskt - pointer to an Instance data to work from.

Return Value:

    TRUE if all reserved bits are zero

--*/

{
    USHORT i, j, bits;

    PAGED_CODE();
    //
    // R_ADDR bits 30:28 have restricted range
    //

    i = (USHORT)((TcicReadBaseReg(pskt, R_ADDR2) & TCIC_SS_MASK) >> TCIC_SS_SHFT);
    if ( i > 1) {
        return FALSE;
    }

    //
    // R_SCTRL bits 6,2,1 are reserved
    //

    if (TcicReadBaseReg(pskt, R_SCTRL) & ((~(SCTRL_ENA|SCTRL_INCMODE|SCTRL_EDCSUM|SCTRL_RESET)) & 0x00ff)) {
        return FALSE;
    }


    //
    // R_ICSR bit 2 must be same as bit 3
    //

    i = TcicReadBaseReg(pskt, R_ICSR);
    i &= (ICSR_ILOCK | ICSR_STOPCPU);
    if ((i != 0) && (i != (ICSR_ILOCK | ICSR_STOPCPU))) {
        return FALSE;
    }

    //
    // R_IENA bits 7,2 are reserved
    //

    if (TcicReadBaseReg(pskt, R_IENA) & ((~(IENA_CDCHG|IENA_PROGTIME|IENA_ILOCK|IENA_CFG_MASK)) & 0xff)) {
        return FALSE;
    }

    //
    // Some aux registers have reserved bits
    // Which are we looking at?
    //

    i = (USHORT)(TcicReadBaseReg(pskt, R_MODE) & MODE_AUXSEL_MASK);
    j = TcicReadBaseReg(pskt, R_AUX);
    switch (i) {
    case MODE_AR_SYSCFG:
        if (INVALID_AR_SYSCFG(j)) {
            return FALSE;
        }
        break;


    case MODE_AR_ILOCK:
        if (INVALID_AR_ILOCK(j)) {
            return FALSE;
        }
        break;

    case MODE_AR_TEST:
        if (INVALID_AR_TEST(j)) {
            return FALSE;
        }
        break;
    }

    //
    // Various bits set or not depending if in RESET mode
    //

    i = TcicReadBaseReg(pskt, R_SCTRL);
    if (i & SCTRL_RESET) {

        //
        // address bits must be 0 */
        //

        if ((TcicReadBaseReg(pskt, R_ADDR)  != 0) || (TcicReadBaseReg(pskt, R_ADDR2) != 0)) {
            return FALSE;
        }

        //
        // EDC bits must be 0 */
        //

        if (TcicReadBaseReg(pskt, R_EDC) != 0) {
            return FALSE;
        }

        //
        // We're OK, so take it out of reset
        // Note: we can write a 0 because RESET guarantees us that the
        // other bits in SCTRL are 0.
        //

        TcicWriteBaseReg(pskt, R_SCTRL, 0);

    } else {

        //
        // not in reset
        // programming timers must be expired
        //

        i = TcicReadBaseReg(pskt, R_SSTAT);
        if ((i & (SSTAT_6US | SSTAT_10US | SSTAT_PROGTIME)) != (SSTAT_6US | SSTAT_10US | SSTAT_PROGTIME)) {
            return FALSE;
        }

        //
        // EDC bits should change on read from data space
        // as long as either EDC or the data are nonzero
        //

        if ((TcicReadBaseReg(pskt, R_ADDR2) & ADR2_INDREG) == 0) {

            j = TcicReadBaseReg(pskt, R_EDC);
            i = TcicReadBaseReg(pskt, R_DATA);

            if ( i | j ) {
                i = TcicReadBaseReg(pskt, R_EDC);
                if (i==j) {
                    return FALSE;
                }
            }
        }

        j = TcicReadBaseReg(pskt, R_MODE);
        i = (USHORT)(j ^ MODE_AUXSEL_MASK);
        TcicWriteBaseReg(pskt, R_MODE, i);
        if (TcicReadBaseReg(pskt, R_MODE) != i) {
            return(FALSE);
        }

        TcicWriteBaseReg(pskt, R_MODE, j);
    }

    //
    // All tests passed
    //

    return TRUE;
}



USHORT
TcicChipID(
    IN PDBSOCKET pInst
    )

/*++

Routine Description:

    Read the silicon ID from a TCIC

Arguments:

    pInst - pointer to an Instance data to work from.

Return Value:

    The TCIC chip id.

--*/

{
    USHORT id, oldtest;

    PAGED_CODE();
    oldtest = TcicReadAuxReg (&pInst->skt, MODE_AR_TEST);
    TcicWriteAuxReg (&pInst->skt, MODE_AR_TEST, (USHORT)TEST_DIAG);
    id = TcicReadAuxReg (&pInst->skt, MODE_AR_ILOCK);
    TcicWriteAuxReg (&pInst->skt, MODE_AR_TEST, oldtest);
    id &= ILOCKTEST_ID_MASK;
    id >>= ILOCKTEST_ID_SHFT;

    //
    // clearn up IRQs inside TCIC
    //

    while (TcicReadBaseReg (&pInst->skt, R_ICSR)) {
        TcicWriteBaseReg (&pInst->skt, R_ICSR, ICSR_JAM);
    }

    return (pInst->chipType = id);
}



BOOLEAN
TcicCheckSkt(
    IN PSOCKET pInst,
    IN int iSocket
    )

/*++

Routine Description:

    If R_SSTAT shows a card inserted, we're done already.
    otherwise, we set up /CRDYBSY and /CWAIT such that if
    there is a socket present, they will float high

Arguments:

    pInst - pointer to an Instance data to work from.
    iSocket - zero-based socket number

Return Value:

    TRUE if given socket exists

--*/

{
    USHORT old_addr2;
    USHORT mode, pwr, sctrl;
    BOOLEAN retval = FALSE;
    BOOLEAN card_in = FALSE;
    int j, rdy, wait;
    USHORT save_pic;

    PAGED_CODE();

    //
    // Socket number OK?
    //

    if (iSocket > 1) {
        return FALSE;
    }

    //
    // save current socket, look at requested
    //

    old_addr2 = TcicReadBaseReg(pInst, R_ADDR2);
    TcicWriteBaseReg(pInst, R_ADDR2,
                     (USHORT)((old_addr2 & ~TCIC_SS_MASK) |
                              (iSocket << ADR2_SS_SHFT)));

    //
    // is there a card?
    //

    if (TcicReadBaseReg(pInst, R_SSTAT) & SSTAT_CD) {

        //
        // should set back address register before return.
        //

        TcicWriteBaseReg(pInst, R_ADDR2, old_addr2);
        return TRUE;

    } else {

        //
        // save mode, sctrl, and power for selected socket
        //

        mode = TcicReadBaseReg(pInst, (USHORT)R_MODE);
        pwr  = TcicReadBaseReg(pInst, (USHORT)R_PWR);
        sctrl = TcicReadBaseReg(pInst, (USHORT)R_SCTRL);

        //
        // check if power is already on- in case someone has
        // inadvertently turned on our power
        //

        if (pwr & 0x27) {
            TcicWriteBaseReg(pInst, R_PWR, (UCHAR)(pwr & ~0x27));
        }


        //
        // put chip into diagnostic mode, turn on VPP enables
        //

        TcicWriteAuxReg(pInst, MODE_AR_TEST,
                        (USHORT)(TEST_DIAG | TEST_VCTL));


        //
        // should see /CRDYBSY and /CWAIT low
        //

        if (!(TcicReadBaseReg(pInst, R_SSTAT) & SSTAT_RDY) &&
             (TcicReadAuxReg(pInst, MODE_AR_ILOCK) & ILOCK_CWAITSNS)) {

            //
            // 5V power on */
            //

            if (TcicIsPnP ((PDBSOCKET)pInst)) {
                TcicWriteBaseReg(pInst, R_PWR, (USHORT)(pwr | 0x27));
            } else {
                TcicWriteBaseReg(pInst, R_PWR,
                                 (UCHAR)(pwr | (iSocket==0? 1 : 2)));
            }

            //
            // should see /CRDYBSY and /CWAIT high within about 1.5 sec
            //

            for (j = 0; j < 75; j++) {
                rdy = TcicReadBaseReg(pInst, R_SSTAT) & SSTAT_RDY;
                wait = TcicReadAuxReg(pInst, MODE_AR_ILOCK) & ILOCK_CWAITSNS;

                if (rdy && !wait) {
                    retval = TRUE;
                    break;
                }
                PcmciaWait(20000);
            }

            //
            // Now be sure /CRDYBSY and /CWAIT drain
            //
            // turn power off
            //

            TcicWriteBaseReg(pInst, R_PWR, 0);

            //
            // force card enable */
            //

            TcicWriteAuxReg(pInst, MODE_AR_TEST,
                            (USHORT)(TEST_DIAG | TEST_VCTL | TEST_ENA) );

            //
            // turn on a bunch of bits for drain path
            //

            TcicWriteBaseReg(pInst, R_MODE,
                             MODE_PGMWR | MODE_PGMRD |
                             MODE_PGMCE | MODE_PGMWORD );

            //
            // enable the socket
            //

            TcicWriteBaseReg(pInst, R_SCTRL, 1);

            //
            // expect CRDYBSY to drain
            //

            for (j = 0; j < 75; j++) {
                rdy = TcicReadBaseReg(pInst, R_SSTAT) & SSTAT_RDY;
                if (!rdy) {
                    break;
                }
                PcmciaWait(20000);
            }

            //
            // Wait for noise to settle
            //

            for (j = 0; j < 50; j++) {
                PcmciaWait(20000);
            }
        }

        //
        // out of diag mode
        //

        TcicWriteAuxReg(pInst, MODE_AR_TEST, 0);

        //
        // clearn up IRQs inside TCIC
        //

        while (TcicReadBaseReg (pInst, R_ICSR)) {
            TcicWriteBaseReg (pInst, R_ICSR, ICSR_JAM);
        }

        //
        // restore original mode
        //

        TcicWriteBaseReg(pInst, R_MODE, mode);

        //
        // restore SCTRL
        //

        TcicWriteBaseReg(pInst, R_SCTRL, sctrl);

        //
        // set socket's power correctly
        //

        TcicWriteBaseReg(pInst, R_PWR, pwr);

        //
        // restore originally selected socket
        //

        TcicWriteBaseReg(pInst, R_ADDR2, old_addr2);

    }

    return retval;
}



USHORT
TcicCheckAliasing(
    IN PDBSOCKET pdbskt,
    IN USHORT offst
    )

/*++

Routine Description:

    For each of the 16 I/O locations in the TCIC, if any of
    the corresponding locations |offst| bytes higher are different,
    then aliasing is not occurring.  Exceptions, if the chip is
    active, may be found in R_DATA and R_SSTAT; accordingly, we
    avoid these registers in this check.
    If they all compare, then the R_MODE register is changed;
    if the corresponding change occurs in the image,
    then we have aliasing.

Arguments:

    pInst - pointer to an Instance data to work from.
    offst - offset to check for image of this TCIC at.

Return Value:

    TCIC_NONE:                  no TCIC found
    TCIC_NOALIAS:   different TCIC found
    TCIC_ALIAS:                 aliasing found

--*/

{
    int j;
    USHORT mode, flipmode;
    SOCKET  locskt;
    USHORT retval;
    PHYSICAL_ADDRESS cardAddress;
    PHYSICAL_ADDRESS portAddress;
    BOOLEAN mapped;
    ULONG   addressSpace;

    PAGED_CODE();
    //
    // Check for TCIC at image location, returning NONE if none found:
    //

    addressSpace = 1; // port space
    portAddress.LowPart = pdbskt->physPortAddr + offst;
    portAddress.HighPart = 0;

    if (!HalTranslateBusAddress(Isa, 0, portAddress, &addressSpace,&cardAddress)) {
        return retval = TCIC_NONE;
    }

    if (addressSpace) {
        mapped = FALSE;
        locskt.AddressPort = (PUCHAR)(cardAddress.QuadPart);

    } else {
        mapped = TRUE;
        locskt.AddressPort = MmMapIoSpace(cardAddress, 0x10, FALSE);
    }

    if (!TcicReservedBitsOK(&locskt)) {
        if (mapped) {
            MmUnmapIoSpace(locskt.AddressPort, 0x10);
        }

        return (retval = TCIC_NONE);
    }

    //
    // Check the R_xxx range for differences
    //

    for (j = R_ADDR; j < 16; ++j) {
        if (j != R_SSTAT) {
            if (READ_PORT_UCHAR(pdbskt->skt.AddressPort + j) != READ_PORT_UCHAR((locskt.AddressPort + j))) {
                if (mapped) {
                    MmUnmapIoSpace(locskt.AddressPort, 0x10);
                }
                return (retval = TCIC_NOALIAS);
            }
        }
    }

    //
    // OK, flip the mode register and see if it changes in the
    // aliased range
    //

    mode = TcicReadBaseReg(&pdbskt->skt, R_MODE) ^ 0xe0;
    TcicWriteBaseReg(&pdbskt->skt, R_MODE, mode);
    flipmode = TcicReadBaseReg(&pdbskt->skt, (USHORT)R_MODE + offst);
    TcicWriteBaseReg(&pdbskt->skt, R_MODE, (USHORT)(mode ^ 0xe0));

    if (flipmode == mode) {
        retval = TCIC_ALIAS;
    } else {
        retval = TCIC_NOALIAS;
    }

    if (mapped) {
        MmUnmapIoSpace(locskt.AddressPort, 0x10);
    }

    return retval;
}



USHORT
TcicCheckAliasType (
    IN PDBSOCKET pInst
    )

/*++

Routine Description:

    This function is useful for distinguishing among Databook
    controller cards.  For instance, the TMI-140 will be found
    at its base address and again at the base address + 10h, while
    the TMB-270 has two controllers separated by 400h, with aliases
    at an offset of 800h.

    Use TcicCheckAliasing to determine:
               1) Do we have a 270 (two non-identical TCICs appear, 400h
                         apart)?
               2) Do we have an "new-style" controller, with an image of
                         itself 800h away from the base address?
    For more detail, see TcicCheckAliasing above.

Arguments:

    pInst - socket instance info.

Return Value:

    A value encoding the results found:
    TCIC_IS270 : indicates 270 found
    TCIC_ALIAS800 : indicates base+800h alias found
    TCIC_IS140 : indicates base+10h alias found
    TCIC_ALIAS400 : indicates base+400h alias found

--*/

{
    USHORT retval = 0;

    PAGED_CODE();
    switch (TcicCheckAliasing (pInst, TCIC_OFFSET_400)) {
    case TCIC_NOALIAS :
        /* (indicating TCIC found, but not aliased) */
        retval |= TCIC_IS270;
        break;

    case TCIC_ALIAS :
        /* (indicating this TCIC appears again there) */
        retval |= TCIC_ALIAS400;
        break;
    }

    if (TcicCheckAliasing (pInst, TCIC_OFFSET_800) == TCIC_ALIAS) {
        retval |= TCIC_ALIAS800;
    }

    if (TcicCheckAliasing (pInst, TCIC_ALIAS_OFFSET) == TCIC_ALIAS) {
        retval |= TCIC_IS140;
    }

    return retval;
}



BOOLEAN
TcicCheckXBufNeeded(
    IN PSOCKET pInst
    )

/*++

Routine Description:

    Two overlapping memory windows are set up, a 16 bit and
    an 8 bit.
    We make two accesses to the memory area: 1st one accesses
    the 16-bit window, 2nd accesses the 8-bit window. They
    MUST be done back-to-back so that MCS16# doesn't have time
    to settle between the two accesses.
    We then check the value from accessing win2. (We don't
    care about the value from Win1, we just use it to make
    sure that MSC16# was asserted.) It should either match
    the value in PDATA or match the low byte in PDATA (082
    mem window bug.) If it matches for all iterations of the
    test, then we assume that external buffers are not
    present.

Arguments:

    pInst - pointer to an Instance data to work from.

Return Value:

    TRUE if external buffering needs to be turned on.

--*/

{
    PUCHAR winPhysAddr;
    PUCHAR WinMappedAddr;
    BOOLEAN ena_buffers = FALSE;
    PUSHORT pfoo1, pfoo2;
    USHORT foo1, foo2;
    int j;
    ULONG  mapped;

    PAGED_CODE();
    //
    // Alloc addr space for an 8K mem window
    //

    WinMappedAddr = TcicAllocateMemRange(pInst->DeviceExtension,
                                         &mapped,
                                         (PULONG)&winPhysAddr);

    //
    // If the alloc failed (WinLinear == NULL), there
    // really is no point in doing the test
    //

    if (WinMappedAddr != NULL) {

        //
        // Set R_ADDR to 0 to make sure that socket 0 is selected
        //

        TcicWriteBaseReg(pInst, R_ADDR, 0);
        TcicWriteBaseReg(pInst, R_ADDR2, 0);

        //
        // Turn on HA24-12 decoding
        //

        TcicWriteAuxReg(pInst, MODE_AR_SYSCFG, SYSCFG_MCSFULL);

        //
        // Setup a test value to drive into the mem windows
        //

        TcicWriteAuxReg(pInst, MODE_AR_PDATA,   0x5678);

        //
        // Set the window to USHORT regardless of CD states
        //

        TcicWriteAuxReg(pInst, MODE_AR_TEST, TEST_ENA | TEST_DRIVECDB);

        //
        // Make sure that PDATA is being driven to the windows
        //

        TcicWriteBaseReg(pInst, R_MODE, MODE_PGMDBW | MODE_PGMWORD);

        //
        // Enable the socket, set INCMODE for convenience
        //

        TcicWriteBaseReg(pInst, R_SCTRL, SCTRL_ENA | SCTRL_INCMODE_AUTO);

        //
        // cook the TCIC's idea of the base addr
        //

        ((ULONG_PTR)winPhysAddr) >>= MBASE_HA_SHFT;

        //
        // setup the two windows
        //

        TcicSetMemWindow(pInst, 0, (ULONG_PTR)winPhysAddr, 1, (USHORT)MCTL_ENA);
        TcicSetMemWindow(pInst, 1, (ULONG_PTR)(winPhysAddr + 1), 1,
                              (USHORT)(MCTL_ENA | MCTL_B8));

        //
        // Now setup two pointers, one into each window.
        // We'll set pfoo2 to point to the 1st USHORT of Win2 and
        // pfoo1 to point to the last USHORT of Win1.
        //

        pfoo1 = pfoo2 = (PUSHORT)(WinMappedAddr + 0x1000);
        pfoo1--;

        //
        // Now the test
        //

        for (j = 0; j < 100; j++) {
            foo1 = READ_REGISTER_USHORT(pfoo1);
            foo2 = READ_REGISTER_USHORT(pfoo2);

            if (foo2 != 0x5678 && foo2 != 0x7878) {
                ena_buffers = TRUE;
                break;
            }
        }

        //
        // last, restore the TCIC to a sane condition
        //

        TcicSetMemWindow(pInst, 0, 0, 0, 0);
        TcicSetMemWindow(pInst, 1, 0, 0, 0);
        TcicWriteAuxReg(pInst, MODE_AR_SYSCFG, 0);
        TcicWriteAuxReg(pInst, MODE_AR_PDATA, 0);
        TcicWriteAuxReg(pInst, MODE_AR_TEST, 0);
        TcicWriteBaseReg(pInst, R_MODE, 0);
        TcicWriteBaseReg(pInst, R_SCTRL, 0);
    }

    if (WinMappedAddr != NULL && mapped) {
        MmUnmapIoSpace(WinMappedAddr, TCIC_WINDOW_SIZE);
    }

    return ena_buffers;
}



VOID
TcicSetMemWindow(
    IN PSOCKET pInst,
    IN USHORT wnum,
    IN ULONG_PTR base,
    IN USHORT npages,
    IN USHORT mctl
    )

/*++

Routine Description:

    Helper function for TcicCheckXBufNeeded()

Arguments:

    pInst - pointer to an Instance data to work from.
    wnum  - window number (0 - n memwindows)
    base  - base Host addr to map to
    npages- window size in 4k pages
    mctl  - window ctrl reg value

Return Value:

    None

--*/

{
    USHORT map;
    USHORT winvals[3];

    PAGED_CODE();
    winvals[1] = (USHORT)(((short)base * -1) & 0x3fff);
    winvals[0] = npages == 1 ? (USHORT)base | MBASE_4K :(USHORT)base;
    winvals[2] = mctl;

    TcicWriteIndirectRegs(pInst, (USHORT)IR_MBASE_W(wnum), 3, winvals);
}




VOID
TcicGetPossibleIRQs(
    IN PDBSOCKET pInst,
    IN UCHAR *ptbl
    )

/*++

Routine Description:

    The given array is filled in with the irqcaps data determined
    from the chip properties.
    If this is a Plug n Play chip, the IR_ADPTCFG register is
    used to provide additional data

Arguments:

    pInst - pointer to an Instance data to work from.
    ptbl  - pointer to list buffer to fill in.

Return Value:

    None

--*/

{
    int j;
    CHIPPROPS *pcp;
    UCHAR *pbtbl;

    PAGED_CODE();
    if ((pcp = TcicGetChipProperties(pInst)) == NULL) {
        return;
    }

    //
    // If we're using the 082 table, and we've got a divided clock,
    // assume that IRQ6 and IRQ9 are crossed. Likewise, if we've got
    // an 072 table and divided clock, assume that 9 and 14 are
    // crossed.
    //

    pbtbl = pcp->irqcaps;

    if (pInst->clkdiv != 0) {
        if (pbtbl == irqcaps_082) {
            pbtbl = irqcaps_082sw;
        } else {
            if (pbtbl == irqcaps_072) {
                pbtbl = irqcaps_072sw;
            }
        }
    }

    for (j = 0; j < 16 ; j++) {
        ptbl[j] = pbtbl[j];
    }


    /*
     * If this chip is a PNP chip, then we need to consult the
     * IR_ADPTCFG reg to see if additional IRQs are available
     */
    if (TcicIsPnP(pInst)) {
        USHORT adptcfg;
        long old_addr;

        old_addr = TcicReadAddrReg(&pInst->skt);
        TcicWriteAddrReg(&pInst->skt, ADDR_INDREG | IR_ADPTCFG0);

        adptcfg = TcicReadBaseReg(&pInst->skt, R_DATA);
        TcicWriteAddrReg(&pInst->skt, old_addr);

        if (adptcfg & IRADPCF0_IRQ6) {
            ptbl[6] = 6;
        }
        if (adptcfg & IRADPCF0_IRQ9) {
            ptbl[9] = 9;
        }
        if (adptcfg & IRADPCF0_IRQ12) {
            ptbl[12] = 12;
        }
        if (adptcfg & IRADPCF0_IRQ15) {
            ptbl[15] = 15;
        }
    }
}




CHIPPROPS *
TcicGetChipProperties(
    IN PDBSOCKET pInst
    )

/*++

Routine Description:

    Search the ChipProperties table for the matching entry

Arguments:

    pInst - pointer to an Instance data to work from.

Return Value:

    ptr to chip properties table entry.

--*/

{
    int j;

    for (j = 0; ChipProperties[j].chip_id != 0 ;j++) {
        if (ChipProperties[j].chip_id == pInst->chipType) {
            return &ChipProperties[j];
        }
    }
    return (CHIPPROPS *)NULL;
}



BOOLEAN
TcicChipIDKnown(
    IN PDBSOCKET pInst
    )

/*++

Routine Description:

    Determine if the chip id makes sense

Arguments:

    pInst - pointer to an Instance data to work from.

Return Value:

    TRUE if chip ID is sane.

--*/

{
    return (TcicGetChipProperties(pInst) != NULL);
}




USHORT
TcicGetnIOWins(
    IN PDBSOCKET pInst
    )

/*++

Routine Description:

    Get the I/O window count based on chip properties, or zero
    if the chip is unidentified

Arguments:

    pInst - pointer to an Instance data to work from.

Return Value:

    number of io windows present.

--*/

{
    CHIPPROPS *pcp = TcicGetChipProperties(pInst);

    PAGED_CODE();
    return (pcp ?pcp->niowins :0);
}



USHORT
TcicGetnMemWins(
    IN PDBSOCKET pInst
    )

/*++

Routine Description:

    Get the memory window count based on chip properties, or zero
    if the chip is unidentified

Arguments:

    pInst - pointer to an Instance data to work from.

Return Value:

    number of memory windows present.

--*/

{
    CHIPPROPS *pcp = TcicGetChipProperties(pInst);

    PAGED_CODE();
    return (pcp ?pcp->nmemwins :0);
}



USHORT
TcicGetFlags(
    IN PDBSOCKET pInst
    )

/*++

Routine Description:

    Get the properties flag bits for this model of TCIC

Arguments:

    pInst - pointer to an Instance data to work from.

Return Value:

    flag bits from chip properties table.

--*/

{
    CHIPPROPS *pcp = TcicGetChipProperties (pInst);
    PAGED_CODE();
    return (pcp ? pcp->fprops : fINVALID);
}




BOOLEAN
TcicIsPnP(
    IN PDBSOCKET pInst
    )
/*++

Routine Description:

    Determine if this chip is a Plug-n-Play chip

Arguments:

    pInst - pointer to an Instance data to work from.

Return Value:

    True if chip is PnP (084/184)

--*/

{
    CHIPPROPS *pcp = TcicGetChipProperties(pInst);

    return (pcp ?pcp->fprops & fIS_PNP :FALSE);
}



BOOLEAN
TcicHasSktIRQPin(
    IN PDBSOCKET pInst
    )

/*++

Routine Description:

    Determine if this chip has a SKT IRQ pin.

Arguments:

    pInst - pointer to an Instance data to work from.

Return Value:

    TRUE if chip has the SktIRQ pin.

--*/

{
    CHIPPROPS *pcp = TcicGetChipProperties(pInst);

    PAGED_CODE();
    return (pcp ?pcp->fprops & fSKTIRQPIN :FALSE);
}




USHORT
TcicGet5vVccVal(
    IN PDBSOCKET pInst
    )

/*++

Routine Description:

    Get the correct R_PWR bits to establish 5V.

Arguments:

    pInst - pointer to an Instance data to work from.

Return Value:

    5v Vcc R_PWR bits.

--*/

{
    USHORT j;
    USHORT pwr;
    CHIPPROPS *pcp = TcicGetChipProperties(pInst);

    PAGED_CODE();
    //
    // Get Table size
    //
    if (pcp == NULL) {
        return 0;
    }

    j = pcp->privpwrtbl[0];

    pwr = pcp->privpwrtbl[j + 1];

    //
    // If not from the 084 family, adjust power value for socket number.
    //

    if (!TcicIsPnP(pInst)) {
        pwr <<= pInst->skt.RegisterOffset;
    }
    return pwr;
}



VOID
TcicGetIRQMap(
    IN PDBSOCKET pInst
    )

/*++

Routine Description:

    Constructs an IRQ cross-mapping table for the controller in question.
    This code just does a copy from a static table.  It should be replaced
    with the Win95 heuristic code.

Arguments:

    pInst - pointer to an Instance data to work from.

Return Value:

    None

--*/

{
    int  i, j;
    UCHAR loc_tbl[16] = {0};

    PAGED_CODE();
    TcicGetPossibleIRQs(pInst, loc_tbl);

    for (j = 0; j < 16; j++) {
        pInst->IRQMapTbl[j] = loc_tbl[j];
    }

    //
    // Don't let IRQ 14 through.. This is also done for the PCIC
    //

    pInst->IRQMapTbl[14] = 0;
}



USHORT
TcicClockRate(
    PSOCKET pInst
    )

/*++

Routine Description:

    This routine determines if CCLK is running at 1:1 (14.318 Mhz) or divided
    by 2.

Arguments:

    pInst - pointer to an Instance data to work from.

Return Value:

    CCLK divisor as a shift count (0 or 1)

--*/

{
    int i;
    LARGE_INTEGER accum = RtlConvertLongToLargeInteger(0L);
    LARGE_INTEGER start, stop, pc, tmp, tmp2;
    USHORT mode;
    USHORT wctl;

    PAGED_CODE();
    //
    // The Ratio break point is the midpoint between 16K ticks at 14.31813 Mhz
    // (14,318130 / 16K = 873 | 1:1 CCLK) and 16K ticks at 7.159065 Mhz
    // (7,159,065 / 16K = 436 | 1:2 CCLK). We calculate the midpoint between
    // these two values: ((873 - 436) / 2) + 436 = 654  to give a comparison
    // value. If x < 654 we assume 1/2 CCLK, otherwise we assume 1/1 CCLK.
    //

#define CLKRATIO_BRKPOINT         654L

    mode = TcicReadBaseReg(pInst, R_MODE);

    //
    // set AR_PCTL to 0x4000
    //

    TcicWriteAuxReg(pInst, MODE_AR_PCTL, 0x4000);
    TcicWriteBaseReg(pInst, R_MODE, MODE_AR_WCTL);
    wctl = TcicReadBaseReg(pInst, R_AUX);

    //
    // Get the performance counter time base
    //

    KeQueryPerformanceCounter(&pc);

    for (i = 0; i < 10; i++) {

        //
        // start the TCIC timer */
        //

        TcicWriteBaseReg(pInst, R_AUX, (USHORT)(wctl & 0xff));
        start = KeQueryPerformanceCounter(NULL);

        //
        // wait for SSTAT_PROGTIME to go high */
        //

        while (!(TcicReadBaseReg(pInst, R_SSTAT) & SSTAT_PROGTIME))
            ;

        //
        // nab the timer count
        //

        stop = KeQueryPerformanceCounter(NULL);
        tmp = RtlLargeIntegerSubtract(stop, start);
        accum = RtlLargeIntegerAdd(accum, tmp);
    }

    //
    // Zero out the timer for power conservation
    //

    TcicWriteAuxReg(pInst, MODE_AR_PCTL, 0);

    //
    // replace Mode
    //

    TcicWriteBaseReg(pInst, R_MODE, mode);

    //
    // Get average elapsed time for 1 iter.
    //

    accum = RtlLargeIntegerDivide(accum, RtlConvertLongToLargeInteger(10L), &tmp2);

    //
    // Divide PC Freq by accum to base accum on some portion of 1 second
    //

    tmp = RtlLargeIntegerDivide(pc, accum, &tmp2);

    return (RtlLargeIntegerLessThan(tmp, RtlConvertLongToLargeInteger(CLKRATIO_BRKPOINT))
              ?(USHORT)2 : (USHORT)1);
}



VOID
TcicSetIoWin(
    IN PSOCKET socketPtr,
    IN USHORT  winIdx,
    IN ULONG   BasePort,
    IN ULONG   NumPorts,
    IN UCHAR   Attributes
    )

/*++

Routine Description:

    Setup a TCIC I/O window.

Arguments:

    socketPtr - ptr to socket instance data
    winIdx   - index of window to setup
    BasePort  - start base port address
    NumPorts  - size of range - 1
    Attributes- window attributes

Return Value:

    None

--*/

{
    PDBSOCKET        pdb = (PDBSOCKET)socketPtr;
    USHORT      tmp;
    USHORT           words[2];

    //
    // Simulate 365 by arbitrary attachment of IOW1:2 to SKT1 and IOW3:4 to SKT2
    //

    winIdx += (socketPtr->RegisterOffset * 2);

    //
    // NumPorts from CIS metaformat is really (NumPorts -1), normalize it now.
    //

    ++NumPorts;

    words[0] = (USHORT)(BasePort + (NumPorts >> 1));

    TcicReadIndirectRegs(socketPtr, IR_SCFG_S(socketPtr->RegisterOffset), 1, &tmp);
    tmp |= (USHORT)(IRSCFG_SPKR | IRSCFG_FINPACK);
    TcicWriteIndirectRegs(socketPtr, IR_SCFG_S(socketPtr->RegisterOffset), 1, &tmp);

    TcicReadIndirectRegs(socketPtr, IR_SCF2_S(socketPtr->RegisterOffset), 1, &tmp);
    tmp &= ~(IRSCF2_IDBR | IRSCF2_MDBR);

    if (Attributes & IO_DATA_PATH_WIDTH) {
        words[1] = ICTL_ENA;
        tmp   |= IRSCF2_IDBR;
    } else {
        words[1] = ICTL_B8 | ICTL_QUIET | ICTL_ENA;
    }
    TcicWriteIndirectRegs(socketPtr, IR_SCF2_S(socketPtr->RegisterOffset), 1, &tmp);

    if (NumPorts < 1024) {
        words[1] |= ICTL_1K;

        if (NumPorts == 1) {
            words[1] |= ICTL_TINY;
        }
    }
    words[1] |= socketPtr->RegisterOffset << ICTL_SS_SHFT;
    words[1] |= 3 + pdb->clkdiv;

    TcicWriteIndirectRegs(socketPtr, IR_IOBASE_W(winIdx), 2, words);
}




USHORT
TcicMapSpeedCode(
    IN PDBSOCKET pdb,
    IN UCHAR AccessSpeed
    )

/*++

Routine Description:

    Determine the correct wait state bits for this controller

Arguments:

    pdb - socket instance data
    AccessSpeed - callers desired speed (unused)

Return Value:

    TCIC wait state bits.

--*/

{

    UNREFERENCED_PARAMETER(AccessSpeed);

    if (pdb->clkdiv) {
        return (3);
    } else {
        return (7);
    }
}



VOID
TcicSetMemWin(
    IN PSOCKET socketPtr,
    IN USHORT  winIdx,
    IN ULONG   cardbase,
    IN ULONG   hostbase,
    IN ULONG   size,
    IN UCHAR   AttrMem,
    IN UCHAR   AccessSpeed,
    IN USHORT  Attributes
    )

/*++

Routine Description:

    Setup the specified TCIC memory window

Arguments:

    socketPtr - socket instance data
    winIdx   - index of window to setup
    cardbase  - PCCard base address
    hostbase  - host base address
    size     - window size
    AttrMem   - attribute or common space
    AccessSpeed      - wait states
    Attributes       - window attributes

Return Value:

    None

--*/

{
    PDBSOCKET        pdb = (PDBSOCKET)socketPtr;
    USHORT      tmp;
    USHORT           words[4];

    //
    // Simulate 365 by arbitrary attachment of MEM1:(x/2-1) to SKT1
    // and MEMx/2:x to SKT2
    //

    winIdx += (socketPtr->RegisterOffset * (pdb->nmemwins / 2));

    //
    // convert base, size, & map to 4K pages
    //

    cardbase >>= 12;
    size >>= 12;
    hostbase >>= 12;

    //
    // combine hostbase & size
    //

    words[0] = (USHORT)hostbase | (USHORT)(size / 2);

    //
    // Check if 4K bit is needed
    //

    if (size == 1) {
        words[0] |= MBASE_4K;
    }

    //
    // setup mapping of cardbase to host addr space
    //

    words[1] = (USHORT)(cardbase - (hostbase & 0xfff)) & 0x3fff;
    if (AttrMem) {
        words[1] |= MMAP_REG;
    }

    //
    // now cook the control bits
    //

    words[2] = MCTL_ENA | MCTL_QUIET;
    if (!(Attributes & MEM_DATA_PATH_WIDTH_16)) {
        words[2] |= MCTL_B8;
    }

    //
    // Now add in the socket selector
    //

    words[2] |= (socketPtr->RegisterOffset << MCTL_SS_SHFT);

    //
    // Last, add in the speed bits
    //

    words[2] |= TcicMapSpeedCode(pdb, AccessSpeed);

    //
    // HW BugFix1: First Rev of 082 needs to have SYSCFG_MCSFULL turned on
    // if we have any open windows. We're opening one so we better assert.
    //

    tmp = TcicReadAuxReg(socketPtr, MODE_AR_SYSCFG);
    tmp |= SYSCFG_MCSFULL;
    TcicWriteAuxReg(socketPtr, MODE_AR_SYSCFG, tmp);

    //
    // HW BugFix2: '2' Step of 082 needs the wait state count written into
    // window[~index] instead of index.
    //

    if (pdb->chipType != SILID_DB86082_1) {

        //
        // No bug case
        //

        TcicWriteIndirectRegs(socketPtr, IR_MBASE_W(winIdx), 3, words);

    } else {

        //
        // Bug case
        //

        words[3] = words[2] & MCTL_WSCNT_MASK;
        words[2] &= ~MCTL_WSCNT_MASK;
        TcicWriteIndirectRegs(socketPtr, IR_MBASE_W(winIdx), 3, words);
        TcicWriteIndirectRegs(socketPtr, IR_MBASE_W((~winIdx) & 7), 1, &words[3]);
    }
}



VOID
TcicAutoBusyOff(
    IN PDBSOCKET pdbs
    )

/*++

Routine Description:

    Turn off the busy LED, re-arm so that it comes on automatically with
    any card access.

Arguments:

    pdbs - socket instance data

Return Value:

    None

--*/

{
    USHORT syscfg;
    USHORT oldmode;

    //
    // Save R_MODE for later restore
    //

    oldmode = TcicReadBaseReg(&pdbs->skt, R_MODE);

    //
    // R/M/W SYSCFG to add in the autobusy bit.
    // This will turn LED off for now but allow it to come on automatically
    // with the next access to this socket.
    //

    syscfg = TcicReadAuxReg(&pdbs->skt, MODE_AR_SYSCFG);
    syscfg |= SYSCFG_AUTOBUSY;
    TcicWriteAuxReg(&pdbs->skt, MODE_AR_SYSCFG, syscfg);

    //
    // Restore Mode
    //

    TcicWriteBaseReg(&pdbs->skt, R_MODE, oldmode);
}



UCHAR
TcicAutoBusyCheck(
    IN PDBSOCKET pdbs
    )

/*++

Routine Description:

    Check SYSCFG access bit to see if PCCard has been accessed since last
    call.  If so, force LED to stay on and clear access bit.

Arguments:

    pdbs - socket instance data

Return Value:

    access bit as a right-justified UCHAR

--*/

{
    USHORT syscfg;
    USHORT oldmode;
    UCHAR activity = 0;

    //
    // Save R_MODE for later restore
    //

    oldmode = TcicReadBaseReg(&pdbs->skt, R_MODE);

    //
    // Read AR_SYSCFG to check for recent activity
    //

    syscfg = TcicReadAuxReg(&pdbs->skt, MODE_AR_SYSCFG);
    if (syscfg & SYSCFG_ACC) {

        //
        // the socket has been accessed since last check
        // clear the access bit and disable AUTOBUSY to force LED to
        // follow socket SCTRL_ENA.
        //

        syscfg &= ~(SYSCFG_ACC | SYSCFG_AUTOBUSY);
        TcicWriteAuxReg(&pdbs->skt, MODE_AR_SYSCFG, syscfg);
        ++activity;
    }

    //
    // Restore Mode
    //

    TcicWriteBaseReg(&pdbs->skt, R_MODE, oldmode);

    return activity;
}




VOID
TcicCheckSktLED(
    IN PDBSOCKET pdbs
    )

/*++

Routine Description:

    Drive the low-level functions to check for PCcard access and control
    the busy LED on this socket/controller.

Arguments:

    pdbs - socket instance data

Return Value:

    None

--*/

{
    UCHAR lastbusy = pdbs->busyLed;

    pdbs->busyLed = TcicAutoBusyCheck(pdbs);

    if (lastbusy & !(pdbs->busyLed)) {
        TcicAutoBusyOff(pdbs);
    }
}




VOID
TcicBusyLedRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

     Main timer routine to drive Busy LED monitor

Arguments:

    DeviceObject - instance data for driver
    Context - unused parameter

Return Value:

    None

--*/

{
    PFDO_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PDBSOCKET pdbs;

    UNREFERENCED_PARAMETER(Context);

    pdbs = (PDBSOCKET)(deviceExtension->SocketList);

    while (pdbs) {

        //
        // If this device is from the 084 family, LED control is per/socket
        //

        if (TcicIsPnP(pdbs)) {
            ULONG   oldaddr = TcicReadAddrReg(&pdbs->skt);

            // Do the first socket
            //

            TcicSocketSelect(&pdbs->skt, pdbs->skt.RegisterOffset);
            TcicCheckSktLED(pdbs);
            TcicWriteAddrReg(&pdbs->skt, oldaddr);
            pdbs = (PDBSOCKET)(pdbs->skt.NextSocket);

            // If a second socket is present, do it too.
            //

            if (pdbs && pdbs->skt.RegisterOffset == 1) {
                oldaddr = TcicReadAddrReg(&pdbs->skt);
                TcicSocketSelect(&pdbs->skt, pdbs->skt.RegisterOffset);
                TcicCheckSktLED(pdbs);
                TcicWriteAddrReg(&pdbs->skt, oldaddr);
                pdbs = (PDBSOCKET)(pdbs->skt.NextSocket);
            }

        } else {

            //
            // Otherwise, LED control is per adapter so do the check and skip
            // over the second socket if present.
            //

            TcicCheckSktLED(pdbs);
            pdbs = (PDBSOCKET)(pdbs->skt.NextSocket);
            if (pdbs && pdbs->skt.RegisterOffset == 1) {
                pdbs = (PDBSOCKET)(pdbs->skt.NextSocket);
            }
        }
    }
}



VOID
TcicDecodeMemWin(
    USHORT  mbase,
    USHORT  mmap,
    USHORT  mctl,
    ULONG  *Host,
    ULONG  *Card,
    ULONG  *Size,
    UCHAR  *Attr
    )

/*++

Routine Description:

    Convert TCIC mem window register values to something understandable

Arguments:

    mbase - TCIC MBASE register value
    mmap  - TCIC MMAP register value
    mctl  - TCIC MCTL register value
    Host  - where to put Host address
    Card  - where to put PCCard address
    Size  - where to put window size
    Attr  - where to put attribute space flag

Return Value:

    None

--*/

{
    USHORT shft;
    USHORT tmp;

    //
    // take care of mapping to common or attr space first.
    // Strip ATTR bit if set
    //

    *Attr = 0;
    if (mmap & MMAP_REG) {
        *Attr = 1;
        mmap &= ~MMAP_REG;
    }

    //
    // Now concentrate on getting the host addr and window size
    //

    if (mbase & MBASE_4K) {
        *Size = 1;
        *Host = (ULONG)(mbase & ~MBASE_4K);
    } else {
        for (*Size = 2, shft = 0, tmp = mbase; !(tmp & 1) ; shft++ ) {
            tmp >>= 1;
            *Size <<= 1;
        }
        *Host = (ULONG)(mbase - (1 << shft));
    }

    //
    // Now for the fun part. We're left with mmap being a 14-bit signed
    // number. We need to normalize it so we can work with it.
    //
    // Check for negative (bit 13 set)
    //

    if (mmap & (1 << 13)) {
        mmap |= 0xc000;
        *Card = (ULONG)((short)mmap + (short)*Host);
    } else {
        *Card = (ULONG)(mmap) + *Host;
    }
    (*Size)--;
    *Host <<= MBASE_HA_SHFT;
    *Size <<= MBASE_HA_SHFT;
    *Card <<= MMAP_CA_SHFT;
}



VOID
TcicDecodeIoWin(
    USHORT  iobase,
    USHORT  ioctl,
    USHORT  *NumPorts,
    USHORT  *BasePort
    )

/*++

Routine Description:

    Convert TCIC I/O window register values to something understandable

Arguments:

    iobase -  TCIC IOBASE register contents
    ioctl  -  TCIC IOCTL register contents
    NumPorts - where to put window size (size - 1)
    BasePort - where to put base address

Return Value:

    None

--*/

{
    if (ioctl & ICTL_TINY) {
        *BasePort = iobase;
        *NumPorts = 1;
    } else {
        USHORT shft;
        USHORT tmp;

        for (*NumPorts = 2, shft = 0, tmp = iobase; !(tmp & 1) ; shft++ ) {
            tmp >>= 1;
            *NumPorts <<= 1;
        }

        *BasePort = (iobase - (1 << shft));
    }
    *NumPorts -= 1;
}



VOID
TcicRegistryLookupScanLimits(
    PULONG Start,
    PULONG End
    )

/*++

Routine Description:

    Open the registry key in the services entry for pcmcia and see if there
    are some values set for TCIC searching.    If not, use the defaults.

Arguments:

    Start - the I/O location for start of search.
    End     - the I/O location to end the search (i.e. nothing greater than).

Return Values:

     None - parameters are modified.

--*/

{
#define ITEMS_TO_QUERY 4
    ULONG                         defaultStart = TCIC_LOW_ADDR_LIMIT;
    ULONG                         defaultEnd    = TCIC_HIGH_ADDR_LIMIT;
    PRTL_QUERY_REGISTRY_TABLE params;
    NTSTATUS                      status;
    PWSTR                         keyName;

    PAGED_CODE();
    //
    // Set up return codes in case there are errors in setting up processing.
    //

    *Start = defaultStart;
    *End = defaultEnd;

    //
    // Allocate memory for operation.
    //

    params = ExAllocatePool(NonPagedPool,
                            sizeof(RTL_QUERY_REGISTRY_TABLE)*ITEMS_TO_QUERY);

    if (!params) {
        return;
    }

    //
    // Set up registry path.  This should not be hard coded, but is for now.
    //

    keyName = L"\\registry\\machine\\system\\currentcontrolset\\services\\pcmcia";

    //
    // Set up query structure.
    //

    RtlZeroMemory(params, sizeof(RTL_QUERY_REGISTRY_TABLE)*ITEMS_TO_QUERY);
    params[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    params[0].Name          = L"TCICStartSearch";
    params[0].EntryContext  = Start;
    params[0].DefaultType   = REG_DWORD;
    params[0].DefaultData   = &defaultStart;
    params[0].DefaultLength = sizeof(ULONG);

    params[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    params[1].Name          = L"TCICStopSearch";
    params[1].EntryContext  = End;
    params[1].DefaultType   = REG_DWORD;
    params[1].DefaultData   = &defaultEnd;
    params[1].DefaultLength = sizeof(ULONG);

    //
    // Perform the registry search
    //

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                    keyName,
                                    params,
                                    NULL,
                                    NULL);

    //
    // Insure that start is less than end - if not, go back to default
    // values
    //

    if (*Start > *End) {
        *Start = defaultStart;
        *End = defaultEnd;
    }

    //
    // Free resources.
    //

    ExFreePool(params);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\pdocb.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    pdocb.c

Abstract:

    This module contains the code to handle
    the IRP_MJ_PNP dispatches for the PDOs
    for cardbus devices

Authors:

    Ravisankar Pudipeddi (ravisp)
    Neil Sandlin (neilsa) 1-Jun-1999

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#include "pch.h"

//
// Internal References
//

NTSTATUS
PcmciaStartCardBusCard(
    IN PDEVICE_OBJECT Pdo,
    IN OUT PIRP       Irp
    );

NTSTATUS
PcmciaRemoveCardBusCard(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP           Irp
    );

NTSTATUS
PcmciaQueryCardBusCardResourceRequirements(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP           Irp
    );

NTSTATUS
PcmciaQueryCardBusCardCapabilities(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP           Irp
    );


#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE,  PcmciaPdoCardBusPnPDispatch)
    #pragma alloc_text(PAGE,  PcmciaStartCardBusCard)
    #pragma alloc_text(PAGE,  PcmciaRemoveCardBusCard)
    #pragma alloc_text(PAGE,  PcmciaQueryCardBusCardResourceRequirements)
    #pragma alloc_text(PAGE,  PcmciaQueryCardBusCardCapabilities)
#endif



NTSTATUS
PcmciaPdoCardBusPnPDispatch(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    )

/*++

Routine Description:

     This routine handles pnp requests for the filter object for CardBus devices.

Arguments:

     Pdo - pointer to the physical device object
     Irp - pointer to the io request packet

Return Value:

     status

--*/

{
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_NOT_SUPPORTED;

    PAGED_CODE();
    ASSERT (pdoExtension->LowerDevice);

#if DBG
    if (irpStack->MinorFunction > IRP_MN_PNP_MAXIMUM_FUNCTION) {
        DebugPrint((PCMCIA_DEBUG_PNP, "pdo %08x irp %08x Unknown minor function %x\n",
                                                 Pdo, Irp, irpStack->MinorFunction));
    } else {
        DebugPrint((PCMCIA_DEBUG_PNP, "pdo %08x irp %08x --> %s\n",
                          Pdo, Irp, PNP_IRP_STRING(irpStack->MinorFunction)));
    }
#endif

    //
    // CardBus PnP Dispatch
    //

    switch (irpStack->MinorFunction) {

    case IRP_MN_START_DEVICE:
        status = PcmciaStartCardBusCard(Pdo, Irp);
        break;

    case IRP_MN_REMOVE_DEVICE:
        status = PcmciaRemoveCardBusCard(Pdo, Irp);
        break;

    case IRP_MN_STOP_DEVICE:
        PcmciaSkipCallLowerDriver(status, pdoExtension->LowerDevice, Irp);
        MarkDeviceNotStarted(pdoExtension);
        break;

    case IRP_MN_SURPRISE_REMOVAL:
        if (IsDevicePhysicallyRemoved(pdoExtension)) {
            PcmciaSetSocketPower(pdoExtension->Socket, NULL, NULL, PCMCIA_POWEROFF);
        }
        PcmciaSkipCallLowerDriver(status, pdoExtension->LowerDevice, Irp);
        break;

    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
        status = PcmciaQueryCardBusCardResourceRequirements(Pdo, Irp);
        break;

    case IRP_MN_QUERY_CAPABILITIES:
        status = PcmciaQueryCardBusCardCapabilities(Pdo, Irp);
        break;

    case IRP_MN_QUERY_INTERFACE:
        status = PcmciaPdoQueryInterface(Pdo, Irp);
        break;

    default:
        PcmciaSkipCallLowerDriver(status, pdoExtension->LowerDevice, Irp);
    }

    DebugPrint((PCMCIA_DEBUG_PNP, "pdo %08x irp %08x <-- %s %08x\n", Pdo, Irp,
                                             STATUS_STRING(status), status));

    return status;
}



NTSTATUS
PcmciaStartCardBusCard(
    IN PDEVICE_OBJECT Pdo,
    IN OUT PIRP       Irp
    )
/*++

Routine Description:

    This routine attempts to start the PC-Card by configuring it with the supplied resources.


Arguments:

    Pdo - Pointer to the device object representing the PC-Card which needs to be started
    ResourceList - Pointer the list of assigned resources for the PC-Card

Return value:

    STATUS_INSUFFICIENT_RESOURCES - Not sufficient resources supplied to start device/
                                              could not allocate memory
    STATUS_UNSUCCESSFUL             - Supplied resources are invalid for this PC-Card
    STATUS_SUCCESS                  - Configured and started the card successfully

--*/
{
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
    PSOCKET         socket = pdoExtension->Socket;
    PSOCKET_DATA    socketData = pdoExtension->SocketData;
    PFDO_EXTENSION fdoExtension = socket->DeviceExtension;
    USHORT          word;
    UCHAR           BaseClass;
    NTSTATUS        status = STATUS_NOT_SUPPORTED;
    ULONG           i;
    ULONG           devid;
    USHORT          cls_lat;
    BOOLEAN         setAudio = FALSE;

    PAGED_CODE();

    ASSERT (pdoExtension->LowerDevice);

    //
    // Apply some hacks if necessary
    //
    status = PcmciaConfigureCardBusCard(pdoExtension);

    if (!NT_SUCCESS(status)) {
        //
        // The card's config space probably never became visible
        //
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // Select PCI IRQ routing
    //

    CBEnableDeviceInterruptRouting(socket);

    //
    // Turn on ZV for this card, if it needs it
    //
    if (socketData && (socketData->Flags & SDF_ZV)) {
        if (PcmciaSetZV(fdoExtension, socket, TRUE)) {
            SetSocketFlag(socket, SOCKET_CUSTOM_INTERFACE);
        }
    } else if (IsSocketFlagSet(socket, SOCKET_CUSTOM_INTERFACE)) {
        PcmciaSetZV(fdoExtension, socket, FALSE);
        ResetSocketFlag(socket, SOCKET_CUSTOM_INTERFACE);
    }

    //
    // Pci needs to enable this card .. send it down to the PDO
    //

    status = PcmciaIoCallDriverSynchronous(pdoExtension->LowerDevice, Irp);

    //
    // Apparently cardbus modems aren't immune to needing delays
    // This yield duration was emperically determined using the Xircom RBM56G
    //
    GetPciConfigSpace(pdoExtension, CFGSPACE_CLASSCODE_BASECLASS, &BaseClass, 1);
    if (BaseClass == PCI_CLASS_SIMPLE_COMMS_CTLR) {
        //
        // Wait for modem to warm up
        //
        PcmciaWait(PCMCIA_CB_MODEM_READY_DELAY);
        setAudio = TRUE;
    }

    PcmciaSetAudio(fdoExtension, socket, setAudio);

    //
    // Assume that the cardbus controller has the correct CLS and latency
    // timer values, and that the cardbus device has zeroes.
    //

    GetPciConfigSpace(fdoExtension, CFGSPACE_CACHE_LINESIZE, &cls_lat, sizeof(cls_lat));
    SetPciConfigSpace(pdoExtension, CFGSPACE_CACHE_LINESIZE, &cls_lat, sizeof(cls_lat));

    if (NT_SUCCESS(status)) {
        MarkDeviceStarted(pdoExtension);
        MarkDeviceLogicallyInserted(pdoExtension);
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}



NTSTATUS
PcmciaRemoveCardBusCard(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP             Irp
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
    PSOCKET         socket = pdoExtension->Socket;
    NTSTATUS status;

    ASSERT(socket != NULL);

    //
    // Send this down to the PDO first
    //

    status = PcmciaIoCallDriverSynchronous(pdoExtension->LowerDevice, Irp);

    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    if (IsDevicePhysicallyRemoved(pdoExtension)) {
        PFDO_EXTENSION fdoExtension = socket->DeviceExtension;
        PDEVICE_OBJECT curPdo, prevPdo;
        PPDO_EXTENSION curPdoExt;
        ULONG waitCount = 0;

        //
        // Synchronize with power routines
        //
        while(!PCMCIA_TEST_AND_SET(&pdoExtension->DeletionLock)) {
            PcmciaWait(1000000);
            if (waitCount++ > PCMCIA_DELETION_TIMEOUT) {
                ASSERT(waitCount <= PCMCIA_DELETION_TIMEOUT);
                break;
            }
        }

        //
        // Delink this Pdo from the FDO list.
        //
        for (curPdo = fdoExtension->PdoList, prevPdo = NULL; curPdo!=NULL; prevPdo=curPdo, curPdo=curPdoExt->NextPdoInFdoChain) {
            curPdoExt = curPdo->DeviceExtension;

            if (curPdo == Pdo) {
                if (prevPdo) {
                    ((PPDO_EXTENSION)prevPdo->DeviceExtension)->NextPdoInFdoChain = pdoExtension->NextPdoInFdoChain;
                } else {
                    fdoExtension->PdoList = pdoExtension->NextPdoInFdoChain;
                }
                break;
            }
        }

        //
        // Delink this Pdo from the socket list.
        //
        for (curPdo = socket->PdoList, prevPdo = NULL; curPdo!=NULL; prevPdo=curPdo, curPdo=curPdoExt->NextPdoInSocket) {
            curPdoExt = curPdo->DeviceExtension;

            if (curPdo == Pdo) {
                if (prevPdo) {
                    ((PPDO_EXTENSION)prevPdo->DeviceExtension)->NextPdoInSocket = pdoExtension->NextPdoInSocket;
                } else {
                    socket->PdoList = pdoExtension->NextPdoInSocket;
                }
                break;
            }
        }

        PcmciaCleanupPdo(Pdo);
        //
        // Delete..
        //
        if (!IsDeviceDeleted(pdoExtension)) {
            MarkDeviceDeleted(pdoExtension);
            IoDeleteDevice(Pdo);
        }


        PcmciaSetSocketPower(pdoExtension->Socket, NULL, NULL, PCMCIA_POWEROFF);

        if (--fdoExtension->PciAddCardBusCount == 0) {
            ResetSocketFlag(socket, SOCKET_CLEANUP_PENDING);
            //
            // If a query_device_relations came in after a card was inserted, but before
            // we have removed the previous card configuration, the enumeration would have been
            // postponed. Here, we start it up again
            //
            if (IsSocketFlagSet(socket, SOCKET_ENUMERATE_PENDING)) {
                ResetSocketFlag(socket, SOCKET_ENUMERATE_PENDING);
                SetSocketFlag(socket, SOCKET_CARD_STATUS_CHANGE);
                IoInvalidateDeviceRelations(fdoExtension->Pdo, BusRelations);
            }
        }

    } else {
        //
        // We will keep this Pdo around, since this is not physically ejected.
        //
        MarkDeviceLogicallyRemoved(pdoExtension);
    }


    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}



NTSTATUS
PcmciaQueryCardBusCardResourceRequirements(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This routine filters the interrupt requirement generated by pci for the cardbus
    card to restrict it to the parent controller's vector. This is anyway what has to
    happen, and this way, the card will still get the interrupt even if there is no
    irq routing on the machine.

Arguments:

    Pdo - Pointer to the device object representing the PC-Card which needs to be started
    Irp - IRP_MN_QUERY_RESOURCE_REQUIREMENTS Irp

Return value:

    status

--*/
{
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
    PFDO_EXTENSION fdoExtension = pdoExtension->Socket->DeviceExtension;
    NTSTATUS        status;
    ULONG           index1, index2;
    PIO_RESOURCE_REQUIREMENTS_LIST IoReqList;
    PIO_RESOURCE_LIST   ioResourceList;
    PIO_RESOURCE_DESCRIPTOR ioResourceDesc;

    PAGED_CODE();

    PcmciaUpdateInterruptLine(pdoExtension, fdoExtension);
    //
    // First pass the irp down the stack
    //
    status = PcmciaIoCallDriverSynchronous(pdoExtension->LowerDevice, Irp);

    IoReqList = (PIO_RESOURCE_REQUIREMENTS_LIST) Irp->IoStatus.Information;

    if (!NT_SUCCESS(status) ||
         (IoReqList == NULL) ||
         (fdoExtension->Configuration.Interrupt.u.Interrupt.Vector == 0)) {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // Change interrupt descriptors to specifically request the parent vector
    //
    for (index1 = 0, ioResourceList = IoReqList->List;
         index1 < IoReqList->AlternativeLists; index1++) {
        ioResourceDesc = ioResourceList->Descriptors;

        for (index2 = 0 ; index2 < ioResourceList->Count; index2++, ioResourceDesc++) {
            if (ioResourceDesc->Type == CmResourceTypeInterrupt) {
                //
                // Cardbus cards by design use the same irq as the parent bus controller
                //
                ioResourceDesc->u.Interrupt.MinimumVector = fdoExtension->Configuration.Interrupt.u.Interrupt.Vector;
                ioResourceDesc->u.Interrupt.MaximumVector = fdoExtension->Configuration.Interrupt.u.Interrupt.Vector;
            }
        }

        ioResourceList = (PIO_RESOURCE_LIST) (((PUCHAR) ioResourceList) +
                                                        sizeof(IO_RESOURCE_LIST) +
                                                        (ioResourceList->Count - 1)* sizeof(IO_RESOURCE_DESCRIPTOR));
    } // outer for loop

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}



NTSTATUS
PcmciaQueryCardBusCardCapabilities(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP           Irp
    )
/*++

Routine Description:

    Obtains the device capabilities of the given pc-card.

    If the pc-card is an R2 card (16-bit pc-card), the capabilities
    are constructed from the parent PCMCIA controller's capabilities.
    If it's a cardbus card, the capabilities are obtained from the underlying
    PCI pdo for the card.
    Finally the obtained capabilities are cached in the pc-card's device
    extension for use in power management of the card.

Arguments:

    Pdo -     Pointer to the device object for the pc-card
    Irp -     Pointer to the query device capabilities Irp

Return Value:

    STATUS_SUCCESS                      - Capabilities obtained and recorded in the passed in pointer
    STATUS_INSUFFICIENT_RESOURCES   - Could not allocate memory to cache the capabilities

--*/
{
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
    NTSTATUS status;

    PAGED_CODE();

    //
    // CardBus card. Get the capabilities from PCI
    //

    status = PcmciaIoCallDriverSynchronous(pdoExtension->LowerDevice, Irp);

    if (NT_SUCCESS(status)) {
        PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
        PDEVICE_CAPABILITIES capabilities = irpStack->Parameters.DeviceCapabilities.Capabilities;

        //
        // Filter the capabilities: we need to set Removable true
        // since this is a pc-card (PCI doesn't know the difference)
        //
        capabilities->Removable = TRUE;
//********************************
// NOTE: HACKHACK
// This is temporary code only to get cardbus wake-on-lan up and running. Here
// we check to see if this has only been marked as a "can't wake" device by
// pci because it said it could wake from D3Hot, but not from D3Cold.
//********************************

        if (capabilities->DeviceWake <= PowerDeviceD0) {
            UCHAR capptr;
            ULONG powercaps;

            GetPciConfigSpace(pdoExtension, CBCFG_CAPPTR, &capptr, sizeof(capptr));
            if (capptr) {
                GetPciConfigSpace(pdoExtension, capptr, &powercaps, sizeof(powercaps));

                if (((powercaps & 0xff) == 1) && ((powercaps&0x40000000) && !(powercaps&0x80000000))) {
                    capabilities->DeviceWake = PowerDeviceD3;
                    capabilities->SystemWake = PowerSystemSleeping3;
                    capabilities->WakeFromD3 = 1;
                }
            }
        }

        if (capabilities->SystemWake > PowerSystemSleeping3) {
            capabilities->SystemWake = PowerSystemSleeping3;
        }
//********************************
// END HACK
//********************************

        //
        // Store these capabilities away..
        //
        RtlCopyMemory(&pdoExtension->DeviceCapabilities,
                      capabilities,
                      sizeof(DEVICE_CAPABILITIES));
    } else {

        RtlZeroMemory(&pdoExtension->DeviceCapabilities, sizeof(DEVICE_CAPABILITIES));

    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\registry.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    registry.c

Abstract:

    This module contains the code that manipulates the ARC firmware
    tree and other elements in the registry.

Author:

    Bob Rinne
    Ravisankar Pudipeddi (ravisp) 1 Dec 1996
    Neil Sandlin (neilsa) June 1 1999

Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"

//
// Internal References
//

VOID
PcmciaGetRegistryContextRange(
    IN HANDLE instanceHandle,
    IN PCWSTR Name,
    IN OPTIONAL const PCMCIA_CONTEXT_RANGE IncludeRange[],
    IN OPTIONAL const PCMCIA_CONTEXT_RANGE ExcludeRange[],
    OUT PPCMCIA_CONTEXT pContext
    );

ULONG
PcmciaGetDetectedFdoIrqMask(
    IN PFDO_EXTENSION FdoExtension
    );

NTSTATUS
PcmciaScanHardwareDescription(
    VOID
    );

NTSTATUS
PcmciaGetHardwareDetectedIrqMask(
    IN HANDLE handlePcCard
    );

//
//
// Registry related definitions
//
#define PCMCIA_REGISTRY_PARAMETERS_KEY               L"Pcmcia\\Parameters"
#define PCMCIA_REGISTRY_DETECTED_DEVICE_KEY          L"ControllerProperties"


//
// Per controller values (in control\class)
//

#define PCMCIA_REGISTRY_PCI_CONTEXT_VALUE  L"CBSSCSContextRanges"
#define PCMCIA_REGISTRY_CB_CONTEXT_VALUE     L"CBSSCBContextRanges"
#define PCMCIA_REGISTRY_EXCA_CONTEXT_VALUE L"CBSSEXCAContextRanges"
#define PCMCIA_REGISTRY_CACHED_IRQMASK   L"CachedIrqMask"
#define PCMCIA_REGISTRY_COMPATIBLE_TYPE  L"CompatibleControllerType"
#define PCMCIA_REGISTRY_VOLTAGE_PREFERENCE L"VoltagePreference"

//
// Irq detection values (in hardware\description)
//

#define PCMCIA_REGISTRY_CONTROLLER_TYPE  L"OtherController"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,PcmciaLoadGlobalRegistryValues)
#pragma alloc_text(INIT,PcmciaScanHardwareDescription)
#pragma alloc_text(INIT,PcmciaGetHardwareDetectedIrqMask)
#pragma alloc_text(PAGE,PcmciaGetControllerRegistrySettings)
#pragma alloc_text(PAGE,PcmciaGetRegistryFdoIrqMask)
#pragma alloc_text(PAGE,PcmciaGetDetectedFdoIrqMask)
#pragma alloc_text(PAGE,PcmciaGetLegacyDetectedControllerType)
#pragma alloc_text(PAGE,PcmciaSetLegacyDetectedControllerType)
#pragma alloc_text(PAGE,PcmciaGetRegistryContextRange)
#endif


NTSTATUS
PcmciaGetHardwareDetectedIrqMask(
    HANDLE handlePcCard
    )
/*++

Routine Description:

    This routine looks through the OtherController key for pccard entries
    created by NTDETECT. For each entry, the IRQ scan data is read in and
    saved for later.


Arguments:

    handlePcCard - open handle to "OtherController" key in registry at
                        HARDWARE\Description\System\MultifunctionAdapter\<ISA>

Return value:

    status

--*/
{
#define VALUE2_BUFFER_SIZE sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(CM_PCCARD_DEVICE_DATA) + sizeof(CM_FULL_RESOURCE_DESCRIPTOR)
    UCHAR valueBuffer[VALUE2_BUFFER_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION valueInfo = (PKEY_VALUE_PARTIAL_INFORMATION) valueBuffer;

    NTSTATUS            status;
    KEY_FULL_INFORMATION KeyFullInfo;
    PKEY_BASIC_INFORMATION subKeyInfo = NULL;
    OBJECT_ATTRIBUTES attributes;
    UNICODE_STRING  strSubKey = {0};
    UNICODE_STRING  strIdentifier;
    UNICODE_STRING  strConfigData;
    HANDLE              handleSubKey = NULL;
    ULONG               subKeyInfoSize;
    ULONG               index;
    ULONG               resultLength;

    RtlInitUnicodeString(&strIdentifier, L"Identifier");
    RtlInitUnicodeString(&strConfigData, L"Configuration Data");

    status = ZwQueryKey(handlePcCard,
                        KeyFullInformation,
                        &KeyFullInfo,
                        sizeof(KeyFullInfo),
                        &resultLength);

    if ((!NT_SUCCESS(status) && (status != STATUS_BUFFER_OVERFLOW))) {
        goto cleanup;
    }

    strSubKey.MaximumLength = (USHORT) KeyFullInfo.MaxNameLen;
    subKeyInfoSize = sizeof(KEY_BASIC_INFORMATION) + KeyFullInfo.MaxNameLen;
    subKeyInfo = ExAllocatePool(PagedPool, subKeyInfoSize);

    if (!subKeyInfo) {
        goto cleanup;
    }

    for (index=0;;index++) {

        //
        // Loop through the children of the PcCardController key
        //

        status = ZwEnumerateKey(handlePcCard,
                                index,
                                KeyBasicInformation,
                                subKeyInfo,
                                subKeyInfoSize,
                                &resultLength);

        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

        //
        // Init the name
        //

        if (subKeyInfo->NameLength > strSubKey.MaximumLength) {
            continue;
        }
        strSubKey.Length = (USHORT) subKeyInfo->NameLength;
        strSubKey.Buffer = subKeyInfo->Name;

        //
        // Get a handle to a child of PcCardController
        //


        InitializeObjectAttributes(&attributes,
                                   &strSubKey,
                                   0,   //Attributes
                                   handlePcCard,
                                   NULL //SecurityDescriptor
                                   );

        if (handleSubKey) {
            // close handle from previous iteration
            ZwClose(handleSubKey);
            handleSubKey = NULL;
        }

        status = ZwOpenKey(&handleSubKey, MAXIMUM_ALLOWED, &attributes);

        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

        //
        // Get the value of "Identifier"
        //

        status = ZwQueryValueKey(handleSubKey,
                                         &strIdentifier,
                                         KeyValuePartialInformation,
                                         valueInfo,
                                         VALUE2_BUFFER_SIZE,
                                         &resultLength);


        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW)) {
            PWCHAR pData = (PWCHAR)valueInfo->Data;

            if ((valueInfo->DataLength == 17*sizeof(WCHAR)) &&
                (pData[0] == (WCHAR)'P') &&
                (pData[1] == (WCHAR)'c') &&
                (pData[2] == (WCHAR)'C') &&
                (pData[3] == (WCHAR)'a') &&
                (pData[4] == (WCHAR)'r') &&
                (pData[5] == (WCHAR)'d')) {

                //
                // Get the IRQ detection data
                //
                status = ZwQueryValueKey(handleSubKey,
                                         &strConfigData,
                                         KeyValuePartialInformation,
                                         valueInfo,
                                         VALUE2_BUFFER_SIZE,
                                         &resultLength);

                if (NT_SUCCESS(status)) {
                    PCM_FULL_RESOURCE_DESCRIPTOR pFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR) valueInfo->Data;
                    PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartialDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) pFullDesc->PartialResourceList.PartialDescriptors;

                    if ((pPartialDesc->Type == CmResourceTypeDeviceSpecific) &&
                         (pPartialDesc->u.DeviceSpecificData.DataSize == sizeof(CM_PCCARD_DEVICE_DATA))) {

                        PCM_PCCARD_DEVICE_DATA pPcCardData = (PCM_PCCARD_DEVICE_DATA) ((ULONG_PTR)&pPartialDesc->u.DeviceSpecificData + 3*sizeof(ULONG));
                        PPCMCIA_NTDETECT_DATA pNewData;

                        pNewData = ExAllocatePool(PagedPool, sizeof(PCMCIA_NTDETECT_DATA));

                        if (pNewData == NULL) {
                            goto cleanup;
                        }

                        pNewData->PcCardData = *pPcCardData;
                        pNewData->Next = pNtDetectDataList;
                        pNtDetectDataList = pNewData;

                    }
                }
            }
        }

    }
cleanup:
    if (handleSubKey) {
        ZwClose(handleSubKey);
    }

    if (subKeyInfo) {
        ExFreePool(subKeyInfo);
    }
    return STATUS_SUCCESS;
}



ULONG
PcmciaGetDetectedFdoIrqMask(
    IN PFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

    This routine looks through the cached PCMCIA_NTDETECT_DATA entries
    to see if there was an entry for this controller. It then returns the
    detected irq mask for that controller.

Arguments:

    FdoExtension - The fdo extension corresponding to the PCMCIA controller

Return value:

    status

--*/
{

    PPCMCIA_NTDETECT_DATA pData;
    PCM_PCCARD_DEVICE_DATA pPcCardData;
    ULONG detectedIrqMask = 0;

    if (FdoExtension->SocketList == NULL) {
        return 0;
    }

    for (pData = pNtDetectDataList; pData != NULL; pData = pData->Next) {

        pPcCardData = &pData->PcCardData;


        if (CardBusExtension(FdoExtension)) {

            if (!(pPcCardData->Flags & PCCARD_DEVICE_PCI) || ((pPcCardData->BusData) == 0) ||
                 ((pPcCardData->BusData & 0xff) != FdoExtension->PciBusNumber) ||
                 (((pPcCardData->BusData >> 8) & 0xff) != FdoExtension->PciDeviceNumber)) {
                continue;
            }

            SetFdoFlag(FdoExtension, PCMCIA_FDO_IRQ_DETECT_DEVICE_FOUND);

            if (!(pPcCardData->Flags & PCCARD_MAP_ERROR)) {
                //
                // we found the device, and the map looks good
                //
                break;
            }

        } else {

            if ((pPcCardData->Flags & PCCARD_DEVICE_PCI) ||
                (pPcCardData->LegacyBaseAddress != (ULONG_PTR)FdoExtension->SocketList->AddressPort)) {
                continue;
            }

            SetFdoFlag(FdoExtension, PCMCIA_FDO_IRQ_DETECT_DEVICE_FOUND);

            if (!(pPcCardData->Flags & PCCARD_MAP_ERROR)) {
                //
                // we found the device, and the map looks good
                //
                break;
            }

        }
    }

    if (pData) {
        ULONG i;
        //
        // Found the entry
        //
        // Since we don't currently handle "rewired" irqs, we can compact
        // it down to a bit mask, throwing away irqs that are wired, say
        // IRQ12 on the controller to IRQ15 on the isa bus.
        //

        for (i = 1; i < 16; i++) {
            if (pPcCardData->IRQMap[i] == i) {
                detectedIrqMask |= (1<<i);
            }
        }
        SetFdoFlag(FdoExtension, PCMCIA_FDO_IRQ_DETECT_COMPLETED);
    }
    return detectedIrqMask;
}



NTSTATUS
PcmciaScanHardwareDescription(
    VOID
    )
/*++

Routine Description:

    This routine finds the "OtherController" entry in
    HARDWARE\Description\System\MultifunctionAdapter\<ISA>. This is
    where NTDETECT stores irq scan results.

    It also looks for machines that aren't supported, for example MCA
    bus.

Arguments:

Return value:

    status

--*/
{
#define VALUE_BUFFER_SIZE sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 3*sizeof(WCHAR)

    UCHAR valueBuffer[VALUE_BUFFER_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION valueInfo = (PKEY_VALUE_PARTIAL_INFORMATION) valueBuffer;
    PKEY_BASIC_INFORMATION subKeyInfo = NULL;
    KEY_FULL_INFORMATION KeyFullInfo;

    HANDLE              handleRoot = NULL;
    HANDLE              handleSubKey = NULL;
    HANDLE              handlePcCard = NULL;
    UNICODE_STRING  strRoot, strIdentifier;
    UNICODE_STRING  strSubKey = {0};
    UNICODE_STRING  strPcCard = {0};
    NTSTATUS            status;
    OBJECT_ATTRIBUTES attributes;
    ULONG               subKeyInfoSize;
    ULONG               resultLength;
    ULONG               index;

    PAGED_CODE();

    //
    // Get a handle to the MultifunctionAdapter key
    //

    RtlInitUnicodeString(&strRoot, L"\\Registry\\MACHINE\\HARDWARE\\DESCRIPTION\\System\\MultiFunctionAdapter");
    RtlInitUnicodeString(&strIdentifier, L"Identifier");
    RtlInitUnicodeString(&strPcCard, PCMCIA_REGISTRY_CONTROLLER_TYPE);

    InitializeObjectAttributes(&attributes,
                               &strRoot,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = ZwOpenKey(&handleRoot, MAXIMUM_ALLOWED, &attributes);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    status = ZwQueryKey(handleRoot,
                        KeyFullInformation,
                        &KeyFullInfo,
                        sizeof(KeyFullInfo),
                        &resultLength);

    if ((!NT_SUCCESS(status) && (status != STATUS_BUFFER_OVERFLOW))) {
        goto cleanup;
    }

    strSubKey.MaximumLength = (USHORT) KeyFullInfo.MaxNameLen;
    subKeyInfoSize = sizeof(KEY_BASIC_INFORMATION) + KeyFullInfo.MaxNameLen;
    subKeyInfo = ExAllocatePool(PagedPool, subKeyInfoSize);

    if (!subKeyInfo) {
        goto cleanup;
    }

    for (index=0;;index++) {

        //
        // Loop through the children of "MultifunctionAdapter"
        //

        status = ZwEnumerateKey(handleRoot,
                                index,
                                KeyBasicInformation,
                                subKeyInfo,
                                subKeyInfoSize,
                                &resultLength);

        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

        //
        // Init the name
        //

        if (subKeyInfo->NameLength > strSubKey.MaximumLength) {
            continue;
        }
        strSubKey.Length = (USHORT) subKeyInfo->NameLength;
        strSubKey.Buffer = subKeyInfo->Name;

        //
        // Get a handle to a child of MultifunctionAdapter
        //


        InitializeObjectAttributes(&attributes,
                                   &strSubKey,
                                   0,   //Attributes
                                   handleRoot,
                                   NULL //SecurityDescriptor
                                   );

        if (handleSubKey) {
            // close handle from previous iteration
            ZwClose(handleSubKey);
            handleSubKey = NULL;
        }

        status = ZwOpenKey(&handleSubKey, MAXIMUM_ALLOWED, &attributes);

        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

        //
        // Get the value of "Identifier"
        //

        status = ZwQueryValueKey(handleSubKey,
                                 &strIdentifier,
                                 KeyValuePartialInformation,
                                 valueInfo,
                                 VALUE_BUFFER_SIZE,
                                 &resultLength);


        if (NT_SUCCESS(status)) {
            PWCHAR pData = (PWCHAR)valueInfo->Data;

            if ((valueInfo->DataLength == 4*sizeof(WCHAR)) &&
                (pData[0] == (WCHAR)'M') &&
                (pData[1] == (WCHAR)'C') &&
                (pData[2] == (WCHAR)'A') &&
                (pData[3] == UNICODE_NULL)) {
                status = STATUS_NO_SUCH_DEVICE;
                goto cleanup;
            }

            if ((valueInfo->DataLength == 4*sizeof(WCHAR)) &&
                (pData[0] == (WCHAR)'I') &&
                (pData[1] == (WCHAR)'S') &&
                (pData[2] == (WCHAR)'A') &&
                (pData[3] == UNICODE_NULL)) {

                InitializeObjectAttributes(&attributes,
                                           &strPcCard,
                                           0,   //Attributes
                                           handleSubKey,
                                           NULL //SecurityDescriptor
                                           );

                status = ZwOpenKey(&handlePcCard, MAXIMUM_ALLOWED, &attributes);

                if (NT_SUCCESS(status)) {

                    status = PcmciaGetHardwareDetectedIrqMask(handlePcCard);
                    ZwClose(handlePcCard);
                }
            }
        }
    }

cleanup:
    if (handleRoot) {
        ZwClose(handleRoot);
    }

    if (handleSubKey) {
        ZwClose(handleSubKey);
    }

    if (subKeyInfo) {
        ExFreePool(subKeyInfo);
    }

    if (status == STATUS_NO_SUCH_DEVICE) {
        //
        // Must be an MCA machine
        //
        return status;
    }
    return STATUS_SUCCESS;
}



NTSTATUS
PcmciaLoadGlobalRegistryValues(
    VOID
    )
/*++

Routine Description:

    This routine is called at driver init time to load in various global
    options from the registry.
    These are read in from SYSTEM\CurrentControlSet\Services\Pcmcia\Parameters.

Arguments:

    none

Return value:

    none

--*/
{
    PRTL_QUERY_REGISTRY_TABLE parms;
    NTSTATUS                      status;
    ULONG                         parmsSize;
    ULONG i;

    status = PcmciaScanHardwareDescription();

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Needs a null entry to terminate the list
    //

    parmsSize = sizeof(RTL_QUERY_REGISTRY_TABLE) * (GlobalInfoCount+1);

    parms = ExAllocatePool(PagedPool, parmsSize);

    if (!parms) {
         return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(parms, parmsSize);

    //
    // Fill in the query table from our table
    //

    for (i = 0; i < GlobalInfoCount; i++) {
        parms[i].Flags        = RTL_QUERY_REGISTRY_DIRECT;
        parms[i].Name             = GlobalRegistryInfo[i].Name;
        parms[i].EntryContext  = GlobalRegistryInfo[i].pValue;
        parms[i].DefaultType   = REG_DWORD;
        parms[i].DefaultData   = &GlobalRegistryInfo[i].Default;
        parms[i].DefaultLength = sizeof(ULONG);
    }

    //
    // Perform the query
    //

    status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES | RTL_REGISTRY_OPTIONAL,
                                    PCMCIA_REGISTRY_PARAMETERS_KEY,
                                    parms,
                                    NULL,
                                    NULL);

    if (!NT_SUCCESS(status)) {
         //
         // This is possible during text mode setup
         //

         for (i = 0; i < GlobalInfoCount; i++) {
             *GlobalRegistryInfo[i].pValue = GlobalRegistryInfo[i].Default;
         }
    }

    if (initUsePolledCsc) {
         PcmciaGlobalFlags |= PCMCIA_GLOBAL_FORCE_POLL_MODE;
    }

    if (initDisableAcpiNameSpaceCheck) {
         PcmciaGlobalFlags |= PCMCIA_DISABLE_ACPI_NAMESPACE_CHECK;
    }

    if (initDefaultRouteR2ToIsa) {
         PcmciaGlobalFlags |= PCMCIA_DEFAULT_ROUTE_R2_TO_ISA;
    }

    if (EventDpcDelay > PCMCIA_MAX_EVENT_DPC_DELAY) {
        EventDpcDelay = PCMCIA_MAX_EVENT_DPC_DELAY;
    }


    if (!pcmciaIsaIrqRescanComplete) {
        UNICODE_STRING  unicodeKey, unicodeValue;
        OBJECT_ATTRIBUTES objectAttributes;
        HANDLE              handle;
        ULONG               value;

        //
        // This mechanism is used to throw away the cached ISA irq map values. To do this
        // only once, we make sure a value in the registry is zero (or non-existant), and
        // here we set it to one.
        //

        RtlInitUnicodeString(&unicodeKey,
                                    L"\\Registry\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Pcmcia\\Parameters");
        RtlZeroMemory(&objectAttributes, sizeof(OBJECT_ATTRIBUTES));
        InitializeObjectAttributes(&objectAttributes,
                                   &unicodeKey,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        if (NT_SUCCESS(ZwOpenKey(&handle, KEY_READ | KEY_WRITE, &objectAttributes))) {

            RtlInitUnicodeString(&unicodeValue, PCMCIA_REGISTRY_ISA_IRQ_RESCAN_COMPLETE);
            value = 1;

            ZwSetValueKey(handle,
                          &unicodeValue,
                          0,
                          REG_DWORD,
                          &value,
                          sizeof(value));

            ZwClose(handle);
        }

    }

    ExFreePool(parms);

    return STATUS_SUCCESS;
}



NTSTATUS
PcmciaGetControllerRegistrySettings(
    IN OUT PFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

    This routine looks in the registry to see if a compatible controller type
    was specified in the INF.

Arguments:

    FdoExtension - The fdo extension corresponding to the PCMCIA controller

Return value:

--*/
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    UNICODE_STRING  KeyName;
    HANDLE instanceHandle;
    UCHAR               buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
    PKEY_VALUE_PARTIAL_INFORMATION value = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
    ULONG               length;
    BOOLEAN             UseLegacyIrqMask = TRUE;
    ULONG               detectedIrqMask;

    if (FdoExtension->Pdo) {
        status = IoOpenDeviceRegistryKey(FdoExtension->Pdo,
                                         PLUGPLAY_REGKEY_DRIVER,
                                         KEY_READ,
                                         &instanceHandle
                                         );
    }

    if (!NT_SUCCESS(status)) {
        instanceHandle = NULL;
    }

    if (instanceHandle) {

        //
        // Look to see if a controller ID was specified
        //
        RtlInitUnicodeString(&KeyName, PCMCIA_REGISTRY_COMPATIBLE_TYPE);

        status =  ZwQueryValueKey(instanceHandle,
                                  &KeyName,
                                  KeyValuePartialInformation,
                                  value,
                                  sizeof(buffer),
                                  &length);


        if (NT_SUCCESS(status)) {
            PcmciaSetControllerType(FdoExtension, *(PPCMCIA_CONTROLLER_TYPE)(value->Data));
        }

        //
        // Check for voltage preference
        // When an 3v R2 card is plugged in, and the controller
        // sets both 5v and 3.3v, this allows 3.3v to be preferred.
        //
        RtlInitUnicodeString(&KeyName, PCMCIA_REGISTRY_VOLTAGE_PREFERENCE);

        status =  ZwQueryValueKey(instanceHandle,
                                  &KeyName,
                                  KeyValuePartialInformation,
                                  value,
                                  sizeof(buffer),
                                  &length);


        if (NT_SUCCESS(status) && (*(PULONG)(value->Data) == 33)) {
            SetDeviceFlag(FdoExtension, PCMCIA_FDO_PREFER_3V);
        }
    }

    //
    // Retrieve context ranges
    //

    PcmciaGetRegistryContextRange(instanceHandle,
                                  PCMCIA_REGISTRY_PCI_CONTEXT_VALUE,
                                  DefaultPciContextSave,
                                  NULL,
                                  &FdoExtension->PciContext
                                  );

    PcmciaGetRegistryContextRange(instanceHandle,
                                  PCMCIA_REGISTRY_CB_CONTEXT_VALUE,
                                  DefaultCardbusContextSave,
                                  ExcludeCardbusContextRange,
                                  &FdoExtension->CardbusContext
                                  );

    PcmciaGetRegistryContextRange(instanceHandle,
                                  PCMCIA_REGISTRY_EXCA_CONTEXT_VALUE,
                                  NULL,
                                  NULL,
                                  &FdoExtension->ExcaContext);


    if (instanceHandle) {
        ZwClose(instanceHandle);
    }


    FdoExtension->AttributeMemoryLow  =  globalAttributeMemoryLow;
    FdoExtension->AttributeMemoryHigh =  globalAttributeMemoryHigh;

    if (FdoExtension->ControllerType == PcmciaDatabook) {
        FdoExtension->AttributeMemoryAlignment = TCIC_WINDOW_ALIGNMENT;
    } else {
        FdoExtension->AttributeMemoryAlignment = PCIC_WINDOW_ALIGNMENT;
    }

    //
    // Assign default attribute memory window size
    //

    if (globalAttributeMemorySize == 0) {
        switch (FdoExtension->ControllerType) {

        case PcmciaDatabook:
            FdoExtension->AttributeMemorySize = TCIC_WINDOW_SIZE;
             break;
        default:
            FdoExtension->AttributeMemorySize = PCIC_WINDOW_SIZE;
            break;
        }
    } else {
        FdoExtension->AttributeMemorySize = globalAttributeMemorySize;
    }

    //
    // See if the user asked for some special IRQ routing considerations based
    // on controller type
    //

    if (CardBusExtension(FdoExtension)) {

        //
        // route to PCI based on controller type
        //

        if (pcmciaIrqRouteToPciController) {
            ULONG ctlr = pcmciaIrqRouteToPciController;

            //
            // Check for exact match, or class if only a class was specified
            //
            if ((ctlr == FdoExtension->ControllerType) ||
                 ((PcmciaClassFromControllerType(ctlr) == ctlr) && (ctlr == PcmciaClassFromControllerType(FdoExtension->ControllerType)))) {

                SetFdoFlag(FdoExtension, PCMCIA_FDO_PREFER_PCI_ROUTING);
            }
        }

        //
        // route to ISA based on controller type
        //

        if (pcmciaIrqRouteToIsaController) {
            ULONG ctlr = pcmciaIrqRouteToIsaController;

            //
            // Check for exact match, or class if only a class was specified
            //
            if ((ctlr == FdoExtension->ControllerType) ||
                 ((PcmciaClassFromControllerType(ctlr) == ctlr) && (ctlr == PcmciaClassFromControllerType(FdoExtension->ControllerType)))) {

                SetFdoFlag(FdoExtension, PCMCIA_FDO_PREFER_ISA_ROUTING);
            }
        }

        //
        // route to PCI based on controller location
        //

        if (pcmciaIrqRouteToPciLocation) {
            ULONG loc = pcmciaIrqRouteToPciLocation;

            if ( ((loc & 0xff) == FdoExtension->PciBusNumber) &&
                  (((loc >> 8) & 0xff) == FdoExtension->PciDeviceNumber)) {

                SetFdoFlag(FdoExtension, PCMCIA_FDO_FORCE_PCI_ROUTING);
            }
        }

        //
        // route to ISA based on controller location
        //

        if (pcmciaIrqRouteToIsaLocation) {
            ULONG loc = pcmciaIrqRouteToIsaLocation;

            if ( ((loc & 0xff) == FdoExtension->PciBusNumber) &&
                  (((loc >> 8) & 0xff) == FdoExtension->PciDeviceNumber)) {

                SetFdoFlag(FdoExtension, PCMCIA_FDO_FORCE_ISA_ROUTING);
            }
        }

    }


    return status;
}



VOID
PcmciaGetRegistryFdoIrqMask(
    IN OUT PFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

    This routine fills in the field "AllocatedIrqMask" in the specified
    fdo extension.

Arguments:

    instanceHandle - open registry key for this controller
    pIrqMask        - pointer to variable to receive irq mask

Return value:

    none

--*/
{
    ULONG               irqMask, cachedIrqMask = 0;
    UNICODE_STRING  KeyName;
    NTSTATUS            status;
    UCHAR               buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
    PKEY_VALUE_PARTIAL_INFORMATION value = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
    ULONG               length;
    HANDLE              instanceHandle;
    ULONG               detectedIrqMask;

    PAGED_CODE();

    if (globalOverrideIrqMask) {

        irqMask = globalOverrideIrqMask;

    } else {

        detectedIrqMask = PcmciaGetDetectedFdoIrqMask(FdoExtension);

        status = STATUS_UNSUCCESSFUL;

        if (FdoExtension->Pdo) {
            status = IoOpenDeviceRegistryKey(FdoExtension->Pdo,
                                             PLUGPLAY_REGKEY_DRIVER,
                                             KEY_READ,
                                             &instanceHandle
                                             );
        }

        if (NT_SUCCESS(status)) {
            //
            // Here we cache the value, and accumulate bits so that
            // our mask improves with time.
            //
            RtlInitUnicodeString(&KeyName, PCMCIA_REGISTRY_CACHED_IRQMASK);

            if (pcmciaIsaIrqRescanComplete) {
                status =  ZwQueryValueKey(instanceHandle,
                                          &KeyName,
                                          KeyValuePartialInformation,
                                          value,
                                          sizeof(buffer),
                                          &length);


                if (NT_SUCCESS(status)) {
                    cachedIrqMask = *(PULONG)(value->Data);
                }
            }

            irqMask = detectedIrqMask | cachedIrqMask;

            if ((cachedIrqMask != irqMask) || !pcmciaIsaIrqRescanComplete) {
                //
                // something changed, update the cached value
                //
                ZwSetValueKey(instanceHandle, &KeyName, 0, REG_DWORD, &irqMask, sizeof(irqMask));
            }

            ZwClose(instanceHandle);
        } else {
            //
            // Hmmm, no key. Can't cache the value
            //
            irqMask = detectedIrqMask;
        }

        if (pcmciaDisableIsaPciRouting && (PcmciaCountOnes(irqMask) < 2)) {
            //
            // Perhaps irq detection is broken... fall back on old NT4 behavior
            //
            irqMask = 0;
        }
    }

    irqMask &= ~globalFilterIrqMask;

    DebugPrint((PCMCIA_DEBUG_INFO, "IrqMask %08x (ovr %08x, flt %08x, det %08x, cache %08x)\n",
                          irqMask, globalOverrideIrqMask, globalFilterIrqMask, detectedIrqMask, cachedIrqMask));

    FdoExtension->DetectedIrqMask = (USHORT)irqMask;
}


VOID
PcmciaGetRegistryContextRange(
    IN HANDLE instanceHandle,
    IN PCWSTR Name,
    IN OPTIONAL const PCMCIA_CONTEXT_RANGE IncludeRange[],
    IN OPTIONAL const PCMCIA_CONTEXT_RANGE ExcludeRange[],
    OUT PPCMCIA_CONTEXT pContext
    )
/*++

Routine Description:

    This routine returns a buffer containing the contents of the
    data which set by the controller's inf definition (AddReg). The value
    is in CurrentControlSet\Control\Class\{GUID}\{Instance}.

Arguments:

    FdoExtension - The fdo extension corresponding to the PCMCIA controller
    Name         - The name of the value in the registry
    IncludeRange - defines areas in the range that must be included
    ExcludeRange - defines areas in the range that must be excluded

Return value:

    Status

--*/
{
#define PCMCIA_MAX_CONTEXT_ENTRIES 128
#define MAX_RANGE_OFFSET 256

    NTSTATUS            status;
    UNICODE_STRING  unicodeKeyName;
    UCHAR               buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
                                    PCMCIA_MAX_CONTEXT_ENTRIES*sizeof(PCMCIA_CONTEXT_RANGE)];
    PKEY_VALUE_PARTIAL_INFORMATION value = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
    UCHAR               rangeMap[MAX_RANGE_OFFSET] = {0};
    PPCMCIA_CONTEXT_RANGE newRange;
    LONG                    rangeCount;
    ULONG               rangeLength;
    ULONG               bufferLength;
    UCHAR               lastEntry;
    ULONG               keyLength;
    USHORT              i, j;
    USHORT              startOffset, endOffset;

    PAGED_CODE();

    //
    // Initialize the range map with the minimum range
    //

    if (IncludeRange) {
        for (i = 0; IncludeRange[i].wLen != 0; i++) {

            startOffset = IncludeRange[i].wOffset;
            endOffset   = IncludeRange[i].wOffset + IncludeRange[i].wLen - 1;

            if ((startOffset >= MAX_RANGE_OFFSET) ||
                 (endOffset >= MAX_RANGE_OFFSET)) {
                continue;
            }

            for (j = startOffset; j <= endOffset; j++) {
                rangeMap[j] = 0xff;
            }
        }
    }


    if (instanceHandle) {
        RtlInitUnicodeString(&unicodeKeyName, Name);

        status =  ZwQueryValueKey(instanceHandle,
                                  &unicodeKeyName,
                                  KeyValuePartialInformation,
                                  value,
                                  sizeof(buffer),
                                  &keyLength);


        if (NT_SUCCESS(status)) {

            //
            // Merge in the range specified in the registry
            //
            newRange = (PPCMCIA_CONTEXT_RANGE) value->Data;
            for (i = 0; i < value->DataLength/sizeof(PCMCIA_CONTEXT_RANGE); i++) {

                startOffset = newRange[i].wOffset;
                endOffset   = newRange[i].wOffset + newRange[i].wLen - 1;

                if ((startOffset >= MAX_RANGE_OFFSET) ||
                     (endOffset >= MAX_RANGE_OFFSET)) {
                    continue;
                }

                for (j = startOffset; j <= endOffset; j++) {
                    rangeMap[j] = 0xff;
                }
            }

        }
    }

    //
    // Filter out registers defined in the exclude range
    //

    if (ExcludeRange) {
        for (i = 0; ExcludeRange[i].wLen != 0; i++) {

            startOffset = ExcludeRange[i].wOffset;
            endOffset   = ExcludeRange[i].wOffset + ExcludeRange[i].wLen - 1;

            if ((startOffset >= MAX_RANGE_OFFSET) ||
                 (endOffset >= MAX_RANGE_OFFSET)) {
                continue;
            }

            for (j = startOffset; j <= endOffset; j++) {
                rangeMap[j] = 0;
            }
        }
    }


    //
    // Now build the resulting merged range in the buffer on the
    // stack, and figure out how big it is.
    //
    newRange = (PPCMCIA_CONTEXT_RANGE) buffer;
    rangeCount = -1;
    bufferLength = 0;
    lastEntry = 0;

    for (i = 0; i < MAX_RANGE_OFFSET; i++) {

        if (rangeMap[i]) {
            bufferLength++;
            if (lastEntry) {
                //
                // This new byte belongs to the current range
                //
                newRange[rangeCount].wLen++;
            } else {
                //
                // Starting a new range
                //
                if (rangeCount == (PCMCIA_MAX_CONTEXT_ENTRIES - 1)) {
                    break;
                }
                rangeCount++;
                newRange[rangeCount].wOffset = i;
                newRange[rangeCount].wLen = 1;
            }

        }
        lastEntry = rangeMap[i];
    }
    rangeCount++;

    pContext->Range = NULL;
    pContext->RangeCount = 0;

    if (rangeCount) {
        //
        // Length of data
        //
        rangeLength = rangeCount*sizeof(PCMCIA_CONTEXT_RANGE);

        pContext->Range = ExAllocatePool(NonPagedPool, rangeLength);

        if (pContext->Range != NULL) {
            RtlCopyMemory(pContext->Range, buffer, rangeLength);
            pContext->RangeCount = (ULONG)rangeCount;
            pContext->BufferLength = bufferLength;

            //
            // Find the length of the longest individual range
            //
            pContext->MaxLen = 0;
            for (i = 0; i < rangeCount; i++) {
                if (pContext->Range[i].wLen > pContext->MaxLen) {
                    pContext->MaxLen = pContext->Range[i].wLen;
                }
            }
        } else {
            ASSERT(pContext->Range != NULL);
        }
    }
}


NTSTATUS
PcmciaGetLegacyDetectedControllerType(
    IN PDEVICE_OBJECT Pdo,
    IN OUT PPCMCIA_CONTROLLER_TYPE ControllerType
    )
/*++

Routine Description:

    This routine returns the previously remembered controller type
    for the supplied pcmcia controller by poking in the registry
    at the appropriate places

Arguments:

    Pdo - The Physical device object corresponding to the PCMCIA controller
    ControllerType - pointer to the object in which the controller type will
                            be returned


Return value:

    Status

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING  unicodeKeyName;
    HANDLE              instanceHandle=NULL;
    HANDLE              parametersHandle = NULL;
    RTL_QUERY_REGISTRY_TABLE queryTable[3];
    ULONG controllerType;
    ULONG invalid = 0xffffffff;


    PAGED_CODE();

    try {
        status = IoOpenDeviceRegistryKey(Pdo,
                                         PLUGPLAY_REGKEY_DEVICE,
                                         KEY_READ,
                                         &instanceHandle
                                         );
        if (!NT_SUCCESS(status)) {
            leave;
        }

        RtlInitUnicodeString(&unicodeKeyName, PCMCIA_REGISTRY_DETECTED_DEVICE_KEY);
        InitializeObjectAttributes(
                                   &objectAttributes,
                                   &unicodeKeyName,
                                   OBJ_CASE_INSENSITIVE,
                                   instanceHandle,
                                   NULL);

        status = ZwOpenKey(&parametersHandle,
                           KEY_READ,
                           &objectAttributes);

        if (!NT_SUCCESS(status)) {
            leave;
        }


        RtlZeroMemory(queryTable, sizeof(queryTable));

        queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        queryTable[0].Name = L"ControllerType";
        queryTable[0].EntryContext = &controllerType;
        queryTable[0].DefaultType = REG_DWORD;
        queryTable[0].DefaultData = &invalid;
        queryTable[0].DefaultLength = sizeof(ULONG);

        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                        (PWSTR) parametersHandle,
                                        queryTable,
                                        NULL,
                                        NULL);

        if (!NT_SUCCESS(status)) {
            leave;
        }

        if (controllerType == invalid) {
            *ControllerType = PcmciaIntelCompatible;
        } else {
            *ControllerType = (PCMCIA_CONTROLLER_TYPE) controllerType;
        }

    } finally {

        if (instanceHandle != NULL) {
            ZwClose(instanceHandle);
        }

        if (parametersHandle != NULL) {
            ZwClose(parametersHandle);
        }
    }

    return status;
}


NTSTATUS
PcmciaSetLegacyDetectedControllerType(
    IN PDEVICE_OBJECT Pdo,
    IN PCMCIA_CONTROLLER_TYPE ControllerType
    )
/*++

Routine Description:

    This routine 'remembers' - by setting a value in the registry -
    the type of the    pcmcia controller that has been legacy detected
    to be retrieved and used in subsequent boots - if legacy re-detection
    of the controller is not performed

Arguments:

    Pdo - The Physical device object corresponding to the PCMCIA controller
    DeviceExtension -  Device extension of the fdo corresponding to the
                              controller

Return value:

    Status

--*/
{
    HANDLE                  instanceHandle;
    NTSTATUS                status;
    OBJECT_ATTRIBUTES   objectAttributes;
    HANDLE                  parametersHandle;
    UNICODE_STRING      unicodeString;

    PAGED_CODE();

    //
    // Get a handle to the registry devnode for this pdo
    //

    status = IoOpenDeviceRegistryKey(Pdo,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_CREATE_SUB_KEY,
                                     &instanceHandle);

    if (!NT_SUCCESS(status)) {
        return status;
    }


    //
    // Open or create a sub-key for this devnode to store
    // the information in
    //

    RtlInitUnicodeString(&unicodeString, PCMCIA_REGISTRY_DETECTED_DEVICE_KEY);

    InitializeObjectAttributes(&objectAttributes,
                               &unicodeString,
                               OBJ_CASE_INSENSITIVE,
                               instanceHandle,
                               NULL);

    status = ZwCreateKey(&parametersHandle,
                         KEY_SET_VALUE,
                         &objectAttributes,
                         0,
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         NULL);

    if (!NT_SUCCESS(status)) {
        ZwClose(instanceHandle);
        return status;
    }
    //
    // Set the controller type value in the registry
    //
    RtlInitUnicodeString(&unicodeString, L"ControllerType");
    status = ZwSetValueKey(parametersHandle,
                           &unicodeString,
                           0,
                           REG_DWORD,
                           &ControllerType,
                           sizeof(ControllerType));
    ZwClose(parametersHandle);
    ZwClose(instanceHandle);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\ti.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    ti.c

Abstract:

    This module contains the code that contains
    Texas Instruments cardbus controller specific
    initialization and other dispatches

Author:

    Ravisankar Pudipeddi (ravisp) 1-Nov-97
    Neil Sandlin (neilsa) 1-Jun-1999


Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"



VOID
TIInitialize(
    IN PFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

    Initialize TI cardbus controllers

Arguments:

    FdoExtension - Pointer to the device extension for the controller FDO

Return Value:

    None
--*/

{
    UCHAR                   byte;
    USHORT                  word;
    BOOLEAN                 TiOldRev = FALSE;
    PSOCKET                 socket = FdoExtension->SocketList;

    if (FdoExtension->ControllerType == PcmciaTI1130) {
        UCHAR revisionID;

        GetPciConfigSpace(FdoExtension, CFGSPACE_REV_ID, &revisionID, 1);
        if (revisionID < 4) {
            TiOldRev = TRUE;
        }
    }

    GetPciConfigSpace(FdoExtension, CFGSPACE_CACHE_LINESIZE, &byte, 1);
    if (byte == 0) {
        byte = 8;
        SetPciConfigSpace(FdoExtension, CFGSPACE_CACHE_LINESIZE, &byte, 1);
    }

    byte = RETRY_CBRETRY_TIMEOUT_ENABLE|RETRY_PCIRETRY_TIMEOUT_ENABLE;
    SetPciConfigSpace(FdoExtension, CFGSPACE_TI_RETRY_STATUS, &byte, 1);

    GetPciConfigSpace(FdoExtension, CFGSPACE_TI_CARD_CTRL, &byte, 1);

    byte &= ~(CARDCTRL_CSCINT_ENABLE | CARDCTRL_FUNCINT_ENABLE |
                 CARDCTRL_PCIINT_ENABLE);
    byte |= CARDCTRL_CSCINT_ENABLE | CARDCTRL_PCIINT_ENABLE;

    if (!TiOldRev) {
        byte |= CARDCTRL_FUNCINT_ENABLE;
    }

    SetPciConfigSpace(FdoExtension, CFGSPACE_TI_CARD_CTRL, &byte, 1);

    byte=PcicReadSocket(socket, PCIC_INTERRUPT);
    PcicWriteSocket(socket, PCIC_INTERRUPT , (UCHAR) (byte | IGC_INTR_ENABLE));


    GetPciConfigSpace(FdoExtension, CFGSPACE_TI_DEV_CTRL, &byte, 1);
    if ((byte & DEVCTRL_INTMODE_MASK) == DEVCTRL_INTMODE_DISABLED) {
        DebugPrint((PCMCIA_DEBUG_INFO, "TIInitialize: ISA interrupt mode is not enabled, assume simple ISA mode"));

        byte |= DEVCTRL_INTMODE_ISA;
        SetPciConfigSpace(FdoExtension, CFGSPACE_TI_DEV_CTRL, &byte, 1);
    } else if ((byte & DEVCTRL_INTMODE_MASK)==DEVCTRL_INTMODE_SERIAL) {
        //
        // We use serial interrupts
        //
    }

    if (((FdoExtension->ControllerType == PcmciaTI1130) || (FdoExtension->ControllerType == PcmciaTI1131)) &&
         ((byte & DEVCTRL_INTMODE_MASK) == DEVCTRL_INTMODE_ISA)) {

        FdoExtension->LegacyIrqMask = 0xCEA0; // 5, 7, 9, 10, 11, 14, 15

    }

    if ((byte & DEVCTRL_INTMODE_MASK) == DEVCTRL_INTMODE_COMPAQ) {
         FdoExtension->Flags |= PCMCIA_INTMODE_COMPAQ;
    } else {
         FdoExtension->Flags &= ~PCMCIA_INTMODE_COMPAQ;
    }

    //NOTE: This only initializes the page register on the 113x
    PcicWriteSocket(socket, PCIC_PAGE_REG, 0);

    //
    // NOTE: this is not done on win9x, I doubt we even need it. It
    // was previously being done because it was in the PcicRegisterInitTable.
    // But it was a bug to have it in that table, since this register is
    // adapter specific. Now I'm putting it here only for paranoia since
    // it has been in the driver for a long time.
    //
    // The comment in data.c was:
    // // Set GLOBAL_CONTROL for auto-clearing of status bit
    //
    PcicWriteSocket(socket, PCIC_TI_GLOBAL_CONTROL, 0);

    //
    // Workaround for CCLK instability problem
    //

    if ((FdoExtension->ControllerType == PcmciaTI1220) ||
         (FdoExtension->ControllerType == PcmciaTI1250) ||
         (FdoExtension->ControllerType == PcmciaTI1251B)) {

        CBWriteSocketRegister(socket, CBREG_TI_SKT_POWER_MANAGEMENT,
                                                (CBREG_TI_CLKCTRLLEN | CBREG_TI_CLKCTRL));

    }

    //
    // initialize IRQ routing to ISA
    //

    GetPciConfigSpace(FdoExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
    word |= BCTRL_IRQROUTING_ENABLE;
    SetPciConfigSpace(FdoExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
}


BOOLEAN
TISetZV(
    IN PSOCKET Socket,
    IN BOOLEAN Enable
    )
{
    UCHAR TiCardCtl;
    PFDO_EXTENSION FdoExtension = Socket->DeviceExtension;

    if (Enable) {

        GetPciConfigSpace(FdoExtension, CFGSPACE_TI_CARD_CTRL, &TiCardCtl, 1);
        TiCardCtl |= CARDCTRL_ZV_ENABLE;
        TiCardCtl &= ~CARDCTRL_SPKR_ENABLE;
        SetPciConfigSpace(FdoExtension, CFGSPACE_TI_CARD_CTRL, &TiCardCtl, 1);

    } else {

        //
        // check for devices that have the problem of leaking current when zv is
        // disabled
        //
        if ((FdoExtension->ControllerType == PcmciaTI1450) ||
             (FdoExtension->ControllerType == PcmciaTI1251B)) {
            return TRUE;
        }

        GetPciConfigSpace(FdoExtension, CFGSPACE_TI_CARD_CTRL, &TiCardCtl, 1);
        TiCardCtl &= ~CARDCTRL_ZV_ENABLE;
        TiCardCtl |= CARDCTRL_SPKR_ENABLE;
        SetPciConfigSpace(FdoExtension, CFGSPACE_TI_CARD_CTRL, &TiCardCtl, 1);

    }

    return TRUE;
}


BOOLEAN
TISetWindowPage(IN PSOCKET Socket,
                     USHORT Index,
                     UCHAR Page)
{
    PFDO_EXTENSION FdoExtension = Socket->DeviceExtension;
    ASSERT(Index <= 4);


    if (FdoExtension->ControllerType == PcmciaTI1031) {
        return FALSE;
    }

    if (FdoExtension->ControllerType != PcmciaTI1130) {
        return CBSetWindowPage(Socket, Index, Page);
    }


    if ((PcicReadSocket(Socket, PCIC_ADD_WIN_ENA) & WE_MEMWIN_MASK) == 0)
        PcicWriteSocket(Socket, PCIC_TI_MEMWIN_PAGE, Page);
    else if ((Page != 0) && (PcicReadSocket(Socket, PCIC_TI_MEMWIN_PAGE) != Page)) {
        DebugPrint((PCMCIA_DEBUG_FAIL,
                      "PCMCIA: TISetWindowPage setting a 2nd memory window in a different 16M page (Page=%x)",
                      Page));
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\topic.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    topic.c

Abstract:

    This module contains the code that contains
    Toshiba topic cardbus controller specific initialization
    and other dispatches

Author:

    Ravisankar Pudipeddi (ravisp) 1-Nov-97
    Neil Sandlin (neilsa) 1-Jun-1999


Environment:

    Kernel mode

Revision History :

    Neil Sandlin (neilsa) 3-Mar-99
       new setpower routine interface

--*/

#include "pch.h"



VOID
TopicInitialize(
    IN PFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

    Initialize Toshiba Topic cardbus controllers

Arguments:

    FdoExtension - Pointer to the device extension for the controller FDO

Return Value:

    None
--*/
{
    UCHAR byte;
    USHORT word;

    if (FdoExtension->ControllerType == PcmciaTopic95) {
        //
        // 480CDT in a dock needs this for socket registers to be visible.
        // It should be on all the time anyway.
        //
        GetPciConfigSpace(FdoExtension, CFGSPACE_TO_CD_CTRL, &byte, 1);
        byte |= CDCTRL_PCCARD_16_32;
        SetPciConfigSpace(FdoExtension, CFGSPACE_TO_CD_CTRL, &byte, 1);
    }

     //enable 3.3V capable

    byte = PcicReadSocket(FdoExtension->SocketList, PCIC_TO_FUNC_CTRL) | TO_FCTRL_CARDPWR_ENABLE;
    PcicWriteSocket(FdoExtension->SocketList,
                    PCIC_TO_FUNC_CTRL,
                    byte);

    //
    // initialize IRQ routing to ISA
    //

    GetPciConfigSpace(FdoExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
    word |= BCTRL_IRQROUTING_ENABLE;
    SetPciConfigSpace(FdoExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
}



NTSTATUS
TopicSetPower(
    IN PSOCKET Socket,
    IN BOOLEAN Enable,
    OUT PULONG pDelayTime
    )

/*++

Routine Description:

    Set power to the specified socket.

Arguments:

    Socket - the socket to set
    Enable - TRUE means to set power - FALSE is to turn it off.
    pDelayTime - specifies delay (msec) to occur after the current phase

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - increment phase, perform delay, recall
    other status values terminate sequence

--*/

{
    NTSTATUS status;
    UCHAR               oldPower, newPower;

    if (IsCardBusCardInSocket(Socket)) {
        //
        // Hand over to generic power setting routine
        //
        return(CBSetPower(Socket, Enable, pDelayTime));
    }

    switch(Socket->PowerPhase) {
    case 1:
        //
        // R2 card - special handling
        //
        oldPower = PcicReadSocket(Socket, PCIC_PWR_RST);

        //
        // Set power values
        //
        if (Enable) {
            //
            // turn power on
            //
            newPower = PC_CARDPWR_ENABLE;

            if (Socket->Vcc == 33) {
                newPower |= PC_VCC_TOPIC_033V;
            }

            //
            // set Vpp
            //
            if (Socket->Vcc == Socket->Vpp1) {
                newPower |= PC_VPP_SETTO_VCC;
            } else if (Socket->Vpp1 == 120) {
                newPower |= PC_VPP_SETTO_VPP;
            }

        } else {
            //
            // turn power off
            //
            newPower = 0;
        }

        //
        // Don't nuke the non-power related bits in the register..
        //
        newPower |= (oldPower & PC_PWRON_BITS);
        //
        // If Vcc is turned off, reset OUTPUT_ENABLE & AUTOPWR_ENABLE
        //
        if (!(newPower & PC_CARDPWR_ENABLE)) {
            newPower &= ~PC_PWRON_BITS;
        }
        //
        // Disable ResetDrv
        //
        newPower |= PC_RESETDRV_DISABLE;

        status = STATUS_SUCCESS;
        if (newPower != oldPower) {
            PcicWriteSocket(Socket, PCIC_PWR_RST, newPower);
            //
            // Allow ramp up.. (actually we don't need to this if
            // Enable was FALSE).  Keep it for paranoia's sake
            //
            *pDelayTime = PCMCIA_PCIC_STALL_POWER;
            Socket->PowerData = (ULONG) newPower;
            status = STATUS_MORE_PROCESSING_REQUIRED;
        }
        break;

    case 2:

        newPower = (UCHAR) Socket->PowerData;

        if ((newPower & PC_CARDPWR_ENABLE) &&
             ((newPower & PC_PWRON_BITS) != PC_PWRON_BITS)) {
            //
            // More paranoia?
            //
            newPower |= PC_PWRON_BITS;
            PcicWriteSocket(Socket, PCIC_PWR_RST, newPower);
        }

        status = STATUS_SUCCESS;
        *pDelayTime = PCMCIA_PCIC_STALL_POWER;
        break;

    default:
        ASSERT(FALSE);
        status = STATUS_UNSUCCESSFUL;
    }
    return status;
}



VOID
TopicSetAudio(
    IN PSOCKET Socket,
    IN BOOLEAN Enable
    )
{
    PFDO_EXTENSION FdoExtension = Socket->DeviceExtension;
    ULONG data;
    ULONG orig_data;
    BOOLEAN setBit;


    setBit = (IsCardBusCardInSocket(Socket) ^ Enable);

    GetPciConfigSpace(FdoExtension, CFGSPACE_TO_CBREG_CTRL, &data, sizeof(data));
    orig_data = data;

    if (setBit) {
        data |= CSRCR_TO_CAUDIO_OFF;
    } else {
        data &= ~CSRCR_TO_CAUDIO_OFF;
    }

    if (orig_data != data) {
        SetPciConfigSpace(FdoExtension, CFGSPACE_TO_CBREG_CTRL, &data, sizeof(data));
    }

}



BOOLEAN
TopicSetZV(
    IN PSOCKET Socket,
    IN BOOLEAN Enable
    )
{
    UCHAR bData;

    if (Enable) {

        PcicWriteSocket(Socket, PCIC_TO_MMI_CTRL, TO_MMI_VIDEO_CTRL | TO_MMI_AUDIO_CTRL);
        bData = PcicReadSocket(Socket, PCIC_TO_ADDITIONAL_GENCTRL);
        bData |= TO_GCTRL_CARDREMOVAL_RESET;
        PcicWriteSocket(Socket, PCIC_TO_ADDITIONAL_GENCTRL, bData);

    } else {

        PcicWriteSocket(Socket, PCIC_TO_MMI_CTRL, 0);
        bData = PcicReadSocket(Socket, PCIC_TO_ADDITIONAL_GENCTRL);
        bData &= ~TO_GCTRL_CARDREMOVAL_RESET;
        PcicWriteSocket(Socket, PCIC_TO_ADDITIONAL_GENCTRL, bData);

    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\agpintrf.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    agpintrf.c

Abstract:

    This module implements the "bus handler" interfaces supported
    by the PCI driver.

Author:

    Peter Johnston (peterj)  6-Jun-1997

Revision History:

--*/

#include "pcip.h"

#define AGPINTRF_VERSION 1

//
// Prototypes for routines exposed only thru the "interface"
// mechanism.
//

NTSTATUS
agpintrf_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    );

VOID
agpintrf_Reference(
    IN PVOID Context
    );

VOID
agpintrf_Dereference(
    IN PVOID Context
    );

NTSTATUS
agpintrf_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    );

ULONG
PciReadAgpConfig(
    IN PVOID Context,
    IN ULONG WhichSpace,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
PciWriteAgpConfig(
    IN PVOID Context,
    IN ULONG WhichSpace,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

//
// Define the Bus Interface "Interface" structure.
//

PCI_INTERFACE AgpTargetInterface = {
    &GUID_AGP_TARGET_BUS_INTERFACE_STANDARD,   // InterfaceType
    sizeof(AGP_TARGET_BUS_INTERFACE_STANDARD), // MinSize
    AGPINTRF_VERSION,                          // MinVersion
    AGPINTRF_VERSION,                          // MaxVersion
    PCIIF_PDO,                                 // Flags
    0,                                         // ReferenceCount
    PciInterface_AgpTarget,                    // Signature
    agpintrf_Constructor,                      // Constructor
    agpintrf_Initializer                       // Instance Initializer
};

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, agpintrf_Constructor)
    #pragma alloc_text(PAGE, agpintrf_Dereference)
    #pragma alloc_text(PAGE, agpintrf_Initializer)
    #pragma alloc_text(PAGE, agpintrf_Reference)
#endif

VOID
agpintrf_Reference(
    IN PVOID Context
    )
{
    PPCI_PDO_EXTENSION targetExtension = (PPCI_PDO_EXTENSION)Context;

    ASSERT_PCI_PDO_EXTENSION(targetExtension);

    if (InterlockedIncrement(&targetExtension->AgpInterfaceReferenceCount) == 1) {

        ObReferenceObject(targetExtension->PhysicalDeviceObject);
    }
}

VOID
agpintrf_Dereference(
    IN PVOID Context
    )
{
    PPCI_PDO_EXTENSION targetExtension = (PPCI_PDO_EXTENSION)Context;

    ASSERT_PCI_PDO_EXTENSION(targetExtension);

    if (InterlockedDecrement(&targetExtension->AgpInterfaceReferenceCount) == 0) {

        ObDereferenceObject(targetExtension->PhysicalDeviceObject);
    }
}



NTSTATUS
agpintrf_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    )
/*++

Routine Description:

    Initialize the AGP_TARGET_BUS_INTERFACE fields.
    This interface can only be requested from the device stack of an AGP
    bridge.  This routine looks for an AGP capability in the requester
    bridge and any peer host bridges.  If one is found, config access
    to the device with the capability is granted.

Arguments:

    PciInterface    Pointer to the PciInterface record for this
                    interface type.
    InterfaceSpecificData
                    A ULONG containing the resource type for which
                    arbitration is required.
    InterfaceReturn

Return Value:

    TRUE is this device is not known to cause problems, FALSE
    if the device should be skipped altogether.

--*/
{
    PAGP_TARGET_BUS_INTERFACE_STANDARD targetInterface = (PAGP_TARGET_BUS_INTERFACE_STANDARD)InterfaceReturn;
    PPCI_PDO_EXTENSION extension = (PPCI_PDO_EXTENSION)DeviceExtension;
    PPCI_PDO_EXTENSION current;
    PPCI_PDO_EXTENSION targetExtension = NULL;
    PPCI_FDO_EXTENSION parentExtension;

    if ((extension->BaseClass != PCI_CLASS_BRIDGE_DEV) ||
        (extension->SubClass != PCI_SUBCLASS_BR_PCI_TO_PCI)) {
        
        //
        // This interface is only supported on AGP bridges,
        // which are PCI-PCI bridges.
        //
        return STATUS_NOT_SUPPORTED;
    }

    if (extension->TargetAgpCapabilityId == PCI_CAPABILITY_ID_AGP_TARGET) {
        
        //
        // The bridge has a target AGP capability itself.  Give the
        // caller access to its config space.
        //
        targetExtension = extension;
    
    } else {

        //
        // No target AGP capability on the bridge itself.  Look on the same
        // bus as the bridge for host bridges with the AGP capability.
        //
        parentExtension = extension->ParentFdoExtension;

        if (!PCI_IS_ROOT_FDO(parentExtension)) {
                       
            //
            // Not likely to find host bridges on non-root busses.
            // Even if we could, constrain this interface to only support
            // root busses.
            //
            return STATUS_NOT_SUPPORTED;
        }

        ExAcquireFastMutex(&parentExtension->ChildListMutex);
        for (current = parentExtension->ChildPdoList; current != NULL; current = current->Next) {
        
            if ((current->BaseClass == PCI_CLASS_BRIDGE_DEV) &&
                (current->SubClass == PCI_SUBCLASS_BR_HOST) &&
                (current->TargetAgpCapabilityId != 0)) {
                
                //
                // We have a host bridge with a target AGP capability.  Check to make
                // sure that there's only one such host bridge.  If there are multiple,
                // we don't know which to grant access to, so fail the call.
                //
                if (targetExtension != NULL) {
                    ExReleaseFastMutex(&parentExtension->ChildListMutex);
                    return STATUS_NOT_SUPPORTED;
                }

                targetExtension = current;
            }
        }
        ExReleaseFastMutex(&parentExtension->ChildListMutex);

        if (targetExtension == NULL) {
            return STATUS_NO_SUCH_DEVICE;
        }
    }

    PCI_ASSERT(targetExtension != NULL);

    targetInterface->Size = sizeof( AGP_TARGET_BUS_INTERFACE_STANDARD );
    targetInterface->Version = AGPINTRF_VERSION;
    targetInterface->Context = targetExtension;
    targetInterface->InterfaceReference = agpintrf_Reference;
    targetInterface->InterfaceDereference = agpintrf_Dereference;

    targetInterface->CapabilityID = targetExtension->TargetAgpCapabilityId;
    targetInterface->SetBusData = PciWriteAgpConfig;
    targetInterface->GetBusData = PciReadAgpConfig;

    return STATUS_SUCCESS;
}

NTSTATUS
agpintrf_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    )

/*++

Routine Description:

    For bus interface, does nothing, shouldn't actually be called.

Arguments:

    Instance        Pointer to the PDO extension.

Return Value:

    Returns the status of this operation.

--*/

{
        
    PCI_ASSERTMSG("PCI agpintrf_Initializer, unexpected call.", 0);

    return STATUS_UNSUCCESSFUL;
}


ULONG
PciReadAgpConfig(
    IN PVOID Context,
    IN ULONG WhichSpace,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    This function reads the PCI configuration space.

Arguments:

    Context - Supplies a pointer to the interface context.  This is actually
        the PDO for the root bus.

    Buffer - Supplies a pointer to where the data should be placed.

    Offset - Indicates the offset into the data where the reading should begin.

    Length - Indicates the count of bytes which should be read.

Return Value:

    Returns the number of bytes read.

--*/
{
    PPCI_PDO_EXTENSION pdoExtension = (PPCI_PDO_EXTENSION)Context;
    ULONG lengthRead;

    ASSERT_PCI_PDO_EXTENSION(pdoExtension);

    PciReadDeviceSpace(pdoExtension,
                      WhichSpace,
                      Buffer,
                      Offset,
                      Length,
                      &lengthRead
                      );
    
    return lengthRead;
}

ULONG
PciWriteAgpConfig(
    IN PVOID Context,
    IN ULONG WhichSpace,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    This function writes the PCI configuration space.

Arguments:

    Context - Supplies a pointer  to the interface context.  This is actually
        the PDO for the root bus.

    Buffer - Supplies a pointer to where the data to be written is.

    Offset - Indicates the offset into the data where the writing should begin.

    Length - Indicates the count of bytes which should be written.

Return Value:

    Returns the number of bytes read.

--*/
{
    PPCI_PDO_EXTENSION pdoExtension = (PPCI_PDO_EXTENSION)Context;
    ULONG lengthWritten;

    ASSERT_PCI_PDO_EXTENSION(pdoExtension);

    PciWriteDeviceSpace(pdoExtension,
                        WhichSpace,
                        Buffer,
                        Offset,
                        Length,
                        &lengthWritten
                        );
    
    return lengthWritten;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\arb_comn.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    arb_comn.c

Abstract:

    This module contains arbitration generic "utility" routines
    for the PCI driver.

Author:

    Peter Johnston (peterj)     1-Apr-1997
    Andrew Thornton (andrewth)  15-May-1997


Revision History:

--*/

#include "pcip.h"

#define PCI_CONTEXT_TO_INSTANCE(context) \
    CONTAINING_RECORD(context, PCI_ARBITER_INSTANCE, CommonInstance)

//
// Plain text (short) description of each arbiter type.
// (For debug).
//
// N.B. Order corresponds to PCI Signature enumeration.
//

PUCHAR PciArbiterNames[] = {
    "I/O Port",
    "Memory",
    "Interrupt",
    "Bus Number"
};
VOID
PciArbiterDestructor(
    IN PVOID Extension
    )

/*++

Routine Description:

    This routine is called when a PCI Secondary Extension that
    contains an arbiter instance is being torn down.   Its function
    is to do any arbiter specific teardown.

Arguments:

    Extension   Address of PCI secondary extension containing
                the arbiter.

Return Value:

    None.

--*/

{
    PPCI_ARBITER_INSTANCE instance;
    PARBITER_INSTANCE arbiter;
    PARBITER_MEMORY_EXTENSION extension;

    instance = (PPCI_ARBITER_INSTANCE)Extension;
    arbiter = &instance->CommonInstance;

    PCI_ASSERT(!arbiter->ReferenceCount);
    PCI_ASSERT(!arbiter->TransactionInProgress);

    //
    // NTRAID #54671 - 04/03/2000 - andrewth
    // This is rather gross but it fixes the leak from the memory
    // arbiter.  
    //

    if (arbiter->ResourceType == CmResourceTypeMemory) {

        extension = arbiter->Extension;

        PCI_ASSERT(extension);

        ArbFreeOrderingList(&extension->PrefetchableOrdering);
        ArbFreeOrderingList(&extension->NonprefetchableOrdering);
        ArbFreeOrderingList(&extension->OriginalOrdering);

        //
        // Arbiter->OrderingList is one of the above three lists we just freed -
        // don't free it again
        //

        RtlZeroMemory(&arbiter->OrderingList, sizeof(ARBITER_ORDERING_LIST));
    }

    ArbDeleteArbiterInstance(arbiter);
}

NTSTATUS
PciArbiterInitializeInterface(
    IN  PVOID DeviceExtension,
    IN  PCI_SIGNATURE DesiredInterface,
    IN OUT PARBITER_INTERFACE ArbiterInterface
    )
{
    PPCI_ARBITER_INSTANCE instance;
    PPCI_FDO_EXTENSION fdoExtension = (PPCI_FDO_EXTENSION)DeviceExtension;

    //
    // Find the arbiter instance (context) for this resource type
    // on this FDO.
    //

    instance = PciFindSecondaryExtension(fdoExtension, DesiredInterface);
    if (instance == NULL) {

#if DBG

        //
        // Check if this bridge is doing subtractive decoding in
        // which case there will be no arbiter for IO or Memory.
        //
        // N.B. Only relevant to debug, either way the call will
        // fail but we don't want to actually assert if this is
        // the case.
        //

        if (!PCI_IS_ROOT_FDO(fdoExtension)) {

            PPCI_PDO_EXTENSION pdoExtension = (PPCI_PDO_EXTENSION)
                fdoExtension->PhysicalDeviceObject->DeviceExtension;

            ASSERT_PCI_PDO_EXTENSION(pdoExtension);

            if (pdoExtension->Dependent.type1.SubtractiveDecode) {

                //
                // Subtractive, no arbiters.
                //

                return STATUS_INVALID_PARAMETER_2;
            }

        }

        PCI_ASSERTMSG("couldn't locate arbiter for resource.", instance);

#endif
        return STATUS_INVALID_PARAMETER_5;
    }

    //
    // Fill in the rest of the caller's arbiter interface structure.
    //

    ArbiterInterface->Context = &instance->CommonInstance;

    PciDebugPrint(
        PciDbgObnoxious,
        "PCI - %S Arbiter Interface Initialized.\n",
        instance->CommonInstance.Name
        );

    return STATUS_SUCCESS;
}

NTSTATUS
PciInitializeArbiters(
    IN  PVOID DeviceExtension
    )
{
    NTSTATUS status;
    PPCI_INTERFACE *interfaceEntry;
    PCI_SIGNATURE arbiterType;
    PPCI_ARBITER_INSTANCE instance;
    PPCI_FDO_EXTENSION fdoExtension = (PPCI_FDO_EXTENSION)DeviceExtension;
    BOOLEAN ok; 

    ASSERT_PCI_FDO_EXTENSION(fdoExtension);

    //
    // For each resource type for which we do arbitration, initialize
    // a context.
    //

    for (arbiterType =  PciArb_Io;
         arbiterType <= PciArb_BusNumber;
         arbiterType++) {

        //
        // If this bridge provides this resource via subtractive
        // decode, get the system to fall thru to the parent
        // arbiter by not creating an arbiter at this level.
        //

        if (!PCI_IS_ROOT_FDO(fdoExtension)) {

            PPCI_PDO_EXTENSION pdoExtension = (PPCI_PDO_EXTENSION)
                fdoExtension->PhysicalDeviceObject->DeviceExtension;

            ASSERT_PCI_PDO_EXTENSION(pdoExtension);

            if (pdoExtension->Dependent.type1.SubtractiveDecode) {

                //
                // Skip creation of this arbiter.
                //

                PciDebugPrint(
                    PciDbgVerbose,
                    "PCI Not creating arbiters for subtractive bus %d\n",
                    pdoExtension->Dependent.type1.SecondaryBus
                    );

                continue;
            }
        }

        //
        // Find this entry in the interface table (if not found, skip
        // it).
        //

        for (interfaceEntry = PciInterfaces;
             *interfaceEntry;
             interfaceEntry++) {

            if ((*interfaceEntry)->Signature == arbiterType) {
                break;
            }
        }

        if (*interfaceEntry == NULL) {

            //
            // Did not find an interface entry.  This means we don't
            // actually implement this arbiter type.
            //

            PciDebugPrint(
                PciDbgObnoxious,
                "PCI - FDO ext 0x%08x no %s arbiter.\n",
                DeviceExtension,
                PciArbiterNames[arbiterType - PciArb_Io]
                );

            continue;
        }

        instance = ExAllocatePool(
                       PagedPool | POOL_COLD_ALLOCATION,
                       sizeof(PCI_ARBITER_INSTANCE)
                       );

        if (instance == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Initialize PCI specific fields
        //

        instance->BusFdoExtension = fdoExtension;
        instance->Interface = *interfaceEntry;

        ok = SUCCEEDED(StringCbPrintfW(instance->InstanceName,
                                       sizeof(instance->InstanceName),
                                       L"PCI %S (b=%02x)",
                                       PciArbiterNames[arbiterType - PciArb_Io],
                                       fdoExtension->BaseBus
                                       ));

        ASSERT(ok);

        //
        // Allow this arbiter to do any of it's own first time
        // initialization.
        //

        status = (*interfaceEntry)->Initializer(instance);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        //
        // Push this arbiter onto the FDO's list of extensions.
        //

        PciLinkSecondaryExtension(fdoExtension,
                                  instance,
                                  arbiterType,
                                  PciArbiterDestructor);

        PciDebugPrint(
            PciDbgObnoxious,
            "PCI - FDO ext 0x%08x %S arbiter initialized (context 0x%08x).\n",
            DeviceExtension,
            instance->CommonInstance.Name,
            instance
            );
    }
    return STATUS_SUCCESS;
}

NTSTATUS
PciInitializeArbiterRanges(
    IN PPCI_FDO_EXTENSION FdoExtension,
    IN PCM_RESOURCE_LIST ResourceList
    )
{
    NTSTATUS status;
    PCI_SIGNATURE arbiterType;
    CM_RESOURCE_TYPE resourceType;
    PPCI_ARBITER_INSTANCE instance;

    //
    // NTRAID #95564 - 04/03/2000 - andrewth
    // This routine needs to be reworked, in the case where
    // this FDO is processing a second or subsequent START_DEVICE
    // IRP, the arbiter's ranges may need to be adjusted according
    // to the incoming resource list.    Until this is done, avoid
    // causing problems by processing it again.
    //

    if (FdoExtension->ArbitersInitialized) {
        PciDebugPrint(
            PciDbgInformative,
            "PCI Warning hot start FDOx %08x, resource ranges not checked.\n",
            FdoExtension
            );
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Check if this bridge is doing subtractive decoding in
    // which case there will be no arbiters
    //

    if (!PCI_IS_ROOT_FDO(FdoExtension)) {
        PPCI_PDO_EXTENSION pdoExtension;

        pdoExtension = (PPCI_PDO_EXTENSION)
            FdoExtension->PhysicalDeviceObject->DeviceExtension;

        ASSERT_PCI_PDO_EXTENSION(pdoExtension);

        if (pdoExtension->Dependent.type1.SubtractiveDecode) {

            //
            // Subtractive decode no arbiters.
            //
            PciDebugPrint(
                PciDbgInformative,
                "PCI Skipping arbiter initialization for subtractive bridge FDOX %p\n",
                FdoExtension
                );

            return STATUS_SUCCESS;
        }
    }


    //
    // For each resource type for which we do arbitration, initialize
    // a context.
    //

    for (arbiterType =  PciArb_Io;
         arbiterType <= PciArb_Memory;
         arbiterType++) {

        //
        // Currently this is only supported for Memory and IO.
        //

        switch (arbiterType) {

            //
            // Go ahead and process these ones.
            //

        case PciArb_Io:
            resourceType = CmResourceTypePort;
            break;

        case PciArb_Memory:
            resourceType = CmResourceTypeMemory;
            break;

        default:

            //
            // Skip anything else.
            //

            continue;
        }

        //
        // Find this arbiter instance.
        //

        instance = PciFindSecondaryExtension(FdoExtension, arbiterType);
        if (instance == NULL) {

            //
            // Did not find an interface entry.  This means we don't
            // actually implement this arbiter type.
            //

            PciDebugPrint(
                PciDbgAlways,
                "PCI - FDO ext 0x%08x %s arbiter (REQUIRED) is missing.\n",
                FdoExtension,
                PciArbiterNames[arbiterType - PciArb_Io]
                );

            continue;
        }

        //
        // The incoming ResourceList gives the ranges this bus supports.
        // Convert this to an inverted range so we can exclude everything
        // we don't cover.
        //

        status = PciRangeListFromResourceList(
                     FdoExtension,
                     ResourceList,
                     resourceType,
                     TRUE,
                     instance->CommonInstance.Allocation
                     );
        if (!NT_SUCCESS(status)) {

            //
            // Nothing we can do here.   Additional debug stuff was
            // in the lower level.  Skip this puppy.
            //

            continue;
        }

        //
        // NTRAID #95564 - 04/03/2000 - andrewth
        //
        // When ArbStartArbiter is complete it will replace
        // the call to PciRangeListFromResourceList.
        //

        PCI_ASSERT(instance->CommonInstance.StartArbiter);

        status = instance->CommonInstance.StartArbiter(&instance->CommonInstance,
                                                       ResourceList
                                                       );

        if (!NT_SUCCESS(status)) {

            //
            // Bail initializing this arbiter and fail the start.  The arbiters
            // will be cleaned up when we get the REMOVE_DEVICE
            //

            return status;
        }
    }

    FdoExtension->ArbitersInitialized = TRUE;
    return STATUS_SUCCESS;
}

VOID
PciReferenceArbiter(
    IN PVOID Context
    )
{
    PPCI_ARBITER_INSTANCE instance = PCI_CONTEXT_TO_INSTANCE(Context);
    InterlockedIncrement(&instance->CommonInstance.ReferenceCount);
}

VOID
PciDereferenceArbiter(
    IN PVOID Context
    )
{
    PPCI_ARBITER_INSTANCE instance = PCI_CONTEXT_TO_INSTANCE(Context);
    InterlockedDecrement(&instance->CommonInstance.ReferenceCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\tuples.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    tuples.c

Abstract:

    This module contains the code that parses and processes
    the configuration tuples of the PC Cards in the PCMCIA sockets

Author:

    Bob Rinne (BobRi) 3-Aug-1994
    Jeff McLeman 12-Apr-1994
    Ravisankar Pudipeddi (ravisp) 1-Nov-1996
    Neil Sandlin (neilsa) 1-Jun-1999

Revision History:

    Lotsa cleaning up. Support for PnP.
    orthogonalized tuple processing.
    Support links etc.

     - Ravisankar Pudipeddi (ravisp) 1-Dec-1996


Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

#define MAX_MISSED_TUPLES    256      // how many bad tuples will we tolerate?
#define MAX_TUPLE_DATA_LENGTH 128     // Enough for the longest tuple


BOOLEAN
CheckLinkTarget(
    IN PTUPLE_PACKET TuplePacket
    );

UCHAR
ConvertVoltage(
    UCHAR MantissaExponentByte,
    UCHAR ExtensionByte
    );

VOID
PcmciaProcessPower(
    IN PTUPLE_PACKET TuplePacket,
    UCHAR        FeatureByte
    );

VOID
PcmciaProcessIoSpace(
    IN PTUPLE_PACKET TuplePacket,
    PCONFIG_ENTRY ConfigEntry
    );

VOID
PcmciaProcessIrq(
    IN PTUPLE_PACKET TuplePacket,
    PCONFIG_ENTRY ConfigEntry
    );

VOID
PcmciaProcessTiming(
    IN PTUPLE_PACKET TuplePacket,
    IN PCONFIG_ENTRY ConfigEntry
    );

VOID
PcmciaProcessMemSpace(
    IN PTUPLE_PACKET TuplePacket,
    IN PCONFIG_ENTRY ConfigEntry,
    IN UCHAR          MemSpace
    );

VOID
PcmciaMiscFeatures(
    IN PTUPLE_PACKET TuplePacket
    );

PCONFIG_ENTRY
PcmciaProcessConfigTable(
    IN PTUPLE_PACKET TuplePacket
    );

VOID
ProcessConfig(
    IN PTUPLE_PACKET TuplePacket
    );

VOID
ProcessConfigCB(
    IN PTUPLE_PACKET TuplePacket
    );

NTSTATUS
InitializeTuplePacket(
    IN PTUPLE_PACKET TuplePacket
    );

NTSTATUS
GetFirstTuple(
    IN PTUPLE_PACKET TuplePacket
    );

BOOLEAN
TupleMatches(
    IN PTUPLE_PACKET TuplePacket
    );

NTSTATUS
GetNextTuple(
    IN PTUPLE_PACKET TuplePacket
    );

NTSTATUS
NextTupleInChain(
    IN PTUPLE_PACKET TuplePacket
    );

NTSTATUS
GetAnyTuple(
    IN PTUPLE_PACKET TuplePacket
    );

NTSTATUS
FollowLink(
    IN PTUPLE_PACKET TuplePacket
    );

NTSTATUS
NextLink(
    IN PTUPLE_PACKET TuplePacket
    );

NTSTATUS
GetTupleData(
    IN PTUPLE_PACKET TuplePacket
    );

UCHAR
GetTupleChar(
    IN PTUPLE_PACKET TuplePacket
    );

NTSTATUS
ProcessLinkTuple(
    IN PTUPLE_PACKET TuplePacket
    );

NTSTATUS
PcmciaMemoryCardHack(
    IN PSOCKET Socket,
    PSOCKET_DATA SocketData
    );

VOID
PcmciaCheckForRecognizedDevice(
    IN PSOCKET Socket,
    IN OUT PSOCKET_DATA SocketData
    );


//
// Some useful macros
//
// VOID
// PcmciaCopyIrqConfig(
//                       IN CONFIG_ENTRY DestConfig,
//                       IN CONFIG_ENTRY SourceConfig
//                       )
// Routine Description:
//    Copies the IRQ information from SourceConfig to DestConfig
//
// Arguments:
//
//   DestConfig - a pointer to the destination configuration entry
//   SourceConfig - a pointer to the source configuration entry
//
// Return Values:
//   None
//

#define PcmciaCopyIrqConfig(DestConfig, SourceConfig)                               \
                                {                                                                       \
                                    DestConfig->IrqMask = SourceConfig->IrqMask;        \
                                    DestConfig->LevelIrq = SourceConfig->LevelIrq;      \
                                    DestConfig->ShareDisposition =                          \
                                                            SourceConfig->ShareDisposition; \
                                }

//
// VOID
// PcmciaCopyIoConfig(
//                       IN CONFIG_ENTRY DestConfig,
//                       IN CONFIG_ENTRY SourceConfig
//                       )
// Routine Description:
//    Copies the Io space information from SourceConfig to DestConfig
//
// Arguments:
//
//   DestConfig - a pointer to the destination configuration entry
//   SourceConfig - a pointer to the source configuration entry
//
// Return Values:
//   None
//

#define PcmciaCopyIoConfig(DestConfig, SourceConfig)                                          \
                                {                                                                             \
                                    DestConfig->NumberOfIoPortRanges =                            \
                                             SourceConfig->NumberOfIoPortRanges;                  \
                                    DestConfig->Io16BitAccess =                                   \
                                             SourceConfig->Io16BitAccess;                         \
                                    DestConfig->Io8BitAccess =                                    \
                                             SourceConfig->Io8BitAccess;                              \
                                    RtlCopyMemory(DestConfig->IoPortBase,                         \
                                                      SourceConfig->IoPortBase,                   \
                                                      sizeof(SourceConfig->IoPortBase[0])*    \
                                                      SourceConfig->NumberOfIoPortRanges);    \
                                    RtlCopyMemory(DestConfig->IoPortLength,                   \
                                                      SourceConfig->IoPortLength,                 \
                                                      sizeof(SourceConfig->IoPortLength[0])*      \
                                                      SourceConfig->NumberOfIoPortRanges);    \
                                    RtlCopyMemory(DestConfig->IoPortAlignment,                \
                                                      SourceConfig->IoPortAlignment,              \
                                                      sizeof(SourceConfig->IoPortAlignment[0])* \
                                                      SourceConfig->NumberOfIoPortRanges);    \
                                }

//
// VOID
// PcmciaCopyMemConfig(
//                       IN CONFIG_ENTRY DestConfig,
//                       IN CONFIG_ENTRY SourceConfig
//                       )
// Routine Description:
//    Copies the Memory space information from SourceConfig to DestConfig
//
// Arguments:
//
//   DestConfig - a pointer to the destination configuration entry
//   SourceConfig - a pointer to the source configuration entry
//
// Return Values:
//   None
//

#define PcmciaCopyMemConfig(DestConfig,SourceConfig)                                         \
                                {                                                                            \
                                    DestConfig->NumberOfMemoryRanges =                           \
                                             SourceConfig->NumberOfMemoryRanges;                 \
                                    RtlCopyMemory(DestConfig->MemoryHostBase,                \
                                                      SourceConfig->MemoryHostBase,              \
                                                      sizeof(SourceConfig->MemoryHostBase[0])* \
                                                      SourceConfig->NumberOfMemoryRanges);   \
                                    RtlCopyMemory(DestConfig->MemoryCardBase,                \
                                                      SourceConfig->MemoryCardBase,              \
                                                      sizeof(SourceConfig->MemoryCardBase[0])* \
                                                      SourceConfig->NumberOfMemoryRanges);   \
                                    RtlCopyMemory(DestConfig->MemoryLength,                  \
                                                      SourceConfig->MemoryLength,                \
                                                      sizeof(SourceConfig->MemoryLength[0])*     \
                                                      SourceConfig->NumberOfMemoryRanges);   \
                                }




USHORT VoltageConversionTable[16] = {
    10, 12, 13, 15, 20, 25, 30, 35,
    40, 45, 50, 55, 60, 70, 80, 90
};

UCHAR TplList[] = {
    CISTPL_DEVICE,
    CISTPL_VERS_1,
    CISTPL_CONFIG,
    CISTPL_CFTABLE_ENTRY,
    CISTPL_MANFID,
    CISTPL_END
};

static unsigned short crc16a[] = {
    0000000,  0140301,  0140601,    0000500,
    0141401,  0001700,  0001200,    0141101,
    0143001,  0003300,  0003600,    0143501,
    0002400,  0142701,  0142201,    0002100,
};
static unsigned short crc16b[] = {
    0000000,  0146001,  0154001,    0012000,
    0170001,  0036000,  0024000,    0162001,
    0120001,  0066000,  0074000,    0132001,
    0050000,  0116001,  0104001,    0043000,
};




UCHAR
GetCISChar(
    IN PTUPLE_PACKET TuplePacket,
    IN ULONG Offset
    )
/*++

Routine Description:

    Returns the contents of the CIS memory of the PC-Card
    in the given socket, at the specified offset

Arguments:

    TuplePacket     - Pointer to the initialized tuple packet
    Offset          - Offset at which the CIS memory contents need to be read
                          This offset is added to the current offset position
                          of the CIS being read as indicated through the TuplePacket
                          to obtain the actual offset

Return Value:

    The byte at the specified offset of the CIS


--*/

{
    PPDO_EXTENSION pdoExtension = TuplePacket->SocketData->PdoExtension;
    MEMORY_SPACE MemorySpace;

    if (Is16BitCardInSocket(pdoExtension->Socket)) {
        if (TuplePacket->Flags & TPLF_COMMON) {

            MemorySpace = (TuplePacket->Flags & TPLF_INDIRECT) ?
                                    PCCARD_COMMON_MEMORY_INDIRECT :
                                    PCCARD_COMMON_MEMORY;

        } else {

            MemorySpace = (TuplePacket->Flags & TPLF_INDIRECT) ?
                                    PCCARD_ATTRIBUTE_MEMORY_INDIRECT :
                                    PCCARD_ATTRIBUTE_MEMORY;

        }
    } else {
        switch((TuplePacket->Flags & TPLF_ASI) >> TPLF_ASI_SHIFT) {
        case 0:
            MemorySpace = PCCARD_PCI_CONFIGURATION_SPACE;
            break;
        case 1:
            MemorySpace = PCCARD_CARDBUS_BAR0;
            break;
        case 2:
            MemorySpace = PCCARD_CARDBUS_BAR1;
            break;
        case 3:
            MemorySpace = PCCARD_CARDBUS_BAR2;
            break;
        case 4:
            MemorySpace = PCCARD_CARDBUS_BAR3;
            break;
        case 5:
            MemorySpace = PCCARD_CARDBUS_BAR4;
            break;
        case 6:
            MemorySpace = PCCARD_CARDBUS_BAR5;
            break;
        case 7:
            MemorySpace = PCCARD_CARDBUS_ROM;
            break;
        }
    }

    return PcmciaReadCISChar(pdoExtension, MemorySpace, TuplePacket->CISOffset + Offset);
}



UCHAR
ConvertVoltage(
    UCHAR MantissaExponentByte,
    UCHAR ExtensionByte
    )

/*++

Routine Description:

    Convert the voltage requirements for the PCCARD based on the
    mantissa and extension byte.

Arguments:

    MantissaExponentByte
    ExtensionByte

Return Value:

    The voltage specified in tenths of a volt.

--*/

{
    SHORT power;
    USHORT value;

    value = (USHORT) VoltageConversionTable[(MantissaExponentByte >> 3) & 0x0f];
    power = 1;

    if ((MantissaExponentByte & EXTENSION_BYTE_FOLLOWS) &&
         (((value / 10) * 10) == value) &&
         (ExtensionByte < 100)) {
        value = (10 * value + (ExtensionByte & 0x7f));
        power += 1;
    }

    power = (MantissaExponentByte & 0x07) - 4 - power;

    while (power > 0) {
        value *= 10;
        power--;
    }

    while (power < 0) {
        value /= 10;
        power++;
    }

    return (UCHAR) value;
}


VOID
PcmciaProcessPower(
    IN PTUPLE_PACKET TuplePacket,
    UCHAR        FeatureByte
    )

/*++

Routine Description:

    Process power information from CIS.

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet
    FeatureByte - the feature byte from the tuple containing power information.

Return Value:

    none

--*/

{
    PSOCKET_DATA SocketData = TuplePacket->SocketData;
    UCHAR  powerSelect;
    UCHAR  bit;
    UCHAR  item;
    UCHAR  rawItem;
    UCHAR  extensionByte;
    UCHAR  index = 0;
    UCHAR  count = FeatureByte;
    UCHAR  skipByte;

    ASSERT(count <= 3);

    while (index < count) {
        powerSelect = GetTupleChar(TuplePacket);
        for (bit = 0; bit < 7; bit++) {
            if (powerSelect & (1 << bit)) {

                rawItem = GetTupleChar(TuplePacket);
                if (rawItem & EXTENSION_BYTE_FOLLOWS) {
                    extensionByte = GetTupleChar(TuplePacket);

                    //
                    // Skip the rest
                    //
                    skipByte = extensionByte;
                    while (skipByte & EXTENSION_BYTE_FOLLOWS) {
                        skipByte = GetTupleChar(TuplePacket);
                    }
                } else {
                    extensionByte = (UCHAR) 0;
                }

                if (bit == 0) {

                    //
                    // Convert nominal power for output.
                    //

                    item = ConvertVoltage(rawItem, extensionByte);
                    switch (index) {
                    case 0:
                        SocketData->Vcc = item;
                        break;
                    case 1:
                        SocketData->Vpp2 = SocketData->Vpp1 = item;
                        break;
                    case 2:
                        SocketData->Vpp2 = item;
                        break;
                    }
                }
            }
        }
        index++;
    }
}


VOID
PcmciaProcessIoSpace(
    IN PTUPLE_PACKET TuplePacket,
    PCONFIG_ENTRY ConfigEntry
    )

/*++

Routine Description:

    Process I/O space information from CIS.

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet
    ConfigEntry - a config entry structure in which to store the information.

Return Value:

    none

--*/

{
    ULONG  address = 0;
    ULONG  index=0, i;
    UCHAR  item = GetTupleChar(TuplePacket);
    UCHAR  ioAddrLines = (item & IO_ADDRESS_LINES_MASK);
    UCHAR  ranges=0;
    UCHAR  addressSize=0;
    UCHAR  lengthSize=0;

    ConfigEntry->Io16BitAccess = Is16BitAccess(item);
    ConfigEntry->Io8BitAccess   = Is8BitAccess(item);

    ranges = HasRanges(item);

    if ((!ranges) && (!ioAddrLines)) {

        //
        // The IBM token ring card has a slightly different interpretation
        // of the tuple data here.  It isn't clear it is incorrect.
        //

        ranges = 0xFF;
    }

    if (ranges) {
        //
        // Specific ranges listed in the tuple.
        //
        if (ranges == 0xFF) {
            //
            // Special processing for IBM token ring IoSpace layout.
            //

            addressSize = 2;
            lengthSize = 1;
            ranges = 1;
        } else {
            item = GetTupleChar(TuplePacket);
            ranges = item & RANGE_MASK;
            ranges++;

            addressSize = GetAddressSize(item);
            lengthSize  = GetLengthSize(item);
        }
        index = 0;
        while (ranges) {
            address = 0;
            if (addressSize >= 1) {
                address = (ULONG) GetTupleChar(TuplePacket);
            }
            if (addressSize >= 2) {
                address |= (GetTupleChar(TuplePacket)) << 8;
            }
            if (addressSize >= 3) {
                address |= (GetTupleChar(TuplePacket)) << 16;
                address |= (GetTupleChar(TuplePacket)) << 24;
            }
            ConfigEntry->IoPortBase[index] = (USHORT) address;

            address = 0;
            if (lengthSize >= 1) {
                address = (ULONG) GetTupleChar(TuplePacket);
            }
            if (lengthSize >= 2) {
                address |= (GetTupleChar(TuplePacket)) << 8;
            }
            if (lengthSize >= 3) {
                address |= (GetTupleChar(TuplePacket)) << 16;
                address |= (GetTupleChar(TuplePacket)) << 24;
            }
            ConfigEntry->IoPortLength[index] = (USHORT) address;
            ConfigEntry->IoPortAlignment[index] = 1;

            index++;

            if (index == MAX_NUMBER_OF_IO_RANGES) {
                break;
            }
            ranges--;
        }
        ConfigEntry->NumberOfIoPortRanges = (USHORT) index;
    }

    //
    // Handle all combinations as specified in table on p. 80
    // (Basic compatibility Layer 1, i/o space encoding guidelines) of
    // PC Card standard Metaformat Specification, March 1997 (PCMCIA/JEIDA)
    //

    if (ioAddrLines) {
        //
        // A modulo base specified
        //
        if (addressSize == 0) {

            //
            // No I/O Base address specified
            //
            if (lengthSize == 0) {
                //
                // No ranges specified. This is a pure modulo base case
                //
                ConfigEntry->NumberOfIoPortRanges = 1;
                ConfigEntry->IoPortBase[0] = 0;
                ConfigEntry->IoPortLength[0] = (1 << ioAddrLines)-1;
                ConfigEntry->IoPortAlignment[0] = (1 << ioAddrLines);
            } else {
                //
                // Length specified. Modulo base is used only to specify alignment.
                //
                for (i=0; i < ConfigEntry->NumberOfIoPortRanges; i++) {
                    ConfigEntry->IoPortBase[i] = 0;
                    ConfigEntry->IoPortAlignment[i] = (1 << ioAddrLines);
                }
            }
        } else {
            //
            // Alignment specified..
            // This fix is for Xircom CE3 card
            //
            for (i=0; i < ConfigEntry->NumberOfIoPortRanges; i++) {
                if (ConfigEntry->IoPortBase[i] != 0) {
                    //
                    // Fixed base address supplied....
                    // Don't specify alignment!
                    //
                    continue;
                }
                ConfigEntry->IoPortAlignment[i] = (1 << ioAddrLines);
            }
        }
    } else {
        //
        // No Modulo Base. So specific ranges should've been specified
        //
        if (lengthSize == 0) {
            //
            //   Error! Length HAS to be specified
            //
            DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaProcessIoSpace: Length not specified in TPCE_IO descriptor for PC Card\n"));
        } else if (addressSize == 0) {
            for (i = 0; i < ConfigEntry->NumberOfIoPortRanges; i++) {
                ConfigEntry->IoPortBase[i]  = 0x0;
                ConfigEntry->IoPortAlignment[i] = 2;
            }
        } else {
            //
            // Proper ranges specified
            // Don't change anything
        }
    }
}


VOID
PcmciaProcessIrq(
    IN PTUPLE_PACKET TuplePacket,
    PCONFIG_ENTRY ConfigEntry
    )

/*++

Routine Description:

    Process IRQ from CIS.

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet
    ConfigEntry - a place to store the IRQ.

Return Value:

    none

--*/

{
    USHORT mask;
    UCHAR  level = GetTupleChar(TuplePacket);

    if (!level) {

        //
        // NOTE: It looks like Future Domain messed up on this
        // and puts an extra zero byte into the structure.
        // skip it for now.
        //

        level = GetTupleChar(TuplePacket);
    }

    if (level & 0x20) {
        ConfigEntry->LevelIrq = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
    } else {
        ConfigEntry->LevelIrq = CM_RESOURCE_INTERRUPT_LATCHED;
    }

    if (level & 0x80) {
        ConfigEntry->ShareDisposition = CmResourceShareShared;
    } else {
        ConfigEntry->ShareDisposition = CmResourceShareDeviceExclusive;
    }

    mask = level & 0x10;

    //
    // 3COM 3C589-75D5 has a peculiar problem
    // where mask bit is 0, but should have been 1.
    // Handle this case here
    //

    if ((mask==0) && ((level & 0xf) == 0)) {
        mask = 1;
    }

    if (mask) {
        //
        // Each bit set in the mask indicates the corresponding IRQ
        // (from 0-15) may be assigned to this card's interrupt req. pin
        //
        mask = (USHORT) GetTupleChar(TuplePacket);
        mask |= ((USHORT) GetTupleChar(TuplePacket)) << 8;
        ConfigEntry->IrqMask = mask;
    } else {
        ConfigEntry->IrqMask = 1 << (level & 0x0f);
    }
}


VOID
PcmciaProcessTiming(
    IN PTUPLE_PACKET TuplePacket,
    IN PCONFIG_ENTRY ConfigEntry
    )

/*++

Routine Description:

    Move the data pointer around the timing information structure.
    No processing of this data occurs at this time.

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet
    ConfigEntry - currently unused.

Return Value:

    none

--*/

{
    UCHAR  item = GetTupleChar(TuplePacket);
    UCHAR  reservedScale = (item & 0xe0) >> 5;
    UCHAR  readyBusyScale = (item & 0x1c) >> 2;
    UCHAR  waitScale = (item & 0x03);

    //
    // NOTE: It looks like the processing of extension bytes is not
    // coded correctly in this routine.
    //

    if (waitScale != 3) {
        item = GetTupleChar(TuplePacket);
        while (item & EXTENSION_BYTE_FOLLOWS) {
            item = GetTupleChar(TuplePacket);
        }
    }

    if (readyBusyScale != 7) {
        item = GetTupleChar(TuplePacket);
        while (item & EXTENSION_BYTE_FOLLOWS) {
            item = GetTupleChar(TuplePacket);
        }
    }

    if (reservedScale != 7) {
        item = GetTupleChar(TuplePacket);
        while (item & EXTENSION_BYTE_FOLLOWS) {
            item = GetTupleChar(TuplePacket);
        }
    }
}


VOID
PcmciaProcessMemSpace(
    IN PTUPLE_PACKET TuplePacket,
    IN PCONFIG_ENTRY ConfigEntry,
    IN UCHAR          MemSpace
    )

/*++

Routine Description:

    Process memory space requirements from CIS.

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet
    ConfigEntry - the socket configuration structure.
    MemSpace    - the memory space enumerator from the config table entry
                       structure.

Return Value:

    none

--*/

{
    ULONG  longValue;
    ULONG  index;
    UCHAR  lengthSize;
    UCHAR  addrSize;
    UCHAR  number;
    UCHAR  hasHostAddress;

    switch (MemSpace) {

    case 1: {
            //
            // Only length is specified
            //
            longValue = (ULONG) GetTupleChar(TuplePacket);
            longValue |= ((ULONG) GetTupleChar(TuplePacket)) << 8;
            ConfigEntry->MemoryLength[0] = longValue * 256;

            ConfigEntry->NumberOfMemoryRanges++;
            break;
        }

    case 2: {

            longValue = (ULONG) GetTupleChar(TuplePacket);
            longValue |= ((ULONG) GetTupleChar(TuplePacket)) << 8;
            ConfigEntry->MemoryLength[0] = longValue * 256;

            longValue = (ULONG) GetTupleChar(TuplePacket);
            longValue |= ((ULONG) GetTupleChar(TuplePacket)) << 8;
            ConfigEntry->MemoryCardBase[0] =
            ConfigEntry->MemoryHostBase[0] = longValue * 256;

            ConfigEntry->NumberOfMemoryRanges++;
            break;
        }

    case 3: {
            UCHAR  item  = GetTupleChar(TuplePacket);
            lengthSize = (item & 0x18) >> 3;
            addrSize   = (item & 0x60) >> 5;
            number    = (item & 0x07) + 1;
            hasHostAddress = item & 0x80;

            if (number > MAX_NUMBER_OF_MEMORY_RANGES) {
                number = MAX_NUMBER_OF_MEMORY_RANGES;
            }

            for (index = 0; index < (ULONG) number; index++) {
                longValue = 0;
                if (lengthSize >= 1) {
                    longValue = (ULONG) GetTupleChar(TuplePacket);
                }
                if (lengthSize >= 2) {
                    longValue |= (GetTupleChar(TuplePacket)) << 8;
                }
                if (lengthSize == 3) {
                    longValue |= (GetTupleChar(TuplePacket)) << 16;
                }
                ConfigEntry->MemoryLength[index] = longValue * 256;

                longValue = 0;
                if (addrSize >= 1) {
                    longValue = (ULONG) GetTupleChar(TuplePacket);
                }
                if (addrSize >= 2) {
                    longValue |= (GetTupleChar(TuplePacket)) << 8;
                }
                if (addrSize == 3) {
                    longValue |= (GetTupleChar(TuplePacket)) << 16;
                }
                ConfigEntry->MemoryCardBase[index] = longValue * 256;

                if (hasHostAddress) {
                    longValue = 0;
                    if (addrSize >= 1) {
                        longValue = (ULONG) GetTupleChar(TuplePacket);
                    }
                    if (addrSize >= 2) {
                        longValue |= (GetTupleChar(TuplePacket)) << 8;
                    }
                    if (addrSize == 3) {
                        longValue |= (GetTupleChar(TuplePacket)) << 16;
                    }
                    ConfigEntry->MemoryHostBase[index] = longValue * 256;
                }
            }
            ConfigEntry->NumberOfMemoryRanges = (USHORT) number;
            break;
        }
    }
}


PCONFIG_ENTRY
PcmciaProcessConfigTable(
    IN PTUPLE_PACKET TuplePacket
    )

/*++

Routine Description:

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

    A pointer to a config entry structure if one is created.

--*/

{
    PSOCKET_DATA SocketData = TuplePacket->SocketData;
    PCONFIG_ENTRY configEntry;
    UCHAR         item;
    UCHAR         defaultBit;
    UCHAR         memSpace;
    UCHAR         power;
    UCHAR         misc;

    configEntry = ExAllocatePool(NonPagedPool, sizeof(CONFIG_ENTRY));
    if (!configEntry) {
        return NULL;
    }
    RtlZeroMemory(configEntry, sizeof(CONFIG_ENTRY));

    item = GetTupleChar(TuplePacket);
    defaultBit = Default(item);
    configEntry->IndexForThisConfiguration = ConfigEntryNumber(item);

    if (IntFace(item)) {

        //
        // This byte indicates type of interface in tuple (i.e. io or memory)
        // This could be processed, but for now is just skipped.
        //

        item = GetTupleChar(TuplePacket);
    }

    item = GetTupleChar(TuplePacket);
    memSpace = MemSpaceInformation(item);
    power   = PowerInformation(item);
    misc        = MiscInformation(item);

    if (power) {
        PcmciaProcessPower(TuplePacket, power);
    }

    if (TimingInformation(item)) {
        PcmciaProcessTiming(TuplePacket, configEntry);
    }

    if (IoSpaceInformation(item)) {
        PcmciaProcessIoSpace(TuplePacket, configEntry);
    } else if (!defaultBit && (SocketData->DefaultConfiguration != NULL)) {
        PcmciaCopyIoConfig(configEntry, SocketData->DefaultConfiguration);
    }

    if (IRQInformation(item)) {
        PcmciaProcessIrq(TuplePacket, configEntry);
    } else if (!defaultBit && (SocketData->DefaultConfiguration != NULL)) {
        PcmciaCopyIrqConfig(configEntry,SocketData->DefaultConfiguration);
    }

    if (memSpace) {
        PcmciaProcessMemSpace(TuplePacket, configEntry, memSpace);
    } else if (!defaultBit && (SocketData->DefaultConfiguration != NULL)) {
        PcmciaCopyMemConfig(configEntry,SocketData->DefaultConfiguration);
    }

    if (misc) {
        PcmciaMiscFeatures(TuplePacket);
    } // need default bit processing here too

    if (defaultBit) {
        //
        // Save this config as the default config for this pc-card (which
        // may be accessed by subsequent tuples)
        //
        SocketData->DefaultConfiguration = configEntry;
    }
    //
    // One more configuration
    //
    SocketData->NumberOfConfigEntries++;

    DebugPrint((PCMCIA_DEBUG_TUPLES,
                                    "config entry %08x idx %x ccr %x\n",
                                    configEntry,
                                    configEntry->IndexForThisConfiguration,
                                    SocketData->ConfigRegisterBase
                                    ));
    return configEntry;
}

VOID
PcmciaMiscFeatures(
    IN PTUPLE_PACKET TuplePacket
    )

/*++

Routine Description:

    Parse the miscellaneous features field and look for audio supported
    bit.

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

    none

--*/

{
    PSOCKET_DATA SocketData = TuplePacket->SocketData;
    UCHAR item = GetTupleChar(TuplePacket);

    DebugPrint((PCMCIA_DEBUG_TUPLES,
                    "TPCE_MS (%lx) is present in  CISTPL_CFTABLE_ENTRY \n",
                    item));

    //
    // If the audio bit is set, remember this in the socket information
    // structure.
    //

    if (item & 0x8) {

        DebugPrint((PCMCIA_DEBUG_TUPLES,
                        "Audio bit set in TPCE_MS \n"));
        SocketData->Audio = TRUE;
    }

    //
    //  Step around the miscellaneous features and its extension bytes.
    //

    while (item & EXTENSION_BYTE_FOLLOWS) {
        item = GetTupleChar(TuplePacket);
    }
}



VOID
ProcessConfig(
    IN PTUPLE_PACKET TuplePacket
    )

/*++

Routine Description:

    Parse the CISTPL_CONFIG to extract the last index value and the
    configuration register base for the PCCARD.

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

    None

--*/

{
    PSOCKET_DATA SocketData = TuplePacket->SocketData;
    PUCHAR TupleData = TuplePacket->TupleData;
    ULONG  base = 0;
    UCHAR  widthOfBaseAddress;
    UCHAR  widthOfRegPresentMask;
    UCHAR  widthOfReservedArea;
    UCHAR  widthOfInterfaceId;
    UCHAR  index;
    UCHAR  subtupleCount = 0;
    ULONG  InterfaceId;

    widthOfBaseAddress = TpccRasz(TupleData[0]) + 1;
    widthOfRegPresentMask = TpccRmsz(TupleData[0]) + 1;
    widthOfReservedArea = TpccRfsz(TupleData[0]);

    ASSERT (widthOfReservedArea == 0);
    ASSERT (widthOfRegPresentMask <= 16);

    SocketData->LastEntryInCardConfig = TupleData[1];

    switch (widthOfBaseAddress) {
    case 4:
        base    = ((ULONG)TupleData[5] << 24);
    case 3:
        base |= ((ULONG)TupleData[4] << 16);
    case 2:
        base |= ((ULONG)TupleData[3] << 8);
    case 1:
        base |= TupleData[2];
        break;
    default:
        DebugPrint((PCMCIA_DEBUG_FAIL,
                        "ProcessConfig - bad number of bytes %d\n",
                        widthOfBaseAddress));
        break;
    }
    SocketData->ConfigRegisterBase = base;
    DebugPrint((PCMCIA_DEBUG_TUPLES,
                    "ConfigRegisterBase in attribute memory is 0x%x\n",
                    SocketData->ConfigRegisterBase));

    //
    // Copy the register presence mask
    //

    for (index = 0; index < widthOfRegPresentMask; index++) {
        SocketData->RegistersPresentMask[index] = TupleData[2 + widthOfBaseAddress + index];
    }

    DebugPrint((PCMCIA_DEBUG_TUPLES,
                    "First Byte in RegPresentMask=%x, width is %d\n",
                    SocketData->RegistersPresentMask[0], widthOfRegPresentMask));

    //
    // Look for subtuples
    //
    index = 2 + widthOfBaseAddress + widthOfRegPresentMask + widthOfReservedArea;

    while (((index+5) < TuplePacket->TupleDataMaxLength) &&
             (++subtupleCount <= 4) &&
             (TupleData[index] == CCST_CIF)) {

        widthOfInterfaceId = ((TupleData[index+2] & 0xC0) >> 6) + 1 ;

        InterfaceId = 0;

        switch (widthOfInterfaceId) {
        case 4:
            InterfaceId  = ((ULONG)TupleData[index+5] << 24);
        case 3:
            InterfaceId |= ((ULONG)TupleData[index+4] << 16);
        case 2:
            InterfaceId |= ((ULONG)TupleData[index+3] << 8);
        case 1:
            InterfaceId |= TupleData[index+2];
            break;
        default:
            DebugPrint((PCMCIA_DEBUG_FAIL,
                            "ProcessConfig - bad number of bytes %d in subtuple\n",
                            widthOfInterfaceId));
            break;
        }

        DebugPrint((PCMCIA_DEBUG_TUPLES, "Custom Interface ID %8x\n", InterfaceId));
        //
        // Currently don't have generic code for recording sub-tuple information,
        // all we look for is Zoom Video.
        //
        if (InterfaceId == 0x141) {
            SocketData->Flags |= SDF_ZV;
        }

        index += (TupleData[index+1] + 2);
    }
}


VOID
ProcessConfigCB(
    IN PTUPLE_PACKET TuplePacket
    )

/*++

Routine Description:

    Parse the CISTPL_CONFIG_CB to extract the last index value and the
    configuration register base for the PCCARD.

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

    None

--*/

{
    PSOCKET_DATA SocketData = TuplePacket->SocketData;
    PUCHAR TupleData = TuplePacket->TupleData;
    ULONG base = 0;
    UCHAR widthOfFields;

    widthOfFields = TupleData[0];

    if (widthOfFields != 3) {
        DebugPrint((PCMCIA_DEBUG_FAIL, "ProcessConfigCB - bad width of fields %d\n", widthOfFields));
        return;
    }

    SocketData->LastEntryInCardConfig = TupleData[1];

    base    = ((ULONG)TupleData[5] << 24);
    base |= ((ULONG)TupleData[4] << 16);
    base |= ((ULONG)TupleData[3] << 8);
    base |= TupleData[2];

    SocketData->ConfigRegisterBase = base;
    DebugPrint((PCMCIA_DEBUG_TUPLES, "ConfigRegisterBase = %08x\n", SocketData->ConfigRegisterBase));

}



VOID
PcmciaSubstituteUnderscore(
    IN OUT PUCHAR Str
    )
/*++
Routine description

    Substitutes underscores ('_' character) for invalid device id
    characters such as spaces & commas in the supplied string

Parameters

    Str - The string for which the substitution is to take place in situ

Return Value

    None

--*/

{
    if (Str == NULL) {
        return;
    }
    while (*Str) {
        if (*Str == ' ' ||
             *Str == ',' ) {
            *Str = '_';
        }
        Str++;
    }
}



/*-------------- Tuple API starts here ----------------------------------------*/

NTSTATUS
InitializeTuplePacket(
    IN PTUPLE_PACKET TuplePacket
    )

/*++

Routine Description:

        Initializes the supplied tuple packet

Arguments:

    TuplePacket - Pointer the caller supplied tuple packet

Return Value:

    Status

--*/
{
    TuplePacket->Flags = TPLF_IMPLIED_LINK;
    TuplePacket->LinkOffset = 0;
    TuplePacket->CISOffset   = 0;
    if (IsCardBusCardInSocket(TuplePacket->Socket)) {
        PPDO_EXTENSION pdoExtension = TuplePacket->SocketData->PdoExtension;

        GetPciConfigSpace(pdoExtension, CBCFG_CISPTR, &TuplePacket->CISOffset, sizeof(TuplePacket->CISOffset));
        DebugPrint((PCMCIA_DEBUG_TUPLES, "CardBus CISPTR = %08x\n", TuplePacket->CISOffset));

        TuplePacket->Flags = TPLF_COMMON | TPLF_IMPLIED_LINK;
        TuplePacket->Flags |= (TuplePacket->CISOffset & 7) << TPLF_ASI_SHIFT;
        TuplePacket->CISOffset &= 0x0ffffff8;
        TuplePacket->LinkOffset = TuplePacket->CISOffset;
    }
    return STATUS_SUCCESS;
}


NTSTATUS
GetFirstTuple(
    IN PTUPLE_PACKET TuplePacket
    )
/*++

Routine Description:

    Retrieves the very first tuple off the pc-card

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

    STATUS_SUCCESS if tuple was retrieved
    STATUS_NO_MORE_ENTRIES - if no tuples were found
                                     this is possible if this is a flash memory card

--*/
{

    NTSTATUS status;

    status=InitializeTuplePacket(TuplePacket);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    TuplePacket->TupleCode = GetCISChar(TuplePacket, 0);
    TuplePacket->TupleLink = GetCISChar(TuplePacket, 1);

    if (TuplePacket->TupleCode == CISTPL_LINKTARGET) {
        if ((status=FollowLink(TuplePacket)) == STATUS_NO_MORE_ENTRIES) {
            return status;
        }
    } else if (IsCardBusCardInSocket(TuplePacket->Socket)) {
        //
        // First tuple on Cardbus cards must be link target
        //
        return STATUS_NO_MORE_ENTRIES;
    }
    if (!NT_SUCCESS(status) || TupleMatches(TuplePacket)) {
        return status;
    }
    return GetNextTuple(TuplePacket);
}

BOOLEAN
TupleMatches(
    PTUPLE_PACKET TuplePacket
    )

/*++

Routine Description:

        Checks if the retrieved tuple matches   what
        the caller requested

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

    TRUE    - if the tuple matches
    FALSE - if not

--*/

{
    if (TuplePacket->TupleCode == TuplePacket->DesiredTuple) {
        return TRUE;
    }

    if (TuplePacket->DesiredTuple != 0xFF) {
        return FALSE;
    }

    //
    // Requested any tuple , but might not want link tuples
    //
    if (TuplePacket->Attributes & TPLA_RET_LINKS) {
        return TRUE;
    }
    return ((TuplePacket->TupleCode != CISTPL_LONGLINK_CB)       &&
            (TuplePacket->TupleCode != CISTPL_INDIRECT)            &&
            (TuplePacket->TupleCode != CISTPL_LONGLINK_MFC)        &&
            (TuplePacket->TupleCode != CISTPL_LONGLINK_A)          &&
            (TuplePacket->TupleCode != CISTPL_LONGLINK_C)          &&
            (TuplePacket->TupleCode != CISTPL_NO_LINK)  &&
            (TuplePacket->TupleCode != CISTPL_LINKTARGET));
}

NTSTATUS
GetNextTuple(
    IN PTUPLE_PACKET TuplePacket
    )
/*++

Routine Description:

    Retrieves the next unprocessed tuple that matches
    the caller requested tuple code off the pc-card

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

    STATUS_SUCCESS if tuple was retrieved
    STATUS_NO_MORE_ENTRIES - if no more tuples were found

--*/
{

    ULONG missCount;
    NTSTATUS status;

    for (missCount = 0; missCount < MAX_MISSED_TUPLES; missCount++) {
        if (((status = GetAnyTuple(TuplePacket)) != STATUS_SUCCESS) ||
             TupleMatches(TuplePacket)) {
            break;
        }
        status = STATUS_NO_MORE_ENTRIES;
    }
    return status;
}


NTSTATUS
NextTupleInChain(
    IN PTUPLE_PACKET TuplePacket
    )
/*++

Routine Description:

    Retrieves the immediately next unprocessed tuple on the pc-card

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

    status

--*/
{
    NTSTATUS status;
    ULONG   i;
    UCHAR link;

    status = STATUS_SUCCESS;
    switch (GetCISChar(TuplePacket, 0)) {
    case CISTPL_END:{
            status = STATUS_NO_MORE_ENTRIES;
            break;
        }
    case CISTPL_NULL: {
            for (i = 0; i < MAX_MISSED_TUPLES; i++) {
                TuplePacket->CISOffset++;
                if (GetCISChar(TuplePacket, 0) != CISTPL_NULL) {
                    break;
                }
            }
            if (i >= MAX_MISSED_TUPLES) {
                status = STATUS_DEVICE_NOT_READY;
            }
            break;
        }
    default: {
            link = GetCISChar(TuplePacket, 1);
            if (link == 0xFF) {
                status = STATUS_NO_MORE_ENTRIES;
            } else {
                TuplePacket->CISOffset += link+2;
            }
            break;
        }
    }
    return (status);
}


NTSTATUS
GetAnyTuple(
    IN PTUPLE_PACKET TuplePacket
    )

/*++

Routine Description:

    Retrieves the next tuple - regardless of tuple code-
    off the pc-card. If the end of chain is reached on the
    current tuple chain, any links are followed to obtain
    the next tuple.

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

    STATUS_SUCCESS if tuple was retrieved
    STATUS_NO_MORE_ENTRIES - if no tuples were found

--*/
{

    NTSTATUS status;

    if (!NT_SUCCESS((status = NextTupleInChain(TuplePacket)))) {
        /* End of this CIS. Follow a link if it exists */
        if (status == STATUS_DEVICE_NOT_READY) {
            return status;
        }
        if ((status = FollowLink(TuplePacket)) != STATUS_SUCCESS) {
            return status;
        }
    }
    TuplePacket->TupleCode = GetCISChar(TuplePacket, 0);
    TuplePacket->TupleLink = GetCISChar(TuplePacket, 1);
    return (ProcessLinkTuple(TuplePacket));
}



NTSTATUS
FollowLink(
    IN PTUPLE_PACKET TuplePacket
    )
/*++

Routine Description:

    Called when the end of tuple chain is encountered:
    this follows links, if any are present

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

    STATUS_SUCCESS if a link is present
    STATUS_NO_MORE_ENTRIES - if not

--*/
{
    if (NextLink(TuplePacket) == STATUS_SUCCESS) {
        return STATUS_SUCCESS;
    }

    // There is no implied or explicit link to follow.  If an indirect link
    // has been specified, indirect attribute memory is processed with an
    // implied link to common memory.

    if ((TuplePacket->Flags & TPLF_IND_LINK) && !(TuplePacket->Flags & TPLF_INDIRECT)) {

         // Link to indirect attribute memory at offset 0.

         TuplePacket->Flags &= ~(TPLF_COMMON | TPLF_IND_LINK | TPLF_LINK_MASK);
         TuplePacket->Flags |= TPLF_INDIRECT;
         TuplePacket->CISOffset = 0;

         if (CheckLinkTarget(TuplePacket)) {
              return STATUS_SUCCESS;
         }
         return(NextLink(TuplePacket));
    }
    return STATUS_NO_MORE_ENTRIES;
}


BOOLEAN
CheckLinkTarget(
    IN PTUPLE_PACKET TuplePacket
    )
/*++

Routine Description:

    Ensures that the target of a link has the signature
    'CIS' which indicates it is a valid target,
    as documented in the PC-Card standard

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

    STATUS_SUCCESS           if valid target
    STATUS_NO_MORE_ENTRIES - if not

--*/
{
    return (GetCISChar(TuplePacket, 0) == CISTPL_LINKTARGET &&
              GetCISChar(TuplePacket, 1) >= 3 &&
              GetCISChar(TuplePacket, 2) == 'C' &&
              GetCISChar(TuplePacket, 3) == 'I' &&
              GetCISChar(TuplePacket, 4) == 'S');

}


NTSTATUS
NextLink(
    IN PTUPLE_PACKET TuplePacket
    )
/*++

Routine Description:

    Fetches the next link off the pc-card tuple chain
    if any are present

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

    STATUS_SUCCESS if a link was present
    STATUS_NO_MORE_ENTRIES - if no links

--*/
{
    switch (TuplePacket->Flags & TPLF_LINK_MASK) {
    case TPLF_IMPLIED_LINK:
    case TPLF_LINK_TO_C:  {
            TuplePacket->Flags |= TPLF_COMMON;
            TuplePacket->CISOffset = TuplePacket->LinkOffset;
            break;
        }
    case TPLF_LINK_TO_A:{
            TuplePacket->Flags &= ~TPLF_COMMON;
            TuplePacket->CISOffset = TuplePacket->LinkOffset;
            break;
        }
    case TPLF_LINK_TO_CB: {
            //
            // Needs work! We have to switch to the appropriate
            // address space (BARs/Expansion Rom/Config space)
            // depending on the link offset
            //
            TuplePacket->Flags &= ~TPLF_ASI;
            TuplePacket->Flags |= (TuplePacket->LinkOffset & 7) << TPLF_ASI_SHIFT;
            TuplePacket->CISOffset = TuplePacket->LinkOffset & ~7 ;
            break;
        }
    case TPLF_NO_LINK:
        default: {
            return STATUS_NO_MORE_ENTRIES;
        }

    }
    // Validate the link target
    if (!CheckLinkTarget (TuplePacket)) {
        if (TuplePacket->Flags & (TPLF_COMMON | TPLF_INDIRECT)) {
             return(STATUS_NO_MORE_ENTRIES);
        }

        // The R2 PCMCIA spec was not clear on how the link off
        // memory was defined.  As a result the offset is often
        // by 2 as defined in the later specs.  Therefore if th
        // not found at the proper offset, the offset is divide
        // proper link target is checked for at that offset.

        TuplePacket->CISOffset >>= 1;       // Divide by 2
        if (!CheckLinkTarget(TuplePacket)) {
             return(STATUS_NO_MORE_ENTRIES);
        }
        return STATUS_NO_MORE_ENTRIES;
    }

    TuplePacket->Flags &= ~TPLF_LINK_MASK;
    return STATUS_SUCCESS;
}


NTSTATUS
ProcessLinkTuple(
    IN PTUPLE_PACKET TuplePacket
    )
/*++

Routine Description:

    Processes an encountered link while traversing the tuple chain
    by storing it for future use - when the link has to be followed
    after end of chain is encountered

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

    STATUS_SUCCESS

--*/
{
    ULONG k;

    switch (TuplePacket->TupleCode) {
    case CISTPL_LONGLINK_CB: {
            // needs to be filled in
            if (TuplePacket->TupleLink < 4) {
                return (STATUS_NO_MORE_ENTRIES);
            }
            TuplePacket->Flags = (TuplePacket->Flags & ~TPLF_LINK_MASK) | TPLF_LINK_TO_CB;
            TuplePacket->LinkOffset =   GetCISChar(TuplePacket, TPLL_ADDR) +
                                       (GetCISChar(TuplePacket, TPLL_ADDR + 1)<<8) +
                                       (GetCISChar(TuplePacket, TPLL_ADDR + 2)<<16) +
                                       (GetCISChar(TuplePacket, TPLL_ADDR + 3)<<24);

            break;
        }

    case CISTPL_INDIRECT: {
            TuplePacket->Flags |= TPLF_IND_LINK;
            TuplePacket->LinkOffset = 0;        // Don't set link offset for indirect
            SetPdoFlag(TuplePacket->SocketData->PdoExtension, PCMCIA_PDO_INDIRECT_CIS);
          break;
        }

    case CISTPL_LONGLINK_A:
    case CISTPL_LONGLINK_C: {
            if (TuplePacket->TupleLink < 4) {
                return STATUS_NO_MORE_ENTRIES;
            }
            TuplePacket->Flags = ((TuplePacket->Flags & ~TPLF_LINK_MASK) |
                                         (TuplePacket->TupleCode == CISTPL_LONGLINK_A ?
                                          TPLF_LINK_TO_A: TPLF_LINK_TO_C));
            TuplePacket->LinkOffset =   GetCISChar(TuplePacket, TPLL_ADDR) +
                                       (GetCISChar(TuplePacket, TPLL_ADDR+1) << 8) +
                                       (GetCISChar(TuplePacket, TPLL_ADDR+2) << 16) +
                                       (GetCISChar(TuplePacket, TPLL_ADDR+3) << 24) ;

            break;
        }
    case CISTPL_LONGLINK_MFC:{
            k = TPLMFC_NUM;
            TuplePacket->Socket->NumberOfFunctions = GetCISChar(TuplePacket, TPLMFC_NUM);

            if ((TuplePacket->TupleLink < (TuplePacket->Function*5 + 6)) ||
                 (GetCISChar(TuplePacket, k) <= TuplePacket->Function)) {
                return STATUS_NO_MORE_ENTRIES;
            }
            k += TuplePacket->Function*5 + 1;
            TuplePacket->Flags = (TuplePacket->Flags & ~TPLF_LINK_MASK) |
                                        (GetCISChar(TuplePacket, k) == 0?TPLF_LINK_TO_A:
                                         TPLF_LINK_TO_C);
            k++;
            TuplePacket->LinkOffset =   GetCISChar(TuplePacket, k) +
                                       (GetCISChar(TuplePacket, k+1) << 8) +
                                       (GetCISChar(TuplePacket, k+2) << 16) +
                                       (GetCISChar(TuplePacket, k+3) << 24);
            break;
        }
    case CISTPL_NO_LINK:{
            TuplePacket->Flags = (TuplePacket->Flags & ~TPLF_LINK_MASK) | TPLF_NO_LINK;
            break;
        }
    }
    return STATUS_SUCCESS;
}



NTSTATUS
GetTupleData(
    IN PTUPLE_PACKET TuplePacket
    )
/*++

Routine Description:

    Retrieves the tuple body for the currently requested
    tuple.
    NOTE: This function assumes that the caller provided
    a big enough buffer in the TuplePacket to hold the tuple
    data. No attempt is made to trap exceptions etc.

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

    STATUS_SUCCESS if tuple data was retrieved
    STATUS_NO_MORE_ENTRIES - otherwise

--*/
{
    PUCHAR bufferPointer;
    USHORT xferLength;
    USHORT tupleOffset;

    TuplePacket->TupleDataIndex = 0;
    xferLength = TuplePacket->TupleDataLength = GetCISChar(TuplePacket, 1);
    if ((tupleOffset = TuplePacket->TupleOffset) > xferLength) {
        return STATUS_NO_MORE_ENTRIES;
    }
    xferLength = MIN((xferLength - tupleOffset), TuplePacket->TupleDataMaxLength);
    for (bufferPointer = TuplePacket->TupleData; xferLength;
         tupleOffset++, bufferPointer++, xferLength--) {
        *bufferPointer = GetCISChar(TuplePacket, tupleOffset + 2);
    }
    return STATUS_SUCCESS;
}


UCHAR
GetTupleChar(
    IN PTUPLE_PACKET TuplePacket
    )
/*++

Routine Description:

    Returns the next byte in the current set of tuple data.

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

    tuple data byte

--*/
{
    UCHAR tupleChar = 0;

    if (TuplePacket->TupleDataIndex < TuplePacket->TupleDataMaxLength) {
        tupleChar = TuplePacket->TupleData[TuplePacket->TupleDataIndex++];
    }
    return tupleChar;
}



/*------------- End of Tuple API -----------------------*/


USHORT
GetCRC(
    IN PSOCKET_DATA SocketData
    )

/*++

Routine Description:

    Using the same algorithm as Windows 95, calculate the CRC value
    to be appended with the manufacturer name and device name to
    obtain the unique identifier for the PCCARD.

Arguments:

    Socket          - Pointer to the socket which contains the device
    Function        - function number of device

Return Value:

    A USHORT CRC value.

--*/

{
    PSOCKET Socket = SocketData->Socket;
    TUPLE_PACKET tuplePacket;
    PUCHAR  tupleData;
    PUCHAR  cp;
    PUCHAR  cpEnd;
    PUCHAR  tplBuffer;
    NTSTATUS     status;
    USHORT  crc = 0;
    USHORT  index;
    USHORT  length;
    UCHAR   tupleCode;
    UCHAR   tmp;

    RtlZeroMemory(&tuplePacket, sizeof(TUPLE_PACKET));

    tuplePacket.DesiredTuple = 0xFF;
    tuplePacket.TupleData = ExAllocatePool(NonPagedPool, MAX_TUPLE_DATA_LENGTH);
    if (tuplePacket.TupleData == NULL) {
        return 0;
    }

    tuplePacket.Socket               = Socket;
    tuplePacket.SocketData           = SocketData;
    tuplePacket.TupleDataMaxLength = MAX_TUPLE_DATA_LENGTH;
    tuplePacket.TupleOffset          = 0;
    tuplePacket.Function             = SocketData->Function;

    try{

        status = GetFirstTuple(&tuplePacket);

        //
        // Calculate CRC
        //
        while (NT_SUCCESS(status)) {

            tupleCode = tuplePacket.TupleCode;

            for (index = 0; TplList[index] != CISTPL_END; index++) {

                if (tupleCode == TplList[index]) {

                    status = GetTupleData(&tuplePacket);
                    if (!NT_SUCCESS(status)) {
                        //
                        // Bail...
                        //
                        crc = 0;
                        leave;
                    };
                    tupleData = tuplePacket.TupleData;
                    length = tuplePacket.TupleDataLength;

                    //
                    // This one is included in the CRC calculation
                    //

                    if (tupleCode == CISTPL_VERS_1) {
                        cp = tupleData + 2;
                        cpEnd = tupleData + MAX_TUPLE_DATA_LENGTH;

                        //
                        // Include all of the manufacturer name.
                        //

                        while ((cp < cpEnd) && *cp) {
                            cp++;
                        }

                        //
                        // Include the product string
                        //

                        cp++;
                        while ((cp < cpEnd) && *cp) {
                            cp++;
                        }
                        cp++;

                        length = (USHORT)(cp - tupleData);
                    }

                    if (length >= MAX_TUPLE_DATA_LENGTH) {
                        crc = 0;
                        leave;
                    }

                    for (cp = tupleData; length; length--, cp++) {

                        tmp = *cp ^ (UCHAR)crc;
                        crc = (crc >> 8) ^ crc16a[tmp & 0x0f] ^ crc16b[tmp >> 4];
                    }
                    break;
                }
            }
            status = GetNextTuple(&tuplePacket);
        }

    } finally {

        if (tuplePacket.TupleData) {
            ExFreePool(tuplePacket.TupleData);
        }
    }

    DebugPrint((PCMCIA_DEBUG_TUPLES, "Checksum=%x\n", crc));
    return crc;
}



NTSTATUS
PcmciaParseFunctionData(
    IN PSOCKET Socket,
    IN PSOCKET_DATA SocketData
    )
/*++

Routine Description

    Parses the tuple data for the supplied function
    (SocketPtr->Function)

Arguments:

    Socket          - Pointer to the socket which contains the device
    SocketData - Pointer to the socket data structure for the function
                     which will be filled with the parsed information

Return Value:

    Status
--*/

{
    PCONFIG_ENTRY configEntry, prevEntry = NULL;
    TUPLE_PACKET  tuplePacket;
    NTSTATUS      status;

    if (SocketData->Function >= Socket->NumberOfFunctions) {
        return STATUS_NO_MORE_ENTRIES;
    }

    if (Is16BitCardInSocket(Socket)) {
        //
        // Get the CIS checksum
        //
        SocketData->CisCrc = GetCRC(SocketData);
    }

    RtlZeroMemory(&tuplePacket, sizeof(TUPLE_PACKET));

    tuplePacket.DesiredTuple = 0xFF;
    tuplePacket.TupleData = ExAllocatePool(PagedPool, MAX_TUPLE_DATA_LENGTH);
    if (tuplePacket.TupleData == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    tuplePacket.Socket             = Socket;
    tuplePacket.SocketData         = SocketData;
    tuplePacket.TupleDataMaxLength = MAX_TUPLE_DATA_LENGTH;
    tuplePacket.TupleOffset        = 0;
    tuplePacket.Function           = SocketData->Function;

    status = GetFirstTuple(&tuplePacket);

    if (!NT_SUCCESS(status) || (tuplePacket.TupleCode == CISTPL_END)) {

        if (IsCardBusCardInSocket(Socket)) {
            //
            // Couldn't get CIS of cardbus card, no big deal
            //
            status = STATUS_SUCCESS;

        } else if (status != STATUS_DEVICE_NOT_READY) {
            //
            // No CIS, munge it to look like a memory card
            //
            status = PcmciaMemoryCardHack(Socket, SocketData);
        }

      if (tuplePacket.TupleData) {
          ExFreePool(tuplePacket.TupleData);
      }
      return status;
    }

    while (NT_SUCCESS(status)) {

        status = GetTupleData(&tuplePacket);
        ASSERT (NT_SUCCESS(status));

        DebugPrint((PCMCIA_DEBUG_TUPLES, "%04x TUPLE %02x %s\n", tuplePacket.CISOffset,
                              tuplePacket.TupleCode, TUPLE_STRING(tuplePacket.TupleCode)));

        switch (tuplePacket.TupleCode) {

        case CISTPL_VERS_1: {
                ULONG         byteCount;
                PUCHAR        pStart, pCurrent;

                //
                // Extract manufacturer name and card name.
                //

                pStart = pCurrent = tuplePacket.TupleData+2;   // To string fields
                byteCount = 0;

                while ((*pCurrent != '\0') && (*pCurrent != (UCHAR)0xff)) {

                    if ((byteCount >= MAX_MANFID_LENGTH-1) || (byteCount >= MAX_TUPLE_DATA_LENGTH)) {
                        status = STATUS_DEVICE_NOT_READY;
                        break;
                    }

                    byteCount++;
                    pCurrent++;
                }

                if (!NT_SUCCESS(status)) {
                    break;
                }

                RtlCopyMemory((PUCHAR)SocketData->Mfg, pStart, byteCount);
                //
                // Null terminate
                SocketData->Mfg[byteCount] = '\0';
                DebugPrint((PCMCIA_DEBUG_TUPLES, "Manufacturer: %s\n", SocketData->Mfg));

                PcmciaSubstituteUnderscore(SocketData->Mfg);

                pCurrent++;
                pStart = pCurrent;

                byteCount = 0;
                while ((*pCurrent != '\0') && (*pCurrent != (UCHAR)0xff)) {

                    if ((byteCount >= MAX_IDENT_LENGTH-1) || (byteCount >= MAX_TUPLE_DATA_LENGTH)) {
                        status = STATUS_DEVICE_NOT_READY;
                        break;
                    }

                    byteCount++;
                    pCurrent++;
                }

                if (!NT_SUCCESS(status)) {
                    break;
                }

                RtlCopyMemory((PUCHAR)SocketData->Ident, pStart, byteCount);
                //
                // Null terminate
                SocketData->Ident[byteCount] = '\0';
                DebugPrint((PCMCIA_DEBUG_TUPLES, "Identifier: %s\n", SocketData->Ident));

                PcmciaSubstituteUnderscore(SocketData->Ident);
                break;
            }
            //
            // get the device configuration base
            //

        case CISTPL_CONFIG: {
                ProcessConfig(&tuplePacket);
                break;
            }

        case CISTPL_CONFIG_CB: {
                ProcessConfigCB(&tuplePacket);
                break;
            }

        case CISTPL_CFTABLE_ENTRY_CB:
        case CISTPL_CFTABLE_ENTRY:  {
                //
                // construct a possible configuration entry for this device
                //
                configEntry = PcmciaProcessConfigTable(&tuplePacket);
                if (configEntry) {

                    //
                    // Link configurations at the end of the list.
                    //

                    configEntry->NextEntry = NULL;
                    if (prevEntry) {
                        prevEntry->NextEntry = configEntry;
                    } else {
                        SocketData->ConfigEntryChain = configEntry;
                    }
                    prevEntry = configEntry;

                }
                break;
            }
        case CISTPL_FUNCID: {
                //  Mark device type..
                SocketData->DeviceType = * (tuplePacket.TupleData);
                DebugPrint((PCMCIA_DEBUG_TUPLES, "DeviceType: %x\n", SocketData->DeviceType));
                break;
            }
        case CISTPL_MANFID: {
                //
                PUCHAR localBufferPointer = tuplePacket.TupleData;

                SocketData->ManufacturerCode = *(localBufferPointer+1) << 8 | *localBufferPointer;
                SocketData->ManufacturerInfo = *(localBufferPointer+3)<<8 | *(localBufferPointer+2);
                DebugPrint((PCMCIA_DEBUG_TUPLES, "Code: %x, Info: %x\n", SocketData->ManufacturerCode,
                                                                                            SocketData->ManufacturerInfo));
                break;
            }

        }   // end switch on Tuple code
        //
        // Skip to the next tuple
        //
        status = GetNextTuple(&tuplePacket);
    }

    if (tuplePacket.TupleData) {
        ExFreePool(tuplePacket.TupleData);
    }
    if (status == STATUS_DEVICE_NOT_READY) {
        return status;
    }

    //
    // Serial/modem/ATA devices recognized and appropriate
    // fixes for tuples applied here
    //

    PcmciaCheckForRecognizedDevice(Socket,SocketData);
    DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x ParseFunctionData: Final PcCard type %x\n",
                    Socket, SocketData->DeviceType));
    return STATUS_SUCCESS;
}


NTSTATUS
PcmciaParseFunctionDataForID(
    IN PSOCKET_DATA SocketData
    )
/*++

Routine Description

    Parses the tuple data for the supplied function
    (SocketPtr->Function)

Arguments:

    Socket          - Pointer to the socket which contains the device
    SocketData - Pointer to the socket data structure for the function
                     which will be filled with the parsed information

Return Value:

    Status
--*/

{
    PSOCKET Socket = SocketData->Socket;
    TUPLE_PACKET  tuplePacket;
    PUCHAR        localBufferPointer;
    NTSTATUS      status;
    USHORT        ManufacturerCode = 0;
    USHORT        ManufacturerInfo = 0;
    USHORT        CisCrc;

    DebugPrint((PCMCIA_DEBUG_TUPLES, "Parsing function %d for ID...\n", SocketData->Function));


    RtlZeroMemory(&tuplePacket, sizeof(TUPLE_PACKET));

    tuplePacket.DesiredTuple = 0xFF;
    tuplePacket.TupleData = ExAllocatePool(NonPagedPool, MAX_TUPLE_DATA_LENGTH);
    if (tuplePacket.TupleData == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    tuplePacket.Socket             = Socket;
    tuplePacket.SocketData         = SocketData;
    tuplePacket.TupleDataMaxLength = MAX_TUPLE_DATA_LENGTH;
    tuplePacket.TupleOffset        = 0;
    tuplePacket.Function           = SocketData->Function;

    status = GetFirstTuple(&tuplePacket);

    if (!NT_SUCCESS(status) ||
         (tuplePacket.TupleCode == CISTPL_END)) {

        if (status != STATUS_DEVICE_NOT_READY) {
            if (IsSocketFlagSet(Socket, SOCKET_CARD_MEMORY)) {
                status = STATUS_SUCCESS;
            }
            status = STATUS_NO_MORE_ENTRIES;
        }

        if (tuplePacket.TupleData) {
            ExFreePool(tuplePacket.TupleData);
        }
        return status;
    }

    while (NT_SUCCESS(status)) {

        status = GetTupleData(&tuplePacket);
        ASSERT (NT_SUCCESS(status));

        switch (tuplePacket.TupleCode) {

        case CISTPL_MANFID: {

                localBufferPointer = tuplePacket.TupleData;
                ManufacturerCode = *(localBufferPointer+1) << 8 | *localBufferPointer;
                ManufacturerInfo = *(localBufferPointer+3)<<8 | *(localBufferPointer+2);
                break;
            }

        }   // end switch on Tuple code
        //
        // Skip to the next tuple
        //
        status = GetNextTuple(&tuplePacket);
    }

    if (tuplePacket.TupleData) {
        ExFreePool(tuplePacket.TupleData);
    }

    if (SocketData->ManufacturerCode != ManufacturerCode) {
        DebugPrint((PCMCIA_DEBUG_TUPLES, "Verify failed on Manf. Code: %x %x\n", SocketData->ManufacturerCode, ManufacturerCode));
        return STATUS_UNSUCCESSFUL;
    }

    if (SocketData->ManufacturerInfo != ManufacturerInfo) {
        DebugPrint((PCMCIA_DEBUG_TUPLES, "Verify failed on Manf. Info: %x %x\n", SocketData->ManufacturerInfo, ManufacturerInfo));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Get the CIS checksum
    //
    CisCrc = GetCRC(SocketData);

    if (SocketData->CisCrc != CisCrc) {
        DebugPrint((PCMCIA_DEBUG_TUPLES, "Verify failed on CRC: %x %x\n", SocketData->CisCrc, CisCrc));
        return STATUS_UNSUCCESSFUL;
    }

    DebugPrint((PCMCIA_DEBUG_INFO, "skt %08x R2 CardId verified %x-%x-%x\n", Socket,
                                                      ManufacturerCode,
                                                      ManufacturerInfo,
                                                      CisCrc
                                                      ));
    return STATUS_SUCCESS;
}



VOID
PcmciaCheckForRecognizedDevice(
    IN PSOCKET  Socket,
    IN OUT PSOCKET_DATA SocketData
    )

/*++

Routine Description:

     Look at the configuration options on the PCCARD to determine if
     it is a serial port / modem / ATA device card.

Arguments:

     Socket          - Pointer to the socket which contains the device
     SocketData - the configuration information on the current PCCARD.

Return Value:

     None - Modifications are made to the socket data structure.

--*/

{
    ULONG         modemPorts[4] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8};
    ULONG         ataPorts0[2]  = { 0x1f0, 0x170};
    BOOLEAN       found = FALSE;
    ULONG         index;
    TUPLE_PACKET  tuplePacket;
    PCONFIG_ENTRY configEntry;
    NTSTATUS      status;

    //
    // This piece of code searches the config data for I/O ranges that start at
    // some known industry standard, and updates the devicetype accordingly.
    //
    // This is such an ugly hack, I'm really skeptical that we should be doing
    // this anymore. I assume there must have been some broken hardware that needed
    // it, but that information is now lost. At some point, this whole for loop
    // should just be removed.
    //
    for (configEntry = SocketData->ConfigEntryChain; configEntry; configEntry = configEntry->NextEntry) {
        for (index = 0; index < 4; index++) {
            if (modemPorts[index] == configEntry->IoPortBase[0]) {

                SocketData->DeviceType = PCCARD_TYPE_SERIAL;
                found = TRUE;
                break;
            }

#pragma prefast(push)
#pragma prefast(disable: 201)        // prefast bug 546

            if (index < 2) {
                if (ataPorts0[index] == configEntry->IoPortBase[0]) {
                    if (configEntry->IoPortBase[1] == 0x376 ||
                         configEntry->IoPortBase[1] == 0x3f6 ) {
                        SocketData->DeviceType = PCCARD_TYPE_ATA;
                        found = TRUE;
                        break;
                    }
                }
            }

#pragma prefast(pop)

        }
    }

    if (SocketData->DeviceType == PCCARD_TYPE_SERIAL) {
        //
        // If card type is serial , check if it's actually a modem...
        //

        UCHAR  tupleDataBuffer[MAX_TUPLE_DATA_LENGTH];
        PUCHAR str, pChar;

        RtlZeroMemory(&tuplePacket, sizeof(TUPLE_PACKET));

        tuplePacket.DesiredTuple = CISTPL_FUNCE;
        tuplePacket.TupleData = tupleDataBuffer;

        tuplePacket.Socket               = Socket;
        tuplePacket.SocketData           = SocketData;
        tuplePacket.TupleDataMaxLength =  MAX_TUPLE_DATA_LENGTH;
        tuplePacket.TupleOffset          =  0;
        tuplePacket.Function             = SocketData->Function;
        status = GetFirstTuple(&tuplePacket);

        while (NT_SUCCESS(status)) {
            status = GetTupleData(&tuplePacket);
            if (!NT_SUCCESS(status) || (tuplePacket.TupleDataLength == 0)) {
                // something bad happened
                break;
            }

            if (tuplePacket.TupleData[0] >=1 &&
                 tuplePacket.TupleData[0] <=3) {
                SocketData->DeviceType = PCCARD_TYPE_MODEM;
                return;
            }
            status = GetNextTuple(&tuplePacket);
        }

        if (status == STATUS_DEVICE_NOT_READY) {
            return;
        }

        if (strstr(SocketData->Mfg, "MODEM") || strstr(SocketData->Mfg,   "FAX") ||
             strstr(SocketData->Ident, "MODEM") || strstr(SocketData->Ident, "FAX")) {
            SocketData->DeviceType = PCCARD_TYPE_MODEM;
        }

    }
}



VOID
PcmciaFilterTupleData(
    IN PPDO_EXTENSION PdoExtension
    )

/*++

Routine Description:

     Look at the configuration options on the PCCARD to determine if
     it is a serial port / modem / ATA device card.

Arguments:

     Socket          - Pointer to the socket which contains the device
     SocketData - the configuration information on the current PCCARD.

Return Value:

     None - Modifications are made to the socket data structure.

--*/

{
    PSOCKET_DATA socketData;
    PCONFIG_ENTRY configEntry;

    for (socketData = PdoExtension->SocketData; socketData != NULL; socketData = socketData->Next) {

        switch(socketData->DeviceType) {

        case PCCARD_TYPE_ATA:
            //
            // More smudges follow here for ATA cards to rub out buggy tuples
            //
            // Search for configurations which are not viable for ATA devices
            // and mark them invalid so they would not be reported to the I/O subsystem.
            // Also fix buggy tuples on ATA cards
            for (configEntry = socketData->ConfigEntryChain;
                 configEntry != NULL; configEntry = configEntry->NextEntry) {
                //
                // Adjust the IO resource requirement: ATA cards
                // typically have an incorrect length here
                // (+1)
                //
                if (configEntry->IoPortLength[1] > 0) {
                    configEntry->IoPortLength[1]=0;
                }

                //
                // This next hack is to work around a problem with Viking SmartCard adapters.
                // This adapter doesn't like I/O ranges that are based at 0x70 or 0xf0,
                // so we bump up the alignment to 0x20 on unrestricted I/O ranges.
                //

                if ((socketData->ManufacturerCode == 0x1df) && (configEntry->NumberOfIoPortRanges == 1) &&
                     (configEntry->IoPortBase[0] == 0) && (configEntry->IoPortLength[0] == 0xf) &&
                     (configEntry->IoPortAlignment[0] == 0x10)) {
                     // alter alignment
                     configEntry->IoPortAlignment[0] = 0x20;
                }

                if (configEntry->NumberOfMemoryRanges) {
                    //
                    // Don't use this configuration
                    //
                    configEntry->Flags |=  PCMCIA_INVALID_CONFIGURATION;
                }
            }
            break;

        case PCCARD_TYPE_PARALLEL:
            // Search for configurations which are not viable for Parallel devices
            for (configEntry = socketData->ConfigEntryChain;
                 configEntry != NULL; configEntry = configEntry->NextEntry) {

                if (configEntry->NumberOfMemoryRanges) {
                    //
                    // Don't use this configuration
                    //
                    configEntry->Flags |=  PCMCIA_INVALID_CONFIGURATION;
                }
            }
            break;
        }


        // Search for configurations which are not viable - because
        // the resources requested are not supported by the controller
        // or the OS - and mark them invalid so they would not be requested

        for (configEntry = socketData->ConfigEntryChain;
             configEntry != NULL; configEntry = configEntry->NextEntry) {

            if ((configEntry->IrqMask == 0) &&
                 (configEntry->NumberOfIoPortRanges == 0) &&
                 (configEntry->NumberOfMemoryRanges == 0)) {
                //
                // This configuration doesn't need any resources!!
                // Obviously bogus. (IBM Etherjet-3FE2 has one of these)
                //
                configEntry->Flags |= PCMCIA_INVALID_CONFIGURATION;
            }

        }
    }
}



NTSTATUS
PcmciaMemoryCardHack(
    IN  PSOCKET Socket,
    IN PSOCKET_DATA SocketData
    )
/*++

Routine Description:

    This routine is called whenever we do not find a CIS of the card.
    We  probe the card to determine if it is sram or not.

Arguments

    SocketPtr   - Point to the socket in which this card was found
    SocketData  - Pointer to  a pointer to the data structure which normally contains
                      parsed tuple data. This will be filled in by this routine


Return Value

    STATUS_SUCCESS

--*/
{

#define JEDEC_SRAM 0x0000                    // JEDEC ID for SRAM cards
#define JEDEC_ROM  0x0002                    // JEDEC ID for ROM cards
#define READ_ID_CMD      0x9090

    PPDO_EXTENSION pdoExtension = SocketData->PdoExtension;
    USHORT OrigValue;
    USHORT ChkValue;
    USHORT ReadIdCmd = READ_ID_CMD;

    PAGED_CODE();

    SetSocketFlag(Socket, SOCKET_CARD_MEMORY);

    SocketData->DeviceType = PCCARD_TYPE_MEMORY;
    SocketData->Flags = SDF_JEDEC_ID;
    SocketData->JedecId = JEDEC_ROM;

    //
    // Like win9x, we probe the card's common memory with a write to offset zero to see if
    // it looks like sram
    //

    if (((*(Socket->SocketFnPtr->PCBReadCardMemory)) (pdoExtension, PCCARD_COMMON_MEMORY, 0, (PUCHAR)&OrigValue, 2) == 2) &&
         ((*(Socket->SocketFnPtr->PCBWriteCardMemory))(pdoExtension, PCCARD_COMMON_MEMORY, 0, (PUCHAR)&ReadIdCmd, 2) == 2) &&
         ((*(Socket->SocketFnPtr->PCBReadCardMemory)) (pdoExtension, PCCARD_COMMON_MEMORY, 0, (PUCHAR)&ChkValue, 2)  == 2) &&
         ((*(Socket->SocketFnPtr->PCBWriteCardMemory))(pdoExtension, PCCARD_COMMON_MEMORY, 0, (PUCHAR)&OrigValue, 2) == 2)) {

        if (ChkValue == ReadIdCmd) {
            SocketData->JedecId = JEDEC_SRAM;
        }
    }

    if (pcmciaReportMTD0002AsError && (SocketData->JedecId == JEDEC_ROM)) {
        return STATUS_DEVICE_NOT_READY;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\ar_memio.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    ar_memio.c

Abstract:

    This module implements the PCI Memory and IO resource Arbiters.
    Most functionality for these two arbiters is common and distinguished
    by the "context".

Author:

    Andrew Thornton (andrewth)  21-May-1997

Revision History:

--*/

#include "pcip.h"

#define BUGFEST_HACKS

#define ARMEMIO_VERSION 0

//
// Flags for WorkSpace
//
#define PORT_ARBITER_PREPROCESSED               0x00000001
#define PORT_ARBITER_IMPROVISED_DECODE          0x00000002
#define PORT_ARBITER_ISA_BIT_SET                0x00000004
#define PORT_ARBITER_BRIDGE_WINDOW              0x00000008

//
// ALLOCATE_ALIASES - this turns on the allocation of 10 & 12 bit decoded
// aliases.
//

#define ALLOCATE_ALIASES                        1
#define IGNORE_PREFETCH_FOR_LEGACY_REPORTED     1
#define PASSIVE_DECODE_SUPPORTED                1
#define PREFETCHABLE_SUPPORTED                  1
#define ISA_BIT_SUPPORTED                       1

//
// Flags for range attributes
//

#define MEMORY_RANGE_ROM                        0x10


//
// Constants
//

#define PCI_BRIDGE_WINDOW_GRANULARITY   0x1000
#define PCI_BRIDGE_ISA_BIT_STRIDE       0x400
#define PCI_BRIDGE_ISA_BIT_WIDTH        0x100
#define PCI_BRIDGE_ISA_BIT_MAX          0xFFFF
#define MAX_10_BIT_DECODE               0x3FF
#define MAX_12_BIT_DECODE               0xFFF
#define MAX_16_BIT_DECODE               0xFFFF
//
// Static data
//

ARBITER_ORDERING PciBridgeOrderings[] = {
    { 0x10000, MAXULONGLONG },
    { 0,       0xFFFF }
};

ARBITER_ORDERING_LIST PciBridgeOrderingList = {
    sizeof(PciBridgeOrderings) / sizeof (ARBITER_ORDERING),
    sizeof(PciBridgeOrderings) / sizeof (ARBITER_ORDERING),
    PciBridgeOrderings
};

//
// Prototypes for routines exposed only thru the "interface"
// mechanism.
//

NTSTATUS
ario_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    );

NTSTATUS
ario_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    );

NTSTATUS
armem_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    );

NTSTATUS
armem_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    );

PCI_INTERFACE ArbiterInterfaceMemory = {
    &GUID_ARBITER_INTERFACE_STANDARD,       // InterfaceType
    sizeof(ARBITER_INTERFACE),              // MinSize
    ARMEMIO_VERSION,                        // MinVersion
    ARMEMIO_VERSION,                        // MaxVersion
    PCIIF_FDO,                              // Flags
    0,                                      // ReferenceCount
    PciArb_Memory,                          // Signature
    armem_Constructor,                      // Constructor
    armem_Initializer                       // Instance Initializer
};

PCI_INTERFACE ArbiterInterfaceIo = {
    &GUID_ARBITER_INTERFACE_STANDARD,       // InterfaceType
    sizeof(ARBITER_INTERFACE),              // MinSize
    ARMEMIO_VERSION,                        // MinVersion
    ARMEMIO_VERSION,                        // MaxVersion
    PCIIF_FDO,                              // Flags
    0,                                      // ReferenceCount
    PciArb_Io,                              // Signature
    ario_Constructor,                       // Constructor
    ario_Initializer                        // Instance Initializer
};

//
// Arbiter helper functions.
//

NTSTATUS
armemio_UnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    );

NTSTATUS
armemio_PackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    );

NTSTATUS
armemio_UnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    );

NTSTATUS
armemio_ScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    );

VOID
ario_BacktrackAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     );

BOOLEAN
ario_FindSuitableRange(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    );

BOOLEAN
ario_GetNextAlias(
    ULONG IoDescriptorFlags,
    ULONGLONG LastAlias,
    PULONGLONG NextAlias
    );

BOOLEAN
ario_IsAliasedRangeAvailable(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    );

VOID
ario_AddAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

BOOLEAN
ario_OverrideConflict(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

NTSTATUS
ario_PreprocessEntry(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

NTSTATUS
armem_StartArbiter(
    IN PARBITER_INSTANCE Arbiter,
    IN PCM_RESOURCE_LIST StartResources
    );

NTSTATUS
armem_PreprocessEntry(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

BOOLEAN
armem_GetNextAllocationRange(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

BOOLEAN
ario_GetNextAllocationRange(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

NTSTATUS
ario_StartArbiter(
    IN PARBITER_INSTANCE Arbiter,
    IN PCM_RESOURCE_LIST StartResources
    );

VOID
ario_AddOrBacktrackAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State,
     IN PARBITER_BACKTRACK_ALLOCATION Callback
     );

BOOLEAN
armem_FindSuitableRange(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, ario_Constructor)
#pragma alloc_text(PAGE, armem_Constructor)
#pragma alloc_text(PAGE, ario_Initializer)
#pragma alloc_text(PAGE, armem_Initializer)
#pragma alloc_text(PAGE, armemio_UnpackRequirement)
#pragma alloc_text(PAGE, armemio_PackResource)
#pragma alloc_text(PAGE, armemio_UnpackResource)
#pragma alloc_text(PAGE, armemio_ScoreRequirement)
#pragma alloc_text(PAGE, ario_OverrideConflict)
#pragma alloc_text(PAGE, ario_BacktrackAllocation)
#pragma alloc_text(PAGE, ario_GetNextAlias)
#pragma alloc_text(PAGE, ario_FindSuitableRange)
#pragma alloc_text(PAGE, ario_GetNextAlias)
#pragma alloc_text(PAGE, ario_IsAliasedRangeAvailable)
#pragma alloc_text(PAGE, ario_AddAllocation)
#pragma alloc_text(PAGE, ario_PreprocessEntry)
#pragma alloc_text(PAGE, armem_StartArbiter)
#pragma alloc_text(PAGE, armem_PreprocessEntry)
#pragma alloc_text(PAGE, armem_GetNextAllocationRange)
#pragma alloc_text(PAGE, ario_AddOrBacktrackAllocation)
#pragma alloc_text(PAGE, armem_FindSuitableRange)

#endif

//
// Prefetchable memory support.
//
// Prefetchable memory is device memory that can be treated like normal memory
// in that reads have no side effects and we can combine writes.  The
// CM_RESOURCE_MEMORY_PREFETCHABLE flag means that the device would *like*
// prefetchable memory but normal memory is just fine as well.
//



NTSTATUS
ario_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    )

/*++

Routine Description:

    Check the InterfaceSpecificData to see if this is the correct
    arbiter (we already know the required interface is an arbiter
    from the GUID) and if so, allocate (and reference) a context
    for this interface.

Arguments:

    PciInterface    Pointer to the PciInterface record for this
                    interface type.
    InterfaceSpecificData
                    A ULONG containing the resource type for which
                    arbitration is required.
    InterfaceReturn

Return Value:

    TRUE is this device is not known to cause problems, FALSE
    if the device should be skipped altogether.

--*/

{
    PARBITER_INTERFACE arbiterInterface;
    NTSTATUS status;

            
    PAGED_CODE();

    //
    // This arbiter handles I/O ports, is that what they want?
    //

    if ((ULONG_PTR)InterfaceSpecificData != CmResourceTypePort) {

        //
        // No, it's not us then.
        //

        return STATUS_INVALID_PARAMETER_5;
    }

    if (!((PPCI_FDO_EXTENSION)DeviceExtension)->ArbitersInitialized) {
    
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Have already verified that the InterfaceReturn variable
    // points to an area in memory large enough to contain an
    // ARBITER_INTERFACE.  Fill it in for the caller.
    //

    arbiterInterface = (PARBITER_INTERFACE)InterfaceReturn;

    arbiterInterface->Size                 = sizeof(ARBITER_INTERFACE);
    arbiterInterface->Version              = ARMEMIO_VERSION;
    arbiterInterface->InterfaceReference   = PciReferenceArbiter;
    arbiterInterface->InterfaceDereference = PciDereferenceArbiter;
    arbiterInterface->ArbiterHandler       = ArbArbiterHandler;
    arbiterInterface->Flags                = 0;

    status = PciArbiterInitializeInterface(DeviceExtension,
                                           PciArb_Io,
                                           arbiterInterface);

    return status;
}

NTSTATUS
armem_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    )

/*++

Routine Description:

    Check the InterfaceSpecificData to see if this is the correct
    arbiter (we already know the required interface is an arbiter
    from the GUID) and if so, allocate (and reference) a context
    for this interface.

Arguments:

    PciInterface    Pointer to the PciInterface record for this
                    interface type.
    InterfaceSpecificData
                    A ULONG containing the resource type for which
                    arbitration is required.
    InterfaceReturn

Return Value:

    TRUE is this device is not known to cause problems, FALSE
    if the device should be skipped altogether.

--*/

{
    PARBITER_INTERFACE arbiterInterface;
    NTSTATUS status;
    
            
    PAGED_CODE();

    //
    // This arbiter handles memory, is that what they want?
    //

    if ((ULONG_PTR)InterfaceSpecificData != CmResourceTypeMemory) {

        //
        // No, it's not us then.
        //

        return STATUS_INVALID_PARAMETER_5;
    }

    if (!((PPCI_FDO_EXTENSION)DeviceExtension)->ArbitersInitialized) {
    
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Have already verified that the InterfaceReturn variable
    // points to an area in memory large enough to contain an
    // ARBITER_INTERFACE.  Fill it in for the caller.
    //

    arbiterInterface = (PARBITER_INTERFACE)InterfaceReturn;

    arbiterInterface->Size                 = sizeof(ARBITER_INTERFACE);
    arbiterInterface->Version              = ARMEMIO_VERSION;
    arbiterInterface->InterfaceReference   = PciReferenceArbiter;
    arbiterInterface->InterfaceDereference = PciDereferenceArbiter;
    arbiterInterface->ArbiterHandler       = ArbArbiterHandler;
    arbiterInterface->Flags                = 0;

    status = PciArbiterInitializeInterface(DeviceExtension,
                                           PciArb_Memory,
                                           arbiterInterface);

    return status;
}

NTSTATUS
armem_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    )

/*++

Routine Description:

    This routine is called once per instantiation of an arbiter.
    Performs initialization of this instantiation's context.

Arguments:

    Instance        Pointer to the arbiter context.

Return Value:

    Returns the status of this operation.

--*/

{

    PAGED_CODE();

    RtlZeroMemory(&Instance->CommonInstance, sizeof(ARBITER_INSTANCE));

    //
    // Set the Action Handler entry points.
    //

    Instance->CommonInstance.UnpackRequirement = armemio_UnpackRequirement;
    Instance->CommonInstance.PackResource      = armemio_PackResource;
    Instance->CommonInstance.UnpackResource    = armemio_UnpackResource;
    Instance->CommonInstance.ScoreRequirement  = armemio_ScoreRequirement;

    Instance->CommonInstance.FindSuitableRange = armem_FindSuitableRange;

#if PREFETCHABLE_SUPPORTED

    Instance->CommonInstance.PreprocessEntry   = armem_PreprocessEntry;
    Instance->CommonInstance.StartArbiter      = armem_StartArbiter;
    Instance->CommonInstance.GetNextAllocationRange
                                               = armem_GetNextAllocationRange;


    //
    // NTRAID #54671 - 2000/03/31 - andrewth
    // When reference counting is working we need to release this
    // extension when we dereference the arbiter to 0
    //

    //
    // Allocate and zero the arbiter extension, it is initialized in
    // armem_StartArbiter
    //

    Instance->CommonInstance.Extension
        = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, sizeof(ARBITER_MEMORY_EXTENSION));

    if (!Instance->CommonInstance.Extension) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(Instance->CommonInstance.Extension,
                  sizeof(ARBITER_MEMORY_EXTENSION)
                  );

#endif // PREFETCHABLE_SUPPORTED

    //
    // Initialize the rest of the common instance
    //

    return ArbInitializeArbiterInstance(&Instance->CommonInstance,
                                        Instance->BusFdoExtension->FunctionalDeviceObject,
                                        CmResourceTypeMemory,
                                        Instance->InstanceName,
                                        L"Pci",
                                        NULL
                                        );

}

NTSTATUS
ario_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    )

/*++

Routine Description:

    This routine is called once per instantiation of an arbiter.
    Performs initialization of this instantiation's context.

Arguments:

    Instance        Pointer to the arbiter context.

Return Value:

    Returns the status of this operation.

--*/

{
    PAGED_CODE();

    PCI_ASSERT(!(Instance->BusFdoExtension->BrokenVideoHackApplied));
    RtlZeroMemory(&Instance->CommonInstance, sizeof(ARBITER_INSTANCE));



    //
    // Set the Action Handler entry points.
    //

#if ALLOCATE_ALIASES

    Instance->CommonInstance.PreprocessEntry      = ario_PreprocessEntry;
    Instance->CommonInstance.FindSuitableRange    = ario_FindSuitableRange;
    Instance->CommonInstance.AddAllocation        = ario_AddAllocation;
    Instance->CommonInstance.BacktrackAllocation  = ario_BacktrackAllocation;

#endif

#if PASSIVE_DECODE_SUPPORTED

    Instance->CommonInstance.OverrideConflict     = ario_OverrideConflict;

#endif

#if ISA_BIT_SUPPORTED

    Instance->CommonInstance.GetNextAllocationRange = ario_GetNextAllocationRange;
    Instance->CommonInstance.StartArbiter           = ario_StartArbiter;
#endif

    Instance->CommonInstance.UnpackRequirement = armemio_UnpackRequirement;
    Instance->CommonInstance.PackResource      = armemio_PackResource;
    Instance->CommonInstance.UnpackResource    = armemio_UnpackResource;
    Instance->CommonInstance.ScoreRequirement  = armemio_ScoreRequirement;

    //
    // Initialize the rest of the common instance
    //

    return ArbInitializeArbiterInstance(&Instance->CommonInstance,
                                        Instance->BusFdoExtension->FunctionalDeviceObject,
                                        CmResourceTypePort,
                                        Instance->InstanceName,
                                        L"Pci",
                                        NULL
                                        );
}

NTSTATUS
armemio_UnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    )

/*++

Routine Description:

    This routine unpacks an resource requirement descriptor.

Arguments:

    Descriptor - The descriptor describing the requirement to unpack.

    Minimum - Pointer to where the minimum acceptable start value should be
        unpacked to.

    Maximum - Pointer to where the maximum acceptable end value should be
        unpacked to.

    Length - Pointer to where the required length should be unpacked to.

    Minimum - Pointer to where the required alignment should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/

{
    NTSTATUS    status = STATUS_SUCCESS;

    PAGED_CODE();

    PCI_ASSERT(Descriptor);
    PCI_ASSERT((Descriptor->Type == CmResourceTypePort) ||
           (Descriptor->Type == CmResourceTypeMemory));

    *Minimum = (ULONGLONG)Descriptor->u.Generic.MinimumAddress.QuadPart;
    *Maximum = (ULONGLONG)Descriptor->u.Generic.MaximumAddress.QuadPart;
    *Length = Descriptor->u.Generic.Length;
    *Alignment = Descriptor->u.Generic.Alignment;

    //
    // Fix the broken hardware that reports 0 alignment
    //

    if (*Alignment == 0) {
        *Alignment = 1;
    }

    //
    // Fix broken INF's that report they support 24bit memory > 0xFFFFFF
    //

    if (Descriptor->Type == CmResourceTypeMemory
    && Descriptor->Flags & CM_RESOURCE_MEMORY_24
    && Descriptor->u.Memory.MaximumAddress.QuadPart > 0xFFFFFF) {
        if (Descriptor->u.Memory.MinimumAddress.QuadPart > 0xFFFFFF) {
            PciDebugPrint(0, "24 bit decode specified but both min and max are greater than 0xFFFFFF, most probably due to broken INF!\n");
            PCI_ASSERT(Descriptor->u.Memory.MinimumAddress.QuadPart <= 0xFFFFFF);
            status = STATUS_UNSUCCESSFUL;
        } else {
            *Maximum = 0xFFFFFF;
        }
    }

    return status;
}

NTSTATUS
armemio_PackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine packs an resource descriptor.

Arguments:

    Requirement - The requirement from which this resource was chosen.

    Start - The start value of the resource.

    Descriptor - Pointer to the descriptor to pack into.

Return Value:

    Returns the status of this operation.

--*/

{
    PAGED_CODE();

    PCI_ASSERT(Descriptor);
    PCI_ASSERT(Requirement);
    PCI_ASSERT((Requirement->Type == CmResourceTypePort) ||
           (Requirement->Type == CmResourceTypeMemory));

    Descriptor->Type = Requirement->Type;
    Descriptor->Flags = Requirement->Flags;
    Descriptor->ShareDisposition = Requirement->ShareDisposition;
    Descriptor->u.Generic.Start.QuadPart = Start;
    Descriptor->u.Generic.Length = Requirement->u.Generic.Length;

    return STATUS_SUCCESS;
}

NTSTATUS
armemio_UnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine unpacks an resource descriptor.

Arguments:

    Descriptor - The descriptor describing the resource to unpack.

    Start - Pointer to where the start value should be unpacked to.

    End - Pointer to where the end value should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/

{
    PAGED_CODE();

    PCI_ASSERT(Descriptor);
    PCI_ASSERT(Start);
    PCI_ASSERT(Length);
    PCI_ASSERT((Descriptor->Type == CmResourceTypePort) ||
           (Descriptor->Type == CmResourceTypeMemory));

    *Start = Descriptor->u.Generic.Start.QuadPart;
    *Length= Descriptor->u.Generic.Length;

    return STATUS_SUCCESS;
}

LONG
armemio_ScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine scores a requirement based on how flexible it is.  The least
    flexible devices are scored the least and so when the arbitration list is
    sorted we try to allocate their resources first.

Arguments:

    Descriptor - The descriptor describing the requirement to score.


Return Value:

    The score.

--*/

{
    LONG score;
    ULONGLONG start, end;
    ULONGLONG bigscore;
    ULONG alignment;

    PAGED_CODE();

    PCI_ASSERT(Descriptor);
    PCI_ASSERT((Descriptor->Type == CmResourceTypePort) ||
           (Descriptor->Type == CmResourceTypeMemory));

    alignment = Descriptor->u.Generic.Alignment;

    //
    // Fix the broken hardware that reports 0 alignment
    //
    if (alignment == 0) {
  
        //
        // Set this to 1 here, because we arbitrate ISA
        // devices in the context of PCI. If you don't understand
        // you don't want to. Trust me. (hint: subtractive decode)
        //
        // Any PCI device that has alignment 0 will also
        // have Length 0, which is horribly wrong to begin with.
        // and we deal with it elsewhere.
        //
        alignment = 1;
    }

    start = ALIGN_ADDRESS_UP(
                Descriptor->u.Generic.MinimumAddress.QuadPart,
                alignment
                );

    end = Descriptor->u.Generic.MaximumAddress.QuadPart;

    //
    // The score is the number of possible allocations that could be made
    // given the alignment and length constraints
    //

    bigscore = (((end - Descriptor->u.Generic.Length + 1) - start)
                    / alignment) + 1;

    //
    // Note, the scores for each possibility are added together.  To
    // avoid overflowing the total, we need to limit the range returned.
    //
    // Make it a sort of logarithmic score.  Find the highest byte
    // set, weight it (add 0x100) and use the log (I said "sort of").
    //
    // This puts the result in the range 0xff80 down to 0x0100.
    //

    for (score = sizeof(bigscore) - 1; score >= 0; score--) {

        UCHAR v = *(((PUCHAR)&bigscore) + score);
        if (v != 0) {
            score = (v + 0x100) << score;
            break;
        }
    }

    //
    // The resulting TOTAL from scoring all the alternatives is used
    // to sort the list.  The highest total is considered the easiest
    // to place,....  which is probably true,... What if we got some-
    // thing like a single fit preferred setting followed by a fits
    // anywhere setting?   We don't want that to score higher than
    // another device which only specified the fit anywhere setting,
    // the preferred setting is harder to achieve.
    //
    // And, are two alternatives, each half as good an a 'fit anywhere'
    // as good as the 'fit anywhere'.  Not really.
    //
    // So, we weight the result even further depending on what options
    // are set in this resource.
    //

    if (Descriptor->Option &
                    (IO_RESOURCE_PREFERRED | IO_RESOURCE_ALTERNATIVE)) {
        score -= 0x100;
    }

    ARB_PRINT(
        3,
        ("  %s resource %08x(0x%I64x-0x%I64x) => %i\n",
        Descriptor->Type == CmResourceTypeMemory ? "Memory" : "Io",
        Descriptor,
        Descriptor->u.Generic.MinimumAddress.QuadPart,
        end,
        score
        ));

    return score;
}
VOID
ario_BacktrackAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     )

/*++

Routine Description:

    This routine is called from AllocateEntry if the possible solution
    (State->Start - State->End) does not allow us to allocate resources to
    the rest of the devices being considered.  It deletes the ranges that were
    added to Arbiter->PossibleAllocation by AddAllocation including those
    associated with ISA aliases.

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    None.

--*/


{

    PAGED_CODE();

    ario_AddOrBacktrackAllocation(Arbiter,
                                  State,
                                  ArbBacktrackAllocation
                                  );


}

VOID
ario_AddOrBacktrackAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State,
     IN PARBITER_BACKTRACK_ALLOCATION Callback
     )

/*++

Routine Description:

    This relies on the fact that PARBITER_BACKTRACK_ALLOCATION and
    PARBITER_ADD_ALLOCATION are of the same type

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

    Backtrack - TRUE for backtrack, false for ADD

Return Value:

    None.

--*/

{
    ARBITER_ALLOCATION_STATE localState;

    PAGED_CODE();

    PCI_ASSERT(Arbiter);
    PCI_ASSERT(State);

    //
    // We are going to mess with the state so make our own local copy
    //

    RtlCopyMemory(&localState, State, sizeof(ARBITER_ALLOCATION_STATE));

#if ISA_BIT_SUPPORTED

    //
    // Check if this is a window for a bridge with the ISA bit set that is
    // in 16 bit IO space.  If so we need to do some special processing
    //

    if (State->WorkSpace & PORT_ARBITER_BRIDGE_WINDOW
    &&  State->WorkSpace & PORT_ARBITER_ISA_BIT_SET
    &&  State->Start < 0xFFFF) {

        //
        // We don't support IO windows that straddle the 16/32 bit boundry
        //

        PCI_ASSERT(State->End <= 0xFFFF);

        //
        // If the ISA bit is set on a bridge it means that the bridge only
        // decodes the first 0x100 ports for each 0x400 ports in 16 bit IO space.
        // Just remove these to the range list.
        //

        for (;
             localState.Start < State->End && localState.Start < 0xFFFF;
             localState.Start += 0x400) {

            localState.End = localState.Start + 0xFF;

            Callback(Arbiter, &localState);

        }

        return;
    }

#endif

    //
    // Process the base range
    //

    Callback(Arbiter, State);

    //
    // Process any aliases with the alias flag set
    //

    ARB_PRINT(2, ("Adding aliases\n"));

    //
    // Lets see if we are processing positively decoded alases - yes you read that
    // right - on a PCI-PCI or Cardbus brigde with the VGA bit set (and seeing
    // as our friends now like AGP cards this is rather common) we decode all
    // VGA ranges together with their 10bit aliases.  This means that the normal
    // rules of engagement with aliases don't apply so don't set the alias bit.
    //

    if (!(State->CurrentAlternative->Descriptor->Flags & CM_RESOURCE_PORT_POSITIVE_DECODE)) {

        //
        // We're processing aliases so set the alias flag
        //
        localState.RangeAttributes |= ARBITER_RANGE_ALIAS;
    }

    while (ario_GetNextAlias(State->CurrentAlternative->Descriptor->Flags,
                             localState.Start,
                             &localState.Start)) {

        localState.End = localState.Start + State->CurrentAlternative->Length - 1;

        Callback(Arbiter, &localState);

    }
}



NTSTATUS
ario_PreprocessEntry(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )
/*++

Routine Description:

    This routine is called from AllocateEntry to allow preprocessing of
    entries

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    None.

--*/
{

    PARBITER_ALTERNATIVE current;
    ULONG defaultDecode;
    BOOLEAN improviseDecode = FALSE, windowDetected = FALSE;
    ULONGLONG greatestPort = 0;
    PCI_OBJECT_TYPE type;
    PPCI_PDO_EXTENSION pdoExtension;

    PAGED_CODE();

    if (State->WorkSpace & PORT_ARBITER_PREPROCESSED) {

        //
        // We have already proprocessed this entry so don't repeat the work
        //
        return STATUS_SUCCESS;

    } else {
        State->WorkSpace |= PORT_ARBITER_PREPROCESSED;
    }

    //
    // If this is a PnP arbitration request for a PCI PDO, make sure the PDO
    // isn't already controlled by a legacy driver.
    //
    if ((State->Entry->PhysicalDeviceObject->DriverObject == PciDriverObject) &&
        (State->Entry->RequestSource == ArbiterRequestPnpEnumerated)) {
        
        pdoExtension = (PPCI_PDO_EXTENSION)State->Entry->PhysicalDeviceObject->DeviceExtension;    
        ASSERT(pdoExtension->ExtensionType == PciPdoExtensionType);

        if (pdoExtension->LegacyDriver) {
            
            return STATUS_DEVICE_BUSY;
        }
    }

    

    //
    // Scan the alternatives and check if we have set any of the decode flags
    // are set or if we have to improvise
    //

    FOR_ALL_IN_ARRAY(State->Alternatives,
                     State->AlternativeCount,
                     current) {

        PCI_ASSERT(current->Descriptor->Type == CmResourceTypePort);
        PCI_ASSERT(current->Descriptor->Flags == State->Alternatives->Descriptor->Flags);

        //
        // Remember the greatest value we come across
        //

        if (current->Maximum > greatestPort) {
            greatestPort = current->Maximum;
        }

        //
        // Remember if we ever encounter a bridge window
        //

        if (current->Descriptor->Flags & CM_RESOURCE_PORT_WINDOW_DECODE) {
            //
            // If the request is marked with the window flag all alternatives
            // should also be marked with the window flag
            //
#if DBG
            if (current != State->Alternatives) {
                //
                // This is an alternative - make sure we have already set the
                // window detected flag
                //
                PCI_ASSERT(windowDetected);
            }
#endif
            windowDetected = TRUE;
        }

        if (!(current->Descriptor->Flags &
              (CM_RESOURCE_PORT_10_BIT_DECODE
               | CM_RESOURCE_PORT_12_BIT_DECODE
               | CM_RESOURCE_PORT_16_BIT_DECODE
               | CM_RESOURCE_PORT_POSITIVE_DECODE))) {

            improviseDecode = TRUE;

            // PCI_ASSERT(LEGACY_REQUEST(State->Entry->Source)

            if (!LEGACY_REQUEST(State->Entry)) {

                ARB_PRINT(0,
                          ("Pnp device (%p) did not specify decodes for IO ports\n",
                           State->Entry->PhysicalDeviceObject
                          ));


            }
        }
    }

    if (improviseDecode) {

        //
        // Remember we improvised this
        //

        State->WorkSpace |= PORT_ARBITER_IMPROVISED_DECODE;

        ARB_PRINT(1, ("Improvising decode "));

        //
        // Work out the default
        //

        switch (State->Entry->InterfaceType) {
        case PNPISABus:
        case Isa:

            //
            // if machine is NEC98, default decode is 16 bit.
            //

            if(IsNEC_98) {
                defaultDecode = CM_RESOURCE_PORT_16_BIT_DECODE;
                ARB_PRINT(1, ("of 16bit for NEC98 Isa\n"));
            } else {

                //
                // If any of the ports is greater than can be decoded in 10 bits
                // assume a 16 bit decode
                //
                if (greatestPort > MAX_10_BIT_DECODE) {
                    defaultDecode = CM_RESOURCE_PORT_16_BIT_DECODE;
                    ARB_PRINT(1, ("of 16bit for Isa with ports > 0x3FF\n"));
                } else {
                    defaultDecode = CM_RESOURCE_PORT_10_BIT_DECODE;
                    ARB_PRINT(1, ("of 10bit for Isa\n"));
                }
            }

            break;

        case Eisa:
        case MicroChannel:
        case PCMCIABus:
            ARB_PRINT(1, ("of 16bit for Eisa/MicroChannel/Pcmcia\n"));
            defaultDecode = CM_RESOURCE_PORT_16_BIT_DECODE;
            break;

        case PCIBus:
            ARB_PRINT(1, ("of positive for PCI\n"));
            defaultDecode = CM_RESOURCE_PORT_POSITIVE_DECODE;
            break;

        default:

            //
            // In NT < 5 we considered everything to be 16 bit decode so in the
            // absence of better information continue that tradition.
            //

            ARB_PRINT(1, ("of 16bit for unknown bus\n"));

            defaultDecode = CM_RESOURCE_PORT_16_BIT_DECODE;
            break;
        }

        //
        // Now set the flags
        //

        FOR_ALL_IN_ARRAY(State->Alternatives,
                         State->AlternativeCount,
                         current) {

                current->Descriptor->Flags |= defaultDecode;
        }

    } else {

        //
        // Even if we are not improvising decodes make sure that they didn't
        // report 10 bit decode for a range over 0x3FF - if so we assume 16 bit
        // decode - think EISA net cards that say they're ISA
        //

        FOR_ALL_IN_ARRAY(State->Alternatives,
                         State->AlternativeCount,
                         current) {

            if ((current->Descriptor->Flags & CM_RESOURCE_PORT_10_BIT_DECODE)
            &&  (greatestPort > MAX_10_BIT_DECODE )) {

                current->Descriptor->Flags &= ~CM_RESOURCE_PORT_10_BIT_DECODE;
                current->Descriptor->Flags |= CM_RESOURCE_PORT_16_BIT_DECODE;
            }
        }
    }

    //
    // If we detected a bridge window then check if the ISA bit is set on the bridge
    //

    if (windowDetected) {

        //
        // Make sure its a PCI bridge...
        //

        if (State->Entry->PhysicalDeviceObject->DriverObject != PciDriverObject) {
            PCI_ASSERT(State->Entry->PhysicalDeviceObject->DriverObject == PciDriverObject);
            return STATUS_INVALID_PARAMETER;
        }

        pdoExtension = (PPCI_PDO_EXTENSION) State->Entry->PhysicalDeviceObject->DeviceExtension;

        if (pdoExtension->ExtensionType != PciPdoExtensionType) {
            PCI_ASSERT(pdoExtension->ExtensionType == PciPdoExtensionType);
            return STATUS_INVALID_PARAMETER;
        }

        type = PciClassifyDeviceType(pdoExtension);

        if (type != PciTypePciBridge && type != PciTypeCardbusBridge) {
            PCI_ASSERT(type == PciTypePciBridge || type == PciTypeCardbusBridge);
            return STATUS_INVALID_PARAMETER;
        }

        if (pdoExtension->Dependent.type1.IsaBitSet) {

            if (type == PciTypePciBridge) {
                State->WorkSpace |= PORT_ARBITER_ISA_BIT_SET;
            } else {
                PCI_ASSERT(type == PciTypePciBridge);
            }
        }

        State->WorkSpace |= PORT_ARBITER_BRIDGE_WINDOW;
    }

    //
    // If this device is positive decode then we want the range to be added to
    // the list with the positive decode flag set
    //

    if (State->Alternatives->Descriptor->Flags & CM_RESOURCE_PORT_POSITIVE_DECODE) {
        State->RangeAttributes |= ARBITER_RANGE_POSITIVE_DECODE;
    }

    return STATUS_SUCCESS;
}

BOOLEAN
ario_FindWindowWithIsaBit(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )
{
    NTSTATUS status;
    ULONGLONG start, current;
    BOOLEAN available = FALSE;
    ULONG findRangeFlags = 0;

    //
    // We only support the ISA bit on Pci bridges
    //

    ASSERT_PCI_DEVICE_OBJECT(State->Entry->PhysicalDeviceObject);

    PCI_ASSERT(PciClassifyDeviceType(((PPCI_PDO_EXTENSION) State->Entry->PhysicalDeviceObject->DeviceExtension)
                                 ) == PciTypePciBridge);

    //
    // Bridges with windows perform positive decode and so can conflict with
    // aliases
    //

    PCI_ASSERT(State->CurrentAlternative->Descriptor->Flags & CM_RESOURCE_PORT_POSITIVE_DECODE);

    State->RangeAvailableAttributes |= ARBITER_RANGE_ALIAS;

    //
    // The request should be correctly aligned - we generated it!
    //

    PCI_ASSERT(State->CurrentAlternative->Length % State->CurrentAlternative->Alignment == 0);

    //
    // CurrentMinimum/CurrentMaximum should have been correctly aligned by
    // GetNextAllocationRange
    //

    PCI_ASSERT(State->CurrentMinimum % State->CurrentAlternative->Alignment == 0);
    PCI_ASSERT((State->CurrentMaximum + 1) % State->CurrentAlternative->Alignment == 0);

    //
    // Conflicts with NULL occur when our parents IO space is sparse, for
    // bridges that is if the ISA bit is set and so everything will line
    // up here.  If the root we are on is sparse then things arn't as easy.

    if (State->Flags & ARBITER_STATE_FLAG_NULL_CONFLICT_OK) {
        findRangeFlags |= RTL_RANGE_LIST_NULL_CONFLICT_OK;
    }

    //
    // ...or we are shareable...
    //

    if (State->CurrentAlternative->Flags & ARBITER_ALTERNATIVE_FLAG_SHARED) {
        findRangeFlags |= RTL_RANGE_LIST_SHARED_OK;
    }

    //
    // Check the length is reasonable
    //
    
    if (State->CurrentMaximum < (State->CurrentAlternative->Length + 1)) {
        return FALSE;
    }
    
    //
    // Iterate through the possible window positions, top down like the rest of
    // arbitration.
    //

    start = State->CurrentMaximum - State->CurrentAlternative->Length + 1;


    while (!available) {

        //
        // Check the range is within the constraints specified
        //

        if (start < State->CurrentMinimum) {
            break;
        }

        //
        // Check if the ISA windows are available we don't care about the rest
        // of the ranges are we don't decode them.
        //

        for (current = start;
             (current < (start + State->CurrentAlternative->Length - 1)) && (current < PCI_BRIDGE_ISA_BIT_MAX);
             current += PCI_BRIDGE_ISA_BIT_STRIDE) {

            status = RtlIsRangeAvailable(
                         Arbiter->PossibleAllocation,
                         current,
                         current + PCI_BRIDGE_ISA_BIT_WIDTH - 1,
                         findRangeFlags,
                         State->RangeAvailableAttributes,
                         Arbiter->ConflictCallbackContext,
                         Arbiter->ConflictCallback,
                         &available
                         );

            PCI_ASSERT(NT_SUCCESS(status));

            if (!available) {
                break;
            }
        }
    
        //
        // Now available indicates if all the ISA windows were available 
        //

        if (available) {

            State->Start = start;
            State->End = start + State->CurrentAlternative->Length - 1;

            PCI_ASSERT(State->Start >= State->CurrentMinimum);
            PCI_ASSERT(State->End <= State->CurrentMaximum);
            
            break;

        } else {
    
            //
            // Move to next range if we can
            //
    
            if (start < PCI_BRIDGE_WINDOW_GRANULARITY) {
                break;
            }

            start -= PCI_BRIDGE_WINDOW_GRANULARITY;    // IO windows are 1000 byte aligned
            continue;
        }
    }

    return available;

}

BOOLEAN
ario_FindSuitableRange(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )
/*++

Routine Description:

    This routine is called from AllocateEntry once we have decided where we want
    to allocate from.  It tries to find a free range that matches the
    requirements in State while restricting its possible solutions to the range
    State->Start to State->CurrentMaximum.  On success State->Start and
    State->End represent this range.  Conflicts with ISA aliases are considered.

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    TRUE if we found a range, FALSE otherwise.

--*/
{
    PPCI_PDO_EXTENSION parentPdo, childPdo;

    PAGED_CODE();

    //
    // Assume we won't be allowing null conflicts
    //

    State->Flags &= ~ARBITER_STATE_FLAG_NULL_CONFLICT_OK;

    //
    // Now check if we really wanted to allow them
    //

    if (State->WorkSpace & PORT_ARBITER_BRIDGE_WINDOW) {

        //
        // If this isn't a PCI PDO we already failed in PreprocessEntry but
        // paranoia reigns.
        //

        ASSERT_PCI_DEVICE_OBJECT(State->Entry->PhysicalDeviceObject);

        childPdo = (PPCI_PDO_EXTENSION) State->Entry->PhysicalDeviceObject->DeviceExtension;

        if (!PCI_PDO_ON_ROOT(childPdo)) {

            parentPdo = PCI_BRIDGE_PDO(PCI_PARENT_FDOX(childPdo));

            PCI_ASSERT(parentPdo);

        } else {

            parentPdo = NULL;
        }


        //
        // Check if this is a PCI-PCI bridge that the bios configured that
        // we have not moved or it is a root bus (which be definition was
        // bios configured ...
        //

        if ((parentPdo == NULL ||
             (parentPdo->HeaderType == PCI_BRIDGE_TYPE && !parentPdo->MovedDevice))
        &&  (State->CurrentAlternative->Flags & ARBITER_ALTERNATIVE_FLAG_FIXED)) {

            //
            // The BIOS configured and we have not moved its parent (thus
            // invalidating the bioses configuration) then we will leave well
            // alone.  We then allow the null conflicts and only configure the
            // arbiter to give out ranges that make it to this bus.
            //

            State->Flags |= ARBITER_STATE_FLAG_NULL_CONFLICT_OK;

        } else {

            //
            // If the BIOS didn't configure it then we need to find somewhere to
            // put the bridge. This will involve trying to find a contiguous 1000
            // port window and then if one is not available, examining all locations
            // to find the one with the most IO.
            //

            //
            // NTRAID #62581 - 04/03/2000 - andrewth
            // We are punting on this for Win2K, if 1000 contiguous ports
            // arn't available then we are not going to configure the bridge. A fix
            // for this will be required for hot plug to work. Setting the ISA bit 
            // on the bridge will increase the chances of configuring this
            //

        }

        //
        // Check if this is a window for a bridge with the ISA bit set in 16 bit IO
        // space.  If so we need to do some special processing...
        //

        if (State->WorkSpace & PORT_ARBITER_ISA_BIT_SET
        && State->CurrentMaximum <= 0xFFFF) {

            return ario_FindWindowWithIsaBit(Arbiter, State);
        }
    }

    //
    // For legacy requests from IoAssignResources (directly or by way of
    // HalAssignSlotResources) or IoReportResourceUsage we consider preallocated
    // resources to be available for backward compatibility reasons.
    //
    // If we are allocating a devices boot config then we consider all other
    // boot configs to be available.
    //

    if (State->Entry->RequestSource == ArbiterRequestLegacyReported
        || State->Entry->RequestSource == ArbiterRequestLegacyAssigned
        || State->Entry->Flags & ARBITER_FLAG_BOOT_CONFIG) {

        State->RangeAvailableAttributes |= ARBITER_RANGE_BOOT_ALLOCATED;
    }

    //
    // This request is for a device which performs positive decode so all
    // aliased ranges should be considered available
    //

    if (State->CurrentAlternative->Descriptor->Flags & CM_RESOURCE_PORT_POSITIVE_DECODE) {

        State->RangeAvailableAttributes |= ARBITER_RANGE_ALIAS;

    }

    while (State->CurrentMaximum >= State->CurrentMinimum) {

        //
        // Try to satisfy the request
        //

        if (ArbFindSuitableRange(Arbiter, State)) {

            if (State->CurrentAlternative->Length == 0) {

                ARB_PRINT(2,
                    ("Zero length solution solution for %p = 0x%I64x-0x%I64x, %s\n",
                    State->Entry->PhysicalDeviceObject,
                    State->Start,
                    State->End,
                    State->CurrentAlternative->Flags & ARBITER_ALTERNATIVE_FLAG_SHARED ?
                        "shared" : "non-shared"
                    ));

                //
                // Set the result in the arbiter appropriatley so that we
                // don't try and translate this zero requirement - it won't!
                //

                State->Entry->Result = ArbiterResultNullRequest;
                return TRUE;

            } else if (ario_IsAliasedRangeAvailable(Arbiter, State)) {

                //
                // We found a suitable range so return
                //

                return TRUE;

            } else {

                //
                // Check if we wrap on start - if so then we're finished.
                //

                if (State->Start - 1 > State->Start) {
                    break;
                }

                //
                // This range's aliases arn't available so reduce allocation
                // window to not include the range just returned and try again
                //

                State->CurrentMaximum = State->Start - 1;

                continue;
            }
        } else {

            //
            // We couldn't find a base range
            //

            break;
        }
    }

    return FALSE;
}

BOOLEAN
ario_GetNextAlias(
    ULONG IoDescriptorFlags,
    ULONGLONG LastAlias,
    PULONGLONG NextAlias
    )
/*++

Routine Description:

    This routine calculates the next alias of an IO port up to 0xFFFF.

Arguments:

    IoDescriptorFlags - The flags from the requirement descriptor indicating the
        type of alias if any.

    LastAlias - The alias previous to this one.

    NextAlias - Point to where the next alias should be returned

Return Value:

    TRUE if we found an alias, FALSE otherwise.

--*/

{
    ULONGLONG next;

    PAGED_CODE();

    if (IoDescriptorFlags & CM_RESOURCE_PORT_10_BIT_DECODE) {
        next = LastAlias + MAX_10_BIT_DECODE + 1;
    } else if (IoDescriptorFlags & CM_RESOURCE_PORT_12_BIT_DECODE) {
        next = LastAlias + MAX_12_BIT_DECODE + 1;
    } else if ((IoDescriptorFlags & CM_RESOURCE_PORT_POSITIVE_DECODE)
           ||  (IoDescriptorFlags & CM_RESOURCE_PORT_16_BIT_DECODE)) {
        //
        // Positive decode implies 16 bit decode unless 10 or 12 bit flags are set
        // There are no aliases as we decode all the bits... what a good idea
        //

        return FALSE;

    } else {
        //
        // None of the CM_RESOURCE_PORT_*_DECODE flags are set - we should never
        // get here as we should have set them in Preprocess
        //

        PCI_ASSERT(FALSE);
        return FALSE;

    }

    //
    // Check that we are below the maximum aliased port
    //

    if (next > 0xFFFF) {
        return FALSE;
    } else {
        *NextAlias = next;
        return TRUE;
    }
}

BOOLEAN
ario_IsAliasedRangeAvailable(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    )

/*++

Routine Description:

    This routine determines if the range (Start-(Length-1)) is available taking
    into account any aliases.

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    TRUE if the range is available, FALSE otherwise.

--*/

{
    NTSTATUS status;
    ULONGLONG alias = State->Start;
    BOOLEAN aliasAvailable;
    UCHAR userFlagsMask;

    PAGED_CODE();

    //
    // If we improvised the decode then add the aliases but don't care it they
    // conflict - more 4.0 compatibility.
    //

    if (State->WorkSpace & PORT_ARBITER_IMPROVISED_DECODE) {
        return TRUE;
    }

    //
    // Positive decode devices can conflict with aliases
    //
    userFlagsMask = ARBITER_RANGE_POSITIVE_DECODE;

    //
    // For legacy requests from IoAssignResources (directly or by way of
    // HalAssignSlotResources) or IoReportResourceUsage we consider preallocated
    // resources to be available for backward compatibility reasons.
    //
    if (State->Entry->RequestSource == ArbiterRequestLegacyReported
        || State->Entry->RequestSource == ArbiterRequestLegacyAssigned
        || State->Entry->Flags & ARBITER_FLAG_BOOT_CONFIG) {

        userFlagsMask |= ARBITER_RANGE_BOOT_ALLOCATED;
    }

    while (ario_GetNextAlias(State->CurrentAlternative->Descriptor->Flags,
                             alias,
                             &alias)) {

        status = RtlIsRangeAvailable(
                     Arbiter->PossibleAllocation,
                     alias,
                     alias + State->CurrentAlternative->Length - 1,
                     RTL_RANGE_LIST_NULL_CONFLICT_OK |
                        (State->CurrentAlternative->Flags & ARBITER_ALTERNATIVE_FLAG_SHARED ?
                            RTL_RANGE_LIST_SHARED_OK : 0),
                     userFlagsMask,
                     Arbiter->ConflictCallbackContext,
                     Arbiter->ConflictCallback,
                     &aliasAvailable
                     );

        PCI_ASSERT(NT_SUCCESS(status));

        if (!aliasAvailable) {

            ARBITER_ALLOCATION_STATE tempState;

            //
            // Check if we allow this conflict by calling OverrideConflict -
            // we will need to falsify ourselves an allocation state first
            //
            // NTRAID #62583 - 04/03/2000 - andrewth
            // This works but relies on knowing what OverrideConflict
            // looks at.  A better fix invloves storing the aliases in another
            // list but this it too much of a change for Win2k
            //

            RtlCopyMemory(&tempState, State, sizeof(ARBITER_ALLOCATION_STATE));

            tempState.CurrentMinimum = alias;
            tempState.CurrentMaximum = alias + State->CurrentAlternative->Length - 1;

            if (Arbiter->OverrideConflict(Arbiter, &tempState)) {
                //
                // We decided this conflict was ok so contine checking the rest
                // of the aliases
                //

                continue;

            }

            //
            // An alias isn't available - get another possibility
            //

            ARB_PRINT(2,
                                ("\t\tAlias 0x%x-0x%x not available\n",
                                alias,
                                alias + State->CurrentAlternative->Length - 1
                                ));

            return FALSE;
        }
    }

    return TRUE;
}

VOID
ario_AddAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )

/*++

Routine Description:

    This routine is called from AllocateEntry once we have found a possible
    solution (State->Start - State->End).  It adds the ranges that will not be
    available if we commit to this solution to Arbiter->PossibleAllocation.

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    None.

--*/

{

    PAGED_CODE();

    ario_AddOrBacktrackAllocation(Arbiter,
                                  State,
                                  ArbAddAllocation
                                  );

}

NTSTATUS
armem_PreprocessEntry(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )
{
    PARBITER_MEMORY_EXTENSION extension = Arbiter->Extension;
    PPCI_PDO_EXTENSION pdoExtension;
    BOOLEAN prefetchable;

    PAGED_CODE();
    PCI_ASSERT(extension);

    //
    // If this is a PnP arbitration request for a PCI PDO, make sure the PDO
    // isn't already controlled by a legacy driver.
    //
    if ((State->Entry->PhysicalDeviceObject->DriverObject == PciDriverObject) &&
        (State->Entry->RequestSource == ArbiterRequestPnpEnumerated)) {
        
        pdoExtension = (PPCI_PDO_EXTENSION)State->Entry->PhysicalDeviceObject->DeviceExtension;    
        ASSERT(pdoExtension->ExtensionType == PciPdoExtensionType);

        if (pdoExtension->LegacyDriver) {
            
            return STATUS_DEVICE_BUSY;
        }
    }

    //
    // Check if this is a request for a ROM - it must be a fixed request with
    // only 1 alternative and the ROM bit set
    //

    if ((State->Alternatives[0].Descriptor->Flags & CM_RESOURCE_MEMORY_READ_ONLY) ||
        ((State->Alternatives[0].Flags & ARBITER_ALTERNATIVE_FLAG_FIXED) &&
          State->AlternativeCount == 1 &&
          State->Entry->RequestSource == ArbiterRequestLegacyReported)) {

        if (State->Alternatives[0].Descriptor->Flags & CM_RESOURCE_MEMORY_READ_ONLY) {

            PCI_ASSERT(State->Alternatives[0].Flags & ARBITER_ALTERNATIVE_FLAG_FIXED);
//            PCI_ASSERT(State->AlternativeCount == 1);

        }

        //
        // Consider other ROMS to be available
        //

        State->RangeAvailableAttributes |= MEMORY_RANGE_ROM;

        //
        // Mark this range as a ROM
        //

        State->RangeAttributes |= MEMORY_RANGE_ROM;

        //
        // Allow NULL conflicts
        //

        State->Flags |= ARBITER_STATE_FLAG_NULL_CONFLICT_OK;

    }

    //
    // Check if this is a request for prefetchable memory and select
    // the correct ordering list
    //

    if (extension->PrefetchablePresent) {

#if IGNORE_PREFETCH_FOR_LEGACY_REPORTED
        //
        // In NT < 5 IoReportResourceUsage had no notion of prefetchable memory
        // so in order to be backward compatible we hope the BIOS/firmware got
        // it right!
        //

        if (State->Entry->RequestSource == ArbiterRequestLegacyReported) {
            Arbiter->OrderingList = extension->OriginalOrdering;
            return STATUS_SUCCESS;
        }
#endif

        prefetchable = BITS_SET(State->Alternatives[0].Descriptor->Flags,
                                CM_RESOURCE_MEMORY_PREFETCHABLE);

        if (prefetchable) {

            Arbiter->OrderingList = extension->PrefetchableOrdering;

        } else {

            Arbiter->OrderingList = extension->NonprefetchableOrdering;
        }

#if DBG

        {
            PARBITER_ALTERNATIVE current;

            //
            // Make sure that all the alternatives are of the same type
            //

            FOR_ALL_IN_ARRAY(State->Alternatives,
                             State->AlternativeCount,
                             current) {

                PCI_ASSERT(BITS_SET(current->Descriptor->Flags,CM_RESOURCE_MEMORY_PREFETCHABLE)
                            == prefetchable
                       );
            }
        }
#endif
    }

    return STATUS_SUCCESS;
}

BOOLEAN
armem_GetNextAllocationRange(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )
{
    PARBITER_MEMORY_EXTENSION extension = Arbiter->Extension;

    //
    // Call the default implementation
    //

    if (!ArbGetNextAllocationRange(Arbiter, State)) {
        return FALSE;
    }

    if (extension->PrefetchablePresent
    &&  State->Entry->RequestSource != ArbiterRequestLegacyReported) {

        //
        // We have already precalculated the reserved ranges into the ordering
        // so if we end up in the reserved ranges we're out of luck...
        //

        if (State->CurrentAlternative->Priority > ARBITER_PRIORITY_PREFERRED_RESERVED) {
            return FALSE;
        }

    }

    return TRUE;
}

NTSTATUS
armem_StartArbiter(
    IN PARBITER_INSTANCE Arbiter,
    IN PCM_RESOURCE_LIST StartResources
    )
/*++

   This is called after ArbInitializeArbiterInstance as it uses
   information initialized there.  The arbiter lock should be held.
   Seeing as this is only applicable to memory descriptors we maniulate
   the resource descriptors directlty as oppose to useing the pack/upack
   routines in the arbiter.

   Example:

    StartResources contain the prefetchable range 0xfff00000 - 0xfffeffff

    OriginalOrdering (from the registry) says:
        0x00100000 - 0xFFFFFFFF
        0x000F0000 - 0x000FFFFF
        0x00080000 - 0x000BFFFF
        0x00080000 - 0x000FFFFF
        0x00080000 - 0xFFBFFFFF

    ReservedList contains 0xfff0a000-0xfff0afff

    Then out ordering lists will be:

        PrefetchableOrdering            NonprefetchableOrdering

        0xFFF0B000 - 0xFFFEFFFF
        0xFFF00000 - 0xFFF09FFF
        0xFFFF0000 - 0xFFFFFFFF         0xFFF0b000 - 0xFFFFFFFF
        0x00100000 - 0xFFFEFFFF         0x00100000 - 0xFFF09FFF
        0x000F0000 - 0x000FFFFF         0x000F0000 - 0x000FFFFF
        0x00080000 - 0x000BFFFF         0x00080000 - 0x000BFFFF
        0x00080000 - 0x000FFFFF         0x00080000 - 0x000FFFFF

     This means that when following the prefetchable ordering we try to
     allocate in the prefetchable range and if we can't then we allocate
     none prefetchable memory.  In the Nonprefetchable ordering we avoid the
     prefetchable ranges. GetNextAllocationRange is changed so that it will not
     allow

--*/
{
    NTSTATUS status;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR current;
    PARBITER_MEMORY_EXTENSION extension = Arbiter->Extension;
    PARBITER_ORDERING currentOrdering;
    ULONGLONG start, end;
#if PCIFLAG_IGNORE_PREFETCHABLE_MEMORY_AT_ROOT_HACK
    PPCI_FDO_EXTENSION fdoExtension;
#endif

    PAGED_CODE();

    //
    // If this is the first time we have initialized the extension do some one
    // only initialization
    //

    if (!extension->Initialized) {

        //
        // Copy the default memory ordering list from the arbiter
        //

        extension->OriginalOrdering = Arbiter->OrderingList;
        RtlZeroMemory(&Arbiter->OrderingList, sizeof(ARBITER_ORDERING_LIST));

    } else {

        //
        // We are reinitializing the arbiter
        //

        if (extension->PrefetchablePresent) {
            //
            // We had prefetchable memory before so free the orderings we
            // created last time.
            //

            ArbFreeOrderingList(&extension->PrefetchableOrdering);
            ArbFreeOrderingList(&extension->NonprefetchableOrdering);

        }

    }

    extension->PrefetchablePresent = FALSE;
    extension->PrefetchableCount = 0;

    if (StartResources != NULL) {

        PCI_ASSERT(StartResources->Count == 1);

        //
        // Check if we have any prefetchable memory - if not we're done
        //

            FOR_ALL_IN_ARRAY(StartResources->List[0].PartialResourceList.PartialDescriptors,
                        StartResources->List[0].PartialResourceList.Count,
                        current) {

                if ((current->Type == CmResourceTypeMemory)
            &&  (current->Flags & CM_RESOURCE_MEMORY_PREFETCHABLE)) {
                extension->PrefetchablePresent = TRUE;
                break;
            }
        }
    }

#if PCIFLAG_IGNORE_PREFETCHABLE_MEMORY_AT_ROOT_HACK

    if (PciSystemWideHackFlags&PCIFLAG_IGNORE_PREFETCHABLE_MEMORY_AT_ROOT_HACK) {

        fdoExtension = (PPCI_FDO_EXTENSION) Arbiter->BusDeviceObject->DeviceExtension;

        ASSERT_PCI_FDO_EXTENSION(fdoExtension);

        if (PCI_IS_ROOT_FDO(fdoExtension)) {

            extension->PrefetchablePresent = FALSE;
        }
    }
#endif

    if (!extension->PrefetchablePresent) {

        //
        // Restore the original ordering list
        //

        Arbiter->OrderingList = extension->OriginalOrdering;
        return STATUS_SUCCESS;
    }

    status = ArbInitializeOrderingList(&extension->PrefetchableOrdering);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Copy of the original ordering into the new Nonprefetchable ordering
    //

    status = ArbCopyOrderingList(&extension->NonprefetchableOrdering,
                                 &extension->OriginalOrdering
                                 );
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Add the range 0-MAXULONGLONG to the list so we will calculate the reserved
    // orderings in the list.  This will ensure that we don't give a half
    // prefetchable and half not range to a device.  Prefetchable devices should
    //  probably be able to deal with this but its asking for trouble!
    //
    status = ArbAddOrdering(&extension->NonprefetchableOrdering,
                            0,
                            MAXULONGLONG
                            );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // For each prefetchable range delete it from the nonprefetchabe ordering
    // and add it to the prefetchable one.
    //
    // NB - We take it "to be self evident that that all prefetchable memory is
    // created equal" and therefore initialize the ordering list in the order
    // the prefetchable memory desciptors are found in the resource list.
    //

    FOR_ALL_IN_ARRAY(StartResources->List[0].PartialResourceList.PartialDescriptors,
                     StartResources->List[0].PartialResourceList.Count,
                     current) {

        if ((current->Type == CmResourceTypeMemory)
        &&  (current->Flags & CM_RESOURCE_MEMORY_PREFETCHABLE)) {

            extension->PrefetchableCount++;

            start = current->u.Memory.Start.QuadPart,
            end = current->u.Memory.Start.QuadPart + current->u.Memory.Length - 1;

            //
            // Add to the prefetchable ordering
            //

            status = ArbAddOrdering(&extension->PrefetchableOrdering,
                                    start,
                                    end
                                    );

            if (!NT_SUCCESS(status)) {
                goto cleanup;
            }

            //
            // And prune it from the Nonprefetchable ordering
            //

            status = ArbPruneOrdering(&extension->NonprefetchableOrdering, start, end);

            if (!NT_SUCCESS(status)) {
                goto cleanup;
            }

            ARB_PRINT(1,("Processed prefetchable range 0x%I64x-0x%I64x\n",
                        start,
                        end
                      ));

        }
    }

    //
    // Now prune out any explicitly reserved ranges from our new prefetchable
    // ordering - these have already been precalculated into the Nonprefetchable
    // ordering
    //

    FOR_ALL_IN_ARRAY(Arbiter->ReservedList.Orderings,
                     Arbiter->ReservedList.Count,
                     currentOrdering) {

        status = ArbPruneOrdering(&extension->PrefetchableOrdering,
                                  currentOrdering->Start,
                                  currentOrdering->End
                                  );

        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

    }

    //
    // Finally append the Nonprefetchable ordering onto the end of the prefetchable
    //

    FOR_ALL_IN_ARRAY(extension->NonprefetchableOrdering.Orderings,
                     extension->NonprefetchableOrdering.Count,
                     currentOrdering) {

        status = ArbAddOrdering(&extension->PrefetchableOrdering,
                                currentOrdering->Start,
                                currentOrdering->End
                               );

        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

    }

    extension->Initialized = TRUE;

    return STATUS_SUCCESS;

cleanup:

    return status;

}

BOOLEAN
ario_IsBridge(
    IN PDEVICE_OBJECT Pdo
    )

/*++

Routine Description:

    Determines if this device is a PCI enumberated PCI-PCI or Cardbus bridge

Arguments:

    Pdo - The Pdo representing the device in question

Return Value:

    TRUE if this Pdo is for a bridge

--*/


{
    PSINGLE_LIST_ENTRY nextEntry;
    PPCI_FDO_EXTENSION fdoExtension;
    PCI_OBJECT_TYPE type;

    PAGED_CODE();

    //
    // First of all see if this is a PCI FDO by walking the list of all our FDOs
    //

    for ( nextEntry = PciFdoExtensionListHead.Next;
          nextEntry != NULL;
          nextEntry = nextEntry->Next ) {

        fdoExtension = CONTAINING_RECORD(nextEntry,
                                         PCI_FDO_EXTENSION,
                                         List);

        if (fdoExtension->PhysicalDeviceObject == Pdo) {

            //
            // Ok this is our FDO so we can look at it and see if it is a
            // PCI-PCI or Cardbus bridge
            //

            type = PciClassifyDeviceType(Pdo->DeviceExtension);

            if (type == PciTypePciBridge || type == PciTypeCardbusBridge) {
                return TRUE;

            }
        }
    }

    return FALSE;
}

BOOLEAN
ario_OverrideConflict(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )

/*++

Routine Description:

    This is the default implementation of override conflict which

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    TRUE if the conflict is allowable, false otherwise

--*/

{

    PRTL_RANGE current;
    RTL_RANGE_LIST_ITERATOR iterator;
    BOOLEAN ok = FALSE;

    PAGED_CODE();

    if (!(State->CurrentAlternative->Flags & ARBITER_ALTERNATIVE_FLAG_FIXED)) {
        return FALSE;
    }

    FOR_ALL_RANGES(Arbiter->PossibleAllocation, &iterator, current) {

        //
        // Only test the overlapping ones
        //

        if (INTERSECT(current->Start, current->End, State->CurrentMinimum, State->CurrentMaximum)) {

            if (current->Attributes & State->RangeAvailableAttributes) {

                //
                // We DON'T set ok to true because we are just ignoring the range,
                // as RtlFindRange would have and thus it can't be the cause of
                // RtlFindRange failing, so ignoring it can't fix the conflict.
                //

                continue;
            }

            //
            // Check if we are conflicting with ourselves and the conflicting
            // range is a fixed requirement
            //

            if (current->Owner == State->Entry->PhysicalDeviceObject
            &&  State->CurrentAlternative->Flags & ARBITER_ALTERNATIVE_FLAG_FIXED) {

                ARB_PRINT(1,
                    ("PnP Warning: Device reported self-conflicting requirement\n"
                    ));

                State->Start=State->CurrentMinimum;
                State->End=State->CurrentMaximum;

                ok = TRUE;
                continue;
            }

            //
            // If the passive decode flag is set and we conflict with a bridge then
            // allow the conflict.  We also allow the conflict if the range never
            // makes it onto the bus (Owner == NULL)
            //
            // NTRAID #62584 - 04/03/2000 - andrewth
            // Once the PCI bridge code is in we need to ensure that we
            // don't put anything into the ranges that are being passively decoded
            //

            if (State->CurrentAlternative->Descriptor->Flags & CM_RESOURCE_PORT_PASSIVE_DECODE
            && (ario_IsBridge(current->Owner) || current->Owner == NULL)) {

                State->Start=State->CurrentMinimum;
                State->End=State->CurrentMaximum;

                ok = TRUE;
                continue;

            }
            //
            // The conflict is still valid
            //

            return FALSE;
        }
    }
    return ok;
}

VOID
ario_ApplyBrokenVideoHack(
    IN PPCI_FDO_EXTENSION FdoExtension
    )
{
    NTSTATUS status;
    PPCI_ARBITER_INSTANCE pciArbiter;
    PARBITER_INSTANCE arbiter;

    PCI_ASSERT(!FdoExtension->BrokenVideoHackApplied);
    PCI_ASSERT(PCI_IS_ROOT_FDO(FdoExtension));

    //
    // Find the arbiter - we should always have one for a root bus.
    //

    pciArbiter = PciFindSecondaryExtension(FdoExtension, PciArb_Io);

    PCI_ASSERT(pciArbiter);

    arbiter = &pciArbiter->CommonInstance;

    //
    // We are reinitializing the orderings free the old ones
    //

    ArbFreeOrderingList(&arbiter->OrderingList);
    ArbFreeOrderingList(&arbiter->ReservedList);

    //
    // Rebuild the ordering list reserving all the places these broken S3 and
    // ATI cards might want to live - this should not fail.
    //

    status = ArbBuildAssignmentOrdering(arbiter,
                                        L"Pci",
                                        L"BrokenVideo",
                                        NULL
                                        );

    PCI_ASSERT(NT_SUCCESS(status));

    FdoExtension->BrokenVideoHackApplied = TRUE;

}


BOOLEAN
ario_GetNextAllocationRange(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )
{
    BOOLEAN rangeFound, doIsaBit;
    ARBITER_ORDERING_LIST savedOrderingList = {0};

    //
    // If this is a bridge with the ISA bit set use the bridge ordering list
    //

    doIsaBit = BITS_SET(State->WorkSpace,
                        PORT_ARBITER_BRIDGE_WINDOW | PORT_ARBITER_ISA_BIT_SET);


    if (doIsaBit) {
        savedOrderingList = Arbiter->OrderingList;
        Arbiter->OrderingList = PciBridgeOrderingList;
    }

    //
    // Call the base function
    //

    rangeFound = ArbGetNextAllocationRange(Arbiter, State);

    if (doIsaBit) {

        //
        // If we have reached preferred reserved priority then we fail as we
        // have already considered both the 16 and 32 bit IO cases and using
        // the reserved may allow us to stradle the boundry.
        //

        if (rangeFound
        && State->CurrentAlternative->Priority > ARBITER_PRIORITY_PREFERRED_RESERVED) {
            rangeFound = FALSE;
        }

        Arbiter->OrderingList = savedOrderingList;
    }

    return rangeFound;

}


NTSTATUS
ario_StartArbiter(
    IN PARBITER_INSTANCE Arbiter,
    IN PCM_RESOURCE_LIST StartResources
    )
{
    NTSTATUS status;
    PPCI_FDO_EXTENSION fdoExtension;
    PPCI_PDO_EXTENSION pdoExtension = NULL;
    PRTL_RANGE_LIST exclusionList = NULL;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor;
    PPCI_FDO_EXTENSION rootFdo;
    PPCI_ARBITER_INSTANCE pciArbiter;
    BOOLEAN foundResource;
    ULONGLONG dummy;

    ArbAcquireArbiterLock(Arbiter);

    fdoExtension = (PPCI_FDO_EXTENSION) Arbiter->BusDeviceObject->DeviceExtension;

    ASSERT_PCI_FDO_EXTENSION(fdoExtension);

    if (StartResources == NULL || PCI_IS_ROOT_FDO(fdoExtension)) {
        //
        // Root bridges don't have ISA bits - at least that we can see...
        // Bridges with no resources also arn't effected by the ISA bit
        //
        status = STATUS_SUCCESS;
        goto exit;
    }

    PCI_ASSERT(StartResources->Count == 1);

    pdoExtension = PCI_BRIDGE_PDO(fdoExtension);

    //
    // Select the appropriate exclusion list
    //

    if (pdoExtension->Dependent.type1.IsaBitSet) {
        if (pdoExtension->Dependent.type1.VgaBitSet) {
            exclusionList = &PciVgaAndIsaBitExclusionList;
        } else {
            exclusionList = &PciIsaBitExclusionList;
        }
    }

    //
    // Find the port window and process it if the ISA bit is set
    //

    foundResource = FALSE;

    FOR_ALL_IN_ARRAY(StartResources->List[0].PartialResourceList.PartialDescriptors,
                     StartResources->List[0].PartialResourceList.Count,
                     descriptor) {

        //
        // NTRAID #62585 - 04/03/2000 - andrewth
        // Again we don't deal with bridges with BARS - for now assume
        // that the first IO descriptor we encounter is for the window
        //

        if (descriptor->Type == CmResourceTypePort) {

            if (exclusionList) {
                status = PciExcludeRangesFromWindow(
                             descriptor->u.Port.Start.QuadPart,
                             descriptor->u.Port.Start.QuadPart
                                + descriptor->u.Port.Length - 1,
                             Arbiter->Allocation,
                             exclusionList
                             );

                if (!NT_SUCCESS(status)) {
                    return status;
                }
            }

            foundResource = TRUE;
            break;
        }
    }

    if (foundResource == FALSE) {

        //
        // There are no IO resourcres on this bus so don't try
        // to handle the sparse root case.
        //

        status = STATUS_SUCCESS;
        goto exit;
    }

    //
    // Now deal with sparse root busses
    //

    rootFdo = PCI_ROOT_FDOX(fdoExtension);

    //
    // Find the root FDO's arbiter
    //

    pciArbiter = PciFindSecondaryExtension(rootFdo, PciArb_Io);

    if (!pciArbiter) {
        status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    //
    // Use it as the exclusion list for this arbiter
    //

    ArbAcquireArbiterLock(&pciArbiter->CommonInstance);

    status = PciExcludeRangesFromWindow(
                descriptor->u.Port.Start.QuadPart,
                descriptor->u.Port.Start.QuadPart
                   + descriptor->u.Port.Length - 1,
                Arbiter->Allocation,
                pciArbiter->CommonInstance.Allocation
                );

    ArbReleaseArbiterLock(&pciArbiter->CommonInstance);

    //
    // Sanity check this to make sure that at least one port is available - if
    // not then fail start.  You could argue that we should really have this
    // marked as insufficient resources (code 12) as oppose to failed start
    // (code 10) but that is much harder and this has the desired effect.
    // We check by seeing if we can find a range for the minimal PCI requirements
    // of 4 ports alignment 4.
    //

    status = RtlFindRange(Arbiter->Allocation,
                          0,
                          MAXULONGLONG,
                          4,
                          4,
                          0,     // Flags
                          0,     // AttribureAvailableMask
                          NULL,  // Context
                          NULL,  // Callback
                          &dummy
                          );

    if (!NT_SUCCESS(status)) {
        //
        // We can't start this bridge
        //
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

exit:

    ArbReleaseArbiterLock(Arbiter);

    return status;
}

BOOLEAN
armem_FindSuitableRange(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    )
/*++

Routine Description:

    This routine is called from AllocateEntry once we have decided where we want
    to allocate from.  It tries to find a free range that matches the
    requirements in State while restricting its possible solutions to the range
    State->Start to State->CurrentMaximum.  On success State->Start and
    State->End represent this range.  Conflicts between boot configs are allowed

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    TRUE if we found a range, FALSE otherwise.

--*/
{
    //
    // If this was a boot config then consider other boot configs to be
    // available
    //

    if (State->Entry->Flags & ARBITER_FLAG_BOOT_CONFIG) {
        State->RangeAvailableAttributes |= ARBITER_RANGE_BOOT_ALLOCATED;
    }

    //
    // Do the default thing
    //

    return ArbFindSuitableRange(Arbiter, State);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\busintrf.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    busintrf.c

Abstract:

    This module implements the "bus handler" interfaces supported
    by the PCI driver.

Author:

    Peter Johnston (peterj)  6-Jun-1997

Revision History:

--*/

#include "pcip.h"

#define BUSINTRF_VERSION 1

//
// Prototypes for routines exposed only thru the "interface"
// mechanism.
//

NTSTATUS
busintrf_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    );

VOID
busintrf_Reference(
    IN PVOID Context
    );

VOID
busintrf_Dereference(
    IN PVOID Context
    );

NTSTATUS
busintrf_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    );

BOOLEAN
PciPnpTranslateBusAddress(
    IN PVOID Context,
    IN PHYSICAL_ADDRESS BusAddress,
    IN ULONG Length,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

struct _DMA_ADAPTER *
PciPnpGetDmaAdapter(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    );

ULONG
PciPnpReadConfig(
    IN PVOID Context,
    IN ULONG WhichSpace,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
PciPnpWriteConfig(
    IN PVOID Context,
    IN ULONG WhichSpace,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

//
// Define the Bus Interface "Interface" structure.
//

PCI_INTERFACE BusHandlerInterface = {
    &GUID_BUS_INTERFACE_STANDARD,           // InterfaceType
    sizeof(BUS_INTERFACE_STANDARD),         // MinSize
    BUSINTRF_VERSION,                       // MinVersion
    BUSINTRF_VERSION,                       // MaxVersion
    PCIIF_PDO,                              // Flags
    0,                                      // ReferenceCount
    PciInterface_BusHandler,                // Signature
    busintrf_Constructor,                   // Constructor
    busintrf_Initializer                    // Instance Initializer
};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, busintrf_Constructor)
#pragma alloc_text(PAGE, busintrf_Dereference)
#pragma alloc_text(PAGE, busintrf_Initializer)
#pragma alloc_text(PAGE, busintrf_Reference)
#pragma alloc_text(PAGE, PciPnpTranslateBusAddress)
#pragma alloc_text(PAGE, PciPnpGetDmaAdapter)
#endif

VOID
busintrf_Reference(
    IN PVOID Context
    )
{
    PPCI_PDO_EXTENSION pdoExtension = (PPCI_PDO_EXTENSION)Context;

    ASSERT_PCI_PDO_EXTENSION(pdoExtension);

    InterlockedIncrement(&pdoExtension->BusInterfaceReferenceCount);
}

VOID
busintrf_Dereference(
    IN PVOID Context
    )
{
    PPCI_PDO_EXTENSION pdoExtension = (PPCI_PDO_EXTENSION)Context;

    ASSERT_PCI_PDO_EXTENSION(pdoExtension);

    InterlockedDecrement(&pdoExtension->BusInterfaceReferenceCount);
}


NTSTATUS
busintrf_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    )

/*++

Routine Description:

    Initialize the BUS_INTERFACE_STANDARD fields.

Arguments:

    PciInterface    Pointer to the PciInterface record for this
                    interface type.
    InterfaceSpecificData
                    A ULONG containing the resource type for which
                    arbitration is required.
    InterfaceReturn

Return Value:

    TRUE is this device is not known to cause problems, FALSE
    if the device should be skipped altogether.

--*/

{
    PBUS_INTERFACE_STANDARD standard = (PBUS_INTERFACE_STANDARD)InterfaceReturn;

                    
    standard->Size = sizeof( BUS_INTERFACE_STANDARD );
    standard->Version = BUSINTRF_VERSION;
    standard->Context = DeviceExtension;
    standard->InterfaceReference = busintrf_Reference;
    standard->InterfaceDereference = busintrf_Dereference;
    standard->TranslateBusAddress = PciPnpTranslateBusAddress;
    standard->GetDmaAdapter = PciPnpGetDmaAdapter;
    standard->SetBusData = PciPnpWriteConfig;
    standard->GetBusData = PciPnpReadConfig;

    return STATUS_SUCCESS;
}

NTSTATUS
busintrf_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    )

/*++

Routine Description:

    For bus interface, does nothing, shouldn't actually be called.

Arguments:

    Instance        Pointer to the PDO extension.

Return Value:

    Returns the status of this operation.

--*/

{
        
    PCI_ASSERTMSG("PCI busintrf_Initializer, unexpected call.", 0);

    return STATUS_UNSUCCESSFUL;
}

BOOLEAN
PciPnpTranslateBusAddress(
    IN PVOID Context,
    IN PHYSICAL_ADDRESS BusAddress,
    IN ULONG Length,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )
/*++

Routine Description:

    This function is used to translate bus addresses from legacy drivers.

Arguments:

    Context - Supplies a pointer to the interface context.  This is actually
        the PDO for the root bus.

    BusAddress - Supplies the orginal address to be translated.

    Length - Supplies the length of the range to be translated.

    AddressSpace - Points to the location of of the address space type such as
        memory or I/O port.  This value is updated by the translation.

    TranslatedAddress - Returns the translated address.

Return Value:

    Returns a boolean indicating if the operations was a success.

--*/
{
    PPCI_PDO_EXTENSION pdoExtension = (PPCI_PDO_EXTENSION)Context;
    
    
    PAGED_CODE();

    ASSERT_PCI_PDO_EXTENSION(pdoExtension);

    return HalTranslateBusAddress(PCIBus,
                                  PCI_PARENT_FDOX(pdoExtension)->BaseBus,
                                  BusAddress,
                                  AddressSpace,
                                  TranslatedAddress);
}

ULONG
PciPnpReadConfig(
    IN PVOID Context,
    IN ULONG WhichSpace,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    This function reads the PCI configuration space.

Arguments:

    Context - Supplies a pointer to the interface context.  This is actually
        the PDO for the root bus.

    Buffer - Supplies a pointer to where the data should be placed.

    Offset - Indicates the offset into the data where the reading should begin.

    Length - Indicates the count of bytes which should be read.

Return Value:

    Returns the number of bytes read.

--*/
{
    PPCI_PDO_EXTENSION pdoExtension = (PPCI_PDO_EXTENSION)Context;
    ULONG lengthRead;

    ASSERT_PCI_PDO_EXTENSION(pdoExtension);

    PciReadDeviceSpace(pdoExtension,
                      WhichSpace,
                      Buffer,
                      Offset,
                      Length,
                      &lengthRead
                      );
    
    return lengthRead;
}

ULONG
PciPnpWriteConfig(
    IN PVOID Context,
    IN ULONG WhichSpace,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    This function writes the PCI configuration space.

Arguments:

    Context - Supplies a pointer  to the interface context.  This is actually
        the PDO for the root bus.

    Buffer - Supplies a pointer to where the data to be written is.

    Offset - Indicates the offset into the data where the writing should begin.

    Length - Indicates the count of bytes which should be written.

Return Value:

    Returns the number of bytes read.

--*/
{
    PPCI_PDO_EXTENSION pdoExtension = (PPCI_PDO_EXTENSION)Context;
    ULONG lengthWritten;

    ASSERT_PCI_PDO_EXTENSION(pdoExtension);

    PciWriteDeviceSpace(pdoExtension,
                        WhichSpace,
                        Buffer,
                        Offset,
                        Length,
                        &lengthWritten
                        );
    
    return lengthWritten;
}

PDMA_ADAPTER
PciPnpGetDmaAdapter(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    )
/*++

Routine Description:

    This function writes the PCI configuration space.

Arguments:

    Context - Supplies a pointer  to the interface context.  This is actually
        the PDO for the root bus.

    DeviceDescriptor - Supplies the device descriptor used to allocate the dma
        adapter object.

    NubmerOfMapRegisters - Returns the maximum number of map registers a device
        can allocate at one time.

Return Value:

    Returns a DMA adapter or NULL.

--*/
{
    PPCI_PDO_EXTENSION pdoExtension = (PPCI_PDO_EXTENSION)Context;

    PAGED_CODE();

    ASSERT_PCI_PDO_EXTENSION(pdoExtension);

    //
    // If this is DMA on a PCI bus update the bus number, otherwise leave well
    // alone
    //

    if (DeviceDescriptor->InterfaceType == PCIBus) {
        DeviceDescriptor->BusNumber = PCI_PARENT_FDOX(pdoExtension)->BaseBus;
    }

    return IoGetDmaAdapter(
               pdoExtension->ParentFdoExtension->PhysicalDeviceObject,
               DeviceDescriptor,
               NumberOfMapRegisters);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\utils.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    This module contains utility functions for the pcmcia driver

Authors:

    Bob Rinne (BobRi) 3-Aug-1994
    Jeff McLeman 12-Apr-1994
    Ravisankar Pudipeddi (ravisp) 1-Nov-96
    Neil Sandlin (neilsa) June 1 1999

Environment:

    Kernel mode

Revision History :
    6-Apr-95
         Modified for databook support - John Keys Databook
    1-Nov-96
         Total overhaul to make this a bus enumerator - Ravisankar Pudipeddi (ravisp)
    30-Mar-99
         Turn this module into really just utility routines

--*/

#include "pch.h"


#pragma alloc_text(PAGE, PcmciaReportControllerError)

//
// Internal References
//

NTSTATUS
PcmciaAdapterIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT pdoIoCompletedEvent
    );

//
//
//



NTSTATUS
PcmciaIoCallDriverSynchronous(
    PDEVICE_OBJECT deviceObject,
    PIRP Irp
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    NTSTATUS status;
    KEVENT event;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(
                                 Irp,
                                 PcmciaAdapterIoCompletion,
                                 &event,
                                 TRUE,
                                 TRUE,
                                 TRUE
                                 );

    status = IoCallDriver(deviceObject, Irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    return status;
}



NTSTATUS
PcmciaAdapterIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT pdoIoCompletedEvent
    )
/*++

Routine Description:

     Generic completion routine used by the driver

Arguments:

     DeviceObject
     Irp
     pdoIoCompletedEvent - this event will be signalled before return of this routine

Return value:

     Status

--*/
{
    KeSetEvent(pdoIoCompletedEvent, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


VOID
PcmciaWait(
    IN ULONG MicroSeconds
    )

/*++
Routine Description

     Waits for the specified interval before returning,
     by yielding execution.

Arguments

     MicroSeconds -  Amount of time to delay in microseconds

Return Value

     None. Must succeed.

--*/
{
    LARGE_INTEGER   dueTime;
    NTSTATUS status;


    if ((KeGetCurrentIrql() < DISPATCH_LEVEL) && (MicroSeconds > 50)) {
        //
        // Convert delay to 100-nanosecond intervals
        //
        dueTime.QuadPart = -((LONG) MicroSeconds*10);

        //
        // We wait for an event that'll never be set.
        //
        status = KeWaitForSingleObject(&PcmciaDelayTimerEvent,
                                                 Executive,
                                                 KernelMode,
                                                 FALSE,
                                                 &dueTime);

        ASSERT(status == STATUS_TIMEOUT);
    } else {
        KeStallExecutionProcessor(MicroSeconds);
    }
}



ULONG
PcmciaCountOnes(
    IN ULONG Data
    )
/*++

Routine Description:

    Counts the number of 1's in the binary representation of the supplied argument

Arguments:

    Data - supplied argument for which 1's need to be counted

Return value:

    Number of 1's in binary rep. of Data

--*/
{
    ULONG count=0;
    while (Data) {
        Data &= (Data-1);
        count++;
    }
    return count;
}


VOID
PcmciaLogError(
    IN PFDO_EXTENSION DeviceExtension,
    IN ULONG ErrorCode,
    IN ULONG UniqueId,
    IN ULONG Argument
    )

/*++

Routine Description:

     This function logs an error.

Arguments:

     DeviceExtension - Supplies a pointer to the port device extension.
     ErrorCode - Supplies the error code for this error.
     UniqueId - Supplies the UniqueId for this error.

Return Value:

     None.

--*/

{
    PIO_ERROR_LOG_PACKET packet;

    packet = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(DeviceExtension->DeviceObject,
                                                                              sizeof(IO_ERROR_LOG_PACKET) + sizeof(ULONG));

    if (packet) {
        packet->ErrorCode = ErrorCode;
        packet->SequenceNumber = DeviceExtension->SequenceNumber++;
        packet->MajorFunctionCode = 0;
        packet->RetryCount = (UCHAR) 0;
        packet->UniqueErrorValue = UniqueId;
        packet->FinalStatus = STATUS_SUCCESS;
        packet->DumpDataSize = sizeof(ULONG);
        packet->DumpData[0] = Argument;

        IoWriteErrorLogEntry(packet);
    }
}


VOID
PcmciaLogErrorWithStrings(
    IN PFDO_EXTENSION DeviceExtension,
    IN ULONG                ErrorCode,
    IN ULONG                UniqueId,
    IN PUNICODE_STRING  String1,
    IN PUNICODE_STRING  String2
    )

/*++

Routine Description

     This function logs an error and includes the strings provided.

Arguments:

     DeviceExtension - Supplies a pointer to the port device extension.
     ErrorCode - Supplies the error code for this error.
     UniqueId - Supplies the UniqueId for this error.
     String1 - The first string to be inserted.
     String2 - The second string to be inserted.

Return Value:

     None.

--*/

{
    ULONG                   length;
    PCHAR                   dumpData;
    PIO_ERROR_LOG_PACKET packet;

    length = String1->Length + sizeof(IO_ERROR_LOG_PACKET) + 4;

    if (String2) {
        length += String2->Length;
    }

    if (length > ERROR_LOG_MAXIMUM_SIZE) {

        //
        // Don't have code to truncate strings so don't log this.
        //

        return;
    }

    packet = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(DeviceExtension->DeviceObject,
                                                                              (UCHAR) length);
    if (packet) {
        packet->ErrorCode = ErrorCode;
        packet->SequenceNumber = DeviceExtension->SequenceNumber++;
        packet->MajorFunctionCode = 0;
        packet->RetryCount = (UCHAR) 0;
        packet->UniqueErrorValue = UniqueId;
        packet->FinalStatus = STATUS_SUCCESS;
        packet->NumberOfStrings = 1;
        packet->StringOffset = (USHORT) ((PUCHAR)&packet->DumpData[0] - (PUCHAR)packet);
        packet->DumpDataSize = (USHORT) (length - sizeof(IO_ERROR_LOG_PACKET));
        packet->DumpDataSize /= sizeof(ULONG);
        dumpData = (PUCHAR) &packet->DumpData[0];

        RtlCopyMemory(dumpData, String1->Buffer, String1->Length);

        dumpData += String1->Length;
        if (String2) {
            *dumpData++ = '\\';
            *dumpData++ = '\0';

            RtlCopyMemory(dumpData, String2->Buffer, String2->Length);
            dumpData += String2->Length;
        }
        *dumpData++ = '\0';
        *dumpData++ = '\0';

        IoWriteErrorLogEntry(packet);
    }

    return;
}



BOOLEAN
PcmciaReportControllerError(
    IN PFDO_EXTENSION FdoExtension,
    NTSTATUS ErrorCode
    )
/*++
Routine Description

     Causes a pop-up dialog to appear indicating an error that
     we should tell the user about. The device description of the
     controller is also included in the text of the pop-up.

Arguments

     FdoExtension - Pointer to device extension for pcmcia controller
     ErrorCode    - the ntstatus code for the error

Return Value

     TRUE   -    If a an error was queued
     FALSE  -    If it failed for some reason

--*/
{
     UNICODE_STRING unicodeString;
     PWSTR  deviceDesc = NULL;
     NTSTATUS status;
     ULONG  length = 0;
     BOOLEAN retVal;

     PAGED_CODE();

     //
     // Obtain the device description for the PCMCIA controller
     // that is used in the error pop-up. If one cannot be obtained,
     // still pop-up the error dialog, indicating the controller as unknown
     //

     // First, find out the length of the buffer required to obtain
     // device description for this pcmcia controller
     //
     status = IoGetDeviceProperty(FdoExtension->Pdo,
                                            DevicePropertyDeviceDescription,
                                            0,
                                            NULL,
                                            &length
                                          );
     ASSERT(!NT_SUCCESS(status));

     if (status == STATUS_BUFFER_TOO_SMALL) {
            deviceDesc = ExAllocatePool(PagedPool, length);
            if (deviceDesc != NULL) {
                status = IoGetDeviceProperty(FdoExtension->Pdo,
                                                      DevicePropertyDeviceDescription,
                                                      length,
                                                      deviceDesc,
                                                      &length);
                if (!NT_SUCCESS(status)) {
                     ExFreePool(deviceDesc);
                }
            } else {
              status = STATUS_INSUFFICIENT_RESOURCES;
            }
     }

     if (!NT_SUCCESS(status)) {
          deviceDesc = L"[unknown]";
     }

     RtlInitUnicodeString(&unicodeString, deviceDesc);

     retVal =  IoRaiseInformationalHardError(
                                          ErrorCode,
                                          &unicodeString,
                                          NULL);

     //
     // Note: successful status here indicates success of
     // IoGetDeviceProperty above. This would mean we still have an
     // allocated buffer.
     //
     if (NT_SUCCESS(status)) {
          ExFreePool(deviceDesc);
     }

     return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\ar_busno.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    ar_busno.c

Abstract:

    This module implements the PCI Bus Number Arbiter.

Author:

    Andy Thornton (andrewth) 04/17/97

Revision History:

--*/

#include "pcip.h"

#define ARBUSNO_VERSION 0

//
// Prototypes for routines exposed only through the "interface"
// mechanism.
//

NTSTATUS
arbusno_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    );

NTSTATUS
arbusno_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    );

PCI_INTERFACE ArbiterInterfaceBusNumber = {
    &GUID_ARBITER_INTERFACE_STANDARD,       // InterfaceType
    sizeof(ARBITER_INTERFACE),              // MinSize
    ARBUSNO_VERSION,                        // MinVersion
    ARBUSNO_VERSION,                        // MaxVersion
    PCIIF_FDO,                              // Flags
    0,                                      // ReferenceCount
    PciArb_BusNumber,                       // Signature
    arbusno_Constructor,                    // Constructor
    arbusno_Initializer                     // Instance Initializer
};

//
// Arbiter helper functions.
//

NTSTATUS
arbusno_UnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    );
    
NTSTATUS
arbusno_PackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    );

NTSTATUS
arbusno_UnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    );

LONG
arbusno_ScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, arbusno_Constructor)
#pragma alloc_text(PAGE, arbusno_Initializer)
#pragma alloc_text(PAGE, arbusno_UnpackRequirement)
#pragma alloc_text(PAGE, arbusno_PackResource)
#pragma alloc_text(PAGE, arbusno_UnpackResource)
#pragma alloc_text(PAGE, arbusno_ScoreRequirement)
#endif

NTSTATUS
arbusno_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    )

/*++

Routine Description:

    Check the InterfaceSpecificData to see if this is the correct
    arbiter (we already know the required interface is an arbiter
    from the GUID) and if so, allocate (and reference) a context
    for this interface.

Arguments:

    PciInterface    Pointer to the PciInterface record for this 
                    interface type.
    InterfaceSpecificData
                    A ULONG containing the resource type for which
                    arbitration is required.
    InterfaceReturn

Return Value:

    TRUE is this device is not known to cause problems, FALSE
    if the device should be skipped altogether.

--*/

{
    PARBITER_INTERFACE arbiterInterface;
    NTSTATUS status;

    PAGED_CODE();
            
    //
    // This arbiter handles bus numbers, is that what they want?
    //

    if ((ULONG_PTR)InterfaceSpecificData != CmResourceTypeBusNumber) {

        //
        // No, it's not us then.
        //

        return STATUS_INVALID_PARAMETER_5;
    }

    //
    // Have already verified that the InterfaceReturn variable
    // points to an area in memory large enough to contain an
    // ARBITER_INTERFACE.  Fill it in for the caller.
    //

    arbiterInterface = (PARBITER_INTERFACE)InterfaceReturn;

    arbiterInterface->Size                 = sizeof(ARBITER_INTERFACE);
    arbiterInterface->Version              = ARBUSNO_VERSION;
    arbiterInterface->InterfaceReference   = PciReferenceArbiter;
    arbiterInterface->InterfaceDereference = PciDereferenceArbiter;
    arbiterInterface->ArbiterHandler       = ArbArbiterHandler;
    arbiterInterface->Flags                = 0;

    status = PciArbiterInitializeInterface(DeviceExtension,
                                           PciArb_BusNumber,
                                           arbiterInterface);

    return status;
}

NTSTATUS
arbusno_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    )

/*++

Routine Description:

    This routine is called once per instantiation of an arbiter.
    Performs initialization of this instantiation's context.

Arguments:

    Instance        Pointer to the arbiter context.

Return Value:

    Returns the status of this operation.

--*/

{
    PAGED_CODE();
    
    RtlZeroMemory(&Instance->CommonInstance, sizeof(ARBITER_INSTANCE));
    
    //
    // Set the Action Handler entry points.
    //

    Instance->CommonInstance.UnpackRequirement = arbusno_UnpackRequirement;
    Instance->CommonInstance.PackResource      = arbusno_PackResource;
    Instance->CommonInstance.UnpackResource    = arbusno_UnpackResource;
    Instance->CommonInstance.ScoreRequirement  = arbusno_ScoreRequirement;
    
    //
    // Initialize the rest of the common instance
    //
    
    return ArbInitializeArbiterInstance(&Instance->CommonInstance,
                                        Instance->BusFdoExtension->FunctionalDeviceObject,
                                        CmResourceTypeBusNumber,
                                        Instance->InstanceName,
                                        L"Pci",
                                        NULL    // no translation of bus numbers
                                        );

}

NTSTATUS
arbusno_UnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    )

/*++

Routine Description:

    This routine unpacks an resource requirement descriptor.
    
Arguments:

    Descriptor - The descriptor describing the requirement to unpack.
    
    Minimum - Pointer to where the minimum acceptable start value should be 
        unpacked to.
    
    Maximum - Pointer to where the maximum acceptable end value should be 
        unpacked to.
    
    Length - Pointer to where the required length should be unpacked to.
    
    Minimum - Pointer to where the required alignment should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/

{
    PAGED_CODE();
    
    PCI_ASSERT(Descriptor);
    PCI_ASSERT(Descriptor->Type == CmResourceTypeBusNumber);

    *Minimum = (ULONGLONG)Descriptor->u.BusNumber.MinBusNumber;
    *Maximum = (ULONGLONG)Descriptor->u.BusNumber.MaxBusNumber;
    *Length = Descriptor->u.BusNumber.Length;
    *Alignment = 1;

    return STATUS_SUCCESS;
}

NTSTATUS
arbusno_PackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine packs an resource descriptor.
    
Arguments:

    Requirement - The requirement from which this resource was chosen.
    
    Start - The start value of the resource.
    
    Descriptor - Pointer to the descriptor to pack into.
    
Return Value:

    Returns the status of this operation.

--*/

{
    PAGED_CODE();
    
    PCI_ASSERT(Descriptor);
    PCI_ASSERT(Requirement);
    PCI_ASSERT(Requirement->Type == CmResourceTypeBusNumber);
    PCI_ASSERT(Start < MAXULONG);

    Descriptor->Type = CmResourceTypeBusNumber;
    Descriptor->Flags = Requirement->Flags;
    Descriptor->ShareDisposition = Requirement->ShareDisposition;
    Descriptor->u.BusNumber.Start = (ULONG) Start;
    Descriptor->u.BusNumber.Length = Requirement->u.BusNumber.Length;
    
    return STATUS_SUCCESS;
}

NTSTATUS
arbusno_UnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine unpacks an resource descriptor.
    
Arguments:

    Descriptor - The descriptor describing the resource to unpack.
    
    Start - Pointer to where the start value should be unpacked to.
    
    Length - Pointer to where the Length value should be unpacked to.
    
Return Value:

    Returns the status of this operation.

--*/

{
    PAGED_CODE();
    
    PCI_ASSERT(Descriptor);
    PCI_ASSERT(Start);
    PCI_ASSERT(Length);
    PCI_ASSERT(Descriptor->Type == CmResourceTypeBusNumber);

    *Start = (ULONGLONG) Descriptor->u.BusNumber.Start;
    *Length = Descriptor->u.BusNumber.Length;
    
    return STATUS_SUCCESS;
}

LONG
arbusno_ScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine scores a requirement based on how flexible it is.  The least
    flexible devices are scored the least and so when the arbitration list is
    sorted we try to allocate their resources first.
    
Arguments:

    Descriptor - The descriptor describing the requirement to score.
    

Return Value:

    The score.

--*/

{
    LONG score;
    
    PAGED_CODE();

    PCI_ASSERT(Descriptor);
    PCI_ASSERT(Descriptor->Type == CmResourceTypeBusNumber);

    score = (Descriptor->u.BusNumber.MaxBusNumber - 
                Descriptor->u.BusNumber.MinBusNumber) / 
                Descriptor->u.BusNumber.Length;

    PciDebugPrint(
        PciDbgObnoxious,
        "Scoring BusNumber resource %p => %i\n",
        Descriptor,
        score
        );

    return score;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\devhere.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    devhere.c

Abstract:

    PCI_DEVICE_PRESENT_INTERFACE lives here

Author:

    Andy Thornton (andrewth) 15-July-1999

Revision History:

--*/

#include "pcip.h"

#define DEVPRESENT_MINSIZE     FIELD_OFFSET(PCI_DEVICE_PRESENT_INTERFACE, IsDevicePresentEx)



BOOLEAN
devpresent_IsDevicePresent(
    USHORT VendorID,
    USHORT DeviceID,
    UCHAR RevisionID,
    USHORT SubVendorID,
    USHORT SubSystemID,
    ULONG Flags
    );

BOOLEAN
devpresent_IsDevicePresentEx(
    IN PVOID Context,
    IN PPCI_DEVICE_PRESENCE_PARAMETERS Parameters
    );

NTSTATUS
devpresent_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    );

NTSTATUS
devpresent_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    );

VOID
PciRefDereferenceNoop(
    IN PVOID Context
    );

BOOLEAN
PcipDevicePresentOnBus(
    IN PPCI_FDO_EXTENSION FdoExtension,
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_DEVICE_PRESENCE_PARAMETERS Parameters
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, devpresent_IsDevicePresent)
#pragma alloc_text(PAGE, devpresent_Initializer)
#pragma alloc_text(PAGE, devpresent_Constructor)
#pragma alloc_text(PAGE, PciRefDereferenceNoop)

#endif


PCI_INTERFACE PciDevicePresentInterface = {
    &GUID_PCI_DEVICE_PRESENT_INTERFACE,     // InterfaceType
    DEVPRESENT_MINSIZE,                     // MinSize
    PCI_DEVICE_PRESENT_INTERFACE_VERSION,   // MinVersion
    PCI_DEVICE_PRESENT_INTERFACE_VERSION,   // MaxVersion
    PCIIF_PDO,                              // Flags
    0,                                      // ReferenceCount
    PciInterface_DevicePresent,             // Signature
    devpresent_Constructor,                 // Constructor
    devpresent_Initializer                  // Instance Initializer
};


VOID
PciRefDereferenceNoop(
    IN PVOID Context
    )
{

    PAGED_CODE();
    return;
}

NTSTATUS
devpresent_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    )
{
    PAGED_CODE();
    return STATUS_SUCCESS;
}

NTSTATUS
devpresent_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    )
{


    PPCI_DEVICE_PRESENT_INTERFACE interface;

    PAGED_CODE();

     //
    // Have already verified that the InterfaceReturn variable
    // points to an area in memory large enough to contain a
    // PCI_DEVICE_PRESENT_INTERFACE.  Fill it in for the caller.
    //

    interface = (PPCI_DEVICE_PRESENT_INTERFACE) InterfaceReturn;

    interface->Version              = PCI_DEVICE_PRESENT_INTERFACE_VERSION;
    interface->InterfaceReference   = PciRefDereferenceNoop;
    interface->InterfaceDereference = PciRefDereferenceNoop;
    interface->Context              = DeviceExtension;
    interface->IsDevicePresent      = devpresent_IsDevicePresent;
        
    //
    // This interface has been extended from the base interface (what was
    // filled in above), to a larger interface.  If the buffer provided
    // is large enough to hold the whole thing, fill in the rest.  Otherwise
    // don't.
    //
    if (Size >= sizeof(PCI_DEVICE_PRESENT_INTERFACE)) {
        
        interface->IsDevicePresentEx = devpresent_IsDevicePresentEx;
        interface->Size = sizeof(PCI_DEVICE_PRESENT_INTERFACE);
    
    } else {

        interface->Size = DEVPRESENT_MINSIZE;
    }
    
    return STATUS_SUCCESS;
}


BOOLEAN
devpresent_IsDevicePresent(
    IN USHORT VendorID,
    IN USHORT DeviceID,
    IN UCHAR RevisionID,
    IN USHORT SubVendorID,
    IN USHORT SubSystemID,
    IN ULONG Flags
    )
/*++

Routine Description:

    This routine searches the PCI device tree to see if the specific device
    is present in the system.  Not devices that are explicitly not enumerated
    (such as PIIX4 power management function) are considered absent.

Arguments:

    VendorID - Required VendorID of the device

    DeviceID - Required DeviceID of the device

    RevisionID - Optional Revision ID

    SubVendorID - Optional Subsystem Vendor ID

    SubSystemID - Optional Subsystem ID

    Flags - Bitfield which indicates if Revision and Sub* ID's should be used:

        PCI_USE_SUBSYSTEM_IDS, PCI_USE_REVISION_ID are valid all other bits
        should be 0


Return Value:

    TRUE if the device is present in the system, FALSE otherwise.

--*/

{
    PCI_DEVICE_PRESENCE_PARAMETERS parameters;

    parameters.Size = sizeof(PCI_DEVICE_PRESENCE_PARAMETERS);
    parameters.VendorID = VendorID;
    parameters.DeviceID = DeviceID;
    parameters.RevisionID = RevisionID;
    parameters.SubVendorID = SubVendorID;
    parameters.SubSystemID = SubSystemID;

    //
    // Clear out flags that this version of the interface didn't use,
    // 
    parameters.Flags = Flags & (PCI_USE_SUBSYSTEM_IDS | PCI_USE_REVISION);
    
    //
    // This original version of the interface required vendor/device ID
    // matching.  The new version doesn't, so set the flag indicating
    // that we do in fact want to do a vendor/device ID match.
    //
    parameters.Flags |= PCI_USE_VENDEV_IDS;
    
    return devpresent_IsDevicePresentEx(NULL,
                                        &parameters
                                        );
}

BOOLEAN
devpresent_IsDevicePresentEx(
    IN PVOID Context,
    IN PPCI_DEVICE_PRESENCE_PARAMETERS Parameters
    )
/*++

Routine Description:

    This routine searches the PCI device tree to see if the specific device
    is present in the system.  Note devices that are explicitly not enumerated
    (such as PIIX4 power management function) are considered absent.

Arguments:

    Context - The device extension of the device requesting the search.
    
    Parameters - Pointer to a structure containing the parameters of the device search,
                 including VendorID, SubSystemID and ClassCode, among others.                 

Return Value:

    TRUE if the device is present in the system, FALSE otherwise.

--*/
{
    PSINGLE_LIST_ENTRY nextEntry;
    PPCI_FDO_EXTENSION fdoExtension;
    PPCI_PDO_EXTENSION pdoExtension;
    BOOLEAN found = FALSE;
    ULONG flags;

    PAGED_CODE();

    //
    // Validate the parameters.
    //

    if (!ARGUMENT_PRESENT(Parameters)) {
        
        ASSERT(ARGUMENT_PRESENT(Parameters));
        return FALSE;
    }
    
    //
    // Validate the size of the structure passed in.
    //
    if (Parameters->Size < sizeof(PCI_DEVICE_PRESENCE_PARAMETERS)) {
        
        ASSERT(Parameters->Size >= sizeof(PCI_DEVICE_PRESENCE_PARAMETERS));
        return FALSE;
    }

    flags = Parameters->Flags;
    
    // 
    // We can either do a Vendor/Device ID match, or a Class/SubClass
    // match.  If neither of these flags are present, fail.
    //
    if (!(flags & (PCI_USE_VENDEV_IDS | PCI_USE_CLASS_SUBCLASS))) {
        
        ASSERT(flags & (PCI_USE_VENDEV_IDS | PCI_USE_CLASS_SUBCLASS));
        return FALSE;
    }

    //
    // RevisionID, SubVendorID and SubSystemID are more precise flags.
    // They are only valid if we're doing a Vendor/Device ID match.
    //
    if (flags & (PCI_USE_REVISION | PCI_USE_SUBSYSTEM_IDS)) {
        
        if (!(flags & PCI_USE_VENDEV_IDS)) {
            
            ASSERT(flags & PCI_USE_VENDEV_IDS);
            return FALSE;
        }
    }

    //
    // Programming Interface is also a more precise flag.
    // It is only valid if we're doing a class code match.
    //
    if (flags & PCI_USE_PROGIF) {
        
        if (!(flags & PCI_USE_CLASS_SUBCLASS)) {
            
            ASSERT(flags & PCI_USE_CLASS_SUBCLASS);
            return FALSE;
        }
    }

    //
    // Okay, validation complete.  Do the search.
    //
    ExAcquireFastMutex(&PciGlobalLock);

    pdoExtension = (PPCI_PDO_EXTENSION)Context;
    
    if (flags & (PCI_USE_LOCAL_BUS | PCI_USE_LOCAL_DEVICE)) {
        
        //
        // Limit the search to the same bus as the device that requested
        // the search.  This requires a pdoExtension representing the device
        // requesting the search.
        //
        if (pdoExtension == NULL) {
            
            ASSERT(pdoExtension != NULL);
            goto cleanup;
        }
        
        fdoExtension = pdoExtension->ParentFdoExtension;

        found = PcipDevicePresentOnBus(fdoExtension,
                                       pdoExtension,
                                       Parameters
                                       );   
    } else {

        //
        // We have not been told to limit the search to
        // the bus on which a particular device lives.
        // Do a global search, iterating over all the buses.
        //
        for ( nextEntry = PciFdoExtensionListHead.Next;
              nextEntry != NULL;
              nextEntry = nextEntry->Next ) {
    
            fdoExtension = CONTAINING_RECORD(nextEntry,
                                             PCI_FDO_EXTENSION,
                                             List
                                             );
            
            found = PcipDevicePresentOnBus(fdoExtension,
                                           NULL,
                                           Parameters
                                           );
            if (found) {
                break;
            }
    
        }
    }
    
cleanup:

    ExReleaseFastMutex(&PciGlobalLock);

    return found;

}

BOOLEAN
PcipDevicePresentOnBus(
    IN PPCI_FDO_EXTENSION FdoExtension,
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_DEVICE_PRESENCE_PARAMETERS Parameters
    )
/*++

Routine Description:
    
    This routine searches the PCI device tree for a given device 
    on the bus represented by the given FdoExtension.  
    
Arguments:

    FdoExtension - A pointer to the device extension of a PCI FDO.
        This represents the bus to be searched for the given device.
        
    PdoExtension - A pointer to the device extension of the PCI PDO that requested
        the search.  Some device searches are limited to the same bus/device number
        as the requesting device, and this is used to get those numbers.
        
    Parameters - The parameters of the search.
    
    Flags - A bitfield indicating which fields of the Parameters structure to use for the search.
    
Return Value:

    TRUE if the requested device is found.
    FALSE if it is not.
    
--*/
{
    IN PPCI_PDO_EXTENSION currentPdo;
    BOOLEAN found = FALSE;
    ULONG flags = Parameters->Flags;

    ExAcquireFastMutex(&FdoExtension->ChildListMutex);

    for (currentPdo = FdoExtension->ChildPdoList;
         currentPdo;
         currentPdo = currentPdo->Next) {

        //
        // If we're limiting the search to devices with the same 
        // device number as the requesting device, make sure this
        // current PDO qualifies.
        //
        if (PdoExtension && (flags & PCI_USE_LOCAL_DEVICE)) {
            
            if (PdoExtension->Slot.u.bits.DeviceNumber != 
                currentPdo->Slot.u.bits.DeviceNumber) {
                
                continue;
            }
        }

        if (flags & PCI_USE_VENDEV_IDS) {
            
            if ((currentPdo->VendorId != Parameters->VendorID)
            ||  (currentPdo->DeviceId != Parameters->DeviceID)) {

                continue;
            }
            
            if ((flags & PCI_USE_SUBSYSTEM_IDS)
            &&  ((currentPdo->SubsystemVendorId != Parameters->SubVendorID) || 
                 (currentPdo->SubsystemId != Parameters->SubSystemID))) {

                continue;
            }

            if ((flags & PCI_USE_REVISION)
            &&  (currentPdo->RevisionId != Parameters->RevisionID)) {

                continue;
            }
        }

        if (flags & PCI_USE_CLASS_SUBCLASS) {
            
            if ((currentPdo->BaseClass != Parameters->BaseClass) ||
                (currentPdo->SubClass != Parameters->SubClass)) {
                
                continue;
            }

            if ((flags & PCI_USE_PROGIF) 
            &&  (currentPdo->ProgIf != Parameters->ProgIf)) {
                
                continue;
            }
        }

        found = TRUE;
        break;
    }

    ExReleaseFastMutex(&FdoExtension->ChildListMutex);

    return found;
}

#if DEVPRSNT_TESTING

NTSTATUS
PciRunDevicePresentInterfaceTest(
    IN PPCI_PDO_EXTENSION PdoExtension
    )
/*++

Routine Description:

    

Arguments:

    FdoExtension - this PCI bus's FDO extension

Return Value:

    STATUS_SUCCESS

Notes:

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PCI_DEVICE_PRESENT_INTERFACE interface;
    PDEVICE_OBJECT targetDevice = NULL;
    KEVENT irpCompleted;
    IO_STATUS_BLOCK statusBlock;
    PIRP irp = NULL;
    PIO_STACK_LOCATION irpStack;
    USHORT interfaceSize;
    ULONG pass;
    PCI_DEVICE_PRESENCE_PARAMETERS parameters;
    BOOLEAN result;

    PAGED_CODE();
    
    targetDevice = IoGetAttachedDeviceReference(PdoExtension->PhysicalDeviceObject);

    for (pass = 0; pass < 2; pass++) {
        
        if (pass == 0) {
            
            //
            // First pass test the old version.
            //
            interfaceSize = FIELD_OFFSET(PCI_DEVICE_PRESENT_INTERFACE, IsDevicePresentEx);

        } else {

            //
            // Second pass test the full new version.
            //
            interfaceSize = sizeof(PCI_DEVICE_PRESENT_INTERFACE);
        }

        //
        // Get an IRP
        //
        //
    // Find out where we are sending the irp
    //

    
        KeInitializeEvent(&irpCompleted, SynchronizationEvent, FALSE);
    
        irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                           targetDevice,
                                           NULL,    // Buffer
                                           0,       // Length
                                           0,       // StartingOffset
                                           &irpCompleted,
                                           &statusBlock
                                           );
        if (!irp) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }
    
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        irp->IoStatus.Information = 0;
    
        //
        // Initialize the stack location
        //
    
        irpStack = IoGetNextIrpStackLocation(irp);
    
        PCI_ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);
    
        irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
    
        irpStack->Parameters.QueryInterface.InterfaceType = (PGUID) &GUID_PCI_DEVICE_PRESENT_INTERFACE;
        irpStack->Parameters.QueryInterface.Version = PCI_DEVICE_PRESENT_INTERFACE_VERSION;
        irpStack->Parameters.QueryInterface.Size = interfaceSize;
        irpStack->Parameters.QueryInterface.Interface = (PINTERFACE)&interface;
        irpStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;
    
        //
        // Call the driver and wait for completion
        //
    
        status = IoCallDriver(targetDevice, irp);
    
        if (status == STATUS_PENDING) {
    
            KeWaitForSingleObject(&irpCompleted, Executive, KernelMode, FALSE, NULL);
            status = statusBlock.Status;
        }
    
        if (!NT_SUCCESS(status)) {
    
            PciDebugPrintf("Couldn't successfully retrieve interface\n");
            goto cleanup;
        }
    
        PciDebugPrintf("Testing PCI Device Presence Interface\n");
        if (pass==0) {
            PciDebugPrintf("Original Version\n");
        } else {
            PciDebugPrintf("New Version\n");
        }

        PciDebugPrintf("Interface values:\n");
        PciDebugPrintf("\tSize=%d\n",interface.Size);
        PciDebugPrintf("\tVersion=%d\n",interface.Version);
        PciDebugPrintf("\tContext=%d\n",interface.Context);
        PciDebugPrintf("\tInterfaceReference=%d\n",interface.InterfaceReference);
        PciDebugPrintf("\tInterfaceDereference=%d\n",interface.InterfaceDereference);
        PciDebugPrintf("\tIsDevicePresent=%d\n",interface.IsDevicePresent);
        PciDebugPrintf("\tIsDevicePresentEx=%d\n",interface.IsDevicePresentEx);
    
        PciDebugPrintf("Testing IsDevicePresent function\n");
        PciDebugPrintf("\tTesting 8086:7190.03 0000:0000 No flags Should be TRUE, is ");
        result = interface.IsDevicePresent(0x8086,0x7190,3,0,0,0);
        if (result) {
            PciDebugPrintf("TRUE\n");
        } else {
            PciDebugPrintf("FALSE\n");
        }

        PciDebugPrintf("\tTesting 8086:7190.03 0000:0000 PCI_USE_REVISION Should be TRUE, is ");
        result = interface.IsDevicePresent(0x8086,0x7190,3,0,0,PCI_USE_REVISION);
        if (result) {
            PciDebugPrintf("TRUE\n");
        } else {
            PciDebugPrintf("FALSE\n");
        }

        PciDebugPrintf("\tTesting 8086:7190.01 0000:0000 PCI_USE_REVISION Should be FALSE, is ");
        result = interface.IsDevicePresent(0x8086,0x7190,1,0,0,PCI_USE_REVISION);
        if (result) {
            PciDebugPrintf("TRUE\n");
        } else {
            PciDebugPrintf("FALSE\n");
        }

        PciDebugPrintf("\tTesting 8086:1229.05 8086:0009 PCI_USE_SUBSYSTEM_IDS Should be TRUE, is ");
        result = interface.IsDevicePresent(0x8086,0x1229,5,0x8086,9,PCI_USE_SUBSYSTEM_IDS);
        if (result) {
            PciDebugPrintf("TRUE\n");
        } else {
            PciDebugPrintf("FALSE\n");
        }

        PciDebugPrintf("\tTesting 8086:1229.05 8086:0009 PCI_USE_SUBSYSTEM_IDS|PCI_USE_REVISION Should be TRUE, is ");
        result = interface.IsDevicePresent(0x8086,0x1229,5,0x8086,9,PCI_USE_SUBSYSTEM_IDS|PCI_USE_REVISION);
        if (result) {
            PciDebugPrintf("TRUE\n");
        } else {
            PciDebugPrintf("FALSE\n");
        }

        PciDebugPrintf("\tTesting 8086:1229.05 8086:0004 PCI_USE_SUBSYSTEM_IDS Should be FALSE, is ");
        result = interface.IsDevicePresent(0x8086,0x1229,5,0x8086,4,PCI_USE_SUBSYSTEM_IDS);
        if (result) {
            PciDebugPrintf("TRUE\n");
        } else {
            PciDebugPrintf("FALSE\n");
        }

        PciDebugPrintf("\tTesting 8086:1229.05 8084:0009 PCI_USE_SUBSYSTEM_IDS|PCI_USE_REVISION Should be FALSE, is ");
        result = interface.IsDevicePresent(0x8086,0x1229,5,0x8084,9,PCI_USE_SUBSYSTEM_IDS|PCI_USE_REVISION);
        if (result) {
            PciDebugPrintf("TRUE\n");
        } else {
            PciDebugPrintf("FALSE\n");
        }

        PciDebugPrintf("\tTesting 0000:0000.00 0000:0000 No flags Should ASSERT and be FALSE, is ");
        result = interface.IsDevicePresent(0,0,0,0,0,0);
        if (result) {
            PciDebugPrintf("TRUE\n");
        } else {
            PciDebugPrintf("FALSE\n");
        }

        PciDebugPrintf("\tTesting 0000:0000.00 0000:0000 PCI_USE_SUBSYSTEM_IDS Should ASSERT and be FALSE, is ");
        result = interface.IsDevicePresent(0,0,0,0,0,PCI_USE_SUBSYSTEM_IDS);
        if (result) {
            PciDebugPrintf("TRUE\n");
        } else {
            PciDebugPrintf("FALSE\n");
        }

        if (pass == 1) {
            
            PciDebugPrintf("Testing IsDevicePresentEx function\n");
            PciDebugPrintf("Running the same tests as IsDevicePresent, but using new function\n");
            
            PciDebugPrintf("\tTesting 8086:7190.03 0000:0000 PCI_USE_VENDEV_IDS Should be TRUE, is ");
            parameters.Size = sizeof(PCI_DEVICE_PRESENCE_PARAMETERS);
            parameters.Flags = PCI_USE_VENDEV_IDS;
            parameters.VendorID = 0x8086;
            parameters.DeviceID = 0x7190;
            parameters.RevisionID = 3;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }
    
            PciDebugPrintf("\tTesting 8086:7190.03 0000:0000 PCI_USE_REVISION Should be TRUE, is ");
            parameters.Flags |= PCI_USE_REVISION;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }
    
            PciDebugPrintf("\tTesting 8086:7190.01 0000:0000 PCI_USE_REVISION Should be FALSE, is ");
            parameters.RevisionID = 1;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }
    
            PciDebugPrintf("\tTesting 8086:1229.05 8086:0009 PCI_USE_SUBSYSTEM_IDS Should be TRUE, is ");
            parameters.DeviceID = 0x1229;
            parameters.RevisionID = 5;
            parameters.SubVendorID = 0x8086;
            parameters.SubSystemID = 9;
            parameters.Flags = PCI_USE_VENDEV_IDS | PCI_USE_SUBSYSTEM_IDS;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }
    
            PciDebugPrintf("\tTesting 8086:1229.05 8086:0009 PCI_USE_SUBSYSTEM_IDS|PCI_USE_REVISION Should be TRUE, is ");
            parameters.Flags |= PCI_USE_REVISION;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }
    
            PciDebugPrintf("\tTesting 8086:1229.05 8086:0004 PCI_USE_SUBSYSTEM_IDS Should be FALSE, is ");
            parameters.Flags &= ~PCI_USE_REVISION;
            parameters.SubSystemID = 4;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }
    
            PciDebugPrintf("\tTesting 8086:1229.05 8084:0009 PCI_USE_SUBSYSTEM_IDS|PCI_USE_REVISION Should be FALSE, is ");
            parameters.SubVendorID = 0x8084;
            parameters.SubSystemID = 9;
            parameters.Flags |= PCI_USE_SUBSYSTEM_IDS;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("\tTesting 8086:1229.05 8084:0009 No flags Should ASSERT and be FALSE, is ");
            parameters.Flags = 0;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("\tTesting 8086:1229.05 8084:0009 PCI_USE_VENDEV_IDS bad Size Should ASSERT and be FALSE, is ");
            parameters.SubVendorID = 0x8086;
            parameters.SubSystemID = 9;
            parameters.Flags = PCI_USE_VENDEV_IDS;
            parameters.Size = 3;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("\tTesting 0000:0000.00 0000:0000 No flags Should ASSERT and be FALSE, is ");
            RtlZeroMemory(&parameters, sizeof(PCI_DEVICE_PRESENCE_PARAMETERS));
            parameters.Size = sizeof(PCI_DEVICE_PRESENCE_PARAMETERS);
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("Running tests on new flags\n");
            PciDebugPrintf("\tTesting Class USB Controller PCI_USE_CLASS_SUBCLASS Should be TRUE, is ");
            parameters.Flags = PCI_USE_CLASS_SUBCLASS;
            parameters.BaseClass = PCI_CLASS_SERIAL_BUS_CTLR;
            parameters.SubClass = PCI_SUBCLASS_SB_USB;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("\tTesting Class USB Controller (UHCI) PCI_USE_CLASS_SUBCLASS|PCI_USE_PROGIF Should be TRUE, is ");
            parameters.Flags = PCI_USE_CLASS_SUBCLASS|PCI_USE_PROGIF;
            parameters.ProgIf = 0;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("\tTesting Class USB Controller (OHCI) PCI_USE_CLASS_SUBCLASS|PCI_USE_PROGIF Should be FALSE, is ");
            parameters.ProgIf = 0x10;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("\tTesting Class Wireless RF PCI_USE_CLASS_SUBCLASS Should be FALSE, is ");
            parameters.BaseClass = PCI_CLASS_WIRELESS_CTLR;
            parameters.SubClass = PCI_SUBCLASS_WIRELESS_RF;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("\tTesting 8086:7112 Class USB Controller PCI_USE_VENDEV|PCI_USE_CLASS_SUBCLASS Should be TRUE, is ");
            parameters.VendorID = 0x8086;
            parameters.DeviceID = 0x7112;
            parameters.BaseClass = PCI_CLASS_SERIAL_BUS_CTLR;
            parameters.SubClass = PCI_SUBCLASS_SB_USB;
            parameters.Flags = PCI_USE_VENDEV_IDS|PCI_USE_CLASS_SUBCLASS;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("\tTesting 8086:7112 Class USB Controller PCI_USE_VENDEV|PCI_USE_CLASS_SUBCLASS|PCI_USE_LOCAL_BUS Should be TRUE, is ");
            parameters.VendorID = 0x8086;
            parameters.DeviceID = 0x7112;
            parameters.BaseClass = PCI_CLASS_SERIAL_BUS_CTLR;
            parameters.SubClass = PCI_SUBCLASS_SB_USB;
            parameters.Flags = PCI_USE_VENDEV_IDS|PCI_USE_CLASS_SUBCLASS|PCI_USE_LOCAL_BUS;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("\tTesting 8086:7112 Class USB Controller PCI_USE_VENDEV|PCI_USE_CLASS_SUBCLASS|PCI_USE_LOCAL_DEVICE Should be ?, is ");
            parameters.VendorID = 0x8086;
            parameters.DeviceID = 0x7112;
            parameters.BaseClass = PCI_CLASS_SERIAL_BUS_CTLR;
            parameters.SubClass = PCI_SUBCLASS_SB_USB;
            parameters.Flags = PCI_USE_VENDEV_IDS|PCI_USE_CLASS_SUBCLASS|PCI_USE_LOCAL_DEVICE;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("\tTesting 8086:7112 Class USB Controller PCI_USE_VENDEV|PCI_USE_CLASS_SUBCLASS|PCI_USE_LOCAL_BUS|PCI_USE_LOCAL_DEVICE Should be ?, is ");
            parameters.VendorID = 0x8086;
            parameters.DeviceID = 0x7112;
            parameters.BaseClass = PCI_CLASS_SERIAL_BUS_CTLR;
            parameters.SubClass = PCI_SUBCLASS_SB_USB;
            parameters.Flags = PCI_USE_VENDEV_IDS|PCI_USE_CLASS_SUBCLASS|PCI_USE_LOCAL_DEVICE|PCI_USE_LOCAL_BUS;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("\tTesting 8086:7190 PCI_USE_VENDEV|PCI_USE_LOCAL_DEVICE Should be FALSE, is ");
            parameters.VendorID = 0x8086;
            parameters.DeviceID = 0x7190;
            parameters.Flags = PCI_USE_VENDEV_IDS|PCI_USE_LOCAL_DEVICE;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("\tTesting 8086:7190 PCI_USE_VENDEV|PCI_USE_LOCAL_BUS Should be TRUE, is ");
            parameters.VendorID = 0x8086;
            parameters.DeviceID = 0x7190;
            parameters.Flags = PCI_USE_VENDEV_IDS|PCI_USE_LOCAL_BUS;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

        }
    }
    
    //
    // Ok we're done with this stack
    //

    ObDereferenceObject(targetDevice);

    return status;

cleanup:

    if (targetDevice) {
        ObDereferenceObject(targetDevice);
    }

    return status;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\debug.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module contains debug functions for PCI.SYS.

Author:

    Peter Johnston (peterj)  12-Feb-1997

Revision History:

--*/

#include "pcip.h"

PUCHAR
PciDebugInterfaceTypeToText(
    ULONG InterfaceType
    );

PUCHAR
PciDebugCmResourceTypeToText(
    UCHAR Type
    );

#if DBG

#define PCI_DEBUG_BUFFER_SIZE 256

PCI_DEBUG_LEVEL PciDebug = PciDbgAlways;
ULONG PciDebugStop = 0;

UCHAR PciDebugBuffer[PCI_DEBUG_BUFFER_SIZE];

#endif

VOID
PciDebugPrintIfLevel(
    PCI_DEBUG_LEVEL DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for the PCI Bus Driver.

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.
    A bit mask corresponding to various debug items.

    Note: This used to be a level, for backward compatibility, 0 is
    treated as print always.



Return Value:

    None

--*/

{

#if DBG

    va_list ap;

    va_start(ap, DebugMessage);

    if (PCI_DEBUGGING_OKAY() &&
        (DebugPrintLevel & PciDebug)) {

        if (FAILED(StringCbVPrintfA(PciDebugBuffer, sizeof(PciDebugBuffer), DebugMessage, ap))) {
       
            DbgPrint("Pci Debug Print Failed!  Format string was %s", DebugMessage);
        
        } else {
            
            DbgPrint(PciDebugBuffer);
        
        }
    }

    va_end(ap);
                                        
#endif

} // end PciDebugPrint()

VOID
PciDebugPrintf(
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for the PCI Bus Driver.

Arguments:

    The message to print

Return Value:

    None

--*/

{

#if DBG

    va_list ap;

    va_start(ap, DebugMessage);

    if (PCI_DEBUGGING_OKAY()) {

        if (FAILED(StringCbVPrintfA(PciDebugBuffer, sizeof(PciDebugBuffer), DebugMessage, ap))) {
            
            DbgPrint("Pci Debug Print Failed!  Format string was %s", DebugMessage);
        
        } else {
            
            DbgPrint(PciDebugBuffer);
        }
    }

    va_end(ap);

#endif

}

VOID
PciDebugHit(
    ULONG StopOnBit
    )

/*++

Routine Description:

    Called from various places with various bits for arguments.
    If the bit(s) are a subset of the bits in the global PciDebugStop,
    call PciDebugBreak.

Arguments:

    Stop bit(s).

Return Value:

    None

--*/

{

#if DBG

    if (PCI_DEBUGGING_OKAY() &&
        (StopOnBit & PciDebugStop)) {

        DbgBreakPoint();
    }

#endif

}
//++
//
// Miscellaneous Debug printing routines.
//
//--

#if DBG

static UCHAR PnpIrpUnknownText[] = "** UNKNOWN PNP IRP Minor Code **";
static UCHAR PoIrpUnknownText[]  = "** UNKNOWN PO IRP Minor Code **";

//
// The following really begin with "IRP_MN_"
//

static PUCHAR PnpIrpTypeStrings[] = {

    "START_DEVICE",                // 0x00
    "QUERY_REMOVE_DEVICE",         // 0x01
    "REMOVE_DEVICE",               // 0x02
    "CANCEL_REMOVE_DEVICE",        // 0x03
    "STOP_DEVICE",                 // 0x04
    "QUERY_STOP_DEVICE",           // 0x05
    "CANCEL_STOP_DEVICE",          // 0x06

    "QUERY_DEVICE_RELATIONS",      // 0x07
    "QUERY_INTERFACE",             // 0x08
    "QUERY_CAPABILITIES",          // 0x09
    "QUERY_RESOURCES",             // 0x0A
    "QUERY_RESOURCE_REQUIREMENTS", // 0x0B
    "QUERY_DEVICE_TEXT",           // 0x0C
    "FILTER_RESOURCE_REQUIREMENTS",// 0x0D
    PnpIrpUnknownText,             // 0x0E

    "READ_CONFIG",                 // 0x0F
    "WRITE_CONFIG",                // 0x10
    "EJECT",                       // 0x11
    "SET_LOCK",                    // 0x12
    "QUERY_ID",                    // 0x13
    "QUERY_PNP_DEVICE_STATE",      // 0x14
    "QUERY_BUS_INFORMATION",       // 0x15
    "DEVICE_USAGE_NOTIFICATION"    // 0x16

    };

static PUCHAR PoIrpTypeStrings[] = {

    "WAIT_WAKE",                   // 0x00
    "POWER_SEQUENCE",              // 0x01
    "SET_POWER",                   // 0x02
    "QUERY_POWER"                  // 0x03
    };

static PUCHAR SystemPowerStateStrings[] = {
    "Unspecified",
    "Working",
    "Sleeping1",
    "Sleeping2",
    "Sleeping3",
    "Hibernate",
    "Shutdown"
};

static PUCHAR DevicePowerStateStrings[] = {
    "Unspecified",
    "D0",
    "D1",
    "D2",
    "D3"
};

PUCHAR
PciDebugCmResourceTypeToText(
    UCHAR Type
    )
{
    switch (Type) {
    case CmResourceTypePort:
        return "CmResourceTypePort";
    case CmResourceTypeInterrupt:
        return "CmResourceTypeInterrupt";
    case CmResourceTypeMemory:
        return "CmResourceTypeMemory";
    case CmResourceTypeDma:
        return "CmResourceTypeDma";
    case CmResourceTypeDeviceSpecific:
        return "CmResourceTypeDeviceSpecific";
    case CmResourceTypeBusNumber:
        return "CmResourceTypeBusNumber";
    case CmResourceTypeConfigData:
        return "CmResourceTypeConfigData";
    case CmResourceTypeDevicePrivate:
        return "CmResourceTypeDevicePrivate";
    case CmResourceTypePcCardConfig:
        return "CmResourceTypePcCardConfig";
    default:
        return "*** INVALID RESOURCE TYPE ***";
    }
}

PUCHAR
PciDebugPnpIrpTypeToText(
    ULONG IrpMinorCode
    )
{
    if (IrpMinorCode < (sizeof(PnpIrpTypeStrings)/sizeof(PUCHAR))) {
        return PnpIrpTypeStrings[IrpMinorCode];
    }
    return PnpIrpUnknownText;
}

PUCHAR
PciDebugPoIrpTypeToText(
    ULONG IrpMinorCode
    )
{
    if (IrpMinorCode < (sizeof(PoIrpTypeStrings)/sizeof(PUCHAR))) {
        return PoIrpTypeStrings[IrpMinorCode];
    }
    return PoIrpUnknownText;
}

VOID
PciDebugDumpCommonConfig(
    IN PPCI_COMMON_CONFIG CommonConfig
    )

{
    PULONG dw;
    ULONG  i;

    if (PciDebug < PciDbgPrattling) {
        return;
    }

    dw = (PULONG)CommonConfig;

    for (i = 0; i < PCI_COMMON_HDR_LENGTH; i += sizeof(ULONG)) {
        PciDebugPrintf("  %02x - %08x\n", i, *dw);
        dw++;
    }
}

VOID
PciDebugDumpQueryCapabilities(
    IN PDEVICE_CAPABILITIES C
    )
{
    //
    // Dump the DEVICE_CAPABILITIES structure pointed to by C.
    //

    SYSTEM_POWER_STATE sw = C->SystemWake;
    DEVICE_POWER_STATE dw = C->DeviceWake;
    ULONG i;

    PciDebugPrintf(
        "Capabilities\n  Lock:%d, Eject:%d, Remove:%d, Dock:%d, UniqueId:%d\n",
        C->LockSupported,
        C->EjectSupported,
        C->Removable,
        C->DockDevice,
        C->UniqueID
        );
    PciDebugPrintf(
        "  SilentInstall:%d, RawOk:%d, SurpriseOk:%d\n",
        C->SilentInstall,
        C->RawDeviceOK,
        C->SurpriseRemovalOK
        );
    PciDebugPrintf(
        "  Address %08x, UINumber %08x, Latencies D1 %d, D2 %d, D3 %d\n",
        C->Address,
        C->UINumber,
        C->D1Latency,
        C->D2Latency,
        C->D3Latency
        );

    if (sw > PowerSystemMaximum) {
        sw = PowerSystemMaximum;
    }
    if (dw > PowerDeviceMaximum) {
        dw = PowerDeviceMaximum;
    }
    PciDebugPrintf(
        "  System Wake: %s, Device Wake: %s\n  DeviceState[PowerState] [",
        SystemPowerStateStrings[sw],
        DevicePowerStateStrings[dw]
        );
    for (i = PowerSystemWorking;
         i < (sizeof(C->DeviceState) / sizeof(C->DeviceState[0]));
         i++) {
        dw = C->DeviceState[i];
        if (dw > PowerDeviceMaximum) {
            dw = PowerDeviceMaximum;
        }
        PciDebugPrintf(" %s", DevicePowerStateStrings[dw]);
    }
    PciDebugPrintf(" ]\n");
}


VOID
PciDebugPrintIoResource(
    IN PIO_RESOURCE_DESCRIPTOR D
    )
{
    ULONG  i;
    PUCHAR t;

    t = PciDebugCmResourceTypeToText(D->Type);
    PciDebugPrintf("     IoResource Descriptor dump:  Descriptor @0x%x\n", D);
    PciDebugPrintf("        Option           = 0x%x\n", D->Option);
    PciDebugPrintf("        Type             = %d (%s)\n", D->Type, t);
    PciDebugPrintf("        ShareDisposition = %d\n", D->ShareDisposition);
    PciDebugPrintf("        Flags            = 0x%04X\n", D->Flags);

    for ( i = 0; i < 6; i+=3 ) {
        PciDebugPrintf("        Data[%d] = %08x  %08x  %08x\n",
                 i,
                 D->u.DevicePrivate.Data[i],
                 D->u.DevicePrivate.Data[i+1],
                 D->u.DevicePrivate.Data[i+2]);
    }
}


VOID
PciDebugPrintIoResReqList(
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoResReqList
    )
{
    ULONG                   numlists;
    PIO_RESOURCE_LIST       list;

    if ((PciDebug < PciDbgPrattling) || (IoResReqList == NULL)) {
        return;
    }

    numlists = IoResReqList->AlternativeLists;
    list     = IoResReqList->List;

    PciDebugPrintf("  IO_RESOURCE_REQUIREMENTS_LIST (PCI Bus Driver)\n");
    PciDebugPrintf("     InterfaceType        %d\n", IoResReqList->InterfaceType);
    PciDebugPrintf("     BusNumber            0x%x\n", IoResReqList->BusNumber    );
    PciDebugPrintf("     SlotNumber           %d (0x%x), (d/f = 0x%x/0x%x)\n",
             IoResReqList->SlotNumber,              // in decimal
             IoResReqList->SlotNumber,              // in hex
             IoResReqList->SlotNumber & 0x1f,       // device number
             (IoResReqList->SlotNumber >> 5) & 0x7  // function
            );
    PciDebugPrintf("     AlternativeLists     %d\n", numlists                   );

    while (numlists--) {

        PIO_RESOURCE_DESCRIPTOR resource = list->Descriptors;
        ULONG                   count    = list->Count;

        PciDebugPrintf("\n     List[%d].Count = %d\n", numlists, count);
        while (count--) {
            PciDebugPrintIoResource(resource++);
        }

        list = (PIO_RESOURCE_LIST)resource;
    }
    PciDebugPrintf("\n");
}


VOID
PciDebugPrintPartialResource(
    PCI_DEBUG_LEVEL DebugPrintLevel,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR D
    )
{
    ULONG  i;
    PUCHAR t;

    if (!(PciDebug & DebugPrintLevel)) {
        return;
    }

    t = PciDebugCmResourceTypeToText(D->Type);
    PciDebugPrintf("     Partial Resource Descriptor @0x%x\n", D);
    PciDebugPrintf("        Type             = %d (%s)\n", D->Type, t);
    PciDebugPrintf("        ShareDisposition = %d\n", D->ShareDisposition);
    PciDebugPrintf("        Flags            = 0x%04X\n", D->Flags);

    for ( i = 0; i < 3; i+=3 ) {
        PciDebugPrintf("        Data[%d] = %08x  %08x  %08x\n",
                 i,
                 D->u.DevicePrivate.Data[i],
                 D->u.DevicePrivate.Data[i+1],
                 D->u.DevicePrivate.Data[i+2]);
    }
}

VOID
PciDebugPrintCmResList(
    PCI_DEBUG_LEVEL DebugPrintLevel,
    IN PCM_RESOURCE_LIST ResourceList
    )
{
    ULONG                           numlists;
    PCM_FULL_RESOURCE_DESCRIPTOR    full;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor;

    if (!ResourceList || !(PciDebug & DebugPrintLevel)) {
        return;
    }

    numlists = ResourceList->Count;
    full     = ResourceList->List;

    PciDebugPrintf("  CM_RESOURCE_LIST (PCI Bus Driver) (List Count = %d)\n",
             numlists);

    while (numlists--) {
        PCM_PARTIAL_RESOURCE_LIST partial = &full->PartialResourceList;
        ULONG                     count   = partial->Count;

        PciDebugPrintf("     InterfaceType        %d\n", full->InterfaceType);
        PciDebugPrintf("     BusNumber            0x%x\n", full->BusNumber    );

        descriptor = partial->PartialDescriptors;
        while (count--) {
            PciDebugPrintPartialResource(DebugPrintLevel, descriptor);
            descriptor = PciNextPartialDescriptor(descriptor);
        }

        full = (PCM_FULL_RESOURCE_DESCRIPTOR)descriptor;
    }
    PciDebugPrintf("\n");
}

static UCHAR InterfaceTypeUnknownText[]  = "** Unknown interface type **";

static PUCHAR InterfaceTypeText[] = {
    "InterfaceTypeUndefined",   // -1
    "Internal",                 // 0
    "Isa",                      // 1
    "Eisa",                     // 2
    "MicroChannel",             // 3
    "TurboChannel",             // 4
    "PCIBus",                   // 5
    "VMEBus",                   // 6
    "NuBus",                    // 7
    "PCMCIABus",                // 8
    "CBus",                     // 9
    "MPIBus",                   // 10
    "MPSABus",                  // 11
    "ProcessorInternal",        // 12
    "InternalPowerBus",         // 13
    "PNPISABus",                // 14
    "PNPBus"                    // 15
    };

PUCHAR
PciDebugInterfaceTypeToText(
    ULONG InterfaceType
    )
{
    if (InterfaceType < MaximumInterfaceType) {
        PCI_ASSERT(InterfaceType + 1 < sizeof(InterfaceTypeText) / sizeof(PUCHAR));
        return InterfaceTypeText[InterfaceType + 1];
    }
    return InterfaceTypeUnknownText;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\device.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    device.c

Abstract:

    This module contains functions associated with enumerating
    ordinary (PCI Header type 0) devices.

Author:

    Peter Johnston (peterj) 09-Mar-1997

Revision History:

--*/

#include "pcip.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, Device_MassageHeaderForLimitsDetermination)
#pragma alloc_text(PAGE, Device_SaveLimits)
#pragma alloc_text(PAGE, Device_SaveCurrentSettings)
#pragma alloc_text(PAGE, Device_GetAdditionalResourceDescriptors)

#endif

VOID
Device_MassageHeaderForLimitsDetermination(
    IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    The limits for a device are determined by writing ones to the
    Base Address Registers (BARs) and examining what the hardware does
    to them.  For example, if a device requires 256 bytes of space,
    writing 0xffffffff to the BAR which configures this requirement
    tells the device to begin decoding its 256 bytes at that address.
    Clearly this is impossible, at most one byte can be configured
    at that address.  The hardware will lower the address by clearing
    the least significant bits until the range requirement can be met.
    In this case, we would get 0xffffff00 back from the register when
    it is next read.

Arguments:

    This    - Pointer to a PCI driver "configurable" object.  This
              object contains configuration data for the function
              currently being configured.

Return Value:

    The Working configuration has been modified so that all range
    fields have been set to their maximum possible values.

    The Current configuration has been modified such that writing it
    to the hardware will restore the hardware to it's current (disabled)
    state.


--*/

{
    ULONG index;

    index = 0;

    //
    // PCI IDE controllers operating in legacy mode implement
    // the first 4 BARs but don't actually use them,... nor are
    // they initialized correctly, and sometimes, nothing will
    // change if we change them,... but we can't read them to determine
    // if they are implemented or not,... so,...
    //

    if (PCI_IS_LEGACY_IDE_CONTROLLER(This->PdoExtension)) {

        //
        // If both interfaces are in native mode and the BARs behave
        // normally.  If both are in legacy mode then we should skip
        // the first 4 BARs.  Any other combination is meaningless so
        // we skip the BARs and let PCIIDE take the system out when
        // its turn comes.
        //

        index = 4;
    }

    do {
        This->Working->u.type0.BaseAddresses[index] = 0xffffffff;
        index++;
    } while (index < PCI_TYPE0_ADDRESSES);

    //
    // Set the ROM to its maximum as well,... and disable it.
    //

    This->Working->u.type0.ROMBaseAddress =
        0xffffffff & PCI_ADDRESS_ROM_ADDRESS_MASK;

    return;
}

VOID
Device_RestoreCurrent(
    IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    Restore any type specific fields in the original copy of config
    space.   In the case of type 0 devices, there are none.

Arguments:

    This    - Pointer to a PCI driver "configurable" object.  This
              object contains configuration data for the function
              currently being configured.

Return Value:

    None.

--*/

{
    return;
}

VOID
Device_SaveLimits(
    IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    Fill in the Limit structure with a IO_RESOURCE_REQUIREMENT
    for each implemented BAR.

Arguments:

    This    - Pointer to a PCI driver "configurable" object.  This
              object contains configuration data for the function
              currently being configured.

Return Value:

    None.

--*/

{
    ULONG index;
    PIO_RESOURCE_DESCRIPTOR descriptor;
    PULONG bar = This->Working->u.type0.BaseAddresses;

    //
    // PCI IDE controllers operating in legacy mode implement
    // the first 4 BARs but don't actually use them,... nor are
    // they initialized correctly, and sometimes, nothing will
    // change if we change them,... but we can't read them to determine
    // if they are implemented or not,... so,...
    //

    if (PCI_IS_LEGACY_IDE_CONTROLLER(This->PdoExtension)) {

        //
        // If both interfaces are in native mode and the BARs behave
        // normally.  If both are in legacy mode then we should skip
        // the first 4 BARs.  Any other combination is meaningless so
        // we skip the BARs and let PCIIDE take the system out when
        // its turn comes.
        //
        //
        // Set the limit to zero in the first 4 bars so we will
        // 'detect' the bars as unimplemented.
        //

        for (index = 0; index < 4; index++) {
            bar[index] = 0;
        }
    }

#if defined(PCI_S3_HACKS)

    //
    // Check for S3 868 and 968.  These cards report memory
    // requirements of 32MB but decode 64MB.   Gross huh?
    //

#if defined(PCIIDE_HACKS)

    //
    // Ok, it looks gross but turning the above and below into
    // an elseif seems marginally more efficient.  plj.
    //

    else

#endif

    if (This->PdoExtension->VendorId == 0x5333) {

        USHORT deviceId = This->PdoExtension->DeviceId;

        if ((deviceId == 0x88f0) || (deviceId == 0x8880)) {
            for (index = 0; index < PCI_TYPE0_ADDRESSES; index++) {

                //
                // Check for memory requirement of 32MB and
                // change it to 64MB.
                //

                if (bar[index] == 0xfe000000) {
                    bar[index] = 0xfc000000;

                    PciDebugPrint(
                        PciDbgObnoxious,
                        "PCI - Adjusted broken S3 requirement from 32MB to 64MB\n"
                        );
                }
            }
        }
    }

#endif

#if defined(PCI_CIRRUS_54XX_HACK)

    //
    // This device reports an IO requirement of 0x400 ports, in
    // the second BAR.   What it really wants is access to the VGA
    // registers (3b0 thru 3bb and 3c0 thru 3df).  It will actually
    // allow them to move but (a) the driver doesn't understand this
    // and the device no longer sees the VGA registers, ie vga.sys
    // won't work any more, (b) if the device is under a bridge and
    // the ISA bit is set, we can't satisfy the requirement,.......
    // however, if we left it where it was, it will work under the
    // bridge as long as the bridge has the VGA bit set.
    //
    // Basically, Cirrus tried to make the VGA registers moveable
    // which is a noble thing, unfortunately the implementation
    // requires a bunch of software knowledge that across all the
    // drivers involved, we just don't have.
    //
    // Solution?  Delete the requirement.
    //

    if ((This->PdoExtension->VendorId == 0x1013) &&
        (This->PdoExtension->DeviceId == 0x00a0)) {

        //
        // If the second requirement is IO for length 0x400,
        // currently unassigned, don't report it at all.
        //

        if ((bar[1] & 0xffff) == 0x0000fc01) {

            //
            // Only do this if the device does not have a valid
            // current setting in this BAR.
            //

            if (This->Current->u.type0.BaseAddresses[1] == 1) {

                bar[1] = 0;

#if DBG

                PciDebugPrint(
                    PciDbgObnoxious,
                    "PCI - Ignored Cirrus GD54xx broken IO requirement (400 ports)\n"
                    );

            } else {

                PciDebugPrint(
                    PciDbgInformative,
                    "PCI - Cirrus GD54xx 400 port IO requirement has a valid setting (%08x)\n",
                    This->Current->u.type0.BaseAddresses[1]
                    );
#endif

            }

#if DBG

        } else {

            //
            // The device doesn't look like we expected it to, complain.
            // (unless 0 in which case we assume cirrus already fixed it).
            //

            if (bar[1] != 0) {
                PciDebugPrint(
                    PciDbgInformative,
                    "PCI - Warning Cirrus Adapter 101300a0 has unexpected resource requirement (%08x)\n",
                    bar[1]
                    );
            }
#endif

        }
    }

#endif

    descriptor = This->PdoExtension->Resources->Limit;

    //
    // Create an IO_RESOURCE_DESCRIPTOR for each implemented
    // resource supported by this function.
    //

    for (index = 0; index < PCI_TYPE0_ADDRESSES; index++) {
        if (PciCreateIoDescriptorFromBarLimit(descriptor, bar, FALSE)) {

            //
            // This base address register is 64 bit, skip one.
            //

            PCI_ASSERT((index+1) < PCI_TYPE0_ADDRESSES);

            index++;
            bar++;

            //
            // Null descriptor in place holder.
            //

            descriptor++;
            descriptor->Type = CmResourceTypeNull;
        }
        descriptor++;
        bar++;
    }

    //
    // Do the same for the ROM
    //

    PciCreateIoDescriptorFromBarLimit(descriptor,
                                      &This->Working->u.type0.ROMBaseAddress,
                                      TRUE);
}

VOID
Device_SaveCurrentSettings(
    IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    Fill in the Current array in the PDO extension with the current
    settings for each implemented BAR.

Arguments:

    This    - Pointer to a PCI driver "configurable" object.  This
              object contains configuration data for the function
              currently being configured.

Return Value:

    None.

--*/

{
    ULONG index;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptor;
    PULONG baseAddress = This->Current->u.type0.BaseAddresses;
    ULONG bar;
    ULONG addressMask;
    BOOLEAN nonZeroBars = FALSE;

    partial = This->PdoExtension->Resources->Current;
    ioResourceDescriptor = This->PdoExtension->Resources->Limit;

    //
    // Create an CM_PARTIAL_RESOURCE_DESCRIPTOR for each implemented
    // resource supported by this function.
    //
    // Note: SaveLimits must have been called before SaveCurrentSettings
    // so we can tell which BARs are implemented.
    //
    // Note: The following loop runs one extra time to get the ROM.
    //

    for (index = 0;
         index <= PCI_TYPE0_ADDRESSES;
         index++, partial++, ioResourceDescriptor++) {

        partial->Type = ioResourceDescriptor->Type;
        bar = *baseAddress++;

        //
        // If this BAR is not implemented, no further processing for
        // this partial descriptor.
        //

        if (partial->Type == CmResourceTypeNull) {
            continue;
        }

        //
        // Copy the length from the limits descriptor, then we
        // actually need to do a little processing to figure out
        // the current limits.
        //

        partial->Flags = ioResourceDescriptor->Flags;
        partial->ShareDisposition = ioResourceDescriptor->ShareDisposition;
        partial->u.Generic.Length = ioResourceDescriptor->u.Generic.Length;
        partial->u.Generic.Start.HighPart = 0;

        if (index == PCI_TYPE0_ADDRESSES) {

            bar = This->Current->u.type0.ROMBaseAddress;
            addressMask = PCI_ADDRESS_ROM_ADDRESS_MASK;

            //
            // If the ROM Enabled bit is clear, don't record
            // a current setting for this ROM BAR.
            //

            if ((bar & PCI_ROMADDRESS_ENABLED) == 0) {
                partial->Type = CmResourceTypeNull;
                continue;
            }

        } else if (bar & PCI_ADDRESS_IO_SPACE) {

            PCI_ASSERT(partial->Type == CmResourceTypePort);
            addressMask = PCI_ADDRESS_IO_ADDRESS_MASK;

        } else {

            PCI_ASSERT(partial->Type == CmResourceTypeMemory);
            addressMask = PCI_ADDRESS_MEMORY_ADDRESS_MASK;

            if ((bar & PCI_ADDRESS_MEMORY_TYPE_MASK) == PCI_TYPE_64BIT) {

                //
                // This is a 64 bit PCI device.  Get the high 32 bits
                // from the next BAR.
                //

                partial->u.Generic.Start.HighPart = *baseAddress;

            } else if ((bar & PCI_ADDRESS_MEMORY_TYPE_MASK) == PCI_TYPE_20BIT) {

                //
                // This device must locate below 1MB, the BAR shouldn't
                // have any top bits set but this isn't clear from the
                // spec.  Enforce it by clearing the top bits.
                //

                addressMask &= 0x000fffff;

            }
        }
        partial->u.Generic.Start.LowPart = bar & addressMask;

        if (partial->u.Generic.Start.QuadPart == 0) {

            //
            // No current setting if the value is current setting
            // is 0.
            //

            partial->Type = CmResourceTypeNull;
            continue;
        }
        nonZeroBars = TRUE;
    }

    //
    // Save type 0 specific data in the PDO.
    //

    This->PdoExtension->SubsystemVendorId =
        This->Current->u.type0.SubVendorID;
    This->PdoExtension->SubsystemId =
        This->Current->u.type0.SubSystemID;
}

VOID
Device_ChangeResourceSettings(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    )

/*++

Description:

    Reconfigure each BAR using the settings from the Current array
    in the PDO extension.   All we actually do here is write the new
    settings into the memory pointed to by CommonConfig, the actual
    write to the hardware is done elsewhere.

    Note:  Possibly not all BARs will be changed, at least one has
    changed or this routine would not have been called.

Arguments:

    PdoExtension    A pointer to the PDO extension for this device.
    CurrentConfig   A pointer to the current contents of PCI config
                    space.

Return Value:

    None.

--*/

{
    ULONG index;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
    PULONG baseAddress;
    ULONG bar;
    ULONG lowPart;

    if (PdoExtension->Resources == NULL) {

        //
        // Nothing to play with.
        //
        return;
    }

    partial = PdoExtension->Resources->Current;
    baseAddress = CommonConfig->u.type0.BaseAddresses;

    for (index = 0;
         index <= PCI_TYPE0_ADDRESSES;
         index++, partial++, baseAddress++) {

        //
        // If this BAR is not implemented, no further processing for
        // this partial descriptor.
        //

        if (partial->Type == CmResourceTypeNull) {
            continue;
        }

        lowPart = partial->u.Generic.Start.LowPart;

        bar = *baseAddress;

        if (index == PCI_TYPE0_ADDRESSES) {

            PCI_ASSERT(partial->Type == CmResourceTypeMemory);

            bar = CommonConfig->u.type0.ROMBaseAddress;
            bar &= ~PCI_ADDRESS_ROM_ADDRESS_MASK;
            bar |= (lowPart & PCI_ADDRESS_ROM_ADDRESS_MASK);
            CommonConfig->u.type0.ROMBaseAddress = bar;

        } else if (bar & PCI_ADDRESS_IO_SPACE) {

            PCI_ASSERT(partial->Type == CmResourceTypePort);

            *baseAddress = lowPart;

        } else {

            PCI_ASSERT(partial->Type == CmResourceTypeMemory);

            *baseAddress = lowPart;

            if ((bar & PCI_ADDRESS_MEMORY_TYPE_MASK) == PCI_TYPE_64BIT) {

                //
                // This is a 64 bit address.  Need to set the upper
                // 32 bits in the next BAR.
                //

                baseAddress++;
                *baseAddress = partial->u.Generic.Start.HighPart;

                //
                // We need to skip the next partial entry and descrement
                // the loop count because we consumed a BAR here.
                //

                index++;
                partial++;

#if DBG

            } else if ((bar & PCI_ADDRESS_MEMORY_TYPE_MASK) == PCI_TYPE_20BIT) {

                //
                // This device must locate below 1MB, make sure we're
                // configuring it that way.
                //

                PCI_ASSERT((lowPart & 0xfff00000) == 0);

#endif

            }
        }
    }
}

VOID
Device_GetAdditionalResourceDescriptors(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig,
    IN PIO_RESOURCE_DESCRIPTOR Resource
    )
{
    //
    // Type 0 (devices) don't require resources not adequately
    // described in the BARs.
    //

    return;
}

NTSTATUS
Device_ResetDevice(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    )
{
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\busno.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    busno.c

Abstract:

    This module implements routines pertaining to PCI bus numbers.

Author:

    Andy Thornton (andrewth) 9/5/98

Revision History:

--*/

#include "pcip.h"

VOID
PciSpreadBridges(
    IN PPCI_FDO_EXTENSION Parent,
    IN UCHAR BridgeCount
    );

UCHAR
PciFindBridgeNumberLimit(
    IN PPCI_FDO_EXTENSION BridgeParent,
    IN UCHAR Base
    );

VOID
PciFitBridge(
    IN PPCI_FDO_EXTENSION ParentFdoExtension,
    IN PPCI_PDO_EXTENSION BridgePdoExtension
    );

VOID
PciSetBusNumbers(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN UCHAR Primary,
    IN UCHAR Secondary,
    IN UCHAR Subordinate
    );

VOID
PciUpdateAncestorSubordinateBuses(
    IN PPCI_FDO_EXTENSION FdoExtension,
    IN UCHAR Subordinate
    );

VOID
PciDisableBridge(
    IN PPCI_PDO_EXTENSION Bridge
    );

UCHAR
PciFindBridgeNumberLimitWorker(
    IN PPCI_FDO_EXTENSION BridgeParent,
    IN PPCI_FDO_EXTENSION CurrentParent,
    IN UCHAR Base,
    OUT PBOOLEAN RootConstrained
    );


#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, PciConfigureBusNumbers)
#pragma alloc_text(PAGE, PciAreBusNumbersConfigured)
#pragma alloc_text(PAGE, PciSpreadBridges)
#pragma alloc_text(PAGE, PciFindBridgeNumberLimit)
#pragma alloc_text(PAGE, PciFitBridge)
#pragma alloc_text(PAGE, PciSetBusNumbers)
#pragma alloc_text(PAGE, PciUpdateAncestorSubordinateBuses)
#pragma alloc_text(PAGE, PciDisableBridge)
#pragma alloc_text(PAGE, PciFindBridgeNumberLimitWorker)

#endif


VOID
PciConfigureBusNumbers(
    PPCI_FDO_EXTENSION Parent
    )

/*++

Routine Description:

    This routine is called after scanning a PCI bus (root or bridge) and
    configures the bus numbers for any newly encountered bridges if possible.

    Any unconfigurable bridges will be set to Primary = Secondary = Subordinate = 0
    and their IO, Memory and BusMaster bits will be disabled.  When PCI is later
    asked to Add to them it will fail.

    The Parent->Mutex lock should be held before calling this function

Arguments:

    Parent - The bridge we have just enumerated.

Return Value:

    Status.

--*/

{
    PPCI_PDO_EXTENSION current, parentPdo = NULL;
    UCHAR bridgeCount = 0, configuredBridgeCount = 0;

    PAGED_CODE();

    if (!PCI_IS_ROOT_FDO(Parent)) {
        parentPdo = (PPCI_PDO_EXTENSION)Parent->PhysicalDeviceObject->DeviceExtension;
    }

    //
    // Walk the list of child PDO's for this bus and count the number of
    // bridges and configured bridges
    //
    ExAcquireFastMutex(&Parent->ChildListMutex);

    for (current = Parent->ChildBridgePdoList;
         current;
         current = current->NextBridge) {

        if (current->NotPresent) {
            PciDebugPrint(PciDbgBusNumbers,
                          "Skipping not present bridge PDOX @ %p\n",
                          current
                         );
            continue;
        }

        bridgeCount++;

        //
        // If we configured the parent then all the children are considered
        // to be unconfigured.  Root buses are always configured
        //

        if ((parentPdo &&
             parentPdo->Dependent.type1.WeChangedBusNumbers &&
             (current->DeviceState == PciNotStarted))
             || (!PciAreBusNumbersConfigured(current))) {

            //
            // Disable this bridge and we will fix it later
            //
            PciDisableBridge(current);

        } else {

            //
            // The bios must have configured this bridge and it looks valid so
            // leave it alone!
            //

            configuredBridgeCount++;
        }
    }

    ExReleaseFastMutex(&Parent->ChildListMutex);

    //
    // Now there are four posibilities...
    //

    if (bridgeCount == 0) {

        //
        // There are no bridges so not a lot to do...
        //

        PciDebugPrint(PciDbgBusNumbers,
                      "PCI - No bridges found on bus 0x%x\n",
                      Parent->BaseBus
                     );


    } else if (bridgeCount == configuredBridgeCount) {

        //
        // All the bridges are configured - still not a lot to do...
        //

        PciDebugPrint(PciDbgBusNumbers,
              "PCI - 0x%x bridges found on bus 0x%x - all already configured\n",
             bridgeCount,
             Parent->BaseBus
             );


    } else if (configuredBridgeCount == 0) {

        PciDebugPrint(PciDbgBusNumbers,
              "PCI - 0x%x bridges found on bus 0x%x - all need configuration\n",
             bridgeCount,
             Parent->BaseBus
             );

        //
        // All the bridges require configuration so we should use a spreading
        // out algorithm
        //

        PciSpreadBridges(Parent, bridgeCount);

    } else {

        //
        // Some of the bridges are configured and some are not - we should try
        // to fit the unconfigured ones into the holes left by the configured
        // ones
        //

        PCI_ASSERT(configuredBridgeCount < bridgeCount);

        PciDebugPrint(PciDbgBusNumbers,
              "PCI - 0x%x bridges found on bus 0x%x - 0x%x need configuration\n",
             bridgeCount,
             Parent->BaseBus,
             bridgeCount - configuredBridgeCount
             );


        //
        // Walk the list of PDO's again and configure each one seperatly
        //

        for (current = Parent->ChildBridgePdoList;
             current;
             current = current->NextBridge) {

            if (current->NotPresent) {
                PciDebugPrint(PciDbgBusNumbers,
                              "Skipping not present bridge PDOX @ %p\n",
                              current
                             );
                continue;
            }

            //
            // Fit the bridge if we disabled it.
            //

            if ((parentPdo &&
                 parentPdo->Dependent.type1.WeChangedBusNumbers &&
                 (current->DeviceState == PciNotStarted))
                 || (!PciAreBusNumbersConfigured(current))) {

                PCI_ASSERT(current->Dependent.type1.PrimaryBus == 0
                       && current->Dependent.type1.SecondaryBus == 0
                       && current->Dependent.type1.SubordinateBus == 0
                       );

                PciFitBridge(Parent, current);
            }
        }
    }
}



BOOLEAN
PciAreBusNumbersConfigured(
    IN PPCI_PDO_EXTENSION Bridge
    )
/*++

Routine Description:

    This checks if the bus numbers assigned to the bridge are valid

Arguments:

    Bridge - the bridge to check

Return Value:

    TRUE if numbers are valid FALSE otherwise.

--*/

{
    PAGED_CODE();

    //
    // Check this bridge is configured to run on the bus we found it.
    //

    if (Bridge->Dependent.type1.PrimaryBus != Bridge->ParentFdoExtension->BaseBus) {
        return FALSE;
    }

    //
    // Ensure the child bus number is greater than the parent bus.
    // (HP Omnibooks actually break this rule when not plugged into
    // their docking stations).
    //

    if (Bridge->Dependent.type1.SecondaryBus <= Bridge->Dependent.type1.PrimaryBus) {
        return FALSE;
    }

    //
    // And finally, make sure the secondary bus is in the range
    // of busses the bridge is programmed for.  Paranoia.
    //

    if (Bridge->Dependent.type1.SubordinateBus < Bridge->Dependent.type1.SecondaryBus) {
        return FALSE;
    }

    return TRUE;
}



VOID
PciSpreadBridges(
    IN PPCI_FDO_EXTENSION Parent,
    IN UCHAR BridgeCount
    )

/*++

Routine Description:

    This routine attemps to spread out the available bus numbers between the
    unconfigured bridges.  It is only called if ALL the bridges on a particular
    bus are not configured - eg we just hot docked!

    If a particular brigde can not be configured it is disabled (Decodes OFF and
    bus number 0->0-0) and the subsequent AddDevice will fail.

Arguments:

    Parent - The FDO extension for the bridge we are enumerating.

    BridgeCount - The number of bridges at this level

Return Value:

    None

--*/

{
    UCHAR base, limit, numberCount, currentNumber, spread, maxAssigned = 0;
    PPCI_PDO_EXTENSION current;

    PAGED_CODE();

    PCI_ASSERT(Parent->BaseBus < PCI_MAX_BRIDGE_NUMBER);

    //
    // Seeing as we only get here if all the bridges arn't configured the base
    // is the lowest bus out parent passes
    //

    base = (UCHAR)Parent->BaseBus;

    //
    // The limit is constrained by the siblings of the parent bridge or in the
    // case that there are none, by the siblings of the parent's parent and so on
    // until we find a sibling or run out of buses in which case the constraint
    // is the maximum bus number passed by this root.
    //

    limit = PciFindBridgeNumberLimit(Parent, base);

    if (limit < base) {
        //
        // This normally means the BIOS or HAL messed up and got the subordinate
        // bus number for the root bus wrong.  There's not much we can do..
        //

        PCI_ASSERT(limit >= base);

        return;
    }

    //
    // Now see if we have enough numbers available to number all the busses
    //

    numberCount = limit - base;

    if (numberCount == 0) {
        //
        // We don't have any bus numbers available - bail now
        //
        return;

    } else if (BridgeCount >= numberCount) {
        //
        // We have just/not enough - don't spread things out!
        //
        spread = 1;

    } else {

        //
        // Try and spread things out a bit so we can accomodate subordinate
        // bridges of the one we are configuring.  Also leave some space on the
        // parent bus for any bridges that appear here (the + 1).  As we have no idea
        // what is behind each bridge treat them equally...
        //

        spread = numberCount / (BridgeCount + 1);
    }

    //
    // Now assign the bus numbers - we have already disabled all the unconfigured
    // bridges
    //
    currentNumber = base + 1;

    for (current = Parent->ChildBridgePdoList;
         current;
         current = current->NextBridge) {

        if (current->NotPresent) {
            PciDebugPrint(PciDbgBusNumbers,
                          "Skipping not present bridge PDOX @ %p\n",
                          current
                         );
            continue;
        }


        //
        // Now go and write it out to the hardware
        //

        PCI_ASSERT(!PciAreBusNumbersConfigured(current));

        //
        // Primary is the bus we are on, secondary is our bus number.
        // We don't know if there are any bridges there - we have left space
        // just in case - therefore we don't pass any bus numbers.  If we
        // need to, the subordinate number can be updated later.
        //

        PciSetBusNumbers(current,
                         base,
                         currentNumber,
                         currentNumber
                         );

        //
        // Remember the max number we assigned
        //

        maxAssigned = currentNumber;

        //
        // Check if we have run out of numbers
        //

        if ((currentNumber + spread) < currentNumber // wrapped
        ||  (currentNumber + spread) > limit) {

            break;

        } else {
            //
            // Move onto the next number
            //
            //currentNumber += spread;
            currentNumber = currentNumber + spread;
        }
    }

    //
    // Now we have programmed the bridges - we need to go back and update the
    // subordinate bus numbers for all ancestor bridges.
    //

    PCI_ASSERT(maxAssigned > 0);

    PciUpdateAncestorSubordinateBuses(Parent, maxAssigned);

}

UCHAR
PciFindBridgeNumberLimitWorker(
    IN PPCI_FDO_EXTENSION BridgeParent,
    IN PPCI_FDO_EXTENSION CurrentParent,
    IN UCHAR Base,
    OUT PBOOLEAN RootConstrained
    )

/*++

Routine Description:

    This determines the subordinate bus number a bridge on the bus BridgeParent
    with secondary number Base can have given the constraints of the configured
    busses in the system.

Arguments:

    BridgeParent - The bus on which the bridge resides

    CurrentParent - The current bridge we are looking at (used for synchronization)

    Base - The primary bus number of this bridge (ie the parent's secondary bus number)

    Constraint - The number of the bus that constrains us

    RootConstrained - Set to TRUE if we were constrained by a root appeture, FALSE
        if constrained by another bridge

Return Value:

    None

--*/
{
    PPCI_PDO_EXTENSION current;
    UCHAR currentNumber, closest = 0;

    PAGED_CODE();

    if (BridgeParent != CurrentParent) {

        //
        // We're going to mess with the child pdo list - lock the state...
        //
        ExAcquireFastMutex(&CurrentParent->ChildListMutex);
    }

    //
    // Look for any bridge that will constrain us
    //

    for (current = CurrentParent->ChildBridgePdoList;
         current;
         current = current->NextBridge) {

        if (current->NotPresent) {
            PciDebugPrint(PciDbgBusNumbers,
                          "Skipping not present bridge PDOX @ %p\n",
                          current
                         );
            continue;
        }

        //
        // Unconfigured bridges can't constrain us
        //

        if (!PciAreBusNumbersConfigured(current)) {
            continue;
        }

        currentNumber = current->Dependent.type1.SecondaryBus;

        if (currentNumber > Base
        && (currentNumber < closest || closest == 0)) {
            closest = currentNumber;
        }
    }


    //
    // If we haven't found a closest bridge then move up one level - yes this
    // is recursive but is bounded by the depth of the pci tree is the best way
    // of dealing with the hierarchial locking.
    //
    if (closest == 0) {

        if (CurrentParent->ParentFdoExtension == NULL) {

            //
            // We have reached the root without finding a sibling
            //

            *RootConstrained = TRUE;
            closest = CurrentParent->MaxSubordinateBus;

        } else {

            closest = PciFindBridgeNumberLimitWorker(BridgeParent,
                                                     CurrentParent->ParentFdoExtension,
                                                     Base,
                                                     RootConstrained
                                                     );
        }

    } else {

        //
        // We are constrained by a bridge so by definition not by a root.
        //

        *RootConstrained = FALSE;
    }

    if (BridgeParent != CurrentParent) {

        ExReleaseFastMutex(&CurrentParent->ChildListMutex);
    }

    return closest;

}

UCHAR
PciFindBridgeNumberLimit(
    IN PPCI_FDO_EXTENSION Bridge,
    IN UCHAR Base
    )

/*++

Routine Description:

    This determines the subordinate bus number a bridge on the bus BridgeParent
    with secondary number Base can have given the constraints of the configured
    busses in the system.

Arguments:

    BridgeParent - The bus on which the bridge resides

    Base - The primary bus number of this bridge (ie the parent's secondary bus number)

Return Value:

    The max subordinate value.

--*/
{

    BOOLEAN rootConstrained;
    UCHAR constraint;

    PAGED_CODE();

    constraint = PciFindBridgeNumberLimitWorker(Bridge,
                                                Bridge,
                                                Base,
                                                &rootConstrained
                                                );



    if (rootConstrained) {

        //
        // We are constrained by the maximum bus number that this root bus passes
        // - this is therefore the max subordinate bus.
        //

        return constraint;

    } else {

        //
        // If we are not constrained by a root bus we must be constrained by a
        // bridge and thus the max subordinate value we can assign to the bus is
        // one less that the bridge that constrained us. (A bridge must have a
        // bus number greater that 1 so we can't wrap)
        //

        PCI_ASSERT(constraint > 0);
        return constraint - 1;
    }
}

VOID
PciFitBridge(
    IN PPCI_FDO_EXTENSION Parent,
    IN PPCI_PDO_EXTENSION Bridge
    )
/*++

Routine Description:

    This routine attemps to find a range of bus numbers for Bridge given the
    constraints of the already configured bridges.

    If a particular brigde can not be configured it is disabled (Decodes OFF and
    bus number 0->0-0) and the subsequent AddDevice will fail.

Arguments:

    Parent - The FDO extension for the bridge we are enumerating.

    Bridge - The brige we want to configure

Return Value:

    None

--*/

{
    PPCI_PDO_EXTENSION current;
    UCHAR base, limit, gap, bestBase = 0, biggestGap = 0, lowest = 0xFF;

    PAGED_CODE();

    for (current = Parent->ChildBridgePdoList;
         current;
         current = current->NextBridge) {

        if (current->NotPresent) {
            PciDebugPrint(PciDbgBusNumbers,
                          "Skipping not present bridge PDOX @ %p\n",
                          current
                         );
            continue;
        }


        //
        // Only look at configured bridges - buses we disabled have
        // bus numbers 0->0-0 which is helpfully invalid
        //

        if (PciAreBusNumbersConfigured(current)) {

            //
            // Get the base and limit for each bridge and calculate which bridge
            // has the biggest gap.
            //

            base = (UCHAR) current->Dependent.type1.SubordinateBus;
            limit = PciFindBridgeNumberLimit(Parent, base);

            //
            // This ASSERT might fail if a BIOS or HAL misreported the limits
            // of a root bridge. For example, an ACPI BIOS might have a _CRS
            // for the root bridge that specifies bus-numbers 0 to 0 (length 1)
            // are passed down, even though the real range is 0 to 255.
            //

            PCI_ASSERT(limit >= base);

            gap = limit - base;

            if (gap > biggestGap) {

                PCI_ASSERT(gap > 0);

                biggestGap = gap;
                bestBase = base + 1;
            }

            if (current->Dependent.type1.SecondaryBus < lowest) {
                lowest = current->Dependent.type1.SecondaryBus;
            }
        }
    }

    //
    // Now make sure the gap between the bus we are on and the first bridge
    // is not the biggest - lowest must always be greater that the parents bus
    // number or it is miss configured and would have failed the
    // BusNumbersConfigured test above.
    //

    PCI_ASSERT(lowest > Parent->BaseBus);

    gap = lowest - (Parent->BaseBus + 1);

    if (gap > biggestGap) {

        PCI_ASSERT(gap > 0);

        biggestGap = gap;
        bestBase = Parent->BaseBus + 1;
    }

    //
    // Did we find anywhere to put the bridge?
    //

    if (biggestGap >= 1) {

        //
        // Ok - we have some space to play with so we can configure out bridge
        // right in the middle of the gap, if the bestGap is 1 (ie the bridge
        // just fits) then this still works.
        //

        base = bestBase + (biggestGap / 2);

        //
        // Set subordinate equal to secondary as we are just leaving room for
        // any bridges.
        //

        PciSetBusNumbers(Bridge, Parent->BaseBus, base, base);

        //
        // Update the ancestor subordinates if we configured the bridge
        //

        PciUpdateAncestorSubordinateBuses(Parent,
                                          Bridge->Dependent.type1.SecondaryBus
                                          );

    }
}

VOID
PciSetBusNumbers(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN UCHAR Primary,
    IN UCHAR Secondary,
    IN UCHAR Subordinate
    )
/*++

Routine Description:

    This routine sets the bus numbers for a bridge and tracks if we have changed
    bus numbers.

Arguments:

    PdoExtension - The PDO for the bridge

    Primary - The primary bus number to assign

    Secondary - The secondary bus number to assign

    Subordinate - The subordinate bus number to assign


Return Value:

    None

--*/

{
    PCI_COMMON_HEADER commonHeader;
    PPCI_COMMON_CONFIG commonConfig = (PPCI_COMMON_CONFIG)&commonHeader;

    PAGED_CODE();

    PCI_ASSERT(Primary < Secondary || (Primary == 0 && Secondary == 0));
    PCI_ASSERT(Secondary <= Subordinate);

    //
    // Fill in in the config. Note that the Primary/Secondary/Subordinate bus
    // numbers are in the same place for type1 and type2 headers.
    //

    commonConfig->u.type1.PrimaryBus = Primary;
    commonConfig->u.type1.SecondaryBus = Secondary;
    commonConfig->u.type1.SubordinateBus = Subordinate;

    //
    // Grab the PCI Bus lock - this will let hwverifier reliably check the
    // config space against our extension.
    //

    ExAcquireFastMutex(&PciBusLock);

    //
    // Remember in the PDO
    //

    PdoExtension->Dependent.type1.PrimaryBus = Primary;
    PdoExtension->Dependent.type1.SecondaryBus = Secondary;
    PdoExtension->Dependent.type1.SubordinateBus = Subordinate;
    PdoExtension->Dependent.type1.WeChangedBusNumbers = TRUE;

    PciWriteDeviceConfig(
        PdoExtension,
        &commonConfig->u.type1.PrimaryBus,
        FIELD_OFFSET(PCI_COMMON_CONFIG, u.type1.PrimaryBus),
        sizeof(Primary) + sizeof(Secondary) + sizeof(Subordinate)
        );

    ExReleaseFastMutex(&PciBusLock);
}


VOID
PciUpdateAncestorSubordinateBuses(
    IN PPCI_FDO_EXTENSION FdoExtension,
    IN UCHAR Subordinate
    )
/*++

Routine Description:

    This routine walks the bridge hierarchy updating the subordinate bus numbers
    of each ancestor to ensure that numbers up to Subordinate are passed.

Arguments:

    FdoExtension - The Fdo for the parent of the bridge(s) we have just configured

    Subordinate - The maximum (subordinate) bus number to pass


Return Value:

    None

--*/

{
    PPCI_FDO_EXTENSION current;
    PPCI_PDO_EXTENSION currentPdo;

    PAGED_CODE();

    //
    // For all ancestors except the root update the subordinate bus number
    //

    for (current = FdoExtension;
         current->ParentFdoExtension;  // Root has no parent
         current = current->ParentFdoExtension) {

        currentPdo = (PPCI_PDO_EXTENSION)current->PhysicalDeviceObject->DeviceExtension;

        PCI_ASSERT(!currentPdo->NotPresent);

        if (currentPdo->Dependent.type1.SubordinateBus < Subordinate) {

            currentPdo->Dependent.type1.SubordinateBus = Subordinate;

            PciWriteDeviceConfig(currentPdo,
                                  &Subordinate,
                                  FIELD_OFFSET(PCI_COMMON_CONFIG,
                                               u.type1.SubordinateBus),
                                  sizeof(Subordinate)
                                  );

        }
    }

    //
    // Ok so now we're at the root - can't be too careful on a checked build
    // so lets make sure the subordinate value we came up with actually gets
    // down this root...
    //

    PCI_ASSERT(PCI_IS_ROOT_FDO(current));
    PCI_ASSERT(Subordinate <= current->MaxSubordinateBus);

}

VOID
PciDisableBridge(
    IN PPCI_PDO_EXTENSION Bridge
    )

/*++

Routine Description:

    This routine disables a bridge by turing of its decodes and zeroing its
    bus numbers.

Arguments:

    PdoExtension - The PDO for the bridge

Return Value:

    node
--*/


{
    PAGED_CODE();

    PCI_ASSERT(Bridge->DeviceState == PciNotStarted);

    //
    // Zero all the bus numbers so we shouldn't pass any config cycles
    //

    PciSetBusNumbers(Bridge, 0, 0, 0);

    // NTRAID #62594 - 04/03/2000 - andrewth
    // Close the windows in case this is the VGA bridge which we must
    // leave decoding...

    //
    // Turn off the decodes so we don't pass IO or Memory cycles and bus
    // master so we don't generate any
    //

    PciDecodeEnable(Bridge, FALSE, NULL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\cardbus.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    cardbus.c

Abstract:

    This module contains functions associated with enumerating
    PCI to Cardbus bridges (PCI Header Type 2).

    This module also contain Cardbus/Pci Private interface functions.

Author:

    Peter Johnston (peterj) 09-Mar-1997

Revision History:

--*/

#include "pcip.h"

//
// Prototypes for routines exposed only thru the "interface"
// mechanism.
//

NTSTATUS
pcicbintrf_AddCardBus(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID * DeviceContext
    );

NTSTATUS
pcicbintrf_DeleteCardBus(
    IN PVOID DeviceContext
    );

NTSTATUS
pcicbintrf_DispatchPnp(
    IN PVOID DeviceContext,
    IN PIRP  Irp
    );

NTSTATUS
pcicbintrf_GetLocation(
    IN PDEVICE_OBJECT Pdo,
    OUT UCHAR *Bus,
    OUT UCHAR *DeviceNumber,
    OUT UCHAR *FunctionNumber,
    OUT BOOLEAN *OnDebugPath
    );

NTSTATUS
pcicbintrf_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    );

VOID
pcicbintrf_Reference(
    IN PVOID Context
    );

VOID
pcicbintrf_Dereference(
    IN PVOID Context
    );

NTSTATUS
pcicbintrf_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    );

//
// Define the PCI-Cardbus private interface.
//

PCI_INTERFACE PciCardbusPrivateInterface = {
    &GUID_PCI_CARDBUS_INTERFACE_PRIVATE,    // InterfaceType
    sizeof(PCI_CARDBUS_INTERFACE_PRIVATE),  // MinSize
    PCI_CB_INTRF_VERSION,                   // MinVersion
    PCI_CB_INTRF_VERSION,                   // MaxVersion
    PCIIF_PDO,                              // Flags
    0,                                      // ReferenceCount
    PciInterface_PciCb,                     // Signature
    pcicbintrf_Constructor,                 // Constructor
    pcicbintrf_Initializer                  // Instance Initializer
};
#ifdef ALLOC_PRAGMA

//
// Query Interface routines
//

#pragma alloc_text(PAGE, pcicbintrf_AddCardBus)
#pragma alloc_text(PAGE, pcicbintrf_DeleteCardBus)
#pragma alloc_text(PAGE, pcicbintrf_DispatchPnp)

#pragma alloc_text(PAGE, pcicbintrf_Constructor)
#pragma alloc_text(PAGE, pcicbintrf_Dereference)
#pragma alloc_text(PAGE, pcicbintrf_Initializer)
#pragma alloc_text(PAGE, pcicbintrf_Reference)

//
// Standard PCI enumeration routines
//

#pragma alloc_text(PAGE, Cardbus_MassageHeaderForLimitsDetermination)
#pragma alloc_text(PAGE, Cardbus_SaveLimits)
#pragma alloc_text(PAGE, Cardbus_SaveCurrentSettings)
#pragma alloc_text(PAGE, Cardbus_GetAdditionalResourceDescriptors)

#endif


NTSTATUS
pcicbintrf_AddCardBus(
    IN      PDEVICE_OBJECT  ControllerPdo,
    IN OUT  PVOID          *DeviceContext
    )
{
    PPCI_PDO_EXTENSION controllerPdoExtension;
    PPCI_FDO_EXTENSION fdoExtension = NULL;
    PPCI_FDO_EXTENSION parent;
    NTSTATUS status;

    PciDebugPrint(
        PciDbgCardBus,
        "PCI - AddCardBus FDO for PDO %08x\n",
        ControllerPdo
        );

    //
    // DeviceObject is the PDO for this CardBus controller.   Ensure
    // the PCI driver created it and knows what it is.
    //

    controllerPdoExtension = (PPCI_PDO_EXTENSION)ControllerPdo->DeviceExtension;

    ASSERT_PCI_PDO_EXTENSION(controllerPdoExtension);

    if ((controllerPdoExtension->BaseClass != PCI_CLASS_BRIDGE_DEV) ||
        (controllerPdoExtension->SubClass  != PCI_SUBCLASS_BR_CARDBUS)) {

        PCI_ASSERT(controllerPdoExtension->BaseClass == PCI_CLASS_BRIDGE_DEV);
        PCI_ASSERT(controllerPdoExtension->SubClass  == PCI_SUBCLASS_BR_CARDBUS);
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto cleanup;
    }

    //
    // Sanity check.
    //

    parent = PCI_PARENT_FDOX(controllerPdoExtension);

    if (    (controllerPdoExtension->Dependent.type2.PrimaryBus !=
             parent->BaseBus)
        ||  (controllerPdoExtension->Dependent.type2.SecondaryBus <=
             parent->BaseBus)
        ||  (controllerPdoExtension->Dependent.type2.SubordinateBus <
             controllerPdoExtension->Dependent.type2.SecondaryBus)
       ) {

        PciDebugPrint(
            PciDbgAlways,
            "PCI Cardbus Bus Number configuration error (%02x>=%02x>%02x=%02x)\n",
            controllerPdoExtension->Dependent.type2.SubordinateBus,
            controllerPdoExtension->Dependent.type2.SecondaryBus,
            controllerPdoExtension->Dependent.type2.PrimaryBus,
            parent->BaseBus
            );

        PCI_ASSERT(controllerPdoExtension->Dependent.type2.PrimaryBus == parent->BaseBus);
        PCI_ASSERT(controllerPdoExtension->Dependent.type2.SecondaryBus > parent->BaseBus);
        PCI_ASSERT(controllerPdoExtension->Dependent.type2.SubordinateBus >=
               controllerPdoExtension->Dependent.type2.SecondaryBus);

        status = STATUS_INVALID_DEVICE_REQUEST;
        goto cleanup;
    }

    fdoExtension = ExAllocatePool(NonPagedPool, sizeof(PCI_FDO_EXTENSION));
    if (fdoExtension == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;

    }
    
    PciInitializeFdoExtensionCommonFields(
        fdoExtension,
        parent->FunctionalDeviceObject, // borrow parent's fdo
        ControllerPdo
        );

    //
    // We are probably only going to see QUERY_DEVICE_RELATIONS
    // Irps so initialize the FDO extension to a working state.
    //

    fdoExtension->PowerState.CurrentSystemState = PowerSystemWorking;
    fdoExtension->PowerState.CurrentDeviceState = PowerDeviceD0;
    fdoExtension->DeviceState = PciStarted;
    fdoExtension->TentativeNextState = PciStarted;
    fdoExtension->BaseBus = controllerPdoExtension->Dependent.type2.SecondaryBus;

    //
    // Copy the access methods from the root fdo and set
    // the root fdo back pointer.
    //

    fdoExtension->BusRootFdoExtension = parent->BusRootFdoExtension;

    //
    // Initialize arbiters for this FDO.
    //

    status = PciInitializeArbiters(fdoExtension);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Point the PDOextension to the new FDOextension (also indicates
    // the object is a bridge) and vice versa.
    //

    controllerPdoExtension->BridgeFdoExtension = fdoExtension;
    fdoExtension->ParentFdoExtension = parent;

    //
    // Flag that this FDO extension doesn't have a REAL FDO
    // associated with it.
    //

    fdoExtension->Fake = TRUE;

    //
    // Normaly we set the arbiter's ranges on a START_DEVICE IRP
    // but this has happened long before we get here so we must
    // regenerate the resource list.
    //

    {
        PCM_RESOURCE_LIST allocatedResources;

        status = PciQueryResources(
                     controllerPdoExtension,
                     &allocatedResources
                     );

        if (NT_SUCCESS(status)) {

            //
            // Note: there's really not much that can be done if
            // the above failed,...
            //
            // Note: Find the first memory range, it should be length
            // 0x1000, we really don't want the arbiter using this so
            // nullify it.
            //

            PCM_FULL_RESOURCE_DESCRIPTOR    full;
            PCM_PARTIAL_RESOURCE_LIST       partial;
            PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor;
            ULONG                           count;

            PCI_ASSERT(allocatedResources != NULL);
            PCI_ASSERT(allocatedResources->Count == 1);

            full = allocatedResources->List;            PCI_ASSERT(full);
            partial = &full->PartialResourceList;       PCI_ASSERT(partial);
            descriptor = partial->PartialDescriptors;   PCI_ASSERT(descriptor);
            count = partial->Count;                     PCI_ASSERT(count);

            while (count--) {
                if (descriptor->Type == CmResourceTypeMemory) {
                    PCI_ASSERT(descriptor->u.Generic.Length == 4096);
                    descriptor->Type = CmResourceTypeNull;
                    break;
                }
            }
            status = PciInitializeArbiterRanges(fdoExtension, allocatedResources);
            PCI_ASSERT(NT_SUCCESS(status));
            ExFreePool(allocatedResources);
        }
    }

    //
    // Insert this Fdo in the list of PCI parent Fdos.
    //

    PciInsertEntryAtTail(&PciFdoExtensionListHead,
                         &fdoExtension->List,
                         &PciGlobalLock);

    //
    // Return the device context (really a pointer to our fake
    // FDO extension) that will be used on all subsequent calls
    // for this device.
    //

    *DeviceContext = fdoExtension;
    return STATUS_SUCCESS;

cleanup:

    if (fdoExtension) {
        ExFreePool(fdoExtension);
    }

    return status;

}

NTSTATUS
pcicbintrf_DeleteCardBus(
    IN PVOID DeviceContext
    )
{
    PPCI_FDO_EXTENSION fdoExtension;
    PPCI_PDO_EXTENSION pdoExtension;

    fdoExtension = (PPCI_FDO_EXTENSION)DeviceContext;
    ASSERT_PCI_FDO_EXTENSION(fdoExtension);

    pdoExtension = fdoExtension->PhysicalDeviceObject->DeviceExtension;
    ASSERT_PCI_PDO_EXTENSION(pdoExtension);

    PCI_ASSERT(pdoExtension->BridgeFdoExtension == fdoExtension);
    pdoExtension->BridgeFdoExtension = NULL;

    PciDebugPrint(
        PciDbgCardBus,
        "PCI - DeleteCardBus (fake) FDO %08x for PDO %08x\n",
        fdoExtension,
        pdoExtension
        );

    //
    // Free the (fake) FDO extension we created to run this
    // bus with.
    //

    PCI_ASSERT(fdoExtension->ChildPdoList == NULL);

    
    PciRemoveEntryFromList(&PciFdoExtensionListHead,
                           &fdoExtension->List,
                           &PciGlobalLock);

    ExFreePool(fdoExtension);

    return STATUS_SUCCESS;
}
NTSTATUS
pcicbintrf_DispatchPnp(
    IN PVOID DeviceContext,
    IN PIRP  Irp
    )
{
    PIO_STACK_LOCATION irpSp;
    PPCI_FDO_EXTENSION fdoExtension;

    PAGED_CODE();

    fdoExtension = (PPCI_FDO_EXTENSION)DeviceContext;
    ASSERT_PCI_FDO_EXTENSION(fdoExtension);
    PCI_ASSERT(fdoExtension->Fake == TRUE);

    //
    // Get the stack location and take appropriate action based
    // on the minor function.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    PCI_ASSERT(irpSp->MajorFunction == IRP_MJ_PNP);
#if DBG
    PciDebugPrint(
        PciDbgCardBus,
        "PCI CardBus Dispatch PNP: FDO(%x, bus 0x%02x)<-%s\n",
        fdoExtension,
        fdoExtension->BaseBus,
        PciDebugPnpIrpTypeToText(irpSp->MinorFunction)
        );
#endif
    return PciFdoIrpQueryDeviceRelations(
        Irp,
        irpSp,
        (PPCI_COMMON_EXTENSION) fdoExtension
        );
}


NTSTATUS
pcicbintrf_GetLocation(
    IN PDEVICE_OBJECT Pdo,
    OUT UCHAR *Bus,
    OUT UCHAR *DeviceNumber,
    OUT UCHAR *FunctionNumber,
    OUT BOOLEAN *OnDebugPath
    )
{
    PPCI_PDO_EXTENSION PdoExt = (PPCI_PDO_EXTENSION)Pdo->DeviceExtension;
    
    PCI_ASSERT(Bus);
    PCI_ASSERT(DeviceNumber);
    PCI_ASSERT(FunctionNumber);
    
    //
    // Verify that this PDO actually belongs to us.
    //
    if (!PdoExt) {
        return STATUS_NOT_FOUND;
    }

    //
    // Verify that it is actually a PDO.
    //
    if (PdoExt->ExtensionType != PciPdoExtensionType) {
        return STATUS_NOT_FOUND;
    }

    *Bus            = (UCHAR) PCI_PARENT_FDOX(PdoExt)->BaseBus;        
    *DeviceNumber   = (UCHAR) PdoExt->Slot.u.bits.DeviceNumber;
    *FunctionNumber = (UCHAR) PdoExt->Slot.u.bits.FunctionNumber;
    *OnDebugPath    = PdoExt->OnDebugPath;
    
    return STATUS_SUCCESS;
}    


VOID
pcicbintrf_Reference(
    IN PVOID Context
    )
{
    }

VOID
pcicbintrf_Dereference(
    IN PVOID Context
    )
{
    }

NTSTATUS
pcicbintrf_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    )

/*++

Routine Description:

    Initialize the PCI_CARDBUS_INTERFACE_PRIVATE fields.

Arguments:

    PciInterface    Pointer to the PciInterface record for this
                    interface type.
    InterfaceSpecificData
                    A ULONG containing the resource type for which
                    arbitration is required.
    InterfaceReturn

Return Value:

    Status of this operation.

--*/

{
    PPCI_CARDBUS_INTERFACE_PRIVATE interface;

                
    interface = (PPCI_CARDBUS_INTERFACE_PRIVATE)InterfaceReturn;

    //
    // Standard interface stuff
    //

    interface->Size = sizeof(PCI_CARDBUS_INTERFACE_PRIVATE);
    interface->Version = PCI_CB_INTRF_VERSION;
    interface->Context = DeviceExtension;
    interface->InterfaceReference = pcicbintrf_Reference;
    interface->InterfaceDereference = pcicbintrf_Dereference;

    //
    // PCI-CardBus private
    //

    interface->DriverObject = PciDriverObject;

    interface->AddCardBus    = pcicbintrf_AddCardBus;
    interface->DeleteCardBus = pcicbintrf_DeleteCardBus;
    interface->DispatchPnp   = pcicbintrf_DispatchPnp;
    interface->GetLocation   = pcicbintrf_GetLocation;

    return STATUS_SUCCESS;
}

NTSTATUS
pcicbintrf_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    )

/*++

Routine Description:

    For pci-cardbus interface, does nothing, shouldn't actually be called.

Arguments:

    Instance        Pointer to the PDO extension.

Return Value:

    Returns the status of this operation.

--*/

{
    
    PCI_ASSERTMSG("PCI pcicbintrf_Initializer, unexpected call.", 0);

    return STATUS_UNSUCCESSFUL;
}

VOID
Cardbus_MassageHeaderForLimitsDetermination(
    IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    The configuration header for a cardbus bridge has one BAR, the
    SocketRegistersBaseAddress (which is handled in the same way as
    a normal device BAR (see device.c)) and four range descriptions,
    two for I/O and two for memory.  Either or both of the memory
    ranges can be prefetchable.

Arguments:

    This    - Pointer to a PCI driver "configurable" object.  This
              object contains configuration data for the function
              currently being configured.

Return Value:

    The Working configuration has been modified so that all range
    fields have been set to their maximum possible values.

    The Current configuration has been modified such that writing it
    to the hardware will restore the hardware to it's current (disabled)
    state.

--*/

{
    PPCI_COMMON_CONFIG working = This->Working;
    PPCI_COMMON_CONFIG current = This->Current;
    ULONG index;
    ULONG mask;

    working->u.type2.SocketRegistersBaseAddress = 0xffffffff;

    for (index = 0; index < (PCI_TYPE2_ADDRESSES-1); index++) {
        working->u.type2.Range[index].Base  = 0xffffffff;
        working->u.type2.Range[index].Limit = 0xffffffff;
    }

    This->PrivateData = This->Current->u.type2.SecondaryStatus;
    This->Current->u.type2.SecondaryStatus = 0;
    This->Working->u.type2.SecondaryStatus = 0;

    //
    // For cardbus, disregard whatever the BIOS set as resource
    // windows, PnP will assign new windows as appropriate.
    //

    if (!This->PdoExtension->OnDebugPath) {
        mask = 0xfffff000;
        for (index = 0; index < (PCI_TYPE2_ADDRESSES-1); index++) {
            current->u.type2.Range[index].Base  = mask;
            current->u.type2.Range[index].Limit = 0;
       
            if (index == 2) {
       
                //
                // Switch to IO (first two are memory).
                //
       
                mask = 0xfffffffc;
            }
        }
    }
}

VOID
Cardbus_RestoreCurrent(
    IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    Restore any type specific fields in the original copy of config
    space.   In the case of Cardbus bridges, the secondary status field.

Arguments:

    This    - Pointer to a PCI driver "configurable" object.  This
              object contains configuration data for the function
              currently being configured.

Return Value:

    None.

--*/

{
    This->Current->u.type2.SecondaryStatus = (USHORT)(This->PrivateData);
}

VOID
Cardbus_SaveLimits(
    IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    Fill in the Limit structure with a IO_RESOURCE_REQUIREMENT
    for each implemented BAR.

Arguments:

    This    - Pointer to a PCI driver "configurable" object.  This
              object contains configuration data for the function
              currently being configured.

Return Value:

    None.

--*/

{
    BOOLEAN DbgChk64Bit;
    ULONG index;
    PIO_RESOURCE_DESCRIPTOR descriptor;
    PPCI_COMMON_CONFIG working = This->Working;
    ULONG endOffset;
    ULONG base;
    ULONG limit;
    TYPE2EXTRAS type2extras;

    descriptor = This->PdoExtension->Resources->Limit;

    DbgChk64Bit = PciCreateIoDescriptorFromBarLimit(
                      descriptor,
                      &working->u.type2.SocketRegistersBaseAddress,
                      FALSE);
    PCI_ASSERT(!DbgChk64Bit);

    descriptor++;

    for (index = 0;
         index < (PCI_TYPE2_ADDRESSES-1);
         index++, descriptor++) {

        if (index < 2) {

            //
            // First two are Memory
            //

            endOffset = 0xfff;

            descriptor->Type = CmResourceTypeMemory;
            descriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE;

        } else {

            //
            // Next two are IO
            //

            if ((working->u.type2.Range[index].Base & 0x3) == 0x0) {

                //
                // Only the lower 16 bits are implemented.
                //

                PCI_ASSERT((working->u.type2.Range[index].Limit & 0x3) == 0x0);

                working->u.type2.Range[index].Base  &= 0xffff;
                working->u.type2.Range[index].Limit &= 0xffff;
            }
            endOffset = 0x3;

            descriptor->Type = CmResourceTypePort;
            descriptor->Flags = CM_RESOURCE_PORT_IO
                              | CM_RESOURCE_PORT_POSITIVE_DECODE
                              | CM_RESOURCE_PORT_WINDOW_DECODE;
        }
        base  = working->u.type2.Range[index].Base  & ~endOffset;
        limit = working->u.type2.Range[index].Limit |  endOffset;

        //
        // Is this range in use?
        //

        if ((base != 0) && (base < limit)) {

            //
            // Yep.
            //

            descriptor->u.Generic.MinimumAddress.QuadPart = 0;
            descriptor->u.Generic.MaximumAddress.QuadPart = limit;
            descriptor->u.Generic.Alignment = endOffset + 1;

            //
            // Length is meaningless here, report zero.
            //

            descriptor->u.Generic.Length = 0;

        } else {

            //
            // Not in use, don't report it.
            //

            descriptor->Type = CmResourceTypeNull;
        }
    }

    //
    // Cardbus has an additional base address register in config
    // space beyond the common header.  Also there are the subsystem
    // ID and subsystem vendor ID so get those while we're there.
    //

    PciReadDeviceConfig(This->PdoExtension,
                        &type2extras,
                        FIELD_OFFSET(PCI_COMMON_CONFIG,
                                     DeviceSpecific),
                        sizeof(type2extras));

    This->PdoExtension->SubsystemVendorId = type2extras.SubVendorID;
    This->PdoExtension->SubsystemId       = type2extras.SubSystemID;

    //
    // CardBus always wants a 4K apperture in the first memory BAR.
    // Note that when saving the original settings we discarded
    // whatever was there already.
    //

    PCI_ASSERT(This->PdoExtension->Resources->Limit[1].u.Generic.Length == 0);

    This->PdoExtension->Resources->Limit[1].u.Generic.Length = 4096;
}

VOID
Cardbus_SaveCurrentSettings(
    IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    Fill in the Current array in the PDO extension with the current
    settings for each implemented BAR.

    Also, fill in the PDO Extension's Dependent structure.

Arguments:

    This    - Pointer to a PCI driver "configurable" object.  This
              object contains configuration data for the function
              currently being configured.

Return Value:

    None.

--*/

{
    ULONG index;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptor;
    PPCI_COMMON_CONFIG current = This->Current;
    ULONG endOffset;
    ULONG base;
    ULONG limit;

    partial = This->PdoExtension->Resources->Current;
    ioResourceDescriptor = This->PdoExtension->Resources->Limit;

    for (index = 0;
         index < PCI_TYPE2_RANGE_COUNT;
         index++, partial++, ioResourceDescriptor++) {

        partial->Type = ioResourceDescriptor->Type;

        if (partial->Type == CmResourceTypeNull) {

            //
            // This entry is not implemented (or permanently disabled)
            // no further processing required.
            //

            continue;
        }

        partial->Flags = ioResourceDescriptor->Flags;
        partial->ShareDisposition = ioResourceDescriptor->ShareDisposition;

        //
        // The first and last entries are in PCI Base Address Register
        // form.
        //

        if (index == 0) {

            partial->u.Generic.Length = ioResourceDescriptor->u.Generic.Length;
            base = current->u.type2.SocketRegistersBaseAddress;
            base &= ~(partial->u.Generic.Length - 1);
            partial->u.Generic.Start.QuadPart = base;
            continue;

        } else if (index == (PCI_TYPE2_RANGE_COUNT - 1)) {
            
            //
            // We don't use LegacyModeBaseAddress any more its always set to 0
            //
            continue;
        }

        //
        // Following entries are in the form of ranges.
        //

        base  = current->u.type2.Range[index-1].Base;
        limit = current->u.type2.Range[index-1].Limit;

        if (index < 3) {

            //
            // after the BAR come two memory ranges.
            //

            endOffset = 0xfff;

        } else {

            //
            // Next two are IO
            //

            if ((current->u.type2.Range[index].Base & 0x3) == 0x0) {

                //
                // Only the lower 16 bits are implemented.
                //

                base  &= 0xffff;
                limit &= 0xffff;
            }
            endOffset = 0x3;
        }
        base  &= ~endOffset;
        limit |=  endOffset;

        //
        // Is this range in use?
        //

        if (base && (base < limit)) {

            //
            // Yep.
            //

            partial->u.Generic.Start.QuadPart = base;
            partial->u.Generic.Length = limit - base + 1;

        } else {

            //
            // Not in use, don't report it.
            //

            partial->Type = CmResourceTypeNull;
        }
    }

    //
    // Always clear the ISA bit on a cardbus bridge
    //

    This->PdoExtension->Dependent.type2.IsaBitSet = FALSE;

    //
    // If any of the MEM0_PREFETCH, MEM1_PREFETCH or ISA bits are set in brigde
    // control register force us to update the hardware so we will clear them
    // in ChangeResourceSettings
    //

    if (current->u.type2.BridgeControl & (PCI_ENABLE_CARDBUS_MEM0_PREFETCH
                                          | PCI_ENABLE_CARDBUS_MEM1_PREFETCH
                                          | PCI_ENABLE_BRIDGE_ISA)) {

        This->PdoExtension->UpdateHardware = TRUE;
    }

    //
    // Save the bridge's PCI bus #'s
    //

    This->PdoExtension->Dependent.type2.PrimaryBus =
        current->u.type2.PrimaryBus;
    This->PdoExtension->Dependent.type2.SecondaryBus =
        current->u.type2.SecondaryBus;
    This->PdoExtension->Dependent.type2.SubordinateBus =
        current->u.type2.SubordinateBus;

}

VOID
Cardbus_ChangeResourceSettings(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    )
{
    ULONG index;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptor;
    ULONG lowPart;
    ULONG length;
    struct _type2_range {
        ULONG Base;
        ULONG Limit;
    } *range;

#if DBG

    PHYSICAL_ADDRESS upperBound;
    ULONG align;

#endif


    //
    // Close the bridge windows and only open them is appropriate resources
    // have been assigned
    //

    for (index = 0; index < PCI_TYPE2_ADDRESSES-1; index++) {
        CommonConfig->u.type2.Range[index].Base = 0xffffffff;
        CommonConfig->u.type2.Range[index].Limit = 0x0;
    }

    if (PdoExtension->Resources) {

        partial = PdoExtension->Resources->Current;
        ioResourceDescriptor = PdoExtension->Resources->Limit;

        for (index = 0;
             index < PCI_TYPE2_RANGE_COUNT;
             index++, partial++, ioResourceDescriptor++) {

            //
            // If this entry is not implemented, skip.
            //

            if (partial->Type == CmResourceTypeNull) {
                continue;
            }
            PCI_ASSERT(partial->Type == ioResourceDescriptor->Type);

            //
            // Cardbus supports 32 (or 16) bit addresses only.
            //

            lowPart = partial->u.Generic.Start.LowPart;

            PCI_ASSERT(partial->u.Generic.Start.HighPart == 0);

            //
            // Type 2 headers
            //
            // entry    cfg offset  size    what
            //
            //  0       10          4       CB Socket reg/EXCA BAR
            //  1       1c          8       Mem base/limit (32 bits each)
            //  2       24          8       ""  ""  2nd aperture
            //  3       2c          8(*)    IO base/limit
            //  4       34          8(*)    ""  ""  2nd aperture
            //  5       40          4(**)   16 bit PC card legacy mode BAR
            //
            // *  Optionally 16 or 32 bits.
            // ** Optional.  Not supported at present (Memphis says they don't
            // support it at all).  Peterj 11/5/97.
            //

            if (index == 0) {

                PCI_ASSERT(partial->Type == CmResourceTypeMemory);
                CommonConfig->u.type2.SocketRegistersBaseAddress = lowPart;
            } else if (index == (PCI_TYPE2_RANGE_COUNT-1)) {
                
                //
                // We don't use LegacyModeBaseAddress any more its always set to 0
                //
                PCI_ASSERT(partial->Type == CmResourceTypeNull);
                continue;

            } else {

                //
                // It's one of the range/limit pairs.
                //

                range =
                    (struct _type2_range *)&CommonConfig->u.type2.Range[index-1];
                length = partial->u.Generic.Length;

 #if DBG

                //
                // Verify type and upper bound.
                //

                upperBound.QuadPart = lowPart + (partial->u.Generic.Length - 1);
                PCI_ASSERT(upperBound.HighPart == 0);

                if (index < 3) {

                    //
                    // Memory ranges, 4KB alignment.
                    //

                    align = 0xfff;

                } else {

                    //
                    // IO ranges, verify type, 4 Byte alignment and
                    // upperbound if 16 bit only.
                    //

                    align = 0x3;

                    if ((range->Base & 0x3) == 0) {

                        //
                        // 16 bit
                        //

                        PCI_ASSERT((upperBound.LowPart & 0xffff0000) == 0);
                    }
                }
                PCI_ASSERT((lowPart & align) == 0);
                PCI_ASSERT(((length & align) == 0) && (length > align));

 #endif

                range->Base = lowPart;
                range->Limit = lowPart + (length - 1);
                continue;
            }
        }
    }

    //
    // Restore the bridge's PCI bus #'s
    //

    CommonConfig->u.type2.PrimaryBus = PdoExtension->Dependent.type2.PrimaryBus;
    CommonConfig->u.type2.SecondaryBus = PdoExtension->Dependent.type2.SecondaryBus;
    CommonConfig->u.type2.SubordinateBus = PdoExtension->Dependent.type2.SubordinateBus;

    //
    // Always clear the MEM0_PREFETCH, MEM1_PREFETCH and ISA enables
    // for a cardbus contoller as we don't support these.
    //

    PCI_ASSERT(!PdoExtension->Dependent.type2.IsaBitSet);

    CommonConfig->u.type2.BridgeControl &= ~(PCI_ENABLE_CARDBUS_MEM0_PREFETCH
                                             | PCI_ENABLE_CARDBUS_MEM1_PREFETCH
                                             | PCI_ENABLE_BRIDGE_ISA);

    //
    // Set the bridge control register bits we might have changes
    //

    if (PdoExtension->Dependent.type2.VgaBitSet) {
        CommonConfig->u.type2.BridgeControl |= PCI_ENABLE_BRIDGE_VGA;
    }


}

VOID
Cardbus_GetAdditionalResourceDescriptors(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig,
    IN PIO_RESOURCE_DESCRIPTOR Resource
    )
{
    
                
    //
    // For the moment, do nothing, need to add the same sort of
    // support as is in pci-pci bridges.
    //

    return;
}

NTSTATUS
Cardbus_ResetDevice(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    )
{
    
            
    //
    // While you might logically expect to find code in this
    // function, RavisP assures me that the cardbus driver
    // handles resets correctly and the PCI driver doesn't
    // need to touch it.
    //

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\config.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    config.c

Abstract:

    Two kinds of config space access are allowed.  One for the config space
    associated with a specific PDO and one for a device specified in terms of
    a (RootFdo, BusNumber, Slot) tuple.

Author:

    Andrew Thornton (andrewth) 27-Aug-1998

Revision History:

--*/

#include "pcip.h"

#define INT_LINE_OFFSET ((ULONG)FIELD_OFFSET(PCI_COMMON_CONFIG,u.type0.InterruptLine))

//
// None of these functions are pageable as they are called to power manage
// devices at high IRQL
//

VOID
PciReadWriteConfigSpace(
    IN PPCI_FDO_EXTENSION ParentFdo,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length,
    IN BOOLEAN Read
    )

/*++

Routine Description:

    This is the base routine through which all config space access from the
    pci driver go.

Arguments:

    ParentFdo - The FDO of the bus who's config space we want

    Slot - The Device/Function of the device on that bus we are interested in

    Buffer - A buffer where the data will be read or written

    Offset - The byte offset in config space where we should start to read/write

    Length - The number of bytes to read/write

    Read - TRUE to read from config space, FALSE to write

Return Value:

    None

Notes:

    If the underlying HAL or ACPI access mechanism failes we bugcheck with a
    PCI_CONFIG_SPACE_ACCESS_FAILURE

--*/

{

    PciReadWriteConfig busHandlerReadWrite;
    PCI_READ_WRITE_CONFIG interfaceReadWrite;
    ULONG count;
    PPCI_BUS_INTERFACE_STANDARD busInterface;

    PCI_ASSERT(PCI_IS_ROOT_FDO(ParentFdo->BusRootFdoExtension));

    busInterface = ParentFdo->BusRootFdoExtension->PciBusInterface;

    if (busInterface) {

        //
        // If we have a PCI_BUS_INTERFACE use it to access config space
        //

        if (Read) {
            interfaceReadWrite = busInterface->ReadConfig;
        } else {
            interfaceReadWrite = busInterface->WriteConfig;
        }

        //
        // The interface access to config space is at the root of each PCI
        // domain
        //

        count = interfaceReadWrite(
                    busInterface->Context,
                    ParentFdo->BaseBus,
                    Slot.u.AsULONG,
                    Buffer,
                    Offset,
                    Length
                    );

        if (count != Length) {

            KeBugCheckEx(
                PCI_CONFIG_SPACE_ACCESS_FAILURE,
                (ULONG_PTR) ParentFdo->BaseBus, // Bus
                (ULONG_PTR) Slot.u.AsULONG,     // Slot
                (ULONG_PTR) Offset,             // Offset
                (ULONG_PTR) Read                // Read/Write
                );

        }

    } else {

        //
        // The BusHandler interface is at the parent level.
        //
        // NOTE: This means that if hot-plug of bridges (aka Docking) is to be
        // supported then the HAL must provide a PCI_BUS_INTERFACE_STANDARD
        // because it will not have a bus handler for the new bridge so we
        // won't be able to use this code path.
        //

        PCI_ASSERT(ParentFdo->BusHandler);

        //
        // We had better not think we can do hot plug
        //

        PCI_ASSERT(!PciAssignBusNumbers);

        if (Read) {
            busHandlerReadWrite =
                ((PPCIBUSDATA)ParentFdo->BusHandler->BusData)->ReadConfig;
        } else {
            busHandlerReadWrite =
                ((PPCIBUSDATA)ParentFdo->BusHandler->BusData)->WriteConfig;
        }


        busHandlerReadWrite(ParentFdo->BusHandler,
                            Slot,
                            Buffer,
                            Offset,
                            Length
                            );

    }

}

VOID
PciReadDeviceConfig(
    IN PPCI_PDO_EXTENSION Pdo,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

/*++

Routine Description:

    Read the config space for a specific device

Arguments:

    Pdo - The PDO representing the device who's config space we want

    Buffer - A buffer where the data will be read or written

    Offset - The byte offset in config space where we should start to read/write

    Length - The number of bytes to read/write

Return Value:

    None

--*/

{
    PciReadWriteConfigSpace(PCI_PARENT_FDOX(Pdo),
                            Pdo->Slot,
                            Buffer,
                            Offset,
                            Length,
                            TRUE    // read
                            );

}


VOID
PciWriteDeviceConfig(
    IN PPCI_PDO_EXTENSION Pdo,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

/*++

Routine Description:

    Write the config space for a specific device

Arguments:

    Pdo - The PDO representing the device who's config space we want

    Buffer - A buffer where the data will be read or written

    Offset - The byte offset in config space where we should start to read/write

    Length - The number of bytes to read/write

Return Value:

    None

--*/

{
#if 0

    //
    // Make sure we never change the interrupt line register
    //

    if ((Offset <= INT_LINE_OFFSET)
    &&  (Offset + Length > INT_LINE_OFFSET)) {

        PUCHAR interruptLine = (PUCHAR)Buffer + INT_LINE_OFFSET - Offset;

        PCI_ASSERT(*interruptLine == Pdo->RawInterruptLine);

    }

#endif

    PciReadWriteConfigSpace(PCI_PARENT_FDOX(Pdo),
                            Pdo->Slot,
                            Buffer,
                            Offset,
                            Length,
                            FALSE   // write
                            );

}

VOID
PciReadSlotConfig(
    IN PPCI_FDO_EXTENSION ParentFdo,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

/*++

Routine Description:

    Read config space for a specific bus/slot

Arguments:

    ParentFdo - The FDO of the bus who's config space we want

    Slot - The Device/Function of the device on that bus we are interested in

    Buffer - A buffer where the data will be read or written

    Offset - The byte offset in config space where we should start to read/write

    Length - The number of bytes to read/write

Return Value:

    None

--*/
{
    PciReadWriteConfigSpace(ParentFdo,
                            Slot,
                            Buffer,
                            Offset,
                            Length,
                            TRUE    // read
                            );
}

VOID
PciWriteSlotConfig(
    IN PPCI_FDO_EXTENSION ParentFdo,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

/*++

Routine Description:

    Read config space for a specific bus/slot

Arguments:

    ParentFdo - The FDO of the bus who's config space we want

    Slot - The Device/Function of the device on that bus we are interested in

    Buffer - A buffer where the data will be read or written

    Offset - The byte offset in config space where we should start to read/write

    Length - The number of bytes to read/write

Return Value:

    None

--*/
{
    PciReadWriteConfigSpace(ParentFdo,
                            Slot,
                            Buffer,
                            Offset,
                            Length,
                            FALSE    // write
                            );
}


UCHAR
PciGetAdjustedInterruptLine(
    IN PPCI_PDO_EXTENSION Pdo
    )

/*++

Routine Description:

   This updates the interrupt line the HAL would like the world to see - this
   may or may not be different than the raw pin.

Arguments:

    Pdo - The PDO representing the device who's config space we want

    Buffer - A buffer where the data will be read or written

    Offset - The byte offset in config space where we should start to read/write

    Length - The number of bytes to read/write

Return Value:

    None

--*/

{

    UCHAR adjustedInterruptLine = 0;
    ULONG lengthRead;

    //
    // Just in case anyone messes up the structures
    //

    PCI_ASSERT(INT_LINE_OFFSET
           == (ULONG)FIELD_OFFSET(PCI_COMMON_CONFIG, u.type1.InterruptLine));
    PCI_ASSERT(INT_LINE_OFFSET
           == (ULONG)FIELD_OFFSET(PCI_COMMON_CONFIG, u.type2.InterruptLine));

    if (Pdo->InterruptPin != 0) {

        //
        // Get the adjusted line the HAL wants us to see
        //

        lengthRead = HalGetBusDataByOffset(
                        PCIConfiguration,
                        PCI_PARENT_FDOX(Pdo)->BaseBus,
                        Pdo->Slot.u.AsULONG,
                        &adjustedInterruptLine,
                        INT_LINE_OFFSET,
                        sizeof(adjustedInterruptLine));

        if (lengthRead != sizeof(adjustedInterruptLine)) {

            adjustedInterruptLine = Pdo->RawInterruptLine;

        }
    }

    return adjustedInterruptLine;
}

NTSTATUS
PciQueryForPciBusInterface(
    IN PPCI_FDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

    This routine sends an IRP to the parent PDO requesting
    handlers for PCI configuration reads and writes.

Arguments:

    FdoExtension - this PCI bus's FDO extension

Return Value:

    STATUS_SUCCESS, if the PDO provided handlers

Notes:

--*/
{
    NTSTATUS status;
    PPCI_BUS_INTERFACE_STANDARD interface;
    PDEVICE_OBJECT targetDevice = NULL;
    KEVENT irpCompleted;
    IO_STATUS_BLOCK statusBlock;
    PIRP irp = NULL;
    PIO_STACK_LOCATION irpStack;

    PAGED_CODE();

    //
    // We only do this for root busses
    //

    PCI_ASSERT(PCI_IS_ROOT_FDO(FdoExtension));

    interface = ExAllocatePool(NonPagedPool, sizeof(PCI_BUS_INTERFACE_STANDARD));

    if (!interface) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Find out where we are sending the irp
    //

    targetDevice = IoGetAttachedDeviceReference(FdoExtension->PhysicalDeviceObject);

    //
    // Get an IRP
    //

    KeInitializeEvent(&irpCompleted, SynchronizationEvent, FALSE);

    irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                       targetDevice,
                                       NULL,    // Buffer
                                       0,       // Length
                                       0,       // StartingOffset
                                       &irpCompleted,
                                       &statusBlock
                                       );
    if (!irp) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;

    //
    // Initialize the stack location
    //

    irpStack = IoGetNextIrpStackLocation(irp);

    PCI_ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);

    irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;

    irpStack->Parameters.QueryInterface.InterfaceType = (PGUID) &GUID_PCI_BUS_INTERFACE_STANDARD;
    irpStack->Parameters.QueryInterface.Version = PCI_BUS_INTERFACE_STANDARD_VERSION;
    irpStack->Parameters.QueryInterface.Size = sizeof (PCI_BUS_INTERFACE_STANDARD);
    irpStack->Parameters.QueryInterface.Interface = (PINTERFACE) interface;
    irpStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Call the driver and wait for completion
    //

    status = IoCallDriver(targetDevice, irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&irpCompleted, Executive, KernelMode, FALSE, NULL);
        status = statusBlock.Status;
    }

    if (NT_SUCCESS(status)) {

        FdoExtension->PciBusInterface = interface;

        //
        // The interface is already referenced when we get it so we don't need
        // to reference it again.
        //

    } else {

        //
        // We don't have an interface
        //

        FdoExtension->PciBusInterface = NULL;
        ExFreePool(interface);
    }

    //
    // Ok we're done with this stack
    //

    ObDereferenceObject(targetDevice);

    return status;

cleanup:

    if (targetDevice) {
        ObDereferenceObject(targetDevice);
    }

    if (interface) {
        ExFreePool(interface);
    }

    return status;

}


NTSTATUS
PciGetConfigHandlers(
    IN PPCI_FDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    This routine attempts to get pnp style config handlers from the PCI busses
    enumerator and if they are not provided falls back on using the HAL bus
    handler method.

Arguments:

    FdoExtension - this PCI bus's FDO extension

Return Value:

    STATUS_SUCCESS, if the PDO provided handlers

Notes:

--*/

{
    NTSTATUS status;

    PCI_ASSERT(FdoExtension->BusHandler == NULL);

    //
    // Check if this is a root bus
    //

    if (PCI_IS_ROOT_FDO(FdoExtension)) {

        PCI_ASSERT(FdoExtension->PciBusInterface == NULL);

        //
        // Check to see if our parent is offering
        // functions for reading and writing config space.
        //


        status = PciQueryForPciBusInterface(FdoExtension);

        if (NT_SUCCESS(status)) {
            //
            // If we have an interface we support numbering of busses
            //

            PciAssignBusNumbers = TRUE;

        } else {

            //
            // We better not think we can number busses - we should only ever
            // get here if one root provides an interface and the other does not
            //

            PCI_ASSERT(!PciAssignBusNumbers);
        }

    } else {

        //
        // Check if our root has a PciBusInterface - which it got from above
        //

        if (FdoExtension->BusRootFdoExtension->PciBusInterface) {
            return STATUS_SUCCESS;
        } else {

            //
            // Set status so we get a bus handler for this bus
            //

            status = STATUS_NOT_SUPPORTED;
        }


    }

    if (!NT_SUCCESS(status)) {

        PCI_ASSERT(status == STATUS_NOT_SUPPORTED);

        //
        // Make sure we arn't trying to get a bus handler for a hot plug
        // capable machine
        //

        PCI_ASSERT(!PciAssignBusNumbers);

        //
        // We couldn't find config handlers the PnP way,
        // build them from the HAL bus handlers.
        //

        FdoExtension->BusHandler =
            HalReferenceHandlerForBus(PCIBus, FdoExtension->BaseBus);


        if (!FdoExtension->BusHandler) {

            //
            // This must be a bus that arrived hot.  We only support hot anything
            // on ACPI machines and they should have provided a PCI_BUS interface
            // at the root.  Fail the add for this new bus.
            //

            return STATUS_INVALID_DEVICE_REQUEST;   // better code?

        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
PciExternalReadDeviceConfig(
    IN PPCI_PDO_EXTENSION Pdo,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

/*++

Routine Description:

    Called when agents outside the PCI driver want to access config space
    (either from a READ_CONFIG IRP or through BUS_INTERFACE_STANDARD).

    This function performs extra sanity checks and sanitization on the
    arguments and also double buffers the data as Buffer might be
    pageable and we access config space at high IRQL.

Arguments:

    Pdo - The PDO representing the device who's config space we want

    Buffer - A buffer where the data will be read or written

    Offset - The byte offset in config space where we should start to read/write

    Length - The number of bytes to read/write

Return Value:

    None

--*/

{
    UCHAR doubleBuffer[sizeof(PCI_COMMON_CONFIG)];

    //
    // Validate the request
    //

    if ((Length + Offset) > sizeof(PCI_COMMON_CONFIG)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Read the data into a buffer allocated on the stack with
    // is guaranteed to not be paged as we access config space
    // at > DISPATCH_LEVEL and the DDK says that the buffer
    // *should* be in paged pool.
    //

    PciReadDeviceConfig(Pdo, &doubleBuffer[Offset], Offset, Length);

    //
    // If we are reading the interrupt line register then adjust it.
    //

    if ((Pdo->InterruptPin != 0) &&
        (Offset <= INT_LINE_OFFSET) &&
        (Offset + Length > INT_LINE_OFFSET)) {

        doubleBuffer[INT_LINE_OFFSET] = Pdo->AdjustedInterruptLine;

    }

    RtlCopyMemory(Buffer, &doubleBuffer[Offset], Length);

    return STATUS_SUCCESS;
}


NTSTATUS
PciExternalWriteDeviceConfig(
    IN PPCI_PDO_EXTENSION Pdo,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Called when agents outside the PCI driver want to access config space
    (either from a WRITE_CONFIG IRP or through BUS_INTERFACE_STANDARD).

    This function performs extra sanity checks and sanitization on the
    arguments and also double buffers the data as Buffer might be
    pageable and we access config space at high IRQL.

Arguments:

    Pdo - The PDO representing the device who's config space we want

    Buffer - A buffer where the data will be read or written

    Offset - The byte offset in config space where we should start to read/write

    Length - The number of bytes to read/write

Return Value:

    None

--*/

{
    PUCHAR interruptLine;
    UCHAR doubleBuffer[255];
    BOOLEAN illegalAccess = FALSE;
    PVERIFIER_DATA verifierData;

    //
    // Validate the request
    //

    if ((Length + Offset) > sizeof(PCI_COMMON_CONFIG)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Make sure they are not touching registers they should not be.  For
    // backward compatiblity we will just complain and let the request through.
    //

    switch (Pdo->HeaderType) {
    case PCI_DEVICE_TYPE:

        //
        // They should not be writing to their BARS including the ROM BAR
        //
        if (INTERSECT_CONFIG_FIELD(Offset, Length, u.type0.BaseAddresses)
        ||  INTERSECT_CONFIG_FIELD(Offset, Length, u.type0.ROMBaseAddress)) {
            illegalAccess = TRUE;
        }
        break;

    case PCI_BRIDGE_TYPE:
        //
        // For bridges they should not touch the bars, the base and limit registers,
        // the bus numbers or bridge control
        //
        if (INTERSECT_CONFIG_FIELD_RANGE(Offset, Length, u.type1.BaseAddresses, u.type1.SubordinateBus)
        ||  INTERSECT_CONFIG_FIELD_RANGE(Offset, Length, u.type1.IOBase, u.type1.IOLimit)
        ||  INTERSECT_CONFIG_FIELD_RANGE(Offset, Length, u.type1.MemoryBase, u.type1.IOLimitUpper16)
        ||  INTERSECT_CONFIG_FIELD(Offset, Length, u.type1.ROMBaseAddress)) {
            illegalAccess = TRUE;
        }
        break;

    case PCI_CARDBUS_BRIDGE_TYPE:

        //
        // For bridges they should not touch the bars, the base and limit registers
        // or the bus numbers.  Bridge control is modified by PCICIA to control cardbus
        // IRQ routing so must be ok.
        //
        if (INTERSECT_CONFIG_FIELD(Offset, Length, u.type2.SocketRegistersBaseAddress)
        ||  INTERSECT_CONFIG_FIELD_RANGE(Offset, Length, u.type2.PrimaryBus, u.type2.SubordinateBus)
        ||  INTERSECT_CONFIG_FIELD(Offset, Length, u.type2.Range)) {
            illegalAccess = TRUE;
        }
        break;
    }

    if (illegalAccess) {

        verifierData = PciVerifierRetrieveFailureData(
            PCI_VERIFIER_PROTECTED_CONFIGSPACE_ACCESS
            );

        PCI_ASSERT(verifierData);

        //
        // We fail the devnode instead of the driver because we don't actually
        // have an address to pass to the driver verifier.
        //
        VfFailDeviceNode(
            Pdo->PhysicalDeviceObject,
            PCI_VERIFIER_DETECTED_VIOLATION,
            PCI_VERIFIER_PROTECTED_CONFIGSPACE_ACCESS,
            verifierData->FailureClass,
            &verifierData->Flags,
            verifierData->FailureText,
            "%DevObj%Ulong%Ulong",
            Pdo->PhysicalDeviceObject,
            Offset,
            Length
            );
    }


    //
    // Copy the data into a buffer allocated on the stack with
    // is guaranteed to not be paged as we access config space
    // at > DISPATCH_LEVEL and the DDK says that the buffer
    // *should* be in paged pool.
    //

    RtlCopyMemory(doubleBuffer, Buffer, Length);

    //
    // If we are writing the interrupt line register then adjust it so we write
    // the raw value back again
    //

    if ((Pdo->InterruptPin != 0) &&
        (Offset <= INT_LINE_OFFSET) &&
        (Offset + Length > INT_LINE_OFFSET)) {

        interruptLine = (PUCHAR)doubleBuffer + INT_LINE_OFFSET - Offset;

        //
        // Adjust the interrupt line with what the HAL wants us to see
        //

        *interruptLine = Pdo->RawInterruptLine;

    }

    PciWriteDeviceConfig(Pdo, doubleBuffer, Offset, Length);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\enum.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    enum.c

Abstract:

    This module contains functions associated with enumerating the
    PCI buses.

Author:

    Peter Johnston (peterj) 20-Nov-1996

Revision History:

   Elliot Shmukler (t-ellios) 7-15-1998      Added support for MSI-capable devices.

--*/

#include "pcip.h"

NTSTATUS
PciScanBus(
    IN PPCI_FDO_EXTENSION FdoExtension
    );

VOID
PciFreeIoRequirementsList(
    IN PIO_RESOURCE_REQUIREMENTS_LIST List
    );

PCM_RESOURCE_LIST
PciAllocateCmResourceList(
    IN ULONG ResourceCount,
    IN ULONG BusNumber
    );


PCI_CONFIGURATOR PciConfigurators[] = {
    {
        Device_MassageHeaderForLimitsDetermination,
        Device_RestoreCurrent,
        Device_SaveLimits,
        Device_SaveCurrentSettings,
        Device_ChangeResourceSettings,
        Device_GetAdditionalResourceDescriptors,
        Device_ResetDevice
    },
    {
        PPBridge_MassageHeaderForLimitsDetermination,
        PPBridge_RestoreCurrent,
        PPBridge_SaveLimits,
        PPBridge_SaveCurrentSettings,
        PPBridge_ChangeResourceSettings,
        PPBridge_GetAdditionalResourceDescriptors,
        PPBridge_ResetDevice
    },
    {
        Cardbus_MassageHeaderForLimitsDetermination,
        Cardbus_RestoreCurrent,
        Cardbus_SaveLimits,
        Cardbus_SaveCurrentSettings,
        Cardbus_ChangeResourceSettings,
        Cardbus_GetAdditionalResourceDescriptors,
        Cardbus_ResetDevice
    },
};

//
// When dealing with devices whose configuration is totally
// unknown to us, we may want to emit the device but not its
// resources,... or, we may not want to see the device at all.
//

typedef enum {
    EnumHackConfigSpace,
    EnumBusScan,
    EnumResourceDetermination,
    EnumStartDevice
} ENUM_OPERATION_TYPE;

PIO_RESOURCE_REQUIREMENTS_LIST PciZeroIoResourceRequirements;

extern PULONG InitSafeBootMode;

//
// Prototypes for functions contained and only used in this module.
//


NTSTATUS
PciGetFunctionLimits(
    IN PPCI_PDO_EXTENSION     PdoExtension,
    IN PPCI_COMMON_CONFIG CurrentConfig,
    IN ULONGLONG          DeviceFlags
    );

NTSTATUS
PcipGetFunctionLimits(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

BOOLEAN
PciSkipThisFunction(
    IN  PPCI_COMMON_CONFIG  Config,
    IN  PCI_SLOT_NUMBER     Slot,
    IN  ENUM_OPERATION_TYPE Operation,
    IN  ULONGLONG           DeviceFlags
    );

VOID
PciPrivateResourceInitialize(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    IN PCI_PRIVATE_RESOURCE_TYPES PrivateResourceType,
    IN ULONG Data
    );

VOID
PciGetInUseRanges(
    IN  PPCI_PDO_EXTENSION                  PdoExtension,
    IN  PPCI_COMMON_CONFIG              CurrentConfig,
    IN  PCM_PARTIAL_RESOURCE_DESCRIPTOR InUse
    );

VOID
PciWriteLimitsAndRestoreCurrent(
    IN PVOID Extension,
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
PcipUpdateHardware(
    IN PVOID Extension,
    IN PPCI_COMMON_CONFIG CommonConfig
    );

VOID
PciGetEnhancedCapabilities(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG Config
    );

BOOLEAN
PcipIsSameDevice(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    );

BOOLEAN
PciConfigureIdeController(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN OUT PPCI_COMMON_CONFIG Config,
    IN BOOLEAN TurnOffAllNative
    );
VOID
PciBuildGraduatedWindow(
    IN PIO_RESOURCE_DESCRIPTOR PrototypeDescriptor,
    IN ULONG WindowMax,
    IN ULONG WindowCount,
    OUT PIO_RESOURCE_DESCRIPTOR OutputDescriptor
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, PciAllocateCmResourceList)
#pragma alloc_text(PAGE, PciComputeNewCurrentSettings)
#pragma alloc_text(PAGE, PciFreeIoRequirementsList)
#pragma alloc_text(PAGE, PciGetInUseRanges)
#pragma alloc_text(PAGE, PciQueryDeviceRelations)
#pragma alloc_text(PAGE, PciQueryTargetDeviceRelations)
#pragma alloc_text(PAGE, PciQueryRequirements)
#pragma alloc_text(PAGE, PciQueryResources)
#pragma alloc_text(PAGE, PciScanBus)
#pragma alloc_text(PAGE, PciBuildRequirementsList)
#pragma alloc_text(PAGE, PciGetFunctionLimits)
#pragma alloc_text(PAGE, PcipGetFunctionLimits)
#pragma alloc_text(PAGE, PciPrivateResourceInitialize)
#pragma alloc_text(PAGE, PciGetEnhancedCapabilities)
#pragma alloc_text(PAGE, PciBuildGraduatedWindow)

#endif

BOOLEAN
PciSkipThisFunction(
    IN  PPCI_COMMON_CONFIG  Config,
    IN  PCI_SLOT_NUMBER     Slot,
    IN  ENUM_OPERATION_TYPE Operation,
    IN  ULONGLONG           RegistryFlags
    )

/*++

Routine Description:

    Check for known defective parts and return TRUE if this driver
    should do no further processing on this function.

Arguments:

    Config  Pointer to a copy of the common configuration header as
            read from the function's configuration space.

Return Value:

    TRUE is this function is not known to cause problems, FALSE
    if the function should be skipped altogether.

--*/

{
    ULONGLONG   flags = RegistryFlags;

#define SKIP_IF_FLAG(f, skip)   if (flags & (f)) goto skip
#define FLAG_SET(f)             (flags & (f))

    switch (Operation) {
    case EnumBusScan:

        //
        // Test the flags we care about during a bus scan.
        // Eg: the ones that say "pretend we never saw this device".
        //

        SKIP_IF_FLAG(PCI_HACK_NO_ENUM_AT_ALL, skipFunction);

        if (FLAG_SET(PCI_HACK_DOUBLE_DECKER) &&
            (Slot.u.bits.DeviceNumber >= 16)) {

            //
            // This device seems to look at only the lower 4 bits of
            // its DEVSEL lines, ie it is mirrored in the upper half
            // if the buss's device domain.
            //

            PciDebugPrint(
                PciDbgInformative,
                "    Device (Ven %04x Dev %04x (d=0x%x, f=0x%x)) is a ghost.\n",
                Config->VendorID,
                Config->DeviceID,
                Slot.u.bits.DeviceNumber,
                Slot.u.bits.FunctionNumber
                );
            goto skipFunction;
        }

        break;

    case EnumResourceDetermination:

        //
        // Limit the flags to those applicable to resource determination.
        //

        SKIP_IF_FLAG(PCI_HACK_ENUM_NO_RESOURCE, skipFunction);
        break;

    default:
        PCI_ASSERTMSG("PCI Skip Function - Operation type unknown.", 0);

        //
        // Don't know how to apply flags here.
        //
    }

    switch (Config->BaseClass) {
    case PCI_CLASS_NOT_DEFINED:

        //
        // Currently we get this from VendorID = 8086, DeviceID = 0008,
        // which reports a bunch of bogus resources.
        //
        // We have no idea what it really is either.
        //

        PciDebugPrint(
            PciDbgInformative,
            "    Vendor %04x, Device %04x has class code of PCI_CLASS_NOT_DEFINED\n",
            Config->VendorID,
            Config->DeviceID
            );

        // This case should be added to the registry.

        if ((Config->VendorID == 0x8086) &&
            (Config->DeviceID == 0x0008)) {
            goto skipFunction;
        }
        break;

    case PCI_CLASS_BRIDGE_DEV:

        switch (Config->SubClass) {
        case PCI_SUBCLASS_BR_HOST:

            //
            // It's a host bridge, emit the PDO in case there is
            // a (miniport) driver for it, but under no circumstances
            // should we attempt to figure out what resources it
            // consumes (we don't know the format of its configuration
            // space).
            //

        case PCI_SUBCLASS_BR_ISA:
        case PCI_SUBCLASS_BR_EISA:
        case PCI_SUBCLASS_BR_MCA:

            //
            // Microchannel bridges report their resource usage
            // like good citizens.   Unfortunately we really want
            // them to behave like ISA bridges and consume no
            // resources themselves.  Their children are subtractive
            // from the parent bus.   Enumerate the device but not
            // its resources.
            //

            if (Operation == EnumResourceDetermination) {
                goto skipFunction;
            }
            break;
        }
    }

    //
    // Verify we understand the header type.
    //

    if (PciGetConfigurationType(Config) > PCI_MAX_CONFIG_TYPE) {
        goto skipFunction;
    }

    //
    // Nothing interesting,
    //

    return FALSE;

skipFunction:

    PciDebugPrint(PciDbgPrattling, "   Device skipped (not enumerated).\n");
    return TRUE;
}

VOID
PciApplyHacks(
    IN  PPCI_FDO_EXTENSION      FdoExtension,
    IN  PPCI_COMMON_CONFIG  Config,
    IN  PCI_SLOT_NUMBER     Slot,
    IN  ENUM_OPERATION_TYPE Operation,
    IN  PPCI_PDO_EXTENSION      PdoExtension OPTIONAL
    )
{

    switch (Operation) {
    case EnumHackConfigSpace:

        PCI_ASSERT(PdoExtension == NULL);

        //
        // Some devices (e.g. pre-2.0 devices) do not report reasonable class
        // codes.  Update the class code for a given set of devices so that we
        // don't have to special-case these devices throughout the driver.
        //

        switch (Config->VendorID) {

        //
        // Intel
        //

        case 0x8086:

            switch (Config->DeviceID) {

            //
            // PCEB - PCI/EISA Bridge (pre 2.0)
            //

            case 0x0482:
                Config->BaseClass = PCI_CLASS_BRIDGE_DEV;
                Config->SubClass = PCI_SUBCLASS_BR_EISA;
#if DBG
                if (PdoExtension != NULL) {
                    PdoExtension->ExpectedWritebackFailure = TRUE;
                }
#endif
                break;

            //
            // SIO - PCI/ISA Bridge (pre 2.0)
            //

            case 0x0484:
                Config->BaseClass = PCI_CLASS_BRIDGE_DEV;
                Config->SubClass = PCI_SUBCLASS_BR_ISA;
#if DBG
                if (PdoExtension != NULL) {
                    PdoExtension->ExpectedWritebackFailure = TRUE;
                }
#endif
                break;

            }

            break;

        }

        break;



    case EnumBusScan:

        PCI_ASSERT(PdoExtension);

        if ((Config->VendorID == 0x1045) &&
            (Config->DeviceID == 0xc621)) {

            //
            // Bug 131482.   Force this device into legacy mode for
            // the purposes of detection anyway.
            //

            Config->ProgIf &= ~(PCI_IDE_PRIMARY_NATIVE_MODE
                                | PCI_IDE_SECONDARY_NATIVE_MODE);

#if DBG
            //
            // This field is not actually writeable so don't tell
            // people the writeback failed (we don't care).
            //

            PdoExtension->ExpectedWritebackFailure = TRUE;
#endif

        } else if (Config->BaseClass == PCI_CLASS_MASS_STORAGE_CTLR
        &&  Config->SubClass == PCI_SUBCLASS_MSC_IDE_CTLR) {

            //
            // Check with the BIOS to ensure that it can deal with the mode change
            // This is indicated by the *parent* of the device having a method
            // called NATA which returns a package of integers which are slots
            // in _ADR format that can be switched to native mode.
            //
            // This method used to be called NIDE but we shipped XP with a bug
            // in PCIIDE so that if a spurious interrupt occured with a machine
            // without a slave device we would attempt to select the slave
            // (we may not have enumerated yet) and attempt to dismiss the interrupt
            // unfortunatley selecting the slave pulls the IDE INT pin high and
            // triggers another interrupt (yuck).  We renamed this method so OEMs
            // have a way to enable native mode without risking incompatibility
            // with XP gold
            //
            // Enabling native mode might expose BIOS bugs like interrupt routing problems
            // that could prevent the machine from booting, so don't do this for
            // safe mode, so that the user has some way to boot.
            //
            // Also base the enablement of this feature on a registry key which OEMs must
            // set in their preinstall to indicate they have tested the feature.
            //
            if ((PciEnableNativeModeATA != 0) &&
                (*InitSafeBootMode == 0) &&
                PciIsSlotPresentInParentMethod(PdoExtension, (ULONG)'ATAN')) {
                
                PdoExtension->BIOSAllowsIDESwitchToNativeMode = TRUE;

            } else {

                PdoExtension->BIOSAllowsIDESwitchToNativeMode = FALSE;
            }
            
            //
            // Config is updated to reflect the results of the switch
            // if any.  Relied upon below.
            //

            PdoExtension->IDEInNativeMode =
                PciConfigureIdeController(PdoExtension, Config, TRUE);
        }

        //
        // If the controller is (still) in legacy mode then it
        // consume 2 ISA interrupts whatever its interrupt pin says
        // force the driver to figure out interrupts on its own.
        //
        // Examine Base Class, Sub Class and Programming Interface,
        // if legacy mode, pretend PIN == 0.
        //

        if (PCI_IS_LEGACY_IDE_CONTROLLER(Config)) {

            //
            // Legacy mode.  Pretend there is no PCI interrupt.
            //

            Config->u.type0.InterruptPin = 0;
        }

        //
        // This hack doesn't change the config space for this device but enables
        // a hack in the PCI arbiters to reserve a large number IO ranges for
        // broken S3 and ATI cards.  These legacy cards don't function behind a
        // bridge so we only perform the check on a root bus and only perform it
        // once
        //

        if ((PdoExtension->HackFlags & PCI_HACK_VIDEO_LEGACY_DECODE)
        &&  PCI_IS_ROOT_FDO(FdoExtension)
        &&  !FdoExtension->BrokenVideoHackApplied) {

            ario_ApplyBrokenVideoHack(FdoExtension);

        }

        //
        // Check if this is the broken Compaq hot-plug controller that
        // is integrated into the Profusion chipset.  It only does a 32bit
        // decode in a 64bit address space... Does this seem familiar to anyone...
        // can you say ISA aliasing!
        //
        // The solution is to disable the memory decode.  But so that the user
        // gets to keep the hot-plug functionality we need to still enumerate
        // but prune out the memory requirement and rely on the fact that the
        // registers can be accessed through config space.  This is done later
        // in PciGetRequirements.
        //
        // Only do this on machines with PAE enabled as they can have > 4GB.
        // Note that this will only work on x86 machines but this is an x86 only
        // chipset.  Only revision 0x11 was broken.
        //

        if (Config->VendorID == 0x0e11
        &&  Config->DeviceID == 0xa0f7
        &&  Config->RevisionID == 0x11
        &&  ExIsProcessorFeaturePresent(PF_PAE_ENABLED)) {

            Config->Command &= ~(PCI_ENABLE_MEMORY_SPACE
                                 | PCI_ENABLE_BUS_MASTER
                                 | PCI_ENABLE_IO_SPACE);

            PciSetCommandRegister(PdoExtension, Config->Command);
            PdoExtension->CommandEnables &= ~(PCI_ENABLE_MEMORY_SPACE
                                                | PCI_ENABLE_BUS_MASTER
                                                | PCI_ENABLE_IO_SPACE);
            PdoExtension->HackFlags |= PCI_HACK_PRESERVE_COMMAND;
        }

        //
        // If this is a cardbus controller force it into Cardbus mode by writing 0
        // to the LegacyModeBaseAddressRegister.
        //

        if (PCI_CONFIGURATION_TYPE(Config) == PCI_CARDBUS_BRIDGE_TYPE) {

            ULONG zeroLMBA = 0;

            PciWriteDeviceConfig(PdoExtension,
                                 &zeroLMBA,
                                 CARDBUS_LMBA_OFFSET,
                                 sizeof(zeroLMBA)
                                 );
        }

        break;

    case EnumStartDevice:

        PCI_ASSERT(PdoExtension);

        //
        // IBM built a bridge (Kirin) that does both positive and subtractive decode
        // - we don't do that so set it to totally subtractive mode (info is from
        // NT bug 267076)
        //
        // NB - this relies on the fact that Kirin has a ProgIf of 1.
        //

        if (PdoExtension->VendorId == 0x1014 && PdoExtension->DeviceId == 0x0095) {

            UCHAR regE0;
            USHORT cmd;

            //
            // Turn off the hardware as we are going to mess with it
            //

            PciGetCommandRegister(PdoExtension, &cmd);
            PciDecodeEnable(PdoExtension, FALSE, &cmd);

            //
            // This is a Kirin
            //
            // Offset E0h - bit 0 : Subtractive Decode enable/disable
            //                  = 1 .. Enable
            //                  = 0 .. Disable
            //              bit 1 : Subtractive Decode Timing
            //                  = 0 : Subtractive Timing
            //                  = 1 : Slow Timing
            //

            PciReadDeviceConfig(PdoExtension, &regE0, 0xE0, 1);

            //
            // Set subtractive with subtractive timing.
            //

            regE0 |= 0x1;
            regE0 &= ~0x2;

            PciWriteDeviceConfig(PdoExtension, &regE0, 0xE0, 1);

            //
            // Put the command register back as we found it
            //

            PciSetCommandRegister(PdoExtension, cmd);

        }

        //
        // Subtractive decode bridges are not meant to have writeable window
        // register - some do so if this is a subtractive bridge then close
        // these windows by setting base > limit.
        //

        if (PdoExtension->HeaderType == PCI_BRIDGE_TYPE
        &&  PdoExtension->Dependent.type1.SubtractiveDecode
        &&  !PCI_IS_INTEL_ICH(PdoExtension)) {

            //
            // Now close all the windows on this bridge - if the registers are read only
            // this is a NOP.
            //

            Config->u.type1.IOBase = 0xFF;
            Config->u.type1.IOLimit = 0;
            Config->u.type1.MemoryBase = 0xFFFF;
            Config->u.type1.MemoryLimit = 0;
            Config->u.type1.PrefetchBase = 0xFFFF;
            Config->u.type1.PrefetchLimit = 0;
            Config->u.type1.PrefetchBaseUpper32 = 0;
            Config->u.type1.PrefetchLimitUpper32 = 0;
            Config->u.type1.IOBaseUpper16 = 0;
            Config->u.type1.IOLimitUpper16 = 0;

        }

        //
        // If this is a cardbus controller force it into Cardbus mode by writing 0
        // to the LegacyModeBaseAddressRegister.
        //

        if (Config->HeaderType ==  PCI_CARDBUS_BRIDGE_TYPE) {

            ULONG zeroLMBA = 0;

            PciWriteDeviceConfig(PdoExtension,
                                 &zeroLMBA,
                                 CARDBUS_LMBA_OFFSET,
                                 sizeof(zeroLMBA)
                                 );
        }

        break;
    }
}


PIO_RESOURCE_REQUIREMENTS_LIST
PciAllocateIoRequirementsList(
    IN ULONG ResourceCount,
    IN ULONG BusNumber,
    IN ULONG SlotNumber
    )
{
    PIO_RESOURCE_REQUIREMENTS_LIST list;
    ULONG                          size;

    //
    // Allocate space for (and zero) the resource requirements list.
    //

    size = ((ResourceCount - 1) * sizeof(IO_RESOURCE_DESCRIPTOR)) +
           sizeof(IO_RESOURCE_REQUIREMENTS_LIST);

    if (ResourceCount == 0) {

        //
        // We should not be called for a resource count of zero, except
        // once for the empty list.   In any case, it should work.
        //

        size = sizeof(IO_RESOURCE_REQUIREMENTS_LIST);
    }

    list = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, size);

    if (list != NULL) {

        RtlZeroMemory(list, size);

        //
        // Initialize the list structure header.
        //
        // Driver constant-
        //

        list->InterfaceType = PCIBus;
        list->AlternativeLists = 1;
        list->List[0].Version = PCI_CM_RESOURCE_VERSION;
        list->List[0].Revision = PCI_CM_RESOURCE_REVISION;

        //
        // Call dependent.
        //

        list->BusNumber = BusNumber;
        list->SlotNumber = SlotNumber;
        list->ListSize = size;
        list->List[0].Count = ResourceCount;
    }
    return list;
}

VOID
PciFreeIoRequirementsList(
    IN PIO_RESOURCE_REQUIREMENTS_LIST List
    )
{
    //
    // Don't free the empty list and don't free NULL which is
    // also allowed.
    //

    if ((List == NULL) || (List == PciZeroIoResourceRequirements)) {
        return;
    }

    ExFreePool(List);
}

PCM_RESOURCE_LIST
PciAllocateCmResourceList(
    IN ULONG ResourceCount,
    IN ULONG BusNumber
    )
{
    PCM_RESOURCE_LIST         list;
    ULONG                     size;
    PCM_PARTIAL_RESOURCE_LIST partial;

    //
    // CM_RESOURCE_LIST includes space for one descriptor.  If there's
    // more than one (in the resource list) increase the allocation by
    // that amount.
    //

    size = sizeof(CM_RESOURCE_LIST);

    if (ResourceCount > 1) {
        size += (ResourceCount - 1) * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
    }

    //
    // Get memory for the resource list.
    //

    list = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, size);
    if (list != NULL) {

        //
        // Initialize the resource list.
        //

        list->Count = 1;
        list->List[0].InterfaceType = PCIBus;
        list->List[0].BusNumber = BusNumber;

        partial = &list->List[0].PartialResourceList;

        partial->Version = PCI_CM_RESOURCE_VERSION;
        partial->Revision = PCI_CM_RESOURCE_REVISION;
        partial->Count = ResourceCount;

        RtlZeroMemory(
            partial->PartialDescriptors,
            size - ((ULONG_PTR)partial->PartialDescriptors - (ULONG_PTR)list)
            );
    }
    return list;
}

VOID
PciPrivateResourceInitialize(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    IN PCI_PRIVATE_RESOURCE_TYPES PrivateResourceType,
    IN ULONG Data
    )
{
    Descriptor->Type = CmResourceTypeDevicePrivate;
    Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
    Descriptor->Option = 0;
    Descriptor->Flags  = 0;

    Descriptor->u.DevicePrivate.Data[0] = PrivateResourceType;
    Descriptor->u.DevicePrivate.Data[1] = Data;
}

VOID
PciGetInUseRanges(
    IN  PPCI_PDO_EXTENSION                  PdoExtension,
    IN  PPCI_COMMON_CONFIG              CurrentConfig,
    IN  PCM_PARTIAL_RESOURCE_DESCRIPTOR InUse
    )

/*++

Routine Description:

    Builds an array of CM Partial Resource descriptors containing
    valid entries only where the corresponding PCI address range
    is in use, NULL otherwise.

Arguments:

    PdoExtension   - Pointer to the Physical Device Object Extension for
                     the device whose requirements list is needed.
    CurrentConfig  - Existing contents of configuration space.
    Partial        - Pointer to an array of CM_PARTIAL_RESOURCE_DESCRIPTORs.

Return Value:

    None.

--*/

{
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptor;
    BOOLEAN enabledPciIo;
    BOOLEAN enabledPciMem;
    ULONG index;

    partial = PdoExtension->Resources->Current;
    ioResourceDescriptor = PdoExtension->Resources->Limit;

    enabledPciIo  = BITS_SET(CurrentConfig->Command, PCI_ENABLE_IO_SPACE)
                    || BITS_SET(PdoExtension->InitialCommand, PCI_ENABLE_IO_SPACE);
    enabledPciMem = BITS_SET(CurrentConfig->Command, PCI_ENABLE_MEMORY_SPACE)
                    || BITS_SET(PdoExtension->InitialCommand, PCI_ENABLE_MEMORY_SPACE);

    for (index = 0;
         index < PCI_MAX_RANGE_COUNT;
         index++, InUse++, partial++, ioResourceDescriptor++) {

        //
        // Default to not in use.
        //

        InUse->Type = CmResourceTypeNull;

        //
        // If the resource type in the limits array is
        // CmResourceTypeNull, this resource is not implemented.
        //

        if (ioResourceDescriptor->Type != CmResourceTypeNull) {

            //
            // Not NULL, only options are Port or Memory, we will
            // consider this entry if the approptiate resource
            // (Port or Memory) is currently enabled.
            //

            if (((partial->Type == CmResourceTypePort) && enabledPciIo) ||
                ((partial->Type == CmResourceTypeMemory) && enabledPciMem)) {

                if (partial->u.Generic.Length != 0) {

                    //
                    // Length is non-zero, if base is also non-zero, OR
                    // if this is a bridge and the resource type is IO,
                    // allow it.
                    //

                    if ((partial->u.Generic.Start.QuadPart != 0) ||
                        ((PciGetConfigurationType(CurrentConfig) == PCI_BRIDGE_TYPE) &&
                         (partial->Type == CmResourceTypePort))) {

                        //
                        // This resource describes a valid range that is
                        // currently enabled by hardware.
                        //

                        *InUse = *partial;
                    }
                }
            }
        }
    }
}

VOID
PciBuildGraduatedWindow(
    IN PIO_RESOURCE_DESCRIPTOR PrototypeDescriptor,
    IN ULONG WindowMax,
    IN ULONG WindowCount,
    OUT PIO_RESOURCE_DESCRIPTOR OutputDescriptor
    )
/*++

Routine Description:

    Builds an array of IO Resource descriptors containing
    graduated requirements from WindowMax for WindowCount
    Descriptors dividing the length required in half each time.

    eg  If WindowMax is 64Mb and WindowCount is 7 we end up with
        the progression 64Mb, 32Mb, 16Mb, 8Mb, 4Mb, 2Mb, 1Mb

    This only works for IO and Memory descriptors.

Arguments:

    PrototypeDescriptor - this is used to initialize each
        requirement descriptor then the lenght is modified

    WindowMax - the maximum size of the window (where we build
        the progression from)

    WindowCount - the number of descriptors in the progression

    OutputDescriptor - pointer to the first of WindowCount
        descriptors to be populated by this function.

Return Value:

    None.

--*/


{
    ULONG window, count;
    PIO_RESOURCE_DESCRIPTOR current;

    PAGED_CODE();

    PCI_ASSERT(PrototypeDescriptor->Type == CmResourceTypePort
           || PrototypeDescriptor->Type == CmResourceTypeMemory);


    window = WindowMax;
    current = OutputDescriptor;

    for (count = 0; count < WindowCount; count++) {

        RtlCopyMemory(current, PrototypeDescriptor, sizeof(IO_RESOURCE_DESCRIPTOR));
        //
        // Update the length
        //
        current->u.Generic.Length = window;
        //
        // If this is an alternative then mark it so
        //
        if (count > 0) {
            current->Option = IO_RESOURCE_ALTERNATIVE;
        }
        current++;

        //
        // Divide window and repeat
        //

        window /= 2;
        PCI_ASSERT(window > 1);
    }

    //
    // Return the number of descriptors filled in
    //

    PCI_ASSERT((ULONG)(current - OutputDescriptor) == WindowCount);
}

NTSTATUS
PciBuildRequirementsList(
    IN  PPCI_PDO_EXTENSION                 PdoExtension,
    IN  PPCI_COMMON_CONFIG             CurrentConfig,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST *FinalReqList
    )

/*++

Routine Description:

    Build the IO_RESOURCE_REQUIREMENTS_LIST structure for this device.

    This structure contains the devices limits and requirements, for
    example, IO space in the range 0x100 to 0x1ff, Length 10.

Arguments:

    PdoExtension   - Pointer to the Physical Device Object Extension for
                     the device whose requirements list is needed.
    CurrentConfig  - Existing contents of configuration space.

Return Value:

    Returns a pointer to the IO_RESOURCE_REQUIREMENTS_LIST for this
    device/function if all went well.  NULL otherwise.

--*/

{
    //
    // Each base resource requires three extended resource descriptors.
    // the total RESOURCES_PER_BAR are
    //
    // 1. Base Resource Descriptor.  eg PCI Memory or I/O space.
    // 2. Ext Resource Descriptor, DevicePrivate.  This is used to
    //    keep track of which BAR this resource is derived from.

#define RESOURCES_PER_BAR   2
#define PCI_GRADUATED_WINDOW_COUNT 7 // 64, 32, 16, 8, 4, 2, 1
#define PCI_GRADUATED_WINDOW_MAX (64 * 1024 * 1024) // 64Mb

    ULONG index;
    ULONG baseResourceCount = 0;
    ULONG interruptMin, interruptMax;
    ULONG iterationCount;
    BOOLEAN generatesInterrupt = FALSE;
    NTSTATUS status;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partial = NULL;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptor = NULL;
    PIO_RESOURCE_DESCRIPTOR resource;
    PIO_RESOURCE_REQUIREMENTS_LIST reqList;
    CM_PARTIAL_RESOURCE_DESCRIPTOR  inUse[PCI_MAX_RANGE_COUNT];
    PPCI_CONFIGURATOR configurator;

    PciDebugPrint(PciDbgInformative,
                  "PciBuildRequirementsList: Bus 0x%x, Dev 0x%x, Func 0x%x.\n",
                  PCI_PARENT_FDOX(PdoExtension)->BaseBus,
                  PdoExtension->Slot.u.bits.DeviceNumber,
                  PdoExtension->Slot.u.bits.FunctionNumber);

    if (PdoExtension->Resources == NULL) {

        //
        // If this function implements no BARs, we won't have a
        // resource structure for it.
        //

        iterationCount = 0;

    } else {

        iterationCount = PCI_MAX_RANGE_COUNT;
        partial = inUse;
        ioResourceDescriptor = PdoExtension->Resources->Limit;
        PciGetInUseRanges(PdoExtension, CurrentConfig, partial);
    }

    configurator =
        &PciConfigurators[PdoExtension->HeaderType];

    //
    // First pass, figure out how large the resource requirements
    // list needs to be.
    //

    for (index = 0;
         index < iterationCount;
         index++, partial++, ioResourceDescriptor++) {

        //
        // If the resource type in the limits array is
        // CmResourceTypeNull, this resource is not implemented.
        //

        if (ioResourceDescriptor->Type != CmResourceTypeNull) {

            if (partial->Type != CmResourceTypeNull) {

                if ((ioResourceDescriptor->u.Generic.Length == 0) // bridge

#if PCI_BOOT_CONFIG_PREFERRED

                    || (1)                                        // always

#endif
                   )
                {

                    //
                    // Count one for the preferred setting.
                    //

                    baseResourceCount++;

                    PciDebugPrint(PciDbgObnoxious,
                        "    Index %d, Preferred = TRUE\n",
                        index
                        );
                }

            } else {

                //
                // This range is not being passed so we will not
                // generate a preferred setting for it.
                //
                // Bridges have variable length ranges so there is
                // no meaningful value that we could have stored in
                // the base descriptor other than 0.  We use this
                // fact to determine if it's a bridged range.
                //
                // If this range is a bridge range, we do not want
                // to generate a base descriptor for it either.
                //
                // Unless we are providing default minimum settings.
                // (Only do this for PCI-PCI bridges, CardBus gets
                // to figure out what it wants).
                //

                if (ioResourceDescriptor->u.Generic.Length == 0) {


                    //
                    // Generating prefered settings,... unless,...
                    // If the bridge IO is enabled and VGA is enabled,
                    // (and the IO range isn't programmed,... which is
                    // how we got here), then the VGA ranges are enough,
                    // don't try to add a range.
                    //

                    if ((ioResourceDescriptor->Type == CmResourceTypePort) &&
                        PdoExtension->Dependent.type1.VgaBitSet) {

                        continue;
                    }

                    //
                    // If this is a memory window then make space for a graduated
                    // requirement and a device private to follow it
                    //

                    if (ioResourceDescriptor->Type == CmResourceTypeMemory) {
                        baseResourceCount += PCI_GRADUATED_WINDOW_COUNT + 1;
                        continue;
                    }
                }

                //
                // If this resource is a ROM which is not currently
                // enabled, don't report it at all.
                //
                // Note: The ROM requirement exists in the io resource
                // descriptors so we know what to do if we get a read
                // config for the ROM.
                //

                if ((ioResourceDescriptor->Type == CmResourceTypeMemory) &&
                    (ioResourceDescriptor->Flags == CM_RESOURCE_MEMORY_READ_ONLY)) {
                    continue;
                }
            }

            //
            // Count one for the base resource, and any per resource
            // special ones (eg Device Private).
            //

            baseResourceCount += RESOURCES_PER_BAR;

            PciDebugPrint(PciDbgObnoxious,
                "    Index %d, Base Resource = TRUE\n",
                index
                );
        }
    }

    //
    // One base type for Interrupts if enabled.
    //

    status = PciGetInterruptAssignment(PdoExtension,
                                       &interruptMin,
                                       &interruptMax);

    if (NT_SUCCESS(status)) {
        generatesInterrupt = TRUE;
        baseResourceCount += RESOURCES_PER_BAR - 1;
    }

    //
    // If the header type dependent resource routines indicated
    // additional resources are required, add them in here.
    //

    baseResourceCount += PdoExtension->AdditionalResourceCount;

    PciDebugPrint(PciDbgPrattling,
                  "PCI - build resource reqs - baseResourceCount = %d\n",
                  baseResourceCount);

    if (baseResourceCount == 0) {

        //
        // This device consumes no resources.  Succeed the request but
        // return a pointer to our private empty list.  This will never
        // actually be given to anyone else but having an empty list
        // removes a bunch of special case code for handling a NULL
        // pointer.
        //

        if (PciZeroIoResourceRequirements == NULL) {
            PciZeroIoResourceRequirements = PciAllocateIoRequirementsList(
                0,  // resource count
                0,  // bus
                0   // slot
                );
        }
        *FinalReqList = PciZeroIoResourceRequirements;

        PciDebugPrint(PciDbgPrattling,
                      "PCI - build resource reqs - early out, 0 resources\n");

        return STATUS_SUCCESS;
    }

    //
    // Allocate and (bulk) initialize the IO resource requirements list.
    //

    reqList = PciAllocateIoRequirementsList(
                  baseResourceCount,
                  PCI_PARENT_FDOX(PdoExtension)->BaseBus,
                  PdoExtension->Slot.u.AsULONG);

    if (reqList == NULL) {

        //
        // Not much we can do about this, bail.
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Second pass, build the resource list.
    //

    if (iterationCount != 0) {
        partial = inUse;
        ioResourceDescriptor = PdoExtension->Resources->Limit;
    }
    resource = reqList->List[0].Descriptors;

    for (index = 0;
         index < iterationCount;
         index++, partial++, ioResourceDescriptor++) {

        BOOLEAN passing;
        ULONG   genericLength;
        ULONG   genericAlignment;

        if (ioResourceDescriptor->Type == CmResourceTypeNull) {

            //
            // Nothing here.
            //

            continue;
        }

        //
        // Try to determine if the current setting for this resource
        // is (a) active (eg is's an IO resource and IO is enabled
        // for this device), and (b) valid.
        //

        passing = FALSE;
        genericLength = ioResourceDescriptor->u.Generic.Length;
        genericAlignment = ioResourceDescriptor->u.Generic.Alignment;

        if (partial->Type == CmResourceTypeNull) {

            //
            // Current setting is either not enabled or it's invalid
            // (h/w invalid ie the h/w will not see it as enabled).
            //
            // The base resource is for a bridged range, skip it
            // altogether.
            //

            if (genericLength == 0) {

                //
                // There is no boot setting for this bridge resource,
                // If the VGA bit is set, no need for a normal range.
                //

                if ((ioResourceDescriptor->Type == CmResourceTypeMemory) ||
                    ((ioResourceDescriptor->Type == CmResourceTypePort) &&
                      (PdoExtension->Dependent.type1.VgaBitSet == FALSE))) {

                    switch (PciClassifyDeviceType(PdoExtension)) {
                    case PciTypePciBridge:

                        if (ioResourceDescriptor->Type == CmResourceTypeMemory) {
                            PciBuildGraduatedWindow(ioResourceDescriptor,
                                                    PCI_GRADUATED_WINDOW_MAX,
                                                    PCI_GRADUATED_WINDOW_COUNT,
                                                    resource);

                            resource += PCI_GRADUATED_WINDOW_COUNT;

                            PciPrivateResourceInitialize(resource,
                                                         PciPrivateBar,
                                                         index);

                            resource++;

                            continue;

                        } else {
                            //
                            // Do the minium for IO space which is 4kb
                            //

                            genericLength = 0x1000;
                            genericAlignment = 0x1000;

                        }

                        break;

                    case PciTypeCardbusBridge:

                        if (ioResourceDescriptor->Type == CmResourceTypeMemory) {
                            PciBuildGraduatedWindow(ioResourceDescriptor,
                                                    PCI_GRADUATED_WINDOW_MAX,
                                                    PCI_GRADUATED_WINDOW_COUNT,
                                                    resource);

                            resource += PCI_GRADUATED_WINDOW_COUNT;

                            PciPrivateResourceInitialize(resource,
                                                         PciPrivateBar,
                                                         index);

                            resource++;

                            continue;

                        } else {
                            //
                            // Do the minium for IO space which is 256 bytes
                            //

                            genericLength = 0x100;
                            genericAlignment = 0x100;
                        }

                        break;
                    default:

                        //
                        // I don't know what this is.
                        // N.B. Can't actually get here.
                        //

                        continue;
                    }
                } else {

                    //
                    // Not IO or memory? - Skip it altogether.
                    //

                    continue;
                }

            } else {

                //
                // Could be that it's a ROM that we don't actually want
                // to report.
                //

                if ((ioResourceDescriptor->Type == CmResourceTypeMemory) &&
                    (ioResourceDescriptor->Flags == CM_RESOURCE_MEMORY_READ_ONLY)) {
                    continue;
                }
            }

        } else {

            //
            // Current setting IS being passed.   If it is a bridge,
            // we will provide the current setting as preferred
            // regardless.  This may change one day, if it does
            // we MUST get the length into the generic setting
            // before we pass it into IO in the resource descriptor.
            //

            if ((genericLength == 0) // bridge

#if PCI_BOOT_CONFIG_PREFERRED

                || (1)                                        // always

#endif
               )
            {
                passing = TRUE;
                genericLength = partial->u.Generic.Length;
            }
        }

        PciDebugPrint(PciDbgObnoxious,
            "    Index %d, Setting Base Resource,%s setting preferred.\n",
            index,
            passing ? "": " not"
            );

        PCI_ASSERT((resource + RESOURCES_PER_BAR + (passing ? 1 : 0) -
                reqList->List[0].Descriptors) <= (LONG)baseResourceCount);

        //
        // Fill in the base resource descriptor.
        //

        *resource = *ioResourceDescriptor;
        resource->ShareDisposition = CmResourceShareDeviceExclusive;
        resource->u.Generic.Length = genericLength;
        resource->u.Generic.Alignment = genericAlignment;

        //
        // Set the positive decode bit and 16 bit decode for all IO requirements
        //

        if (ioResourceDescriptor->Type == CmResourceTypePort) {
            resource->Flags |= (CM_RESOURCE_PORT_POSITIVE_DECODE
                                    | CM_RESOURCE_PORT_16_BIT_DECODE);
        }

        //
        // If this device is decoding IO or Memory, and this resource
        // is of that type, include the prefered settings in the list.
        //

        if (passing) {

            extern BOOLEAN PciLockDeviceResources;

            //
            // Copy the set of descriptors we just created.
            //

            PciDebugPrint(PciDbgVerbose, "  Duplicating for preferred locn.\n");

            *(resource + 1) = *resource;

            //
            // Change the original to indicate it is the preferred
            // setting and put the current settings into minimum
            // address field, current setting + length into the max.
            //

            resource->Option = IO_RESOURCE_PREFERRED;
            resource->u.Generic.MinimumAddress = partial->u.Generic.Start;
            resource->u.Generic.MaximumAddress.QuadPart =
                 resource->u.Generic.MinimumAddress.QuadPart +
                 (resource->u.Generic.Length - 1);

            //
            // The preferred setting is fixed (Start + Length - 1 == End) and
            // so alignment is not a restricting factor.
            //
            resource->u.Generic.Alignment = 1;

            if (PciLockDeviceResources == TRUE ||
                PdoExtension->LegacyDriver == TRUE ||
                PdoExtension->OnDebugPath ||
                (PCI_PARENT_FDOX(PdoExtension)->BusHackFlags & PCI_BUS_HACK_LOCK_RESOURCES) ||

                //
                // This is a work around for a pnp bug which affects Toshiba
                // Satellite machines.  We end up moving the PCI modem off its
                // boot config because it is reserved (on 2f8 or 3f8) and then
                // put a PCMCIA modem on top of it before it has been turned off.
                // Stops before Starts would fix this but the driver folks say
                // they can't deal with that so we need to fix this as part
                // of the rebalance cleanup in 5.1
                //

#if PCI_NO_MOVE_MODEM_IN_TOSHIBA
                (PdoExtension->VendorId == 0x11c1
                 && PdoExtension->DeviceId == 0x0441
                 && PdoExtension->SubsystemVendorId == 0x1179
                 && (PdoExtension->SubsystemId == 0x0001 || PdoExtension->SubsystemId == 0x0002))
#endif

            ) {


                //
                // Restrict the alternatives to the current settings.
                //

                *(resource + 1) = *resource;
            }

            (resource + 1)->Option = IO_RESOURCE_ALTERNATIVE;

            //
            // bump resource by one to allow for the one we just added.
            //

            resource++;
        }

        //
        // A devicePrivateResource is used to keep track of which
        // BAR this resource is derived from.  Record it now because
        // index may get bumped if this is a 64 bit memory BAR.
        //

        PciPrivateResourceInitialize(resource + 1,
                                     PciPrivateBar,
                                     index);

        resource += RESOURCES_PER_BAR;
    }

    //
    // Assign descriptors for interrupts.
    //

    if (generatesInterrupt) {

        PciDebugPrint(PciDbgVerbose, "  Assigning INT descriptor\n");

        //
        // Finally, fill in the base resource descriptor.
        //

        resource->Type = CmResourceTypeInterrupt;
        resource->ShareDisposition = CmResourceShareShared;
        resource->Option = 0;
        resource->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
        resource->u.Interrupt.MinimumVector = interruptMin;
        resource->u.Interrupt.MaximumVector = interruptMax;

        resource += (RESOURCES_PER_BAR - 1);
    }

    if (PdoExtension->AdditionalResourceCount != 0) {

        //
        // The header type dependent code indicated that it has
        // resources to add.  Call it back and allow it do add
        // them now.
        //

        configurator->GetAdditionalResourceDescriptors(
            PdoExtension,
            CurrentConfig,
            resource
            );

        resource += PdoExtension->AdditionalResourceCount;
    }

    //
    // Done.
    //

    PCI_ASSERT(reqList->ListSize == (ULONG_PTR)resource - (ULONG_PTR)reqList);

#if DBG

    PciDebugPrint(PciDbgPrattling,
                  "PCI build resource req - final resource count == %d\n",
                  resource - reqList->List[0].Descriptors);

    PCI_ASSERT((resource - reqList->List[0].Descriptors) != 0);

#endif

    //
    // Return the address of the resource list and a successful status
    // back to the caller.
    //

    *FinalReqList = reqList;

    return STATUS_SUCCESS;
}

VOID
PciWriteLimitsAndRestoreCurrent(
    IN PPCI_COMMON_EXTENSION Extension,
    IN PPCI_CONFIGURABLE_OBJECT This
    )
//
// Overwrite the device's configuration space with the adjusted
// version then read it back to see what the device did with it.
//
{

    //
    // Write out all those F's to work out which bits are sticky
    //

    PciSetConfigData(This->PdoExtension, This->Working);

    //
    // Read in which bits stuck
    //

    PciGetConfigData(This->PdoExtension, This->Working);

    //
    // Return the device to it's previous state by writing the
    // original values back into it.
    //
    // Note: Don't enable anything up front (ie, Command = 0)
    // because the Command register will get wriiten before
    // the BARs are updated which might enable translations
    // at undesirable locations.
    //

    PciSetConfigData(This->PdoExtension, This->Current);

    //
    // Now, return the command register to it's previous state.
    //

    This->Current->Command = This->Command;

    //
    // Only do the write if we are actually going to change the
    // value of the command field.
    //

    if (This->Command != 0) {

        PciSetCommandRegister(This->PdoExtension, This->Command);
    }

    //
    // Restore the status field in the caller's buffer.
    //

    This->Current->Status = This->Status;

    //
    // Restore any type specific fields.
    //

    This->Configurator->RestoreCurrent(This);
}


NTSTATUS
PcipGetFunctionLimits(
    IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    Determine the limits for the Base Address Registers (BARs) for a
    given Bus/Device/Function.

    This is done by writing all ones the the BARs, reading them
    back again.  The hardware will adjust the values to it's limits
    so we just store these new values away.

Arguments:

    This - Pointer to the configuration object.

Return Value:

    Returns status indicating the success or failure of this routine.

--*/

{
    ULONG                   configType;
    PPCI_COMMON_CONFIG      current = This->Current;
    PPCI_COMMON_CONFIG      working = This->Working;
    ULONG                   count;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptor;
    PCI_CRITICAL_ROUTINE_CONTEXT routineContext;


    PAGED_CODE();

    //
    // The first 16 bytes of configuration space are required by the
    // PCI specification to be of the following format.
    //
    //           3            2            1            0
    //    +------------+------------+------------+------------+
    //    |        Device ID        |        Vendor ID        |
    //    +------------+------------+------------+------------+
    //    |          Status         |         Command         |
    //    +------------+------------+------------+------------+
    //    | Base Class | Sub Class  | Progr. I/F | Revision ID|
    //    +------------+------------+------------+------------+
    //    |     BIST   | Header Type|   Latency  | Cache Ln Sz|
    //    +------------+------------+------------+------------+
    //
    // The status field in PCI Configuration space has its bits cleared
    // by writing a one to each bit to be cleared.  Zero the status
    // field in the image of the current configuration space so writing
    // to the hardware will not change it.
    //

    This->Status = current->Status;
    current->Status = 0;

    //
    // Disable the device while it's configuration is being messed
    // with.
    //

    This->Command = current->Command;
    current->Command &= ~(PCI_ENABLE_IO_SPACE |
                          PCI_ENABLE_MEMORY_SPACE |
                          PCI_ENABLE_BUS_MASTER);


    //
    // Make a copy of the configuration space that was handed in.
    // This copy will be modified and written to/read back from the
    // device's configuration space to allow us to determine the
    // limits for the device.
    //

    RtlCopyMemory(working, current, PCI_COMMON_HDR_LENGTH);

    //
    // Get the configuration type from the function's header.
    // NOTE: We have already checked that it is valid so no
    // further checking is needed here.
    //

    configType = PciGetConfigurationType(current);

    //
    // Set the configuration type dispatch table.
    //

    This->Configurator = &PciConfigurators[configType];

    //
    // Modify the "Working" copy of config space such that writing
    // it to the hardware and reading it back again will enable us
    // to determine the "limits" of this hardware's configurability.
    //

    This->Configurator->MassageHeaderForLimitsDetermination(This);

    //
    // Overwrite the device's configuration space with the adjusted
    // version then read it back to see what the device did with it.
    //
    if (This->PdoExtension->HackFlags & PCI_HACK_CRITICAL_DEVICE) {

        //
        // If this is a critical device (one that cannot be safely
        // turned off to determine the limits), call the routine
        // in the context of KeIpiGenericCall, which brings all processors
        // into step, guaranteeing that nothing else will run on
        // the system while we're determining the limits.
        //
        routineContext.Gate = 1;
        routineContext.Barrier = 1;
        routineContext.Routine = PciWriteLimitsAndRestoreCurrent;
        routineContext.Extension = This->PdoExtension;
        routineContext.Context = This;
        KeIpiGenericCall(PciExecuteCriticalSystemRoutine,
                         (ULONG_PTR)&routineContext
                         );
    } else {

        if (This->PdoExtension->OnDebugPath) {

            //
            //  If our debugger is bus mastering then dont clear this bit as it
            //  will blow away the DMA engine on the card and we dont currently
            //  re-program the card when we call KdEnableDebugger.
            //
            if (This->Command & PCI_ENABLE_BUS_MASTER){

                This->Working->Command |= PCI_ENABLE_BUS_MASTER;
                This->Current->Command |= PCI_ENABLE_BUS_MASTER;
            }

            KdDisableDebugger();
        }

        PciWriteLimitsAndRestoreCurrent(This->PdoExtension,
                                        This
                                        );

        if (This->PdoExtension->OnDebugPath) {
            KdEnableDebugger();
        }
    }

#if DBG
    //
    // Check that what was written back stuck.
    //
    if (This->PdoExtension->ExpectedWritebackFailure == FALSE) {

        PPCI_COMMON_CONFIG verifyConfig;
        ULONG              len;

        verifyConfig = (PPCI_COMMON_CONFIG)
            ((ULONG_PTR)This->Working + PCI_COMMON_HDR_LENGTH);
        PciGetConfigData(This->PdoExtension, verifyConfig);

        if ((len = (ULONG)RtlCompareMemory(
                            verifyConfig,
                            This->Current,
                            PCI_COMMON_HDR_LENGTH)) != PCI_COMMON_HDR_LENGTH) {

            //
            // Compare failed.
            //

            PciDebugPrint(PciDbgInformative,
                  "PCI - CFG space write verify failed at offset 0x%x\n",
                  len);
            PciDebugDumpCommonConfig(verifyConfig);
        }
    }
#endif


    //
    // Allocate memory for limits and current usage.
    //
    // Note: This should NOT have been done already.
    //

    PCI_ASSERT(This->PdoExtension->Resources == NULL);

    This->PdoExtension->Resources = ExAllocatePool(
                                        NonPagedPool,
                                        sizeof(PCI_FUNCTION_RESOURCES)
                                        );

    if (This->PdoExtension->Resources == NULL) {

        //
        // Couldn't get memory for this???
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Clear these structures.
    //
    // CmResourceTypeNull == 0, otherwise we need to init the Limits
    // and current settings structures seperately.
    //

    RtlZeroMemory(
        This->PdoExtension->Resources,
        sizeof(PCI_FUNCTION_RESOURCES)
        );

#if CmResourceTypeNull

    for (count = 0; count < PCI_MAX_RANGE_COUNT; count++) {
        This->PdoExtension->Resources->Limit[count].Type = CmResourceTypeNull;
        This->PdoExtension->Resources->Current[count].Type = CmResourceTypeNull;
    }

#endif

    //
    // Copy the limits and current settings into our device extension.
    //

    This->Configurator->SaveLimits(This);
    This->Configurator->SaveCurrentSettings(This);

    //
    // If SaveLimits didn't find any resources, we can free the
    // memory allocated to both limits and current settings. Note
    // that we still must call SaveCurrentSettings because that
    // routine is responsible for saving type specific data.
    //

    count = 0;
    ioResourceDescriptor = This->PdoExtension->Resources->Limit +
                           PCI_MAX_RANGE_COUNT;

    do {
        ioResourceDescriptor--;

        if (ioResourceDescriptor->Type != CmResourceTypeNull) {

            //
            // Some resource exists, get out.
            //

            count++;
            break;
        }
    } while (ioResourceDescriptor != This->PdoExtension->Resources->Limit);

    if (count == 0) {

        //
        // No resources.
        //

        ExFreePool(This->PdoExtension->Resources);
        This->PdoExtension->Resources = NULL;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
PciGetFunctionLimits(
    IN PPCI_PDO_EXTENSION     PdoExtension,
    IN PPCI_COMMON_CONFIG CurrentConfig,
    IN ULONGLONG              Flags
    )

/*++

Description:

    Determine the limits for the Base Address Registers (BARs) for a
    given Bus/Device/Function.

    The work is really done by PcipGetFunctionLimits.  This function is
    a wrapper to handle the allocation/deallocation of working memory.

Arguments:

    PdoExtension  - PDO Extension for the device object to obtain the
                    limits for.
    CurrentConfig - Existing contents of the PCI Common Configuration
                    Space for this function.

Return Value:

    Returns status indicating the success or failure of this routine.

--*/

{
    PPCI_COMMON_CONFIG      workingConfig;
    NTSTATUS                status;
    ULONG                   size;
    PCI_CONFIGURABLE_OBJECT this;

    PAGED_CODE();

    //
    // Check for anything the registry says we should not try
    // to figure out the resources on.  Examples are devices
    // that don't consume resources but return garbage in their
    // base address registers.
    //

    if (PciSkipThisFunction(CurrentConfig,
                            PdoExtension->Slot,
                            EnumResourceDetermination,
                            Flags) == TRUE) {
        return STATUS_SUCCESS;
    }

    size = PCI_COMMON_HDR_LENGTH;

#if DBG

    //
    // If a checked build, we will verify the writeback of the
    // orginal contents of configuration space.  Allow enough
    // space for a verification copy.
    //

    size *= 2;

#endif

    workingConfig = ExAllocatePool(NonPagedPool, size);

    if (workingConfig == NULL) {

        //
        // Failed to get memory to work with, bail.
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    this.Current      = CurrentConfig;
    this.Working      = workingConfig;
    this.PdoExtension = PdoExtension;

    status = PcipGetFunctionLimits(&this);

    ExFreePool(workingConfig);

    return status;
}

VOID
PciProcessBus(
    IN PPCI_FDO_EXTENSION ParentFdo
)
/*++

Routine Description:

    Walk the child devices enumerated by PciScanBus and perform any processing
    the needs to be done once all the children have been enumerated

Arguments:

    ParentFdo - Our extension for the PCI bus functional device object.

Return Value:

    NT status.

--*/

{
    PPCI_PDO_EXTENSION current, vgaBridge = NULL, parentBridge = NULL;

    PAGED_CODE();

    if (!PCI_IS_ROOT_FDO(ParentFdo)) {
        parentBridge = PCI_BRIDGE_PDO(ParentFdo);
    }

    //
    // If our parent is a bridge with the ISA bit set, then set the ISA bit on
    // all child bridges unless they are subtractive in which case we set the
    // IsaRequired bit
    //

    if (parentBridge
    && PciClassifyDeviceType(parentBridge) == PciTypePciBridge
    && (parentBridge->Dependent.type1.IsaBitSet || parentBridge->Dependent.type1.IsaBitRequired)) {

        for (current = ParentFdo->ChildBridgePdoList;
             current;
             current = current->NextBridge) {

            //
            // For now we only set the ISA bit on PCI-PCI bridges
            //

            if (PciClassifyDeviceType(current) == PciTypePciBridge) {
                if (current->Dependent.type1.SubtractiveDecode) {
                    current->Dependent.type1.IsaBitRequired = TRUE;
                } else {
                    current->Dependent.type1.IsaBitSet = TRUE;
                    current->UpdateHardware = TRUE;
                }
            }
        }

    } else {

        //
        // Scan the bridges enumerated to see if we need to set the ISA bit
        //

        for (current = ParentFdo->ChildBridgePdoList;
             current;
             current = current->NextBridge) {

            if (current->Dependent.type1.VgaBitSet) {
                vgaBridge = current;
                break;
            }
        }

        //
        // If we have a bridge with the VGA bit set - set the ISA bit on all other
        // bridges on this bus and force this to be written out to the hardware on
        // the start.
        //

        if (vgaBridge) {

            for (current = ParentFdo->ChildBridgePdoList;
                 current;
                 current = current->NextBridge) {

                if (current != vgaBridge
                && PciClassifyDeviceType(current) == PciTypePciBridge) {

                    //
                    // If this device is already started then we had better have already set the ISA bit
                    //

                    if (current->DeviceState == PciStarted) {
                        PCI_ASSERT(current->Dependent.type1.IsaBitRequired || current->Dependent.type1.IsaBitSet);
                    }

                    //
                    // If its a subtrative decode bridge remember we would have
                    // set the ISA bit so any children can inhereit it, otherwise
                    // set it and force it out to the hardware.
                    //

                    if (current->Dependent.type1.SubtractiveDecode) {
                        current->Dependent.type1.IsaBitRequired = TRUE;
                    } else {
                        current->Dependent.type1.IsaBitSet = TRUE;
                        current->UpdateHardware = TRUE;
                    }
                }
            }
        }
    }

    //
    // Check to see if there are any bridges in need of bus numbers and assign
    // them if we are running on a machine where this is a good idea.
    //
    if (PciAssignBusNumbers) {
        PciConfigureBusNumbers(ParentFdo);
    }
}




NTSTATUS
PciScanBus(
    IN PPCI_FDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    Scan the bus (detailed in FdoExtension) for any PCI devices/functions
    elligible for control via a WDM driver.

Arguments:

    FdoExtension - Our extension for the PCI bus functional device object.

Return Value:

    NT status.

--*/

{
    NTSTATUS status;
    PCI_COMMON_HEADER commonHeader[2];
    PPCI_COMMON_CONFIG commonConfig = (PPCI_COMMON_CONFIG)&commonHeader[0];
    PPCI_COMMON_CONFIG biosConfig = (PPCI_COMMON_CONFIG)&commonHeader[1];
    PDEVICE_OBJECT physicalDeviceObject;
    PPCI_PDO_EXTENSION pdoExtension;
    PCI_SLOT_NUMBER slot;
    ULONG deviceNumber;
    ULONG functionNumber;
    USHORT SubVendorID, SubSystemID;
    BOOLEAN isRoot;
    ULONGLONG hackFlags;
    ULONG maximumDevices;
    BOOLEAN newDevices = FALSE;
    UCHAR secondary;

    PciDebugPrint(PciDbgPrattling,
                  "PCI Scan Bus: FDO Extension @ 0x%x, Base Bus = 0x%x\n",
                  FdoExtension,
                  FdoExtension->BaseBus);

    isRoot = PCI_IS_ROOT_FDO(FdoExtension);

    //
    // Examine each possible device on this bus.
    //

    maximumDevices = PCI_MAX_DEVICES;
    if (!isRoot) {

        //
        // Examine the PDO extension for the bridge device and see
        // if it's broken.
        //

        pdoExtension = (PPCI_PDO_EXTENSION)
                       FdoExtension->PhysicalDeviceObject->DeviceExtension;

        ASSERT_PCI_PDO_EXTENSION(pdoExtension);

        if (pdoExtension->HackFlags & PCI_HACK_ONE_CHILD) {
            maximumDevices = 1;
        }

        //
        // NEC program the bus number in their _DCK method, unfortunatley we have already
        // done it!  So detect someone else reprogramming the bus number and restore
        // the correct one!
        //

        PciReadDeviceConfig(pdoExtension,
                            &secondary,
                            FIELD_OFFSET(PCI_COMMON_CONFIG, u.type1.SecondaryBus),
                            sizeof(UCHAR)
                            );

        if (secondary != pdoExtension->Dependent.type1.SecondaryBus) {
            PciDebugPrint(PciDbgBusNumbers,"PCI: Bus numbers have been changed!  Restoring originals.\n");
            PciSetBusNumbers(pdoExtension,
                             pdoExtension->Dependent.type1.PrimaryBus,
                             pdoExtension->Dependent.type1.SecondaryBus,
                             pdoExtension->Dependent.type1.SubordinateBus
                             );
        }

    }

    slot.u.AsULONG = 0;

    for (deviceNumber = 0;
         deviceNumber < maximumDevices;
         deviceNumber++) {

        slot.u.bits.DeviceNumber = deviceNumber;

        //
        // Examine each possible function on this device.
        // N.B. Early out if function 0 not present.
        //

        for (functionNumber = 0;
             functionNumber < PCI_MAX_FUNCTION;
             functionNumber++) {

            slot.u.bits.FunctionNumber = functionNumber;

            PciReadSlotConfig(FdoExtension,
                              slot,
                              commonConfig,
                              0,
                              sizeof(commonConfig->VendorID)
                              );


            if (commonConfig->VendorID == 0xFFFF ||
                commonConfig->VendorID == 0) {

                if (functionNumber == 0) {

                    //
                    // Didn't get any data on function zero of this
                    // device, no point in checking other functions.
                    //

                    break;

                } else {

                    //
                    // Check next function.
                    //

                    continue;

                }
            }

            //
            // We have a device so get the rest of its config space
            //

            PciReadSlotConfig(FdoExtension,
                              slot,
                              &commonConfig->DeviceID,
                              FIELD_OFFSET(PCI_COMMON_CONFIG, DeviceID),
                              sizeof(PCI_COMMON_HEADER)
                                - sizeof(commonConfig->VendorID)
                              );

            //
            // Munge the config space if necessary
            //

            PciApplyHacks(FdoExtension,
                          commonConfig,
                          slot,
                          EnumHackConfigSpace,
                          NULL
                          );

#if DBG

            {
                ULONG i;
                PWSTR descr;

                i = 0x8000000 |
                    (FdoExtension->BaseBus << 16) |
                    (deviceNumber << 11) |
                    (functionNumber << 8);

                PciDebugPrint(PciDbgPrattling,
                              "Scan Found Device 0x%x (b=0x%x, d=0x%x, f=0x%x)\n",
                              i,
                              FdoExtension->BaseBus,
                              deviceNumber,
                              functionNumber);

                PciDebugDumpCommonConfig(commonConfig);

                descr = PciGetDeviceDescriptionMessage(
                            commonConfig->BaseClass,
                            commonConfig->SubClass);

                PciDebugPrint(PciDbgPrattling,
                              "Device Description \"%S\".\n",
                              descr ? descr : L"(NULL)");

                if (descr) {
                    ExFreePool(descr);
                }
            }

#endif

            //
            // Look for the watchdog timer device.
            // If this is the watchdog device and the
            // vendor has requested to have the device
            // hidden then swallow the device.
            //

            if (WdTable != NULL && isRoot &&
                 FdoExtension->BaseBus == WdTable->PciBusNumber &&
                 commonConfig->VendorID == WdTable->PciVendorId &&
                 commonConfig->DeviceID == WdTable->PciDeviceId &&
                 deviceNumber == WdTable->PciSlotNumber &&
                 functionNumber == WdTable->PciFunctionNumber) {

                continue;
            }

            if ((PciGetConfigurationType(commonConfig) == PCI_DEVICE_TYPE) &&
                (commonConfig->BaseClass != PCI_CLASS_BRIDGE_DEV)) {
                SubVendorID = commonConfig->u.type0.SubVendorID;
                SubSystemID = commonConfig->u.type0.SubSystemID;
            } else {
                SubVendorID = 0;
                SubSystemID = 0;
            }

            hackFlags = PciGetHackFlags(commonConfig->VendorID,
                                        commonConfig->DeviceID,
                                        SubVendorID,
                                        SubSystemID,
                                        commonConfig->RevisionID
                                        );

            if (PciIsCriticalDeviceClass(commonConfig->BaseClass,commonConfig->SubClass) &&
                !(hackFlags & PCI_HACK_OVERRIDE_CRITICAL_DEVICE)) {

                hackFlags |= PCI_HACK_CRITICAL_DEVICE;
            }

            if ((commonConfig->BaseClass == PCI_CLASS_BRIDGE_DEV)      &&
                (commonConfig->SubClass == PCI_SUBCLASS_BR_PCI_TO_PCI) &&
                (commonConfig->u.type1.BridgeControl & PCI_ENABLE_BRIDGE_VGA)) {

                //
                // If this is a PCI-to-PCI bridge whose VGA routing bit is enabled,
                // then the legacy VGA lives below this bridge and we must treat
                // it as a critical device.
                //
                if (!(hackFlags & PCI_HACK_OVERRIDE_CRITICAL_DEVICE)) {
                    
                    hackFlags |= PCI_HACK_CRITICAL_DEVICE;
                }
            }
            
            if (PciSkipThisFunction(commonConfig,
                                    slot,
                                    EnumBusScan,
                                    hackFlags)) {
                //
                // Skip this function
                //

                continue;
            }


            //
            // In case we are rescanning the bus, check to see if
            // a PDO for this device already exists as a child of
            // the FDO.
            //

            pdoExtension = PciFindPdoByFunction(
                               FdoExtension,
                               slot,
                               commonConfig);

            if (pdoExtension == NULL) {

                //
                // Create a PDO for this new device.
                //

                newDevices = TRUE;

                status = PciPdoCreate(FdoExtension,
                                      slot,
                                      &physicalDeviceObject);

                if (!NT_SUCCESS(status)) {
                    PCI_ASSERT(NT_SUCCESS(status));
                    return status;
                }

                pdoExtension = (PPCI_PDO_EXTENSION)
                               physicalDeviceObject->DeviceExtension;

                if (hackFlags & PCI_HACK_FAKE_CLASS_CODE) {
                    commonConfig->BaseClass = PCI_CLASS_BASE_SYSTEM_DEV;
                    commonConfig->SubClass = PCI_SUBCLASS_SYS_OTHER;
#if DBG
                    pdoExtension->ExpectedWritebackFailure = TRUE;
#endif
                }

                //
                // Record device identification and type info.
                //

                pdoExtension->VendorId   = commonConfig->VendorID;
                pdoExtension->DeviceId   = commonConfig->DeviceID;
                pdoExtension->RevisionId = commonConfig->RevisionID;
                pdoExtension->ProgIf     = commonConfig->ProgIf;
                pdoExtension->SubClass   = commonConfig->SubClass;
                pdoExtension->BaseClass  = commonConfig->BaseClass;
                pdoExtension->HeaderType =
                    PciGetConfigurationType(commonConfig);

                //
                // If this is a bridge (PCI-PCI or Cardbus) then insert into
                // the list of child bridges for this bus
                //

                if (pdoExtension->BaseClass == PCI_CLASS_BRIDGE_DEV
                &&  (pdoExtension->SubClass == PCI_SUBCLASS_BR_PCI_TO_PCI
                  || pdoExtension->SubClass == PCI_SUBCLASS_BR_CARDBUS)) {

                    PPCI_PDO_EXTENSION *current;

                    //
                    // Insert at the end of the list
                    //

                    ExAcquireFastMutex(&FdoExtension->ChildListMutex);

                    current = &FdoExtension->ChildBridgePdoList;

                    while (*current) {
                        current = &((*current)->NextBridge);
                    }

                    *current = pdoExtension;
                    PCI_ASSERT(pdoExtension->NextBridge == NULL);

                    ExReleaseFastMutex(&FdoExtension->ChildListMutex);
                }


                //
                // See if we have already cached info for this device
                //

                status = PciGetBiosConfig(pdoExtension,
                                          biosConfig
                                          );

                if (NT_SUCCESS(status)) {

                    //
                    // Check if its the same device
                    //

                    if (PcipIsSameDevice(pdoExtension, biosConfig)) {

                        //
                        // Write the BiosConfig InterruptLine out to the hardware
                        // now and don't wait until start as many HALs will fail in
                        // PciGetAdjustedInterruptLine if we don't
                        //

                        if (biosConfig->u.type1.InterruptLine
                                != commonConfig->u.type1.InterruptLine) {

                            PciWriteDeviceConfig(pdoExtension,
                                                 &biosConfig->u.type1.InterruptLine,
                                                 FIELD_OFFSET(PCI_COMMON_CONFIG,
                                                              u.type1.InterruptLine),
                                                 sizeof(UCHAR)
                                                 );
                        }

                        pdoExtension->RawInterruptLine
                            = biosConfig->u.type0.InterruptLine;

                        pdoExtension->InitialCommand = biosConfig->Command;


                    } else {

                        //
                        // Its a different device so blow away the old bios
                        // config
                        //

                        status = STATUS_UNSUCCESSFUL;
                    }

                }

                if (!NT_SUCCESS(status)) {

                    //
                    // Write out the BiosConfig from the config space we just
                    // read from the hardware
                    //

                    status = PciSaveBiosConfig(pdoExtension,
                                               commonConfig
                                               );

                    PCI_ASSERT(NT_SUCCESS(status));

                    pdoExtension->RawInterruptLine
                        = commonConfig->u.type0.InterruptLine;

                    pdoExtension->InitialCommand = commonConfig->Command;

                }

                //
                // Save the command register so we can restore the appropriate bits
                //
                pdoExtension->CommandEnables = commonConfig->Command;

                //
                // Save the device flags so we don't need to go to
                // the registry all the time.
                //

                pdoExtension->HackFlags = hackFlags;

                //
                // See if we have any capabilities for this device
                //

                PciGetEnhancedCapabilities(pdoExtension, commonConfig);

                //
                // Before we calculate the Bar length, or get the capabilities
                // we may need to set the device to D0. N.B. This does *not*
                // update the power state stored in the pdoExtension.
                //
                PciSetPowerManagedDevicePowerState(
                    pdoExtension,
                    PowerDeviceD0,
                    FALSE
                    );

                //
                // Apply any hacks we know about for this device
                //

                PciApplyHacks(FdoExtension,
                              commonConfig,
                              slot,
                              EnumBusScan,
                              pdoExtension
                              );

                //
                // The interrupt number we report in the config data is obtained
                // from the HAL rather than the hardware's config space.
                //
                pdoExtension->InterruptPin = commonConfig->u.type0.InterruptPin;
                pdoExtension->AdjustedInterruptLine = PciGetAdjustedInterruptLine(pdoExtension);

                //
                // Work out if we are on the debug path
                //

                pdoExtension->OnDebugPath = PciIsDeviceOnDebugPath(pdoExtension);

                //
                // Get the IO and MEMORY limits for this device.  This
                // is a hardware thing and will never change so we keep
                // it in the PDO extension for future reference.
                //

                status = PciGetFunctionLimits(pdoExtension,
                                              commonConfig,
                                              hackFlags);


                //
                // NTRAID #62636 - 4/20/2000 - andrewth
                // We are going to expose a PDO. Why not just let the OS put
                // into whatever Dstate it feels?
                //
                PciSetPowerManagedDevicePowerState(
                    pdoExtension,
                    pdoExtension->PowerState.CurrentDeviceState,
                    FALSE
                    );

                //
                // Currently, this only returns errors on memory allocation.
                //
                if (!NT_SUCCESS(status)) {
                    PCI_ASSERT(NT_SUCCESS(status));
                    PciPdoDestroy(physicalDeviceObject);
                    return status;
                }

                //
                // If the device's SubSystem ID fields are not
                // guaranteed to be the same when we enumerate
                // the device after reapplying power to it (ie
                // they depend on the BIOS to initialize it),
                // then pretend it doesn't have a SubSystem ID
                // at all.
                //

                if (hackFlags & PCI_HACK_NO_SUBSYSTEM) {
                    pdoExtension->SubsystemVendorId = 0;
                    pdoExtension->SubsystemId       = 0;
                }

#if DBG
                //
                // Dump the capabilities list.
                //

                {
                    union _cap_buffer {
                        PCI_CAPABILITIES_HEADER header;
                        PCI_PM_CAPABILITY       pm;
                        PCI_AGP_CAPABILITY      agp;
                    } cap;

                    UCHAR   capOffset = pdoExtension->CapabilitiesPtr;
                    PUCHAR  capStr;
                    ULONG   nshort;
                    PUSHORT capData;

                    //
                    // Run the list.
                    //

                    while (capOffset != 0) {

                        UCHAR tmpOffset;
                        tmpOffset = PciReadDeviceCapability(
                                        pdoExtension,
                                        capOffset,
                                        0,          // match ANY ID
                                        &cap,
                                        sizeof(cap.header)
                                        );

                        if (tmpOffset != capOffset) {

                            //
                            // Sanity check only, this can't happen.
                            //

                            PciDebugPrint(
                                PciDbgAlways,
                                "PCI - Failed to read PCI capability at offset 0x%02x\n",
                                capOffset
                                );

                            PCI_ASSERT(tmpOffset == capOffset);
                            break;
                        }

                        //
                        // Depending on the Capability ID, the amount
                        // of data varies.
                        //

                        switch (cap.header.CapabilityID) {
                        case PCI_CAPABILITY_ID_POWER_MANAGEMENT:

                            capStr = "POWER";
                            nshort = 3;
                            tmpOffset = PciReadDeviceCapability(
                                            pdoExtension,
                                            capOffset,
                                            cap.header.CapabilityID,
                                            &cap,
                                            sizeof(cap.pm)
                                            );
                            break;

                        case PCI_CAPABILITY_ID_AGP:

                            capStr = "AGP";
                            nshort = 5;
                            tmpOffset = PciReadDeviceCapability(
                                            pdoExtension,
                                            capOffset,
                                            cap.header.CapabilityID,
                                            &cap,
                                            sizeof(cap.agp)
                                            );
                            break;

                        default:

                            capStr = "UNKNOWN CAPABILITY";
                            nshort = 0;
                            break;
                        }

                        PciDebugPrint(
                            PciDbgPrattling,
                            "CAP @%02x ID %02x (%s)",
                            capOffset,
                            cap.header.CapabilityID,
                            capStr
                            );

                        if (tmpOffset != capOffset) {

                            //
                            // Sanity check only, this can't happen.
                            //

                            PciDebugPrint(
                                PciDbgAlways,
                                "- Failed to read capability data. ***\n"
                                );

                            PCI_ASSERT(tmpOffset == capOffset);
                            break;
                        }

                        capData = ((PUSHORT)&cap) + 1;

                        while (nshort--) {

                            PciDebugPrint(
                                PciDbgPrattling,
                                "  %04x",
                                *capData++
                                );
                        }
                        PciDebugPrint(PciDbgPrattling, "\n");

                        //
                        // Advance to the next entry in the list.
                        //

                        capOffset = cap.header.Next;
                    }
                }

#endif

                //
                // Don't allow Power Down to legacy type busses (ISA/EISA/
                // MCA).  Who knows what sort of unenumerated devices
                // might be out there that the system is dependent on.
                //

#ifdef PCIIDE_HACKS

                //
                // NTRAID #103766 - 4/20/2000 - andrewth
                // This needs to be removed
                // Also, don't allow an IDE device to power itself off.
                //

                if (pdoExtension->BaseClass == PCI_CLASS_MASS_STORAGE_CTLR &&
                    pdoExtension->SubClass  == PCI_SUBCLASS_MSC_IDE_CTLR) {
                    pdoExtension->DisablePowerDown = TRUE;
                }
#endif

                if ((pdoExtension->BaseClass == PCI_CLASS_BRIDGE_DEV &&
                     (pdoExtension->SubClass == PCI_SUBCLASS_BR_ISA ||
                      pdoExtension->SubClass == PCI_SUBCLASS_BR_EISA ||
                      pdoExtension->SubClass == PCI_SUBCLASS_BR_MCA)) ||

                    (pdoExtension->VendorId == 0x8086 &&
                     pdoExtension->DeviceId == 0x0482)) {

                    pdoExtension->DisablePowerDown = TRUE;
                }

                //
                // Try to determine if this device looks like it was hot plugged
                // we assume that if IO, Mem and BusMaster bits are off and no
                // one has initialized either the latency timer or the cache line
                // size they should be initialized.
                //

                if (((pdoExtension->CommandEnables & (PCI_ENABLE_IO_SPACE
                                                      | PCI_ENABLE_MEMORY_SPACE
                                                      | PCI_ENABLE_BUS_MASTER)) == 0)
                &&  commonConfig->LatencyTimer == 0
                &&  commonConfig->CacheLineSize == 0) {

                    PciDebugPrint(
                        PciDbgConfigParam,
                        "PCI - ScanBus, PDOx %x found unconfigured\n",
                        pdoExtension
                        );

                    //
                    // Remember we need to configure this in PciSetResources
                    //

                    pdoExtension->NeedsHotPlugConfiguration = TRUE;
                }
                //
                // Save the Latency Timer and Cache Line Size
                // registers.   These were set by the BIOS on
                // power up but might need to be reset by the
                // OS if the device is powered down/up by the
                // OS without a reboot.
                //

                pdoExtension->SavedLatencyTimer =
                    commonConfig->LatencyTimer;
                pdoExtension->SavedCacheLineSize =
                    commonConfig->CacheLineSize;

                //
                // We are able to receive IRPs for this device now.
                //

                physicalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

            } else {

                //
                // A PDO already exists for this device.
                //

                pdoExtension->NotPresent = FALSE;
                PCI_ASSERT(pdoExtension->DeviceState != PciDeleted);
            }

            if ( (functionNumber == 0) &&
                !PCI_MULTIFUNCTION_DEVICE(commonConfig) ) {

                //
                // Not a multifunction adapter, skip other functions on
                // this device.
                //

                break;
            }
        }       // function loop
    }           // device loop

    //
    // Perform any post processing on the devices for this bridge if we found any
    // new devices
    //

    if (newDevices) {
        PciProcessBus(FdoExtension);
    }

    return STATUS_SUCCESS;

}

NTSTATUS
PciQueryRequirements(
    IN  PPCI_PDO_EXTENSION                  PdoExtension,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST *RequirementsList
    )
/*++

Routine Description:

    Calculate the device's resource requirements from PCI Config space.

Arguments:

    PdoExtension     - Pdo Extension for the device (object) whose
                       requirements are needed.

    RequirementsList - Returns the address of the requirements list.

Return Value:

    NT status.

--*/
{
    NTSTATUS status;
    PCI_COMMON_HEADER commonHeader;
    PPCI_COMMON_CONFIG commonConfig = (PPCI_COMMON_CONFIG)&commonHeader;

    PAGED_CODE();

    //
    // Early out, if the device has no CM or IO resources and doesn't
    // use interrupts,... it doesn't have any resource requirements.
    //

    if ((PdoExtension->Resources == NULL) &&
        (PdoExtension->InterruptPin == 0)) {
        PciDebugPrint(
            PciDbgPrattling,
            "PciQueryRequirements returning NULL requirements list\n");
        *RequirementsList = NULL;
        return STATUS_SUCCESS;
    }

    //
    // Get the config space for the device (still needed to gen
    // a requirements list.   This should be changed so the PDOx
    // has enough info to do it without going to the h/w again).
    //

    PciGetConfigData(PdoExtension, commonConfig);

    status = PciBuildRequirementsList(PdoExtension,
                                      commonConfig,
                                      RequirementsList);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Check if this is the broken Compaq hot-plug controller that
    // is integrated into the Profusion chipset.  It only does a 32bit
    // decode in a 64bit address space... Does this seem familiar to anyone...
    // can you say ISA aliasing!
    //
    // The solution is to disable the memory decode.  This was done earlier in
    // PciApplyHacks from PciScan Bus.  But so that the user gets to keep the
    // hot-plug functionality we need to still enumerate but prune out the
    // memory requirement and rely on the fact that the registers can be
    // accessed through config space.
    //
    // Only do this on machines with PAE enabled as they can have > 4GB.
    // Note that this will only work on x86 machines but this is an x86 only
    // chipset.  Only revision 0x11 was broken.
    //


    if (commonConfig->VendorID == 0x0e11
    &&  commonConfig->DeviceID == 0xa0f7
    &&  commonConfig->RevisionID == 0x11
    &&  ExIsProcessorFeaturePresent(PF_PAE_ENABLED)) {

        PIO_RESOURCE_DESCRIPTOR current;

        //
        // Prune out the memory requirement
        //


        FOR_ALL_IN_ARRAY((*RequirementsList)->List[0].Descriptors,
                         (*RequirementsList)->List[0].Count,
                         current) {
            if (current->Type == CmResourceTypeMemory) {
                PIO_RESOURCE_DESCRIPTOR lookahead = current + 1;

                current->Type = CmResourceTypeNull;
                if (lookahead < ((*RequirementsList)->List[0].Descriptors +
                                 (*RequirementsList)->List[0].Count)) {
                    if (lookahead->Type == CmResourceTypeDevicePrivate) {
                        lookahead->Type = CmResourceTypeNull;
                        current++;
                    }
                }
            }
        }
    }

    if (*RequirementsList == PciZeroIoResourceRequirements) {

        //
        // This device (function) has no resources, return NULL
        // intead of our zero list.
        //

        *RequirementsList = NULL;

#if DBG

        PciDebugPrint(PciDbgPrattling, "Returning NULL requirements list\n");

    } else {

        PciDebugPrintIoResReqList(*RequirementsList);

#endif

    }
    return STATUS_SUCCESS;
}

NTSTATUS
PciQueryResources(
    IN  PPCI_PDO_EXTENSION     PdoExtension,
    OUT PCM_RESOURCE_LIST *ResourceList
    )
/*++

Routine Description:

    Given a pointer to a PCI PDO, this routine allocates and returns a pointer
    to the resource description of that PDO.

Arguments:

    PdoExtension - Our extension for the PCI-enumerated physical device object.

    ResourceList - Used to return a pointer to the resource list.

Return Value:

    NT status.

--*/
{
    ULONG    i;
    ULONG    resourceCount;
    PCM_RESOURCE_LIST cmResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR resource, lastResource;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR current;
    BOOLEAN enabledMemory;
    BOOLEAN enabledIo;
    USHORT command;

    PAGED_CODE();

    *ResourceList = NULL;

    //
    // Get a count of the resources.
    //

    if (PdoExtension->Resources == NULL) {

        //
        // This device has no resources, successfully return
        // a NULL resource list.
        //

        return STATUS_SUCCESS;
    }

    //
    // Seeing as other drivers (esp VideoPort for multimon) can change the
    // enables for this device re-read the hardware to ensure we are correct.
    //

    PciGetCommandRegister(PdoExtension, &command);

    enabledMemory = BITS_SET(command, PCI_ENABLE_MEMORY_SPACE);
    enabledIo = BITS_SET(command, PCI_ENABLE_IO_SPACE);

    resourceCount = 0;
    current = PdoExtension->Resources->Current;

    for (i = 0; i < PCI_MAX_RANGE_COUNT; i++, current++) {
        if ((enabledMemory && (current->Type == CmResourceTypeMemory))
        ||  (enabledIo && (current->Type == CmResourceTypePort))) {
            resourceCount++;
       }
    }

    if (PdoExtension->InterruptPin && (enabledMemory || enabledIo)) {

        if (PdoExtension->AdjustedInterruptLine != 0 && PdoExtension->AdjustedInterruptLine != 0xFF) {
            resourceCount += 1;
        }
    }




    if (resourceCount == 0) {

        //
        // Device has no resources currently enabled.
        //

        return STATUS_SUCCESS;
    }

    //
    // Allocate a CM Resource List large enough to handle this
    // device's resources.
    //

    cmResourceList = PciAllocateCmResourceList(
                         resourceCount,
                         PCI_PARENT_FDOX(PdoExtension)->BaseBus
                         );
    if (cmResourceList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    resource = PciFirstCmResource(cmResourceList);
    lastResource = resource + resourceCount;

    //
    // Copy the resources from the PDO's in-use resource table to
    // the output resource list - the ISA bit is set will be dealt with in
    // the arbiters - just as for resource requirements.
    //

    current = PdoExtension->Resources->Current;
    for (i = 0; i < PCI_MAX_RANGE_COUNT; i++, current++) {
        if (enabledMemory && (current->Type == CmResourceTypeMemory)) {
            *resource++ = *current;
        } else if (enabledIo && (current->Type == CmResourceTypePort)) {
            *resource++ = *current;
        }
    }

    if (PdoExtension->InterruptPin && (enabledMemory || enabledIo)) {

        if (PdoExtension->AdjustedInterruptLine != 0 && PdoExtension->AdjustedInterruptLine != 0xFF) {

            PCI_ASSERT(resource < lastResource);

            resource->Type = CmResourceTypeInterrupt;
            resource->ShareDisposition = CmResourceShareShared;
            resource->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;;
            resource->u.Interrupt.Level =
            resource->u.Interrupt.Vector = PdoExtension->AdjustedInterruptLine;
            resource->u.Interrupt.Affinity = (ULONG)-1;
        }
    }


    //
    // Return the list and indicate success.
    //

    *ResourceList = cmResourceList;
    return STATUS_SUCCESS;
}

NTSTATUS
PciQueryDeviceRelations(
    IN PPCI_FDO_EXTENSION FdoExtension,
    IN OUT PDEVICE_RELATIONS *PDeviceRelations
    )

/*++

Routine Description:

    This function builds a DEVICE_RELATIONS structure containing an array
    of pointers to physical device objects for the devices of the specified
    type on the bus indicated by FdoExtension.

Arguments:

    FdoExtension - Pointer to the FDO Extension for the bus itself.
    PDeviceRelations - Used to return the pointer to the allocated
                   device relations structure.

Return Value:

    Returns the status of the operation.

--*/

{
    ULONG pdoCount;
    PPCI_PDO_EXTENSION childPdo;
    PDEVICE_RELATIONS deviceRelations;
    PDEVICE_RELATIONS oldDeviceRelations;
    ULONG deviceRelationsSize;
    PDEVICE_OBJECT physicalDeviceObject;
    PDEVICE_OBJECT *object;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Check that it reasonable to perform this operation now.
    //

    if (FdoExtension->DeviceState != PciStarted) {

        PCI_ASSERT(FdoExtension->DeviceState == PciStarted);

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // We're going to mess with the child pdo list - lock the state...
    //
    status = PCI_ACQUIRE_STATE_LOCK(FdoExtension);
    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Run down the existing child list and flag each child as
    // not present.   This flag will be cleared by the bus
    // scan when (/if) the device is still present.   Any pdo
    // with the flag still present after the scan is no longer
    // in the system (could be powered off).
    //

    childPdo = FdoExtension->ChildPdoList;
    while (childPdo != NULL) {
        childPdo->NotPresent = TRUE;
        childPdo = childPdo->Next;
    }

    //
    // Enumerate the bus.
    //

    status = PciScanBus(FdoExtension);

    if (!NT_SUCCESS(status)) {

        PCI_ASSERT(NT_SUCCESS(status));
        goto cleanup;
    }

    //
    // First count the child PDOs
    //

    pdoCount = 0;
    childPdo = FdoExtension->ChildPdoList;
    while (childPdo != NULL) {
        if (childPdo->NotPresent == FALSE) {
            pdoCount++;

        } else {

            childPdo->ReportedMissing = TRUE;
#if DBG
            PciDebugPrint(
                PciDbgObnoxious,
                "PCI - Old device (pdox) %08x not found on rescan.\n",
                childPdo
                );
#endif

        }
        childPdo = childPdo->Next;
    }


    //
    // Calculate the amount of memory required to hold the DEVICE_RELATIONS
    // structure along with the array
    //

    deviceRelationsSize = FIELD_OFFSET(DEVICE_RELATIONS, Objects) +
                          pdoCount * sizeof(PDEVICE_OBJECT);

    //
    // We could be either (a) creating the DEVICE_RELATIONS structure
    // (list) here, or (b) adding our PDOs to an existing list.
    //

    oldDeviceRelations = *PDeviceRelations;

    if (oldDeviceRelations != NULL) {

        //
        // List already exists, allow enough space for both the old
        // and the new.
        //

        deviceRelationsSize += oldDeviceRelations->Count *
                               sizeof(PDEVICE_OBJECT);
    }

    deviceRelations = ExAllocatePool(NonPagedPool, deviceRelationsSize);

    if (deviceRelations == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    deviceRelations->Count = 0;

    if (oldDeviceRelations != NULL) {

        //
        // Copy and free the old list.
        //

        RtlCopyMemory(deviceRelations,
                      oldDeviceRelations,
                      FIELD_OFFSET(DEVICE_RELATIONS, Objects) +
                      oldDeviceRelations->Count * sizeof(PDEVICE_OBJECT));

        ExFreePool(oldDeviceRelations);
    }

    //
    // Set object to point at the DeviceRelations list entry being
    // added, walk our PDO list adding entries until we reach the
    // end of the list.
    //

    object = &deviceRelations->Objects[deviceRelations->Count];
    childPdo = FdoExtension->ChildPdoList;

    PciDebugPrint(
        PciDbgObnoxious,
        "PCI QueryDeviceRelations/BusRelations FDOx %08x (bus 0x%02x)\n",
        FdoExtension,
        FdoExtension->BaseBus
        );

    while (childPdo) {

        PciDebugPrint(
            PciDbgObnoxious,
            "  QDR PDO %08x (x %08x)%s\n",
            childPdo->PhysicalDeviceObject,
            childPdo,
            childPdo->NotPresent ? " <Omitted, device flaged not present>" : ""
            );

        if (childPdo->NotPresent == FALSE) {
            physicalDeviceObject = childPdo->PhysicalDeviceObject;
            ObReferenceObject(physicalDeviceObject);
            *object++ = physicalDeviceObject;
        }
        childPdo = childPdo->Next;
    }

    PciDebugPrint(
        PciDbgObnoxious,
        "  QDR Total PDO count = %d (%d already in list)\n",
        deviceRelations->Count + pdoCount,
        deviceRelations->Count
        );

    deviceRelations->Count += pdoCount;
    *PDeviceRelations = deviceRelations;

    status = STATUS_SUCCESS;

cleanup:

    //
    // Unlock
    //
    PCI_RELEASE_STATE_LOCK(FdoExtension);

    return status;
}

NTSTATUS
PciQueryTargetDeviceRelations(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN OUT PDEVICE_RELATIONS *PDeviceRelations
    )

/*++

Routine Description:

    This function builds a DEVICE_RELATIONS structure containing a
    one element array of pointers to the device object for which
    PdoExtension is the device extension.

Arguments:

    PdoExtension - Pointer to the PDO Extension for the device itself.
    PDeviceRelations - Used to return the pointer to the allocated
                   device relations structure.

Return Value:

    Returns the status of the operation.

--*/

{
    PDEVICE_RELATIONS deviceRelations;

    PAGED_CODE();

    if (*PDeviceRelations != NULL) {

        //
        // The caller kindly supplied a device relations structure,
        // it's either too small or exactly the right size.   Throw
        // it away.
        //

        ExFreePool(*PDeviceRelations);
    }

    deviceRelations = ExAllocatePool(NonPagedPool, sizeof(DEVICE_RELATIONS));

    if (deviceRelations == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    deviceRelations->Count = 1;
    deviceRelations->Objects[0] = PdoExtension->PhysicalDeviceObject;
    *PDeviceRelations = deviceRelations;

    ObReferenceObject(deviceRelations->Objects[0]);

    return STATUS_SUCCESS;
}

BOOLEAN
PcipIsSameDevice(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    )
{
    //
    // Verify the data we got, was for the same device
    //

    if ((CommonConfig->VendorID != PdoExtension->VendorId) ||
        (CommonConfig->DeviceID != PdoExtension->DeviceId) ||
        (CommonConfig->RevisionID != PdoExtension->RevisionId)) {

        return FALSE;
    }

    //
    // If the device has a subsystem ID make sure that's the same too.
    //

    if ((PciGetConfigurationType(CommonConfig) == PCI_DEVICE_TYPE) &&
        (PdoExtension->BaseClass != PCI_CLASS_BRIDGE_DEV)          &&
        ((PdoExtension->HackFlags & PCI_HACK_NO_SUBSYSTEM) == 0)&&
        ((PdoExtension->HackFlags & PCI_HACK_NO_SUBSYSTEM_AFTER_D3) == 0)) {

        if ((PdoExtension->SubsystemVendorId !=
             CommonConfig->u.type0.SubVendorID) ||
            (PdoExtension->SubsystemId       !=
             CommonConfig->u.type0.SubSystemID)) {

            return FALSE;
        }
    }

    //
    // Done
    //

    return TRUE;
}

NTSTATUS
PciQueryEjectionRelations(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN OUT PDEVICE_RELATIONS *PDeviceRelations
    )

/*++

Routine Description:

    This function builds a DEVICE_RELATIONS structure containing an array
    of pointers to the device objects that would presumably leave if this
    device were ejected. This is constructed from all the functions of a device.

Arguments:

    PdoExtension - Pointer to the PDO Extension for the device itself.
    PDeviceRelations - Used to return the pointer to the allocated
                 device relations structure.

Return Value:

    Returns the status of the operation.

--*/
{
    PPCI_FDO_EXTENSION     fdoExtension;
    PPCI_PDO_EXTENSION     siblingExtension;
    PDEVICE_RELATIONS  ejectionRelations;
    ULONG              additionalNodes, relationCount;

    additionalNodes = 0;
    fdoExtension = PCI_PARENT_FDOX(PdoExtension);

    //
    // Search the child Pdo list.
    //

    ExAcquireFastMutex(&fdoExtension->ChildListMutex);
    for ( siblingExtension = fdoExtension->ChildPdoList;
          siblingExtension;
          siblingExtension = siblingExtension->Next ) {

        //
        // Is this someone who should be in the list?
        //

        if ((siblingExtension != PdoExtension) &&
            (!siblingExtension->NotPresent) &&
            (siblingExtension->Slot.u.bits.DeviceNumber ==
             PdoExtension->Slot.u.bits.DeviceNumber)) {

            additionalNodes++;
        }
    }

    if (!additionalNodes) {

        ExReleaseFastMutex(&fdoExtension->ChildListMutex);

        return STATUS_NOT_SUPPORTED;
    }

    relationCount = (*PDeviceRelations) ? (*PDeviceRelations)->Count : 0;

    ejectionRelations = (PDEVICE_RELATIONS) ExAllocatePool(
        NonPagedPool,
        sizeof(DEVICE_RELATIONS)+
            (relationCount+additionalNodes-1)*sizeof(PDEVICE_OBJECT)
        );

    if (ejectionRelations == NULL) {

        ExReleaseFastMutex(&fdoExtension->ChildListMutex);

        return STATUS_NOT_SUPPORTED;
    }

    if (*PDeviceRelations) {

        RtlCopyMemory(
            ejectionRelations,
            *PDeviceRelations,
            sizeof(DEVICE_RELATIONS)+
                (relationCount-1)*sizeof(PDEVICE_OBJECT)
            );

        ExFreePool(*PDeviceRelations);

    } else {

        ejectionRelations->Count = 0;
    }

    for ( siblingExtension = fdoExtension->ChildPdoList;
          siblingExtension;
          siblingExtension = siblingExtension->Next ) {

        //
        // Is this someone who should be in the list?
        //

        if ((siblingExtension != PdoExtension) &&
            (!siblingExtension->NotPresent) &&
            (siblingExtension->Slot.u.bits.DeviceNumber ==
             PdoExtension->Slot.u.bits.DeviceNumber)) {

            ObReferenceObject(siblingExtension->PhysicalDeviceObject);
            ejectionRelations->Objects[ejectionRelations->Count++] =
                siblingExtension->PhysicalDeviceObject;
        }
    }

    *PDeviceRelations = ejectionRelations;

    ExReleaseFastMutex(&fdoExtension->ChildListMutex);

    return STATUS_SUCCESS;
}

BOOLEAN
PciIsSameDevice(
    IN PPCI_PDO_EXTENSION PdoExtension
    )
{
    PCI_COMMON_HEADER               commonHeader;

    //
    // Get the devices pci data
    //

    PciGetConfigData(PdoExtension, &commonHeader);

    return PcipIsSameDevice(PdoExtension, (PPCI_COMMON_CONFIG)&commonHeader);
}

BOOLEAN
PciComputeNewCurrentSettings(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PCM_RESOURCE_LIST ResourceList
    )
/*++

Routine Description:

    Determine the new "device settings" based on the incoming
    resource list.

Arguments:

    PdoExtension    - Pointer to the PDO Extension for the PDO.
    ResourceList    - The set of resources the device is to be configured
                      to use.

Return Value:

    Returns TRUE if the devices new settings are not the same as
    the settings programmed into the device (FALSE otherwise).

--*/

{
    CM_PARTIAL_RESOURCE_DESCRIPTOR  newResources[PCI_MAX_RANGE_COUNT];
    PCM_FULL_RESOURCE_DESCRIPTOR    fullList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR oldPartial;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partial = NULL;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR nextPartial;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR interruptResource = NULL;
    BOOLEAN                         configurationChanged = FALSE;
    ULONG                           listCount;
    ULONG                           count;
    ULONG                           bar;

    PAGED_CODE();

    //
    // We should never get a Count of anything other that 1 but if so deal with 0 gracefully
    //

    PCI_ASSERT(ResourceList == NULL || ResourceList->Count == 1);

    if (ResourceList == NULL || ResourceList->Count == 0) {

        //
        // No incoming resource list,.. == no change unless we've previously
        // decided we must update the hardware.
        //

        return PdoExtension->UpdateHardware;
    }

#if DBG

    PciDebugPrintCmResList(PciDbgSetRes, ResourceList);

#endif

    //
    // Produce a new "Current Resources Array" based on the
    // incoming resource list and compare it to the devices
    // current resource list.  First init it to nothing.
    //

    for (count = 0; count < PCI_MAX_RANGE_COUNT; count++) {
        newResources[count].Type = CmResourceTypeNull;
    }

    listCount = ResourceList->Count;
    fullList  = ResourceList->List;

    //
    // In the CM Resource list, IO will have copied the device
    // private (extended) resource that we gave it in the
    // resource requirements list handed in earlier.
    //
    // Find that BAR number.   (Note: It's not there for interrupts).
    //

    while (listCount--) {
        PCM_PARTIAL_RESOURCE_LIST partialList = &fullList->PartialResourceList;
        ULONG                     drainPartial = 0;
        PCM_PARTIAL_RESOURCE_DESCRIPTOR baseResource = NULL;
        CM_PARTIAL_RESOURCE_DESCRIPTOR tempResource;

        count       = partialList->Count;
        nextPartial = partialList->PartialDescriptors;

        while (count--) {

            partial = nextPartial;
            nextPartial = PciNextPartialDescriptor(partial);

            if (drainPartial != 0) {

                //
                // We encountered a device private indicating
                // we should skip some number of descriptors.
                //

                drainPartial--;
                continue;
            }


            switch (partial->Type) {
            case CmResourceTypeInterrupt:

                PCI_ASSERT(interruptResource == NULL); // once only please

                PCI_ASSERT(partial->u.Interrupt.Level ==
                       partial->u.Interrupt.Vector);

                interruptResource = partial;

                //
                // The interrupt line register is only 8 bits wide, but some
                // machines have more than 256 interrupt inputs.  If the interrupt
                // input assigned to the device is small enough to fit in the
                // interrupt line register, write it out.  If the interrupt input
                // assigned to the device is too large, just write 0 to the interrupt
                // line register.
                //
                if (partial->u.Interrupt.Level > 0xFF) {

                    PdoExtension->AdjustedInterruptLine = 0;

                } else {
                    PdoExtension->AdjustedInterruptLine =
                        (UCHAR)partial->u.Interrupt.Level;
                }

                continue;

            case CmResourceTypeMemory:
            case CmResourceTypePort:

                //
                // Is this expected at this time?
                //

                PCI_ASSERT(baseResource == NULL);

                baseResource = partial;
                continue;

            case CmResourceTypeDevicePrivate:

                switch (partial->u.DevicePrivate.Data[0]) {
                case PciPrivateIsaBar:

                    PCI_ASSERT(baseResource != NULL);

                    //
                    // This private resource tells us which BAR
                    // is associated with this base resource AND
                    // modifies the length of the base resource.
                    // It is created in conjunction with the set
                    // of partial resources that make up a larger
                    // resource on a bridge when the bridge's ISA
                    // mode bit is set.
                    //
                    // What's really coming down the pipe is the
                    // set of descriptors that describe the ISA
                    // holes in the range.  These are 0x100 bytes
                    // every 0x400 bytes for the entire range.
                    //
                    // Make a copy of the base resource we have just
                    // seen.  Its starting address is the start of
                    // the entire range.  Adjust its length to the
                    // entire range.
                    //

                    tempResource = *baseResource;

                    //
                    // A little paranoia is sometimes a good thing.
                    // This can only happen on an IO resource which
                    // is the length of an ISA hole, ie 0x100 bytes.
                    //

                    PCI_ASSERT((tempResource.Type == CmResourceTypePort) &&
                           (tempResource.u.Generic.Length == 0x100)
                          );

                    //
                    // Excessive paranoia.
                    //

                    PCI_ASSERT((PdoExtension->BaseClass == PCI_CLASS_BRIDGE_DEV) &&
                           (PdoExtension->Dependent.type1.IsaBitSet == TRUE)
                          );

                    //
                    // Get the new length.
                    //

                    drainPartial = partial->u.DevicePrivate.Data[2];
                    tempResource.u.Generic.Length = drainPartial;

                    //
                    // Skip the remaining descriptors that make up this
                    // range.
                    //

                    drainPartial = (drainPartial / 0x400) - 1;

#if DBG

                    {
                        PCM_PARTIAL_RESOURCE_DESCRIPTOR lastOne;

                        lastOne = baseResource + drainPartial + 1;

                        PCI_ASSERT(lastOne->Type == CmResourceTypePort);
                        PCI_ASSERT(lastOne->u.Generic.Length == 0x100);
                        PCI_ASSERT(lastOne->u.Generic.Start.QuadPart ==
                                (tempResource.u.Generic.Start.QuadPart +
                                 tempResource.u.Generic.Length - 0x400)
                              );
                    }

#endif

                    //
                    // Finally, shift out pointer to our temp (adjusted)
                    // copy of the resource.
                    //

                    baseResource = &tempResource;

                    // fall thru.

                case PciPrivateBar:

                    PCI_ASSERT(baseResource != NULL);

                    //
                    // This private resource tells us which BAR
                    // to is associated with this resource.
                    //

                    bar = partial->u.DevicePrivate.Data[1];

                    //
                    // Copy this descriptor into the new array.
                    //

                    newResources[bar] = *baseResource;

#if DBG

                    baseResource = NULL;

#endif

                    continue;

                case PciPrivateSkipList:

                    PCI_ASSERT(baseResource == NULL);

                    //
                    // The remainder of this list is device
                    // specific stuff we can't change anyway.
                    //

                    drainPartial = partial->u.DevicePrivate.Data[1];
                    PCI_ASSERT(drainPartial); // sanity check
                    continue;
                }
            }
        }
        PCI_ASSERT(baseResource == NULL);

        //
        // Advance to next partial list.
        //

        fullList = (PCM_FULL_RESOURCE_DESCRIPTOR)partial;
    }

    //
    // If we have no I/O or memory resources, then there is no need to look
    // any further.
    //
    if (PdoExtension->Resources == NULL) {
        return FALSE;
    }

    //
    // Ok, we now have a new list of resources in the same order as
    // the "current" set.  See if anything changed.
    //

    partial = newResources;
    oldPartial = PdoExtension->Resources->Current;

#if DBG

    if (PciDebug & PciDbgSetResChange) {

        BOOLEAN dbgConfigurationChanged = FALSE;

        for (count = 0;
             count < PCI_MAX_RANGE_COUNT;
             count++, partial++, oldPartial++) {

            if ((partial->Type != oldPartial->Type) ||
                ((partial->Type != CmResourceTypeNull) &&
                 ((partial->u.Generic.Start.QuadPart !=
                   oldPartial->u.Generic.Start.QuadPart) ||
                  (partial->u.Generic.Length != oldPartial->u.Generic.Length)))) {

                //
                // Devices settings have changed.
                //

                dbgConfigurationChanged = TRUE;

                PciDebugPrint(
                    PciDbgAlways,
                    "PCI - PDO(b=0x%x, d=0x%x, f=0x%x) changing resource settings.\n",
                    PCI_PARENT_FDOX(PdoExtension)->BaseBus,
                    PdoExtension->Slot.u.bits.DeviceNumber,
                    PdoExtension->Slot.u.bits.FunctionNumber
                    );

                break;
            }
        }

        partial = newResources;
        oldPartial = PdoExtension->Resources->Current;

        if (dbgConfigurationChanged == TRUE) {
            PciDebugPrint(
                PciDbgAlways,
                "PCI - SetResources, old state, new state\n"
                );
            for (count = 0; count < PCI_MAX_RANGE_COUNT; count++) {
                PCM_PARTIAL_RESOURCE_DESCRIPTOR old = oldPartial + count;
                PCM_PARTIAL_RESOURCE_DESCRIPTOR new = partial + count;
                if ((old->Type == new->Type) &&
                    (new->Type == CmResourceTypeNull)) {
                    PciDebugPrint(
                        PciDbgAlways,
                        "00 <unused>\n"
                        );
                    continue;
                }
                PciDebugPrint(
                    PciDbgAlways,
                    "%02x %08x%08x %08x    ->    %02x %08x%08x %08x\n",
                    old->Type,
                    old->u.Generic.Start.HighPart,
                    old->u.Generic.Start.LowPart,
                    old->u.Generic.Length,
                    new->Type,
                    new->u.Generic.Start.HighPart,
                    new->u.Generic.Start.LowPart,
                    new->u.Generic.Length
                    );
                PCI_ASSERT((old->Type == new->Type) ||
                       (old->Type == CmResourceTypeNull) ||
                       (new->Type == CmResourceTypeNull));
            }
        }
    }

#endif

    for (count = 0;
         count < PCI_MAX_RANGE_COUNT;
         count++, partial++, oldPartial++) {

        //
        // If the resource type changed, OR, if any of the resources
        // settings changed (this latter only if type != NULL) ...
        //

        if ((partial->Type != oldPartial->Type) ||
            ((partial->Type != CmResourceTypeNull) &&
             ((partial->u.Generic.Start.QuadPart !=
               oldPartial->u.Generic.Start.QuadPart) ||
              (partial->u.Generic.Length != oldPartial->u.Generic.Length)))) {

            //
            // Devices settings have changed.
            //

            configurationChanged = TRUE;

#if DBG

            if (oldPartial->Type != CmResourceTypeNull) {
                PciDebugPrint(PciDbgSetResChange,
                              "      Old range-\n");
                PciDebugPrintPartialResource(PciDbgSetResChange, oldPartial);
            } else {
                PciDebugPrint(PciDbgSetResChange,
                              "      Previously unset range\n");
            }
            PciDebugPrint(PciDbgSetResChange,
                          "      changed to\n");
            PciDebugPrintPartialResource(PciDbgSetResChange, partial);

#endif

            //
            // Copy the new setting into the "current" settings
            // array.   This will then be written to the h/w.
            //

            oldPartial->Type = partial->Type;
            oldPartial->u.Generic = partial->u.Generic;
        }
    }

    return configurationChanged || PdoExtension->UpdateHardware;
}

NTSTATUS
PciSetResources(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN BOOLEAN        PowerOn,
    IN BOOLEAN        StartDeviceIrp
    )
/*++

Routine Description:

    Called to change a devices resource settings to those in the
    incoming list.

Arguments:

    PdoExtension    - Pointer to the PDO Extension for the PDO.
    Change          - TRUE is the resources are to be written.
    PowerOn         - TRUE if the device is having power restored
                      and extraneous config space registers should
                      be restored.  (PowerOn implies Change).
    StartDeviceIrp  - TRUE if this call is the result of a PNP START_DEVICE
                      IRP.

Return Value:

    Returns the status of the operation.

--*/

{
    PCI_COMMON_HEADER commonHeader;
    PPCI_COMMON_CONFIG commonConfig = (PPCI_COMMON_CONFIG)&commonHeader;
    PPCI_FDO_EXTENSION fdoExtension = PCI_PARENT_FDOX(PdoExtension);
    ULONG configType;
#if MSI_SUPPORTED
    PCI_MSI_CAPABILITY msiCapability;
#endif
    //
    // Get the common configuration data.
    //
    // N.B. This is done using RAW access to config space so that
    // (a) no pageable code is used, and
    // (b) the actual contents of the interrupt line register is
    //     returned/written.
    //

    PciGetConfigData(PdoExtension, commonConfig);

    if (!PcipIsSameDevice(PdoExtension, commonConfig)) {
        PCI_ASSERTMSG("PCI Set resources - not same device", 0);
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // If this is a host bridge, bail.  We don't want to touch host bridge
    // config space.  This is a hack and should be fixed.
    //
    if (PdoExtension->BaseClass == PCI_CLASS_BRIDGE_DEV
    &&  PdoExtension->SubClass == PCI_SUBCLASS_BR_HOST) {

        return STATUS_SUCCESS;
    }

    if (PowerOn) {

        //
        // If this is an IDE controller then attempt to switch it to
        // native mode
        //

        if (PdoExtension->BaseClass == PCI_CLASS_MASS_STORAGE_CTLR
        &&  PdoExtension->SubClass == PCI_SUBCLASS_MSC_IDE_CTLR) {
            BOOLEAN native;

            //
            // It is important that once we come back from a low power state
            // and configure the IDE controller, it's in the same mode (native vs.
            // compatible) as it was before it went into the low power state.
            // Otherwise, the device state is completely different.
            //
            native = PciConfigureIdeController(PdoExtension, commonConfig, FALSE);
            PCI_ASSERT(native == PdoExtension->IDEInNativeMode);
        }
    }

    //
    // Get part of the MSI capability structure for supported devices
    //

    //
    // NOTE: This code is UNTESTED due to the unavailability of MSI devices
    //
#if MSI_SUPPORTED

    if(PdoExtension->CapableMSI && PdoExtension->MsiInfo.MessageAddress) {

       //
       // Make sure we have an offset for the Capability structure
       //

       PCI_ASSERT(PdoExtension->MsiInfo.CapabilityOffset);

       //
       // We just need the message control register for configuration purposes
       //

        PciReadDeviceConfig(
            PdoExtension,
            &(msiCapability.MessageControl),
            PdoExtension->MsiInfo.CapabilityOffset +
               FIELD_OFFSET(PCI_MSI_CAPABILITY, MessageControl),
            sizeof(msiCapability.MessageControl)
        );

    }

#endif

    //
    // If this device is marked as needing hot plug configuration and we have a
    // clue of what to do...
    //

    if (PdoExtension->NeedsHotPlugConfiguration && fdoExtension->HotPlugParameters.Acquired) {

        UCHAR readCacheLineSize;
        USHORT newCmdBits = 0;

        //
        // Save away our new latency timer so it gets written out below
        //

        PdoExtension->SavedLatencyTimer = fdoExtension->HotPlugParameters.LatencyTimer;



        PciDebugPrint(
            PciDbgConfigParam,
            "PCI - SetResources, PDOx %x current CacheLineSize is %x, Want %x\n",
            PdoExtension,
            (ULONG)commonConfig->CacheLineSize,
            (ULONG)fdoExtension->HotPlugParameters.CacheLineSize
            );

        //
        // Write out out suggested cache line size
        //

        PciWriteDeviceConfig(
            PdoExtension,
            &fdoExtension->HotPlugParameters.CacheLineSize,
            FIELD_OFFSET(PCI_COMMON_CONFIG, CacheLineSize),
            sizeof(fdoExtension->HotPlugParameters.CacheLineSize)
            );

        //
        // Check if the cache line size stuck which means the hardware liked it
        //

        PciReadDeviceConfig(
            PdoExtension,
            &readCacheLineSize,
            FIELD_OFFSET(PCI_COMMON_CONFIG, CacheLineSize),
            sizeof(readCacheLineSize)
            );

        PciDebugPrint(
            PciDbgConfigParam,
            "PCI - SetResources, PDOx %x After write, CacheLineSize %x\n",
            PdoExtension,
            (ULONG)readCacheLineSize
            );

        if ((readCacheLineSize == fdoExtension->HotPlugParameters.CacheLineSize) &&
            (readCacheLineSize != 0)) {

            PciDebugPrint(
                PciDbgConfigParam,
                "PCI - SetResources, PDOx %x cache line size stuck, set MWI\n",
                PdoExtension
                );

            //
            // First stash this so that when we power manage the device we set
            // it back correctly and that we want to set MWI...
            //

            PdoExtension->SavedCacheLineSize = fdoExtension->HotPlugParameters.CacheLineSize;
            newCmdBits |= PCI_ENABLE_WRITE_AND_INVALIDATE;

            //
            // ISSUE-3/16/2000-andrewth
            // If we get our PDO blown away (ie removed parent) then we forget that we need to
            // set MWI...
            //

        } else {
            PciDebugPrint(
                PciDbgConfigParam,
                "PCI - SetResources, PDOx %x cache line size non-sticky\n",
                PdoExtension
                );
        }

        //
        // Now deal with SERR and PERR - abandon hope all ye who set these bits on
        // flaky PC hardware...
        //

        if (fdoExtension->HotPlugParameters.EnableSERR) {
            newCmdBits |= PCI_ENABLE_SERR;
        }

        if (fdoExtension->HotPlugParameters.EnablePERR) {
            newCmdBits |= PCI_ENABLE_PARITY;
        }

        //
        // Update the command enables so we write this out correctly after a PM op
        //

        PdoExtension->CommandEnables |= newCmdBits;

    }

    //
    // Write the resources out to the hardware...
    //

    configType = PciGetConfigurationType(commonConfig);

    //
    // Call the device type dependent routine to set the new
    // configuration.
    //

    PciConfigurators[configType].ChangeResourceSettings(
        PdoExtension,
        commonConfig
        );

    //
    // If we explicitly wanted the hardware updated (UpdateHardware flag)
    // this its done now...
    //

    PdoExtension->UpdateHardware = FALSE;

    if (PowerOn) {

        PciConfigurators[configType].ResetDevice(
            PdoExtension,
            commonConfig
            );

        //
        // Restore InterruptLine register too. (InterruptLine is
        // at same offset for header type 0, 1 and 2).
        //

        commonConfig->u.type0.InterruptLine =
                PdoExtension->RawInterruptLine;
    }

    //
    // Restore Maximum Latency and Cache Line Size.
    //

#if DBG

    if (commonConfig->LatencyTimer != PdoExtension->SavedLatencyTimer) {
        PciDebugPrint(
            PciDbgConfigParam,
            "PCI (pdox %08x) changing latency from %02x to %02x.\n",
            PdoExtension,
            commonConfig->LatencyTimer,
            PdoExtension->SavedLatencyTimer
            );
    }

    if (commonConfig->CacheLineSize != PdoExtension->SavedCacheLineSize) {
        PciDebugPrint(
            PciDbgConfigParam,
            "PCI (pdox %08x) changing cache line size from %02x to %02x.\n",
            PdoExtension,
            commonConfig->CacheLineSize,
            PdoExtension->SavedCacheLineSize
            );
    }

#endif

    //
    // Restore random registers
    //

    commonConfig->LatencyTimer = PdoExtension->SavedLatencyTimer;
    commonConfig->CacheLineSize  = PdoExtension->SavedCacheLineSize;
    commonConfig->u.type0.InterruptLine = PdoExtension->RawInterruptLine;

    //
    // Call out and apply any hacks necessary
    //

    PciApplyHacks(
        PCI_PARENT_FDOX(PdoExtension),
        commonConfig,
        PdoExtension->Slot,
        EnumStartDevice,
        PdoExtension
        );

#if MSI_SUPPORTED

    //
    // Program MSI devices with their new message interrupt resources
    //
    // NOTE: This code is UNTESTED due to the unavailability of MSI devices
    //

    if (PdoExtension->CapableMSI && PdoExtension->MsiInfo.MessageAddress) {

        PciDebugPrint(
            PciDbgInformative,
            "PCI: Device %08x being reprogrammed for MSI.\n",
            PdoExtension->PhysicalDeviceObject
            );

        //
        // Set the proper resources in the MSI capability structure
        // and write them to Hardware.
        //
        // Message Address
        //
        PCI_ASSERT(PdoExtension->MsiInfo.MessageAddress);
        msiCapability.MessageAddress.Raw = PdoExtension->MsiInfo.MessageAddress;

        //
        // Must be DWORD aligned address
        //
        PCI_ASSERT(msiCapability.MessageAddress.Register.Reserved == 0);

        //
        // Message Upper Address
        //

        if(msiCapability.MessageControl.CapableOf64Bits) {

            // All the APICs we know live below 4GB so their upper address component
            // is always 0.
            msiCapability.Data.Bit64.MessageUpperAddress = 0;

            //
            // Message Data
            //
            msiCapability.Data.Bit64.MessageData = PdoExtension->MsiInfo.MessageData;

        } else {

            //
            // Message Data
            //
            msiCapability.Data.Bit32.MessageData = PdoExtension->MsiInfo.MessageData;
        }

        // # of Messages granted
        //
        // We have the arbiter allocate only 1 interrupt for us, so we
        // are allocating just 1 message.
        //
        msiCapability.MessageControl.MultipleMessageEnable = 1;

        //
        // Enable bit
        //
        msiCapability.MessageControl.MSIEnable = 1;

        //
        // Copy the MSI capability into the buffer that will be written into
        // hardware below.
        //
        RtlCopyMemory((PUCHAR)commonConfig+PdoExtension->MsiInfo.CapabilityOffset,
                      &msiCapability,
                      sizeof(msiCapability)
                      );
    }

#endif // MSI_SUPPORTED


    //
    // Write it out to the hardware
    //
    PciUpdateHardware(PdoExtension, commonConfig);

    //
    // Update our concept of the RawInterruptLine (either as read from
    // the h/w or restored by us).  Note: InterruptLine is at the same
    // offset for types 0, 1 and 2 PCI config space headers.
    //

    PdoExtension->RawInterruptLine = commonConfig->u.type0.InterruptLine;


    //
    // If it needed configuration its done by now!
    //

    PdoExtension->NeedsHotPlugConfiguration = FALSE;

    return STATUS_SUCCESS;
}

VOID
PciUpdateHardware(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG Config
    )
/*++

Routine Description:

    This routine updates the given device's config space header
    with the given buffer.

    If this is a critical device (one that cannot be safely
    turned off to update the hardware), call the worker routine
    in the context of KeIpiGenericCall, which brings all processors
    into step, guaranteeing that nothing else will run on
    the system while we're updating the hardware.

Arguments:

    PdoExtension - device extension for the PCI PDO representing the
        device to be updated

    Config - the common config header to update the device with.

Return Value:

    VOID

--*/
{
    PCI_CRITICAL_ROUTINE_CONTEXT routineContext;

    // NB Not paged because it can be called during a power operation,
    //    which can occur at DISPATCH_LEVEL

    if (PdoExtension->HackFlags & PCI_HACK_CRITICAL_DEVICE) {

        routineContext.Gate = 1;
        routineContext.Barrier = 1;
        routineContext.Routine = PcipUpdateHardware;
        routineContext.Extension = PdoExtension;
        routineContext.Context = Config;
        KeIpiGenericCall(PciExecuteCriticalSystemRoutine,
                         (ULONG_PTR)&routineContext
                         );
    } else {

        PcipUpdateHardware(PdoExtension,
                           Config
                           );
    }
}

VOID
PcipUpdateHardware(
    IN PVOID Extension,
    IN PPCI_COMMON_CONFIG CommonConfig
    )
/*++

Routine Description:

    This routine updates the given device's config space header
    with the given buffer.

    If this is a critical device (one that cannot be safely
    turned off to update the hardware), this routine will have
    been called in the context of KeIpiGenericCall, which calls
    it at IPI_LEVEL.  Because of this, no asserts, debug prints,
    or other debugging may be used in this routine, or else it
    will hang an MP machine.

Arguments:

    Extension - device extension for the PCI PDO representing the
        device to be updated

    CommonConfig - the common config header to update the device with.

Return Value:

    VOID

--*/
{
    PPCI_PDO_EXTENSION pdoExtension = (PPCI_PDO_EXTENSION)Extension;

    //
    // Restore the command register we remember in the power down case
    //
    CommonConfig->Command = pdoExtension->CommandEnables;

    //
    // Disable the device while we write the rest of its config
    // space.  Also, don't write any non-zero value to it's status
    // register.
    //
    if ((pdoExtension->HackFlags & PCI_HACK_PRESERVE_COMMAND) == 0) {
        CommonConfig->Command &= ~(PCI_ENABLE_IO_SPACE |
                                  PCI_ENABLE_MEMORY_SPACE |
                                  PCI_ENABLE_BUS_MASTER |
                                  PCI_ENABLE_WRITE_AND_INVALIDATE);
    }
    CommonConfig->Status = 0;

    //
    // This function writes the entire config header out to the hardware,
    // one dword at a time.  This means that the top of the config header
    // is written out before the bottom, meaning that the command register
    // is written before any other writeable register.  Thus, the first
    // thing that this routine does is to disable the I/O,memory, and bus
    // master enable bits, making the rest of the config writes occur
    // with the device disabled.
    //
    PciSetConfigData(pdoExtension, CommonConfig);

#if MSI_SUPPORTED
    if (pdoExtension->CapableMSI && pdoExtension->MsiInfo.MessageAddress) {
        PciWriteDeviceConfig(
               pdoExtension,
               (PUCHAR)CommonConfig + pdoExtension->MsiInfo.CapabilityOffset,
               pdoExtension->MsiInfo.CapabilityOffset,
               sizeof(PCI_MSI_CAPABILITY)
               );
    }

#endif

    //
    // New values written to config space, now re-enable the
    // device (as indicated in the CommandEnables)
    //
    PciDecodeEnable(pdoExtension, TRUE, &pdoExtension->CommandEnables);

    return;
}


VOID
PciGetEnhancedCapabilities(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG Config
)
/*++

Routine Description:

    This routine sets the appropriate fields in the Pdo extension relating
    to capabilities and power. If no power management registers are available
    the power state is based off of the decode fields. PCI bus reset code
    depends on this, and to prevent excessive resets this routine should only
    be called immediately after a new PDO is created.

    NOTE:
    We should rename this function to something with GetInitialState in the
    title and so it can't be confused with IRP_MN_QUERY_CAPABILITIES.

Arguments:

    PdoExtension    - Pointer to the PDO Extension for the PDO.
    Config          - Pointer to the common portion of the config space.

Return Value:

    None.

--*/
{
    UCHAR capPtr = 0;
    PCI_CAPABILITIES_HEADER header;
    UCHAR agpCapPtr;
    UCHAR capId;
#if MSI_SUPPORTED
    PCI_MSI_CAPABILITY msi;
    UCHAR msicapptr;
#endif

    PAGED_CODE();

    //
    // If this function supports a capabilities list, record the
    // capabilities pointer.
    //

    PdoExtension->PowerState.DeviceWakeLevel = PowerDeviceUnspecified;

    if (!(Config->Status & PCI_STATUS_CAPABILITIES_LIST)) {

        //
        // If we don't have a capability bit we can't do MSI or Power management
        //

        PdoExtension->HackFlags |= PCI_HACK_NO_PM_CAPS;
        PdoExtension->CapabilitiesPtr = 0;
#if MSI_SUPPORTED
        PdoExtension->CapableMSI = FALSE;
#endif
        goto PciGetCapabilitiesExit;
    }

    switch (PciGetConfigurationType(Config)) {
    case PCI_DEVICE_TYPE:
        capPtr = Config->u.type0.CapabilitiesPtr;
        break;
    case PCI_BRIDGE_TYPE:
        capPtr = Config->u.type1.CapabilitiesPtr;
        break;
    case PCI_CARDBUS_BRIDGE_TYPE:
        capPtr = Config->u.type2.CapabilitiesPtr;
        break;
    }

    //
    // Capabilities pointers are a new feature so we verify a
    // little that the h/w folks built the right thing. Must
    // be a DWORD offset, must not point into common header.
    // (Zero is allowable, means not used).
    //

    if (capPtr) {
        if (((capPtr & 0x3) == 0) && (capPtr >= PCI_COMMON_HDR_LENGTH)) {
            PdoExtension->CapabilitiesPtr = capPtr;
        } else {
            PCI_ASSERT(((capPtr & 0x3) == 0) && (capPtr >= PCI_COMMON_HDR_LENGTH));
        }
    }

#if MSI_SUPPORTED

    //
    // Search for the MSI capability structure
    // Just get the structure header since we don't look at the structure here.
    //

    msicapptr = PciReadDeviceCapability(
                    PdoExtension,
                    PdoExtension->CapabilitiesPtr,
                    PCI_CAPABILITY_ID_MSI,
                    &msi,
                    sizeof(PCI_CAPABILITIES_HEADER)
                    );

    if (msicapptr != 0) {

        PciDebugPrint(PciDbgInformative,"PCI: MSI Capability Found for device %p\n",
                      PdoExtension->PhysicalDeviceObject);

        //
        // Cache the capability address in the PDO extension
        // and initialize MSI routing info.
        //

        PdoExtension->MsiInfo.CapabilityOffset = msicapptr;
        PdoExtension->MsiInfo.MessageAddress = 0;
        PdoExtension->MsiInfo.MessageData = 0;

        //
        // Mark this PDO as capable of MSI.
        //

        PdoExtension->CapableMSI = TRUE;
    }

#endif // MSI_SUPPORTED

    //
    // For PCI-PCI and host bridges, look for the AGP capability so
    // that we know which bridge is the AGP target, so
    // we can support the AGP target interface
    //
    if ((PdoExtension->BaseClass == PCI_CLASS_BRIDGE_DEV) &&
        ((PdoExtension->SubClass == PCI_SUBCLASS_BR_PCI_TO_PCI) ||
         (PdoExtension->SubClass == PCI_SUBCLASS_BR_HOST))) {

        //
        // PCI-PCI bridges use the AGP_TARGET capability ID.  Host
        // bridges use the AGP capability ID.
        //
        if (PdoExtension->SubClass == PCI_SUBCLASS_BR_PCI_TO_PCI) {
            
            capId = PCI_CAPABILITY_ID_AGP_TARGET;
        
        } else {
            
            capId = PCI_CAPABILITY_ID_AGP;
        }

        agpCapPtr = PciReadDeviceCapability(
                        PdoExtension,
                        PdoExtension->CapabilitiesPtr,
                        capId,
                        &header,
                        sizeof(PCI_CAPABILITIES_HEADER)
                        );

        if (agpCapPtr != 0) {
            
            PdoExtension->TargetAgpCapabilityId = capId;
        }
    }        

    //
    // See if the device is Power Management capable.
    //

    if (!(PdoExtension->HackFlags & PCI_HACK_NO_PM_CAPS)) {

        PCI_PM_CAPABILITY pm;
        UCHAR pmcapptr;

        pmcapptr = PciReadDeviceCapability(
                        PdoExtension,
                        PdoExtension->CapabilitiesPtr,
                        PCI_CAPABILITY_ID_POWER_MANAGEMENT,
                        &pm,
                        sizeof(pm)
                        );

        if (pmcapptr != 0) {

            //
            // Found a PM capability structure.
            //
            // Select "most powered off state" this device can
            // issue a PME from.
            //

            DEVICE_POWER_STATE ds = PowerDeviceUnspecified;

            if (pm.PMC.Capabilities.Support.PMED0    ) ds = PowerDeviceD0;
            if (pm.PMC.Capabilities.Support.PMED1    ) ds = PowerDeviceD1;
            if (pm.PMC.Capabilities.Support.PMED2    ) ds = PowerDeviceD2;
            if (pm.PMC.Capabilities.Support.PMED3Hot ) ds = PowerDeviceD3;
            if (pm.PMC.Capabilities.Support.PMED3Cold) ds = PowerDeviceD3;

            PdoExtension->PowerState.DeviceWakeLevel = ds;

            //
            // Record the current power state.
            // Note: D0 = 0, thru D3 = 3, convert to
            // PowerDeviceD0 thru PowerDeviceD3.  It's
            // only a two bit field (in h/w) so no other
            // values are possible.
            //

            PdoExtension->PowerState.CurrentDeviceState =
                pm.PMCSR.ControlStatus.PowerState +
                PowerDeviceD0;

            //
            // Remember the power capabilities
            //

            PdoExtension->PowerCapabilities = pm.PMC.Capabilities;

        } else {

            //
            // Device has capabilities but not Power
            // Management capabilities.  Cheat a little
            // by pretending the registry flag is set
            // that says this.  (This speeds saves us
            // hunting through the h/w next time we
            // want to look at the PM caps).
            //

            PdoExtension->HackFlags |= PCI_HACK_NO_PM_CAPS;
        }
    }

PciGetCapabilitiesExit:
    if (PdoExtension->HackFlags & PCI_HACK_NO_PM_CAPS) {

        //
        // In this case we only support D0 and D3. D3 is defined as decodes
        // off.
        //
        if ((Config->Command & (PCI_ENABLE_IO_SPACE |
                                PCI_ENABLE_MEMORY_SPACE |
                                PCI_ENABLE_BUS_MASTER)) != 0) {

            PdoExtension->PowerState.CurrentDeviceState = PowerDeviceD0;

        } else {

            PdoExtension->PowerState.CurrentDeviceState = PowerDeviceD3;
        }
    }
}


NTSTATUS
PciScanHibernatedBus(
    IN PPCI_FDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    Scan the bus (detailed in FdoExtension) for any new PCI devices
    that were not there when we hibernated and turn them off if doing so seems
    like a good idea.

Arguments:

    FdoExtension - Our extension for the PCI bus functional device object.

Return Value:

    NT status.

--*/

{
    PCI_COMMON_HEADER commonHeader;
    PPCI_COMMON_CONFIG commonConfig = (PPCI_COMMON_CONFIG)&commonHeader;
    PPCI_PDO_EXTENSION pdoExtension;
    PCI_SLOT_NUMBER slot;
    ULONG deviceNumber;
    ULONG functionNumber;
    USHORT SubVendorID, SubSystemID;
    BOOLEAN isRoot;
    ULONGLONG hackFlags;
    ULONG maximumDevices;
    BOOLEAN newDevices = FALSE;

    PciDebugPrint(PciDbgPrattling,
                  "PCI Scan Bus: FDO Extension @ 0x%x, Base Bus = 0x%x\n",
                  FdoExtension,
                  FdoExtension->BaseBus);

    isRoot = PCI_IS_ROOT_FDO(FdoExtension);

    //
    // Examine each possible device on this bus.
    //

    maximumDevices = PCI_MAX_DEVICES;
    if (!isRoot) {

        //
        // Examine the PDO extension for the bridge device and see
        // if it's broken.
        //

        pdoExtension = (PPCI_PDO_EXTENSION)
                       FdoExtension->PhysicalDeviceObject->DeviceExtension;

        ASSERT_PCI_PDO_EXTENSION(pdoExtension);

        if (pdoExtension->HackFlags & PCI_HACK_ONE_CHILD) {
            maximumDevices = 1;
        }
    }

    slot.u.AsULONG = 0;

    for (deviceNumber = 0;
         deviceNumber < maximumDevices;
         deviceNumber++) {

        slot.u.bits.DeviceNumber = deviceNumber;

        //
        // Examine each possible function on this device.
        // N.B. Early out if function 0 not present.
        //

        for (functionNumber = 0;
             functionNumber < PCI_MAX_FUNCTION;
             functionNumber++) {

            slot.u.bits.FunctionNumber = functionNumber;

            PciReadSlotConfig(FdoExtension,
                              slot,
                              commonConfig,
                              0,
                              sizeof(commonConfig->VendorID)
                              );


            if (commonConfig->VendorID == 0xFFFF ||
                commonConfig->VendorID == 0) {

                if (functionNumber == 0) {

                    //
                    // Didn't get any data on function zero of this
                    // device, no point in checking other functions.
                    //

                    break;

                } else {

                    //
                    // Check next function.
                    //

                    continue;

                }
            }

            //
            // We have a device so get the rest of its config space
            //

            PciReadSlotConfig(FdoExtension,
                              slot,
                              &commonConfig->DeviceID,
                              FIELD_OFFSET(PCI_COMMON_CONFIG, DeviceID),
                              sizeof(PCI_COMMON_HEADER)
                                - sizeof(commonConfig->VendorID)
                              );

            //
            // Munge the config space if necessary
            //

            PciApplyHacks(FdoExtension,
                          commonConfig,
                          slot,
                          EnumHackConfigSpace,
                          NULL
                          );


            if ((PciGetConfigurationType(commonConfig) == PCI_DEVICE_TYPE) &&
                (commonConfig->BaseClass != PCI_CLASS_BRIDGE_DEV)) {
                SubVendorID = commonConfig->u.type0.SubVendorID;
                SubSystemID = commonConfig->u.type0.SubSystemID;
            } else {
                SubVendorID = 0;
                SubSystemID = 0;
            }

            hackFlags = PciGetHackFlags(commonConfig->VendorID,
                                        commonConfig->DeviceID,
                                        SubVendorID,
                                        SubSystemID,
                                        commonConfig->RevisionID
                                        );

            if (PciSkipThisFunction(commonConfig,
                                    slot,
                                    EnumBusScan,
                                    hackFlags)) {
                //
                // Skip this function
                //

                continue;
            }


            //
            // In case we are rescanning the bus, check to see if
            // a PDO for this device already exists as a child of
            // the FDO.
            //

            pdoExtension = PciFindPdoByFunction(
                               FdoExtension,
                               slot,
                               commonConfig);

            if (pdoExtension == NULL) {

                newDevices = TRUE;

                //
                // This is a new device disable it if we can
                //

                if (PciCanDisableDecodes(NULL, commonConfig, hackFlags, 0)) {

                    commonConfig->Command &= ~(PCI_ENABLE_IO_SPACE |
                                               PCI_ENABLE_MEMORY_SPACE |
                                               PCI_ENABLE_BUS_MASTER);

                    PciWriteSlotConfig(FdoExtension,
                                       slot,
                                       &commonConfig->Command,
                                       FIELD_OFFSET(PCI_COMMON_CONFIG, Command),
                                       sizeof(commonConfig->Command)
                                       );
                }

            } else {

                //
                // We already know about this device so leave well alone!
                //

            }

            if ( (functionNumber == 0) &&
                !PCI_MULTIFUNCTION_DEVICE(commonConfig) ) {

                //
                // Not a multifunction adapter, skip other functions on
                // this device.
                //

                break;
            }
        }       // function loop
    }           // device loop

    //
    // Tell pnp we found some new devices
    //

    if (newDevices) {
        IoInvalidateDeviceRelations(FdoExtension->PhysicalDeviceObject, BusRelations);
    }

    return STATUS_SUCCESS;

}


BOOLEAN
PciConfigureIdeController(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN OUT PPCI_COMMON_CONFIG Config,
    IN BOOLEAN TurnOffAllNative
    )
/*++

Routine Description:

    If this is an IDE contoller that can be switched to native mode
    and its not already there, we change the programming interface
    (yes PCI 2.x does say its read only) and check if it sticks.

    Assuming all went well we update the Config to reflect the change.

Arguments:

    PdoExtension - PDO for the IDE controller to be switched

    Config - Config header for said device

    TurnOffAllNative - If TRUE indicates that we are calling this from
                       the initial bus scan and so we should turn
                       thid native capable IDE controllers.  If
                       FALSE we should turn off only if the we have
                       accessed the PCI_NATIVE_IDE_INTERFACE.

Return Value:

    TRUE if the result is that the controller ends up in native mode
    FALSE otherwise

Note:

    We support three styles of PCI IDE controller:
         - Compatible mode controllers that consume 2 ISA interrupts
           and decode fixed legacy resources, together with an optional
           relocateable bus master register
         - Native mode controller which uses all 5 bars and the PCI
           interrupt for both channels
         - Controllers which can be switched between modes.
    We do NOT support running one channel in native mode and one in
    compatible mode.

--*/


{

    BOOLEAN primaryChangeable, secondaryChangeable, primaryNative, secondaryNative;
    BOOLEAN native = FALSE;
    UCHAR progIf, tempProgIf;
    USHORT command;

    primaryChangeable = BITS_SET(Config->ProgIf, PCI_IDE_PRIMARY_MODE_CHANGEABLE);
    secondaryChangeable = BITS_SET(Config->ProgIf, PCI_IDE_SECONDARY_MODE_CHANGEABLE);
    primaryNative = BITS_SET(Config->ProgIf, PCI_IDE_PRIMARY_NATIVE_MODE);
    secondaryNative = BITS_SET(Config->ProgIf, PCI_IDE_SECONDARY_NATIVE_MODE);

    //
    // Don't touch controllers we don't support - leave ATAPI to deal with it!
    //

    if ((primaryNative != secondaryNative)
    ||  (primaryChangeable != secondaryChangeable)) {

        PciDebugPrint(PciDbgInformative,
                      "PCI: Warning unsupported IDE controller configuration for VEN_%04x&DEV_%04x!",
                      PdoExtension->VendorId,
                      PdoExtension->DeviceId
                      );

        return FALSE;

    } else if (primaryNative && secondaryNative
           && (TurnOffAllNative || PdoExtension->IoSpaceUnderNativeIdeControl)) {

        //
        // For a fully native mode controller turn off the IO decode.
        // In recent controllers MSFT has requested that this prevent
        // the PCI interrupt from being asserted to close a race condition
        // that can occur if an IDE device interrupts before the IDE driver
        // has been loaded on the PCI device.  This is not a issue for
        // compatible mode controllers because they use edge triggered
        // interrupts that can be dismissed as spurious at the interrupt
        // controller, unlike the shared, level triggered,  PCI interrups
        // of native mode.
        //
        // Once loaded and having connected its interrupt the IDE driver
        // will renable IO space access.
        //
        // We only do this during the initial bus scan or if the IDE driver
        // has requested it through the PCI_NATIVE_IDE_INTERFACE.  This is
        // to avoid not enabling IoSpace for 3rd party native IDE controllers
        // with their own drivers.
        //

        PciGetCommandRegister(PdoExtension, &command);
        command &= ~PCI_ENABLE_IO_SPACE;
        PciSetCommandRegister(PdoExtension, command);
        Config->Command = command;

        native = TRUE;

    } else if (primaryChangeable && secondaryChangeable
           &&  (PdoExtension->BIOSAllowsIDESwitchToNativeMode
           &&  !(PdoExtension->HackFlags & PCI_HACK_BAD_NATIVE_IDE))) {

        //
        // If we aren't already in native mode, the controller can change modes
        // and the bios is ammenable then do so...
        //

        PciDecodeEnable(PdoExtension, FALSE, NULL);
        PciGetCommandRegister(PdoExtension, &Config->Command);

        progIf = Config->ProgIf | (PCI_IDE_PRIMARY_NATIVE_MODE
                                   | PCI_IDE_SECONDARY_NATIVE_MODE);

        PciWriteDeviceConfig(PdoExtension,
                             &progIf,
                             FIELD_OFFSET(PCI_COMMON_CONFIG, ProgIf),
                             sizeof(progIf)
                             );
        //
        // Check if it stuck
        //
        PciReadDeviceConfig(PdoExtension,
                            &tempProgIf,
                            FIELD_OFFSET(PCI_COMMON_CONFIG, ProgIf),
                            sizeof(tempProgIf)
                            );

        if (tempProgIf == progIf) {
            //
            // If it stuck, remember we did this
            //
            Config->ProgIf = progIf;
            PdoExtension->ProgIf = progIf;
            native = TRUE;

            //
            // Zero the first 4 bars in the config space because they might have
            // bogus values in them...
            //

            RtlZeroMemory(Config->u.type0.BaseAddresses,
                          4 * sizeof(Config->u.type0.BaseAddresses[0]));

            PciWriteDeviceConfig(PdoExtension,
                                 &Config->u.type0.BaseAddresses,
                                 FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.BaseAddresses),
                                 4 * sizeof(Config->u.type0.BaseAddresses[0])
                                 );

            //
            // Read back what stuck into the config which we are going to generate
            // requirements from
            //

            PciReadDeviceConfig(PdoExtension,
                                &Config->u.type0.BaseAddresses,
                                FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.BaseAddresses),
                                4 * sizeof(Config->u.type0.BaseAddresses[0])
                                );

            PciReadDeviceConfig(PdoExtension,
                                &Config->u.type0.InterruptPin,
                                FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.InterruptPin),
                                sizeof(Config->u.type0.InterruptPin)
                                );
        } else {

            PciDebugPrint(PciDbgInformative,
                          "PCI: Warning failed switch to native mode for IDE controller VEN_%04x&DEV_%04x!",
                          Config->VendorID,
                          Config->DeviceID
                          );
        }
    }

    return native;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\dispatch.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module contains all of the data variables that are used for
    dispatching IRPs in the PCI Driver. The major Irp tables might
    be assigned as follows:

                                   +-- PCI Bus ---------IRP--+
                                   | FDO: PciFdoDispatchTable |
                                   | PDO:                     |
                                   +--------------------------+

                        +-- PCI Bus ---------IRP--+
                        | FDO: PciFdoDispatchTable |
                        | PDO: PciPdoDispatchTable |
                        +--------------------------+

 +-- PCI Device -----------IRP--+  +-- Cardbus Device -------IRP--+
 | FDO:                          |  | FDO:                          |
 | PDO: PciPdoDispatchTable      |  | PDO:                          |
 +-------------------------------+  +-------------------------------+


Author:

    Peter Johnston (peterj) 20-Nov-1996

Revision History:

Environment:

    NT Kernel Model Driver only

--*/

#include "pcip.h"

VOID
PciDispatchInvalidObject(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PUCHAR MajorString
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PciDispatchInvalidObject)
#pragma alloc_text(PAGE, PciCallDownIrpStack)
#endif

#if DBG

BOOLEAN
PciDebugIrpDispatchDisplay(
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension,
    IN ULONG                 MinorTableMax
    );

ULONG PciBreakOnPdoPnpIrp = 0;
ULONG PciBreakOnFdoPnpIrp = 0;
ULONG PciBreakOnPdoPowerIrp = 0;
ULONG PciBreakOnFdoPowerIrp = 0;

#endif


NTSTATUS
PciDispatchIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION        irpSp;
    PPCI_COMMON_EXTENSION     deviceExtension;
    PPCI_MJ_DISPATCH_TABLE    dispatchTable;
    PPCI_MN_DISPATCH_TABLE    minorTable;
    ULONG                     minorTableMax;
    PPCI_MN_DISPATCH_TABLE    irpDispatchTableEntry;
    PCI_MN_DISPATCH_FUNCTION  irpDispatchHandler;
    NTSTATUS                  status;
    PCI_DISPATCH_STYLE        irpDispatchStyle;
    BOOLEAN                   passDown;

    //
    // Get the Irp stack pointer
    //
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // And our device extension
    //
    deviceExtension = ((PPCI_COMMON_EXTENSION)(DeviceObject->DeviceExtension));

    //
    // In checked, assert things aren't screwey.
    //
    PCI_ASSERT((deviceExtension->ExtensionType == PCI_EXTENSIONTYPE_PDO)||
           (deviceExtension->ExtensionType == PCI_EXTENSIONTYPE_FDO));

    if (deviceExtension->DeviceState == PciDeleted) {

        //
        // We should not be getting IRPs. Fail the invalid request.
        //
        status = STATUS_NO_SUCH_DEVICE;
        passDown = FALSE;
        goto FinishUpIrp;
    }

    //
    // Get the correct IRP handler.
    //
    dispatchTable = deviceExtension->IrpDispatchTable;

    switch(irpSp->MajorFunction) {

        case IRP_MJ_PNP:

            minorTable    = dispatchTable->PnpIrpDispatchTable;
            minorTableMax = dispatchTable->PnpIrpMaximumMinorFunction;
            break;

        case IRP_MJ_POWER:

            minorTable    = dispatchTable->PowerIrpDispatchTable;
            minorTableMax = dispatchTable->PowerIrpMaximumMinorFunction;
            break;

        case IRP_MJ_SYSTEM_CONTROL:
            
             irpDispatchHandler = dispatchTable->SystemControlIrpDispatchFunction;
             irpDispatchStyle = dispatchTable->SystemControlIrpDispatchStyle;
             minorTableMax = (ULONG) -1; // Always "handled"
             goto CallDispatchHandler;

        default:

            irpDispatchHandler = dispatchTable->OtherIrpDispatchFunction;
            irpDispatchStyle = dispatchTable->OtherIrpDispatchStyle;
            minorTableMax = (ULONG) -1; // Always "handled"
            goto CallDispatchHandler;
    }

    //
    // Grab the appropriate dispatch handler from the table. The last chance
    // handler is always at the end of the table so that the normal code path
    // is fast. Grab the dispatch style too.
    //
    irpDispatchTableEntry = (irpSp->MinorFunction <= minorTableMax) ?
        minorTable+irpSp->MinorFunction :
        minorTable+minorTableMax+1;

    irpDispatchStyle   = irpDispatchTableEntry->DispatchStyle;
    irpDispatchHandler = irpDispatchTableEntry->DispatchFunction;

CallDispatchHandler:

#if DBG
    if (PciDebugIrpDispatchDisplay(irpSp, deviceExtension, minorTableMax)) {
        DbgBreakPoint();
    }
#endif

    //
    // For now, if handlers want to see the IRP after completion, pass it down
    // synchronously. Later we can get more fancy.
    //
    if (irpDispatchStyle == IRP_UPWARD) {

        PciCallDownIrpStack(deviceExtension, Irp);
    }

    //
    // Call the handler
    //
    status = (irpDispatchHandler)(Irp, irpSp, deviceExtension);

    //
    // Post-op. Update IRP status and send Irp along it's way iff appropriate.
    //
    switch(irpDispatchStyle) {

        //
        // For this style, the IRP is being handled entirely our handler. Touch
        // nothing.
        //
        case IRP_DISPATCH:
            return status;

        //
        // For this style, the IRP status will be appropriately updated iff
        // status != STATUS_NOT_SUPPORTED. The IRP will be completed or
        // passed down appropriately.
        //
        case IRP_DOWNWARD:
            passDown = TRUE;
            break;

        //
        // For this style, the IRP will be completed and have it's status
        // appropriately updated iff status != STATUS_NOT_SUPPORTED
        //
        case IRP_COMPLETE:
            passDown = FALSE;
            break;

        //
        // For this style, the IRP status will be appropriately updated iff
        // status != STATUS_NOT_SUPPORTED. The IRP has already been sent down,
        // and must be completed.
        //
        case IRP_UPWARD:
            passDown = FALSE;
            break;

        default:
            PCI_ASSERT(0);
            passDown = FALSE;
            break;
    }

    //
    // STATUS_NOT_SUPPORTED is the only illegal failure code. So if one of our
    // table handlers returns this, it means the dispatch handler does not know
    // what to do with the IRP. In that case, we must leave the status
    // untouched, otherwise we update it. In both cases, return the correct
    // status value.
    //
    if (status == STATUS_PENDING) {

        return status;

    }

FinishUpIrp:

    if (status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = status;
    }

    if (passDown && (NT_SUCCESS(status) || (status == STATUS_NOT_SUPPORTED))) {

        return PciPassIrpFromFdoToPdo(deviceExtension, Irp);
    }

    //
    // Read back status to return
    //
    status = Irp->IoStatus.Status;

    //
    // Power IRPs need just a little more help...
    //
    if (irpSp->MajorFunction == IRP_MJ_POWER) {

        //
        // Start the next power irp
        //
        PoStartNextPowerIrp(Irp);
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS
PciSetEventCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )
/*++

Routine Description:

    This routine is used as a completion routine when an IRP is passed
    down the stack but more processing must be done on the way back up.
    The effect of using this as a completion routine is that the IRP
    will not be destroyed in IoCompleteRequest as called by the lower
    level object.  The event which is a KEVENT is signaled to allow
    processing to continue

Arguments:

    DeviceObject - Supplies the device object

    Irp - The IRP we are processing

    Event - Supplies the event to be signaled

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
            PCI_ASSERT(Event);

    //
    // This can be called at DISPATCH_LEVEL so must not be paged
    //

    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
PciPassIrpFromFdoToPdo(
    PPCI_COMMON_EXTENSION  DeviceExtension,
    PIRP                   Irp
    )

/*++

Description:

    Given an FDO, pass the IRP to the next device object in the
    device stack.  This is the PDO if there are no lower level
    filters.

    Note: This routine is used only if we do not expect to do
    any further processing on this IRP at this level.

    Note: For Power IRPs, the next power IRP is *not* started.

Arguments:

    DeviceObject - the Fdo
    Irp - the request

Return Value:

    Returns the result from calling the next level.

--*/

{
    PPCI_FDO_EXTENSION     fdoExtension;

#if DBG
    PciDebugPrint(PciDbgInformative, "Pci PassIrp ...\n");
#endif

    //
    // Get the pointer to the device extension.
    //

    fdoExtension = (PPCI_FDO_EXTENSION) DeviceExtension;

    //
    // Call the PDO driver with the request.
    //
    if (IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_POWER) {

        //
        // ADRIAO BUGBUG 10/22/98 - Power IRPs don't appear to be skipable.
        //                          Need to investigate in ntos\po\pocall,
        //                          who may be mistakenly checking the current
        //                          instead of the next IrpSp.
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);

        //
        // Start the next power irp
        //
        PoStartNextPowerIrp(Irp);

        //
        // And now you know why this function isn't pageable...
        //
        return PoCallDriver(fdoExtension->AttachedDeviceObject, Irp);

    } else {

        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver(fdoExtension->AttachedDeviceObject, Irp);
    }
}

NTSTATUS
PciCallDownIrpStack(
    PPCI_COMMON_EXTENSION  DeviceExtension,
    PIRP                   Irp
    )

/*++

Description:

    Pass the IRP to the next device object in the device stack.  This
    routine is used when more processing is required at this level on
    this IRP on the way back up.

Arguments:

    DeviceObject - the Fdo
    Irp - the request

Return Value:

    Returns the result from calling the next level.

--*/

{
    PPCI_FDO_EXTENSION     fdoExtension;
    NTSTATUS           status;
    KEVENT             event;

    PAGED_CODE();

#if DBG
    PciDebugPrint(PciDbgInformative, "PciCallDownIrpStack ...\n");
#endif

    fdoExtension = (PPCI_FDO_EXTENSION) DeviceExtension;
    ASSERT_PCI_FDO_EXTENSION(fdoExtension);

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    //
    // Set our completion routine
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp,
                           PciSetEventCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE
                           );

    //
    // Pass down the driver stack
    status = IoCallDriver(fdoExtension->AttachedDeviceObject, Irp);

    //
    // If we did things asynchronously then wait on our event
    //

    if (status == STATUS_PENDING) {

        //
        // We do a KernelMode wait so that our stack where the event is
        // doesn't get paged out!
        //

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

        status = Irp->IoStatus.Status;
    }

    return status;
}

VOID
PciDispatchInvalidObject(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PUCHAR         MajorString
    )
{
            
    PciDebugPrint(
        PciDbgInformative,
        "PCI - %s IRP for unknown or corrupted Device Object.\n",
        MajorString
        );

    PciDebugPrint(
        PciDbgInformative,
        "      Device Object            0x%08x\n",
        DeviceObject
        );

    PciDebugPrint(
        PciDbgInformative,
        "      Device Object Extension  0x%08x\n",
        DeviceObject->DeviceExtension
        );

    PciDebugPrint(
        PciDbgInformative,
        "      Extension Signature      0x%08x\n",
        ((PPCI_PDO_EXTENSION)DeviceObject->DeviceExtension)->ExtensionType
        );
}

NTSTATUS
PciIrpNotSupported(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
                
    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
PciIrpInvalidDeviceRequest(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
            
    return STATUS_INVALID_DEVICE_REQUEST;
}

#if DBG
BOOLEAN
PciDebugIrpDispatchDisplay(
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension,
    IN ULONG                 MinorTableMax
    )
{
    ULONG irpBreakMask;
    ULONG debugPrintMask;
    PUCHAR debugIrpText;

    //
    // Pick up the irpBreakMasks
    //
    switch(IrpSp->MajorFunction) {

        case IRP_MJ_PNP:

            irpBreakMask =
                (DeviceExtension->ExtensionType == PCI_EXTENSIONTYPE_PDO) ?
                PciBreakOnPdoPnpIrp :
                PciBreakOnFdoPnpIrp;

            debugIrpText = PciDebugPnpIrpTypeToText(IrpSp->MinorFunction);

            break;

        case IRP_MJ_POWER:

            irpBreakMask =
                (DeviceExtension->ExtensionType == PCI_EXTENSIONTYPE_PDO) ?
                PciBreakOnPdoPowerIrp :
                PciBreakOnFdoPowerIrp;

            debugIrpText = PciDebugPoIrpTypeToText(IrpSp->MinorFunction);

            break;

        default:

            debugIrpText = "";
            irpBreakMask = 0;
            break;
    }

    //
    // Print out stuff...
    //
    debugPrintMask = 0;
    if (DeviceExtension->ExtensionType == PCI_EXTENSIONTYPE_PDO) {

        switch(IrpSp->MajorFunction) {

            case IRP_MJ_POWER: debugPrintMask = PciDbgPoIrpsPdo;  break;
            case IRP_MJ_PNP:   debugPrintMask = PciDbgPnpIrpsPdo; break;
        }

    } else {

        switch(IrpSp->MajorFunction) {

            case IRP_MJ_POWER: debugPrintMask = PciDbgPoIrpsFdo;  break;
            case IRP_MJ_PNP:   debugPrintMask = PciDbgPnpIrpsFdo; break;
        }
    }

    if (DeviceExtension->ExtensionType == PCI_EXTENSIONTYPE_PDO) {

        PPCI_PDO_EXTENSION pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;

        PciDebugPrint(
            debugPrintMask,
            "PDO(b=0x%x, d=0x%x, f=0x%x)<-%s\n",
            PCI_PARENT_FDOX(pdoExtension)->BaseBus,
            pdoExtension->Slot.u.bits.DeviceNumber,
            pdoExtension->Slot.u.bits.FunctionNumber,
            debugIrpText
            );

    } else {

        PPCI_FDO_EXTENSION fdoExtension = (PPCI_FDO_EXTENSION) DeviceExtension;

        PciDebugPrint(
            debugPrintMask,
            "FDO(%x)<-%s\n",
            fdoExtension,
            debugIrpText
            );
    }

    //
    // If it's an unknown minor IRP, squirt some text to the debugger...
    //
    if (IrpSp->MinorFunction > MinorTableMax) {

        PciDebugPrint(debugPrintMask | PciDbgInformative,
                      "Unknown IRP, minor = 0x%x\n",
                      IrpSp->MinorFunction);
    }

    return (BOOLEAN)((irpBreakMask & (1 << IrpSp->MinorFunction))!=0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\fdo.c ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    fdo.c

Abstract:

    This module handles IRPs for PCI FDO's.

Author:

    Adrian J. Oney (adriao) & Andrew Thornton (andrewth)  10-20-1998

Revision History:

--*/

#include "pcip.h"

NTSTATUS
PciFdoIrpStartDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoIrpQueryRemoveDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoIrpRemoveDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoIrpCancelRemoveDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoIrpStopDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoIrpQueryStopDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoIrpCancelStopDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoIrpQueryCapabilities(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoIrpQueryInterface(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoIrpQueryLegacyBusInformation(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoIrpDeviceUsageNotification(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoIrpSurpriseRemoval(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    );

VOID
PciGetHotPlugParameters(
    IN PPCI_FDO_EXTENSION Fdo
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PciAddDevice)
#pragma alloc_text(PAGE, PciInitializeFdoExtensionCommonFields)
#pragma alloc_text(PAGE, PciFdoIrpStartDevice)
#pragma alloc_text(PAGE, PciFdoIrpQueryRemoveDevice)
#pragma alloc_text(PAGE, PciFdoIrpRemoveDevice)
#pragma alloc_text(PAGE, PciFdoIrpCancelRemoveDevice)
#pragma alloc_text(PAGE, PciFdoIrpQueryStopDevice)
#pragma alloc_text(PAGE, PciFdoIrpStopDevice)
#pragma alloc_text(PAGE, PciFdoIrpCancelStopDevice)
#pragma alloc_text(PAGE, PciFdoIrpQueryDeviceRelations)
#pragma alloc_text(PAGE, PciFdoIrpQueryInterface)
#pragma alloc_text(PAGE, PciFdoIrpQueryCapabilities)
#pragma alloc_text(PAGE, PciFdoIrpDeviceUsageNotification)
#pragma alloc_text(PAGE, PciFdoIrpSurpriseRemoval)
#pragma alloc_text(PAGE, PciFdoIrpQueryLegacyBusInformation)
#pragma alloc_text(PAGE, PciGetHotPlugParameters)
#endif

//
// The following is used to determine if we failed to get a
// reasonable configuration from the PDO (in AddDevice) more
// than once.  If only once, we try to guess, if twice, we're
// in big trouble.
//

static BOOLEAN HaveGuessedConfigOnceAlready = FALSE;

/*++

The majority of functions in this file are called based on their presence
in Pnp and Po dispatch tables.  In the interests of brevity the arguments
to all those functions will be described below:

NTSTATUS
PciXxxPdo(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpStack,
    IN PPCI_EXTENSION DeviceExtension
    )

Routine Description:

    This function handles the Xxx requests for a given PCI FDO or PDO.

Arguments:

    Irp - Points to the IRP associated with this request.

    IrpStack - Points to the current stack location for this request.

    DeviceExtension - Points to the device's extension.

Return Value:

    Status code that indicates whether or not the function was successful.

    STATUS_NOT_SUPPORTED indicates that the IRP should be completed without
    changing the Irp->IoStatus.Status field otherwise it is updated with this
    status.

--*/

#define PCI_MAX_MINOR_POWER_IRP  0x3
#define PCI_MAX_MINOR_PNP_IRP    0x18

PCI_MN_DISPATCH_TABLE PciFdoDispatchPowerTable[] = {
    { IRP_DISPATCH, PciFdoWaitWake                     }, // 0x00 - IRP_MN_WAIT_WAKE
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x01 - IRP_MN_POWER_SEQUENCE
    { IRP_DOWNWARD, PciFdoSetPowerState                }, // 0x02 - IRP_MN_SET_POWER
    { IRP_DOWNWARD, PciFdoIrpQueryPower                }, // 0x03 - IRP_MN_QUERY_POWER
    { IRP_DOWNWARD, PciIrpNotSupported                 }  //      - UNHANDLED Power IRP
};

PCI_MN_DISPATCH_TABLE PciFdoDispatchPnpTable[] = {
    { IRP_UPWARD,   PciFdoIrpStartDevice               }, // 0x00 - IRP_MN_START_DEVICE
    { IRP_DOWNWARD, PciFdoIrpQueryRemoveDevice         }, // 0x01 - IRP_MN_QUERY_REMOVE_DEVICE
    { IRP_DISPATCH, PciFdoIrpRemoveDevice              }, // 0x02 - IRP_MN_REMOVE_DEVICE
    { IRP_DOWNWARD, PciFdoIrpCancelRemoveDevice        }, // 0x03 - IRP_MN_CANCEL_REMOVE_DEVICE
    { IRP_DOWNWARD, PciFdoIrpStopDevice                }, // 0x04 - IRP_MN_STOP_DEVICE
    { IRP_DOWNWARD, PciFdoIrpQueryStopDevice           }, // 0x05 - IRP_MN_QUERY_STOP_DEVICE
    { IRP_DOWNWARD, PciFdoIrpCancelStopDevice          }, // 0x06 - IRP_MN_CANCEL_STOP_DEVICE
    { IRP_DOWNWARD, PciFdoIrpQueryDeviceRelations      }, // 0x07 - IRP_MN_QUERY_DEVICE_RELATIONS
    { IRP_DISPATCH, PciFdoIrpQueryInterface            }, // 0x08 - IRP_MN_QUERY_INTERFACE
    { IRP_UPWARD,   PciFdoIrpQueryCapabilities         }, // 0x09 - IRP_MN_QUERY_CAPABILITIES
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x0A - IRP_MN_QUERY_RESOURCES
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x0C - IRP_MN_QUERY_DEVICE_TEXT
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x0E - NOT USED
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x0F - IRP_MN_READ_CONFIG
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x10 - IRP_MN_WRITE_CONFIG
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x11 - IRP_MN_EJECT
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x12 - IRP_MN_SET_LOCK
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x13 - IRP_MN_QUERY_ID
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x15 - IRP_MN_QUERY_BUS_INFORMATION
    { IRP_UPWARD,   PciFdoIrpDeviceUsageNotification   }, // 0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION
    { IRP_DOWNWARD, PciFdoIrpSurpriseRemoval           }, // 0x17 - IRP_MN_SURPRISE_REMOVAL
    { IRP_DOWNWARD, PciFdoIrpQueryLegacyBusInformation }, // 0x18 - IRP_MN_QUERY_LEGACY_BUS_INFORMATION
    { IRP_DOWNWARD, PciIrpNotSupported                 }  //      - UNHANDLED PNP IRP
};

//
// This is the major function dispatch table for Fdo's
//
PCI_MJ_DISPATCH_TABLE PciFdoDispatchTable = {
    PCI_MAX_MINOR_PNP_IRP,    PciFdoDispatchPnpTable,       // Pnp irps
    PCI_MAX_MINOR_POWER_IRP,  PciFdoDispatchPowerTable,     // Power irps
    IRP_DOWNWARD,             PciIrpNotSupported,           // SystemControl - just pass down!
    IRP_DOWNWARD,             PciIrpNotSupported            // DeviceControl - just pass down!
};

NTSTATUS
PciFdoIrpStartDevice(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Handler routine for start IRPs. This allows PDO filters to
    modify the allocated resources if they are filtering resource
    requirements. Called after completion.

Arguments:

    DeviceObject - Supplies the device object

    Irp - Supplies the IRP_MN_START_DEVICE irp.

    FdoExtension - Supplies the FDO extension

Return Value:

    ERROR_SUCCESS if successful

    NTSTATUS error code otherwise

--*/
{
    NTSTATUS status;
    PPCI_FDO_EXTENSION fdoExtension;
    PPCI_PDO_EXTENSION pdoExtension = NULL;
    PCM_RESOURCE_LIST resources;
    UCHAR barType[PCI_TYPE1_ADDRESSES] = {0,0};
    ULONG index;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR currentResource;
    PIO_RESOURCE_DESCRIPTOR currentRequirement;
    

    PAGED_CODE();

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {

        return STATUS_NOT_SUPPORTED;
    }

    fdoExtension = (PPCI_FDO_EXTENSION) DeviceExtension;

    status = PciBeginStateTransition(DeviceExtension, PciStarted);

    if (!NT_SUCCESS(status)) {

        return status;
    }                                                                                       

    //
    // If this is a PCI-PCI bridge then check if it has any bars and if so exclude
    // them from the list used to initialize the arbiters.
    //
    
    resources = IrpSp->Parameters.StartDevice.AllocatedResources;

    if (resources && !PCI_IS_ROOT_FDO(fdoExtension)) {
        
        PCI_ASSERT(resources->Count == 1);
        
        pdoExtension = PCI_BRIDGE_PDO(fdoExtension);

        if (pdoExtension->Resources) {

            if (pdoExtension->HeaderType == PCI_BRIDGE_TYPE) {
                
                //
                // If there are any bars they are at the beginning of the list 
                // so "begin at the beginning which is a very good place to start".
                //
                
                currentResource = resources->List[0].PartialResourceList.PartialDescriptors;
                
                for (index = 0; index < PCI_TYPE1_ADDRESSES; index++) {
                    
                    //
                    // Extract the requirement we asked for to determine if this
                    // bridge implements any bars (index 0 and 1 in the Limits 
                    // array)
                    //
                    
                    currentRequirement = &pdoExtension->Resources->Limit[index]; 
                    
                    //
                    // CmResourceTypeNull indicates that we didn't request any 
                    // resources so the bar is not implemented and there is nothing
                    // to prune out.
                    //
                    
                    if (currentRequirement->Type != CmResourceTypeNull) {
                        
                        PCI_ASSERT(currentResource->Type == currentRequirement->Type);
    
                        //
                        // Save away the type so we can restore it later
                        //
    
                        barType[index] = currentResource->Type;
                        
                        //
                        // Null out the resource so we don't configure the arbiters to
                        // use it
                        //
                        
                        currentResource->Type = CmResourceTypeNull;
    
                        //
                        // Advance the pointer into the started resources by 2 
                        // descriptors to skip over the device private
                        //
    
                        PCI_ASSERT((currentResource+1)->Type == CmResourceTypeDevicePrivate);
                        
                        currentResource+=2;
                    }
                }
            }
        }
    }

    //
    // Initialize arbiters with these resources.
    //
    status = PciInitializeArbiterRanges(fdoExtension, resources);
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }
    
    //
    // Restore the original resource list if we changed it
    //
    
    if (resources && !PCI_IS_ROOT_FDO(fdoExtension) && pdoExtension->Resources) {
        
        currentResource = resources->List[0].PartialResourceList.PartialDescriptors;
        
        for (index = 0; index < PCI_TYPE1_ADDRESSES; index++) {
            
            if (barType[index] != CmResourceTypeNull) {
                
                currentResource->Type = barType[index];
                
                //
                // Advance the pointer into the started resources by 2 
                // descriptors to skip over the device private
                //

                PCI_ASSERT((currentResource+1)->Type == CmResourceTypeDevicePrivate);

                currentResource+=2;
            }
        }
    }

cleanup:

    if (!NT_SUCCESS(status)) {
        PciCancelStateTransition(DeviceExtension, PciStarted);
        return status;
    }

    PciCommitStateTransition(DeviceExtension, PciStarted);
    return STATUS_SUCCESS;
}

NTSTATUS
PciFdoIrpQueryRemoveDevice(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
    PAGED_CODE();
    
            
    return PciBeginStateTransition(DeviceExtension, PciDeleted);
}

NTSTATUS
PciFdoIrpRemoveDevice(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
    PPCI_FDO_EXTENSION fdoExtension;
    PPCI_PDO_EXTENSION pdox;
    PDEVICE_OBJECT attachedDevice;
    NTSTATUS       status;

        
    PAGED_CODE();

    fdoExtension = (PPCI_FDO_EXTENSION) DeviceExtension;

    ExAcquireFastMutex(&fdoExtension->ChildListMutex);

    while (fdoExtension->ChildPdoList) {

        pdox = (PPCI_PDO_EXTENSION) fdoExtension->ChildPdoList;
#if DBG

        PciDebugPrint(
            PciDbgVerbose,
            "PCI Killing PDO %p PDOx %p (b=%d, d=%d, f=%d)\n",
            pdox->PhysicalDeviceObject,
            pdox,
            PCI_PARENT_FDOX(pdox)->BaseBus,
            pdox->Slot.u.bits.DeviceNumber,
            pdox->Slot.u.bits.FunctionNumber
            );

        PCI_ASSERT(pdox->DeviceState == PciNotStarted);

#endif
        PciPdoDestroy(pdox->PhysicalDeviceObject);
    }

    ExReleaseFastMutex(&fdoExtension->ChildListMutex);

    //
    // Destroy any secondary extensions associated with
    // this FDO.
    //
    while (fdoExtension->SecondaryExtension.Next) {

        PcipDestroySecondaryExtension(
            &fdoExtension->SecondaryExtension,
            NULL,
            fdoExtension->SecondaryExtension.Next
            );
    }

    //
    // Destroy the FDO.
    //
    // The IRP needs to go down the device stack but we
    // need to remove the device from the stack so grab
    // the next object first, then detach, then pass it
    // down.
    //
    PciDebugPrint(
        PciDbgInformative,
        "PCI FDOx (%p) destroyed.",
        fdoExtension
        );

    //
    // Note that a filter above us may have failed Start. If this is so, we get
    // no query because the "devnode" has never been started...
    //
    if (!PciIsInTransitionToState(DeviceExtension, PciDeleted)) {

        status = PciBeginStateTransition(DeviceExtension, PciDeleted);
        PCI_ASSERT(NT_SUCCESS(status));
    }

    PciCommitStateTransition(DeviceExtension, PciDeleted);

    PciRemoveEntryFromList(&PciFdoExtensionListHead,
                           &fdoExtension->List,
                           &PciGlobalLock);

    attachedDevice = fdoExtension->AttachedDeviceObject;
    IoDetachDevice(attachedDevice);
    IoDeleteDevice(fdoExtension->FunctionalDeviceObject);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(attachedDevice, Irp);
}

NTSTATUS
PciFdoIrpCancelRemoveDevice(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
    PAGED_CODE();

            
    PciCancelStateTransition(DeviceExtension, PciDeleted);
    return STATUS_SUCCESS;
}

NTSTATUS
PciFdoIrpStopDevice(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
    PAGED_CODE();

        
    PciCommitStateTransition(DeviceExtension, PciStopped);
    return STATUS_SUCCESS;
}

NTSTATUS
PciFdoIrpQueryStopDevice(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
    PAGED_CODE();
    
        
    PciBeginStateTransition(DeviceExtension, PciStopped);

    //
    // We don't support multilevel rebalance so we can't stop host bridges.
    //

    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
PciFdoIrpCancelStopDevice(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
    PAGED_CODE();

        
    PciCancelStateTransition(DeviceExtension, PciStopped);
    return STATUS_SUCCESS;
}

NTSTATUS
PciFdoIrpQueryDeviceRelations(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
    PAGED_CODE();

    if (IrpSp->Parameters.QueryDeviceRelations.Type == BusRelations) {

        return PciQueryDeviceRelations(
            (PPCI_FDO_EXTENSION) DeviceExtension,
            (PDEVICE_RELATIONS *) &Irp->IoStatus.Information
            );
    }

    //
    // No other relation types need to be handled.
    //
    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
PciFdoIrpQueryCapabilities(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    Snoops the results of a QUERY CAPABILITIES IRP that got sent
    downwards.   This saves us having to send our own for things
    like the device's power characteristics.

Arguments:

    DeviceObject - Supplies the device object

    Irp - Supplies the IRP_MN_QUERY_CAPABILITIES irp.

    FdoExtension - Supplies the FDO extension

Return Value:

    STATUS_SUCCESS

--*/

{
    PDEVICE_CAPABILITIES capabilities;
    PPCI_FDO_EXTENSION fdoExtension;

    PAGED_CODE();

    fdoExtension = (PPCI_FDO_EXTENSION) DeviceExtension;

    ASSERT_PCI_FDO_EXTENSION(fdoExtension);

    PciDebugPrint(
        PciDbgQueryCap,
        "PCI - FdoQueryCapabilitiesCompletion (fdox %08x) child status = %08x\n",
        fdoExtension,
        Irp->IoStatus.Status
        );

    //
    // Grab a pointer to the capablities for easy referencing
    //
    capabilities = IrpSp->Parameters.DeviceCapabilities.Capabilities;

    //
    // Remember what the system wake and device wake level are
    //
    fdoExtension->PowerState.SystemWakeLevel = capabilities->SystemWake;
    fdoExtension->PowerState.DeviceWakeLevel = capabilities->DeviceWake;

    //
    // Grab the S-state to D-State mapping
    //
    RtlCopyMemory(
        fdoExtension->PowerState.SystemStateMapping,
        capabilities->DeviceState,
        (PowerSystemShutdown + 1) * sizeof(DEVICE_POWER_STATE)
        );

#if DBG

    if (PciDebug & PciDbgQueryCap) {
        PciDebugDumpQueryCapabilities(capabilities);
    }

#endif

    return STATUS_SUCCESS;
}



NTSTATUS
PciFdoIrpQueryLegacyBusInformation(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
    PAGED_CODE();
    
    
    return PciQueryLegacyBusInformation(
        (PPCI_FDO_EXTENSION) DeviceExtension,
        (PLEGACY_BUS_INFORMATION *) &Irp->IoStatus.Information
        );
}

NTSTATUS
PciFdoIrpDeviceUsageNotification(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
   PPCI_FDO_EXTENSION fdoExtension;

   PAGED_CODE();

      
   fdoExtension = (PPCI_FDO_EXTENSION) DeviceExtension;

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        return PciLocalDeviceUsage(&fdoExtension->PowerState, Irp);

    } else {

        return STATUS_NOT_SUPPORTED;
    }
}

NTSTATUS
PciFdoIrpQueryInterface(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
   PPCI_FDO_EXTENSION fdoExtension;
   NTSTATUS status;

   PAGED_CODE();

   fdoExtension = (PPCI_FDO_EXTENSION) DeviceExtension;

   ASSERT_PCI_FDO_EXTENSION(fdoExtension);


   // NTRAID #54671 - 4/20/2000 - andrewth
   //
   // We might want to do a synchronizing state
   // transition here so we don't attempt to get the interface during a
   // stop/remove sequence.
   //
   // We shouldn't hold interfaces when something isn't
   // started. But we won't boot unless we hack the below....
   //

   //if (fdoExtension->DeviceState != PciStarted) {
   if (fdoExtension->DeviceState == PciDeleted) {

       return PciPassIrpFromFdoToPdo(DeviceExtension, Irp);
   }

   status = PciQueryInterface(
                fdoExtension,
                IrpSp->Parameters.QueryInterface.InterfaceType,
                IrpSp->Parameters.QueryInterface.Size,
                IrpSp->Parameters.QueryInterface.Version,
                IrpSp->Parameters.QueryInterface.InterfaceSpecificData,
                IrpSp->Parameters.QueryInterface.Interface,
                FALSE
                );

   if (NT_SUCCESS(status)) {

       Irp->IoStatus.Status = status;
       return PciPassIrpFromFdoToPdo(DeviceExtension, Irp);

   } else if (status == STATUS_NOT_SUPPORTED) {

       //
       // Status == STATUS_NOT_SUPPORTED. Pass IRP down the stack
       // and see if anyone else is kind enough to provide this
       // interface.
       //
       status = PciCallDownIrpStack(DeviceExtension, Irp);

       if (status == STATUS_NOT_SUPPORTED) {

           //
           // If nobody provided the interface, try again at
           // this level.
           //
           status = PciQueryInterface(
               fdoExtension,
               IrpSp->Parameters.QueryInterface.InterfaceType,
               IrpSp->Parameters.QueryInterface.Size,
               IrpSp->Parameters.QueryInterface.Version,
               IrpSp->Parameters.QueryInterface.InterfaceSpecificData,
               IrpSp->Parameters.QueryInterface.Interface,
               TRUE
               );
       }
   }

   if (status != STATUS_NOT_SUPPORTED) {

       Irp->IoStatus.Status = status;
   } else {

       status = Irp->IoStatus.Status;
   }

   IoCompleteRequest(Irp, IO_NO_INCREMENT);
   return status;
}

NTSTATUS
PciFdoIrpSurpriseRemoval(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
   PPCI_FDO_EXTENSION fdoExtension;
   NTSTATUS status;

   PAGED_CODE();
   
      
   fdoExtension = (PPCI_FDO_EXTENSION) DeviceExtension;

   status = PciBeginStateTransition(DeviceExtension, PciSurpriseRemoved);
   PCI_ASSERT(NT_SUCCESS(status));
   if (NT_SUCCESS(status)) {

       PciCommitStateTransition(DeviceExtension, PciSurpriseRemoved);
       status = PciBeginStateTransition(DeviceExtension, PciDeleted);
   }
   return status;
}

NTSTATUS
PciAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    Given a physical device object, this routine creates a functional
    device object for it.

Arguments:

    DriverObject - Pointer to our driver's DRIVER_OBJECT structure.

    PhysicalDeviceObject - Pointer to the physical device object for which
                           we must create a functional device object.

Return Value:

    NT status.

--*/
{
    PDEVICE_OBJECT functionalDeviceObject = NULL;
    PDEVICE_OBJECT attachedTo = NULL;
    PPCI_FDO_EXTENSION fdoExtension = NULL;
    PPCI_FDO_EXTENSION pciParentFdoExtension;
    PPCI_PDO_EXTENSION pdoExtension = NULL;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor;
    NTSTATUS       status;
    HANDLE deviceRegistryHandle;
    ULONG resultLength;
    UNICODE_STRING hackFlagsString;
    UCHAR infoBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG) - 1];
    PKEY_VALUE_PARTIAL_INFORMATION info = (PKEY_VALUE_PARTIAL_INFORMATION) infoBuffer;

    PAGED_CODE();

    PciDebugPrint(PciDbgAddDevice, "PCI - AddDevice (a new bus).\n");

    //
    // Find out if the PDO was created by the PCI driver.  That is,
    // if it is a child or a root bus.   Validate a few things before
    // going any further.
    //

    pciParentFdoExtension = PciFindParentPciFdoExtension(PhysicalDeviceObject,
                                                         &PciGlobalLock);
    if (pciParentFdoExtension) {

        //
        // The PDO was created by this driver, therefore we can look at
        // the extension.   Get it and verify it's ours.
        //

        pdoExtension = (PPCI_PDO_EXTENSION)PhysicalDeviceObject->DeviceExtension;
        ASSERT_PCI_PDO_EXTENSION(pdoExtension);

        //
        // The only thing we should get an add device that is a
        // child device is a PCI-PCI bridge.
        //

        if ((pdoExtension->BaseClass != PCI_CLASS_BRIDGE_DEV) ||
            (pdoExtension->SubClass  != PCI_SUBCLASS_BR_PCI_TO_PCI)) {
            PciDebugPrint(
                PciDbgAlways,
                "PCI - PciAddDevice for Non-Root/Non-PCI-PCI bridge,\n"
                "      Class %02x, SubClass %02x, will not add.\n",
                pdoExtension->BaseClass,
                pdoExtension->SubClass
                );
            PCI_ASSERT((pdoExtension->BaseClass == PCI_CLASS_BRIDGE_DEV) &&
                   (pdoExtension->SubClass  == PCI_SUBCLASS_BR_PCI_TO_PCI));

            status = STATUS_INVALID_DEVICE_REQUEST;
            goto cleanup;
        }

        PciDebugPrint(PciDbgAddDevice,
                      "PCI - AddDevice (new bus is child of bus 0x%x).\n",
                      pciParentFdoExtension->BaseBus
                      );

        if (!PciAreBusNumbersConfigured(pdoExtension)) {

            //
            // This bridge isn't configured and if we had been able to we would
            // already have done so
            //

            PciDebugPrint(
                PciDbgAddDevice | PciDbgInformative,
                "PCI - Bus numbers not configured for bridge (0x%x.0x%x.0x%x)\n",
                pciParentFdoExtension->BaseBus,
                pdoExtension->Slot.u.bits.DeviceNumber,
                pdoExtension->Slot.u.bits.FunctionNumber,
                pdoExtension->Dependent.type1.PrimaryBus
            );

            status = STATUS_INVALID_DEVICE_REQUEST;
            goto cleanup;

        }
    }

    //
    // We've been given the PhysicalDeviceObject for a PCI bus.  Create the
    // functionalDeviceObject.  Our FDO will be nameless.
    //

    status = IoCreateDevice(
                DriverObject,               // our driver object
                sizeof(PCI_FDO_EXTENSION),      // size of our extension
                NULL,                       // our name
                FILE_DEVICE_BUS_EXTENDER,   // device type
                0,                          // device characteristics
                FALSE,                      // not exclusive
                &functionalDeviceObject     // store new device object here
                );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    fdoExtension = (PPCI_FDO_EXTENSION)functionalDeviceObject->DeviceExtension;

    //
    // We have our functionalDeviceObject, initialize it.
    //

    PciInitializeFdoExtensionCommonFields(
        fdoExtension,
        functionalDeviceObject,
        PhysicalDeviceObject
        );

    //
    // Now attach to the PDO we were given.
    //

    attachedTo = IoAttachDeviceToDeviceStack(functionalDeviceObject,
                                             PhysicalDeviceObject);

    if (attachedTo == NULL) {

        PCI_ASSERT(attachedTo != NULL);
        status =  STATUS_NO_SUCH_DEVICE;
        goto cleanup;
    }

    fdoExtension->AttachedDeviceObject = attachedTo;

    //
    // Get the access registers and base bus number for this bus.
    // If this bus was discovered by this driver, then the PDO was
    // created by this driver and will be on one of the PDO lists
    // under one of the FDOs owned by this driver.  Otherwise it
    // is a new root,.... use magic.
    //

    if (pciParentFdoExtension) {

        //
        // This physical device was discovered by this driver.
        // Get the bus number from the PDO extension.
        //

        fdoExtension->BaseBus = pdoExtension->Dependent.type1.SecondaryBus;

        //
        // Copy the access methods from the root fdo and set
        // the root fdo back pointer.
        //

        fdoExtension->BusRootFdoExtension =
            pciParentFdoExtension->BusRootFdoExtension;

        //
        // Point the PDOextension to the new FDOextension (also indicates
        // the object is a bridge) and vice versa.
        //

        pdoExtension->BridgeFdoExtension = fdoExtension;
        fdoExtension->ParentFdoExtension = pciParentFdoExtension;

    } else {

        PVOID buffer;

        //
        // Get the boot configuration (CmResourceList) for
        // this PDO.  This gives us the bus number and the
        // ranges covered by this host bridge.
        //

        status = PciGetDeviceProperty(
                    PhysicalDeviceObject,
                    DevicePropertyBootConfiguration,
                    &buffer
                    );

        if (NT_SUCCESS(status)) {
#if DBG

            PciDebugPrint(PciDbgAddDeviceRes,
                         "PCI - CM RESOURCE LIST FROM ROOT PDO\n");
            PciDebugPrintCmResList(PciDbgAddDeviceRes,
                         buffer);

#endif

            descriptor = PciFindDescriptorInCmResourceList(
                            CmResourceTypeBusNumber,
                            buffer,
                            NULL
                            );
        } else {

            descriptor = NULL;
        }

        if (descriptor != NULL) {

            //
            // Sanity check, some servers are aproaching
            // 256 busses but as there is no way to deal with
            // numbering bridges under a bus > 256 and we don't
            // have raw and translated bus numbers yet - it had
            // better be < 0xFF!
            //

            PCI_ASSERT(descriptor->u.BusNumber.Start <= 0xFF);
            PCI_ASSERT(descriptor->u.BusNumber.Start + descriptor->u.BusNumber.Length - 1 <= 0xFF);

            fdoExtension->BaseBus =
                (UCHAR)descriptor->u.BusNumber.Start;
            fdoExtension->MaxSubordinateBus =
                (UCHAR)(descriptor->u.BusNumber.Start + descriptor->u.BusNumber.Length - 1);
            PciDebugPrint(PciDbgAddDevice,
                          "PCI - Root Bus # 0x%x->0x%x.\n",
                          fdoExtension->BaseBus,
                          fdoExtension->MaxSubordinateBus
                          );
        } else {

            //
            // HaveGuessedConfigOnceAlready is used to tell
            // if have multiple roots and no config info. If
            // this happens we end up gussing the bus number
            // as zero, doing this more than once is not good.
            //

            if (HaveGuessedConfigOnceAlready) {

                KeBugCheckEx(PCI_BUS_DRIVER_INTERNAL,
                             PCI_BUGCODE_TOO_MANY_CONFIG_GUESSES,
                             (ULONG_PTR)PhysicalDeviceObject,
                             0,
                             0);
            }
            PciDebugPrint(
                PciDbgAlways,
                "PCI   Will use default configuration.\n"
                );

            HaveGuessedConfigOnceAlready = TRUE;
            fdoExtension->BaseBus = 0;
        }

        fdoExtension->BusRootFdoExtension = fdoExtension;
    }

    //
    // Organise access to config space
    //

    status = PciGetConfigHandlers(fdoExtension);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Initialize arbiters for this FDO.
    //
    status = PciInitializeArbiters(fdoExtension);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Indicate this is a REAL FDO extension that is part of a REAL
    // FDO.   (Fake extensions exist to assist in the enumeration of
    // busses which PCI isn't the real controller for (eg CardBus).
    //

    fdoExtension->Fake = FALSE;

    //
    // Insert this Fdo in the list of PCI parent Fdos.
    //

    PciInsertEntryAtTail(&PciFdoExtensionListHead,
                         &fdoExtension->List,
                         &PciGlobalLock);


#if defined(_WIN64)

    //
    // Update the legacy hardware tree that would have been build by the ARC
    // firmware or NTDetect which don't exist here.
    //

    status = PciUpdateLegacyHardwareDescription(fdoExtension);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

#endif

    //
    // Check if there are any hacks to apply to this bus.
    // These are located under the device registry key in a value called HackFlags
    //

    status = IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_ALL_ACCESS,
                                     &deviceRegistryHandle
                                     );



    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    PciConstStringToUnicodeString(&hackFlagsString, L"HackFlags");

    status = ZwQueryValueKey(deviceRegistryHandle,
                             &hackFlagsString,
                             KeyValuePartialInformation,
                             info,
                             sizeof(infoBuffer),
                             &resultLength
                             );
    
    ZwClose(deviceRegistryHandle);

    //
    // If we have valid data in the registry then remember it
    //

    if (NT_SUCCESS(status)
    && (info->Type == REG_DWORD)
    && (info->DataLength == sizeof(ULONG))) {
    
        fdoExtension->BusHackFlags = *((PULONG)(&info->Data));
    }

    //
    // We can receive IRPs now...
    //

    functionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;


    //
    // Get any hotplug parameters (we send IRPS for this so it must be after
    // DO_DEVICE_INITIALIZING is cleared so we can deal with them)
    //
    PciGetHotPlugParameters(fdoExtension);

    return STATUS_SUCCESS;

cleanup:

    PCI_ASSERT(!NT_SUCCESS(status));

    //
    // Destroy any secondary extensions associated with
    // this FDO.
    //
    if (fdoExtension) {

        while (fdoExtension->SecondaryExtension.Next) {

            PcipDestroySecondaryExtension(
                &fdoExtension->SecondaryExtension,
                NULL,
                fdoExtension->SecondaryExtension.Next
                );
        }
    }

    if (attachedTo) {
        IoDetachDevice(attachedTo);
    }

    if (functionalDeviceObject) {
        IoDeleteDevice(functionalDeviceObject);
    }

    return status;
}

VOID
PciInitializeFdoExtensionCommonFields(
    IN  PPCI_FDO_EXTENSION  FdoExtension,
    IN  PDEVICE_OBJECT  Fdo,
    IN  PDEVICE_OBJECT  Pdo
    )
{
    RtlZeroMemory(FdoExtension, sizeof(PCI_FDO_EXTENSION));

    FdoExtension->ExtensionType = PciFdoExtensionType;
    FdoExtension->PhysicalDeviceObject = Pdo;
    FdoExtension->FunctionalDeviceObject = Fdo;
    FdoExtension->PowerState.CurrentSystemState = PowerSystemWorking;
    FdoExtension->PowerState.CurrentDeviceState = PowerDeviceD0;
    FdoExtension->IrpDispatchTable = &PciFdoDispatchTable;
    ExInitializeFastMutex(&FdoExtension->SecondaryExtMutex);
    ExInitializeFastMutex(&FdoExtension->ChildListMutex);
    PciInitializeState((PPCI_COMMON_EXTENSION) FdoExtension);
}

VOID
PciGetHotPlugParameters(
    IN PPCI_FDO_EXTENSION Fdo
    )
/*++

Description:

    Runs the _HPP (described below) on the device and saves the parameters if available

    Method (_HPP, 0) {
        Return (Package(){
            0x00000008,     // CacheLineSize in DWORDS
            0x00000040,     // LatencyTimer in PCI clocks
            0x00000001,     // Enable SERR (Boolean)
            0x00000001      // Enable PERR (Boolean)
            })

Arguments:

    Fdo - The PDO extension for the bridge

Return Value:

    TRUE - if the parameters are available, FASLE otherwise

--*/
{
    NTSTATUS status;
    ACPI_EVAL_INPUT_BUFFER input;
    PACPI_EVAL_OUTPUT_BUFFER output = NULL;
    ULONG count;
    ULONG outputSize = sizeof(ACPI_EVAL_OUTPUT_BUFFER) + sizeof(ACPI_METHOD_ARGUMENT) * PCI_HPP_PACKAGE_COUNT;

    PAGED_CODE();

    output = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, outputSize);

    if (!output) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    RtlZeroMemory(&input, sizeof(ACPI_EVAL_INPUT_BUFFER));
    RtlZeroMemory(output, outputSize);

    //
    // Send a IOCTL to ACPI to request it to run the _HPP method on this device
    // if the method it is present
    //

    input.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
    input.MethodNameAsUlong = (ULONG)'PPH_';

    //
    // PciSendIoctl deals with sending this from the top of the stack.
    //

    status = PciSendIoctl(Fdo->PhysicalDeviceObject,
                          IOCTL_ACPI_EVAL_METHOD,
                          &input,
                          sizeof(ACPI_EVAL_INPUT_BUFFER),
                          output,
                          outputSize
                          );

    if (!NT_SUCCESS(status)) {
        //
        // Inherit them from my parent (If I have one)
        //

        if (!PCI_IS_ROOT_FDO(Fdo)) {
            RtlCopyMemory(&Fdo->HotPlugParameters,
                          &Fdo->ParentFdoExtension->HotPlugParameters,
                          sizeof(Fdo->HotPlugParameters)
                          );
        }
    
    } else {
    
        if (output->Count != PCI_HPP_PACKAGE_COUNT) {
            goto exit;
        }

        //
        // Check they are all integers and in the right bounds
        //

        for (count = 0; count < PCI_HPP_PACKAGE_COUNT; count++) {
            ULONG current;

            if (output->Argument[count].Type != ACPI_METHOD_ARGUMENT_INTEGER) {
                goto exit;
            }

            current = output->Argument[count].Argument;
            switch (count) {
            case PCI_HPP_CACHE_LINE_SIZE_INDEX:
            case PCI_HPP_LATENCY_TIMER_INDEX:
                //
                // These registers are only a UCHAR in length
                //
                if (current > 0xFF) {
                    goto exit;
                }
                break;
            case PCI_HPP_ENABLE_SERR_INDEX:
            case PCI_HPP_ENABLE_PERR_INDEX:
                //
                // These are booleans - 1 or 0
                //
                if (current > 1) {
                    goto exit;
                }
                break;
            }
        }
    
        //
        // Finally save them and remember we got them.
        //
    
        Fdo->HotPlugParameters.CacheLineSize = (UCHAR)output->Argument[PCI_HPP_CACHE_LINE_SIZE_INDEX].Argument;
        Fdo->HotPlugParameters.LatencyTimer = (UCHAR)output->Argument[PCI_HPP_LATENCY_TIMER_INDEX].Argument;
        Fdo->HotPlugParameters.EnableSERR = (BOOLEAN)output->Argument[PCI_HPP_ENABLE_SERR_INDEX].Argument;
        Fdo->HotPlugParameters.EnablePERR = (BOOLEAN)output->Argument[PCI_HPP_ENABLE_PERR_INDEX].Argument;
        Fdo->HotPlugParameters.Acquired = TRUE;
    }

exit:

    if (output) {
        ExFreePool(output);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\guid.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    guid.c

Abstract:

    This module instantiates the guids used by pci that are not part of 
    wdmguid.{h|lib}.
    
    It relies on the DEFINE_GUID macros being outside the #ifdef _FOO_H
    multiple inclusion fix.

Author:

    Peter Johnston (peterj)  20-Nov-1996

Revision History:

--*/

#include "pcip.h"
#include <initguid.h>
#include "pciintrf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\init.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module contains the initialization code for PCI.SYS.

Author:

    Forrest Foltz (forrestf) 22-May-1996

Revision History:

--*/

#include "pcip.h"
#include <ntacpi.h>

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
PciDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
PciBuildHackTable(
    IN HANDLE HackTableKey
    );

NTSTATUS
PciGetIrqRoutingTableFromRegistry(
    PPCI_IRQ_ROUTING_TABLE *RoutingTable
    );

NTSTATUS
PciGetDebugPorts(
    IN HANDLE ServiceHandle
    );

NTSTATUS
PciAcpiFindRsdt(
    OUT PACPI_BIOS_MULTI_NODE   *AcpiMulti
    );

PVOID
PciGetAcpiTable(
    IN  ULONG  Signature
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, PciBuildHackTable)
#pragma alloc_text(INIT, PciGetIrqRoutingTableFromRegistry)
#pragma alloc_text(INIT, PciGetDebugPorts)
#pragma alloc_text(INIT, PciAcpiFindRsdt)
#pragma alloc_text(INIT, PciGetAcpiTable)
#pragma alloc_text(PAGE, PciDriverUnload)
#endif

PDRIVER_OBJECT PciDriverObject;
BOOLEAN PciLockDeviceResources;
ULONG PciSystemWideHackFlags;
ULONG PciEnableNativeModeATA;

//
// List of FDOs created by this driver.
//

SINGLE_LIST_ENTRY PciFdoExtensionListHead;
LONG              PciRootBusCount;

//
// PciAssignBusNumbers - this flag indicates whether we should try to assign
// bus numbers to an unconfigured bridge.  It is set once we know if the enumerator
// of the PCI bus provides sufficient support.
//

BOOLEAN PciAssignBusNumbers = FALSE;

//
// PciRunningDatacenter - set to TRUE if we are running on the Datacenter SKU
//
BOOLEAN PciRunningDatacenter = FALSE;

//
// This locks all PCI's global data structures
//

FAST_MUTEX        PciGlobalLock;

//
// This locks changes to bus numbers
//

FAST_MUTEX        PciBusLock;

//
// Table of hacks for broken hardware read from the registry at init.
// Protected by PciGlobalSpinLock and in none paged pool as it is needed at
// dispatch level
//

PPCI_HACK_TABLE_ENTRY PciHackTable = NULL;

// Will point to PCI IRQ Routing Table if one was found in the registry.
PPCI_IRQ_ROUTING_TABLE PciIrqRoutingTable = NULL;

//
// Debug ports we support
//
PCI_DEBUG_PORT PciDebugPorts[MAX_DEBUGGING_DEVICES_SUPPORTED];
ULONG PciDebugPortsCount;

//
// Watchdog timer resource table
//
PWATCHDOG_TIMER_RESOURCE_TABLE WdTable;

#define PATH_CCS            L"\\Registry\\Machine\\System\\CurrentControlSet"

#define KEY_BIOS_INFO       L"Control\\BiosInfo\\PCI"
#define VALUE_PCI_LOCK      L"PCILock"

#define KEY_PNP_PCI         L"Control\\PnP\\PCI"
#define VALUE_PCI_HACKFLAGS L"HackFlags"
#define VALUE_ENABLE_NATA   L"EnableNativeModeATA"

#define KEY_CONTROL      L"Control"
#define VALUE_OSLOADOPT  L"SystemStartOptions"

#define KEY_MULTIFUNCTION L"\\Registry\\Machine\\HARDWARE\\DESCRIPTION\\System\\MultiFunctionAdapter"
#define KEY_IRQ_ROUTING_TABLE L"RealModeIrqRoutingTable\\0"
#define VALUE_IDENTIFIER L"Identifier"
#define VALUE_CONFIGURATION_DATA L"Configuration Data"
#define PCIIR_IDENTIFIER L"PCI BIOS"
#define ACPI_BIOS_ID L"ACPI BIOS"

#define HACKFMT_VENDORDEV         (sizeof(L"VVVVDDDD") - sizeof(UNICODE_NULL))
#define HACKFMT_VENDORDEVREVISION (sizeof(L"VVVVDDDDRR") - sizeof(UNICODE_NULL))
#define HACKFMT_SUBSYSTEM         (sizeof(L"VVVVDDDDSSSSssss") - sizeof(UNICODE_NULL))
#define HACKFMT_SUBSYSTEMREVISION (sizeof(L"VVVVDDDDSSSSssssRR") - sizeof(UNICODE_NULL))
#define HACKFMT_MAX_LENGTH        HACKFMT_SUBSYSTEMREVISION

#define HACKFMT_DEVICE_OFFSET     4
#define HACKFMT_SUBVENDOR_OFFSET  8
#define HACKFMT_SUBSYSTEM_OFFSET 12


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Entrypoint needed to initialize the PCI bus enumerator.

Arguments:

    DriverObject - Pointer to the driver object created by the system.
    RegistryPath - Pointer to the unicode registry service path.

Return Value:

    NT status.

--*/

{
    NTSTATUS status;
    ULONG length;
    PWCHAR osLoadOptions;
    HANDLE ccsHandle = NULL, serviceKey = NULL, paramsKey = NULL, debugKey = NULL;
    PULONG registryValue;
    ULONG registryValueLength;
    OBJECT_ATTRIBUTES attributes;
    UNICODE_STRING pciLockString, osLoadOptionsString;

    //
    // Fill in the driver object
    //

    DriverObject->MajorFunction[IRP_MJ_PNP]            = PciDispatchIrp;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = PciDispatchIrp;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = PciDispatchIrp;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = PciDispatchIrp;

    DriverObject->DriverUnload                         = PciDriverUnload;
    DriverObject->DriverExtension->AddDevice           = PciAddDevice;

    PciDriverObject = DriverObject;

    //
    // Open our service key and retrieve the hack table
    //

    InitializeObjectAttributes(&attributes,
                               RegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );

    status = ZwOpenKey(&serviceKey,
                       KEY_READ,
                       &attributes
                       );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Get the Hack table from the registry
    //

    if (!PciOpenKey(L"Parameters", serviceKey, KEY_READ, &paramsKey, &status)) {
        goto exit;
    }

    status = PciBuildHackTable(paramsKey);

    if (!NT_SUCCESS(status)) {
        goto exit;
    }

    //
    // Get any info about debugging ports from the registry so we don't perturb
    // them
    //

    if (PciOpenKey(L"Debug", serviceKey, KEY_READ, &debugKey, &status)) {

        status = PciGetDebugPorts(debugKey);

        if (!NT_SUCCESS(status)) {
            goto exit;
        }

    }
    //
    // Initialize the list of FDO Extensions.
    //

    PciFdoExtensionListHead.Next = NULL;
    PciRootBusCount = 0;
    ExInitializeFastMutex(&PciGlobalLock);
    ExInitializeFastMutex(&PciBusLock);

    //
    // Need access to the CurrentControlSet for various
    // initialization chores.
    //

    if (!PciOpenKey(PATH_CCS, NULL, KEY_READ, &ccsHandle, &status)) {
        goto exit;
    }

    //
    // Get OSLOADOPTIONS and see if PCILOCK was specified.
    // (Unless the driver is build to force PCILOCK).
    // (Note: Can't check for leading '/', it was stripped
    // before getting put in the registry).
    //

    PciLockDeviceResources = FALSE;

    if (NT_SUCCESS(PciGetRegistryValue(VALUE_OSLOADOPT,
                                       KEY_CONTROL,
                                       ccsHandle,
                                       REG_SZ,
                                       &osLoadOptions,
                                       &length
                                       ))) {

        //
        // Build counted versions of the stings we need to search
        //

        PciConstStringToUnicodeString(&pciLockString, L"PCILOCK");
        
        //
        // We assume that the string coming from the registry is NUL terminated
        // and if this isn't the case, the MaximumLength in the counted string
        // prevents us from over running our buffer.  If the string is larger 
        // than MAX_USHORT bytes then we truncate it.
        //
        
        osLoadOptionsString.Buffer = osLoadOptions;
        osLoadOptionsString.Length = (USHORT)(length - sizeof(UNICODE_NULL));
        osLoadOptionsString.MaximumLength = (USHORT) length;

        if (PciUnicodeStringStrStr(&osLoadOptionsString, &pciLockString, TRUE)) {
            PciLockDeviceResources = TRUE;
        }

        ExFreePool(osLoadOptions);
    
    
    }

    if (!PciLockDeviceResources) {
        PULONG  pciLockValue;
        ULONG   pciLockLength;

        if (NT_SUCCESS(PciGetRegistryValue( VALUE_PCI_LOCK,
                                            KEY_BIOS_INFO,
                                            ccsHandle,
                                            REG_DWORD,
                                            &pciLockValue,
                                            &pciLockLength))) {                                                
            
            if (pciLockLength == sizeof(ULONG) && *pciLockValue == 1) {

                PciLockDeviceResources = TRUE;
            }

            ExFreePool(pciLockValue);
        }
    }

    PciSystemWideHackFlags = 0;

    if (NT_SUCCESS(PciGetRegistryValue( VALUE_PCI_HACKFLAGS,
                                        KEY_PNP_PCI,
                                        ccsHandle,
                                        REG_DWORD,
                                        &registryValue,
                                        &registryValueLength))) {

        if (registryValueLength == sizeof(ULONG)) {

            PciSystemWideHackFlags = *registryValue;
        }

        ExFreePool(registryValue);
    }

    PciEnableNativeModeATA = 0;

    if (NT_SUCCESS(PciGetRegistryValue( VALUE_ENABLE_NATA,
                                        KEY_PNP_PCI,
                                        ccsHandle,
                                        REG_DWORD,
                                        &registryValue,
                                        &registryValueLength))) {

        if (registryValueLength == sizeof(ULONG)) {

            PciEnableNativeModeATA = *registryValue;
        }

        ExFreePool(registryValue);
    }

    //
    // Build some global data structures
    //

    status = PciBuildDefaultExclusionLists();

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // If we don't find an IRQ routing table, no UI number information
    // will be returned for the PDOs using this mechanism.  ACPI may
    // still filter in UI numbers.
    //
    PciGetIrqRoutingTableFromRegistry(&PciIrqRoutingTable);

    //
    // Override the functions that used to be in the HAL but are now in the
    // PCI driver
    //

    PciHookHal();

    //
    // Enable the hardware verifier code if appropriate.
    //
    PciVerifierInit(DriverObject);

    PciRunningDatacenter = PciIsDatacenter();
    if (PciRunningDatacenter) {

        PciDebugPrint(
            PciDbgInformative,
            "PCI running on datacenter build\n"
            );
    }

    //
    // Get the WD ACPI table
    //

    WdTable = (PWATCHDOG_TIMER_RESOURCE_TABLE) PciGetAcpiTable( WDTT_SIGNATURE );

    status = STATUS_SUCCESS;

exit:

    if (ccsHandle) {
        ZwClose(ccsHandle);
    }

    if (serviceKey) {
        ZwClose(serviceKey);
    }

    if (paramsKey) {
        ZwClose(paramsKey);
    }

    if (debugKey) {
        ZwClose(debugKey);
    }

    return status;
}
VOID
PciDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Entrypoint used to unload the PCI driver.   Does nothing, the
    PCI driver is never unloaded.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

Return Value:

    None.

--*/

{
    //
    // Disable the hardware verifier code if appropriate.
    //
    PciVerifierUnload(DriverObject);

    //
    // Unallocate anything we can find.
    //

    RtlFreeRangeList(&PciIsaBitExclusionList);
    RtlFreeRangeList(&PciVgaAndIsaBitExclusionList);

    //
    // Free IRQ routing table if we have one
    //

    if (PciIrqRoutingTable != NULL) {
        ExFreePool(PciIrqRoutingTable);
    }

    //
    // Attempt to remove our hooks in case we actually get unloaded.
    //

    PciUnhookHal();
}


NTSTATUS
PciBuildHackTable(
    IN HANDLE HackTableKey
    )
{

    NTSTATUS status;
    PKEY_FULL_INFORMATION keyInfo = NULL;
    ULONG hackCount, size, index;
    USHORT temp;
    PPCI_HACK_TABLE_ENTRY entry;
    ULONGLONG data;
    PKEY_VALUE_FULL_INFORMATION valueInfo = NULL;
    ULONG valueInfoSize = sizeof(KEY_VALUE_FULL_INFORMATION)
                          + HACKFMT_MAX_LENGTH +
                          + sizeof(ULONGLONG);

    //
    // Get the key info so we know how many hack values there are.
    // This does not change during system initialization.
    //

    status = ZwQueryKey(HackTableKey,
                        KeyFullInformation,
                        NULL,
                        0,
                        &size
                        );

    if (status != STATUS_BUFFER_TOO_SMALL) {
        PCI_ASSERT(!NT_SUCCESS(status));
        goto cleanup;
    }

    PCI_ASSERT(size > 0);

    keyInfo = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, size);

    if (!keyInfo) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    status = ZwQueryKey(HackTableKey,
                        KeyFullInformation,
                        keyInfo,
                        size,
                        &size
                        );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    hackCount = keyInfo->Values;

    ExFreePool(keyInfo);
    keyInfo = NULL;

    //
    // Allocate and initialize the hack table
    //

    PciHackTable = ExAllocatePool(NonPagedPool,
                                  (hackCount + 1) * sizeof(PCI_HACK_TABLE_ENTRY)
                                  );

    if (!PciHackTable) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }


    //
    // Allocate a valueInfo buffer big enough for the biggest valid
    // format and a ULONGLONG worth of data.
    //

    valueInfo = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, valueInfoSize);

    if (!valueInfo) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    entry = PciHackTable;

    for (index = 0; index < hackCount; index++) {

        status = ZwEnumerateValueKey(HackTableKey,
                                     index,
                                     KeyValueFullInformation,
                                     valueInfo,
                                     valueInfoSize,
                                     &size
                                     );

        if (!NT_SUCCESS(status)) {
            if (status == STATUS_BUFFER_OVERFLOW || status == STATUS_BUFFER_TOO_SMALL) {
                //
                // All out data is of fixed length and the buffer is big enough
                // so this can't be for us.
                //

                continue;
            } else {
                goto cleanup;
            }
        }

        //
        // Get pointer to the data if its of the right type
        //

        if ((valueInfo->Type == REG_BINARY) &&
            (valueInfo->DataLength == sizeof(ULONGLONG))) {
            data = *(ULONGLONG UNALIGNED *)(((PUCHAR)valueInfo) + valueInfo->DataOffset);
        } else {
            //
            // We only deal in ULONGLONGs
            //

            continue;
        }

        //
        // Now see if the name is formatted like we expect it to be:
        // VVVVDDDD
        // VVVVDDDDRR
        // VVVVDDDDSSSSssss
        // VVVVDDDDSSSSssssRR

        if ((valueInfo->NameLength != HACKFMT_VENDORDEV) &&
            (valueInfo->NameLength != HACKFMT_VENDORDEVREVISION) &&
            (valueInfo->NameLength != HACKFMT_SUBSYSTEM) &&
            (valueInfo->NameLength != HACKFMT_SUBSYSTEMREVISION)) {

            //
            // This isn't ours
            //

            PciDebugPrint(
                PciDbgInformative,
                "Skipping hack entry with invalid length name\n"
                );

            continue;
        }


        //
        // This looks plausable - try to parse it and fill in a hack table
        // entry
        //

        RtlZeroMemory(entry, sizeof(PCI_HACK_TABLE_ENTRY));

        //
        // Look for DeviceID and VendorID (VVVVDDDD)
        //

        if (!PciStringToUSHORT(valueInfo->Name, &entry->VendorID)) {
            continue;
        }

        if (!PciStringToUSHORT(valueInfo->Name + HACKFMT_DEVICE_OFFSET,
                               &entry->DeviceID)) {
            continue;
        }


        //
        // Look for SubsystemVendorID/SubSystemID (SSSSssss)
        //

        if ((valueInfo->NameLength == HACKFMT_SUBSYSTEM) ||
            (valueInfo->NameLength == HACKFMT_SUBSYSTEMREVISION)) {

            if (!PciStringToUSHORT(valueInfo->Name + HACKFMT_SUBVENDOR_OFFSET,
                                   &entry->SubVendorID)) {
                continue;
            }

            if (!PciStringToUSHORT(valueInfo->Name + HACKFMT_SUBSYSTEM_OFFSET,
                                   &entry->SubSystemID)) {
                continue;
            }

            entry->Flags |= PCI_HACK_FLAG_SUBSYSTEM;
        }

        //
        // Look for RevisionID (RR)
        //

        if ((valueInfo->NameLength == HACKFMT_VENDORDEVREVISION) ||
            (valueInfo->NameLength == HACKFMT_SUBSYSTEMREVISION)) {
            if (PciStringToUSHORT(valueInfo->Name +
                                   (valueInfo->NameLength/sizeof(WCHAR) - 4), &temp)) {
                entry->RevisionID = (UCHAR)temp & 0xFF;
                entry->Flags |= PCI_HACK_FLAG_REVISION;
            } else {
                continue;
            }
        }

        PCI_ASSERT(entry->VendorID != 0xFFFF);

        //
        // Fill in the entry
        //

        entry->HackFlags = data;

        PciDebugPrint(
            PciDbgInformative,
            "Adding Hack entry for Vendor:0x%04x Device:0x%04x ",
            entry->VendorID, entry->DeviceID
            );

        if (entry->Flags & PCI_HACK_FLAG_SUBSYSTEM) {
            PciDebugPrint(
                PciDbgInformative,
                "SybSys:0x%04x SubVendor:0x%04x ",
                entry->SubSystemID, entry->SubVendorID
                );
        }

        if (entry->Flags & PCI_HACK_FLAG_REVISION) {
            PciDebugPrint(
                PciDbgInformative,
                "Revision:0x%02x",
                (ULONG) entry->RevisionID
                );
        }

        PciDebugPrint(
            PciDbgInformative,
            " = 0x%I64x\n",
            entry->HackFlags
            );

        entry++;
    }

    PCI_ASSERT(entry < (PciHackTable + hackCount + 1));

    //
    // Terminate the table with an invalid VendorID
    //

    entry->VendorID = 0xFFFF;

    ExFreePool(valueInfo);

    return STATUS_SUCCESS;

cleanup:

    PCI_ASSERT(!NT_SUCCESS(status));

    if (keyInfo) {
        ExFreePool(keyInfo);
    }

    if (valueInfo) {
        ExFreePool(valueInfo);
    }

    if (PciHackTable) {
        ExFreePool(PciHackTable);
        PciHackTable = NULL;
    }

    return status;

}

NTSTATUS
PciGetIrqRoutingTableFromRegistry(
    PPCI_IRQ_ROUTING_TABLE *RoutingTable
    )
/*++

Routine Description:

    Retrieve the IRQ routing table from the registry if present so it
    can be used to determine the UI Number (slot #) that will be used
    later when answering capabilities queries on the PDOs.

    Searches HKLM\Hardware\Description\System\MultiFunctionAdapter for
    a subkey with an "Identifier" value equal to "PCI BIOS".  It then looks at
    "RealModeIrqRoutingTable\0" from this subkey to find actual irq routing
    table value.  This value has a CM_FULL_RESOURCE_DESCRIPTOR in front of it.

    Hals that suppirt irq routing tables have a similar routine.

Arguments:

    RoutingTable - Pointer to a pointer to the routing table returned if any

Return Value:

    NTSTATUS - failure indicates inability to get irq routing table
    information from the registry.

--*/
{
    PUCHAR irqTable = NULL;
    PKEY_FULL_INFORMATION multiKeyInformation = NULL;
    PKEY_BASIC_INFORMATION keyInfo = NULL;
    PKEY_VALUE_PARTIAL_INFORMATION identifierValueInfo = NULL;
    UNICODE_STRING unicodeString;
    HANDLE keyMultifunction = NULL, keyTable = NULL;
    ULONG i, length, maxKeyLength, identifierValueLen;
    BOOLEAN result;
    NTSTATUS status;

    //
    // Open the multifunction key
    //
    result = PciOpenKey(KEY_MULTIFUNCTION,
                        NULL,
                        KEY_READ,
                        &keyMultifunction,
                        &status);
    if (!result) {
        goto Cleanup;
    }

    //
    // Do allocation of buffers up front
    //

    //
    // Determine maximum size of a keyname under the multifunction key
    //
    status = ZwQueryKey(keyMultifunction,
                        KeyFullInformation,
                        NULL,
                        sizeof(multiKeyInformation),
                        &length);
    if (status != STATUS_BUFFER_TOO_SMALL) {
        goto Cleanup;
    }
    multiKeyInformation = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, length);
    if (multiKeyInformation == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    status = ZwQueryKey(keyMultifunction,
                        KeyFullInformation,
                        multiKeyInformation,
                        length,
                        &length);
    if (!NT_SUCCESS(status)) {
        goto Cleanup;
    }
    // includes space for a terminating null that will be added later.
    maxKeyLength = multiKeyInformation->MaxNameLen +
        sizeof(KEY_BASIC_INFORMATION) + sizeof(WCHAR);

    //
    // Allocate buffer used for storing subkeys that we are enumerated
    // under multifunction.
    //
    keyInfo = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, maxKeyLength);
    if (keyInfo == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Allocate buffer large enough to store a value containing REG_SZ
    // 'PCI BIOS'.  We hope to find such a value under one of the
    // multifunction subkeys
    //
    identifierValueLen = sizeof(PCIIR_IDENTIFIER) +
        sizeof(KEY_VALUE_PARTIAL_INFORMATION);
    identifierValueInfo = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, identifierValueLen);
    if (identifierValueInfo == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Enumerate subkeys of multifunction key looking for keys with an
    // Identifier value of "PCI BIOS".  If we find one, look for the
    // irq routing table in the tree below.
    //
    i = 0;
    do {
        status = ZwEnumerateKey(keyMultifunction,
                                i,
                                KeyBasicInformation,
                                keyInfo,
                                maxKeyLength,
                                &length);
        if (NT_SUCCESS(status)) {
            //
            // Found a key, now we need to open it and check the
            // 'Identifier' value to see if it is 'PCI BIOS'
            //
            keyInfo->Name[keyInfo->NameLength / sizeof(WCHAR)] = UNICODE_NULL;
            result = PciOpenKey(keyInfo->Name,
                                keyMultifunction,
                                KEY_READ,
                                &keyTable,
                                &status);
            if (result) {
                //
                // Checking 'Identifier' value to see if it contains 'PCI BIOS'
                //
                RtlInitUnicodeString(&unicodeString, VALUE_IDENTIFIER);
                status = ZwQueryValueKey(keyTable,
                                         &unicodeString,
                                         KeyValuePartialInformation,
                                         identifierValueInfo,
                                         identifierValueLen,
                                         &length);
                if (NT_SUCCESS(status) &&
                    RtlEqualMemory((PCHAR)identifierValueInfo->Data,
                                   PCIIR_IDENTIFIER,
                                   identifierValueInfo->DataLength))
                {
                    //
                    // This is the PCI BIOS key.  Try to get PCI IRQ
                    // routing table.  This is the key we were looking
                    // for so regardless of succss, break out.
                    //

                    status = PciGetRegistryValue(VALUE_CONFIGURATION_DATA,
                                                 KEY_IRQ_ROUTING_TABLE,
                                                 keyTable,
                                                 REG_FULL_RESOURCE_DESCRIPTOR,
                                                 &irqTable,
                                                 &length);
                    ZwClose(keyTable);
                    break;
                }
                ZwClose(keyTable);
            }
        } else {
            //
            // If not NT_SUCCESS, only alowable value is
            // STATUS_NO_MORE_ENTRIES,... otherwise, someone
            // is playing with the keys as we enumerate
            //
            PCI_ASSERT(status == STATUS_NO_MORE_ENTRIES);
            break;
        }
        i++;
    
    } while (status != STATUS_NO_MORE_ENTRIES);

    if (NT_SUCCESS(status) && irqTable) {

        //
        // The routing table is stored as a resource and thus we need
        // to trim off the CM_FULL_RESOURCE_DESCRIPTOR that
        // lives in front of the actual table.
        //

        //
        // Perform sanity checks on the table.
        //

        if (length < (sizeof(CM_FULL_RESOURCE_DESCRIPTOR) +
                      sizeof(PCI_IRQ_ROUTING_TABLE))) {
            ExFreePool(irqTable);
            status = STATUS_UNSUCCESSFUL;
            goto Cleanup;
        }

        length -= sizeof(CM_FULL_RESOURCE_DESCRIPTOR);

        if (((PPCI_IRQ_ROUTING_TABLE) (irqTable + sizeof(CM_FULL_RESOURCE_DESCRIPTOR)))->TableSize > length) {
            ExFreePool(irqTable);
            status = STATUS_UNSUCCESSFUL;
            goto Cleanup;
        }

        //
        // Create a new table minus the header.
        //
        *RoutingTable = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, length);
        if (*RoutingTable) {

            RtlMoveMemory(*RoutingTable,
                          ((PUCHAR) irqTable) + sizeof(CM_FULL_RESOURCE_DESCRIPTOR),
                          length);
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
        ExFreePool(irqTable);
    }

 Cleanup:
    if (identifierValueInfo != NULL) {
        ExFreePool(identifierValueInfo);
    }

    if (keyInfo != NULL) {
        ExFreePool(keyInfo);
    }

    if (multiKeyInformation != NULL) {
        ExFreePool(multiKeyInformation);
    }

    if (keyMultifunction != NULL) {
        ZwClose(keyMultifunction);
    }

    return status;
}

NTSTATUS
PciGetDebugPorts(
    IN HANDLE ServiceHandle
    )
/*++

Routine Description:

    Looks in the PCI service key for debug port info and puts in into
    the PciDebugPorts global table.

Arguments:

    ServiceHandle - handle to the PCI service key passed into DriverEntry
Return Value:

    Status

--*/

{
    NTSTATUS status;
    ULONG index;
    WCHAR indexString[sizeof("999")];
    PULONG buffer = NULL;
    ULONG segment, bus, device, function, length;
    BOOLEAN ok;

    C_ASSERT(MAX_DEBUGGING_DEVICES_SUPPORTED <= 999);

    for (index = 0; index < MAX_DEBUGGING_DEVICES_SUPPORTED; index++) {

        ok = SUCCEEDED(StringCbPrintfW(indexString, sizeof(indexString), L"%d", index));

        ASSERT(ok);

        status = PciGetRegistryValue(L"Bus",
                                     indexString,
                                     ServiceHandle,
                                     REG_DWORD,
                                     &buffer,
                                     &length
                                     );

        if (!NT_SUCCESS(status) || length != sizeof(ULONG)) {
            continue;
        }


        //
        // This is formatted as 31:8 Segment Number, 7:0 Bus Number
        //

        segment = (*buffer & 0xFFFFFF00) >> 8;
        bus = *buffer & 0x000000FF;

        ExFreePool(buffer);
        buffer = NULL;

        status = PciGetRegistryValue(L"Slot",
                                     indexString,
                                     ServiceHandle,
                                     REG_DWORD,
                                     &buffer,
                                     &length
                                     );


        if (!NT_SUCCESS(status) || length != sizeof(ULONG)) {
            goto exit;
        }

        //
        // This is formatted as 7:5 Function Number, 4:0 Device Number
        //

        device = *buffer & 0x0000001F;
        function = (*buffer & 0x000000E0) >> 5;

        ExFreePool(buffer);
        buffer = NULL;


        PciDebugPrint(PciDbgInformative,
                      "Debug device @ Segment %x, %x.%x.%x\n",
                      segment,
                      bus,
                      device,
                      function
                      );
        //
        // We don't currently handle segment numbers for config space...
        //

        PCI_ASSERT(segment == 0);

        PciDebugPorts[index].Bus = bus;
        PciDebugPorts[index].Slot.u.bits.DeviceNumber = device;
        PciDebugPorts[index].Slot.u.bits.FunctionNumber = function;

        //
        // Remember we are using the debug port
        //
        PciDebugPortsCount++;

    }

    status = STATUS_SUCCESS;

exit:

    if (buffer) {
        ExFreePool(buffer);
    }

    return status;
}


NTSTATUS
PciAcpiFindRsdt (
    OUT PACPI_BIOS_MULTI_NODE   *AcpiMulti
    )
{
    PKEY_FULL_INFORMATION multiKeyInformation = NULL;
    PKEY_BASIC_INFORMATION keyInfo = NULL;
    PKEY_VALUE_PARTIAL_INFORMATION identifierValueInfo = NULL;
    UNICODE_STRING unicodeString;
    HANDLE keyMultifunction = NULL, keyTable = NULL;
    PCM_PARTIAL_RESOURCE_LIST prl = NULL;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR prd;
    PACPI_BIOS_MULTI_NODE multiNode;
    ULONG multiNodeSize;
    ULONG i, length, maxKeyLength, identifierValueLen;
    BOOLEAN result;
    NTSTATUS status;

    //
    // Open the multifunction key
    //
    result = PciOpenKey(KEY_MULTIFUNCTION,
                        NULL,
                        KEY_READ,
                        &keyMultifunction,
                        &status);
    if (!result) {
        goto Cleanup;
    }

    //
    // Do allocation of buffers up front
    //

    //
    // Determine maximum size of a keyname under the multifunction key
    //
    status = ZwQueryKey(keyMultifunction,
                        KeyFullInformation,
                        NULL,
                        sizeof(multiKeyInformation),
                        &length);
    if (status != STATUS_BUFFER_TOO_SMALL) {
        goto Cleanup;
    }
    multiKeyInformation = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, length);
    if (multiKeyInformation == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    status = ZwQueryKey(keyMultifunction,
                        KeyFullInformation,
                        multiKeyInformation,
                        length,
                        &length);
    if (!NT_SUCCESS(status)) {
        goto Cleanup;
    }
    // includes space for a terminating null that will be added later.
    maxKeyLength = multiKeyInformation->MaxNameLen +
        sizeof(KEY_BASIC_INFORMATION) + sizeof(WCHAR);

    //
    // Allocate buffer used for storing subkeys that we are enumerated
    // under multifunction.
    //
    keyInfo = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, maxKeyLength);
    if (keyInfo == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Allocate buffer large enough to store a value containing REG_SZ
    // 'ACPI BIOS'.  We hope to find such a value under one of the
    // multifunction subkeys
    //
    identifierValueLen = sizeof(ACPI_BIOS_ID) + sizeof(KEY_VALUE_PARTIAL_INFORMATION);
    identifierValueInfo = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, identifierValueLen);
    if (identifierValueInfo == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Enumerate subkeys of multifunction key looking for keys with an
    // Identifier value of "ACPI BIOS".  If we find one, look for the
    // irq routing table in the tree below.
    //
    i = 0;
    do {
        status = ZwEnumerateKey(keyMultifunction,
                                i,
                                KeyBasicInformation,
                                keyInfo,
                                maxKeyLength,
                                &length);
        if (NT_SUCCESS(status)) {
            //
            // Found a key, now we need to open it and check the
            // 'Identifier' value to see if it is 'ACPI BIOS'
            //
            keyInfo->Name[keyInfo->NameLength / sizeof(WCHAR)] = UNICODE_NULL;
            result = PciOpenKey(keyInfo->Name,
                                keyMultifunction,
                                KEY_READ,
                                &keyTable,
                                &status);
            if (result) {
                //
                // Checking 'Identifier' value to see if it contains 'ACPI BIOS'
                //
                RtlInitUnicodeString(&unicodeString, VALUE_IDENTIFIER);
                status = ZwQueryValueKey(keyTable,
                                         &unicodeString,
                                         KeyValuePartialInformation,
                                         identifierValueInfo,
                                         identifierValueLen,
                                         &length);
                if (NT_SUCCESS(status) &&
                    RtlEqualMemory((PCHAR)identifierValueInfo->Data,
                                   ACPI_BIOS_ID,
                                   identifierValueInfo->DataLength))
                {
                    //
                    // This is the ACPI BIOS key.  Try to get Configuration Data
                    // This is the key we were looking
                    // for so regardless of success, break out.
                    //

                    ZwClose(keyTable);

                    status = PciGetRegistryValue(VALUE_CONFIGURATION_DATA,
                                                 keyInfo->Name,
                                                 keyMultifunction,
                                                 REG_FULL_RESOURCE_DESCRIPTOR,
                                                 &prl,
                                                 &length);

                    break;
                }
                ZwClose(keyTable);
            }
        } else {
            //
            // If not NT_SUCCESS, only alowable value is
            // STATUS_NO_MORE_ENTRIES,... otherwise, someone
            // is playing with the keys as we enumerate
            //
            PCI_ASSERT(status == STATUS_NO_MORE_ENTRIES);
            break;
        }
        i++;
    }
    while (status != STATUS_NO_MORE_ENTRIES);

    if (NT_SUCCESS(status) && prl) {

        prd = &prl->PartialDescriptors[0];
        multiNode = (PACPI_BIOS_MULTI_NODE)((PCHAR) prd + sizeof(CM_PARTIAL_RESOURCE_LIST));

        multiNodeSize = sizeof(ACPI_BIOS_MULTI_NODE) + ((ULONG)(multiNode->Count - 1) * sizeof(ACPI_E820_ENTRY));

        *AcpiMulti = (PACPI_BIOS_MULTI_NODE) ExAllocatePool(NonPagedPool,multiNodeSize);
        if (*AcpiMulti == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        RtlCopyMemory(*AcpiMulti, multiNode, multiNodeSize);
    }

 Cleanup:
    if (identifierValueInfo != NULL) {
        ExFreePool(identifierValueInfo);
    }

    if (keyInfo != NULL) {
        ExFreePool(keyInfo);
    }

    if (multiKeyInformation != NULL) {
        ExFreePool(multiKeyInformation);
    }

    if (keyMultifunction != NULL) {
        ZwClose(keyMultifunction);
    }

    if (prl) {
        ExFreePool(prl);
    }

    return status;
}

PVOID
PciGetAcpiTable(
  IN  ULONG  Signature
  )
/*++

  Routine Description:

      This routine will retrieve any table referenced in the ACPI
      RSDT.

  Arguments:

      Signature - Target table signature

  Return Value:

      pointer to a copy of the table, or NULL if not found

--*/
{
  PACPI_BIOS_MULTI_NODE multiNode;
  NTSTATUS status;
  ULONG entry, rsdtEntries;
  PDESCRIPTION_HEADER header;
  PHYSICAL_ADDRESS physicalAddr;
  PRSDT rsdt;
  ULONG rsdtSize;
  PVOID table = NULL;


  //
  // Get the physical address of the RSDT from the Registry
  //

  status = PciAcpiFindRsdt(&multiNode);

  if (!NT_SUCCESS(status)) {
    DbgPrint("AcpiFindRsdt() Failed!\n");
    return NULL;
  }


  //
  // Map down header to get total RSDT table size
  //

  header = (PDESCRIPTION_HEADER) MmMapIoSpace(multiNode->RsdtAddress, sizeof(DESCRIPTION_HEADER), MmNonCached);

  if (!header) {
    return NULL;
  }

  rsdtSize = header->Length;
  MmUnmapIoSpace(header, sizeof(DESCRIPTION_HEADER));


  //
  // Map down entire RSDT table
  //

  rsdt = (PRSDT) MmMapIoSpace(multiNode->RsdtAddress, rsdtSize, MmNonCached);

  ExFreePool(multiNode);

  if (!rsdt) {
    return NULL;
  }


  //
  // Do a sanity check on the RSDT.
  //

  if ((rsdt->Header.Signature != RSDT_SIGNATURE) &&
      (rsdt->Header.Signature != XSDT_SIGNATURE)) {

    DbgPrint("RSDT table contains invalid signature\n");
    goto GetAcpiTableEnd;
  }


  //
  // Calculate the number of entries in the RSDT.
  //

  rsdtEntries = rsdt->Header.Signature == XSDT_SIGNATURE ?
      NumTableEntriesFromXSDTPointer(rsdt) :
      NumTableEntriesFromRSDTPointer(rsdt);


  //
  // Look down the pointer in each entry to see if it points to
  // the table we are looking for.
  //

  for (entry = 0; entry < rsdtEntries; entry++) {

    if (rsdt->Header.Signature == XSDT_SIGNATURE) {
      physicalAddr = ((PXSDT)rsdt)->Tables[entry];
    } else {
      physicalAddr.HighPart = 0;
      physicalAddr.LowPart = (ULONG)rsdt->Tables[entry];
    }

    //
    // Map down the header, check the signature
    //

    header = (PDESCRIPTION_HEADER) MmMapIoSpace(physicalAddr, sizeof(DESCRIPTION_HEADER), MmNonCached);

    if (!header) {
      goto GetAcpiTableEnd;
    }

    if (header->Signature == Signature) {

      table = ExAllocatePool( PagedPool, header->Length );
      if (table) {
        RtlCopyMemory(table, header, header->Length);
      }

      MmUnmapIoSpace(header, sizeof(DESCRIPTION_HEADER));
      break;
    }

    MmUnmapIoSpace(header, sizeof(DESCRIPTION_HEADER));
  }


GetAcpiTableEnd:

  MmUnmapIoSpace(rsdt, rsdtSize);
  return table;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\ideintrf.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    ideintrf.c

Abstract:

    This module implements the "Pci Native Ide" interfaces supported
    by the PCI driver.

Author:

    Andrew Thornton (andrewth) 1-26-2001

Revision History:

--*/

#include "pcip.h"

VOID
nativeIde_RefDereference(
    IN PVOID Context
    );

NTSTATUS
nativeIde_Constructor(
    IN PVOID DeviceExtension,
    IN PVOID PciInterface,
    IN PVOID InterfaceSpecificData,
    IN USHORT Version,
    IN USHORT Size,
    OUT PINTERFACE InterfaceReturn
    );

NTSTATUS
nativeIde_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    );

VOID
nativeIde_InterruptControl(
    IN PVOID Context,
    IN BOOLEAN Enable
    );


//
// Define the Pci Routing interface "Interface" structure.
//

PCI_INTERFACE PciNativeIdeInterface = {
    &GUID_PCI_NATIVE_IDE_INTERFACE,         // InterfaceType
    sizeof(PCI_NATIVE_IDE_INTERFACE),       // MinSize
    PCI_NATIVE_IDE_INTERFACE_VERSION,       // MinVersion
    PCI_NATIVE_IDE_INTERFACE_VERSION,       // MaxVersion
    PCIIF_PDO,                              // Flags
    0,                                      // ReferenceCount
    PciInterface_NativeIde,                 // Signature
    nativeIde_Constructor,                  // Constructor
    nativeIde_Initializer                   // Instance Initializer
};


VOID
nativeIde_RefDereference(
    IN PVOID Context
    )
{
    return;
}

NTSTATUS
nativeIde_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    )

/*++

Routine Description:

    Initialize the PCI_NATIVE_IDE_INTERFACE fields.

Arguments:

    DeviceExtension - Extension of the device
    
    PciInterface    Pointer to the PciInterface record for this
                    interface type.
    
    InterfaceSpecificData - from the QUERY_INTERFACE irp

    Version - Version of the interface requested
    
    Size - Size of the buffer 
    
    InterfaceReturn - Buffer to return the interface in

Return Value:

    Status

--*/

{
    PPCI_NATIVE_IDE_INTERFACE interface = (PPCI_NATIVE_IDE_INTERFACE)InterfaceReturn;
    PPCI_PDO_EXTENSION pdo = DeviceExtension;

    ASSERT_PCI_PDO_EXTENSION(pdo);

    if (!PCI_IS_NATIVE_CAPABLE_IDE_CONTROLLER(pdo)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    interface->Size = sizeof(PCI_NATIVE_IDE_INTERFACE);
    interface->Context = DeviceExtension;
    interface->Version = PCI_NATIVE_IDE_INTERFACE_VERSION;
    interface->InterfaceReference = nativeIde_RefDereference;
    interface->InterfaceDereference = nativeIde_RefDereference;

    interface->InterruptControl = nativeIde_InterruptControl;
    
    return STATUS_SUCCESS;
}

NTSTATUS
nativeIde_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    )
/*++

Routine Description:

    For bus interface, does nothing, shouldn't actually be called.

Arguments:

    Instance        Pointer to the PDO extension.

Return Value:

    Returns the status of this operation.

--*/

{
    PCI_ASSERTMSG("PCI nativeide_Initializer, unexpected call.", 0);

    return STATUS_UNSUCCESSFUL;
}


VOID
nativeIde_InterruptControl(
    IN PVOID Context,
    IN BOOLEAN Enable
    )
/*++


Routine Description:

    Controls the enabling and disabling of native mode PCI IDE controllers
    IoSpaceEnable bits which on some controllers (currently Intel ICH3)
    will mask off interrupt generation and this prevent the system from 
    crashing...
    
Arguments:

    Context - Context from the PCI_NATIVE_IDE_INTERFACE
    
    Enable - If TRUE then set the IoSpaceEnable bit in the command register,
             otherwise disable it.


Return Value:

    None - if this operation fails we have aleady bugchecked in the PCI driver


    N.B. This function is called from with an ISR and this must be callable at
    DEVICE_LEVEL

--*/
{
    PPCI_PDO_EXTENSION pdo = Context;
    USHORT command;
    
    //
    // Remember we gave the IDE driver control of this
    //
    pdo->IoSpaceUnderNativeIdeControl = TRUE;

    PciReadDeviceConfig(pdo, 
                        &command, 
                        FIELD_OFFSET(PCI_COMMON_CONFIG, Command), 
                        sizeof(command)
                        );

    if (Enable) {
        command |= PCI_ENABLE_IO_SPACE;
        pdo->CommandEnables |= PCI_ENABLE_IO_SPACE;
    } else {
        command &= ~PCI_ENABLE_IO_SPACE;
        pdo->CommandEnables &= ~PCI_ENABLE_IO_SPACE; 
    }

    PciWriteDeviceConfig(pdo, 
                         &command, 
                         FIELD_OFFSET(PCI_COMMON_CONFIG, Command), 
                         sizeof(command)
                         );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\hookhal.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    hookhal.c

Abstract:

    The module overrides the Hal functions that are now controlled by the
    PCI driver.

Author:

    Andrew Thornton (andrewth) 11-Sept-1998

Revision History:

--*/

#include "pcip.h"

pHalAssignSlotResources PcipSavedAssignSlotResources = NULL;
pHalTranslateBusAddress PcipSavedTranslateBusAddress = NULL;

BOOLEAN
PciTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

VOID
PciHookHal(
    VOID
    )
/*++

Routine Description:

    This is called when the PCI driver is loaded and it takes over the functions
    that have traditionally been in the HAL.

Arguments:

    None

Return Value:

    None

--*/

{

    PCI_ASSERT(PcipSavedAssignSlotResources == NULL);
    PCI_ASSERT(PcipSavedTranslateBusAddress == NULL);

    //
    // Override the handlers for AssignSlotResources and
    // TranslateBusAddress.  (But only modify the HAL dispatch
    // table once.)
    //

    PcipSavedAssignSlotResources = HALPDISPATCH->HalPciAssignSlotResources;
    HALPDISPATCH->HalPciAssignSlotResources = PciAssignSlotResources;
    PcipSavedTranslateBusAddress = HALPDISPATCH->HalPciTranslateBusAddress;
    HALPDISPATCH->HalPciTranslateBusAddress = PciTranslateBusAddress;
}

VOID
PciUnhookHal(
    VOID
    )

/*++

Routine Description:

    This reverses the changed made by PciHookHal.  It is called as part of
    unloading the PCI driver which seems like a really bad idea...

Arguments:

    None

Return Value:

    None

--*/

{

    PCI_ASSERT(PcipSavedAssignSlotResources != NULL);
    PCI_ASSERT(PcipSavedTranslateBusAddress != NULL);

    //
    // Override the handlers for AssignSlotResources and
    // TranslateBusAddress.  (But only modify the HAL dispatch
    // table once.)
    //

    HALPDISPATCH->HalPciAssignSlotResources = PcipSavedAssignSlotResources;
    HALPDISPATCH->HalPciTranslateBusAddress = PcipSavedTranslateBusAddress;

    PcipSavedAssignSlotResources = NULL;
    PcipSavedTranslateBusAddress = NULL;
}


PPCI_PDO_EXTENSION
PciFindPdoByLocation(
    IN ULONG BusNumber,
    IN PCI_SLOT_NUMBER Slot
    )
/*++

Routine Description:


Arguments:

    BusNumber - the bus number of the bus the device is on
    Slot - the device/function of the device

Return Value:

    The PDO or NULL if one can not be found

--*/


{
    PSINGLE_LIST_ENTRY nextEntry;
    PPCI_FDO_EXTENSION fdoExtension = NULL;
    PPCI_PDO_EXTENSION pdoExtension = NULL;

    ExAcquireFastMutex(&PciGlobalLock);

    //
    // Find the bus FDO.
    //

    for ( nextEntry = PciFdoExtensionListHead.Next;
          nextEntry != NULL;
          nextEntry = nextEntry->Next ) {

        fdoExtension = CONTAINING_RECORD(nextEntry,
                                         PCI_FDO_EXTENSION,
                                         List);

        if (fdoExtension->BaseBus == BusNumber) {
            break;
        }
    }

    ExReleaseFastMutex(&PciGlobalLock);

    if (nextEntry == NULL) {

        //
        // This is bad.
        //

        PciDebugPrint(PciDbgAlways, "Pci: Could not find PCI bus FDO. Bus Number = 0x%x\n", BusNumber);
        goto cleanup;
    }

    //
    // Now find the pdo for the device in this slot
    //

    ExAcquireFastMutex(&fdoExtension->ChildListMutex);
    for (pdoExtension = fdoExtension->ChildPdoList;
         pdoExtension;
         pdoExtension = pdoExtension->Next) {

        //
        // People probably don't clear the unused bits in a PCI_SLOT_NUMBER so
        // ignore them in the main build but assert checked so we can get this
        // fixed
        //

        if (pdoExtension->Slot.u.bits.DeviceNumber == Slot.u.bits.DeviceNumber
        &&  pdoExtension->Slot.u.bits.FunctionNumber == Slot.u.bits.FunctionNumber) {

            PCI_ASSERT(pdoExtension->Slot.u.AsULONG == Slot.u.AsULONG);

            //
            // This is our guy!
            //

            break;
        }
    }
    ExReleaseFastMutex(&fdoExtension->ChildListMutex);

    if (pdoExtension == NULL) {

        //
        // This is bad.
        //

        PciDebugPrint(PciDbgAlways,
                      "Pci: Could not find PDO for device @ %x.%x.%x\n",
                      BusNumber,
                      Slot.u.bits.DeviceNumber,
                      Slot.u.bits.FunctionNumber
                      );

        goto cleanup;
    }

    return pdoExtension;

cleanup:

    return NULL;

}

NTSTATUS
PciAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    Slot,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    )
/*++

Routine Description:

    This subsumes the the functinality of HalAssignSlotResources for PCI devices.

    This function builds some bookkeeping information about legacy
    PCI device so that we know how to route interrupts for these
    PCI devices.  We build this here because this is the only place
    we see the legacy device object associated with proper bus, slot,
    function information.

Arguments:

    As HalAssignSlotResources

Return Value:

    STATUS_SUCCESS or error

--*/
{
    NTSTATUS status;
    PPCI_PDO_EXTENSION pdoExtension;
    PPCI_SLOT_NUMBER slotNumber = (PPCI_SLOT_NUMBER) &Slot;
    PCI_COMMON_HEADER buffer;
    PPCI_COMMON_CONFIG commonConfig = (PPCI_COMMON_CONFIG) &buffer;
    PIO_RESOURCE_REQUIREMENTS_LIST requirements = NULL;
    PCM_RESOURCE_LIST resources = NULL;
    ULONG readIndex, writeIndex;
    PCM_PARTIAL_RESOURCE_LIST partialList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptors;
    ULONG descriptorCount;
    PDEVICE_OBJECT  oldDO;

    PAGED_CODE();
    PCI_ASSERT(PcipSavedAssignSlotResources);
    
    //
    // We should only ever get here if this is a request for a PCI device
    //

    if (BusType != PCIBus) {
        ASSERT(BusType == PCIBus);
        return STATUS_INVALID_PARAMETER;
    }

    *AllocatedResources = NULL;

    pdoExtension = PciFindPdoByLocation(BusNumber, *slotNumber);
    if (!pdoExtension) {
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    if (pdoExtension->DeviceState != PciNotStarted) {
         
        return STATUS_INVALID_OWNER;
    }

    //
    // Grab the PciGlobalLock since we will modify the legacy cache.
    //

    ExAcquireFastMutex(&PciGlobalLock);

    //
    // Make sure that they didn't pass us in our PDO
    //

    PCI_ASSERT(DeviceObject != pdoExtension->PhysicalDeviceObject);

    PciReadDeviceConfig(
        pdoExtension,
        commonConfig,
        0,
        PCI_COMMON_HDR_LENGTH
        );

    //
    // Cache everything we have now learned about this
    // device object provided that they gave us one so that we can regurgitate
    // it when the IRQ arbiter needs to know.
    //
    //
    // NTRAID #62644 - 4/20/2000 - andrewth
    //
    // This should go away when we return the real PCI pdo
    // from IoReportDetectedDevice
    //

    status = PciCacheLegacyDeviceRouting(
            DeviceObject,
            BusNumber,
            Slot,
            commonConfig->u.type0.InterruptLine,
            commonConfig->u.type0.InterruptPin,
            commonConfig->BaseClass,
            commonConfig->SubClass,
            PCI_PARENT_FDOX(pdoExtension)->PhysicalDeviceObject,
            pdoExtension,
            &oldDO
            );
    if (!NT_SUCCESS(status)) {

        //
        // We failed to allocate memory while trying to cache this legacy DO.
        //

        goto ExitWithoutUpdatingCache;
    }

    //
    // Build a requirements list for this device
    //

    status = PciBuildRequirementsList(pdoExtension,
                                      commonConfig,
                                      &requirements
                                      );

    pdoExtension->LegacyDriver = TRUE;

    if (!NT_SUCCESS(status)) {
        goto ExitWithCacheRestoreOnFailure;
    }

    //
    // Call the legacy API to get the resources
    //

    status = IoAssignResources(RegistryPath,
                               DriverClassName,
                               DriverObject,
                               DeviceObject,
                               requirements,
                               &resources
                               );
    if (!NT_SUCCESS(status)) {
        PCI_ASSERT(resources == NULL);
        goto ExitWithCacheRestoreOnFailure;
    }

    //
    // Enable the decodes
    //

    pdoExtension->CommandEnables |= (PCI_ENABLE_IO_SPACE 
                                   | PCI_ENABLE_MEMORY_SPACE 
                                   | PCI_ENABLE_BUS_MASTER);

    //
    // Set up the extension
    //

    PciComputeNewCurrentSettings(pdoExtension,
                                 resources
                                 );
    //
    // Program the hardware
    //

    status = PciSetResources(pdoExtension,
                             TRUE, // power on
                             TRUE  // pretend its from a start irp
                             );

    if (!NT_SUCCESS(status)) {
        goto ExitWithCacheRestoreOnFailure;
    }

    //
    // Remove the device privates from the list - yes this means that we will
    // have allocated a little more pool than required.
    //

    PCI_ASSERT(resources->Count == 1);

    partialList = &resources->List[0].PartialResourceList;
    descriptorCount = resources->List[0].PartialResourceList.Count;
    descriptors = &resources->List[0].PartialResourceList.PartialDescriptors[0];

    readIndex = 0;
    writeIndex = 0;

    while (readIndex < descriptorCount) {
        if (descriptors[readIndex].Type != CmResourceTypeDevicePrivate) {

            if (writeIndex < readIndex) {

                //
                // Shuffle the descriptor up
                //

                RtlCopyMemory(&descriptors[writeIndex],
                              &descriptors[readIndex],
                              sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
                              );
            }

            writeIndex++;

        } else {

            //
            // Skip the device private, don't increment writeCount so we will
            // overwrite it
            //

            PCI_ASSERT(partialList->Count > 0);
            partialList->Count--;

        }
        readIndex++;
    }

    PCI_ASSERT(partialList->Count > 0);

    *AllocatedResources = resources;
    resources = NULL;
    status = STATUS_SUCCESS;

ExitWithCacheRestoreOnFailure:
    //
    // On failure, restore the old legacy DO in our cache.
    //

    if (!NT_SUCCESS(status)) {

        PciCacheLegacyDeviceRouting(
        oldDO,
        BusNumber,
        Slot,
        commonConfig->u.type0.InterruptLine,
        commonConfig->u.type0.InterruptPin,
        commonConfig->BaseClass,
        commonConfig->SubClass,
        PCI_PARENT_FDOX(pdoExtension)->PhysicalDeviceObject,
        pdoExtension,
        NULL
        );

    }

ExitWithoutUpdatingCache:
    ExReleaseFastMutex(&PciGlobalLock);

    if (requirements) {
        ExFreePool(requirements);
    }

    if (resources) {
        ExFreePool(resources);
    }
    return status;

}


BOOLEAN
PciTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )

/*++

Routine Description:

    This subsumes the the functinality of HalTranslateBusAddress for PCI devices.

Arguments:

    As HalTranslateBusAddress

Return Value:

    TRUE if translation succeeded, FALSE otherwise.

--*/


{
    PPCI_FDO_EXTENSION fdoExtension = NULL;
    PSINGLE_LIST_ENTRY nextEntry;
    ULONG savedAddressSpace;
    PPCI_PDO_EXTENSION pdoExtension = NULL;
    BOOLEAN translatesOk = TRUE;
    PPCI_ARBITER_INSTANCE pciArbiter;
    PCI_SIGNATURE arbiterType;
    PARBITER_INSTANCE arbiter;
    RTL_RANGE_LIST_ITERATOR iterator;
    PRTL_RANGE current;
    ULONGLONG address = (ULONGLONG) BusAddress.QuadPart;

    //
    // HalTranslateBusAddress can be called at high IRQL (the DDK says
    // <= DISPATCH_LEVEL) but crash dump seems to be at HIGH_LEVEL.  Either way
    // touching pageable data and code is a no no.  If we are calling at high
    // IRQL then just skip the validation that the range is on the bus as we are
    // crashing/hibernating at the time anyway...  We still need to call the
    // original hal function to perform the translation magic.
    //

    if (KeGetCurrentIrql() < DISPATCH_LEVEL) {

        //
        // Find the FDO for this bus
        //

        ExAcquireFastMutex(&PciGlobalLock);

        for ( nextEntry = PciFdoExtensionListHead.Next;
              nextEntry != NULL;
              nextEntry = nextEntry->Next ) {

            fdoExtension = CONTAINING_RECORD(nextEntry,
                                             PCI_FDO_EXTENSION,
                                             List);

            if (fdoExtension->BaseBus == BusNumber) {
                break;
            }
        }

        if (nextEntry == NULL) {

            //
            // This is bad.
            //

            PciDebugPrint(PciDbgAlways, "Pci: Could not find PCI bus FDO. Bus Number = 0x%x\n", BusNumber);
            ExReleaseFastMutex(&PciGlobalLock);
            return FALSE;
        }


        for (;;) {

            if (!PCI_IS_ROOT_FDO(fdoExtension)) {

                pdoExtension = PCI_BRIDGE_PDO(fdoExtension);

                if (pdoExtension->Dependent.type1.SubtractiveDecode) {

                    //
                    // It is subtractive go up a level, rinse and repeat
                    //

                    fdoExtension = PCI_PARENT_FDOX(pdoExtension);
                    continue;
                }
            }
            break;
        }

        ExReleaseFastMutex(&PciGlobalLock);

        PCI_ASSERT(fdoExtension);

        //
        // Find the appropriate arbiter
        //

        switch (*AddressSpace) {
        case 0: // Memory space
        case 2: // UserMode view of memory space (Alpha)
        case 4: // Dense memory space (Alpha)
        case 6: // UserMode view of dense memory space (Alpha)
            arbiterType = PciArb_Memory;
            break;

        case 1: // Port space
        case 3: // UserMode view of port space (Alpha)
            arbiterType = PciArb_Io;
            break;

        default:

            PCI_ASSERT(FALSE);
            return FALSE;
        }

        pciArbiter = PciFindSecondaryExtension(fdoExtension,arbiterType);

        if (!pciArbiter) {
            PCI_ASSERT(FALSE);
            return FALSE;
        }

        arbiter = &pciArbiter->CommonInstance;

        //
        // Lock it
        //

        ArbAcquireArbiterLock(arbiter);

        //
        // If the range is not owned by NULL then it should translate
        //

        FOR_ALL_RANGES(arbiter->Allocation, &iterator, current) {

            if (address < current->Start) {
                //
                // We have passed all possible intersections
                //
                break;
            }

            if (INTERSECT(current->Start, current->End, address, address)
            &&  current->Owner == NULL) {

                //
                // This guy is not on our bus so he doesn't translate!
                //
                translatesOk = FALSE;
                break;
            }


        }

        ArbReleaseArbiterLock(arbiter);
    }

    //
    // Call the original HAL function to perform the translation magic
    //

    savedAddressSpace = *AddressSpace;

    if (translatesOk) {

            translatesOk = PcipSavedTranslateBusAddress(
                            InterfaceType,
                            BusNumber,
                            BusAddress,
                            AddressSpace,
                            TranslatedAddress
                            );

    }

#if defined(_X86_) && defined(PCI_NT50_BETA1_HACKS)

    if (!translatesOk) {

        //
        // HalTranslateBusAddress failed, figure out if we want to
        // pretend it succeeded.
        //

        //
        // GROSS HACK:  If we failed to translate in the range 0xa0000
        // thru 0xbffff on an X86 machine, just go ahead and allow it.
        // It is probably because the BIOS is buggy.
        //
        // Same for 0x400 thru 0x4ff
        //

        if (BusAddress.HighPart == 0) {

            ULONG lowPart = BusAddress.LowPart; // improve code generation

            if (((savedAddressSpace == ADDRESS_SPACE_MEMORY) &&
                    (((lowPart >= 0xa0000) &&     // HACK broken MPS BIOS
                      (lowPart <= 0xbffff)) ||    //
                     ((lowPart >= 0x400)   &&     // HACK MGA
                      (lowPart <= 0x4ff))   ||    //
                     (lowPart == 0x70)      )) || // HACK Trident
                 ((savedAddressSpace == ADDRESS_SPACE_PORT) &&
                     ((lowPart >= 0xcf8) &&       // HACK MGA
                      (lowPart <= 0xcff)))) {

                translatesOk = TRUE;
                *TranslatedAddress = BusAddress;
                *AddressSpace = savedAddressSpace;
            }
        }
    }

#endif

    return translatesOk;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\intrface.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    interface.c

Abstract:

    IRP_MN_QUERY_INTERFACE lives here.

Author:

    Peter Johnston (peterj)  31-Mar-1997

Revision History:

--*/

#include "pcip.h"


NTSTATUS
PciGetBusStandardInterface(
    IN PDEVICE_OBJECT Pdo,
    OUT PBUS_INTERFACE_STANDARD BusInterface
    );

extern PCI_INTERFACE ArbiterInterfaceBusNumber;
extern PCI_INTERFACE ArbiterInterfaceMemory;
extern PCI_INTERFACE ArbiterInterfaceIo;
extern PCI_INTERFACE TranslatorInterfaceInterrupt;
extern PCI_INTERFACE TranslatorInterfaceMemory;
extern PCI_INTERFACE TranslatorInterfaceIo;
extern PCI_INTERFACE BusHandlerInterface;
extern PCI_INTERFACE PciRoutingInterface;
extern PCI_INTERFACE PciCardbusPrivateInterface;
extern PCI_INTERFACE PciLegacyDeviceDetectionInterface;
extern PCI_INTERFACE PciPmeInterface;
extern PCI_INTERFACE PciDevicePresentInterface;
extern PCI_INTERFACE PciNativeIdeInterface;
extern PCI_INTERFACE PciLocationInterface;
extern PCI_INTERFACE AgpTargetInterface;

PPCI_INTERFACE PciInterfaces[] = {
    &ArbiterInterfaceBusNumber,
    &ArbiterInterfaceMemory,
    &ArbiterInterfaceIo,
    &BusHandlerInterface,
    &PciRoutingInterface,
    &PciCardbusPrivateInterface,
    &PciLegacyDeviceDetectionInterface,
    &PciPmeInterface,
    &PciDevicePresentInterface,
    &PciNativeIdeInterface,
    &PciLocationInterface,
    &AgpTargetInterface,
    NULL
};

//
// These are the interfaces we supply only if nobody underneath
// us (the HAL) does.
//
PPCI_INTERFACE PciInterfacesLastResort[] = {
    &TranslatorInterfaceInterrupt,
    NULL
};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PciQueryInterface)
#pragma alloc_text(PAGE, PciGetBusStandardInterface)
#endif

NTSTATUS
PciGetBusStandardInterface(
    IN PDEVICE_OBJECT Pdo,
    OUT PBUS_INTERFACE_STANDARD BusInterface
    )
/*++

Routine Description:

    This routine gets the bus iterface standard information from the PDO.

Arguments:

    Pdo - Physical device object to query for this information.

    BusInterface - Supplies a pointer for the retrived information.

Return Value:

    NT status.

--*/
{
    KEVENT event;
    NTSTATUS status;
    PIRP irp;
    IO_STATUS_BLOCK ioStatusBlock;
    PIO_STACK_LOCATION irpStack;

    PciDebugPrint(
        PciDbgObnoxious,
        "PCI - PciGetBusStandardInterface entered.\n"
        );

    KeInitializeEvent( &event, NotificationEvent, FALSE );

    irp = IoBuildSynchronousFsdRequest( IRP_MJ_PNP,
                                        Pdo,
                                        NULL,
                                        0,
                                        NULL,
                                        &event,
                                        &ioStatusBlock );

    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack = IoGetNextIrpStackLocation( irp );
    irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
    irpStack->Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_BUS_INTERFACE_STANDARD;
    irpStack->Parameters.QueryInterface.Size = sizeof( BUS_INTERFACE_STANDARD );
    irpStack->Parameters.QueryInterface.Version = 1;
    irpStack->Parameters.QueryInterface.Interface = (PINTERFACE) BusInterface;
    irpStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Initialize the status to error in case the ACPI driver decides not to
    // set it correctly.
    //

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;


    status = IoCallDriver( Pdo, irp );

    if (!NT_SUCCESS( status)) {
        PciDebugPrint(
            PciDbgVerbose,
            "PCI - PciGetBusStandardInterface IoCallDriver returned %08x.\n",
            status
            );

        return status;
    }

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL );
    }

    PciDebugPrint(
        PciDbgVerbose,
        "PCI - PciGetBusStandardInterface returning status %08x.\n",
        ioStatusBlock.Status
        );

    return ioStatusBlock.Status;

}


NTSTATUS
PciQueryInterface(
    IN PVOID DeviceExtension,
    IN PGUID InterfaceType,
    IN USHORT Size,
    IN USHORT Version,
    IN PVOID InterfaceSpecificData,
    IN OUT PINTERFACE InterfaceReturn,
    IN BOOLEAN LastChance
    )
{
    PPCI_INTERFACE *interfaceEntry;
    PPCI_INTERFACE interface;
    PPCI_INTERFACE *interfaceTable;
    BOOLEAN isPdo;
    NTSTATUS status;

#if DBG

    UNICODE_STRING guidString;

    status = RtlStringFromGUID(InterfaceType, &guidString);

    if (NT_SUCCESS(status)) {
        PciDebugPrint(
            PciDbgVerbose,
            "PCI - PciQueryInterface TYPE = %wZ\n",
            &guidString
            );
        RtlFreeUnicodeString(&guidString);

        PciDebugPrint(
            PciDbgObnoxious,
            "      Size = %d, Version = %d, InterfaceData = %x, LastChance = %s\n",
            Size,
            Version,
            InterfaceSpecificData,
            LastChance ? "TRUE" : "FALSE"
            );
    }

#endif

    isPdo = (BOOLEAN)(((PPCI_PDO_EXTENSION)DeviceExtension)->ExtensionType
                == PciPdoExtensionType);

    //
    // Try to locate the requested interface in the PCI driver's set
    // of exported interfaces.
    //
    // Note - we do not allow last chance interfaces (ie mock translators) for
    // machines where we assign bus numbers
    //
    if (LastChance) {

        interfaceTable = PciInterfacesLastResort;
    } else {
        interfaceTable = PciInterfaces;
    }

    for (interfaceEntry = interfaceTable; *interfaceEntry; interfaceEntry++) {

        interface = *interfaceEntry;

#if 0
        status = RtlStringFromGUID(interface->InterfaceType, &guidString);
        if (NT_SUCCESS(status)) {
            PciDebugPrint(
                PciDbgVerbose,
                "PCI - PciQueryInterface looking at guid = %wZ\n",
                &guidString
                );
            RtlFreeUnicodeString(&guidString);
        }
#endif

        //
        // Check if this interface is allowed to be used from this
        // device object type.
        //

        if (isPdo) {

            if ((interface->Flags & PCIIF_PDO) == 0) {

                //
                // This interface cannot be used from a PDO.
                //
#if DBG
                status = RtlStringFromGUID(interface->InterfaceType, &guidString);
                if (NT_SUCCESS(status)) {
                    PciDebugPrint(
                        PciDbgVerbose,
                        "PCI - PciQueryInterface: guid = %wZ only for PDOs\n",
                        &guidString
                        );
                    RtlFreeUnicodeString(&guidString);
                }
#endif
                continue;

            }

        } else {

            //
            // Allowable from FDO?
            //

            if ((interface->Flags & PCIIF_FDO) == 0) {

                //
                // No.
                //
#if DBG
                status = RtlStringFromGUID(interface->InterfaceType, &guidString);
                if (NT_SUCCESS(status)) {
                    PciDebugPrint(
                        PciDbgVerbose,
                        "PCI - PciQueryInterface: guid = %wZ only for FDOs\n",
                        &guidString
                        );
                    RtlFreeUnicodeString(&guidString);
                }

#endif
                continue;

            }
            //
            // Allowable only at root?
            //
            if (interface->Flags & PCIIF_ROOT) {

                PPCI_FDO_EXTENSION FdoExtension = (PPCI_FDO_EXTENSION)DeviceExtension;

                if (!PCI_IS_ROOT_FDO(FdoExtension)) {

#if DBG
                    status = RtlStringFromGUID(interface->InterfaceType, &guidString);
                    if (NT_SUCCESS(status)) {
                        PciDebugPrint(
                            PciDbgVerbose,
                            "PCI - PciQueryInterface: guid = %wZ only for ROOT\n",
                            &guidString
                            );
                        RtlFreeUnicodeString(&guidString);
                    }
#endif
                    continue;

                }

            }

        }

#if DBG
        status = RtlStringFromGUID(interface->InterfaceType, &guidString);
        if (NT_SUCCESS(status)) {
            PciDebugPrint(
                PciDbgVerbose,
                "PCI - PciQueryInterface looking at guid = %wZ\n",
                &guidString
                );
            RtlFreeUnicodeString(&guidString);
        }
#endif

        //
        // Check for the appropriate GUID then verify version numbers
        // and size.
        //

        if ((PciCompareGuid(InterfaceType, interface->InterfaceType)) &&
            (Version >= interface->MinVersion)                        &&
            (Version <= interface->MaxVersion)                        &&
            (Size    >= interface->MinSize)                           ) {

            //
            // We have a possible hit.  Check to see if the interface
            // itself agrees.
            //
            status = interface->Constructor(
                DeviceExtension,
                interface,
                InterfaceSpecificData,
                Version,
                Size,
                InterfaceReturn
                );
            if (NT_SUCCESS(status)) {

                //
                // We found and allocated an interface, reference it
                // and get out of the loop.
                //

                InterfaceReturn->InterfaceReference(InterfaceReturn->Context);

                PciDebugPrint(
                    PciDbgObnoxious,
                    "PCI - PciQueryInterface returning SUCCESS\n"
                    );
                return status;
#if DBG
            } else {

                PciDebugPrint(
                    PciDbgVerbose,
                    "PCI - PciQueryInterface - Contructor %08lx = %08lx\n",
                    interface->Constructor,
                    status
                    );

#endif
            }

        }

    }

    //
    // Failed to find the requested interface.
    //
    PciDebugPrint(
        PciDbgObnoxious,
        "PCI - PciQueryInterface FAILED TO FIND INTERFACE\n"
        );
    return STATUS_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\id.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    id.c

Abstract:

    This module contains functions used in the generation of responses
    to a IRP_MN_QUERY_ID IRP.

Author:

    Peter Johnston (peterj)  08-Mar-1997

Revision History:

--*/

#include "pcip.h"

//++
//
// PciQueryId returns UNICODE strings when the ID type is DeviceID
// or InstanceID.  For HardwareIDs and CompatibleIDs it returns a
// a zero terminated list of zero terminated UNICODE strings (MULTI_SZ).
//
// The normal process of converting a string to a unicode string involves
// taking it's length, allocating pool memory for the new string and
// calling RtlAnsiStringToUnicodeString to do the conversion.  The following
// is an attempt to be a little more efficient in terms of both size and
// speed by keeping track of the relevant string data as it goes past in
// the process of creating the set of strings.
//
//--

#define MAX_ANSI_STRINGS 8
#define MAX_ANSI_BUFFER  256

typedef struct _PCI_ID_BUFFER {
    ULONG       Count;                 // number of ansi strings
    ANSI_STRING AnsiStrings[MAX_ANSI_STRINGS];
    USHORT      UnicodeSZSize[MAX_ANSI_STRINGS];
    USHORT      UnicodeBufferSize;
    PUCHAR      NextFree;              // first unused byte in buffer
    UCHAR       Bytes[MAX_ANSI_BUFFER];// buffer start address
} PCI_ID_BUFFER, *PPCI_ID_BUFFER;

//
// All functins in this module are pageable.
//
// Define prototypes for module local functions.
//

VOID
PciIdPrintf(
    IN PPCI_ID_BUFFER IdBuffer,
    PCCHAR Format,
    ...
    );

VOID
PciIdPrintfAppend(
    IN PPCI_ID_BUFFER IdBuffer,
    PCCHAR Format,
    ...
    );

VOID
PciInitIdBuffer(
    IN PPCI_ID_BUFFER IdBuffer
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PciGetDeviceDescriptionMessage)
#pragma alloc_text(PAGE, PciIdPrintf)
#pragma alloc_text(PAGE, PciIdPrintfAppend)
#pragma alloc_text(PAGE, PciInitIdBuffer)
#pragma alloc_text(PAGE, PciQueryId)
#pragma alloc_text(PAGE, PciQueryDeviceText)
#endif


VOID
PciInitIdBuffer(
    IN PPCI_ID_BUFFER IdBuffer
    )
{
    IdBuffer->NextFree          = IdBuffer->Bytes;
    IdBuffer->UnicodeBufferSize = 0;
    IdBuffer->Count             = 0;
}

VOID
PciIdPrintf(
    IN PPCI_ID_BUFFER IdBuffer,
    PCCHAR Format,
    ...
    )
{
    ULONG        index;
    PUCHAR       buffer;
    LONG         maxLength;
    va_list      ap;
    PANSI_STRING ansiString;
    BOOLEAN ok;

    PCI_ASSERT(IdBuffer->Count < MAX_ANSI_STRINGS);

    //
    // Make my life easier, keep repeated values in locals.
    //

    index      = IdBuffer->Count;
    buffer     = IdBuffer->NextFree;
    maxLength  = MAX_ANSI_BUFFER - (LONG)(buffer - IdBuffer->Bytes);
    ansiString = &IdBuffer->AnsiStrings[index];

    //
    // Pass the format string and subsequent data into (effectively)
    // sprintf.
    //

    va_start(ap, Format);

    ok = SUCCEEDED(StringCbVPrintfA(buffer, maxLength, Format, ap));

    ASSERT(ok);

    va_end(ap);

    //
    // Turn this into a counted Ansi string 
    //

    RtlInitAnsiString(ansiString, buffer);
    
    //
    // Get the length of this string in a unicode world and record it
    // for later when the whole set of strings gets converted (keep
    // the total size also).
    //

    IdBuffer->UnicodeSZSize[index] =
                            (USHORT)RtlAnsiStringToUnicodeSize(ansiString);
    IdBuffer->UnicodeBufferSize += IdBuffer->UnicodeSZSize[index];

    //
    // Bump buffer pointer for next iteration and the count.
    //

    IdBuffer->NextFree += ansiString->Length + 1;
    IdBuffer->Count++;
}

VOID
PciIdPrintfAppend(
    IN PPCI_ID_BUFFER IdBuffer,
    PCCHAR Format,
    ...
    )
{
    ULONG        index;
    PUCHAR       buffer;
    va_list      ap;
    PANSI_STRING ansiString;
    SIZE_T       maxLength, length;
    SIZE_T       remainingCount = 0;
    BOOLEAN ok;

    PCI_ASSERT(IdBuffer->Count);

    //
    // Make my life easier, keep repeated values in locals.
    //

    index      = IdBuffer->Count - 1;
    buffer     = IdBuffer->NextFree - 1;
    maxLength  = MAX_ANSI_BUFFER - (ULONG)(buffer - IdBuffer->Bytes);
    ansiString = &IdBuffer->AnsiStrings[index];

    //
    // Pass the format string and subsequent data into (effectively)
    // sprintf.
    //

    va_start(ap, Format);

    ok = SUCCEEDED(StringCbVPrintfExA(buffer, maxLength, NULL, &remainingCount, 0, Format, ap));

    ASSERT(ok);

    length = maxLength - remainingCount;

    va_end(ap);

    PCI_ASSERT(length < maxLength);

    //
    // Increase the ansi string length by the length of the new
    // portion of the string.
    //

    ansiString->Length += (USHORT)length;
    ansiString->MaximumLength += (USHORT)length;

    //
    // Get the length of this string in a unicode world and record it
    // for later when the whole set of strings gets converted (keep
    // the total size also).
    //

    IdBuffer->UnicodeSZSize[index] =
                            (USHORT)RtlAnsiStringToUnicodeSize(ansiString);
    IdBuffer->UnicodeBufferSize += IdBuffer->UnicodeSZSize[index];

    //
    // Bump buffer pointer for next iteration.
    //

    IdBuffer->NextFree += length;
}

NTSTATUS
PciQueryId(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    )
{
    PCI_ID_BUFFER  idBuffer;
    UCHAR          venDevString[sizeof("PCI\\VEN_vvvv&DEV_dddd")];
    NTSTATUS       status = STATUS_SUCCESS;
    UNICODE_STRING unicodeId;
    PVOID          unicodeBuffer;
    ULONG          i;
    ULONG          subsystem;
    PPCI_PDO_EXTENSION current;
    BOOLEAN ok;

    PAGED_CODE();

    *BusQueryId = NULL;

    //
    // In all the following we want PCI\VEN_vvvv&DEV_dddd.
    //

    ok = SUCCEEDED(StringCbPrintfA(venDevString,
                                   sizeof(venDevString),
                                   "PCI\\VEN_%04X&DEV_%04X",
                                   PdoExtension->VendorId,
                                   PdoExtension->DeviceId));

    ASSERT(ok);

    PciInitIdBuffer(&idBuffer);

    subsystem = (PdoExtension->SubsystemId << 16) |
                 PdoExtension->SubsystemVendorId;

    switch (IdType) {
    case BusQueryInstanceID:

        //
        // Caller wants an instance ID for this device.  The PCI
        // driver reports that it does NOT generate unique IDs for
        // devices so PnP Manager will prepend bus information.
        //
        // The instance ID is of the form-
        //
        //  AABBCCDDEEFF...XXYYZZ
        //
        // Where AA is the slot number (device/function) of the device
        // on the bus, BB, CC,... XX, YY, ZZ are the slot number of the
        // PCI-to-PCI bridges on their parent busses all the way up to
        // the root.   A device on the root bus will have only one entry,
        // AA.
        //

        current = PdoExtension;

        //
        // Initialize empty buffer.
        //

        PciIdPrintf(&idBuffer,"");

        for (;;) {
            
            PciIdPrintfAppend(&idBuffer,
                              "%02X",
                              PCI_DEVFUNC(current)
                              );

            if (PCI_PDO_ON_ROOT(current)) {
                break;
            }
            current = PCI_PARENT_PDO(current)->DeviceExtension;
        }
        break;

    case BusQueryHardwareIDs:
    case BusQueryDeviceID:

        //
        // Hardware and Compatible IDs are generated as specified
        // in the ACPI spec (section 6.1.2 in version 0.9).
        //
        // Hardware IDs are a list of identifiers of the form
        //
        //  PCI\VEN_vvvv&DEV_dddd&SUBSYS_ssssssss&REV_rr
        //  PCI\VEN_vvvv&DEV_dddd&SUBSYS_ssssssss
        //  PCI\VEN_vvvv&DEV_dddd&REV_rr
        //  PCI\VEN_vvvv&DEV_dddd
        //
        // Where vvvv is the Vendor ID from config space,
        //       dddd is the Device ID,
        //       ssssssss is the Subsystem ID/Subsystem Vendor ID, and
        //       rr   is the Revision ID.
        //
        // Device ID is the same as the first Hardware ID (ie most
        // specific of all possible IDs).
        //

        PciIdPrintf(&idBuffer,
                    "%s&SUBSYS_%08X&REV_%02X",
                    venDevString,
                    subsystem,
                    PdoExtension->RevisionId);

        if (IdType == BusQueryDeviceID) {
            break;
        }

        PciIdPrintf(&idBuffer,
                    "%s&SUBSYS_%08X",
                    venDevString,
                    subsystem);

        //
        // Fall thru.
        //

    case BusQueryCompatibleIDs:

        //
        // If the subsystem is non-zero, the second two are compatible
        // IDs, otherwise they are hardware IDs.
        //

        if (((subsystem == 0) && (IdType == BusQueryHardwareIDs)) ||
            ((subsystem != 0) && (IdType == BusQueryCompatibleIDs))) {

            PciIdPrintf(&idBuffer,
                        "%s&REV_%02X",
                        venDevString,
                        PdoExtension->RevisionId);

            //
            // Device ID is PCI\VEN_vvvv&DEV_dddd
            //

            PciIdPrintf(&idBuffer,
                        "%s",
                        venDevString);
        }

        if (IdType == BusQueryHardwareIDs) {

            //
            // The comment in the Memphis code says "Add
            // special Intel entry".  Odd that these entries
            // are absent from the spec.  They are added for
            // PIIX4 which has the same vendor and device IDs
            // for two different sub class codes.
            //
            // These two entries are
            //
            //  PCI\VEN_vvvv&DEV_dddd&CC_ccsspp
            //  PCI\VEN_vvvv&DEV_dddd&CC_ccss
            //
            // (See below for cc, ss and pp explanaitions).
            //

            PciIdPrintf(&idBuffer,
                        "%s&CC_%02X%02X%02X",
                        venDevString,
                        PdoExtension->BaseClass,
                        PdoExtension->SubClass,
                        PdoExtension->ProgIf);

            PciIdPrintf(&idBuffer,
                        "%s&CC_%02X%02X",
                        venDevString,
                        PdoExtension->BaseClass,
                        PdoExtension->SubClass);
        }

        if (IdType == BusQueryCompatibleIDs) {

            //
            // The Compatible IDs list, consists of the above plus
            //
            //  PCI\VEN_vvvv&CC_ccsspp
            //  PCI\VEN_vvvv&CC_ccss
            //  PCI\VEN_vvvv
            //  PCI\CC_ccsspp
            //  PCI\CC_ccss
            //
            // Where cc is the Class Code from config space,
            //       ss is the Sub-Class Code, and
            //       pp is the programming interface.
            //
            // WARNING: Revise the size of the buffer if you increase
            //          the above list.
            //

            PciIdPrintf(&idBuffer,
                        "PCI\\VEN_%04X&CC_%02X%02X%02X",
                        PdoExtension->VendorId,
                        PdoExtension->BaseClass,
                        PdoExtension->SubClass,
                        PdoExtension->ProgIf);

            PciIdPrintf(&idBuffer,
                        "PCI\\VEN_%04X&CC_%02X%02X",
                        PdoExtension->VendorId,
                        PdoExtension->BaseClass,
                        PdoExtension->SubClass);

            PciIdPrintf(&idBuffer,
                        "PCI\\VEN_%04X",
                        PdoExtension->VendorId);

            PciIdPrintf(&idBuffer,
                        "PCI\\CC_%02X%02X%02X",
                        PdoExtension->BaseClass,
                        PdoExtension->SubClass,
                        PdoExtension->ProgIf);

            PciIdPrintf(&idBuffer,
                        "PCI\\CC_%02X%02X",
                        PdoExtension->BaseClass,
                        PdoExtension->SubClass);

        }

        //
        // HardwareIDs and CompatibleIDs are MULTI_SZ, add a
        // NULL list to terminate it all.
        //

        PciIdPrintf(&idBuffer, "");

        break;

    default:

        PciDebugPrint(PciDbgVerbose,
                      "PciQueryId expected ID type = %d\n",
                      IdType);

        //PCI_ASSERT(0 && "Unexpected BUS_QUERY_ID_TYPE");
        return STATUS_NOT_SUPPORTED;
    }

    PCI_ASSERT(idBuffer.Count > 0);

    //
    // What we have is a (bunch of) ansi strings.  What we need is a
    // (bunch of) unicode strings.
    //

    unicodeBuffer = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, idBuffer.UnicodeBufferSize);

    if (unicodeBuffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Build the (possibly MULTI_SZ) unicode string(s).
    //

    PciDebugPrint(PciDbgPrattling,
                  "PciQueryId(%d)\n",
                  IdType);

    unicodeId.Buffer = unicodeBuffer;
    unicodeId.MaximumLength = idBuffer.UnicodeBufferSize;

    for (i = 0; i < idBuffer.Count; i++) {
        PciDebugPrint(PciDbgPrattling,
                      "    <- \"%s\"\n",
                      idBuffer.AnsiStrings[i].Buffer);

        status = RtlAnsiStringToUnicodeString(&unicodeId,
                                              &idBuffer.AnsiStrings[i],
                                              FALSE);
        if (!NT_SUCCESS(status)) {
            PCI_ASSERT(NT_SUCCESS(status));
            ExFreePool(unicodeBuffer);
            return status;
        }

        //
        // Bump the base pointer and decrement the max length for the
        // next trip thru the loop.
        //

        unicodeId.Buffer += idBuffer.UnicodeSZSize[i] / sizeof(WCHAR);
        unicodeId.MaximumLength -= idBuffer.UnicodeSZSize[i];
    }

    *BusQueryId = unicodeBuffer;
    return status;
}

PWSTR
PciGetDescriptionMessage(
    IN ULONG MessageNumber,
    OUT PUSHORT MessageLength OPTIONAL
    )
{
    PWSTR description = NULL;
    NTSTATUS status;
    PMESSAGE_RESOURCE_ENTRY messageEntry;

    status = RtlFindMessage(PciDriverObject->DriverStart,
                            11,             // <-- I wonder what this is.
                            LANG_NEUTRAL,
                            MessageNumber,
                            &messageEntry);

    if (NT_SUCCESS(status)) {

        if (messageEntry->Flags & MESSAGE_RESOURCE_UNICODE) {

            //
            // Our caller wants a copy they can free, also we need to
            // strip the trailing CR/LF.  The Length field of the
            // message structure includes both the header and the
            // actual text.
            //
            // Note: The message resource entry length will always be a
            // multiple of 4 bytes in length.  The 2 byte null terminator
            // could be in either the last or second last WCHAR position.
            //

            USHORT textLength;

            textLength = messageEntry->Length -
                         FIELD_OFFSET(MESSAGE_RESOURCE_ENTRY, Text) -
                         2 * sizeof(WCHAR);

            description = (PWSTR)(messageEntry->Text);
            if (description[textLength / sizeof(WCHAR)] == 0) {
                textLength -= sizeof(WCHAR);
            }

            PCI_ASSERT((LONG)textLength > 1);
            PCI_ASSERT(description[textLength / sizeof(WCHAR)] == 0x000a);

            description = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, textLength);

            if (description) {

                //
                // Copy the text except for the CR/LF/NULL
                //

                textLength -= sizeof(WCHAR);
                RtlCopyMemory(description, messageEntry->Text, textLength);

                //
                // New NULL terminator.
                //

                description[textLength / sizeof(WCHAR)] = 0;
            
                if (MessageLength) {
                    *MessageLength = textLength;
                }
            }

        } else {

            //
            // RtlFindMessage returns a string?   Wierd.
            //

            ANSI_STRING    ansiDescription;
            UNICODE_STRING unicodeDescription;

            RtlInitAnsiString(&ansiDescription, messageEntry->Text);

            //
            // Strip CR/LF off the end of the string.
            //

            ansiDescription.Length -= 2;

            //
            // Turn it all into a unicode string so we can grab the buffer
            // and return that to our caller.
            //

            status = RtlAnsiStringToUnicodeString(
                         &unicodeDescription,
                         &ansiDescription,
                         TRUE
                         );

            description = unicodeDescription.Buffer;

            if (MessageLength) {
                *MessageLength = unicodeDescription.Length;
            }
        }
    }

    return description;
}

PWSTR
PciGetDeviceDescriptionMessage(
    IN UCHAR BaseClass,
    IN UCHAR SubClass
    )
{
    PWSTR deviceDescription = NULL;
    ULONG messageNumber;

    messageNumber = (BaseClass << 8) | SubClass;

    deviceDescription = PciGetDescriptionMessage(messageNumber, NULL);

    if (!deviceDescription) {

#define TEMP_DESCRIPTION L"PCI Device"
        deviceDescription = ExAllocatePool(PagedPool, sizeof(TEMP_DESCRIPTION));
        if (deviceDescription) {
            RtlCopyMemory(deviceDescription,
                          TEMP_DESCRIPTION,
                          sizeof(TEMP_DESCRIPTION));
        }
    }

    return deviceDescription;
}

NTSTATUS
PciQueryDeviceText(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN DEVICE_TEXT_TYPE TextType,
    IN LCID LocaleId,
    IN OUT PWSTR *DeviceText
    )
{
    PWSTR locationFormat;
    SIZE_T textLength;
    USHORT messageLength;
    BOOLEAN ok;

    PAGED_CODE();
    
    switch (TextType) {
    case DeviceTextDescription:

        *DeviceText = PciGetDeviceDescriptionMessage(PdoExtension->BaseClass,
                                                     PdoExtension->SubClass);
        if (*DeviceText) {
            return STATUS_SUCCESS;
        }
        return STATUS_NOT_SUPPORTED;

    case DeviceTextLocationInformation:

        //
        // Get the internationalized location description string from the
        // resources of pci.sys.  It contains 3 %u specifiers for each of
        // Bus, Device & Function.
        //

        locationFormat = PciGetDescriptionMessage(PCI_LOCATION_TEXT, &messageLength);

        if (locationFormat) {
            //
            // Compute max size for location information string:
            //  The messageLength contains 3 %u format specifiers means that
            //  the messageLength contains 6 unprinted characters.  We need to 
            //  allow space for these numbers.  Up to 3 digits for bus number
            //  0-255, up to 2 digits for device 0-32 and up to 1 digit for 
            //  function 0-7.  Note we assume standard arabic numbers in this
            //  internationalzed string.
            //
            textLength = messageLength + ((3 + 2 + 2 - 6) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);
            
            *DeviceText = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION,
                                         textLength * sizeof(WCHAR));
            if (*DeviceText) {
                
                ok = SUCCEEDED(StringCchPrintfW(
                                    *DeviceText, 
                                     textLength,
                                     locationFormat,
                                     (ULONG) PdoExtension->ParentFdoExtension->BaseBus,
                                     (ULONG) PdoExtension->Slot.u.bits.DeviceNumber,
                                     (ULONG) PdoExtension->Slot.u.bits.FunctionNumber
                                     ));

                ASSERT(ok);

            }
            
            ExFreePool(locationFormat);

            if (*DeviceText) {
                return STATUS_SUCCESS;
            } else {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        // fall thru if we couldn't get format string

    default:
        return STATUS_NOT_SUPPORTED;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\lddintrf.c ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    lddintrf.c

Abstract:

    This module implements the "legacy device detection" interface
    supported by the PCI driver.

Author:

    Dave Richards (daveri)  2-Oct-1998

Revision History:

--*/

#include "pcip.h"

#define LDDINTRF_VERSION 0

//
// Prototypes for routines exposed only through the "interface"
// mechanism.
//

NTSTATUS
lddintrf_Constructor(
    IN PVOID DeviceExtension,
    IN PVOID PciInterface,
    IN PVOID InterfaceSpecificData,
    IN USHORT Version,
    IN USHORT Size,
    IN PINTERFACE InterfaceReturn
    );

VOID
lddintrf_Reference(
    IN PVOID Context
    );

VOID
lddintrf_Dereference(
    IN PVOID Context
    );

NTSTATUS
lddintrf_Initializer(
    IN PVOID Instance
    );

NTSTATUS
PciLegacyDeviceDetection(
    IN PVOID Context,
    IN INTERFACE_TYPE LegacyBusType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    OUT PDEVICE_OBJECT *PhysicalDeviceObject
    );

//
// Define the Legacy Device Detection "Interface" structure.
//

PCI_INTERFACE PciLegacyDeviceDetectionInterface = {
    &GUID_LEGACY_DEVICE_DETECTION_STANDARD, // InterfaceType
    sizeof(LEGACY_DEVICE_DETECTION_INTERFACE),
                                            // MinSize
    LDDINTRF_VERSION,                       // MinVersion
    LDDINTRF_VERSION,                       // MaxVersion
    PCIIF_FDO,                              // Flags
    0,                                      // ReferenceCount
    PciInterface_LegacyDeviceDetection,     // Signature
    lddintrf_Constructor,                   // Constructor
    lddintrf_Initializer                    // Instance Initializer
};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, lddintrf_Constructor)
#pragma alloc_text(PAGE, lddintrf_Dereference)
#pragma alloc_text(PAGE, lddintrf_Initializer)
#pragma alloc_text(PAGE, lddintrf_Reference)
#pragma alloc_text(PAGE, PciLegacyDeviceDetection)
#endif

VOID
lddintrf_Reference(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine adds a reference to a legacy device detection interface.

Arguments:

    Instance - FDO extension pointer.

Return Value:

    None.

--*/
{
    ASSERT_PCI_FDO_EXTENSION((PPCI_FDO_EXTENSION)Context);
}

VOID
lddintrf_Dereference(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine releases a reference to a legacy device detection interface.

Arguments:

    Instance - FDO extension pointer.

Return Value:

    None.

--*/
{
    ASSERT_PCI_FDO_EXTENSION((PPCI_FDO_EXTENSION)Context);
}

NTSTATUS
lddintrf_Constructor(
    IN PVOID DeviceExtension,
    IN PVOID PciInterface,
    IN PVOID InterfaceSpecificData,
    IN USHORT Version,
    IN USHORT Size,
    IN PINTERFACE InterfaceReturn
    )
/*++

Routine Description:

    This routine constructs a LEGACY_DEVICE_DETECTION_INTERFACE.

Arguments:

    DeviceExtension - An FDO extenion pointer.

    PCIInterface - PciInterface_LegacyDeviceDetection.

    InterfaceSpecificData - Unused.

    Version - Interface version.

    Size - Size of the LEGACY_DEVICE_DETECTION interface object.

    InterfaceReturn - The interface object pointer.

Return Value:

    Returns NTSTATUS.

--*/
{
    PLEGACY_DEVICE_DETECTION_INTERFACE standard;

                

    standard = (PLEGACY_DEVICE_DETECTION_INTERFACE)InterfaceReturn;
    standard->Size = sizeof( LEGACY_DEVICE_DETECTION_INTERFACE );
    standard->Version = LDDINTRF_VERSION;
    standard->Context = DeviceExtension;
    standard->InterfaceReference = lddintrf_Reference;
    standard->InterfaceDereference = lddintrf_Dereference;
    standard->LegacyDeviceDetection = PciLegacyDeviceDetection;

    return STATUS_SUCCESS;
}

NTSTATUS
lddintrf_Initializer(
    IN PVOID Instance
    )
/*++

Routine Description:

    For legacy device detection does nothing, shouldn't actually be called.

Arguments:

    Instance - FDO extension pointer.

Return Value:

    Returns NTSTATUS.

--*/
{
        
    PCI_ASSERTMSG("PCI lddintrf_Initializer, unexpected call.", FALSE);

    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
PciLegacyDeviceDetection(
    IN PVOID Context,
    IN INTERFACE_TYPE LegacyBusType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    OUT PDEVICE_OBJECT *PhysicalDeviceObject
    )
/*++

Routine Description:

    This function searches for a legacy device, specified by LegacyBusType,
    BusNumber and SlotNumber, and returns a referenced physical device object
    as an output argument.

Arguments:

    Context - Supplies a pointer to the interface context.  This is actually
        the FDO for the given bus.

    LegacyBusType - PCIBus.

    BusNumber - The legacy device's bus number.

    SlotNumber - The legacy device's slot number.

    PhysicalDeviceObject - The return argument i.e. a reference physical
        device object if the corresponding legacy device is found.

Return Value:

    Returns NTSTATUS.

--*/
{
    PCI_SLOT_NUMBER slotNumber;
    PPCI_FDO_EXTENSION fdoExtension;
    PPCI_PDO_EXTENSION pdoExtension;
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    fdoExtension = (PPCI_FDO_EXTENSION)Context;

    ASSERT_PCI_FDO_EXTENSION(fdoExtension);

    if (LegacyBusType != PCIBus) {
        return STATUS_UNSUCCESSFUL;
    }

    if (fdoExtension->BaseBus != BusNumber) {
        return STATUS_UNSUCCESSFUL;
    }

    slotNumber.u.AsULONG = SlotNumber;

    ExAcquireFastMutex(&fdoExtension->SecondaryExtMutex);

    for (pdoExtension = fdoExtension->ChildPdoList;
         pdoExtension != NULL;
         pdoExtension = pdoExtension->Next) {

        if (pdoExtension->Slot.u.bits.DeviceNumber == slotNumber.u.bits.DeviceNumber &&
            pdoExtension->Slot.u.bits.FunctionNumber == slotNumber.u.bits.FunctionNumber) {

            if (pdoExtension->DeviceState != PciNotStarted) {
                break;
            }

//          pdoExtension->DeviceState = PciLockedBecauseNotPnp;

            *PhysicalDeviceObject = pdoExtension->PhysicalDeviceObject;
            ObReferenceObject(pdoExtension->PhysicalDeviceObject);
            status = STATUS_SUCCESS;
            break;

        }

    }

    ExReleaseFastMutex(&fdoExtension->SecondaryExtMutex);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\pciverifier.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    pciverifier.c

Abstract:

    This module implements routines used to catch BIOS, hardware, and driver
    bugs.

Author:

    Adrian J. Oney (AdriaO) 02/20/2001

Revision History:

--*/

#include "pcip.h"
#include <initguid.h>
#include <wdmguid.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,     PciVerifierInit)
#pragma alloc_text(PAGE,     PciVerifierUnload)
//#pragma alloc_text(PAGEVRFY, PciVerifierProfileChangeCallback)
//#pragma alloc_text(PAGEVRFY, PciVerifierEnsureTreeConsistancy)
//#pragma alloc_text(PAGEVRFY, PciVerifierRetrieveFailureData)
#endif

BOOLEAN PciVerifierRegistered = FALSE;

#ifdef ALLOC_DATA_PRAGMA
//#pragma data_seg("PAGEVRFD")
#endif

PVOID PciVerifierNotificationHandle = NULL;

//
// This is the table of PCI verifier failures
//
VERIFIER_DATA PciVerifierFailureTable[] = {

    { PCI_VERIFIER_BRIDGE_REPROGRAMMED, VFFAILURE_FAIL_LOGO,
      0,
      "The BIOS has reprogrammed the bus numbers of an active PCI device "
      "(!devstack %DevObj) during a dock or undock!" },

    { PCI_VERIFIER_PMCSR_TIMEOUT, VFFAILURE_FAIL_LOGO,
      0,
      "A device in the system did not update it's PMCSR register in the spec "
      "mandated time (!devstack %DevObj, Power state D%Ulong)" },

    { PCI_VERIFIER_PROTECTED_CONFIGSPACE_ACCESS, VFFAILURE_FAIL_LOGO,
      0,
      "A driver controlling a PCI device has tried to access OS controlled "
      "configuration space registers (!devstack %DevObj, Offset 0x%Ulong1, "
      "Length 0x%Ulong2)" },
    
    { PCI_VERIFIER_INVALID_WHICHSPACE, VFFAILURE_FAIL_UNDER_DEBUGGER,
      0,
      "A driver controlling a PCI device has tried to read or write from "
      "an invalid space using IRP_MN_READ/WRITE_CONFIG or via BUS_INTERFACE_STANDARD.  "
      "NB: These functions take WhichSpace parameters of the form PCI_WHICHSPACE_* "
      "and not a BUS_DATA_TYPE (!devstack %DevObj, WhichSpace 0x%Ulong1)" }

};


VOID
PciVerifierInit(
    IN  PDRIVER_OBJECT  DriverObject
    )
/*++

Routine Description:

    This routine initializes the hardware verification support, enabling
    consistancy hooks and state checks where appropriate.

Arguments:

    DriverObject - Pointer to our driver object.

Return Value:

    None.

--*/
{
    NTSTATUS status;

    if (!VfIsVerificationEnabled(VFOBJTYPE_SYSTEM_BIOS, NULL)) {

        return;
    }

    status = IoRegisterPlugPlayNotification(
        EventCategoryHardwareProfileChange,
        0,
        NULL,
        DriverObject,
        PciVerifierProfileChangeCallback,
        (PVOID) NULL,
        &PciVerifierNotificationHandle
        );

    if (NT_SUCCESS(status)) {

        PciVerifierRegistered = TRUE;
    }
}


VOID
PciVerifierUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )
/*++

Routine Description:

    This routine uninitializes the hardware verification support.

Arguments:

    DriverObject - Pointer to our driver object.

Return Value:

    None.

--*/
{
    NTSTATUS status;

    
    if (!PciVerifierRegistered) {

        return;
    }

    ASSERT(PciVerifierNotificationHandle);

    status = IoUnregisterPlugPlayNotification(PciVerifierNotificationHandle);

    ASSERT(NT_SUCCESS(status));

    PciVerifierRegistered = FALSE;
}


NTSTATUS
PciVerifierProfileChangeCallback(
    IN  PHWPROFILE_CHANGE_NOTIFICATION  NotificationStructure,
    IN  PVOID                           NotUsed
    )
/*++

Routine Description:

    This routine gets called back during hardware profile change events if
    hardware verification is enabled.

Arguments:

    NotificationStructure - Describes the hardware profile event that occured.

    NotUsed - Not used

Return Value:

    NTSTATUS.

--*/
{
    PAGED_CODE();

    
    if (IsEqualGUID((LPGUID) &NotificationStructure->Event,
                    (LPGUID) &GUID_HWPROFILE_CHANGE_COMPLETE)) {

        //
        // This is a HW profile change complete message. Do some tests to
        // ensure our hardware hasn't been reprogrammed behind our back.
        //
        PciVerifierEnsureTreeConsistancy();
    }

    return STATUS_SUCCESS;
}


VOID
PciVerifierEnsureTreeConsistancy(
    VOID
    )
/*++

Routine Description:

    This routine checks the device tree and ensures it's physical state matches
    the virtual state described by our structures. A deviation may mean someone
    has reprogrammed the hardware behind our back.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PSINGLE_LIST_ENTRY  nextEntry;
    PPCI_FDO_EXTENSION  fdoExtension;
    PPCI_PDO_EXTENSION  pdoExtension;
    PCI_COMMON_CONFIG   commonConfig;
    PVERIFIER_DATA      verifierData;

    //
    // Walk the list of FDO extensions and verifier the physical hardware
    // matches our virtual state. Owning the PciGlobalLock ensures the list
    // is locked.
    //

    ExAcquireFastMutex(&PciGlobalLock);

    //
    // Grab the bus renumbering lock. Note that this lock can be held when
    // child list locks are held.
    //

    ExAcquireFastMutex(&PciBusLock);

    for ( nextEntry = PciFdoExtensionListHead.Next;
          nextEntry != NULL;
          nextEntry = nextEntry->Next ) {

        fdoExtension = CONTAINING_RECORD(nextEntry, PCI_FDO_EXTENSION, List);

        if (PCI_IS_ROOT_FDO(fdoExtension)) {

            //
            // It's a root FDO, ignore it.
            //
            continue;
        }

        pdoExtension = PCI_BRIDGE_PDO(fdoExtension);

        if (pdoExtension->NotPresent ||
            (pdoExtension->PowerState.CurrentDeviceState == PowerDeviceD3)) {

            //
            // Don't touch.
            //
            continue;
        }

        if ((pdoExtension->HeaderType != PCI_BRIDGE_TYPE) &&
            (pdoExtension->HeaderType != PCI_CARDBUS_BRIDGE_TYPE)) {

            //
            // Nothing to verify - in fact, why are here, this is a bridge list!
            //
            ASSERT(0);
            continue;
        }

        //
        // Read in the common config (that should be enough)
        //
        PciReadDeviceConfig(
            pdoExtension,
            &commonConfig,
            0,
            sizeof(PCI_COMMON_CONFIG)
            );

        //
        // Ensure bus numbers haven't changed. Note that P2P and Cardbus
        // bridges have their Primary, Secondary & Subordinate fields in the
        // same place.
        //
        if ((commonConfig.u.type1.PrimaryBus !=
             pdoExtension->Dependent.type1.PrimaryBus) ||
            (commonConfig.u.type1.SecondaryBus !=
             pdoExtension->Dependent.type1.SecondaryBus) ||
            (commonConfig.u.type1.SubordinateBus !=
             pdoExtension->Dependent.type1.SubordinateBus)) {

            verifierData = PciVerifierRetrieveFailureData(
                PCI_VERIFIER_BRIDGE_REPROGRAMMED
                );

            ASSERT(verifierData);

            VfFailSystemBIOS(
                PCI_VERIFIER_DETECTED_VIOLATION,
                PCI_VERIFIER_BRIDGE_REPROGRAMMED,
                verifierData->FailureClass,
                &verifierData->Flags,
                verifierData->FailureText,
                "%DevObj",
                pdoExtension->PhysicalDeviceObject
                );
        }
    }

    ExReleaseFastMutex(&PciBusLock);

    ExReleaseFastMutex(&PciGlobalLock);
}


PVERIFIER_DATA
PciVerifierRetrieveFailureData(
    IN  PCI_VFFAILURE   VerifierFailure
    )
/*++

Routine Description:

    This routine retrieves the failure data corresponding to a particular PCI
    verifier failure event.

Arguments:

    PCI Failure.

Return Value:

    Verifier data corresponding to the failure.

--*/
{
    PVERIFIER_DATA verifierData;
    ULONG i;

    for(i=0;
        i<(sizeof(PciVerifierFailureTable)/sizeof(PciVerifierFailureTable[0]));
        i++) {

        verifierData = PciVerifierFailureTable + i;

        if (verifierData->VerifierFailure == VerifierFailure) {

            return verifierData;
        }
    }

    ASSERT(0);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\pdo.c ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    pdo.c

Abstract:

    This module handles IRPs for PCI PDO's.

Author:

    Adrian J. Oney (adriao) & Andrew Thornton (andrewth)  10-20-1998

Revision History:

--*/

#include "pcip.h"

NTSTATUS
PciPdoIrpStartDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpQueryRemoveDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpRemoveDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpCancelRemoveDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpStopDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpQueryStopDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpCancelStopDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpQueryDeviceRelations(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpQueryCapabilities(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpQueryInterface(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpQueryResources(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpQueryResourceRequirements(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpQueryDeviceText(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpReadConfig(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpWriteConfig(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpQueryId(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpQueryBusInformation(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpDeviceUsageNotification(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpQueryLegacyBusInformation(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpSurpriseRemoval(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpQueryDeviceState(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PciPdoCreate)
#pragma alloc_text(PAGE, PciPdoDestroy)
#pragma alloc_text(PAGE, PciPdoIrpStartDevice)
#pragma alloc_text(PAGE, PciPdoIrpQueryRemoveDevice)
#pragma alloc_text(PAGE, PciPdoIrpRemoveDevice)
#pragma alloc_text(PAGE, PciPdoIrpCancelRemoveDevice)
#pragma alloc_text(PAGE, PciPdoIrpStopDevice)
#pragma alloc_text(PAGE, PciPdoIrpQueryStopDevice)
#pragma alloc_text(PAGE, PciPdoIrpCancelStopDevice)
#pragma alloc_text(PAGE, PciPdoIrpQueryDeviceRelations)
#pragma alloc_text(PAGE, PciPdoIrpQueryInterface)
#pragma alloc_text(PAGE, PciPdoIrpQueryCapabilities)
#pragma alloc_text(PAGE, PciPdoIrpQueryResources)
#pragma alloc_text(PAGE, PciPdoIrpQueryResourceRequirements)
#pragma alloc_text(PAGE, PciPdoIrpQueryDeviceText)
#pragma alloc_text(PAGE, PciPdoIrpReadConfig)
#pragma alloc_text(PAGE, PciPdoIrpWriteConfig)
#pragma alloc_text(PAGE, PciPdoIrpQueryId)
#pragma alloc_text(PAGE, PciPdoIrpQueryBusInformation)
#pragma alloc_text(PAGE, PciPdoIrpDeviceUsageNotification)
#pragma alloc_text(PAGE, PciPdoIrpQueryLegacyBusInformation)
#pragma alloc_text(PAGE, PciPdoIrpSurpriseRemoval)
#pragma alloc_text(PAGE, PciPdoIrpQueryDeviceState)
#endif

/*++

The majority of functions in this file are called based on their presence
in Pnp and Po dispatch tables.  In the interests of brevity the arguments
to all those functions will be described below:

NTSTATUS
PciXxxPdo(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpStack,
    IN PPCI_EXTENSION DeviceExtension
    )

Routine Description:

    This function handles the Xxx requests for a given PCI FDO or PDO.

Arguments:

    Irp - Points to the IRP associated with this request.

    IrpStack - Points to the current stack location for this request.

    DeviceExtension - Points to the device's extension.

Return Value:

    Status code that indicates whether or not the function was successful.

    STATUS_NOT_SUPPORTED indicates that the IRP should be completed without
    changing the Irp->IoStatus.Status field otherwise it is updated with this
    status.

--*/

#define PCI_MAX_MINOR_POWER_IRP  0x3
#define PCI_MAX_MINOR_PNP_IRP    0x18

PCI_MN_DISPATCH_TABLE PciPdoDispatchPowerTable[] = {
    { IRP_DISPATCH, PciPdoWaitWake                     }, // 0x00 - IRP_MN_WAIT_WAKE
    { IRP_COMPLETE, PciIrpNotSupported                 }, // 0x01 - IRP_MN_POWER_SEQUENCE
    { IRP_COMPLETE, PciPdoSetPowerState                }, // 0x02 - IRP_MN_SET_POWER
    { IRP_COMPLETE, PciPdoIrpQueryPower                }, // 0x03 - IRP_MN_QUERY_POWER
    { IRP_COMPLETE, PciIrpNotSupported                 }, //      - UNHANDLED Power IRP
};

PCI_MN_DISPATCH_TABLE PciPdoDispatchPnpTable[] = {
    { IRP_COMPLETE, PciPdoIrpStartDevice               }, // 0x00 - IRP_MN_START_DEVICE
    { IRP_COMPLETE, PciPdoIrpQueryRemoveDevice         }, // 0x01 - IRP_MN_QUERY_REMOVE_DEVICE
    { IRP_COMPLETE, PciPdoIrpRemoveDevice              }, // 0x02 - IRP_MN_REMOVE_DEVICE
    { IRP_COMPLETE, PciPdoIrpCancelRemoveDevice        }, // 0x03 - IRP_MN_CANCEL_REMOVE_DEVICE
    { IRP_COMPLETE, PciPdoIrpStopDevice                }, // 0x04 - IRP_MN_STOP_DEVICE
    { IRP_COMPLETE, PciPdoIrpQueryStopDevice           }, // 0x05 - IRP_MN_QUERY_STOP_DEVICE
    { IRP_COMPLETE, PciPdoIrpCancelStopDevice          }, // 0x06 - IRP_MN_CANCEL_STOP_DEVICE
    { IRP_COMPLETE, PciPdoIrpQueryDeviceRelations      }, // 0x07 - IRP_MN_QUERY_DEVICE_RELATIONS
    { IRP_COMPLETE, PciPdoIrpQueryInterface            }, // 0x08 - IRP_MN_QUERY_INTERFACE
    { IRP_COMPLETE, PciPdoIrpQueryCapabilities         }, // 0x09 - IRP_MN_QUERY_CAPABILITIES
    { IRP_COMPLETE, PciPdoIrpQueryResources            }, // 0x0A - IRP_MN_QUERY_RESOURCES
    { IRP_COMPLETE, PciPdoIrpQueryResourceRequirements }, // 0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    { IRP_COMPLETE, PciPdoIrpQueryDeviceText           }, // 0x0C - IRP_MN_QUERY_DEVICE_TEXT
    { IRP_COMPLETE, PciIrpNotSupported                 }, // 0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    { IRP_COMPLETE, PciIrpNotSupported                 }, // 0x0E - NOT USED
    { IRP_COMPLETE, PciPdoIrpReadConfig                }, // 0x0F - IRP_MN_READ_CONFIG
    { IRP_COMPLETE, PciPdoIrpWriteConfig               }, // 0x10 - IRP_MN_WRITE_CONFIG
    { IRP_COMPLETE, PciIrpNotSupported                 }, // 0x11 - IRP_MN_EJECT
    { IRP_COMPLETE, PciIrpNotSupported                 }, // 0x12 - IRP_MN_SET_LOCK
    { IRP_COMPLETE, PciPdoIrpQueryId                   }, // 0x13 - IRP_MN_QUERY_ID
    { IRP_COMPLETE, PciPdoIrpQueryDeviceState          }, // 0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE
    { IRP_COMPLETE, PciPdoIrpQueryBusInformation       }, // 0x15 - IRP_MN_QUERY_BUS_INFORMATION
    { IRP_COMPLETE, PciPdoIrpDeviceUsageNotification   }, // 0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION
    { IRP_COMPLETE, PciPdoIrpSurpriseRemoval           }, // 0x17 - IRP_MN_SURPRISE_REMOVAL
    { IRP_COMPLETE, PciPdoIrpQueryLegacyBusInformation }, // 0x18 - IRP_MN_QUERY_LEGACY_BUS_INFORMATION
    { IRP_COMPLETE, PciIrpNotSupported                 }  //      - UNHANDLED PNP IRP
};

//
// This is the major function dispatch table for Pdo's
//
PCI_MJ_DISPATCH_TABLE PciPdoDispatchTable = {
    PCI_MAX_MINOR_PNP_IRP,    PciPdoDispatchPnpTable,       // Pnp irps
    PCI_MAX_MINOR_POWER_IRP,  PciPdoDispatchPowerTable,     // Power irps
    IRP_COMPLETE,             PciIrpNotSupported,
    IRP_COMPLETE,             PciIrpInvalidDeviceRequest    // Other
};

//
// Data
//

BOOLEAN PciStopOnIllegalConfigAccess = FALSE;
ULONG   PciPdoSequenceNumber = (ULONG)-1;

NTSTATUS
PciPdoCreate(
    IN PPCI_FDO_EXTENSION FdoExtension,
    IN PCI_SLOT_NUMBER Slot,
    OUT PDEVICE_OBJECT *PhysicalDeviceObject
    )
{
    NTSTATUS       status;
    PDRIVER_OBJECT driverObject;
    PDEVICE_OBJECT functionalDeviceObject;
    PDEVICE_OBJECT physicalDeviceObject;
    PPCI_PDO_EXTENSION pdoExtension;
    UNICODE_STRING unicodeDeviceString;
    WCHAR          deviceString[32];
    BOOLEAN        ok;

    PAGED_CODE();

    //
    // We've been asked to create a new PDO for a PCI device.  First get
    // a pointer to our driver object.
    //

    functionalDeviceObject = FdoExtension->FunctionalDeviceObject;
    driverObject = functionalDeviceObject->DriverObject;

    //
    // Create the physical device object for this device.
    // In theory it doesn't need a name,...  It must have
    // a name.
    //
    // But what name?  For now we'll call it NTPNP_PCIxxxx,
    // where xxxx is the 0-based number of PCI devices we've
    // found.
    //

    ok = SUCCEEDED(StringCbPrintfW(deviceString,
                                   sizeof(deviceString),
                                   L"\\Device\\NTPNP_PCI%04d",
                                   InterlockedIncrement(&PciPdoSequenceNumber)
                                   ));

    ASSERT(ok);

    RtlInitUnicodeString(&unicodeDeviceString, deviceString);

    status = IoCreateDevice(
                driverObject,               // our driver object
                sizeof(PCI_PDO_EXTENSION),      // size of our extension,
                &unicodeDeviceString,       // our name
                FILE_DEVICE_UNKNOWN,        // device type
                0,                          // device characteristics
                FALSE,                      // not exclusive
                &physicalDeviceObject       // store new device object here
                );

    if (!NT_SUCCESS(status)) {
        PCI_ASSERT(NT_SUCCESS(status));
        return status;
    }

    pdoExtension = (PPCI_PDO_EXTENSION)physicalDeviceObject->DeviceExtension;

    PciDebugPrint(PciDbgVerbose,
                  "PCI: New PDO (b=0x%x, d=0x%x, f=0x%x) @ %p, ext @ %p\n",
                  FdoExtension->BaseBus,
                  Slot.u.bits.DeviceNumber,
                  Slot.u.bits.FunctionNumber,
                  physicalDeviceObject,
                  pdoExtension);

    //
    // We have our physical device object, initialize it.
    //
    // And yes, I would have zeroed the extension if I didn't know
    // for a fact that it was zeroed by IoCreateDevice().
    //
    pdoExtension->ExtensionType = PciPdoExtensionType;
    pdoExtension->IrpDispatchTable = &PciPdoDispatchTable;
    pdoExtension->PhysicalDeviceObject = physicalDeviceObject;
    pdoExtension->Slot = Slot;
    pdoExtension->PowerState.CurrentSystemState = PowerSystemWorking;
    pdoExtension->PowerState.CurrentDeviceState = PowerDeviceD0;
    pdoExtension->ParentFdoExtension = FdoExtension;
    
    ExInitializeFastMutex(&pdoExtension->SecondaryExtMutex);
    PciInitializeState((PPCI_COMMON_EXTENSION) pdoExtension);

    //
    // Insert it into the list of child PDOs hanging off of the FdoExtension.
    // We won't be re-entered enumerating the same bus, so we don't need to
    // protect the list.
    //

    pdoExtension->Next = NULL;

    PciInsertEntryAtTail(
        (PSINGLE_LIST_ENTRY)&FdoExtension->ChildPdoList,
        (PSINGLE_LIST_ENTRY)&pdoExtension->Next,
        &FdoExtension->ChildListMutex
        );

    *PhysicalDeviceObject = physicalDeviceObject;
    return STATUS_SUCCESS;
}

VOID
PciPdoDestroy(
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
{
    PPCI_PDO_EXTENSION pdoExtension;
    PPCI_PDO_EXTENSION *previousBridge;
    PPCI_FDO_EXTENSION fdoExtension;

    PAGED_CODE();

    pdoExtension = (PPCI_PDO_EXTENSION)PhysicalDeviceObject->DeviceExtension;

    ASSERT_PCI_PDO_EXTENSION(pdoExtension);

    PCI_ASSERT(!pdoExtension->LegacyDriver);

    fdoExtension = PCI_PARENT_FDOX(pdoExtension);

    ASSERT_PCI_FDO_EXTENSION(fdoExtension);

    PciDebugPrint(PciDbgVerbose,
                  "PCI: destroy PDO (b=0x%x, d=0x%x, f=0x%x)\n",
                  PCI_PARENT_FDOX(pdoExtension)->BaseBus,
                  pdoExtension->Slot.u.bits.DeviceNumber,
                  pdoExtension->Slot.u.bits.FunctionNumber);

    //
    // Remove this PDO from the Child Pdo List.
    //
    ASSERT_MUTEX_HELD(&fdoExtension->ChildListMutex);

    PciRemoveEntryFromList((PSINGLE_LIST_ENTRY)&fdoExtension->ChildPdoList,
                           (PSINGLE_LIST_ENTRY)pdoExtension,
                           NULL);

    for (previousBridge = &fdoExtension->ChildBridgePdoList;
         *previousBridge;
         previousBridge = &((*previousBridge)->NextBridge)) {

        if (*previousBridge == pdoExtension) {
            *previousBridge = pdoExtension->NextBridge;
            pdoExtension->NextBridge = NULL;
            break;
        }
    }

    pdoExtension->Next = NULL;

    //
    // Delete any secondary extensions this PDO may have.
    //

    while (pdoExtension->SecondaryExtension.Next) {

        PcipDestroySecondaryExtension(&pdoExtension->SecondaryExtension,
                                      NULL,
                                      pdoExtension->SecondaryExtension.Next);
    }

    //
    // Zap the extension type so we'll trip up if we try to resuse it.
    //

    pdoExtension->ExtensionType = 0xdead;
    
    //
    // If there are any resource lists etc associated with this puppy,
    // give them back to the system.
    //

    //PciInvalidateResourceInfoCache(pdoExtension);

    // BUGBUG - leak


    if (pdoExtension->Resources) {
        ExFreePool(pdoExtension->Resources);
    }

    //
    // And finally,...
    //

    IoDeleteDevice(PhysicalDeviceObject);
}


NTSTATUS
PciPdoIrpStartDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    NTSTATUS status;
    BOOLEAN change, powerOn, isVideoController;
    PPCI_PDO_EXTENSION pdoExtension;

    PAGED_CODE();

        
    status = PciBeginStateTransition(DeviceExtension, PciStarted);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;

    //
    // If there is a motherboard video device and a plug in video
    // device, the BIOS will have disabled the motherboard one.  The
    // video drivers use this fact to determine if this device should
    // be disabled,... don't change its settings here.
    //
    isVideoController =
       ((pdoExtension->BaseClass == PCI_CLASS_PRE_20) &&
        (pdoExtension->SubClass  == PCI_SUBCLASS_PRE_20_VGA)) ||
       ((pdoExtension->BaseClass == PCI_CLASS_DISPLAY_CTLR) &&
        (pdoExtension->SubClass  == PCI_SUBCLASS_VID_VGA_CTLR));

    if ( !isVideoController ) {

        //
        // Non-VGA, unconditionally enable the IO and Memory for the device.
        //

        pdoExtension->CommandEnables |= (PCI_ENABLE_IO_SPACE 
                                       | PCI_ENABLE_MEMORY_SPACE);
    }

    //
    // Disable interrupt generation for IDE controllers until IDE is up and
    // running (See comment in PciConfigureIdeController)
    //
    if (pdoExtension->IoSpaceUnderNativeIdeControl) {
        pdoExtension->CommandEnables &= ~PCI_ENABLE_IO_SPACE;
    }

    //
    // Always enable the bus master bit - even for video controllers
    //
    pdoExtension->CommandEnables |= PCI_ENABLE_BUS_MASTER;

    //
    // Extract the PDO Resources (PCI driver internal style)
    // from the incoming resource list.
    //
    change = PciComputeNewCurrentSettings(
                 pdoExtension,
                 IrpSp->Parameters.StartDevice.AllocatedResources
                 );

    //
    // Remember if we ever move the device
    //

    if (change) {
        pdoExtension->MovedDevice = TRUE;
    }

#if DBG

    if (!change) {
        PciDebugPrint(
            PciDbgObnoxious,
            "PCI - START not changing resource settings.\n"
            );
    }

#endif

    //
    // The device should be powered up at this stage.
    //

    powerOn = FALSE;

    if (pdoExtension->PowerState.CurrentDeviceState != PowerDeviceD0) {

        POWER_STATE powerState;

        status = PciSetPowerManagedDevicePowerState(
                     pdoExtension,
                     PowerDeviceD0,
                     FALSE
                     );
        
        if (!NT_SUCCESS(status)) {
            PciCancelStateTransition(DeviceExtension, PciStarted);
            return STATUS_DEVICE_POWER_FAILURE;
        }

        powerState.DeviceState = PowerDeviceD0;

        PoSetPowerState(
            pdoExtension->PhysicalDeviceObject,
            DevicePowerState,
            powerState
            );

        //
        // Force PciSetResources to write the configuration
        // and other extraneous data to the device.
        //

        powerOn = TRUE;

        pdoExtension->PowerState.CurrentDeviceState = PowerDeviceD0;
    }

    //
    // Program the device with the resources allocated.
    //

    status = PciSetResources(
                 pdoExtension,
                 powerOn,
                 TRUE
                 );

    if (NT_SUCCESS(status)) {

        PciCommitStateTransition(DeviceExtension, PciStarted);
    } else {

        PciCancelStateTransition(DeviceExtension, PciStarted);
    }

    return status;
}

NTSTATUS
PciPdoIrpQueryRemoveDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    PPCI_PDO_EXTENSION pdoExtension;

    PAGED_CODE();
    
        
    pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;

    //
    // Don't allow the paging device (or a hibernate device) to
    // be removed or stopped
    //

    if (pdoExtension->PowerState.Hibernate ||
        pdoExtension->PowerState.Paging    ||
        pdoExtension->PowerState.CrashDump ||
        pdoExtension->OnDebugPath ||
        (pdoExtension->HackFlags & PCI_HACK_FAIL_QUERY_REMOVE)) {

        return STATUS_DEVICE_BUSY;
    }

    //
    // Don't allow devices with legacy drivers to be removed (even thought the
    // driver may be root enumerated)
    //

    if (pdoExtension->LegacyDriver) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (DeviceExtension->DeviceState == PciNotStarted) {

        return STATUS_SUCCESS;

    } else {

        return PciBeginStateTransition(DeviceExtension, PciNotStarted);
    }
}

NTSTATUS
PciPdoIrpRemoveDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    NTSTATUS status;
    PPCI_PDO_EXTENSION pdoExtension;

    PAGED_CODE();
    
        
    pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;

    //
    // If this PDO is for a PCI-PCI bridge, it has a pointer
    // to the FDO that was attached to it.  That FDO was destroyed
    // as a result of the IRP coming down the stack.  Clear the
    // pointer.  (Unconditionally as it is only set for bridges).
    //

    pdoExtension->BridgeFdoExtension = NULL;

    if (!pdoExtension->NotPresent) {

        //
        // Turn the device off.   (Checks for whether or not
        // this is a good idea are in the PciDecodeEnable routine).
        // While you might think this should be done only if we were already
        // headed to PciNotStarted, we may in fact have a boot config that
        // needs to be disabled.
        //

        PciDecodeEnable(pdoExtension, FALSE, NULL);

        //
        // Power it down if we are allowed to disable its decodes - if not then
        // don't turn it off.  eg. Don't turn of the VGA card...
        //
        if (pdoExtension->PowerState.CurrentDeviceState != PowerDeviceD3
        &&  PciCanDisableDecodes(pdoExtension, NULL, 0, 0)) {

            POWER_STATE powerState;

            status = PciSetPowerManagedDevicePowerState(
                         pdoExtension,
                         PowerDeviceD3,
                         FALSE
                         );

            pdoExtension->PowerState.CurrentDeviceState = PowerDeviceD3;

            powerState.DeviceState = PowerDeviceD3;

            PoSetPowerState(
                pdoExtension->PhysicalDeviceObject,
                DevicePowerState,
                powerState
                );
        }
    }

    //
    // We can get a remove in one of three states:
    // 1) We have received a QueryRemove/SurpriseRemove in which case we are
    //    transitioning to PciNotStarted.
    // 2) We were never started, so we are already in PciNotStarted.
    // 3) We started the PDO, but the FDO failed start. We are in PciStarted in
    //    this case.
    //
    if (!PciIsInTransitionToState(DeviceExtension, PciNotStarted)&&
        (DeviceExtension->DeviceState == PciStarted)) {

        PciBeginStateTransition(DeviceExtension, PciNotStarted);
    }

    if (PciIsInTransitionToState(DeviceExtension, PciNotStarted)) {

        PciCommitStateTransition(DeviceExtension, PciNotStarted);
    }

    if (pdoExtension->ReportedMissing) {

        status = PciBeginStateTransition(DeviceExtension, PciDeleted);
        PCI_ASSERT(NT_SUCCESS(status));

        PciCommitStateTransition(DeviceExtension, PciDeleted);

        PciPdoDestroy(pdoExtension->PhysicalDeviceObject);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PciPdoIrpCancelRemoveDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    PAGED_CODE();

            
    PciCancelStateTransition(DeviceExtension, PciNotStarted);
    return STATUS_SUCCESS;
}

NTSTATUS
PciPdoIrpStopDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    PAGED_CODE();

            
    //
    // Turn the device off.   (Checks for whether or not
    // this is a good idea are in the PciDecodeEnable routine).
    //
    PciDecodeEnable((PPCI_PDO_EXTENSION) DeviceExtension, FALSE, NULL);

    PciCommitStateTransition(DeviceExtension, PciStopped);

    return STATUS_SUCCESS;

}

NTSTATUS
PciPdoIrpQueryStopDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    PPCI_PDO_EXTENSION pdoExtension;

    PAGED_CODE();

            
    //
    // Don't allow the paging device (or a hibernate device) to
    // be removed or stopped
    //
    pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;

    if (pdoExtension->PowerState.Hibernate ||
        pdoExtension->PowerState.Paging    ||
        pdoExtension->PowerState.CrashDump ||
        pdoExtension->OnDebugPath) {

        return STATUS_DEVICE_BUSY;
    }

    //
    // Don't stop PCI->PCI and CardBus bridges
    //

    if (pdoExtension->BaseClass == PCI_CLASS_BRIDGE_DEV
        &&  (pdoExtension->SubClass == PCI_SUBCLASS_BR_PCI_TO_PCI
             || pdoExtension->SubClass == PCI_SUBCLASS_BR_CARDBUS)) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Don't allow devices with legacy drivers to be stopped (even thought the
    // driver may be root enumerated)
    //

    if (pdoExtension->LegacyDriver) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // If we cannot free the resources, do tell the OS.
    //
    if (!PciCanDisableDecodes(pdoExtension, NULL, 0, 0)) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    return PciBeginStateTransition(DeviceExtension, PciStopped);
}

NTSTATUS
PciPdoIrpCancelStopDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    PAGED_CODE();
    
        
    PciCancelStateTransition(DeviceExtension, PciStopped);
    return STATUS_SUCCESS;
}

NTSTATUS
PciPdoIrpQueryDeviceRelations(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    NTSTATUS status;
    PPCI_PDO_EXTENSION pdoExtension;

    PAGED_CODE();

    pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;

    switch(IrpSp->Parameters.QueryDeviceRelations.Type) {

        case EjectionRelations:
            status = PciQueryEjectionRelations(
                pdoExtension,
                (PDEVICE_RELATIONS*)&Irp->IoStatus.Information
                );
            break;

        case TargetDeviceRelation:
            status = PciQueryTargetDeviceRelations(
                pdoExtension,
                (PDEVICE_RELATIONS*)&Irp->IoStatus.Information
                );
            break;

        default:
            status = STATUS_NOT_SUPPORTED;
            break;
    }

    return status;
}

NTSTATUS
PciPdoIrpQueryInterface(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    NTSTATUS status;
    PPCI_PDO_EXTENSION pdoExtension;

    PAGED_CODE();

    
    pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;

    status = PciQueryInterface(
                pdoExtension,
                IrpSp->Parameters.QueryInterface.InterfaceType,
                IrpSp->Parameters.QueryInterface.Size,
                IrpSp->Parameters.QueryInterface.Version,
                IrpSp->Parameters.QueryInterface.InterfaceSpecificData,
                IrpSp->Parameters.QueryInterface.Interface,
                FALSE
                );

    if (!NT_SUCCESS(status)) {

        //
        // KLUDGE:   If this pdo has a fake FDO attatched to
        // it (because it's a cardbus controller), we should
        // check to see if this interface could have been supplied
        // by the FDO and supply it if so.
        //
        // Yes, this is really gross and yes it breaks the filter
        // model.  The correct thing is for cardbus to pass the
        // IRP here via the "backdoor" while it has it at the FDO
        // level.
        //

        PPCI_FDO_EXTENSION fakeFdo;

        fakeFdo = pdoExtension->BridgeFdoExtension;

        if (fakeFdo && (fakeFdo->Fake == TRUE)) {

            PCI_ASSERT((pdoExtension->BaseClass == PCI_CLASS_BRIDGE_DEV) &&
                   (pdoExtension->SubClass  == PCI_SUBCLASS_BR_CARDBUS));

            status = PciQueryInterface(
                        fakeFdo,
                        IrpSp->Parameters.QueryInterface.InterfaceType,
                        IrpSp->Parameters.QueryInterface.Size,
                        IrpSp->Parameters.QueryInterface.Version,
                        IrpSp->Parameters.QueryInterface.InterfaceSpecificData,
                        IrpSp->Parameters.QueryInterface.Interface,
                        FALSE
                        );
        }
    }

    return status;
}

NTSTATUS
PciPdoIrpQueryCapabilities(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    PAGED_CODE();

    
    return PciQueryCapabilities(
                (PPCI_PDO_EXTENSION) DeviceExtension,
                IrpSp->Parameters.DeviceCapabilities.Capabilities
                );
}

NTSTATUS
PciPdoIrpQueryId(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    PAGED_CODE();

    //
    // Get a pointer to the query id structure and process.
    //
    return PciQueryId(
        (PPCI_PDO_EXTENSION) DeviceExtension,
        IrpSp->Parameters.QueryId.IdType,
        (PWSTR*)&Irp->IoStatus.Information
        );
}

NTSTATUS
PciPdoIrpQueryResources(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    PAGED_CODE();
    
    
    return PciQueryResources(
        (PPCI_PDO_EXTENSION) DeviceExtension,
        (PCM_RESOURCE_LIST*)&Irp->IoStatus.Information
        );
}

NTSTATUS
PciPdoIrpQueryResourceRequirements(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    PAGED_CODE();
    
    
    return PciQueryRequirements(
        (PPCI_PDO_EXTENSION) DeviceExtension,
        (PIO_RESOURCE_REQUIREMENTS_LIST*)&Irp->IoStatus.Information
        );
}

NTSTATUS
PciPdoIrpQueryDeviceText(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    PAGED_CODE();

    return PciQueryDeviceText(
             (PPCI_PDO_EXTENSION) DeviceExtension,
             IrpSp->Parameters.QueryDeviceText.DeviceTextType,
             IrpSp->Parameters.QueryDeviceText.LocaleId,
             (PWSTR*)&Irp->IoStatus.Information
             );
}

NTSTATUS
PciPdoIrpReadConfig(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    NTSTATUS status;
    ULONG lengthRead;
    PPCI_PDO_EXTENSION pdoExtension;

    PAGED_CODE();
    
    pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;
    
    status = PciReadDeviceSpace(pdoExtension,
                                IrpSp->Parameters.ReadWriteConfig.WhichSpace,
                                IrpSp->Parameters.ReadWriteConfig.Buffer,
                                IrpSp->Parameters.ReadWriteConfig.Offset,
                                IrpSp->Parameters.ReadWriteConfig.Length,
                                &lengthRead
                                );
    
    //
    // Update the information files with the number of bytes read
    //
    
    Irp->IoStatus.Information = lengthRead;

    return status;
}

NTSTATUS
PciPdoIrpWriteConfig(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    NTSTATUS status;
    ULONG lengthWritten;
    PPCI_PDO_EXTENSION pdoExtension;

    PAGED_CODE();
    
    pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;
    
    status = PciWriteDeviceSpace(pdoExtension,
                                 IrpSp->Parameters.ReadWriteConfig.WhichSpace,
                                 IrpSp->Parameters.ReadWriteConfig.Buffer,
                                 IrpSp->Parameters.ReadWriteConfig.Offset,
                                 IrpSp->Parameters.ReadWriteConfig.Length,
                                 &lengthWritten
                                 );
    
    //
    // Update the information files with the number of bytes read
    //
    
    Irp->IoStatus.Information = lengthWritten;

    return status;
}

NTSTATUS
PciPdoIrpQueryBusInformation(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
    PAGED_CODE();

    
    return PciQueryBusInformation(
        (PPCI_PDO_EXTENSION) DeviceExtension,
        (PPNP_BUS_INFORMATION *) &Irp->IoStatus.Information
        );
}

NTSTATUS
PciPdoIrpDeviceUsageNotification(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    PAGED_CODE();

    
    return PciPdoDeviceUsage((PPCI_PDO_EXTENSION) DeviceExtension, Irp);
}

NTSTATUS
PciPdoIrpQueryLegacyBusInformation(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
    PPCI_PDO_EXTENSION PdoExtension;
    PLEGACY_BUS_INFORMATION information;

    PAGED_CODE();

        
    //
    // We're interested in IRP_MN_QUERY_LEGACY_BUS_INFORMATION on a
    // PDO if the PDO is for a CardBus bridge.  In this case, the
    // CardBus/PCMCIA FDO has passed the irp down so that we can
    // answer it correctly.
    //

    PdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;

    if (PciClassifyDeviceType(PdoExtension) != PciTypeCardbusBridge) {
        return STATUS_NOT_SUPPORTED;
    }

    information = ExAllocatePool(PagedPool, sizeof(LEGACY_BUS_INFORMATION));

    if (information == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(&information->BusTypeGuid, &GUID_BUS_TYPE_PCI, sizeof(GUID));
    information->LegacyBusType = PCIBus;
    information->BusNumber = PdoExtension->Dependent.type1.SecondaryBus;

    Irp->IoStatus.Information = (ULONG_PTR) information;

    return STATUS_SUCCESS;
}

NTSTATUS
PciPdoIrpSurpriseRemoval(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    PPCI_PDO_EXTENSION pdoExtension;

    PAGED_CODE();

            
    pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;

    //
    // There are two kinds of surprise removals
    // - Surprise removals due to removal of our device
    // - Surprise removals due to failure of our device to start
    //

    if (!pdoExtension->NotPresent) {

        //
        // Turn the device off.   (Checks for whether or not
        // this is a good idea are in the PciDecodeEnable routine).
        // While you might think this should be done only if we were already
        // headed to PciNotStarted, we may in fact have a boot config that
        // needs to be disabled. Note that we may turn it off again in remove
        // device. No big deal.
        //

        PciDecodeEnable(pdoExtension, FALSE, NULL);

        //
        // Power it down if we are allowed to disable its decodes - if not then
        // don't turn it off.  eg. Don't turn of the VGA card...
        //
        if (pdoExtension->PowerState.CurrentDeviceState != PowerDeviceD3
        &&  PciCanDisableDecodes(pdoExtension, NULL, 0, 0)) {

            POWER_STATE powerState;
            
            //
            // Power it down - if it fails we don't care - the hardware may be 
            // gone!
            //

            PciSetPowerManagedDevicePowerState(
                         pdoExtension,
                         PowerDeviceD3,
                         FALSE
                         );
            
            pdoExtension->PowerState.CurrentDeviceState = PowerDeviceD3;

            powerState.DeviceState = PowerDeviceD3;

            PoSetPowerState(
                pdoExtension->PhysicalDeviceObject,
                DevicePowerState,
                powerState
                );
        }
    }

    if (!pdoExtension->ReportedMissing) {

        PciBeginStateTransition(DeviceExtension, PciNotStarted);
        
    } else {

        //
        // The device is physically gone, don't dare touch it!
        //
        PciBeginStateTransition(DeviceExtension, PciSurpriseRemoved);
        PciCommitStateTransition(DeviceExtension, PciSurpriseRemoved);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
PciPdoIrpQueryDeviceState(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    PPCI_PDO_EXTENSION pdoExtension;
    
    PAGED_CODE();

    
    pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;
    //
    // Host brides cannot be disabled and the user should not be given a 
    // opportunity to do so.
    //
    if ((pdoExtension->BaseClass == PCI_CLASS_BRIDGE_DEV) &&
        (pdoExtension->SubClass  == PCI_SUBCLASS_BR_HOST)) {

        //
        // PNP_DEVICE_STATE us a ULONG value just passed in the information field 
        // of the IRP.
        //
        Irp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE;
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\pcip.h ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    pcip.h

Abstract:

    This module contains local definitions for PCI.SYS.

Author:

    Andrew Thornton (andrewth) 25-Jan-2000

Revision History:

--*/

#if !defined(_PCIP_H)
#define _PCIP_H

//
// Disable warnings of features used by the standard headers
//
// Disable warning C4214: nonstandard extension used : bit field types other than int
// Disable warning C4201: nonstandard extension used : nameless struct/union
// Disable warning C4115: named type definition in parentheses
// Disable warning C4127: conditional expression is constant
//

#pragma warning(disable:4214 4201 4115 4127)

#define _NTDRIVER_
#define _NTSRV_
#define _NTDDK_

#define InitSafeBootMode TempInitSafeBootMode
#include "ntos.h"
#undef InitSafeBootMode

#include "strsafe.h"
#include "pci.h"
#include "wdmguid.h"
#include "zwapi.h"
#include "pciirqmp.h"
#include "arbiter.h"
#include "acpiioct.h"
#include "pciintrf.h"
#include "pcicodes.h"
#include "pciverifier.h"
#include "acpitabl.h"

//
// regstr.h uses things of type WORD, which isn't around in kernel mode.
//

#define _IN_KERNEL_
#include "regstr.h"

//
// Pragmas to disable /W4 warnings so PCI can be compiled /W4
//
// Disable warning C4057; X differs in indirection to slightly different base types from Y 
// Disable warning C4244; '+='/'-=' : conversion from 'int' to 'X', possible loss of data
// Disable warning C4100: 'X' : unreferenced formal parameter
#pragma warning(disable: 4057 4244 4100)

//
// It seems that anything to do with the definitions of GUIDs is
// bogus.
//

typedef const GUID * PGUID;

#define PciCompareGuid(a,b)                                         \
    (RtlEqualMemory((PVOID)(a), (PVOID)(b), sizeof(GUID)))

//
// Internal constants.
//

#define PCI_CM_RESOURCE_VERSION     1
#define PCI_CM_RESOURCE_REVISION    1
#define PCI_MAX_CONFIG_TYPE (PCI_CARDBUS_BRIDGE_TYPE)

//
// Internal bug codes.
//

#define PCI_BUGCODE_TOO_MANY_CONFIG_GUESSES     0xdead0010

//
// Internal Controls
//

#define PCI_BOOT_CONFIG_PREFERRED           1
#define PCIIDE_HACKS                        1
#define PCI_NT50_BETA1_HACKS                1
#define PCI_DISABLE_LAST_CHANCE_INTERFACES  1
#define MSI_SUPPORTED                       0
#define PCI_NO_MOVE_MODEM_IN_TOSHIBA        1

//
// Systemwide hack flags. These flags are a bitmask that can be set to zero so
// as to eliminate support for the hack.
//
#define PCIFLAG_IGNORE_PREFETCHABLE_MEMORY_AT_ROOT_HACK     0x00000001

//
// Video Hacks
//

#define PCI_S3_HACKS                        1
#define PCI_CIRRUS_54XX_HACK                1


#define PCI_IS_ATI_M1(_PdoExtension)                \
    ((_PdoExtension)->VendorId == 0x1002            \
        && ((_PdoExtension)->DeviceId == 0x4C42     \
         || (_PdoExtension)->DeviceId == 0x4C44     \
         || (_PdoExtension)->DeviceId == 0x4C49     \
         || (_PdoExtension)->DeviceId == 0x4C4D     \
         || (_PdoExtension)->DeviceId == 0x4C4E     \
         || (_PdoExtension)->DeviceId == 0x4C50     \
         || (_PdoExtension)->DeviceId == 0x4C51     \
         || (_PdoExtension)->DeviceId == 0x4C52     \
         || (_PdoExtension)->DeviceId == 0x4C53))

#define INTEL_ICH_HACKS                     1

#if INTEL_ICH_HACKS

#define PCI_IS_INTEL_ICH(_PdoExtension)             \
   ((_PdoExtension)->VendorId == 0x8086             \
       && ((_PdoExtension)->DeviceId == 0x2418      \
        || (_PdoExtension)->DeviceId == 0x2428      \
        || (_PdoExtension)->DeviceId == 0x244E      \
        || (_PdoExtension)->DeviceId == 0x2448))

#else

#define PCI_IS_INTEL_ICH(_PdoExtension)     FALSE

#endif

//
// Translatable resources
//

#define ADDRESS_SPACE_MEMORY                0x0
#define ADDRESS_SPACE_PORT                  0x1
#define ADDRESS_SPACE_USER_MEMORY           0x2
#define ADDRESS_SPACE_USER_PORT             0x3
#define ADDRESS_SPACE_DENSE_MEMORY          0x4
#define ADDRESS_SPACE_USER_DENSE_MEMORY     0x6

//
// Add our tag signature
//

#ifdef ExAllocatePool

#undef ExAllocatePool

#endif

#define ExAllocatePool( t, s ) ExAllocatePoolWithTag( (t), (s), 'BicP' )

//
// Lock and Unlock
//

typedef struct _PCI_LOCK {
    KSPIN_LOCK  Atom;
    KIRQL       OldIrql;

#if DBG

    PUCHAR      File;
    ULONG       Line;

#endif

} PCI_LOCK, *PPCI_LOCK;

#if DBG

#define PCI_LOCK_OBJECT(x)                                          \
    (x)->Lock.File = __FILE__,                                      \
    (x)->Lock.Line = __LINE__,                                      \
    KeAcquireSpinLock(&(x)->Lock.Atom, &(x)->Lock.OldIrql)

#else

#define PCI_LOCK_OBJECT(x)                                          \
    KeAcquireSpinLock(&(x)->Lock.Atom, &(x)->Lock.OldIrql)

#endif
#define PCI_UNLOCK_OBJECT(x)                                        \
    KeReleaseSpinLock(&(x)->Lock.Atom, (x)->Lock.OldIrql)



#define PciAcquireGlobalLock()                                      \
    ExAcquireFastMutex(&PciGlobalLock)

#define PciReleaseGlobalLock()                                      \
    ExReleaseFastMutex(&PciGlobalLock)


//
// PCM_PARTIAL_RESOURCE_DESCRIPTOR
// PciFirstCmResource(
//     PCM_RESOURCE_LIST List
//     )
//
// Routine Description:
//
//   Returns the address of the first CM PARTIAL RESOURCE DESCRIPTOR
//   in the given CM RESOURCE LIST.
//

#define PciFirstCmResource(x)                                           \
    (x)->List[0].PartialResourceList.PartialDescriptors


//
// ULONG
// PciGetConfigurationType(
//     PPCI_COMMON_CONFIG x
//     )
//
// Routine Description:
//
//   Returns the configuration type subfield from the HeaderType
//   field in PCI Configuration Space.
//

#define PciGetConfigurationType(x) PCI_CONFIGURATION_TYPE(x)

//
// PPCI_FDO_EXTENSION
// PCI_PARENT_FDO(
//     PPCI_PDO_EXTENSION x
//     )
//
// Routine Description:
//
//   Returns a pointer to the FDO extension that created PDO x as a result
//   of enumeration.  That is, the FDO extension of the bus that owns this
//   device.
//

#define PCI_PARENT_FDOX(x) ((x)->ParentFdoExtension)


//
// PPCI_FDO_EXTENSION
// PCI_ROOT_FDOX(
//     PPCI_PDO_EXTENSION x
//     )
//
// Routine Description:
//
//   Returns a pointer to the FDO extension for the root bus (CPU-PCI Bridge)
//   that this device is situated under.
//

#define PCI_ROOT_FDOX(x) ((x)->ParentFdoExtension->BusRootFdoExtension)


//
// PDEVICE_OBJECT
// PCI_PARENT_PDO(
//     PPCI_PDO_EXTENSION x
//     )
//
// Routine Description:
//
//   Returns a pointer to the PDO for the parent bus.
//

#define PCI_PARENT_PDO(x) ((x)->ParentFdoExtension->PhysicalDeviceObject)

//
// PPCI_PDO_EXTENSION
// PCI_BRIDGE_PDO(
//     PPCI_FDO_EXTENSION x
//     )
//
// Routine Description:
//
//   Returns a pointer to the PDO for the bridge given its FDO
//

#define PCI_BRIDGE_PDO(x) ((PPCI_PDO_EXTENSION)((x)->PhysicalDeviceObject->DeviceExtension))



//
// PPCI_FDO_EXTENSION
// PCI_BRIDGE_FDO(
//     PPCI_PDO_EXTENSION x
//     )
//
// Routine Description:
//
//   Returns a pointer to the FDO for the bridge given its PDO
//

#define PCI_BRIDGE_FDO(x) ((PPCI_FDO_EXTENSION)((x)->BridgeFdoExtension))

//
// BOOLEAN
// PCI_IS_ROOT_FDO(
//     PPCI_FDO_EXTENSION x
//     )
//
// Routine Description:
//
//   Returns TRUE if x is an FDO for a PCI ROOT bus.
//

#define PCI_IS_ROOT_FDO(x) ((BOOLEAN)((x) == (x)->BusRootFdoExtension))

//
// BOOLEAN
// PCI_PDO_ON_ROOT(
//     PPCI_PDO_EXTENSION x
//     )
//
// Routine Description:
//

#define PCI_PDO_ON_ROOT(x)  ((BOOLEAN)PCI_IS_ROOT_FDO(PCI_PARENT_FDOX(x)))

//
// UCHAR
// PCI_DEVFUNC(
//     PPCI_PDO_EXTENSION x
//     )
//
// Routine Description:
//
//   Returns the 5 bit device number and 3 bit function number for this
//   device as a single 8 bit quantity.
//

#define PCI_DEVFUNC(x)    (((x)->Slot.u.bits.DeviceNumber << 3) | \
                          (x)->Slot.u.bits.FunctionNumber)

//
//
// VOID
// PciConstStringToUnicodeString(
//     OUT PUNICODE_STRING u,
//     IN  PCWSTR p
//     )
//
//
#define PciConstStringToUnicodeString(u, p)                                     \
    (u)->Length = ((u)->MaximumLength = sizeof((p))) - sizeof(WCHAR);   \
    (u)->Buffer = (p)

//
// Name of the volative key under the DeviceParameters key where data that needs
// to be persistent accross removes, but NOT reboots is stored
//
#define BIOS_CONFIG_KEY_NAME L"BiosConfig"


//
// Assert this is a device object created by PCI
//

#define ASSERT_PCI_DEVICE_OBJECT(_DeviceObject) \
    PCI_ASSERT((_DeviceObject)->DriverObject == PciDriverObject)

#define ASSERT_MUTEX_HELD(x)

//
// IRPs can be handled the following ways
//
typedef enum _PCI_DISPATCH_STYLE {

    IRP_COMPLETE, // Complete IRP, adjust status as neccessary
    IRP_DOWNWARD, // Dispatch on the way down, adjust status as neccessary
    IRP_UPWARD,   // Dispatch on the way up, adjust status as neccessary
    IRP_DISPATCH  // Dispatch downward, don't touch afterwards
} PCI_DISPATCH_STYLE;

//
// The following routines are dispatched to depending on header type.
//

typedef
VOID
(*PMASSAGEHEADERFORLIMITSDETERMINATION)(
    IN struct _PCI_CONFIGURABLE_OBJECT *This
    );

typedef
VOID
(*PSAVELIMITS)(
    IN struct _PCI_CONFIGURABLE_OBJECT *This
    );

typedef
VOID
(*PSAVECURRENTSETTINGS)(
    IN struct _PCI_CONFIGURABLE_OBJECT *This
    );

typedef
VOID
(*PRESTORECURRENT)(
    IN struct _PCI_CONFIGURABLE_OBJECT *This
    );

typedef
VOID
(*PCHANGERESOURCESETTINGS)(
    IN struct _PCI_PDO_EXTENSION * PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    );

typedef
VOID
(*PGETADDITIONALRESOURCEDESCRIPTORS)(
    IN struct _PCI_PDO_EXTENSION * PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig,
    IN PIO_RESOURCE_DESCRIPTOR Resource
    );

typedef
NTSTATUS
(*PRESETDEVICE)(
    IN struct _PCI_PDO_EXTENSION * PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    );

typedef struct {
    PMASSAGEHEADERFORLIMITSDETERMINATION    MassageHeaderForLimitsDetermination;
    PRESTORECURRENT                         RestoreCurrent;
    PSAVELIMITS                             SaveLimits;
    PSAVECURRENTSETTINGS                    SaveCurrentSettings;
    PCHANGERESOURCESETTINGS                 ChangeResourceSettings;
    PGETADDITIONALRESOURCEDESCRIPTORS       GetAdditionalResourceDescriptors;
    PRESETDEVICE                            ResetDevice;
} PCI_CONFIGURATOR, *PPCI_CONFIGURATOR;

//
// Internal structure definitions follow
//


typedef enum {
    PciBridgeIo = 0x10,
    PciBridgeMem,
    PciBridgePrefetch,
    PciBridgeMaxPassThru
} PCI_BRIDGE_PASSTHRU;

typedef enum {

    //
    // Device Object Extension Types
    //

    PciPdoExtensionType = 'icP0',
    PciFdoExtensionType,

    //
    // Arbitration Types.  (These are also secondary extensions).
    //

    PciArb_Io,
    PciArb_Memory,
    PciArb_Interrupt,
    PciArb_BusNumber,

    //
    // Translation Types.  (These are also secondary extensions).
    //

    PciTrans_Interrupt,

    //
    // Other exposed interfaces.
    //

    PciInterface_BusHandler,
    PciInterface_IntRouteHandler,
    PciInterface_PciCb,
    PciInterface_LegacyDeviceDetection,
    PciInterface_PmeHandler,
    PciInterface_DevicePresent,
    PciInterface_NativeIde,
    PciInterface_Location,
    PciInterface_AgpTarget

} PCI_SIGNATURE;

#define PCI_EXTENSIONTYPE_FDO PciFdoExtensionType
#define PCI_EXTENSIONTYPE_PDO PciPdoExtensionType

typedef enum {
    PciTypeUnknown,
    PciTypeHostBridge,
    PciTypePciBridge,
    PciTypeCardbusBridge,
    PciTypeDevice
} PCI_OBJECT_TYPE;

typedef enum {
    PciPrivateUndefined,
    PciPrivateBar,
    PciPrivateIsaBar,
    PciPrivateSkipList
} PCI_PRIVATE_RESOURCE_TYPES;

typedef
VOID
(*PSECONDARYEXTENSIONDESTRUCTOR)(
    IN PVOID Extension
    );

typedef struct {
    SINGLE_LIST_ENTRY               List;
    PCI_SIGNATURE                   ExtensionType;
    PSECONDARYEXTENSIONDESTRUCTOR   Destructor;
} PCI_SECONDARY_EXTENSION, *PPCI_SECONDARY_EXTENSION;

//
// Define a structure to contain current and limit settings
// for any (currently defined) PCI header type.
//
// Currently type 0 defines the greatest number of possible
// resources but we shall do it programmatically anyway.
//
// Type 0 and type 1 also have a ROM base address, additionally,
// type 1 has three ranges that aren't included in its address
// count but should be.
//

#define PCI_TYPE0_RANGE_COUNT   ((PCI_TYPE0_ADDRESSES) + 1)
#define PCI_TYPE1_RANGE_COUNT   ((PCI_TYPE1_ADDRESSES) + 4)
#define PCI_TYPE2_RANGE_COUNT   ((PCI_TYPE2_ADDRESSES) + 1)

#if PCI_TYPE0_RANGE_COUNT > PCI_TYPE1_RANGE_COUNT

    #if PCI_TYPE0_RANGE_COUNT > PCI_TYPE2_RANGE_COUNT

        #define PCI_MAX_RANGE_COUNT PCI_TYPE0_RANGE_COUNT

    #else

        #define PCI_MAX_RANGE_COUNT PCI_TYPE2_RANGE_COUNT

    #endif

#else

    #if PCI_TYPE1_RANGE_COUNT > PCI_TYPE2_RANGE_COUNT

        #define PCI_MAX_RANGE_COUNT PCI_TYPE1_RANGE_COUNT

    #else

        #define PCI_MAX_RANGE_COUNT PCI_TYPE2_RANGE_COUNT

    #endif

#endif


typedef union {
    struct {
        UCHAR Spare[4];
    } type0;

    struct {
        UCHAR   PrimaryBus;
        UCHAR   SecondaryBus;
        UCHAR   SubordinateBus;
        BOOLEAN SubtractiveDecode:1;
        BOOLEAN IsaBitSet:1;
        BOOLEAN VgaBitSet:1;
        BOOLEAN WeChangedBusNumbers:1;
        BOOLEAN IsaBitRequired:1;
    } type1;

    struct {
        UCHAR   PrimaryBus;
        UCHAR   SecondaryBus;
        UCHAR   SubordinateBus;
        BOOLEAN SubtractiveDecode:1;
        BOOLEAN IsaBitSet:1;
        BOOLEAN VgaBitSet:1;
        BOOLEAN WeChangedBusNumbers:1;
        BOOLEAN IsaBitRequired:1;
    } type2;

} PCI_HEADER_TYPE_DEPENDENT;

typedef struct {
    IO_RESOURCE_DESCRIPTOR          Limit[PCI_MAX_RANGE_COUNT];
    CM_PARTIAL_RESOURCE_DESCRIPTOR  Current[PCI_MAX_RANGE_COUNT];
} PCI_FUNCTION_RESOURCES, *PPCI_FUNCTION_RESOURCES;

//
// Indices for the PCI_FUNCTION_RESOURCES arrays for different header types
//

#define PCI_DEVICE_BAR_0            0
#define PCI_DEVICE_BAR_1            1
#define PCI_DEVICE_BAR_2            2
#define PCI_DEVICE_BAR_3            3
#define PCI_DEVICE_BAR_4            4
#define PCI_DEVICE_BAR_5            5
#define PCI_DEVICE_BAR_ROM          6

#define PCI_BRIDGE_BAR_0            0
#define PCI_BRIDGE_BAR_1            1
#define PCI_BRIDGE_IO_WINDOW        2
#define PCI_BRIDGE_MEMORY_WINDOW    3
#define PCI_BRIDGE_PREFETCH_WINDOW  4
#define PCI_BRIDGE_BAR_ROM          5

#define PCI_CARDBUS_SOCKET_BAR      0
#define PCI_CARDBUS_MEMORY_WINDOW_0 1
#define PCI_CARDBUS_MEMORY_WINDOW_1 2
#define PCI_CARDBUS_IO_WINDOW_0     3
#define PCI_CARDBUS_IO_WINDOW_1     4
#define PCI_CARDBUS_LEGACY_BAR      5 // Not used



typedef struct {
    ULONGLONG   Total;
    ULONG       Alignment;
} PCI_RESOURCE_ACCUMULATOR, *PPCI_RESOURCE_ACCUMULATOR;

typedef struct {

    SYSTEM_POWER_STATE  CurrentSystemState;
    DEVICE_POWER_STATE  CurrentDeviceState;
    SYSTEM_POWER_STATE  SystemWakeLevel;
    DEVICE_POWER_STATE  DeviceWakeLevel;
    DEVICE_POWER_STATE  SystemStateMapping[PowerSystemMaximum];

    PIRP                WaitWakeIrp;
    PDRIVER_CANCEL      SavedCancelRoutine;

    // device usage...
    LONG                Paging;
    LONG                Hibernate;
    LONG                CrashDump;

} PCI_POWER_STATE, *PPCI_POWER_STATE;

typedef struct _PCI_PDO_EXTENSION          *PPCI_PDO_EXTENSION;
typedef struct _PCI_FDO_EXTENSION          *PPCI_FDO_EXTENSION;
typedef struct _PCI_COMMON_EXTENSION   *PPCI_COMMON_EXTENSION;


//
// This is an Irp Dispatch Handler for PCI
//
typedef NTSTATUS (*PCI_MN_DISPATCH_FUNCTION) (
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

typedef struct _PCI_MN_DISPATCH_TABLE {

    PCI_DISPATCH_STYLE        DispatchStyle;
    PCI_MN_DISPATCH_FUNCTION  DispatchFunction;

} PCI_MN_DISPATCH_TABLE, *PPCI_MN_DISPATCH_TABLE;

//
// This is a table that contains everything neccessary to handle Power, PnP,
// and other IRPs.
//
typedef struct _PCI_MJ_DISPATCH_TABLE {

    ULONG                     PnpIrpMaximumMinorFunction;
    PPCI_MN_DISPATCH_TABLE    PnpIrpDispatchTable;
    ULONG                     PowerIrpMaximumMinorFunction;
    PPCI_MN_DISPATCH_TABLE    PowerIrpDispatchTable;
    PCI_DISPATCH_STYLE        SystemControlIrpDispatchStyle;
    PCI_MN_DISPATCH_FUNCTION  SystemControlIrpDispatchFunction;
    PCI_DISPATCH_STYLE        OtherIrpDispatchStyle;
    PCI_MN_DISPATCH_FUNCTION  OtherIrpDispatchFunction;

} PCI_MJ_DISPATCH_TABLE, *PPCI_MJ_DISPATCH_TABLE;

typedef
VOID
(*PCRITICALROUTINE)(
    IN PVOID Extension,
    IN PVOID Context
    );

typedef struct _PCI_CRITICAL_ROUTINE_CONTEXT {

    volatile LONG Gate;
    volatile LONG Barrier;

    PCRITICALROUTINE Routine;
    PVOID Extension;
    PVOID Context;

} PCI_CRITICAL_ROUTINE_CONTEXT, *PPCI_CRITICAL_ROUTINE_CONTEXT;

//
// Structure used for storing MSI routing info
// in the PDO extention.
//

typedef struct _PCI_MSI_INFO {
   ULONG_PTR MessageAddress;
   UCHAR CapabilityOffset;
   USHORT MessageData;
} PCI_MSI_INFO, *PPCI_MSI_INFO;

//
// This much must be common to both the PDO and FDO extensions.
//
typedef struct _PCI_COMMON_EXTENSION {
    PVOID                           Next;
    PCI_SIGNATURE                   ExtensionType;
    PPCI_MJ_DISPATCH_TABLE          IrpDispatchTable;
    UCHAR                           DeviceState;
    UCHAR                           TentativeNextState;
    FAST_MUTEX                      SecondaryExtMutex;
} PCI_COMMON_EXTENSION;

typedef struct _PCI_PDO_EXTENSION{
    PPCI_PDO_EXTENSION                  Next;
    PCI_SIGNATURE                   ExtensionType;
    PPCI_MJ_DISPATCH_TABLE          IrpDispatchTable;
    UCHAR                           DeviceState;
    UCHAR                           TentativeNextState;
    FAST_MUTEX                      SecondaryExtMutex;
    PCI_SLOT_NUMBER                 Slot;
    PDEVICE_OBJECT                  PhysicalDeviceObject;
    PPCI_FDO_EXTENSION                  ParentFdoExtension;
    SINGLE_LIST_ENTRY               SecondaryExtension;
    ULONG                           BusInterfaceReferenceCount;
    ULONG                           AgpInterfaceReferenceCount;
    USHORT                          VendorId;
    USHORT                          DeviceId;
    USHORT                          SubsystemVendorId;
    USHORT                          SubsystemId;
    UCHAR                           RevisionId;
    UCHAR                           ProgIf;
    UCHAR                           SubClass;
    UCHAR                           BaseClass;
    UCHAR                           AdditionalResourceCount;
    UCHAR                           AdjustedInterruptLine;
    UCHAR                           InterruptPin;
    UCHAR                           RawInterruptLine;
    UCHAR                           CapabilitiesPtr;
    UCHAR                           SavedLatencyTimer;
    UCHAR                           SavedCacheLineSize;
    UCHAR                           HeaderType;

    BOOLEAN                         NotPresent;
    BOOLEAN                         ReportedMissing;
    BOOLEAN                         ExpectedWritebackFailure;
    BOOLEAN                         NoTouchPmeEnable;
    BOOLEAN                         LegacyDriver;
    BOOLEAN                         UpdateHardware;
    BOOLEAN                         MovedDevice;
    BOOLEAN                         DisablePowerDown;
    BOOLEAN                         NeedsHotPlugConfiguration;
    BOOLEAN                         IDEInNativeMode;
    BOOLEAN                         BIOSAllowsIDESwitchToNativeMode; // NATA method said it was OK
    BOOLEAN                         IoSpaceUnderNativeIdeControl;
    BOOLEAN                         OnDebugPath;    // Includes headless port

#if MSI_SUPPORTED
    BOOLEAN                         CapableMSI;
    PCI_MSI_INFO                    MsiInfo;
#endif // MSI_SUPPORTED

    PCI_POWER_STATE                 PowerState;

    PCI_HEADER_TYPE_DEPENDENT       Dependent;
    ULONGLONG                       HackFlags;
    PPCI_FUNCTION_RESOURCES         Resources;
    PPCI_FDO_EXTENSION              BridgeFdoExtension;
    PPCI_PDO_EXTENSION              NextBridge;
    PPCI_PDO_EXTENSION              NextHashEntry;
    PCI_LOCK                        Lock;
    PCI_PMC                         PowerCapabilities;
    UCHAR                           TargetAgpCapabilityId;
    USHORT                          CommandEnables; // What we want to enable for this device
    USHORT                          InitialCommand; // How we found the command register
} PCI_PDO_EXTENSION;

#define ASSERT_PCI_PDO_EXTENSION(x)                                     \
    PCI_ASSERT((x)->ExtensionType == PciPdoExtensionType)

typedef struct _PCI_FDO_EXTENSION{
    SINGLE_LIST_ENTRY      List;                  // List of pci.sys's FDOs
    PCI_SIGNATURE          ExtensionType;         // PciFdoExtensionType
    PPCI_MJ_DISPATCH_TABLE IrpDispatchTable;      // Irp Dispatch Table to use.
    UCHAR                  DeviceState;
    UCHAR                  TentativeNextState;
    FAST_MUTEX             SecondaryExtMutex;
    PDEVICE_OBJECT         PhysicalDeviceObject;  // PDO passed into AddDevice()
    PDEVICE_OBJECT         FunctionalDeviceObject;// FDO that points here
    PDEVICE_OBJECT         AttachedDeviceObject;  // next DO in chain.
    FAST_MUTEX             ChildListMutex;
    PPCI_PDO_EXTENSION     ChildPdoList;
    PPCI_FDO_EXTENSION     BusRootFdoExtension;   // points to top of this tree
    PPCI_FDO_EXTENSION     ParentFdoExtension;    // points to the parent bridge
    PPCI_PDO_EXTENSION     ChildBridgePdoList;
    PPCI_BUS_INTERFACE_STANDARD PciBusInterface;  // Only for a root
    UCHAR                 MaxSubordinateBus;      // Only for a root
    PBUS_HANDLER          BusHandler;
    UCHAR                 BaseBus;                // Bus number for THIS bus
    BOOLEAN               Fake;                   // True if not a real FDOx
    BOOLEAN               Scanned;                // True is bus enumerated
    BOOLEAN               ArbitersInitialized;
    BOOLEAN               BrokenVideoHackApplied;
    BOOLEAN               Hibernated;
    PCI_POWER_STATE       PowerState;
    SINGLE_LIST_ENTRY     SecondaryExtension;
    ULONG                 ChildWaitWakeCount;
#if INTEL_ICH_HACKS
    PPCI_COMMON_CONFIG    IchHackConfig;
#endif
    PCI_LOCK              Lock;

    //
    // Information from ACPI _HPP to apply to hot plugged cards,
    // Acquired indicates the rest are valid.
    //
    struct {
        BOOLEAN               Acquired;
        UCHAR                 CacheLineSize;
        UCHAR                 LatencyTimer;
        BOOLEAN               EnablePERR;
        BOOLEAN               EnableSERR;
    } HotPlugParameters;

    ULONG                 BusHackFlags;            // see PCI_BUS_HACK_*
} PCI_FDO_EXTENSION;


#define ASSERT_PCI_FDO_EXTENSION(x)                                     \
    PCI_ASSERT((x)->ExtensionType == PciFdoExtensionType)

typedef struct _PCI_CONFIGURABLE_OBJECT {
    PPCI_PDO_EXTENSION      PdoExtension;
    PPCI_COMMON_CONFIG  Current;
    PPCI_COMMON_CONFIG  Working;
    PPCI_CONFIGURATOR   Configurator;
    ULONG               PrivateData;
    USHORT              Status;
    USHORT              Command;
} PCI_CONFIGURABLE_OBJECT, *PPCI_CONFIGURABLE_OBJECT;

typedef struct _PCI_ASSIGNED_RESOURCE_EXTENSION {
    ULONG   ResourceIdentifier;
} PCI_ASSIGNED_RESOURCE_EXTENSION, *PPCI_ASSIGNED_RESOURCE_EXTENSION;

//
// The PCI_COMMON_CONFIG includes the 192 bytes of device specific
// data.  The following structure is used to get only the first 64
// bytes which is all we care about most of the time anyway.  We cast
// to PCI_COMMON_CONFIG to get at the actual fields.
//

typedef struct {
    ULONG Reserved[PCI_COMMON_HDR_LENGTH/sizeof(ULONG)];
} PCI_COMMON_HEADER, *PPCI_COMMON_HEADER;

//
// In order to be able to arbitrate interrupts for device with
// legacy drivers, we have to do some bookkeeping.
//

typedef struct {
    SINGLE_LIST_ENTRY List;
    PDEVICE_OBJECT LegacyDeviceObject;
    ULONG          Bus;
    ULONG          PciSlot;
    UCHAR          InterruptLine;
    UCHAR          InterruptPin;
    UCHAR          ClassCode;
    UCHAR          SubClassCode;
    PDEVICE_OBJECT ParentPdo;
    ROUTING_TOKEN  RoutingToken;
    PPCI_PDO_EXTENSION PdoExtension;
} LEGACY_DEVICE, *PLEGACY_DEVICE;

extern PLEGACY_DEVICE PciLegacyDeviceHead;


#define PCI_HACK_FLAG_SUBSYSTEM 0x01
#define PCI_HACK_FLAG_REVISION  0x02

typedef struct _PCI_HACK_TABLE_ENTRY {
    USHORT VendorID;
    USHORT DeviceID;
    USHORT SubVendorID;
    USHORT SubSystemID;
    ULONGLONG HackFlags;
    UCHAR   RevisionID;
    UCHAR   Flags;
} PCI_HACK_TABLE_ENTRY, *PPCI_HACK_TABLE_ENTRY;

typedef struct _ARBITER_MEMORY_EXTENSION {

    //
    // Indicates that this arbiter will arbitrate prefetchable memory
    //
    BOOLEAN PrefetchablePresent;

    //
    // Indicates that this arbiter has been initialized
    //
    BOOLEAN Initialized;

    //
    // The number of prefetchable ranges
    //
    USHORT PrefetchableCount;

    //
    // The allocation ordering list to be used for prefetchable memory
    //
    ARBITER_ORDERING_LIST PrefetchableOrdering;

    //
    // The allocation ordering list to be used for standard memory
    //
    ARBITER_ORDERING_LIST NonprefetchableOrdering;

    //
    // The original memory allocation ordering (from the registry)
    //
    ARBITER_ORDERING_LIST OriginalOrdering;

} ARBITER_MEMORY_EXTENSION, *PARBITER_MEMORY_EXTENSION;



NTSTATUS
PciCacheLegacyDeviceRouting(
    IN PDEVICE_OBJECT       LegacyDO,
    IN ULONG                Bus,
    IN ULONG                PciSlot,
    IN UCHAR                InterruptLine,
    IN UCHAR                InterruptPin,
    IN UCHAR                ClassCode,
    IN UCHAR                SubClassCode,
    IN PDEVICE_OBJECT       ParentPdo,
    IN PPCI_PDO_EXTENSION   PdoExtension,
    OUT PDEVICE_OBJECT      *OldLegacyDO
    );


//
// Global data declarations follow
//

extern PDRIVER_OBJECT           PciDriverObject;
extern UNICODE_STRING           PciServiceRegistryPath;
extern SINGLE_LIST_ENTRY        PciFdoExtensionListHead;
extern FAST_MUTEX               PciGlobalLock;
extern FAST_MUTEX               PciBusLock;
extern LONG                     PciRootBusCount;
extern BOOLEAN                  PciAssignBusNumbers;
extern PPCI_FDO_EXTENSION       PciRootExtensions;
extern RTL_RANGE_LIST           PciIsaBitExclusionList;
extern RTL_RANGE_LIST           PciVgaAndIsaBitExclusionList;
extern ULONG                    PciSystemWideHackFlags;
extern ULONG                    PciEnableNativeModeATA;
extern PPCI_HACK_TABLE_ENTRY    PciHackTable;
extern BOOLEAN                  PciRunningDatacenter;

//
// Watchdog timer resource table
//
extern PWATCHDOG_TIMER_RESOURCE_TABLE WdTable;


// arb_comn.h

#define INSTANCE_NAME_LENGTH 24

typedef struct _PCI_ARBITER_INSTANCE {

    //
    // Standard secondary extension header
    //

    PCI_SECONDARY_EXTENSION     Header;

    //
    // Back pointer to the interface we are a context of
    //

    struct _PCI_INTERFACE      *Interface;

    //
    // Pointer to owning device object (extension).
    //

    PPCI_FDO_EXTENSION              BusFdoExtension;

    //
    // Arbiter description.
    //

    WCHAR                       InstanceName[INSTANCE_NAME_LENGTH];

    //
    // The common instance data
    //

    ARBITER_INSTANCE            CommonInstance;

} PCI_ARBITER_INSTANCE, *PPCI_ARBITER_INSTANCE;



NTSTATUS
PciArbiterInitializeInterface(
    IN  PVOID DeviceExtension,
    IN  PCI_SIGNATURE DesiredInterface,
    IN OUT PARBITER_INTERFACE ArbiterInterface
    );

NTSTATUS
PciInitializeArbiterRanges(
    IN  PPCI_FDO_EXTENSION FdoExtension,
    IN  PCM_RESOURCE_LIST ResourceList
    );

NTSTATUS
PciInitializeArbiters(
    IN  PVOID DeviceExtension
    );

VOID
PciReferenceArbiter(
    IN PVOID Context
    );

VOID
PciDereferenceArbiter(
    IN PVOID Context
    );

VOID
ario_ApplyBrokenVideoHack(
    IN PPCI_FDO_EXTENSION FdoExtension
    );


//    busno.h

BOOLEAN
PciAreBusNumbersConfigured(
    IN PPCI_PDO_EXTENSION Bridge
    );


VOID
PciConfigureBusNumbers(
    PPCI_FDO_EXTENSION Parent
    );

VOID
PciSetBusNumbers(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN UCHAR Primary,
    IN UCHAR Secondary,
    IN UCHAR Subordinate
    );

//    cardbus.h

VOID
Cardbus_MassageHeaderForLimitsDetermination(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
Cardbus_RestoreCurrent(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
Cardbus_SaveLimits(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
Cardbus_SaveCurrentSettings(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
Cardbus_ChangeResourceSettings(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    );

VOID
Cardbus_GetAdditionalResourceDescriptors(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig,
    IN PIO_RESOURCE_DESCRIPTOR Resource
    );

NTSTATUS
Cardbus_ResetDevice(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    );

//    config.h

VOID
PciReadDeviceConfig(
    IN PPCI_PDO_EXTENSION Pdo,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

VOID
PciWriteDeviceConfig(
    IN PPCI_PDO_EXTENSION Pdo,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

VOID
PciReadSlotConfig(
    IN PPCI_FDO_EXTENSION ParentFdo,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

VOID
PciWriteSlotConfig(
    IN PPCI_FDO_EXTENSION ParentFdo,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

UCHAR
PciGetAdjustedInterruptLine(
    IN PPCI_PDO_EXTENSION Pdo
    );

NTSTATUS
PciExternalReadDeviceConfig(
    IN PPCI_PDO_EXTENSION Pdo,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
PciExternalWriteDeviceConfig(
    IN PPCI_PDO_EXTENSION Pdo,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
PciGetConfigHandlers(
    IN PPCI_FDO_EXTENSION FdoExtension
    );

//
// Macros to access common registers in config space
//

//
// VOID
// PciGetCommandRegister(
//      PPCI_PDO_EXTENSION _PdoExt,
//      PUSHORT _Command
//  );
//
#define PciGetCommandRegister(_PdoExt, _Command)                    \
    PciReadDeviceConfig((_PdoExt),                                  \
                        (_Command),                                 \
                        FIELD_OFFSET(PCI_COMMON_CONFIG, Command),   \
                        sizeof(USHORT)                              \
                        );

//
// VOID
// PciSetCommandRegister(
//      PPCI_PDO_EXTENSION _PdoExt,
//      USHORT _Command
//  );
//
#define PciSetCommandRegister(_PdoExt, _Command)                    \
    PciWriteDeviceConfig((_PdoExt),                                 \
                        &(_Command),                                \
                        FIELD_OFFSET(PCI_COMMON_CONFIG, Command),   \
                        sizeof(USHORT)                              \
                        );

//  BOOLEAN
//  BITS_SET(
//      IN  USHORT C
//      IN  USHORT F
//      )
//
#define BITS_SET(C,F) ((BOOLEAN)(((C) & (F)) == (F)))

//  BOOLEAN
//  ANY_BITS_SET(
//      IN  USHORT C
//      IN  USHORT F
//      )
//
#define ANY_BITS_SET(C,F) ((BOOLEAN)(((C) & (F)) != 0))


//
//  VOID
//  PciGetConfigData(
//      IN PPCI_PDO_EXTENSION PdoExtension,
//      OUT PPCI_COMMON_CONFIG PciConfig
//      )
//

#define PciGetConfigData(_PdoExtension, _PciConfig) \
    PciReadDeviceConfig((_PdoExtension),            \
                        (_PciConfig),               \
                        0,                          \
                        PCI_COMMON_HDR_LENGTH       \
                        );
//
//  VOID
//  PciSetConfigData(
//      IN PPCI_PDO_EXTENSION PdoExtension,
//      OUT PPCI_COMMON_CONFIG PciConfig
//      )
//

#define PciSetConfigData(_PdoExtension, _PciConfig) \
    PciWriteDeviceConfig((_PdoExtension),           \
                         (_PciConfig),              \
                         0,                         \
                         PCI_COMMON_HDR_LENGTH      \
                         );

//    debug.c

typedef enum {
    PciDbgAlways        = 0x00000000,   // unconditionally
    PciDbgInformative   = 0x00000001,
    PciDbgVerbose       = 0x00000003,
    PciDbgPrattling     = 0x00000007,

    PciDbgPnpIrpsFdo    = 0x00000100,   // PnP IRPs at FDO
    PciDbgPnpIrpsPdo    = 0x00000200,   // PnP IRPs at PDO
    PciDbgPoIrpsFdo     = 0x00000400,   // PO  IRPs at FDO
    PciDbgPoIrpsPdo     = 0x00000800,   // PO  IRPs at PDO

    PciDbgAddDevice     = 0x00001000,   // AddDevice info
    PciDbgAddDeviceRes  = 0x00002000,   // bus initial resource info

    PciDbgWaitWake      = 0x00008000,   // noisy debug for wait wake
    PciDbgQueryCap      = 0x00010000,   // Dump QueryCapabilities
    PciDbgCardBus       = 0x00020000,   // CardBus FDOish behavior
    PciDbgROM           = 0x00040000,   // access to device ROM
    PciDbgConfigParam   = 0x00080000,   // Setting config parameters

    PciDbgBusNumbers    = 0x00100000,   // checking and assigning bus numbers

    PciDbgResReqList    = 0x01000000,   // generated resource requirements
    PciDbgCmResList     = 0x02000000,   // generated CM Resource lists
    PciDbgSetResChange  = 0x04000000,   // SetResources iff changing
    PciDbgSetRes        = 0x08000000,   // SetResources


    PciDbgObnoxious     = 0x7fffffff    // anything
} PCI_DEBUG_LEVEL;

#if DBG

#define PCI_DEBUGGING_OKAY()    \
    (KeGetCurrentIrql() < IPI_LEVEL)

#define PCI_ASSERT  \
    if (PCI_DEBUGGING_OKAY()) ASSERT

#define PCI_ASSERTMSG  \
    if (PCI_DEBUGGING_OKAY()) ASSERTMSG

extern PCI_DEBUG_LEVEL PciDebug;

#define PCI_DEBUG_BUFFER_SIZE 256

#define PciDebugPrint   PciDebugPrintIfLevel

#else

#define PciDebugPrint   if(0)

#define PCI_ASSERT(exp)
#define PCI_ASSERTMSG(msg,exp)

#endif

VOID
PciDebugDumpCommonConfig(
    IN PPCI_COMMON_CONFIG CommonConfig
    );

VOID
PciDebugDumpQueryCapabilities(
    IN PDEVICE_CAPABILITIES C
    );

VOID
PciDebugHit(
    ULONG StopOnBit
    );

PUCHAR
PciDebugPnpIrpTypeToText(
    ULONG IrpMinorCode
    );

PUCHAR
PciDebugPoIrpTypeToText(
    ULONG IrpMinorCode
    );

VOID
PciDebugPrintIfLevel(
    PCI_DEBUG_LEVEL DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

VOID
PciDebugPrintf(
    PCCHAR DebugMessage,
    ...
    );

VOID
PciDebugPrintCmResList(
    PCI_DEBUG_LEVEL DebugPrintLevel,
    IN PCM_RESOURCE_LIST ResourceList
    );

VOID
PciDebugPrintIoResource(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    );

VOID
PciDebugPrintIoResReqList(
    IN PIO_RESOURCE_REQUIREMENTS_LIST List
    );

VOID
PciDebugPrintPartialResource(
    PCI_DEBUG_LEVEL DebugPrintLevel,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR D
    );


//    device.h

VOID
Device_MassageHeaderForLimitsDetermination(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
Device_RestoreCurrent(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
Device_SaveLimits(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
Device_SaveCurrentSettings(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
Device_ChangeResourceSettings(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    );

VOID
Device_GetAdditionalResourceDescriptors(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig,
    IN PIO_RESOURCE_DESCRIPTOR Resource
    );

NTSTATUS
Device_ResetDevice(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    );


//    dispatch.h

//
// This is the dispatch table for normal PDO's.
//
extern PCI_MJ_DISPATCH_TABLE PciPdoDispatchTable;

NTSTATUS
PciDispatchIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );


NTSTATUS
PciPassIrpFromFdoToPdo(
    PPCI_COMMON_EXTENSION  DeviceExtension,
    PIRP                   Irp
    );

NTSTATUS
PciCallDownIrpStack(
    PPCI_COMMON_EXTENSION  DeviceExtension,
    PIRP                   Irp
    );

NTSTATUS
PciIrpNotSupported(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciIrpInvalidDeviceRequest(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

//    enum.h

PIO_RESOURCE_REQUIREMENTS_LIST
PciAllocateIoRequirementsList(
    IN ULONG ResourceCount,
    IN ULONG BusNumber,
    IN ULONG SlotNumber
    );

BOOLEAN
PciComputeNewCurrentSettings(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PCM_RESOURCE_LIST ResourceList
    );

NTSTATUS
PciQueryDeviceRelations(
    IN PPCI_FDO_EXTENSION FdoExtension,
    OUT PDEVICE_RELATIONS *DeviceRelations
    );

NTSTATUS
PciQueryRequirements(
    IN  PPCI_PDO_EXTENSION                  PdoExtension,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST *RequirementsList
    );

NTSTATUS
PciQueryResources(
    IN PPCI_PDO_EXTENSION PdoExtension,
    OUT PCM_RESOURCE_LIST *ResourceList
    );

NTSTATUS
PciQueryTargetDeviceRelations(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN OUT PDEVICE_RELATIONS *PDeviceRelations
    );

NTSTATUS
PciQueryEjectionRelations(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN OUT PDEVICE_RELATIONS *PDeviceRelations
    );

NTSTATUS
PciScanHibernatedBus(
    IN PPCI_FDO_EXTENSION FdoExtension
    );

NTSTATUS
PciSetResources(
    IN PPCI_PDO_EXTENSION    PdoExtension,
    IN BOOLEAN           PowerOn,
    IN BOOLEAN           StartDeviceIrp
    );

VOID
PciUpdateHardware(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG Config
    );

BOOLEAN
PciIsSameDevice(
    IN PPCI_PDO_EXTENSION PdoExtension
    );

NTSTATUS
PciBuildRequirementsList(
    IN  PPCI_PDO_EXTENSION                 PdoExtension,
    IN  PPCI_COMMON_CONFIG             CurrentConfig,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST *FinalReqList
    );


//    fdo.h


NTSTATUS
PciFdoIrpQueryDeviceRelations(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

VOID
PciInitializeFdoExtensionCommonFields(
    IN PPCI_FDO_EXTENSION  FdoExtension,
    IN PDEVICE_OBJECT  Fdo,
    IN PDEVICE_OBJECT  Pdo
    );


// hookhal.c

VOID
PciHookHal(
    VOID
    );

VOID
PciUnhookHal(
    VOID
    );

//    id.h

PWSTR
PciGetDeviceDescriptionMessage(
    IN UCHAR BaseClass,
    IN UCHAR SubClass
    );

NTSTATUS
PciQueryId(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    );

NTSTATUS
PciQueryDeviceText(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN DEVICE_TEXT_TYPE TextType,
    IN LCID LocaleId,
    IN OUT PWSTR *DeviceText
    );

//    interface.h

#define PCIIF_PDO       0x01        // Interface can be used by a PDO
#define PCIIF_FDO       0x02        // Interface can be used by an FDO
#define PCIIF_ROOT      0x04        // Interface can be used only at by the root.

typedef
NTSTATUS
(*PPCI_INTERFACE_CONSTRUCTOR)(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    );

typedef
NTSTATUS
(*PPCI_INTERFACE_INITIALIZER)(
    PPCI_ARBITER_INSTANCE Instance
    );

typedef struct _PCI_INTERFACE {
    PGUID                      InterfaceType;
    USHORT                     MinSize;
    USHORT                     MinVersion;
    USHORT                     MaxVersion;
    USHORT                     Flags;
    LONG                       ReferenceCount;
    PCI_SIGNATURE              Signature;
    PPCI_INTERFACE_CONSTRUCTOR Constructor;
    PPCI_INTERFACE_INITIALIZER Initializer;
} PCI_INTERFACE, *PPCI_INTERFACE;

NTSTATUS
PciQueryInterface(
    IN PVOID DeviceExtension,
    IN PGUID InterfaceType,
    IN USHORT Size,
    IN USHORT Version,
    IN PVOID InterfaceSpecificData,
    IN OUT PINTERFACE Interface,
    IN BOOLEAN LastChance
    );


extern PPCI_INTERFACE PciInterfaces[];

//    pdo.h

NTSTATUS
PciPdoCreate(
    IN PPCI_FDO_EXTENSION FdoExtension,
    IN PCI_SLOT_NUMBER Slot,
    OUT PDEVICE_OBJECT *PhysicalDeviceObject
    );

VOID
PciPdoDestroy(
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );


//  pmeintf.h

VOID
PciPmeAdjustPmeEnable(
    IN  PPCI_PDO_EXTENSION  PdoExtension,
    IN  BOOLEAN         Enable,
    IN  BOOLEAN         ClearStatusOnly
    );

VOID
PciPmeGetInformation(
    IN  PDEVICE_OBJECT  Pdo,
    OUT PBOOLEAN        PmeCapable,
    OUT PBOOLEAN        PmeStatus,
    OUT PBOOLEAN        PmeEnable
    );



//  power.h

NTSTATUS
PciPdoIrpQueryPower(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoSetPowerState (
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpStack,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoWaitWake (
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );


VOID
PciPdoWaitWakeCancelRoutine(
    IN PDEVICE_OBJECT         DeviceObject,
    IN OUT PIRP               Irp
    );

NTSTATUS
PciFdoIrpQueryPower(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoSetPowerState(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoWaitWake(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciSetPowerManagedDevicePowerState(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN DEVICE_POWER_STATE DeviceState,
    IN BOOLEAN RefreshConfigSpace
    );

// ppbridge.h

VOID
PPBridge_MassageHeaderForLimitsDetermination(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
PPBridge_RestoreCurrent(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
PPBridge_SaveLimits(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
PPBridge_SaveCurrentSettings(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
PPBridge_ChangeResourceSettings(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    );

VOID
PPBridge_GetAdditionalResourceDescriptors(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig,
    IN PIO_RESOURCE_DESCRIPTOR Resource
    );

NTSTATUS
PPBridge_ResetDevice(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    );

//    romimage.h

NTSTATUS
PciReadRomImage(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN ULONG WhichSpace,
    OUT PVOID Buffer,
    IN ULONG Offset,
    IN OUT PULONG LENGTH
    );

//    state.h

//
// Note - State.c depends on the order of these.
//
typedef enum {
    PciNotStarted = 0,
    PciStarted,
    PciDeleted,
    PciStopped,
    PciSurpriseRemoved,
    PciSynchronizedOperation,
    PciMaxObjectState
} PCI_OBJECT_STATE;

VOID
PciInitializeState(
    IN PPCI_COMMON_EXTENSION DeviceExtension
    );

NTSTATUS
PciBeginStateTransition(
    IN PPCI_COMMON_EXTENSION DeviceExtension,
    IN PCI_OBJECT_STATE      NewState
    );

VOID
PciCommitStateTransition(
    IN PPCI_COMMON_EXTENSION DeviceExtension,
    IN PCI_OBJECT_STATE      NewState
    );

NTSTATUS
PciCancelStateTransition(
    IN PPCI_COMMON_EXTENSION DeviceExtension,
    IN PCI_OBJECT_STATE      StateNotEntered
    );

BOOLEAN
PciIsInTransitionToState(
    IN PPCI_COMMON_EXTENSION DeviceExtension,
    IN PCI_OBJECT_STATE      NextState
    );

/*
NTSTATUS
PciBeginStateTransitionIfNotBegun(
    IN PPCI_COMMON_EXTENSION DeviceExtension,
     IN PCI_OBJECT_STATE      StateToEnter
    );
*/

#define PCI_ACQUIRE_STATE_LOCK(Extension) \
   PciBeginStateTransition((PPCI_COMMON_EXTENSION) (Extension), \
                           PciSynchronizedOperation)


#define PCI_RELEASE_STATE_LOCK(Extension) \
   PciCancelStateTransition((PPCI_COMMON_EXTENSION) (Extension), \
                           PciSynchronizedOperation)



//    tr_comn.h

typedef struct _PCI_TRANSLATOR_INSTANCE {
    PTRANSLATOR_INTERFACE Interface;
    ULONG ReferenceCount;
    PPCI_FDO_EXTENSION FdoExtension;
} PCI_TRANSLATOR_INSTANCE, *PPCI_TRANSLATOR_INSTANCE;

#define PCI_TRANSLATOR_INSTANCE_TO_CONTEXT(x)   ((PVOID)(x))
#define PCI_TRANSLATOR_CONTEXT_TO_INSTANCE(x)   ((PPCI_TRANSLATOR_INSTANCE)(x))

VOID
PciReferenceTranslator(
    IN PVOID Context
    );

VOID
PciDereferenceTranslator(
    IN PVOID Context
    );

//    usage.h

NTSTATUS
PciLocalDeviceUsage (
    IN PPCI_POWER_STATE     PowerState,
    IN PIRP                 Irp
    );

NTSTATUS
PciPdoDeviceUsage (
    IN PPCI_PDO_EXTENSION   pdoExtension,
    IN PIRP             Irp
    );

//  utils.h

NTSTATUS
PciAssignSlotResources(
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

PCI_OBJECT_TYPE
PciClassifyDeviceType(
    PPCI_PDO_EXTENSION PdoExtension
    );

// VOID
// PciCompleteRequest(
//     IN OUT PIRP Irp,
//     IN NTSTATUS Status
//     );

#define PciCompleteRequest(_Irp_,_Status_)                      \
    {                                                           \
        (_Irp_)->IoStatus.Status = (_Status_);                  \
        IoCompleteRequest((_Irp_), IO_NO_INCREMENT);            \
    }

BOOLEAN
PciCreateIoDescriptorFromBarLimit(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    IN PULONG BaseAddress,
    IN BOOLEAN Rom
    );

BOOLEAN
PciIsCriticalDeviceClass(
    IN UCHAR BaseClass,
    IN UCHAR SubClass
    );

#define PCI_CAN_DISABLE_VIDEO_DECODES   0x00000001

BOOLEAN
PciCanDisableDecodes(
    IN PPCI_PDO_EXTENSION PdoExtension OPTIONAL,
    IN PPCI_COMMON_CONFIG Config OPTIONAL,
    IN ULONGLONG HackFlags,
    IN ULONG Flags
    );

VOID
PciDecodeEnable(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN BOOLEAN EnableOperation,
    IN PUSHORT ExistingCommand OPTIONAL
    );

PCM_PARTIAL_RESOURCE_DESCRIPTOR
PciFindDescriptorInCmResourceList(
    IN CM_RESOURCE_TYPE DescriptorType,
    IN PCM_RESOURCE_LIST ResourceList,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR PreviousHit
    );

PPCI_FDO_EXTENSION
PciFindParentPciFdoExtension(
    PDEVICE_OBJECT PhysicalDeviceObject,
    IN PFAST_MUTEX Mutex
    );

PPCI_PDO_EXTENSION
PciFindPdoByFunction(
    IN PPCI_FDO_EXTENSION FdoExtension,
    IN PCI_SLOT_NUMBER Slot,
    IN PPCI_COMMON_CONFIG Config
    );

PVOID
PciFindNextSecondaryExtension(
    IN PSINGLE_LIST_ENTRY   ListEntry,
    IN PCI_SIGNATURE        DesiredType
    );

#define PciFindSecondaryExtension(X,TYPE) \
    PciFindNextSecondaryExtension((X)->SecondaryExtension.Next, TYPE)

VOID
PcipLinkSecondaryExtension(
    IN PSINGLE_LIST_ENTRY               ListHead,
    IN PFAST_MUTEX                      Mutex,
    IN PVOID                            NewExtension,
    IN PCI_SIGNATURE                    Type,
    IN PSECONDARYEXTENSIONDESTRUCTOR    Destructor
    );

#define PciLinkSecondaryExtension(X,X2,T,D)                 \
    PcipLinkSecondaryExtension(&(X)->SecondaryExtension,    \
                               &(X)->SecondaryExtMutex,     \
                               X2,                          \
                               T,                           \
                               D)

VOID
PcipDestroySecondaryExtension(
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PFAST_MUTEX        Mutex,
    IN PVOID              Extension
    );

ULONGLONG
PciGetHackFlags(
    IN USHORT VendorID,
    IN USHORT DeviceID,
    IN USHORT SubVendorID,
    IN USHORT SubSystemID,
    IN UCHAR  RevisionID
    );

NTSTATUS
PciGetDeviceProperty(
    IN  PDEVICE_OBJECT PhysicalDeviceObject,
    IN  DEVICE_REGISTRY_PROPERTY DeviceProperty,
    OUT PVOID *PropertyBuffer
    );

NTSTATUS
PciGetInterruptAssignment(
    IN PPCI_PDO_EXTENSION PdoExtension,
    OUT ULONG *Minimum,
    OUT ULONG *Maximum
    );

ULONG
PciGetLengthFromBar(
    ULONG BaseAddressRegister
    );

NTSTATUS
PciGetRegistryValue(
    IN  PWSTR   ValueName,
    IN  PWSTR   KeyName,
    IN  HANDLE  ParentHandle,
    IN  ULONG   Type,
    OUT PVOID   *Buffer,
    OUT PULONG  Length
    );

VOID
PciInsertEntryAtTail(
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PSINGLE_LIST_ENTRY NewEntry,
    IN PFAST_MUTEX        Mutex
    );

VOID
PciInsertEntryAtHead(
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PSINGLE_LIST_ENTRY NewEntry,
    IN PFAST_MUTEX        Mutex
    );

PCM_PARTIAL_RESOURCE_DESCRIPTOR
PciNextPartialDescriptor(
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    );

BOOLEAN
PciOpenKey(
    IN  PWSTR           KeyName,
    IN  HANDLE          ParentHandle,
    IN  ACCESS_MASK     Access,
    OUT PHANDLE         ChildHandle,
    OUT PNTSTATUS       Status
    );

NTSTATUS
PciQueryBusInformation(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPNP_BUS_INFORMATION *BusInformation
    );

NTSTATUS
PciQueryLegacyBusInformation(
    IN PPCI_FDO_EXTENSION FdoExtension,
    IN PLEGACY_BUS_INFORMATION *BusInformation
    );

NTSTATUS
PciQueryCapabilities(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PDEVICE_CAPABILITIES Capabilities
    );

NTSTATUS
PciRangeListFromResourceList(
    IN  PPCI_FDO_EXTENSION    FdoExtension,
    IN  PCM_RESOURCE_LIST ResourceList,
    IN  CM_RESOURCE_TYPE  DesiredType,
    IN  BOOLEAN           Complement,
    IN  PRTL_RANGE_LIST   ResultRange
    );

UCHAR
PciReadDeviceCapability(
    IN     PPCI_PDO_EXTENSION PdoExtension,
    IN     UCHAR          Offset,
    IN     UCHAR          Id,
    IN OUT PVOID          Buffer,
    IN     ULONG          Length
    );

VOID
PciRemoveEntryFromList(
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PSINGLE_LIST_ENTRY OldEntry,
    IN PFAST_MUTEX        Mutex
    );

PPCI_PDO_EXTENSION
PciFindPdoByLocation(
    IN ULONG BusNumber,
    IN PCI_SLOT_NUMBER Slot
    );

NTSTATUS
PciBuildDefaultExclusionLists(
    VOID
    );

NTSTATUS
PciExcludeRangesFromWindow(
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN PRTL_RANGE_LIST ArbiterRanges,
    IN PRTL_RANGE_LIST ExclusionRanges
    );

NTSTATUS
PciSaveBiosConfig(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG Config
    );

NTSTATUS
PciGetBiosConfig(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG Config
    );

BOOLEAN
PciStringToUSHORT(
    IN PWCHAR String,
    OUT PUSHORT Result
    );

NTSTATUS
PciSendIoctl(
    IN PDEVICE_OBJECT Device,
    IN ULONG IoctlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );

BOOLEAN
PciIsOnVGAPath(
    IN PPCI_PDO_EXTENSION Pdo
    );

BOOLEAN
PciIsSlotPresentInParentMethod(
    IN PPCI_PDO_EXTENSION Pdo,
    IN ULONG Method
    );

NTSTATUS
PciUpdateLegacyHardwareDescription(
    IN PPCI_FDO_EXTENSION Fdo
    );

NTSTATUS
PciWriteDeviceSpace(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN ULONG WhichSpace,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length,
    OUT PULONG LengthWritten
    );

NTSTATUS
PciReadDeviceSpace(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN ULONG WhichSpace,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length,
    OUT PULONG LengthRead
    );

BOOLEAN
PciIsSuiteVersion(
    IN USHORT Version
    );

BOOLEAN
PciIsDatacenter(
    );

ULONG_PTR
PciExecuteCriticalSystemRoutine(
    IN ULONG_PTR Context
    );

BOOLEAN
PciUnicodeStringStrStr(
    IN PUNICODE_STRING SearchString,
    IN PUNICODE_STRING SubString,
    IN BOOLEAN CaseInsensitive
    );

//
// Programming Interface encodings for PCI IDE Controllers
// BaseClass = 1, SubClass = 1
//


#define PCI_IDE_PRIMARY_NATIVE_MODE         0x01
#define PCI_IDE_PRIMARY_MODE_CHANGEABLE     0x02
#define PCI_IDE_SECONDARY_NATIVE_MODE       0x04
#define PCI_IDE_SECONDARY_MODE_CHANGEABLE   0x08

#define PCI_IS_LEGACY_IDE_CONTROLLER(_Config)                               \
        ((_Config)->BaseClass == PCI_CLASS_MASS_STORAGE_CTLR                \
        && (_Config)->SubClass == PCI_SUBCLASS_MSC_IDE_CTLR                 \
        && !BITS_SET((_Config)->ProgIf, (PCI_IDE_PRIMARY_NATIVE_MODE        \
                                        | PCI_IDE_SECONDARY_NATIVE_MODE)))

#define PCI_IS_NATIVE_IDE_CONTROLLER(_Config)                               \
        ((_Config)->BaseClass == PCI_CLASS_MASS_STORAGE_CTLR                \
        && (_Config)->SubClass == PCI_SUBCLASS_MSC_IDE_CTLR                 \
        && BITS_SET((_Config)->ProgIf, (PCI_IDE_PRIMARY_NATIVE_MODE         \
                                        | PCI_IDE_SECONDARY_NATIVE_MODE)))

#define PCI_IS_NATIVE_CAPABLE_IDE_CONTROLLER(_Config)                       \
        ((_Config)->BaseClass == PCI_CLASS_MASS_STORAGE_CTLR                \
        && (_Config)->SubClass == PCI_SUBCLASS_MSC_IDE_CTLR                 \
        && BITS_SET((_Config)->ProgIf, (PCI_IDE_PRIMARY_MODE_CHANGEABLE     \
                                        | PCI_IDE_SECONDARY_MODE_CHANGEABLE)))


//
// _HPP method for HotPlugParameters
//
//    Method (_HPP, 0) {
//        Return (Package(){
//            0x00000008,     // CacheLineSize in DWORDS
//            0x00000040,     // LatencyTimer in PCI clocks
//            0x00000001,     // Enable SERR (Boolean)
//            0x00000001      // Enable PERR (Boolean)
//         })
//

#define PCI_HPP_CACHE_LINE_SIZE_INDEX   0
#define PCI_HPP_LATENCY_TIMER_INDEX     1
#define PCI_HPP_ENABLE_SERR_INDEX       2
#define PCI_HPP_ENABLE_PERR_INDEX       3
#define PCI_HPP_PACKAGE_COUNT           4


//
// Support for kernel debugger and headless ports that can't be turned off
// This is retrieved from the registry in DriverEntry and thus the bus numbers
// are how the firmware configured the machine and not necessarily the current
// settings.  Luckily we saved away the BIOS config in the registry.
//

typedef struct _PCI_DEBUG_PORT {
    ULONG Bus;
    PCI_SLOT_NUMBER Slot;
} PCI_DEBUG_PORT, *PPCI_DEBUG_PORT;

extern PCI_DEBUG_PORT PciDebugPorts[];
extern ULONG PciDebugPortsCount;

BOOLEAN
PciIsDeviceOnDebugPath(
    IN PPCI_PDO_EXTENSION Pdo
    );

//
// Cardbus has extra configuration information beyond the common
// header.
//

typedef struct _TYPE2EXTRAS {
    USHORT  SubVendorID;
    USHORT  SubSystemID;
    ULONG   LegacyModeBaseAddress;
} TYPE2EXTRAS;

#define CARDBUS_LMBA_OFFSET                                     \
    (ULONG)(FIELD_OFFSET(PCI_COMMON_CONFIG, DeviceSpecific) +   \
            FIELD_OFFSET(TYPE2EXTRAS, LegacyModeBaseAddress))


//
// Hack flags for PCI devices (PDO)
//

#define PCI_HACK_NO_VIDEO_IRQ               0x0000000000000001L
#define PCI_HACK_PCMCIA_WANT_IRQ            0x0000000000000002L
#define PCI_HACK_DUAL_IDE                   0x0000000000000004L
#define PCI_HACK_NO_ENUM_AT_ALL             0x0000000000000008L
#define PCI_HACK_ENUM_NO_RESOURCE           0x0000000000000010L
#define PCI_HACK_NEED_DWORD_ACCESS          0x0000000000000020L
#define PCI_HACK_SINGLE_FUNCTION            0x0000000000000040L
#define PCI_HACK_ALWAYS_ENABLED             0x0000000000000080L
#define PCI_HACK_IS_IDE                     0x0000000000000100L
#define PCI_HACK_IS_VIDEO                   0x0000000000000200L
#define PCI_HACK_FAIL_START                 0x0000000000000400L
#define PCI_HACK_GHOST                      0x0000000000000800L
#define PCI_HACK_DOUBLE_DECKER              0x0000000000001000L
#define PCI_HACK_ONE_CHILD                  0x0000000000002000L
#define PCI_HACK_PRESERVE_COMMAND           0x0000000000004000L
#define PCI_HACK_IS_VGA                     0x0000000000008000L
#define PCI_HACK_CB_SHARE_CMD_BITS          0x0000000000010000L
#define PCI_HACK_STRAIGHT_IRQ_ROUTING       0x0000000000020000L
#define PCI_HACK_SUBTRACTIVE_DECODE         0x0000000000040000L
#define PCI_HACK_FDMA_ISA                   0x0000000000080000L
#define PCI_HACK_EXCLUSIVE                  0x0000000000100000L
#define PCI_HACK_EDGE                       0x0000000000200000L
#define PCI_HACK_NO_SUBSYSTEM               0x0000000000400000L
#define PCI_HACK_NO_WPE                     0x0000000000800000L
#define PCI_HACK_OLD_ID                     0x0000000001000000L
#define PCI_HACK_DONT_SHRINK_BRIDGE         0x0000000002000000L
#define PCI_HACK_TURN_OFF_PARITY            0x0000000004000000L
#define PCI_HACK_NO_NON_PCI_CHILD_BAR       0x0000000008000000L
#define PCI_HACK_NO_ENUM_WITH_DISABLE       0x0000000010000000L
#define PCI_HACK_NO_PM_CAPS                 0x0000000020000000L
#define PCI_HACK_NO_DISABLE_DECODES         0x0000000040000000L
#define PCI_HACK_NO_SUBSYSTEM_AFTER_D3      0x0000000080000000L
#define PCI_HACK_VIDEO_LEGACY_DECODE        0x0000000100000000L
#define PCI_HACK_FAKE_CLASS_CODE            0x0000000200000000L
#define PCI_HACK_RESET_BRIDGE_ON_POWERUP    0x0000000400000000L
#define PCI_HACK_BAD_NATIVE_IDE             0x0000000800000000L
#define PCI_HACK_FAIL_QUERY_REMOVE          0x0000001000000000L
#define PCI_HACK_CRITICAL_DEVICE            0x0000002000000000L
#define PCI_HACK_OVERRIDE_CRITICAL_DEVICE   0x0000004000000000L

//
// Hack flags for PCI busses (FDO)
// NB: These are not currently applied to cardbus bridges
//

//
// PCI_BUS_HACK_LOCK_RESOURCES - prevent devices on *this* bus from
// being moved.  If a BAR are unconfigured it will still be assigned
// resources from what is available on the bus.  If the BAR is
// configured only those resources if available will be assigned, if
// not available the the device will fail CM_PROBLEM_RESOURCE_CONFLICT.
//
// Putting /PCILOCK in boot.ini applies this to all devices in the system.
//
#define PCI_BUS_HACK_LOCK_RESOURCES         0x00000001

//
// Random useful macros
//

#ifndef FIELD_SIZE
#define FIELD_SIZE(type, field) (sizeof(((type *)0)->field))
#endif

//
// This macro computes if a range of bytes with configuration
// space from offset for length bytes will intersect with the
// any of the fields between field1 and field2 as defined in
// PCI_COMMON_CONFIG
//

#define INTERSECT_CONFIG_FIELD_RANGE(offset, length, field1, field2)    \
    INTERSECT((offset),                                                 \
              (offset) + (length) - 1,                                  \
              FIELD_OFFSET(PCI_COMMON_CONFIG, field1),                \
              FIELD_OFFSET(PCI_COMMON_CONFIG, field2)                 \
                + FIELD_SIZE(PCI_COMMON_CONFIG, field2) - 1           \
              )

//
// This macro computes if a range of bytes with configuration
// space from offset for length bytes will intersect with
// field as defined in PCI_COMMON_CONFIG
//

#define INTERSECT_CONFIG_FIELD(offset, length, field)                   \
    INTERSECT_CONFIG_FIELD_RANGE(offset, length, field, field)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\locintrf.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    locintrf.c

Abstract:

    This module implements the device location interface
    supported by the PCI driver.
    
    This interface reports the bus-relative location identifier
    string(s) of a given device.

Author:

    Davis Walker (dwalker) 5 December 2001

Revision History:

--*/

#include "pcip.h"

#define LOCINTRF_VERSION 1

//
// The length - in characters - of the Multi-Sz strings returned from the interface.
// count one extra character for the MultiSz second terminator
//
#define PCI_LOCATION_STRING_COUNT (sizeof "PCI(XXXX)" + 1)
#define PCIROOT_LOCATION_STRING_COUNT (sizeof "PCIROOT(XX)" + 1)

//
// Prototypes for routines exposed only through the "interface"
// mechanism.
//

NTSTATUS
locintrf_Constructor(
    IN PVOID DeviceExtension,
    IN PVOID PciInterface,
    IN PVOID InterfaceSpecificData,
    IN USHORT Version,
    IN USHORT Size,
    IN PINTERFACE InterfaceReturn
    );

VOID
locintrf_Reference(
    IN PVOID Context
    );

VOID
locintrf_Dereference(
    IN PVOID Context
    );

NTSTATUS
locintrf_Initializer(
    IN PVOID Instance
    );

NTSTATUS 
PciGetLocationStrings(
    IN PVOID Context,
    OUT PWCHAR *LocationStrings
    );

//
// Define this interface's PCI_INTERFACE structure.
//

PCI_INTERFACE PciLocationInterface = {
    &GUID_PNP_LOCATION_INTERFACE,           // InterfaceType
    sizeof(PNP_LOCATION_INTERFACE),         // MinSize
    LOCINTRF_VERSION,                       // MinVersion
    LOCINTRF_VERSION,                       // MaxVersion
    PCIIF_PDO | PCIIF_FDO | PCIIF_ROOT,     // Flags - supported on PDOs and root FDOs
    0,                                      // ReferenceCount
    PciInterface_Location,                  // Signature
    locintrf_Constructor,                   // Constructor
    locintrf_Initializer                    // Instance Initializer
};

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, locintrf_Constructor)
    #pragma alloc_text(PAGE, locintrf_Dereference)
    #pragma alloc_text(PAGE, locintrf_Initializer)
    #pragma alloc_text(PAGE, locintrf_Reference)
    #pragma alloc_text(PAGE, PciGetLocationStrings)
#endif

NTSTATUS
locintrf_Constructor(
    IN PVOID DeviceExtension,
    IN PVOID PciInterface,
    IN PVOID InterfaceSpecificData,
    IN USHORT Version,
    IN USHORT Size,
    IN PINTERFACE InterfaceReturn
    )
/*++

Routine Description:

    This routine constructs a PNP_LOCATION_INTERFACE.

Arguments:

    DeviceExtension - An extension pointer.

    PCIInterface - PciInterface_Location.

    InterfaceSpecificData - Unused.

    Version - Interface version.

    Size - Size of the PNP_LOCATION_INTERFACE interface object.

    InterfaceReturn - The interface object pointer to be filled in.

Return Value:

    Returns NTSTATUS.

--*/
{
    PPNP_LOCATION_INTERFACE interface;
    
                
    interface = (PPNP_LOCATION_INTERFACE)InterfaceReturn;
    interface->Size = sizeof(PNP_LOCATION_INTERFACE);
    interface->Version = LOCINTRF_VERSION;
    interface->Context = DeviceExtension;
    interface->InterfaceReference = locintrf_Reference;
    interface->InterfaceDereference = locintrf_Dereference;
    interface->GetLocationString = PciGetLocationStrings;

    return STATUS_SUCCESS;
}

NTSTATUS
locintrf_Initializer(
    IN PVOID Instance
    )
/*++

Routine Description:

    For the location interface, this does nothing, shouldn't actually be called.

Arguments:

    Instance - FDO extension pointer.

Return Value:

    Returns NTSTATUS.

--*/
{
    ASSERTMSG("PCI locintrf_Initializer, unexpected call.", FALSE);

    
    return STATUS_UNSUCCESSFUL;
}

VOID
locintrf_Reference(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine adds a reference to a location interface.

Arguments:

    Context - device extension pointer.

Return Value:

    None.

--*/
{
    }

VOID
locintrf_Dereference(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine releases a reference to a location interface.

Arguments:

    Context - extension pointer.

Return Value:

    None.

--*/
{
    }

NTSTATUS 
PciGetLocationStrings(
    IN PVOID Context,
    OUT PWCHAR *LocationStrings
    )
/*++

Routine Description:

    This routine allocates, fills in, and returns a Multi-Sz string
    containing the bus-relative location identifier string for the
    given device.
    
    For a PCI device, this is "PCI(XXYY)", where XX is the device 
    number of the device, and YY is the function number of the device.  
    
    For a PCI root bus, this is PCIROOT(XX), where XX is the bus number 
    of the root bus.  This relies on the fact that bus numbers of root
    buses will not change, which is believed to be a safe assumption
    for some time to come.
    
    This interface is permitted to return a Multi-Sz containing
    multiple strings describing the same device, but in this
    first implementation, only the single strings listed above
    will be returned from the interface.  The string must still
    be in the format of a Multi-Sz, however, meaning a double-NULL
    terminator is required.

Arguments:

    Context - extension pointer.

Return Value:

    NTSTATUS code.

--*/
{
    PPCI_COMMON_EXTENSION extension = (PPCI_COMMON_EXTENSION)Context;
    PPCI_PDO_EXTENSION pdoExtension;
    PPCI_FDO_EXTENSION rootExtension;
    PWCHAR stringBuffer;
    PCI_SLOT_NUMBER slotNumber;
    SIZE_T remainingChars;
    BOOLEAN ok;
    
    if (extension->ExtensionType == PciPdoExtensionType) {
        
        pdoExtension = (PPCI_PDO_EXTENSION)extension;
        slotNumber = pdoExtension->Slot;
    
        stringBuffer = ExAllocatePoolWithTag(PagedPool,PCI_LOCATION_STRING_COUNT*sizeof(WCHAR),'coLP');
        if (!stringBuffer) {
            *LocationStrings = NULL;
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        
        //
        // The location string for a PCI device is "PCI(XXYY)"
        // where XX is the device number and YY is the function number
        // We use the STRSAFE_FILL_BEHIND_NULL flag to ensure the unused portion
        // of the buffer is filled with 0s which null terminates the multsz
        //
        ok = SUCCEEDED(StringCchPrintfExW(stringBuffer, 
                                         PCI_LOCATION_STRING_COUNT,
                                         NULL,
                                         &remainingChars,
                                         STRSAFE_FILL_BEHIND_NULL,
                                         L"PCI(%.2X%.2X)",
                                         slotNumber.u.bits.DeviceNumber,
                                         slotNumber.u.bits.FunctionNumber
                                         ));    
        
        ASSERT(ok);

        //
        // Make sure there was room for the multisz termination NUL 
        // N.B. remainingChars counts the NUL terminatiun of the regular string
        // as being available so we need to ensure 2 chars are left for the 2 NULS
        //
        ASSERT(remainingChars >= 2);
        
        *LocationStrings = stringBuffer;
        return STATUS_SUCCESS;    
    
    } else {

        rootExtension = (PPCI_FDO_EXTENSION)extension;
        
        ASSERT(PCI_IS_ROOT_FDO(rootExtension));
        if (PCI_IS_ROOT_FDO(rootExtension)) {
            
            stringBuffer = ExAllocatePoolWithTag(PagedPool,PCIROOT_LOCATION_STRING_COUNT*sizeof(WCHAR),'coLP');
            if (!stringBuffer) {
                *LocationStrings = NULL;
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            
            //
            // The location string for a PCI root is "PCIROOT(X)"
            // where X is the bus number of root bus.
            // We use the STRSAFE_FILL_BEHIND_NULL flag to ensure the unused portion
            // of the buffer is filled with 0s which null terminates the multsz
            //
            ok = SUCCEEDED(StringCchPrintfExW(stringBuffer,
                                              PCIROOT_LOCATION_STRING_COUNT,
                                              NULL,
                                              &remainingChars,
                                              STRSAFE_FILL_BEHIND_NULL,
                                              L"PCIROOT(%X)",
                                              rootExtension->BaseBus
                                              ));    
            ASSERT(ok);

            //
            // Make sure there was room for the multisz termination NUL 
            // N.B. remainingChars counts the NUL terminatiun of the regular string
            // as being available so we need to ensure 2 chars are left for the 2 NULS
            //
            ASSERT(remainingChars >= 2);
            
            *LocationStrings = stringBuffer;

            //
            // returning STATUS_TRANSLATION_COMPLETE indicates that PnP shouldn't
            // query for this interface any further up the tree.  Stop here.
            //
            return STATUS_TRANSLATION_COMPLETE;
        
        } else {

            //
            // In the interface constructor, we specified that this interface
            // is only valid for root FDOs.  If we get here, we've been asked
            // to fill in this interface for a P-P bridge FDO, which is illegal.
            //
            *LocationStrings = NULL;
            return STATUS_INVALID_PARAMETER;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\power.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    power.c

Abstract:

    This module contains power management code for PCI.SYS.

Author:

    Joe Dai (joedai) 11-Sept-1997
    Peter Johnston (peterj) 24-Oct-1997

Revision History:

--*/


#include "pcip.h"


NTSTATUS
PciFdoWaitWakeCompletion(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PIRP                   Irp,
    IN PPCI_FDO_EXTENSION     FdoExtension
    );

NTSTATUS
PciFdoWaitWakeCallBack(
    IN PDEVICE_OBJECT         DeviceObject,
    IN UCHAR                  MinorFunction,
    IN POWER_STATE            PowerState,
    IN PVOID                  Context,
    IN PIO_STATUS_BLOCK       IoStatus
    );

VOID
PciFdoWaitWakeCancel(
    IN PDEVICE_OBJECT         DeviceObject,
    IN OUT PIRP               Irp
    );

VOID
PciFdoSetPowerStateCompletion(
    IN PDEVICE_OBJECT         DeviceObject,
    IN UCHAR                  MinorFunction,
    IN POWER_STATE            PowerState,
    IN PVOID                  Context,
    IN PIO_STATUS_BLOCK       IoStatus
    );

NTSTATUS
PciPdoWaitWakeCallBack(
    IN PDEVICE_OBJECT         DeviceObject,
    IN UCHAR                  MinorFunction,
    IN POWER_STATE            PowerState,
    IN PVOID                  Context,
    IN PIO_STATUS_BLOCK       IoStatus
    );

VOID
PciPdoAdjustPmeEnable(
    IN PPCI_PDO_EXTENSION         PdoExtension,
    IN BOOLEAN                Enable
    );

VOID
PciPmeClearPmeStatus(
    IN  PDEVICE_OBJECT  Pdo
    );

//
// This table is taken from the PCI spec.  The units are microseconds.

LONG PciPowerDelayTable[4][4] = {
//  D0      D1      D2      D3(Hot)
    0,      0,      200,    10000,  // D0
    0,      0,      200,    10000,  // D1
    200,    200,    0,      10000,  // D2
    10000,  10000,  10000,  0       // D3(Hot)
};


VOID
PciPdoAdjustPmeEnable(
    IN  PPCI_PDO_EXTENSION  PdoExtension,
    IN  BOOLEAN         Enable
    )

/*++

Routine Description:

    Enable or Disable the PME Enable bit for a device(function).

    Note: The PDO Extension lock is held on entry and is not released
    by this routine.

Arguments:

    PdoExtension - Pointer to the PDO Extension for the device whose
                   PME Enable bit is to be altered.

    Enable - TRUE if PME Enable is to be set, FALSE if to be cleared.

Return Value:

    None.

--*/

{
    //
    // Is the device's PME management owned by someone else?
    //
    if (PdoExtension->NoTouchPmeEnable) {

        PciDebugPrint(
            PciDbgWaitWake,
            "AdjustPmeEnable on pdox %08x but PME not owned.\n",
            PdoExtension
            );
        return;

    }

    //
    // Really update the PME signal. Note that we always need to supply
    // the 3rd argument as FALSE --- we don't want to just clear the PME
    // Status bit
    //
    PciPmeAdjustPmeEnable( PdoExtension, Enable, FALSE );
}

NTSTATUS
PciPdoIrpQueryPower(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    
    
        
    //
    // pass 1, claim we can do it.
    //

    //
    // ADRIAO N.B. 08/29/1999 -
    //     For D-IRPs, we do *not* want to verify the requested D-state is
    // actually supported. See PciQueryPowerCapabilities for details.
    //
    return STATUS_SUCCESS;
}

NTSTATUS
PciPdoSetPowerState (
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpStack,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
/*++

Routine Description:

    Handles SetPower Irps send to a PCI PDO

    If the irp is an S-Irp, then do nothing

    If the irp is an D-Irp, then put the device in the appropriate state.
        Exceptions: If the device is in the hibernate path, then don't
                        actually power down if we are hibernating

Arguments:

    Irp             - The request
    IrpStack        - The current stack location
    DeviceExtension - The device that is getting powered down

Return Value:

    NTSTATUS

--*/
{
    DEVICE_POWER_STATE  desiredDeviceState;
    NTSTATUS            status;
    PPCI_PDO_EXTENSION      pdoExtension;
    POWER_ACTION        powerAction;
    
    
    pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;

    ASSERT_PCI_PDO_EXTENSION(pdoExtension);

    status   = STATUS_SUCCESS;

    switch (IrpStack->Parameters.Power.Type) {
    case DevicePowerState:
        desiredDeviceState = IrpStack->Parameters.Power.State.DeviceState;
        powerAction = IrpStack->Parameters.Power.ShutdownType;
        break;
    case SystemPowerState:
        return STATUS_SUCCESS;
    default:
        return STATUS_NOT_SUPPORTED;
    }

    if ((desiredDeviceState == PowerDeviceD0)
        && (pdoExtension->PowerState.CurrentDeviceState == PowerDeviceD0)) {
        return STATUS_SUCCESS;
    }

#if DBG

    if ((desiredDeviceState < PowerDeviceD0) ||
        (desiredDeviceState > PowerDeviceD3)) {

        //
        // Invalid power level.
        //

        return STATUS_INVALID_PARAMETER;
    }

#endif

    //
    // If the device is trying to power down perform some sanity checks
    //

    if (desiredDeviceState > PowerDeviceD0) {

        if (pdoExtension->OnDebugPath) {
            KdPowerTransition(desiredDeviceState);
        }
        //
        // If device is currently in D0 state, capture it's command
        // register settings in case the FDO changed them since we
        // looked at them.
        //
        if (pdoExtension->PowerState.CurrentDeviceState == PowerDeviceD0) {

            PciGetCommandRegister(pdoExtension,
                                  &pdoExtension->CommandEnables);

        }

        //
        // Prevent race conditions and remember that the device is off before
        // we actually turn it off
        //
        pdoExtension->PowerState.CurrentDeviceState = desiredDeviceState;

        if (pdoExtension->DisablePowerDown) {

            //
            // Powerdown of this device disabled (based on device type).
            //
            PciDebugPrint(
                PciDbgObnoxious,
                "PCI power down of PDOx %08x, disabled, ignored.\n",
                pdoExtension
                );
            return STATUS_SUCCESS;

        }


        //
        // Device driver should likely not be powering down any device
        // that's on the hibernate path or the crashdump path
        //
        if ( powerAction == PowerActionHibernate &&
             (pdoExtension->PowerState.Hibernate || pdoExtension->PowerState.CrashDump ) ) {

            //
            // Don't actually change the device, but new device state was
            // recorded above (as if we HAD done it) so we know to reset
            // resources as the system comes up again.
            //
            return STATUS_SUCCESS;
        }

        //
        // If we are a device on the VGA path then don't turn off for shutdown so we can
        // display the "Safe to turn off your machine" screen.  For hibernate we also
        // don't want to turn off so we can display the "Dumping stuff to your disk progress
        // bar" but this is accomplished by video putting device on the video path on the hibernate
        // path.
        //

        if (IrpStack->Parameters.Power.State.DeviceState == PowerDeviceD3
        &&  (IrpStack->Parameters.Power.ShutdownType == PowerActionShutdownReset ||
             IrpStack->Parameters.Power.ShutdownType == PowerActionShutdownOff ||
             IrpStack->Parameters.Power.ShutdownType == PowerActionShutdown)
        &&  PciIsOnVGAPath(pdoExtension)) {

            return STATUS_SUCCESS;
        }

        //
        // If this device is on the debug path then don't power it down so we
        // can report if this crashes the machine...
        //

        if (pdoExtension->OnDebugPath) {
            return STATUS_SUCCESS;
        }

    } else {

        //
        // Device is powering UP.
        //
        // Verify the device is still the same as before (and that someone
        // hasn't removed/replaced it with something else)
        //
        if (!PciIsSameDevice(pdoExtension)) {

            return STATUS_NO_SUCH_DEVICE;

        }
    }

    //
    // Place the device in the proper power state
    //
    status = PciSetPowerManagedDevicePowerState(
                 pdoExtension,
                 desiredDeviceState,
                 TRUE
                 );

    //
    // If the device is transitioning to the D0 state, reset the common
    // config information on the device and inform the system of the device
    // state change.
    //
    if (desiredDeviceState == PowerDeviceD0) {
        if (NT_SUCCESS(status)) {

            pdoExtension->PowerState.CurrentDeviceState = desiredDeviceState;
            PoSetPowerState (
                pdoExtension->PhysicalDeviceObject,
                DevicePowerState,
                IrpStack->Parameters.Power.State
                );

            if (pdoExtension->OnDebugPath) {
                KdPowerTransition(PowerDeviceD0);
            }
        }

    } else {

        //
        // The new device state is something other then D0.
        // notify the system before continuing
        //
        PoSetPowerState (
            pdoExtension->PhysicalDeviceObject,
            DevicePowerState,
            IrpStack->Parameters.Power.State
            );

        //
        // Turn off the device's IO and MEMory access.
        //
        PciDecodeEnable(pdoExtension, FALSE, NULL);
        status = STATUS_SUCCESS;

    }
    return status;
}

NTSTATUS
PciPdoWaitWake(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )

/*++

Routine Description:

    Handle IRP_MN_WAIT_WAKE for PCI PDOs.

    This operation is used to wait for the device to signal a wake event.
    By waiting for a wake signal from a device, its wake event is enabled
    so long as the System Power State is above the requested SystemWake
    state.   By not waiting for a wake signal from a device, its wake
    signal is not enabled.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP.

Return Value:

    NT status.

    STATUS_INVALID_DEVICE_STATE, if the device is in the PowerD0 state or
        a state below which can support waking or if the SystemWake state
        is below a state which can be supported.

        A pending IRP_MN_WAIT_WAKE will complete with this error if the
        device's state is changed to be incompatible with the wake request.

    STATUS_DEVICE_BUSY, if the device already has a WAIT_WAKE request
        outstanding.  To change the SystemWake level the outstanding
        IRP must be canceled.

    STATUS_INVALID_DEVICE_REQUEST, if the device is not capable of
        signaling a wakeup.   In theory we should have gotten out
        before getting this far because DeviceWake woud be unspecified.

    STATUS_SUCCESS.  The device has signaled a WAKE event.

    STATUS_PENDING.  This is the expected return, the IRP will not
        complete until the wait is complete or cancelled.

--*/

{
    BOOLEAN             pmeCapable;
    DEVICE_POWER_STATE  devPower;
    NTSTATUS            status;
    PPCI_FDO_EXTENSION      fdoExtension;
    POWER_STATE         powerState;
    PPCI_PDO_EXTENSION      pdoExtension;
    ULONG               waitCount;

    pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;

    ASSERT_PCI_PDO_EXTENSION(pdoExtension);

    PoStartNextPowerIrp(Irp);

    devPower = pdoExtension->PowerState.CurrentDeviceState;

    //
    // The docs say WAIT_WAKE is allowed only from a state < D0, and
    // only if current power state supports wakeup.
    //

    PCI_ASSERT(devPower < PowerDeviceMaximum);

    if ((devPower > pdoExtension->PowerState.DeviceWakeLevel) ||
        (pdoExtension->PowerState.DeviceWakeLevel == PowerDeviceUnspecified)) {

        //
        // NTRAID #62653 - 4/28/2000 - andrewth
        // Need to add system state to conditions here.
        //

        PciDebugPrint(
            PciDbgWaitWake,
            "WaitWake: pdox %08x current state (%d) not valid for waiting\n",
            pdoExtension,
            devPower
            );

        status = STATUS_INVALID_DEVICE_STATE;
        goto PciPdoWaitWakeFailIrp;

    }

    PCI_LOCK_OBJECT(pdoExtension);

    //
    // Only one WAIT_WAKE IRP allowed.   Set THIS IRP as the wait wake
    // irp in the pdo extension, if and only if, there is no other irp
    // there.
    //

    if (pdoExtension->PowerState.WaitWakeIrp != NULL) {

        //
        // A WAIT_WAKE IRP is already pending for this device.
        //

        PCI_UNLOCK_OBJECT(pdoExtension);
        PciDebugPrint(
            PciDbgWaitWake,
            "WaitWake: pdox %08x is already waiting\n",
            devPower
            );
        status = STATUS_DEVICE_BUSY;
        goto PciPdoWaitWakeFailIrp;

    }

    //
    // Does this device support Power Management?   That is, do we
    // know how to enable PME?
    //
    PciPmeGetInformation(
        pdoExtension->PhysicalDeviceObject,
        &pmeCapable,
        NULL,
        NULL
        );
    if (pmeCapable == FALSE) {

        //
        // This device does not support Power Management.
        // Don't allow a wait wake.   In theory we couldn't
        // have gotten here because our capabilities should
        // have stopped the caller from even trying this.
        //
        PCI_UNLOCK_OBJECT(pdoExtension);
        PciDebugPrint(
            PciDbgWaitWake,
            "WaitWake: pdox %08x does not support PM\n",
            devPower
            );
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto PciPdoWaitWakeFailIrp;

    }

    fdoExtension = PCI_PARENT_FDOX(pdoExtension);
    ASSERT_PCI_FDO_EXTENSION(fdoExtension);
    if (fdoExtension->Fake) {

        //
        // Parent is really PCMCIA.sys, his filter will take care
        // of sending the wait wake to the parent,... bail out.
        //
        PCI_UNLOCK_OBJECT(pdoExtension);
        return STATUS_PENDING;

    }

    //
    // We're going to do this.  Set the wait wake irp field in the
    // pdo extension and set cancel routine for this IRP.
    //
    PciDebugPrint(
        PciDbgWaitWake,
        "WaitWake: pdox %08x setting PMEEnable.\n",
        pdoExtension
        );

    pdoExtension->PowerState.WaitWakeIrp = Irp;

    IoMarkIrpPending(Irp);

    pdoExtension->PowerState.SavedCancelRoutine =
        IoSetCancelRoutine(Irp, PciPdoWaitWakeCancelRoutine);

    //
    // NTRAID #62653 - 4/28/2000 - andrewth
    // What is the correct behaviour if there are stacked
    // cancel routines?
    //
    PCI_ASSERT(!pdoExtension->PowerState.SavedCancelRoutine);

    //
    // Set the PME Enable bit.
    //
    PciPdoAdjustPmeEnable( pdoExtension, TRUE );

    //
    // Remember that the parent now has one more child that is armed
    // for wakeup
    //
    waitCount = InterlockedIncrement(&fdoExtension->ChildWaitWakeCount);

    //
    // Once we have a wait count reference, we can unlock the object
    //
    PCI_UNLOCK_OBJECT(pdoExtension);

    //
    // This PDO is now waiting.  If this is the first child of this
    // PDO's parent bus to enter this state, the parent bus should
    // also enter this state.
    //
    if (waitCount == 1) {

        //
        // Note that there are two values that can use here, the
        // SystemWakeLevel of the FDO itself or the SystemWakeLevel of
        // the PDO. Both are equally valid, but since we want to catch people
        // who fail to prevent the system from going into a deeper sleep state
        // than their device can support, we use the SystemWakeLevel from the
        // PDO, which conviniently enough, is stored in the irp..
        //
        powerState.SystemState = IrpSp->Parameters.WaitWake.PowerState;

        //
        // Request a power irp to go to our parent stack
        //
        PoRequestPowerIrp(
            fdoExtension->FunctionalDeviceObject,
            IRP_MN_WAIT_WAKE,
            powerState,
            PciPdoWaitWakeCallBack,
            fdoExtension,
            NULL
            );

    }

    //
    // If we get to this point, then we will return pending because we
    // have queue up the request
    //
    status = STATUS_PENDING;

PciPdoWaitWakeFailIrp:
    if (!NT_SUCCESS(status)) {

        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    } else {

        PCI_ASSERT( status == STATUS_PENDING );

    }
    return status;
}

NTSTATUS
PciPdoWaitWakeCallBack(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  UCHAR               MinorFunction,
    IN  POWER_STATE         PowerState,
    IN  PVOID               Context,
    IN  PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:

    This is the callback routine that gets invoked when the W/W irp that was
    sent to the FDO by a PDO is finished. The purpose of this routine is to
    see if we need to re-arm the W/W on the FDO because we have more devices
    with W/W outstanding on them

Arguments:

    DeviceObject        - The FDO's device object
    MinorFunction       - IRP_MN_WAIT_WAKE
    PowerState          - The sleep state that was used to wake up the system
    Context             - The FDO Extension
    IoStatus            - The Status of the request

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN         pmeStatus;
    PPCI_FDO_EXTENSION  fdoExtension = (PPCI_FDO_EXTENSION) Context;
    PIRP            finishedIrp;
    PPCI_PDO_EXTENSION  pdoExtension;

    //
    // Normally, the IRP (to the PDO) will have completed with
    // STATUS_SUCCESS.  In that case, just wake up the one device
    // which is signalling for wakeup.   If the IRP to the PDO
    // failed, wake up ALL devices that are dependent on this wake.
    //

    PCI_LOCK_OBJECT(fdoExtension);

    //
    // If the current WaitWakeIrp is not NULL, another IRP has been requested
    // as this one was completed.  It has taken over responsibility for completing
    // child IRPs, so just bail here.
    //
    if (fdoExtension->PowerState.WaitWakeIrp != NULL) {
        
        PCI_UNLOCK_OBJECT(fdoExtension);
        return STATUS_SUCCESS;
    }
    PCI_UNLOCK_OBJECT(fdoExtension);

    //
    // For each child
    //
    for (pdoExtension = fdoExtension->ChildPdoList;
         pdoExtension && fdoExtension->ChildWaitWakeCount;
         pdoExtension = pdoExtension->Next) {

        //
        // Does this device do power management and if so, does
        // it have an outstanding WaitWake IRP?
        //
        PCI_LOCK_OBJECT(pdoExtension);
        if (pdoExtension->PowerState.WaitWakeIrp != NULL) {

            PciPmeGetInformation(
                pdoExtension->PhysicalDeviceObject,
                NULL,
                &pmeStatus,
                NULL
                );

            //
            // Is this device signalling for a wakeup?  (Or, if we
            // are completing wake irps because our own wait_wake
            // failed).
            //
            if (pmeStatus || !NT_SUCCESS(IoStatus->Status)) {

                //
                // Yes.  Complete its outstanding wait wake IRP.
                //

#if DBG
                if (pmeStatus) {

                    PciDebugPrint(
                        PciDbgWaitWake,
                        "PCI - pdox %08x is signalling a PME\n",
                        pdoExtension
                        );

                } else {

                    PciDebugPrint(
                        PciDbgWaitWake,
                        "PCI - waking pdox %08x because fdo wait failed %0x.\n",
                        pdoExtension,
                        IoStatus->Status
                        );
                }
#endif

                //
                // Wait_wake irp being dequeued, disable the PME enable,
                // clear PMEStatus (if set) and EOI this device.
                //
                PciPdoAdjustPmeEnable( pdoExtension, FALSE );

                //
                // Make sure this IRP will not be completed again,
                // or, canceled.
                //
                finishedIrp = pdoExtension->PowerState.WaitWakeIrp;
                pdoExtension->PowerState.WaitWakeIrp = NULL;
                IoSetCancelRoutine(finishedIrp, NULL);

                PoStartNextPowerIrp( finishedIrp );
                PciCompleteRequest(
                    finishedIrp,    // send down parent status
                    IoStatus->Status
                    );

                //
                // Decrement the waiter count.
                //
                PCI_ASSERT(fdoExtension->ChildWaitWakeCount > 0);
                InterlockedDecrement( &(fdoExtension->ChildWaitWakeCount) );

            }

        }
        PCI_UNLOCK_OBJECT(pdoExtension);

    }

    //
    // Did we succeed this irp?
    //
    if (!NT_SUCCESS(IoStatus->Status)) {

        PciDebugPrint(
            PciDbgWaitWake,
            "WaitWake (fdox %08x) - WaitWake Irp Failed %08x\n",
            fdoExtension,
            IoStatus->Status
            );
        return IoStatus->Status;

    }

    //
    // Are there any children with outstanding WaitWakes on thems?
    //
    if (fdoExtension->ChildWaitWakeCount) {

        PciDebugPrint(
            PciDbgWaitWake,
            "WaitWake (fdox %08x) - WaitWake Irp restarted - count = %x\n",
            fdoExtension,
            fdoExtension->ChildWaitWakeCount
            );

        //
        // Loop
        //
        PoRequestPowerIrp(
            DeviceObject,
            MinorFunction,
            PowerState,
            PciPdoWaitWakeCallBack,
            Context,
            NULL
            );
#if DBG
    } else {

        PciDebugPrint(
            PciDbgWaitWake,
            "WaitWake (fdox %08x) - WaitWake Irp Finished\n",
            fdoExtension
            );

#endif

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

VOID
PciPdoWaitWakeCancelRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN OUT PIRP         Irp
    )
/*++

Routine Description:

    Cancel an outstanding WAIT_WAKE IRP.

    Note: The Cancel Spin Lock is held on entry.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP.

Return Value:

    None.

--*/
{
    PPCI_PDO_EXTENSION pdoExtension;
    PPCI_FDO_EXTENSION fdoExtension;
    PIRP savedParentWaitWake;

    KIRQL oldIrql;
    ULONG waitCount;

    pdoExtension = (PPCI_PDO_EXTENSION) DeviceObject->DeviceExtension;

    PciDebugPrint(
        PciDbgWaitWake,
        "WaitWake (pdox %08x) Cancel routine, Irp %08x.\n",
        pdoExtension,
        Irp
        );

    ASSERT_PCI_PDO_EXTENSION(pdoExtension);

    oldIrql = Irp->CancelIrql;
    IoReleaseCancelSpinLock(oldIrql);

    PCI_LOCK_OBJECT(pdoExtension);

    if (pdoExtension->PowerState.WaitWakeIrp == NULL) {

        //
        // The WaitWake IRP has already been dealt with.
        //

        PCI_UNLOCK_OBJECT(pdoExtension);
        return;
    }

    //
    // Clear WaitWake Irp in the PDO.
    //

    pdoExtension->PowerState.WaitWakeIrp = NULL;

    PciPdoAdjustPmeEnable(pdoExtension, FALSE);

    //
    // As this is a cancel, the wait wake count in the parent has not
    // been decremented.   Decrement it here and if decrementing to
    // zero waiters, cancel the IRP at the parent.
    //

    fdoExtension = PCI_PARENT_FDOX(pdoExtension);

    ASSERT_PCI_FDO_EXTENSION(fdoExtension);

    waitCount = InterlockedDecrement(&fdoExtension->ChildWaitWakeCount);

    PCI_UNLOCK_OBJECT(pdoExtension);

    if (waitCount == 0) {

        savedParentWaitWake = NULL;
        PCI_LOCK_OBJECT(fdoExtension);
        if (fdoExtension->PowerState.WaitWakeIrp) {
            
            savedParentWaitWake = fdoExtension->PowerState.WaitWakeIrp;
            fdoExtension->PowerState.WaitWakeIrp = NULL;
        }
        PCI_UNLOCK_OBJECT(fdoExtension);

        if (savedParentWaitWake) {
            
            //
            // Cancel the parent's wait wake also.
            //
            PciDebugPrint(
                PciDbgWaitWake,
                "WaitWake (pdox %08x) zero waiters remain on parent, cancelling parent wait.\n",
                pdoExtension
                );
    
            IoCancelIrp(savedParentWaitWake);    
        }
        
    }

    //
    // Complete the IRP.
    //

    Irp->IoStatus.Information = 0;
    PoStartNextPowerIrp(Irp);
    PciCompleteRequest(Irp, STATUS_CANCELLED);

    //
    // NTRAID #62653 - 4/28/2000 - andrewth
    // Need to cause the bus parent to decrement its outstanding
    // IRP counter,... how to make this happen?
    //

    return;
}

NTSTATUS
PciFdoIrpQueryPower(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    
            
    //
    // pass 1, claim we can do it.
    //
    return STATUS_SUCCESS;
}

NTSTATUS
PciFdoSetPowerState (
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
/*++

Routine Description:

    Handle SET_POWER irps set to an FDO

    Basic Rules for handling this:
        - If this is a DEVICE power irp, we don't need to do anything since
          for root buses and bridges, all necessary programming is done by the
          PDO
        - If this is a SYSTEM power irp, then
            a) block all incoming IRP_MN_POWER requests (using a spinlock)
            b) use the capabilities table in the device extension to determine
               what the "highest" allowed DEVICE state that we should transition
               the device into
            c) look at all the children of this device and see if we can pick a
               "lower" DEVICE state.
            d) Consideration should be granted if a child is armed for wake
               or if this device is armed for wake (in general, both should be
               true, or both should be false)
            e) Remember the answer as the "Desired State"
            f) Release the spinlock and allow other IRP_MN_POWER requests in
            g) Use PoRequestPowerIrp() to request a power irp to put the device
               in the appropriate state
            h) return STATUS_PENDING
         - In another thread context (ie: in the context of the completion
           passed to PoRequestPowerIrp), complete the irp that was handed to
           us

Arguments:

    Irp             - The Power Irp
    IrpSp           - The current stack location in the irp
    DeviceExtension - The device whose power we want to set

--*/
{
    POWER_STATE         desiredState;
    PPCI_FDO_EXTENSION      fdoExtension;
    SYSTEM_POWER_STATE  systemState;

    fdoExtension = (PPCI_FDO_EXTENSION) DeviceExtension;

    ASSERT_PCI_FDO_EXTENSION(fdoExtension);

    //
    // If this is a device power irp, remember that we say it go by, and
    // remember what D-state the bus/bridge is now in. If we needed to do more
    // here, then we should have to distinguish between power up and power down
    // requests. PowerDown requests we can add the code in-line. PowerUp
    // requests would force us to set a completion routine on the IRP and do
    // the work in the completion routine
    //
    if (IrpSp->Parameters.Power.Type == DevicePowerState) {

        fdoExtension->PowerState.CurrentDeviceState =
            IrpSp->Parameters.Power.State.DeviceState;
        return STATUS_SUCCESS;

    }

    //
    // If we aren't started, don't touch the power IRP.
    //
    if (fdoExtension->DeviceState != PciStarted) {

        return STATUS_NOT_SUPPORTED;

    }

    //
    // If this isn't a SystemPowerState irp, then we don't know what it is, and
    // so we will not support it
    //
    PCI_ASSERT( IrpSp->Parameters.Power.Type == SystemPowerState );
    if (IrpSp->Parameters.Power.Type != SystemPowerState) {

        return STATUS_NOT_SUPPORTED;

    }

    //
    // If this is a Shutdown so we can warm reboot don't take the bridges to D3 as
    // if the video or boot device is behind the bridge and the BIOS doesn't power
    // things up (most don't) then we don't reboot...
    //

    if (IrpSp->Parameters.Power.State.SystemState == PowerSystemShutdown
    &&  IrpSp->Parameters.Power.ShutdownType == PowerActionShutdownReset) {

        return STATUS_SUCCESS;
    }

    //
    // Grab the system state that we want to go to
    //
    systemState = IrpSp->Parameters.Power.State.SystemState;
    PCI_ASSERT( systemState > PowerSystemUnspecified && systemState < PowerSystemMaximum );

    //
    // At this point, we can assume that we will transition the Device into a
    // least the following D-state
    //
    desiredState.DeviceState = fdoExtension->PowerState.SystemStateMapping[ systemState ];

    //
    // Mark the irp as pending
    //
    IoMarkIrpPending( Irp );

    //
    // Send a request
    //
    PoRequestPowerIrp(
        fdoExtension->FunctionalDeviceObject,
        IRP_MN_SET_POWER,
        desiredState,
        PciFdoSetPowerStateCompletion,
        Irp,
        NULL
        );
    return STATUS_PENDING;
}

VOID
PciFdoSetPowerStateCompletion(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  UCHAR               MinorFunction,
    IN  POWER_STATE         PowerState,
    IN  PVOID               Context,
    IN  PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:

    This routine is called when the D-Irp that was requested by the FDO
    has been completed.

    This routine needs to pass the S-Irp that initiated the D-Irp all the
    way down the stack

Arguments:

    DeviceObject    - The FDO device object
    MinorFunction   - IRP_MN_SET_POWER
    PowerState      - Whatever the requested power state was
    Context         - This is really the S-Irp that requested the D-Irp
    IoStatus        - The result of the D-Irp

Return Value:

    None

--*/
{
    PPCI_FDO_EXTENSION  fdoExtension;
    PIRP            irp = (PIRP) Context;
    PIO_STACK_LOCATION irpSp;

        
    PCI_ASSERT( IoStatus->Status == STATUS_SUCCESS );

    //
    // Grab a pointer to the FDO extension and make sure that it is valid
    fdoExtension = (PPCI_FDO_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT_PCI_FDO_EXTENSION(fdoExtension);

    irpSp = IoGetCurrentIrpStackLocation(irp);

    //
    // Check if we are returning from a hibernate and powering on the bus
    //

    if (irpSp->Parameters.Power.State.SystemState == PowerSystemWorking
    &&  fdoExtension->Hibernated) {

        fdoExtension->Hibernated = FALSE;

            //
            // Scan the bus and turn off any new hardware
            //

            PciScanHibernatedBus(fdoExtension);
        }


    if (irpSp->Parameters.Power.ShutdownType == PowerActionHibernate
    &&  irpSp->Parameters.Power.State.SystemState > PowerSystemWorking) {

            //
            // We're powering down for a hibernate so remember
            //

            fdoExtension->Hibernated = TRUE;
    }

    //
    // Mark the current irp as having succeeded
    //
    irp->IoStatus.Status = STATUS_SUCCESS;

    //
    // Start the next power irp for this device
    //
    PoStartNextPowerIrp( irp );

    //
    // Get ready to pass the power irp down the stack
    //
    IoCopyCurrentIrpStackLocationToNext( irp );

    //
    // Pass the irp down the stack
    //
    PoCallDriver( fdoExtension->AttachedDeviceObject, irp );
}

NTSTATUS
PciFdoWaitWake(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )

/*++

Routine Description:

    Handle IRP_MN_WAIT_WAKE for PCI FDOs.

    PCI FDOs receive a WAIT_WAKE IRP when the number of child PDOs
    with a pending WAIT_WAKE IRP transitions from 0 to 1.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP.

Return Value:

    NT status.

--*/

{
    PIO_STACK_LOCATION irpStack;
    PPCI_FDO_EXTENSION fdoExtension;
    NTSTATUS status;

    fdoExtension = (PPCI_FDO_EXTENSION) DeviceExtension;

    ASSERT_PCI_FDO_EXTENSION(fdoExtension);

    irpStack = IrpSp;

    PCI_LOCK_OBJECT(fdoExtension);

    //
    // Only one WAIT_WAKE IRP allowed.   Set THIS IRP as the wait wake
    // irp in the fdo extension, if and only if, there is no other irp
    // there.
    //
    // Note: The ChildWaitWakeCount field is incremented by the PCI
    // driver before sending this IRP down.  Only accept this IRP if
    // the ChildWaitWakeCount field is one (ie don't listen to ACPI).
    //
    if (!fdoExtension->ChildWaitWakeCount) {

        //
        // Didn't come from a PCI PDO, ignore it.
        //
        PciDebugPrint(
            PciDbgWaitWake,
            "WaitWake (fdox %08x) Unexpected WaitWake IRP IGNORED.\n",
            fdoExtension
            );
        status = STATUS_DEVICE_BUSY;
        goto Cleanup;

    }
    if (fdoExtension->PowerState.WaitWakeIrp != NULL) {

        //
        // A WAIT_WAKE IRP is already pending for this device.
        //
        PciDebugPrint(
            PciDbgWaitWake,
            "WaitWake: fdox %08x already waiting (%d waiters)\n",
            fdoExtension,
            fdoExtension->ChildWaitWakeCount
            );
        status = STATUS_DEVICE_BUSY;
        goto Cleanup;

    }

    fdoExtension->PowerState.WaitWakeIrp = Irp;

    //
    // This IRP will be passed down to the underlying PDO who
    // will pend it.   The completion routine does needs to check
    // that the bus is capable of checking its children and then
    // examining each child (that has a wait wake outstanding).
    //
    PciDebugPrint(
        PciDbgWaitWake,
        "WaitWake: fdox %08x is a now waiting for a wake event\n",
        fdoExtension
        );
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(
        Irp,
        PciFdoWaitWakeCompletion,
        fdoExtension,
        TRUE,
        TRUE,
        TRUE
        );
    Irp->IoStatus.Status = status = STATUS_SUCCESS;

Cleanup:

    PCI_UNLOCK_OBJECT(fdoExtension);
    //
    // Start the next power irp
    //
    PoStartNextPowerIrp(Irp);
    if (!NT_SUCCESS(status) ) {

        PciCompleteRequest(Irp, status);
        return status;

    }

    //
    // Pass the IRP down the stack.
    //
    return PoCallDriver(fdoExtension->AttachedDeviceObject ,Irp);
}

NTSTATUS
PciFdoWaitWakeCallBack(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  UCHAR               MinorFunction,
    IN  POWER_STATE         PowerState,
    IN  PVOID               Context,
    IN  PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:

    This routine is called when a device has transitioned back into the
    into the D-zero state

Arguments:

    DeviceObject    - Pointer to the FDO
    MinorFunction   - IRP_MN_SET_POWER
    PowerState      - D0
    Context         - The WaitWake irp that caused us to make this transition
    IoStatus        - The status of the request

Return Value:

    NTSTATUS

--*/
{
    PIRP    waitWakeIrp = (PIRP) Context;

            
    //
    // Complete the wait wake irp
    //
    PoStartNextPowerIrp( waitWakeIrp );
    PciCompleteRequest( waitWakeIrp, IoStatus->Status );

    //
    // Done
    //
    return IoStatus->Status;
}

VOID
PciFdoWaitWakeCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    Cancel an outstanding WAIT_WAKE IRP.

    Note: The Cancel Spin Lock is held on entry.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP.

Return Value:

    None.

--*/

{
    PPCI_FDO_EXTENSION fdoExtension;
    KIRQL oldIrql;

    fdoExtension = (PPCI_FDO_EXTENSION)DeviceObject->DeviceExtension;

    PciDebugPrint(
        PciDbgWaitWake,
        "WaitWake (fdox %08x) Cancel routine, Irp %08x.\n",
        fdoExtension,
        Irp
        );

    ASSERT_PCI_FDO_EXTENSION(fdoExtension);

    oldIrql = Irp->CancelIrql;

    IoReleaseCancelSpinLock(oldIrql);

    PCI_LOCK_OBJECT(fdoExtension);
    if (fdoExtension->PowerState.WaitWakeIrp == NULL) {

        //
        // The WaitWake IRP has already been dealt with.
        //
        PCI_UNLOCK_OBJECT(fdoExtension);
        return;

    }
    fdoExtension->PowerState.WaitWakeIrp = NULL;
    PCI_UNLOCK_OBJECT(fdoExtension);

    Irp->IoStatus.Information = 0;
    PoStartNextPowerIrp(Irp);
    PciCompleteRequest(Irp, STATUS_CANCELLED);

    return;
}

NTSTATUS
PciFdoWaitWakeCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PPCI_FDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    Handle IRP_MN_WAIT_WAKE completion for PCI FDOs.

    WAIT_WAKE completion at the FDO means some device (not necesarily
    a child of this FDO) is signalling wake.  This routine scans each
    child to see if that device is the one.   This is a recursive
    operation.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP.

Return Value:

    NT status.

--*/

{
    POWER_STATE powerState;

    PciDebugPrint(
        PciDbgWaitWake,
        "WaitWake (fdox %08x) Completion routine, Irp %08x, IrpStatus = %08x.\n",
        FdoExtension,
        Irp,
        Irp->IoStatus.Status
        );

    ASSERT_PCI_FDO_EXTENSION(FdoExtension);

    //
    // We will need the device's lock for some of the following...
    //
    PCI_LOCK_OBJECT(FdoExtension);

    //
    // If the stored wait/wake IRP is the one we're completing, record
    // that it has been completed.  If the stored IRP is NOT the one we're
    // completing, it is a new one that has crossed this one in flight.  Leave
    // it alone.
    //
    if ((FdoExtension->PowerState.WaitWakeIrp == Irp) ||
        (FdoExtension->PowerState.WaitWakeIrp == NULL)) {
        
        FdoExtension->PowerState.WaitWakeIrp = NULL;    
    
    
        //
        // Check the bus is at a power level at which the config space
        // of its children can be examined.
        //
        // NTRAID #62653 - 4/28/2000 - andrewth
        //
        // Question: Should we depend on PO to take care of this requirement?
        // can we use PO to do the needed power state changes?
        //
        // Assumption: The parent of this bus is powered at this moment.
        //
        if (FdoExtension->PowerState.CurrentDeviceState != PowerDeviceD0) {
    
            powerState.SystemState = PowerDeviceD0;
    
            //
            // Power up the bus.
            //
            PoRequestPowerIrp(
                DeviceObject,
                IRP_MN_SET_POWER,
                powerState,
                PciFdoWaitWakeCallBack,
                Irp,
                NULL
                );
            PCI_UNLOCK_OBJECT(FdoExtension);
            return STATUS_MORE_PROCESSING_REQUIRED;
    
        }
    }

    //
    // Done with lock
    //
    PCI_UNLOCK_OBJECT(FdoExtension);
    return STATUS_SUCCESS;
}

NTSTATUS
PciStallForPowerChange(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN DEVICE_POWER_STATE PowerState,
    IN UCHAR PowerCapabilityPointer
    )
{
    NTSTATUS status = STATUS_DEVICE_PROTOCOL_ERROR;
    PVERIFIER_DATA verifierData;
    LONG delay;
    ULONG retries = 100;
    KIRQL irql;
    PCI_PMCSR pmcsr;

    PCI_ASSERT(PdoExtension->PowerState.CurrentDeviceState >= PowerDeviceD0
           && PdoExtension->PowerState.CurrentDeviceState <= PowerDeviceD3);
    PCI_ASSERT(PowerState >= PowerDeviceD0 && PowerState <= PowerDeviceD3);
    PCI_ASSERT(!(PdoExtension->HackFlags & PCI_HACK_NO_PM_CAPS));

    //
    // Lookup the delay we are meant to do as in the PCI spec
    //

    delay = PciPowerDelayTable[PdoExtension->PowerState.CurrentDeviceState-1][PowerState-1];

    //
    // Stall in a polite fashion if IRQL allows
    //

    irql = KeGetCurrentIrql();

    while (retries--) {

        if (delay > 0) {

            if (irql < DISPATCH_LEVEL) {

                //
                // Get off the processor.
                //
                // timeoutPeriod is in units of 100ns, negative means
                // relative.
                //

                LARGE_INTEGER timeoutPeriod;

                timeoutPeriod.QuadPart = -10 * delay;
                timeoutPeriod.QuadPart -= (KeQueryTimeIncrement() - 1);

                KeDelayExecutionThread(KernelMode,
                                       FALSE,
                                       &timeoutPeriod
                                        );
            } else {

                //
                // Spin, units are microseconds
                //

                KeStallExecutionProcessor((ULONG)delay);
            }
        }

        //
        // Reread the status and control register.  The assumption here is that
        // some cards don't get their act together fast enough and the fact that
        // they arn't ready yet is reflected by them not updating the power control
        // register with what we just wrote to it.  This is not in the PCI spec
        // but is how some of these broken cards work and it can't hurt...
        //

        PciReadDeviceConfig(
            PdoExtension,
            &pmcsr,
            PowerCapabilityPointer + FIELD_OFFSET(PCI_PM_CAPABILITY,PMCSR),
            sizeof(PCI_PMCSR)
            );


        //
        // Pci power states are 0-3 where as NT power states are 1-4
        //

        if (pmcsr.PowerState == PowerState-1) {

            //
            // Device is ready, we're done.
            //
            return STATUS_SUCCESS;
        }

        //
        // Subsequent iterations, delay 1ms.
        //

        delay = 1000;

    }

    //
    // So how nasty can this sort of problem be?
    //
    // If this is an ATI M1 (mobile video) and on some machines under some
    // circumstances (and no ATI doesn't know which ones) they disable the
    // operation of the PMCSR.  It would have been nice if they had just
    // removed the PM capability from the list so we would have never
    // attempted to power manage this chip but they would have failed
    // WHQL.  Unfortunately it is not possible to just add these to the
    // list of devices that have bad PM because some BIOSes (read HP and
    // Dell) monitor this register to save extra state from the chip and
    // thus if we don't change it we spin in AML forever.
    //
    // Yes this is a gross hack.
    //
    verifierData = PciVerifierRetrieveFailureData(
        PCI_VERIFIER_PMCSR_TIMEOUT
        );

    PCI_ASSERT(verifierData);

    if (verifierData) {
        
        VfFailDeviceNode(
            PdoExtension->PhysicalDeviceObject,
            PCI_VERIFIER_DETECTED_VIOLATION,
            PCI_VERIFIER_PMCSR_TIMEOUT,
            verifierData->FailureClass,
            &verifierData->Flags,
            verifierData->FailureText,
            "%DevObj%Ulong",
            PdoExtension->PhysicalDeviceObject,
            PowerState-1
            );    
    }
    

    return status;
}


NTSTATUS
PciSetPowerManagedDevicePowerState(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN DEVICE_POWER_STATE DeviceState,
    IN BOOLEAN RefreshConfigSpace
    )

/*++

Routine Description:

    If the PCI device supports the PCI Power Management extensions,
    set the device to the desired state.   Otherwise, this routine
    does (can do) nothing.

Arguments:

    PdoExtension    Pointer to the PDO device extension for the device
                    being programmed. The current power state stored
                    in the extension is *not* updated by this function.

    DeviceState     Power state the device is to be set to.

Return Value:

    None.

--*/

{
    PCI_PM_CAPABILITY   pmCap;
    UCHAR               pmCapPtr = 0;
    NTSTATUS            status = STATUS_SUCCESS;

    //
    // If we are standing by then we want to power down the video to preseve the batteries,
    // we have already (in PdoPdoSetPoweState) decided to leave the video on for the hibernate
    // and shutdown cases.
    //

    if ((!PciCanDisableDecodes(PdoExtension, NULL, 0, PCI_CAN_DISABLE_VIDEO_DECODES)) &&
        (DeviceState != PowerDeviceD0)) {

        //
        // Here is a device we unfortunately can't turn off. We do not however
        // convert this to D0 - the virtual state of the device will represent
        // a powered down device, and only when a real D0 is requested will we
        // restore all the various state.
        //
        return STATUS_SUCCESS;
    }

    if (!(PdoExtension->HackFlags & PCI_HACK_NO_PM_CAPS) ) {

        pmCapPtr = PciReadDeviceCapability(
           PdoExtension,
           PdoExtension->CapabilitiesPtr,
           PCI_CAPABILITY_ID_POWER_MANAGEMENT,
           &pmCap,
           sizeof(pmCap)
           );

        if (pmCapPtr == 0) {
            //
            // We don't have a power management capability - how did we get here?
            //
            PCI_ASSERT(pmCapPtr);
            return STATUS_INVALID_DEVICE_REQUEST;

        }

        //
        // Set the device into its new D state
        //
        switch (DeviceState) {
        case PowerDeviceD0:
            pmCap.PMCSR.ControlStatus.PowerState = 0;

            //
            // PCI Power Management Specification. Table-7. Page 25
            //
            if (pmCap.PMC.Capabilities.Support.PMED3Cold) {

                pmCap.PMCSR.ControlStatus.PMEStatus = 1;

            }
            break;
        case PowerDeviceUnspecified:
            PCI_ASSERT( DeviceState != PowerDeviceUnspecified);
            pmCapPtr = 0;
            break;
        default:
            pmCap.PMCSR.ControlStatus.PowerState = (DeviceState - 1);
            break;
        }

        if (pmCapPtr) {

            PciWriteDeviceConfig(
                PdoExtension,
                &pmCap.PMCSR.ControlStatus,
                pmCapPtr + FIELD_OFFSET(PCI_PM_CAPABILITY,PMCSR.ControlStatus),
                sizeof(pmCap.PMCSR.ControlStatus)
                );

        } else {

            //
            // Debug only. ControlFlags should have been set so this
            // can't happen.
            //
            PCI_ASSERT(pmCapPtr);

        }

        //
        // Stall for the appropriate time
        //

        status = PciStallForPowerChange(PdoExtension, DeviceState, pmCapPtr);
    }

    //
    // Only update the config space if:
    //      - The device is happy and in the correct power state
    //      - We have been asked to refresh the config space
    //      - We have powered up the device
    //

    if (NT_SUCCESS(status)
    &&  RefreshConfigSpace
    &&  DeviceState < PdoExtension->PowerState.CurrentDeviceState) {
        status = PciSetResources(PdoExtension, TRUE, FALSE);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\pciverifier.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    pciverifier.h

Abstract:

    This header contains prototypes for hardware state verification.

Author:

    Adrian J. Oney (AdriaO) 02/20/2001

--*/

//
// The following definitions are external to pciverifier.c
//
VOID
PciVerifierInit(
    IN  PDRIVER_OBJECT  DriverObject
    );

VOID
PciVerifierUnload(
    IN  PDRIVER_OBJECT  DriverObject
    );

//
// This is the list of PCI verifier failures.
//
typedef enum {

    PCI_VERIFIER_BRIDGE_REPROGRAMMED = 1,
    PCI_VERIFIER_PMCSR_TIMEOUT,
    PCI_VERIFIER_PROTECTED_CONFIGSPACE_ACCESS,
    PCI_VERIFIER_INVALID_WHICHSPACE

} PCI_VFFAILURE, *PPCI_VFFAILURE;

//
// This structure specifies table elements used when failing hardware, bioses,
// or drivers.
//
typedef struct {

    PCI_VFFAILURE       VerifierFailure;
    VF_FAILURE_CLASS    FailureClass;
    ULONG               Flags;
    PSTR                FailureText;

} VERIFIER_DATA, *PVERIFIER_DATA;

PVERIFIER_DATA
PciVerifierRetrieveFailureData(
    IN  PCI_VFFAILURE   VerifierFailure
    );

//
// These definitions are *internal* to pciverifier.c
//
NTSTATUS
PciVerifierProfileChangeCallback(
    IN  PHWPROFILE_CHANGE_NOTIFICATION  NotificationStructure,
    IN  PVOID                           NotUsed
    );

VOID
PciVerifierEnsureTreeConsistancy(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\pmeintf.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    gpeintf.c

Abstract:

    This module implements the "PME" interfaces supported
    by the PCI driver.

Author:

    Stephane Plante (splante) Feb-1-1999

Revision History:

--*/

#include "pcip.h"

NTSTATUS
PciPmeInterfaceConstructor(
    PVOID       DeviceExtension,
    PVOID       PciInterface,
    PVOID       InterfaceSpecificData,
    USHORT      Version,
    USHORT      Size,
    PINTERFACE  InterfaceReturn
    );

VOID
PciPmeInterfaceDereference(
    IN PVOID Context
    );

NTSTATUS
PciPmeInterfaceInitializer(
    IN PPCI_ARBITER_INSTANCE Instance
    );

VOID
PciPmeInterfaceReference(
    IN PVOID Context
    );

VOID
PciPmeUpdateEnable(
    IN  PDEVICE_OBJECT   Pdo,
    IN  BOOLEAN          PmeEnable
    );

//
// Define the Pci PME interface "interface" structure
//
PCI_INTERFACE PciPmeInterface = {
    &GUID_PCI_PME_INTERFACE,        // Interface Type
    sizeof(PCI_PME_INTERFACE),      // Mininum Size
    PCI_PME_INTRF_STANDARD_VER,     // Minimum Version
    PCI_PME_INTRF_STANDARD_VER,     // Maximum Version
    PCIIF_FDO | PCIIF_ROOT,         // Flags
    0,                              // ReferenceCount
    PciInterface_PmeHandler,        // Signature
    PciPmeInterfaceConstructor,     // Constructor
    PciPmeInterfaceInitializer      // Instance Initializer
};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PciPmeInterfaceConstructor)
#pragma alloc_text(PAGE, PciPmeInterfaceDereference)
#pragma alloc_text(PAGE, PciPmeInterfaceInitializer)
#pragma alloc_text(PAGE, PciPmeInterfaceReference)
#endif


VOID
PciPmeAdjustPmeEnable(
    IN  PPCI_PDO_EXTENSION  PdoExtension,
    IN  BOOLEAN         Enable,
    IN  BOOLEAN         ClearStatusOnly
    )
/*++

Routine Description:

    This is the only routine in the the PCI driver that is allowed to set
    the PME Enable pin for a device.

Arguments:

    PdoExtension    - The device that wants to have the PME enable set
    Enable          - Turn on the PME pin or not
    ClearStatusOnly - Only clear the status --- ignore the Enable bit

Return Value:

    VOID

--*/
{
    PCI_PM_CAPABILITY   pmCap;
    UCHAR               pmCapPtr     = 0;

    //
    // Are there any pm capabilities?
    //
    if (!(PdoExtension->HackFlags & PCI_HACK_NO_PM_CAPS) ) {

        pmCapPtr = PciReadDeviceCapability(
            PdoExtension,
            PdoExtension->CapabilitiesPtr,
            PCI_CAPABILITY_ID_POWER_MANAGEMENT,
            &pmCap,
            sizeof(pmCap)
            );

    }
    if (pmCapPtr == 0) {

        return;

    }

    //
    // Set or clear the PMEEnable bit depending on the value of Enable
    //
    if (!ClearStatusOnly) {

        pmCap.PMCSR.ControlStatus.PMEEnable = (Enable != 0);

    }

    //
    // Write back what we read to clear the PME Status.
    //
    PciWriteDeviceConfig(
        PdoExtension,
        &(pmCap.PMCSR.ControlStatus),
        pmCapPtr + FIELD_OFFSET(PCI_PM_CAPABILITY, PMCSR.ControlStatus),
        sizeof(pmCap.PMCSR.ControlStatus)
        );
}

VOID
PciPmeClearPmeStatus(
    IN  PDEVICE_OBJECT  Pdo
    )
/*++

Routine Description:

    This routine explicitly clears the PME status bit from a device

Arguments:

    Pdo - The device whose pin we are to clear

Return Value:

    VOID

--*/
{
    PPCI_PDO_EXTENSION  pdoExtension = (PPCI_PDO_EXTENSION) Pdo->DeviceExtension;

    ASSERT_PCI_PDO_EXTENSION( pdoExtension );

    //
    // Call the Adjust function to do the actual work. Note that passing
    // in the 3rd argument as TRUE means that the 2nd argument is ignored
    //
    PciPmeAdjustPmeEnable( pdoExtension, FALSE, TRUE );
}

VOID
PciPmeGetInformation(
    IN  PDEVICE_OBJECT  Pdo,
    OUT PBOOLEAN    PmeCapable,
    OUT PBOOLEAN    PmeStatus,
    OUT PBOOLEAN    PmeEnable
    )
/*++

Routine Description:

    Supplies the information regarding a PDO's PME capabilities

Arguments:

    Pdo         - The device object whose capabilities we care about
    PmeCapable  - Can the device generate a PME?
    PmeStatus   - Is the PME status for the device on?
    PmeEnable   - Is the PME enable for the device on?

Return Value:

    None

--*/
{
    BOOLEAN             pmeCapable   = FALSE;
    BOOLEAN             pmeEnable    = FALSE;
    BOOLEAN             pmeStatus    = FALSE;
    PCI_PM_CAPABILITY   pmCap = {0};
    PPCI_PDO_EXTENSION      pdoExtension = (PPCI_PDO_EXTENSION) Pdo->DeviceExtension;
    UCHAR               pmCapPtr     = 0;

    ASSERT_PCI_PDO_EXTENSION( pdoExtension );

    //
    // Get the current power management capabilities from the device
    //
    if (!(pdoExtension->HackFlags & PCI_HACK_NO_PM_CAPS) ) {

        pmCapPtr = PciReadDeviceCapability(
            pdoExtension,
            pdoExtension->CapabilitiesPtr,
            PCI_CAPABILITY_ID_POWER_MANAGEMENT,
            &pmCap,
            sizeof(pmCap)
            );

    }

    if (pmCapPtr == 0) {

        //
        // No power capabilities
        //
        goto PciPmeGetInformationExit;

    }

    //
    // At this point, we are found to be PME capable
    //
    pmeCapable = TRUE;

    //
    // Are enabled for PME?
    //
    if (pmCap.PMCSR.ControlStatus.PMEEnable == 1) {

        pmeEnable = TRUE;

    }

    //
    // Is the PME Status pin set?
    //
    if (pmCap.PMCSR.ControlStatus.PMEStatus == 1) {

        pmeStatus = TRUE;

    }

PciPmeGetInformationExit:

    if (PmeCapable != NULL) {

        *PmeCapable = pmeCapable;

    }
    if (PmeStatus != NULL) {

        *PmeStatus = pmeStatus;

    }
    if (PmeEnable != NULL) {

        *PmeEnable = pmeEnable;

    }
    return;

}

NTSTATUS
PciPmeInterfaceConstructor(
    PVOID       DeviceExtension,
    PVOID       PciInterface,
    PVOID       InterfaceSpecificData,
    USHORT      Version,
    USHORT      Size,
    PINTERFACE  InterfaceReturn
    )
/*++

Routine Description:

    Initialize the PCI_PME_INTERFACE fields.

Arguments:

    PciInterface    Pointer to the PciInterface record for this
                    interface type.
    InterfaceSpecificData

    InterfaceReturn

Return Value:

    Status

--*/

{
    PPCI_PME_INTERFACE   standard   = (PPCI_PME_INTERFACE) InterfaceReturn;
    
            
    switch(Version) {
    case PCI_PME_INTRF_STANDARD_VER:
        standard->GetPmeInformation  = PciPmeGetInformation;
        standard->ClearPmeStatus     = PciPmeClearPmeStatus;
        standard->UpdateEnable       = PciPmeUpdateEnable;
        break;
    default:
        return STATUS_NOINTERFACE;
    }

    standard->Size                  = sizeof( PCI_PME_INTERFACE );
    standard->Version               = Version;
    standard->Context               = DeviceExtension;
    standard->InterfaceReference    = PciPmeInterfaceReference;
    standard->InterfaceDereference  = PciPmeInterfaceDereference;
    return STATUS_SUCCESS;
}

VOID
PciPmeInterfaceDereference(
    IN PVOID Context
    )
{
    
    
    return;
}

NTSTATUS
PciPmeInterfaceInitializer(
    IN PPCI_ARBITER_INSTANCE Instance
    )
/*++

Routine Description:

    For bus interface, does nothing, shouldn't actually be called.

Arguments:

    Instance        Pointer to the PDO extension.

Return Value:

    Returns the status of this operation.

--*/

{
    
    PCI_ASSERTMSG("PCI PciPmeInterfaceInitializer, unexpected call.", 0);
    return STATUS_UNSUCCESSFUL;
}

VOID
PciPmeInterfaceReference(
    IN PVOID Context
    )
{
    
    return;
}

VOID
PciPmeUpdateEnable(
    IN  PDEVICE_OBJECT   Pdo,
    IN  BOOLEAN          PmeEnable
    )
/*++

Routine Description:

    This routine sets or clears the PME Enable bit on the specified
    device object

Arguments:

    Pdo         - The device object whose PME enable we care about
    PmeEnable   - Wether or not we should enable PME on the device

Return Value:

    None

--*/
{
    PPCI_PDO_EXTENSION  pdoExtension    = (PPCI_PDO_EXTENSION) Pdo->DeviceExtension;

    ASSERT_PCI_PDO_EXTENSION( pdoExtension );

    //
    // Mark the device as not having its PME managed by PCI any more...
    //
    pdoExtension->NoTouchPmeEnable = 1;

    //
    // Call the interface that does the real work. Note that we always need
    // to supply the 3rd argument as FALSE --- we don't to just clear the
    // PME Status bit
    //
    PciPmeAdjustPmeEnable( pdoExtension, PmeEnable, FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\tr_comn.c ===
/*++                                       

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    tr_comn.c

Abstract:

    This module provides the routines which are common to all the translators
    
Author:

    Andrew Thornton (andrewth)  21-May-1997

Revision History:

--*/


#include "pcip.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, PciReferenceTranslator)
#pragma alloc_text(PAGE, PciDereferenceTranslator)

#endif

VOID
PciReferenceTranslator(
    IN PVOID Context
    )
{
    PAGED_CODE();
}

VOID
PciDereferenceTranslator(
    IN PVOID Context
    )
{
    PAGED_CODE();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\ppbridge.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    ppbridge.c

Abstract:

    This module contains functions associated with enumerating
    PCI to PCI bridges.

Author:

    Peter Johnston (peterj) 12-Feb-1997

Revision History:

--*/

#include "pcip.h"

BOOLEAN
PciBridgeIsPositiveDecode(
    IN PPCI_PDO_EXTENSION Pdo
    );

BOOLEAN
PciBridgeIsSubtractiveDecode(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

ULONG
PciBridgeIoBase(
    IN  PPCI_COMMON_CONFIG  Config
    );

ULONG
PciBridgeIoLimit(
    IN  PPCI_COMMON_CONFIG  Config
    );

ULONG
PciBridgeMemoryBase(
    IN  PPCI_COMMON_CONFIG  Config
    );

ULONG
PciBridgeMemoryLimit(
    IN  PPCI_COMMON_CONFIG  Config
    );

PHYSICAL_ADDRESS
PciBridgePrefetchMemoryBase(
    IN  PPCI_COMMON_CONFIG  Config
    );

PHYSICAL_ADDRESS
PciBridgePrefetchMemoryLimit(
    IN  PPCI_COMMON_CONFIG  Config
    );


#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, PciBridgeIoBase)
#pragma alloc_text(PAGE, PciBridgeIoLimit)
#pragma alloc_text(PAGE, PciBridgeMemoryBase)
#pragma alloc_text(PAGE, PciBridgeMemoryLimit)
#pragma alloc_text(PAGE, PciBridgePrefetchMemoryBase)
#pragma alloc_text(PAGE, PciBridgePrefetchMemoryLimit)
#pragma alloc_text(PAGE, PPBridge_MassageHeaderForLimitsDetermination)
#pragma alloc_text(PAGE, PPBridge_SaveLimits)
#pragma alloc_text(PAGE, PPBridge_SaveCurrentSettings)
#pragma alloc_text(PAGE, PPBridge_GetAdditionalResourceDescriptors)
#pragma alloc_text(PAGE, PciBridgeIsPositiveDecode)

#endif

ULONG
PciBridgeIoBase(
    IN  PPCI_COMMON_CONFIG  Config
    )

/*++

Routine Description:

    Compute the 32 bit base IO address being passed by the bridge
    whose config space is at Config.

    The IO base address is always 4KB aligned.  If only 64KB IO
    address space is supported, this is represented in the upper
    nibble of Config->u.type1.IOBase giving the range 0 to 0xf000
    for the base address.  The low nibble of Config->u.type1.IOBase
    contains flags.  If the least significant bit is set, then the
    bridge supports IO addressing to 4GB and Config->u.type1.IOBaseUpper16
    contains the upper 16 bits of the base address.

Arguments:

    Config - Pointer to a buffer containing the device's common (type1)
    configuration header.

Return Value:

    ULONG containing the IO Base address.

--*/

{
    BOOLEAN io32Bit = (Config->u.type1.IOBase & 0x0f) == 1;
    ULONG   base    = (Config->u.type1.IOBase & 0xf0) << 8;

    PCI_ASSERT(PciGetConfigurationType(Config) == PCI_BRIDGE_TYPE);

    if (io32Bit) {
        base |= Config->u.type1.IOBaseUpper16 << 16;

        //
        // Check h/w (base and limit must be the same bit width).
        //

        PCI_ASSERT(Config->u.type1.IOLimit & 0x1);
    }
    return base;
}

ULONG
PciBridgeIoLimit(
    IN  PPCI_COMMON_CONFIG  Config
    )

/*++

Routine Description:

    Compute the 32 bit IO address limit being passed by the bridge
    whose config space is at Config.

    The range of IO addresses being passed is always a multiple of 4KB
    therefore the least significant 12 bits of the address limit are
    always 0xfff.  The upper nibble of Config->u.type1.IOLimit provides
    the next significant 4 bits.  The lower nibble of this byte contains
    flags.  If the least significant bit is set, the bridge is capable of
    passing 32 bit IO addresses and the next 16 significant bits are
    obtained from Config->u.type1.IOLimitUpper16.

Arguments:

    Config - Pointer to a buffer containing the device's common (type1)
    configuration header.

Return Value:

    ULONG containing the IO address limit.

--*/

{
    BOOLEAN io32Bit = (Config->u.type1.IOLimit & 0x0f) == 1;
    ULONG   limit   = (Config->u.type1.IOLimit & 0xf0) << 8;

    PCI_ASSERT(PciGetConfigurationType(Config) == PCI_BRIDGE_TYPE);

    if (io32Bit) {
        limit |= Config->u.type1.IOLimitUpper16 << 16;

        //
        // Check h/w (base and limit must be the same bit width).
        //

        PCI_ASSERT(Config->u.type1.IOBase & 0x1);
    }
    return limit | 0xfff;
}

ULONG
PciBridgeMemoryBase(
    IN  PPCI_COMMON_CONFIG  Config
    )

/*++

Routine Description:

    Compute the 32 bit base Memory address being passed by the bridge
    whose config space is at Config.

    The Memory base address is always 1MB aligned.

Arguments:

    Config - Pointer to a buffer containing the device's common (type1)
    configuration header.

Return Value:

    ULONG containing the Memory Base address.

--*/

{
    PCI_ASSERT(PciGetConfigurationType(Config) == PCI_BRIDGE_TYPE);

    //
    // The upper 12 bits of the memory base address are contained in
    // the upper 12 bits of the USHORT Config->u.type1.MemoryBase.
    //

    return Config->u.type1.MemoryBase << 16;
}

ULONG
PciBridgeMemoryLimit(
    IN  PPCI_COMMON_CONFIG  Config
    )

/*++

Routine Description:

    Compute the 32 bit Memory address limit being passed by the bridge
    whose config space is at Config.

    The memory limit is always at the byte preceeding a 1MB boundary.
    The upper 12 bits of the limit address are contained in the upper
    12 bits of Config->u.type1.MemoryLimit, the lower 20 bits are all
    ones.

Arguments:

    Config - Pointer to a buffer containing the device's common (type1)
    configuration header.

Return Value:

    ULONG containing the Memory limit.

--*/

{
    PCI_ASSERT(PciGetConfigurationType(Config) == PCI_BRIDGE_TYPE);

    return (Config->u.type1.MemoryLimit << 16) | 0xfffff;
}

PHYSICAL_ADDRESS
PciBridgePrefetchMemoryBase(
    IN  PPCI_COMMON_CONFIG  Config
    )

/*++

Routine Description:

    Compute the 64 bit base Prefetchable Memory address being passed
    by the bridge whose config space is at Config.

    The Prefetchable Memory base address is always 1MB aligned.

Arguments:

    Config - Pointer to a buffer containing the device's common (type1)
    configuration header.

Return Value:

    PHYSICAL_ADDRESS containing the Prefetchable Memory Base address.

--*/

{
    BOOLEAN          prefetch64Bit;
    PHYSICAL_ADDRESS base;

    PCI_ASSERT(PciGetConfigurationType(Config) == PCI_BRIDGE_TYPE);

    prefetch64Bit = (BOOLEAN)((Config->u.type1.PrefetchBase & 0x000f) == 1);

    base.QuadPart = 0;

    base.LowPart = (Config->u.type1.PrefetchBase & 0xfff0) << 16;

    if (prefetch64Bit) {
        base.HighPart = Config->u.type1.PrefetchBaseUpper32;
    }

    return base;
}

PHYSICAL_ADDRESS
PciBridgePrefetchMemoryLimit(
    IN  PPCI_COMMON_CONFIG  Config
    )

/*++

Routine Description:

    Compute the 64 bit Prefetchable Memory address limit being passed
    by the bridge whose config space is at Config.

    The prefetchable memory limit is always at the byte preceeding a
    1MB boundary, that is, the least significant 20 bits are all ones.
    The next 12 bits are obtained from the upper 12 bits of
    Config->u.type1.PrefetchLimit.  The botton 4 bits of that field
    provide a flag indicating whether the upper 32 bits should be obtained
    from Config->u.type1.PrefetchLimitUpper32 or should be 0.

Arguments:

    Config - Pointer to a buffer containing the device's common (type1)
    configuration header.

Return Value:

    PHYSICAL_ADDRESS containing the prefetchable memory limit.

--*/

{
    BOOLEAN          prefetch64Bit;
    PHYSICAL_ADDRESS limit;

    PCI_ASSERT(PciGetConfigurationType(Config) == PCI_BRIDGE_TYPE);

    prefetch64Bit = (BOOLEAN)((Config->u.type1.PrefetchLimit & 0x000f) == 1);

    limit.LowPart = (Config->u.type1.PrefetchLimit & 0xfff0) << 16;
    limit.LowPart |= 0xfffff;

    if (prefetch64Bit) {
        limit.HighPart = Config->u.type1.PrefetchLimitUpper32;
    } else {
        limit.HighPart = 0;
    }

    return limit;
}

ULONG
PciBridgeMemoryWorstCaseAlignment(
    IN ULONG Length
    )
/*

Description:

    This function calculates the maximum alignment a device can have if it is
    behind a bridge with a memory window of Length.  This turns out to be finding
    the top bit set in the length.

Arguments:

    Length - the size of the memory window

Return Value:

    The alignment

*/
{
    ULONG alignment = 0x80000000;

    if (Length == 0) {
        PCI_ASSERT(Length != 0);
        return 0;
    }

    while (!(Length & alignment)) {
        alignment >>= 1;
    }

    return alignment;
}

VOID
PPBridge_MassageHeaderForLimitsDetermination(
    IN IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    The configuration header for a PCI to PCI bridge has two BARs
    and three range descriptors (IO, Memory and Prefetchable Memory).

Arguments:

    This    - Pointer to a PCI driver "configurable" object.  This
              object contains configuration data for the function
              currently being configured.

Return Value:

    Returns status indicating the success or failure of this routine.

    The Working configuration has been modified so that all range
    fields have been set to their maximum possible values.

    The Current configuration has been modified such that writing it
    to the hardware will restore the hardware to it's current (disabled)
    state.

--*/

{
    PUCHAR fStart;
    ULONG  fLength;

    //
    // Set BARs and ranges to all ones in the working copy.  Note
    // that the method used will overwrite some other values that
    // need to be restored before going any further.
    //

    fStart = (PUCHAR)&This->Working->u.type1.BaseAddresses;
    fLength  = FIELD_OFFSET(PCI_COMMON_CONFIG,u.type1.CapabilitiesPtr) -
               FIELD_OFFSET(PCI_COMMON_CONFIG,u.type1.BaseAddresses[0]);

    RtlFillMemory(fStart, fLength, 0xff);

    //
    // Restore Primary/Secondary/Subordinate bus numbers and
    // Secondary Latency from the "Current" copy.  (All four
    // are byte fields in the same ULONG so cheat).
    //

    *(PULONG)&This->Working->u.type1.PrimaryBus =
        *(PULONG)&This->Current->u.type1.PrimaryBus;

    //
    // Set the ROM to its maximum as well,... and disable it.
    //

    This->Working->u.type0.ROMBaseAddress =
        0xffffffff & ~PCI_ROMADDRESS_ENABLED;

    This->PrivateData = This->Current->u.type1.SecondaryStatus;
    This->Current->u.type1.SecondaryStatus = 0;
    This->Working->u.type1.SecondaryStatus = 0;

    return;
}

VOID
PPBridge_RestoreCurrent(
    IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    Restore any type specific fields in the original copy of config
    space.   In the case of PCI-PCI bridges, the secondary status field.

Arguments:

    This    - Pointer to a PCI driver "configurable" object.  This
              object contains configuration data for the function
              currently being configured.

Return Value:

    None.

--*/

{
    This->Current->u.type1.SecondaryStatus = (USHORT)(This->PrivateData);
}

VOID
PPBridge_SaveLimits(
    IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    Fill in the Limit structure with a IO_RESOURCE_REQUIREMENT
    for each implemented BAR.

Arguments:

    This    - Pointer to a PCI driver "configurable" object.  This
              object contains configuration data for the function
              currently being configured.

Return Value:

    None.

--*/

{
    ULONG index;
    PIO_RESOURCE_DESCRIPTOR descriptor;
    PPCI_COMMON_CONFIG working = This->Working;
    PULONG bar = working->u.type1.BaseAddresses;
    PHYSICAL_ADDRESS limit;

    descriptor = This->PdoExtension->Resources->Limit;

    //
    // Create an IO_RESOURCE_DESCRIPTOR for each implemented
    // resource supported by this function.
    //

    for (index = 0; index < PCI_TYPE1_ADDRESSES; index++) {
        if (PciCreateIoDescriptorFromBarLimit(descriptor, bar, FALSE)) {

            //
            // This base address register is 64 bit, skip one.
            //

            PCI_ASSERT((index+1) < PCI_TYPE1_ADDRESSES);

            index++;
            bar++;

            //
            // Null descriptor in place holder.
            //

            descriptor++;
            descriptor->Type = CmResourceTypeNull;
        }
        descriptor++;
        bar++;
    }

    //
    // Check if we support subtractive decode (if we do then clear the VGA and
    // ISA bits as they don't mean anything for subtractive bridges)
    //

    if (PciBridgeIsSubtractiveDecode(This)) {
        This->PdoExtension->Dependent.type1.SubtractiveDecode = TRUE;
        This->PdoExtension->Dependent.type1.VgaBitSet = FALSE;
        This->PdoExtension->Dependent.type1.IsaBitSet = FALSE;
    }

    //
    // Skip the bridge windows for a subtractive bridge
    //

    if (!This->PdoExtension->Dependent.type1.SubtractiveDecode) {

        for (index = PciBridgeIo;
             index < PciBridgeMaxPassThru;
             index++, descriptor++) {

            limit.HighPart = 0;
            descriptor->u.Generic.MinimumAddress.QuadPart = 0;

            switch (index) {
            case PciBridgeIo:

                //
                // Get I/O Limit.
                //
                //

                PCI_ASSERT(working->u.type1.IOLimit != 0);

                //
                // IO Space is implemented by the bridge, calculate
                // the real limit.
                //
                // The IOLimit field is one byte, the upper nibble of
                // which represents the 4096 byte block number of the
                // highest 4096 byte block that can be addressed by
                // this bridge.  The highest addressable byte is 4095
                // bytes higher.
                //

                limit.LowPart = PciBridgeIoLimit(working);

                //
                // The lower nibble is a flag.  The least significant bit
                // indicates that this bridge supports I/O ranges up to
                // 4GB and the other bits are currently reserved.
                //

                PCI_ASSERT((working->u.type1.IOLimit & 0x0e) == 0);

                descriptor->Type = CmResourceTypePort;
                descriptor->Flags = CM_RESOURCE_PORT_IO
                                  | CM_RESOURCE_PORT_POSITIVE_DECODE
                                  | CM_RESOURCE_PORT_WINDOW_DECODE;
                descriptor->u.Generic.Alignment = 0x1000;

                break;

            case PciBridgeMem:

                //
                // Get Memory Limit.  Memory limit is not optional on a bridge.
                // It is a 16 bit field in which only the upper 12 bits are
                // implemented, the lower 4 bits MUST be zero.
                //

                limit.LowPart = PciBridgeMemoryLimit(working);

                PCI_ASSERT((working->u.type1.MemoryLimit & 0xf) == 0);

                descriptor->Type = CmResourceTypeMemory;
                descriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE;
                descriptor->u.Generic.Alignment = 0x100000;

                break;

            case PciBridgePrefetch:

                //
                // Get Prefetchable memory limit.
                //

                if (working->u.type1.PrefetchLimit != 0) {

                    //
                    // Prefetchable memory is implemented by this bridge.
                    //

                    limit = PciBridgePrefetchMemoryLimit(working);

                } else {

                    //
                    // prefetchable memory not implemented on this bridge.
                    //

                    descriptor->Type = CmResourceTypeNull;
                    continue;
                }
                descriptor->Type = CmResourceTypeMemory;
                descriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE |
                                    CM_RESOURCE_MEMORY_PREFETCHABLE;;
                descriptor->u.Generic.Alignment = 0x100000;

                break;

            }
            descriptor->u.Generic.MinimumAddress.QuadPart = 0;
            descriptor->u.Generic.MaximumAddress = limit;

            //
            // Length is meaningless here.
            //

            descriptor->u.Generic.Length = 0;
        }
    }

    //
    // Do the BAR thing for the ROM if its active
    //

    if (!(This->Current->u.type1.ROMBaseAddress & PCI_ROMADDRESS_ENABLED)) {
        return;
    }

    PciCreateIoDescriptorFromBarLimit(descriptor,
                                      &working->u.type1.ROMBaseAddress,
                                      TRUE);
}

VOID
PPBridge_SaveCurrentSettings(
    IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    Fill in the Resource array in the PDO extension with the current
    settings for each implemented BAR.

    Also, fill in the PDO Extension's Dependent structure.

Arguments:

    This    - Pointer to a PCI driver "configurable" object.  This
              object contains configuration data for the function
              currently being configured.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    ULONG index;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptor;
    PPCI_COMMON_CONFIG current;
    ULONG bar;
    PHYSICAL_ADDRESS base;
    PHYSICAL_ADDRESS limit;
    PHYSICAL_ADDRESS length;
    BOOLEAN zeroBaseOk;
    BOOLEAN updateAlignment;
    PCI_COMMON_HEADER biosConfigBuffer;
    PPCI_COMMON_CONFIG biosConfig = (PPCI_COMMON_CONFIG) &biosConfigBuffer;

    partial = This->PdoExtension->Resources->Current;
    ioResourceDescriptor = This->PdoExtension->Resources->Limit;

    //
    // Check if the device has either IO or Memory enabled
    //

    if (This->Command & (PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE)) {

        //
        // It does so use the real current settings
        //

        current = This->Current;

    } else {

        //
        // Check if we have a bios config
        //

        status = PciGetBiosConfig(This->PdoExtension, biosConfig);

        if (NT_SUCCESS(status)) {

            //
            // Ok - this is a bit gross but until multi level/multi arbiter
            // rebalance working this will have to do.  We use the initial bios
            // configuration config space to record the current settings.  The
            // current settings is used for responding to the QUERY_RESOURCES
            // and the QUERY_RESOURCE_REQUIREMENTS.  We want to have the original
            // requirements be reported as the preferred location for this
            // bridge and, more importantly, for the original window sizes to
            // be used. We do not however want to report this as the resources
            // currently being decoded as they arn't but we have already checked
            // that the decodes of the device are off so PciQueryResources will
            // not report these.
            //

            current = biosConfig;

        } else {

            //
            // This is a bridge disabled by the BIOS (or one it didn't see) so
            // minimal requirements are likely...
            //

            current = This->Current;

        }

    }


    //
    // Create an IO_RESOURCE_DESCRIPTOR for each implemented
    // resource supported by this function.
    //

    for (index = 0;
         index < PCI_TYPE1_RANGE_COUNT;
         index++, partial++, ioResourceDescriptor++) {

        partial->Type = ioResourceDescriptor->Type;

        //
        // If this entry is not implemented, no further processing for
        // this partial descriptor.
        //

        if (partial->Type == CmResourceTypeNull) {
            continue;
        }

        partial->Flags = ioResourceDescriptor->Flags;
        partial->ShareDisposition = ioResourceDescriptor->ShareDisposition;
        base.HighPart = 0;

        //
        // Depending on where we are in the 'set' we have to look
        // at the data differently.
        //
        // In a header type 1, there are two BARs, I/O limit and
        // base, Memory limit and base, prefetchable limit and base
        // and a ROM BAR.
        //

        if ((index < PCI_TYPE1_ADDRESSES) ||
            (index == (PCI_TYPE1_RANGE_COUNT-1))) {

            ULONG addressMask;

            //
            // Handle BARs
            //

            if (index < PCI_TYPE1_ADDRESSES) {
                bar = current->u.type1.BaseAddresses[index];

                if ((bar & PCI_ADDRESS_IO_SPACE) != 0) {
                    addressMask = PCI_ADDRESS_IO_ADDRESS_MASK;
                } else {
                    addressMask = PCI_ADDRESS_MEMORY_ADDRESS_MASK;
                    if ((bar & PCI_ADDRESS_MEMORY_TYPE_MASK) == PCI_TYPE_64BIT) {
                        //
                        // 64 bit address, consume next BAR.
                        //

                        base.HighPart = current->u.type1.BaseAddresses[index+1];
                    }
                }
            } else {
                bar = current->u.type1.ROMBaseAddress;
                addressMask = PCI_ADDRESS_ROM_ADDRESS_MASK;
            }
            base.LowPart = bar & addressMask;

            //
            // Copy the length from the limits descriptor.
            //

            partial->u.Generic.Length = ioResourceDescriptor->u.Generic.Length;

        } else {

            //
            // It's one of the base/limit pairs (each a different format).
            //

            limit.HighPart = 0;
            zeroBaseOk = FALSE;
            updateAlignment = FALSE;

            switch (index - PCI_TYPE1_ADDRESSES + PciBridgeIo) {
            case PciBridgeIo:

                //
                // Get I/O range.
                //
                //

                base.LowPart  = PciBridgeIoBase(current);
                limit.LowPart = PciBridgeIoLimit(current);

                if (base.LowPart == 0) {
                    if (This->Working->u.type1.IOLimit != 0) {

                        //
                        // The bridge's IO IObase and IOlimit are both
                        // zero but the maximum setting of IOlimit is
                        // non-zero.   This means the bridge is decoding
                        // IO addresses 0 thru 0xfff.
                        //

                        zeroBaseOk = TRUE;
                    }
                }
                break;

            case PciBridgeMem:

                //
                // Get Memory range.
                //

                base.LowPart  = PciBridgeMemoryBase(current);
                limit.LowPart = PciBridgeMemoryLimit(current);
                updateAlignment = TRUE;

                break;

            case PciBridgePrefetch:


                PCI_ASSERT(partial->Flags & CM_RESOURCE_MEMORY_PREFETCHABLE);

                //
                // Get Prefetchable memory range.
                //

                base  = PciBridgePrefetchMemoryBase(current);
                limit = PciBridgePrefetchMemoryLimit(current);
                updateAlignment = TRUE;

                break;
            }

            if ((ULONGLONG)base.QuadPart > (ULONGLONG)limit.QuadPart) {

                //
                // This resource is disabled - remove the current setting AND
                // the requirement
                //
                partial->Type = CmResourceTypeNull;
                ioResourceDescriptor->Type = CmResourceTypeNull;
                continue;

            } else if (((base.QuadPart == 0) && (!zeroBaseOk))) {

                //
                // This resource is not currently being bridged.
                //

                partial->Type = CmResourceTypeNull;
                continue;
            }

            length.QuadPart = limit.QuadPart - base.QuadPart + 1;
            PCI_ASSERT(length.HighPart == 0);
            partial->u.Generic.Length = length.LowPart;

            if (updateAlignment) {

                //
                // We don't know what the alignment requirements for the bridge
                // are because that is dependent on the requirements of the
                // childen of the bridge which we haven't enumerated yet, so
                // we use the maximal alignment that a child could have based
                // on the size of the bridge window.  We don't need to do this
                // for IO requirements because the alignment requirements of
                // the bridge are greater than or equal to any child.
                //

                PCI_ASSERT(partial->u.Generic.Length > 0);
                ioResourceDescriptor->u.Generic.Alignment =
                    PciBridgeMemoryWorstCaseAlignment(partial->u.Generic.Length);

            }
        }
        partial->u.Generic.Start = base;
    }

    //
    // Up until this point we might have been using the bios config but we need
    // to know the real current settings for thr bus number registers and the
    // bridge control register so undo the falsification here
    //

    current = This->Current;

    //
    // Save the header specific data in the PDO.
    //

    This->PdoExtension->Dependent.type1.PrimaryBus =
        current->u.type1.PrimaryBus;
    This->PdoExtension->Dependent.type1.SecondaryBus =
        current->u.type1.SecondaryBus;
    This->PdoExtension->Dependent.type1.SubordinateBus =
        current->u.type1.SubordinateBus;


    if (!This->PdoExtension->Dependent.type1.SubtractiveDecode) {

        //
        // If the VGA bit is set in the bridge control register, we
        // will be passing an additional memory range and a bunch of
        // IO ranges, possibly in conflict with the normal ranges.
        //
        // If this is going to be the case, BuildRequirementsList needs
        // to know to allocate a bunch of additional resources.
        //
        // How many?  One Memory range 0xa0000 thru 0xbffff plus IO
        // ranges 3b0 thru 3bb and 3c0 thru 3df AND every 10 bit alias
        // to these in the possible 16 bit IO space.
        //
        // However, it turns out there's this neat flag so we can
        // tell IO that this resource uses 10 bit decode so we only
        // need to build the two IO port resources.
        //

        if (current->u.type1.BridgeControl & PCI_ENABLE_BRIDGE_VGA) {

            This->PdoExtension->AdditionalResourceCount =
                1 + // Device Private
                1 + // Memory
                2;  // Io
            This->PdoExtension->Dependent.type1.VgaBitSet = TRUE;
        }

        This->PdoExtension->Dependent.type1.IsaBitSet = (BOOLEAN)
            (current->u.type1.BridgeControl & PCI_ENABLE_BRIDGE_ISA) != 0;

    } else {

        PCI_ASSERT(!This->PdoExtension->Dependent.type1.VgaBitSet);
        PCI_ASSERT(!This->PdoExtension->Dependent.type1.IsaBitSet);
    }

#if INTEL_ICH_HACKS

    if (PCI_IS_INTEL_ICH(This->PdoExtension)) {
    
        PPCI_FDO_EXTENSION fdo;

        fdo = PCI_PARENT_FDOX(This->PdoExtension);

        fdo->IchHackConfig = ExAllocatePool(NonPagedPool, PCI_COMMON_HDR_LENGTH);
        if (!fdo->IchHackConfig) {
            //
            // Um - we're screwed
            //
            return;
        }

        RtlCopyMemory(fdo->IchHackConfig, This->Current, PCI_COMMON_HDR_LENGTH);

    }

#endif

}

VOID
PPBridge_ChangeResourceSettings(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    )
{
    ULONG index;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
    ULONG bar;
    ULONG lowPart;
    ULONG limit;
    PHYSICAL_ADDRESS bigLimit;
#if DBG
    BOOLEAN has32BitIo = ((CommonConfig->u.type1.IOBase & 0xf) == 1);
#endif


    if (PCI_IS_INTEL_ICH(PdoExtension)) {
        
        //
        // If this is an ICH then copy back how it was configured before. 
        // Yes this is a vile hack.
        //

        PPCI_FDO_EXTENSION fdo = PCI_PARENT_FDOX(PdoExtension);
        
        PCI_ASSERT(!PdoExtension->Resources);

        CommonConfig->u.type1.IOBase = fdo->IchHackConfig->u.type1.IOBase;
        CommonConfig->u.type1.IOLimit = fdo->IchHackConfig->u.type1.IOLimit;
        CommonConfig->u.type1.MemoryBase = fdo->IchHackConfig->u.type1.MemoryBase;
        CommonConfig->u.type1.MemoryLimit = fdo->IchHackConfig->u.type1.MemoryLimit;
        CommonConfig->u.type1.PrefetchBase = fdo->IchHackConfig->u.type1.PrefetchBase;
        CommonConfig->u.type1.PrefetchLimit = fdo->IchHackConfig->u.type1.PrefetchLimit;
        CommonConfig->u.type1.PrefetchBaseUpper32 = fdo->IchHackConfig->u.type1.PrefetchBaseUpper32;
        CommonConfig->u.type1.PrefetchLimitUpper32 = fdo->IchHackConfig->u.type1.PrefetchLimitUpper32;
        CommonConfig->u.type1.IOBaseUpper16 = fdo->IchHackConfig->u.type1.IOBaseUpper16;
        CommonConfig->u.type1.IOLimitUpper16 = fdo->IchHackConfig->u.type1.IOLimitUpper16;
    
    } else {

        //
        // Close the bridge windows and only open them is appropriate resources
        // have been assigned
        //
    
        CommonConfig->u.type1.IOBase = 0xff;
        CommonConfig->u.type1.IOLimit = 0x0;
        CommonConfig->u.type1.MemoryBase = 0xffff;
        CommonConfig->u.type1.MemoryLimit = 0x0;
        CommonConfig->u.type1.PrefetchBase = 0xffff;
        CommonConfig->u.type1.PrefetchLimit = 0x0;
        CommonConfig->u.type1.PrefetchBaseUpper32 = 0;
        CommonConfig->u.type1.PrefetchLimitUpper32 = 0;
        CommonConfig->u.type1.IOBaseUpper16 = 0;
        CommonConfig->u.type1.IOLimitUpper16 = 0;

    }

    if (PdoExtension->Resources) {

        partial = PdoExtension->Resources->Current;

        for (index = 0;
             index < PCI_TYPE1_RANGE_COUNT;
             index++, partial++) {

            //
            // If this entry is not implemented, no further processing for
            // this partial descriptor.
            //

            if (partial->Type == CmResourceTypeNull) {
                continue;
            }

            lowPart = partial->u.Generic.Start.LowPart;

            //
            // Depending on where we are in the 'set' we have to look
            // at the data differently.
            //
            // In a header type 1, there are two BARs, I/O limit and
            // base, Memory limit and base, prefetchable limit and base
            // and a ROM BAR.
            //

            if ((index < PCI_TYPE1_ADDRESSES) ||
                (index == (PCI_TYPE1_RANGE_COUNT-1))) {

                //
                // Handle BARs
                //
                if (index < PCI_TYPE1_ADDRESSES) {
                    bar = CommonConfig->u.type1.BaseAddresses[index];

                    if (partial->Type == CmResourceTypeMemory){
                    
                        if ((bar & PCI_ADDRESS_MEMORY_TYPE_MASK) == PCI_TYPE_64BIT) {

                            //
                            // 64 bit address, set upper 32 bits in next bar.
                            //
                            PCI_ASSERT(index == 0);
                            PCI_ASSERT((partial+1)->Type == CmResourceTypeNull);
    
                            CommonConfig->u.type1.BaseAddresses[1] =
                                partial->u.Generic.Start.HighPart;
#if DBG

                        } else if ((bar & PCI_ADDRESS_MEMORY_TYPE_MASK) == PCI_TYPE_20BIT) {

                            //
                            // This device must locate below 1MB, make sure we're
                            // configuring it that way.
                            //
    
                            PCI_ASSERT((lowPart & 0xfff00000) == 0);
#endif
                        }
                        
                    }

                    CommonConfig->u.type1.BaseAddresses[index] = lowPart;

                } else {

                    PCI_ASSERT(partial->Type == CmResourceTypeMemory);

                    bar = CommonConfig->u.type1.ROMBaseAddress;
                    bar &= ~PCI_ADDRESS_ROM_ADDRESS_MASK;
                    bar |= (lowPart & PCI_ADDRESS_ROM_ADDRESS_MASK);
                    CommonConfig->u.type0.ROMBaseAddress = bar;
                }

            } else {

                //
                // It's one of the base/limit pairs (each a different format).
                //

                limit = lowPart - 1 + partial->u.Generic.Length;

                switch (index - PCI_TYPE1_ADDRESSES + PciBridgeIo) {
                case PciBridgeIo:

                    //
                    // Set I/O range.
                    //
                    //

#if DBG

                    PCI_ASSERT(((lowPart & 0xfff) == 0) && ((limit & 0xfff) == 0xfff));

                    if (!has32BitIo) {
                        PCI_ASSERT(((lowPart | limit) & 0xffff0000) == 0);
                    }

#endif

                    CommonConfig->u.type1.IOBaseUpper16  = (USHORT)(lowPart >> 16);
                    CommonConfig->u.type1.IOLimitUpper16 = (USHORT)(limit   >> 16);

                    CommonConfig->u.type1.IOBase  = (UCHAR)((lowPart >> 8) & 0xf0);
                    CommonConfig->u.type1.IOLimit = (UCHAR)((limit   >> 8) & 0xf0);
                    break;

                case PciBridgeMem:

                    //
                    // Set Memory range.
                    //

                    PCI_ASSERT(((lowPart & 0xfffff) == 0) &&
                           ((limit & 0xfffff) == 0xfffff));

                    CommonConfig->u.type1.MemoryBase = (USHORT)(lowPart >> 16);
                    CommonConfig->u.type1.MemoryLimit =
                        (USHORT)((limit >> 16) & 0xfff0);
                    break;

                case PciBridgePrefetch:

                    //
                    // Set Prefetchable memory range.
                    //

                    bigLimit.QuadPart = partial->u.Generic.Start.QuadPart - 1 +
                                        partial->u.Generic.Length;

                    PCI_ASSERT(((lowPart & 0xfffff) == 0) &&
                            (bigLimit.LowPart & 0xfffff) == 0xfffff);

                    CommonConfig->u.type1.PrefetchBase = (USHORT)(lowPart >> 16);
                    CommonConfig->u.type1.PrefetchLimit =
                        (USHORT)((bigLimit.LowPart >> 16) & 0xfff0);

                    CommonConfig->u.type1.PrefetchBaseUpper32 =
                        partial->u.Generic.Start.HighPart;

                    CommonConfig->u.type1.PrefetchLimitUpper32 = bigLimit.HighPart;
                    break;
                }
            }
        }
    }

    //
    // Restore the bridge's PCI bus #'s
    //

    CommonConfig->u.type1.PrimaryBus =
        PdoExtension->Dependent.type1.PrimaryBus;
    CommonConfig->u.type1.SecondaryBus =
        PdoExtension->Dependent.type1.SecondaryBus;
    CommonConfig->u.type1.SubordinateBus =
        PdoExtension->Dependent.type1.SubordinateBus;

    //
    // Set the bridge control register bits we might have changes
    //

    if (PdoExtension->Dependent.type1.IsaBitSet) {
        CommonConfig->u.type1.BridgeControl |= PCI_ENABLE_BRIDGE_ISA;
    }

    if (PdoExtension->Dependent.type1.VgaBitSet) {
        CommonConfig->u.type1.BridgeControl |= PCI_ENABLE_BRIDGE_VGA;
    }

}

VOID
PPBridge_GetAdditionalResourceDescriptors(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig,
    IN PIO_RESOURCE_DESCRIPTOR Resource
    )
{
    
    //
    // If this bridge is has the ISA or VGA bits set in its Bridge
    // Control Register, or is doing subtractive decoding, now would
    // be a good time to add the descriptors.
    //

#define SET_RESOURCE(type, minimum, maximum, flags)             \
                                                                \
        Resource->Type = type;                                  \
        Resource->Flags = flags;                                \
        Resource->u.Generic.Length = (maximum) - (minimum) + 1; \
        Resource->u.Generic.Alignment = 1;                      \
        Resource->u.Generic.MinimumAddress.QuadPart = minimum;  \
        Resource->u.Generic.MaximumAddress.QuadPart = maximum;  \
        Resource++;

    if (CommonConfig->u.type1.BridgeControl & PCI_ENABLE_BRIDGE_VGA) {

        //
        // Add VGA ranges.
        //
        // These are memory from 0xA0000 thru 0xBFFFF, and IO ranges
        // 3b0 thru 3bb and 3c0 thru 3df.   These will be passed
        // regardless of the memory and IO range settings but IS
        // controlled by the Memory and IO command register bits.
        //
        // Note: It's also going to do any 10 bit alias to the two
        // IO ranges.
        //
        // First, indicate that the rest of the list is not for
        // generic processing.
        //

        Resource->Type = CmResourceTypeDevicePrivate;
        Resource->u.DevicePrivate.Data[0] = PciPrivateSkipList;
        Resource->u.DevicePrivate.Data[1] = 3; // count to skip
        Resource++;

        //
        // Set the memory descriptor.
        //

        SET_RESOURCE(CmResourceTypeMemory, 0xa0000, 0xbffff, 0);

        //
        // Do the two IO ranges AND their aliases positive decode.
        //

        SET_RESOURCE(CmResourceTypePort,
                     0x3b0,
                     0x3bb,
                     CM_RESOURCE_PORT_10_BIT_DECODE | CM_RESOURCE_PORT_POSITIVE_DECODE);
        SET_RESOURCE(CmResourceTypePort,
                     0x3c0,
                     0x3df,
                     CM_RESOURCE_PORT_10_BIT_DECODE | CM_RESOURCE_PORT_POSITIVE_DECODE);
    }
    return;

#undef SET_RESOURCE

}

NTSTATUS
PPBridge_ResetDevice(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    )
{
    USHORT  bridgeControl;

    //
    // Only reset if device is not enabled and a reset is necessary
    //

    if (CommonConfig->Command == 0 && (PdoExtension->HackFlags & PCI_HACK_RESET_BRIDGE_ON_POWERUP)) {

        //
        // We should never have powered down a device on the debug path so we should
        // never have to reset it on the way back up... but you never know!
        //

        PCI_ASSERT(!PdoExtension->OnDebugPath);

        PciReadDeviceConfig(
            PdoExtension,
            &bridgeControl,
            FIELD_OFFSET(PCI_COMMON_CONFIG, u.type1.BridgeControl),
            sizeof(bridgeControl)
            );

        bridgeControl |= PCI_ASSERT_BRIDGE_RESET;

        PciWriteDeviceConfig(
            PdoExtension,
            &bridgeControl,
            FIELD_OFFSET(PCI_COMMON_CONFIG, u.type1.BridgeControl),
            sizeof(bridgeControl)
            );

        //
        // Per PCI 2.1, reset must remain asserted for a minimum
        // of 100 us.
        //

        KeStallExecutionProcessor(100);

        bridgeControl &= ~PCI_ASSERT_BRIDGE_RESET;

        PciWriteDeviceConfig(
            PdoExtension,
            &bridgeControl,
            FIELD_OFFSET(PCI_COMMON_CONFIG, u.type1.BridgeControl),
            sizeof(bridgeControl)
            );
    }

    return STATUS_SUCCESS;
}

BOOLEAN
PciBridgeIsSubtractiveDecode(
    IN PPCI_CONFIGURABLE_OBJECT This
    )
{

    PCI_ASSERT(This->Current->BaseClass == 0x6 && This->Current->SubClass == 0x4);

    //
    // Bridges are subtractive if their programming interface of 0x1 or we
    // have the appropriate hack flag set.
    //
    // They are also subtractive if the IO Limit register isn't sticky (we tried
    // to write 0xFF to it (see MassageHeader) but the top nibble which is meant
    // to be sticky did't stick).
    //
    // By tradition (NT4/Win9x) this means that the bridge performs subtractive
    // decode of both memory and IO.Unfortunatly the PCI spec says that IO in
    // bridges is optional and so if anyone builds a bridge that doesn't do IO
    // then we will think they have subtractive IO.  One might think that the
    // non-optional memory limit register would have been a better choice but
    // seeing as this is how it works so lets be consistent.
    //

    if (!((This->PdoExtension->HackFlags & PCI_HACK_SUBTRACTIVE_DECODE)
           || (This->Current->ProgIf == 0x1)
           || ((This->Working->u.type1.IOLimit & 0xf0) != 0xf0))) {

        //
        // This is a positive decode bridge
        //
        return FALSE;
    }

    //
    // Intel built a device that claims to be a PCI-PCI bridge - it is actually
    // a hublink-PCI bridge.  It operates like a PCI-PCI bridge only that it
    // subtractively decodes all unclaimed cycles not in the bridge window.
    // Yes so it is positive and subtractive at the same time - we can support
    // this in a later release using partial arbitration but its too late for
    // that now.  It would be nice is we could detect such bridges - perhaps
    // with a Programming Interface of 2.
    //
    // We are giving the OEM a choice - they can have a positive window and
    // operate just like a normal PCI-PCI bridge (and thus can use peer-peer
    // trafic) OR they cah operate like a subtractive PCI-PCI bridge (so ISA
    // like devices (eg PCMCIA, PCI Sound Cards) work but peer-peer doesn't)).
    //
    // Given that most machines will want the subtractive mode, we default to
    // that using the hack table (and this code relies on the correct entries
    // being in said table).  If the OEM wants to enfore positive decode
    // they add an ACPI control method under the parent of the bridge.  This
    // method is a package that enumerates to a list of _ADR style slot numbers
    // for each the bridge we should treat as a vanila PCI-PCI bridge.
    //
    // Note this is only tried for the hublink bridges we know about.
    //

    if (This->PdoExtension->VendorId == 0x8086
    &&  (This->PdoExtension->DeviceId == 0x2418
        || This->PdoExtension->DeviceId == 0x2428
        || This->PdoExtension->DeviceId == 0x244E
        || This->PdoExtension->DeviceId == 0x2448)
        ) {

        //
        // Run the PDEC method if its present
        //

        if (PciBridgeIsPositiveDecode(This->PdoExtension)) {

            PciDebugPrint(
                PciDbgInformative,
                "Putting bridge in positive decode because of PDEC\n"
            );

            return FALSE;

        }
    }

    PciDebugPrint(
        PciDbgInformative,
        "PCI : Subtractive decode on Bus 0x%x\n",
        This->Current->u.type1.SecondaryBus
        );

    //
    // Force us to update the hardware and thus close the windows if necessary.
    //

    This->PdoExtension->UpdateHardware = TRUE;

    return TRUE;

}

BOOLEAN
PciBridgeIsPositiveDecode(
    IN PPCI_PDO_EXTENSION Pdo
    )
/*++

Description:

    Determines if a PCI-PCI bridge device performs positive decode even though
    it says subtractive (either ProfIf=1 or from a hack flag).  This is currently
    only the Intel ICH.

Arguments:

    Pdo - The PDO extension for the bridge

Return Value:

    TRUE - the bridge performs positive decode, FASLE it does not

--*/
{
    return PciIsSlotPresentInParentMethod(Pdo, (ULONG)'CEDP');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\usage.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module contains dispatch code for PCI.SYS.

Author:

    Ken Reneris (kenr) 4-Dec-1997

Revision History:

--*/

#include "pcip.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PciLocalDeviceUsage)
#pragma alloc_text(PAGE, PciPdoDeviceUsage)
#endif


NTSTATUS
PciLocalDeviceUsage (
    IN PPCI_POWER_STATE     PowerState,
    IN PIRP                 Irp
    )
{
    PIO_STACK_LOCATION  irpSp;
    PLONG               Addend;
    LONG                Increment;
    LONG                Junk;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    Increment = irpSp->Parameters.UsageNotification.InPath  ? 1 : -1;
    switch (irpSp->Parameters.UsageNotification.Type) {
        case DeviceUsageTypePaging:         Addend = &PowerState->Paging;      break;
        case DeviceUsageTypeHibernation:    Addend = &PowerState->Hibernate;   break;
        case DeviceUsageTypeDumpFile:       Addend = &PowerState->CrashDump;   break;
        default:
            return STATUS_NOT_SUPPORTED;
    }

    Junk = InterlockedExchangeAdd (Addend, Increment);

#if DBG

    if (Increment == -1) {
        PCI_ASSERT(Junk > 0);
    }

#endif

    return STATUS_SUCCESS;
}

NTSTATUS
PciPdoDeviceUsage (
    IN PPCI_PDO_EXTENSION   pdoExtension,
    IN PIRP             Irp
    )
{
    PDEVICE_OBJECT      ParentFdo;
    PIO_STACK_LOCATION  IrpSp;
    PIO_STACK_LOCATION  NewIrpSp;
    PIRP                NewIrp;
    KEVENT              Event;
    NTSTATUS            Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK     LocalIoStatus;

    PAGED_CODE();

    //
    // Do we have a parent that we must notify?
    //
    if (pdoExtension->ParentFdoExtension != NULL &&
        pdoExtension->ParentFdoExtension->PhysicalDeviceObject != NULL) {

        //
        // Get a referenced object to the parent
        //
        ParentFdo = IoGetAttachedDeviceReference(
            pdoExtension->ParentFdoExtension->PhysicalDeviceObject
            );
        if (ParentFdo == NULL) {

            Status = STATUS_NO_SUCH_DEVICE;
            goto PciPdoDeviceUsageExit;

        }

        //
        // Initialize the event to wait on
        //
        KeInitializeEvent( &Event, SynchronizationEvent, FALSE );

        //
        // Build an Irp
        //
        NewIrp = IoBuildSynchronousFsdRequest(
            IRP_MJ_PNP,
            ParentFdo,
            NULL,
            0,
            NULL,
            &Event,
            &LocalIoStatus
            );
        if (NewIrp == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            ObDereferenceObject( ParentFdo );
            goto PciPdoDeviceUsageExit;

        }

        //
        // Get the top of the stacks
        //
        NewIrpSp = IoGetNextIrpStackLocation( NewIrp );
        IrpSp = IoGetCurrentIrpStackLocation(Irp);

        //
        // Set the top of stack
        //
        *NewIrpSp = *IrpSp;

        //
        // Clear any completion routines from the new stack
        //
        IoSetCompletionRoutine(
            NewIrp,
            NULL,
            NULL,
            FALSE,
            FALSE,
            FALSE
            );

        NewIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        //
        // Send the request down
        //
        Status = IoCallDriver( ParentFdo, NewIrp );
        if (Status == STATUS_PENDING) {

            //
            // Wait for the request to be done
            //
            KeWaitForSingleObject(
                &Event,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );
            Status = LocalIoStatus.Status;

        }

        //
        // Deference the target
        //
        ObDereferenceObject( ParentFdo );

    }


PciPdoDeviceUsageExit:

    //
    // If we succeeded, then apply the usages locally
    //
    if (NT_SUCCESS(Status)) {

        //
        // Apply the usage locally
        //

        Status = PciLocalDeviceUsage(&pdoExtension->PowerState, Irp);

    }

    //
    // Done
    //
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\tr_irq.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    tr_irq.c

Abstract:

    This module implements the PCI Interrupt translator.  It should eventually
    go away when all the HALs provide translators.

Author:

    Andrew Thornton (andrewth)  21-May-1997

Revision History:

--*/


#include "pcip.h"

#define TRANIRQ_VERSION     0

//
// Irq translator
//

NTSTATUS
tranirq_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    );

NTSTATUS
tranirq_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    );

NTSTATUS
tranirq_TranslateResource(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
tranirq_TranslateResourceRequirement(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
tranirq_TranslateInterrupt(
    IN PDEVICE_OBJECT Pdo,
    IN PPCI_TRANSLATOR_INSTANCE Translator,
    IN ULONG Vector,
    OUT PULONG TranslatedVector,
    OUT PULONG TranslatedLevel,
    OUT PULONG TranslatedAffinity,
    OUT PULONG UntranslatedVector
    );

#define TR_IRQ_INVALID_VECTOR 0xffffffff

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, tranirq_Initializer)
#pragma alloc_text(PAGE, tranirq_Constructor)
#endif


PCI_INTERFACE TranslatorInterfaceInterrupt = {
    &GUID_TRANSLATOR_INTERFACE_STANDARD,    // InterfaceType
    sizeof(TRANSLATOR_INTERFACE),           // MinSize
    TRANIRQ_VERSION,                        // MinVersion
    TRANIRQ_VERSION,                        // MaxVersion
    PCIIF_FDO,                              // Flags
    0,                                      // ReferenceCount
    PciTrans_Interrupt,                     // Signature
    tranirq_Constructor,                    // Constructor
    tranirq_Initializer                     // Instance Initializer
};

NTSTATUS
tranirq_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    )
{
    
    
    return STATUS_SUCCESS;
}

NTSTATUS
tranirq_Constructor(
    IN PVOID DeviceExtension,
    IN PVOID PciInterface,
    IN PVOID InterfaceSpecificData,
    IN USHORT Version,
    IN USHORT Size,
    IN PINTERFACE InterfaceReturn
    )

/*++

Routine Description:

    Check the InterfaceSpecificData to see if this is the correct
    translator (we already know the required interface is a translator
    from the GUID) and if so, allocate (and reference) a context
    for this interface.

Arguments:

    PciInterface    Pointer to the PciInterface record for this
                    interface type.
    InterfaceSpecificData
                    A ULONG containing the resource type for which
                    arbitration is required.
    InterfaceReturn

Return Value:

    TRUE is this device is not known to cause problems, FALSE
    if the device should be skipped altogether.

--*/

{
    ULONG secondaryBusNumber, parentBusNumber;
    INTERFACE_TYPE parentInterface;
    PPCI_FDO_EXTENSION fdoExt = (PPCI_FDO_EXTENSION)DeviceExtension;
    PPCI_PDO_EXTENSION pdoExt;

                
    //
    // This translator handles interrupts, is that what they want?
    //

    if ((CM_RESOURCE_TYPE)(ULONG_PTR)InterfaceSpecificData != CmResourceTypeInterrupt) {

        PciDebugPrint(
            PciDbgVerbose,
            "PCI - IRQ trans constructor doesn't like %x in InterfaceSpecificData\n",
            InterfaceSpecificData);
        
        //
        // No, it's not us then.
        //

        return STATUS_INVALID_PARAMETER_3;
    }

    PCI_ASSERT(fdoExt->ExtensionType == PciFdoExtensionType);

    //
    // Give the HAL a shot at providing this translator.
    //
    
    if (PCI_IS_ROOT_FDO(fdoExt)) {

        parentInterface = Internal;
        secondaryBusNumber = fdoExt->BaseBus;
        parentBusNumber = 0;

        PciDebugPrint(PciDbgObnoxious, "      Is root FDO\n");

    } else {

        parentInterface = PCIBus;
        secondaryBusNumber = fdoExt->BaseBus;
        
        pdoExt = (PPCI_PDO_EXTENSION)fdoExt->PhysicalDeviceObject->DeviceExtension;
        parentBusNumber = PCI_PARENT_FDOX(pdoExt)->BaseBus;
        
        PciDebugPrint(PciDbgObnoxious, 
                      "      Is bridge FDO, parent bus %x, secondary bus %x\n",
                      parentBusNumber,
                      secondaryBusNumber);

    }
    
    return HalGetInterruptTranslator(parentInterface,
                                     parentBusNumber,
                                     PCIBus,
                                     sizeof(TRANSLATOR_INTERFACE),
                                     TRANIRQ_VERSION,
                                     (PTRANSLATOR_INTERFACE)InterfaceReturn,
                                     &secondaryBusNumber);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\routintf.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    routintf.c

Abstract:

    This module implements the "Pci Interrupt Routing" interfaces supported
    by the PCI driver.

Author:

    Jake Oshins (jakeo)  19-Jul-1997

Revision History:

   Elliot Shmukler (t-ellios) 7-15-1998   Modified the PCI routing interface to support
                                          MSI capable devices.

--*/

#include "pcip.h"

#define MSI_SIMULATE 0

//
// Prototypes for routines exposed only thru the "interface"
// mechanism.
//

NTSTATUS
routeintrf_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    );

NTSTATUS
routeintrf_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    );

VOID
routeintrf_Reference(
    IN PVOID Context
    );

VOID
routeintrf_Dereference(
    IN PVOID Context
    );

NTSTATUS
PciGetInterruptRoutingInfoEx(
    IN  PDEVICE_OBJECT  Pdo,
    OUT ULONG           *Bus,
    OUT ULONG           *PciSlot,
    OUT UCHAR           *InterruptLine,
    OUT UCHAR           *InterruptPin,
    OUT UCHAR           *ClassCode,
    OUT UCHAR           *SubClassCode,
    OUT PDEVICE_OBJECT  *ParentPdo,
    OUT ROUTING_TOKEN   *RoutingToken,
    OUT UCHAR           *Flags
    );

NTSTATUS
PciSetRoutingToken(
    IN  PDEVICE_OBJECT  Pdo,
    IN  PROUTING_TOKEN  RoutingToken
    );

NTSTATUS
PciSetRoutingTokenEx(
    IN  PDEVICE_OBJECT  Pdo,
    IN  PROUTING_TOKEN  RoutingToken
    );

VOID
PciUpdateInterruptLine(
    IN PDEVICE_OBJECT Pdo,
    IN UCHAR Line
    );

NTSTATUS 
PciGetInterruptRoutingInfo(
    IN  PDEVICE_OBJECT  Pdo,
    OUT ULONG           *Bus,
    OUT ULONG           *PciSlot,
    OUT UCHAR           *InterruptLine,
    OUT UCHAR           *InterruptPin,
    OUT UCHAR           *ClassCode,
    OUT UCHAR           *SubClassCode,
    OUT PDEVICE_OBJECT  *ParentPdo,
    OUT ROUTING_TOKEN   *RoutingToken
    );

NTSTATUS
PciSetLegacyDeviceToken(
    IN PDEVICE_OBJECT LegacyDO,
    IN PROUTING_TOKEN RoutingToken
    );

NTSTATUS
PciFindLegacyDevice(
    IN PDEVICE_OBJECT LegacyDO,
    OUT ULONG           *Bus,
    OUT ULONG           *PciSlot,
    OUT UCHAR           *InterruptLine,
    OUT UCHAR           *InterruptPin,
    OUT UCHAR           *ClassCode,
    OUT UCHAR           *SubClassCode,
    OUT PDEVICE_OBJECT  *ParentPdo,
    OUT ROUTING_TOKEN   *RoutingToken
    );

typedef struct {
    PCI_SECONDARY_EXTENSION ExtensionHeader;
    ROUTING_TOKEN RoutingToken;
} ROUTING_EXTENSION, *PROUTING_EXTENSION;

//
// Define the Pci Routing interface "Interface" structure.
//

PCI_INTERFACE PciRoutingInterface = {
    &GUID_INT_ROUTE_INTERFACE_STANDARD,     // InterfaceType
    sizeof(INT_ROUTE_INTERFACE_STANDARD),   // MinSize
    PCI_INT_ROUTE_INTRF_STANDARD_VER,                // MinVersion
    PCI_INT_ROUTE_INTRF_STANDARD_VER,                // MaxVersion
    PCIIF_FDO,                              // Flags
    0,                                      // ReferenceCount
    PciInterface_IntRouteHandler,           // Signature
    routeintrf_Constructor,                 // Constructor
    routeintrf_Initializer                  // Instance Initializer
};

PLEGACY_DEVICE PciLegacyDeviceHead = NULL;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, routeintrf_Constructor)
#pragma alloc_text(PAGE, routeintrf_Initializer)
#pragma alloc_text(PAGE, routeintrf_Reference)
#pragma alloc_text(PAGE, PciGetInterruptRoutingInfo)
#pragma alloc_text(PAGE, PciGetInterruptRoutingInfoEx)
#pragma alloc_text(PAGE, PciSetRoutingToken)
#pragma alloc_text(PAGE, PciSetRoutingTokenEx)
#pragma alloc_text(PAGE, PciFindLegacyDevice)
#pragma alloc_text(PAGE, PciCacheLegacyDeviceRouting)
#pragma alloc_text(PAGE, PciUpdateInterruptLine)
#endif

VOID
routeintrf_Reference(
    IN PVOID Context
    )
{
    
    return;
}

NTSTATUS
routeintrf_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    )

/*++

Routine Description:

    Initialize the BUS_INTERFACE_STANDARD fields.

Arguments:

    PciInterface    Pointer to the PciInterface record for this
                    interface type.
    InterfaceSpecificData

    InterfaceReturn

Return Value:

    Status

--*/

{
    PINT_ROUTE_INTERFACE_STANDARD standard = (PINT_ROUTE_INTERFACE_STANDARD)InterfaceReturn;

                
    switch(Version)
    {
    case PCI_INT_ROUTE_INTRF_STANDARD_VER:
       standard->GetInterruptRouting = PciGetInterruptRoutingInfoEx;
       standard->SetInterruptRoutingToken = PciSetRoutingTokenEx;
       standard->UpdateInterruptLine = PciUpdateInterruptLine;
       break;
    default:
       return STATUS_NOINTERFACE;

    }

    standard->Size = sizeof( INT_ROUTE_INTERFACE_STANDARD );
    standard->Version = Version;
    standard->Context = DeviceExtension;
    standard->InterfaceReference = routeintrf_Reference;
    standard->InterfaceDereference = routeintrf_Reference;


    return STATUS_SUCCESS;
}

NTSTATUS
routeintrf_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    )
/*++

Routine Description:

    For bus interface, does nothing, shouldn't actually be called.

Arguments:

    Instance        Pointer to the PDO extension.

Return Value:

    Returns the status of this operation.

--*/

{       
        
    PCI_ASSERTMSG("PCI routeintrf_Initializer, unexpected call.", 0);

    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
PciGetInterruptRoutingInfo(
    IN  PDEVICE_OBJECT  Pdo,
    OUT ULONG           *Bus,
    OUT ULONG           *PciSlot,
    OUT UCHAR           *InterruptLine,
    OUT UCHAR           *InterruptPin,
    OUT UCHAR           *ClassCode,
    OUT UCHAR           *SubClassCode,
    OUT PDEVICE_OBJECT  *ParentPdo,
    OUT ROUTING_TOKEN   *RoutingToken
)
/*++

Routine Description:

    Each PCI device in the system is connected to some
    interrupt pin.  And in order to figure out which interrupt
    that device may trigger, an IRQ arbiter must have this
    information.  This interface gathers all such information
    for the arbiter.

Arguments:

    Pdo           - Device object that the arbiter needs to inquire about
    Bus           - Number of the PCI bus in question
    PciSlot       - Slot/Function that corresponds to this device
    InterruptLine - Contents of the device's interrupt line register
    InterruptPin  - Contents of the device's interrupt pin register
    ClassCode     - type of device
    SubClassCode  - sub-type of device
    ParentPdo     - PDO of parent PCI bus
    RoutingToken  - blob of data

Return Value:

    STATUS_SUCCESS   - this is a PCI device and all the fields have been filled
    STATUS_NOT_FOUND - to the knowledge of the PCI driver, this is not a PCI device

--*/
{
    PROUTING_EXTENSION RoutingExtension;
    PPCI_PDO_EXTENSION PdoExt = (PPCI_PDO_EXTENSION)Pdo->DeviceExtension;
    NTSTATUS status;

    PCI_ASSERT(Bus);
    PCI_ASSERT(PciSlot);
    PCI_ASSERT(InterruptLine);
    PCI_ASSERT(InterruptPin);
    PCI_ASSERT(ClassCode);
    PCI_ASSERT(SubClassCode);
    PCI_ASSERT(ParentPdo);
    PCI_ASSERT(RoutingToken);

    //
    // Check to see if this is a legacy PCI device that
    // we are tracking.
    //

    status = PciFindLegacyDevice(Pdo,
                                 Bus,
                                 PciSlot,
                                 InterruptLine,
                                 InterruptPin,
                                 ClassCode,
                                 SubClassCode,
                                 ParentPdo,
                                 RoutingToken);

    if (NT_SUCCESS(status)) {
        //
        // If so, the fields have been filled in already.
        //
        return status;
    }

    //
    // Verify that this PDO actually belongs to us.
    //
    if (!PdoExt) {
        return STATUS_NOT_FOUND;
    }

    //
    // Verify that it is actually a PDO.
    //
    if (PdoExt->ExtensionType != PciPdoExtensionType) {
        return STATUS_NOT_FOUND;
    }

    *Bus            = PCI_PARENT_FDOX(PdoExt)->BaseBus;
    *PciSlot        = PdoExt->Slot.u.AsULONG;
    *InterruptLine  = PdoExt->RawInterruptLine;
    *InterruptPin   = PdoExt->InterruptPin;
    *ClassCode      = PdoExt->BaseClass;
    *SubClassCode   = PdoExt->SubClass;
    *ParentPdo      = PCI_PARENT_PDO(PdoExt);

    RoutingExtension = PciFindSecondaryExtension(PdoExt,
                                                 PciInterface_IntRouteHandler);

    if (RoutingExtension) {

        *RoutingToken = RoutingExtension->RoutingToken;

    } else {

        RoutingToken->LinkNode = 0;
        RoutingToken->StaticVector = 0;
        RoutingToken->Flags = 0;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PciGetInterruptRoutingInfoEx(
    IN  PDEVICE_OBJECT  Pdo,
    OUT ULONG           *Bus,
    OUT ULONG           *PciSlot,
    OUT UCHAR           *InterruptLine,
    OUT UCHAR           *InterruptPin,
    OUT UCHAR           *ClassCode,
    OUT UCHAR           *SubClassCode,
    OUT PDEVICE_OBJECT  *ParentPdo,
    OUT ROUTING_TOKEN   *RoutingToken,
    OUT UCHAR           *Flags
    )
/*++

Routine Description:

    Wrapper for PciGetInterruptroutingInfo that sets
    the Flags parameter to indicate MSI-capable PCI devices.

Arguments:

    Mostly, same as PciGetInterruptRoutingInfo.

    Flags receives device-specific flags such as whether the device
    supports MSI.

Return Value:

    Same as PciGetInterruptRoutingInfo.

--*/

{
   NTSTATUS status;

   // Call the real function

   status = PciGetInterruptRoutingInfo(Pdo,
                                       Bus,
                                       PciSlot,
                                       InterruptLine,
                                       InterruptPin,
                                       ClassCode,
                                       SubClassCode,
                                       ParentPdo,
                                       RoutingToken);

   *Flags = 0;


#if MSI_SUPPORTED

   if (NT_SUCCESS(status)

#if !MSI_SIMULATE
       && PdoExt->CapableMSI
#endif
        ) {


      // MSI device?
      *Flags = PCI_MSI_ROUTING;

   }

#endif // MSI_SUPPORTED

   return status;
}



NTSTATUS
PciSetRoutingToken(
    IN  PDEVICE_OBJECT  Pdo,
    IN  PROUTING_TOKEN  RoutingToken
    )
/*++

Routine Description:

    This routine stores a blob of data associated with this
    PCI device.  This job is foisted off on the PCI driver because
    the PCI driver has a one-to-one correspondence between useful
    data structures and PCI devices.

Arguments:

    Pdo          - Device object that the IRQ arbiter is working with

    RoutingToken - Blob of data that the IRQ arbiter wants to associate with
                   the PCI device.

Return Value:

    Returns the status of this operation.

--*/
{
    PROUTING_EXTENSION RoutingExtension;
    PPCI_PDO_EXTENSION PdoExt = (PPCI_PDO_EXTENSION)Pdo->DeviceExtension;
    NTSTATUS status;

    //
    // Check first to see if this is a legacy PCI device.
    //

    status = PciSetLegacyDeviceToken(Pdo, RoutingToken);

    if (NT_SUCCESS(status)) {
        return STATUS_SUCCESS;
    }

    //
    // This isn't in our list of legacy devices.  So it must be
    // a PCI PDO.
    //

#if DBG
    RoutingExtension = PciFindSecondaryExtension(PdoExt,
                                                 PciInterface_IntRouteHandler);

    if (RoutingExtension != NULL) {
        PciDebugPrint(PciDbgPrattling,
                      "PCI:  *** redundant PCI routing extesion being created ***\n"
                      );
    }
    PCI_ASSERT(RoutingExtension == NULL);
#endif

    RoutingExtension = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION,
                                      sizeof(ROUTING_EXTENSION));

    if (!RoutingExtension) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RoutingExtension->RoutingToken = *RoutingToken;

    PciLinkSecondaryExtension(PdoExt,
                              RoutingExtension,
                              PciInterface_IntRouteHandler,
                              NULL);

    return STATUS_SUCCESS;
}

NTSTATUS
PciSetRoutingTokenEx(
    IN  PDEVICE_OBJECT  Pdo,
    IN  PROUTING_TOKEN  RoutingToken
    )
/*++

Routine Description:

    MSI-aware wrapper for PciSetRoutingToken.

    This function will intercept MSI routing tokens (as indicated by
    the PCI_MSI_ROUTING flag) and store the MSI routing information
    in the PDO extension without caching the token in a secondary extension.

    Non-MSI routing tokens will be passed to PciSetRoutingToken.

Arguments:

    Same as PciSetRoutingToken.


Return Value:

    Same as PciSetRoutingToken.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

#if MSI_SUPPORTED
    PPCI_PDO_EXTENSION PdoExt = (PPCI_PDO_EXTENSION)Pdo->DeviceExtension;

    if(

#if !MSI_SIMULATE
        PdoExt->CapableMSI &&
#endif

       (RoutingToken->Flags & PCI_MSI_ROUTING))
    {

       // MSI token

       PciDebugPrint(PciDbgInformative,"PCI: MSI Resources Received for Device %08x\n", Pdo);

#ifdef DBG

       // have we received a new resource assignment?

       if ((PdoExt->MsiInfo.MessageAddress != (ULONG_PTR)RoutingToken->LinkNode)
          || (PdoExt->MsiInfo.MessageData != (USHORT)RoutingToken->StaticVector)) {

          PciDebugPrint(PciDbgPrattling,"PCI: Device %08x will be reprogrammed with Message = %ld @%p\n",
                   Pdo, RoutingToken->StaticVector, RoutingToken->LinkNode);

       }

#endif

       // Store MSI info in PdoExt.

       PdoExt->MsiInfo.MessageAddress = (ULONG_PTR)RoutingToken->LinkNode;
       PdoExt->MsiInfo.MessageData = (USHORT)RoutingToken->StaticVector;
    }
    else

#endif // MSI_SUPPORTED

    {
       // Call the original function on non-MSI tokens.

       status = PciSetRoutingToken(Pdo, RoutingToken);
    }

    return status;
}


//
//  NT 5.0 has to support non-PnP 4.0-style device drivers.  And
//  this driver doesn't create the device objects associated with
//  a PCI device when its driver is 4.0-style.  It does, however
//  get a chance to look at those objects when the driver calls
//  HalAssignSlotResources.  This collection of functions tracks
//  these foreign device objects.
//

NTSTATUS
PciFindLegacyDevice(
    IN PDEVICE_OBJECT LegacyDO,
    OUT ULONG           *Bus,
    OUT ULONG           *PciSlot,
    OUT UCHAR           *InterruptLine,
    OUT UCHAR           *InterruptPin,
    OUT UCHAR           *ClassCode,
    OUT UCHAR           *SubClassCode,
    OUT PDEVICE_OBJECT  *ParentPdo,
    OUT ROUTING_TOKEN   *RoutingToken
    )
/*++

Routine Description:

    This function returns all the routing data for a legacy
    device object.

Arguments:

Return Value:

    Returns the status of this operation.

--*/
{
    PLEGACY_DEVICE  legacyDev = PciLegacyDeviceHead;
    NTSTATUS        status = STATUS_NOT_FOUND;

    PAGED_CODE();

    while (legacyDev) {

        if (legacyDev->LegacyDeviceObject == LegacyDO) {
            
            break;

        } else if (legacyDev->Bus == *Bus && legacyDev->PciSlot == *PciSlot) {
            
            if (legacyDev->LegacyDeviceObject == NULL) {
                
                //
                // Cache the LegacyDO in case we matched on the bus and slot info.
                //

                legacyDev->LegacyDeviceObject = LegacyDO;
                break;

            } else {
                
                PciDebugPrint(PciDbgAlways, "Two PDOs (Legacy = %08x, Pnp = %08x) for device on bus %08x, slot %08x\n", legacyDev->LegacyDeviceObject, LegacyDO, *Bus, *PciSlot);
                PCI_ASSERT(legacyDev->LegacyDeviceObject != NULL);
                legacyDev = NULL;
                break;

            }
        }

        legacyDev = (PLEGACY_DEVICE)legacyDev->List.Next;
    }

    if (legacyDev) {
        
        *Bus            = legacyDev->Bus;
        *PciSlot        = legacyDev->PciSlot;
        *InterruptLine  = legacyDev->InterruptLine;
        *InterruptPin   = legacyDev->InterruptPin;
        *ClassCode      = legacyDev->ClassCode;
        *SubClassCode   = legacyDev->SubClassCode;
        *ParentPdo      = legacyDev->ParentPdo;
        *RoutingToken   = legacyDev->RoutingToken;

        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
PciCacheLegacyDeviceRouting(
    IN PDEVICE_OBJECT LegacyDO,
    IN ULONG          Bus,
    IN ULONG          PciSlot,
    IN UCHAR          InterruptLine,
    IN UCHAR          InterruptPin,
    IN UCHAR          ClassCode,
    IN UCHAR          SubClassCode,
    IN PDEVICE_OBJECT ParentPdo,
    IN PPCI_PDO_EXTENSION PdoExtension,
    OUT PDEVICE_OBJECT      *OldLegacyDO
    )
/*++

Routine Description:

    This function stores all the routing data for a legacy
    device object, except the RoutingToken. Caller needs to acquire 
    PciGlobalLock before calling this function.

Arguments:

Return Value:

    Returns the status of this operation.

--*/
{
    PLEGACY_DEVICE  legacyDev = PciLegacyDeviceHead;

    PAGED_CODE();

    while (legacyDev) {

        if (Bus == legacyDev->Bus && PciSlot == legacyDev->PciSlot) {
            if (legacyDev->LegacyDeviceObject == LegacyDO) {

                //
                // This device is already in the list.
                //

                if (OldLegacyDO) {

                    *OldLegacyDO = LegacyDO;
                }

                return STATUS_SUCCESS;
            } else {

                PDEVICE_OBJECT oldDO;

                //
                // We are overwriting an existing entry.
                //

                oldDO = legacyDev->LegacyDeviceObject;
                legacyDev->LegacyDeviceObject = LegacyDO;

                if (OldLegacyDO) {

                    *OldLegacyDO = oldDO;
                }

                return STATUS_SUCCESS;
            }
        }
        legacyDev = (PLEGACY_DEVICE)legacyDev->List.Next;
    }

    legacyDev = ExAllocatePool(PagedPool,
                               sizeof(LEGACY_DEVICE));

    if (!legacyDev) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(legacyDev, sizeof(LEGACY_DEVICE));

    legacyDev->LegacyDeviceObject   = LegacyDO;
    legacyDev->Bus                  = Bus;
    legacyDev->PciSlot              = PciSlot;
    legacyDev->InterruptLine        = InterruptLine;
    legacyDev->InterruptPin         = InterruptPin;
    legacyDev->ClassCode            = ClassCode;
    legacyDev->SubClassCode         = SubClassCode;
    legacyDev->ParentPdo            = ParentPdo;
    legacyDev->PdoExtension         = PdoExtension;

    //
    // Push this one onto the list.
    //

    legacyDev->List.Next = (PSINGLE_LIST_ENTRY)PciLegacyDeviceHead;
    PciLegacyDeviceHead = legacyDev;

    if (OldLegacyDO) {

        *OldLegacyDO = LegacyDO;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PciSetLegacyDeviceToken(
    IN PDEVICE_OBJECT LegacyDO,
    IN PROUTING_TOKEN RoutingToken
    )
/*++

Routine Description:

    This function stores the RoutingToken.

Arguments:

Return Value:

    Returns the status of this operation.

--*/
{
    PLEGACY_DEVICE  legacyDev = PciLegacyDeviceHead;

    PAGED_CODE();

    while (legacyDev) {

        if (legacyDev->LegacyDeviceObject == LegacyDO) {

            //
            // Found it.  Copy the token into the structure.
            //

            legacyDev->RoutingToken = *RoutingToken;

            return STATUS_SUCCESS;
        }

        legacyDev = (PLEGACY_DEVICE)legacyDev->List.Next;
    }

    return STATUS_NOT_FOUND;
}

VOID
PciUpdateInterruptLine(
    IN PDEVICE_OBJECT Pdo,
    IN UCHAR Line
    )
{
    NTSTATUS status;
    PPCI_PDO_EXTENSION pdoExt = NULL;
    PLEGACY_DEVICE legacyDev = PciLegacyDeviceHead;
    PCI_COMMON_HEADER header;
    PPCI_COMMON_CONFIG biosConfig = (PPCI_COMMON_CONFIG) &header;

    PAGED_CODE();

    //
    // Work out if this is a legacy PDO or not
    //

    while (legacyDev) {

        if (legacyDev->LegacyDeviceObject == Pdo) {

            //
            // Found it.
            //

            pdoExt = legacyDev->PdoExtension;
            break;
        }

        legacyDev = (PLEGACY_DEVICE)legacyDev->List.Next;
    }


    if (pdoExt == NULL) {

        //
        // Oh well it must be a PCI pdo
        //

        pdoExt = Pdo->DeviceExtension;
    }

    ASSERT_PCI_PDO_EXTENSION(pdoExt);

    //
    // Now we can update the hardware and our internal state!
    //

    pdoExt->RawInterruptLine = pdoExt->AdjustedInterruptLine = Line;

    PciWriteDeviceConfig(pdoExt,
                         &Line,
                         FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.InterruptLine),
                         sizeof(Line)
                         );

    //
    // Finally refresh the config space stored in the registry
    //

    status = PciGetBiosConfig(pdoExt, biosConfig);

    PCI_ASSERT(NT_SUCCESS(status));

    if (NT_SUCCESS(status)
    &&  biosConfig->u.type0.InterruptLine != Line) {

        biosConfig->u.type0.InterruptLine = Line;

        status = PciSaveBiosConfig(pdoExt, biosConfig);

        PCI_ASSERT(NT_SUCCESS(status));

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\romimage.c ===
/*++
Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    romimage.c

Abstract:

    This module contains the code required to obtain a copy of a
    device's ROM (Read Only Memory).

    The PCI spec allows a device to share address decoding logic
    between the ROM BAR (Base Address Registers) and other BARs.
    Effectively, this means the ROM cannot be accessed at the same
    time as the device is otherwise operating.

    The ROM is accesible when both the ROM enabled bit is set and
    memory decoding is enabled.

Author:

    Peter Johnston  (peterj)    15-Apr-1998

Revision History:

--*/


#include "pcip.h"

extern pHalTranslateBusAddress PcipSavedTranslateBusAddress;

typedef struct _PCI_ROM_HEADER {
    USHORT  Signature;
    UCHAR   RsvdArchitectureUnique[0x16];
    USHORT  DataStructureOffset;
} PCI_ROM_HEADER, *PPCI_ROM_HEADER;

typedef struct _PCI_DATA_STRUCTURE {
    ULONG   Signature;
    USHORT  VendorId;
    USHORT  DeviceId;
    USHORT  VitalProductDataOffset;
    USHORT  DataStructureLength;
    UCHAR   DataStructureRevision;
    UCHAR   ClassCode[3];
    USHORT  ImageLength;
    USHORT  ImageRevision;
    UCHAR   CodeType;
    UCHAR   Indicator;
    USHORT  Reserved;
} PCI_DATA_STRUCTURE, *PPCI_DATA_STRUCTURE;

typedef struct _PCI_ROM_ACCESS_PARAMETERS {
    PVOID Buffer;
    ULONG Length;
    ULONG OriginalRomAddress;
    ULONG NewRomAddress;
    PUCHAR MappedRomAddress;
    ULONG NewBarAddress;
    ULONG DisplacedBarIndex;
    BOOLEAN AcquiredResources;
    ULONG OriginalStatusCommand;
} PCI_ROM_ACCESS_PARAMETERS, *PPCI_ROM_ACCESS_PARAMETERS;

#define PCI_ROM_HEADER_SIGNATURE            0xaa55
#define PCI_ROM_DATA_STRUCTURE_SIGNATURE    'RICP'  // LE PCIR

//
// Prototypes for local routines.
//

NTSTATUS
PciRomTestWriteAccessToBuffer(
    IN PUCHAR Buffer,
    IN ULONG  Length
    );

VOID
PciTransferRomData(
    IN PVOID    RomAddress,
    IN PVOID    Buffer,
    IN ULONG    Length
    );

VOID
PciAccessRom(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_ROM_ACCESS_PARAMETERS RomAccessParameters
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, PciReadRomImage)
#pragma alloc_text(PAGE, PciRomTestWriteAccessToBuffer)

#endif

VOID
PciTransferRomData(
    IN PVOID    RomAddress,
    IN PVOID    Buffer,
    IN ULONG    Length
    )

/*++

Routine Description:

    Simple abstraction of READ_REGISTER_BUFFER_Uxxxx()

    Copies from ROM to an in memory buffer.   Deals with alignment
    and tries to use the most efficient means.

Arguments:

    RomAddress  Mapped/Translated address to copy from.
    Buffer      Memory address to copy to.
    Length      Number of BYTEs to copy.

Return Value:

    None.

--*/

{
    #define BLKSIZE sizeof(ULONG)
    #define BLKMASK (BLKSIZE - 1)

    ULONG temp;

    if (Length > BLKSIZE) {

        //
        // Optimize for aligned case (typically, both will be perfectly
        // aligned) and a multiple of DWORDs.
        //

        temp = (ULONG)((ULONG_PTR)RomAddress & BLKMASK);
        if (temp == ((ULONG_PTR)Buffer & BLKMASK)) {

            //
            // Same alignment, (note: if not same alignment, we
            // transfer byte by byte).
            //
            // Walk off any leading bytes...
            //

            if (temp != 0) {

                //
                // temp is offset from a dword boundary, get number of
                // bytes to copy.
                //

                temp = BLKSIZE - temp;

                READ_REGISTER_BUFFER_UCHAR(RomAddress, Buffer, temp);

                Length -= temp;
                Buffer = (PVOID)((PUCHAR)Buffer + temp);
                RomAddress = (PVOID)((PUCHAR)RomAddress + temp);
            }

            if (Length > BLKSIZE) {

                //
                // Get as much as possible using DWORDS
                //

                temp = Length / BLKSIZE;

                READ_REGISTER_BUFFER_ULONG(RomAddress, Buffer, temp);

                temp = temp * BLKSIZE;
                Length -= temp;
                Buffer = (PVOID)((PUCHAR)Buffer + temp);
                RomAddress = (PVOID)((PUCHAR)RomAddress + temp);
            }
        }
    }

    //
    // Finish any remaining bytes.
    //

    if (Length) {
        READ_REGISTER_BUFFER_UCHAR(RomAddress, Buffer, Length);
    }

    #undef BLKMASK
    #undef BLKSIZE
}

NTSTATUS
PciRomTestWriteAccessToBuffer(
    IN PUCHAR Buffer,
    IN ULONG  Length
    )

/*++

Routine Description:

    Complete Paranoia.  Make sure we can write every page in the
    caller's buffer (assumes 4096 bytes per page) by writing to
    every page.

    We do this in a try block to avoid killing the system.  The
    hope is to avoid anything that might bugcheck the system while
    we have changed the operating characteristics of the device.

Arguments:

    Buffer      Address of start of buffer.
    Length      Number of bytes in buffer.

Return Value:

    Status.

--*/

{
    PUCHAR endAddress = Buffer + Length - 1;

    try {

        while (Buffer <= endAddress) {
            *Buffer = 0;
            Buffer += 0x1000;
        }
        *endAddress = 0;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }
    return STATUS_SUCCESS;
}

NTSTATUS
PciReadRomImage(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN ULONG WhichSpace,
    OUT PVOID Buffer,
    IN ULONG Offset,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    Copy the device ROM to the caller's Buffer.

Arguments:

    PdoExtension    Device Extension of the device in question.
    WhichSpace      Indicates which part of the ROM image is required.
                    (Currently only the x86 BIOS image is supported,
                    can be expanded to pass back the Open FW image if
                    needed).
    Buffer          Address of the caller's data area.
    Offset          Offset from the start of the ROM image data should
                    be returned from.   Currently not used, can be used
                    in the future to stage data.
    Length          Pointer to a ULONG containing the length of the
                    Buffer (requested length).   The value is modified
                    to the actual data length.


Return Value:

    Status of this operation.

--*/

{
    PIO_RESOURCE_DESCRIPTOR         requirement;
    PIO_RESOURCE_DESCRIPTOR         movedRequirement = NULL;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR resource;
    CM_PARTIAL_RESOURCE_DESCRIPTOR  tempResource;
    BOOLEAN                         acquiredResources = TRUE;
    BOOLEAN                         translated;
    ULONG                           oldStatusCommand;
    ULONG                           newStatusCommand;
    ULONG                           oldRom;
    ULONG                           newRom;
    ULONG                           maximumLength;
    NTSTATUS                        status;
    PHYSICAL_ADDRESS                translatedAddress;
    ULONG                           addressIsIoSpace = 0;
    PVOID                           mapped = NULL;
    PVOID                           romBase;
    PPCI_ARBITER_INSTANCE           pciArbiter;
    PARBITER_INSTANCE               arbiter = NULL;
    PHYSICAL_ADDRESS                movedAddress;
    ULONG                           movedIndex = MAXULONG   ;
    ULONGLONG                       tempResourceStart;
    PCI_CRITICAL_ROUTINE_CONTEXT    criticalContext;
    PCI_ROM_ACCESS_PARAMETERS       romParameters;
    PUCHAR                          doubleBuffer;

    PAGED_CODE();

    PciDebugPrint(
        PciDbgROM,
        "PCI ROM entered for pdox %08x (buffer @ %08x %08x bytes)\n",
        PdoExtension,
        Buffer,
        *Length
        );

    //
    // Currently not very flexible, assert we can do what the
    // caller wants.
    //

    PCI_ASSERT(Offset == 0);
    PCI_ASSERT(WhichSpace == PCI_WHICHSPACE_ROM);

    //
    // Capture the length and set the returned length to 0.  This
    // will be set to the correct value any data is successfully
    // returned.
    //

    maximumLength = *Length;
    *Length = 0;

    //
    // Only do this for header type 0 (ie devices, not bridges,
    // bridges actually can have ROMs,.... I don't know why and
    // currently have no plan to support it).
    //

    if (PdoExtension->HeaderType != PCI_DEVICE_TYPE) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // It's a device, does it use a ROM?
    //

    requirement = &PdoExtension->Resources->Limit[PCI_TYPE0_ADDRESSES];

    if ((PdoExtension->Resources == NULL) ||
        (requirement->Type == CmResourceTypeNull)) {

        return STATUS_SUCCESS;
    }

    //
    // Special case.  If Length == 0 on entry, caller wants to know
    // what the length should be.
    //

    PCI_ASSERT((requirement->u.Generic.Length & 0x1ff) == 0);

    if (maximumLength == 0) {
        *Length = requirement->u.Generic.Length;
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Trim length to device maximum.
    //

    if (requirement->u.Generic.Length < maximumLength) {
        maximumLength = requirement->u.Generic.Length;
    }

    //
    // Paranoia1:  This device is probably video.  If the system
    // bugchecks while we have the device' memory access in limbo,
    // the system will appear to hung.  Reduce the possibility of
    // bugcheck by ensuring we have (write) access to the caller's
    // buffer.
    //

    status = PciRomTestWriteAccessToBuffer(Buffer, maximumLength);

    if (!NT_SUCCESS(status)) {
        PCI_ASSERT(NT_SUCCESS(status));
        return status;
    }

    PCI_ASSERT(requirement->Type == CmResourceTypeMemory);
    PCI_ASSERT(requirement->Flags == CM_RESOURCE_MEMORY_READ_ONLY);

    //
    // Get current settings for the command register and the ROM BAR.
    //

    PciReadDeviceConfig(
        PdoExtension,
        &oldStatusCommand,
        FIELD_OFFSET(PCI_COMMON_CONFIG, Command),
        sizeof(ULONG)
        );

    PciReadDeviceConfig(
        PdoExtension,
        &oldRom,
        FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.ROMBaseAddress),
        sizeof(ULONG)
        );

    //
    // Zero the upper 16 bits of the Status/Command variable so the
    // Status field in h/w is unchanged in subsequent writes.  (Bits
    // in the Status field are cleared by writing ones to them).
    //

    oldStatusCommand &= 0xffff;

    newStatusCommand = oldStatusCommand;
    newRom = oldRom;

    //
    // If access to the ROM is already enabled, and memory is
    // currently enabled, we already have access to the image.
    // (I've never actually seen that condition.  plj).
    // Otherwise, we need to get PnP to allocate the range.
    //


    if (PdoExtension->Resources->Current[PCI_TYPE0_ADDRESSES].Type ==
        CmResourceTypeMemory) {

        PCI_ASSERT(oldRom & PCI_ROMADDRESS_ENABLED);

        if (oldStatusCommand & PCI_ENABLE_MEMORY_SPACE) {

            //
            // No need to acquire resources.
            //

            acquiredResources = FALSE;
        }
    } else {
        PCI_ASSERT(PdoExtension->Resources->Current[PCI_TYPE0_ADDRESSES].Type ==
               CmResourceTypeNull);
    }

    movedAddress.QuadPart = 0;

    //
    // Allocate a memory resource to access the ROM with.
    //

    if (acquiredResources == TRUE) {

        ULONGLONG rangeMin, rangeMax;
        PPCI_PDO_EXTENSION currentPdo, bridgePdo = NULL;



        //
        // Acquire the Arbiter lock for the parent FDO (ie the
        // bridge this device lives under).
        //
        // Attempt to acquire the range needed.   If that fails,
        // attempt to find a memory range the device already has
        // and move it to an invalid range then give the ROM the
        // memory that used to be assigned to that memory window.
        //

        currentPdo = PdoExtension;
        do {

            //
            // Find the PDO of the bridge - NULL for a root bus
            //

            if (PCI_PDO_ON_ROOT(currentPdo)) {

                bridgePdo = NULL;

            } else {

                bridgePdo = PCI_BRIDGE_PDO(PCI_PARENT_FDOX(currentPdo));

            }

            pciArbiter = PciFindSecondaryExtension(PCI_PARENT_FDOX(currentPdo),
                                                   PciArb_Memory);

            if (!pciArbiter) {

                //
                // If this device is on a root bus and the root doesn't have an
                // arbiter something bad happened...
                //

                if (!bridgePdo) {
                    PCI_ASSERT(pciArbiter);
                    return STATUS_UNSUCCESSFUL;
                };

                //
                // We didn't find an arbiter - probably because this is a
                // subtractive decode bridge.
                //


                if (bridgePdo->Dependent.type1.SubtractiveDecode) {

                    //
                    // This is subtractive so we want to find the guy who
                    // arbitrates our resources (so we move on up the tree)
                    //

                    currentPdo = bridgePdo;

                } else {

                    //
                    // We have a non-subtractive bridge without an arbiter -
                    // something is wrong...
                    //

                    PCI_ASSERT(pciArbiter);
                    return STATUS_UNSUCCESSFUL;
                }
            }

        } while (!pciArbiter);


        arbiter = &pciArbiter->CommonInstance;

        ArbAcquireArbiterLock(arbiter);

        //
        // Attempt to get this resource as an additional resource
        // within the ranges supported by this bridge.
        //

        rangeMin = requirement->u.Memory.MinimumAddress.QuadPart;
        rangeMax = requirement->u.Memory.MaximumAddress.QuadPart;

        //
        // If this is a PCI-PCI bridge then restrict this to the
        // non-prefetchable memory.  Currently we don't enable
        // prefetchable memory cardbus so there is nothing to
        // do there.
        //
        // Note: ROM BARs are 32 bit only so limit to low 4GB).
        // Note: Is is not clear that we really need to limit to
        // non-prefetchable memory.
        //

        if (bridgePdo) {

            if (bridgePdo->HeaderType == PCI_BRIDGE_TYPE) {

                //
                // The 3 below is the index of the non-prefetchable
                // memory bar for a PCI-PCI bridge within it's resources
                // current settings.
                //

                resource = &bridgePdo->Resources->Current[3];
                if (resource->Type == CmResourceTypeNull) {

                    //
                    // Bridge isn't passing memory,.... so reading
                    // ROMs isn't really an option.
                    //

                    PciDebugPrint(
                        PciDbgROM,
                        "PCI ROM pdo %p parent %p has no memory aperture.\n",
                        PdoExtension,
                        bridgePdo
                        );
                    ArbReleaseArbiterLock(arbiter);
                    return STATUS_UNSUCCESSFUL;
                }
                PCI_ASSERT(resource->Type == CmResourceTypeMemory);
                rangeMin = resource->u.Memory.Start.QuadPart;
                rangeMax = rangeMin + (resource->u.Memory.Length - 1);
            }
        }

        status = RtlFindRange(
                     arbiter->Allocation,
                     rangeMin,
                     rangeMax,
                     requirement->u.Memory.Length,
                     requirement->u.Memory.Alignment,
                     0,
                     0,
                     NULL,
                     NULL,
                     &tempResourceStart);

        tempResource.u.Memory.Start.QuadPart = tempResourceStart;

        if (!NT_SUCCESS(status)) {

            ULONG i;

            //
            // If this is a cardbus controller then game over as stealing BARS
            // is not something we encourage and is not fatal if we fail.
            //

            if (bridgePdo && bridgePdo->HeaderType == PCI_CARDBUS_BRIDGE_TYPE) {
                ArbReleaseArbiterLock(arbiter);
                return STATUS_UNSUCCESSFUL;
            }

            //
            // We were unable to get enough space on this bus
            // given the existing ranges and resources being
            // consumed.  Run down the list of memory resources
            // already assigned to this device and try to find
            // one which is large enough to cover the ROM and
            // appropriate aligned.   (Note: look for the smallest
            // one meeting these requirements).
            //
            // Note: ROM BARs are only 32 bits so we cannot steal
            // a 64 bit BAR that has been assigned an address > 4GB-1.
            // We could allow the replacement range to be > 4GB-1 if
            // the BAR supports it but I'm not doing this on the first
            // pass. (plj).
            //


            for (i = 0; i < PCI_TYPE0_ADDRESSES; i++) {

                PIO_RESOURCE_DESCRIPTOR l = &PdoExtension->Resources->Limit[i];

                if ((l->Type == CmResourceTypeMemory) &&
                    (l->u.Memory.Length >= requirement->u.Memory.Length) &&
                    (PdoExtension->Resources->Current[i].u.Memory.Start.HighPart == 0)) {
                    if ((!movedRequirement) ||
                        (movedRequirement->u.Memory.Length >
                                    l->u.Memory.Length)) {
                            movedRequirement = l;
                    }
                }
            }

            if (!movedRequirement) {
                PciDebugPrint(
                    PciDbgROM,
                    "PCI ROM pdo %p could not get MEM resource len 0x%x.\n",
                    PdoExtension,
                    requirement->u.Memory.Length
                    );
                ArbReleaseArbiterLock(arbiter);
                return STATUS_UNSUCCESSFUL;
            }

            //
            // Ok, we found a suitable candidate to move.   Let's see
            // if we can find somewhere to put it that's out of the
            // way.   We do this by allowing a conflict with ranges
            // not owned by this bus.  We know the driver isn't
            // using this range at this instant so we can put it
            // somewhere where there's no way to use it then use
            // the space it occupied for the ROM.
            //

            status = RtlFindRange(arbiter->Allocation,
                                  0,
                                  0xffffffff,
                                  movedRequirement->u.Memory.Length,
                                  movedRequirement->u.Memory.Alignment,
                                  RTL_RANGE_LIST_NULL_CONFLICT_OK,
                                  0,
                                  NULL,
                                  NULL,
                                  &movedAddress.QuadPart);
            
            if (!NT_SUCCESS(status)) {

                //
                // We were unable to find somewhere to move the
                // memory aperture to even allowing conflicts with
                // ranges not on this bus.   This can't happen
                // unless the requirement is just plain bogus.
                //

                PciDebugPrint(
                    PciDbgROM,
                    "PCI ROM could find range to disable %x memory window.\n",
                    movedRequirement->u.Memory.Length
                    );
                ArbReleaseArbiterLock(arbiter);
                return STATUS_UNSUCCESSFUL;
            }
            movedIndex = (ULONG)(movedRequirement - PdoExtension->Resources->Limit);
            tempResource = PdoExtension->Resources->Current[movedIndex];
            PciDebugPrint(
                PciDbgROM,
                "PCI ROM Moving existing memory resource from %p to %p\n",
                tempResource.u.Memory.Start.LowPart,
                movedAddress.LowPart);
        }
    } else {

        //
        // The ROM is currently enabled on this device, translate and
        // map the current setting.
        //

        tempResource.u.Generic.Start.LowPart =
            oldRom & PCI_ADDRESS_ROM_ADDRESS_MASK;
    }

    tempResource.Type = CmResourceTypeMemory;
    tempResource.u.Memory.Start.HighPart = 0;
    tempResource.u.Memory.Length = requirement->u.Memory.Length;
    resource = &tempResource;

    //
    // The following need to be done regardless of whether
    // or not we had to go acquire resources.
    //
    // HalTranslateBusAddress
    // MmMapIoSpace
    //
    // Note: HalTranslateBusAddress has been hooked to call back
    // into the PCI driver which will then attempt to acquire the
    // arbiter lock on this bus.  We can't release the lock as we
    // haven't really acquired this resource we're about to use.
    // We could trick PciTranslateBusAddress into not acquiring
    // the lock by calling it at dispatch level, or, we could
    // just call the saved (prehook) HAL function which is what
    // that routine ends up doing anyway.
    //

    PCI_ASSERT(PcipSavedTranslateBusAddress);

    translated = PcipSavedTranslateBusAddress(
                     PCIBus,
                     PCI_PARENT_FDOX(PdoExtension)->BaseBus,
                     resource->u.Generic.Start,
                     &addressIsIoSpace,
                     &translatedAddress
                     );

    //
    // NTRAID #62658 - 3/30/2001 - andrewth
    // If the resource won't translate it may be because the HAL doesn't
    // know about this bus.  Try the translation of the root bus this is 
    // under instead
    //

    if (!translated) {
        
        translated = PcipSavedTranslateBusAddress(
                     PCIBus,
                     PCI_PARENT_FDOX(PdoExtension)->BusRootFdoExtension->BaseBus,
                     resource->u.Generic.Start,
                     &addressIsIoSpace,
                     &translatedAddress
                     );

    }
    
    if (!translated) {
        PciDebugPrint(PciDbgROM,
                      "PCI ROM range at %p FAILED to translate\n",
                      resource->u.Generic.Start.LowPart);
        PCI_ASSERT(translated);
        status = STATUS_UNSUCCESSFUL;
        goto cleanup;
    }

    PciDebugPrint(PciDbgROM,
                  "PCI ROM range at %p translated to %p\n",
                  resource->u.Generic.Start.LowPart,
                  translatedAddress.LowPart);

    if (!addressIsIoSpace) {

        //
        // Translated to memory, map it.
        //

        mapped = MmMapIoSpace(translatedAddress,
                              requirement->u.Generic.Length,
                              MmNonCached);

        if (!mapped) {

            //
            // Failed to get mapping.
            //

            PCI_ASSERT(mapped);
            status = STATUS_UNSUCCESSFUL;
            goto cleanup;
        }

        romBase = mapped;

        PciDebugPrint(
            PciDbgROM,
            "PCI ROM mapped b %08x t %08x to %p length %x bytes\n",
            resource->u.Generic.Start.LowPart,
            translatedAddress.LowPart,
            mapped,
            requirement->u.Generic.Length
            );

    } else {

        romBase = (PVOID)((ULONG_PTR)translatedAddress.LowPart);

        //
        // NOTE - on alpha even if things are translated into ports from memory
        // you still access them using HAL_READ_MEMORY_* routines - YUCK!
        //

        PciDebugPrint(
            PciDbgROM,
            "PCI ROM b %08x t %08x IO length %x bytes\n",
            resource->u.Generic.Start.LowPart,
            translatedAddress.LowPart,
            requirement->u.Generic.Length
            );

    }

    romParameters.AcquiredResources = acquiredResources;
    romParameters.OriginalStatusCommand = oldStatusCommand;
    romParameters.OriginalRomAddress = oldRom;
    romParameters.NewRomAddress = resource->u.Memory.Start.LowPart;
    romParameters.MappedRomAddress = (PUCHAR)romBase;
    romParameters.NewBarAddress = movedAddress.LowPart;
    romParameters.DisplacedBarIndex = movedIndex;
    romParameters.Length = maximumLength;

    if (acquiredResources &&
        (PdoExtension->HackFlags & PCI_HACK_CRITICAL_DEVICE)) {
            
        doubleBuffer = (PUCHAR)ExAllocatePool(NonPagedPool, maximumLength);
        if (!doubleBuffer) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }
        romParameters.Buffer = doubleBuffer;
        
        criticalContext.Gate = 1;
        criticalContext.Barrier = 1;
        criticalContext.Routine = PciAccessRom;
        criticalContext.Extension = PdoExtension;
        criticalContext.Context = &romParameters;
        KeIpiGenericCall(PciExecuteCriticalSystemRoutine,
                         (ULONG_PTR)&criticalContext
                         );

        if (romParameters.Length != 0) {
            RtlCopyMemory(Buffer, doubleBuffer, romParameters.Length);
        }
        ExFreePool(doubleBuffer);

    } else {

        romParameters.Buffer = Buffer;
        PciAccessRom(PdoExtension, &romParameters);
    }

    *Length = romParameters.Length;
        
cleanup:

    if (acquiredResources == TRUE) {

        //
        // Release the arbiter lock (we're no longer using extraneous
        // resources so it should be safe to let someone else allocate
        // them.
        //
        if (arbiter) {
            ArbReleaseArbiterLock(arbiter);
        }
    }
    if (mapped) {
        MmUnmapIoSpace(mapped, requirement->u.Generic.Length);
    }
    PciDebugPrint(
        PciDbgROM,
        "PCI ROM leaving pdox %08x (buffer @ %08x %08x bytes, status %08x)\n",
        PdoExtension,
        (PUCHAR)Buffer - *Length,
        *Length,
        status
        );
    return status;
}

VOID
PciAccessRom(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_ROM_ACCESS_PARAMETERS RomAccessParameters
    )
/*++

Routine Description:

    Does the work of programming the hardware and transferring
    the data to the caller's buffer after all the values that
    should be programmed have already been configured above.

Arguments:

    PdoExtension - Device Extension of the device in question.
    
    RomAccessParameters - A structure containing the parameters
        for the call.  These are packed into this structure format
        to fit into the calling convention required by
        PciExecuteCriticalSystemRoutine.  The parameters are:
        
        Buffer - The buffer to write the ROM data into
        Length - On input, the length of the buffer.  On output,
            contains the length of the data transferred.
        OriginalRomAddress - The address programmed into the ROM BAR
            when we started.
        NewRomAddress - The new address to program into the ROM BAR
            to transfer the data.
        MappedRomAddress - A mapping of the ROM BAR for data transfer.
        DisplacedBarIndex - If space for the ROM was found by stealing
            space from a BAR, the index of the BAR that was displaced.
            Otherwise, MAXULONG.
        NewBarAddress - If DisplacedBarIndex is valid, the address
            to write into the displaced BAR to prevent it from decoding.
        AcquiredResources - TRUE if we had to find space for the ROM somewhere.
            FALSE if the ROM was already active and decoding when we found it.
        OriginalStatusCommand - The value of the status and command registers
            when we found the device.


Return Value:

    VOID.

--*/
{
    ULONG statusCommand;
    ULONG romBar = 0;
    PUCHAR mappedRom;
    PUCHAR imageBase;
    ULONG imageLength;
    ULONG maximumLength;
    ULONG barIndex;
    PCI_ROM_HEADER header;
    PCI_DATA_STRUCTURE dataStructure;
    PUCHAR bufferPointer;
    ULONG lengthTransferred;
    
    barIndex = RomAccessParameters->DisplacedBarIndex;

    if (RomAccessParameters->AcquiredResources) {
        
        //
        // Disable IO, MEMory and DMA while we enable the rom h/w.
        //
        statusCommand = RomAccessParameters->OriginalStatusCommand & 
                            ~(PCI_ENABLE_IO_SPACE |
                              PCI_ENABLE_MEMORY_SPACE |
                              PCI_ENABLE_BUS_MASTER
                              );
    
        PciWriteDeviceConfig(
            PdoExtension,
            &statusCommand,
            FIELD_OFFSET(PCI_COMMON_CONFIG, Command),
            sizeof(ULONG)
            );
    
        //
        // WARNING:  While in this state, the device cannot operate
        // normally.
        //
        // If we have to move a memory aperture to access the ROM
        // do so now.
        //
        if (barIndex < PCI_TYPE0_ADDRESSES) {
    
            PciWriteDeviceConfig(
                PdoExtension,
                &RomAccessParameters->NewBarAddress,
                FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.BaseAddresses[barIndex]),
                sizeof(ULONG)
                );
        }
    
        //
        // Set the ROM address (+enable).
        //
        romBar = RomAccessParameters->NewRomAddress | PCI_ROMADDRESS_ENABLED;
    
        PciWriteDeviceConfig(
            PdoExtension,
            &romBar,
            FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.ROMBaseAddress),
            sizeof(ULONG)
            );
    
        //
        // Enable MEMory access to this device.
        //
        statusCommand |= PCI_ENABLE_MEMORY_SPACE;
    
        PciWriteDeviceConfig(
            PdoExtension,
            &statusCommand,
            FIELD_OFFSET(PCI_COMMON_CONFIG, Command),
            sizeof(ULONG)
            );
    }
    

    //
    // Copy the ROM to the caller's buffer.
    //
    mappedRom = RomAccessParameters->MappedRomAddress;
    imageBase = mappedRom;
    bufferPointer = (PUCHAR)RomAccessParameters->Buffer;
    maximumLength = RomAccessParameters->Length;
    lengthTransferred = 0;

    do {
    
        //
        // Get the header, check signature.
        //
        PciTransferRomData(imageBase, &header, sizeof(header));
    
        if (header.Signature != PCI_ROM_HEADER_SIGNATURE) {
    
            //
            // Not a valid ROM image, don't transfer anything.
            //
            PciDebugPrint(
                PciDbgROM,
                "PCI ROM invalid signature, offset %x, expected %04x, got %04x\n",
                imageBase - (PUCHAR)mappedRom,
                PCI_ROM_HEADER_SIGNATURE,
                header.Signature
                );
    
            break;
        }
    
        //
        // Get image data structure, check its signature and
        // get actual length.
        //
        PciTransferRomData(imageBase + header.DataStructureOffset,
                           &dataStructure,
                           sizeof(dataStructure)
                           );
    
        if (dataStructure.Signature != PCI_ROM_DATA_STRUCTURE_SIGNATURE) {
    
            //
            // Invalid data structure, bail.
            //
            PciDebugPrint(
                PciDbgROM,
                "PCI ROM invalid signature, offset %x, expected %08x, got %08x\n",
                imageBase - (PUCHAR)mappedRom + header.DataStructureOffset,
                PCI_ROM_DATA_STRUCTURE_SIGNATURE,
                dataStructure.Signature
                );
    
            break;
        }
    
        //
        // Image length is in units of 512 bytes.   We presume
        // it's from the start of this image, ie imageBase, not
        // from the start of the code,... 'coz that wouldn't make
        // any sense.
        //
        imageLength = dataStructure.ImageLength * 512;
    
        if (imageLength > maximumLength) {
    
            //
            // Truncate to available buffer space.
            //
            imageLength = maximumLength;
        }
    
        //
        // Transfer this image to the caller's buffer.
        //
        PciTransferRomData(imageBase, bufferPointer, imageLength);
    
        //
        // Update pointers etc
        //
        bufferPointer += imageLength;
        lengthTransferred += imageLength;
        imageBase += imageLength;
        maximumLength -= imageLength;
    
        if (dataStructure.Indicator & 0x80) {
    
            //
            // Indicator bit 7 == 1 means this was the last image.
            //
    
            break;
        }
    } while (maximumLength);

    
    if (RomAccessParameters->AcquiredResources) {
    
        //
        // Disable memory decoding and disable ROM access.
        //
        statusCommand &= ~PCI_ENABLE_MEMORY_SPACE;

        PciWriteDeviceConfig(
            PdoExtension,
            &statusCommand,
            FIELD_OFFSET(PCI_COMMON_CONFIG, Command),
            sizeof(ULONG)
            );

        PciWriteDeviceConfig(
            PdoExtension,
            &RomAccessParameters->OriginalRomAddress,
            FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.ROMBaseAddress),
            sizeof(ULONG)
            );        
        
        //
        // If we moved someone to make room for the ROM, put them
        // back where they started off.
        //
        if (barIndex < PCI_TYPE0_ADDRESSES) {
    
            PciWriteDeviceConfig(
                PdoExtension,
                &PdoExtension->Resources->Current[barIndex].u.Memory.Start.LowPart,
                FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.BaseAddresses[barIndex]),
                sizeof(ULONG)
                );
        }
        
        //
        // Restore the command register to its original state.
        //
        PciWriteDeviceConfig(
            PdoExtension,
            &RomAccessParameters->OriginalStatusCommand,
            FIELD_OFFSET(PCI_COMMON_CONFIG, Command),
            sizeof(ULONG)
            );        
    }

    RomAccessParameters->Length = lengthTransferred;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\state.c ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    state.c

Abstract:

    This module the state manipulation engine for PCI

Author:

    Adrian J. Oney (AdriaO) 20-Oct-1998

Revision History:

Environment:

    NT Kernel Model Driver only

--*/

#include "pcip.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PciBeginStateTransition)
#pragma alloc_text(PAGE, PciCommitStateTransition)
#pragma alloc_text(PAGE, PciCancelStateTransition)
#pragma alloc_text(PAGE, PciIsInTransitionToState)
#endif

//
// This array marks Allowed, Disallowed, and Illegal state transitions.
//
// The horizontal axis represents the current state.
// The vertical axis represents the state we are being asked to transition into.
//
//    There are four values in the table:
//       STATUS_SUCCESS                - State transition is possible
//       STATUS_INVALID_DEVICE_STATE   - We legally cannot do the state transition
//       STATUS_INVALID_DEVICE_REQUEST - Illegal transition, but known OS bug.
//       STATUS_FAIL_CHECK             - Consistancy problem. We should ASSERT!
//
// Count is PciMaxObjectState of
//
// PciNotStarted, PciStarted, PciDeleted, PciStopped, PciSurpriseRemoved, and
// PciSynchronizedOperation
//
// The final state is used to initiate operations that synchronously with
// respect to it and other state transitions. Commiting PciSynchronizedOperation
// is strictly illegal, and we are never strickly "in" that state.
//

//
// We will use the following visually shorter notation (State Transition foo)
// for the table:
//
#define ST_OK     STATUS_SUCCESS
#define ST_NOTOK  STATUS_INVALID_DEVICE_STATE
#define ST_ERROR  STATUS_FAIL_CHECK
#define ST_NTBUG  STATUS_INVALID_DEVICE_REQUEST
#define ST_OSBUG  STATUS_INVALID_DEVICE_REQUEST
#define ST_9XBUG  STATUS_FAIL_CHECK           // Change to STATUS_SUCCESS for 9x

NTSTATUS PnpStateTransitionArray[PciMaxObjectState][PciMaxObjectState] = {
// at NotStarted, Started, Deleted, Stopped, SurpriseRemoved, SynchronizedOperation
   { ST_ERROR, ST_OK,    ST_ERROR, ST_OK,    ST_ERROR, ST_ERROR }, // entering PciNotStarted
   { ST_OK,    ST_ERROR, ST_ERROR, ST_OK,    ST_ERROR, ST_ERROR }, // entering PciStarted
   { ST_OK,    ST_OK,    ST_ERROR, ST_ERROR, ST_OK,    ST_ERROR }, // entering PciDeleted
   { ST_OSBUG, ST_OK,    ST_ERROR, ST_ERROR, ST_ERROR, ST_ERROR }, // entering PciStopped
   { ST_NTBUG, ST_OK,    ST_ERROR, ST_OK,    ST_ERROR, ST_ERROR }, // entering PciSurpriseRemoved
   { ST_OK,    ST_OK,    ST_NOTOK, ST_OK,    ST_NOTOK, ST_ERROR }  // entering PciSynchronizedOperation
};

//
// This array is used in debug to restrict which state transitions can be
// spuriously cancelled. We restrict this to Stops and Removes, which come
// through all the time due to the inability of PnP to differentiate which
// device in a stack failed a query.
//
#if DBG
// Cancelling NotStarted, Started, Removed, Stopped, SurpriseRemoved, SynchronizedOperation
NTSTATUS PnpStateCancelArray[PciMaxObjectState] =
   { ST_NTBUG, ST_ERROR, ST_NOTOK, ST_NOTOK, ST_ERROR, ST_ERROR };

//
// While here, declare the text we use for debug squirties...
//

PUCHAR PciTransitionText[] = {
   "PciNotStarted",
   "PciStarted",
   "PciDeleted",
   "PciStopped",
   "PciSurpriseRemoved",
   "PciSynchronizedOperation",
   "PciMaxObjectState"
};
#endif


VOID
PciInitializeState(
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
   DeviceExtension->DeviceState        = PciNotStarted;
   DeviceExtension->TentativeNextState = PciNotStarted;
}

NTSTATUS
PciBeginStateTransition(
    IN PPCI_COMMON_EXTENSION DeviceExtension,
    IN PCI_OBJECT_STATE      NewState
    )
{
    NTSTATUS status;
    PCI_OBJECT_STATE currentState;

#if DBG
    PciDebugPrint(
        PciDbgInformative,
        "PCI Request to begin transition of Extension %p to %s ->",
        DeviceExtension,
        PciTransitionText[NewState]
        );
#endif

    //
    // Our "next" device state should be the same as our current device state.
    //
    PCI_ASSERT(DeviceExtension->TentativeNextState == DeviceExtension->DeviceState);
    currentState = DeviceExtension->DeviceState;

    //
    // One of three returns will wind their way out of this code:
    // STATUS_SUCCESS              - State transition is possible
    // STATUS_INVALID_DEVICE_STATE - We legally cannot do the state transition
    // STATUS_FAIL_CHECK           - Consistancy problem. We should ASSERT!
    //
    PCI_ASSERT(currentState < PciMaxObjectState);
    PCI_ASSERT(NewState     < PciMaxObjectState);

    //
    // Get plausibility and legality of requested state change.
    //
    status = PnpStateTransitionArray[NewState][currentState];

#if DBG
    //
    // State bug in PnP or driver. Investigation required.
    //
    if (status == STATUS_FAIL_CHECK) {

        PciDebugPrint(
            PciDbgAlways,
            "ERROR\nPCI: Error trying to enter state \"%s\" from state \"%s\"\n",
            PciTransitionText[NewState],
            PciTransitionText[currentState]
            );

        DbgBreakPoint();

    } else if (status == STATUS_INVALID_DEVICE_REQUEST) {

        PciDebugPrint(
            PciDbgInformative,
            "ERROR\nPCI: Illegal request to try to enter state \"%s\" from state \"%s\", rejecting",
            PciTransitionText[NewState],
            PciTransitionText[currentState]
            );
    }
#endif

    //
    // Someone tried to transition from A to A. We must fail the attemtpt
    // (ie STATUS_INVALID_DEVICE_STATE). There is no known case where we
    // should return success yet do nothing.
    //
    PCI_ASSERT((NewState!=DeviceExtension->DeviceState) || (!NT_SUCCESS(status)));

    if (NT_SUCCESS(status)) {
        DeviceExtension->TentativeNextState = (UCHAR)NewState;
    }

    PciDebugPrint(PciDbgInformative, "->%x\n", status);
    return status;
}

VOID
PciCommitStateTransition(
    IN PPCI_COMMON_EXTENSION DeviceExtension,
    IN PCI_OBJECT_STATE      NewState
    )
{
#if DBG
    PciDebugPrint(
        PciDbgInformative,
        "PCI Commit transition of Extension %p to %s\n",
        DeviceExtension,
        PciTransitionText[NewState]
        );
#endif

    //
    // This state is illegal.
    //
    PCI_ASSERT(NewState != PciSynchronizedOperation);

    //
    // verify commit properly pairs with previous PciBeginStateTransition.
    //
    PCI_ASSERT(DeviceExtension->TentativeNextState == NewState);

    DeviceExtension->DeviceState = (UCHAR)NewState;
}

NTSTATUS
PciCancelStateTransition(
    IN PPCI_COMMON_EXTENSION DeviceExtension,
    IN PCI_OBJECT_STATE      StateNotEntered
    )
{
#if DBG
    PciDebugPrint(
        PciDbgInformative,
        "PCI Request to cancel transition of Extension %p to %s ->",
        DeviceExtension,
        PciTransitionText[StateNotEntered]
        );
#endif

    //
    // Spurious Cancel's are allowed in specific states. This is allowed
    // because PnP can't help but send them.
    //
    if (DeviceExtension->TentativeNextState == DeviceExtension->DeviceState) {

        PciDebugPrint(PciDbgInformative, "%x\n", STATUS_INVALID_DEVICE_STATE);
        PCI_ASSERT(StateNotEntered < PciMaxObjectState);
        PCI_ASSERT(PnpStateCancelArray[StateNotEntered] != STATUS_FAIL_CHECK);
        return STATUS_INVALID_DEVICE_STATE;
    }

    //
    // verify cancel properly pairs with previous PciBeginStateTransition.
    //
    PCI_ASSERT(DeviceExtension->TentativeNextState == StateNotEntered);

    //
    // OK, our tests say we are in a transition. Verify the mutex.
    //

    DeviceExtension->TentativeNextState = DeviceExtension->DeviceState;

    PciDebugPrint(PciDbgInformative, "%x\n", STATUS_SUCCESS);
    return STATUS_SUCCESS;
}

BOOLEAN
PciIsInTransitionToState(
    IN PPCI_COMMON_EXTENSION DeviceExtension,
    IN PCI_OBJECT_STATE      NextState
    )
{
    PCI_ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    PCI_ASSERT(NextState < PciMaxObjectState);

    //
    // Are we in a state transition?
    //
    if (DeviceExtension->TentativeNextState == DeviceExtension->DeviceState) {

        return FALSE;
    }

    //
    // OK, our tests say we are in a transition. Verify the mutex.
    //
    ASSERT_MUTEX_HELD(&DeviceExtension->StateMutex);

    return (BOOLEAN)(DeviceExtension->TentativeNextState == NextState);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\setup\proj.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    proj.h

Abstract:

    Battery Class Installer header

Author:

    Scott Brenden

Environment:

Notes:


Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <windows.h>

#include <ntpoapi.h>


#include <setupapi.h>       // PnP setup/installer services
#include <cfgmgr32.h>


//
// Debug stuff
//

#if DBG > 0 && !defined(DEBUG)
#define DEBUG
#endif

#if DBG > 0 && !defined(FULL_DEBUG)
#define FULL_DEBUG
#endif



//
// Calling declarations
//
#define PUBLIC                      FAR PASCAL
#define CPUBLIC                     FAR CDECL
#define PRIVATE                     NEAR PASCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\data.c ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    data.c

Abstract:

    Data definitions for discardable/pageable data

Author:
    Neil Sandlin (neilsa) Jan 1 2002

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg ("INIT")
#endif
//
// Beginning of Init Data
//

//
// Global registry values (in sdbus\\parameters)
//
#define SDBUS_REGISTRY_POWER_POLICY_VALUE          L"PowerPolicy"
#define SDBUS_REGISTRY_DEBUG_MASK                  L"DebugMask"
#define SDBUS_REGISTRY_EVENT_DPC_DELAY             L"EventDpcDelay"

//
// Table which defines global registry settings
//
//          RegistryName                           Internal Variable              Default Value
//          ------------                           -----------------              -------------
GLOBAL_REGISTRY_INFORMATION GlobalRegistryInfo[] = {
#if DBG
   SDBUS_REGISTRY_DEBUG_MASK,                  &SdbusDebugMask,             1,
#endif   
   SDBUS_REGISTRY_POWER_POLICY_VALUE,          &SdbusPowerPolicy,           0,
   SDBUS_REGISTRY_EVENT_DPC_DELAY,             &EventDpcDelay,               SDBUS_DEFAULT_EVENT_DPC_DELAY
};

ULONG GlobalInfoCount = sizeof(GlobalRegistryInfo) / sizeof(GLOBAL_REGISTRY_INFORMATION);

//
// end of Init Data
//
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg ()
#endif


#ifdef ALLOC_DATA_PRAGMA
   #pragma data_seg()
#endif
//
// Non-Paged global variables
//

//
// List of FDOs managed by this driver
//
PDEVICE_OBJECT   FdoList;
//
// GLobal Flags
//
ULONG            SdbusGlobalFlags = 0;
//
// Event used by SdbusWait
//
KEVENT           SdbusDelayTimerEvent;

KSPIN_LOCK SdbusGlobalLock;

ULONG EventDpcDelay;
ULONG SdbusPowerPolicy;

#if DBG
ULONG SdbusDebugMask;
#endif

#ifdef ALLOC_DATA_PRAGMA
   #pragma data_seg("PAGE")
#endif
//
// Paged const tables
//


const
PCI_CONTROLLER_INFORMATION PciControllerInformation[] = {
   
    // Vendor id                Device Id               Controller type
    // -------------------------------------------------------------------------------
    // --------------------------------------------------------------------
    // Additional database entries go above this line
    //
    PCI_INVALID_VENDORID,       0,                      0,                  
};

const
PCI_VENDOR_INFORMATION PciVendorInformation[] = {
   PCI_TOSHIBA_VENDORID,      &ToshibaSupportFns,
   PCI_INVALID_VENDORID,      NULL
};


#ifdef ALLOC_DATA_PRAGMA
   #pragma data_seg()
#endif
//
// Non-paged const tables
//

const
UCHAR SdbusCmdResponse[MAX_SD_CMD] = {
    0xFF,               // 0 - 9
    0xFF,
    SDCMD_RESP_2,
    SDCMD_RESP_6,
    0xFF,
    SDCMD_RESP_4,
    0xFF,
    SDCMD_RESP_1B, 
    0xFF,
    SDCMD_RESP_2,
    
    SDCMD_RESP_2,       // 10 - 19
    0xFF,
    SDCMD_RESP_1B,
    SDCMD_RESP_1,
    0xFF,
    0xFF,
    SDCMD_RESP_1,
    SDCMD_RESP_1,
    SDCMD_RESP_1,
    0xFF,
    
    0xFF,               // 20 - 29
    0xFF,
    0xFF,
    0xFF,
    SDCMD_RESP_1,
    SDCMD_RESP_1,
    0xFF,
    SDCMD_RESP_1,
    SDCMD_RESP_1B,
    SDCMD_RESP_1B,
    
    SDCMD_RESP_1,       // 30 - 39
    0xFF,
    SDCMD_RESP_1,
    SDCMD_RESP_1,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    SDCMD_RESP_1B,
    0xFF,
    
    0xFF,               // 40 - 49
    0xFF,
    SDCMD_RESP_1,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    
    0xFF,               // 50 - 59
    0xFF,
    SDCMD_RESP_5,
    SDCMD_RESP_5,
    0xFF,
    SDCMD_RESP_1,
    SDCMD_RESP_1
    
};

const
UCHAR SdbusACmdResponse[MAX_SD_ACMD] = {
    0xFF,               // 0 - 9
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    SDCMD_RESP_1,
    0xFF,
    0xFF,
    0xFF,
    
    0xFF,               // 10 - 19
    0xFF,
    0xFF,
    SDCMD_RESP_1,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    
    0xFF,               // 20 - 29
    0xFF,
    SDCMD_RESP_1,
    SDCMD_RESP_1,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    
    0xFF,               // 30 - 39
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    
    0xFF,               // 40 - 49
    SDCMD_RESP_3,
    SDCMD_RESP_1,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    
    0xFF,               // 50 - 59
    SDCMD_RESP_1
    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\setup\sdbsetup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ci.c

Abstract:

    Battery Class Installer

Author:

    Scott Brenden

Environment:

Notes:


Revision History:

--*/



#include "proj.h"

#include <initguid.h>
#include <devguid.h>



BOOL APIENTRY LibMain(
    HANDLE hDll, 
    DWORD dwReason,  
    LPVOID lpReserved)
{
    
    switch( dwReason ) {
    case DLL_PROCESS_ATTACH:
        
        DisableThreadLibraryCalls(hDll);

        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }


    
    return TRUE;
} 



DWORD
APIENTRY
SdClassInstall(
    IN DI_FUNCTION      DiFunction,
    IN HDEVINFO         DevInfoHandle,
    IN PSP_DEVINFO_DATA DevInfoData     OPTIONAL
    )       
/*++

Routine Description:

    This function is the class installer entry-point.

Arguments:

    DiFunction      - Requested installation function

    DevInfoHandle   - Handle to a device information set

    DevInfoData     - Pointer to device information about device to install

Return Value:

    

--*/
{
    return ERROR_DI_DO_DEFAULT;
}


DWORD
APIENTRY
SdClassCoInstaller (
    IN DI_FUNCTION  InstallFunction,
    IN HDEVINFO  DeviceInfoSet,
    IN PSP_DEVINFO_DATA  DeviceInfoData,
    IN OUT PCOINSTALLER_CONTEXT_DATA  Context
    )
{
    return (NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pci\utils.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    This module contains assorted utility functions for PCI.SYS.

Author:

    Peter Johnston (peterj)  20-Nov-1996

Revision History:

--*/

#include "pcip.h"

typedef struct _LIST_CONTEXT {
    PCM_PARTIAL_RESOURCE_LIST       List;
    CM_RESOURCE_TYPE                DesiredType;
    ULONG                           Remaining;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Next;
    CM_PARTIAL_RESOURCE_DESCRIPTOR  Alias;
} LIST_CONTEXT, *PLIST_CONTEXT;

extern PPCI_IRQ_ROUTING_TABLE PciIrqRoutingTable;

VOID
PcipInitializePartialListContext(
    IN PLIST_CONTEXT             ListContext,
    IN PCM_PARTIAL_RESOURCE_LIST PartialList,
    IN CM_RESOURCE_TYPE          DesiredType
    );

PCM_PARTIAL_RESOURCE_DESCRIPTOR
PcipGetNextRangeFromList(
    PLIST_CONTEXT ListContext
    );

NTSTATUS
PciGetDeviceCapabilities(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PDEVICE_CAPABILITIES    DeviceCapabilities
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PcipDestroySecondaryExtension)
#pragma alloc_text(PAGE, PciFindDescriptorInCmResourceList)
#pragma alloc_text(PAGE, PciFindParentPciFdoExtension)
#pragma alloc_text(PAGE, PciGetDeviceCapabilities)
#pragma alloc_text(PAGE, PciGetDeviceProperty)
#pragma alloc_text(PAGE, PcipGetNextRangeFromList)
#pragma alloc_text(PAGE, PciGetRegistryValue)
#pragma alloc_text(PAGE, PcipInitializePartialListContext)
#pragma alloc_text(PAGE, PciInsertEntryAtHead)
#pragma alloc_text(PAGE, PciInsertEntryAtTail)
#pragma alloc_text(PAGE, PcipLinkSecondaryExtension)
#pragma alloc_text(PAGE, PciOpenKey)
#pragma alloc_text(PAGE, PciQueryBusInformation)
#pragma alloc_text(PAGE, PciQueryLegacyBusInformation)
#pragma alloc_text(PAGE, PciQueryCapabilities)
#pragma alloc_text(PAGE, PciRangeListFromResourceList)
#pragma alloc_text(PAGE, PciSaveBiosConfig)
#pragma alloc_text(PAGE, PciGetBiosConfig)
#pragma alloc_text(PAGE, PciStringToUSHORT)
#pragma alloc_text(PAGE, PciSendIoctl)
#pragma alloc_text(INIT, PciBuildDefaultExclusionLists)
#pragma alloc_text(PAGE, PciIsDeviceOnDebugPath)
#endif


//
// Range lists indicating the ranges excluded from decode when the ISA and/or
// VGA bits are set on a bridge.  Initialized by PciBuildDefaultExclusionLists
// from DriverEntry.
//
RTL_RANGE_LIST PciIsaBitExclusionList;
RTL_RANGE_LIST PciVgaAndIsaBitExclusionList;


PCM_PARTIAL_RESOURCE_DESCRIPTOR
PciFindDescriptorInCmResourceList(
    IN CM_RESOURCE_TYPE DescriptorType,
    IN PCM_RESOURCE_LIST ResourceList,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR PreviousHit
    )
{
    ULONG                           numlists;
    PCM_FULL_RESOURCE_DESCRIPTOR    full;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor;

    if (ResourceList == NULL) {
        return NULL;
    }
    numlists = ResourceList->Count;
    full     = ResourceList->List;
    while (numlists--) {
        PCM_PARTIAL_RESOURCE_LIST partial = &full->PartialResourceList;
        ULONG                     count   = partial->Count;

        descriptor = partial->PartialDescriptors;
        while (count--) {

            if (descriptor->Type == DescriptorType) {

                //
                // We have a hit on the type.  If we we are doing a
                // find next, check to see if we're back where we got
                // to last time yet.
                //

                if (PreviousHit != NULL) {
                    if (PreviousHit == descriptor) {

                        //
                        // We found it again, now we can search for real.
                        //

                        PreviousHit = NULL;
                    }
                } else {

                    //
                    // It's the one.
                    //

                    return descriptor;
                }

            }
            descriptor = PciNextPartialDescriptor(descriptor);
        }

        full = (PCM_FULL_RESOURCE_DESCRIPTOR)descriptor;
    }
    return NULL;
}

PVOID
PciFindNextSecondaryExtension(
    IN PSINGLE_LIST_ENTRY   ListEntry,
    IN PCI_SIGNATURE        DesiredType
    )
{
    PPCI_SECONDARY_EXTENSION extension;

    while (ListEntry != NULL) {

        extension = CONTAINING_RECORD(ListEntry,
                                      PCI_SECONDARY_EXTENSION,
                                      List);
        if (extension->ExtensionType == DesiredType) {

            //
            // This extension is the right type, get out.
            //

            return extension;
        }
        ListEntry = extension->List.Next;
    }

    //
    // Didn't find it, fail.
    //
    return NULL;
}

VOID
PcipLinkSecondaryExtension(
    IN PSINGLE_LIST_ENTRY               ListHead,
    IN PFAST_MUTEX                      Mutex,
    IN PVOID                            NewExtension,
    IN PCI_SIGNATURE                    Type,
    IN PSECONDARYEXTENSIONDESTRUCTOR    Destructor
    )

/*++

Routine Description:

    Add a secondary extension to the secondary extension list for
    a PDO/FDO and fill in the header fields.

    NOTE: Use the macro PciLinkSecondaryExtension which takes a
    PDO extension or FDO extension instead of the list header and
    mutex fields.

Arguments:

    ListHead    &SecondaryExtension.Next from the FDO/PDO extension.
    Mutex       FDO/PDO Mutex.
    NewExtension    Extension being added to the list.
    Type            Member of the enum PCI_SIGNATURE.
    Destructor      Routine to call when this entry is being torn down.
                    (Optional).

Return Value:

    None.

--*/

{
    PPCI_SECONDARY_EXTENSION Header;

    PAGED_CODE();

    Header = (PPCI_SECONDARY_EXTENSION)NewExtension;

    Header->ExtensionType = Type;
    Header->Destructor    = Destructor;

    PciInsertEntryAtHead(ListHead, &Header->List, Mutex);
}

VOID
PcipDestroySecondaryExtension(
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PFAST_MUTEX        Mutex,
    IN PVOID              Extension
    )

/*++

Routine Description:

    Remove this secondary extension from the list of secondary
    extensions, call its destructor routine and free the memory
    allocated to it.   The destructor is responsible for deleting
    any associated allocations.

    Failure is not an option.

    Note: Use the macro PciDestroySecondaryExtension instead of
    calling this routine directly.

Arguments:

    ListHead    Pointer to the list this extension is on.
    Mutex       Mutex for synchronization of list manipulation.
    Extension   The Secondary extension being destroyed.

Return Value:

    None.

--*/

{
    PPCI_SECONDARY_EXTENSION Header;

    PAGED_CODE();

    Header = (PPCI_SECONDARY_EXTENSION)Extension;

    PciRemoveEntryFromList(ListHead, &Header->List, Mutex);

    //
    // Call the extension's destructor if one was specified.
    //

    if (Header->Destructor != NULL) {
        Header->Destructor(Extension);
    }

    //
    // Free the memory allocated for this extension.
    //

    ExFreePool(Extension);
}

VOID
PciInsertEntryAtTail(
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PSINGLE_LIST_ENTRY NewEntry,
    IN PFAST_MUTEX        Mutex
    )
{
    PSINGLE_LIST_ENTRY Previous;

    PAGED_CODE();

    if (Mutex) {
        ExAcquireFastMutex(Mutex);
    }

    //
    // Find the end of the list.
    //

    Previous = ListHead;

    while (Previous->Next) {
        Previous = Previous->Next;
    }

    //
    // Append the entry.
    //

    Previous->Next = NewEntry;

    if (Mutex) {
        ExReleaseFastMutex(Mutex);
    }
}

VOID
PciInsertEntryAtHead(
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PSINGLE_LIST_ENTRY NewEntry,
    IN PFAST_MUTEX        Mutex
    )
{
    PAGED_CODE();

    if (Mutex) {
        ExAcquireFastMutex(Mutex);
    }

    NewEntry->Next = ListHead->Next;
    ListHead->Next = NewEntry;

    if (Mutex) {
        ExReleaseFastMutex(Mutex);
    }
}

VOID
PciRemoveEntryFromList(
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PSINGLE_LIST_ENTRY OldEntry,
    IN PFAST_MUTEX        Mutex
    )

/*++

Routine Description:

    Remove an entry from a singly linked list.

    It is the caller's responsibility to have locked the list if
    there is danger of multiple updates.

Arguments:

    ListHead    - Address of the first entry in the list.
    OldEntry    - Address of the entry to be removed from the
                  list.

Return Value:

    None.

--*/

{
    PSINGLE_LIST_ENTRY Previous;

    //
    // Sanity check, the list head can't be removed.
    //

    PCI_ASSERT(ListHead != OldEntry);

    if (Mutex) {
        ExAcquireFastMutex(Mutex);
    }

    //
    // Locate the entry that points to this entry.
    //

    for (Previous = ListHead; Previous; Previous = Previous->Next) {
        if (Previous->Next == OldEntry) {
            break;
        }
    }

    //
    // The entry is not in the list - this is bad but fail gracefully...
    //

    if (!Previous) {
        PCI_ASSERT(Previous);
        goto exit;
    }

    //
    // Pull it off the list.
    //

    Previous->Next = OldEntry->Next;
    OldEntry->Next = NULL;

exit:

    if (Mutex) {
        ExReleaseFastMutex(Mutex);
    }

}

PCM_PARTIAL_RESOURCE_DESCRIPTOR
PciNextPartialDescriptor(
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    Given a pointer to a CmPartialResourceDescriptor, return a pointer
    to the next descriptor in the same list.

    This is only done in a routine (rather than a simple descriptor++)
    because if the variable length resource CmResourceTypeDeviceSpecific.

Arguments:

    Descriptor   - Pointer to the descriptor being advanced over.

Return Value:

    Pointer to the next descriptor in the same list (or byte beyond
    end of list).

--*/

{
    PCM_PARTIAL_RESOURCE_DESCRIPTOR nextDescriptor;

    nextDescriptor = Descriptor + 1;

    if (Descriptor->Type == CmResourceTypeDeviceSpecific) {

        //
        // This (old) descriptor is followed by DataSize bytes
        // of device specific data, ie, not immediatelly by the
        // next descriptor.   Adjust nextDescriptor by this amount.
        //

        nextDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)
            ((ULONG_PTR)nextDescriptor + Descriptor->u.DeviceSpecificData.DataSize);
    }
    return nextDescriptor;
}

VOID
PcipInitializePartialListContext(
    IN PLIST_CONTEXT             ListContext,
    IN PCM_PARTIAL_RESOURCE_LIST PartialList,
    IN CM_RESOURCE_TYPE          DesiredType
    )
{
    PCI_ASSERT(DesiredType != CmResourceTypeNull);

    ListContext->List = PartialList;
    ListContext->DesiredType = DesiredType;
    ListContext->Remaining = PartialList->Count;
    ListContext->Next = PartialList->PartialDescriptors;
    ListContext->Alias.Type = CmResourceTypeNull;
}

PCM_PARTIAL_RESOURCE_DESCRIPTOR
PcipGetNextRangeFromList(
    PLIST_CONTEXT ListContext
    )
{
    ULONG Addend;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR current;

    //
    // See if we should be generating an alias to the current
    // descriptor.
    //

    if (ListContext->Alias.Type == ListContext->DesiredType) {

        //
        // Yes, advance to alias by adding offset to next 10 bit or
        // 12 bit alias (only allowable values).
        //

        if (ListContext->Alias.Flags & CM_RESOURCE_PORT_10_BIT_DECODE) {
            Addend = 1 << 10;
        } else {
            Addend = 1 << 12;
        }
        Addend += ListContext->Alias.u.Generic.Start.LowPart;

        if (Addend < (1 << 16)) {

            //
            // This is a valid alias, return it.
            //

            ListContext->Alias.u.Generic.Start.LowPart = Addend;
            return &ListContext->Alias;
        }

        //
        // Out of aliases to this resource.
        //

        ListContext->Alias.Type = CmResourceTypeNull;
    }

    //
    // We get here if there are no aliases or it is time to advance
    // to the next descriptor of the desired type.
    //

    while (ListContext->Remaining != 0) {

        current = ListContext->Next;

        //
        // Advance context to next before examining and possibly
        // returning current.
        //

        ListContext->Next = PciNextPartialDescriptor(current);
        ListContext->Remaining--;

        //
        // Is this current descriptor a candidate?
        //

        if (current->Type == ListContext->DesiredType) {

            //
            // Return this one to caller.   If this descriptor has
            // aliases, setup so the next call will return an alias.
            //

            if (current->Flags & (CM_RESOURCE_PORT_10_BIT_DECODE |
                                  CM_RESOURCE_PORT_12_BIT_DECODE)) {
                ListContext->Alias = *current;
            }
            return current;
        }
    }

    //
    // No aliases and no new descriptors of the desired type.
    //

    return NULL;
}

NTSTATUS
PciQueryPowerCapabilities(
    IN  PPCI_PDO_EXTENSION          PdoExtension,
    IN  PDEVICE_CAPABILITIES    Capabilities
    )
/*++

Routine Description:

    determine a device's power capabilites by using its parent capabilities

    It should be noted that there two ways that the code calculates the system
    and device wake levels. The first method, which is preferred, biases toward
    the deepest possible system state, and the second, which gets used if the
    first fails to find something legal, is biased towards finding the deepest
    possible device wake state

Arguments:

    PdoExtension    - The PDO whose capabilities we will provide
    Capablities     - Where we will store the device capabilities

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    DEVICE_CAPABILITIES     parentCapabilities;
    DEVICE_POWER_STATE      deviceState;
    DEVICE_POWER_STATE      validDeviceWakeState       = PowerDeviceUnspecified;
    SYSTEM_POWER_STATE      index;
    SYSTEM_POWER_STATE      highestSupportedSleepState = PowerSystemUnspecified;
    SYSTEM_POWER_STATE      validSystemWakeState       = PowerSystemUnspecified;

    //
    // Get the device capabilities of the parent
    //
    status = PciGetDeviceCapabilities(
        PdoExtension->ParentFdoExtension->PhysicalDeviceObject,
        &parentCapabilities
        );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Make sure that we have sane device capabilities to start with...
    //
    if (parentCapabilities.DeviceState[PowerSystemWorking] == PowerDeviceUnspecified) {

        parentCapabilities.DeviceState[PowerSystemWorking] = PowerDeviceD0;

    }
    if (parentCapabilities.DeviceState[PowerSystemShutdown] == PowerDeviceUnspecified) {

        parentCapabilities.DeviceState[PowerSystemShutdown] = PowerDeviceD3;

    }

    //
    // Does the device have any PCI power capabilities?
    //
    if ( (PdoExtension->HackFlags & PCI_HACK_NO_PM_CAPS)) {

        //
        // Use the parent's mapping as our own
        //
        RtlCopyMemory(
            Capabilities->DeviceState,
            parentCapabilities.DeviceState,
            (PowerSystemShutdown + 1) * sizeof(DEVICE_POWER_STATE)
            );

        //
        // As D1 and D2 are not supported here, round down to D3.
        //
        //     This code is not enabled so that a hack becomes available for
        // older PCI video cards. Basically, older video cards can do D3 hot
        // but not D3 cold (in which case they need reposting). ACPI supplies
        // a hack by which all PCI-to-PCI bridges are said to map S1->D1. The
        // code below lets the parent's D1 "appear" as a state the child
        // supports, regardless of it's real capabilities. Video drivers for
        // such cards fail D3 (which may be D3-cold), but succeed D1 (which is
        // really D3-hot).
        //
        // Also note that this is not targetted at video cards but rather is
        // targetted at any non-PCI power managed device. That means drivers
        // for older devices need to either map D1&D2 to D3 themselves, or
        // treat unexpected D1&D2 IRPs as if D3. Folklore says that there is
        // also a net card or two that also takes advantage of this hack.
        //
#if 0
        for (index = PowerSystemWorking; index < PowerSystemMaximum; index++) {

            //
            // This is the device state that the parent supports
            //
            deviceState = parentCapabilities.DeviceState[index];

            //
            // Round down if D1 or D2
            //
            if ((deviceState == PowerDeviceD1) || (deviceState == PowerDeviceD2)) {

                Capabilities->DeviceState[index] = PowerDeviceD3;
            }
        }
#endif

        //
        // The device has no wake capabilities
        //
        Capabilities->DeviceWake = PowerDeviceUnspecified;
        Capabilities->SystemWake = PowerSystemUnspecified;

        //
        // Set these bits explicitly
        //
        Capabilities->DeviceD1 = FALSE;
        Capabilities->DeviceD2 = FALSE;
        Capabilities->WakeFromD0 = FALSE;
        Capabilities->WakeFromD1 = FALSE;
        Capabilities->WakeFromD2 = FALSE;
        Capabilities->WakeFromD3 = FALSE;

        //
        // Done
        //
        return STATUS_SUCCESS;

    }

    //
    // Set all the capabilities bits
    //
    Capabilities->DeviceD1 = PdoExtension->PowerCapabilities.Support.D1;
    Capabilities->DeviceD2 = PdoExtension->PowerCapabilities.Support.D2;
    Capabilities->WakeFromD0 = PdoExtension->PowerCapabilities.Support.PMED0;
    Capabilities->WakeFromD1 = PdoExtension->PowerCapabilities.Support.PMED1;
    Capabilities->WakeFromD2 = PdoExtension->PowerCapabilities.Support.PMED2;
    if (parentCapabilities.DeviceWake == PowerDeviceD3) {

        //
        // If our parent can wake from the D3 state, than we must support
        // PM3 From D3 Cold. The (obvious) exception to this is if the
        // parent is a root bus...
        //
        if (PCI_PDO_ON_ROOT(PdoExtension)) {

            Capabilities->WakeFromD3 =
                PdoExtension->PowerCapabilities.Support.PMED3Hot;

        } else {

            Capabilities->WakeFromD3 =
                PdoExtension->PowerCapabilities.Support.PMED3Cold;

        }

    } else {

        //
        // If our parent cannot wake from the D3 state, then we support
        // the D3 state if we support PME3Hot
        //
        Capabilities->WakeFromD3 =
            PdoExtension->PowerCapabilities.Support.PMED3Hot;

    }

    //
    // First step is to make sure that all the S-states that we got from
    // out parent map to valid D-states for this device
    //
    // ADRIAO N.B. 08/18/1999 -
    //     This algorithm works but it's overly aggressive. It is in fact legal
    // for a bridge to be in D2 with a card behind it in D1.
    //
    for (index = PowerSystemWorking; index < PowerSystemMaximum; index++) {

        //
        // This is the device state that the parent supports
        //
        deviceState = parentCapabilities.DeviceState[index];

        //
        // If the device state is D1 and we don't support D1, then
        // consider D2 instead
        //
        if (deviceState == PowerDeviceD1 &&
            PdoExtension->PowerCapabilities.Support.D1 == FALSE) {

            deviceState++;

        }

        //
        // If the device state is D2 and we don't support D2, then
        // consider D3 instead
        //
        if (deviceState == PowerDeviceD2 &&
            PdoExtension->PowerCapabilities.Support.D2 == FALSE) {

            deviceState++;

        }

        //
        // We should be able to support this deviceState
        //
        Capabilities->DeviceState[index] = deviceState;

        //
        // If this S-state is less than PowerSystemHibernate, and the
        // S-State doesn't map to PowerDeviceUnspecified, then consider
        // this to be the highest supported SleepState
        //
        if (index < PowerSystemHibernate &&
            Capabilities->DeviceState[index] != PowerDeviceUnspecified) {

            highestSupportedSleepState = index;

        }

        //
        // Can we support this as a wake state?
        //
        if (index < parentCapabilities.SystemWake &&
            deviceState >= parentCapabilities.DeviceState[index] &&
            parentCapabilities.DeviceState[index] != PowerDeviceUnspecified) {

            //
            // Consider using this as a valid wake state
            //
            if ( (deviceState == PowerDeviceD0 && Capabilities->WakeFromD0) ||
                 (deviceState == PowerDeviceD1 && Capabilities->WakeFromD1) ||
                 (deviceState == PowerDeviceD2 && Capabilities->WakeFromD2) ) {

                validSystemWakeState = index;
                validDeviceWakeState = deviceState;

            } else if (deviceState == PowerDeviceD3 &&
                       PdoExtension->PowerCapabilities.Support.PMED3Hot) {

                //
                // This is a special case logic (which is why it is seperate from
                // the above logic
                //
                if (parentCapabilities.DeviceState[index] < PowerDeviceD3 ||
                    PdoExtension->PowerCapabilities.Support.PMED3Cold) {

                    validSystemWakeState = index;
                    validDeviceWakeState = deviceState;

                }

            }

        }

    }

    //
    // Does the parent device have power management capabilities?
    // Does the device have power management capabilities?
    // Can we wake up from the same D-states that our parent can? or better?
    //
    if (parentCapabilities.SystemWake == PowerSystemUnspecified ||
        parentCapabilities.DeviceWake == PowerDeviceUnspecified ||
        PdoExtension->PowerState.DeviceWakeLevel == PowerDeviceUnspecified ||
        PdoExtension->PowerState.DeviceWakeLevel < parentCapabilities.DeviceWake) {

        //
        // The device doesn't support any kind of wakeup (that we know about)
        // or the device doesn't support wakeup from supported D-states, so
        // set the latency and return
        //
        Capabilities->D1Latency  = 0;
        Capabilities->D2Latency  = 0;
        Capabilities->D3Latency  = 0;

        return STATUS_SUCCESS;

    }

    //
    // We should be able to wake the device from the same state
    // that our parent can wake from
    //
    Capabilities->SystemWake = parentCapabilities.SystemWake;
    Capabilities->DeviceWake = PdoExtension->PowerState.DeviceWakeLevel;

    //
    // Change our device wake level to include a state that we support
    //
    if (Capabilities->DeviceWake == PowerDeviceD0 && !Capabilities->WakeFromD0) {

        Capabilities->DeviceWake++;

    }
    if (Capabilities->DeviceWake == PowerDeviceD1 && !Capabilities->WakeFromD1) {

        Capabilities->DeviceWake++;

    }
    if (Capabilities->DeviceWake == PowerDeviceD2 && !Capabilities->WakeFromD2) {

        Capabilities->DeviceWake++;

    }
    if (Capabilities->DeviceWake == PowerDeviceD3 && !Capabilities->WakeFromD3) {

        Capabilities->DeviceWake = PowerDeviceUnspecified;
        Capabilities->SystemWake = PowerSystemUnspecified;

    }

    //
    // This is our fallback position. If we got here and there is no wake
    // capability using the above method of calcuation, then we should
    // check to see if we noticed a valid wake combination while scanning
    // the S to D mapping information
    //
    if ( (Capabilities->DeviceWake == PowerDeviceUnspecified  ||
          Capabilities->SystemWake == PowerSystemUnspecified) &&
         (validSystemWakeState != PowerSystemUnspecified &&
          validDeviceWakeState != PowerSystemUnspecified) ) {

        Capabilities->DeviceWake = validDeviceWakeState;
        Capabilities->SystemWake = validSystemWakeState;

        //
        // Note that in this case, we might have set DeviceWake to D3, without
        // having set the bit, so "correct" that situation.
        //
        if (validDeviceWakeState == PowerDeviceD3) {

            Capabilities->WakeFromD3 = TRUE;

        }

    }
    //
    // We shouldn't allow Wake From S4, S5, unless the supports the D3 state
    // Even then, we really shouldn't allow S4, S5 unless the device supports
    // the D3Cold PME state
    //
    if (Capabilities->SystemWake > PowerSystemSleeping3) {

        //
        // Does the device support wake from D3?
        //
        if (Capabilities->DeviceWake != PowerDeviceD3) {

            //
            // Reduce the systemwake level to something more realistic
            //
            Capabilities->SystemWake = highestSupportedSleepState;

        }

        //
        // This is in a seperate if statement so that the code can be easily
        // commented out
        //
        if (!PdoExtension->PowerCapabilities.Support.PMED3Cold) {

            //
            // Reduce the systemwake level to something more realistic
            //
            Capabilities->SystemWake = highestSupportedSleepState;

        }

    }

    //
    // From the PCI Power Management spec V1.0, table 18
    // "PCI Function State Transition Delays".
    //
    // D1 -> D0  0
    // D2 -> D0  200 us
    // D3 -> D0  10  ms
    //
    // The latency entries are in units of 100 us.
    //
    Capabilities->D1Latency  = 0;
    Capabilities->D2Latency  = 2;
    Capabilities->D3Latency  = 100;

    //
    // Make sure that S0 maps to D0
    //
    PCI_ASSERT( Capabilities->DeviceState[PowerSystemWorking] == PowerDeviceD0);

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
PciDetermineSlotNumber(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN OUT PULONG SlotNumber
    )

/*++

Description:

    Determine the slot number associated with a PCI device (if any)
    through use of the PCI IRQ routing table information we may have
    stored earlier.

    If the previous mechanism fails to retrieve a slot number, see if
    we can inherit our parent's slot number.

    This result may be filtered further by ACPI and other bus filters..

Arguments:

    PdoExtension - PDO extension of device in question.
    SlotNumber - Pointer to slot number to update

Return Value:

    STATUS_SUCCESS if slot # found

--*/

{
    PSLOT_INFO slotInfo, lastSlot;
    ULONG length;

    //
    // If we have a legacy PCI routing table and our Pdo isn't orphaned search 
    // the table for our physical slot number.  If this is an ACPI machine then ACPI
    // will overwrite this with the value from the _SUN if it exists.
    // 

    if (PciIrqRoutingTable && PCI_PARENT_FDOX(PdoExtension)) {
    
        slotInfo = (PSLOT_INFO)((PUCHAR) PciIrqRoutingTable +
                                sizeof(PCI_IRQ_ROUTING_TABLE));
        lastSlot = (PSLOT_INFO)((PUCHAR) PciIrqRoutingTable +
                                PciIrqRoutingTable->TableSize);
    
        // Search for a entry in the routing table that matches this device
    
        while (slotInfo < lastSlot) {
            if ((PCI_PARENT_FDOX(PdoExtension)->BaseBus == slotInfo->BusNumber)  &&
                ((UCHAR)PdoExtension->Slot.u.bits.DeviceNumber == (slotInfo->DeviceNumber >> 3)) &&
                (slotInfo->SlotNumber != 0)) {
                *SlotNumber = slotInfo->SlotNumber;
                return STATUS_SUCCESS;
            }
            slotInfo++;
        }
    

    }
    
    //
    // Maybe our parent has a UI Number that we could 'inherit'.
    // but only if we're not a PDO off a root bus otherwise we pick up
    // the UI number from the PNPA03 node (likely 0)
    //

    if (PCI_PDO_ON_ROOT(PdoExtension)) {
        return STATUS_UNSUCCESSFUL;
    }

    return IoGetDeviceProperty(PCI_PARENT_PDO(PdoExtension),
                               DevicePropertyUINumber,
                               sizeof(*SlotNumber),
                               SlotNumber,
                               &length);
}

NTSTATUS
PciQueryCapabilities(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PDEVICE_CAPABILITIES Capabilities
    )

/*++

Routine Description:

    return a subset of our parent's capabilities.

Arguments:

    Capabilities - pointer to a DEVICE_CAPABILITIES structured supplied
                   by the caller.

Return Value:

    Status.

--*/

{
    NTSTATUS    status = STATUS_SUCCESS;

#ifndef HANDLE_BOGUS_CAPS
    if (Capabilities->Version < 1) {

        //
        // do not touch irp!
        //
        return STATUS_NOT_SUPPORTED;

    }
#endif

    //
    // For PCI devices, the Capabilities Address field contains
    // the Device Number in the upper 16 bits and the function
    // number in the lower.
    //
    Capabilities->Address =
        PdoExtension->Slot.u.bits.DeviceNumber << 16 |
        PdoExtension->Slot.u.bits.FunctionNumber;

    //
    // The PCI bus driver does not generate Unique IDs for its children.
    //
    Capabilities->UniqueID = FALSE;

    //
    // If this PDO is for a HOST BRIDGE, claim that it supports
    // being handled Raw.  This is so the device controller will
    // allow installation of the NULL device on this puppy.
    //

    if ((PdoExtension->BaseClass == PCI_CLASS_BRIDGE_DEV) &&
        (PdoExtension->SubClass  == PCI_SUBCLASS_BR_HOST)) {

        Capabilities->RawDeviceOK = TRUE;

    } else {

        Capabilities->RawDeviceOK = FALSE;

    }

    //
    // The following values should be fixed by filters or function
    // drivers that actually know the answer.
    //
    Capabilities->LockSupported = FALSE;
    Capabilities->EjectSupported = FALSE;
    Capabilities->Removable = FALSE;
    Capabilities->DockDevice = FALSE;

    PciDetermineSlotNumber(PdoExtension, &Capabilities->UINumber);

    //
    // Get the device power capabilities
    //
    status = PciQueryPowerCapabilities( PdoExtension, Capabilities );
    if (!NT_SUCCESS(status)) {

        return status;

    }

#if DBG
    if (PciDebug & PciDbgQueryCap) {

        PciDebugDumpQueryCapabilities(Capabilities);

    }
#endif

    //
    // Done
    //
    return status;
}

NTSTATUS
PciQueryBusInformation(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPNP_BUS_INFORMATION *BusInformation
    )

/*++

Routine Description:

    Tell PnP that it's talking to a PCI bus.

Arguments:

    BusInformation - Pointer to a PPNP_BUS_INFORMATION.  We create
                     a PNP_BUS_INFORMATION and pass its address
                     back thru here.

Return Value:

    Status.

--*/

{
    PPNP_BUS_INFORMATION information;

    information = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, sizeof(PNP_BUS_INFORMATION));

    if (information == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(&information->BusTypeGuid, &GUID_BUS_TYPE_PCI, sizeof(GUID));
    information->LegacyBusType = PCIBus;
    information->BusNumber = PCI_PARENT_FDOX(PdoExtension)->BaseBus;

    *BusInformation = information;

    return STATUS_SUCCESS;
}

NTSTATUS
PciQueryLegacyBusInformation(
    IN PPCI_FDO_EXTENSION FdoExtension,
    IN PLEGACY_BUS_INFORMATION *BusInformation
    )

/*++

Routine Description:

    Tell PnP that it's talking to a PCI bus.

Arguments:

    BusInformation - Pointer to a PLEGACY_BUS_INFORMATION.  We create
                     a LEGACY_BUS_INFORMATION and pass its address
                     back thru here.

Return Value:

    Status.

--*/

{
    PLEGACY_BUS_INFORMATION information;

    information = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, sizeof(LEGACY_BUS_INFORMATION));

    if (information == NULL) {
        PCI_ASSERT(information != NULL);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(&information->BusTypeGuid, &GUID_BUS_TYPE_PCI, sizeof(GUID));
    information->LegacyBusType = PCIBus;
    information->BusNumber = FdoExtension->BaseBus;

    *BusInformation = information;

    return STATUS_SUCCESS;
}

NTSTATUS
PciGetInterruptAssignment(
    IN PPCI_PDO_EXTENSION PdoExtension,
    OUT ULONG *Minimum,
    OUT ULONG *Maximum
    )
{
    UCHAR pin       = PdoExtension->InterruptPin;

    //
    // Using HAL for interrupts.
    //

    PIO_RESOURCE_REQUIREMENTS_LIST reqList;
    PIO_RESOURCE_DESCRIPTOR resource;
    NTSTATUS         status = STATUS_RESOURCE_TYPE_NOT_FOUND;

    if (pin != 0) {

        //
        // This hardware uses an interrupt.
        //
        // Depend on the HAL to understand how IRQ routing is
        // really done.
        //

        reqList = PciAllocateIoRequirementsList(
                      1,                            // number of resources
                      PCI_PARENT_FDOX(PdoExtension)->BaseBus,
                      PdoExtension->Slot.u.AsULONG
                      );

        if (reqList == NULL) {

            //
            // Out of system resources?  Bad things are happening.
            //

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        resource = reqList->List[0].Descriptors;
        resource->Type = CmResourceTypeInterrupt;
        resource->ShareDisposition = CmResourceShareShared;
        resource->Option = 0;
        resource->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
        resource->u.Interrupt.MinimumVector = 0x00;

        //
        // Historically the maximum allowable interrupt vector for a PCI
        // device was FF, since that is the largest value that can be written
        // into the interrupt line register.  However, the interrupt line
        // register is largely irrelevant now, and large machines may contain
        // enough interrupt controllers to kick the number of interrupt vectors
        // in the machine above FF.  To support devices connected to these vectors
        // the maximum vector in the requirement must be as large as possible.
        // For now this change is only made on the Datacenter SKU as drivers may
        // rely on the interrupt line register, which is now bogus.  When more
        // complete testing is available, this change will be made global.
        //
        if (PciRunningDatacenter) {
            resource->u.Interrupt.MaximumVector = MAXULONG;
        } else {
            resource->u.Interrupt.MaximumVector = 0xff;
        }
        

#if defined(NO_LEGACY_DRIVERS)
        *Minimum = 0;
        if (PciRunningDatacenter) {
            *Maximum = MAXULONG;
        } else {
            *Maximum = 0xFF;
        }
        
        status = STATUS_SUCCESS;
#else
        status = HalAdjustResourceList(&reqList);

        //
        // If the HAL succeeded it will have reallocated the list.
        //
        resource = reqList->List[0].Descriptors;

        if (!NT_SUCCESS(status)) {

            PciDebugPrint(
                PciDbgInformative,
                "    PIN %02x, HAL FAILED Interrupt Assignment, status %08x\n",
                pin,
                status
                );

            status = STATUS_UNSUCCESSFUL;

        } else if (resource->u.Interrupt.MinimumVector >
                   resource->u.Interrupt.MaximumVector) {

            UCHAR line;

            //
            // The HAL succeeded but returned an invalid range.  This
            // is the HALs way of telling us that, sorry, it doesn't
            // know either.
            //

            //
            // We have a bug in that we restore the interrupt line to
            // config space before we power up the device and thus if
            // the device is in D>0 and the interrupt line register
            // isn't sticky it doesn't stick.  It doesn't matter unless
            // we are on a machine that doesn't support interrupt
            // routing in which case we are toast.  The correct fix is
            // to move the restore code after we power managed the device
            // but that changes things too much for Whistler Beta2 and this
            // is totally rewritten for Blackcomb so, now that you know
            // the right way to fix this, the hack is if the HAL fails
            // the call use what we would have restored into the interrupt
            // line.
            //

            //
            // Get the current int line (this is in the same place for all header types)
            //

            PciReadDeviceConfig(PdoExtension,
                                &line,
                                FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.InterruptLine),
                                sizeof(line)
                                );

            //
            // If this is 0 and it was something when we first saw the device then use
            // what we first saw
            //

            if (line == 0 && PdoExtension->RawInterruptLine != 0) {
                *Minimum = *Maximum = (ULONG)PdoExtension->RawInterruptLine;

                status = STATUS_SUCCESS;

            } else {

                PciDebugPrint(
                    PciDbgInformative,
                    "    PIN %02x, HAL could not assign interrupt.\n",
                    pin
                    );

                status = STATUS_UNSUCCESSFUL;
            }

        } else {

            *Minimum = resource->u.Interrupt.MinimumVector;
            *Maximum = resource->u.Interrupt.MaximumVector;

            PciDebugPrint(
                PciDbgObnoxious,
                "    Interrupt assigned = 0x%x through 0x%x\n",
                *Minimum,
                *Maximum
                );

            status = STATUS_SUCCESS;
        }
        ExFreePool(reqList);

#endif // NO_LEGACY_DRIVERS

    } else {

#if MSI_SUPPORTED

        if (PdoExtension->CapableMSI) {

            //
            // MSI Only device - we need to return a success here so that
            // this device gets resource requests passed to a (hopefully)
            // MSI-aware arbiter. If the arbiter is not MSI aware, we will
            // simply get extraneous/unusable resources allocated for this
            // device - not to mention the fact that the device will not work.
            //
            // The below could be anything, they are only limited by message
            // size and the available APIC ranges which only the arbiter
            // knows about.
            //

            *Minimum = 0x00;
            *Maximum = 0xFF;

            status = STATUS_SUCCESS;
        }

#endif // MSI_SUPPORTED

    }
    return status;
}

PPCI_PDO_EXTENSION
PciFindPdoByFunction(
    IN PPCI_FDO_EXTENSION FdoExtension,
    IN PCI_SLOT_NUMBER Slot,
    IN PPCI_COMMON_CONFIG Config
    )
{
    PPCI_PDO_EXTENSION pdoExtension;
    KIRQL currentIrql;

    //
    // This can be called at >= DISPATCH_LEVEL when we scan the bus on returning
    // from hibernate.  Don't try to acquire the locks because (1) it'll crash
    // and (2) it is guaranteed to be single threaded
    //

    currentIrql = KeGetCurrentIrql();

    if (currentIrql < DISPATCH_LEVEL) {
        ExAcquireFastMutex(&FdoExtension->ChildListMutex);
    };

    //
    // Seach each PDO hanging off of the given FDO until we find a matching
    // PCI function or fall off the end of the list.
    //

    for (pdoExtension = FdoExtension->ChildPdoList;
         pdoExtension;
         pdoExtension = pdoExtension->Next) {

        if ((!pdoExtension->ReportedMissing) &&
            (pdoExtension->Slot.u.bits.DeviceNumber == Slot.u.bits.DeviceNumber)   &&
            (pdoExtension->Slot.u.bits.FunctionNumber == Slot.u.bits.FunctionNumber)) {

            //
            // Check that the device in this slot hasn't changed. (as best
            // we can).
            //

            if (   (pdoExtension->VendorId   == Config->VendorID)
                && (pdoExtension->DeviceId   == Config->DeviceID)
                && (pdoExtension->RevisionId == Config->RevisionID)
#if 0
                //
                // NTRAID #62668 - 4/25/2000
                //
                // These do not contribute towards the device ID itself, and
                // as they are unfortunately volatile on some cards (SubClass
                // changes on the ATIRage, Programming interface on IDE cards).
                // Therefore a change in these fields does not mean a change in
                // the presence of the card.
                //
                // What about the SSVID?
                //
                && (pdoExtension->ProgIf     == Config->ProgIf)
                && (pdoExtension->SubClass   == Config->SubClass)
                && (pdoExtension->BaseClass  == Config->BaseClass)
#endif
                ) {

                break;
            }
        }
    }

    if (currentIrql < DISPATCH_LEVEL) {
        ExReleaseFastMutex(&FdoExtension->ChildListMutex);
    }

    return pdoExtension;
}

PPCI_FDO_EXTENSION
PciFindParentPciFdoExtension(
    PDEVICE_OBJECT PhysicalDeviceObject,
    IN PFAST_MUTEX Mutex
    )

/*++

Routine Description:

    For each Parent PCI FDO, search the child Pdo lists for the supplied
    PhysicalDeviceObject.

Arguments:

    PhysicalDeviceObject    Pdo to find.
    Mutex                   Mutex list is protected by.

Return Value:

    If Pdo is found as a child, returns a pointer to the root Fdo's
    device extension, otherwise returns NULL.

--*/

{
    PPCI_FDO_EXTENSION     fdoExtension;
    PPCI_PDO_EXTENSION     pdoExtension;
    PPCI_PDO_EXTENSION     target;
    PSINGLE_LIST_ENTRY nextEntry;

    if (Mutex) {
        ExAcquireFastMutex(Mutex);
    }

    target = (PPCI_PDO_EXTENSION)PhysicalDeviceObject->DeviceExtension;

    //
    // For each root
    //

    for ( nextEntry = PciFdoExtensionListHead.Next;
          nextEntry != NULL;
          nextEntry = nextEntry->Next ) {

        fdoExtension = CONTAINING_RECORD(nextEntry,
                                         PCI_FDO_EXTENSION,
                                         List);

        //
        // Search the child Pdo list.
        //

        ExAcquireFastMutex(&fdoExtension->ChildListMutex);
        for ( pdoExtension = fdoExtension->ChildPdoList;
              pdoExtension;
              pdoExtension = pdoExtension->Next ) {

            //
            // Is this the one we're looking for?
            //

            if ( pdoExtension == target ) {

                ExReleaseFastMutex(&fdoExtension->ChildListMutex);

                //
                // Yes, return it.
                //

                if (Mutex) {
                     ExReleaseFastMutex(Mutex);
                }

                return fdoExtension;
            }
        }
        ExReleaseFastMutex(&fdoExtension->ChildListMutex);
    }

    //
    // Did not find match.
    //
    if (Mutex) {
         ExReleaseFastMutex(Mutex);
    }

    return NULL;
}

PCI_OBJECT_TYPE
PciClassifyDeviceType(
    PPCI_PDO_EXTENSION PdoExtension
    )

/*++

Routine Description:

    Examine the Configuration Header BaseClass and SubClass fields
    and classify the device into a simple enumerated type.

Arguments:

    PdoExtension    Pointer to the Physical Device Object extension
                    into which the above fields have been previously
                    been copied from PCI config space.

Return Value:

    Returns a device type from the PCI_OBJECT_TYPE enumeration.

--*/

{
    ASSERT_PCI_PDO_EXTENSION(PdoExtension);

    switch (PdoExtension->BaseClass) {

    case PCI_CLASS_BRIDGE_DEV:

        //
        // It's a bridge, subdivide it into the kind of bridge.
        //

        switch (PdoExtension->SubClass) {

        case PCI_SUBCLASS_BR_HOST:

            return PciTypeHostBridge;

        case PCI_SUBCLASS_BR_PCI_TO_PCI:

            return PciTypePciBridge;

        case PCI_SUBCLASS_BR_CARDBUS:

            return PciTypeCardbusBridge;

        default:

            //
            // Anything else is just a device.
            //

            break;
        }

    default:

        //
        // Anything else is just another device.
        //

        break;
    }
    return PciTypeDevice;
}

ULONG
PciGetLengthFromBar(
    ULONG BaseAddressRegister
    )

/*++

Routine Description:

    Given the contents of a PCI Base Address Register, after it
    has been written with all ones, this routine calculates the
    length (and alignment) requirement for this BAR.

    This method for determining requirements is described in
    section 6.2.5.1 of the PCI Specification (Rev 2.1).

    NTRAID #62631 - 4/25/2000 - andrewth
    The length is a power of two, given only a ULONG to
    contain it, we are restricted to a maximum resource size of
    2GB.

Arguments:

    BaseAddressRegister contains something.

Return Value:

    Returns the length of the resource requirement.  This will be a number
    in the range 0 thru 0x80000000.

--*/

{
    ULONG Length;

    //
    // A number of least significant bits should be ignored in the
    // determination of the length.  These are flag bits, the number
    // of bits is dependent on the type of the resource.
    //

    if (BaseAddressRegister & PCI_ADDRESS_IO_SPACE) {

        //
        // PCI IO space.
        //

        BaseAddressRegister &= PCI_ADDRESS_IO_ADDRESS_MASK;

    } else {

        //
        // PCI Memory space.
        //

        BaseAddressRegister &= PCI_ADDRESS_MEMORY_ADDRESS_MASK;
    }

    //
    // BaseAddressRegister now contains the maximum base address
    // this device can reside at and still exist below the top of
    // memory.
    //
    // The value 0xffffffff was written to the BAR.  The device will
    // have adjusted this value to the maximum it can really use.
    //
    // Length MUST be a power of 2.
    //
    // For most devices, h/w will simply have cleared bits from the
    // least significant bit positions so that the address 0xffffffff
    // is adjusted to accomodate the length.  eg: if the new value is
    // 0xffffff00, the device requires 256 bytes.
    //
    // The difference between the original and new values is the length (-1).
    //
    // For example, if the value fead back from the BAR is 0xffff0000,
    // the length of this resource is
    //
    //     0xffffffff - 0xffff0000 + 1
    //   = 0x0000ffff + 1
    //   = 0x00010000
    //
    //  ie 16KB.
    //
    // Some devices cannot reside at the top of PCI address space.  These
    // devices will have adjusted the value such that length bytes are
    // accomodated below the highest address.  For example, if a device
    // must reside below 1MB, and occupies 256 bytes, the value will now
    // be 0x000fff00.
    //
    // In the first case, length can be calculated as-
    //

    Length = (0xffffffff - BaseAddressRegister) + 1;

    if (((Length - 1) & Length) != 0) {

        //
        // We didn't end up with a power of two, must be the latter
        // case, we will have to scan for it.
        //

        Length = 4;     // start with minimum possible

        while ((Length | BaseAddressRegister) != BaseAddressRegister) {

            //
            // Length *= 2, note we will eventually drop out of this
            // loop for one of two reasons (a) because we found the
            // length, or (b) because Length left shifted off the end
            // and became 0.
            //

            Length <<= 1;
        }
    }

    //
    // Check that we got something - if this is a 64bit bar then nothing is ok as
    // we might be asking for a range >= 4GB (not that that's going to work any time soon)
    //

    if (!((BaseAddressRegister & PCI_ADDRESS_MEMORY_TYPE_MASK) == PCI_TYPE_64BIT)) {
        PCI_ASSERT(Length);
    }

    return Length;
}

BOOLEAN
PciCreateIoDescriptorFromBarLimit(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    IN PULONG BaseAddress,
    IN BOOLEAN Rom
    )

/*++

Description:

    Generate an IO resource descriptor to describe the settings
    a Base Address Register can take.

Arguments:

    Descriptor -
    BaseAddress - Pointer to the value read from a base address register
                  immediately after writing all ones to it.
    Rom         - If true, this is a base address register for ROM.

Return Value:

    Returns TRUE if this address register was a 64 bit address register,
    FALSE otherwise.

--*/

{
    ULONG bar = *BaseAddress;
    ULONG length;
    ULONG addressMask;
    BOOLEAN returnValue = FALSE;

    //
    // If the Base Address Register contains zero after being written
    // with all ones, it is not implemented.  Set the resource type to
    // NULL, no further processing is required.
    //
    // Note: We ignore the I/O bit in the BAR due to HARDWARE BUGS
    // in some people's hardware.
    //

    if ((bar & ~1) == 0) {
        Descriptor->Type = CmResourceTypeNull;
        return FALSE;
    }

    //
    // Default to ordinary (32 bit) memory.
    //

    Descriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE;
    Descriptor->u.Memory.MaximumAddress.HighPart = 0;
    Descriptor->u.Memory.MinimumAddress.QuadPart = 0;

    if (Rom == TRUE) {

        //
        // Mask out unused bits and indicate in the descriptor that
        // this entry describes ROM.
        //

        bar &= PCI_ADDRESS_ROM_ADDRESS_MASK;
        Descriptor->Flags = CM_RESOURCE_MEMORY_READ_ONLY;
    }

    //
    // Ranges described by PCI Base Address Registers must be a
    // power of 2 in length and naturally aligned.  Get the length
    // and set the length and alignment in the descriptor.
    //

    length = PciGetLengthFromBar(bar);
    Descriptor->u.Generic.Length = length;
    Descriptor->u.Generic.Alignment = length;

    if ((bar & PCI_ADDRESS_IO_SPACE) != 0) {

        //
        // This BAR describes I/O space.
        //

        addressMask = PCI_ADDRESS_IO_ADDRESS_MASK;
        Descriptor->Type = CmResourceTypePort;
        Descriptor->Flags = CM_RESOURCE_PORT_IO;

    } else {

        //
        // This BAR describes PCI memory space.
        //

        addressMask = PCI_ADDRESS_MEMORY_ADDRESS_MASK;
        Descriptor->Type = CmResourceTypeMemory;

        if ((bar & PCI_ADDRESS_MEMORY_TYPE_MASK) == PCI_TYPE_64BIT) {

            //
            // This is a 64 bit PCI device.  Get the high 32 bits
            // from the next BAR.
            //

            Descriptor->u.Memory.MaximumAddress.HighPart = *(BaseAddress+1);
            returnValue = TRUE;

        } else if ((bar & PCI_ADDRESS_MEMORY_TYPE_MASK) == PCI_TYPE_20BIT) {

            //
            // This device must locate below 1MB, the BAR shouldn't
            // have any top bits set but this isn't clear from the
            // spec.  Enforce it by clearing the top bits.
            //

            addressMask &= 0x000fffff;
        }

        if (bar & PCI_ADDRESS_MEMORY_PREFETCHABLE) {
            Descriptor->Flags |= CM_RESOURCE_MEMORY_PREFETCHABLE;
        }
    }
    Descriptor->u.Generic.MaximumAddress.LowPart = bar & addressMask;
    Descriptor->u.Generic.MaximumAddress.QuadPart += (length - 1);

    return returnValue;
}

BOOLEAN
PciOpenKey(
    IN  PWSTR   KeyName,
    IN  HANDLE  ParentHandle,
    IN  ACCESS_MASK Access,
    OUT PHANDLE Handle,
    OUT PNTSTATUS Status
    )

/*++

Description:

    Open a registry key.

Arguments:

    KeyName      Name of the key to be opened.
    ParentHandle Pointer to the parent handle (OPTIONAL)
    Handle       Pointer to a handle to recieve the opened key.

Return Value:

    TRUE is key successfully opened, FALSE otherwise.

--*/

{
    UNICODE_STRING    nameString;
    OBJECT_ATTRIBUTES nameAttributes;
    NTSTATUS localStatus;

    PAGED_CODE();

    RtlInitUnicodeString(&nameString, KeyName);

    InitializeObjectAttributes(&nameAttributes,
                               &nameString,
                               OBJ_CASE_INSENSITIVE,
                               ParentHandle,
                               (PSECURITY_DESCRIPTOR)NULL
                               );
    localStatus = ZwOpenKey(Handle,
                            Access,
                            &nameAttributes
                            );

    if (Status != NULL) {

        //
        // Caller wants underlying status.
        //

        *Status = localStatus;
    }

    //
    // Return status converted to a boolean, TRUE if
    // successful.
    //

    return NT_SUCCESS(localStatus);
}

NTSTATUS
PciGetRegistryValue(
    IN  PWSTR   ValueName,
    IN  PWSTR   KeyName,
    IN  HANDLE  ParentHandle,
    IN  ULONG   Type, 
    OUT PVOID   *Buffer,
    OUT PULONG  Length
    )
{
    NTSTATUS status;
    HANDLE keyHandle = NULL;
    ULONG neededLength;
    ULONG actualLength;
    UNICODE_STRING unicodeValueName;
    PKEY_VALUE_PARTIAL_INFORMATION info = NULL;
    
    if (!PciOpenKey(KeyName, ParentHandle, KEY_READ, &keyHandle, &status)) {
        goto exit;
    }

    RtlInitUnicodeString(&unicodeValueName, ValueName);

    //
    // Find out how much memory we need for this.
    //

    status = ZwQueryValueKey(
                 keyHandle,
                 &unicodeValueName,
                 KeyValuePartialInformation,
                 NULL,
                 0,
                 &neededLength
                 );

    if (status != STATUS_BUFFER_TOO_SMALL) {

        //
        // Either the value doesn't exist or something else went wrong but this
        // should never succeed
        //

        ASSERT(!(NT_SUCCESS(status)));
        
        goto exit;
    }
        
    ASSERT(neededLength != 0);

    //
    // Get memory to return the data in.  Note this includes
    // a header that we really don't want.
    //

    info = ExAllocatePool(
               PagedPool | POOL_COLD_ALLOCATION,
               neededLength);

    if (info == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    //
    // Get the data.
    //

    status = ZwQueryValueKey(
             keyHandle,
             &unicodeValueName,
             KeyValuePartialInformation,
             info,
             neededLength,
             &actualLength
             );
    
    if (!NT_SUCCESS(status)) {
        goto exit;
    }

    //
    // Make sure the data is the correcty type
    //

    if (info->Type != Type) {
        status = STATUS_INVALID_PARAMETER;
        goto exit;
    }
    
    ASSERT(neededLength == actualLength);

    //
    // Subtract out the header size and get memory for just
    // the data we want.
    //

    neededLength -= FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);

    *Buffer = ExAllocatePool(
                  PagedPool | POOL_COLD_ALLOCATION,
                  neededLength
                  );
    
    if (*Buffer == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    //
    // Copy data sans header.
    //

    RtlCopyMemory(*Buffer, info->Data, neededLength);
    

    if (Length) {
        *Length = neededLength;
    }
    
exit:

    if (keyHandle) {
        ZwClose(keyHandle);
    }

    if (info) {
        ExFreePool(info);
    }
    
    return status;
}

NTSTATUS
PciGetDeviceCapabilities(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PDEVICE_CAPABILITIES    DeviceCapabilities
    )
/*++

Routine Description:

    This routine sends the get capabilities irp to the given stack

Arguments:

    DeviceObject        A device object in the stack whose capabilities we want
    DeviceCapabilites   Where to store the answer

Return Value:

    NTSTATUS

--*/
{
    IO_STATUS_BLOCK     ioStatus;
    KEVENT              pnpEvent;
    NTSTATUS            status;
    PDEVICE_OBJECT      targetObject;
    PIO_STACK_LOCATION  irpStack;
    PIRP                pnpIrp;

    PAGED_CODE();

    //
    // Initialize the capabilities that we will send down
    //
    RtlZeroMemory( DeviceCapabilities, sizeof(DEVICE_CAPABILITIES) );
    DeviceCapabilities->Size = sizeof(DEVICE_CAPABILITIES);
    DeviceCapabilities->Version = 1;
    DeviceCapabilities->Address = MAXULONG;
    DeviceCapabilities->UINumber = MAXULONG;

    //
    // Initialize the event
    //
    KeInitializeEvent( &pnpEvent, SynchronizationEvent, FALSE );

    //
    // Get the irp that we will send the request to
    //
    targetObject = IoGetAttachedDeviceReference( DeviceObject );

    //
    // Build an Irp
    //
    pnpIrp = IoBuildSynchronousFsdRequest(
        IRP_MJ_PNP,
        targetObject,
        NULL,
        0,
        NULL,
        &pnpEvent,
        &ioStatus
        );
    if (pnpIrp == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto PciGetDeviceCapabilitiesExit;

    }

    //
    // Pnp Irps all begin life as STATUS_NOT_SUPPORTED;
    //
    pnpIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    pnpIrp->IoStatus.Information = 0;

    //
    // Get the top of stack
    //
    irpStack = IoGetNextIrpStackLocation( pnpIrp );
    if (irpStack == NULL) {

        status = STATUS_INVALID_PARAMETER;
        goto PciGetDeviceCapabilitiesExit;

    }

    //
    // Set the top of stack
    //
    RtlZeroMemory( irpStack, sizeof(IO_STACK_LOCATION ) );
    irpStack->MajorFunction = IRP_MJ_PNP;
    irpStack->MinorFunction = IRP_MN_QUERY_CAPABILITIES;
    irpStack->Parameters.DeviceCapabilities.Capabilities = DeviceCapabilities;

    //
    // Make sure that there are no completion routines set
    //
    IoSetCompletionRoutine(
        pnpIrp,
        NULL,
        NULL,
        FALSE,
        FALSE,
        FALSE
        );

    //
    // Call the driver
    //
    status = IoCallDriver( targetObject, pnpIrp );
    if (status == STATUS_PENDING) {

        //
        // Block until the irp comes back
        //
        KeWaitForSingleObject(
            &pnpEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
        status = ioStatus.Status;

    }

PciGetDeviceCapabilitiesExit:
    //
    // Done with reference
    //
    ObDereferenceObject( targetObject );

    //
    // Done
    //
    return status;

}

ULONGLONG
PciGetHackFlags(
    IN USHORT VendorID,
    IN USHORT DeviceID,
    IN USHORT SubVendorID,
    IN USHORT SubSystemID,
    IN UCHAR  RevisionID
    )

/*++

Description:

    Look in the registry for any flags for this VendorId/DeviceId.

Arguments:

    VendorId      PCI Vendor ID (16 bits) of the manufacturer of the
                  device.

    DeviceId      PCI Device ID (16 bits) of the device.

    SubVendorID   PCI SubVendorID representing the manufacturer of the
                  subsystem

    SubSystemID   PCI SubSystemID representing subsystem

    RevisionID    PCI Revision denoting the revision of the device

Return Value:

    64 bit flags value or 0 if not found.

--*/

{
    PPCI_HACK_TABLE_ENTRY current;
    ULONGLONG hackFlags = 0;
    ULONG match, bestMatch = 0;
    PCI_ASSERT(PciHackTable);

    //
    // We want to do a best-case match:
    // VVVVDDDDSSSSssssRR
    // VVVVDDDDSSSSssss
    // VVVVDDDDRR
    // VVVVDDDD
    //
    // List is currently unsorted, so keep updating current best match.
    //

    for (current = PciHackTable; current->VendorID != 0xFFFF; current++) {
        match = 0;

        //
        // Must at least match vendor/dev
        //

        if ((current->DeviceID != DeviceID) ||
            (current->VendorID != VendorID)) {
            continue;
        }

        match = 1;

        //
        // If this entry specifies a revision, check that it is consistent.
        //

        if (current->Flags & PCI_HACK_FLAG_REVISION) {
            if (current->RevisionID == RevisionID) {
                match += 2;
            } else {
                continue;
            }
        }

        //
        // If this entry specifies subsystems, check that they are consistent
        //

        if (current->Flags & PCI_HACK_FLAG_SUBSYSTEM) {
            if (current->SubVendorID == SubVendorID &&
                current->SubSystemID == SubSystemID) {
                match += 4;
            } else {
                continue;
            }
        }

        if (match > bestMatch) {
            bestMatch = match;
            hackFlags = current->HackFlags;
        }
    }

    return hackFlags;
}

NTSTATUS
PciGetDeviceProperty(
    IN  PDEVICE_OBJECT PhysicalDeviceObject,
    IN  DEVICE_REGISTRY_PROPERTY DeviceProperty,
    OUT PVOID *PropertyBuffer
    )
{
    NTSTATUS status;
    NTSTATUS expected;
    ULONG length;
    ULONG length2;
    PVOID buffer;

    //
    // Two passes, first pass, find out what size buffer
    // is needed.
    //

    status = IoGetDeviceProperty(
                 PhysicalDeviceObject,
                 DeviceProperty,
                 0,
                 NULL,
                 &length
                 );

    expected = STATUS_BUFFER_TOO_SMALL;

    if (status == expected) {

        //
        // Good, now get a buffer.
        //

        buffer = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, length);

        if (buffer == NULL) {

            PciDebugPrint(
                PciDbgAlways,
                "PCI - Failed to allocate DeviceProperty buffer (%d bytes).\n",
                length
                );

            status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            //
            // This time, do it for real.
            //

            status = IoGetDeviceProperty(
                         PhysicalDeviceObject,
                         DeviceProperty,
                         length,
                         buffer,
                         &length2
                         );

            if (NT_SUCCESS(status)) {
                PCI_ASSERT(length == length2);

                //
                // Return the buffer containing the requested device
                // property to the caller.
                //

                *PropertyBuffer = buffer;
                return STATUS_SUCCESS;
            }
            expected = STATUS_SUCCESS;
        }
    }

    PciDebugPrint(
        PciDbgAlways,
        "PCI - Unexpected status from GetDeviceProperty, saw %08X, expected %08X.\n",
        status,
        expected
        );

    //
    // Clear the caller's buffer pointer, and, if the unexpected status
    // is success (from the first call to IoGetDeviceProperty) change it
    // to STATUS_UNSUCCESSFUL (N.B. This is if course impossible).
    //

    *PropertyBuffer = NULL;

    if (status == STATUS_SUCCESS) {
        PCI_ASSERTMSG("PCI Successfully did the impossible!", 0);
        status = STATUS_UNSUCCESSFUL;
    }
    return status;
}

NTSTATUS
PciRangeListFromResourceList(
    IN  PPCI_FDO_EXTENSION    FdoExtension,
    IN  PCM_RESOURCE_LIST ResourceList,
    IN  CM_RESOURCE_TYPE  DesiredType,
    IN  BOOLEAN           Complement,
    IN  PRTL_RANGE_LIST   ResultRange
    )

/*++

Description:

    Generates a range list for the resources of a given type
    from a resource list.

    Note: This routine supports only Memory or Io resources.

    Overlapping ranges in the incoming list will be combined.

Arguments:

    FdoExtension    Bus particulars.  NOTE: This is only needed for the
                    gross X86 hack for A0000 due to buggy MPS BIOS
                    implementations.  Otherwise this routine is more
                    generalized.
    ResourceList    Incoming CM Resource List.
    DesiredType     Type of resource to be included in the range list.
    Complement      Specifies wether or not the range list should be
                    the "complement" of the incoming data.
    ResultRange     Output range list.

Return Value:

    TRUE is key successfully opened, FALSE otherwise.

--*/

{

#define EXIT_IF_ERROR(status)                           \
    if (!NT_SUCCESS(status)) {                          \
        PCI_ASSERT(NT_SUCCESS(status));                     \
        goto exitPoint;                                 \
    }

#if DBG

#define ADD_RANGE(range, start, end, status)                       \
        PciDebugPrint(                                             \
        PciDbgObnoxious,                                           \
        "    Adding to RtlRange  %I64x thru %I64x\n",              \
        (ULONGLONG)start,                                          \
        (ULONGLONG)end                                             \
        );                                                         \
        status = RtlAddRange(range, start, end, 0, 0, NULL, NULL); \
        if (!NT_SUCCESS(status)) {                                 \
            PCI_ASSERT(NT_SUCCESS(status));                            \
            goto exitPoint;                                        \
        }

#else

#define ADD_RANGE(range, start, end, status)                       \
        status = RtlAddRange(range, start, end, 0, 0, NULL, NULL); \
        if (!NT_SUCCESS(status)) {                                 \
            PCI_ASSERT(NT_SUCCESS(status));                            \
            goto exitPoint;                                        \
        }

#endif

    NTSTATUS                        status;
    ULONG                           elementCount;
    ULONG                           count;
    ULONG                           numlists;
    PCM_FULL_RESOURCE_DESCRIPTOR    full = NULL;
    PCM_PARTIAL_RESOURCE_LIST       partial = NULL;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor = NULL;

    typedef struct {
        LIST_ENTRY list;
        ULONGLONG  start;
        ULONGLONG  end;
        BOOLEAN    valid;
    } PCI_RANGE_LIST_ELEMENT, *PPCI_RANGE_LIST_ELEMENT;

    PPCI_RANGE_LIST_ELEMENT         elementBuffer;
    PPCI_RANGE_LIST_ELEMENT         upper;
    PPCI_RANGE_LIST_ELEMENT         lower = NULL;
    PPCI_RANGE_LIST_ELEMENT         current;
    ULONG                           allocatedElement;
    ULONGLONG                       start;
    ULONGLONG                       end;

#if defined(_X86_) && defined(PCI_NT50_BETA1_HACKS)

    //
    // BETA1_HACKS - Remove this when the problem is fixed.
    //
    // HACK HACK some MPS BIOS implementations don't report the
    // memory range 0xA0000 thru 0xBFFFF.  They should.  HACK
    // them into the memory list.  Gross.
    // Even grosser, assume this applies only to bus 0.
    //
    // The 400 hack is because some cards (Matrox MGA) want access
    // to the SYSTEM BIOS DATA area which is in memory at address
    // 0x400 thru 0x4ff.  It's not on the BUS so why are we making
    // it appear here?
    //
    // Note, there is TWO hacks here but we do both under the
    // exact same condition so we have only one boolean.  If the
    // two are seperated (or one removed) this needs to be split.
    //

    BOOLEAN doA0000Hack = (DesiredType == CmResourceTypeMemory) &&
                          (FdoExtension && (FdoExtension->BaseBus == 0));

#else

    
#endif

    PAGED_CODE();

    PCI_ASSERT((DesiredType == CmResourceTypeMemory) ||
           (DesiredType == CmResourceTypePort));

    //
    // First, get a count of the number of resources of the desired
    // type in the list.   This gives us the maximum number of entries
    // in the resulting list.
    //
    // Plus 1 in case we're complementing it.  2 actually, we start
    // with a beginning and end entry.
    //

    elementCount = 2;

    numlists = 0;
    if (ResourceList != NULL) {
        numlists = ResourceList->Count;
        full = ResourceList->List;
    }

    while (numlists--) {
        partial = &full->PartialResourceList;
        count   = partial->Count;
        descriptor = partial->PartialDescriptors;
        while (count--) {
            if (descriptor->Type == DesiredType) {
                if (DesiredType == CmResourceTypePort) {
                    if (descriptor->Flags & CM_RESOURCE_PORT_10_BIT_DECODE) {
                        elementCount += ((1 << 16) / (1 << 10)) - 1;
                    } else if (descriptor->Flags & CM_RESOURCE_PORT_12_BIT_DECODE) {
                        elementCount += ((1 << 16) / (1 << 12)) - 1;
                    }
                }
                elementCount++;
            }
            descriptor = PciNextPartialDescriptor(descriptor);
        }
        full = (PCM_FULL_RESOURCE_DESCRIPTOR)descriptor;
    }

    PciDebugPrint(
        PciDbgObnoxious,
        "PCI - PciRangeListFromResourceList processing %d elements.\n",
        elementCount - 2
        );

#if defined(_X86_) && defined(PCI_NT50_BETA1_HACKS)

    if (doA0000Hack) {
        elementCount += 3;  // one for A0000 hack, one for 400 hack. + 1 for 70
    }

#endif

    //
    // Allocate list entries and initialize the list.
    //

    elementBuffer = ExAllocatePool(
                        PagedPool | POOL_COLD_ALLOCATION,
                        elementCount * sizeof(PCI_RANGE_LIST_ELEMENT)
                        );

    if (elementBuffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Take the first two entries and set them to the absolute minimum
    // and absolute maximum possible values.   Everything else will
    // either end up between these or be combined with them.
    //
    // Setting the terminators this way should avoid us having to check
    // for end conditions.
    //

    allocatedElement = 2;
    current = &elementBuffer[1];

    // first element (list min terminator)

    elementBuffer[1].start = elementBuffer[1].end = 0;
    elementBuffer[1].list.Flink = &elementBuffer[0].list;
    elementBuffer[1].list.Blink = &elementBuffer[0].list;
    elementBuffer[1].valid = FALSE;

    // last element (list max terminator)

    elementBuffer[0].start = elementBuffer[0].end = MAXULONGLONG;
    elementBuffer[0].list.Flink = &elementBuffer[1].list;
    elementBuffer[0].list.Blink = &elementBuffer[1].list;
    elementBuffer[0].valid = FALSE;

#if defined(_X86_) && defined(PCI_NT50_BETA1_HACKS)

    if (doA0000Hack) {

        //
        // Hack in A0000 thru FFFFF by just adding an entry for it
        // to the otherwise empty list.
        //
        // Hack in 400 thru 4ff too.
        //

        PLIST_ENTRY minEntry = &elementBuffer[1].list;
        PLIST_ENTRY maxEntry = &elementBuffer[0].list;
        
        allocatedElement = 5;

        elementBuffer[2].start = 0x70;      // HACK Trident
        elementBuffer[2].end   = 0x70;
        elementBuffer[2].valid = TRUE;

        elementBuffer[3].start = 0x400;     // HACK Matrox MGA
        elementBuffer[3].end   = 0x4FF;
        elementBuffer[3].valid = TRUE;

        elementBuffer[4].start = 0xA0000;   // HACK broken MPS BIOS
        elementBuffer[4].end   = 0xBFFFF;
        elementBuffer[4].valid = TRUE;

        // set the flinks

        minEntry->Flink = &elementBuffer[2].list;
        elementBuffer[2].list.Flink = &elementBuffer[3].list;
        elementBuffer[3].list.Flink = &elementBuffer[4].list;
        elementBuffer[4].list.Flink = maxEntry;

        // set the blinks

        elementBuffer[2].list.Blink = minEntry;
        elementBuffer[3].list.Blink = &elementBuffer[2].list;
        elementBuffer[4].list.Blink = &elementBuffer[3].list;
        maxEntry->Blink = &elementBuffer[4].list;

#if DBG
        {
            PPCI_RANGE_LIST_ELEMENT tempElement;
    
            tempElement = CONTAINING_RECORD(
                              minEntry,
                              PCI_RANGE_LIST_ELEMENT,
                              list
                              );
    
            PciDebugPrint(
                PciDbgObnoxious,
                "    === PCI added default initial ranges ===\n"
                );
    
            do {
    
                //
                // Print this entry if it is valid.
                //
    
                if (tempElement->valid == TRUE) {
                    PciDebugPrint(
                        PciDbgObnoxious,
                        "    %I64x .. %I64x\n",
                        tempElement->start,
                        tempElement->end
                        );
                }
    
                //
                // Next entry.
                //
    
                if (tempElement->list.Flink == minEntry) {
                    break;
                }
                tempElement = CONTAINING_RECORD(
                                  tempElement->list.Flink,
                                  PCI_RANGE_LIST_ELEMENT,
                                  list
                                  );
            } while (TRUE);
    
            PciDebugPrint(
                PciDbgObnoxious,
                "    === end added default initial ranges ===\n"
                );
        }
#endif

    }

#endif

    //
    // Starting again at the beginning of the resource list, extract
    // the desired resources and insert them in our new list.
    //

    numlists = 0;
    if (ResourceList != NULL) {
        full = ResourceList->List;
        numlists = ResourceList->Count;
    }

    while (numlists--) {

        LIST_CONTEXT listContext;

        PcipInitializePartialListContext(
            &listContext,
            &full->PartialResourceList,
            DesiredType
            );

        while ((descriptor = PcipGetNextRangeFromList(&listContext)) != NULL) {


            PCI_ASSERT(descriptor->Type == DesiredType);

            //
            // insert this element into the list.
            //

            start = (ULONGLONG)descriptor->u.Generic.Start.QuadPart;
            end   = start - 1 + descriptor->u.Generic.Length;

            //
            // First find the element to the left of this one
            // (below it).
            //

            lower = current;

            //
            // Just in case we actually need to go right,...
            //

            while (start > lower->end) {

                lower = CONTAINING_RECORD(
                            lower->list.Flink,
                            PCI_RANGE_LIST_ELEMENT,
                            list
                            );
            }

            //
            // Search left.
            //

            while (start <= lower->end) {
                if (start >= lower->start) {
                    break;
                }

                //
                // Go left.
                //

                lower = CONTAINING_RECORD(
                            lower->list.Blink,
                            PCI_RANGE_LIST_ELEMENT,
                            list
                            );
            }

            //
            // Early out if the lower entry completely
            // covers the new entry.
            //

            if ((start >= lower->start) && (end <= lower->end)) {

                //
                // It does, just skip it.
                //

                PciDebugPrint(
                    PciDbgObnoxious,
                    "    -- (%I64x .. %I64x) swallows (%I64x .. %I64x)\n",
                    lower->start,
                    lower->end,
                    start,
                    end
                );

                current = lower;
                current->valid = TRUE;
                continue;
            }


            //
            // Then, the one above it.
            //

            upper = lower;

            while (end > upper->start) {
                if (end <= upper->end) {
                    break;
                }

                //
                // Go right.
                //

                upper = CONTAINING_RECORD(
                            upper->list.Flink,
                            PCI_RANGE_LIST_ELEMENT,
                            list
                            );
            }
            current = &elementBuffer[allocatedElement++];
            current->start = start;
            current->end   = end;
            current->valid = TRUE;

            PciDebugPrint(
                PciDbgObnoxious,
                "    (%I64x .. %I64x) <= (%I64x .. %I64x) <= (%I64x .. %I64x)\n",
                lower->start,
                lower->end,
                start,
                end,
                upper->start,
                upper->end
                );

            //
            // We now have, the element below this one, possibly
            // overlapping, the element above this one, possibly
            // overlapping, and a new one.
            //
            // The easiest way to deal with this is to create
            // the new entry, link it in, then unlink the overlaps
            // if they exist.
            //
            //
            // Note: The new entry may overlap several entries,
            // these are orphaned.
            //
            // Link it in.
            //

            current->list.Flink = &upper->list;
            current->list.Blink = &lower->list;
            upper->list.Blink = &current->list;
            lower->list.Flink = &current->list;

            //
            // Check for lower overlap.
            //

            if ((lower->valid == TRUE) && (start > 0)) {
                start--;
            }

            if (lower->end >= start) {

                //
                // Overlaps from below,...
                //
                // Merge lower into current.
                //

                current->start = lower->start;
                current->list.Blink = lower->list.Blink;

                //
                //
                // lower is being orphaned, reuse it to get to
                // our new lower neighbor.
                //

                lower = CONTAINING_RECORD(
                            lower->list.Blink,
                            PCI_RANGE_LIST_ELEMENT,
                            list
                            );
                lower->list.Flink = &current->list;

                PciDebugPrint(
                    PciDbgObnoxious,
                    "    -- Overlaps lower, merged to (%I64x .. %I64x)\n",
                    current->start,
                    current->end
                    );
            }

            //
            // Check for upper overlap.
            //

            if ((upper->valid == TRUE) && (end < MAXULONGLONG)) {
                end++;
            }
            if ((end >= upper->start) && (current != upper)) {

                //
                // Overlaps above,... merge upper into current.
                //

                current->end = upper->end;
                current->list.Flink = upper->list.Flink;

                //
                // upper is being orphaned, reuse it to get to
                // our new upper neighbor.
                //

                upper = CONTAINING_RECORD(
                            upper->list.Flink,
                            PCI_RANGE_LIST_ELEMENT,
                            list
                            );
                upper->list.Blink = &current->list;

                PciDebugPrint(
                    PciDbgObnoxious,
                    "    -- Overlaps upper, merged to (%I64x .. %I64x)\n",
                    current->start,
                    current->end
                    );
            }
        }
        full = (PCM_FULL_RESOURCE_DESCRIPTOR)listContext.Next;
    }

    //
    // Find the lowest value.
    //

    while (current->valid == TRUE) {

        lower = CONTAINING_RECORD(
                    current->list.Blink,
                    PCI_RANGE_LIST_ELEMENT,
                    list
                    );
        if ((lower->valid == FALSE) ||
            (lower->start > current->start)) {
            break;
        }
        current = lower;
    }

#if DBG

    lower = current;

    if (current->valid == FALSE) {
        PciDebugPrint(
            PciDbgObnoxious,
            "    ==== No ranges in results list. ====\n"
            );
    } else {

        PciDebugPrint(
            PciDbgObnoxious,
            "    === ranges ===\n"
            );

        do {
            if (current->valid == TRUE) {
                PciDebugPrint(
                    PciDbgObnoxious,
                    "    %I64x .. %I64x\n",
                    current->start,
                    current->end
                    );
            }

            //
            // Next entry.
            //
            current = CONTAINING_RECORD(
                          current->list.Flink,
                          PCI_RANGE_LIST_ELEMENT,
                          list
                          );

        } while (current != lower);
    }

#endif

    if (Complement == TRUE) {

        //
        // Invert the list.
        //
        // The generation of the list always results in the orphaning
        // of elementBuffer[1] (which was the original start point),
        // we can use that one for the first element of the new
        // inverted list.
        //

        if (current->valid == FALSE) {

            //
            // Empty list, complement it you get everything.
            //

            ADD_RANGE(ResultRange, 0, MAXULONGLONG, status);
        } else {

            //
            // If the original range doesn't start at zero we must
            // generate an entry from 0 to the start of that range.
            //

            if (current->start != 0) {
                ADD_RANGE(ResultRange, 0, current->start - 1, status);
            }

            //
            // Run the list greating range list entries for the
            // gaps between entries in this list.
            //

            do {
                PPCI_RANGE_LIST_ELEMENT next = CONTAINING_RECORD(
                                                   current->list.Flink,
                                                   PCI_RANGE_LIST_ELEMENT,
                                                   list
                                                   );
                if (current->valid == TRUE) {
                    start = current->end + 1;
                    end = next->start - 1;

                    if ((end < start) || (next == elementBuffer)) {
                        end = MAXULONGLONG;
                    }
                    ADD_RANGE(ResultRange, start, end, status);
                }

                //
                // Next entry.
                //
                current = next;

            } while (current != lower);
        }
    } else {

        //
        // Not complementing,... add a range for each member of the
        // list.
        //

        if (current->valid == TRUE) {
            do {
                ADD_RANGE(ResultRange, current->start, current->end, status);

                //
                // Next entry.
                //
                current = CONTAINING_RECORD(
                              current->list.Flink,
                              PCI_RANGE_LIST_ELEMENT,
                              list
                              );

            } while (current != lower);
        }
    }
    status = STATUS_SUCCESS;

exitPoint:

    ExFreePool(elementBuffer);
    return status;

#undef EXIT_IF_ERROR
}


UCHAR
PciReadDeviceCapability(
    IN     PPCI_PDO_EXTENSION PdoExtension,
    IN     UCHAR          Offset,
    IN     UCHAR          Id,
    IN OUT PVOID          Buffer,
    IN     ULONG          Length
    )

/*++

Description:

    Searches configuration space for the PCI Capabilities structure
    identified by Id.  Begins at offset Offset in PCI config space.

Arguments:

    PdoExtension    Pointer to the PDO Extension for this device.
    Offset          Offset into PCI config space to begin traversing
                    the capabilities list.
    Id              Capabilities ID.  (0 if want to match any).
    Buffer          Pointer to the buffer where the capabilities
                    structure is to be returned (includes capabilities
                    header).
    Length          Number of bytes wanted (must be at least large
                    enough to contain the header).

Return Value:

    Returns the Offset in PCI config space at which the capability
    was found or 0 if not found.

--*/

{
    PPCI_CAPABILITIES_HEADER capHeader;
    UCHAR       loopCount = 0;

    capHeader = (PPCI_CAPABILITIES_HEADER)Buffer;

    //
    // In case the caller is running the list, check if we got
    // handed the list end.
    //

    if (Offset == 0) {
        return 0;
    }

    ASSERT_PCI_PDO_EXTENSION(PdoExtension);

    PCI_ASSERT(PdoExtension->CapabilitiesPtr != 0);

    PCI_ASSERT(Buffer);

    PCI_ASSERT(Length >= sizeof(PCI_CAPABILITIES_HEADER));

    do {

        //
        // Catch case where the device has been powered off.   (Reads
        // from a powered off device return FF,... allowing also for
        // the case where the device is just broken).
        //

        if ((Offset < PCI_COMMON_HDR_LENGTH) ||
            ((Offset & 0x3) != 0)) {
            PCI_ASSERT((Offset >= PCI_COMMON_HDR_LENGTH) && ((Offset & 0x3) == 0));

            return 0;
        }

        PciReadDeviceConfig(
            PdoExtension,
            Buffer,
            Offset,
            sizeof(PCI_CAPABILITIES_HEADER)
            );

        //
        // Check if this capability is the one we want (or if we want
        // ALL capability structures).
        //
        // NOTE: Intel 21554 non-transparent P2P bridge has a VPD
        // capability that has the Chassis capability id.  Needs to be
        // handled here in the future. Maybe fixed in later revisions.
        //

        if ((capHeader->CapabilityID == Id) || (Id == 0)) {
            break;
        }

        Offset = capHeader->Next;

        //
        // One more check for broken h/w.   Make sure we're not
        // traversing a circular list.   A Capabilities header
        // cannot be in the common header and must be DWORD aligned
        // in config space so there can only be (256-64)/4 of them.
        //

        if (++loopCount > ((256-64)/4)) {

            PciDebugPrint(
                PciDbgAlways,
                "PCI device %p capabilities list is broken.\n",
                PdoExtension
                );
            return 0;
        }

    } while (Offset != 0);

    //
    // If we found a match and we haven't read all the data, get the
    // remainder.
    //

    if ((Offset != 0) && (Length > sizeof(PCI_CAPABILITIES_HEADER))) {

        if (Length > (sizeof(PCI_COMMON_CONFIG) - Offset)) {

            //
            // If we are too close to the end of config space to
            // return the amount of data the caller requested,
            // truncate.
            //
            // Worst case truncation will be to 4 bytes so no need
            // to check we have data to read (again).
            //

            PCI_ASSERT(Length <= (sizeof(PCI_COMMON_CONFIG) - Offset));

            Length = sizeof(PCI_COMMON_CONFIG) - Offset;
        }

        //
        // Read remainder.
        //

        Length -= sizeof(PCI_CAPABILITIES_HEADER);

        PciReadDeviceConfig(
            PdoExtension,
            capHeader + 1,
            Offset + sizeof(PCI_CAPABILITIES_HEADER),
            Length
            );
    }
    return Offset;
}

BOOLEAN
PciIsCriticalDeviceClass(
    IN UCHAR BaseClass,
    IN UCHAR SubClass
    )
/*++

Routine Description:

    Checks to see if a given class/subclass pair identifies a
    "critical" device class, that is, a class of devices that
    cannot be turned off at any time during boot (not to probe
    the BARs, etc) without risking a crash.
    
Arguments:

    BaseClass - the PCI class code to check.
    
    SubClass - the subclass within BaseClass to check.
    
Return Value:

    TRUE if the class/subclass pair is critical
    FALSE otherwise
    
--*/
{
    //
    // Interrupt controllers are critical system devices and
    // must be treated very specially.  They cannot be turned
    // off without stopping all traffic in the system, but
    // they can't be left alone either.
    //
    
    if ((BaseClass == PCI_CLASS_BASE_SYSTEM_DEV) &&
        (SubClass == PCI_SUBCLASS_SYS_INTERRUPT_CTLR)) {
        
        return TRUE;
    }

    // 
    // Video cards are critical because vga writes to the
    // video card during boot in parallel with PnP enumeration
    // of the video card.  It doesn't know if/when PnP tries
    // to turn off the card for enumeration.
    //
    
    if (BaseClass == PCI_CLASS_DISPLAY_CTLR) {
        
        return TRUE;
    }
    
    return FALSE;
}

BOOLEAN
PciCanDisableDecodes(
    IN PPCI_PDO_EXTENSION PdoExtension OPTIONAL,
    IN PPCI_COMMON_CONFIG Config OPTIONAL,
    IN ULONGLONG HackFlags,
    IN ULONG Flags
    )
// N.B. - not paged so we can power down at dispatch level
{
    UCHAR baseClass;
    UCHAR subClass;
    BOOLEAN canDisableVideoDecodes;

    canDisableVideoDecodes = (Flags & PCI_CAN_DISABLE_VIDEO_DECODES) == PCI_CAN_DISABLE_VIDEO_DECODES;

    if (ARGUMENT_PRESENT(PdoExtension)) {
        PCI_ASSERT(HackFlags == 0);
        HackFlags = PdoExtension->HackFlags;
        baseClass = PdoExtension->BaseClass;
        subClass = PdoExtension->SubClass;
    } else {
        PCI_ASSERT(ARGUMENT_PRESENT(Config));
        baseClass = Config->BaseClass;
        subClass = Config->SubClass;
    }

    if (HackFlags & PCI_HACK_PRESERVE_COMMAND) {

        //
        // Bad things happen if we touch this device's command
        // register, leave it alone.
        //

        return FALSE;
    }

    if (HackFlags & PCI_HACK_CB_SHARE_CMD_BITS) {

        //
        // This is a multifunction cardbus controller with a shared
        // command register.  Never turn of any of the functions because it has
        // the unfortunate side effect of turning of all of them!
        //
        // NTRAID #62672 - 4/25/2000 - andrewth
        // We should probably ensure that the windows for all functions
        // are closed on all functions before enabling any of them...
        //
        //

        return FALSE;
    }

    if (HackFlags & PCI_HACK_NO_DISABLE_DECODES) {

        //
        // If we disable the decodes on this device bad things happen
        //

        return FALSE;

    }

    //
    // If this is a video device then don't allow the decodes to be disabled unless
    // we are allowed to...
    //

    if ((baseClass == PCI_CLASS_DISPLAY_CTLR && subClass == PCI_SUBCLASS_VID_VGA_CTLR)
    ||  (baseClass == PCI_CLASS_PRE_20 && subClass == PCI_SUBCLASS_PRE_20_VGA)) {

        return canDisableVideoDecodes;

    }

    //
    // There are various things in the world we shouldn't turn off.
    // The system is quite possibly unable to recover if we do, so
    // don't (just pretend).
    //
    switch (baseClass) {
    case PCI_CLASS_BRIDGE_DEV:

        //
        // Bad things happen if we turn off the HOST bridge (the
        // system doesn't understand that this device, which is
        // on a PCI bus, is actually the parent of that PCI bus),
        // or ISA/EISA/MCA bridges under which are devices we still
        // need to have working but are legacy detected so not in
        // the heirachy in any way we understand.
        //

        if ((subClass == PCI_SUBCLASS_BR_ISA )  ||
            (subClass == PCI_SUBCLASS_BR_EISA)  ||
            (subClass == PCI_SUBCLASS_BR_MCA)   ||
            (subClass == PCI_SUBCLASS_BR_HOST)  ||
            (subClass == PCI_SUBCLASS_BR_OTHER)) {

            return FALSE;
        }

        //
        // We don't want to turn off bridges that might have the VGA card behind
        // then otherwise video stops working.  Seeing as we can't actually tell
        // where the VGA card is use the hint that if the bridge is passing VGA
        // ranges the video card is probably somewhere down there.
        //

        if (subClass == PCI_SUBCLASS_BR_PCI_TO_PCI
        ||  subClass == PCI_SUBCLASS_BR_CARDBUS) {

            BOOLEAN vgaBitSet;

            if (ARGUMENT_PRESENT(PdoExtension)) {
                vgaBitSet = PdoExtension->Dependent.type1.VgaBitSet;
            } else {
                vgaBitSet = (Config->u.type1.BridgeControl & PCI_ENABLE_BRIDGE_VGA) != 0;
            }

            if (vgaBitSet) {
                //
                // We can disable the video path if we are powering down the machine
                //
                return canDisableVideoDecodes;
            }
        }

        break;

    case PCI_CLASS_DISPLAY_CTLR:

        //
        // If a video driver fails to start, the device reverts back to being
        // VGA if it is the VGA device.   Don't disable the decodes on VGA
        // devices.
        //

        if (subClass == PCI_SUBCLASS_VID_VGA_CTLR) {
            //
            // We can disable the video path if we are powering down the machine
            //
            return canDisableVideoDecodes;
        }
        break;

    case PCI_CLASS_PRE_20:

        //
        // Same as above.
        //

        if (subClass == PCI_SUBCLASS_PRE_20_VGA) {
            //
            // We can disable the video path if we are powering down the machine
            //
            return canDisableVideoDecodes;
        }
        break;
    }

    //
    // NB - The check to see if this device is a critical device is done
    // AFTER the check to see if this device is the video device.  This
    // is done so that video devices, which are normally critical, can
    // be turned off when the caller specifies the PCI_CAN_DISABLE_VIDEO_DECODES
    // flag (eg when going into a sleep state)
    //
    if (HackFlags & PCI_HACK_CRITICAL_DEVICE) {
        
        //
        // This device performs a critical system function,
        // like processing interrupts.  Turning it off is
        // likely to cause the machine to crash.
        //
        return FALSE;
    }

    return TRUE;
}

VOID
PciDecodeEnable(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN BOOLEAN Enable,
    IN PUSHORT ExistingCommand OPTIONAL
    )
/*++

Description:

    Either sets the decodes to match the extension (misnomered Enable) or zeros
    the decodes entirely.

    N.B. - not paged so we can power down at dispatch level

Arguments:

    PdoExtension    Pointer to the PDO Extension for this device.
    Enable          If TRUE, decodes are set to match the extension (on or off).
                    If FALSE, decodes are disabled.
    ExistingCommand Optional saved command to prevent a reread of the config
                    space command field.

Return Value:

    Nothing.

--*/
{
    USHORT cmd;

    //
    // Can we disable it if so ordered?
    //
    if (!Enable && !PciCanDisableDecodes(PdoExtension, NULL, 0, 0)) {
        return;
    }

    if (PdoExtension->HackFlags & PCI_HACK_PRESERVE_COMMAND) {

        //
        // Bad things happen if we touch this device's command
        // register, leave it alone.
        //

        return;
    }

    if (ARGUMENT_PRESENT(ExistingCommand)) {

        //
        // The caller has supplied the current contents of the
        // device's config space.
        //

        cmd = *ExistingCommand;
    } else {

        //
        // Get the current command register from the device.
        //

        PciGetCommandRegister(PdoExtension, &cmd);
    }

    cmd &= ~(PCI_ENABLE_IO_SPACE |
             PCI_ENABLE_MEMORY_SPACE |
             PCI_ENABLE_BUS_MASTER);

    if (Enable) {

        //
        // Set enables
        //

        cmd |= PdoExtension->CommandEnables & (PCI_ENABLE_IO_SPACE
                                             | PCI_ENABLE_MEMORY_SPACE
                                             | PCI_ENABLE_BUS_MASTER);
    }

    //
    // Set the new command register into the device.
    //

    PciSetCommandRegister(PdoExtension, cmd);
}

NTSTATUS
PciExcludeRangesFromWindow(
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN PRTL_RANGE_LIST ArbiterRanges,
    IN PRTL_RANGE_LIST ExclusionRanges
    )
{

    NTSTATUS status;
    RTL_RANGE_LIST_ITERATOR iterator;
    PRTL_RANGE current;

    FOR_ALL_RANGES(ExclusionRanges, &iterator, current) {

        if (current->Owner == NULL
        &&  INTERSECT(current->Start, current->End, Start, End)) {

            status = RtlAddRange(ArbiterRanges,
                                 current->Start,
                                 current->End,
                                 0,
                                 RTL_RANGE_LIST_ADD_IF_CONFLICT,
                                 NULL,
                                 NULL // this range is not on the bus
                                 );

            if (!NT_SUCCESS(status)) {
                PCI_ASSERT(NT_SUCCESS(status));
                return status;
            }
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PciBuildDefaultExclusionLists(
    VOID
    )
{
    NTSTATUS status;
    ULONG windowBase;

    PCI_ASSERT(PciIsaBitExclusionList.Count == 0);
    PCI_ASSERT(PciVgaAndIsaBitExclusionList.Count == 0);

    RtlInitializeRangeList(&PciIsaBitExclusionList);
    RtlInitializeRangeList(&PciVgaAndIsaBitExclusionList);


    for (windowBase = 0; windowBase <= 0xFFFF; windowBase += 0x400) {

        //
        // Add the x100-x3ff range to the ISA list
        //

        status = RtlAddRange(&PciIsaBitExclusionList,
                             windowBase + 0x100,
                             windowBase + 0x3FF,
                             0,
                             RTL_RANGE_LIST_ADD_IF_CONFLICT,
                             NULL,
                             NULL // this range is not on the bus
                             );

        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

        //
        // Add the x100-x3af, x3bc-x3bf and x3e0-x3ff ranges to the VGA/ISA list
        //

        status = RtlAddRange(&PciVgaAndIsaBitExclusionList,
                             windowBase + 0x100,
                             windowBase + 0x3AF,
                             0,
                             RTL_RANGE_LIST_ADD_IF_CONFLICT,
                             NULL,
                             NULL // this range is not on the bus
                             );

        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }


        status = RtlAddRange(&PciVgaAndIsaBitExclusionList,
                             windowBase + 0x3BC,
                             windowBase + 0x3BF,
                             0,
                             RTL_RANGE_LIST_ADD_IF_CONFLICT,
                             NULL,
                             NULL // this range is not on the bus
                             );

        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

        status = RtlAddRange(&PciVgaAndIsaBitExclusionList,
                             windowBase + 0x3E0,
                             windowBase + 0x3FF,
                             0,
                             RTL_RANGE_LIST_ADD_IF_CONFLICT,
                             NULL,
                             NULL // this range is not on the bus
                             );

        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

    }

    return STATUS_SUCCESS;

cleanup:

    RtlFreeRangeList(&PciIsaBitExclusionList);
    RtlFreeRangeList(&PciVgaAndIsaBitExclusionList);

    return status;
}

NTSTATUS
PciSaveBiosConfig(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG Config
    )
/*++

Description:

    This saves the original configuration of a device in the registry

Arguments:

    PdoExtension    Pointer to the PDO Extension for this device.

    Config          The config space as the BIOS initialized it

Return Value:

    Status

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES attributes;
    UNICODE_STRING unicodeString;
    HANDLE deviceHandle, configHandle;
    WCHAR buffer[sizeof("DEV_xx&FUN_xx")];

    PAGED_CODE();

    status = IoOpenDeviceRegistryKey(PCI_PARENT_PDO(PdoExtension),
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_WRITE,
                                     &deviceHandle
                                     );



    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    PciConstStringToUnicodeString(&unicodeString, BIOS_CONFIG_KEY_NAME);

    InitializeObjectAttributes(&attributes,
                               &unicodeString,
                               OBJ_KERNEL_HANDLE,
                               deviceHandle,
                               NULL
                               );

    status = ZwCreateKey(&configHandle,
                         KEY_WRITE,
                         &attributes,
                         0,
                         NULL,
                         REG_OPTION_VOLATILE,
                         NULL
                         );

    ZwClose(deviceHandle);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    if (FAILED(StringCbPrintfW(buffer, 
                               sizeof(buffer), 
                               L"DEV_%02x&FUN_%02x",
                               PdoExtension->Slot.u.bits.DeviceNumber,
                               PdoExtension->Slot.u.bits.FunctionNumber
                               ))) {
        
        status = STATUS_INVALID_PARAMETER;
        goto cleanup;
    }
    

    RtlInitUnicodeString(&unicodeString, buffer);    

    status = ZwSetValueKey(configHandle,
                           &unicodeString,
                           0,
                           REG_BINARY,
                           Config,
                           PCI_COMMON_HDR_LENGTH
                           );

    ZwClose(configHandle);

    return status;

cleanup:

    return status;
}

NTSTATUS
PciGetBiosConfig(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG Config
    )
/*++

Description:

    This retrieves the original configuration of a device from the registry

Arguments:

    PdoExtension    Pointer to the PDO Extension for this device.

    Config          The config space as the BIOS initialized it

Return Value:

    Status

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES attributes;
    UNICODE_STRING unicodeString;
    HANDLE deviceHandle, configHandle;
    WCHAR buffer[sizeof("DEV_xx&FUN_xx")];
    CHAR returnBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + PCI_COMMON_HDR_LENGTH - 1];
    PKEY_VALUE_PARTIAL_INFORMATION info;
    ULONG resultLength;

    PAGED_CODE();

    status = IoOpenDeviceRegistryKey(PCI_PARENT_PDO(PdoExtension),
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_READ | KEY_WRITE,
                                     &deviceHandle
                                     );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    PciConstStringToUnicodeString(&unicodeString, BIOS_CONFIG_KEY_NAME);

    InitializeObjectAttributes(&attributes,
                               &unicodeString,
                               OBJ_KERNEL_HANDLE,
                               deviceHandle,
                               NULL
                               );

    status = ZwOpenKey(&configHandle,
                         KEY_READ,
                         &attributes
                         );

    ZwClose(deviceHandle);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }
    
    if (FAILED(StringCbPrintfW(buffer, 
                               sizeof(buffer), 
                               L"DEV_%02x&FUN_%02x",
                               PdoExtension->Slot.u.bits.DeviceNumber,
                               PdoExtension->Slot.u.bits.FunctionNumber
                               ))) {
        
        status = STATUS_INVALID_PARAMETER;
        goto cleanup;
    }

    RtlInitUnicodeString(&unicodeString, buffer);

    status = ZwQueryValueKey(configHandle,
                             &unicodeString,
                             KeyValuePartialInformation,
                             returnBuffer,
                             sizeof(returnBuffer),
                             &resultLength
                             );

    ZwClose(configHandle);

    if (NT_SUCCESS(status)) {

        info = (PKEY_VALUE_PARTIAL_INFORMATION) returnBuffer;

        PCI_ASSERT(info->DataLength == PCI_COMMON_HDR_LENGTH);

        RtlCopyMemory(Config, info->Data, PCI_COMMON_HDR_LENGTH);
    }

    return status;

cleanup:

    return status;
}

#if 0
BOOLEAN
PciPresenceCheck(
    IN PPCI_PDO_EXTENSION PdoExtension
    )
{
    UCHAR configSpaceBuffer[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG cardConfig = (PPCI_COMMON_CONFIG) configSpaceBuffer;

    PAGED_CODE();

    //
    // If the card is already missing, don't bother reexamining it.
    //
    if (PdoExtension->NotPresent) {

        return FALSE;
    }

    if (PciIsSameDevice(PdoExtension)) {

        //
        // Still here.
        //
        return TRUE;
    }

    //
    // Mark it not present, then tell the OS it's gone.
    //
    PdoExtension->NotPresent = 1;

    IoInvalidateDeviceState(PdoExtension->PhysicalDeviceObject);
    return FALSE;
}
#endif

BOOLEAN
PciStringToUSHORT(
    IN PWCHAR String,
    OUT PUSHORT Result
    )
/*++

Description:

    Takes a 4 character hexidecimal sting and converts it into a USHORT.

Arguments:

    String - the string

    Result - the USHORT

Return Value:

    TRUE is success, FASLE otherwise

--*/

{
    ULONG count;
    USHORT number = 0;
    PWCHAR current;

    current = String;

    for (count = 0; count < 4; count++) {

        number <<= 4;

        if (*current >= L'0' && *current <= L'9') {
            number |= *current - L'0';
        } else if (*current >= L'A' && *current <= L'F') {
            number |= *current + 10 - L'A';
        } else if (*current >= L'a' && *current <= L'f') {
            number |= *current + 10 - L'a';
        } else {
            return FALSE;
        }

        current++;
    }

    *Result = number;
    return TRUE;
}


NTSTATUS
PciSendIoctl(
    IN PDEVICE_OBJECT Device,
    IN ULONG IoctlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    )
/*++

Description:

    Builds and send an IOCTL to a device and return the results

Arguments:

    Device - a device on the device stack to receive the IOCTL - the
             irp is always sent to the top of the stack

    IoctlCode - the IOCTL to run

    InputBuffer - arguments to the IOCTL

    InputBufferLength - length in bytes of the InputBuffer

    OutputBuffer - data returned by the IOCTL

    OnputBufferLength - the size in bytes of the OutputBuffer

Return Value:

    Status

--*/
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;
    KEVENT event;
    PIRP irp;
    PDEVICE_OBJECT targetDevice = NULL;

    PAGED_CODE();

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    //
    // Get the top of the stack to send the IRP to
    //

    targetDevice = IoGetAttachedDeviceReference(Device);

    if (!targetDevice) {
        status = STATUS_INVALID_PARAMETER;
    goto exit;
    }

    //
    // Get Io to build the IRP for us
    //

    irp = IoBuildDeviceIoControlRequest(IoctlCode,
                                        targetDevice,
                                        InputBuffer,
                                        InputBufferLength,
                                        OutputBuffer,
                                        OutputBufferLength,
                                        FALSE, // InternalDeviceIoControl
                                        &event,
                                        &ioStatus
                                        );


    if (!irp) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    //
    // Send the IRP and wait for it to complete
    //

    status = IoCallDriver(targetDevice, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

exit:

    if (targetDevice) {
        ObDereferenceObject(targetDevice);
    }

    return status;

}

BOOLEAN
PciIsOnVGAPath(
    IN PPCI_PDO_EXTENSION Pdo
    )

/*++

Description:

    Guesses if we are on the VGA path or not!

Arguments:

    Pdo - The PDO for the device in question

Return Value:

    TRUE if we are on the VGA path, TRUE otherwise

--*/

{
    switch (Pdo->BaseClass) {

    case PCI_CLASS_BRIDGE_DEV:
        //
        // We don't want to turn off bridges that might have the VGA card behind
        // then otherwise video stops working.  Seeing as we can't actually tell
        // where the VGA card is use the hint that if the bridge is passing VGA
        // ranges the video card is probably somewhere down there.
        //

        if (Pdo->SubClass == PCI_SUBCLASS_BR_PCI_TO_PCI
        ||  Pdo->SubClass == PCI_SUBCLASS_BR_CARDBUS) {

            if (Pdo->Dependent.type1.VgaBitSet) {
                return TRUE;
            }
        }

        break;

    case PCI_CLASS_DISPLAY_CTLR:

        if (Pdo->SubClass == PCI_SUBCLASS_VID_VGA_CTLR) {
            return TRUE;
        }
        break;

    case PCI_CLASS_PRE_20:

        if (Pdo->SubClass == PCI_SUBCLASS_PRE_20_VGA) {
            return TRUE;
        }
        break;
    }

    return FALSE;
}

BOOLEAN
PciIsSlotPresentInParentMethod(
    IN PPCI_PDO_EXTENSION Pdo,
    IN ULONG Method
    )
/*++

Description:

    This function checks if the slot this device is in is present in a
    Method named package on the parent of this device.

Arguments:

    Pdo - The PDO extension for the device

    Method - The Parents method to examine

Return Value:

    TRUE if present, FALSE otherwise

--*/
{
    NTSTATUS status;
    ACPI_EVAL_INPUT_BUFFER input;
    PACPI_EVAL_OUTPUT_BUFFER output = NULL;
    ULONG count, adr;
    PACPI_METHOD_ARGUMENT argument;
    BOOLEAN result = FALSE;
    //
    // Allocate a buffer big enough for all possible slots
    //
    ULONG outputSize = sizeof(ACPI_EVAL_OUTPUT_BUFFER) + sizeof(ACPI_METHOD_ARGUMENT) * (PCI_MAX_DEVICES * PCI_MAX_FUNCTION);

    PAGED_CODE();

    output = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, outputSize);

    if (!output) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    RtlZeroMemory(&input, sizeof(ACPI_EVAL_INPUT_BUFFER));
    RtlZeroMemory(output, outputSize);

    //
    // Send a IOCTL to ACPI to request it to run the method on this device's
    // parent if the method it is present
    //

    input.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
    input.MethodNameAsUlong = Method;

    status = PciSendIoctl(PCI_PARENT_FDOX(Pdo)->PhysicalDeviceObject,
                          IOCTL_ACPI_EVAL_METHOD,
                          &input,
                          sizeof(ACPI_EVAL_INPUT_BUFFER),
                          output,
                          outputSize
                          );

    if (!NT_SUCCESS(status)) {
        goto exit;
    }

    //
    // Format my slot number as an _ADR style integer
    //

    adr = (Pdo->Slot.u.bits.DeviceNumber << 16) | Pdo->Slot.u.bits.FunctionNumber;

    for (count = 0; count < output->Count; count++) {

        //
        // Walking the arguments works like this because we are a package of
        // integers
        //

        argument = &output->Argument[count];

        if (argument->Type != ACPI_METHOD_ARGUMENT_INTEGER) {
            status = STATUS_INVALID_PARAMETER;
            goto exit;
        }

        if (argument->Argument == adr) {
            //
            // Jackpot!
            //

            result = TRUE;
            break;
        }
    }

exit:

    if (output) {
        ExFreePool(output);
    }

    return result;

}

BOOLEAN
PciIsDeviceOnDebugPath(
    IN PPCI_PDO_EXTENSION Pdo
    )
/*++

Description:

    This function checks if device is on the path to the debugging device

    NOTE: PDO is only partially initialized at this point. Take care to insure
          that fields touched here are valid.

Arguments:

    Pdo - The PDO extension for the device

Return Value:

    TRUE if on the debug path, FALSE otherwise

--*/

{
    NTSTATUS status;
    PPCI_DEBUG_PORT current;
    PCI_COMMON_HEADER header;
    PPCI_COMMON_CONFIG config = (PPCI_COMMON_CONFIG) &header;

    PAGED_CODE();

    PCI_ASSERT(PciDebugPortsCount <= MAX_DEBUGGING_DEVICES_SUPPORTED);

    //
    // We can't be on the debug path if we aren't using a PCI debug port!
    //
    if (PciDebugPortsCount == 0) {
        return FALSE;
    }

    RtlZeroMemory(&header, sizeof(header));

    //
    // If its a bridge check if one of its subordinate buses has the debugger
    // port on it
    //

    if (Pdo->HeaderType == PCI_BRIDGE_TYPE
    ||  Pdo->HeaderType == PCI_CARDBUS_BRIDGE_TYPE) {

        //
        // Use the configuration that the firmware left the device in
        //

        status = PciGetBiosConfig(Pdo, config);

        PCI_ASSERT(NT_SUCCESS(status));

        FOR_ALL_IN_ARRAY(PciDebugPorts, PciDebugPortsCount, current) {

            if (current->Bus >= config->u.type1.SecondaryBus
            &&  current->Bus <= config->u.type1.SubordinateBus
            &&  config->u.type1.SecondaryBus != 0
            &&  config->u.type1.SubordinateBus != 0) {
                return TRUE;
            }
        }

    } else {

        UCHAR parentBus;

        if (PCI_PDO_ON_ROOT(Pdo)) {

            parentBus = PCI_PARENT_FDOX(Pdo)->BaseBus;

        } else {

            //
            // Get the BIOS config of the parent so we can get its initial bus
            // number
            //

            status = PciGetBiosConfig(PCI_BRIDGE_PDO(PCI_PARENT_FDOX(Pdo)),
                                      config
                                      );

            PCI_ASSERT(NT_SUCCESS(status));

            if (config->u.type1.SecondaryBus == 0
            ||  config->u.type1.SubordinateBus == 0) {
                //
                // This is a bridge that wasn't configured by the firmware so this
                // child can't be on the debug path.
                //
                return FALSE;

            } else {

                parentBus = config->u.type1.SecondaryBus;
            }

        }

        //
        // Check if we are the device on the correct bus in the correct slot
        //

        FOR_ALL_IN_ARRAY(PciDebugPorts, PciDebugPortsCount, current) {


            if (current->Bus == parentBus
            &&  current->Slot.u.AsULONG == Pdo->Slot.u.AsULONG) {
                return TRUE;
            }
        }
    }

    return FALSE;
}

NTSTATUS
PciUpdateLegacyHardwareDescription(
    IN PPCI_FDO_EXTENSION Fdo
    )
{
    NTSTATUS status;
    HANDLE multifunctionHandle = NULL, indexHandle = NULL;
    WCHAR indexStringBuffer[10];
    UNICODE_STRING indexString, tempString, pciString;
    OBJECT_ATTRIBUTES attributes;
    UCHAR infoBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 50];
    PKEY_VALUE_PARTIAL_INFORMATION info = (PKEY_VALUE_PARTIAL_INFORMATION) infoBuffer;
    ULONG infoLength;
    ULONG disposition;
    CM_FULL_RESOURCE_DESCRIPTOR descriptor;
    PCM_FULL_RESOURCE_DESCRIPTOR full;
    CONFIGURATION_COMPONENT component;
    ULONG index;
    BOOLEAN createdNewKey = FALSE;

    if (!PciOpenKey(L"\\REGISTRY\\MACHINE\\HARDWARE\\DESCRIPTION\\System\\MultifunctionAdapter",
                    NULL,
                    KEY_READ | KEY_WRITE,
                    &multifunctionHandle,
                    &status)) {

        goto exit;
    }

    //
    // HKML\Hardware\Description\System\MultifunctionAdapter is structured as
    // a set of 0 base consecutive numbered keys.
    // Run through all the subkeys and check that we haven't already reported
    // this bus
    //

    RtlInitEmptyUnicodeString(&indexString, 
                              indexStringBuffer, 
                              sizeof(indexStringBuffer)
                              ); 

    for (index = 0;;index++) {

        status = RtlIntegerToUnicodeString(index, 10, &indexString);

        if (!NT_SUCCESS(status)) {
            goto exit;
        }

        InitializeObjectAttributes(&attributes,
                                   &indexString,
                                   OBJ_CASE_INSENSITIVE,
                                   multifunctionHandle,
                                   NULL
                                   );

        status = ZwCreateKey(&indexHandle,
                             KEY_READ | KEY_WRITE,
                             &attributes,
                             0,
                             NULL,
                             REG_OPTION_VOLATILE,
                             &disposition
                             );

        if (!NT_SUCCESS(status)) {
            goto exit;
        }

        //
        // As the keys are all consecutive then if we created this key we have
        // enumerated then all and we can get on with registering out data
        //

        if (disposition == REG_CREATED_NEW_KEY) {
            createdNewKey = TRUE;
            break;
        }

        PciConstStringToUnicodeString(&tempString, L"Identifier");

        status = ZwQueryValueKey(indexHandle,
                                 &tempString,
                                 KeyValuePartialInformation,
                                 info,
                                 sizeof(infoBuffer),
                                 &infoLength
                                 );

        if (NT_SUCCESS(status) && info->Type == REG_SZ) {

            //
            // Build counted strings of the REG_SZ which we assume has been 
            // NULL terminated and then compare knowing we can't overrun
            // as everything is counted.  If the string is longer than MAXUSHORT
            // we truncate it.
            //

            PciConstStringToUnicodeString(&pciString, L"PCI");

            tempString.Buffer = (PWSTR)&info->Data;
            tempString.MaximumLength = (USHORT)info->DataLength;
            tempString.Length = tempString.MaximumLength - sizeof(UNICODE_NULL);
            
            if (RtlEqualUnicodeString(&pciString, &tempString, FALSE)) {
                //
                // This is a PCI bus, now check if its our bus number
                //

                PciConstStringToUnicodeString(&tempString, L"Configuration Data");

                status = ZwQueryValueKey(indexHandle,
                                         &tempString,
                                         KeyValuePartialInformation,
                                         info,
                                         sizeof(infoBuffer),
                                         &infoLength
                                         );

                if (NT_SUCCESS(status)) {
                    if (info->Type == REG_FULL_RESOURCE_DESCRIPTOR) {

                        full = (PCM_FULL_RESOURCE_DESCRIPTOR) &info->Data;

                        PCI_ASSERT(full->InterfaceType == PCIBus);

                        if (full->BusNumber == Fdo->BaseBus) {

                            //
                            // We're already reported this so we don't need to
                            // do anything.
                            //

                            status = STATUS_SUCCESS;

                            //
                            // indexHandle will be closed by the exit path.
                            //
                            goto exit;

                        }
                    }
                }
            }
        }

        ZwClose(indexHandle);
        indexHandle = NULL;
    }

    //
    // if we created a new key then indexHandle is it
    //

    if (createdNewKey) {

        //
        // Fill in the Identifier entry.  This is a PCI bus.
        //

        PciConstStringToUnicodeString(&tempString, L"Identifier");

        status = ZwSetValueKey(indexHandle,
                               &tempString,
                               0,
                               REG_SZ,
                               L"PCI",
                               sizeof(L"PCI")
                               );

        if (!NT_SUCCESS(status)) {
            goto exit;
        }

        //
        // Fill in the Configuration Data entry.
        //
        // Note that the complete descriptor is not written to the registry just
        // enough data to indicate that this is an empty list (the first 16 bytes).
        // This is a bit gross but it is what happens on x86 machines today and
        // after all we're only doing this for backward compatibility.
        //

        RtlZeroMemory(&descriptor, sizeof(CM_FULL_RESOURCE_DESCRIPTOR));

        descriptor.InterfaceType = PCIBus;
        descriptor.BusNumber = Fdo->BaseBus;

        PciConstStringToUnicodeString(&tempString, L"Configuration Data");

        status = ZwSetValueKey(indexHandle,
                               &tempString,
                               0,
                               REG_FULL_RESOURCE_DESCRIPTOR,
                               &descriptor,
                               16
                               );

        if (!NT_SUCCESS(status)) {
            goto exit;
        }


        //
        // Fill in the Component Information entry.  This is the Flags, Revision, Version,
        // Key and AffinityMask members from the CONFIGURATION_COMPONENT structure.
        //
        // For PCI buses the affinity is set to all processors (0xFFFFFFFF) and
        // everything else is 0.
        //

        RtlZeroMemory(&component, sizeof(CONFIGURATION_COMPONENT));

        component.AffinityMask = 0xFFFFFFFF;

        PciConstStringToUnicodeString(&tempString, L"Component Information");

        status = ZwSetValueKey(indexHandle,
                               &tempString,
                               0,
                               REG_BINARY,
                               &component.Flags,
                               FIELD_OFFSET(CONFIGURATION_COMPONENT, ConfigurationDataLength) -
                                   FIELD_OFFSET(CONFIGURATION_COMPONENT, Flags)
                               );

        if (!NT_SUCCESS(status)) {
            goto exit;
        }

    }

    status = STATUS_SUCCESS;

exit:

    if (indexHandle) {

        //
        // If we are failing attempt to cleanup by deleting the key we tried
        // to create.
        //
        if (!NT_SUCCESS(status) && createdNewKey) {
            ZwDeleteKey(indexHandle);
        }

        ZwClose(indexHandle);
    }


    if (multifunctionHandle) {
        ZwClose(multifunctionHandle);
    }


    return status;

}

NTSTATUS
PciReadDeviceSpace(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN ULONG WhichSpace,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length,
    OUT PULONG LengthRead
    )

/*++

Routine Description:

    This function handles reading from PCI device spaces and is called for both 
    the IRP_MN_READ_CONFIG and the BUS_INTERFACE_STANDARD.GetBusData cases.

Arguments:

    PdoExtension - the PDO for the device we want to read from
    
    WhichSpace - what type of space we want to read - of the form PCI_WHICHSPACE_*

    Buffer - Supplies a pointer to where the data is to be returned

    Offset - Indicates the offset into the space where the reading should begin.

    Length - Indicates the count of bytes which should be read.
    
    LengthRead - Indicates the count of bytes which was actually read.

Return Value:

    Status

--*/

{
    // NOT PAGED
    
    NTSTATUS status;
    PVERIFIER_DATA verifierData;

    *LengthRead = 0;

    switch (WhichSpace) {

    default:
                               
        //
        // Many people hand in the wrong WhichSpace parameters slap them around if we are verifing...
        //

        verifierData = PciVerifierRetrieveFailureData(PCI_VERIFIER_INVALID_WHICHSPACE);
    
        PCI_ASSERT(verifierData);

        VfFailDeviceNode(
            PdoExtension->PhysicalDeviceObject,
            PCI_VERIFIER_DETECTED_VIOLATION,
            PCI_VERIFIER_INVALID_WHICHSPACE,
            verifierData->FailureClass,
            &verifierData->Flags,
            verifierData->FailureText,
            "%DevObj%Ulong",
            PdoExtension->PhysicalDeviceObject,
            WhichSpace
            );

        // fall through 

    case PCI_WHICHSPACE_CONFIG:

        status = PciExternalReadDeviceConfig(
                    PdoExtension,
                    Buffer,
                    Offset,
                    Length
                    );
        
        if(NT_SUCCESS(status)){
            *LengthRead = Length;
        }

        break;

    case PCI_WHICHSPACE_ROM:

        //
        // Read ROM.
        //

        *LengthRead = Length;

        status = PciReadRomImage(
                     PdoExtension,
                     WhichSpace,
                     Buffer,
                     Offset,
                     LengthRead
                     );
        break;
    }

    return status;
}


NTSTATUS
PciWriteDeviceSpace(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN ULONG WhichSpace,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length,
    OUT PULONG LengthWritten
    )

/*++

Routine Description:

    This function handles reading from PCI device spaces and is called for both 
    the IRP_MN_WRITE_CONFIG and the BUS_INTERFACE_STANDARD.SetBusData cases.

Arguments:

    PdoExtension - the PDO for the device we want to write to
    
    WhichSpace - what type of space we want to write - of the form PCI_WHICHSPACE_*

    Buffer - Supplies a pointer to where the data is to be written resides

    Offset - Indicates the offset into the space where the writing should begin.

    Length - Indicates the count of bytes which should be written.
    
    LengthWritten - Indicates the count of bytes which was actually written.

Return Value:

    Status

--*/

{
    NTSTATUS status;
    PVERIFIER_DATA verifierData;

    *LengthWritten = 0;

    switch (WhichSpace) {

    default:
                               
        //
        // Many people hand in the wrong WhichSpace parameters slap them around if we are verifing...
        //

        verifierData = PciVerifierRetrieveFailureData(PCI_VERIFIER_INVALID_WHICHSPACE);
    
        PCI_ASSERT(verifierData);

        VfFailDeviceNode(
            PdoExtension->PhysicalDeviceObject,
            PCI_VERIFIER_DETECTED_VIOLATION,
            PCI_VERIFIER_INVALID_WHICHSPACE,
            verifierData->FailureClass,
            &verifierData->Flags,
            verifierData->FailureText,
            "%DevObj%Ulong",
            PdoExtension->PhysicalDeviceObject,
            WhichSpace
            );
    
        // fall through 

    case PCI_WHICHSPACE_CONFIG:

        status = PciExternalWriteDeviceConfig(
                    PdoExtension,
                    Buffer,
                    Offset,
                    Length
                    );
        
        if( NT_SUCCESS(status)){
            *LengthWritten = Length;
        }

        break;

    case PCI_WHICHSPACE_ROM:

        //
        // You can't write ROM
        //

        PciDebugPrint(
            PciDbgAlways,
            "PCI (%08x) WRITE_CONFIG IRP for ROM, failing.\n",
            PdoExtension
            );
        
        status = STATUS_INVALID_DEVICE_REQUEST;
        *LengthWritten = 0;

        break;

    }

    return status;
}

BOOLEAN
PciIsSuiteVersion(
    IN USHORT Version
    )
/*++

Routine Description:

    This routine checks to see if the system is currently running the given
    product suite.
    
Arguments:
    
    Version - a USHORT representing the suite to check for.
    
Return Value:

    TRUE if the currently running system matches the suite.
    FALSE otherwise.
    
--*/
{
    OSVERSIONINFOEXW versionInfo;
    ULONGLONG conditionMask = 0;

    RtlZeroMemory(&versionInfo,sizeof(OSVERSIONINFOEX));
    versionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    versionInfo.wSuiteMask = Version;

    VER_SET_CONDITION(conditionMask, VER_SUITENAME, VER_AND);

    return NT_SUCCESS(RtlVerifyVersionInfo(&versionInfo, VER_SUITENAME, conditionMask));
}

BOOLEAN
PciIsDatacenter(
    )
/*++

Routine Description:

    This routine checks to see if the system is currently running the datacenter SKU.
    PciIsSuiteVersion is the supported system API to do this, but it does not work
    in text mode setup, when only a value under the setupdd registry key contains
    the information.  The setupdd key only exists in text mode setup, so if it doesn't
    exist, the normal API is used.
    
Return Value:

    TRUE if the system is currently running datacenter.
    FALSE otherwise.
    
--*/
{
    PVOID valueBuffer = NULL;
    ULONG valueLength = 0;
    ULONG suiteVersion;
    BOOLEAN returnValue = FALSE;

    //
    // Look for an unnamed value under CCS\Services\setupdd
    // If it exists, we are in text mode setup and need to get the information out of this
    // unnamed value.
    //
    if (NT_SUCCESS(PciGetRegistryValue(L"",
                                       L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\setupdd",
                                       NULL,
                                       REG_BINARY,
                                       &valueBuffer,
                                       &valueLength
                                       ))) {
        if (valueLength == 16) {
             
            //
            // The unnamed value is 4 DWORDs long, and the fourth is the Suite version.
            // 130 is the encoding for Datacenter.
            //
            suiteVersion = *((PULONG)valueBuffer + 3);
            if (suiteVersion == 130) {
                returnValue = TRUE;
            }
        }

        ExFreePool(valueBuffer);
        return returnValue;
        
    } else {

        //
        // Not in text mode setup.  The normal APIs will work.
        //
        return PciIsSuiteVersion(VER_SUITE_DATACENTER);
    }
}

ULONG_PTR
PciExecuteCriticalSystemRoutine(
    IN ULONG_PTR Context
    )
/*++

Routine Description:

    This routine is called in the context of KeIpiGenericCall, which
    executes it on all processors.  It is used to execute
    a critical routine which needs all processors synchronized, such
    as probing the BARs of a device that could not otherwise be turned off.
    Only one context parameter is allowed in this routine, so it must
    contain both the routine to execute and any context that routine
    requires.
    
    When this routine is entered, it is guaranteed that all processors will
    already have been targeted with an IPI, and will be running at IPI_LEVEL.
    All processors will either be running this routine, or will be about to
    enter the routine.  No arbitrary threads can possibly be running.  No
    devices can interrupt the execution of this routine, since IPI_LEVEL is
    above all device IRQLs.
    
    Because this routine runs at IPI_LEVEL, no debug prints, asserts or other 
    debugging can occur in this function without hanging MP machines.
    
Arguments:

    Context - the context passed into the call to KeIpiGenericCall.
        It contains the critical routine to execute, any context required
        in that routine and a gate and a barrier to ensure that the critical routine
        is executed on only one processor, even though this function is
        executed on all processors.                                                                   
    
Return Value:

    VOID
    
--*/
{
    PPCI_CRITICAL_ROUTINE_CONTEXT routineContext = (PPCI_CRITICAL_ROUTINE_CONTEXT)Context;

    //
    // The Gate parameter in the routineContext is preinitialized
    // to 1, meaning that the first processor to reach this point
    // in the routine will decrement it to 0, and succeed the if
    // statement.
    //
    if (InterlockedDecrement(&routineContext->Gate) == 0) { 

        //
        // This is only executed on one processor.
        //
        routineContext->Routine(routineContext->Extension,
                                routineContext->Context
                                );

        //
        // Free other processors.
        //
        routineContext->Barrier = 0;
 
    } else {
 
        //
        // Wait for gated function to complete.
        // 
        do {
        } while (routineContext->Barrier != 0);
    }

    return (ULONG_PTR)0;
}

BOOLEAN
PciUnicodeStringStrStr(
    IN PUNICODE_STRING SearchString,
    IN PUNICODE_STRING SubString,
    IN BOOLEAN CaseInsensitive
    )

/*++

Routine Description:

    This routine is a counted string version of strstr and searchs for any 
    instance of SubString within SearchString.
    
Arguments:

    SearchString - String to search within
    
    SubString - String to search for
    
    CaseInsensitive - If TRUE indicates that a the comparison should be case
        insensitive
    
Return Value:

    TRUE if SubString is contained within SearchString, FALSE otherwise.
    
--*/

{
    USHORT searchIndex, searchCount, subCount;
    UNICODE_STRING currentSearchString;

    searchCount = SearchString->Length / sizeof(WCHAR);
    subCount = SubString->Length / sizeof(WCHAR);
    
    currentSearchString.Buffer = SearchString->Buffer;
    currentSearchString.MaximumLength = SearchString->MaximumLength;
    
    //
    // Set the length of the potential match string to the same length as 
    // SubString so we can use RtlEqualUnicodeString to compare them.
    //

    currentSearchString.Length = SubString->Length;

    //
    // Iterate through the search string until we are less than searchCount
    // characters from the end since the SubString can't possibly fit.
    //                             
                                   
    for (searchIndex = 0;
         searchIndex <= searchCount - subCount; 
         searchIndex++) {
    
        //
        // Now see if our substring is located at this position.
        //
                                                               
        if(RtlEqualUnicodeString(SubString, &currentSearchString, CaseInsensitive)) {

            return TRUE;
        }

        //
        // Advance one character in the currentSearchString and decrement maximum
        // length accordingly
        //
        
        currentSearchString.Buffer++;
        currentSearchString.MaximumLength -= sizeof(WCHAR);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\inc\sdbuslib.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    sdbuslib.h

Abstract:

    This is the include file that defines all constants and types for
    interfacing to the SD bus driver.

Author:

    Neil Sandlin

Revision History:

--*/

#ifndef _SDBUSLIBH_
#define _SDBUSLIBH_

#if _MSC_VER > 1000
#pragma once
#endif



NTSTATUS
SdBusSendIoctl(
    IN ULONG  IoControlCode,
    IN PDEVICE_OBJECT  DeviceObject,
    IN PVOID  InputBuffer  OPTIONAL,
    IN ULONG  InputBufferLength,
    OUT PVOID  OutputBuffer  OPTIONAL,
    IN ULONG  OutputBufferLength
    );


//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define IOCTL_SDBUS_BASE                 FILE_DEVICE_CONTROLLER

#define DD_SDBUS_DEVICE_NAME "\\\\.\\Sdbus"


//
// IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_SD_READ_BLOCK             CTL_CODE(IOCTL_SDBUS_BASE, 3020, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SD_WRITE_BLOCK            CTL_CODE(IOCTL_SDBUS_BASE, 3021, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SD_GET_DEVICE_PARMS       CTL_CODE(IOCTL_SDBUS_BASE, 3022, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SD_INTERFACE_OPEN         CTL_CODE(IOCTL_SDBUS_BASE, 3023, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SD_IO_READ                CTL_CODE(IOCTL_SDBUS_BASE, 3024, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SD_IO_WRITE               CTL_CODE(IOCTL_SDBUS_BASE, 3025, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SD_ACKNOWLEDGE_CARD_IRQ   CTL_CODE(IOCTL_SDBUS_BASE, 3026, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SD_INTERFACE_CLOSE        CTL_CODE(IOCTL_SDBUS_BASE, 3027, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_SD_SUBMIT_REQUEST         CTL_CODE(IOCTL_SDBUS_BASE, 3028, METHOD_BUFFERED, FILE_ANY_ACCESS)


typedef struct _SDBUS_READ_PARAMETERS {
    USHORT Size;
    USHORT Version;
    
    PVOID Buffer;
    ULONG Length;
    ULONGLONG ByteOffset;
} SDBUS_READ_PARAMETERS, *PSDBUS_READ_PARAMETERS;


typedef struct _SDBUS_WRITE_PARAMETERS {
    USHORT Size;
    USHORT Version;
    
    PVOID Buffer;
    ULONG Length;
    ULONGLONG ByteOffset;
} SDBUS_WRITE_PARAMETERS, *PSDBUS_WRITE_PARAMETERS;


typedef struct _SDBUS_IO_READ_PARAMETERS {
    USHORT Size;
    USHORT Version;
    UCHAR CmdType;
    
    PVOID Buffer;
    ULONG Length;
    ULONG Offset;
} SDBUS_IO_READ_PARAMETERS, *PSDBUS_IO_READ_PARAMETERS;


typedef struct _SDBUS_IO_WRITE_PARAMETERS {
    USHORT Size;
    USHORT Version;
    UCHAR CmdType;
    
    PVOID Buffer;
    ULONG Length;
    ULONG Offset;
} SDBUS_IO_WRITE_PARAMETERS, *PSDBUS_IO_WRITE_PARAMETERS;





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\card.c ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    card.c

Abstract:

    This module contains code to handle SD card operations like identification
    and configuration.

Authors:

    Neil Sandlin (neilsa) 1-Jan-2002

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#include "pch.h"

//
// Internal References
//

VOID
SdbusReadCommonCIS(
    IN PFDO_EXTENSION FdoExtension,
    IN PSD_CARD_DATA CardData
    );

VOID
SdbusReadFunctionCIS(
    IN PFDO_EXTENSION FdoExtension,
    IN PSD_FUNCTION_DATA FunctionData
    );





NTSTATUS
SdbusGetCardConfigData(
    IN PFDO_EXTENSION FdoExtension,
    OUT PSD_CARD_DATA *pCardData
    )
    
/*++

Routine Description:

   This enumerates the IO card present in the given SDBUS controller,
   and updates the internal structures to reflect the new card state.


Arguments


Return value

   Status
--*/
{    
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    ULONG i;
    ULONG relativeAddr = FdoExtension->RelativeAddr;
    PSD_CARD_DATA cardData = NULL;
    ULONG responseBuffer[4];
    
    try{

        if ((FdoExtension->numFunctions!=0) || FdoExtension->memFunction) {
            PSD_FUNCTION_DATA functionData;

            DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x IO functions found=%d, memFunction=%s\n",
                                           FdoExtension->DeviceObject, FdoExtension->numFunctions,
                                           (FdoExtension->memFunction ? "TRUE" : "FALSE")));

            //
            // At this point, it would be good to verify if the previous enumeration matches
            // the present one. This hokey mechanism is just to get something working.
            // ISSUE: NEED TO IMPLEMENT: swapping SD cards while hibernated
            //


            cardData = ExAllocatePool(NonPagedPool, sizeof(SD_CARD_DATA));
            if (cardData == NULL) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                leave;
            }

            RtlZeroMemory(cardData, sizeof(SD_CARD_DATA));

            if (FdoExtension->memFunction) {
                PUCHAR pResponse, pTarget;
                UCHAR j;

                cardData->SdCid = FdoExtension->SdCid;
                cardData->SdCsd = FdoExtension->SdCsd;
                for (j=0; j<5; j++) {
                    UCHAR data = cardData->SdCid.ProductName[4-j];
                
                    if ((data <= ' ') || data > 0x7F) {
                        break;
                    }
                    cardData->ProductName[j] = data;
                }
            }

            if (FdoExtension->memFunction) {
                //
                // Read the SCR register
                //
                SdbusSendCmdSynchronous(FdoExtension, SDCMD_APP_CMD, SDCMD_RESP_1, relativeAddr, 0, NULL, 0);
                //ISSUE: How do I get the data?
                SdbusSendCmdSynchronous(FdoExtension, SDCMD_SEND_SCR, SDCMD_RESP_1, 0, SDCMDF_ACMD, NULL, 0);
            }                


            if (FdoExtension->numFunctions) {
                UCHAR function;

                (*(FdoExtension->FunctionBlock->SetFunctionType))(FdoExtension, SDBUS_FUNCTION_TYPE_IO);
                
                // This command seems to be needed to start reading tuples, but breaks memory
                // enumeration (gets bad Cid, Csd)... need to figure that out later, since that
                // would imply that a combo card wouldn't work.
                SdbusReadCommonCIS(FdoExtension, cardData);

                for (function=1; function<=FdoExtension->numFunctions; function++) {

                    functionData = ExAllocatePool(NonPagedPool, sizeof(SD_FUNCTION_DATA));

                    if (functionData == NULL) {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        leave;
                    }

                    RtlZeroMemory(functionData, sizeof(SD_FUNCTION_DATA));
                    functionData->Function = function;
                    SdbusReadFunctionCIS(FdoExtension, functionData);

                    functionData->Next = cardData->FunctionData;
                    cardData->FunctionData = functionData;
                }
            }

            status = STATUS_SUCCESS;


        }
    } finally {

        if (!NT_SUCCESS(status)) {
            SdbusCleanupCardData(cardData);
        } else {
            *pCardData = cardData;
        }
    }

    return status;
}





VOID
SdbusCleanupCardData(
    IN PSD_CARD_DATA CardData
    )
{
    PSD_FUNCTION_DATA functionData;
    PSD_FUNCTION_DATA nextFunctionData;

    if (CardData != NULL) {

        for (functionData = CardData->FunctionData; functionData != NULL; functionData = nextFunctionData) {
            nextFunctionData = functionData->Next;
            ExFreePool(functionData);
        }
        ExFreePool(CardData);
    }
}



UCHAR
SdbusReadCIAChar(
    IN PFDO_EXTENSION FdoExtension,
    IN ULONG ciaPtr
    )
{
    SD_RW_DIRECT_ARGUMENT argument;
    UCHAR response;

    argument.u.AsULONG = 0;    
    argument.u.bits.Address = ciaPtr;
    
    SdbusSendCmdSynchronous(FdoExtension,
                            SDCMD_IO_RW_DIRECT,
                            SDCMD_RESP_5,
                            argument.u.AsULONG,
                            0,
                            &response,
                            sizeof(UCHAR));

    return response;
}


VOID
SdbusWriteCIAChar(
    IN PFDO_EXTENSION FdoExtension,
    IN ULONG ciaPtr,
    IN UCHAR data
    )
{
    SD_RW_DIRECT_ARGUMENT argument;
    ULONG responseBuffer[4];

    argument.u.AsULONG = 0;    
    argument.u.bits.Address = ciaPtr;
    argument.u.bits.Data = data;
    argument.u.bits.WriteToDevice = 1;
    
    SdbusSendCmdSynchronous(FdoExtension,
                            SDCMD_IO_RW_DIRECT,
                            SDCMD_RESP_5,
                            argument.u.AsULONG,
                            0,
                            NULL,
                            0);

}


USHORT
SdbusReadCIAWord(
    IN PFDO_EXTENSION FdoExtension,
    IN ULONG ciaPtr
    )
{
    USHORT data;

    data = (USHORT) SdbusReadCIAChar(FdoExtension, ciaPtr+1) << 8;
    data |= (USHORT) SdbusReadCIAChar(FdoExtension, ciaPtr);
    return data;
}

ULONG
SdbusReadCIADword(
    IN PFDO_EXTENSION FdoExtension,
    IN ULONG ciaPtr
    )
{
    ULONG data;

    data = (ULONG) SdbusReadCIAChar(FdoExtension, ciaPtr+3) << 24;
    data |= (ULONG) SdbusReadCIAChar(FdoExtension, ciaPtr+2) << 16;
    data |= (ULONG) SdbusReadCIAChar(FdoExtension, ciaPtr+1) << 8;
    data |= (ULONG) SdbusReadCIAChar(FdoExtension, ciaPtr);
    return data;
}




VOID
SdbusReadCommonCIS(
    IN PFDO_EXTENSION FdoExtension,
    IN PSD_CARD_DATA CardData
    )
{

    UCHAR cmd, link;
    UCHAR i;
    ULONG tupleCount = 0;
    USHORT manfCode, manfInf;
    UCHAR funcId;
    UCHAR funcEType;
    ULONG cisPtr;
    ULONG index;
    ULONG endStr;
    UCHAR data;

    CardData->CardCapabilities = SdbusReadCIAChar(FdoExtension,8);

    //
    // Get the common cisptr from the CCCR
    //

    cisPtr = ((SdbusReadCIAChar(FdoExtension, SD_CCCR_CIS_POINTER+2) << 16) +
              (SdbusReadCIAChar(FdoExtension, SD_CCCR_CIS_POINTER+1) << 8) +
               SdbusReadCIAChar(FdoExtension, SD_CCCR_CIS_POINTER));

    DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x cisPtr=%.06x\n",
                                   FdoExtension->DeviceObject, cisPtr));

    cmd  = SdbusReadCIAChar(FdoExtension, cisPtr);
    link = SdbusReadCIAChar(FdoExtension, cisPtr+1);


    while((cmd != CISTPL_END) && (cmd != CISTPL_NULL)) {
        tupleCount++;

        DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x CIS %.06x cmd=%.02x link=%.02x\n",
                    FdoExtension->DeviceObject, cisPtr, cmd, link));

        switch(cmd) {

        case CISTPL_MANFID:
            if (link < 4) {
                DebugPrint((SDBUS_DEBUG_FAIL, "fdo %08x   CISTPL_MANFID invalid link %x\n",
                            FdoExtension->DeviceObject, link));
                return;
            }

            CardData->MfgId   = SdbusReadCIAWord(FdoExtension, cisPtr+2);
            CardData->MfgInfo = SdbusReadCIAWord(FdoExtension, cisPtr+4);

            DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x   CISTPL_MANFID code=%x, inf=%x\n",
                        FdoExtension->DeviceObject, CardData->MfgId, CardData->MfgInfo));
            break;


        case CISTPL_VERS_1:

            index = cisPtr+4;
            endStr = index + (link - 2);
            i = 0;
            
            data = SdbusReadCIAChar(FdoExtension, index++);
            while (data) {
                if (index > endStr) {
                    DebugPrint((SDBUS_DEBUG_FAIL, "fdo %08x   CISTPL_VERS_1 parse error\n",
                                FdoExtension->DeviceObject));
                    return;
                }
                
                if (data >= ' ' && data < 0x7F) {
                    CardData->MfgText[i++] = data;
                }                    
                data = SdbusReadCIAChar(FdoExtension, index++);
            }                
                
            CardData->MfgText[i] = 0;

            i = 0;            
            
            data = SdbusReadCIAChar(FdoExtension, index++);
            while (data) {
                if (index > endStr) {
                    DebugPrint((SDBUS_DEBUG_FAIL, "fdo %08x   CISTPL_VERS_1 parse error\n",
                                FdoExtension->DeviceObject));
                    return;
                }
                
                if (data >= ' ' && data < 0x7F) {
                    CardData->ProductText[i++] = data;
                }
                data = SdbusReadCIAChar(FdoExtension, index++);
            }                
                
            CardData->ProductText[i] = 0;
            

            DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x   CISTPL_VERS_1 %s %s\n",
                        FdoExtension->DeviceObject, CardData->MfgText, CardData->ProductText));
            break;


        case CISTPL_FUNCID:
            if (link != 2) {
                DebugPrint((SDBUS_DEBUG_FAIL, "fdo %08x   CISTPL_FUNCID invalid link %x\n",
                            FdoExtension->DeviceObject, link));
                return;
            }

            funcId = SdbusReadCIAChar(FdoExtension, cisPtr+2);

            if (funcId != 12) {
                DebugPrint((SDBUS_DEBUG_FAIL, "fdo %08x   CISTPL_FUNCID invalid id %x\n",
                            FdoExtension->DeviceObject, funcId));
                return;
            }
            break;


        case CISTPL_FUNCE:
            funcEType = SdbusReadCIAChar(FdoExtension, cisPtr+2);

            if (funcEType == 0) {
                USHORT blkSize;
                UCHAR tranSpeed;

                if (link != 4) {
                    DebugPrint((SDBUS_DEBUG_FAIL, "fdo %08x   CISTPL_FUNCE invalid type0 link %x\n",
                                FdoExtension->DeviceObject, link));
                    return;
                }

                blkSize = SdbusReadCIAWord(FdoExtension, cisPtr+3);
                tranSpeed = SdbusReadCIAChar(FdoExtension, cisPtr+5);

                DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x   CISTPL_FUNCE 0 blksize %04x transpeed %02x\n",
                            FdoExtension->DeviceObject, blkSize, tranSpeed));

            } else {
                DebugPrint((SDBUS_DEBUG_FAIL, "fdo %08x   CISTPL_FUNCE invalid funce type %x\n",
                            FdoExtension->DeviceObject, funcEType));
                return;
            }
            break;
        }

        cisPtr += link+2;

        cmd  = SdbusReadCIAChar(FdoExtension, cisPtr);
        link = SdbusReadCIAChar(FdoExtension, cisPtr+1);
    }


    DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x CIS %.06x cmd=%.02x link=%.02x EXITING %d tuples read\n",
                FdoExtension->DeviceObject, cisPtr, cmd, link, tupleCount));

}



VOID
SdbusReadFunctionCIS(
    IN PFDO_EXTENSION FdoExtension,
    IN PSD_FUNCTION_DATA FunctionData
    )
{
    UCHAR cmd, link;
    UCHAR i;
    ULONG tupleCount = 0;
    UCHAR funcId;
    UCHAR funcEType;
    ULONG fbrPtr = FunctionData->Function*0x100;
    ULONG cisPtr;
    BOOLEAN hasCsa;
    UCHAR data;

    data = SdbusReadCIAChar(FdoExtension, fbrPtr);

    FunctionData->IoDeviceInterface = data & 0xf;
    hasCsa = ((data & 0x40) != 0);


    cisPtr = ((SdbusReadCIAChar(FdoExtension, fbrPtr + SD_CCCR_CIS_POINTER + 2) << 16) +
              (SdbusReadCIAChar(FdoExtension, fbrPtr + SD_CCCR_CIS_POINTER + 1) << 8) +
               SdbusReadCIAChar(FdoExtension, fbrPtr + SD_CCCR_CIS_POINTER));


    DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x function %d cisPtr=%.06x interfaceCode=%d hasCsa=%s\n",
                                   FdoExtension->DeviceObject, FunctionData->Function, cisPtr, FunctionData->IoDeviceInterface,
                                   hasCsa ? "TRUE" : "FALSE"));

    if (!cisPtr || (cisPtr == 0xFFFFFF)) {
        return;
    }

    cmd  = SdbusReadCIAChar(FdoExtension, cisPtr);
    link = SdbusReadCIAChar(FdoExtension, cisPtr+1);


    while((cmd != CISTPL_END) && (cmd != CISTPL_NULL)) {
        tupleCount++;

        DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x CIS %.06x cmd=%.02x link=%.02x\n",
                    FdoExtension->DeviceObject, cisPtr, cmd, link));

        switch(cmd) {


        case CISTPL_FUNCID:
            if (link != 2) {
                DebugPrint((SDBUS_DEBUG_FAIL, "fdo %08x   CISTPL_FUNCID invalid link %x\n",
                            FdoExtension->DeviceObject, link));
                return;
            }

            funcId = SdbusReadCIAChar(FdoExtension, cisPtr+2);

            if (funcId != 12) {
                DebugPrint((SDBUS_DEBUG_FAIL, "fdo %08x   CISTPL_FUNCID invalid id %x\n",
                            FdoExtension->DeviceObject, funcId));
                return;
            }
            break;


        case CISTPL_FUNCE:
            funcEType = SdbusReadCIAChar(FdoExtension, cisPtr+2);

            if (funcEType == 1) {
                UCHAR fInfo, ioRev, csaProp, opMin, opAvg, opMax, sbMin, sbAvg, sbMax;
                USHORT blkSize, minBw, optBw;
                ULONG cardPsn, csaSize, ocr;

                if (link != 0x1C) {
                    DebugPrint((SDBUS_DEBUG_FAIL, "fdo %08x   CISTPL_FUNCE invalid type1 link %x\n",
                                FdoExtension->DeviceObject, link));
                    return;
                }

                fInfo = SdbusReadCIAChar(FdoExtension, cisPtr+3);
                ioRev = SdbusReadCIAChar(FdoExtension, cisPtr+4);

                cardPsn = SdbusReadCIADword(FdoExtension, cisPtr+5);
                csaSize = SdbusReadCIADword(FdoExtension, cisPtr+9);

                csaProp = SdbusReadCIAChar(FdoExtension, cisPtr+13);

                blkSize = SdbusReadCIAWord(FdoExtension, cisPtr+14);

                ocr     = SdbusReadCIADword(FdoExtension, cisPtr+16);

                opMin = SdbusReadCIAChar(FdoExtension, cisPtr+20);
                opAvg = SdbusReadCIAChar(FdoExtension, cisPtr+21);
                opMax = SdbusReadCIAChar(FdoExtension, cisPtr+22);

                sbMin = SdbusReadCIAChar(FdoExtension, cisPtr+23);
                sbAvg = SdbusReadCIAChar(FdoExtension, cisPtr+24);
                sbMax = SdbusReadCIAChar(FdoExtension, cisPtr+25);

                minBw = SdbusReadCIAWord(FdoExtension, cisPtr+26);
                optBw = SdbusReadCIAWord(FdoExtension, cisPtr+28);

                DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x   CISTPL_FUNCE 1\n",
                            FdoExtension->DeviceObject));

            } else {
                DebugPrint((SDBUS_DEBUG_FAIL, "fdo %08x   CISTPL_FUNCE invalid funce type %x\n",
                            FdoExtension->DeviceObject, funcEType));
                return;
            }
            break;
        }

        cisPtr += link+2;

        cmd  = SdbusReadCIAChar(FdoExtension, cisPtr);
        link = SdbusReadCIAChar(FdoExtension, cisPtr+1);
    }


    DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x CIS %.06x cmd=%.02x link=%.02x EXITING %d tuples read\n",
                FdoExtension->DeviceObject, cisPtr, cmd, link, tupleCount));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\lib\sdbus.c ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    sdbus.c

Abstract:

Author:

    Neil Sandlin (neilsa) 1-Jan-02

Environment:

    Kernel mode only.

--*/
#include <ntddk.h>
#if DBG
#include <stdarg.h>
#include <stdio.h>
#endif
#include "ntddsd.h"
#include "sdbuslib.h"

//
// Prototypes
//

NTSTATUS
SdbusIoctlCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT pdoIoCompletedEvent
    );

NTSTATUS
SdBusSendIoctl(
    IN ULONG  IoControlCode,
    IN PDEVICE_OBJECT  DeviceObject,
    IN PVOID  InputBuffer  OPTIONAL,
    IN ULONG  InputBufferLength,
    OUT PVOID  OutputBuffer  OPTIONAL,
    IN ULONG  OutputBufferLength
    );

NTSTATUS
SdbusRequestCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSDBUS_REQUEST_PACKET SdRp
    );

#if DBG

VOID
SdbusDebugPrint(
                PCCHAR DebugMessage,
                ...
                );
                
#define DebugPrint(X) SdbusDebugPrint X

BOOLEAN SdbusDebugEnabled = FALSE;
                
#else

#define DebugPrint(X)

#endif                

//
// External entry points
//


NTSTATUS
SdBusOpenInterface(
    IN PSDBUS_INTERFACE_DATA InterfaceData,
    IN PVOID *pContext
    )
{
    NTSTATUS status;
    PSDBUS_INTERFACE_DATA pIdataEntry;
    ULONG size = InterfaceData->Size;
    ULONG_PTR information;

    if (size > sizeof(SDBUS_INTERFACE_DATA)) {
        return STATUS_INVALID_PARAMETER;
    }
    
    status = SdBusSendIoctl(IOCTL_SD_INTERFACE_OPEN,
                            InterfaceData->TargetObject,
                            InterfaceData,
                            size,
                            &information,
                            sizeof(information));
                            
    if (!NT_SUCCESS(status)) {
        return status;
    }                            
    
    pIdataEntry = ExAllocatePool(NonPagedPool, sizeof(SDBUS_INTERFACE_DATA));
    
    if (pIdataEntry == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    RtlCopyMemory(pIdataEntry, InterfaceData, size);
    *pContext = pIdataEntry;    
    return STATUS_SUCCESS;    
}    
    


NTSTATUS
SdBusCloseInterface(
    IN PSDBUS_INTERFACE_DATA InterfaceData
    )
{
    if (InterfaceData) {
    
        SdBusSendIoctl(IOCTL_SD_INTERFACE_CLOSE,
                       InterfaceData->TargetObject,
                       NULL,
                       0, 
                       NULL,
                       0);
    
        ExFreePool(InterfaceData);
    }        
    return STATUS_SUCCESS;
}    
    


NTSTATUS
SdBusSubmitRequest(
    IN PSDBUS_INTERFACE_DATA InterfaceData,
    IN PSDBUS_REQUEST_PACKET SdRp
    )
{
    IO_STATUS_BLOCK statusBlock;
    NTSTATUS status;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    
    DebugPrint(("sdbuslib: Request - %08x %02x\n", SdRp, SdRp->Function));
    
    irp = IoAllocateIrp(InterfaceData->TargetObject->StackSize, FALSE);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    irpSp = IoGetNextIrpStackLocation(irp);    
    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    irpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(SDBUS_REQUEST_PACKET);
    irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_SD_SUBMIT_REQUEST;
    
    irp->AssociatedIrp.SystemBuffer = SdRp;
    irp->Flags = 0;
    irp->UserBuffer = NULL;
    irp->UserIosb = NULL;

    
    IoSetCompletionRoutine(irp,
                           SdbusRequestCompletion,
                           SdRp,
                           TRUE,
                           TRUE,
                           TRUE);                               
    
    status = IoCallDriver(InterfaceData->TargetObject, irp);
   
    DebugPrint(("sdbuslib: Request exiting status %08x \n", status));
    
    return status;

}    



NTSTATUS
SdbusRequestCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSDBUS_REQUEST_PACKET SdRp
    )
{
    NTSTATUS status = Irp->IoStatus.Status;
    ULONG_PTR information = Irp->IoStatus.Information;

    DebugPrint(("sdbuslib: Request Complete %08x\n", status));

    IoFreeIrp(Irp);

    SdRp->Status = status;
    SdRp->Information = information;
    (*(SdRp->CompletionRoutine))(SdRp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}   




VOID
SdBusReadWriteCompletion(
    IN PSDBUS_REQUEST_PACKET SdRp
    )
{
    KeSetEvent(SdRp->UserContext, IO_NO_INCREMENT, FALSE);
}    


NTSTATUS
SdBusReadMemory(
    IN PVOID           Context,
    IN ULONGLONG       Offset,
    IN PVOID           Buffer,
    IN ULONG           Length,
    IN ULONG          *LengthRead
    )
{
    NTSTATUS status;
    IN PSDBUS_REQUEST_PACKET SdRp;
    KEVENT event;
    
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    
    SdRp = ExAllocatePool(NonPagedPool, sizeof(SDBUS_REQUEST_PACKET));
    if (!SdRp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    RtlZeroMemory(SdRp, sizeof(SDBUS_REQUEST_PACKET));
    
    SdRp->Function = SDRP_READ_BLOCK;
    SdRp->Parameters.ReadBlock.ByteOffset = Offset;
    SdRp->Parameters.ReadBlock.Buffer = Buffer;
    SdRp->Parameters.ReadBlock.Length = Length;
    SdRp->CompletionRoutine = SdBusReadWriteCompletion;
    SdRp->UserContext = &event;
    
    status = SdBusSubmitRequest(Context, SdRp);
    
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = SdRp->Status;
    }
    
    if (NT_SUCCESS(status)) {
        *LengthRead = SdRp->Information;
    }
    
    ExFreePool(SdRp);
    
    return status;
}    



NTSTATUS
SdBusWriteMemory(
    IN PVOID           Context,
    IN ULONGLONG       Offset,
    IN PVOID           Buffer,
    IN ULONG           Length,
    IN ULONG          *LengthWritten
    )
{
    NTSTATUS status;
    IN PSDBUS_REQUEST_PACKET SdRp;
    KEVENT event;
    
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    
    SdRp = ExAllocatePool(NonPagedPool, sizeof(SDBUS_REQUEST_PACKET));
    if (!SdRp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    RtlZeroMemory(SdRp, sizeof(SDBUS_REQUEST_PACKET));
    
    SdRp->Function = SDRP_WRITE_BLOCK;
    SdRp->Parameters.WriteBlock.ByteOffset = Offset;
    SdRp->Parameters.WriteBlock.Buffer = Buffer;
    SdRp->Parameters.WriteBlock.Length = Length;
    SdRp->CompletionRoutine = SdBusReadWriteCompletion;
    SdRp->UserContext = &event;
    
    status = SdBusSubmitRequest(Context, SdRp);
    
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = SdRp->Status;
    }
    
    if (NT_SUCCESS(status)) {
        *LengthWritten = SdRp->Information;
    }
    
    ExFreePool(SdRp);
    
    return status;
}
    



NTSTATUS
SdBusReadIo(
    IN PVOID           Context,
    IN UCHAR           CmdType,
    IN ULONG           Offset,
    IN PVOID           Buffer,
    IN ULONG           Length,
    IN ULONG          *LengthRead
    )
{

    NTSTATUS status;
    IN PSDBUS_REQUEST_PACKET SdRp;
    KEVENT event;
    
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    
    SdRp = ExAllocatePool(NonPagedPool, sizeof(SDBUS_REQUEST_PACKET));
    if (!SdRp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    RtlZeroMemory(SdRp, sizeof(SDBUS_REQUEST_PACKET));
    
    if (CmdType == 52) {
    
        SdRp->Function = SDRP_READ_IO;
        SdRp->Parameters.ReadIo.Offset = Offset;
        SdRp->Parameters.ReadIo.Buffer = Buffer;
    
    } else {
        SdRp->Function = SDRP_READ_IO_EXTENDED;
        SdRp->Parameters.ReadIoExtended.Offset = Offset;
        SdRp->Parameters.ReadIoExtended.Buffer = Buffer;
        SdRp->Parameters.ReadIoExtended.Length = Length;
    }
    
    SdRp->CompletionRoutine = SdBusReadWriteCompletion;
    SdRp->UserContext = &event;
    
    status = SdBusSubmitRequest(Context, SdRp);
    
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = SdRp->Status;
    }
    
    if (NT_SUCCESS(status)) {
        *LengthRead = SdRp->Information;
    }
    
    ExFreePool(SdRp);

    return status;
}    



NTSTATUS
SdBusWriteIo(
    IN PVOID           Context,
    IN UCHAR           CmdType,
    IN ULONG           Offset,
    IN PVOID           Buffer,
    IN ULONG           Length,
    IN ULONG          *LengthWritten
    )
{

    NTSTATUS status;
    IN PSDBUS_REQUEST_PACKET SdRp;
    KEVENT event;
    
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    
    SdRp = ExAllocatePool(NonPagedPool, sizeof(SDBUS_REQUEST_PACKET));
    if (!SdRp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    RtlZeroMemory(SdRp, sizeof(SDBUS_REQUEST_PACKET));
    
    if (CmdType == 52) {
    
        SdRp->Function = SDRP_WRITE_IO;
        SdRp->Parameters.WriteIo.Offset = Offset;
        SdRp->Parameters.WriteIo.Data = *(PUCHAR)Buffer;
    
    } else {
        SdRp->Function = SDRP_WRITE_IO_EXTENDED;
        SdRp->Parameters.WriteIoExtended.Offset = Offset;
        SdRp->Parameters.WriteIoExtended.Buffer = Buffer;
        SdRp->Parameters.WriteIoExtended.Length = Length;
    }

    SdRp->CompletionRoutine = SdBusReadWriteCompletion;
    SdRp->UserContext = &event;
    
    status = SdBusSubmitRequest(Context, SdRp);
    
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = SdRp->Status;
    }
    
    if (NT_SUCCESS(status)) {
        *LengthWritten = SdRp->Information;
    }
    
    ExFreePool(SdRp);
    
    return status;
}    



NTSTATUS
SdBusAcknowledgeCardInterrupt(
    IN PSDBUS_INTERFACE_DATA InterfaceData
    )
{
    NTSTATUS status;

    status = SdBusSendIoctl(IOCTL_SD_ACKNOWLEDGE_CARD_IRQ,
                            InterfaceData->TargetObject,
                            NULL,
                            0, 
                            NULL,
                            0);

    return status;
}



NTSTATUS
SdBusGetDeviceParameters(
    IN PSDBUS_INTERFACE_DATA InterfaceData,
    IN PSDBUS_DEVICE_PARAMETERS pDeviceParameters,
    IN ULONG Length
    )
{
    NTSTATUS status;

    status = SdBusSendIoctl(IOCTL_SD_GET_DEVICE_PARMS,
                            InterfaceData->TargetObject,
                            NULL,
                            0, 
                            pDeviceParameters,
                            Length);

    return status;
}    

//
// Internal routines
//



NTSTATUS
SdBusSendIoctl(
    IN ULONG  IoControlCode,
    IN PDEVICE_OBJECT  DeviceObject,
    IN PVOID  InputBuffer  OPTIONAL,
    IN ULONG  InputBufferLength,
    OUT PVOID  OutputBuffer  OPTIONAL,
    IN ULONG  OutputBufferLength
    )
{
    KEVENT event;
    IO_STATUS_BLOCK statusBlock;
    NTSTATUS status;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    
    DebugPrint(("SEND - %08x %08x %08x %08x %08x\n", IoControlCode,
                 InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength));
    
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    
    irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    irpSp = IoGetNextIrpStackLocation(irp);    
    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;

    irpSp->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferLength;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = InputBufferLength;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IoControlCode;    
    
    if (InputBufferLength != 0 || OutputBufferLength != 0) {
        irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithTag( NonPagedPoolCacheAligned,
                                                                 InputBufferLength > OutputBufferLength ? InputBufferLength : OutputBufferLength,
                                                                 '  oI' );
        if (irp->AssociatedIrp.SystemBuffer == NULL) {
            IoFreeIrp( irp );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        if (ARGUMENT_PRESENT( InputBuffer )) {
            RtlCopyMemory( irp->AssociatedIrp.SystemBuffer,
                           InputBuffer,
                           InputBufferLength );
        }
        irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
        irp->UserBuffer = OutputBuffer;
        if (ARGUMENT_PRESENT( OutputBuffer )) {
            irp->Flags |= IRP_INPUT_OPERATION;
        }
    } else {
        irp->Flags = 0;
        irp->UserBuffer = (PVOID) NULL;
    }

    irp->UserIosb = &statusBlock;

    IoSetCompletionRoutine(irp,
                           SdbusIoctlCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);                               
    
    status = IoCallDriver(DeviceObject, irp);
   
    if (status == STATUS_PENDING) {
        DebugPrint(("SEND - %08x wait on event %08x \n", IoControlCode, &event));
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = statusBlock.Status;
    }

    DebugPrint(("SEND - %08x exiting status %08x \n", IoControlCode, status));
    
    return status;
}



NTSTATUS
SdbusIoctlCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT pdoIoCompletedEvent
    )
{

    DebugPrint(("SEND - on event %08x Complete %08x\n", pdoIoCompletedEvent, Irp->IoStatus.Status));
    
    if (NT_SUCCESS(Irp->IoStatus.Status) &&
        (Irp->IoStatus.Information != 0) &&
        (Irp->UserBuffer)) {
        
        RtlCopyMemory( Irp->UserBuffer,
                       Irp->AssociatedIrp.SystemBuffer,
                       Irp->IoStatus.Information);
    }

    if (Irp->AssociatedIrp.SystemBuffer) {
        ExFreePool (Irp->AssociatedIrp.SystemBuffer);
    }
    Irp->UserIosb->Status = Irp->IoStatus.Status;
    IoFreeIrp(Irp);

    KeSetEvent(pdoIoCompletedEvent, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}   



#if DBG
VOID
SdbusDebugPrint(
                PCCHAR DebugMessage,
                ...
                )

/*++

Routine Description:

    Debug print for the SDBUS enabler.

Arguments:

    Check the mask value to see if the debug message is requested.

Return Value:

    None

--*/

{
    va_list ap;
    char    buffer[256];

    if (SdbusDebugEnabled) {
        va_start(ap, DebugMessage);
        
        sprintf(buffer, "%s ", "Sdbuslib:");
       
        vsprintf(&buffer[strlen(buffer)], DebugMessage, ap);
        
        DbgPrint(buffer);
       
        va_end(ap);
    }

} // end SdbusDebugPrint()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\activate.c ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    activate.c

Abstract:

    This module contains code to prepare an SD card in a given
    slot for use. This is done when the host is started, after
    device insertions, and after a power up transition.

Authors:

    Neil Sandlin (neilsa) Jan 1, 2002

Environment:

    Kernel mode only

Notes:

Revision History:


--*/

#include "pch.h"

//
// Internal References
//



VOID
SdbusActivatePowerUpComplete(
    IN PSD_WORK_PACKET WorkPacket,
    IN NTSTATUS status
    );
    
VOID
SdbusActivateIdentifyPhase1Complete(
    IN PSD_WORK_PACKET WorkPacket,
    IN NTSTATUS status
    );

VOID
SdbusActivateIdentifyPhase2Complete(
    IN PSD_WORK_PACKET WorkPacket,
    IN NTSTATUS status
    );
   
VOID
SdbusActivateInitializeCardComplete(
    IN PSD_WORK_PACKET WorkPacket,
    IN NTSTATUS status
    );

//
//
//   


VOID
SdbusActivateSocket(
    IN PDEVICE_OBJECT Fdo,
    IN PSDBUS_ACTIVATE_COMPLETION_ROUTINE CompletionRoutine,
    IN PVOID Context
    )
/*++

Routine Description:


Arguments:

    Fdo - Pointer to the device object for the host controller

Return Value:


--*/    
{
    NTSTATUS status;
    PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PSD_WORK_PACKET workPacket1 = NULL, workPacket2 = NULL, workPacket3 = NULL, workPacket4 = NULL;
    BOOLEAN cardInSlot;
    BOOLEAN callCompletion;
    PSD_ACTIVATE_CONTEXT activateContext;
    
    DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x activate socket START\n", Fdo));

    activateContext = ExAllocatePool(NonPagedPool, sizeof(SD_ACTIVATE_CONTEXT));

    if (!activateContext) {
        ASSERT(activateContext != NULL);
        return;
    }

    activateContext->CompletionRoutine = CompletionRoutine;
    activateContext->Context = Context;

    try{

        cardInSlot = (*(fdoExtension->FunctionBlock->DetectCardInSocket))(fdoExtension);
       
        if (!cardInSlot) {
        
            if (fdoExtension->SocketState != SOCKET_EMPTY) {
                IoInvalidateDeviceRelations(fdoExtension->Pdo, BusRelations);
            }
            //ISSUE: implement synchronization
            fdoExtension->SocketState = SOCKET_EMPTY;
            
            callCompletion = TRUE;
            status = STATUS_SUCCESS;
            leave;
        }    
       
        fdoExtension->SocketState = CARD_DETECTED;
        
        status = SdbusBuildWorkPacket(fdoExtension,
                                      SDWP_POWER_ON,
                                      SdbusActivatePowerUpComplete,
                                      NULL,
                                      &workPacket1);
                                      
        if (!NT_SUCCESS(status)) {
            callCompletion = TRUE;
            leave;
        }
        
        status = SdbusBuildWorkPacket(fdoExtension,
                                      SDWP_IDENTIFY_IO_DEVICE,
                                      SdbusActivateIdentifyPhase1Complete,
                                      NULL,
                                      &workPacket2);
     
        if (!NT_SUCCESS(status)) {
            callCompletion = TRUE;
            leave;
        }
        
        
        status = SdbusBuildWorkPacket(fdoExtension,
                                      SDWP_IDENTIFY_MEMORY_DEVICE,
                                      SdbusActivateIdentifyPhase2Complete,
                                      NULL,
                                      &workPacket3);
     
        if (!NT_SUCCESS(status)) {
            callCompletion = TRUE;
            leave;
        }

        status = SdbusBuildWorkPacket(fdoExtension,
                                      SDWP_INITIALIZE_CARD,
                                      SdbusActivateInitializeCardComplete,
                                      activateContext,
                                      &workPacket4);

        if (!NT_SUCCESS(status)) {
            callCompletion = TRUE;
            leave;
        }

        workPacket1->NextWorkPacketInChain = workPacket2;
        workPacket2->NextWorkPacketInChain = workPacket3;
        workPacket3->NextWorkPacketInChain = workPacket4;
                
        SdbusQueueWorkPacket(fdoExtension, workPacket1, WP_TYPE_SYSTEM);
        
        callCompletion = FALSE;

    } finally {
        if (callCompletion) {
            if (activateContext->CompletionRoutine) {
                (*activateContext->CompletionRoutine)(Fdo, activateContext->Context, status);
            }
            if (workPacket1) {
                ExFreePool(workPacket1);
            }                
            if (workPacket2) {
                ExFreePool(workPacket2);
            }                
            if (workPacket3) {
                ExFreePool(workPacket3);
            }                
            if (workPacket4) {
                ExFreePool(workPacket4);
            }                
            ExFreePool(activateContext);
        }
    }        
}



VOID
SdbusActivatePowerUpComplete(
    IN PSD_WORK_PACKET WorkPacket,
    IN NTSTATUS status
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/    
{
    
    DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x activate PowerUp Complete\n", WorkPacket->FdoExtension->DeviceObject));
    
    if (WorkPacket->NextWorkPacketInChain) {
        WorkPacket->NextWorkPacketInChain->ChainedStatus = status;
    }
    ExFreePool(WorkPacket);
}    

    

VOID
SdbusActivateIdentifyPhase1Complete(
    IN PSD_WORK_PACKET WorkPacket,
    IN NTSTATUS status
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/    
{
    DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x activate Identify Phase1 Complete\n", WorkPacket->FdoExtension->DeviceObject));

    if (WorkPacket->NextWorkPacketInChain) {
        WorkPacket->NextWorkPacketInChain->ChainedStatus = status;
    }
    ExFreePool(WorkPacket);
}    

    

VOID
SdbusActivateIdentifyPhase2Complete(
    IN PSD_WORK_PACKET WorkPacket,
    IN NTSTATUS status
    )
/*++

Routine Description:


Arguments:

    Fdo - Pointer to the device object for the host controller

Return Value:


--*/    
{
    PFDO_EXTENSION fdoExtension = WorkPacket->FdoExtension;
    PDEVICE_OBJECT Fdo = fdoExtension->DeviceObject;
    PSD_ACTIVATE_CONTEXT activateContext = WorkPacket->CompletionContext;
    BOOLEAN callCompletion;

    DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x activate Identify Phase2 Complete\n", WorkPacket->FdoExtension->DeviceObject));
    
    ExFreePool(WorkPacket);
    
#if 0
    try{
    
        if (!NT_SUCCESS(status)) {
            callCompletion = TRUE;
            leave;
        }

        //
        // If we get this far, we expect that there is at least one function detected
        //
        
        if (!fdoExtension->numFunctions && !fdoExtension->memFunction) {
            callCompletion = TRUE;
            SdbusDumpDbgLog();
            status = STATUS_UNSUCCESSFUL;
            leave;
        }

        //
        // The card should be in the Identification state. Send a CMD3 to get the relative address,
        // and to move the card to the standby state.
        //
        
        status = SdbusBuildWorkPacket(fdoExtension,
                                      SDWP_PASSTHRU,
                                      SdbusActivateTransitionToStandbyCompletion,
                                      activateContext,
                                      &WorkPacket);
        
        if (!NT_SUCCESS(status)) {
            callCompletion = TRUE;
            leave;
        }

        WorkPacket->ExecutingSDCommand = TRUE;
        WorkPacket->Cmd                = SDCMD_SEND_RELATIVE_ADDR;
        WorkPacket->ResponseType       = SDCMD_RESP_6;

    
        SdbusQueueWorkPacket(fdoExtension, WorkPacket, WP_TYPE_SYSTEM_PRIORITY);
        
        callCompletion = FALSE;
    } finally {        
        if (callCompletion) {
            if (activateContext->CompletionRoutine) {
                (*activateContext->CompletionRoutine)(Fdo, activateContext->Context, status);
            }
            ExFreePool(activateContext);
        }
    }    
#endif
}    


#if 0

VOID
SdbusActivateTransitionToStandbyCompletion(
    IN PSD_WORK_PACKET WorkPacket,
    IN NTSTATUS status
    )
/*++

Routine Description:


Arguments:

    Fdo - Pointer to the device object for the host controller

Return Value:


--*/    
{
    PFDO_EXTENSION fdoExtension = WorkPacket->FdoExtension;
    PDEVICE_OBJECT Fdo = fdoExtension->DeviceObject;
    PSD_ACTIVATE_CONTEXT activateContext = WorkPacket->CompletionContext;
    BOOLEAN callCompletion;

    DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x activate TransitionToStandby COMPLETE %08x\n", Fdo, status));
    
    try{
        if (!NT_SUCCESS(status)) {
            callCompletion = TRUE;
            leave;
        }
    
        fdoExtension->RelativeAddr = WorkPacket->ResponseBuffer[0] & 0xFFFF0000;
        DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x relative addr %08x\n", Fdo, fdoExtension->RelativeAddr));

        status = SdbusBuildWorkPacket(fdoExtension,
                                      SDWP_INITIALIZE_CARD,
                                      SdbusActivateInitializeCardComplete,
                                      activateContext,
                                      &workPacket);
     
        if (!NT_SUCCESS(status)) {
            callCompletion = TRUE;
            leave;
        }
        
    } else {
        if (activateContext->CompletionRoutine) {
            (*activateContext->CompletionRoutine)(Fdo, activateContext->Context, status);
        }
        ExFreePool(activateContext);
    }

    ExFreePool(WorkPacket);

}    
#endif



VOID
SdbusActivateInitializeCardComplete(
    IN PSD_WORK_PACKET WorkPacket,
    IN NTSTATUS status
    )
/*++

Routine Description:


Arguments:

    Fdo - Pointer to the device object for the host controller

Return Value:


--*/    
{
    PFDO_EXTENSION fdoExtension = WorkPacket->FdoExtension;
    PDEVICE_OBJECT Fdo = fdoExtension->DeviceObject;
    PSD_ACTIVATE_CONTEXT activateContext = WorkPacket->CompletionContext;

    DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x activate socket COMPLETE %08x\n", Fdo, status));
    
    if (NT_SUCCESS(status)) {
        fdoExtension->SocketState = CARD_NEEDS_ENUMERATION;
        IoInvalidateDeviceRelations(fdoExtension->Pdo, BusRelations);
    } else {
        DebugPrint((SDBUS_DEBUG_FAIL, "fdo %08x activate failure %08x\n", Fdo, status));
        SdbusDumpDbgLog();
    }

    ExFreePool(WorkPacket);

    if (activateContext->CompletionRoutine) {
        (*activateContext->CompletionRoutine)(Fdo, activateContext->Context, status);
    }
    ExFreePool(activateContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\data.h ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    data.h

Abstract:

    This module provides the definitions for controller types

Author(s):

    Neil Sandlin (neilsa)

Revisions:

--*/

#ifndef _SDBUS_DATA_H_
#define _SDBUS_DATA_H_

//
// Vendor/Device Ids for sd controllers we're interested in
//
#define PCI_TOSHIBA_VENDORID     0x1179



#endif  // _SDBUS_DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\dispatch.c ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module contains the global dispatch related
    routines for the sd controller & it's child devices

Author:

    Neil Sandlin  (neilsa) Jan 1 2002

Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"


NTSTATUS
SdbusDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SdbusFdoPowerDispatch(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp
    );

NTSTATUS
SdbusPdoPowerDispatch(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    );



#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, SdbusInitDeviceDispatchTable)
#endif

//
// Dispatch table array for FDOs/PDOs
//
PDRIVER_DISPATCH DeviceObjectDispatch[sizeof(DEVICE_OBJECT_TYPE)][IRP_MJ_MAXIMUM_FUNCTION + 1];


VOID
SdbusInitDeviceDispatchTable(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:
    Initializes the IRP dispatch tables for Pdo's & Fdo's

Arguments:
    None

Return value:
    None

--*/
{
    ULONG i;
   
    PAGED_CODE();
   
    //
    // Init the controller (FDO) dispatch table
    //
    DeviceObjectDispatch[FDO][IRP_MJ_CREATE]         = SdbusOpenCloseDispatch;
    DeviceObjectDispatch[FDO][IRP_MJ_CLOSE]          = SdbusOpenCloseDispatch;
    DeviceObjectDispatch[FDO][IRP_MJ_CLEANUP]        = SdbusCleanupDispatch;
    DeviceObjectDispatch[FDO][IRP_MJ_DEVICE_CONTROL] = SdbusFdoDeviceControl;
    DeviceObjectDispatch[FDO][IRP_MJ_SYSTEM_CONTROL] = SdbusFdoSystemControl;
    DeviceObjectDispatch[FDO][IRP_MJ_PNP]            = SdbusFdoPnpDispatch;
    DeviceObjectDispatch[FDO][IRP_MJ_POWER]          = SdbusFdoPowerDispatch;
   
    //
    // Init the PDO dispatch table
    //
    DeviceObjectDispatch[PDO][IRP_MJ_DEVICE_CONTROL]          = SdbusPdoDeviceControl;
    DeviceObjectDispatch[PDO][IRP_MJ_INTERNAL_DEVICE_CONTROL] = SdbusPdoInternalDeviceControl;
    DeviceObjectDispatch[PDO][IRP_MJ_SYSTEM_CONTROL]          = SdbusPdoSystemControl;
    DeviceObjectDispatch[PDO][IRP_MJ_PNP]                     = SdbusPdoPnpDispatch;
    DeviceObjectDispatch[PDO][IRP_MJ_POWER]                   = SdbusPdoPowerDispatch;
   
    //
    // Set the global dispatch table
    DriverObject->MajorFunction[IRP_MJ_CREATE]                  = SdbusDispatch;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                   = SdbusDispatch;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]                 = SdbusDispatch;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]          = SdbusDispatch;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = SdbusDispatch;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]          = SdbusDispatch;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN]                = SdbusDispatch;
    DriverObject->MajorFunction[IRP_MJ_PNP]                     = SdbusDispatch;
    DriverObject->MajorFunction[IRP_MJ_POWER]                   = SdbusDispatch;
}


NTSTATUS
SdbusDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

   Dispatch routine for all IRPs handled by this driver. This dispatch would then
   call the appropriate real dispatch routine which corresponds to the device object
   type (physical or functional).

Arguments:

   DeviceObject -  Pointer to the device object this dispatch is intended for
   Irp          -  Pointer to the IRP to be handled

Return value:
   Returns the status from the 'real' dispatch routine which handles this IRP

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;
    DEVICE_OBJECT_TYPE devtype = IS_PDO(DeviceObject) ? PDO : FDO;
    UCHAR MajorFunction = irpStack->MajorFunction;
    
    if ((MajorFunction > IRP_MJ_MAXIMUM_FUNCTION) || 
       (DeviceObjectDispatch[devtype][MajorFunction] == NULL)) {
       
       DebugPrint((SDBUS_DEBUG_INFO, "SDBUS: Dispatch skipping unimplemented Irp MJ function %x\n", MajorFunction));
       status = Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
       IoCompleteRequest(Irp, IO_NO_INCREMENT);
   
    } else if (((devtype == PDO) && IsDeviceDeleted((PPDO_EXTENSION)DeviceObject->DeviceExtension)) ||
               ((devtype == FDO) && IsDeviceDeleted((PFDO_EXTENSION)DeviceObject->DeviceExtension))) {
       //
       // This do was supposed to have been already deleted
       // so we don't support any IRPs on it
       //
       DebugPrint((SDBUS_DEBUG_INFO, "SDBUS: Dispatch skipping Irp on deleted DO %08x MJ function %x\n", DeviceObject, MajorFunction));
       
       if (MajorFunction == IRP_MJ_POWER) {
          PoStartNextPowerIrp(Irp);
       }
       status = Irp->IoStatus.Status = STATUS_DELETE_PENDING;
       IoCompleteRequest(Irp, IO_NO_INCREMENT);
       
    } else {
    
       //
       // Dispatch the irp
       //   
       status = ((*DeviceObjectDispatch[devtype][MajorFunction])(DeviceObject, Irp));
       
    }
    return status;
}




NTSTATUS
SdbusFdoPowerDispatch(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles power requests
    for the PDOs.

Arguments:

    Pdo - pointer to the physical device object
    Irp - pointer to the io request packet

Return Value:

    status

--*/

{
    PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS        status = STATUS_INVALID_DEVICE_REQUEST;
   
   
    switch (irpStack->MinorFunction) {
   
    case IRP_MN_SET_POWER:
   
        DebugPrint((SDBUS_DEBUG_POWER, "fdo %08x irp %08x --> IRP_MN_SET_POWER\n", Fdo, Irp));
        DebugPrint((SDBUS_DEBUG_POWER, "                              (%s%x context %x)\n",
                    (irpStack->Parameters.Power.Type == SystemPowerState)  ?
                    "S":
                    ((irpStack->Parameters.Power.Type == DevicePowerState) ?
                     "D" :
                     "Unknown"),
                    irpStack->Parameters.Power.State,
                    irpStack->Parameters.Power.SystemContext
                   ));
        status = SdbusSetFdoPowerState(Fdo, Irp);
        break;
   
    case IRP_MN_QUERY_POWER:
   
        DebugPrint((SDBUS_DEBUG_POWER, "fdo %08x irp %08x --> IRP_MN_QUERY_POWER\n", Fdo, Irp));
        DebugPrint((SDBUS_DEBUG_POWER, "                              (%s%x context %x)\n",
                    (irpStack->Parameters.Power.Type == SystemPowerState)  ?
                    "S":
                    ((irpStack->Parameters.Power.Type == DevicePowerState) ?
                     "D" :
                     "Unknown"),
                    irpStack->Parameters.Power.State,
                    irpStack->Parameters.Power.SystemContext
                   ));
        //
        // Let the pdo handle it
        //
        PoStartNextPowerIrp(Irp);
        IoSkipCurrentIrpStackLocation(Irp);
        status = PoCallDriver(fdoExtension->LowerDevice, Irp);
        break;
   
    case IRP_MN_WAIT_WAKE:
        DebugPrint((SDBUS_DEBUG_POWER, "fdo %08x irp %08x --> IRP_MN_WAIT_WAKE\n", Fdo, Irp));
        status = SdbusFdoWaitWake(Fdo, Irp);
        break;
   
    default:
        DebugPrint((SDBUS_DEBUG_POWER, "FdoPowerDispatch: Unhandled Irp %x received for 0x%08x\n",
                    Irp,
                    Fdo));
   
        PoStartNextPowerIrp(Irp);
        IoSkipCurrentIrpStackLocation(Irp);
        status = PoCallDriver(fdoExtension->LowerDevice, Irp);
        break;
    }
    DebugPrint((SDBUS_DEBUG_POWER, "fdo %08x irp %08x <-- %08x\n", Fdo, Irp, status));
    return status;
}



NTSTATUS
SdbusPdoPowerDispatch(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles power requests
    for the PDOs.

Arguments:

    Pdo - pointer to the physical device object
    Irp - pointer to the io request packet

Return Value:

    status

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_INVALID_DEVICE_REQUEST;
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
   
    if(IsDevicePhysicallyRemoved(pdoExtension) || IsDeviceDeleted(pdoExtension)) {
        // couldn't aquire RemoveLock - we're in the process of being removed - abort
        status = STATUS_NO_SUCH_DEVICE;
        PoStartNextPowerIrp( Irp );
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;
    }
   
    InterlockedIncrement(&pdoExtension->DeletionLock);
   
   
    switch (irpStack->MinorFunction) {
   
    case IRP_MN_SET_POWER:
        DebugPrint((SDBUS_DEBUG_POWER, "pdo %08x irp %08x --> IRP_MN_SET_POWER\n", Pdo, Irp));
        DebugPrint((SDBUS_DEBUG_POWER, "                              (%s%x, context %x)\n",
                    (irpStack->Parameters.Power.Type == SystemPowerState)  ?
                    "S":
                    ((irpStack->Parameters.Power.Type == DevicePowerState) ?
                     "D" :
                     "Unknown"),
                    irpStack->Parameters.Power.State,
                    irpStack->Parameters.Power.SystemContext
                   ));
   
        status = SdbusSetPdoPowerState(Pdo, Irp);
        break;

    case IRP_MN_QUERY_POWER:
   
   
        DebugPrint((SDBUS_DEBUG_POWER, "pdo %08x irp %08x --> IRP_MN_QUERY_POWER\n", Pdo, Irp));
        DebugPrint((SDBUS_DEBUG_POWER, "                              (%s%x, context %x)\n",
                    (irpStack->Parameters.Power.Type == SystemPowerState)  ?
                    "S":
                    ((irpStack->Parameters.Power.Type == DevicePowerState) ?
                     "D" :
                     "Unknown"),
                    irpStack->Parameters.Power.State,
                    irpStack->Parameters.Power.SystemContext
                   ));
   
        InterlockedDecrement(&pdoExtension->DeletionLock);
        status = Irp->IoStatus.Status = STATUS_SUCCESS;
        PoStartNextPowerIrp(Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        break;

   
    case IRP_MN_WAIT_WAKE: {
   
        BOOLEAN completeIrp;
   
        DebugPrint((SDBUS_DEBUG_POWER, "pdo %08x irp %08x --> IRP_MN_WAIT_WAKE\n", Pdo, Irp));
        //
        // Should not have a wake pending already
        //
        ASSERT (!(((PPDO_EXTENSION)Pdo->DeviceExtension)->Flags & SDBUS_DEVICE_WAKE_PENDING));
   
        status = SdbusPdoWaitWake(Pdo, Irp, &completeIrp);
   
        if (completeIrp) {
            InterlockedDecrement(&pdoExtension->DeletionLock);
            PoStartNextPowerIrp(Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
        break;
    }        
   
    default:
        //
        // Unhandled minor function
        //
        InterlockedDecrement(&pdoExtension->DeletionLock);
        status = Irp->IoStatus.Status;
        PoStartNextPowerIrp(Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
   
    DebugPrint((SDBUS_DEBUG_POWER, "pdo %08x irp %08x <-- %08x\n", Pdo, Irp, status));
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\fdopnp.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    fdopnp.c

Abstract:

    This module contains the code that handles PNP irps for sd bus driver
    targeted towards the FDO's (for the sd controller object)

Author:

    Neil Sandlin (neilsa) Jan 1 2002

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

//
// Internal References
//


NTSTATUS
SdbusGetPciControllerType(
    IN PDEVICE_OBJECT Pdo,
    IN PDEVICE_OBJECT Fdo
    );
    
NTSTATUS
SdbusFdoStartDevice(
    IN  PDEVICE_OBJECT Fdo,
    IN  PIRP           Irp
    );

NTSTATUS
SdbusFdoStopDevice(
    IN  PDEVICE_OBJECT Fdo,
    IN  PIRP           Irp
    );

NTSTATUS
SdbusFdoRemoveDevice(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP  Irp
    );

NTSTATUS
SdbusFdoDeviceCapabilities(
    IN  PDEVICE_OBJECT Fdo,
    IN  PIRP           Irp
    );

NTSTATUS
SdbusDeviceRelations(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp,
    IN DEVICE_RELATION_TYPE RelationType,
    OUT PDEVICE_RELATIONS *DeviceRelations
    );

PUNICODE_STRING  DriverRegistryPath;

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, SdbusFdoPnpDispatch)
    #pragma alloc_text(PAGE, SdbusFdoStartDevice)
    #pragma alloc_text(PAGE, SdbusFdoStopDevice)
    #pragma alloc_text(PAGE, SdbusFdoRemoveDevice)
    #pragma alloc_text(PAGE, SdbusFdoDeviceCapabilities)
    #pragma alloc_text(PAGE, SdbusAddDevice)
    #pragma alloc_text(PAGE, SdbusGetPciControllerType)
    #pragma alloc_text(PAGE, SdbusDeviceRelations)
#endif



NTSTATUS
SdbusFdoPnpDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    PNP/Power IRPs dispatch routine for the sd bus controller

Arguments:

    DeviceObject - Pointer to the device object.
    Irp - Pointer to the IRP

Return Value:

    Status

--*/
{

    PIO_STACK_LOCATION nextIrpStack;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PFDO_EXTENSION     fdoExtension = DeviceObject->DeviceExtension;
    NTSTATUS           status = Irp->IoStatus.Status;
   
    PAGED_CODE();
    ASSERT (fdoExtension->LowerDevice != NULL);

#if DBG
    if (irpStack->MinorFunction > IRP_MN_PNP_MAXIMUM_FUNCTION) {
       DebugPrint((SDBUS_DEBUG_PNP, "fdo %08x irp %08x - Unknown PNP irp\n",
                                      DeviceObject, irpStack->MinorFunction));
    } else {
       DebugPrint((SDBUS_DEBUG_PNP, "fdo %08x irp %08x --> %s\n",
                     DeviceObject, Irp, PNP_IRP_STRING(irpStack->MinorFunction)));
    }
#endif

    switch (irpStack->MinorFunction) {
   
    case IRP_MN_START_DEVICE: {
          status = SdbusFdoStartDevice(DeviceObject, Irp);
          break;
       }
   
    case IRP_MN_QUERY_STOP_DEVICE: {
          Irp->IoStatus.Status = STATUS_SUCCESS;
          status = SdbusIoCallDriverSynchronous(fdoExtension->LowerDevice, Irp);
          break;
       }
   
    case IRP_MN_CANCEL_STOP_DEVICE: {
          Irp->IoStatus.Status = STATUS_SUCCESS;
          status = SdbusIoCallDriverSynchronous(fdoExtension->LowerDevice, Irp);
          break;
       }
   
    case IRP_MN_STOP_DEVICE: {
          status = SdbusFdoStopDevice(DeviceObject, Irp);
          break;
       }
   
    case IRP_MN_QUERY_DEVICE_RELATIONS: {
   
          //
          // Return the list of devices on the bus
          //
   
          status = SdbusDeviceRelations(DeviceObject,
                                        Irp,
                                        irpStack->Parameters.QueryDeviceRelations.Type,
                                        (PDEVICE_RELATIONS *) &Irp->IoStatus.Information);
                                        
          Irp->IoStatus.Status = status;
          status = SdbusIoCallDriverSynchronous(fdoExtension->LowerDevice, Irp);
          break;
       }
   
    case IRP_MN_QUERY_REMOVE_DEVICE: {
          Irp->IoStatus.Status = STATUS_SUCCESS;
          status = SdbusIoCallDriverSynchronous(fdoExtension->LowerDevice, Irp);
          break;
       }
   
    case IRP_MN_CANCEL_REMOVE_DEVICE: {
          Irp->IoStatus.Status = STATUS_SUCCESS;
          status = SdbusIoCallDriverSynchronous(fdoExtension->LowerDevice, Irp);
          break;
       }
   
    case IRP_MN_REMOVE_DEVICE:{
          status = SdbusFdoRemoveDevice(DeviceObject, Irp);
          break;
       }
   
    case IRP_MN_SURPRISE_REMOVAL: {
          SdbusFdoStopDevice(DeviceObject, NULL);
          Irp->IoStatus.Status = STATUS_SUCCESS;
          status = SdbusIoCallDriverSynchronous(fdoExtension->LowerDevice, Irp);
          break;
       }
   
    case IRP_MN_QUERY_CAPABILITIES: {
          status = SdbusFdoDeviceCapabilities(DeviceObject, Irp);
          break;
       }
   
    default: {
          DebugPrint((SDBUS_DEBUG_PNP, "fdo %08x irp %08x - Skipping unsupported irp\n", DeviceObject, Irp));
          status = SdbusIoCallDriverSynchronous(fdoExtension->LowerDevice, Irp);
          break;
       }
    }
   
   
    //
    // Set the IRP status only if we set it to something other than
    // STATUS_NOT_SUPPORTED.
    //
    if (status != STATUS_NOT_SUPPORTED) {
   
        Irp->IoStatus.Status = status ;
    }
   
    status = Irp->IoStatus.Status;
    DebugPrint((SDBUS_DEBUG_PNP, "fdo %08x irp %08x comp %s %08x\n",
                                        DeviceObject, Irp, STATUS_STRING(status), status));
                                        
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}





NTSTATUS
SdbusAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    )

/*++

Routine Description:

    This routine creates functional device objects for each SD controller in the
    system and attaches them to the physical device objects for the controllers


Arguments:

    DriverObject - a pointer to the object for this driver
    PhysicalDeviceObject - a pointer to the physical object we need to attach to

Return Value:

    Status from device creation and initialization

--*/

{
    PDEVICE_OBJECT fdo = NULL;
    PDEVICE_OBJECT lowerDevice = NULL;
   
    PFDO_EXTENSION deviceExtension;
    ULONG          resultLength;
   
    NTSTATUS status;
   
    PAGED_CODE();
   
    DebugPrint((SDBUS_DEBUG_PNP, "AddDevice Entered with pdo %x\n", Pdo));
   
    if (Pdo == NULL) {
   
        //
        // Have we been asked to do detection on our own?
        // if so just return no more devices
        //
   
        DebugPrint((SDBUS_DEBUG_FAIL, "SdbusAddDevice - asked to do detection\n"));
        return STATUS_NO_MORE_ENTRIES;
    }
   
    //
    // create and initialize the new functional device object
    //
   
    status = IoCreateDevice(DriverObject,
                            sizeof(FDO_EXTENSION),
                            NULL,
                            FILE_DEVICE_CONTROLLER,
                            0L,
                            FALSE,
                            &fdo);
   
    if (!NT_SUCCESS(status)) {
   
        DebugPrint((SDBUS_DEBUG_FAIL, "SdbusAddDevice - error creating Fdo [%#08lx]\n", status));
        return status;
    }

    try {   
    
        deviceExtension = fdo->DeviceExtension;
        RtlZeroMemory(deviceExtension, sizeof(FDO_EXTENSION));
        //
        // Set up the device extension.
        //
        deviceExtension->Signature    = SDBUS_FDO_EXTENSION_SIGNATURE;
        deviceExtension->DeviceObject = fdo;
        deviceExtension->RegistryPath = DriverRegistryPath;
        deviceExtension->DriverObject = DriverObject;
        deviceExtension->Flags        = SDBUS_FDO_OFFLINE;
        deviceExtension->WaitWakeState= WAKESTATE_DISARMED;
       
        KeInitializeTimer(&deviceExtension->WorkerTimer);
        KeInitializeDpc(&deviceExtension->WorkerTimeoutDpc, SdbusWorkerTimeoutDpc, deviceExtension);
        KeInitializeDpc(&deviceExtension->WorkerDpc, SdbusWorkerDpc, deviceExtension);
        KeInitializeSpinLock(&deviceExtension->WorkerSpinLock);

        InitializeListHead(&deviceExtension->IoWorkPacketQueue);
        InitializeListHead(&deviceExtension->SystemWorkPacketQueue);
        
        IoInitializeRemoveLock(&deviceExtension->RemoveLock, 'Sdbu', 1, 100);
        //
        // card events we are interested in
        //        
        deviceExtension->CardEvents = SDBUS_EVENT_CARD_RW_END |
                                      SDBUS_EVENT_BUFFER_EMPTY |
                                      SDBUS_EVENT_BUFFER_FULL |
                                      SDBUS_EVENT_CARD_RESPONSE;
        
        //
        // Layer our FDO on top of the PDO
        //
        //
       
        lowerDevice = IoAttachDeviceToDeviceStack(fdo,Pdo);
       
        //
        // No status. Do the best we can.
        //
        if (lowerDevice == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        };
       
        deviceExtension->LowerDevice = lowerDevice;
        deviceExtension->Pdo = Pdo;
       
        status = IoGetDeviceProperty(Pdo,
                                     DevicePropertyLegacyBusType,
                                     sizeof(INTERFACE_TYPE),
                                     (PVOID)&deviceExtension->InterfaceType,
                                     &resultLength);
       
        if (!NT_SUCCESS(status)) {
            leave;
        }
       
        //
        // Get our controller type
        //
       
        status = SdbusGetPciControllerType(Pdo, fdo);
        if (!NT_SUCCESS(status)) {
            leave;
        }
           
        
        //
        // Get the pci interface for reading/writing to config header space
        //
        status = SdbusGetInterface(Pdo,
                                     &GUID_BUS_INTERFACE_STANDARD,
                                    sizeof(BUS_INTERFACE_STANDARD),
                                    (PINTERFACE) &deviceExtension->PciBusInterface);
        if (!NT_SUCCESS(status)) {
            leave;
        }                                  
           
        //
        // Link this fdo to the list of fdo's managed by the driver
        //
        
        DebugPrint((SDBUS_DEBUG_PNP, "FDO %08X now linked to fdolist by AddDevice\n", fdo));
        deviceExtension->NextFdo = FdoList;
        FdoList = fdo;
        
        fdo->Flags &= ~DO_DEVICE_INITIALIZING;

    } finally {
    
        if (!NT_SUCCESS(status)) {

            MarkDeviceDeleted(deviceExtension);
            //
            // Cannot support a controller without knowing its type etc.
            //
            
            if (deviceExtension->LowerDevice) {
                IoDetachDevice(deviceExtension->LowerDevice);
            }      
            
            IoDeleteDevice(fdo);
        }
    }
       
    return status;
}



NTSTATUS
SdbusGetPciControllerType(
    IN PDEVICE_OBJECT Pdo,
    IN PDEVICE_OBJECT Fdo
    )
/*++

Routine Description:
    Look at the PCI hardware ID to see if it is already a device we know about. If so,
    set the appropriate controller type in the fdoExtension.

Arguments:
    Pdo - Physical Device object for the Sdbus controller owned by the PCI driver
    Fdo - Functional Device object for the sd controller owned by this driver, whose
         extension will store the relevant controller information upon exit from this routine.

Return Value:
    STATUS_SUCCESS             Things are fine and information obtained
    STATUS_NOT_SUPPORTED       This is actually a healthy status for this routine: all it means
                               is that this PDO is not on a PCI bus, so no information needs to be
                               obtained anyways.
    Any other status           Failure. Caller probably needs to back out & not support this controller
--*/
{
    PFDO_EXTENSION fdoExtension    = Fdo->DeviceExtension;
    PIRP                             irp;
    IO_STATUS_BLOCK                  statusBlock;
    PIO_STACK_LOCATION               irpSp;
    PCI_COMMON_CONFIG                pciConfig;
    PPCI_CONTROLLER_INFORMATION      id;
    PPCI_VENDOR_INFORMATION          vid;
    KEVENT                           event;
    NTSTATUS                         status;
    BOOLEAN                          foundController = FALSE;
   
    PAGED_CODE();
    //
    // Allocate & initialize an Irp (IRP_MN_READ_CONFIG) to be sent down
    // to the PCI bus driver to get config. header for this controller
    //
    // Following is all standard stuff to send an IRP down - needs no documentation
   
    //
    // Fresh PDO. No need to jump through hoops to get attached devices
    //
    KeInitializeEvent (&event, NotificationEvent, FALSE);
    irp = IoBuildSynchronousFsdRequest( IRP_MJ_PNP,
                                        Pdo,
                                        NULL,
                                        0,
                                        0,
                                        &event,
                                        &statusBlock
                                        );
   
    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
   
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;
   
    irpSp = IoGetNextIrpStackLocation(irp);
   
    irpSp->MinorFunction = IRP_MN_READ_CONFIG;
   
    irpSp->Parameters.ReadWriteConfig.WhichSpace = PCI_WHICHSPACE_CONFIG;
    irpSp->Parameters.ReadWriteConfig.Buffer = &pciConfig;
    irpSp->Parameters.ReadWriteConfig.Offset = 0;
    irpSp->Parameters.ReadWriteConfig.Length = sizeof(pciConfig);
   
   
    status = IoCallDriver(Pdo, irp);
   
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = statusBlock.Status;
    }
   
    if (!NT_SUCCESS(status)) {
        return status;
    }
    //
    // Now weed out the critical information from the config header and
    // store it away in the fdo's extension
    //
   
    //
    // Look up the PCI device id in our table
    //
#if 0
   for (id = (PPCI_CONTROLLER_INFORMATION) PciControllerInformation;id->VendorID != PCI_INVALID_VENDORID; id++) {
      if ((id->VendorID == pciConfig.VendorID) && (id->DeviceID == pciConfig.DeviceID)) {

         SdbusSetControllerType(fdoExtension, id->ControllerType);
         foundController = TRUE;

         break;
      }
   }
#endif   

    //
    // Didn't find a specific vendor/device id, try to just base it on the vendor id
    //   
    if (!foundController) {
        for (vid = (PPCI_VENDOR_INFORMATION) PciVendorInformation;vid->VendorID != PCI_INVALID_VENDORID; vid++) {
            if (vid->VendorID == pciConfig.VendorID) {
      
                fdoExtension->FunctionBlock = vid->FunctionBlock;
                break;
            }
        }
    }
   
    return STATUS_SUCCESS;
}



NTSTATUS
SdbusFdoDeviceCapabilities(
    IN  PDEVICE_OBJECT Fdo,
    IN  PIRP           Irp
    )
/*++

Routine Description
    Records the device capabilities of this sd controller,
    so  1. they can be used in the power management for the controller
    and 2. they can be used for determining the capabilities of the
           child pc-card PDO's of this sd controller.
 
Arguments

    Fdo               - Pointer to functional device object of the sd
                        controller
    Irp               - Pointer to the i/o request packet

Return Value

    STATUS_SUCCESS                       Capabilities returned
    STATUS_INSUFFICIENT_RESOURCES        Could not allocate memory to cache the capabilities

--*/
{
    PFDO_EXTENSION fdoExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_CAPABILITIES capabilities;
    NTSTATUS       status;
   
    PAGED_CODE();
   
    capabilities = irpStack->Parameters.DeviceCapabilities.Capabilities;
    fdoExtension = Fdo->DeviceExtension;
   
    //
    // Send this down the stack to obtain the capabilities
    //
    
    status = SdbusIoCallDriverSynchronous(fdoExtension->LowerDevice, Irp);
   
   
    if (NT_SUCCESS(status)) {
    
        //
        // Cache the device capabilities in the device extension
        // for this sd controller.
        //
        RtlCopyMemory(&fdoExtension->DeviceCapabilities,
                      capabilities,
                      sizeof(DEVICE_CAPABILITIES));
       
    } else {
   
        RtlZeroMemory(&fdoExtension->DeviceCapabilities, sizeof(DEVICE_CAPABILITIES));
    
    }
   
    return status;
}




NTSTATUS
SdbusFdoStartDevice(
    IN  PDEVICE_OBJECT Fdo,
    IN  PIRP           Irp
    )
/*++

Routine Description:

    This routine will start the sd controller with the supplied
    resources.  The IRP is sent down to the pdo first, so PCI
    or whoever sits underneath gets a chance to program the controller
    to decode the resources.

Arguments:

    Fdo               - Functional device object of the sd controller
    Irp               - Pointer to the i/o request packet
    PassedDown        - Contains FALSE on entry, which means caller must
                        complete or pass down irp based on status. If set
                        to TRUE, Irp may need to be re-completed...
    NeedsRecompletion - ...In which case this parameter will be checked

Return value:

    Status

--*/
{
    NTSTATUS           status;
    PFDO_EXTENSION     fdoExtension = Fdo->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   
    PAGED_CODE();
    //
    // Send this down to the PDO first
    //
   
    status = SdbusIoCallDriverSynchronous(fdoExtension->LowerDevice, Irp);
   
    if (!NT_SUCCESS(status)) {
        return status;
    }
   
    //
    // Give the hardware some time to settle after returning from the pdo
    //
    SdbusWait(256);
    
    try {
        PCM_RESOURCE_LIST ResourceList = irpStack->Parameters.StartDevice.AllocatedResources;
        PCM_RESOURCE_LIST TranslatedResourceList = irpStack->Parameters.StartDevice.AllocatedResourcesTranslated;
        PCM_FULL_RESOURCE_DESCRIPTOR     fullResourceDesc;
        PCM_PARTIAL_RESOURCE_LIST        partialResourceList;
        PCM_PARTIAL_RESOURCE_DESCRIPTOR  partialResourceDesc;
        ULONG i;
        BOOLEAN           sharedInterrupt;
        KINTERRUPT_MODE   interruptMode;
        INTERFACE_TYPE    interfaceType;
   
        if (fdoExtension->Flags & SDBUS_DEVICE_STARTED) {
            //
            // Start to already started device
            //
            DebugPrint((SDBUS_DEBUG_INFO,"SdbusFdoStartDevice: Fdo %x already started\n", Fdo));
            status = STATUS_SUCCESS;
            leave;
        }
       
        //
        // Parse AllocatedResources & get IoPort/AttributeMemoryBase/IRQ info.
        //

        if ((ResourceList == NULL) || (ResourceList->Count <=0) ) {
            status = STATUS_UNSUCCESSFUL;
            leave;
        }
       
        fullResourceDesc=&TranslatedResourceList->List[0];
        partialResourceList = &fullResourceDesc->PartialResourceList;
        partialResourceDesc = partialResourceList->PartialDescriptors;
        
        //
        // The memory resource is the host register base.
        //
        for (i=0; (i < partialResourceList->Count) && (partialResourceDesc->Type != CmResourceTypeMemory);
            i++, partialResourceDesc++);
        if (i >= partialResourceList->Count) {
            status = STATUS_UNSUCCESSFUL;
            leave;
        };
       
        //
        // This is memory. We need to map it
        //
        fdoExtension->HostRegisterBase = MmMapIoSpace(partialResourceDesc->u.Memory.Start,
                                                      partialResourceDesc->u.Memory.Length,
                                                      FALSE);
        fdoExtension->HostRegisterSize = partialResourceDesc->u.Memory.Length;
       
        fdoExtension->Flags |= SDBUS_HOST_REGISTER_BASE_MAPPED;
       
        DebugPrint((SDBUS_DEBUG_INFO, "SdbusGetAssignedResources: Host Register Base at %x, size %x\n",
                                      fdoExtension->HostRegisterBase, fdoExtension->HostRegisterSize));
       
        //
        // Finally see if an IRQ is assigned
        //
       
        for (i = 0, partialResourceDesc = partialResourceList->PartialDescriptors;
            (i < partialResourceList->Count) && (partialResourceDesc->Type != CmResourceTypeInterrupt);
            i++,partialResourceDesc++);
       
       
        if (i < partialResourceList->Count) {
            //
            // We have an interrupt to used for CSC
            //
            DebugPrint((SDBUS_DEBUG_INFO, "SdbusGetAssignedResources: Interrupt resource assigned\n"));
            fdoExtension->TranslatedInterrupt = *partialResourceDesc;
            //
            // Get the raw interrupt resource  - needed to enable the interrupt on the controller
            //
            fullResourceDesc=&ResourceList->List[0];
            partialResourceList = &fullResourceDesc->PartialResourceList;
            partialResourceDesc = partialResourceList->PartialDescriptors;
            for (i=0; (i< partialResourceList->Count) && (partialResourceDesc->Type != CmResourceTypeInterrupt);
                i++, partialResourceDesc++);
            if (i < partialResourceList->Count) {
                fdoExtension->Interrupt = *partialResourceDesc;
            } else {
                //
                // Should not happen.. translated descriptor was present, but raw is missing!
                // Just reset the translated interrupt and pretend no interrupt was assigned
                //
                RtlZeroMemory(&fdoExtension->TranslatedInterrupt, sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));
            }
        }
       
        //
        // do vendor-specific init of controller
        //
       
        (*(fdoExtension->FunctionBlock->InitController))(fdoExtension);
        
        //
        // Now the controller registers should be accessible
        //
        fdoExtension->Flags &= ~SDBUS_FDO_OFFLINE;
       
       
        fdoExtension->SystemPowerState = PowerSystemWorking;
        fdoExtension->DevicePowerState = PowerDeviceD0;
       
        //
        // Initialize our DpcForIsr
        //
        IoInitializeDpcRequest(Fdo, SdbusInterruptDpc);
        
        if (fdoExtension->Interrupt.u.Interrupt.Level == 0) {
            status = STATUS_UNSUCCESSFUL;
            leave;
        }
        
        fdoExtension->IoWorkItem = IoAllocateWorkItem(Fdo);
       
        //
        // Hook up the controller interrupt for detecting pc-card plug ins/outs
        //
        interruptMode=((fdoExtension->Interrupt.Flags & CM_RESOURCE_INTERRUPT_LATCHED) == CM_RESOURCE_INTERRUPT_LATCHED) ? Latched:LevelSensitive;
       
        sharedInterrupt=(fdoExtension->Interrupt.ShareDisposition == CmResourceShareShared)?
                        TRUE:FALSE;
       
       
        status = IoConnectInterrupt(&(fdoExtension->SdbusInterruptObject),
                                    (PKSERVICE_ROUTINE) SdbusInterrupt,
                                    (PVOID) Fdo,
                                    NULL,
                                    fdoExtension->TranslatedInterrupt.u.Interrupt.Vector,
                                    (KIRQL) fdoExtension->TranslatedInterrupt.u.Interrupt.Level,
                                    (KIRQL) fdoExtension->TranslatedInterrupt.u.Interrupt.Level,
                                    interruptMode,
                                    sharedInterrupt,
                                    (KAFFINITY) fdoExtension->TranslatedInterrupt.u.Interrupt.Affinity,
                                    FALSE);
        if (!NT_SUCCESS(status)) {
       
            DebugPrint((SDBUS_DEBUG_FAIL, "Unable to connect interrupt\n"));
            leave;
        }
        
        (*(fdoExtension->FunctionBlock->EnableEvent))(fdoExtension, (SDBUS_EVENT_INSERTION | SDBUS_EVENT_REMOVAL));


        //
        // Activate socket will power up and ready the card
        //
        
        SdbusActivateSocket(Fdo, NULL, NULL);

    } finally {        
       
        if (NT_SUCCESS(status)) {
            fdoExtension->Flags |= SDBUS_DEVICE_STARTED;
            
        } else {
            //
            // Failure
            //
            if (fdoExtension->Flags & SDBUS_HOST_REGISTER_BASE_MAPPED) {
                MmUnmapIoSpace(fdoExtension->HostRegisterBase,
                               fdoExtension->HostRegisterSize);
                fdoExtension->Flags &= ~SDBUS_HOST_REGISTER_BASE_MAPPED;
                fdoExtension->HostRegisterBase = 0;
                fdoExtension->HostRegisterSize = 0;
            }
            
            if (fdoExtension->IoWorkItem) {
                IoFreeWorkItem(fdoExtension->IoWorkItem);
                fdoExtension->IoWorkItem = NULL;
            }
        }
    }        
        
    return status;
}



NTSTATUS
SdbusFdoStopDevice(
    IN  PDEVICE_OBJECT Fdo,
    IN  PIRP           Irp                OPTIONAL
    )
/*++

Routine Description:

    IRP_MN_STOP_DEVICE handler for the given sd controller.
    If Irp is present, it'll send it down first to the PDO.
    Unhooks the interrupt/cancels poll timer etc.

Arguments:

    Fdo               - Pointer to functional device object for the sd
                        controller
    Irp               - If present it's the pointer to the stop Irp initiated
                        by PnP

Return value:

    STATUS_SUCCESS    - Sdbus controller successfully stopped
    Other             - Stop failed

--*/
{
    PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
    NTSTATUS       status;
   
    
    SdbusFdoDisarmWake(fdoExtension);
   
    //
    // Disable the interrupt
    //
   
    (*(fdoExtension->FunctionBlock->DisableEvent))(fdoExtension, SDBUS_EVENT_ALL);
//         (*(socket->SocketFnPtr->PCBEnableDisableWakeupEvent))(socket, NULL, FALSE);

    //
    // the bus driver below us will make us go offline
    //
    fdoExtension->Flags |= SDBUS_FDO_OFFLINE;
   
    //
    // clear pending event
    //  ISSUE: NEED TO IMPLEMENT : drain worker timer before OK'ing stop
    KeCancelTimer(&fdoExtension->WorkerTimer);
   
    //
    // Send this down to the PDO 
    //
    if (ARGUMENT_PRESENT(Irp)) {
   
        status = SdbusIoCallDriverSynchronous(fdoExtension->LowerDevice, Irp);
       
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }
   

    if (!(fdoExtension->Flags & SDBUS_DEVICE_STARTED)) {
        //
        // Already stopped
        //
        return STATUS_SUCCESS;
    }
    
    if (fdoExtension->SdbusInterruptObject) {
        //
        // unhook the interrupt
        //
        IoDisconnectInterrupt(fdoExtension->SdbusInterruptObject);
        fdoExtension->SdbusInterruptObject = NULL;
    }
   
    //
    // Unmap any i/o space or memory we might have mapped
    //
   
    if (fdoExtension->Flags & SDBUS_HOST_REGISTER_BASE_MAPPED) {
        MmUnmapIoSpace(fdoExtension->HostRegisterBase,
                       fdoExtension->HostRegisterSize);
        fdoExtension->Flags &= ~SDBUS_HOST_REGISTER_BASE_MAPPED;
        fdoExtension->HostRegisterBase = 0;
        fdoExtension->HostRegisterSize = 0;
    }
    
    if (fdoExtension->IoWorkItem) {
        IoFreeWorkItem(fdoExtension->IoWorkItem);
        fdoExtension->IoWorkItem = NULL;
    }

    fdoExtension->Flags &= ~SDBUS_DEVICE_STARTED;
    return STATUS_SUCCESS;
}



NTSTATUS
SdbusFdoRemoveDevice(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp
    )
/*++

Routine Description:

    Handles IRP_MN_REMOVE for the sd controller.
    Stops the adapter if it isn't already, sends the IRP
    to the PDO first & cleans up the Fdo for this controller
    and detaches & deletes the device object.

Arguments:

    Fdo   - Pointer to functional device object for the controller
            to be removed

Return value:

   Status

--*/
{
    PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PDEVICE_OBJECT pdo, nextPdo, fdo, prevFdo;
    PPDO_EXTENSION pdoExtension;
    NTSTATUS       status;
   
    if (fdoExtension->Flags & SDBUS_DEVICE_STARTED) {
        //
        // Stop the fdo first.
        //
        SdbusFdoStopDevice(Fdo, NULL);
    }
   
    //
    // Send this down to the PDO
    //
   
    status = SdbusIoCallDriverSynchronous(fdoExtension->LowerDevice, Irp);
   
    if (!NT_SUCCESS(status)) {
        return status;
    }
   
    //
    // If the PdoList in the fdoExtension is non-empty it means:
    // that the PDOs in the list were not physically removed, but
    // a soft REMOVE was issued, hence they are still hanging on
    // and now this controller itself is being REMOVED.
    // Hence we dispose of those PDOs now
    //
   
    for (pdo = fdoExtension->PdoList; pdo != NULL ; pdo = nextPdo) {
        DebugPrint((SDBUS_DEBUG_INFO,
                    "RemoveDevice: pdo %x child of fdo %x was not removed before fdo\n",
                    pdo, Fdo));
       
        pdoExtension = pdo->DeviceExtension;
       
        ASSERT (!IsDevicePhysicallyRemoved(pdoExtension));
        //
        // It's possible for this bit to be on, if the device was added,
        // but never started (because of some other error.
        //ASSERT (!IsDeviceAlive(pdoExtension));
       
        nextPdo =  pdoExtension->NextPdoInFdoChain;
        if (!IsDeviceDeleted(pdoExtension)) {
            MarkDeviceDeleted(pdoExtension);
            SdbusCleanupPdo(pdo);
            IoDeleteDevice(pdo);
        }
    }
   
    MarkDeviceDeleted(fdoExtension);
   
    //
    // Remove this from the fdo list..
    //
    prevFdo = NULL;
    for (fdo = FdoList; fdo != NULL; prevFdo = fdo, fdo = fdoExtension->NextFdo) {
        fdoExtension = fdo->DeviceExtension;
        if (fdo == Fdo) {
            if (prevFdo) {
                //
                // Delink this fdo
                //
                ((PFDO_EXTENSION)prevFdo->DeviceExtension)->NextFdo
                = fdoExtension->NextFdo;
            } else {
                FdoList = fdoExtension->NextFdo;
            }
            break;
        }
    }
   
    DebugPrint((SDBUS_DEBUG_PNP, "fdo %08x Remove detach & delete\n", Fdo));
    IoDetachDevice(((PFDO_EXTENSION)Fdo->DeviceExtension)->LowerDevice);
    IoDeleteDevice(Fdo);
   
    return STATUS_SUCCESS;
}



NTSTATUS
SdbusDeviceRelations(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp,
    IN DEVICE_RELATION_TYPE RelationType,
    OUT PDEVICE_RELATIONS *DeviceRelations
    )

/*++

Routine Description:

    This routine will force enumeration of the sd controller represented by Fdo,
    allocate a device relations structure and fill in the count and object array with
    referenced object pointers to the valid PDOs which are created during enumeration

Arguments:

    Fdo - a pointer to the functional device object being enumerated
    Irp - pointer to the Irp
    RelationType - Type of relationship to be retrieved
    DeviceRelations - Structure to store the device relations

--*/

{

    PDEVICE_OBJECT currentPdo;
    PPDO_EXTENSION currentPdoExtension;
    PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
    ULONG newRelationsSize, oldRelationsSize = 0;
    PDEVICE_RELATIONS deviceRelations = NULL, oldDeviceRelations;
    ULONG i;
    ULONG count;
    NTSTATUS status;
   
    PAGED_CODE();
   
    //
    // Handle only bus, ejection & removal relations for now
    //
   
    if (RelationType != BusRelations &&
        RelationType != RemovalRelations) {
        DebugPrint((SDBUS_DEBUG_INFO,
                   "SdbusDeviceRelations: RelationType %d, not handled\n",
                   (USHORT) RelationType));
        return STATUS_NOT_SUPPORTED;
    }
   
    //
    // Need reenumeration only if bus relations are required
    // We need to save the pointer to the old device relations
    // before we call SdbusReenumerateDevices, as it might trample
    // on it
    //
    oldDeviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;
    
    // I don't understand how this can be non-null, so I added this
    // assert to find out.
    ASSERT(oldDeviceRelations == NULL);
   
    if (RelationType == BusRelations) {
        status =  SdbusEnumerateDevices(Fdo, Irp);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }
   
    if ((fdoExtension->LivePdoCount == 0) ||
        (RelationType == RemovalRelations)) {
        //
        // No PDO's to report, we can return early.
        // If no device_relations structure has yet been allocated, however,
        // we need to allocate one & set the count to zero. This will ensure
        // that regardless of whether we pass this IRP down or not, the IO
        // subsystem won't barf.
        //
        if (oldDeviceRelations == NULL) {
            *DeviceRelations = ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));
            if (*DeviceRelations == NULL) {
               return STATUS_INSUFFICIENT_RESOURCES;
            }
            (*DeviceRelations)->Count = 0;
            (*DeviceRelations)->Objects[0] = NULL;
        }
        return STATUS_SUCCESS;
    }
   
    if (!(oldDeviceRelations) || (oldDeviceRelations->Count == 0)) {
        newRelationsSize =  sizeof(DEVICE_RELATIONS)+(fdoExtension->LivePdoCount - 1)
                           * sizeof(PDEVICE_OBJECT);
    } else {
        oldRelationsSize = sizeof(DEVICE_RELATIONS) +
                          (oldDeviceRelations->Count-1) * sizeof(PDEVICE_OBJECT);
        newRelationsSize = oldRelationsSize + fdoExtension->LivePdoCount
                          * sizeof(PDEVICE_OBJECT);
    }
   
    deviceRelations = ExAllocatePool(PagedPool, newRelationsSize);
   
    if (deviceRelations == NULL) {
   
        DebugPrint((SDBUS_DEBUG_FAIL,
                    "SdbusDeviceRelations: unable to allocate %d bytes for device relations\n",
                    newRelationsSize));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
   
    if (oldDeviceRelations) {
        if ((oldDeviceRelations)->Count > 0) {
            RtlCopyMemory(deviceRelations, oldDeviceRelations, oldRelationsSize);
        }
        count = oldDeviceRelations->Count; // May be zero
        ExFreePool (oldDeviceRelations);
    } else {
        count = 0;
    }
    //
    // Copy the object pointers into the structure
    //
    for (currentPdo = fdoExtension->PdoList ;currentPdo != NULL;
        currentPdo = currentPdoExtension->NextPdoInFdoChain) {
   
        currentPdoExtension = currentPdo->DeviceExtension;
       
        if (!IsDevicePhysicallyRemoved(currentPdoExtension)) {
            //
            // Devices have to be referenced by the bus driver
            // before returning them to PNP
            //
            deviceRelations->Objects[count++] = currentPdo;
            status = ObReferenceObjectByPointer(currentPdo,
                                                0,
                                                NULL,
                                                KernelMode);
           
            if (!NT_SUCCESS(status)) {
           
                DebugPrint((SDBUS_DEBUG_FAIL, "SdbusDeviceRelations: status %#08lx "
                           "while referencing object %#08lx\n",
                           status,
                           currentPdo));
            }
        }
    }
   
    deviceRelations->Count = count;
    *DeviceRelations = deviceRelations;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\debug.c ===
/*++      

Copyright (c) 2002 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module provides debugging support.

Author:

    Neil Sandlin (neilsa) Jan 1, 2002

Revision History:


--*/


#include "pch.h"

#if DBG
//
// Get mappings from status codes to strings
//

#include <ntstatus.dbg>

#undef MAP
#define MAP(_Value) { (_Value), #_Value }
#define END_STRING_MAP  { 0xFFFFFFFF, NULL }

typedef struct _DBG_MASK_STRING {
   ULONG Mask;
   PUCHAR String;
} DBG_MASK_STRING, *PDBG_MASK_STRING;


DBG_MASK_STRING MaskStrings[] = {
   SDBUS_DEBUG_FAIL,      "ERR",
   SDBUS_DEBUG_WARNING,   "WNG",
   SDBUS_DEBUG_INFO,      "INF",
   SDBUS_DEBUG_PNP,       "PNP", 
   SDBUS_DEBUG_POWER,     "PWR", 
   SDBUS_DEBUG_TUPLES,    "TPL", 
   SDBUS_DEBUG_ENUM,      "ENU", 
   SDBUS_DEBUG_EVENT,     "EVT", 
   SDBUS_DEBUG_CARD_EVT,  "CEV", 
   SDBUS_DEBUG_INTERFACE, "IFC", 
   SDBUS_DEBUG_IOCTL,     "IOC",
   SDBUS_DEBUG_WORKENG,   "WKR",
   SDBUS_DEBUG_WORKPROC,  "WKP",
   SDBUS_DEBUG_DEVICE,    "DEV",
   SDBUS_DEBUG_DUMP_REGS, "REG",
   0, NULL
   };


PSDBUS_STRING_MAP SdbusDbgStatusStringMap = (PSDBUS_STRING_MAP) ntstatusSymbolicNames;

SDBUS_STRING_MAP SdbusDbgPnpIrpStringMap[] = {

    MAP(IRP_MN_START_DEVICE),
    MAP(IRP_MN_QUERY_REMOVE_DEVICE),
    MAP(IRP_MN_REMOVE_DEVICE),
    MAP(IRP_MN_CANCEL_REMOVE_DEVICE),
    MAP(IRP_MN_STOP_DEVICE),
    MAP(IRP_MN_QUERY_STOP_DEVICE),
    MAP(IRP_MN_CANCEL_STOP_DEVICE),
    MAP(IRP_MN_QUERY_DEVICE_RELATIONS),
    MAP(IRP_MN_QUERY_INTERFACE),
    MAP(IRP_MN_QUERY_CAPABILITIES),
    MAP(IRP_MN_QUERY_RESOURCES),
    MAP(IRP_MN_QUERY_RESOURCE_REQUIREMENTS),
    MAP(IRP_MN_QUERY_DEVICE_TEXT),
    MAP(IRP_MN_FILTER_RESOURCE_REQUIREMENTS),
    MAP(IRP_MN_READ_CONFIG),
    MAP(IRP_MN_WRITE_CONFIG),
    MAP(IRP_MN_EJECT),
    MAP(IRP_MN_SET_LOCK),
    MAP(IRP_MN_QUERY_ID),
    MAP(IRP_MN_QUERY_PNP_DEVICE_STATE),
    MAP(IRP_MN_QUERY_BUS_INFORMATION),
    MAP(IRP_MN_DEVICE_USAGE_NOTIFICATION),
    MAP(IRP_MN_SURPRISE_REMOVAL),
    MAP(IRP_MN_QUERY_LEGACY_BUS_INFORMATION),
    END_STRING_MAP
};


SDBUS_STRING_MAP SdbusDbgPoIrpStringMap[] = {

    MAP(IRP_MN_WAIT_WAKE),
    MAP(IRP_MN_POWER_SEQUENCE),
    MAP(IRP_MN_SET_POWER),
    MAP(IRP_MN_QUERY_POWER),
    END_STRING_MAP
};



SDBUS_STRING_MAP SdbusDbgDeviceRelationStringMap[] = {
    
    MAP(BusRelations),
    MAP(EjectionRelations),
    MAP(PowerRelations),
    MAP(RemovalRelations),
    MAP(TargetDeviceRelation),
    END_STRING_MAP
    
};

SDBUS_STRING_MAP SdbusDbgSystemPowerStringMap[] = {
    
    MAP(PowerSystemUnspecified),
    MAP(PowerSystemWorking),
    MAP(PowerSystemSleeping1),
    MAP(PowerSystemSleeping2),
    MAP(PowerSystemSleeping3),
    MAP(PowerSystemHibernate),
    MAP(PowerSystemShutdown),
    MAP(PowerSystemMaximum),
    END_STRING_MAP

};

SDBUS_STRING_MAP SdbusDbgDevicePowerStringMap[] = {
    
    MAP(PowerDeviceUnspecified),
    MAP(PowerDeviceD0),
    MAP(PowerDeviceD1),
    MAP(PowerDeviceD2),
    MAP(PowerDeviceD3),
    MAP(PowerDeviceMaximum),
    END_STRING_MAP

};


SDBUS_STRING_MAP SdbusDbgTupleStringMap[] = {

    MAP(CISTPL_NULL),
    MAP(CISTPL_DEVICE),
    MAP(CISTPL_INDIRECT),
    MAP(CISTPL_CONFIG_CB),
    MAP(CISTPL_CFTABLE_ENTRY_CB),
    MAP(CISTPL_LONGLINK_MFC),
    MAP(CISTPL_CHECKSUM),
    MAP(CISTPL_LONGLINK_A),
    MAP(CISTPL_LONGLINK_C),
    MAP(CISTPL_LINKTARGET),
    MAP(CISTPL_NO_LINK),
    MAP(CISTPL_VERS_1),
    MAP(CISTPL_ALTSTR),
    MAP(CISTPL_DEVICE_A),
    MAP(CISTPL_JEDEC_C),
    MAP(CISTPL_JEDEC_A),
    MAP(CISTPL_CONFIG),
    MAP(CISTPL_CFTABLE_ENTRY),
    MAP(CISTPL_DEVICE_OC),
    MAP(CISTPL_DEVICE_OA),
    MAP(CISTPL_GEODEVICE),
    MAP(CISTPL_GEODEVICE_A),
    MAP(CISTPL_MANFID),
    MAP(CISTPL_FUNCID),
    MAP(CISTPL_FUNCE),
    MAP(CISTPL_VERS_2),
    MAP(CISTPL_FORMAT),
    MAP(CISTPL_GEOMETRY),
    MAP(CISTPL_BYTEORDER),
    MAP(CISTPL_DATE),
    MAP(CISTPL_BATTERY),
    MAP(CISTPL_ORG),
    MAP(CISTPL_LONGLINK_CB),
    MAP(CISTPL_END),

    END_STRING_MAP
};


SDBUS_STRING_MAP SdbusDbgWakeStateStringMap[] = {
    
    MAP(WAKESTATE_DISARMED),
    MAP(WAKESTATE_WAITING),
    MAP(WAKESTATE_WAITING_CANCELLED),
    MAP(WAKESTATE_ARMED),
    MAP(WAKESTATE_ARMING_CANCELLED),
    MAP(WAKESTATE_COMPLETING),

    END_STRING_MAP
};


SDBUS_STRING_MAP SdbusDbgEventStringMap[] = {
    
    MAP(SDBUS_EVENT_INSERTION),
    MAP(SDBUS_EVENT_REMOVAL),
    MAP(SDBUS_EVENT_CARD_RESPONSE),
    MAP(SDBUS_EVENT_CARD_RW_END),
    MAP(SDBUS_EVENT_BUFFER_EMPTY),
    MAP(SDBUS_EVENT_BUFFER_FULL),

    END_STRING_MAP
};

SDBUS_STRING_MAP SdbusDbgWPFunctionStringMap[] = {
    
    MAP(SDWP_READBLOCK),
    MAP(SDWP_WRITEBLOCK),
    MAP(SDWP_READIO),
    MAP(SDWP_WRITEIO),
    MAP(SDWP_READIO_EXTENDED),
    MAP(SDWP_WRITEIO_EXTENDED),
    MAP(SDWP_CARD_RESET),
    MAP(SDWP_PASSTHRU),
    MAP(SDWP_POWER_ON),
    MAP(SDWP_POWER_OFF),
    MAP(SDWP_IDENTIFY_IO_DEVICE),
    MAP(SDWP_IDENTIFY_MEMORY_DEVICE),
    MAP(SDWP_INITIALIZE_FUNCTION),

    END_STRING_MAP
};

SDBUS_STRING_MAP SdbusDbgWorkerStateStringMap[] = {
    
    MAP(WORKER_IDLE),
    MAP(PACKET_PENDING),
    MAP(IN_PROCESS),
    MAP(WAITING_FOR_TIMER),

    END_STRING_MAP
};

SDBUS_STRING_MAP SdbusDbgSocketStateStringMap[] = {
    
    MAP(SOCKET_EMPTY),
    MAP(CARD_DETECTED),
    MAP(CARD_NEEDS_ENUMERATION),
    MAP(CARD_ACTIVE),
    MAP(CARD_LOGICALLY_REMOVED),

    END_STRING_MAP
};


PCHAR
SdbusDbgLookupString(
    IN PSDBUS_STRING_MAP Map,
    IN ULONG Id
    )

/*++

Routine Description:

    Looks up the string associated with Id in string map Map
    
Arguments:

    Map - The string map
    
    Id - The id to lookup

Return Value:

    The string
        
--*/

{
    PSDBUS_STRING_MAP current = Map;
    
    while(current->Id != 0xFFFFFFFF) {

        if (current->Id == Id) {
            return current->String;
        }
        
        current++;
    }
    
    return "** UNKNOWN **";
}


PUCHAR SdbusDbgLog;
LONG SdbusDbgLogEntry;
LONG SdbusDbgLogCount;

VOID
SdbusDebugPrint(
                ULONG  DebugMask,
                PCCHAR DebugMessage,
                ...
                )

/*++

Routine Description:

    Debug print for the SDBUS enabler.

Arguments:

    Check the mask value to see if the debug message is requested.

Return Value:

    None

--*/

{
    va_list ap;
    char    buffer[256];
    ULONG i = 0;
   
    if (DebugMask & SdbusDebugMask) {
    
        va_start(ap, DebugMessage);
       
       
        if (!(SdbusDebugMask & SDBUS_DEBUG_LOG)) {
            sprintf(buffer, "%s ", "Sdbus");
        } else {
            ULONGLONG diff;
            ULONGLONG interruptTime;
            static ULONGLONG lastInterruptTime = 0;
            LARGE_INTEGER performanceCounter;
            
            performanceCounter = KeQueryPerformanceCounter(NULL);
            interruptTime = performanceCounter.QuadPart;
            if (lastInterruptTime != 0) {
                diff = interruptTime - lastInterruptTime;
            } else {
                diff = 0;
            }                
                
            lastInterruptTime = interruptTime;
            sprintf(buffer, "%s (%05d) - ", "Sdbus", (ULONG)diff);
            
        }        
        
        for (i = 0; (MaskStrings[i].Mask != 0); i++) {
            if (DebugMask & MaskStrings[i].Mask) {
                strcat(buffer, MaskStrings[i].String);
                strcat(buffer, ": ");
                break;
            }
        }
        
        if (MaskStrings[i].Mask == 0) {
            strcat(buffer, "???: ");
        }         
   
        vsprintf(&buffer[strlen(buffer)], DebugMessage, ap);
       
        if ((SdbusDebugMask & SDBUS_DEBUG_LOG) && (SdbusDbgLog != NULL)) {
            PUCHAR pNewLoc = &SdbusDbgLog[SdbusDbgLogEntry*DBGLOGWIDTH];
            SdbusDbgLogEntry++;
            if (SdbusDbgLogEntry >= DBGLOGCOUNT) {
                SdbusDbgLogEntry = 0;
            }
            
            if (SdbusDbgLogCount < DBGLOGCOUNT) {
                SdbusDbgLogCount++;
            }
            
            strncpy(pNewLoc, buffer, DBGLOGWIDTH);

        
        } else {
            DbgPrint(buffer);
        }            
   
        va_end(ap);
    }

} // end SdbusDebugPrint()


VOID
SdbusDumpDbgLog(
    )
{
    ULONG i;
    
    for(i = DBGLOGCOUNT; i > 0; i--) {
         SdbusPrintLogEntry(i-1);
    }                    
    if (SdbusDebugMask & SDBUS_DEBUG_BREAK) {
        DbgBreakPoint();
    }            
    SdbusClearDbgLog();
}    


VOID
SdbusPrintLogEntry(
    LONG index
    )
{
    PUCHAR pLogEntry;
    LONG logIndex;
    
    if (index >= SdbusDbgLogCount) {
        return;
    }

    logIndex = (SdbusDbgLogEntry - 1) - index;
    
    if (logIndex < 0) {
        logIndex += DBGLOGCOUNT;
    }
    
    if ((logIndex < 0) || (logIndex >= DBGLOGCOUNT)) {
        DbgBreakPoint();
        return;
    }
    
    pLogEntry = &SdbusDbgLog[logIndex*DBGLOGWIDTH];
    DbgPrint(pLogEntry);

}

VOID
SdbusInitializeDbgLog(
    PUCHAR buffer
    )
{

    SdbusDbgLog = buffer;
}    

VOID
SdbusClearDbgLog(
    )
{
    SdbusDbgLogEntry = 0;
    SdbusDbgLogCount = 0;
}    


#if 0
VOID
MyFreePool(
    PVOID pointer
    )
{
    DebugPrint((SDBUS_DEBUG_WARNING, "FREEPOOL: %08x\n", pointer));
    ExFreePool(pointer);
}
#endif



VOID
SdbusDebugDumpCsd(
    PSD_CSD sdCsd
    )
{

    PUCHAR pUc = (PUCHAR) sdCsd;
    ULONG deviceSize;
    ULONG capacity, blockNr, mult, block_len;

    DebugPrint((SDBUS_DEBUG_ENUM, "------------------------CSD----------------------\n"));
    
    DebugPrint((SDBUS_DEBUG_ENUM, "%02x %02x %02x %02x %02x %02x %02x %02x-%02x %02x %02x %02x %02x %02x %02x\n",
                                  pUc[0], pUc[1], pUc[2], pUc[3],
                                  pUc[4], pUc[5], pUc[6], pUc[7],
                                  pUc[8], pUc[9], pUc[10],pUc[11],
                                  pUc[12], pUc[13], pUc[14]));
    

    DebugPrint((SDBUS_DEBUG_ENUM, "TAAC=%02x NSAC=%02x TRANSPEED=%02x\n", 
                                   sdCsd->DataReadAccessTime1, sdCsd->DataReadAccessTime2, sdCsd->MaxDataTransferRate));


    deviceSize = sdCsd->b.DeviceSizeHigh << 2 | sdCsd->c.DeviceSizeLow;

    DebugPrint((SDBUS_DEBUG_ENUM, "DeviceSize=%08x\n", deviceSize));

    mult = (1 << (sdCsd->c.DeviceSizeMultiplier+2));
    blockNr = (deviceSize+1) * mult;
    block_len = (1 << sdCsd->b.MaxReadDataBlockLength);
    capacity = blockNr * block_len;

    DebugPrint((SDBUS_DEBUG_ENUM, "mult=%08x blockNr=%08x block_len=%08x capacity=%08x\n", mult, blockNr, block_len, capacity));
    
    
    DebugPrint((SDBUS_DEBUG_ENUM, "DsrImpl=%d RBlMisalign=%d WBlMisalign=%d PartialBlocksRead=%d\n",
                                   sdCsd->b.DsrImplemented, sdCsd->b.ReadBlockMisalignment, sdCsd->b.WriteBlockMisalignment,
                                   sdCsd->b.PartialBlocksRead));

    DebugPrint((SDBUS_DEBUG_ENUM, "MaxReadBlkLen=%d CCC=%03x\n",
                                   sdCsd->b.MaxReadDataBlockLength, sdCsd->b.CardCommandClasses));

    DebugPrint((SDBUS_DEBUG_ENUM, "WPGsize=%d EraseSectSize=%d EraseSBlEnable=%d DevSizeMult=%d\n",
                                   sdCsd->c.WriteProtectGroupSize, sdCsd->c.EraseSectorSize, sdCsd->c.EraseSingleBlockEnable,
                                   sdCsd->c.DeviceSizeMultiplier));

    DebugPrint((SDBUS_DEBUG_ENUM, "WvddMax=%d WvddMin=%d RvddMax=%d RvddMin=%d\n",
                                   sdCsd->c.WriteCurrentVddMax, sdCsd->c.WriteCurrentVddMin, sdCsd->c.ReadCurrentVddMax, 
                                   sdCsd->c.ReadCurrentVddMin));

    DebugPrint((SDBUS_DEBUG_ENUM, "PartialBlkWrite=%d MaxWriteBlkLen=%d WriteSpeedFactor=%d WPGenable=%d\n",
                                   sdCsd->d.PartialBlocksWrite, sdCsd->d.MaxWriteDataBlockLength, sdCsd->d.WriteSpeedFactor, 
                                   sdCsd->d.WriteProtectGroupEnable));

    DebugPrint((SDBUS_DEBUG_ENUM, "FileFmt=%d TempWP=%d PermWP=%d CopyFlag=%d FileFmtGroup=%d\n",
                                   sdCsd->e.FileFormat, sdCsd->e.TempWriteProtect, sdCsd->e.PermWriteProtect, 
                                   sdCsd->e.CopyFlag, sdCsd->e.FileFormatGroup));
}

VOID
SdbusDebugDumpCid(
    PSD_CID sdCid
    )
{

    UCHAR productName[6];
    UCHAR j;
    PUCHAR pUc = (PUCHAR) sdCid;
    
    
    DebugPrint((SDBUS_DEBUG_ENUM, "------------------------CID----------------------\n"));
    
    DebugPrint((SDBUS_DEBUG_ENUM, "%02x %02x %02x %02x %02x %02x %02x %02x-%02x %02x %02x %02x %02x %02x %02x\n",
                                  pUc[0], pUc[1], pUc[2], pUc[3],
                                  pUc[4], pUc[5], pUc[6], pUc[7],
                                  pUc[8], pUc[9], pUc[10],pUc[11],
                                  pUc[12], pUc[13], pUc[14]));
    
    
    DebugPrint((SDBUS_DEBUG_ENUM, "ManufacturerId=%02x OEMId=%04x Rev=%02x PSN=%08x\n",
                                    sdCid->ManufacturerId, sdCid->OemId, sdCid->Revision, sdCid->SerialNumber));

    for (j=0; j<5; j++) productName[j] = sdCid->ProductName[4-j];
    productName[5] = 0;
    DebugPrint((SDBUS_DEBUG_ENUM, "ProductName = %s\n", productName));

    DebugPrint((SDBUS_DEBUG_ENUM, "ManufacturerDate=%d, %d\n",
                                    sdCid->a.ManufactureMonth, sdCid->a.ManufactureYearLow+(sdCid->b.ManufactureYearHigh<<4)+2000));

}

VOID
DebugDumpSdResponse(
    PULONG pResp,
    UCHAR ResponseType
    )
{    

    {
        ULONG resp = pResp[0];

        switch (ResponseType) {
        case SDCMD_RESP_NONE:
            break;


        case SDCMD_RESP_1:
            DebugPrint((SDBUS_DEBUG_DEVICE, "R1 resp %08x currentState = %d\n", resp, (resp & 0x00001e00) >> 9));
            break;

            
        case SDCMD_RESP_5:
            DebugPrint((SDBUS_DEBUG_DEVICE, "R5 resp %08x state=%d%s%s%s%s%s\n", resp, (resp > 12) & 3,
                                            resp & 0x8000 ? " CRC ERR" : "",
                                            resp & 0x4000 ? " CMD ERR" : "",
                                            resp & 0x0800 ? " GEN ERR" : "",
                                            resp & 0x0200 ? " FUNC NUM ERR" : "",
                                            resp & 0x0100 ? " RANGE ERR" : ""));
            break;
        
        case SDCMD_RESP_4:
        case SDCMD_RESP_6:
        case SDCMD_RESP_2:
        case SDCMD_RESP_3:
        case SDCMD_RESP_1B:
            DebugPrint((SDBUS_DEBUG_DEVICE, "resp=%08x %08x %08x %08x\n",
                                       pResp[0], pResp[1], pResp[2], pResp[3]));
            break;

        default:
            ASSERT(FALSE);
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\debug.h ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This header provides debugging support prototypes and macros

Author:

    Neil Sandlin (neilsa) Jan 1 2002

Revision History:


--*/


#if !defined(_DEBUG_)
#define DEBUG

#if DBG

//
// Debug mask flags
//
#define SDBUS_DEBUG_ALL       0x0FFFFFFF
#define SDBUS_DEBUG_FAIL      0x00000001
#define SDBUS_DEBUG_WARNING   0x00000002
#define SDBUS_DEBUG_INFO      0x00000004
#define SDBUS_DEBUG_ENUM      0x00000010
#define SDBUS_DEBUG_TUPLES    0x00000020
#define SDBUS_DEBUG_PNP       0x00000040
#define SDBUS_DEBUG_POWER     0x00000080
#define SDBUS_DEBUG_INTERFACE 0x00000100
#define SDBUS_DEBUG_IOCTL     0x00000200
#define SDBUS_DEBUG_WORKENG   0x00000400
#define SDBUS_DEBUG_WORKPROC  0x00000800
#define SDBUS_DEBUG_EVENT     0x00001000
#define SDBUS_DEBUG_CARD_EVT  0x00002000
#define SDBUS_DEBUG_DEVICE    0x00010000
#define SDBUS_DEBUG_DUMP_REGS 0x00020000

#define SDBUS_DEBUG_BREAK     0x10000000
#define SDBUS_DEBUG_LOG       0x20000000


#define DBGLOGWIDTH 128
#define DBGLOGCOUNT 500


typedef struct _SDBUS_STRING_MAP {
    ULONG Id;
    PCHAR String;
} SDBUS_STRING_MAP, *PSDBUS_STRING_MAP;

//
// Debug globals
//

extern ULONG SdbusDebugMask;
extern SDBUS_STRING_MAP SdbusDbgPnpIrpStringMap[];
extern SDBUS_STRING_MAP SdbusDbgPoIrpStringMap[];
extern SDBUS_STRING_MAP SdbusDbgDeviceRelationStringMap[];
extern SDBUS_STRING_MAP SdbusDbgSystemPowerStringMap[];
extern SDBUS_STRING_MAP SdbusDbgDevicePowerStringMap[];
extern PSDBUS_STRING_MAP SdbusDbgStatusStringMap;
extern SDBUS_STRING_MAP SdbusDbgFdoPowerWorkerStringMap[];
extern SDBUS_STRING_MAP SdbusDbgPdoPowerWorkerStringMap[];
extern SDBUS_STRING_MAP SdbusDbgSocketPowerWorkerStringMap[];
extern SDBUS_STRING_MAP SdbusDbgConfigurationWorkerStringMap[];
extern SDBUS_STRING_MAP SdbusDbgTupleStringMap[];
extern SDBUS_STRING_MAP SdbusDbgWakeStateStringMap[];
extern SDBUS_STRING_MAP SdbusDbgEventStringMap[];
extern SDBUS_STRING_MAP SdbusDbgWPFunctionStringMap[];
extern SDBUS_STRING_MAP SdbusDbgWorkerStateStringMap[];
extern SDBUS_STRING_MAP SdbusDbgSocketStateStringMap[];

//
// Debug prototypes
//

PCHAR
SdbusDbgLookupString(
    IN PSDBUS_STRING_MAP Map,
    IN ULONG Id
    );


VOID
SdbusDebugPrint(
                ULONG  DebugMask,
                PCCHAR DebugMessage,
                ...
                );

VOID
SdbusDumpDbgLog(
    );
    
VOID
SdbusPrintLogEntry(
    LONG index
    );

VOID
SdbusClearDbgLog(
    );
    
VOID
SdbusInitializeDbgLog(
    PUCHAR buffer
    );

VOID
SdbusDebugDumpCsd(
    PSD_CSD pSdCsd
    );

VOID
SdbusDebugDumpCid(
    PSD_CID pSdCid
    );
    
VOID
DebugDumpSdResponse(
    PULONG pResp,
    UCHAR ResponseType
    );
    
//
// Debug macros
//
#define DebugPrint(X) SdbusDebugPrint X

#define STATUS_STRING(_Status)                                              \
    (_Status) == STATUS_SUCCESS ?                                           \
        "STATUS_SUCCESS" : SdbusDbgLookupString(SdbusDbgStatusStringMap, (_Status))

#define PNP_IRP_STRING(_Irp)                                                \
    SdbusDbgLookupString(SdbusDbgPnpIrpStringMap, (_Irp))

#define PO_IRP_STRING(_Irp)                                                 \
    SdbusDbgLookupString(SdbusDbgPoIrpStringMap, (_Irp))

#define RELATION_STRING(_Relation)                                          \
    SdbusDbgLookupString(SdbusDbgDeviceRelationStringMap, (_Relation))

#define SYSTEM_POWER_STRING(_State)                                         \
    SdbusDbgLookupString(SdbusDbgSystemPowerStringMap, (_State))

#define DEVICE_POWER_STRING(_State)                                         \
    SdbusDbgLookupString(SdbusDbgDevicePowerStringMap, (_State))

#define FDO_POWER_WORKER_STRING(_State)                                    \
    SdbusDbgLookupString(SdbusDbgFdoPowerWorkerStringMap, (_State))

#define PDO_POWER_WORKER_STRING(_State)                                    \
    SdbusDbgLookupString(SdbusDbgPdoPowerWorkerStringMap, (_State))

#define SOCKET_POWER_WORKER_STRING(_State)                                 \
    SdbusDbgLookupString(SdbusDbgSocketPowerWorkerStringMap, (_State))

#define TUPLE_STRING(_Tuple)                                                \
    SdbusDbgLookupString(SdbusDbgTupleStringMap, (_Tuple))

#define WAKESTATE_STRING(_State)                                                \
    SdbusDbgLookupString(SdbusDbgWakeStateStringMap, (_State))

#define EVENT_STRING(_State)                                                \
    SdbusDbgLookupString(SdbusDbgEventStringMap, (_State))

#define WP_FUNC_STRING(_State)                                                \
    SdbusDbgLookupString(SdbusDbgWPFunctionStringMap, (_State))

#define WORKER_STATE_STRING(_State)                                                \
    SdbusDbgLookupString(SdbusDbgWorkerStateStringMap, (_State))

#define SOCKET_STATE_STRING(_State)                                                \
    SdbusDbgLookupString(SdbusDbgSocketStateStringMap, (_State))

//
// Structures
//


#else

//
// !defined DBG
//

#define DebugPrint(X)
#define SdbusDumpDbgLog()
#define DebugDumpSdResponse(x, y)
#define DUMP_SOCKET(Socket)
#define PDO_TRACE(PdoExt, Context)
#define STATUS_STRING(_Status)      ""
#define PNP_IRP_STRING(_Irp)        ""
#define PO_IRP_STRING(_Irp)         ""
#define RELATION_STRING(_Relation)  ""
#define SYSTEM_POWER_STRING(_State) ""
#define DEVICE_POWER_STRING(_State) ""

#endif // DBG

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\interupt.c ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    interupt.c

Abstract:

    This module contains code to support events generated by the
    sd controller.

Author:

    Neil Sandlin (neilsa) 1-Jan-2002

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

VOID
SdbusEventWorkItemProc(
    IN PDEVICE_OBJECT Fdo,
    IN PVOID Context
    );

VOID
SdbusReflectCardInterrupt(
    IN PDEVICE_OBJECT Fdo
    );



BOOLEAN
SdbusInterrupt(
   IN PKINTERRUPT InterruptObject,
   PVOID Context
   )

/*++

Routine Description:

    interrupt handler

Arguments:

    InterruptObject - Pointer to the interrupt object.
    Context - Pointer to the device context.

Return Value:

    Status

--*/

{
    PFDO_EXTENSION    fdoExtension;
    ULONG eventMask;
   
    fdoExtension=((PDEVICE_OBJECT)Context)->DeviceExtension;
   
    if (fdoExtension->Flags & SDBUS_FDO_OFFLINE) {
       return FALSE;
    }
   

    eventMask = (*(fdoExtension->FunctionBlock->GetPendingEvents))(fdoExtension);

    if (eventMask) {

        fdoExtension->IsrEventStatus |= eventMask;

        (*(fdoExtension->FunctionBlock->DisableEvent))(fdoExtension, eventMask);
        //
        // Something changed out there.. could be
        // a card insertion/removal.
        // Request a DPC to check it out.
        //
        IoRequestDpc((PDEVICE_OBJECT) Context, NULL, NULL);
    }
    return (eventMask != 0);
}


BOOLEAN
SdbusInterruptSynchronize(
    PFDO_EXTENSION fdoExtension
    )
{

    fdoExtension->LatchedIsrEventStatus = fdoExtension->IsrEventStatus;
    fdoExtension->IsrEventStatus = 0;
    return TRUE;
}    


VOID
SdbusInterruptDpc(
   IN PKDPC          Dpc,
   IN PDEVICE_OBJECT DeviceObject,
   IN PVOID          SystemContext1,
   IN PVOID          SystemContext2
   )

/*++

Routine Description:

    This DPC is just an intermediate step in getting to the main DPC
    handler. This is used to "debounce" hardware and give it some time after
    the physical interrupt has come in.

Arguments:

    DeviceObject - Pointer to the device object.

Return Value:


--*/

{
    PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    static ULONG IoWorkerEventTypes[] = {SDBUS_EVENT_CARD_RW_END,
                                         SDBUS_EVENT_BUFFER_EMPTY,
                                         SDBUS_EVENT_BUFFER_FULL,
                                         SDBUS_EVENT_CARD_RESPONSE,
                                         0};
    UCHAR i;
    ULONG acknowledgedEvents;
   
   
    if (fdoExtension->Flags & SDBUS_FDO_OFFLINE) {
       return;
    }
    

    KeSynchronizeExecution(fdoExtension->SdbusInterruptObject, SdbusInterruptSynchronize, fdoExtension);

    DebugPrint((SDBUS_DEBUG_EVENT, "SdbusDpc: Event Status %08x\n", fdoExtension->LatchedIsrEventStatus));

    if (fdoExtension->LatchedIsrEventStatus & SDBUS_EVENT_INSERTION) {

        DebugPrint((SDBUS_DEBUG_EVENT, "SdbusDpc: Card Insertion\n"));
   
        (*(fdoExtension->FunctionBlock->AcknowledgeEvent))(fdoExtension, SDBUS_EVENT_INSERTION);
        fdoExtension->LatchedIsrEventStatus &= ~SDBUS_EVENT_INSERTION;
        SdbusActivateSocket(DeviceObject, NULL, NULL);
    }        
        
    if (fdoExtension->LatchedIsrEventStatus & SDBUS_EVENT_REMOVAL) {

        DebugPrint((SDBUS_DEBUG_EVENT, "SdbusDpc: Card Removal\n"));
   
        (*(fdoExtension->FunctionBlock->AcknowledgeEvent))(fdoExtension, SDBUS_EVENT_REMOVAL);
        fdoExtension->LatchedIsrEventStatus &= ~SDBUS_EVENT_REMOVAL;
        SdbusActivateSocket(DeviceObject, NULL, NULL);
        
    }        

    acknowledgedEvents = 0;

    for(i = 0; IoWorkerEventTypes[i] != 0; i++) {
        if (fdoExtension->LatchedIsrEventStatus & IoWorkerEventTypes[i]) {

            DebugPrint((SDBUS_DEBUG_EVENT, "SdbusDpc: received event %08x - %s\n",
                        IoWorkerEventTypes[i], EVENT_STRING(IoWorkerEventTypes[i])));
        
            (*(fdoExtension->FunctionBlock->AcknowledgeEvent))(fdoExtension, IoWorkerEventTypes[i]);

            DebugPrint((SDBUS_DEBUG_EVENT, "SdbusDpc: ack'd event %08x - %s\n",
                        IoWorkerEventTypes[i], EVENT_STRING(IoWorkerEventTypes[i])));

            acknowledgedEvents |= IoWorkerEventTypes[i];
            fdoExtension->LatchedIsrEventStatus &= ~IoWorkerEventTypes[i];
        }        
    }
    
    
    if (acknowledgedEvents) {
    
        DebugPrint((SDBUS_DEBUG_EVENT, "SdbusDpc: dispatching event %08x\n", acknowledgedEvents));
        SdbusPushWorkerEvent(fdoExtension, acknowledgedEvents);
    }
    
    //
    // Now check to see if the card has interrupted, and call back to the function driver
    //
    if (fdoExtension->LatchedIsrEventStatus & SDBUS_EVENT_CARD_INTERRUPT) {
    
        DebugPrint((SDBUS_DEBUG_EVENT, "SdbusDpc: got CARD INTERRUPT\n"));

        SdbusReflectCardInterrupt(DeviceObject);

        fdoExtension->LatchedIsrEventStatus &= ~SDBUS_EVENT_CARD_INTERRUPT;
    }
    
    ASSERT(fdoExtension->LatchedIsrEventStatus == 0);

    return;
}   




VOID
SdbusReflectCardInterrupt(
    IN PDEVICE_OBJECT Fdo
    )
{
    PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PDEVICE_OBJECT pdo;
    PPDO_EXTENSION pdoExtension;
    
    //
    // ISSUE: NEED TO IMPLEMENT:
    //  need to queue an IoWorker packet to read the CCCR and find out which
    //  function is interrupting. For now, assume there is only a single I/O function,
    //  and use the first callback found.
    //        
    for (pdo = fdoExtension->PdoList; pdo != NULL; pdo = pdoExtension->NextPdoInFdoChain) {
        pdoExtension = pdo->DeviceExtension;
        
        if (pdoExtension->Flags & SDBUS_PDO_GENERATES_IRQ) {
        
        
            if (pdoExtension->Flags & SDBUS_PDO_DPC_CALLBACK) {
            
                pdoExtension->Flags |= SDBUS_PDO_CALLBACK_IN_SERVICE;
                (pdoExtension->CallbackRoutine)(pdoExtension->CallbackRoutineContext, 0);
                
            } else {
                pdoExtension->Flags |= SDBUS_PDO_CALLBACK_REQUESTED;
                KeSetEvent(&fdoExtension->CardInterruptEvent, 0, FALSE);
            }                
        }
    }
}    

VOID
SdbusEventWorkItemProc(
    IN PDEVICE_OBJECT Fdo,
    IN PVOID Context
    )
{
    PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PKEVENT Events[2] = {&fdoExtension->CardInterruptEvent, &fdoExtension->WorkItemExitEvent};
    PDEVICE_OBJECT pdo;
    PPDO_EXTENSION pdoExtension;
    NTSTATUS status;

    while(TRUE){
    
        status = KeWaitForMultipleObjects(2, Events, WaitAny,
                                          Executive, KernelMode, FALSE,
                                          NULL, NULL);

        if ((fdoExtension->Flags & SDBUS_FDO_WORK_ITEM_ACTIVE) == 0) {
            break;
        }
        
        for (pdo = fdoExtension->PdoList; pdo != NULL; pdo = pdoExtension->NextPdoInFdoChain) {
            pdoExtension = pdo->DeviceExtension;
            
            if (pdoExtension->Flags & SDBUS_PDO_GENERATES_IRQ) {
            
                DebugPrint((SDBUS_DEBUG_CARD_EVT, "WorkItemProc: CallBack %08x %08x\n", pdoExtension->CallbackRoutine,
                                                    pdoExtension->CallbackRoutineContext));
                
                ASSERT((pdoExtension->Flags & SDBUS_PDO_CALLBACK_IN_SERVICE) == 0);
                
                pdoExtension->Flags |= SDBUS_PDO_CALLBACK_IN_SERVICE;
                pdoExtension->Flags &= ~SDBUS_PDO_CALLBACK_REQUESTED;
                (pdoExtension->CallbackRoutine)(pdoExtension->CallbackRoutineContext, 0);
                
            }
            
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\extern.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    extern.h

Abstract:

    External definitions for intermodule functions.

Revision History:

--*/
#ifndef _SDBUS_EXTERN_H_
#define _SDBUS_EXTERN_H_

//
// Global data referenced by the driver
//
extern ULONG                          SdbusGlobalFlags;
extern ULONG                          SdbusDebugMask;
extern PDEVICE_OBJECT                 FdoList;

extern GLOBAL_REGISTRY_INFORMATION GlobalRegistryInfo[];
extern ULONG GlobalInfoCount;

extern const PCI_CONTROLLER_INFORMATION   PciControllerInformation[];
extern const PCI_VENDOR_INFORMATION       PciVendorInformation[];
extern KEVENT                       SdbusDelayTimerEvent;
extern KSPIN_LOCK SdbusGlobalLock;
extern ULONG EventDpcDelay;
extern ULONG SdbusPowerPolicy;

extern const UCHAR SdbusCmdResponse[];
extern const UCHAR SdbusACmdResponse[];


extern SD_FUNCTION_BLOCK ToshibaSupportFns;

//
// Irp dispatch routines
//

VOID
SdbusInitDeviceDispatchTable(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
SdbusFdoPnpDispatch(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp
    );

NTSTATUS
SdbusPdoPnpDispatch(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    );

NTSTATUS
SdbusOpenCloseDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SdbusCleanupDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SdbusFdoDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SdbusPdoDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SdbusPdoInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SdbusFdoSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SdbusPdoSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// enumeration routines
//

NTSTATUS
SdbusEnumerateDevices(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp
    );

NTSTATUS
SdbusGetCardConfigData(
    IN PFDO_EXTENSION FdoExtension,
    OUT PSD_CARD_DATA *pCardData
    );

VOID
SdbusCleanupCardData(
    IN PSD_CARD_DATA CardData
    );

UCHAR
SdbusReadCIAChar(
    IN PFDO_EXTENSION FdoExtension,
    IN ULONG ciaPtr
    );
        
VOID
SdbusWriteCIAChar(
    IN PFDO_EXTENSION FdoExtension,
    IN ULONG ciaPtr,
    IN UCHAR data
    );

//
// controller support routines
//

NTSTATUS
SdbusAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT pdo
    );

VOID
SdbusCleanupPdo(
    IN PDEVICE_OBJECT Pdo
    );

VOID
SdbusActivateSocket(
    IN PDEVICE_OBJECT Fdo,
    IN PSDBUS_ACTIVATE_COMPLETION_ROUTINE CompletionRoutine,
    IN PVOID Context
    );

//
// Interface routines
//

NTSTATUS
SdbusPdoQueryInterface(
    IN PDEVICE_OBJECT Pdo,
    IN OUT PIRP       Irp
    );

NTSTATUS
SdbusGetInterface(
    IN PDEVICE_OBJECT Pdo,
    IN CONST GUID *pGuid,
    IN USHORT sizeofInterface,
    OUT PINTERFACE pInterface
    );

NTSTATUS
SdbusGetSetPciConfigData(
    IN PDEVICE_OBJECT PciPdo,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length,
    IN BOOLEAN Read
    );

//
// Interrupt routines
//

BOOLEAN
SdbusInterrupt(
    IN PKINTERRUPT InterruptObject,
    IN PVOID       Context
    );

VOID
SdbusInterruptDpc(
    IN PKDPC          Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          SystemContext1,
    IN PVOID          SystemContext2
    );

VOID
SdbusDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SdbusEventWorkItemProc(
    IN PDEVICE_OBJECT Fdo,
    IN PVOID Context
    );

//
// Registry routines
//

NTSTATUS
SdbusLoadGlobalRegistryValues(
    VOID
    );

NTSTATUS
SdbusGetControllerRegistrySettings(
    IN OUT PFDO_EXTENSION FdoExtension
    );



#endif // _SDBUS_EXTERN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\intrface.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    io.c

Abstract:

    This module handles device ioctl's and read/write to the sdbus driver.

Authors:

    Neil Sandlin (neilsa) 1-Jan-2002

Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"

NTSTATUS
SdbusPdoSubmitRequest(
    IN PFDO_EXTENSION fdoExtension,
    IN PPDO_EXTENSION pdoExtension,
    IN PSDBUS_REQUEST_PACKET SdRp,
    PSDBUS_WORKPACKET_COMPLETION_ROUTINE CompletionRoutine,    
    IN PIRP Irp
    );

VOID
SdbusPdoInternalIoctlCompletion (
    IN PSD_WORK_PACKET WorkPacket,
    IN NTSTATUS status
    );
    
VOID
SdbusPdoIoctlCompletion (
    IN PSD_WORK_PACKET WorkPacket,
    IN NTSTATUS status
    );



NTSTATUS
SdbusFdoDeviceControl(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    IOCTL device routine

Arguments:

    DeviceObject - Pointer to the device object.
    Irp - Pointer to the IRP

Return Value:

    Status

--*/

{

    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
SdbusPdoInternalDeviceControl(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    IOCTL device routine

Arguments:

    DeviceObject - Pointer to the device object.
    Irp - Pointer to the IRP

Return Value:

    Status

--*/

{
    PPDO_EXTENSION      pdoExtension = Pdo->DeviceExtension;
    PFDO_EXTENSION      fdoExtension = pdoExtension->FdoExtension;
    PDEVICE_OBJECT      fdo = fdoExtension->DeviceObject;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status = STATUS_SUCCESS;

    DebugPrint((SDBUS_DEBUG_IOCTL, "pdo %.08x irp %.08x code %08x DISPATCH\n", Pdo, Irp,
                                   irpSp->Parameters.DeviceIoControl.IoControlCode));


    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_SD_SUBMIT_REQUEST: {
        PSDBUS_REQUEST_PACKET SdRp = Irp->AssociatedIrp.SystemBuffer;

        if (irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SDBUS_REQUEST_PACKET)) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Build and queue a work packet to handle this request
        //
        status = SdbusPdoSubmitRequest(fdoExtension,
                                       pdoExtension,
                                       SdRp,
                                       SdbusPdoInternalIoctlCompletion,
                                       Irp);
        
        break;
    }        
    
    default:
        status = STATUS_INVALID_DEVICE_REQUEST;
        DebugPrint((SDBUS_DEBUG_IOCTL, "pdo %.08x irp %.08x complete %08x\n", Pdo, Irp, status));
        break;
    }
    
    if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DebugPrint((SDBUS_DEBUG_IOCTL, "pdo %.08x ioctl exits %08x\n", Pdo, status));
    return status;
}



VOID
SdbusPdoInternalIoctlCompletion (
    IN PSD_WORK_PACKET WorkPacket,
    IN NTSTATUS status
    )
{
    PIRP irp = WorkPacket->CompletionContext;

    DebugPrint((SDBUS_DEBUG_IOCTL, "pdo %08x irp %08x ioctl complete %08x\n",
                                    WorkPacket->PdoExtension->DeviceObject, irp, status));
    
    if (NT_SUCCESS(status)) {
        irp->IoStatus.Information = WorkPacket->Information;
    }
    
    irp->IoStatus.Status = status;
    IoCompleteRequest(irp, IO_NO_INCREMENT);
    
    ExFreePool(WorkPacket);
}    



NTSTATUS
SdbusPdoSubmitRequest(
    IN PFDO_EXTENSION fdoExtension,
    IN PPDO_EXTENSION pdoExtension,
    IN PSDBUS_REQUEST_PACKET SdRp,
    PSDBUS_WORKPACKET_COMPLETION_ROUTINE CompletionRoutine,    
    IN PIRP Irp
    )
{
    NTSTATUS status;
    PSD_WORK_PACKET     workPacket;

    switch(SdRp->Function) {
    
    case SDRP_READ_BLOCK:
        status = SdbusBuildWorkPacket(fdoExtension,
                                      SDWP_READBLOCK,
                                      CompletionRoutine,
                                      Irp,
                                      &workPacket);
        if (!NT_SUCCESS(status)) {
            break;
        }                                      
       
        workPacket->PdoExtension                    = pdoExtension;
        workPacket->Parameters.ReadBlock.ByteOffset = SdRp->Parameters.ReadBlock.ByteOffset;
        workPacket->Parameters.ReadBlock.Buffer     = SdRp->Parameters.ReadBlock.Buffer;
        workPacket->Parameters.ReadBlock.Length     = SdRp->Parameters.ReadBlock.Length;
       
        SdbusQueueWorkPacket(fdoExtension, workPacket, WP_TYPE_IO);
        status = STATUS_PENDING;
        break;
        
    case SDRP_WRITE_BLOCK:
    
        if ((*(fdoExtension->FunctionBlock->IsWriteProtected))(fdoExtension)) {
            status = STATUS_MEDIA_WRITE_PROTECTED;
            break;
        }
       
        status = SdbusBuildWorkPacket(fdoExtension,
                                      SDWP_WRITEBLOCK,
                                      CompletionRoutine,
                                      Irp,
                                      &workPacket);
        if (!NT_SUCCESS(status)) {
            break;
        }                                      
           
        workPacket->PdoExtension                     = pdoExtension;
        workPacket->Parameters.WriteBlock.ByteOffset = SdRp->Parameters.WriteBlock.ByteOffset;
        workPacket->Parameters.WriteBlock.Buffer     = SdRp->Parameters.WriteBlock.Buffer;
        workPacket->Parameters.WriteBlock.Length     = SdRp->Parameters.WriteBlock.Length;
        IoMarkIrpPending(Irp);
       
        SdbusQueueWorkPacket(fdoExtension, workPacket, WP_TYPE_IO);
        status = STATUS_PENDING;
        break;

    case SDRP_READ_IO:
        status = SdbusBuildWorkPacket(fdoExtension,
                                      SDWP_READIO,
                                      CompletionRoutine,
                                      Irp,
                                      &workPacket);
        if (!NT_SUCCESS(status)) {
            break;
        }                                      
       
        workPacket->PdoExtension             = pdoExtension;
        workPacket->Parameters.ReadIo.Offset = SdRp->Parameters.ReadIo.Offset;
        workPacket->Parameters.ReadIo.Buffer = SdRp->Parameters.ReadIo.Buffer;
        workPacket->Parameters.ReadIo.Length = 1;
        IoMarkIrpPending(Irp);
       
        SdbusQueueWorkPacket(fdoExtension, workPacket, WP_TYPE_IO);
        status = STATUS_PENDING;
        break;
        
    case SDRP_READ_IO_EXTENDED:
        status = SdbusBuildWorkPacket(fdoExtension,
                                      SDWP_READIO_EXTENDED,
                                      CompletionRoutine,
                                      Irp,
                                      &workPacket);
        if (!NT_SUCCESS(status)) {
            break;
        }                                      
       
        workPacket->PdoExtension             = pdoExtension;
        workPacket->Parameters.ReadIo.Offset = SdRp->Parameters.ReadIoExtended.Offset;
        workPacket->Parameters.ReadIo.Buffer = SdRp->Parameters.ReadIoExtended.Buffer;
        workPacket->Parameters.ReadIo.Length = SdRp->Parameters.ReadIoExtended.Length;
        IoMarkIrpPending(Irp);
       
        SdbusQueueWorkPacket(fdoExtension, workPacket, WP_TYPE_IO);
        status = STATUS_PENDING;
        break;
        

    case SDRP_WRITE_IO:
        status = SdbusBuildWorkPacket(fdoExtension,
                                      SDWP_WRITEIO,
                                      CompletionRoutine,
                                      Irp,
                                      &workPacket);
        if (!NT_SUCCESS(status)) {
            break;
        }                                      
       
        workPacket->PdoExtension              = pdoExtension;
        workPacket->Parameters.WriteIo.Offset = SdRp->Parameters.WriteIo.Offset;
        workPacket->Parameters.WriteIo.Data   = SdRp->Parameters.WriteIo.Data;
        workPacket->Parameters.WriteIo.Length = 1;
        IoMarkIrpPending(Irp);
       
        SdbusQueueWorkPacket(fdoExtension, workPacket, WP_TYPE_IO);
        status = STATUS_PENDING;
        break;
        
    case SDRP_WRITE_IO_EXTENDED:
        status = SdbusBuildWorkPacket(fdoExtension,
                                      SDWP_WRITEIO_EXTENDED,
                                      CompletionRoutine,
                                      Irp,
                                      &workPacket);
        if (!NT_SUCCESS(status)) {
            break;
        }                                      
       
        workPacket->PdoExtension              = pdoExtension;
        workPacket->Parameters.WriteIo.Offset = SdRp->Parameters.WriteIoExtended.Offset;
        workPacket->Parameters.WriteIo.Buffer = SdRp->Parameters.WriteIoExtended.Buffer;
        workPacket->Parameters.WriteIo.Length = SdRp->Parameters.WriteIoExtended.Length;
        IoMarkIrpPending(Irp);
       
        SdbusQueueWorkPacket(fdoExtension, workPacket, WP_TYPE_IO);
        status = STATUS_PENDING;
        break;
        
    case SDRP_ACKNOWLEDGE_INTERRUPT:
    
        ASSERT((pdoExtension->Flags & SDBUS_PDO_CALLBACK_IN_SERVICE) != 0);
    
        pdoExtension->Flags &= ~SDBUS_PDO_CALLBACK_IN_SERVICE;
        
        (*(fdoExtension->FunctionBlock->AcknowledgeEvent))(fdoExtension, SDBUS_EVENT_CARD_INTERRUPT);
        status = STATUS_SUCCESS;
        break;
        
    default:
        status = STATUS_INVALID_PARAMETER;
    }

    return status;        
}    





NTSTATUS
SdbusPdoDeviceControl(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    IOCTL device routine

Arguments:

    DeviceObject - Pointer to the device object.
    Irp - Pointer to the IRP

Return Value:

    Status

--*/

{
    PPDO_EXTENSION      pdoExtension = Pdo->DeviceExtension;
    PFDO_EXTENSION      fdoExtension = pdoExtension->FdoExtension;
    PDEVICE_OBJECT      fdo = fdoExtension->DeviceObject;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status = STATUS_SUCCESS;
    PSD_WORK_PACKET     workPacket;

    DebugPrint((SDBUS_DEBUG_IOCTL, "pdo %.08x irp %.08x code %08x DISPATCH\n", Pdo, Irp,
                                   irpSp->Parameters.DeviceIoControl.IoControlCode));


    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
    
    case IOCTL_SD_INTERFACE_OPEN: {
        PSDBUS_INTERFACE_DATA interfaceData = Irp->AssociatedIrp.SystemBuffer;
        
        if (irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SDBUS_INTERFACE_DATA)) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        if (interfaceData->DeviceGeneratesInterrupts) {
            pdoExtension->Flags |= SDBUS_PDO_GENERATES_IRQ;
            //
            // ISSUE: this is not multifunction-aware
            //

            if (interfaceData->CallbackAtDpcLevel) {

                //
                // reflect ISR at dispatch level
                //
                pdoExtension->Flags |= SDBUS_PDO_DPC_CALLBACK;

            } else {

                //
                // reflect ISR at passive level
                //
                KeInitializeEvent(&fdoExtension->CardInterruptEvent, SynchronizationEvent, FALSE);
                KeInitializeEvent(&fdoExtension->WorkItemExitEvent, SynchronizationEvent, FALSE);
                
                fdoExtension->Flags |= SDBUS_FDO_WORK_ITEM_ACTIVE;
                IoQueueWorkItem(fdoExtension->IoWorkItem,
                                SdbusEventWorkItemProc,
                                DelayedWorkQueue,
                                NULL);

            }
                
            (*(fdoExtension->FunctionBlock->EnableEvent))(fdoExtension, SDBUS_EVENT_CARD_INTERRUPT);
        }            


        // TO IMPLEMENT: can I validate this address at all?        
        pdoExtension->CallbackRoutine        = interfaceData->CallbackRoutine;
        pdoExtension->CallbackRoutineContext = interfaceData->CallbackRoutineContext;
        
        status = STATUS_SUCCESS;
        break;
    }        


    case IOCTL_SD_INTERFACE_CLOSE:
        //
        // ISSUE: this is not multifunction-aware
        //
        if (fdoExtension->Flags & SDBUS_FDO_WORK_ITEM_ACTIVE) {

            fdoExtension->Flags &= ~SDBUS_FDO_WORK_ITEM_ACTIVE;
            KeSetEvent(&fdoExtension->WorkItemExitEvent, 0, FALSE);
        }
        
        status = STATUS_SUCCESS;
        break;


    case IOCTL_SD_GET_DEVICE_PARMS: {
        PSDBUS_DEVICE_PARAMETERS deviceParameters = Irp->AssociatedIrp.SystemBuffer;
        ULONG deviceSize;
        ULONGLONG capacity, blockNr, mult, block_len;
        PSD_CSD sdCsd;

        DebugPrint((SDBUS_DEBUG_IOCTL, "IOCTL_SD_GET_DEVICE_PARMS\n"));

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SDBUS_DEVICE_PARAMETERS)) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //ISSUE: NEED TO IMPLEMENT: synchronization
        sdCsd = &fdoExtension->CardData->SdCsd;

        deviceSize = sdCsd->b.DeviceSizeHigh << 2 | sdCsd->c.DeviceSizeLow;
        mult = (1 << (sdCsd->c.DeviceSizeMultiplier+2));
        blockNr = (deviceSize+1) * mult;
        block_len = (1 << sdCsd->b.MaxReadDataBlockLength);
        capacity = blockNr * block_len;

        deviceParameters->Capacity = capacity;

        deviceParameters->WriteProtected = (*(fdoExtension->FunctionBlock->IsWriteProtected))(fdoExtension);

        Irp->IoStatus.Information = sizeof(SDBUS_DEVICE_PARAMETERS);
        DebugPrint((SDBUS_DEBUG_IOCTL, "pdo %.08x irp %.08x complete %08x\n", Pdo, Irp, status));
        break;
    }

    
#if 0
    case IOCTL_SD_READ_BLOCK: {
        PSDBUS_READ_PARAMETERS readParameters = Irp->AssociatedIrp.SystemBuffer;

        DebugPrint((SDBUS_DEBUG_IOCTL, "IOCTL_SD_READ_BLOCK - off %08x len %08x\n",
                                        (ULONG)readParameters->ByteOffset, readParameters->Length));

        if ((irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SDBUS_READ_PARAMETERS)) ||
            (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG_PTR))) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        status = SdbusBuildWorkPacket(fdoExtension,
                                      SDWP_READBLOCK,
                                      SdbusPdoIoctlCompletion,
                                      Irp,
                                      &workPacket);
        if (!NT_SUCCESS(status)) {
            break;
        }                                      

        workPacket->PdoExtension                    = pdoExtension;
        workPacket->Parameters.ReadBlock.ByteOffset = readParameters->ByteOffset;
        workPacket->Parameters.ReadBlock.Buffer     = readParameters->Buffer;
        workPacket->Parameters.ReadBlock.Length     = readParameters->Length;

        IoMarkIrpPending(Irp);
        Irp = NULL;
        SdbusQueueWorkPacket(fdoExtension, workPacket, WP_TYPE_IO);
        status = STATUS_PENDING;
        break;
    }


    case IOCTL_SD_WRITE_BLOCK: {
        PSDBUS_WRITE_PARAMETERS writeParameters = Irp->AssociatedIrp.SystemBuffer;

        DebugPrint((SDBUS_DEBUG_IOCTL, "IOCTL_SD_WRITE_BLOCK - off %08x len %08x\n",
                                        (ULONG)writeParameters->ByteOffset, writeParameters->Length));

        if ((irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SDBUS_WRITE_PARAMETERS)) ||
            (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG_PTR))) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        if ((*(fdoExtension->FunctionBlock->IsWriteProtected))(fdoExtension)) {
            status = STATUS_MEDIA_WRITE_PROTECTED;
            break;
        }

        status = SdbusBuildWorkPacket(fdoExtension,
                                      SDWP_WRITEBLOCK,
                                      SdbusPdoIoctlCompletion,
                                      Irp,
                                      &workPacket);
        if (!NT_SUCCESS(status)) {
            break;
        }                                      

        workPacket->PdoExtension                     = pdoExtension;
        workPacket->Parameters.WriteBlock.ByteOffset = writeParameters->ByteOffset;
        workPacket->Parameters.WriteBlock.Buffer     = writeParameters->Buffer;
        workPacket->Parameters.WriteBlock.Length     = writeParameters->Length;

        IoMarkIrpPending(Irp);
        Irp = NULL;
        SdbusQueueWorkPacket(fdoExtension, workPacket, WP_TYPE_IO);
        status = STATUS_PENDING;
        break;
    }

    case IOCTL_SD_IO_READ: {
        PSDBUS_IO_READ_PARAMETERS readParameters = Irp->AssociatedIrp.SystemBuffer;
        WORKPROC_FUNCTION workProcFunction;
        
        if ((irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SDBUS_IO_READ_PARAMETERS)) ||
            (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG_PTR))) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        
        if (readParameters->CmdType == 52) {
            workProcFunction = SDWP_READIO;
        } else if (readParameters->CmdType == 53) {
            workProcFunction = SDWP_READIO_EXTENDED;
        } else {            
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        
        status = SdbusBuildWorkPacket(fdoExtension,
                                      workProcFunction,
                                      SdbusPdoIoctlCompletion,
                                      Irp,
                                      &workPacket);
        if (!NT_SUCCESS(status)) {
            break;
        }                                      

        workPacket->PdoExtension              = pdoExtension;
        workPacket->Parameters.ReadIo.Offset  = readParameters->Offset;
        workPacket->Parameters.ReadIo.Buffer  = readParameters->Buffer;
        workPacket->Parameters.ReadIo.Length  = readParameters->Length;

        IoMarkIrpPending(Irp);
        Irp = NULL;
        SdbusQueueWorkPacket(fdoExtension, workPacket, WP_TYPE_IO);
        status = STATUS_PENDING;
        break;
    }
    
    case IOCTL_SD_IO_WRITE: {
        PSDBUS_IO_WRITE_PARAMETERS writeParameters = Irp->AssociatedIrp.SystemBuffer;
        WORKPROC_FUNCTION workProcFunction;

        if ((irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SDBUS_IO_WRITE_PARAMETERS)) ||
            (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG_PTR))) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        
        if (writeParameters->CmdType == 52) {
            workProcFunction = SDWP_WRITEIO;
        } else if (writeParameters->CmdType == 53) {
            workProcFunction = SDWP_WRITEIO_EXTENDED;
        } else {            
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        
        status = SdbusBuildWorkPacket(fdoExtension,
                                      workProcFunction,
                                      SdbusPdoIoctlCompletion,
                                      Irp,
                                      &workPacket);
        if (!NT_SUCCESS(status)) {
            break;
        }

        workPacket->PdoExtension               = pdoExtension;
        workPacket->Parameters.WriteIo.Offset  = writeParameters->Offset;
        workPacket->Parameters.WriteIo.Buffer  = writeParameters->Buffer;
        workPacket->Parameters.WriteIo.Length  = writeParameters->Length;

        IoMarkIrpPending(Irp);
        Irp = NULL;
        SdbusQueueWorkPacket(fdoExtension, workPacket, WP_TYPE_IO);
        status = STATUS_PENDING;
        break;
    }
#endif    
    

    case IOCTL_SD_ACKNOWLEDGE_CARD_IRQ:
    
        ASSERT((pdoExtension->Flags & SDBUS_PDO_CALLBACK_IN_SERVICE) != 0);
    
        pdoExtension->Flags &= ~SDBUS_PDO_CALLBACK_IN_SERVICE;
        
        (*(fdoExtension->FunctionBlock->AcknowledgeEvent))(fdoExtension, SDBUS_EVENT_CARD_INTERRUPT);
        status = STATUS_SUCCESS;
        break;
        

    default:
        status = STATUS_INVALID_DEVICE_REQUEST;
        DebugPrint((SDBUS_DEBUG_IOCTL, "pdo %.08x irp %.08x complete %08x\n", Pdo, Irp, status));
        break;
    }
    
    if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DebugPrint((SDBUS_DEBUG_IOCTL, "pdo %.08x ioctl exits %08x\n", Pdo, status));
    return status;
}




VOID
SdbusPdoIoctlCompletion (
    IN PSD_WORK_PACKET WorkPacket,
    IN NTSTATUS status
    )
{
    PIRP irp = WorkPacket->CompletionContext;

    DebugPrint((SDBUS_DEBUG_IOCTL, "pdo %08x irp %08x ioctl complete %08x\n",
                                    WorkPacket->PdoExtension->DeviceObject, irp, status));
    
    if (NT_SUCCESS(status)) {
        PULONG_PTR outputBuffer = (PULONG_PTR)irp->AssociatedIrp.SystemBuffer;
    
        // ISSUE make this so the individual worker routine can decide how big the return buffer is
        *outputBuffer = WorkPacket->Information;
        irp->IoStatus.Information = sizeof(ULONG_PTR);
    }
    
    irp->IoStatus.Status = status;
    IoCompleteRequest(irp, IO_NO_INCREMENT);
    
    ExFreePool(WorkPacket);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\enum.c ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    enum.c

Abstract:

    This module contains the bus enum code for SDBUS driver

Authors:

    Neil Sandlin (neilsa) 1-Jan-2002

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#include "pch.h"

//
// Internal References
//

NTSTATUS
SdbusCreatePdo(
    IN PDEVICE_OBJECT  Fdo,
    OUT PDEVICE_OBJECT *PdoPtr
    );

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, SdbusEnumerateDevices)
    #pragma alloc_text(PAGE, SdbusCreatePdo)
#endif



NTSTATUS
SdbusEnumerateDevices(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp
    )
/*++

Routine Description:

   This enumerates the sd bus which is represented by Fdo (a pointer to the device object representing
   the sd controller. It creates new PDOs for any new PC-Cards which have been discovered
   since the last enumeration

Notes:

Arguments:

   Fdo - Pointer to the functional device object for the SD controller which needs to be enumerated

Return value:

   None

--*/
{
    PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PPDO_EXTENSION pdoExtension = NULL;
    PDEVICE_OBJECT pdo;
    NTSTATUS       status = STATUS_SUCCESS;
    ULONG          i;
    PDEVICE_OBJECT nextPdo;
    PSD_CARD_DATA cardData;
    ULONG response;

    PAGED_CODE();

    DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x enumerate devices - %s\n", Fdo,
                                SOCKET_STATE_STRING(fdoExtension->SocketState)));

    switch(fdoExtension->SocketState) {
    
    case SOCKET_EMPTY:

        // mark pdo's removed
        for (pdo = fdoExtension->PdoList; pdo != NULL; pdo = pdoExtension->NextPdoInFdoChain) {
            pdoExtension = pdo->DeviceExtension;
            MarkDevicePhysicallyRemoved(pdoExtension);
        }

        //ISSUE: NEED TO IMPLEMENT SYNCHRONIZATION
        SdbusCleanupCardData(fdoExtension->CardData);
        fdoExtension->CardData = NULL;
        SdbusExecuteWorkSynchronous(SDWP_POWER_OFF, fdoExtension, NULL);
        (*(fdoExtension->FunctionBlock->SetFunctionType))(fdoExtension, SDBUS_FUNCTION_TYPE_MEMORY);
        break;
    
    case CARD_NEEDS_ENUMERATION:
        

        status = SdbusGetCardConfigData(fdoExtension, &cardData);
        
        //ISSUE: HACKHACK: UNIMPLEMENTED: temp code for test
        if (NT_SUCCESS(status) && fdoExtension->CardData) {
            // here we cheat, and just assume it is the same card
            // Normally we would want to compare the carddata we just
            // built with what was in the fdo extension.
            SdbusCleanupCardData(cardData);
            break;
        }
        
        if (!NT_SUCCESS(status)) {
            DebugPrint((SDBUS_DEBUG_FAIL, "fdo %08x error from GetCardConfig %08x\n", Fdo, status));
            break;
        }            
                
        if (NT_SUCCESS(status)) {
            UCHAR function;
            
            //ISSUE: would be better here to loop through the function data structures
            for (function=1; function <= fdoExtension->numFunctions; function++) {

                status = SdbusCreatePdo(fdoExtension->DeviceObject, &pdo);

                if (!NT_SUCCESS(status)) {
                   return status;
                }
                DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x created PDO %08x\n", fdoExtension->DeviceObject, pdo));
                //
                // initialize the pointers
                //
                pdoExtension = pdo->DeviceExtension;
                pdoExtension->NextPdoInFdoChain = fdoExtension->PdoList;
                fdoExtension->PdoList = pdo;
                pdoExtension->FdoExtension = fdoExtension;
                pdoExtension->Function = function;
                pdoExtension->FunctionType = SDBUS_FUNCTION_TYPE_IO;

            }

            if (fdoExtension->memFunction) {
                status = SdbusCreatePdo(fdoExtension->DeviceObject, &pdo);

                if (!NT_SUCCESS(status)) {
                   return status;
                }
                DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x created PDO %08x\n", fdoExtension->DeviceObject, pdo));
                //
                // initialize the pointers
                //
                pdoExtension = pdo->DeviceExtension;
                pdoExtension->NextPdoInFdoChain = fdoExtension->PdoList;
                fdoExtension->PdoList = pdo;
                pdoExtension->FdoExtension = fdoExtension;
                pdoExtension->Function = 8;
                pdoExtension->FunctionType = SDBUS_FUNCTION_TYPE_MEMORY;
            }

            fdoExtension->CardData = cardData;
        }
        break;

    case CARD_DETECTED:
    case CARD_ACTIVE:
    case CARD_LOGICALLY_REMOVED:
        DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x enum state %s not implemented\n", Fdo,
                                SOCKET_STATE_STRING(fdoExtension->SocketState)));
        break;

    default:
        ASSERT(FALSE);
    }        


    fdoExtension->LivePdoCount = 0;
    for (pdo = fdoExtension->PdoList; pdo != NULL; pdo = pdoExtension->NextPdoInFdoChain) {
        pdoExtension = pdo->DeviceExtension;
        if (!IsDevicePhysicallyRemoved(pdoExtension)) {
            fdoExtension->LivePdoCount++;
        }
    }

    DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x live pdo count = %d\n", Fdo, fdoExtension->LivePdoCount));

    if (fdoExtension->LivePdoCount == 0) {
        //
        // ISSUE: active power management not implemented
        // Hint for the controller to check if it should turn itself off
        //
//        SdbusFdoCheckForIdle(fdoExtension);
    }
    return status;
}



NTSTATUS
SdbusCreatePdo(
    IN PDEVICE_OBJECT Fdo,
    OUT PDEVICE_OBJECT *PdoPtr
    )
/*++

Routine Description:
    Creates and initializes a device object - which will be referred to as a Physical Device
    Object or PDO - for the PC-Card in the socket represented by Socket, hanging off the SDBUS
    controller represented by Fdo.

Arguments:

    Fdo    - Functional device object representing the SDBUS controller
    Socket - Socket in which the PC-Card for which we're creating a PDO resides
    PdoPtr - Pointer to an area of memory where the created PDO is returned

Return value:

    STATUS_SUCCESS - Pdo creation/initialization successful, PdoPtr contains the pointer
                     to the Pdo
    Any other status - creation/initialization unsuccessful

--*/
{
    ULONG pdoNameIndex = 0;
    PPDO_EXTENSION pdoExtension;
    PFDO_EXTENSION fdoExtension=Fdo->DeviceExtension;
    char deviceName[128];
    ANSI_STRING ansiName;
    UNICODE_STRING unicodeName;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Allocate space for the Unicode string:(handles upto 0xFFFF
    // devices for now :)
    //
    sprintf(deviceName, "%s-%d", "\\Device\\SdBus", 0xFFFF);
    RtlInitAnsiString(&ansiName, deviceName);
    status = RtlAnsiStringToUnicodeString(&unicodeName, &ansiName, TRUE);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Attempt to create the device with a unique name
    //
    do {
        sprintf(deviceName, "%s-%d", "\\Device\\SdBus", pdoNameIndex++);
        RtlInitAnsiString(&ansiName, deviceName);
        status = RtlAnsiStringToUnicodeString(&unicodeName, &ansiName, FALSE);

        if (!NT_SUCCESS(status)) {
            RtlFreeUnicodeString(&unicodeName);
            return status;
        }

        status = IoCreateDevice(
                               Fdo->DriverObject,
                               sizeof(PDO_EXTENSION),
                               &unicodeName,
                               FILE_DEVICE_UNKNOWN,
                               0,
                               FALSE,
                               PdoPtr
                               );
    } while ((status == STATUS_OBJECT_NAME_EXISTS) ||
             (status == STATUS_OBJECT_NAME_COLLISION));

    RtlFreeUnicodeString(&unicodeName);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Initialize the device extension for the PDO
    //
    pdoExtension = (*PdoPtr)->DeviceExtension;
    RtlZeroMemory(pdoExtension, sizeof(PDO_EXTENSION));

    pdoExtension->Signature = SDBUS_PDO_EXTENSION_SIGNATURE;
    pdoExtension->DeviceObject = *PdoPtr;

    //
    // Initialize power states
    //
    pdoExtension->SystemPowerState = PowerSystemWorking;
    pdoExtension->DevicePowerState = PowerDeviceD0;


    //
    // ISSUE: Is this still relevant?
    //
    // PNP is going to mark the PDO as a DO_BUS_ENUMERATED_DEVICE,
    // but for CardBus cards- the PDO we return is owned by PCI.
    // Hence we need to mark this device object (in that case a
    // filter on top of PCI's PDO) as PDO explicitly.
    //
//    MARK_AS_PDO(*PdoPtr);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\pcicfg.h ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    pcicfg.h

Abstract:

    Contains defines for vendor specific PCI configuration
    information

Author(s):

    Neil Sandlin (neilsa) Jan 1 2002

Revision History:

--*/

#ifndef _SD_PCICFG_H_
#define _SD_PCICFG_H_

//
// Macros for read/writing to PCI config headers
//

//
// VOID
// GetPciConfigSpace (IN PVOID  Extension,
//                    IN UCHAR  Offset,
//                    IN PUCHAR Buffer,
//                    IN ULONG  Size)
//
#define GetPciConfigSpace(Extension, Offset, Buffer, Size)    \
           (Extension)->PciBusInterface.GetBusData(           \
               (Extension)->PciBusInterface.Context,          \
               PCI_WHICHSPACE_CONFIG, Buffer, Offset, Size);


//
// VOID
// SetPciConfigSpace (IN PVOID  Extension,
//                    IN UCHAR  Offset,
//                    IN PUCHAR Buffer,
//                    IN ULONG  Size)
//
#define SetPciConfigSpace(Extension, Offset, Buffer, Size)    \
           (Extension)->PciBusInterface.SetBusData(           \
               (Extension)->PciBusInterface.Context,          \
               PCI_WHICHSPACE_CONFIG, Buffer, Offset, Size);




//ConfigSpace Registers

#define CFGSPACE_VENDOR_ID              0x00
#define CFGSPACE_DEVICE_ID              0x02
#define CFGSPACE_COMMAND                0x04
#define CFGSPACE_STATUS                 0x06
#define CFGSPACE_REV_ID                 0x08
#define CFGSPACE_CLASS_CODE             0x09
#define CFGSPACE_CLASSCODE_PI           0x09
#define CFGSPACE_CLASSCODE_SUBCLASS     0x0a
#define CFGSPACE_CLASSCODE_BASECLASS    0x0b
#define CFGSPACE_CACHE_LINESIZE         0x0c
#define CFGSPACE_LATENCY_TIMER          0x0d
#define CFGSPACE_HEADER_TYPE            0x0e
#define CFGSPACE_BIST                   0x0f
#define CFGSPACE_REGBASE_ADDR           0x10
#define CFGSPACE_CAPPTR                 0x14
#define CFGSPACE_SECOND_STATUS          0x16
#define CFGSPACE_PCI_BUSNUM             0x18
#define CFGSPACE_CARDBUS_BUSNUM         0x19
#define CFGSPACE_SUB_BUSNUM             0x1a
#define CFGSPACE_CB_LATENCY_TIMER       0x1b
#define CFGSPACE_MEMBASE_0              0x1c
#define CFGSPACE_MEMLIMIT_0             0x20
#define CFGSPACE_MEMBASE_1              0x24
#define CFGSPACE_MEMLIMIT_1             0x28
#define CFGSPACE_IOBASE_0               0x2c
#define CFGSPACE_IOLIMIT_0              0x30
#define CFGSPACE_IOBASE_1               0x34
#define CFGSPACE_IOLIMIT_1              0x38
#define CFGSPACE_INT_LINE               0x3c
#define CFGSPACE_INT_PIN                0x3d
#define CFGSPACE_BRIDGE_CTRL            0x3e
#define CFGSPACE_SUBSYS_VENDOR_ID       0x40
#define CFGSPACE_SUBSYS_ID              0x42
#define CFGSPACE_LEGACY_MODE_BASE_ADDR 0x44

//ConfigSpace registers for cardbus cards

#define CBCFG_BAR0                      0x10
#define CBCFG_BAR1                      0x14
#define CBCFG_BAR2                      0x18
#define CBCFG_BAR3                      0x1c
#define CBCFG_BAR4                      0x20
#define CBCFG_BAR5                      0x24
#define CBCFG_CISPTR                    0x28
#define CBCFG_SUBSYS_VENDOR_ID          0x2c
#define CBCFG_SUBSYS_ID                 0x2e
#define CBCFG_ROMBAR                    0x30
#define CBCFG_CAPPTR                    0x34


//Command Register bits
#define CMD_IOSPACE_ENABLE              0x0001
#define CMD_MEMSPACE_ENABLE             0x0002
#define CMD_BUSMASTER_ENABLE            0x0004
#define CMD_SPECIALCYCLE_ENABLE         0x0008
#define CMD_MEMWR_INVALIDATE_ENABLE     0x0010
#define CMD_VGA_PALETTE_SNOOP           0x0020
#define CMD_PARITY_ERROR_ENABLE         0x0040
#define CMD_WAIT_CYCLE_CTRL             0x0080
#define CMD_SYSTEM_ERROR_ENABLE         0x0100
#define CMD_FAST_BACKTOBACK_ENABLE      0x0200

//Bridge Control Register bits
#define BCTRL_PERR_RESPONSE_ENABLE      0x0001
#define BCTRL_SERR_ENABLE               0x0002
#define BCTRL_ISA_ENABLE                0x0004
#define BCTRL_VGA_ENABLE                0x0008
#define BCTRL_MASTER_ABORT_MODE         0x0020
#define BCTRL_CRST                      0x0040
#define BCTRL_IRQROUTING_ENABLE         0x0080
#define BCTRL_MEMWIN0_PREFETCH_ENABLE   0x0100
#define BCTRL_MEMWIN1_PREFETCH_ENABLE   0x0200
#define BCTRL_WRITE_POSTING_ENABLE      0x0400
#define BCTRL_CL_CSCIRQROUTING_ENABLE   0x0800

//Power Management control bits
#define PME_EN                          0x0100
#define PME_STAT                        0x8000


#endif  // _SD_PCICFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\power.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    power.h

Abstract:

    External definitions for intermodule functions.

Revision History:

--*/
#ifndef _SDBUS_POWER_H_
#define _SDBUS_POWER_H_


//
// Power management routines
//

NTSTATUS
SdbusSetFdoPowerState(
    IN PDEVICE_OBJECT Fdo,
    IN OUT PIRP Irp
    );

NTSTATUS
SdbusSetPdoPowerState(
    IN PDEVICE_OBJECT Pdo,
    IN OUT PIRP Irp
    );

VOID
SdbusPdoPowerWorkerDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
SdbusFdoPowerWorkerDpc(
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

    
#endif // _SDBUS_POWER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\pch.h ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    PCH.H

Abstract:

    This module includes all  the headers which need
    to be precompiled & are included by all the source
    files in the SD project.

Author(s):

    Neil Sandlin (neilsa) Jan 1 2002

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#ifndef _SDBUS_PCH_H_
#define _SDBUS_PCH_H_

#include "ntosp.h"
#include <zwapi.h>
#include <initguid.h>
#include "ntddsd.h"
#include "wdmguid.h"
#include <stdarg.h>
#include <stdio.h>
#include "string.h"

#include "sdbuslib.h"
#include "sdcard.h"
#include "sdbus.h"
#include "wake.h"
#include "workeng.h"
#include "workproc.h"
#include "power.h"
#include "utils.h"
#include "data.h"
#include "tuple.h"
#include "extern.h"
#include "pcicfg.h"
//#include "sdbusmc.h"
#include "debug.h"

#endif  // _SDBUS_PCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\registry.c ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    registry.c

Abstract:

    This module contains the code that manipulates the registry

Author:

    Neil Sandlin (neilsa) Jan 1 2002

Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"
                         
//
//
// Registry related definitions
//
#define SDBUS_REGISTRY_PARAMETERS_KEY              L"Sdbus\\Parameters"



#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,SdbusLoadGlobalRegistryValues)
#endif




NTSTATUS
SdbusLoadGlobalRegistryValues(
   VOID
   )
/*++

Routine Description:

   This routine is called at driver init time to load in various global
   options from the registry.
   These are read in from SYSTEM\CurrentControlSet\Services\Sdbus\Parameters.

Arguments:

   none

Return value:

   none

--*/
{
   PRTL_QUERY_REGISTRY_TABLE parms;
   NTSTATUS                  status;
   ULONG                     parmsSize;
   ULONG i;
   
   //
   // Needs a null entry to terminate the list
   //   

   parmsSize = sizeof(RTL_QUERY_REGISTRY_TABLE) * (GlobalInfoCount+1);

   parms = ExAllocatePool(PagedPool, parmsSize);

   if (!parms) {
       return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(parms, parmsSize);

   //
   // Fill in the query table from our table
   //

   for (i = 0; i < GlobalInfoCount; i++) {
      parms[i].Flags         = RTL_QUERY_REGISTRY_DIRECT;
      parms[i].Name          = GlobalRegistryInfo[i].Name;
      parms[i].EntryContext  = GlobalRegistryInfo[i].pValue;
      parms[i].DefaultType   = REG_DWORD;
      parms[i].DefaultData   = &GlobalRegistryInfo[i].Default;
      parms[i].DefaultLength = sizeof(ULONG);
   }      

   //
   // Perform the query
   //

   status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES | RTL_REGISTRY_OPTIONAL,
                                   SDBUS_REGISTRY_PARAMETERS_KEY,
                                   parms,
                                   NULL,
                                   NULL);

   if (!NT_SUCCESS(status)) {
       //
       // This is possible during text mode setup
       //
       
       for (i = 0; i < GlobalInfoCount; i++) {
          *GlobalRegistryInfo[i].pValue = GlobalRegistryInfo[i].Default;
       }      
   }
   
   ExFreePool(parms);
   
   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\pdopnp.c ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    pdopnp.c

Abstract:

    This module contains the code to handle
    the IRP_MJ_PNP dispatches for the PDOs
    enumerated by the SD bus driver


Authors:

    Neil Sandlin (neilsa) 1-Jan-2002

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#include "pch.h"

//
// Internal References
//

NTSTATUS
SdbusPdoDeviceCapabilities(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP           Irp
    );

NTSTATUS
SdbusPdoStartDevice(
    IN PDEVICE_OBJECT Pdo,
    IN PCM_RESOURCE_LIST AllocatedResources,
    IN OUT PIRP       Irp
    );

NTSTATUS
SdbusPdoStopDevice(
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
SdbusPdoRemoveDevice(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP           Irp
    );

NTSTATUS
SdbusPdoQueryId(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP           Irp
    );

NTSTATUS
SdbusPdoGetBusInformation(
    IN  PPDO_EXTENSION         PdoExtension,
    OUT PPNP_BUS_INFORMATION * BusInformation
    );

NTSTATUS
SdbusQueryDeviceText(
    IN PDEVICE_OBJECT Pdo,
    IN OUT PIRP       Irp
    );

VOID
SdbusPdoGetDeviceInfSettings(
    IN  PPDO_EXTENSION         PdoExtension
    );


#ifdef ALLOC_PRAGMA
   #pragma alloc_text(PAGE,  SdbusPdoPnpDispatch)
   #pragma alloc_text(PAGE,  SdbusPdoGetDeviceInfSettings)
   #pragma alloc_text(PAGE,  SdbusQueryDeviceText)
   #pragma alloc_text(PAGE,  SdbusPdoGetBusInformation)
   #pragma alloc_text(PAGE,  SdbusPdoStartDevice)
   #pragma alloc_text(PAGE,  SdbusPdoStopDevice)
   #pragma alloc_text(PAGE,  SdbusPdoRemoveDevice)
   #pragma alloc_text(PAGE,  SdbusPdoDeviceCapabilities)
   #pragma alloc_text(PAGE,  SdbusPdoGetDeviceInfSettings)
#endif



NTSTATUS
SdbusPdoPnpDispatch(
   IN PDEVICE_OBJECT Pdo,
   IN PIRP Irp
   )

/*++

Routine Description:

    This routine handles pnp requests
    for the PDOs.

Arguments:

    Pdo - pointer to the physical device object
    Irp - pointer to the io request packet

Return Value:

    status

--*/

{
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;

    PAGED_CODE();

#if DBG
    if (irpStack->MinorFunction > IRP_MN_PNP_MAXIMUM_FUNCTION) {
        DebugPrint((SDBUS_DEBUG_PNP, "pdo %08x irp %08x Unknown minor function %x\n",
                                      Pdo, Irp, irpStack->MinorFunction));
    } else {
        DebugPrint((SDBUS_DEBUG_PNP, "pdo %08x irp %08x --> %s\n",
                     Pdo, Irp, PNP_IRP_STRING(irpStack->MinorFunction)));
    }
#endif

    switch (irpStack->MinorFunction) {

    case IRP_MN_START_DEVICE:
        status = SdbusPdoStartDevice(Pdo, irpStack->Parameters.StartDevice.AllocatedResources, Irp);
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_STOP_DEVICE:
        status = SdbusPdoStopDevice(Pdo);
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_REMOVE_DEVICE:
        status = SdbusPdoRemoveDevice(Pdo, Irp);
        break;

    case IRP_MN_SURPRISE_REMOVAL:

//          SdbusReleaseSocketPower(pdoExtension, NULL);
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_ID:
        status = SdbusPdoQueryId(Pdo, Irp);
        break;

    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_RESOURCES:
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS: {

        PDEVICE_RELATIONS deviceRelations;

        if (irpStack->Parameters.QueryDeviceRelations.Type != TargetDeviceRelation) {
            status = Irp->IoStatus.Status;
            break;
        }

        deviceRelations = ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));
        if (deviceRelations == NULL) {

            DebugPrint((SDBUS_DEBUG_FAIL,
                       "SdbusPdoPnpDispatch:unable to allocate memory for device relations\n"));

            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        status = ObReferenceObjectByPointer(Pdo,
                                            0,
                                            NULL,
                                            KernelMode);
        if (!NT_SUCCESS(status)) {
            ExFreePool(deviceRelations);
            break;
        }

        deviceRelations->Count  = 1;
        deviceRelations->Objects[0] = Pdo;
        Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
        status = STATUS_SUCCESS;
        break;
        }

    case IRP_MN_QUERY_CAPABILITIES:
        status = SdbusPdoDeviceCapabilities(Pdo, Irp);
        break;

    case IRP_MN_QUERY_DEVICE_TEXT:

        status = SdbusQueryDeviceText(Pdo, Irp);

        if (status == STATUS_NOT_SUPPORTED ) {
           //
           // Do not change IRP status if this IRP is
           // not handled
           //
           status = Irp->IoStatus.Status;
        }
        break;

    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_BUS_INFORMATION:
        status = SdbusPdoGetBusInformation(pdoExtension,
                                           (PPNP_BUS_INFORMATION *) &Irp->IoStatus.Information);
        break;

    default:
        //
        // Retain the status
        //
        DebugPrint((SDBUS_DEBUG_PNP, "pdo %08x irp %08x Skipping unsupported irp\n", Pdo, Irp));
        status = Irp->IoStatus.Status;
        break;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    DebugPrint((SDBUS_DEBUG_PNP, "pdo %08x irp %08x comp %s %08x\n", Pdo, Irp,
                                               STATUS_STRING(status), status));
    return status;
}



NTSTATUS
SdbusPdoGetBusInformation(
   IN  PPDO_EXTENSION         PdoExtension,
   OUT PPNP_BUS_INFORMATION * BusInformation
   )

/*++

Routine Description:

  Returns the  bus type information for the pc-card.
  Bus type is GUID_BUS_TYPE_SDBUS(legacy type is SdbusBus) for R2 cards
  Bus numbers are not implemented for SDBUS, so it's always 0

Arguments:

  PdoExtension   - pointer to device extension for the pc-card

  BusInformation - pointer to the bus information structure that
                   needs to be filled in

Return value:

  Status

--*/

{
   PAGED_CODE();

   *BusInformation = ExAllocatePool(PagedPool, sizeof (PNP_BUS_INFORMATION));
   if (!*BusInformation) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlCopyMemory(&((*BusInformation)->BusTypeGuid),
                 &GUID_BUS_TYPE_SD,
                 sizeof(GUID));
   (*BusInformation)->LegacyBusType = InterfaceTypeUndefined;
   (*BusInformation)->BusNumber = 0;
   return STATUS_SUCCESS;
}



VOID
SdbusPdoGetDeviceInfSettings(
   IN  PPDO_EXTENSION PdoExtension
   )
/*++

Routine Description:

   This routine retrieves settings from the INF for this device.

Arguments:

   DeviceExtension - Device extension of the Pc-Card

Return value:

   None

--*/
{
   NTSTATUS status;
   UNICODE_STRING KeyName;
   HANDLE instanceHandle;
   UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
   PKEY_VALUE_PARTIAL_INFORMATION value = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
   ULONG length;

   PAGED_CODE();

   status = IoOpenDeviceRegistryKey(PdoExtension->DeviceObject,
                                    PLUGPLAY_REGKEY_DRIVER,
                                    KEY_READ,
                                    &instanceHandle
                                    );

   if (NT_SUCCESS(status)) {

#if 0
      //
      // Look to see if SdbusExclusiveIrq is specified
      //
      RtlInitUnicodeString(&KeyName, L"SdbusExclusiveIrq");

      status =  ZwQueryValueKey(instanceHandle,
                                &KeyName,
                                KeyValuePartialInformation,
                                value,
                                sizeof(buffer),
                                &length);


      //
      // If the key doesn't exist, or zero was specified, it means that
      // routing is ok
      //
      if (NT_SUCCESS(status) && (*(PULONG)(value->Data) != 0)) {
         SetDeviceFlag(PdoExtension, SDBUS_PDO_EXCLUSIVE_IRQ);
      }
#endif

      ZwClose(instanceHandle);
   }
}




NTSTATUS
SdbusQueryDeviceText(
   IN PDEVICE_OBJECT Pdo,
   IN OUT PIRP       Irp
   )

/*++

Routine Description:

   Returns descriptive text information about the
   PDO (location and device desc.)

Arguments:

   Pdo -    Pointer to the PC-Card's device object
   Irp -    IRP_MN_QUERY_DEVICE_TEXT Irp

Return Value:

    STATUS_SUCCESS
    STATUS_NOT_SUPPORTED - if  not supported

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
    UNICODE_STRING   unicodeString;
    ANSI_STRING      ansiString;
    UCHAR          deviceText[128];
    NTSTATUS       status;
    USHORT         deviceTextLength;

    PAGED_CODE();

    if (irpStack->Parameters.QueryDeviceText.DeviceTextType == DeviceTextDescription) {

        if (pdoExtension->FunctionType == SDBUS_FUNCTION_TYPE_IO) {
            PUCHAR mfg, prod;

            if (pdoExtension->FdoExtension->CardData->MfgText[0]) {
                mfg = pdoExtension->FdoExtension->CardData->MfgText;
            } else {
                mfg = "Generic";
            }

            if (pdoExtension->FdoExtension->CardData->ProductText[0]) {
                prod = pdoExtension->FdoExtension->CardData->ProductText;
            } else {
                prod = "SD IO Device";
            }

            sprintf(deviceText, "%s %s", mfg, prod);

        } else {
            sprintf(deviceText, "%s", "Secure Digital Storage Device");
        }

        RtlInitAnsiString(&ansiString, deviceText);

        deviceTextLength = (strlen(deviceText) + 1)*sizeof(WCHAR);
        unicodeString.Buffer = ExAllocatePool(PagedPool, deviceTextLength);
        if (unicodeString.Buffer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        unicodeString.MaximumLength = deviceTextLength;
        unicodeString.Length = 0;

        status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, FALSE);
        if (!NT_SUCCESS(status)) {
            ExFreePool(unicodeString.Buffer);
            return status;
        }

        unicodeString.Buffer[unicodeString.Length/sizeof(WCHAR)] = L'\0';
        Irp->IoStatus.Information = (ULONG_PTR) unicodeString.Buffer;
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_NOT_SUPPORTED ;
    }
    return status;
}



NTSTATUS
SdbusGenerateDeviceId(
    IN PPDO_EXTENSION PdoExtension,
    OUT PUCHAR *DeviceId
    )
/*++

    This routines generates the device id for the given SD device.

Arguments:

   Pdo            - Pointer to the physical device object for the SD device
   DeviceId       - Pointer to the string in which device id is returned

Return Value

   Status

--*/
{
    PUCHAR deviceId;

    PAGED_CODE();

    deviceId = ExAllocatePool(PagedPool, SDBUS_MAXIMUM_DEVICE_ID_LENGTH);

    if (deviceId == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (PdoExtension->FunctionType == SDBUS_FUNCTION_TYPE_IO) {
        PSD_CARD_DATA cardData = PdoExtension->FdoExtension->CardData;
        //
        // IO card
        //

        sprintf(deviceId, "%s\\VID_%04x&PID_%04x",
                      "SD",
                      cardData->MfgId,
                      cardData->MfgInfo);

    } else {
        UCHAR productName[6];
        UCHAR j;
        PSD_CARD_DATA cardData = PdoExtension->FdoExtension->CardData;
        //
        // Memory card
        //

        sprintf(deviceId, "%s\\VID_%02x&OID_%04x&PID_%s&REV_%d.%d",
                      "SD",
                      cardData->SdCid.ManufacturerId,
                      cardData->SdCid.OemId,
                      cardData->ProductName,
                      (cardData->SdCid.Revision >> 4) , (cardData->SdCid.Revision & 0xF));
    }

    *DeviceId = deviceId;
    return STATUS_SUCCESS;
}



NTSTATUS
SdbusGetHardwareIds(
    IN PPDO_EXTENSION PdoExtension,
    OUT PUNICODE_STRING HardwareIds
    )
/*++

Routine Description:

   This routine generates the hardware id's for the given sd device and returns them
   as a Unicode multi-string.

Arguments:

   Pdo - Pointer to device object representing the sd device
   HardwareIds - Pointer to the unicode string which contains the hardware id's as a multi-string

Return value:

--*/
{
    NTSTATUS status;
    PSTR     strings[4] = {NULL};
    PUCHAR   hwId;
    UCHAR    stringCount = 0;

    PAGED_CODE();

    //
    // The first hardware id is identical to the device id
    // Generate the device id
    //
    status = SdbusGenerateDeviceId(PdoExtension,
                                   &strings[stringCount++]);
    if (!NT_SUCCESS(status)) {
       return status;
    }

    try {

        //
        // Add less specific IDs
        //

        if (PdoExtension->FunctionType == SDBUS_FUNCTION_TYPE_MEMORY) {
            UCHAR productName[6];
            UCHAR j;
            PSD_CARD_DATA cardData = PdoExtension->FdoExtension->CardData;

            status = STATUS_INSUFFICIENT_RESOURCES;
            hwId = ExAllocatePool(PagedPool, SDBUS_MAXIMUM_DEVICE_ID_LENGTH);

            if (!hwId) {
               leave;
            }
            strings[stringCount++] = hwId;

            //
            // Memory card
            //

            sprintf(hwId, "%s\\VID_%02x&OID_%04x&PID_%s",
                          "SD",
                          cardData->SdCid.ManufacturerId,
                          cardData->SdCid.OemId,
                          cardData->ProductName);

        }

       status = SdbusStringsToMultiString(strings, stringCount, HardwareIds);

    } finally {

       while(stringCount != 0) {
          ExFreePool(strings[--stringCount]);
       }

    }

    return  status;
}



NTSTATUS
SdbusGetCompatibleIds(
    IN PPDO_EXTENSION PdoExtension,
    OUT PUNICODE_STRING CompatibleIds
    )
/*++

Routine Description:

   This routine generates the compatible id's for the given sd device and returns them
   as a Unicode multi-string.

Arguments:

   Pdo - Pointer to device object representing the sd device
   HardwareIds - Pointer to the unicode string which contains the hardware id's as a multi-string

Return value:

--*/
{
    NTSTATUS status;
    PSTR     strings[1] = {NULL};
    PUCHAR   compatId;
    UCHAR    stringCount = 0;

    PAGED_CODE();

    try {

        //
        // Add the class ID
        //

        status = STATUS_INSUFFICIENT_RESOURCES;
        compatId = ExAllocatePool(PagedPool, SDBUS_MAXIMUM_DEVICE_ID_LENGTH);

        if (!compatId) {
            leave;
        }
        strings[stringCount++] = compatId;

        if (PdoExtension->FunctionType == SDBUS_FUNCTION_TYPE_MEMORY) {

            sprintf(compatId, "%s\\CLASS_STORAGE", "SD");

        } else {
            PSD_CARD_DATA cardData = PdoExtension->FdoExtension->CardData;
            PSD_FUNCTION_DATA functionData;

            // find the right function data
            for (functionData = cardData->FunctionData;
                 functionData != NULL;
                 functionData = functionData->Next) {
                if (functionData->Function == PdoExtension->Function) break;
            }

            if (!functionData || (functionData->IoDeviceInterface == 0)) {
                ASSERT(functionData != NULL);
                status = STATUS_UNSUCCESSFUL;
                leave;
            }

            sprintf(compatId, "%s\\CLASS_%02x",
                          "SD",
                          functionData->IoDeviceInterface);

            DebugPrint((SDBUS_DEBUG_INFO, " %s\n", compatId));
        }

        status = SdbusStringsToMultiString(strings, stringCount, CompatibleIds);

    } finally {

        ASSERT(stringCount <= 1);
        while(stringCount != 0) {
            ExFreePool(strings[--stringCount]);
        }
    }

    return  status;
}




NTSTATUS
SdbusGetInstanceId(
    IN PPDO_EXTENSION PdoExtension,
    OUT PUNICODE_STRING InstanceId
    )
/*++

Routine Description:

   This routine generates a unique instance id  (1 upwards) for the supplied
   PC-Card which is guaranteed not to clash with any other instance ids under
   the same pcmcia controller, for the same type of card.
   A new instance id is computed only if it was not already  present for the PC-Card.

Arguments:

   Pdo - Pointer to the  device object representing the PC-Card
   InstanceId -  Pointer to a unicode string which will contain the generated
                 instance id.
                 Memory for the unicode string allocated by this routine.
                 Caller's responsibility to free it .

Return value:

   STATUS_SUCCESS
   STATUS_UNSUCCESSFUL - Currently there's a cap on the maximum value of instance id - 999999
                         This status returned only if more than 999999 PC-Cards exist under
                         this PCMCIA controller!
   Any other status - Something failed in the string allocation/conversion

--*/
{
    ULONG    instance;
    NTSTATUS status;
    ANSI_STRING sizeString;

    ASSERT(InstanceId);

    //
    // Allocate memory for the unicode string
    // Maximum of 6 digits in the instance..
    //
    RtlInitAnsiString(&sizeString, "123456");
    status = RtlAnsiStringToUnicodeString(InstanceId, &sizeString, TRUE);

    if (!NT_SUCCESS(status)) {
       return status;
    }

    status = RtlIntegerToUnicodeString(999, 10, InstanceId);

    if (!NT_SUCCESS(status)) {
       RtlFreeUnicodeString(InstanceId);
    }

    return status;
}



NTSTATUS
SdbusPdoQueryId(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP           Irp
    )
/*++

Routine Description:

   Returns descriptive text information about the
   PDO (location and device desc.)

Arguments:

   Pdo -    Pointer to the SD-Card's device object
   Irp -    IRP_MN_QUERY_DEVICE_TEXT Irp

Return Value:

    STATUS_SUCCESS
    STATUS_NOT_SUPPORTED - if  not supported

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
    UNICODE_STRING   unicodeString;
    ANSI_STRING      ansiString;
    UCHAR          deviceText[128];
    NTSTATUS       status;
    USHORT         deviceTextLength;
    UNICODE_STRING   unicodeId;
    PUCHAR      deviceId;

    PAGED_CODE();

    status = Irp->IoStatus.Status;
    RtlInitUnicodeString(&unicodeId, NULL);

    switch (irpStack->Parameters.QueryId.IdType) {

    case BusQueryDeviceID:
        DebugPrint((SDBUS_DEBUG_INFO, " Device Id for pdo %x\n", Pdo));

        status = SdbusGenerateDeviceId(pdoExtension, &deviceId);

        if (!NT_SUCCESS(status)) {
           break;
        }

        DebugPrint((SDBUS_DEBUG_INFO, "pdo %08x Device Id=%s\n", Pdo, deviceId));

        RtlInitAnsiString(&ansiString,  deviceId);

        status = RtlAnsiStringToUnicodeString(&unicodeId, &ansiString, TRUE);

        ExFreePool(deviceId);

        if (NT_SUCCESS(status)) {
           Irp->IoStatus.Information = (ULONG_PTR) unicodeId.Buffer;
        }
        break;

    case BusQueryInstanceID:
        DebugPrint((SDBUS_DEBUG_INFO, " Instance Id for pdo %x\n", Pdo));
        status = SdbusGetInstanceId(pdoExtension, &unicodeId);
        if (NT_SUCCESS(status)) {
           Irp->IoStatus.Information = (ULONG_PTR) unicodeId.Buffer;
        }
        break;

    case BusQueryHardwareIDs:
        DebugPrint((SDBUS_DEBUG_INFO, " Hardware Ids for pdo %x\n", Pdo));
        status = SdbusGetHardwareIds(pdoExtension, &unicodeId);
        if (NT_SUCCESS(status)) {
           Irp->IoStatus.Information = (ULONG_PTR) unicodeId.Buffer;
        }
        break;

    case BusQueryCompatibleIDs:
        DebugPrint((SDBUS_DEBUG_INFO, " Compatible Ids for pdo %x\n", Pdo));
        status = SdbusGetCompatibleIds(pdoExtension, &unicodeId);
        if (NT_SUCCESS(status)) {
           Irp->IoStatus.Information = (ULONG_PTR) unicodeId.Buffer;
        }
        break;
    }
    return status;
}



NTSTATUS
SdbusPdoStartDevice(
    IN PDEVICE_OBJECT Pdo,
    IN PCM_RESOURCE_LIST ResourceList,
    IN OUT PIRP       Irp
    )
/*++

Routine Description:

    This routine attempts to start the PC-Card by configuring it with the supplied resources.


Arguments:

    Pdo - Pointer to the device object representing the PC-Card which needs to be started
    ResourceList - Pointer the list of assigned resources for the PC-Card

Return value:

    STATUS_INSUFFICIENT_RESOURCES - Not sufficient resources supplied to start device/
                                    could not allocate memory
    STATUS_UNSUCCESSFUL           - Supplied resources are invalid for this PC-Card
    STATUS_SUCCESS                - Configured and started the card successfully

--*/
{
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
    PFDO_EXTENSION fdoExtension = pdoExtension->FdoExtension;
    NTSTATUS status;

    PAGED_CODE();

    if (IsDeviceStarted(pdoExtension)) {
        //
        // Already started..
        //
        return STATUS_SUCCESS;
    }

    if (IsDevicePhysicallyRemoved(pdoExtension)) {
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    status = SdbusExecuteWorkSynchronous(SDWP_INITIALIZE_FUNCTION, fdoExtension, pdoExtension);

    if (NT_SUCCESS(status)) {

        MarkDeviceStarted(pdoExtension);
        MarkDeviceLogicallyInserted(pdoExtension);
    }

    return status;
}



NTSTATUS
SdbusPdoStopDevice(
    IN PDEVICE_OBJECT Pdo
    )
/*++

Routine Description:

    This routine stops and deconfigures the given PC-Card

Arguments:

    Pdo - Pointer to the device object representing the PC-Card which needs to be stopped

Return value:

    STATUS_SUCCESS - PC-Card was already stopped, or stopped and deconfigured now successfully

--*/
{
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;

    PAGED_CODE();

    if (!IsDeviceStarted(pdoExtension)) {
       return STATUS_SUCCESS;
    }
    //
    // Need to deconfigure the controller
    //

    MarkDeviceNotStarted(pdoExtension);
    return STATUS_SUCCESS;
}



NTSTATUS
SdbusPdoRemoveDevice(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP           Irp
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
    NTSTATUS status;

    PAGED_CODE();

    SdbusPdoStopDevice(Pdo);
//   SdbusReleaseSocketPower(pdoExtension, NULL);

    if (IsDevicePhysicallyRemoved(pdoExtension)) {
        PFDO_EXTENSION fdoExtension = pdoExtension->FdoExtension;
        PDEVICE_OBJECT curPdo, prevPdo;
        PPDO_EXTENSION curPdoExt;
        ULONG waitCount = 0;

#if 0
      //
      // Synchronize with power routines
      // LATER: make these values adjustable
      //
      while(!SDBUS_TEST_AND_SET(&pdoExtension->DeletionLock)) {
         SdbusWait(1000000);
         if (waitCount++ > 20) {
            ASSERT(waitCount <= 20);
            break;
         }
      }
#endif

        //
        // Delink this Pdo from the FDO list.
        //
        for (curPdo = fdoExtension->PdoList, prevPdo = NULL; curPdo!=NULL; prevPdo = curPdo, curPdo=curPdoExt->NextPdoInFdoChain) {
           curPdoExt = curPdo->DeviceExtension;

           if (curPdo == Pdo) {
              if (prevPdo) {
                 ((PPDO_EXTENSION)prevPdo->DeviceExtension)->NextPdoInFdoChain = pdoExtension->NextPdoInFdoChain;
              } else {
                 fdoExtension->PdoList = pdoExtension->NextPdoInFdoChain;
              }
              break;

           }
        }

        SdbusCleanupPdo(Pdo);
        //
        // Delete..
        //
        if (!IsDeviceDeleted(pdoExtension)) {
           MarkDeviceDeleted(pdoExtension);
           IoDeleteDevice(Pdo);
        }

    } else {
        //
        // We will keep this Pdo around, since this is not physically ejected.
        //
        MarkDeviceLogicallyRemoved(pdoExtension);
    }

    return STATUS_SUCCESS;
}


VOID
SdbusCleanupPdo(
    IN PDEVICE_OBJECT Pdo
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;

    // currently nothing to do
}



NTSTATUS
SdbusPdoDeviceCapabilities(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP           Irp
    )
/*++

Routine Description:

    Obtains the device capabilities of the given SD device.

Arguments:

    Pdo   -    Pointer to the device object for the pc-card
    Irp   -    Pointer to the query device capabilities Irp

Return Value:

    STATUS_SUCCESS                   - Capabilities obtained and recorded in the passed in pointer
    STATUS_INSUFFICIENT_RESOURCES    - Could not allocate memory to cache the capabilities

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_CAPABILITIES capabilities = irpStack->Parameters.DeviceCapabilities.Capabilities;
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
    PDEVICE_CAPABILITIES busCapabilities = &pdoExtension->FdoExtension->DeviceCapabilities;

    PAGED_CODE();

    //
    // R2 card. Fill in the capabilities ourselves..
    //

    capabilities->Removable = TRUE;
    capabilities->UniqueID = FALSE;
    capabilities->EjectSupported = FALSE;

//    capabilities->Address = pdoExtension->Socket->RegisterOffset;
    capabilities->Address = 0;
    // Don't know the UINumber, just leave it alone


    if (busCapabilities->DeviceState[PowerSystemWorking] != PowerDeviceUnspecified) {
        capabilities->DeviceState[PowerSystemWorking] = busCapabilities->DeviceState[PowerSystemWorking];
        capabilities->DeviceState[PowerSystemSleeping1] = busCapabilities->DeviceState[PowerSystemSleeping1];
        capabilities->DeviceState[PowerSystemSleeping2] = busCapabilities->DeviceState[PowerSystemSleeping2];
        capabilities->DeviceState[PowerSystemSleeping3] = busCapabilities->DeviceState[PowerSystemSleeping3];
        capabilities->DeviceState[PowerSystemHibernate] = busCapabilities->DeviceState[PowerSystemHibernate];
        capabilities->DeviceState[PowerSystemShutdown] = busCapabilities->DeviceState[PowerSystemShutdown];

        capabilities->SystemWake = MIN(PowerSystemSleeping3, busCapabilities->SystemWake);
        capabilities->DeviceWake = PowerDeviceD0; // don't rely on FDO mungeing in the right thing for r2 cards
        capabilities->D1Latency = busCapabilities->D1Latency;
        capabilities->D2Latency = busCapabilities->D2Latency;
        capabilities->D3Latency = busCapabilities->D3Latency;
    } else {
        capabilities->DeviceState[PowerSystemWorking]   = PowerDeviceD0;
        capabilities->DeviceState[PowerSystemSleeping1] = PowerDeviceD3;
        capabilities->DeviceState[PowerSystemSleeping2] = PowerDeviceD3;
        capabilities->DeviceState[PowerSystemSleeping3] = PowerDeviceD3;
        capabilities->DeviceState[PowerSystemHibernate] = PowerDeviceD3;
        capabilities->DeviceState[PowerSystemShutdown] = PowerDeviceD3;

        capabilities->SystemWake = PowerSystemUnspecified;
        capabili